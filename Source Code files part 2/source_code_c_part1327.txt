SERT(pCommOutput->cbData <= pCommOutput->cbBuffer);

    SP_RETURN(PCT_ERR_OK);
}


void
SetTls1Alert(
    PSPContext  pContext,
    BYTE        bAlertLevel,
    BYTE        bAlertNumber)
{
    pContext->State        = TLS1_STATE_ERROR;
    pContext->bAlertLevel  = bAlertLevel;
    pContext->bAlertNumber = bAlertNumber;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\spbase\ssl2srv.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ssl2srv.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-08-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <ssl2msg.h>
#include <ssl2prot.h>



SP_STATUS Ssl2SrvGenerateServerFinish(PSPContext pContext,
                              PSPBuffer  pCommOutput);

SP_STATUS Ssl2SrvGenerateServerVerify(PSPContext pContext,
                              PSPBuffer  pCommOutput);

SP_STATUS Ssl2SrvVerifyClientFinishMsg(PSPContext pContext,
                              PSPBuffer  pCommInput);

#define SSL_OFFSET_OF(t, v) ((DWORD)(ULONG_PTR)&(((t)NULL)->v))


#define SSL2_CERT_TYPE_FROM_CAPI(s) X509_ASN_ENCODING


SP_STATUS WINAPI
Ssl2ServerProtocolHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pCommOutput)
{
    SP_STATUS pctRet = 0;
    DWORD cMessageType;

    DWORD dwStateTransition;
    BOOL fRaw = TRUE;
    SPBuffer MsgInput;
    DWORD cbMsg;
    PUCHAR pb;
    UCHAR bCT;

    if (NULL != pCommOutput)
    {
        pCommOutput->cbData = 0;
    }

    MsgInput.pvBuffer = pCommInput->pvBuffer;
    MsgInput.cbBuffer = pCommInput->cbBuffer;
    MsgInput.cbData   = pCommInput->cbData;

    // In the following states, we should decrypt the message:


    switch(pContext->State)
    {
        case SSL2_STATE_SERVER_VERIFY:
        case SSL2_STATE_SERVER_RESTART:
            pctRet = Ssl2DecryptMessage(pContext, pCommInput, &MsgInput);
            cMessageType = ((PUCHAR) MsgInput.pvBuffer)[0];
            fRaw = FALSE;
            break;

        case SP_STATE_SHUTDOWN:
        case SP_STATE_SHUTDOWN_PENDING:
            cMessageType = 0;
            break;

        case SP_STATE_CONNECTED:
            // The server has attempted to initiate a reconnect.
            return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);

        default:
            if(pCommInput->cbData < 3)
            {
                return SP_LOG_RESULT(PCT_INT_INCOMPLETE_MSG);
            }
            cMessageType = ((PUCHAR) MsgInput.pvBuffer)[2];
            break;

    }


    if (pctRet != PCT_ERR_OK)
    {
        // to handle incomplete message errors
        return(pctRet);
    }

    dwStateTransition = pContext->State | (cMessageType<<16);




    switch(dwStateTransition)
    {
        case SP_STATE_SHUTDOWN_PENDING:
            // There's no CloseNotify in SSL2, so just transition to
            // the shutdown state and leave the output buffer empty.
            pContext->State = SP_STATE_SHUTDOWN;
            break;

        case SP_STATE_SHUTDOWN:
            return PCT_INT_EXPIRED;

        /* Server receives client hello */
        case (SSL2_MT_CLIENT_HELLO << 16) | SP_STATE_NONE:
        {
            PSsl2_Client_Hello pSsl2Hello;

            // Attempt to recognize and handle various versions of client
            // hello, start by trying to unpickle the most recent version, and
            // then next most recent, until one unpickles.  Then run the handle
            // code.  We can also put unpickling and handling code in here for
            // SSL messages.

            pctRet = Ssl2UnpackClientHello(pCommInput, &pSsl2Hello);

            if (PCT_ERR_OK == pctRet)
            {

                if (((pContext->Flags & CONTEXT_FLAG_NOCACHE) == 0) &&
                    (pSsl2Hello->cbSessionID) &&
                    (SPCacheRetrieveBySession(pContext,
                                              pSsl2Hello->SessionID,
                                              pSsl2Hello->cbSessionID,
                                              &pContext->RipeZombie)))

                {
                    DebugLog((DEB_TRACE, "Accept client's reconnect request.\n"));

                    pctRet = Ssl2SrvGenRestart(pContext,
                                               pSsl2Hello,
                                               pCommOutput);
                    if (PCT_ERR_OK == pctRet)
                    {
                        pContext->State = SSL2_STATE_SERVER_VERIFY;
                    }
                }
                else
                {
                    // We're doing a full handshake, so allocate a cache entry.

                    if(!SPCacheRetrieveNew(TRUE,
                                           pContext->pszTarget, 
                                           &pContext->RipeZombie))
                    {
                        pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
                    }
                    else
                    {
                        pContext->RipeZombie->fProtocol      = pContext->dwProtocol;
                        pContext->RipeZombie->dwCF           = pContext->dwRequestedCF;
                        pContext->RipeZombie->pServerCred    = pContext->pCredGroup;

                        pctRet = Ssl2SrvHandleClientHello(pContext,
                                                          pCommInput,
                                                          pSsl2Hello,
                                                          pCommOutput);
                        if (PCT_ERR_OK == pctRet)
                        {
                            pContext->State = SSL2_STATE_SERVER_HELLO;
                        }
                    }
                }
                SPExternalFree(pSsl2Hello);

            }
            else if(pctRet != PCT_INT_INCOMPLETE_MSG)
            {
                pctRet |= PCT_INT_DROP_CONNECTION;
            }


            if (SP_FATAL(pctRet))
            {
                pContext->State = PCT1_STATE_ERROR;
            }
            break;
        }

        case (SSL2_MT_CLIENT_MASTER_KEY << 16) | SSL2_STATE_SERVER_HELLO:

            pctRet = Ssl2SrvHandleCMKey(pContext, pCommInput, pCommOutput);
            if (SP_FATAL(pctRet))
            {
                pContext->State = PCT1_STATE_ERROR;
            }
            else
            {
                if (PCT_ERR_OK == pctRet)
                {
                    pContext->State = SSL2_STATE_SERVER_VERIFY;
                }
                // We received a non-fatal error, so the state doesn't change,
                // giving the app time to deal with this.
            }
            break;

        case (SSL2_MT_CLIENT_FINISHED_V2 << 16) | SSL2_STATE_SERVER_VERIFY:
            pctRet = Ssl2SrvHandleClientFinish(
                                                pContext,
                                                &MsgInput,
                                                pCommOutput);
            if (SP_FATAL(pctRet))
            {
                pContext->State = PCT1_STATE_ERROR;
            }
            else
            {
            if (PCT_ERR_OK == pctRet)
            {
                pContext->State = SP_STATE_CONNECTED;
                pContext->DecryptHandler = Ssl2DecryptHandler;
                pContext->Encrypt = Ssl2EncryptMessage;
                pContext->Decrypt = Ssl2DecryptMessage;
                pContext->GetHeaderSize = Ssl2GetHeaderSize;

            }
            // We received a non-fatal error, so the state doesn't change,
            // giving the app time to deal with this.
            }
            break;

        default:
            DebugLog((DEB_WARN, "Error in protocol, dwStateTransition is %lx\n", dwStateTransition));
            pContext->State = PCT1_STATE_ERROR;
            pctRet = SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
            break;
    }

    if (pctRet & PCT_INT_DROP_CONNECTION)
    {
        pContext->State &= ~SP_STATE_CONNECTED;
    }

    return(pctRet);
}



SP_STATUS
Ssl2SrvHandleClientHello(
    PSPContext         pContext,
    PSPBuffer           pCommInput,
    PSsl2_Client_Hello  pHello,
    PSPBuffer           pCommOutput)
{
    SP_STATUS pctRet = PCT_ERR_ILLEGAL_MESSAGE;
    PSPCredential  pCred;
    Ssl2_Server_Hello    Reply;
    DWORD           cCommonCiphers;
    DWORD           CommonCiphers[MAX_UNI_CIPHERS];
    PSessCacheItem  pZombie;
    BOOL            fFound;
    DWORD           i,j;

    SP_BEGIN("Ssl2SrvHandleClientHello");

    pCommOutput->cbData = 0;

    /* validate the buffer configuration */

    if(NULL == pContext)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }
    pZombie = pContext->RipeZombie;

    // See if we have a cert that supports ssl2
    pctRet = SPPickServerCertificate(pContext, SP_EXCH_RSA_PKCS1);
    if(PCT_ERR_OK != pctRet)
    {
        SP_RETURN(pctRet | PCT_INT_DROP_CONNECTION);
    }

    pCred   = pZombie->pActiveServerCred;
    if (!pCred)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    do {

        ZeroMemory(&Reply, sizeof(Reply));

        //
        // Calculate common ciphers:
        //

        cCommonCiphers = 0;

        for(i = 0; i < UniNumCiphers; i++)
        {
            PCipherInfo      pCipherInfo;
            PHashInfo        pHashInfo;
            PKeyExchangeInfo pExchInfo;

            // Is this an SSL2 cipher suite?
            if(!(UniAvailableCiphers[i].fProt & pContext->RipeZombie->fProtocol))
            {
                continue;
            }

            pCipherInfo = GetCipherInfo(UniAvailableCiphers[i].aiCipher,
                                        UniAvailableCiphers[i].dwStrength);
            if(NULL == pCipherInfo)
            {
                continue;
            }

            if(!IsCipherSuiteAllowed(pContext,
                                     pCipherInfo,
                                     pZombie->fProtocol,
                                     pZombie->dwCF,
                                     UniAvailableCiphers[i].dwFlags))
            {
                continue;
            }

            pHashInfo = GetHashInfo(UniAvailableCiphers[i].aiHash);
            if(NULL == pHashInfo)
            {
                continue;
            }

            if(!IsHashAllowed(pContext, pHashInfo, pZombie->fProtocol))
            {
                continue;
            }

            pExchInfo = GetKeyExchangeInfo(UniAvailableCiphers[i].KeyExch);
            if(NULL == pExchInfo)
            {
                continue;
            }
            if(!IsExchAllowed(pContext, pExchInfo, pZombie->fProtocol))
            {
                continue;
            }


            // Is this cipher suite supported by the client?
            for(fFound = FALSE, j = 0; j < pHello->cCipherSpecs; j++)
            {
                if(UniAvailableCiphers[i].CipherKind == pHello->CipherSpecs[j])
                {
                    fFound = TRUE;
                    break;
                }
            }
            if(!fFound)
            {
                continue;
            }

            // Does the CSP support this cipher suite?
            if(!IsAlgSupportedCapi(pContext->RipeZombie->fProtocol,
                                   UniAvailableCiphers + i,
                                   pCred->pCapiAlgs,
                                   pCred->cCapiAlgs))
            {
                continue;
            }

            // Add this cipher to list.
            CommonCiphers[cCommonCiphers++] = UniAvailableCiphers[i].CipherKind;
        }

        //
        // if cCommonCipers == 0, then we have none in common.  At this point, we
        // should generate an error response, but that is for later.  For now,
        // we will generate an invalid_token return, and bail out.
        //

        if (cCommonCiphers == 0)
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
            LogCipherMismatchEvent();
            break;
        }


        Reply.cCipherSpecs = cCommonCiphers;
        Reply.pCipherSpecs = CommonCiphers;
        Reply.SessionIdHit = 0;

        Reply.CertificateType =   SSL2_CERT_TYPE_FROM_CAPI(pCred->pCert->dwCertEncodingType);

        // Auto allocate the certificate.  !We must free them when we're done....
        Reply.pCertificate = NULL;
        Reply.cbCertificate = 0;
        pctRet = SPSerializeCertificate(SP_PROT_SSL2,
                                        FALSE,
                                        &Reply.pCertificate,
                                        &Reply.cbCertificate,
                                        pCred->pCert,
                                        0);

        if (PCT_ERR_OK != pctRet)
        {
            break;
        }



        /* Generate a conneciton id to use while establishing connection */

        Reply.cbConnectionID = SSL2_GEN_CONNECTION_ID_LEN;
        GenerateRandomBits(  Reply.ConnectionID,
                             Reply.cbConnectionID );

        CopyMemory(pContext->pConnectionID,
                   Reply.ConnectionID,
                   Reply.cbConnectionID);
        pContext->cbConnectionID = Reply.cbConnectionID;


        /* keep challenge around for later */
        CopyMemory( pContext->pChallenge,
                    pHello->Challenge,
                    pHello->cbChallenge);
        pContext->cbChallenge = pHello->cbChallenge;



        pctRet = Ssl2PackServerHello(&Reply, pCommOutput);

        if(Reply.pCertificate)
        {
            SPExternalFree(Reply.pCertificate);
        }

        if (PCT_ERR_OK != pctRet)
        {
            break;
        }
        pContext->WriteCounter = 1;  /* received client hello */
        pContext->ReadCounter = 1;   /* Sending server hello */


        SP_RETURN(PCT_ERR_OK);
    } while (TRUE); /* end Polish Loop */

    if((pContext->Flags & CONTEXT_FLAG_EXT_ERR) &&
        (pctRet == PCT_ERR_SPECS_MISMATCH))
    {
        // Our SSL2 implementation does not do client auth,
        // so there is only one error message, cipher error.
        pCommOutput->cbData = 3; // MSG-ERROR + ERROR-CODE-MSB + ERROR-CODE-LSB

        if(pCommOutput->pvBuffer == NULL)
        {
            pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
            if (NULL == pCommOutput->pvBuffer)
            {
                SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
            }
            pCommOutput->cbBuffer = pCommOutput->cbData;
        }
        if(pCommOutput->cbData > pCommOutput->cbBuffer)
        {
            // Required buffer size returned in pCommOutput->cbData.
            SP_RETURN(SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL));
        }

        ((PUCHAR)pCommOutput->pvBuffer)[0] = SSL2_MT_ERROR;
        ((PUCHAR)pCommOutput->pvBuffer)[1] = MSBOF(SSL_PE_NO_CIPHER);
        ((PUCHAR)pCommOutput->pvBuffer)[2] = LSBOF(SSL_PE_NO_CIPHER);

    }
    SP_RETURN(pctRet | PCT_INT_DROP_CONNECTION);
}



 SP_STATUS
 Ssl2SrvGenRestart(
    PSPContext         pContext,
    PSsl2_Client_Hello  pHello,
    PSPBuffer           pCommOutput)
{
    SP_STATUS pctRet = PCT_ERR_ILLEGAL_MESSAGE;
    SPBuffer SecondOutput;
    Ssl2_Server_Hello    Reply;
    DWORD cbMessage, cbMsg, cPadding;
    PSessCacheItem  pZombie;

    SP_BEGIN("Ssl2SrvGenRestart");

    pCommOutput->cbData = 0;

    /* validate the buffer configuration */

    /* make sure we have the needed authentication data area */
    if (NULL == pContext)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }
    pZombie = pContext->RipeZombie;




    do {

        FillMemory( &Reply, sizeof( Reply ), 0 );

        Reply.SessionIdHit = (DWORD)1;
        Reply.cCipherSpecs = 0;
        Reply.pCipherSpecs = NULL;
        Reply.pCertificate = NULL;
        Reply.cbCertificate = 0;
        Reply.CertificateType = 0;

        /* Note, we generate both a server hello, and a server verify in
         * this handling routing.  This is because netscape will not send
         * us a client finish until the server verify is received
         */


        // Load pending ciphers from cache
        pctRet = ContextInitCiphersFromCache(pContext);

        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        pctRet = ContextInitCiphers(pContext, TRUE, TRUE);

        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        Reply.cbConnectionID = SSL2_GEN_CONNECTION_ID_LEN;
        GenerateRandomBits(  Reply.ConnectionID,
                             Reply.cbConnectionID );

        CopyMemory(pContext->pConnectionID,
                   Reply.ConnectionID,
                   Reply.cbConnectionID);
        pContext->cbConnectionID = Reply.cbConnectionID;


        /* keep challenge around for later */
        CopyMemory( pContext->pChallenge,
                    pHello->Challenge,
                    pHello->cbChallenge);
        pContext->cbChallenge = pHello->cbChallenge;


        // Make a new set of session keys.
        pctRet = MakeSessionKeys(pContext,
                                 pContext->RipeZombie->hMasterProv,
                                 pContext->RipeZombie->hMasterKey);
        if(pctRet != PCT_ERR_OK)
        {
            break;
        }

        // Activate session keys.
        pContext->hReadKey          = pContext->hPendingReadKey;
        pContext->hWriteKey         = pContext->hPendingWriteKey;
        pContext->hPendingReadKey   = 0;
        pContext->hPendingWriteKey  = 0;


        /* calc size of the server hello (restart only) */
        cbMessage = Reply.cbConnectionID +
                        Reply.cbCertificate +
                        Reply.cCipherSpecs * sizeof(Ssl2_Cipher_Tuple) +
                        SSL_OFFSET_OF(PSSL2_SERVER_HELLO, VariantData) -
                        sizeof(SSL2_MESSAGE_HEADER);

        pCommOutput->cbData = cbMessage + 2;

        /* calc size of server verify */
        cbMsg  = sizeof(UCHAR) + pContext->cbChallenge;

        cPadding = ((cbMsg+pContext->pHashInfo->cbCheckSum) % pContext->pCipherInfo->dwBlockSize);
        if(cPadding)
        {
            cPadding = pContext->pCipherInfo->dwBlockSize - cPadding;
        }

        pCommOutput->cbData += cbMsg +
                              pContext->pHashInfo->cbCheckSum +
                              cPadding +
                              (cPadding?3:2);


        /* are we allocating our own memory? */
        if(pCommOutput->pvBuffer == NULL) {
            pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
            if (NULL == pCommOutput->pvBuffer)
                SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
            pCommOutput->cbBuffer = pCommOutput->cbData;
        }

        if(pCommOutput->cbData > pCommOutput->cbBuffer)
        {
            // Required buffer size returned in pCommOutput->cbData.
            SP_RETURN(PCT_INT_BUFF_TOO_SMALL);
        }


        pctRet = Ssl2PackServerHello(&Reply, pCommOutput);
        if (PCT_ERR_OK != pctRet)
        {
            break;
        }
        pContext->WriteCounter = 1;  /* received client hello */
        pContext->ReadCounter = 1;   /* Sending server hello */

        /* Now pack the server verify message and encrypt it */
        SecondOutput.pvBuffer = (PUCHAR)pCommOutput->pvBuffer+pCommOutput->cbData;
        SecondOutput.cbBuffer = pCommOutput->cbBuffer-pCommOutput->cbData;


        pctRet = Ssl2SrvGenerateServerVerify(pContext, &SecondOutput);
        if (PCT_ERR_OK != pctRet)
        {
            break;
        }
        pCommOutput->cbData += SecondOutput.cbData;

        SP_RETURN(PCT_ERR_OK);
    } while (TRUE); /* end Polish Loop */
    SP_RETURN(pctRet | PCT_INT_DROP_CONNECTION);
}



SP_STATUS
Ssl2SrvHandleCMKey(
    PSPContext pContext,
    PSPBuffer   pCommInput,
    PSPBuffer   pCommOutput)
{
    SP_STATUS          pctRet = PCT_ERR_ILLEGAL_MESSAGE;
    PSsl2_Client_Master_Key  pMasterKey = NULL;
    DWORD               dwKeyLen;
    DWORD               EncryptedLen;
    DWORD               i;

    DWORD               cbData;
    PSessCacheItem      pZombie;

    SP_BEGIN("Ssl2SrvHandleCMKey");

    pCommOutput->cbData = 0;

    pZombie = pContext->RipeZombie;

    do {

        /* make sure we have the needed authentication data area */

        cbData = pCommInput->cbData;
        pctRet = Ssl2UnpackClientMasterKey(pCommInput, &pMasterKey);


        if (PCT_ERR_OK != pctRet)
        {
            // If it's an incomplete message or something, just return;
            if(!SP_FATAL(pctRet))
            {
                SP_RETURN(pctRet);
            }
            break;
        }

        pctRet = PCT_ERR_ILLEGAL_MESSAGE;


        /* CMK sent cleartext, so we must auto-inc the read counter */
        pContext->ReadCounter++;

        pContext->pCipherInfo = NULL;
        pContext->pHashInfo = NULL;
        pContext->pKeyExchInfo = NULL;

        // Pick a cipher suite

        pctRet = PCT_ERR_SPECS_MISMATCH;
        for(i = 0; i < UniNumCiphers; i++)
        {
            // Is this an SSL2 cipher suite?
            if(!(UniAvailableCiphers[i].fProt & pContext->RipeZombie->fProtocol))
            {
                continue;
            }

            if(UniAvailableCiphers[i].CipherKind != pMasterKey->CipherKind)
            {
                continue;
            }


            pZombie->aiCipher     = UniAvailableCiphers[i].aiCipher;
            pZombie->dwStrength   = UniAvailableCiphers[i].dwStrength;
            pZombie->aiHash       = UniAvailableCiphers[i].aiHash;
            pZombie->SessExchSpec = UniAvailableCiphers[i].KeyExch;

            pctRet = ContextInitCiphersFromCache(pContext);

            if(pctRet != PCT_ERR_OK)
            {
                continue;
            }
            break;
        }

        pctRet = ContextInitCiphers(pContext, TRUE, TRUE);
        if(pctRet != PCT_ERR_OK)
        {
            SP_LOG_RESULT(pctRet);
            break;

        }


        /* Copy over the key args */
        CopyMemory( pZombie->pKeyArgs,
                    pMasterKey->KeyArg,
                    pMasterKey->KeyArgLen );
        pZombie->cbKeyArgs = pMasterKey->KeyArgLen;


        // Store the clear key in the context structure.
        CopyMemory( pZombie->pClearKey,
                    pMasterKey->ClearKey,
                    pMasterKey->ClearKeyLen);
        pZombie->cbClearKey = pMasterKey->ClearKeyLen;


        /* Decrypt the encrypted portion of the master key */
        pctRet = pContext->pKeyExchInfo->System->GenerateServerMasterKey(
                    pContext,
                    pMasterKey->ClearKey,
                    pMasterKey->ClearKeyLen,
                    pMasterKey->pbEncryptedKey,
                    pMasterKey->EncryptedKeyLen);
        if(PCT_ERR_OK != pctRet)
        {
            break;
        }


        SPExternalFree( pMasterKey );
        pMasterKey = NULL;

        // Update keys.
        pContext->hReadKey  = pContext->hPendingReadKey;
        pContext->hWriteKey = pContext->hPendingWriteKey;
        pContext->hPendingReadKey   = 0;
        pContext->hPendingWriteKey  = 0;


        pctRet = Ssl2SrvGenerateServerVerify(pContext, pCommOutput);
        SP_RETURN(pctRet);

    } while(TRUE);

    if (pMasterKey)
    {
        SPExternalFree( pMasterKey );
    }
    if((pContext->Flags & CONTEXT_FLAG_EXT_ERR) &&
        (pctRet == PCT_ERR_SPECS_MISMATCH))
    {
        // Our SSL2 implementation does not do client auth,
        // so there is only one error message, cipher error.
        pCommOutput->cbData = 3; // MSG-ERROR + ERROR-CODE-MSB + ERROR-CODE-LSB

        /* are we allocating our own memory? */
        if(pCommOutput->pvBuffer == NULL)
        {
            pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);

            if (NULL == pCommOutput->pvBuffer)
            {
                SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
            }
            pCommOutput->cbBuffer = pCommOutput->cbData;
        }
        if(pCommOutput->cbData <= pCommOutput->cbBuffer)
        {
            ((PUCHAR)pCommOutput->pvBuffer)[0] = SSL2_MT_ERROR;
            ((PUCHAR)pCommOutput->pvBuffer)[1] = MSBOF(SSL_PE_NO_CIPHER);
            ((PUCHAR)pCommOutput->pvBuffer)[2] = LSBOF(SSL_PE_NO_CIPHER);
        }
        else
        {
            pCommOutput->cbData = 0;
        }

    }
    SP_RETURN((PCT_INT_DROP_CONNECTION | pctRet));
}



SP_STATUS
Ssl2SrvVerifyClientFinishMsg(
    PSPContext pContext,
    PSPBuffer  pCommInput)
{
    SP_STATUS     pctRet = PCT_ERR_ILLEGAL_MESSAGE;
    PSSL2_CLIENT_FINISHED pFinished;

    SP_BEGIN("Ssl2SrvVerifyClientFinishMsg");


    /* Note, there is no header in this message, as it has been pre-decrypted */
    if (pCommInput->cbData != sizeof(UCHAR) + pContext->cbConnectionID)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG));
    }
    pFinished = pCommInput->pvBuffer;
    if (pFinished->MessageId != SSL2_MT_CLIENT_FINISHED_V2)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG));
    }

    if ( memcmp(pFinished->ConnectionID,
            pContext->pConnectionID,
            pContext->cbConnectionID))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG));
    }
    SP_RETURN(PCT_ERR_OK);

}

SP_STATUS
Ssl2SrvGenerateServerVerify(
    PSPContext pContext,
    PSPBuffer   pCommOutput)
{
    SP_STATUS     pctRet = PCT_ERR_ILLEGAL_MESSAGE;
    PSSL2_SERVER_VERIFY     pVerify;
    DWORD                   HeaderSize;
    SPBuffer                MsgOutput;
    DWORD                   cPadding;
    BOOL                    fAlloced = FALSE;

    pCommOutput->cbData = 0;

    SP_BEGIN("Ssl2SrvGenerateServerVerify");

    do {

        MsgOutput.cbData = sizeof(UCHAR) + pContext->cbChallenge;
        cPadding = ((MsgOutput.cbData+pContext->pHashInfo->cbCheckSum) % pContext->pCipherInfo->dwBlockSize);
        if(cPadding)
        {
            cPadding = pContext->pCipherInfo->dwBlockSize - cPadding;
        }

        HeaderSize = (cPadding?3:2);

        pCommOutput->cbData = MsgOutput.cbData +
                              pContext->pHashInfo->cbCheckSum +
                              cPadding + HeaderSize;


        /* are we allocating our own memory? */
        if (pCommOutput->pvBuffer == NULL) {
            pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
            if (NULL == pCommOutput->pvBuffer)
            {
                SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
            }
            fAlloced = TRUE;
            pCommOutput->cbBuffer = pCommOutput->cbData;
        }

        MsgOutput.pvBuffer= (PUCHAR)pCommOutput->pvBuffer +
                             HeaderSize+pContext->pHashInfo->cbCheckSum;

        MsgOutput.cbBuffer=  pCommOutput->cbBuffer -
                             HeaderSize-pContext->pHashInfo->cbCheckSum;


        pVerify = (PSSL2_SERVER_VERIFY) MsgOutput.pvBuffer;
        pVerify->MessageId = SSL2_MT_SERVER_VERIFY;


        CopyMemory( pVerify->ChallengeData,
                pContext->pChallenge,
                pContext->cbChallenge );


        pctRet = Ssl2EncryptMessage( pContext, &MsgOutput, pCommOutput);
        if(PCT_ERR_OK != pctRet)
        {
            break;
        }
        SP_RETURN(PCT_ERR_OK);

    } while(TRUE);

    if(fAlloced && (NULL != pCommOutput->pvBuffer))
    {
        SPExternalFree(pCommOutput->pvBuffer);
        pCommOutput->cbBuffer = 0;
        pCommOutput->cbData = 0;
        pCommOutput->pvBuffer = NULL;

    }
    SP_RETURN(PCT_INT_DROP_CONNECTION | pctRet);
}

SP_STATUS
Ssl2SrvGenerateServerFinish(
    PSPContext pContext,
    PSPBuffer   pCommOutput)
{
    SP_STATUS     pctRet = PCT_ERR_ILLEGAL_MESSAGE;
    PSSL2_SERVER_FINISHED pFinish;
    DWORD                   HeaderSize;
    SPBuffer                MsgOutput;
    DWORD                   cPadding;
    BOOL                    fAlloced = FALSE;
    pCommOutput->cbData = 0;
    SP_BEGIN("Ssl2SrvGenerateServerFinish");

    do {

        /* Generate a session id to use during the session */
        pContext->RipeZombie->cbSessionID = SSL2_SESSION_ID_LEN;

        /* store this context in the cache */
        /* note - we don't check error 'cause it's recoverable
         * if we don't cache */

        SPCacheAdd(pContext);

        MsgOutput.cbData = sizeof(UCHAR) + pContext->RipeZombie->cbSessionID;
        cPadding = ((MsgOutput.cbData+pContext->pHashInfo->cbCheckSum) % pContext->pCipherInfo->dwBlockSize);
        if(cPadding)
        {
            cPadding = pContext->pCipherInfo->dwBlockSize - cPadding;
        }

        HeaderSize = (cPadding?3:2);

        pCommOutput->cbData = MsgOutput.cbData +
                              pContext->pHashInfo->cbCheckSum +
                              cPadding +
                              HeaderSize;

        /* are we allocating our own memory? */
        if(pCommOutput->pvBuffer == NULL)
        {
            pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
            if (NULL == pCommOutput->pvBuffer)
            {
                SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
            }
            fAlloced = TRUE;

            pCommOutput->cbBuffer = pCommOutput->cbData;
        }
        if(pCommOutput->cbData > pCommOutput->cbBuffer)
        {
            // Required buffer size returned in pCommOutput->cbData.
            SP_RETURN(SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL));
        }

        MsgOutput.pvBuffer= (PUCHAR)pCommOutput->pvBuffer + HeaderSize+pContext->pHashInfo->cbCheckSum;
        MsgOutput.cbBuffer=  pCommOutput->cbBuffer-HeaderSize-pContext->pHashInfo->cbCheckSum;


        pFinish = (PSSL2_SERVER_FINISHED) MsgOutput.pvBuffer;
        pFinish->MessageId = SSL2_MT_SERVER_FINISHED_V2;


        CopyMemory( pFinish->SessionID,
                pContext->RipeZombie->SessionID,
                pContext->RipeZombie->cbSessionID );

        /* Cache Context Here */

        pctRet = Ssl2EncryptMessage( pContext, &MsgOutput, pCommOutput);
        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        SP_RETURN(PCT_ERR_OK);

    } while(TRUE);
    if(fAlloced && (NULL != pCommOutput->pvBuffer))
    {
        SPExternalFree(pCommOutput->pvBuffer);
        pCommOutput->cbBuffer = 0;
        pCommOutput->cbData = 0;
        pCommOutput->pvBuffer = NULL;

    }
    SP_RETURN(PCT_INT_DROP_CONNECTION | pctRet);

 }

SP_STATUS
Ssl2SrvHandleClientFinish(
    PSPContext pContext,
    PSPBuffer   pCommInput,
    PSPBuffer   pCommOutput)
{
    SP_STATUS     pctRet = PCT_ERR_ILLEGAL_MESSAGE;

    SP_BEGIN("Ssl2SrvHandleClientFinish");

    pCommOutput->cbData = 0;

    pctRet = Ssl2SrvVerifyClientFinishMsg(pContext, pCommInput);
    if (PCT_ERR_OK != pctRet)
    {
        SP_RETURN(pctRet);
    }
    pctRet = Ssl2SrvGenerateServerFinish(pContext, pCommOutput);

    SP_RETURN(pctRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\spbase\tls1key.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
*   Owner       : ramas
*   Date        : 5/03/97
*   description : Main Crypto functions for TLS1
*----------------------------------------------------------------------------*/

#include <spbase.h>

#define DEB_TLS1KEYS  0x01000000


//+---------------------------------------------------------------------------
//
//  Function:   Tls1MakeWriteSessionKeys
//
//  Synopsis:   
//
//  Arguments:  [pContext]      --  Schannel context.
//
//  History:    10-10-97   jbanes   Added server-side CAPI integration.
//
//  Notes:      
//
//----------------------------------------------------------------------------
SP_STATUS
Tls1MakeWriteSessionKeys(PSPContext pContext)
{
    BOOL fClient;

    // Determine if we're a client or a server.
    fClient = (0 != (pContext->RipeZombie->fProtocol & SP_PROT_TLS1_CLIENT));

    if(pContext->hWriteKey)
    {
        if(!SchCryptDestroyKey(pContext->hWriteKey, 
                               pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }
    pContext->hWriteProv       = pContext->RipeZombie->hMasterProv;
    pContext->hWriteKey        = pContext->hPendingWriteKey;
    pContext->hPendingWriteKey = 0;

    if(pContext->hWriteMAC)
    {
        if(!SchCryptDestroyKey(pContext->hWriteMAC, 
                               pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }
    pContext->hWriteMAC        = pContext->hPendingWriteMAC;
    pContext->hPendingWriteMAC = 0;

    return PCT_ERR_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   Tls1MakeReadSessionKeys
//
//  Synopsis:   
//
//  Arguments:  [pContext]      --  Schannel context.
//
//  History:    10-10-97   jbanes   Added server-side CAPI integration.
//
//  Notes:      
//
//----------------------------------------------------------------------------
SP_STATUS
Tls1MakeReadSessionKeys(PSPContext pContext)
{
    BOOL fClient;

    // Determine if we're a client or a server.
    fClient = (0 != (pContext->RipeZombie->fProtocol & SP_PROT_TLS1_CLIENT));

    if(pContext->hReadKey)
    {
        if(!SchCryptDestroyKey(pContext->hReadKey, 
                               pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }
    pContext->hReadProv       = pContext->RipeZombie->hMasterProv;
    pContext->hReadKey        = pContext->hPendingReadKey;
    pContext->hPendingReadKey = 0;

    if(pContext->hReadMAC)
    {
        if(!SchCryptDestroyKey(pContext->hReadMAC, 
                               pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }
    pContext->hReadMAC        = pContext->hPendingReadMAC;
    pContext->hPendingReadMAC = 0;

    return PCT_ERR_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   Tls1ComputeMac
//
//  Synopsis:   
//
//  Arguments:  [pContext]      --  
//              [hSecret]       --
//              [dwSequence]    --  
//              [pClean]        --  
//              [cContentType]  --  
//              [pbMac]         --  
//              [cbMac]
//
//  History:    10-03-97   jbanes   Created.
//
//  Notes:      
//
//----------------------------------------------------------------------------
SP_STATUS
Tls1ComputeMac(
    PSPContext  pContext,
    BOOL        fReadMac,
    PSPBuffer   pClean,
    CHAR        cContentType,
    PBYTE       pbMac,
    DWORD       cbMac)
{
    HCRYPTHASH  hHash;
    HMAC_INFO   HmacInfo;
    PBYTE       pbData;
    DWORD       cbData;
    DWORD       cbDataReverse;
    DWORD       dwReverseSequence;
    UCHAR       rgbData1[15]; 
    PUCHAR      pbData1;
    DWORD       cbData1;
    HCRYPTPROV  hProv;
    HCRYPTKEY   hSecret;
    DWORD       dwSequence;
    DWORD       dwCapiFlags;
    PHashInfo   pHashInfo;

    pbData = pClean->pvBuffer;
    cbData = pClean->cbData; 
    if(cbData & 0xFFFF0000)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    if(fReadMac)
    {
        hProv      = pContext->hReadProv;
        hSecret    = pContext->hReadMAC;
        dwSequence = pContext->ReadCounter;
        pHashInfo  = pContext->pReadHashInfo;
    }
    else
    {
        hProv      = pContext->hWriteProv;
        hSecret    = pContext->hWriteMAC;
        dwSequence = pContext->WriteCounter;
        pHashInfo  = pContext->pWriteHashInfo;
    }
    dwCapiFlags = pContext->RipeZombie->dwCapiFlags;

    if(!hProv)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    // Create hash object.
    if(!SchCryptCreateHash(hProv,
                           CALG_HMAC,
                           hSecret,
                           0,
                           &hHash,
                           dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        return PCT_INT_INTERNAL_ERROR;
    }

    // Specify hash algorithm.
    ZeroMemory(&HmacInfo, sizeof(HMAC_INFO));
    HmacInfo.HashAlgid = pHashInfo->aiHash;
    if(!SchCryptSetHashParam(hHash,
                             HP_HMAC_INFO,
                             (PBYTE)&HmacInfo,
                             0,
                             dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        SchCryptDestroyHash(hHash, dwCapiFlags);
        return PCT_INT_INTERNAL_ERROR;
    }

    // Build data to be hashed.
    cbData1 = 2 * sizeof(DWORD) +   // sequence number (64-bit)
              1 +                   // content type
              2 +                   // protocol version
              2;                    // message length 
    SP_ASSERT(cbData1 <= sizeof(rgbData1));

    pbData1 = rgbData1;

    ZeroMemory(pbData1, sizeof(DWORD));
    pbData1 += sizeof(DWORD);
    dwReverseSequence = htonl(dwSequence);
    CopyMemory(pbData1, &dwReverseSequence, sizeof(DWORD));
    pbData1 += sizeof(DWORD);

    *pbData1++ = cContentType;

    *pbData1++ = SSL3_CLIENT_VERSION_MSB;
    *pbData1++ = TLS1_CLIENT_VERSION_LSB;

    cbDataReverse = (cbData >> 8) | (cbData << 8);
    CopyMemory(pbData1, &cbDataReverse, 2);

    // Hash data.
    if(!SchCryptHashData(hHash, 
                         rgbData1, cbData1, 
                         0, 
                         dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        SchCryptDestroyHash(hHash, dwCapiFlags);
        return PCT_INT_INTERNAL_ERROR;
    }
    if(!SchCryptHashData(hHash, 
                         pbData, cbData, 
                         0, 
                         dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        SchCryptDestroyHash(hHash, dwCapiFlags);
        return PCT_INT_INTERNAL_ERROR;
    }

    // Get hash value.
    if(!SchCryptGetHashParam(hHash,
                             HP_HASHVAL,
                             pbMac,
                             &cbMac,
                             0,
                             dwCapiFlags))
    {
        SP_LOG_RESULT(GetLastError());
        SchCryptDestroyHash(hHash, dwCapiFlags);
        return PCT_INT_INTERNAL_ERROR;
    }
    SP_ASSERT(cbMac == pHashInfo->cbCheckSum);

    #if DBG
        DebugLog((DEB_TLS1KEYS, "  TLS1 MAC Output"));
        DBG_HEX_STRING(DEB_TLS1KEYS, pbMac, cbMac);
    #endif

    SchCryptDestroyHash(hHash, dwCapiFlags);

    return PCT_ERR_OK;
}

#define HMAC_K_PADSIZE              64

BOOL MyPrimitiveSHA(
			PBYTE       pbData, 
			DWORD       cbData,
            BYTE        rgbHash[A_SHA_DIGEST_LEN])
{
    BOOL fRet = FALSE;
    A_SHA_CTX   sSHAHash;

            
    A_SHAInit(&sSHAHash);
    A_SHAUpdate(&sSHAHash, (BYTE *) pbData, cbData);
    A_SHAFinal(&sSHAHash, rgbHash);

    fRet = TRUE;
//Ret:

    return fRet;
}                                

BOOL MyPrimitiveMD5(
			PBYTE       pbData, 
			DWORD       cbData,
            BYTE        rgbHash[MD5DIGESTLEN])
{
    BOOL fRet = FALSE;
    MD5_CTX   sMD5Hash;

            
    MD5Init(&sMD5Hash);
    MD5Update(&sMD5Hash, (BYTE *) pbData, cbData);
    MD5Final(&sMD5Hash);
    memcpy(rgbHash, sMD5Hash.digest, MD5DIGESTLEN);

    fRet = TRUE;
//Ret:

    return fRet;
}                                

BOOL MyPrimitiveHMACParam(
        PBYTE       pbKeyMaterial, 
        DWORD       cbKeyMaterial,
        PBYTE       pbData, 
        DWORD       cbData,
        ALG_ID      Algid,
        BYTE        rgbHMAC[A_SHA_DIGEST_LEN])
{
    BYTE    rgbFirstHash[A_SHA_DIGEST_LEN];
    BYTE    rgbHMACTmp[HMAC_K_PADSIZE+A_SHA_DIGEST_LEN];
    BOOL    fRet = FALSE;

    BYTE    rgbKipad[HMAC_K_PADSIZE];
    BYTE    rgbKopad[HMAC_K_PADSIZE];
    DWORD   dwBlock;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;

    
    ZeroMemory(rgbKipad, HMAC_K_PADSIZE);
    CopyMemory(rgbKipad, pbKeyMaterial, cbKeyMaterial);

    ZeroMemory(rgbKopad, HMAC_K_PADSIZE);
    CopyMemory(rgbKopad, pbKeyMaterial, cbKeyMaterial);

    // Kipad, Kopad are padded sMacKey. Now XOR across...
    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)rgbKipad)[dwBlock] ^= 0x36363636;
        ((DWORD*)rgbKopad)[dwBlock] ^= 0x5C5C5C5C;
    }

    // prepend Kipad to data, Hash to get H1
    if (CALG_SHA1 == Algid)
    {
        // do this inline since it would require data copy
        A_SHA_CTX   sSHAHash;

        A_SHAInit(&sSHAHash);
        A_SHAUpdate(&sSHAHash, rgbKipad, HMAC_K_PADSIZE);
        A_SHAUpdate(&sSHAHash, pbData, cbData);

        // Finish off the hash
        A_SHAFinal(&sSHAHash, sSHAHash.HashVal);

        // prepend Kopad to H1, hash to get HMAC
        CopyMemory(rgbHMACTmp, rgbKopad, HMAC_K_PADSIZE);
        CopyMemory(rgbHMACTmp+HMAC_K_PADSIZE, sSHAHash.HashVal, A_SHA_DIGEST_LEN);

        if (!MyPrimitiveSHA(
			    rgbHMACTmp, 
			    HMAC_K_PADSIZE + A_SHA_DIGEST_LEN,
                rgbHMAC))
            goto Ret;
    }
    else
    {
        // do this inline since it would require data copy
        MD5_CTX   sMD5Hash;
            
        MD5Init(&sMD5Hash);
        MD5Update(&sMD5Hash, rgbKipad, HMAC_K_PADSIZE);
        MD5Update(&sMD5Hash, pbData, cbData);
        MD5Final(&sMD5Hash);

        // prepend Kopad to H1, hash to get HMAC
        CopyMemory(rgbHMACTmp, rgbKopad, HMAC_K_PADSIZE);
        CopyMemory(rgbHMACTmp+HMAC_K_PADSIZE, sMD5Hash.digest, MD5DIGESTLEN);

        if (!MyPrimitiveMD5(
			    rgbHMACTmp, 
			    HMAC_K_PADSIZE + MD5DIGESTLEN,
                rgbHMAC))
            goto Ret;
    }

    fRet = TRUE;
Ret:

    return fRet;    
}

//+ ---------------------------------------------------------------------
// the P_Hash algorithm from TLS 
BOOL P_Hash
(
    PBYTE  pbSecret,
    DWORD  cbSecret, 

    PBYTE  pbSeed,  
    DWORD  cbSeed,  

    ALG_ID Algid,

    PBYTE  pbKeyOut, //Buffer to copy the result...
    DWORD  cbKeyOut  //# of bytes of key length they want as output.
)
{
    BOOL    fRet = FALSE;
    BYTE    rgbDigest[A_SHA_DIGEST_LEN];      
    DWORD   iKey;
    DWORD   cbHash;

    PBYTE   pbAofiDigest = NULL;

    if (NULL == (pbAofiDigest = SPExternalAlloc(cbSeed + A_SHA_DIGEST_LEN)))
        goto Ret;

    if (CALG_SHA1 == Algid)
    {
        cbHash = A_SHA_DIGEST_LEN;
    }
    else
    {
        cbHash = MD5DIGESTLEN;
    }

//   First, we define a data expansion function, P_hash(secret, data)
//   which uses a single hash function to expand a secret and seed into
//   an arbitrary quantity of output:

//       P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) +
//                              HMAC_hash(secret, A(2) + seed) +
//                              HMAC_hash(secret, A(3) + seed) + ...

//   Where + indicates concatenation.

//   A() is defined as:
//       A(0) = seed
//       A(i) = HMAC_hash(secret, A(i-1))


    // build A(1)
    if (!MyPrimitiveHMACParam(pbSecret, cbSecret, pbSeed, cbSeed,
                              Algid, pbAofiDigest))
        goto Ret;

    // create Aofi: (  A(i) | seed )
    CopyMemory(&pbAofiDigest[cbHash], pbSeed, cbSeed);

    for (iKey=0; cbKeyOut; iKey++)
    {
        // build Digest = HMAC(key | A(i) | seed);
        if (!MyPrimitiveHMACParam(pbSecret, cbSecret, pbAofiDigest,
                                  cbSeed + cbHash, Algid, rgbDigest))
            goto Ret;

        // append to pbKeyOut
        if(cbKeyOut < cbHash)
        {
            CopyMemory(pbKeyOut, rgbDigest, cbKeyOut);
            break;
        }
        else
        {
            CopyMemory(pbKeyOut, rgbDigest, cbHash);
            pbKeyOut += cbHash;
        }

        cbKeyOut -= cbHash;

        // build A(i) = HMAC(key, A(i-1))
        if (!MyPrimitiveHMACParam(pbSecret, cbSecret, pbAofiDigest, cbHash,
                                  Algid, pbAofiDigest))
            goto Ret;
    }

    fRet = TRUE;
Ret:
    if (pbAofiDigest)
        SPExternalFree(pbAofiDigest);

    return fRet;
}

BOOL PRF(
    PBYTE  pbSecret,
    DWORD  cbSecret, 

    PBYTE  pbLabel,  
    DWORD  cbLabel,
    
    PBYTE  pbSeed,  
    DWORD  cbSeed,  

    PBYTE  pbKeyOut, //Buffer to copy the result...
    DWORD  cbKeyOut  //# of bytes of key length they want as output.
    )
{
    BYTE    *pbBuff = NULL;
    BYTE    *pbLabelAndSeed = NULL;
    DWORD   cbLabelAndSeed;
    DWORD   cbOdd;
    DWORD   cbHalfSecret;
    DWORD   i;
    BOOL    fRet = FALSE;

    cbOdd = cbSecret % 2;
    cbHalfSecret = cbSecret / 2;

    cbLabelAndSeed = cbLabel + cbSeed;
    if (NULL == (pbLabelAndSeed = SPExternalAlloc(cbLabelAndSeed)))
        goto Ret;
    if (NULL == (pbBuff = SPExternalAlloc(cbKeyOut)))
        goto Ret;

    // copy label and seed into one buffer
    memcpy(pbLabelAndSeed, pbLabel, cbLabel);
    memcpy(pbLabelAndSeed + cbLabel, pbSeed, cbSeed);

    // Use P_hash to calculate MD5 half
    if (!P_Hash(pbSecret, cbHalfSecret + cbOdd, pbLabelAndSeed,  
                cbLabelAndSeed, CALG_MD5, pbKeyOut, cbKeyOut))
        goto Ret;

    // Use P_hash to calculate SHA half
    if (!P_Hash(pbSecret + cbHalfSecret, cbHalfSecret + cbOdd, pbLabelAndSeed,  
                cbLabelAndSeed, CALG_SHA1, pbBuff, cbKeyOut))
        goto Ret;

    // XOR the two halves
    for (i=0;i<cbKeyOut;i++)
    {
        pbKeyOut[i] = pbKeyOut[i] ^ pbBuff[i];
    }
    fRet = TRUE;
Ret:
    if (pbBuff)
        SPExternalFree(pbBuff);
    if (pbLabelAndSeed)
        SPExternalFree(pbLabelAndSeed);
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\spbase\ssl3key.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
*   Owner       : ramas
*   Date        : 4/16/96
*   description : Main Crypto functions for SSL3
*----------------------------------------------------------------------------*/

#include <spbase.h>
#include <ssl3key.h>
#include <ssl2msg.h>
#include <ssl3msg.h>
#include <ssl2prot.h>


//+---------------------------------------------------------------------------
//
//  Function:   Ssl3MakeWriteSessionKeys
//
//  Synopsis:   
//
//  Arguments:  [pContext]      --  Schannel context.
//
//  History:    10-08-97   jbanes   Added server-side CAPI integration.
//
//  Notes:      
//
//----------------------------------------------------------------------------
SP_STATUS
Ssl3MakeWriteSessionKeys(PSPContext pContext)
{
    BOOL fClient;

    // Determine if we're a client or a server.
    fClient = (0 != (pContext->RipeZombie->fProtocol & SP_PROT_SSL3_CLIENT));

    //
    // Derive write key.
    //

    if(pContext->hWriteKey)
    {
        if(!SchCryptDestroyKey(pContext->hWriteKey, 
                               pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }
    pContext->hWriteProv       = pContext->RipeZombie->hMasterProv;
    pContext->hWriteKey        = pContext->hPendingWriteKey;
    pContext->hPendingWriteKey = 0;

    //
    // Derive the write MAC key.
    //

    if(pContext->hWriteMAC)
    {
        if(!SchCryptDestroyKey(pContext->hWriteMAC, 
                               pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }
    pContext->hWriteMAC = pContext->hPendingWriteMAC;
    pContext->hPendingWriteMAC = 0;

    DebugLog((DEB_TRACE, "Write Keys are Computed\n"));

    return PCT_ERR_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   Ssl3MakeReadSessionKeys
//
//  Synopsis:   
//
//  Arguments:  [pContext]      --  Schannel context.
//
//  History:    10-03-97   jbanes   Added server-side CAPI integration.
//
//  Notes:      
//
//----------------------------------------------------------------------------
SP_STATUS
Ssl3MakeReadSessionKeys(PSPContext pContext)
{
    BOOL fClient;

    // Determine if we're a client or a server.
    fClient = (pContext->RipeZombie->fProtocol & SP_PROT_SSL3_CLIENT);


    //
    // Derive the read key.
    //

    if(pContext->hReadKey)
    {
        if(!SchCryptDestroyKey(pContext->hReadKey, 
                               pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }
    pContext->hReadProv       = pContext->RipeZombie->hMasterProv;
    pContext->hReadKey        = pContext->hPendingReadKey;
    pContext->hPendingReadKey = 0;

    //
    // Derive the read MAC key.
    //

    if(pContext->hReadMAC)
    {
        if(!SchCryptDestroyKey(pContext->hReadMAC, 
                               pContext->RipeZombie->dwCapiFlags))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }
    pContext->hReadMAC = pContext->hPendingReadMAC;
    pContext->hPendingReadMAC = 0;

    DebugLog((DEB_TRACE, "Read Keys are Computed\n"));

    return PCT_ERR_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\spbase\ssl3.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ssl3.c
//
//  Contents:   Ssl3 protocol handling functions
//
//  Classes:
//
//  Functions:
//
//  History:    8-08-95   Ramas     Created
//              1-14-97   Ramas     Rewritten
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <_ssl3cli.h>
#include <time.h>


DWORD g_Ssl3CertTypes[] = { SSL3_CERTTYPE_RSA_SIGN,
                            SSL3_CERTTYPE_DSS_SIGN};
DWORD g_cSsl3CertTypes = sizeof(g_Ssl3CertTypes) / sizeof(DWORD);

SP_STATUS WINAPI
Ssl3ClientProtocolHandler(
    PSPContext  pContext,
    PSPBuffer   pCommInput,
    PSPBuffer   pCommOutput);

SP_STATUS
UpdateAndDuplicateIssuerList(
    PSPCredentialGroup  pCredGroup,
    PBYTE *             ppbIssuerList,
    PDWORD              pcbIssuerList);


SP_STATUS WINAPI
Ssl3ProtocolHandler(
    PSPContext  pContext,
    PSPBuffer   pCommInput,
    PSPBuffer   pCommOutput)
{
    SPBuffer MsgInput;
    SP_STATUS pctRet;
    DWORD cbInputData = 0;

    if(pContext->Flags & CONTEXT_FLAG_CONNECTION_MODE)
    {
        do
        {
            MsgInput.pvBuffer = (PUCHAR) pCommInput->pvBuffer + cbInputData;
            MsgInput.cbData   = pCommInput->cbData - cbInputData;
            MsgInput.cbBuffer = pCommInput->cbBuffer - cbInputData;

            pctRet = Ssl3ClientProtocolHandler(pContext,
                                               &MsgInput,
                                               pCommOutput);
            cbInputData += MsgInput.cbData;

            if(SP_STATE_CONNECTED == pContext->State)
            {
                break;
            }
            if(PCT_ERR_OK != pctRet)
            {
                break;
            }

        } while(pCommInput->cbData - cbInputData);

        pCommInput->cbData = cbInputData;
    }
    else
    {
        pctRet = Ssl3ClientProtocolHandler(pContext,
                                           pCommInput,
                                           pCommOutput);
    }

    return(pctRet);
}


/*
***************************************************************************
* Ssl3ProtocolHandler
* Main Entry point for handling ssl3 type handshake messages...
****************************************************************************
*/
SP_STATUS WINAPI
Ssl3ClientProtocolHandler
(
    PSPContext  pContext,       // in; state changes and temp data stored
    PSPBuffer   pCommInput,     // in: decrypted in-place...
    PSPBuffer   pCommOutput)    // out
{
    SP_STATUS   pctRet = PCT_ERR_OK;
    DWORD       dwState;
    DWORD       cbMsg;
    BYTE        bContentType;
    BOOL        fServer = (pContext->dwProtocol & SP_PROT_SERVERS);
    BOOL        fProcessMultiple = FALSE;
    PBYTE       pbData;
    DWORD       cbData;
    DWORD       cbBytesProcessed = 0;
    DWORD       dwVersion;
    DWORD       cbDecryptedMsg;

    if(NULL != pCommOutput)
    {
        pCommOutput->cbData = 0;
    }

    dwState = (pContext->State & 0xffff);

    if(FNoInputState(dwState))
    {
        // Process no input cases...
        goto GenResponse;
    }

    if(pContext->State == UNI_STATE_RECVD_UNIHELLO)
    {
        // We've just received a unified client_hello message.
        // This always consists of a single SSL2-format handshake
        // message.

        if(pCommInput->cbData < 3)
        {
            return(PCT_INT_INCOMPLETE_MSG);
        }

        bContentType = UNI_STATE_RECVD_UNIHELLO;

        pbData = pCommInput->pvBuffer;
        cbData = pCommInput->cbData;
        cbDecryptedMsg = cbData;
        cbMsg = cbData;

        goto Process;
    }


    //
    // The input buffer should contain one or more SSL3-format
    // messages. 
    //

    if(pCommInput->cbData < CB_SSL3_HEADER_SIZE)
    {
        return (PCT_INT_INCOMPLETE_MSG);
    }


    //
    // If there are multiple messages in the input buffer, and 
    // these messages exactly fill the buffer, then we should
    // process all of the messages during this call. If there
    // are any fractions, then we should just process the first
    // message.
    //

    pbData = pCommInput->pvBuffer;
    cbData = pCommInput->cbData;

    while(TRUE)
    {
        if(cbData < CB_SSL3_HEADER_SIZE)
        {
            break;
        }

        bContentType = pbData[0];

        if(bContentType != SSL3_CT_CHANGE_CIPHER_SPEC &&
           bContentType != SSL3_CT_ALERT &&
           bContentType != SSL3_CT_HANDSHAKE &&
           bContentType != SSL3_CT_APPLICATIONDATA)
        {
            break;
        }

        dwVersion = COMBINEBYTES(pbData[1], pbData[2]);

        if(dwVersion != SSL3_CLIENT_VERSION &&
           dwVersion != TLS1_CLIENT_VERSION)
        {
            break;
        }

        cbMsg = COMBINEBYTES(pbData[3], pbData[4]);
        cbDecryptedMsg = cbMsg;

        if(CB_SSL3_HEADER_SIZE + cbMsg > cbData)
        {
            break;
        }

        pbData += CB_SSL3_HEADER_SIZE + cbMsg;
        cbData -= CB_SSL3_HEADER_SIZE + cbMsg;

        if(cbData == 0)
        {
            fProcessMultiple = TRUE;
            break;
        }
    }


    //
    // Step through the messages in the input buffer, processing
    // each one in turn.
    //

    pbData = pCommInput->pvBuffer;
    cbData = pCommInput->cbData;

    while(TRUE)
    {
        //
        // Validate the message.
        //

        if(cbData < CB_SSL3_HEADER_SIZE)
        {
            return (PCT_INT_INCOMPLETE_MSG);
        }

        
        bContentType = pbData[0];

        if(bContentType != SSL3_CT_CHANGE_CIPHER_SPEC &&
           bContentType != SSL3_CT_ALERT &&
           bContentType != SSL3_CT_HANDSHAKE &&
           bContentType != SSL3_CT_APPLICATIONDATA)
        {
            return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
        }


        cbMsg = COMBINEBYTES(pbData[3], pbData[4]);
        cbDecryptedMsg = cbMsg;

        if(CB_SSL3_HEADER_SIZE + cbMsg > cbData)
        {
            return (PCT_INT_INCOMPLETE_MSG);
        }

        cbBytesProcessed += CB_SSL3_HEADER_SIZE + cbMsg;

        pCommInput->cbData = cbBytesProcessed;


        //
        // Decrypt the message.
        //

        if(FSsl3Cipher(fServer))
        {
            SPBuffer Message;

            Message.cbBuffer = CB_SSL3_HEADER_SIZE + cbMsg;
            Message.cbData   = CB_SSL3_HEADER_SIZE + cbMsg;
            Message.pvBuffer = pbData;

            // Decrypt the message.
            pctRet = UnwrapSsl3Message(pContext, &Message);

            // if we have to send ALERT messages to the peer, build it!
            if(TLS1_STATE_ERROR == pContext->State)
            {
                goto GenResponse;
            }

            if(pctRet != PCT_ERR_OK)
            {
                return pctRet;
            }

            cbDecryptedMsg = COMBINEBYTES(pbData[3], pbData[4]);
        }


        pbData += CB_SSL3_HEADER_SIZE;
        cbData -= CB_SSL3_HEADER_SIZE;

Process:

        pctRet = SPProcessMessage(pContext, bContentType, pbData, cbDecryptedMsg) ;
        if(pctRet != PCT_ERR_OK)
        {
            return pctRet;
        }

        pbData += cbMsg;
        cbData -= cbMsg;

        // If a response is required at this state then break out of the 
        // message processing loop.
        if(F_RESPONSE(pContext->State))
        {

GenResponse:

            if(pContext->State > SSL3_STATE_GEN_START)
            {
                pctRet = SPGenerateResponse(pContext, pCommOutput);
            }

            return pctRet;
        }

        // If the handshake is complete then stop processing messages.
        // We don't want to accidentally process any application data
        // messages.
        if(pContext->State == SP_STATE_CONNECTED)
        {
            break;
        }

        if(fProcessMultiple && cbData > 0)
        {
            continue;
        }

        break;
    }

    return pctRet;
}

/*
***************************************************************************
* Ssl3HandleFinish
* Handle the handshake finished message..
****************************************************************************
*/

SP_STATUS
Ssl3HandleFinish(
    PSPContext  pContext,
    PBYTE      pb,  //in
    BOOL        fClient //in

    )
{
    SP_STATUS          pctRet;

    pctRet = SPVerifyFinishMsgCli(pContext, pb, !fClient);
    return(pctRet);
}


/*
***************************************************************************
* SPVerifyFinishMsgCli
* Verify the Finished handshake message. This is common for client/server
****************************************************************************
*/

SP_STATUS
SPVerifyFinishMsgCli(
    PSPContext pContext,
    PBYTE       pbMsg,
    BOOL        fClient
    )
{
    BOOL fSucc = FALSE;
    BYTE rgbDigest[CB_MD5_DIGEST_LEN + CB_SHA_DIGEST_LEN];
    SP_STATUS pctRet = PCT_ERR_OK;
    PBYTE pb = pbMsg;

    SP_BEGIN("SPVerifyFinishMsgCli");

    do
    {
        DWORD dwSize;
        DWORD dwSizeExpect = CB_MD5_DIGEST_LEN + CB_SHA_DIGEST_LEN;

        //is this the right message type
        if(*pb != SSL3_HS_FINISHED)
        {
            pctRet = SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
            break;
        }

        if(pContext->RipeZombie->fProtocol & SP_PROT_TLS1)
        {
            dwSizeExpect = CB_TLS1_VERIFYDATA;
        }

        // check the size
        dwSize = ((INT)pb[1] << 16) + ((INT)pb[2] << 8) + (INT)pb[3];
        pb += sizeof(SHSH);

        if(dwSize != dwSizeExpect)
        {
            pctRet = SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
            break;
        }

        // Build our end finish message to compare
        if(pContext->RipeZombie->fProtocol & SP_PROT_SSL3)
        {
            pctRet = Ssl3BuildFinishMessage(pContext,
                                            rgbDigest,
                                            &rgbDigest[CB_MD5_DIGEST_LEN],
                                            fClient);
        }
        else
        {
            pctRet = Tls1BuildFinishMessage(pContext,
                                            rgbDigest,
                                            sizeof(rgbDigest),
                                            fClient);
        }
        if(pctRet != PCT_ERR_OK)
        {
            break;
        }

        // compare the two...
        if (memcmp(rgbDigest, pb, dwSizeExpect))
        {
            DebugLog((DEB_WARN, "Finished MAC didn't matchChecksum Invalid\n"));
            pctRet = SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
            break;
        }
        SP_RETURN(PCT_ERR_OK);

    } while(TRUE);

    SP_RETURN(pctRet);
}


/*
***************************************************************************
* Ssl3PackClientHello
****************************************************************************
*/

SP_STATUS
Ssl3PackClientHello(
    PSPContext              pContext,
    PSsl2_Client_Hello       pCanonical,
    PSPBuffer          pCommOutput)
{
    SP_STATUS pctRet;
    DWORD cbHandshake;
    DWORD cbMessage;
    PBYTE pbMessage = NULL;
    DWORD dwCipherSize;
    DWORD i;
    BOOL  fAllocated = FALSE;

    //
    // opaque SessionID<0..32>;
    //
    // struct {
    //     ProtocolVersion client_version;
    //     Random random;
    //     SessionID session_id;
    //     CipherSuite cipher_suites<2..2^16-1>;
    //     CompressionMethod compression_methods<1..2^8-1>;
    // } ClientHello;
    //

    SP_BEGIN("Ssl3PackClientHello");

    if(pCanonical == NULL || pCommOutput == NULL)
    {
        SP_RETURN(PCT_INT_INTERNAL_ERROR);
    }

    // Compute size of the ClientHello message.
    cbHandshake = sizeof(SHSH) +
                  2 +
                  CB_SSL3_RANDOM +
                  1 + pCanonical->cbSessionID +
                  2 + pCanonical->cCipherSpecs * sizeof(short) +
                  2; // Size of compression algorithm 1 + null (0)

    // Compute size of encrypted ClientHello message.
    cbMessage = Ssl3CiphertextLen(pContext,
                                  cbHandshake,
                                  TRUE);

    if(pCommOutput->pvBuffer)
    {
        // Application has allocated memory.
        if(pCommOutput->cbBuffer < cbMessage)
        {
            pCommOutput->cbData = cbMessage;
            return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
        }
        fAllocated = TRUE;
    }
    else
    {
        // Schannel is to allocate memory.
        pCommOutput->cbBuffer = cbMessage;
        pCommOutput->pvBuffer = SPExternalAlloc(cbMessage);
        if(pCommOutput->pvBuffer == NULL)
        {
            return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        }
    }
    pCommOutput->cbData = cbMessage;

    // Initialize the member variables.
    pbMessage = (PBYTE)pCommOutput->pvBuffer + sizeof(SWRAP) + sizeof(SHSH);

    *pbMessage++ =  MSBOF(pCanonical->dwVer);
    *pbMessage++ =  LSBOF(pCanonical->dwVer);

    CopyMemory(pbMessage, pCanonical->Challenge, CB_SSL3_RANDOM);
    pbMessage += CB_SSL3_RANDOM;

    *pbMessage++ = (BYTE)pCanonical->cbSessionID;
    CopyMemory(pbMessage, pCanonical->SessionID, pCanonical->cbSessionID);
    pbMessage += pCanonical->cbSessionID;

    dwCipherSize = pCanonical->cCipherSpecs * sizeof(short);
    *pbMessage++ = MSBOF(dwCipherSize);
    *pbMessage++ = LSBOF(dwCipherSize);
    for(i = 0; i < pCanonical->cCipherSpecs; i++)
    {
        *pbMessage++ = MSBOF(pCanonical->CipherSpecs[i]);
        *pbMessage++ = LSBOF(pCanonical->CipherSpecs[i]);
    }

    *pbMessage++ = 1;    // One compression method;
    *pbMessage++ = 0x00; // NULL compression method.

    // Fill in Handshake structure.
    SetHandshake((PBYTE)pCommOutput->pvBuffer + sizeof(SWRAP),
                 SSL3_HS_CLIENT_HELLO,
                 NULL,
                 (WORD)(cbHandshake - sizeof(SHSH)));

    // Save the ClientHello message so we can hash it later, once
    // we know what algorithm and CSP we're using.
    if(pContext->pClientHello)
    {
        SPExternalFree(pContext->pClientHello);
    }
    pContext->cbClientHello = cbHandshake;
    pContext->pClientHello = SPExternalAlloc(pContext->cbClientHello);
    if(pContext->pClientHello == NULL)
    {
        SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
    }
    CopyMemory(pContext->pClientHello,
               (PBYTE)pCommOutput->pvBuffer + sizeof(SWRAP),
               pContext->cbClientHello);
    pContext->dwClientHelloProtocol = SP_PROT_SSL3_CLIENT;

    // Fill in record header and encrypt the message.
    SP_RETURN(SPSetWrap(pContext,
            pCommOutput->pvBuffer,
            SSL3_CT_HANDSHAKE,
            cbHandshake,
            TRUE,
            NULL));
}


//+---------------------------------------------------------------------------
//
//  Function:   Ssl3GenerateRandom
//
//  Synopsis:   Create a client_random or server_random value.
//
//  Arguments:  [pRandom]   --  Output buffer.
//
//  History:    04-03-2001  jbanes  Created.
//
//  Notes:      struct {
//                  uint32 gmt_unix_time;
//                  opaque random_bytes[28];
//              } Random;
//
//              gmt_unix_time
//                  The current time and date in standard UNIX 32-bit format
//                  (seconds since the midnight starting Jan 1, 1970, GMT) 
//                  according to the sender's internal clock. Clocks are not
//                  required to be set correctly by the basic TLS Protocol; 
//                  higher level or application protocols may define 
//                  additional requirements.
//
//              random_bytes
//                  28 bytes generated by a secure random number generator.
//
//----------------------------------------------------------------------------
void
Ssl3GenerateRandom(
    PBYTE pRandom)
{
    time_t UnixTime;

    GenerateRandomBits(pRandom + sizeof(DWORD), CB_SSL3_RANDOM - sizeof(DWORD));

    time(&UnixTime);

    *(DWORD *)pRandom = htonl((DWORD)UnixTime);
}


/*
***************************************************************************
* GenerateSsl3ClientHello
*  v3 client hello build it on pOutpu
****************************************************************************
*/

SP_STATUS WINAPI
GenerateSsl3ClientHello(
    PSPContext              pContext,
    PSPBuffer               pOutput)
{
    Ssl2_Client_Hello    HelloMessage;
    SP_STATUS pctRet;

    SP_BEGIN("GenerateSsl3ClientHello");

    Ssl3GenerateRandom( pContext->pChallenge );
    pContext->cbChallenge = CB_SSL3_RANDOM;

    pctRet = GenerateUniHelloMessage(pContext, &HelloMessage, SP_PROT_SSL3_CLIENT);

    if(PCT_ERR_OK == pctRet)
    {
        pctRet = Ssl3PackClientHello(pContext, &HelloMessage,  pOutput);
    }

    SP_RETURN(pctRet);
}

SP_STATUS WINAPI
GenerateTls1ClientHello(
    PSPContext              pContext,
    PSPBuffer               pOutput,
    DWORD                   dwProtocol)
{
    Ssl2_Client_Hello    HelloMessage;
    SP_STATUS pctRet;

    SP_BEGIN("GenerateTls1ClientHello");

    Ssl3GenerateRandom( pContext->pChallenge );
    pContext->cbChallenge = CB_SSL3_RANDOM;

    pctRet = GenerateUniHelloMessage(pContext, &HelloMessage, dwProtocol);

    if(PCT_ERR_OK == pctRet)
    {
        pctRet = Ssl3PackClientHello(pContext, &HelloMessage,  pOutput);
    }
    SP_RETURN(pctRet);
}

/*
***************************************************************************
* ParseCertificateRequest
* if server is requesting client-auth, server will send this message.
* parse them and store it in pContext, for later use....
****************************************************************************
*/


SP_STATUS
ParseCertificateRequest(
    PSPContext  pContext,
    PBYTE       pb,
    DWORD       dwcb)
{
    SP_STATUS pctRet;
    UCHAR cbCertType;
    DWORD cbIssuerList;
    PBYTE pbNewIssuerList;
    DWORD cbNewIssuerList;

    UCHAR i, j;

    //
    // enum {
    //     rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
    //     rsa_ephemeral_dh(5), dss_ephemeral_dh(6), fortezza_dms(20), (255)
    // } ClientCertificateType;
    //
    // opaque DistinguishedName<1..2^16-1>;
    //
    // struct {
    //     ClientCertificateType certificate_types<1..2^8-1>;
    //     DistinguishedName certificate_authorities<3..2^16-1>;
    // } CertificateRequest;
    //

    //
    // Skip over handshake header.
    //

    if(dwcb < sizeof(SHSH))
    {
        pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
        goto cleanup;
    }
    pb   += sizeof(SHSH);
    dwcb -= sizeof(SHSH);


    //
    // Parse certificate type list.
    //

    if(dwcb < 1)
    {
        pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
        goto cleanup;
    }

    cbCertType = pb[0];

    pb   += 1;
    dwcb -= 1;

    if(cbCertType > dwcb)
    {
        pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
        goto cleanup;
    }

    pContext->cSsl3ClientCertTypes = 0;
    for(i = 0; i < cbCertType; i++)
    {
        for(j = 0; j < g_cSsl3CertTypes; j++)
        {
            if(g_Ssl3CertTypes[j] == pb[i])
            {
                pContext->Ssl3ClientCertTypes[pContext->cSsl3ClientCertTypes++] = g_Ssl3CertTypes[j];
            }
        }
    }

    pb   += cbCertType;
    dwcb -= cbCertType;


    //
    // Parse issuer list.
    //

    if(dwcb < 2)
    {
        pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
        goto cleanup;
    }

    cbIssuerList = COMBINEBYTES(pb[0], pb[1]);

    pb   += 2;
    dwcb -= 2;

    if(dwcb < cbIssuerList)
    {
        pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
        goto cleanup;
    }

    pctRet = FormatIssuerList(pb, 
                              cbIssuerList, 
                              NULL,
                              &cbNewIssuerList);
    if(pctRet != PCT_ERR_OK)
    {
        goto cleanup;
    }

    pbNewIssuerList = SPExternalAlloc(2 + cbNewIssuerList);
    if(pbNewIssuerList == NULL)
    {
        pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto cleanup;
    }

    pbNewIssuerList[0] = MSBOF(cbNewIssuerList);
    pbNewIssuerList[1] = LSBOF(cbNewIssuerList);

    pctRet = FormatIssuerList(pb, 
                              cbIssuerList, 
                              pbNewIssuerList + 2,
                              &cbNewIssuerList);
    if(pctRet != PCT_ERR_OK)
    {
        SPExternalFree(pbNewIssuerList);
        goto cleanup;
    }


    //
    // Store issuer list in context structure.
    //

    if(pContext->pbIssuerList)
    {
        SPExternalFree(pContext->pbIssuerList);
    }
    pContext->pbIssuerList = pbNewIssuerList;
    pContext->cbIssuerList = cbNewIssuerList + 2;


cleanup:

    return (pctRet);
}


/*
***************************************************************************
* BuildCertVerify
* Build certificate Verify message. This is sent by client if sending
* client certificate.
****************************************************************************
*/

SP_STATUS
BuildCertVerify(
    PSPContext  pContext,
    PBYTE pbCertVerify,
    DWORD *pcbCertVerify)
{
    SP_STATUS pctRet;
    PBYTE pbSigned;
    DWORD cbSigned;
    BYTE  rgbHashValue[CB_MD5_DIGEST_LEN + CB_SHA_DIGEST_LEN];
    DWORD cbHashValue;
    ALG_ID aiHash;
    PBYTE pbMD5;
    PBYTE pbSHA;
    DWORD cbHeader;
    DWORD cbBytesRequired;

    PSPCredential pCred;

    if((pcbCertVerify == NULL) ||
       (pContext == NULL) ||
       (pContext->RipeZombie == NULL) ||
       (pContext->pActiveClientCred == NULL))
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    pCred = pContext->pActiveClientCred;

    //
    // digitally-signed struct {
    //     opaque md5_hash[16];
    //     opaque sha_hash[20];
    // } Signature;
    //
    // struct {
    //     Signature signature;
    // } CertificateVerify;
    //
    // CertificateVerify.signature.md5_hash = MD5(master_secret + pad2 +
    //    MD5(handshake_messages + master_secret + pad1));
    //
    // CertificateVerify.signature.sha_hash = SHA(master_secret + pad2 +
    //    SHA(handshake_messages + master_secret + pad1));
    //

    cbHeader = sizeof(SHSH);

    cbBytesRequired = cbHeader + 
                      2 +
                      pCred->pPublicKey->cbPublic;
    
    if(pbCertVerify == NULL)
    {
        *pcbCertVerify = cbBytesRequired;
        return PCT_ERR_OK;
    }

    if(*pcbCertVerify < sizeof(SHSH))
    {
        *pcbCertVerify = cbBytesRequired;
        return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
    }


    //
    // Generate hash values
    //

    switch(pCred->pPublicKey->pPublic->aiKeyAlg)
    {
    case CALG_RSA_SIGN:
    case CALG_RSA_KEYX:
        aiHash      = CALG_SSL3_SHAMD5;
        pbMD5       = rgbHashValue;
        pbSHA       = rgbHashValue + CB_MD5_DIGEST_LEN;
        cbHashValue = CB_MD5_DIGEST_LEN + CB_SHA_DIGEST_LEN;
        break;

    case CALG_DSS_SIGN:
        aiHash      = CALG_SHA;
        pbMD5       = NULL;
        pbSHA       = rgbHashValue;
        cbHashValue = CB_SHA_DIGEST_LEN;
        break;

    default:
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    if(pContext->RipeZombie->fProtocol & SP_PROT_TLS1)
    {
        pctRet = Tls1ComputeCertVerifyHashes(pContext, pbMD5, pbSHA);
    }
    else
    {
        pctRet = Ssl3ComputeCertVerifyHashes(pContext, pbMD5, pbSHA);
    }
    if(pctRet != PCT_ERR_OK)
    {
        return pctRet;
    }


    //
    // Sign hash values.
    //

    pbSigned = pbCertVerify + sizeof(SHSH) + 2;
    cbSigned = cbBytesRequired - sizeof(SHSH) - 2;

    DebugLog((DEB_TRACE, "Sign certificate_verify message.\n"));

    pctRet = SignHashUsingCred(pCred,
                               aiHash,
                               rgbHashValue,
                               cbHashValue,
                               pbSigned,
                               &cbSigned);
    if(pctRet != PCT_ERR_OK)
    {
        return pctRet;
    }

    DebugLog((DEB_TRACE, "Certificate_verify message signed successfully.\n"));

    //
    // Fill in header.
    //

    pbCertVerify[cbHeader + 0] = MSBOF(cbSigned);
    pbCertVerify[cbHeader + 1] = LSBOF(cbSigned);

    SetHandshake(pbCertVerify, SSL3_HS_CERTIFICATE_VERIFY, NULL, (WORD)(cbSigned + 2));

    *pcbCertVerify =  cbHeader + 2 + cbSigned;

    return PCT_ERR_OK;
}


SP_STATUS
HandleCertVerify(
    PSPContext  pContext, 
    PBYTE       pbMessage, 
    DWORD       cbMessage)
{
    PBYTE pbSignature;
    DWORD cbSignature;
    BYTE  rgbHashValue[CB_MD5_DIGEST_LEN + CB_SHA_DIGEST_LEN];
    DWORD cbHashValue;
    HCRYPTPROV hProv;
    ALG_ID aiHash;
    PBYTE pbMD5;
    PBYTE pbSHA;
    SP_STATUS pctRet;

    if((pContext == NULL) ||
       (pContext->RipeZombie == NULL))
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    if(pContext->RipeZombie->pRemotePublic == NULL)
    {
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    pbSignature = pbMessage + sizeof(SHSH);

    cbSignature = ((DWORD)pbSignature[0] << 8) + pbSignature[1];
    pbSignature += 2;

    if(sizeof(SHSH) + 2 + cbSignature > cbMessage)
    {
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    switch(pContext->RipeZombie->pRemotePublic->pPublic->aiKeyAlg)
    {
    case CALG_RSA_SIGN:
    case CALG_RSA_KEYX:
        hProv       = g_hRsaSchannel;
        aiHash      = CALG_SSL3_SHAMD5;
        pbMD5       = rgbHashValue;
        pbSHA       = rgbHashValue + CB_MD5_DIGEST_LEN;
        cbHashValue = CB_MD5_DIGEST_LEN + CB_SHA_DIGEST_LEN;
        break;

    case CALG_DSS_SIGN:
        hProv       = g_hDhSchannelProv;
        aiHash      = CALG_SHA;
        pbMD5       = NULL;
        pbSHA       = rgbHashValue;
        cbHashValue = CB_SHA_DIGEST_LEN;
        break;

    default:
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    if(pContext->RipeZombie->fProtocol & SP_PROT_TLS1)
    {
        pctRet = Tls1ComputeCertVerifyHashes(pContext, pbMD5, pbSHA);
    }
    else
    {
        pctRet = Ssl3ComputeCertVerifyHashes(pContext, pbMD5, pbSHA);
    }
    if(pctRet != PCT_ERR_OK)
    {
        return pctRet;
    }

    // Verify signature.
    DebugLog((DEB_TRACE, "Verify certificate_verify signature.\n"));
    pctRet = SPVerifySignature(hProv, 
                               0,
                               pContext->RipeZombie->pRemotePublic,
                               aiHash,
                               rgbHashValue,
                               cbHashValue,
                               pbSignature,
                               cbSignature,
                               FALSE);
    if(pctRet != PCT_ERR_OK)
    {
        return SP_LOG_RESULT(pctRet);
    }
    DebugLog((DEB_TRACE, "Certificate_verify verified successfully.\n"));

    return PCT_ERR_OK;
}


SP_STATUS 
FormatIssuerList(
    PBYTE       pbInput,
    DWORD       cbInput,
    PBYTE       pbIssuerList,
    DWORD *     pcbIssuerList)
{
    DWORD cbIssuerList = 0;
    PBYTE pbList = pbInput;
    DWORD cbList = cbInput;
    DWORD cbIssuer;
    DWORD cbTag;

    while(cbList)
    {
        if(cbList < 2)
        {
            return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
        }

        cbIssuer = COMBINEBYTES(pbList[0], pbList[1]);

        pbList += 2;
        cbList -= 2;

        if(cbList < cbIssuer)
        {
            return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
        }

        if(pbIssuerList)
        {
            pbIssuerList[0] = MSBOF(cbIssuer);
            pbIssuerList[1] = LSBOF(cbIssuer);
            pbIssuerList += 2;
        }
        cbIssuerList += 2;

        if(pbList[0] != SEQUENCE_TAG) 
        {
            // An old version of Netscape Enterprise Server had a bug, in that 
            // the issuer names did not start off with a SEQUENCE tag. Patch
            // the name appropriately before storing it into pContext.
            cbTag = CbLenOfEncode(cbIssuer, pbIssuerList);

            if(pbIssuerList)
            {
                pbIssuerList += cbTag;
            }
            cbIssuerList += cbTag;
        }

        if(pbIssuerList)
        {
            memcpy(pbIssuerList, pbList, cbIssuer);
            pbIssuerList += cbIssuer;
        }
        cbIssuerList += cbIssuer;

        pbList += cbIssuer;
        cbList -= cbIssuer;
    }

    *pcbIssuerList = cbIssuerList;

    return(PCT_ERR_OK);
}

/*
***************************************************************************
* CbLenOfEncode
* Retunrs the length of the ASN encoding, for certificate
****************************************************************************
*/


DWORD  CbLenOfEncode(DWORD dw, PBYTE pbDst)
{
    BYTE   lenbuf[8];
    DWORD   length = sizeof(lenbuf) - 1;
    LONG    lth;

    if (0x80 > dw)
    {
        lenbuf[length] = (BYTE)dw;
        lth = 1;
    }
    else
    {
        while (0 < dw)
        {
            lenbuf[length] = (BYTE)(dw & 0xff);
            length -= 1;
            dw = (dw >> 8) & 0x00ffffff;
        }
        lth = sizeof(lenbuf) - length;
        lenbuf[length] = (BYTE)(0x80 | (lth - 1));
    }

    if(NULL != pbDst)
    {
        pbDst[0] = 0x30;
        memcpy(pbDst+1, &lenbuf[length], lth);

    }
    return ++lth; //for 0x30
}


/*
***************************************************************************
* SPDigestServerHello
* Parse the server hello from the server.
****************************************************************************
*/
SP_STATUS
SPDigestServerHello(
    PSPContext  pContext,
    PUCHAR      pb,
    DWORD       dwSrvHello,
    PBOOL       pfRestart)
{
    SSH *pssh;
    SP_STATUS pctRet = PCT_ERR_ILLEGAL_MESSAGE;
    SHORT wCipher, wCompression;
    BOOL fRestartServer = FALSE;
    PSessCacheItem      pZombie;
    PSPCredentialGroup  pCred;
    DWORD dwVersion;

    // We should have a zombie identity here
    if(pContext->RipeZombie == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }
    pZombie = pContext->RipeZombie;

    pCred = pContext->pCredGroup;
    if(!pCred)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    SP_BEGIN("SPDigestServerHello");

    // Pad the random structure with zero's if the challenge is
    // smaller than the normal SSL3 size (SSL2 v3 hello, Unihello, PCT1 wierdness if
    // we add it)
    FillMemory(pContext->rgbS3CRandom, CB_SSL3_RANDOM - pContext->cbChallenge, 0);

    CopyMemory(  pContext->rgbS3CRandom + CB_SSL3_RANDOM - pContext->cbChallenge,
                 pContext->pChallenge,
                 pContext->cbChallenge);

    pssh = (SSH *)pb ;


    if(pssh->cbSessionId > CB_SSL3_SESSION_ID)
    {
        SP_RETURN(PCT_ERR_ILLEGAL_MESSAGE);
    }


    dwVersion = COMBINEBYTES(pssh->bMajor, pssh->bMinor);

    if((dwVersion == SSL3_CLIENT_VERSION) && 
       (pCred->grbitEnabledProtocols & SP_PROT_SSL3_CLIENT))
    {
        // This appears to be an SSL3 server_hello.
        pContext->dwProtocol = SP_PROT_SSL3_CLIENT;
    }
    else if((dwVersion == TLS1_CLIENT_VERSION) && 
       (pCred->grbitEnabledProtocols & SP_PROT_TLS1_CLIENT))
    {
        // This appears to be a TLS server_hello.
        pContext->dwProtocol = SP_PROT_TLS1_CLIENT;
    }
    else
    {
        return SP_LOG_RESULT(PCT_INT_SPECS_MISMATCH);
    }

    DebugLog((DEB_TRACE, "**********Protocol***** %x\n", pContext->dwProtocol));

    CopyMemory(pContext->rgbS3SRandom, pssh->rgbRandom, CB_SSL3_RANDOM);
    wCipher = (SHORT)COMBINEBYTES(pssh->rgbSessionId[pssh->cbSessionId],
                           pssh->rgbSessionId[pssh->cbSessionId+1]);
    wCompression = pssh->rgbSessionId[pssh->cbSessionId+2];

    if( wCompression != 0)
    {
        SP_RETURN(PCT_ERR_ILLEGAL_MESSAGE);
    }
    if(pZombie->hMasterKey  &&
       pZombie->cbSessionID && 
       memcmp(pZombie->SessionID, PbSessionid(pssh), pssh->cbSessionId) == 0)
    {
        fRestartServer = TRUE;

        if(!pZombie->ZombieJuju)
        {
            DebugLog((DEB_WARN, "Session expired on client machine, but not on server.\n"));
        }
    }

    if(!fRestartServer)
    {
        if(pZombie->hMasterKey != 0)
        {
            // We've attempted to do a reconnect and the server has
            // blown us off. In this case we must use a new and different
            // cache entry.
            pZombie->ZombieJuju = FALSE;

            if(!SPCacheClone(&pContext->RipeZombie))
            {
                SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
            }
            pZombie = pContext->RipeZombie;
        }

        pZombie->fProtocol = pContext->dwProtocol;

        #if DBG
        if(pssh->cbSessionId == 0)
        {
            DebugLog((DEB_WARN, "Server didn't give us a session id!\n"));
        }
        #endif

        if(pssh->cbSessionId)
        {
            CopyMemory(pZombie->SessionID, PbSessionid(pssh), pssh->cbSessionId);
            pZombie->cbSessionID = pssh->cbSessionId;
        }
    }

    pctRet = Ssl3SelectCipher(pContext, wCipher);
    if(pctRet != PCT_ERR_OK)
    {
        SP_RETURN(SP_LOG_RESULT(pctRet));
    }


    if(fRestartServer)
    {
        // Make a new set of session keys.
        pctRet = MakeSessionKeys(pContext,
                                 pZombie->hMasterProv,
                                 pZombie->hMasterKey);
        if(PCT_ERR_OK != pctRet)
        {
            SP_RETURN(SP_LOG_RESULT(pctRet));
        }
    }


    // Initialize handshake hashes and hash ClientHello message. This
    // must be done _after_ the ServerHello message is processed,
    // so that the correct CSP context is used.
    if(pContext->dwClientHelloProtocol == SP_PROT_PCT1_CLIENT ||
       pContext->dwClientHelloProtocol == SP_PROT_SSL2_CLIENT)
    {
        // Skip over the 2 byte header.
        pctRet = UpdateHandshakeHash(pContext,
                                     pContext->pClientHello  + 2,
                                     pContext->cbClientHello - 2,
                                     TRUE);
    }
    else
    {
        pctRet = UpdateHandshakeHash(pContext,
                                     pContext->pClientHello,
                                     pContext->cbClientHello,
                                     TRUE);
    }
    SPExternalFree(pContext->pClientHello);
    pContext->pClientHello  = NULL;
    pContext->cbClientHello = 0;


    *pfRestart = fRestartServer;

    SP_RETURN(pctRet);
}


/*
***************************************************************************
* SpDigestRemoteCertificate
* Process the Certificate message. This is common for server/client.
****************************************************************************
*/

SP_STATUS
SpDigestRemoteCertificate (
    PSPContext  pContext,
    PUCHAR      pb,
    DWORD       cb)
{
    SP_STATUS pctRet = PCT_ERR_OK;
    CERT *pcert;
    DWORD cbCert;
    DWORD dwSize;
    DWORD dwFlags;

    SP_BEGIN("SpDigestRemoteCertificate");

    if(pContext == NULL)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    if((pContext->RipeZombie->fProtocol & SP_PROT_SERVERS) && (pContext->fCertReq == FALSE))
    {
        // We're a server and the client just sent us an
        // unexpected certificate message.
        SP_RETURN(SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG));
    }

    pcert = (CERT *)pb;

    if(cb < CB_SSL3_CERT_VECTOR + sizeof(SHSH))
    {
         SP_RETURN(SP_LOG_RESULT(PCT_INT_INCOMPLETE_MSG));
    }
    dwSize = ((INT)pcert->bcb24 << 16) +
             ((INT)pcert->bcbMSB << 8) +
             (INT)pcert->bcbLSB;

    cbCert = COMBINEBYTES(pcert->bcbMSBClist, pcert->bcbLSBClist);
    cbCert |= (pcert->bcbClist24 << 16);

    if(dwSize != cbCert + CB_SSL3_CERT_VECTOR)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG));
    }

    if(dwSize + sizeof(SHSH) > cb)
    {
         SP_RETURN(SP_LOG_RESULT(PCT_INT_INCOMPLETE_MSG));
    }

    if(cbCert == 0)
    {
        if(pContext->RipeZombie->fProtocol & SP_PROT_CLIENTS)
        {
            // Error out if the server certificate is zero length
            SP_RETURN(SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG));
        }
        else
        {
            DebugLog((DEB_WARN, "Zero length client certificate received.\n"));
        }
    }

    if(cbCert != 0) //for tls1, it could be zero length.
    {
        // The certificate type is derived from the key exchange method
        // but most currently use X509_ASN_ENCODING
        pctRet = SPLoadCertificate( SP_PROT_SSL3_CLIENT,
                                X509_ASN_ENCODING,
                                (PUCHAR)&pcert->bcbCert24,
                                cbCert,
                                &pContext->RipeZombie->pRemoteCert);

        if(PCT_ERR_OK != pctRet)
        {
            SP_RETURN(pctRet);
        }
        if(pContext->RipeZombie->pRemotePublic != NULL)
        {
            SPExternalFree(pContext->RipeZombie->pRemotePublic);
            pContext->RipeZombie->pRemotePublic = NULL;
        }

        pctRet = SPPublicKeyFromCert(pContext->RipeZombie->pRemoteCert,
                                     &pContext->RipeZombie->pRemotePublic,
                                     NULL);

        if(PCT_ERR_OK != pctRet)
        {
            SP_RETURN(pctRet);
        }
    }

    SP_RETURN(pctRet);
}


/*
***************************************************************************
* SPDigestSrvKeyX
* Digest the Server key  exhcnage message.
* this function encrypts the Pre-master secret with the public-key from this
* message
****************************************************************************
*/

SP_STATUS SPDigestSrvKeyX(
    PSPContext  pContext,
    PUCHAR pbServerExchangeValue,
    DWORD cbServerExchangeValue)
{
    SP_STATUS pctRet;

    if((pContext->pKeyExchInfo == NULL) || ((pContext->pKeyExchInfo->fProtocol & SP_PROT_SSL3TLS1_CLIENTS) == 0))
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    SP_ASSERT(NULL == pContext->pbEncryptedKey);

    pctRet = pContext->pKeyExchInfo->System->GenerateClientExchangeValue(
                    pContext,
                    pbServerExchangeValue,
                    cbServerExchangeValue,
                    NULL,
                    NULL,
                    NULL,  
                    &pContext->cbEncryptedKey);

    if(pctRet != PCT_ERR_OK)
    {
        return pctRet;
    }

    pContext->pbEncryptedKey = SPExternalAlloc(pContext->cbEncryptedKey);
    if(pContext->pbEncryptedKey == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }

    pctRet = pContext->pKeyExchInfo->System->GenerateClientExchangeValue(
                    pContext,
                    pbServerExchangeValue,
                    cbServerExchangeValue,
                    NULL,
                    NULL,
                    pContext->pbEncryptedKey,
                    &pContext->cbEncryptedKey);

    return pctRet;
}


//+---------------------------------------------------------------------------
//
//  Function:   Ssl3CheckForExistingCred
//
//  Synopsis:   Choose client certificate. Use one of the certificates
//              attached to the credential handle if possible. If the 
//              credential handle is anonymous, then attempt to create
//              a default credential.
//
//  Notes:      This routine is called by the client-side only.
//              
//  Returns:    PCT_ERR_OK      
//                  The function completed successfully. The
//                  pContext->pActiveClientCred field has been updated to
//                  point at a suitable client credential.
//
//              SEC_E_INCOMPLETE_CREDENTIALS
//                  No suitable certificate has been found. Notify the
//                  application.
//
//              SEC_I_INCOMPLETE_CREDENTIALS
//                  No suitable certificate has been found. Attempt an
//                  anonymous connection. 
//
//              <other>
//                  Fatal error.
//
//----------------------------------------------------------------------------
SP_STATUS
Ssl3CheckForExistingCred(PSPContext pContext)
{
    SP_STATUS pctRet;

    //
    // Examine the certificates attached to the credential group and see
    // if any of them are suitable.
    //

    if(pContext->pCredGroup->pCredList)
    {
        DWORD i, j;

        for(i = 0; i < pContext->cSsl3ClientCertTypes; i++)
        {
            for(j = 0; j < g_cCertTypes; j++)
            {
                if(pContext->Ssl3ClientCertTypes[i] != g_CertTypes[j].dwCertType)
                {
                    continue;
                }

                pctRet = SPPickClientCertificate(
                                pContext,
                                g_CertTypes[j].dwExchSpec);
                if(pctRet == PCT_ERR_OK)
                {
                    // We found one.
                    DebugLog((DEB_TRACE, "Application provided suitable client certificate.\n"));

                    return PCT_ERR_OK;
                }
            }
        }

        // The credential group contained one or more certificates,
        // but none were suitable. Don't even try to find a default
        // certificate in this situation.
        goto error;
    }


    //
    // Attempt to acquire a default credential.
    //

    if(pContext->pCredGroup->dwFlags & CRED_FLAG_NO_DEFAULT_CREDS)
    {
        // Look in credential manager only.
        pctRet = AcquireDefaultClientCredential(pContext, TRUE);
    }
    else
    {
        // Look in both credential manager and MY certificate store.
        pctRet = AcquireDefaultClientCredential(pContext, FALSE);
    }

    if(pctRet == PCT_ERR_OK)
    {
        DebugLog((DEB_TRACE, "Default client certificate acquired.\n"));

        return PCT_ERR_OK;
    }


error:

    if(pContext->Flags & CONTEXT_FLAG_NO_INCOMPLETE_CRED_MSG)
    {
        return SP_LOG_RESULT(SEC_I_INCOMPLETE_CREDENTIALS);
    }
    else
    {
        return SP_LOG_RESULT(SEC_E_INCOMPLETE_CREDENTIALS);
    }
}


/*
***************************************************************************
* SPGenerateSHResponse
* This is the main function which outgoing message to the wire
****************************************************************************
*/

SP_STATUS
SPGenerateSHResponse(PSPContext  pContext, PSPBuffer pCommOutput)
{
    PBYTE pbMessage = NULL;
    DWORD cbMessage;
    PBYTE pbHandshake = NULL;
    DWORD cbHandshake;
    PBYTE pbClientCert = NULL;
    DWORD cbClientCert = 0;
    DWORD cbDataOut;
    SP_STATUS pctRet;
    BOOL  fAllocated = FALSE;
    BOOL fClientAuth;
    PSessCacheItem pZombie;

    SP_BEGIN("SPGenerateSHResponse");

    if((pContext == NULL) ||
       (pCommOutput == NULL) ||
       (pContext->RipeZombie == NULL) ||
       (pContext->pKeyExchInfo == NULL))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    fClientAuth = pContext->fCertReq;
    pZombie = pContext->RipeZombie;


    //
    // Estimate size of the ClientKeyExchange message group.
    //

    cbMessage = 0;

    if(fClientAuth)
    {
        if(pContext->pActiveClientCred != NULL)
        {
            DWORD cbCertVerify;

            pbClientCert = pContext->pActiveClientCred->pbSsl3SerializedChain;
            cbClientCert = pContext->pActiveClientCred->cbSsl3SerializedChain;

            if(cbClientCert > 0x3fff) //Separate Wrappers after this
            {                          // is a BIG UNDONE...
                pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
                goto cleanup;
            }

            cbMessage += sizeof(SHSH) +             // ClientCertificate
                         CB_SSL3_CERT_VECTOR +
                         cbClientCert;


            pctRet = BuildCertVerify(pContext,
                                     NULL,
                                     &cbCertVerify);
            if(pctRet != PCT_ERR_OK)
            {
                goto cleanup;
            }

            cbMessage += cbCertVerify;              // CertificateVerify
        }
        else
        {
            LogNoClientCertFoundEvent();

            //for ssl3, it's no_certificate alert
            if((pContext->RipeZombie->fProtocol & SP_PROT_SSL3))
            {
                cbMessage += sizeof(SWRAP) +            // no_certificate Alert
                         CB_SSL3_ALERT_ONLY +
                         SP_MAX_DIGEST_LEN +
                         SP_MAX_BLOCKCIPHER_SIZE;
            }
            // for tls1, it's certificate of zero length.
            else
            {
                cbMessage += sizeof(SHSH) + CB_SSL3_CERT_VECTOR;
            }
        }
    }

    cbMessage += sizeof(SWRAP) +                    // ClientKeyExchange
                 sizeof(SHSH) +
                 pContext->cbEncryptedKey +
                 SP_MAX_DIGEST_LEN +
                 SP_MAX_BLOCKCIPHER_SIZE;

    cbMessage += sizeof(SWRAP) +                    // ChangeCipherSpec
                 CB_SSL3_CHANGE_CIPHER_SPEC_ONLY +
                 SP_MAX_DIGEST_LEN +
                 SP_MAX_BLOCKCIPHER_SIZE;

    cbMessage += sizeof(SWRAP) +                    // Finished
                 CB_SSL3_FINISHED_MSG_ONLY +
                 SP_MAX_DIGEST_LEN +
                 SP_MAX_BLOCKCIPHER_SIZE;

    //
    // Allocate memory for the ClientKeyExchange message group.
    //

    if(pCommOutput->pvBuffer)
    {
        // Application has allocated memory.
        if(pCommOutput->cbBuffer < cbMessage)
        {
            pCommOutput->cbData = cbMessage;
            pctRet = SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
            goto cleanup;
        }
        fAllocated = TRUE;
    }
    else
    {
        // Schannel is to allocate memory.
        pCommOutput->cbBuffer = cbMessage;
        pCommOutput->pvBuffer = SPExternalAlloc(cbMessage);
        if(pCommOutput->pvBuffer == NULL)
        {
            pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }
    }
    pCommOutput->cbData = 0;


    // Build no_certificate alert (at the end of the output buffer).
    if((pContext->RipeZombie->fProtocol & SP_PROT_SSL3) && fClientAuth && pbClientCert == NULL)
    {
        pbMessage = (PBYTE)pCommOutput->pvBuffer + pCommOutput->cbData;

        // Build alert message.
        BuildAlertMessage(pbMessage,
                          SSL3_ALERT_WARNING,
                          SSL3_ALERT_NO_CERTIFICATE);

        // Build record header and encrypt message.
        pctRet = SPSetWrap(pContext,
                pbMessage,
                SSL3_CT_ALERT,
                CB_SSL3_ALERT_ONLY,
                TRUE,
                &cbDataOut);

        if(pctRet != PCT_ERR_OK)
        {
            SP_LOG_RESULT(pctRet);
            goto cleanup;
        }

        // Update buffer length.
        pCommOutput->cbData += cbDataOut;

        SP_ASSERT(pCommOutput->cbData <= pCommOutput->cbBuffer);
    }


    // Keep pointer to record structure. This will represent the
    // ClientCertificate, ClientKeyExchange, and CertificateVerify messages.
    pbMessage = (PBYTE)pCommOutput->pvBuffer + pCommOutput->cbData;
    cbMessage = 0;

    pbHandshake = pbMessage + sizeof(SWRAP);


    // Build ClientCertificate message.
    if((pContext->RipeZombie->fProtocol & SP_PROT_TLS1) && fClientAuth && pbClientCert == NULL)
    {
        //Build a zero length certificate message for TLS1
        pbMessage = (PBYTE)pCommOutput->pvBuffer + pCommOutput->cbData;

        ((CERT *)pbHandshake)->bcbClist24  = 0;
        ((CERT *)pbHandshake)->bcbMSBClist = 0;
        ((CERT *)pbHandshake)->bcbLSBClist = 0;

        cbHandshake = sizeof(SHSH) + CB_SSL3_CERT_VECTOR;

        // Fill in Handshake structure.
        SetHandshake(pbHandshake,
                     SSL3_HS_CERTIFICATE,
                     NULL,
                     CB_SSL3_CERT_VECTOR);

        // Update handshake hash objects.
        pctRet = UpdateHandshakeHash(pContext,
                                     pbHandshake,
                                     cbHandshake,
                                     FALSE);
        if(pctRet != PCT_ERR_OK)
        {
            goto cleanup;
        }

        pbHandshake += cbHandshake;
        cbMessage += cbHandshake;
    }

    if(fClientAuth && pbClientCert != NULL)
    {
        memcpy(&((CERT *)pbHandshake)->bcbCert24,
               pbClientCert,
               cbClientCert);

        ((CERT *)pbHandshake)->bcbClist24  = MS24BOF(cbClientCert);
        ((CERT *)pbHandshake)->bcbMSBClist = MSBOF(cbClientCert);
        ((CERT *)pbHandshake)->bcbLSBClist = LSBOF(cbClientCert);

        cbHandshake = sizeof(SHSH) + CB_SSL3_CERT_VECTOR + cbClientCert;

        // Fill in Handshake structure.
        SetHandshake(pbHandshake,
                     SSL3_HS_CERTIFICATE,
                     NULL,
                     cbHandshake - sizeof(SHSH));

        // Update handshake hash objects.
        pctRet = UpdateHandshakeHash(pContext,
                                     pbHandshake,
                                     cbHandshake,
                                     FALSE);
        if(pctRet != PCT_ERR_OK)
        {
            goto cleanup;
        }

        pbHandshake += cbHandshake;
        cbMessage += cbHandshake;
    }

    // Build ClientKeyExchange message.
    {
        SetHandshake(pbHandshake,
                     SSL3_HS_CLIENT_KEY_EXCHANGE,
                     pContext->pbEncryptedKey,
                     pContext->cbEncryptedKey);

        cbHandshake = sizeof(SHSH) + pContext->cbEncryptedKey;

        SPExternalFree(pContext->pbEncryptedKey);
        pContext->pbEncryptedKey = NULL;
        pContext->cbEncryptedKey = 0;

        // Update handshake hash objects.
        pctRet = UpdateHandshakeHash(pContext,
                                     pbHandshake,
                                     cbHandshake,
                                     FALSE);
        if(pctRet != PCT_ERR_OK)
        {
            goto cleanup;
        }

        pbHandshake += cbHandshake;
        cbMessage += cbHandshake;
    }

    // Build CertificateVerify message.
    if(fClientAuth && pbClientCert != NULL)
    {
        pctRet = BuildCertVerify(pContext, pbHandshake, &cbHandshake);
        if(pctRet != PCT_ERR_OK)
        {
            SP_LOG_RESULT(pctRet);
            goto cleanup;
        }

        // Update handshake hash objects.
        pctRet = UpdateHandshakeHash(pContext,
                                     pbHandshake,
                                     cbHandshake,
                                     FALSE);
        if(pctRet != PCT_ERR_OK)
        {
            goto cleanup;
        }

        pbHandshake += cbHandshake;
        cbMessage += cbHandshake;
    }

    // Add record header and encrypt handshake messages.
    pctRet = SPSetWrap(pContext,
            pbMessage,
            SSL3_CT_HANDSHAKE,
            cbMessage,
            TRUE,
            &cbDataOut);

    if(pctRet != PCT_ERR_OK)
    {
        SP_LOG_RESULT(pctRet);
        goto cleanup;
    }

    // Update buffer length.
    pCommOutput->cbData += cbDataOut;

    SP_ASSERT(pCommOutput->cbData <= pCommOutput->cbBuffer);


    // Build the ChangeCipherSpec and Finished messages.
    {
        pctRet = BuildCCSAndFinishMessage(pContext, pCommOutput, TRUE);
        if(pctRet != PCT_ERR_OK)
        {
            SP_LOG_RESULT(pctRet);
            goto cleanup;
        }
    }

    // Advance state machine.
    pContext->State = SSL3_STATE_CLIENT_FINISH;

    pctRet = PCT_ERR_OK;

cleanup:

    SP_RETURN(pctRet);
}

SP_STATUS
SPGenerateCloseNotify(
    PSPContext  pContext,
    PSPBuffer   pCommOutput)
{
    PBYTE pbMessage = NULL;
    DWORD cbMessage;
    DWORD cbDataOut;
    SP_STATUS pctRet;

    SP_BEGIN("SPGenerateCloseNotify");

    if((pContext == NULL) ||
       (pCommOutput == NULL))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    //
    // Estimate size of the message.
    //

    cbMessage = sizeof(SWRAP) +
                CB_SSL3_ALERT_ONLY +
                SP_MAX_DIGEST_LEN +
                SP_MAX_BLOCKCIPHER_SIZE;


    //
    // Allocate memory for the message.
    //

    if(pCommOutput->pvBuffer)
    {
        // Application has allocated memory.
        if(pCommOutput->cbBuffer < cbMessage)
        {
            pCommOutput->cbData = cbMessage;
            return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
        }
    }
    else
    {
        // Schannel is to allocate memory.
        pCommOutput->cbBuffer = cbMessage;
        pCommOutput->pvBuffer = SPExternalAlloc(cbMessage);
        if(pCommOutput->pvBuffer == NULL)
        {
            SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
        }
    }
    pCommOutput->cbData = 0;

    //
    // Build alert message.
    //

    pbMessage = pCommOutput->pvBuffer;

    // Build alert message.
    BuildAlertMessage(pbMessage,
                      SSL3_ALERT_WARNING,
                      SSL3_ALERT_CLOSE_NOTIFY);

    // Build record header and encrypt message.
    pctRet = SPSetWrap( pContext,
                        pbMessage,
                        SSL3_CT_ALERT,
                        CB_SSL3_ALERT_ONLY,
                        TRUE,
                        &cbDataOut);

    if(pctRet != PCT_ERR_OK)
    {
        SP_RETURN(SP_LOG_RESULT(pctRet));
    }

    // Update buffer length.
    pCommOutput->cbData += cbDataOut;

    SP_ASSERT(pCommOutput->cbData <= pCommOutput->cbBuffer);

    pContext->State = SP_STATE_SHUTDOWN;

    SP_RETURN(PCT_ERR_OK);
}


/*
***************************************************************************
* SPProcessMessage
* This is the main function which parses and stores the incoming messages
* from the wire.
****************************************************************************
*/

SP_STATUS 
SPProcessMessage(
    PSPContext pContext,
    BYTE bContentType,
    PBYTE pbMsg,
    DWORD cbMsg)
{
    UCHAR chMsgType = 0;
    SP_STATUS pctRet = PCT_ERR_ILLEGAL_MESSAGE;
    DWORD dwState = pContext->State;

//     enum {
//         change_cipher_spec(20), alert(21), handshake(22),
//         application_data(23), (255)
//     } ContentType;


    switch(bContentType)
    {
        case SSL3_CT_ALERT:
            DebugLog((DEB_TRACE, "Alert Message:\n"));

            pctRet = ParseAlertMessage(pContext,
                                        pbMsg,
                                        cbMsg);

            break;


        case SSL3_CT_CHANGE_CIPHER_SPEC:
            DebugLog((DEB_TRACE, "Change Cipher Spec:\n"));
            if(SSL3_STATE_RESTART_CCS == dwState ||
               SSL3_STATE_CLIENT_FINISH == dwState)
            {
                pctRet = Ssl3HandleCCS(
                                    pContext,
                                    pbMsg,
                                    cbMsg);

                if (PCT_ERR_OK == pctRet)
                {
                    if(SSL3_STATE_RESTART_CCS == dwState)
                        pContext->State = SSL3_STATE_RESTART_SERVER_FINISH;
                }
            }
            else if(SSL3_STATE_CLIENT_KEY_XCHANGE == dwState ||
                    SSL3_STATE_CERT_VERIFY == dwState ||
                    SSL3_STATE_RESTART_SER_HELLO == dwState)
            {
                pctRet = Ssl3HandleCCS(
                                    pContext,
                                    pbMsg,
                                    cbMsg);

                if (PCT_ERR_OK == pctRet)
                {
                    if(SSL3_STATE_RESTART_SER_HELLO == dwState)
                    {
                          pContext->State = SSL3_STATE_SER_RESTART_CHANGE_CIPHER_SPEC;
                    }
                }

            }

            else
            {
                pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
            }
            break;


        case UNI_STATE_RECVD_UNIHELLO:
            {
                DebugLog((DEB_TRACE, "Unified Hello:\n"));

                pctRet = Ssl3SrvHandleUniHello(pContext, pbMsg, cbMsg);
                if (SP_FATAL(pctRet))
                {
                    pContext->State = PCT1_STATE_ERROR;
                }
            }
            break;


        case SSL3_CT_HANDSHAKE:
            {
                DWORD dwcb;

                if(pContext->State == SP_STATE_CONNECTED)
                {
                    //We may be  getting a REDO message
                    DebugLog((DEB_WARN, "May be a ReDO"));
                    pContext->State = SSL3_STATE_CLIENT_HELLO;
                }


                //Since multiple handshake can be put into on Record
                //layer- we have to do this loop-here.
                do
                {
                    if(cbMsg < sizeof(SHSH))
                        break;
                    dwcb = ((INT)pbMsg[1] << 16) + ((INT)pbMsg[2] << 8) + (INT)pbMsg[3];
                    if(sizeof(SHSH) + dwcb > cbMsg)
                        break;
                    pctRet = SPProcessHandshake(pContext, pbMsg, dwcb + sizeof(SHSH));
                    CHECK_PCT_RET_BREAK(pctRet);
                    cbMsg -= dwcb + sizeof(SHSH);
                    pbMsg += dwcb + sizeof(SHSH);
                } while(cbMsg > 0);
            }

            break;

        default:
            DebugLog((DEB_WARN, "Error in protocol, dwState is %lx\n", dwState));
            pContext->State = PCT1_STATE_ERROR;
            break;
    }
    if (pctRet & PCT_INT_DROP_CONNECTION)
    {
        pContext->State &= ~ SP_STATE_CONNECTED;
    }

    return(pctRet);
}


/*
***************************************************************************
* Helper function to make connected state for ssl3
****************************************************************************
*/
void Ssl3StateConnected(PSPContext pContext)
{
    pContext->State = SP_STATE_CONNECTED;
    pContext->DecryptHandler = Ssl3DecryptHandler;
    pContext->Encrypt = Ssl3EncryptMessage;
    pContext->Decrypt = Ssl3DecryptMessage;
    pContext->GetHeaderSize = Ssl3GetHeaderSize;
    SPContextClean(pContext);
}

/*
***************************************************************************
* SPProcessHandshake, Process all the handshake messages.
****************************************************************************
*/

SP_STATUS SPProcessHandshake(
    PSPContext  pContext,
    PBYTE       pb,
    DWORD       dwcb)
{
    SP_STATUS   pctRet;
    SHSH *      pshsh;

    //
    // char HandshakeType;
    // char Length24
    // char Length16
    // char Length08
    // <actual handshake message>
    //

    SP_BEGIN("SPProcessHandshake");

    if(pContext == NULL || pb == NULL)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    if(dwcb < sizeof(SHSH))
    {
        SP_RETURN(PCT_INT_INCOMPLETE_MSG);
    }

    pshsh = (SHSH *)pb;

    DebugLog((DEB_TRACE, "Protocol:%x, Message:%x, State:%x\n",
              pContext->dwProtocol,
              pshsh->typHS,
              pContext->State));


    if(pContext->dwProtocol & SP_PROT_CLIENTS)
    {
        //
        // Handle client-side handshake states.
        //

        switch((pshsh->typHS << 16) | (pContext->State & 0xffff) )
        {
            case  (SSL3_HS_SERVER_HELLO << 16) | SSL3_STATE_CLIENT_HELLO:
            case  (SSL3_HS_SERVER_HELLO << 16) | UNI_STATE_CLIENT_HELLO:
            {
                BOOL fRestart;

                DebugLog((DEB_TRACE, "Server Hello:\n"));

                pctRet = SPDigestServerHello(pContext, (PUCHAR) pb, dwcb, &fRestart);
                if(PCT_ERR_OK != pctRet)
                {
                    SP_LOG_RESULT(pctRet);
                    break;
                }

                if(fRestart)
                {
                    pContext->State = SSL3_STATE_RESTART_CCS;
                }
                else
                {
                    pContext->State = SSL3_STATE_SERVER_HELLO ;
                }
                pContext->fCertReq = FALSE;

                break;
            }

            case (SSL3_HS_CERTIFICATE << 16) | SSL3_STATE_SERVER_HELLO:
            {
                DebugLog((DEB_TRACE, "Server Certificate:\n"));

                // Process server Certificate message.
                pctRet = SpDigestRemoteCertificate(pContext, pb, dwcb);
                if(pctRet != PCT_ERR_OK)
                {
                    SP_LOG_RESULT(pctRet);
                    break;
                }

                // Automatically validate server certificate if appropriate
                // context flag is set.
                pctRet = AutoVerifyServerCertificate(pContext);
                if(pctRet != PCT_ERR_OK)
                {
                    SP_LOG_RESULT(pctRet);
                    break;
                }

                pContext->State = SSL3_STATE_SERVER_CERTIFICATE ;
                break;

            }

            case (SSL3_HS_SERVER_KEY_EXCHANGE <<  16) | SSL3_STATE_SERVER_CERTIFICATE:
            {
                DebugLog((DEB_TRACE, "Key Exchange:\n"));

                if((pContext->dwRequestedCF & pContext->RipeZombie->dwCF) != (pContext->dwRequestedCF))
                {
                    if((pContext->dwRequestedCF & CF_FASTSGC) != 0)
                    {
                        pContext->State = SSL3_HS_SERVER_KEY_EXCHANGE;
                        pctRet = PCT_ERR_OK;
                        break;
                    }
                }

                // Store the server key exchange value in the context. This
                // will be processed later when the ServerHelloDone message
                // is received. This is necessary because Fortezza needs to
                // process the CertificateRequest message before building the
                // ClientKeyExchange value.
                pContext->cbServerKeyExchange = dwcb - sizeof(SHSH);
                pContext->pbServerKeyExchange = SPExternalAlloc(pContext->cbServerKeyExchange);
                if(NULL == pContext->pbServerKeyExchange)
                {
                    SP_RETURN(SEC_E_INSUFFICIENT_MEMORY);
                }
                CopyMemory(pContext->pbServerKeyExchange,
                           pb + sizeof(SHSH),
                           pContext->cbServerKeyExchange);

                pContext->State = SSL3_HS_SERVER_KEY_EXCHANGE ;
                pctRet = PCT_ERR_OK;
                break;
            }

            case (SSL3_HS_CERTIFICATE_REQUEST << 16)| SSL3_HS_SERVER_KEY_EXCHANGE:
            case (SSL3_HS_CERTIFICATE_REQUEST << 16)| SSL3_STATE_SERVER_CERTIFICATE:
            {
                DebugLog((DEB_TRACE, "Certificate Request:\n"));

                if((pContext->dwRequestedCF & pContext->RipeZombie->dwCF) != (pContext->dwRequestedCF))
                {
                    if((pContext->dwRequestedCF & CF_FASTSGC) != 0)
                    {
                        pContext->State = SSL3_STATE_SERVER_CERTREQ;
                        pctRet = PCT_ERR_OK;
                        break;
                    }
                }

                pctRet = ParseCertificateRequest(pContext, pb, dwcb);
                CHECK_PCT_RET_BREAK(pctRet);

                pctRet = Ssl3CheckForExistingCred(pContext);

                if(pctRet == SEC_E_INCOMPLETE_CREDENTIALS)
                {
                    pContext->fInsufficientCred = TRUE;

                    // Process all the messages and then return the warning...
                    pctRet = PCT_ERR_OK;
                }
                if(pctRet == SEC_I_INCOMPLETE_CREDENTIALS)
                {
                    // we didn't have a cert, so we proceed, expecting
                    // to send a no cert alert
                    pctRet = PCT_ERR_OK;
                }
                CHECK_PCT_RET_BREAK(pctRet);

                pContext->fCertReq = TRUE;
                pContext->State = SSL3_STATE_SERVER_CERTREQ ;
                break;
            }

            case (SSL3_HS_SERVER_HELLO_DONE << 16) | SSL3_HS_SERVER_KEY_EXCHANGE:
            case (SSL3_HS_SERVER_HELLO_DONE << 16) | SSL3_STATE_SERVER_CERTIFICATE:
            case (SSL3_HS_SERVER_HELLO_DONE << 16) | SSL3_STATE_SERVER_CERTREQ:
            {
                DebugLog((DEB_TRACE, "Server Hello Done:\n"));

                if(dwcb > sizeof(SHSH))
                {
                    pctRet = SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
                    break;
                }

                if((pContext->dwRequestedCF & pContext->RipeZombie->dwCF) != (pContext->dwRequestedCF))
                {
                    if((pContext->dwRequestedCF & CF_FASTSGC) != 0)
                    {
                        pContext->State = SSL3_STATE_GEN_HELLO_REQUEST;
                        pContext->RipeZombie->dwCF = pContext->dwRequestedCF;
                        pctRet = PCT_ERR_OK;
                        SPContextClean(pContext);
                        break;
                    }
                }

                pctRet = SPDigestSrvKeyX(pContext,
                                         pContext->pbServerKeyExchange,
                                         pContext->cbServerKeyExchange);

                CHECK_PCT_RET_BREAK(pctRet);
                if(pContext->pbServerKeyExchange)
                {
                    SPExternalFree(pContext->pbServerKeyExchange);
                    pContext->pbServerKeyExchange = NULL;
                }

                pContext->State = SSL3_STATE_GEN_SERVER_HELLORESP;

                if(TRUE == pContext->fInsufficientCred)
                {
                    pctRet = SEC_I_INCOMPLETE_CREDENTIALS;
                }
                else
                {
                    pctRet = PCT_ERR_OK;
                }
                break;
            }

            case (SSL3_HS_FINISHED << 16) | SSL3_STATE_RESTART_SERVER_FINISH:
                DebugLog((DEB_TRACE, "ServerFinished (reconnect):\n"));

                pctRet = Ssl3HandleFinish(pContext, pb, TRUE /*fclient*/);
                if(PCT_ERR_OK != pctRet)
                {
                    break;
                }

                pContext->State = SSL3_STATE_GEN_CLIENT_FINISH;
                
                break;

            case (SSL3_HS_FINISHED << 16) | SSL3_STATE_CHANGE_CIPHER_SPEC_CLIENT:
                DebugLog((DEB_TRACE, "ServerFinished (full):\n"));

                pctRet = Ssl3HandleFinish(pContext, pb, TRUE /*fclient*/);
                if(PCT_ERR_OK != pctRet)
                {
                    break;
                }

                // Initiate SGC renegotiation if appropriate.
                if((pContext->dwRequestedCF & pContext->RipeZombie->dwCF) != (pContext->dwRequestedCF))
                {
                    if((pContext->dwRequestedCF & CF_FASTSGC) == 0)
                    {
                        SPContextClean(pContext);
                        pContext->State = SSL3_STATE_GEN_HELLO_REQUEST;
                        pContext->RipeZombie->dwCF = pContext->dwRequestedCF;
                        pctRet = PCT_ERR_OK;
                        break;
                    }
                }

                Ssl3StateConnected(pContext);

                // We add to cache because this is where we are finishing
                // a normal connect.
                SPCacheAdd(pContext);

                break;

            default:
                DebugLog((DEB_TRACE, "***********ILLEGAL ********\n"));
                if(pContext->RipeZombie->fProtocol & SP_PROT_TLS1)
                {
                    SetTls1Alert(pContext, TLS1_ALERT_FATAL, TLS1_ALERT_UNEXPECTED_MESSAGE);
                }
                pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
        }
    }
    else
    {

        //
        // Handle server-side handshake states.
        //

        switch((pshsh->typHS << 16) | (pContext->State & 0xffff) )
        {
            case (SSL3_HS_CLIENT_HELLO << 16) | SSL3_STATE_RENEGOTIATE:
                DebugLog((DEB_TRACE, "ClientHello After REDO:\n"));

                // We need to do a full handshake, so lose the cache entry.
                SPCacheDereference(pContext->RipeZombie);
                pContext->RipeZombie = NULL;

                pctRet = SPSsl3SrvHandleClientHello(pContext, pb, FALSE);
                pContext->Flags &= ~CONTEXT_FLAG_MAPPED;
                if(PCT_ERR_OK == pctRet)
                {
                    pContext->State = SSL3_STATE_GEN_REDO;
                }
                break;

            case (SSL3_HS_CLIENT_HELLO << 16) | SSL2_STATE_SERVER_HELLO:
                DebugLog((DEB_TRACE, "ClientHello after fast SGC accepted:\n"));

                // We need to do a full handshake, so lose the cache entry.
                SPCacheDereference(pContext->RipeZombie);
                pContext->RipeZombie = NULL;

                pctRet = SPSsl3SrvHandleClientHello(pContext, pb, FALSE);
                break;

            case (SSL3_HS_CLIENT_HELLO << 16):
                DebugLog((DEB_TRACE, "ClientHello:\n"));
                pctRet = SPSsl3SrvHandleClientHello(pContext, pb, TRUE);
                break;

            case (SSL3_HS_CLIENT_KEY_EXCHANGE << 16) | SSL2_STATE_SERVER_HELLO:
            case (SSL3_HS_CLIENT_KEY_EXCHANGE << 16) | SSL3_STATE_NO_CERT_ALERT:
            case (SSL3_HS_CLIENT_KEY_EXCHANGE << 16) | SSL2_STATE_CLIENT_CERTIFICATE:
                DebugLog((DEB_TRACE, "Client Key Exchange:\n"));
                pctRet = ParseKeyExchgMsg(pContext, pb) ;
                CHECK_PCT_RET_BREAK(pctRet);

                if(PCT_ERR_OK == pctRet)
                    pContext->State = SSL3_STATE_CLIENT_KEY_XCHANGE;
                if(!pContext->fCertReq)
                    pContext->State = SSL3_STATE_CLIENT_KEY_XCHANGE;

                break;

            case ( SSL3_HS_CERTIFICATE << 16) | SSL2_STATE_SERVER_HELLO:
                 DebugLog((DEB_TRACE, "Client Certificate:\n"));

                 pctRet = SpDigestRemoteCertificate(pContext, pb, dwcb);
                 CHECK_PCT_RET_BREAK(pctRet);
                 if(PCT_ERR_OK == pctRet)
                    pContext->State = SSL2_STATE_CLIENT_CERTIFICATE ;
                 break;

            case (SSL3_HS_CERTIFICATE_VERIFY << 16) | SSL3_STATE_CLIENT_KEY_XCHANGE:
                DebugLog((DEB_TRACE, "Certificate Verify :\n"));

                pctRet = HandleCertVerify(pContext, pb, dwcb);
                if(pctRet != PCT_ERR_OK)
                {
                    break;
                }

                pctRet = SPContextDoMapping(pContext);
                pContext->State = SSL3_STATE_CERT_VERIFY;
                break;

            case (SSL3_HS_FINISHED << 16) | SSL3_STATE_SER_RESTART_CHANGE_CIPHER_SPEC:
                DebugLog((DEB_TRACE, "Finished(client) Restart :\n"));

                pctRet = Ssl3HandleFinish(pContext, pb, FALSE /*fclient*/);
                if(pctRet != PCT_ERR_OK)
                {
                    break;
                }

                Ssl3StateConnected(pContext);

                break;

            case (SSL3_HS_FINISHED << 16) | SSL3_STATE_CHANGE_CIPHER_SPEC_SERVER:
                DebugLog((DEB_TRACE, "Finished(Client):\n"));
                pctRet = Ssl3HandleFinish(pContext, pb, FALSE /*fclient*/);
                if(PCT_ERR_OK == pctRet)
                {
                    pContext->State = SSL3_STATE_GEN_SERVER_FINISH;
                }
                break;

            default:
                DebugLog((DEB_TRACE, "***********ILLEGAL ********\n"));
                if(pContext->dwProtocol & SP_PROT_TLS1)
                {
                    SetTls1Alert(pContext, TLS1_ALERT_FATAL, TLS1_ALERT_UNEXPECTED_MESSAGE);
                }
                pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);

                break;
        }
    }

    if(pctRet == PCT_ERR_OK || pctRet == SEC_I_INCOMPLETE_CREDENTIALS)
    {
        if(pContext->cbClientHello == 0)
        {
            if(UpdateHandshakeHash(pContext, pb, dwcb, FALSE) != PCT_ERR_OK)
            {
                pctRet = PCT_INT_INTERNAL_ERROR;
            }
        }
    }

    SP_RETURN(pctRet);
}




/*
***************************************************************************
* SPGenerateResponse, All the messages are built from this function.
****************************************************************************
*/
SP_STATUS SPGenerateResponse(
    PSPContext pContext,
    PSPBuffer pCommOutput) //Out
{
    SP_STATUS pctRet = PCT_ERR_OK;

    DebugLog((DEB_TRACE, "**********Protocol***** %x\n", pContext->RipeZombie->fProtocol));
    switch(pContext->State)
    {
    case TLS1_STATE_ERROR:
        // TLS1 Alert message
        DebugLog((DEB_TRACE, "GEN TLS1 Alert Message:\n"));
        pctRet = SPBuildTlsAlertMessage(pContext, pCommOutput);
        pContext->State = SP_STATE_SHUTDOWN;
        break;

    case SP_STATE_SHUTDOWN_PENDING:
        DebugLog((DEB_TRACE, "GEN Close Notify:\n"));
        pctRet = SPGenerateCloseNotify(pContext, pCommOutput);
        break;

    case SP_STATE_SHUTDOWN:
        return PCT_INT_EXPIRED;

    case  SSL3_STATE_GEN_SERVER_HELLORESP:
        DebugLog((DEB_TRACE, "GEN Server Hello Response:\n"));
        pctRet = SPGenerateSHResponse(pContext, pCommOutput);
        break;

    case  SSL3_STATE_GEN_HELLO_REQUEST:
        DebugLog((DEB_TRACE, "GEN Hello Request:\n"));
         //Temp Disabling Reconnect during REDO
        if(!SPCacheClone(&pContext->RipeZombie))
        {
            pctRet = SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
            break;
        }
        if(pContext->RipeZombie->fProtocol == SP_PROT_SSL3_CLIENT)
        {
            pctRet =  GenerateSsl3ClientHello(pContext, pCommOutput);
        }
        else
        {
            pctRet =  GenerateTls1ClientHello(pContext, pCommOutput, SP_PROT_TLS1_CLIENT);
        }

        pContext->Flags &= ~CONTEXT_FLAG_MAPPED;

        pContext->State = SSL3_STATE_CLIENT_HELLO;

        break;

    case SSL3_STATE_GEN_CLIENT_FINISH:
        {
            DebugLog((DEB_TRACE, "GEN Client Finish:\n"));

            pctRet = SPBuildCCSAndFinish(pContext, pCommOutput);
            if(PCT_ERR_OK == pctRet)
            {
                Ssl3StateConnected(pContext);
            }
        }
        break;


    /*-------------------------------------SERVER SIDE------------------------------------*/


    case  SSL3_STATE_GEN_SERVER_FINISH:
        DebugLog((DEB_TRACE, "GEN Server Finish:\n"));
        pctRet = SPBuildCCSAndFinish(pContext, pCommOutput);
        /* Cache Session Here */
        if(pctRet == PCT_ERR_OK)
        {
            Ssl3StateConnected(pContext);
            SPCacheAdd(pContext);
        }
        break;

    case  SSL3_STATE_GEN_SERVER_HELLO:       // Generate the response
        DebugLog((DEB_TRACE, "GEN Server hello:\n"));
        pctRet = SPSsl3SrvGenServerHello(pContext, pCommOutput);
        break;

    case SSL3_STATE_GEN_SERVER_HELLO_RESTART:
        pctRet = SPSsl3SrvGenRestart(pContext, pCommOutput);
        break;

    case SP_STATE_CONNECTED:
        // We were called from a connected state, so the application
        // must be requesting a redo.
        DebugLog((DEB_TRACE, "GEN Hello Request:\n"));

        if(!(pContext->RipeZombie->fProtocol & SP_PROT_SERVERS))
        {
            DebugLog((DEB_ERROR, "Client-initiated redo not currently supported\n"));
            pctRet = PCT_ERR_ILLEGAL_MESSAGE;
            break;
        }

        // Build a HelloRequest message.
        pctRet = SPBuildHelloRequest(pContext, pCommOutput);
        break;

    case SSL3_STATE_GEN_REDO:
        DebugLog((DEB_TRACE, "GEN Server hello ( REDO ):\n"));
        // We processed a client hello from the decrypt handler,
        // so generate a server hello.
        pctRet = SPSsl3SrvGenServerHello(pContext, pCommOutput);
        break;

    default:
        break;
    }
    if (pctRet & PCT_INT_DROP_CONNECTION)
    {
        pContext->State &= ~ SP_STATE_CONNECTED;
    }

    return(pctRet);
}



/*
***************************************************************************
* FNoInputState Are we in a state  that all the inputs are handled and
* waiting for Response generation RETURN TRUE if yes
****************************************************************************
*/
BOOL FNoInputState(DWORD dwState)
{
    switch(dwState)
    {
        default:
            return(FALSE);

        case SSL3_STATE_GEN_HELLO_REQUEST:
        case SSL3_STATE_GEN_SERVER_HELLORESP:
        case SSL3_STATE_GEN_SERVER_FINISH:
        case SSL3_STATE_GEN_REDO:
        case SP_STATE_CONNECTED:
        case TLS1_STATE_ERROR:
        case SP_STATE_SHUTDOWN_PENDING:

            return(TRUE);
    }
}

/*
***************************************************************************
* SPBuildHelloRequest
*
* Build hello-request message, this is done, when server sees a GET and the
* GET object needs client-authentication.
* this may be needed when the server thinks that the session is for a long
* time or lots of bytes gon down the wire, to RENEGOTIATE the keys
****************************************************************************
*/

SP_STATUS
SPBuildHelloRequest(
    PSPContext pContext,
    PSPBuffer  pCommOutput)
{
    PBYTE pbMessage = NULL;
    DWORD cbMessage;
    PBYTE pbHandshake = NULL;
    DWORD cbHandshake;
    BOOL  fAllocated = FALSE;
    SP_STATUS pctRet;
    DWORD cbDataOut;

    // Estimate size of HelloRequest message.
    cbMessage = sizeof(SWRAP) +
                sizeof(SHSH) +
                SP_MAX_DIGEST_LEN +
                SP_MAX_BLOCKCIPHER_SIZE;

    if(pCommOutput->pvBuffer)
    {
        // Application has allocated memory.
        if(pCommOutput->cbBuffer < cbMessage)
        {
            pCommOutput->cbData = cbMessage;
            return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
        }
        fAllocated = TRUE;
    }
    else
    {
        // Schannel is to allocate memory.
        pCommOutput->cbBuffer = cbMessage;
        pCommOutput->pvBuffer = SPExternalAlloc(cbMessage);
        if(pCommOutput->pvBuffer == NULL)
        {
            return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        }
    }
    pCommOutput->cbData = 0;

    pbMessage = pCommOutput->pvBuffer;

    pbHandshake = pbMessage + sizeof(SWRAP);
    cbHandshake = sizeof(SHSH);

    // Fill in Handshake structure.
    SetHandshake(pbHandshake,
                 SSL3_HS_HELLO_REQUEST,
                 NULL,
                 0);

    // Update handshake hash objects.
    pctRet = UpdateHandshakeHash(pContext,
                                 pbHandshake,
                                 cbHandshake,
                                 FALSE);
    if(pctRet != PCT_ERR_OK)
    {
        return(pctRet);
    }

    // Add record header and encrypt handshake messages.
    pctRet = SPSetWrap(pContext,
            pbMessage,
            SSL3_CT_HANDSHAKE,
            cbHandshake,
            FALSE,
            &cbDataOut);

    // Update buffer length.
    pCommOutput->cbData += cbDataOut;

    SP_ASSERT(pCommOutput->cbData <= pCommOutput->cbBuffer);

    return pctRet;
}


/*
***************************************************************************

****************************************************************************
*/

SP_STATUS
SPSsl3SrvGenServerHello(
    PSPContext pContext,
    PSPBuffer  pCommOutput)
{
    SP_STATUS pctRet;
    PSPCredentialGroup pCred;
    BOOL  fAllocated = FALSE;

    PBYTE pbServerCert = NULL;
    DWORD cbServerCert = 0;

    PBYTE pbIssuerList = NULL;
    DWORD cbIssuerList = 0;

    PBYTE pbMessage = NULL;
    DWORD cbMessage;
    PBYTE pbHandshake = NULL;
    DWORD cbHandshake;
    DWORD cbDataOut;

    DWORD cbServerExchange;

    BOOL fClientAuth = ((pContext->Flags & CONTEXT_FLAG_MUTUAL_AUTH) != 0);

    if(pCommOutput == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    // Get pointer to server certificate chain.
    pCred  = pContext->RipeZombie->pServerCred;
    pbServerCert = pContext->RipeZombie->pActiveServerCred->pbSsl3SerializedChain;
    cbServerCert = pContext->RipeZombie->pActiveServerCred->cbSsl3SerializedChain;

    if(pbServerCert == NULL)
    {
        pctRet = SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
        goto cleanup;
    }

    //
    // Estimate size of the ServerHello message group, which includes the
    // ServerHello, ServerCertificate, ServerKeyExchange, CertificateRequest,
    // and ServerHelloDone messages.
    //

    cbMessage =  sizeof(SWRAP) +        // ServerHello (plus encryption goo)
                 sizeof(SSH) +
                 SP_MAX_DIGEST_LEN +
                 SP_MAX_BLOCKCIPHER_SIZE;

    cbMessage += sizeof(SHSH) +         // ServerCertificate
                 CB_SSL3_CERT_VECTOR +
                 cbServerCert;

    cbMessage += sizeof(SHSH);          // ServerHelloDone

    // Get pointer to key exchange system.

    if((pContext->pKeyExchInfo == NULL) || ((pContext->pKeyExchInfo->fProtocol & SP_PROT_SSL3TLS1_CLIENTS) == 0))
    {
        SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    pctRet = pContext->pKeyExchInfo->System->GenerateServerExchangeValue(
                        pContext,
                        NULL,
                        &cbServerExchange);
    if(pctRet != PCT_ERR_OK)
    {
        goto cleanup;
    }
    if(pContext->fExchKey)
    {
        cbMessage += sizeof(SHSH) + cbServerExchange;
    }

    // Add in length of CertificateRequest message.
    if(fClientAuth)
    {
        UpdateAndDuplicateIssuerList(pCred, &pbIssuerList, &cbIssuerList);

        cbMessage += sizeof(CERTREQ) + cbIssuerList;
    }


    pContext->fCertReq = fClientAuth;

    DebugLog((DEB_TRACE, "Server hello message %x\n", cbMessage));


    //
    // Allocate memory for the ServerHello message group.
    //

    if(pCommOutput->pvBuffer)
    {
        // Application has allocated memory.
        if(pCommOutput->cbBuffer < cbMessage)
        {
            pCommOutput->cbData = cbMessage;
            pctRet = SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
            goto cleanup;
        }
        fAllocated = TRUE;
    }
    else
    {
        // Schannel is to allocate memory.
        pCommOutput->cbBuffer = cbMessage;
        pCommOutput->pvBuffer = SPExternalAlloc(cbMessage);
        if(pCommOutput->pvBuffer == NULL)
        {
            pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }
    }
    pCommOutput->cbData = 0;

    // Keep pointer to record structure. This will represent all of the
    // handshake messages.
    pbMessage = (PBYTE)pCommOutput->pvBuffer + pCommOutput->cbData;
    cbMessage = 0;

    pbHandshake = pbMessage + sizeof(SWRAP);


    // Generate the session ID (actually previously generated)
    pContext->RipeZombie->cbSessionID = CB_SSL3_SESSION_ID;

    // Generate internal values to make server hello
    Ssl3GenerateRandom(pContext->rgbS3SRandom);

    // Build ServerHello
    Ssl3BuildServerHello(pContext, pbHandshake);
    pbHandshake += sizeof(SSH);
    cbMessage   += sizeof(SSH);

    // Build ServerCertificate
    {
        memcpy(&((CERT *)pbHandshake)->bcbCert24,
               pbServerCert,
               cbServerCert);

        ((CERT *)pbHandshake)->bcbClist24  = MS24BOF(cbServerCert);
        ((CERT *)pbHandshake)->bcbMSBClist = MSBOF(cbServerCert);
        ((CERT *)pbHandshake)->bcbLSBClist = LSBOF(cbServerCert);

        cbHandshake = sizeof(SHSH) + CB_SSL3_CERT_VECTOR + cbServerCert;

        // Fill in Handshake structure.
        SetHandshake(pbHandshake,
                     SSL3_HS_CERTIFICATE,
                     NULL,
                     cbHandshake - sizeof(SHSH));

        pbHandshake += cbHandshake;
        cbMessage   += cbHandshake;
    }

    // Build ServerKeyExchange.
    if(pContext->fExchKey)
    {
        pctRet = pContext->pKeyExchInfo->System->GenerateServerExchangeValue(
                            pContext,
                            pbHandshake + sizeof(SHSH),
                            &cbServerExchange);
        if(pctRet != PCT_ERR_OK)
        {
            SP_LOG_RESULT(pctRet);
            goto cleanup;
        }
        SetHandshake(pbHandshake,  SSL3_HS_SERVER_KEY_EXCHANGE, NULL,  (WORD)cbServerExchange);

        pbHandshake += sizeof(SHSH) + cbServerExchange;
        cbMessage   += sizeof(SHSH) + cbServerExchange;
    }

    // Build CertificateRequest.
    if(fClientAuth)
    {
        pctRet = Ssl3BuildCertificateRequest(pContext,
                                             pbIssuerList,
                                             cbIssuerList,
                                             pbHandshake,
                                             &cbHandshake);
        if(pctRet != PCT_ERR_OK)
        {
            SP_LOG_RESULT(pctRet);
            goto cleanup;
        }

        pbHandshake += cbHandshake;
        cbMessage   += cbHandshake;
    }

    // Build ServerHelloDone.
    {
        BuildServerHelloDone(pbHandshake, sizeof(SHSH));

        pbHandshake += sizeof(SHSH);
        cbMessage   += sizeof(SHSH);
    }

    // Initialize handshake hashes and hash ClientHello message. This
    // must be done _after_ the ServerKeyExchange message is built,
    // so that the correct CSP context is used.
    pctRet = UpdateHandshakeHash(pContext,
                                 pContext->pClientHello,
                                 pContext->cbClientHello,
                                 TRUE);
    SPExternalFree(pContext->pClientHello);
    pContext->pClientHello  = NULL;
    pContext->cbClientHello = 0;
    if(pctRet != PCT_ERR_OK)
    {
        goto cleanup;
    }

    // Update handshake hash objects.
    pctRet = UpdateHandshakeHash(pContext,
                        pbMessage + sizeof(SWRAP),
                        cbMessage,
                        FALSE);
    if(pctRet != PCT_ERR_OK)
    {
        goto cleanup;
    }

    // Add record header and encrypt handshake messages.
    pctRet = SPSetWrap(pContext,
                       pbMessage,
                       SSL3_CT_HANDSHAKE,
                       cbMessage,
                       FALSE,
                       &cbDataOut);

    if(pctRet != PCT_ERR_OK)
    {
        SP_LOG_RESULT(pctRet);
        goto cleanup;
    }

    // Update buffer length.
    pCommOutput->cbData += cbDataOut;

    SP_ASSERT(pCommOutput->cbData <= pCommOutput->cbBuffer);

    // Advance state machine.
    pContext->State = SSL2_STATE_SERVER_HELLO;

    pctRet = PCT_ERR_OK;


cleanup:

    if(pctRet != PCT_ERR_OK && !fAllocated)
    {
        SPExternalFree(pCommOutput->pvBuffer);
        pCommOutput->pvBuffer =NULL;
    }

    if(pbIssuerList)
    {
        SPExternalFree(pbIssuerList);
    }

    return pctRet;
}


/*
***************************************************************************
****************************************************************************
*/

SP_STATUS
SPSsl3SrvGenRestart(
    PSPContext          pContext,
    PSPBuffer           pCommOutput)
{
    SP_STATUS   pctRet;
    PBYTE pbMessage = NULL;
    DWORD cbMessage;
    DWORD cbDataOut;
    BOOL  fAllocated = FALSE;

    if(pCommOutput == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    //
    // Estimate size of the restart ServerHello message group, which includes
    // the ServerHello, ChangeCipherSpec, and Finished messages.
    //

    cbMessage =  sizeof(SWRAP) +        // ServerHello (plus encryption goo)
                 sizeof(SSH) +
                 SP_MAX_DIGEST_LEN +
                 SP_MAX_BLOCKCIPHER_SIZE;

    cbMessage += sizeof(SWRAP) +                    // ChangeCipherSpec
                 CB_SSL3_CHANGE_CIPHER_SPEC_ONLY +
                 SP_MAX_DIGEST_LEN +
                 SP_MAX_BLOCKCIPHER_SIZE;

    cbMessage += sizeof(SWRAP) +                    // Finished
                 CB_SSL3_FINISHED_MSG_ONLY +
                 SP_MAX_DIGEST_LEN +
                 SP_MAX_BLOCKCIPHER_SIZE;

    DebugLog((DEB_TRACE, "Server hello message %x\n", cbMessage));

    if(pCommOutput->pvBuffer)
    {
        // Application has allocated memory.
        if(pCommOutput->cbBuffer < cbMessage)
        {
            pCommOutput->cbData = cbMessage;
            return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
        }
        fAllocated = TRUE;
    }
    else
    {
        // Schannel is to allocate memory.
        pCommOutput->cbBuffer = cbMessage;
        pCommOutput->pvBuffer = SPExternalAlloc(cbMessage);
        if(pCommOutput->pvBuffer == NULL)
        {
            return (SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
        }
    }
    pCommOutput->cbData = 0;

    pbMessage = (PBYTE)pCommOutput->pvBuffer + pCommOutput->cbData;

    // Generate internal values to make server hello
    Ssl3GenerateRandom(pContext->rgbS3SRandom);

    // Make a new set of session keys.
    pctRet = MakeSessionKeys(pContext,
                             pContext->RipeZombie->hMasterProv,
                             pContext->RipeZombie->hMasterKey);
    if(pctRet != PCT_ERR_OK)
    {
        return SP_LOG_RESULT(pctRet);
    }

    // Initialize handshake hashes and hash ClientHello message.
    pctRet = UpdateHandshakeHash(pContext,
                                 pContext->pClientHello,
                                 pContext->cbClientHello,
                                 TRUE);
    SPExternalFree(pContext->pClientHello);
    pContext->pClientHello  = NULL;
    pContext->cbClientHello = 0;

    if(pctRet != PCT_ERR_OK)
    {
        return(pctRet);
    }

    // Build ServerHello message body.
    Ssl3BuildServerHello(pContext, pbMessage + sizeof(SWRAP));

    // Update handshake hash objects.
    pctRet = UpdateHandshakeHash(pContext,
                                 pbMessage + sizeof(SWRAP),
                                 sizeof(SSH),
                                 FALSE);
    if(pctRet != PCT_ERR_OK)
    {
        return(pctRet);
    }

    // Build record header and encrypt message.
    pctRet = SPSetWrap(pContext,
            pbMessage,
            SSL3_CT_HANDSHAKE,
            sizeof(SSH),
            FALSE,
            &cbDataOut);

    if(pctRet != PCT_ERR_OK)
    {
        SPExternalFree(pCommOutput->pvBuffer);
        pCommOutput->pvBuffer = 0;
        return pctRet;
    }

    // Update buffer length.
    pCommOutput->cbData += cbDataOut;

    SP_ASSERT(pCommOutput->cbData <= pCommOutput->cbBuffer);


    pContext->WriteCounter = 0;

    pctRet = BuildCCSAndFinishMessage(pContext,
                                      pCommOutput,
                                      FALSE);
    if(pctRet != PCT_ERR_OK)
    {
        SPExternalFree(pCommOutput->pvBuffer);
        pCommOutput->pvBuffer = 0;
        return pctRet;
    }

    pContext->State =  SSL3_STATE_RESTART_SER_HELLO;

    return(PCT_ERR_OK);
}



/*
***************************************************************************
* SPSsl3SrvHandleClientHello
* Client-hello from ssl3 parsing the client hello
****************************************************************************
*/

SP_STATUS
SPSsl3SrvHandleClientHello(
    PSPContext pContext,
    PBYTE pb,
    BOOL fAttemptReconnect)
{
    SP_STATUS pctRet = PCT_ERR_ILLEGAL_MESSAGE;
    BOOL  fRestart = FALSE;
    DWORD dwHandshakeLen;


    SP_BEGIN("SPSsl3SrvHandleClientHello");

    // Validate handshake type
    if(pb[0] != SSL3_HS_CLIENT_HELLO)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG));
    }

    dwHandshakeLen = ((INT)pb[1] << 16) +
                     ((INT)pb[2] << 8) +
                     (INT)pb[3];

    // Save the ClientHello message so we can hash it later, once
    // we know what algorithm and CSP we're using.
    if(pContext->pClientHello)
    {
        SPExternalFree(pContext->pClientHello);
    }
    pContext->cbClientHello = sizeof(SHSH) + dwHandshakeLen;
    pContext->pClientHello = SPExternalAlloc(pContext->cbClientHello);
    if(pContext->pClientHello == NULL)
    {
        SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
    }
    CopyMemory(pContext->pClientHello, pb, pContext->cbClientHello);
    pContext->dwClientHelloProtocol = SP_PROT_SSL3_CLIENT;

    pb += sizeof(SHSH);

    if(!Ssl3ParseClientHello(pContext, pb, dwHandshakeLen, fAttemptReconnect, &fRestart))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG));
    }

    if(fRestart)
    {
        pContext->State = SSL3_STATE_GEN_SERVER_HELLO_RESTART;
    }
    else
    {
        pContext->State = SSL3_STATE_GEN_SERVER_HELLO;
    }

    SP_RETURN(PCT_ERR_OK);
}



/*
***************************************************************************
* SPBuildCCSAndFinish
* This is a common nroutine for client/server. it builds the change cipher
* spec message and finished message.
****************************************************************************
*/

SP_STATUS
SPBuildCCSAndFinish(
    PSPContext pContext,        // in, out
    PSPBuffer  pCommOutput)     // out
{
    DWORD cbMessage;
    BOOL fClient;
    SP_STATUS pctRet;
    BOOL  fAllocated = FALSE;

    // Estimate size of the message group.
    cbMessage  = sizeof(SWRAP) +                    // ChangeCipherSpec
                 CB_SSL3_CHANGE_CIPHER_SPEC_ONLY +
                 SP_MAX_DIGEST_LEN +
                 SP_MAX_BLOCKCIPHER_SIZE;

    cbMessage += sizeof(SWRAP) +                    // Finished
                 CB_SSL3_FINISHED_MSG_ONLY +
                 SP_MAX_DIGEST_LEN +
                 SP_MAX_BLOCKCIPHER_SIZE;

    if(pCommOutput->pvBuffer)
    {
        // Application has allocated memory.
        if(pCommOutput->cbBuffer < cbMessage)
        {
            pCommOutput->cbData = cbMessage;
            return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
        }
        fAllocated = TRUE;
    }
    else
    {
        // Schannel is to allocate memory.
        pCommOutput->cbBuffer = cbMessage;
        pCommOutput->pvBuffer = SPExternalAlloc(cbMessage);
        if(pCommOutput->pvBuffer == NULL)
        {
            return (SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
        }
    }
    pCommOutput->cbData = 0;

    // Are we the client?
    if(pContext->RipeZombie->fProtocol & SP_PROT_SSL3TLS1_CLIENTS)
    {
        fClient = TRUE;
    }
    else
    {
        fClient = FALSE;
    }

    // Build messages.
    pctRet = BuildCCSAndFinishMessage(pContext,
                                    pCommOutput,
                                    fClient);
    if(pctRet != PCT_ERR_OK)
    {
        SPExternalFree(pCommOutput->pvBuffer);
        pCommOutput->pvBuffer = NULL;
    }
    return pctRet;

}


/*
***************************************************************************
* Ssl3SrvHandleUniHello:
*    we can get an UniHello from client-side, parse and digest the info
****************************************************************************
*/

SP_STATUS
Ssl3SrvHandleUniHello(
    PSPContext  pContext,
    PBYTE       pbMsg,
    DWORD       cbMsg)
{
    SP_STATUS           pctRet;
    PSsl2_Client_Hello  pHello = NULL;
    SPBuffer            Input;

    SP_BEGIN("Ssl3SrvHandleUniHello");

    if(pContext == NULL)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    if(pContext->pCredGroup == NULL)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }


    //
    // Decode the ClientHello message.
    //

    Input.pvBuffer = pbMsg;
    Input.cbData   = cbMsg;
    Input.cbBuffer = cbMsg;

    pctRet = Ssl2UnpackClientHello(&Input, &pHello);

    if(PCT_ERR_OK != pctRet)
    {
        goto Ret;
    }


    // Save the ClientHello message so we can hash it later, once
    // we know what algorithm and CSP we're using.
    if(pContext->pClientHello)
    {
        SPExternalFree(pContext->pClientHello);
    }
    pContext->cbClientHello = Input.cbData - sizeof(SSL2_MESSAGE_HEADER);
    pContext->pClientHello = SPExternalAlloc(pContext->cbClientHello);
    if(pContext->pClientHello == NULL)
    {
        pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto Ret;
    }
    CopyMemory(pContext->pClientHello,
               (PUCHAR)Input.pvBuffer + sizeof(SSL2_MESSAGE_HEADER),
               pContext->cbClientHello);
    pContext->dwClientHelloProtocol = SP_PROT_SSL2_CLIENT;


    /* keep challenge around for later */
    CopyMemory( pContext->pChallenge,
                pHello->Challenge,
                pHello->cbChallenge);
    pContext->cbChallenge = pHello->cbChallenge;

    /* Initialize the "Client.random" from the challenge */
    FillMemory(pContext->rgbS3CRandom, CB_SSL3_RANDOM - pContext->cbChallenge, 0);

    CopyMemory(  pContext->rgbS3CRandom + CB_SSL3_RANDOM - pContext->cbChallenge,
                 pContext->pChallenge,
                 pContext->cbChallenge);


    //
    // We know that this isn't a reconnect, so allocate a new cache entry.
    //

    if(!SPCacheRetrieveNew(TRUE, 
                           pContext->pszTarget, 
                           &pContext->RipeZombie))
    {
        pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto Ret;
    }

    pContext->RipeZombie->fProtocol      = pContext->dwProtocol;
    pContext->RipeZombie->dwCF           = pContext->dwRequestedCF;
    pContext->RipeZombie->pServerCred    = pContext->pCredGroup;


    //
    // Determine cipher suite to use.
    //

    pctRet = Ssl3SelectCipherEx(pContext,
                                pHello->CipherSpecs,
                                pHello->cCipherSpecs);
    if (pctRet != PCT_ERR_OK)
    {
        goto Ret;
    }

    pContext->State = SSL3_STATE_GEN_SERVER_HELLO;

Ret:
    if(NULL != pHello)
    {
        SPExternalFree(pHello);
    }

    SP_RETURN( pctRet );
}


/*
***************************************************************************
Build Server hello onto pb... we need to check the boundary condition with cb
****************************************************************************
*/
void
Ssl3BuildServerHello(PSPContext pContext, PBYTE pb)
{
    SSH *pssh = (SSH *) pb;
    WORD wT = sizeof(SSH) - sizeof(SHSH);
    DWORD dwCipher = UniAvailableCiphers[pContext->dwPendingCipherSuiteIndex].CipherKind;

    FillMemory(pssh, sizeof(SSH), 0);
    pssh->typHS = SSL3_HS_SERVER_HELLO;
    pssh->bcbMSB = MSBOF(wT) ;
    pssh->bcbLSB = LSBOF(wT) ;
    pssh->bMajor = SSL3_CLIENT_VERSION_MSB;
    if(pContext->RipeZombie->fProtocol == SP_PROT_SSL3_SERVER)
    {
        pssh->bMinor = (UCHAR)SSL3_CLIENT_VERSION_LSB;
    }
    else
    {
        pssh->bMinor = (UCHAR)TLS1_CLIENT_VERSION_LSB;
    }
    pssh->wCipherSelectedMSB = MSBOF(dwCipher);
    pssh->wCipherSelectedLSB = LSBOF(dwCipher);
    pssh->cbSessionId = (char)pContext->RipeZombie->cbSessionID;
    CopyMemory(pssh->rgbSessionId, pContext->RipeZombie->SessionID, pContext->RipeZombie->cbSessionID) ;
    CopyMemory(pssh->rgbRandom, pContext->rgbS3SRandom, CB_SSL3_RANDOM);
}

/*
***************************************************************************
Build Server Hello Done message
****************************************************************************
*/
void BuildServerHelloDone(
PBYTE pb,
DWORD cb)
{
    SHSH *pshsh = (SHSH *) pb ;

    //     struct { } ServerHelloDone;

    SP_BEGIN("BuildServerHelloDone");
    FillMemory(pshsh, sizeof(SHSH), 0);
    pshsh->typHS = SSL3_HS_SERVER_HELLO_DONE;
    SP_END();
}


//+---------------------------------------------------------------------------
//
//  Function:   ParseKeyExchgMsg
//
//  Synopsis:   Parse the ClientKeyExchange message.
//
//  Arguments:  [pContext]      --  Schannel context.
//              [pb]            --  Pointer to message's 4-byte handshake
//                                  header.
//
//  History:    10-03-97   jbanes   Server-side CAPI integration.
//
//  Notes:      This routine is called by the server-side only.
//
//----------------------------------------------------------------------------
SP_STATUS
ParseKeyExchgMsg(PSPContext pContext, PBYTE pb)
{
    SP_STATUS pctRet;
    DWORD cbEncryptedKey;
    PBYTE pbEncryptedKey;

    // check for correct state
    if(SSL2_STATE_SERVER_HELLO == pContext->State && pContext->fCertReq)
    {
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    // make sure we're a server
    if(!(pContext->pKeyExchInfo->fProtocol & SP_PROT_SSL3TLS1_CLIENTS))
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    if(*pb != SSL3_HS_CLIENT_KEY_EXCHANGE)
    {
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    cbEncryptedKey = ((INT)pb[1] << 16) + ((INT)pb[2] << 8) + (INT)pb[3];
    pbEncryptedKey = pb + (sizeof(SHSH)) ;

    if(pContext->pKeyExchInfo == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    /* Decrypt the encrypted portion of the master key */
    pctRet = pContext->pKeyExchInfo->System->GenerateServerMasterKey(
                pContext,
                NULL,
                0,
                pbEncryptedKey,
                cbEncryptedKey);
    if(pctRet != PCT_ERR_OK)
    {
        return SP_LOG_RESULT(pctRet);
    }


    pContext->State = SSL3_STATE_SERVER_KEY_XCHANGE;

    return PCT_ERR_OK;
}


SP_STATUS
UpdateAndDuplicateIssuerList(
    PSPCredentialGroup  pCredGroup,
    PBYTE *             ppbIssuerList,
    PDWORD              pcbIssuerList)
{
    SP_STATUS pctRet;

    LockCredential(pCredGroup);

    *ppbIssuerList = NULL;
    *pcbIssuerList = 0;

    // Check for GP update from the domain controller.
    SslCheckForGPEvent();

    // Build list of trusted issuers.
    if((pCredGroup->pbTrustedIssuers == NULL) ||
       (pCredGroup->dwFlags & CRED_FLAG_UPDATE_ISSUER_LIST))
    {
        pctRet = SPContextGetIssuers(pCredGroup);
        if(pctRet != PCT_ERR_OK)
        {
            UnlockCredential(pCredGroup);
            return SP_LOG_RESULT(pctRet);
        }
    }

    // Allocate memory.
    *ppbIssuerList = SPExternalAlloc(pCredGroup->cbTrustedIssuers);
    if(*ppbIssuerList == NULL)
    {
        UnlockCredential(pCredGroup);
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }

    // Copy issuer list.
    memcpy(*ppbIssuerList, pCredGroup->pbTrustedIssuers, pCredGroup->cbTrustedIssuers);
    *pcbIssuerList = pCredGroup->cbTrustedIssuers;

    UnlockCredential(pCredGroup);

    return PCT_ERR_OK;
}

/*
* *****************************************************************************
* Ssl3BuildCertificateRequest
*
* Build the CERTIFICATE_REQUEST handshake message.
*/
SP_STATUS
Ssl3BuildCertificateRequest(
    PSPContext pContext,
    PBYTE pbIssuerList,         // in
    DWORD cbIssuerList,         // in
    PBYTE pbMessage,            // out
    DWORD *pdwMessageLen)       // out
{
    SP_STATUS       pctRet;
    PBYTE           pbMessageStart = pbMessage;
    DWORD           dwBodyLength;

    // HandshakeType
    pbMessage[0] = SSL3_HS_CERTIFICATE_REQUEST;
    pbMessage += 1;

    // Skip message body length field (3 bytes)
    pbMessage += 3;

    //
    // enum {
    //     rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
    //     rsa_ephemeral_dh(5), dss_ephemeral_dh(6), fortezza_dms(20), (255)
    // } ClientCertificateType;
    //
    // opaque DistinguishedName<1..2^16-1>;
    //
    // struct {
    //     ClientCertificateType certificate_types<1..2^8-1>;
    //     DistinguishedName certificate_authorities<3..2^16-1>;
    // } CertificateRequest;
    //

    // Certificate type
    pbMessage[0] = 2;           // certificate type vector length
    pbMessage[1] = SSL3_CERTTYPE_RSA_SIGN;
    pbMessage[2] = SSL3_CERTTYPE_DSS_SIGN;
    pbMessage += 3;

    // Trusted issuer list length
    pbMessage[0] = MSBOF(cbIssuerList);
    pbMessage[1] = LSBOF(cbIssuerList);
    pbMessage += 2;

    // Trusted issuer list
    CopyMemory(pbMessage, pbIssuerList, cbIssuerList);
    pbMessage += cbIssuerList;


    // Compute message body length (subtract 4 byte header)
    dwBodyLength = (DWORD)(pbMessage - pbMessageStart) - 4;

    // Fill in message body length field (3 bytes)
    pbMessageStart[1] = (UCHAR) ((dwBodyLength & 0x00ff0000) >> 16);
    pbMessageStart[2] = MSBOF(dwBodyLength);
    pbMessageStart[3] = LSBOF(dwBodyLength);

    *pdwMessageLen = dwBodyLength + 4;

    return PCT_ERR_OK;
}


/*
* *****************************************************************************
* Ssl3ParseClientHello
*
* This routine parses just the CLIENT_HELLO message itself. The
* handshake crud has already been stripped off.
*/
BOOL Ssl3ParseClientHello(
    PSPContext  pContext,
    PBYTE       pbMessage,
    INT         iMessageLen,
    BOOL        fAttemptReconnect,
    BOOL *      pfReconnect)
{
    PBYTE pbMessageStart = pbMessage;
    INT iVersion;
    PBYTE pbSessionId;
    DWORD cbSessionId;
    INT iCipherSpecLen;
    INT iCipherSpec;
    INT iCompMethodLen;
    INT iCompMethod;
    INT i;
    SP_STATUS pctRet = PCT_ERR_OK;
    DWORD dwProtocol = SP_PROT_SSL3_SERVER;
    Ssl2_Cipher_Kind CipherSpecs[MAX_UNI_CIPHERS];
    INT cCipherSpecs;
    DWORD dwCacheCipher;
    BOOL fFound;

    //
    // struct {
    //     ProtocolVersion client_version;
    //     Random random;
    //     SessinoID session_id;
    //     CipherSuite cipher_suites<2..2^16-1>
    //     CompressionMethod compression_methods<1..2^8-1>;
    // } ClientHello;
    //

    *pfReconnect = FALSE;


    //
    // Parse the ClientHello message.
    //

    // ProtocolVersion = client_version;
    iVersion = ((INT)pbMessage[0] << 8) + pbMessage[1];
    if(iVersion < SSL3_CLIENT_VERSION)
    {
        return FALSE;
    }

    //see if it's a TLS 1 version !
    if(iVersion >= TLS1_CLIENT_VERSION)
        dwProtocol = SP_PROT_TLS1_SERVER;
    pbMessage += 2;

    // Random random
    CopyMemory(pContext->rgbS3CRandom, pbMessage, CB_SSL3_RANDOM);
    pContext->cbChallenge = CB_SSL3_RANDOM;
    pbMessage += CB_SSL3_RANDOM;

    // SessionID session_id; (length)
    cbSessionId = pbMessage[0];
    if(cbSessionId > CB_SSL3_SESSION_ID)
    {
        return FALSE;
    }
    pbMessage += 1;

    // SessionID session_id;
    pbSessionId = pbMessage;
    pbMessage += cbSessionId;

    // CipherSuite cipher_suites<2..2^16-1>; (length)
    iCipherSpecLen = ((INT)pbMessage[0] << 8) + pbMessage[1];
    if(iCipherSpecLen % 2)
    {
        return FALSE;
    }
    pbMessage += 2;
    if(pbMessage + iCipherSpecLen >= pbMessageStart + iMessageLen)
    {
        return FALSE;
    }

    // CipherSuite cipher_suites<2..2^16-1>;
    if(iCipherSpecLen / 2 > MAX_UNI_CIPHERS)
    {
        cCipherSpecs = MAX_UNI_CIPHERS;
    }
    else
    {
        cCipherSpecs = iCipherSpecLen / 2;
    }

    // Build list of client cipher suites.
    for(i = 0; i < cCipherSpecs; i++)
    {
        CipherSpecs[i] = COMBINEBYTES(pbMessage[i*2], pbMessage[(i*2)+1]);
    }
    pbMessage += iCipherSpecLen;

    // CompressionMethod compression_methods<1..2^8-1>; (length)
    iCompMethodLen = pbMessage[0];
    if(iCompMethodLen < 1)
    {
        return FALSE;
    }
    pbMessage += 1;
    if(pbMessage + iCompMethodLen > pbMessageStart + iMessageLen)
    {
        return FALSE;
    }

    iCompMethod = -1;
    for(i = 0 ; i <iCompMethodLen; i++)
    {
        if(pbMessage[i] == 0)
        {
            iCompMethod = 0;
            break;
        }

    }
    pbMessage += iCompMethodLen;

    if(iCompMethod != 0)
    {
        return FALSE;
    }


    // 
    // Check to see if this is a reconnect.
    //

    if(((pContext->Flags & CONTEXT_FLAG_NOCACHE) == 0) &&
       (cbSessionId > 0) &&
       fAttemptReconnect)
    {
        if(SPCacheRetrieveBySession(pContext,
                                    pbSessionId,
                                    cbSessionId,
                                    &pContext->RipeZombie))
        {
            // Make sure client's cipher suite list includes one from cache.
            fFound = FALSE;
            dwCacheCipher = UniAvailableCiphers[pContext->RipeZombie->dwCipherSuiteIndex].CipherKind;
            for(i = 0; i < cCipherSpecs; i++)
            {
                if(CipherSpecs[i] == dwCacheCipher)
                {
                    fFound = TRUE;
                    break;
                }
            }

            if(fFound)
            {
                // Transfer information from the cache entry to the context element.
                pctRet = ContextInitCiphersFromCache(pContext);
            }

            if(!fFound || pctRet != PCT_ERR_OK)
            {
                // This cache entry is not suitable for some reason. We need
                // to dump this cache entry and perform a full handshake.
                // This is typically caused by a client-side implementation 
                // problem.
                pContext->RipeZombie->ZombieJuju = FALSE;
                SPCacheDereference(pContext->RipeZombie);
                pContext->RipeZombie = NULL;
            }
        }
    }

    if(pContext->RipeZombie != NULL)
    {
        // We're doing a reconnect.
        DebugLog((DEB_TRACE, "Accept client's reconnect request.\n"));

        *pfReconnect = TRUE;

    }
    else
    {
        // We're doing a full handshake, so allocate a cache entry.

        if(!SPCacheRetrieveNew(TRUE,
                               pContext->pszTarget, 
                               &pContext->RipeZombie))
        {
            SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            return FALSE;
        }

        pContext->RipeZombie->fProtocol      = pContext->dwProtocol;
        pContext->RipeZombie->dwCF           = pContext->dwRequestedCF;
        pContext->RipeZombie->pServerCred    = pContext->pCredGroup;


        //
        // Select cipher suite to use.
        //

        pctRet = Ssl3SelectCipherEx(pContext,
                                    CipherSpecs,
                                    cCipherSpecs);
        if (pctRet != PCT_ERR_OK)
        {
            return FALSE;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\spbase\common\spbase.h ===
#include "spbasei.h"
#include <rsa.h>

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\spbase\expsrv\spbase.h ===
#include "spbasei.h"

#include <rsa.h>

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\utillib\test.c ===
long
EncodeInteger(
    unsigned char *  pbEncoded,
    unsigned char *  pbInt,
    unsigned long   dwLen,
    int    Writeflag)
{
    long    count;
    unsigned long   i;
    long    j;

    if (Writeflag)
        pbEncoded[0] = 0x02;

    count = 1;

    i = dwLen - 1;

    // find the most significant non-zero unsigned char
    while ((pbInt[i] == 0) && (i > 0))
        i--;

    if ((i == 0) && (pbInt[i] == 0))
        // this means that the integer value is 0
    {
        if (Writeflag)
            {
            pbEncoded[1] = 0x01;
            pbEncoded[2] = 0x00;
            }
        count += 2;
    }
    else
    {
        // if the most significant bit of the most sig unsigned char is set
        // then need to add a 0 unsigned char to the beginning.
        if (pbInt[i] > 0x7F)
        {
            // encode the length
            count += EncodeLength (pbEncoded + count, i+2, Writeflag);

            if (Writeflag)
            {
                // set the first unsigned char of the integer to zero and increment count
                pbEncoded[count++] = 0x00;

                // copy the integer unsigned chars into the encoded buffer
                j = i;
                while (j >= 0)
                    pbEncoded[count++] = pbInt[j--];
                }
            }

        else
        {
            // encode the length
            count += EncodeLength (pbEncoded + count, i+1, Writeflag);

            // copy the integer unsigned chars into the encoded buffer
            if (Writeflag)
                {
                j = i;
                while (j >= 0)
                    pbEncoded[count++] = pbInt[j--];
                }

            }
    }

    return (count);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\utillib\spbase.h ===
#include "spbasei.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\xtcb\context.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       context.h
//
//  Contents:   Security Context structures and manipulation
//
//  Classes:
//
//  Functions:
//
//  History:    2-24-97   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __CONTEXT_H__
#define __CONTEXT_H__


typedef enum _XTCB_CONTEXT_TYPE {
    XtcbContextClient,
    XtcbContextServer,
    XtcbContextClientMapped,
    XtcbContextServerMapped
} XTCB_CONTEXT_TYPE ;

typedef enum _XTCB_CONTEXT_STATE {
    ContextFirstCall,
    ContextSecondCall,
    ContextThirdCall
} XTCB_CONTEXT_STATE ;

#define XTCB_CONTEXT_CHECK  'txtC'

typedef struct _XTCB_CONTEXT_CORE {
    ULONG               Check ;
    XTCB_CONTEXT_TYPE   Type ;
    XTCB_CONTEXT_STATE  State ;
    LONG                RefCount ;
    ULONG               Attributes ;
    UCHAR               RootKey[ SEED_KEY_SIZE ];
    UCHAR               InboundKey[ SEED_KEY_SIZE ];
    UCHAR               OutboundKey[ SEED_KEY_SIZE ];
    ULONG               InboundNonce ;
    ULONG               OutboundNonce ;
    ULONG               CoreTokenHandle ;
} XTCB_CONTEXT_CORE, * PXTCB_CONTEXT_CORE ;

typedef struct _XTCB_CONTEXT {
    XTCB_CONTEXT_CORE   Core ;
    LSA_SEC_HANDLE      CredHandle ;
    HANDLE              Token ;
} XTCB_CONTEXT, * PXTCB_CONTEXT ;

NTSTATUS
XtcbInitializeContexts(
    VOID
    );

PXTCB_CONTEXT
XtcbCreateContextRecord(
    XTCB_CONTEXT_TYPE   Type,
    PXTCB_CRED_HANDLE   Handle
    );


VOID
XtcbDeleteContextRecord(
    PXTCB_CONTEXT   Context
    );

NTSTATUS
XtcbMapContextToUser(
    PXTCB_CONTEXT    Context,
    PSecBuffer      ContextBuffer
    );

BOOL
XtcbRefContextRecord(
    PXTCB_CONTEXT Context
    );

VOID
XtcbDerefContextRecordEx(
    PXTCB_CONTEXT Context,
    LONG RefBy
    );

#define XtcbDerefContextRecord( C )  XtcbDerefContextRecordEx( C, 1 );


#endif // __CONTEXT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\utest\sslcache\sslcache.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <windows.h> 
#include <wincrypt.h>

#define SECURITY_WIN32
#include <security.h>
#include <sspi.h>
#include <ntsecapi.h>
#include <ntrtl.h>
#include <schannel.h>
#include <sslcache.h>

#define LIST_CACHE_ENTRIES          1
#define LIST_ENTRIES_INTERACTIVE    2
#define PURGE_CACHE_ENTRIES         3

DWORD dwOperation           = LIST_CACHE_ENTRIES;
BOOL  fIncludeClient        = FALSE;
BOOL  fIncludeServer        = FALSE;
BOOL  fIncludeMappedEntries = FALSE;
LPSTR pszServerName         = NULL;

void
DisplayCacheInfo(
    HANDLE LsaHandle,
    DWORD PackageNumber,
    BOOL fClient, 
    BOOL fServer);

void
PurgeCacheEntries(
    HANDLE LsaHandle,
    DWORD PackageNumber);

void
DisplayCacheInfoInteractive(
    HANDLE LsaHandle,
    DWORD PackageNumber);

void Usage(void)
{
    printf("USAGE: sslcache [ operation ] [ flags ]\n");
    printf("\n");
    printf("    OPERATIONS:\n");
    printf("        -l      List cache entries (default)\n");
    printf("        -i      List cache entries interactively\n");
    printf("        -p      Purge cache entries\n");
    printf("\n");
    printf("    FLAGS:\n");
    printf("        -c      Include client entries (default)\n");
    printf("        -s      Include server entries\n");
    printf("        -S      Include IIS mapped server entries (purge only)\n");
}

void _cdecl main(int argc, char *argv[])
{
    DWORD Status;
    HANDLE LsaHandle;
    DWORD PackageNumber;
    LSA_STRING PackageName;
    BOOLEAN Trusted = TRUE;
    BOOLEAN WasEnabled;
    STRING Name;
    ULONG Dummy;

    INT i;
    INT iOption;
    PCHAR pszOption;

    //
    // Parse user-supplied parameters.
    //

    for(i = 1; i < argc; i++) 
    {
        if(argv[i][0] == '/') argv[i][0] = '-';

        if(argv[i][0] != '-') 
        {
            printf("**** Invalid argument \"%s\"\n", argv[i]);
            Usage();
            return;
        }

        iOption = argv[i][1];
        pszOption = &argv[i][2];

        switch(iOption) 
        {
        case 'l':
            dwOperation = LIST_CACHE_ENTRIES;
            break;

        case 'i':
            dwOperation = LIST_ENTRIES_INTERACTIVE;
            break;

        case 'p':
            dwOperation = PURGE_CACHE_ENTRIES;
            break;

        case 'c':
            fIncludeClient = TRUE;
            break;

        case 's':
            if(*pszOption == '\0')
            {
                fIncludeServer = TRUE;
            }
            else
            {
                pszServerName  = pszOption;
                fIncludeClient = TRUE;
            }
            break;

        case 'S':
            fIncludeMappedEntries = TRUE;
            fIncludeServer = TRUE;
            break;

        default:
            printf("**** Invalid option \"%s\"\n", argv[i]);
            Usage();
            return;
        }
    }


    //
    // If neither client nor server was specified by user set appropriate default.
    //

    if(!fIncludeClient && !fIncludeServer)
    {
        if(dwOperation == PURGE_CACHE_ENTRIES)
        {
            fIncludeClient = TRUE;
        }
        else
        {
            fIncludeClient = TRUE;
            fIncludeServer = TRUE;
        }
    }


    //
    // Get handle to schannel security package.
    //

    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    if (!NT_SUCCESS(Status))
    {
        Trusted = FALSE;
    }
    RtlInitString(
        &Name,
        "sslcache");

    if(Trusted)
    {
        Status = LsaRegisterLogonProcess(
                    &Name,
                    &LsaHandle,
                    &Dummy);

        if(FAILED(Status))
        {
            printf("**** Error 0x%x returned by LsaRegisterLogonProcess\n", Status);
            return;
        }
    }
    else
    {
        Status = LsaConnectUntrusted(&LsaHandle);

        if(FAILED(Status))
        {
            printf("**** Error 0x%x returned by LsaConnectUntrusted\n", Status);
            return;
        }
    }

    PackageName.Buffer          = UNISP_NAME_A;
    PackageName.Length          = (USHORT)strlen(PackageName.Buffer);
    PackageName.MaximumLength   = PackageName.Length + 1;

    Status = LsaLookupAuthenticationPackage(
                    LsaHandle,
                    &PackageName,
                    &PackageNumber);
    if(FAILED(Status))
    {
        printf("**** Error 0x%x returned by LsaLookupAuthenticationPackage\n", Status);
        CloseHandle(LsaHandle);
        return;
    }


    // 
    // Perform specified operation.
    //

    if(dwOperation == LIST_CACHE_ENTRIES)
    {
        printf("\nDISPLAY CACHE ENTRIES\n");
        printf("\n");

        if(fIncludeClient)
        {
            printf("--CLIENT--\n");
            DisplayCacheInfo(LsaHandle, PackageNumber, TRUE, FALSE);
        }

        if(fIncludeServer)
        {
            printf("--SERVER--\n");
            DisplayCacheInfo(LsaHandle, PackageNumber, FALSE, TRUE);
        }

        if(fIncludeClient && fIncludeServer)
        {
            printf("--TOTAL--\n");
            DisplayCacheInfo(LsaHandle, PackageNumber, TRUE, TRUE);
        }
    }
    else if(dwOperation == LIST_ENTRIES_INTERACTIVE)
    {
        DisplayCacheInfoInteractive(LsaHandle, PackageNumber);
    }
    else
    {
        PurgeCacheEntries(LsaHandle, PackageNumber);
    }


    CloseHandle(LsaHandle);
}


void
PurgeCacheEntries(
    HANDLE LsaHandle,
    DWORD PackageNumber)
{
    PSSL_PURGE_SESSION_CACHE_REQUEST pRequest;
    DWORD cchServerName;
    DWORD cbServerName;
    DWORD SubStatus;
    DWORD Status;

    printf("\nPURGE CACHE ENTRIES\n");
    printf("Client:%s\n", fIncludeClient ? "yes" : "no");
    printf("Server:%s\n", fIncludeServer ? "yes" : "no");

    if(pszServerName == NULL)
    {
        cbServerName = 0;

        pRequest = (PSSL_PURGE_SESSION_CACHE_REQUEST)LocalAlloc(LPTR, sizeof(SSL_PURGE_SESSION_CACHE_REQUEST));
        if(pRequest == NULL)
        {
            printf("**** Out of memory\n");
            return;
        }
    }
    else
    {
        cchServerName = MultiByteToWideChar(CP_ACP, 0, pszServerName, -1, NULL, 0);
        cbServerName  = (cchServerName + 1) * sizeof(WCHAR);

        pRequest = LocalAlloc(LPTR, sizeof(SSL_PURGE_SESSION_CACHE_REQUEST) + cbServerName);
        if(pRequest == NULL)
        {
            printf("**** Out of memory\n");
            return;
        }

        cchServerName = MultiByteToWideChar(CP_ACP, 0, pszServerName, -1, (LPWSTR)(pRequest + 1), cchServerName);
        if(cchServerName == 0)
        {
            printf("**** Error converting server name\n");
            return;
        }


        pRequest->ServerName.Buffer        = (LPWSTR)(pRequest + 1);
        pRequest->ServerName.Length        = (WORD)(cchServerName * sizeof(WCHAR));
        pRequest->ServerName.MaximumLength = (WORD)cbServerName;
    }

    pRequest->MessageType = SslPurgeSessionCacheMessage;

    if(fIncludeClient)
    {
        pRequest->Flags |= SSL_PURGE_CLIENT_ENTRIES;
    }
    if(fIncludeServer)
    {
        pRequest->Flags |= SSL_PURGE_SERVER_ENTRIES | SSL_PURGE_SERVER_ALL_ENTRIES;
    }
    if(fIncludeMappedEntries)
    {
        pRequest->Flags |= SSL_PURGE_SERVER_ENTRIES_DISCARD_LOCATORS;
    }


    Status = LsaCallAuthenticationPackage(
                    LsaHandle,
                    PackageNumber,
                    pRequest,
                    sizeof(SSL_PURGE_SESSION_CACHE_REQUEST) + cbServerName,
                    NULL,
                    NULL,
                    &SubStatus);
    if(FAILED(Status))
    {
        printf("**** Error 0x%x returned by LsaCallAuthenticationPackage\n", Status);
        return;
    }

    if(FAILED(SubStatus))
    {
        if(SubStatus == 0xC0000061)
        {
            printf("**** The TCB privilege is required to perform this operation.\n");
        }
        else
        {
            printf("**** Error 0x%x occurred while purging cache entries.\n", SubStatus);
        }
    }
}


void
DisplayCacheInfo(
    HANDLE LsaHandle,
    DWORD PackageNumber,
    BOOL fClient, 
    BOOL fServer)
{
    PSSL_SESSION_CACHE_INFO_REQUEST pRequest = NULL;
    PSSL_SESSION_CACHE_INFO_RESPONSE pResponse = NULL;
    DWORD cbResponse = 0;
    DWORD SubStatus;
    DWORD Status;

    pRequest = (PSSL_SESSION_CACHE_INFO_REQUEST)LocalAlloc(LPTR, sizeof(SSL_SESSION_CACHE_INFO_REQUEST));
    if(pRequest == NULL)
    {
        printf("**** Out of memory\n");
        goto cleanup;
    }

    pRequest->MessageType = SslSessionCacheInfoMessage;

    if(fClient)
    {
        pRequest->Flags |= SSL_RETRIEVE_CLIENT_ENTRIES;
    }
    if(fServer)
    {
        pRequest->Flags |= SSL_RETRIEVE_SERVER_ENTRIES;
    }


    Status = LsaCallAuthenticationPackage(
                    LsaHandle,
                    PackageNumber,
                    pRequest,
                    sizeof(SSL_SESSION_CACHE_INFO_REQUEST),
                    &pResponse,
                    &cbResponse,
                    &SubStatus);
    if(FAILED(Status))
    {
        printf("**** Error 0x%x returned by LsaCallAuthenticationPackage\n", Status);
        goto cleanup;
    }

    if(FAILED(SubStatus))
    {
        printf("**** Error 0x%x occurred while reading cache entries.\n", SubStatus);
    }

    printf("CacheSize:      %d    \n", pResponse->CacheSize);
    printf("Entries:        %d    \n", pResponse->Entries);
    printf("ActiveEntries:  %d    \n", pResponse->ActiveEntries);
    printf("Zombies:        %d    \n", pResponse->Zombies);
    printf("ExpiredZombies: %d    \n", pResponse->ExpiredZombies);
    printf("AbortedZombies: %d    \n", pResponse->AbortedZombies);
    printf("DeletedZombies: %d    \n", pResponse->DeletedZombies);
    printf("\n");

cleanup:

    if(pRequest)
    {
        LocalFree(pRequest);
    }

    if (pResponse != NULL)
    {
        LsaFreeReturnBuffer(pResponse);
    }
}

void cls(HANDLE hConsole)
{
    COORD coordScreen = { 0, 0 };    /* here's where we'll home the
                                        cursor */
    BOOL bSuccess;
    DWORD cCharsWritten;
    CONSOLE_SCREEN_BUFFER_INFO csbi; /* to get buffer info */
    DWORD dwConSize;                 /* number of character cells in
                                        the current buffer */

    /* get the number of character cells in the current buffer */

    bSuccess = GetConsoleScreenBufferInfo( hConsole, &csbi );
    dwConSize = csbi.dwSize.X * csbi.dwSize.Y;

    /* fill the entire screen with blanks */

    bSuccess = FillConsoleOutputCharacter( hConsole, (TCHAR) ' ',
       dwConSize, coordScreen, &cCharsWritten );

    /* get the current text attribute */

    bSuccess = GetConsoleScreenBufferInfo( hConsole, &csbi );

    /* now set the buffer's attributes accordingly */

    bSuccess = FillConsoleOutputAttribute( hConsole, csbi.wAttributes,
       dwConSize, coordScreen, &cCharsWritten );

    /* put the cursor at (0, 0) */

    bSuccess = SetConsoleCursorPosition( hConsole, coordScreen );
}

void home(HANDLE hConsole)
{
    COORD coordScreen = { 0, 0 };    /* here's where we'll home the
                                        cursor */
    BOOL bSuccess;

    /* put the cursor at (0, 0) */
    bSuccess = SetConsoleCursorPosition( hConsole, coordScreen );
}

void
DisplayCacheInfoInteractive(
    HANDLE LsaHandle,
    DWORD PackageNumber)
{
    HANDLE hConsoleOut;

    hConsoleOut = GetStdHandle( STD_OUTPUT_HANDLE );

    cls(hConsoleOut);

    while(TRUE)
    {
        home(hConsoleOut);

        if(fIncludeClient)
        {
            printf("--CLIENT--\n");
            DisplayCacheInfo(LsaHandle, PackageNumber, TRUE, FALSE);
        }

        if(fIncludeServer)
        {
            printf("--SERVER--\n");
            DisplayCacheInfo(LsaHandle, PackageNumber, FALSE, TRUE);
        }

        if(fIncludeClient && fIncludeServer)
        {
            printf("--TOTAL--\n");
            DisplayCacheInfo(LsaHandle, PackageNumber, TRUE, TRUE);
        }

        Sleep(2000);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\utillib\keys.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       keys.c
//
//  Contents:   Well known keys for certificate validation
//
//  Classes:
//
//  Functions:
//
//  History:    9-21-95   RichardW   Created
//
//----------------------------------------------------------------------------


#include "spbase.h"
#include <oidenc.h>

#include <rsa.h>

#define SCHANNEL_GENKEY_NAME "SchannelGenKey"

BOOL
GenerateKeyPair(
    PSSL_CREDENTIAL_CERTIFICATE pCerts,
    PSTR pszDN,
    PSTR pszPassword,
    DWORD Bits)
{

    BOOL            fRet = FALSE;
    DWORD           BitsCopy;
    DWORD           dwPrivateSize;
    DWORD           dwPublicSize;
    MD5_CTX         md5Ctx;
    struct RC4_KEYSTRUCT rc4Key;

    BLOBHEADER      *pCapiPrivate = NULL;
    BLOBHEADER      *pCapiPublic = NULL;

    PRIVATE_KEY_FILE_ENCODE PrivateEncode;
    CERT_REQUEST_INFO Req;

    CRYPT_ALGORITHM_IDENTIFIER SignAlg;

    HCRYPTPROV     hProv = 0;
    HCRYPTKEY      hKey = 0;

    if(!SchannelInit(TRUE))
    {
        return FALSE;
    }

    pCerts->pPrivateKey = NULL;
    Req.SubjectPublicKeyInfo.PublicKey.pbData = NULL;
    Req.Subject.pbData = NULL;
    pCerts->pCertificate = NULL;

    CryptAcquireContext(&hProv, SCHANNEL_GENKEY_NAME, NULL, PROV_RSA_FULL, CRYPT_DELETEKEYSET);

    if(!CryptAcquireContext(&hProv, SCHANNEL_GENKEY_NAME, NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET))
    {
        goto error;
    }

    if(!CryptGenKey(hProv, CALG_RSA_SIGN,  (Bits << 16) | CRYPT_EXPORTABLE, &hKey))
    {
        goto error;
    }

    if(!CryptExportKey(hKey, 0, PRIVATEKEYBLOB, 0, NULL, &dwPrivateSize))
    {
        goto error;
    }

    pCapiPrivate = (BLOBHEADER *)SPExternalAlloc(dwPrivateSize);
    if(!CryptExportKey(hKey, 0, PRIVATEKEYBLOB, 0, (PBYTE)pCapiPrivate, &dwPrivateSize))
    {
        goto error;
    }


    if(!CryptExportKey(hKey, 0, PUBLICKEYBLOB, 0, NULL, &dwPublicSize))
    {
        goto error;
    }

    pCapiPublic = (BLOBHEADER *)SPExternalAlloc(dwPublicSize);
    if(!CryptExportKey(hKey, 0, PUBLICKEYBLOB, 0, (PBYTE)pCapiPublic, &dwPublicSize))
    {
        goto error;
    }

    // Encode the private key into a 
    // priavate key blob.
    if(!CryptEncodeObject(X509_ASN_ENCODING, 
                      szPrivateKeyInfoEncode,
                      pCapiPrivate,
                      NULL,
                      &PrivateEncode.EncryptedBlob.cbData))
    {
        goto error;
    }
    PrivateEncode.EncryptedBlob.pbData = SPExternalAlloc(PrivateEncode.EncryptedBlob.cbData);
    if(PrivateEncode.EncryptedBlob.pbData == NULL)
    {
        goto error;
    }
    if(!CryptEncodeObject(X509_ASN_ENCODING, 
                      szPrivateKeyInfoEncode,
                      pCapiPrivate,
                      PrivateEncode.EncryptedBlob.pbData,
                      &PrivateEncode.EncryptedBlob.cbData))
    {
        goto error;
    }

    // Okay, now encrypt this
    MD5Init(&md5Ctx);
    MD5Update(&md5Ctx, pszPassword, lstrlen(pszPassword));
    MD5Final(&md5Ctx);

    rc4_key(&rc4Key, 16, md5Ctx.digest);
    ZeroMemory(&md5Ctx, sizeof(md5Ctx));

    rc4(&rc4Key, 
        PrivateEncode.EncryptedBlob.cbData,
        PrivateEncode.EncryptedBlob.pbData);
    ZeroMemory(&rc4Key, sizeof(rc4Key));

    // 
    PrivateEncode.Alg.pszObjId = szOID_RSA_ENCRYPT_RC4_MD5;
    PrivateEncode.Alg.Parameters.pbData = NULL;
    PrivateEncode.Alg.Parameters.cbData = 0;


    // Ah yes, now to encode them...
    //
    // First, the private key.  Why?  Well, it's at least straight-forward
    // First, get the size of the private key encode...
    if(!CryptEncodeObject(X509_ASN_ENCODING, 
                      szPrivateKeyFileEncode,
                      &PrivateEncode,
                      NULL,
                      &pCerts->cbPrivateKey))
    {
        goto error;
    }
    pCerts->pPrivateKey = SPExternalAlloc(pCerts->cbPrivateKey);

    if(!CryptEncodeObject(X509_ASN_ENCODING, 
                      szPrivateKeyFileEncode,
                      &PrivateEncode,
                      pCerts->pPrivateKey,
                      &pCerts->cbPrivateKey))
    {
        goto error;
    }


    SPExternalFree(PrivateEncode.EncryptedBlob.pbData);

    // Create the Req structure so we can encode it.
    Req.dwVersion = CERT_REQUEST_V1;

    // Initialize the PublicKeyInfo
    Req.SubjectPublicKeyInfo.Algorithm.pszObjId = szOID_RSA_RSA;
    Req.SubjectPublicKeyInfo.Algorithm.Parameters.cbData = 0;
    Req.SubjectPublicKeyInfo.Algorithm.Parameters.pbData = NULL;

    Req.SubjectPublicKeyInfo.PublicKey.cbData;


    // Encode the public key info
    if(!CryptEncodeObject(X509_ASN_ENCODING, 
                      szOID_RSA_RSA_Public,
                      pCapiPublic,
                      NULL,
                      &Req.SubjectPublicKeyInfo.PublicKey.cbData))
    {
        goto error;
    }
    Req.SubjectPublicKeyInfo.PublicKey.pbData = 
        SPExternalAlloc(Req.SubjectPublicKeyInfo.PublicKey.cbData);

    if(Req.SubjectPublicKeyInfo.PublicKey.pbData == NULL)
    {
        goto error;
    }

    // Encode the public key info
    if(!CryptEncodeObject(X509_ASN_ENCODING, 
                      szOID_RSA_RSA_Public,
                      pCapiPublic,
                      Req.SubjectPublicKeyInfo.PublicKey.pbData,
                      &Req.SubjectPublicKeyInfo.PublicKey.cbData))
    {
        goto error;
    }

    Req.SubjectPublicKeyInfo.PublicKey.cUnusedBits = 0;

    // Encode the name
    Req.Subject.cbData =  EncodeDN(NULL, pszDN, FALSE);
    if((LONG)Req.Subject.cbData < 0)
    {
        goto error;
    }

    Req.Subject.pbData = SPExternalAlloc(Req.Subject.cbData);

    if(Req.Subject.pbData== NULL)
    {
        goto error;
    }

    Req.Subject.cbData = EncodeDN(Req.Subject.pbData, pszDN, TRUE);

    if((LONG)Req.Subject.cbData < 0)
    {
        goto error;
    }


    // Attributes
    Req.cAttribute = 0;
    Req.rgAttribute = NULL;

    SignAlg.pszObjId = szOID_RSA_MD5RSA;
    SignAlg.Parameters.cbData = 0;
    SignAlg.Parameters.pbData = NULL;

    // Encode the public key info
    if(!CryptSignAndEncodeCertificate(
                      hProv,
                      AT_SIGNATURE,
                      X509_ASN_ENCODING, 
                      X509_CERT_REQUEST_TO_BE_SIGNED,
                      &Req,
                      &SignAlg,
                      NULL,
                      NULL,
                      &pCerts->cbCertificate))
    {
        goto error;
    }

    pCerts->pCertificate = SPExternalAlloc(pCerts->cbCertificate);
    if(pCerts->pCertificate == NULL)
    {
        goto error;
    }

    // Encode the public key info
    if(!CryptSignAndEncodeCertificate(
                      hProv,
                      AT_SIGNATURE,
                      X509_ASN_ENCODING, 
                      X509_CERT_REQUEST_TO_BE_SIGNED,
                      &Req,
                      &SignAlg,
                      NULL,
                      pCerts->pCertificate,
                      &pCerts->cbCertificate))
    {
        goto error;
    }

    fRet = TRUE;

    goto cleanup;

error:
    if(pCerts->pPrivateKey)
    {
        SPExternalFree(pCerts->pPrivateKey);
    }

    if(pCerts->pCertificate)
    {
        SPExternalFree(pCerts->pCertificate);
    }


cleanup:
    if(pCapiPrivate)
    {
        SPExternalFree(pCapiPrivate);
    }

    if(pCapiPublic)
    {
        SPExternalFree(pCapiPublic);
    }


    if(Req.SubjectPublicKeyInfo.PublicKey.pbData)
    {
        SPExternalFree(Req.SubjectPublicKeyInfo.PublicKey.pbData);
    }

    if(Req.Subject.pbData)
    {
        SPExternalFree(Req.Subject.pbData);
    }


    if(hKey != 0)
    {
        CryptDestroyKey(hKey);
    }
    
    if(hProv != 0)
    {

        CryptReleaseContext(hProv,0);
        CryptAcquireContext(&hProv, SCHANNEL_GENKEY_NAME, NULL, PROV_RSA_FULL, CRYPT_DELETEKEYSET);
    }
    return(fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\xtcb\credapi.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       credapi.c
//
//  Contents:   Credential related API
//
//  Classes:
//
//  Functions:
//
//  History:    2-24-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include "xtcbpkg.h"


//+---------------------------------------------------------------------------
//
//  Function:   XtcbAcceptCredentials
//
//  Synopsis:   Accept credentials stored during a prior logon session.
//
//  Arguments:  [LogonType]         -- Type of logon
//              [UserName]          -- name logged on with
//              [PrimaryCred]       -- Primary credential data
//              [SupplementalCreds] -- supplemental credential data
//
//  History:    2-19-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
XtcbAcceptCredentials(
    IN SECURITY_LOGON_TYPE LogonType,
    IN PUNICODE_STRING UserName,
    IN PSECPKG_PRIMARY_CRED PrimaryCred,
    IN PSECPKG_SUPPLEMENTAL_CRED SupplementalCreds)
{
    PXTCB_CREDS Creds ;

    DebugLog(( DEB_TRACE_CALLS, "AcceptCredentials( %d, %ws, ...)\n",
                    LogonType, UserName->Buffer ));

    Creds = XtcbCreateCreds( &PrimaryCred->LogonId );

    if ( Creds )
    {
        return SEC_E_OK ;
    }

    return SEC_E_INSUFFICIENT_MEMORY ;
}

//+---------------------------------------------------------------------------
//
//  Function:   XtcbAcquireCredentialsHandle
//
//  Synopsis:   Acquire a handle representing the user.
//
//  Arguments:  [psPrincipal]      -- claimed name of user
//              [fCredentials]     -- credential use
//              [pLogonID]         -- logon id of the calling thread
//              [pvAuthData]       -- provided auth data pointer (unmapped)
//              [pvGetKeyFn]       -- function in calling process for key data
//              [pvGetKeyArgument] -- argument to be passed
//              [pdwHandle]        -- returned handle
//              [ptsExpiry]        -- expiration time
//
//  History:    2-19-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
XtcbAcquireCredentialsHandle(
            PSECURITY_STRING    psPrincipal,
            ULONG               fCredentials,
            PLUID               pLogonId,
            PVOID               pvAuthData,
            PVOID               pvGetKeyFn,
            PVOID               pvGetKeyArgument,
            PLSA_SEC_HANDLE     pCredHandle,
            PTimeStamp          ptsExpiry)
{
    PXTCB_CREDS  Creds;
    PXTCB_CRED_HANDLE   Handle ;
    SECPKG_CLIENT_INFO  Info ;
    PSEC_WINNT_AUTH_IDENTITY AuthData ;

    DebugLog(( DEB_TRACE_CALLS, "AcquireCredentialsHandle(..., %x:%x, %x, ...)\n",
                                    pLogonId->HighPart, pLogonId->LowPart,
                                    pvAuthData ));

    Creds = NULL ;

    if ( pvAuthData == NULL )
    {

        if ( (pLogonId->LowPart == 0) && (pLogonId->HighPart == 0) )
        {
            LsaTable->GetClientInfo( &Info );

            *pLogonId = Info.LogonId ;

        }
        Creds = XtcbFindCreds( pLogonId, TRUE );

        if ( !Creds )
        {
            //
            // Time to create credentials for this user
            //

            Creds = XtcbCreateCreds( pLogonId );

            if ( !Creds )
            {
                return SEC_E_INSUFFICIENT_MEMORY ;
            }

            if ( Creds->Pac == NULL )
            {
                Creds->Pac = XtcbCreatePacForCaller();
            }
        }
    }
    else
    {
        return SEC_E_UNKNOWN_CREDENTIALS ;
    }

    Handle = XtcbAllocateCredHandle( Creds );

    XtcbDerefCreds( Creds );

    *pCredHandle = (LSA_SEC_HANDLE) Handle ;

    *ptsExpiry = XtcbNever ;

    if ( Handle )
    {
        Handle->Usage = fCredentials ;

        return SEC_E_OK ;
    }
    else
    {
        return SEC_E_INSUFFICIENT_MEMORY ;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   XtcbQueryCredentialsAttributes
//
//  Synopsis:   Return information about credentials
//
//  Arguments:  [dwCredHandle] -- Handle to check
//              [dwAttribute]  -- attribute to return
//              [Buffer]       -- Buffer to fill with attribute
//
//  History:    2-20-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
XtcbQueryCredentialsAttributes(
    LSA_SEC_HANDLE CredHandle,
    ULONG   dwAttribute,
    PVOID   Buffer)
{
    NTSTATUS Status ;
    PXTCB_CRED_HANDLE   Handle ;
    SecPkgCredentials_NamesW Names;

    DebugLog(( DEB_TRACE_CALLS, "QueryCredentialsAttribute( %p, %d, ... )\n",
                    CredHandle, dwAttribute ));

    Handle = (PXTCB_CRED_HANDLE) CredHandle ;

#if DBG
    if ( Handle->Check != XTCB_CRED_HANDLE_CHECK )
    {
        return SEC_E_INVALID_HANDLE ;
    }
#endif

    //
    // We only know about one credential attribute right now:
    //

    if ( dwAttribute != SECPKG_CRED_ATTR_NAMES )
    {
        return SEC_E_UNSUPPORTED_FUNCTION ;
    }

    Status = SEC_E_UNSUPPORTED_FUNCTION ;
    return Status ;

}

//+---------------------------------------------------------------------------
//
//  Function:   XtcbFreeCredentialsHandle
//
//  Synopsis:   Dereferences a credential handle from AcquireCredHandle
//
//  Arguments:  [dwHandle] --
//
//  History:    2-20-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
XtcbFreeCredentialsHandle(
    LSA_SEC_HANDLE  CredHandle
    )
{
    PXTCB_CRED_HANDLE   Handle ;

    DebugLog(( DEB_TRACE_CALLS, "FreeCredentialsHandle( %p )\n", CredHandle ));

    Handle = (PXTCB_CRED_HANDLE) CredHandle ;

    if ( Handle->Check == XTCB_CRED_HANDLE_CHECK )
    {
        XtcbDerefCredHandle( Handle );

        return SEC_E_OK ;
    }

    return( SEC_E_INVALID_HANDLE );
}

//+---------------------------------------------------------------------------
//
//  Function:   XtcbLogonTerminated
//
//  Synopsis:   Called when the logon session has terminated (all tokens closed)
//
//  Arguments:  [pLogonId] -- Logon session that has terminated
//
//  History:    2-20-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
SEC_ENTRY
XtcbLogonTerminated(PLUID  pLogonId)
{
    PXTCB_CREDS Creds ;

    DebugLog(( DEB_TRACE_CALLS, "LogonTerminated( %x:%x )\n",
                    pLogonId->HighPart, pLogonId->LowPart ));

    Creds = XtcbFindCreds( pLogonId, FALSE );

    if ( Creds )
    {
        Creds->Flags |= XTCB_CRED_TERMINATED ;

        XtcbDerefCreds( Creds );
    }

    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   XtcbGetUserInfo
//
//  Synopsis:   Return information about a user to the LSA
//
//  Arguments:  [pLogonId]   --
//              [fFlags]     --
//              [ppUserInfo] --
//
//  History:    2-20-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
XtcbGetUserInfo(  PLUID                   pLogonId,
                ULONG                   fFlags,
                PSecurityUserData *     ppUserInfo)
{
    PSecurityUserData   pInfo ;
    PXTCB_CREDS Creds ;
    SECURITY_STATUS Status ;

    DebugLog(( DEB_TRACE_CALLS, "GetUserInfo( %x:%x, %x, ...)\n",
                    pLogonId->HighPart, pLogonId->LowPart, fFlags ));


    return SEC_E_UNSUPPORTED_FUNCTION ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\xtcb\context.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       context.c
//
//  Contents:   Context manipulation functions
//
//  Classes:
//
//  Functions:
//
//  History:    2-26-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include "xtcbpkg.h"

CRITICAL_SECTION XtcbContextLock ;


//+---------------------------------------------------------------------------
//
//  Function:   XtcbInitializeContexts
//
//  Synopsis:   Initialization function
//
//  Arguments:  (none)
//
//  History:    8-15-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
XtcbInitializeContexts(
    VOID
    )
{
    NTSTATUS Status ;

    Status = STATUS_SUCCESS ;

    try
    {
        InitializeCriticalSection( &XtcbContextLock );
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        Status = GetExceptionCode();
    }

    return Status ;
}

//+---------------------------------------------------------------------------
//
//  Function:   XtcbCreateContextRecord
//
//  Synopsis:   Create a context record for use during authentication
//
//  Arguments:  [Type]   -- Type of context
//              [Handle] -- Credential handle that this context is derived from
//
//  History:    2-26-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PXTCB_CONTEXT
XtcbCreateContextRecord(
    XTCB_CONTEXT_TYPE   Type,
    PXTCB_CRED_HANDLE   Handle
    )
{
    PXTCB_CONTEXT   Context ;

    Context = (PXTCB_CONTEXT) LocalAlloc( LMEM_FIXED, sizeof( XTCB_CONTEXT) );

    if ( Context )
    {
        Context->Core.Check = XTCB_CONTEXT_CHECK ;

        Context->Core.Type = Type ;

        Context->Core.State = ContextFirstCall ;

        Context->CredHandle = (LSA_SEC_HANDLE) Handle ;

        XtcbRefCredHandle( Handle );

        //
        // Set initial count to 2, one for the context handle
        // that will be returned, and one for the reference that
        // indicates that we are currently working on it.
        //

        Context->Core.RefCount = 2 ;

    }

    return Context ;
}
//+---------------------------------------------------------------------------
//
//  Function:   XtcbDeleteContextRecord
//
//  Synopsis:   Deletes a security context record
//
//  Arguments:  [Context] -- Context
//
//  History:    2-26-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
XtcbDeleteContextRecord(
    PXTCB_CONTEXT   Context
    )
{
#if DBG
    if ( Context->Core.Check != XTCB_CONTEXT_CHECK )
    {
        DebugLog(( DEB_ERROR, "DeleteContext: not a valid context record: %x\n",
                Context ));
        return;

    }
#endif

    XtcbDerefCredHandle( (PXTCB_CRED_HANDLE) Context->CredHandle );

    LocalFree( Context );
}



VOID
XtcbDerefContextRecordEx(
    PXTCB_CONTEXT Context,
    LONG RefBy
    )
{
    LONG RefCount ;

    EnterCriticalSection( &XtcbContextLock );

    Context->Core.RefCount -= RefBy ;

    RefCount = Context->Core.RefCount ;

    LeaveCriticalSection( &XtcbContextLock );

    if ( RefCount )
    {
        return ;
    }

#if DBG

    if ( RefCount < 0 )
    {
        DebugLog(( DEB_ERROR, "Refcount below 0\n" ));
    }
#endif

    XtcbDeleteContextRecord( Context );

}

BOOL
XtcbRefContextRecord(
    PXTCB_CONTEXT Context
    )
{
    BOOL Ret ;

    Ret = FALSE ;

    EnterCriticalSection( &XtcbContextLock );

    try
    {

        if ( Context->Core.Check == XTCB_CONTEXT_CHECK )
        {
            if ( Context->Core.RefCount > 0 )
            {
                Context->Core.RefCount++ ;
                Ret = TRUE ;
            }

        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        Ret = FALSE ;
    }

    LeaveCriticalSection( &XtcbContextLock );

    return Ret ;
}

//+---------------------------------------------------------------------------
//
//  Function:   XtcbMapContextToUser
//
//  Synopsis:   Prepares a context to be mapped to usermode by the LSA
//
//  Arguments:  [Context]       --
//              [ContextBuffer] --
//
//  History:    3-28-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
XtcbMapContextToUser(
    PXTCB_CONTEXT    Context,
    PSecBuffer      ContextBuffer
    )
{
    PXTCB_CONTEXT_CORE  NewContext ;
    NTSTATUS            Status ;
    HANDLE DupHandle ;

    NewContext = LsaTable->AllocateLsaHeap( sizeof( XTCB_CONTEXT_CORE ) );

    if ( NewContext )
    {
        CopyMemory( NewContext, &Context->Core, sizeof( XTCB_CONTEXT_CORE ) );

        switch ( Context->Core.Type )
        {
            case XtcbContextClient:
                NewContext->Type = XtcbContextClientMapped ;
                Context->Core.Type = XtcbContextClientMapped ;
                break;

            case XtcbContextServer:
                NewContext->Type = XtcbContextServerMapped ;
                Context->Core.Type = XtcbContextClientMapped ;

                Status = LsaTable->DuplicateHandle( Context->Token,
                                                    &DupHandle );

                DebugLog(( DEB_TRACE, "New token = %x\n", DupHandle ));
                if ( !NT_SUCCESS( Status ) )
                {
                    DebugLog(( DEB_ERROR, "Failed to dup handle, %x\n",
                        Status ));
                    goto MapContext_Cleanup ;

                }
                NewContext->CoreTokenHandle = (ULONG) ((ULONG_PTR)DupHandle) ;

                CloseHandle( Context->Token );
                Context->Token = NULL ;
                break;

            default:
                Status = SEC_E_INVALID_TOKEN ;
                goto MapContext_Cleanup ;
                break;

        }

        ContextBuffer->pvBuffer = NewContext ;
        ContextBuffer->cbBuffer = sizeof( XTCB_CONTEXT_CORE );

        return SEC_E_OK ;

    }
    else
    {
        Status = SEC_E_INSUFFICIENT_MEMORY ;
    }

MapContext_Cleanup:

    if ( NewContext )
    {
        LsaTable->FreeLsaHeap( NewContext );
    }

    return Status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\schannel\utillib\enc.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/

#include <spbase.h>

#include <ber.h>


typedef struct __EncAlgs {
    DWORD       Id;
    UCHAR       Sequence[16];
    DWORD       SequenceLen;
} _EncAlgs;


#define iso_member          0x2a,               /* iso(1) memberbody(2) */
#define us                  0x86, 0x48,         /* us(840) */
#define rsadsi              0x86, 0xf7, 0x0d,   /* rsadsi(113549) */
#define pkcs                0x01,               /* pkcs(1) */

#define pkcs_1              iso_member us rsadsi pkcs
#define pkcs_len            7
#define rsa_dsi             iso_member us rsadsi
#define rsa_dsi_len         6

#define joint_iso_ccitt_ds  0x55,
#define attributetype       0x04,

#define attributeType       joint_iso_ccitt_ds attributetype
#define attrtype_len        2


_EncAlgs EncKnownAlgs[] =
{
    {ALGTYPE_SIG_RSA_MD5, {pkcs_1 1, 4}, pkcs_len + 2},
    {ALGTYPE_KEYEXCH_RSA_MD5, {pkcs_1 1, 1}, pkcs_len + 2},
    {ALGTYPE_CIPHER_RC4_MD5, {rsa_dsi 3, 4}, rsa_dsi_len + 2},
    {ALGTYPE_KEYEXCH_DH, {pkcs_1 3, 1}, pkcs_len + 2},
};



typedef struct _NameTypes {
    PSTR        Prefix;
    DWORD       PrefixLen;
    UCHAR       Sequence[8];
    DWORD       SequenceLen;
} NameTypes;

#define CNTYPE_INDEX        0

NameTypes EncKnownNameTypes[] =
{
    {"CN=", 3, {attributeType 3},  attrtype_len + 1},
    {"C=",  2, {attributeType 6},  attrtype_len + 1},
    {"L=",  2, {attributeType 7},  attrtype_len + 1},
    {"S=",  2, {attributeType 8},  attrtype_len + 1},
    {"O=",  2, {attributeType 10}, attrtype_len + 1},
    {"OU=", 3, {attributeType 11}, attrtype_len + 1}
};


/************************************************************/
/* EncodeLength ASN1 encodes a length field.  The parameter */
/* dwLen is the length to be encoded, it is a DWORD and     */
/* therefore may be no larger than 2^32.  The pbEncoded     */
/* parameter is the encoded result, and memory must be      */
/* allocated for it by the caller.  The Writeflag parameter */
/* indicates if the result is to be written to the pbEncoded*/
/* parameter.  The function cannot fail and returns the     */
/* number of total bytes in the encoded length.             */
/* encoded length.                                          */
/************************************************************/

// Notes:       Encodes 0x0000 to 0x007f as <lobyte>
//            Encodes 0x0080 to 0x00ff as <81>, <lobyte>
//            Encodes 0x0100 to 0xffff as <82>, <hibyte>, <lobyte>

long
EncodeLength(
    BYTE *  pbEncoded,
    DWORD   dwLen,
    BOOL    Writeflag)
{
    // length is between 2^8 and 2^16 - 1

    if (dwLen > 0xFF)
    {
        if (Writeflag)
        {
            pbEncoded[0] = 0x82;
            pbEncoded[1] = (BYTE) (dwLen >> 8);
            pbEncoded[2] = (BYTE) dwLen;
        }
        return (3);
    }

    // length is between 2^7 and 2^8 - 1

    if (dwLen > 0x7F)
    {
        if (Writeflag)
        {
            pbEncoded[0] = 0x81;
            pbEncoded[1] = (BYTE) dwLen;
        }
        return (2);
    }

    // length is between 0 and 2^7 - 1

    if (Writeflag)
    {
        pbEncoded[0] = (BYTE) dwLen;
    }
    return (1);
}


/****************************************************************/
/* EncodeInteger ASN1 encodes an integer.  The pbInt parameter  */
/* is the integer as an array of bytes, and dwLen is the number */
/* of bytes in the array.  The least significant byte of the    */
/* integer is the zeroth byte of the array.  The encoded result */
/* is passed back in the pbEncoded parameter.  The Writeflag    */
/* indicates if the result is to be written to the pbEncoded    */
/* parameter. The function cannot fail and returns the number   */
/* of total bytes in the encoded integer.                       */
/* This implementation will only deal with positive integers.   */
/****************************************************************/

long
EncodeInteger(
    BYTE *pbEncoded,
    BYTE *pbInt,
    DWORD dwLen,
    BOOL Writeflag)
{
    DWORD i;
    long j;               // Must be signed!
    BYTE *pb = pbEncoded;

    if (Writeflag)
    {
        *pb = INTEGER_TAG;
    }
    pb++;

    /* find the most significant non-zero byte */

    for (i = dwLen - 1; pbInt[i] == 0; i--)
    {
        if (i == 0)     /* if the integer value is 0 */
        {
            if (Writeflag)
            {
                pb[0] = 0x01;
                pb[1] = 0x00;
            }
            return(3);
        }
    }

    /* if the most significant bit of the most sig byte is set */
    /* then need to add a 0 byte to the beginning. */

    if (pbInt[i] > 0x7F)
    {
        /* encode the length */
        pb += EncodeLength(pb, i + 2, Writeflag);

        if (Writeflag)
        {
            /* set the first byte of the integer to 0 and increment pointer */
            *pb = 0;
        }
        pb++;
    }
    else
    {
        /* encode the length */
        pb += EncodeLength(pb, i + 1, Writeflag);
    }

    /* copy the integer bytes into the encoded buffer */
    if (Writeflag)
    {
        /* copy the integer bytes into the encoded buffer */
        for (j = i; j >= 0; j--)
        {
            *pb++ = pbInt[j];
        }
    }
    else
    {
        pb += i;
    }
    return (long)(pb - pbEncoded);
}


/****************************************************************/
/* EncodeString ASN1 encodes a character string.  The pbStr     */
/* parameter is the string as an array of characters, and dwLen */
/* is the number of characters in the array.  The encoded result*/
/* is passed back in the pbEncoded parameter.  The Writeflag    */
/* indicates if the result is to be written to the pbEncoded    */
/* parameter. The function cannot fail and returns the number   */
/* of total bytes in the encoded string.                        */
/****************************************************************/

long
EncodeString(
    BYTE *  pbEncoded,
    BYTE *  pbStr,
    DWORD   dwLen,
    BOOL    Writeflag)
{
    long lengthlen;

    if (Writeflag)
    {
        *pbEncoded++ = CHAR_STRING_TAG;
    }
    lengthlen = EncodeLength(pbEncoded, dwLen, Writeflag);

    if (Writeflag)
    {
        CopyMemory(pbEncoded + lengthlen, pbStr, dwLen);
    }
    return(1 + lengthlen + dwLen);
}


/****************************************************************/
/* EncodeOctetString ASN1 encodes a string of hex valued        */
/* characters. The pbStr parameter is an array of characters,   */
/* and dwLen is the number of characters in the array.  The     */
/* encoded result is passed back in the pbEncoded parameter. The*/
/* Writeflag parameter indicates if the result is to be written */
/* to the pbEncoded parameter. The function cannot fail and     */
/* returns the number of total bytes in the encoded octet string*/
/****************************************************************/

long
EncodeOctetString(
    BYTE *  pbEncoded,
    BYTE *  pbStr,
    DWORD   dwLen,
    BOOL    Writeflag)
{
    long lengthlen;

    if (Writeflag)
    {
        *pbEncoded++ = OCTET_STRING_TAG;
    }
    lengthlen = EncodeLength(pbEncoded, dwLen, Writeflag);

    if (Writeflag)
    {
        CopyMemory(pbEncoded + lengthlen, pbStr, dwLen);
    }
    return(1 + lengthlen + dwLen);
}


/****************************************************************/
/* EncodeBitString ASN1 encodes a string of bit characters. The */
/* pbStr parameter is an array of characters (bits), and dwLen  */
/* is the number of characters in the array.  The encoded result*/
/* is passed back in the pbEncoded parameter.  The Writeflag    */
/* indicates if the result is to be written to the pbEncoded    */
/* parameter. The function cannot fail and returns the number   */
/* of total bytes in the encoded string.  This function uses    */
/* the DER.                                                     */
/****************************************************************/
long
EncodeBitString(
    BYTE *  pbEncoded,
    BYTE *  pbStr,
    DWORD   dwLen,
    BOOL    Writeflag)
{
    long lengthlen;

    if (Writeflag)
    {
        *pbEncoded++ = BIT_STRING_TAG;
    }

    lengthlen = EncodeLength(pbEncoded, dwLen + 1, Writeflag);

    if (Writeflag)
    {
        pbEncoded += lengthlen;

        // the next byte tells how many unused bits there are in the last byte,
        // but this will always be zero in this implementation (DER)

        *pbEncoded++ = 0;
        CopyMemory(pbEncoded, pbStr, dwLen);
    }
    return(1 + lengthlen + 1 + (long) dwLen);
}


/****************************************************************/
/* EncodeHeader ASN1 encodes a header for a sequence type. The  */
/* dwLen is the length of the encoded information in the        */
/* sequence.  The Writeflag indicates if the result is to be    */
/* written to the pbEncoded parameter.  The function cannot     */
/* fail and returns the number of total bytes in the encoded    */
/* header.                                                      */
/****************************************************************/

// Notes:       Encodes header as <SEQUENCE_TAG>, <length>

long
EncodeHeader(
    BYTE *  pbEncoded,
    DWORD   dwLen,
    BOOL    Writeflag)
{
    if (Writeflag)
    {
        *pbEncoded++ = SEQUENCE_TAG;
    }
    return(1 + EncodeLength(pbEncoded, dwLen, Writeflag));
}


/****************************************************************/
/* EncodeSetOfHeader ASN1 encodes a header for a set of type.   */
/* The dwLen is the length of the encoded information in the    */
/* set of.  The Writeflag indicates if the result is to be      */
/* written to the pbEncoded parameter.  The function cannot     */
/* fail and returns the number of total bytes in the encoded    */
/* header.                                                      */
/****************************************************************/

// Notes:       Encodes header as <SET_OF_TAG>, <length>

long
EncodeSetOfHeader(
    BYTE *  pbEncoded,
    DWORD   dwLen,
    BOOL    Writeflag)
{
    if (Writeflag)
    {
        *pbEncoded++ = SET_OF_TAG;
    }
    return(1 + EncodeLength(pbEncoded, dwLen, Writeflag));
}


// Notes:       Encodes header as <ATTRIBUTE_TAG>, <length>

long
EncodeAttributeHeader(
    BYTE *  pbEncoded,
    DWORD   dwLen,
    BOOL    Writeflag)
{
    if (Writeflag)
    {
        *pbEncoded++ = ATTRIBUTE_TAG;
    }
    return(1 + EncodeLength(pbEncoded, dwLen, Writeflag));
}


// Notes:       Encodes header as <BER_SET>, <length>

long
EncodeSetHeader(
    BYTE *  pbEncoded,
    DWORD   dwLen,
    BOOL    WriteFlag)
{
    if (WriteFlag)
    {
        *pbEncoded++ = BER_SET;
    }
    return(1 + EncodeLength(pbEncoded, dwLen, WriteFlag));
}



/****************************************************************/
/* EncodeName ASN1 encodes a Name type. The pbName parameter is */
/* the name and dwLen is the length of the name in bytes.       */
/* The Writeflag indicates if the result is to be written to    */
/* the pbEncoded parameter.  The function cannot fail and       */
/* returns the number of total bytes in the encoded name.       */
/****************************************************************/

long
EncodeName(
    BYTE *  pbEncoded,
    BYTE *  pbName,
    DWORD   dwLen,
    BOOL    Writeflag)
{
    BYTE        Type[MAXOBJIDLEN];
    long        TypeLen;
    BYTE        Value[MAXNAMEVALUELEN+MINHEADERLEN];
    long        ValueLen;
    BYTE        Attribute[MAXNAMELEN];
    long        AttributeLen;
    BYTE        SetHdr[MINHEADERLEN];
    long        HdrLen;
    long        NameLen;

    /* encode the name value */
    ValueLen = EncodeString(Value, pbName, dwLen, Writeflag);
    SP_ASSERT(ValueLen > 0 && ValueLen <= sizeof(Value));

    /* encode the attribute type, this is an object identifier and here it */
    /* is a fake encoding */
    Type[0] = 0x06;
    Type[1] = 0x01;
    Type[2] = 0x00;

    TypeLen = 3;

    /* enocde the header for the attribute */
    AttributeLen = EncodeHeader(
                            Attribute,
                            (DWORD) (ValueLen + TypeLen),
                            Writeflag);
    SP_ASSERT(AttributeLen > 0);
    SP_ASSERT(AttributeLen + TypeLen + ValueLen <= sizeof(Attribute));

    /* copy the attribute type and value into the attribute */
    CopyMemory(Attribute + AttributeLen, Type, (size_t) TypeLen);
    AttributeLen += TypeLen;
    CopyMemory(Attribute + AttributeLen, Value, (size_t) ValueLen);
    AttributeLen += ValueLen;

    /* encode set of header */
    HdrLen = EncodeSetOfHeader(SetHdr, (DWORD) AttributeLen, Writeflag);
    SP_ASSERT(HdrLen > 0 && HdrLen <= sizeof(SetHdr));

    /* encode Name header */
    NameLen = EncodeHeader(
                        pbEncoded,
                        (DWORD) (HdrLen + AttributeLen),
                        Writeflag);
    SP_ASSERT(NameLen > 0);

    CopyMemory(pbEncoded + NameLen, SetHdr, (size_t) HdrLen);
    NameLen += HdrLen;
    CopyMemory(pbEncoded + NameLen, Attribute, (size_t) AttributeLen);

    return(NameLen + AttributeLen);
}

long
EncodeRDN(
    BYTE *  pbEncoded,
    PSTR    pszRDN,
    BOOL    WriteFlag)
{
    LONG    Result;
    DWORD   RelLength;
    long    Length;
    NameTypes *pNameType;
    char ach[4];

    SP_ASSERT(pszRDN != NULL);
    if (pszRDN[0] == '\0' ||
        pszRDN[1] == '\0' ||
        pszRDN[2] == '\0' ||
        (pszRDN[1] != '=' && pszRDN[2] != '='))
    {
        return(-1);
    }
    ach[0] = pszRDN[0];
    ach[1] = pszRDN[1];
    if (ach[1] == '=')
    {
        ach[2] = '\0';
    }
    else
    {
        ach[2] = pszRDN[2];
        ach[3] = '\0';
    }

    for (pNameType = EncKnownNameTypes; ; pNameType++)
    {
        if (pNameType ==
            &EncKnownNameTypes[sizeof(EncKnownNameTypes) /
                               sizeof(EncKnownNameTypes[0])])
        {
            return(-1);
        }
        SP_ASSERT(lstrlen(pNameType->Prefix) < sizeof(ach));
        if (lstrcmpi(ach, pNameType->Prefix) == 0)
        {
            break;
        }
    }

    RelLength = lstrlen(&pszRDN[pNameType->PrefixLen]);

    // Prefix data takes up 9 bytes

    Length = EncodeSetHeader(pbEncoded, RelLength + 9, WriteFlag);
    pbEncoded += Length;

    Result = EncodeHeader(pbEncoded, RelLength + 7, WriteFlag);
    pbEncoded += Result;
    Length += Result + 2 + pNameType->SequenceLen;

    if (WriteFlag)
    {
        *pbEncoded++ = OBJECT_ID_TAG;
        *pbEncoded++ = (BYTE) pNameType->SequenceLen;

        CopyMemory(pbEncoded, pNameType->Sequence, pNameType->SequenceLen);
        pbEncoded += pNameType->SequenceLen;

        *pbEncoded++ =
            pNameType == &EncKnownNameTypes[CNTYPE_INDEX]?
                TELETEX_STRING_TAG : PRINTABLE_STRING_TAG;

    }
    Length++;

    Result = EncodeLength(pbEncoded, RelLength, WriteFlag);
    Length += Result;

    if (WriteFlag)
    {
        CopyMemory(
                pbEncoded + Result,
                &pszRDN[pNameType->PrefixLen],
                RelLength);
    }
    return(Length + RelLength);
}

long
EncodeDN(
    BYTE *  pbEncoded,
    PSTR    pszDN,
    BOOL    WriteFlag)
{
    PSTR pszRDN;
    long Result = 0;
    long Length;
    long SaveResult;

    SP_ASSERT(pszDN != NULL);

    SaveResult = 0;           // force one full iteration
    Length = 2 * lstrlen(pszDN); // your guess is as good as mine
    while (TRUE)
    {
        PSTR pszNext;
        BYTE *pb;

        pb = pbEncoded;

        Result = EncodeHeader(pb, Length, WriteFlag);
        if (SaveResult == Result)
        {
            break;
        }
        pb += Result;
        SaveResult = Result;

        Length = 0;
        pszRDN = pszDN;
        while (*pszRDN != '\0')
        {
            for (pszNext = pszRDN; ; pszNext++)
            {
                if (*pszNext == ',')
                {
                    *pszNext = '\0';
                    break;
                }
                if (*pszNext == '\0')
                {
                    pszNext = NULL;
                    break;
                }
            }

            Result = EncodeRDN(pb, pszRDN, WriteFlag);

            // Restore the comma before checking for error

            if (NULL != pszNext)
            {
                *pszNext = ',';
            }
            if (Result < 0)
            {
                DebugLog((DEB_TRACE, "EncodeDN: Error: %s\n", pszRDN));
                Length = 0;
                goto error;     // return(-1)
            }

            pb += Result;
            Length += Result;

            if (NULL == pszNext)
            {
                break;
            }

            pszRDN = pszNext + 1;
            while (*pszRDN == ' ')
            {
                pszRDN++;
            }
            DebugLog((DEB_TRACE, "EncodeDN: Length = %d\n", Length));
        }
    }
    SP_ASSERT(0 != SaveResult);
error:
    return(Result + Length);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\xtcb\debug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       debug.h
//
//  Contents:   Debug helpers
//
//  Classes:
//
//  Functions:
//
//  History:    2-20-97   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __DEBUG_H__
#define __DEBUG_H__


#include <dsysdbg.h>
DECLARE_DEBUG2( XtcbPkg );

#if DBG
#define DebugLog(x) XtcbPkgDebugPrint x
#else
#define DebugLog(x)
#endif

#define DEB_TRACE_CREDS     0x00000008          // Trace Credentials
#define DEB_TRACE_CTXT      0x00000010          // Trace contexts
#define DEB_TRACE_CALLS     0x00000020          // Trace Enters
#define DEB_TRACE_AUTH      0x00000040          // Trace Authentication

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\xtcb\creds.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       creds.c
//
//  Contents:   Cred Management for Xtcb Package
//
//  Classes:
//
//  Functions:
//
//  History:    2-19-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include "xtcbpkg.h"

LIST_ENTRY  XtcbCredList ;
CRITICAL_SECTION    XtcbCredListLock ;

#define ReadLockCredList()  EnterCriticalSection( &XtcbCredListLock )
#define WriteLockCredList() EnterCriticalSection( &XtcbCredListLock )
#define WriteFromReadLockCredList()
#define UnlockCredList()    LeaveCriticalSection( &XtcbCredListLock )


//+---------------------------------------------------------------------------
//
//  Function:   XtcbInitCreds
//
//  Synopsis:   Initialize the credential management
//
//  Arguments:  (none)
//
//  History:    2-19-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
XtcbInitCreds(
    VOID
    )
{
    InitializeCriticalSection( &XtcbCredListLock );

    InitializeListHead( &XtcbCredList );

    return TRUE ;
}

//+---------------------------------------------------------------------------
//
//  Function:   XtcbFindCreds
//
//  Synopsis:   Look for credentials of a particular logon id, optionally
//              referencing them
//
//  Arguments:  [LogonId] --
//              [Ref]     --
//
//  History:    2-19-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PXTCB_CREDS
XtcbFindCreds(
    PLUID   LogonId,
    BOOL    Ref
    )
{
    PLIST_ENTRY Scan ;
    PXTCB_CREDS Cred ;

    Cred = NULL ;

    ReadLockCredList();

    Scan = XtcbCredList.Flink ;

    while ( Scan != &XtcbCredList )
    {
        Cred = CONTAINING_RECORD( Scan, XTCB_CREDS, List );

        DsysAssert( Cred->Check == XTCB_CRED_CHECK );

        if ( RtlEqualLuid( &Cred->LogonId, LogonId ) )
        {
            break;
        }

        Scan = Cred->List.Flink ;

        Cred = NULL ;
    }

    if ( Cred )
    {
        if ( Ref )
        {
            WriteFromReadLockCredList();

            Cred->RefCount++;
        }
    }

    UnlockCredList();

    return Cred ;

}

//+---------------------------------------------------------------------------
//
//  Function:   XtcbCreateCreds
//
//  Synopsis:   Create and initialize a credential structure.  The reference
//              count is set to 1, so the pointer will remain valid.
//
//  Arguments:  [LogonId] --
//
//  History:    2-19-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PXTCB_CREDS
XtcbCreateCreds(
    PLUID LogonId 
    )
{
    PXTCB_CREDS Creds ;

    Creds = (PXTCB_CREDS) LocalAlloc( LMEM_FIXED, sizeof( XTCB_CREDS ) );

    if ( Creds )
    {
        DebugLog(( DEB_TRACE_CREDS, "Creating new credential for (%x:%x)\n",
                   LogonId->HighPart, LogonId->LowPart ));

        ZeroMemory( Creds, sizeof( XTCB_CREDS ) );

        Creds->LogonId = *LogonId ;
        Creds->RefCount = 1 ;
        Creds->Check = XTCB_CRED_CHECK ;

        Creds->Pac = XtcbCreatePacForCaller();

        WriteLockCredList();

        InsertTailList( &XtcbCredList, &Creds->List );

        UnlockCredList();

    }

    return Creds ;
}


//+---------------------------------------------------------------------------
//
//  Function:   XtcbRefCreds
//
//  Synopsis:   Reference the credentials
//
//  Arguments:  [Creds] --
//
//  History:    2-19-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
XtcbRefCreds(
    PXTCB_CREDS Creds
    )
{
    WriteLockCredList();

    Creds->RefCount++ ;

    UnlockCredList();

}

//+---------------------------------------------------------------------------
//
//  Function:   XtcbDerefCreds
//
//  Synopsis:   Deref Credentials, freeing if the refcount goes to zero
//
//  Arguments:  [Creds] --
//
//  History:    2-19-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
XtcbDerefCreds(
    PXTCB_CREDS Creds
    )
{
    WriteLockCredList();

    Creds->RefCount--;

    if ( Creds->RefCount )
    {
        UnlockCredList();

        return;
    }

    RemoveEntryList( &Creds->List );

    UnlockCredList();

    Creds->Check = 0 ;

    LocalFree( Creds );
}


//+---------------------------------------------------------------------------
//
//  Function:   XtcbAllocateCredHandle
//
//  Synopsis:   Allocates and returns a cred handle (reference to a credential)
//
//  Arguments:  [Creds] -- Creds this handle is for
//
//  History:    2-21-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PXTCB_CRED_HANDLE
XtcbAllocateCredHandle(
    PXTCB_CREDS Creds
    )
{
    PXTCB_CRED_HANDLE   Handle ;

    Handle = (PXTCB_CRED_HANDLE) LocalAlloc( LMEM_FIXED,
                            sizeof( XTCB_CRED_HANDLE ) );

    if ( Handle )
    {
        ZeroMemory( Handle, sizeof( XTCB_CRED_HANDLE )  );

        Handle->Check = XTCB_CRED_HANDLE_CHECK ;

        XtcbRefCreds( Creds );

        Handle->Creds = Creds ;

        Handle->RefCount = 1 ;

    }

    return Handle ;


}

//+---------------------------------------------------------------------------
//
//  Function:   XtcbRefCredHandle
//
//  Synopsis:   Reference a credential handle
//
//  Arguments:  [Handle] -- Handle to ref
//
//  History:    2-24-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
XtcbRefCredHandle(
    PXTCB_CRED_HANDLE   Handle
    )
{
    WriteLockCredList();

    Handle->RefCount ++ ;

    UnlockCredList();

}

//+---------------------------------------------------------------------------
//
//  Function:   XtcbDerefCredHandle
//
//  Synopsis:   Dereference a cred handle
//
//  Arguments:  [Handle] --
//
//  History:    2-24-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
XtcbDerefCredHandle(
    PXTCB_CRED_HANDLE   Handle
    )
{
    WriteLockCredList();

    Handle->RefCount -- ;

    if ( Handle->RefCount == 0 )
    {
        XtcbDerefCreds( Handle->Creds );

        LocalFree( Handle );
    }

    UnlockCredList();
}


//+---------------------------------------------------------------------------
//                           
//  Function:   XtcbCreatePacForCaller
//
//  Synopsis:   Creates an XTCB_PAC for the caller
//
//  Arguments:  none
//
//  History:    3-14-00   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PXTCB_PAC
XtcbCreatePacForCaller(
    VOID
    )
{
    HANDLE Token ;
    NTSTATUS Status ;
    PXTCB_PAC Pac = NULL ;
    PTOKEN_USER User = NULL ;
    PTOKEN_GROUPS Groups = NULL ;
    PTOKEN_GROUPS Restrictions = NULL ;
    TOKEN_STATISTICS Stats ;
    ULONG UserSize ;
    ULONG GroupSize ;
    ULONG RestrictionSize ;
    ULONG PacGroupSize = 0 ;
    ULONG PacRestrictionSize = 0 ;
    ULONG PacUserName = 0 ;
    ULONG PacDomainName = 0 ;
    ULONG PacSize ;
    ULONG i ;
    PUCHAR CopyTo ;
    PUCHAR Base ;
    BOOL SpecialAccount = FALSE ;
    PSECURITY_LOGON_SESSION_DATA LogonSessionData = NULL ;



    Status = LsaTable->ImpersonateClient();

    if ( !NT_SUCCESS( Status ) )
    {
        return NULL ;
    }

    Status = NtOpenThreadToken(
                NtCurrentThread(),
                TOKEN_READ,
                TRUE,
                &Token );

    RevertToSelf();

    if ( !NT_SUCCESS( Status ) )
    {
        return NULL ;
    }

    //
    // Now that we have the token, capture all the information about this user,
    // and compute our own "PAC" structure.
    //

    Status = NtQueryInformationToken(
                Token,
                TokenStatistics,
                &Stats,
                sizeof( Stats ),
                &UserSize );

    if ( !NT_SUCCESS( Status ) )
    {
        goto CreatePac_Exit ;
    }

    //
    // If this is a special logon session (e.g. LocalSystem, LocalService, etc.),
    // then the LUID will be less than 1000.  Set the flag to copy all SIDs in the token.
    //

    if ( (Stats.AuthenticationId.HighPart == 0) &&
         (Stats.AuthenticationId.LowPart < 1000 ) )
    {
        SpecialAccount = TRUE ;
    }

    UserSize = 0 ;

    (void) NtQueryInformationToken(
                Token,
                TokenUser,
                NULL,
                0,
                &UserSize );

    if ( UserSize == 0 )
    {
        goto CreatePac_Exit ;
    }

    User = LocalAlloc( LMEM_FIXED, UserSize );

    if ( !User )
    {
        goto CreatePac_Exit ;
    }

    Status = NtQueryInformationToken(
                Token,
                TokenUser,
                User,
                UserSize,
                &UserSize );

    if ( !NT_SUCCESS( Status ) )
    {
        goto CreatePac_Exit ;
    }

    GroupSize = 0 ;
    
    (void) NtQueryInformationToken(
                Token,
                TokenGroups,
                NULL,
                0,
                &GroupSize );

    if ( GroupSize == 0 )
    {
        goto CreatePac_Exit ;
    }

    Groups = LocalAlloc( LMEM_FIXED, GroupSize );

    if ( !Groups )
    {
        goto CreatePac_Exit ;
    }

    Status = NtQueryInformationToken(
                Token,
                TokenGroups,
                Groups,
                GroupSize,
                &GroupSize );

    if ( !NT_SUCCESS( Status ) )
    {
        goto CreatePac_Exit;
    }

    RestrictionSize = 0 ;

    (void) NtQueryInformationToken(
                Token,
                TokenRestrictedSids,
                NULL,
                0,
                &RestrictionSize );

    if ( RestrictionSize != 0 )
    {
        Restrictions = LocalAlloc( LMEM_FIXED, RestrictionSize );

        if ( Restrictions )
        {
            Status = NtQueryInformationToken(
                        Token,
                        TokenRestrictedSids,
                        Restrictions,
                        RestrictionSize,
                        &RestrictionSize );

            if ( !NT_SUCCESS( Status ) )
            {
                goto CreatePac_Exit ;
            }
        }
        else 
        {
            goto CreatePac_Exit ;
        }
    }


    //
    // We now have all the users SIDs in the two (or three) pointers.  First, grovel the Groups
    // for non-local SIDs, and set all the rest to 0.  This will let us compute how much space
    // we need.
    //

    for ( i = 0 ; i < Groups->GroupCount ; i++ )
    {
        if ( (*RtlSubAuthorityCountSid( Groups->Groups[ i ].Sid ) > 2) ||
             (SpecialAccount) )
        {
            //
            // A "real" SID.  Check to make sure it is not from this machine
            //

            if ( ( XtcbMachineSid != NULL ) && 
                 RtlEqualPrefixSid( XtcbMachineSid, Groups->Groups[ i ].Sid ) )
            {
                //
                // Don't use this group
                //

                Groups->Groups[ i ].Attributes = 0 ;
            }
            else 
            {
                //
                // We like this SID (it is not from the local machine)
                //

                Groups->Groups[ i ].Attributes = SE_GROUP_MANDATORY ;
                PacGroupSize += RtlLengthSid( Groups->Groups[ i ].Sid );
            }
        }
        else 
        {
            Groups->Groups[ i ].Attributes = 0 ;
        }
    }

    //
    // Do the same for the restrictions, if any
    //

    if ( Restrictions )
    {
        for ( i = 0 ; i < Restrictions->GroupCount ; i++ )
        {
            PacRestrictionSize += RtlLengthSid( Restrictions->Groups[ i ].Sid );
        }
    }

    //
    // Get the user's name and domain:
    //

    Status = LsaGetLogonSessionData( 
                    &Stats.AuthenticationId, 
                    &LogonSessionData );

    if ( !NT_SUCCESS( Status ) )
    {
        goto CreatePac_Exit ;
    }

    PacUserName = LogonSessionData->UserName.Length ;
    PacDomainName = LogonSessionData->LogonDomain.Length ;

    //
    // In an advanced world, we'd query the other packages for
    // delegatable credentials, bundle them up and ship them
    // over.
    //


    //
    // Ok, we've got all the information we need
    //

    PacSize = sizeof( XTCB_PAC ) +
              RtlLengthSid( User->User.Sid ) +
              PacGroupSize +
              PacRestrictionSize +
              PacUserName +
              PacDomainName ;

    Pac = LocalAlloc( LMEM_FIXED, PacSize );

    if ( !Pac )
    {
        goto CreatePac_Exit ;
    }


    //
    // Create the PAC structure:
    //

    Pac->Tag = XTCB_PAC_TAG ;
    Pac->Length = PacSize ;

    CopyTo = (PUCHAR) (Pac + 1);
    Base = (PUCHAR) Pac ;
    
    //
    // Assemble the PAC:
    //
    // first, the user
    //

    Pac->UserOffset = (ULONG) (CopyTo - Base);
    Pac->UserLength = RtlLengthSid( User->User.Sid );

    RtlCopyMemory(
        CopyTo,
        User->User.Sid,
        Pac->UserLength );

    CopyTo += RtlLengthSid( User->User.Sid );

    //
    // Now the normal groups:
    //

    Pac->GroupCount = 0 ;
    Pac->GroupOffset = (ULONG) (CopyTo - Base);


    for ( i = 0 ; i < Groups->GroupCount ; i++ )
    {
        if ( Groups->Groups[ i ].Attributes & SE_GROUP_MANDATORY )
        {
            RtlCopyMemory(
                    CopyTo,
                    Groups->Groups[ i ].Sid,
                    RtlLengthSid( Groups->Groups[ i ].Sid ) );

            CopyTo += RtlLengthSid( Groups->Groups[ i ].Sid );

            Pac->GroupCount++ ;
        }
    }
    Pac->GroupLength = (ULONG) (CopyTo - Base) - Pac->GroupOffset;

    //
    // If there are restrictions, copy them in as well
    //

    if ( (Restrictions == NULL) ||
         (Restrictions->GroupCount == 0 ) )
    {
        Pac->RestrictionCount = 0 ;
        Pac->RestrictionOffset = 0 ;
        Pac->RestrictionLength = 0 ;
    }
    else 
    {
        Pac->RestrictionCount = Restrictions->GroupCount ;
        Pac->RestrictionOffset = (ULONG) ( CopyTo - Base );

        for ( i = 0 ; i < Restrictions->GroupCount ; i++ )
        {
            RtlCopyMemory(
                    CopyTo,
                    Restrictions->Groups[ i ].Sid,
                    RtlLengthSid( Restrictions->Groups[ i ].Sid ) );

            CopyTo += RtlLengthSid( Restrictions->Groups[ i ].Sid );

            Pac->RestrictionCount++ ;
        }
        Pac->RestrictionLength = (ULONG) (CopyTo - Base) - Pac->RestrictionOffset ;
    }

    Pac->NameOffset = (ULONG) ( CopyTo - Base );
    Pac->NameLength = LogonSessionData->UserName.Length ;
    RtlCopyMemory(
            CopyTo,
            LogonSessionData->UserName.Buffer,
            LogonSessionData->UserName.Length );

    CopyTo += LogonSessionData->UserName.Length ;

    Pac->DomainLength = LogonSessionData->LogonDomain.Length ;
    Pac->DomainOffset = (ULONG) ( CopyTo - Base );

    RtlCopyMemory(
            CopyTo,
            LogonSessionData->LogonDomain.Buffer,
            LogonSessionData->LogonDomain.Length );


    
    //
    // Someday, maybe, copy credential data here
    //

    Pac->CredentialLength = 0 ;
    Pac->CredentialOffset = 0 ;
    

CreatePac_Exit:

    if ( LogonSessionData )
    {
        LsaFreeReturnBuffer( LogonSessionData );
    }

    if ( User )
    {
        LocalFree( User );
    }

    if ( Groups )
    {
        LocalFree( Groups );
    }

    if ( Restrictions )
    {
        LocalFree( Restrictions );
    }

    NtClose( Token );

    return Pac ;
    

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\xtcb\md5.h ===
/*
 ***********************************************************************
 ** md5.h -- Header file for implementation of MD5                    **
 ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
 ** Created: 2/17/90 RLR                                              **
 ** Revised: 12/27/90 SRD,AJ,BSK,JT Reference C version               **
 ** Revised (for MD5): RLR 4/27/91                                    **
 **   -- G modified to have y&~z instead of y&z                       **
 **   -- FF, GG, HH modified to add in last register done             **
 **   -- Access pattern: round 2 works mod 5, round 3 works mod 3     **
 **   -- distinct additive constant for each step                     **
 **   -- round 4 added, working mod 7                                 **
 ***********************************************************************
 */

/*
 ***********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
 **                                                                   **
 ** License to copy and use this software is granted provided that    **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
 ** Digest Algorithm" in all material mentioning or referencing this  **
 ** software or this function.                                        **
 **                                                                   **
 ** License is also granted to make and use derivative works          **
 ** provided that such works are identified as "derived from the RSA  **
 ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
 ** material mentioning or referencing the derived work.              **
 **                                                                   **
 ** RSA Data Security, Inc. makes no representations concerning       **
 ** either the merchantability of this software or the suitability    **
 ** of this software for any particular purpose.  It is provided "as  **
 ** is" without express or implied warranty of any kind.              **
 **                                                                   **
 ** These notices must be retained in any copies of any part of this  **
 ** documentation and/or software.                                    **
 ***********************************************************************
 */

#ifdef __cplusplus
extern "C" {
#endif

/* Data structure for MD5 (Message-Digest) computation */
typedef struct {
  ULONG i[2];                          /* number of _bits_ handled mod 2^64 */
  ULONG buf[4];                                           /* scratch buffer */
  unsigned char in[64];                                     /* input buffer */
  unsigned char digest[16];            /* actual digest after MD5Final call */
  ULONG FinishFlag;
} MD5_CTX;


#define MD5DIGESTLEN 16

#define PROTO_LIST(list)    list


/*
 * MTS: Each of these assumes MD5_CTX is locked against simultaneous use.
 */
void MD5Init PROTO_LIST ((MD5_CTX *));
void MD5Update PROTO_LIST ((MD5_CTX *, const unsigned char *, unsigned int));
void MD5Final PROTO_LIST ((MD5_CTX *));

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\xtcb\creds.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       creds.h
//
//  Contents:   Credential mgmt prototypes
//
//  Classes:
//
//  Functions:
//
//  History:    2-19-97   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __CREDS_H__
#define __CREDS_H__


#define XTCB_CRED_CHECK      'tseT'

typedef struct _XTCB_CREDS {
    ULONG       Check;
    ULONG       Flags ;
    LIST_ENTRY  List ;
    LUID        LogonId ;
    ULONG       RefCount ;
    SECURITY_STRING Name ;
    PXTCB_PAC   Pac ;
} XTCB_CREDS, * PXTCB_CREDS ;

#define XTCB_CRED_TERMINATED    0x00000001

#define XTCB_CRED_HANDLE_CHECK  'naHC'

typedef struct _XTCB_CRED_HANDLE {
    ULONG       Check ;
    PXTCB_CREDS Creds ;
    PVOID       SharedMemory ;
    ULONG       Usage ;
    ULONG       RefCount ;
} XTCB_CRED_HANDLE, * PXTCB_CRED_HANDLE;


BOOL
XtcbInitCreds(
    VOID
    );

PXTCB_CREDS
XtcbFindCreds(
    PLUID   LogonId,
    BOOL    Ref
    );

PXTCB_CREDS
XtcbCreateCreds(
    PLUID LogonId
    );

VOID
XtcbRefCreds(
    PXTCB_CREDS Creds
    );

VOID
XtcbDerefCreds(
    PXTCB_CREDS Creds
    );

PXTCB_CRED_HANDLE
XtcbAllocateCredHandle(
    PXTCB_CREDS Creds
    );

VOID
XtcbRefCredHandle(
    PXTCB_CRED_HANDLE   Handle
    );

VOID
XtcbDerefCredHandle(
    PXTCB_CRED_HANDLE   Handle
    );

#endif // __CREDS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\xtcb\md5c.c ===
/*
 ***********************************************************************
 ** md5.c                                                             **
 ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
 ** Created: 2/17/90 RLR                                              **
 ** Revised: 1/91 SRD,AJ,BSK,JT Reference C Version                   **
 ***********************************************************************
 */

/*
 ***********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
 **                                                                   **
 ** License to copy and use this software is granted provided that    **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
 ** Digest Algorithm" in all material mentioning or referencing this  **
 ** software or this function.                                        **
 **                                                                   **
 ** License is also granted to make and use derivative works          **
 ** provided that such works are identified as "derived from the RSA  **
 ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
 ** material mentioning or referencing the derived work.              **
 **                                                                   **
 ** RSA Data Security, Inc. makes no representations concerning       **
 ** either the merchantability of this software or the suitability    **
 ** of this software for any particular purpose.  It is provided "as  **
 ** is" without express or implied warranty of any kind.              **
 **                                                                   **
 ** These notices must be retained in any copies of any part of this  **
 ** documentation and/or software.                                    **
 ***********************************************************************
 */

//  Portions copyright (c) 1992 Microsoft Corp.
//  All rights reserved


#define UINT4   unsigned long
#define ULONG	unsigned long


#include "md5.h"


/* Constants for Transform routine.
 */
#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21

static void TransformMD5 PROTO_LIST ((UINT4 *, UINT4 *));

static const unsigned char PADDING[64] = {
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

/* F, G and H are basic MD5 functions */
#define F(x, y, z) (z ^ (x & (y^z)))	/* optimized version of (((x) & (y)) | ((~x) & (z))) */
#define G(x, y, z) (y ^ (z & (x^y)))	/* optimized version of (((x) & (z)) | ((y) & (~z))) */
#define H(x, y, z) (x ^ y ^ z)
#define I(x, y, z) (y ^ (x | ~z))

/* ROTATE_LEFT rotates x left n bits.
 */
#define ROTATE_LEFT(x, n) _rotl((x), (n))

/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4 */
/* Rotation is separate from addition to prevent recomputation */
#define FF(a, b, c, d, x, s, ac) \
  {(a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define GG(a, b, c, d, x, s, ac) \
  {(a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define HH(a, b, c, d, x, s, ac) \
  {(a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define II(a, b, c, d, x, s, ac) \
  {(a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }

/*
** MTS: Assumes mdContext is locked against simultaneous use.
*/
void MD5Init (mdContext)
MD5_CTX *mdContext;
{
  mdContext->i[0] = mdContext->i[1] = (UINT4)0;

  /* Load magic initialization constants.
   */
  mdContext->buf[0] = (UINT4)0x67452301;
  mdContext->buf[1] = (UINT4)0xefcdab89;
  mdContext->buf[2] = (UINT4)0x98badcfe;
  mdContext->buf[3] = (UINT4)0x10325476;
}

/*
** MTS: Assumes mdContext is locked against simultaneous use.
*/
void MD5Update (mdContext, inBuf, inLen)
MD5_CTX *mdContext;
const unsigned char *inBuf;
unsigned int inLen;
{
  UINT4 in[16];
  int mdi;
  unsigned int i, ii;

  /* compute number of bytes mod 64 */
  mdi = (int)((mdContext->i[0] >> 3) & 0x3f);

  /* update number of bits */
  if ((mdContext->i[0] + ((UINT4)inLen << 3)) < mdContext->i[0])
    mdContext->i[1]++;
  mdContext->i[0] += ((UINT4)inLen << 3);
  mdContext->i[1] += ((UINT4)inLen >> 29);

  while (inLen--) {
    /* add new character to buffer, increment mdi */
    mdContext->in[mdi++] = *inBuf++;

    /* transform if necessary */
    if (mdi == 0x40) {
      for (i = 0, ii = 0; i < 16; i++, ii += 4)
        in[i] = (((UINT4)mdContext->in[ii+3]) << 24) |
                (((UINT4)mdContext->in[ii+2]) << 16) |
                (((UINT4)mdContext->in[ii+1]) << 8) |
                ((UINT4)mdContext->in[ii]);
      TransformMD5 (mdContext->buf, in);
      mdi = 0;
    }
  }
}

/*
** MTS: Assumes mdContext is locked against simultaneous use.
*/
void MD5Final (mdContext)
MD5_CTX *mdContext;
{
  UINT4 in[16];
  int mdi;
  unsigned int i, ii;
  unsigned int padLen;

  /* save number of bits */
  in[14] = mdContext->i[0];
  in[15] = mdContext->i[1];

  /* compute number of bytes mod 64 */
  mdi = (int)((mdContext->i[0] >> 3) & 0x3f);

  /* pad out to 56 mod 64 */
  padLen = (mdi < 56) ? (56 - mdi) : (120 - mdi);
  MD5Update (mdContext, PADDING, padLen);

  /* append length in bits and transform */
  for (i = 0, ii = 0; i < 14; i++, ii += 4)
    in[i] = (((UINT4)mdContext->in[ii+3]) << 24) |
            (((UINT4)mdContext->in[ii+2]) << 16) |
            (((UINT4)mdContext->in[ii+1]) << 8) |
            ((UINT4)mdContext->in[ii]);
  TransformMD5 (mdContext->buf, in);

  /* store buffer in digest */
  for (i = 0, ii = 0; i < 4; i++, ii += 4) {
    mdContext->digest[ii] = (unsigned char)(mdContext->buf[i] & 0xff);
    mdContext->digest[ii+1] =
      (unsigned char)((mdContext->buf[i] >> 8) & 0xff);
    mdContext->digest[ii+2] =
      (unsigned char)((mdContext->buf[i] >> 16) & 0xff);
    mdContext->digest[ii+3] =
      (unsigned char)((mdContext->buf[i] >> 24) & 0xff);
  }
}

/* Basic MD5 step. Transforms buf based on in.
 */
static void TransformMD5 (buf, in)
UINT4 *buf;
UINT4 *in;
{
  UINT4 a = buf[0], b = buf[1], c = buf[2], d = buf[3];

  /* Round 1 */
  FF ( a, b, c, d, in[ 0], S11, 0xd76aa478); /* 1 */
  FF ( d, a, b, c, in[ 1], S12, 0xe8c7b756); /* 2 */
  FF ( c, d, a, b, in[ 2], S13, 0x242070db); /* 3 */
  FF ( b, c, d, a, in[ 3], S14, 0xc1bdceee); /* 4 */
  FF ( a, b, c, d, in[ 4], S11, 0xf57c0faf); /* 5 */
  FF ( d, a, b, c, in[ 5], S12, 0x4787c62a); /* 6 */
  FF ( c, d, a, b, in[ 6], S13, 0xa8304613); /* 7 */
  FF ( b, c, d, a, in[ 7], S14, 0xfd469501); /* 8 */
  FF ( a, b, c, d, in[ 8], S11, 0x698098d8); /* 9 */
  FF ( d, a, b, c, in[ 9], S12, 0x8b44f7af); /* 10 */
  FF ( c, d, a, b, in[10], S13, 0xffff5bb1); /* 11 */
  FF ( b, c, d, a, in[11], S14, 0x895cd7be); /* 12 */
  FF ( a, b, c, d, in[12], S11, 0x6b901122); /* 13 */
  FF ( d, a, b, c, in[13], S12, 0xfd987193); /* 14 */
  FF ( c, d, a, b, in[14], S13, 0xa679438e); /* 15 */
  FF ( b, c, d, a, in[15], S14, 0x49b40821); /* 16 */

  /* Round 2 */
  GG ( a, b, c, d, in[ 1], S21, 0xf61e2562); /* 17 */
  GG ( d, a, b, c, in[ 6], S22, 0xc040b340); /* 18 */
  GG ( c, d, a, b, in[11], S23, 0x265e5a51); /* 19 */
  GG ( b, c, d, a, in[ 0], S24, 0xe9b6c7aa); /* 20 */
  GG ( a, b, c, d, in[ 5], S21, 0xd62f105d); /* 21 */
  GG ( d, a, b, c, in[10], S22,  0x2441453); /* 22 */
  GG ( c, d, a, b, in[15], S23, 0xd8a1e681); /* 23 */
  GG ( b, c, d, a, in[ 4], S24, 0xe7d3fbc8); /* 24 */
  GG ( a, b, c, d, in[ 9], S21, 0x21e1cde6); /* 25 */
  GG ( d, a, b, c, in[14], S22, 0xc33707d6); /* 26 */
  GG ( c, d, a, b, in[ 3], S23, 0xf4d50d87); /* 27 */
  GG ( b, c, d, a, in[ 8], S24, 0x455a14ed); /* 28 */
  GG ( a, b, c, d, in[13], S21, 0xa9e3e905); /* 29 */
  GG ( d, a, b, c, in[ 2], S22, 0xfcefa3f8); /* 30 */
  GG ( c, d, a, b, in[ 7], S23, 0x676f02d9); /* 31 */
  GG ( b, c, d, a, in[12], S24, 0x8d2a4c8a); /* 32 */

  /* Round 3 */
  HH ( a, b, c, d, in[ 5], S31, 0xfffa3942); /* 33 */
  HH ( d, a, b, c, in[ 8], S32, 0x8771f681); /* 34 */
  HH ( c, d, a, b, in[11], S33, 0x6d9d6122); /* 35 */
  HH ( b, c, d, a, in[14], S34, 0xfde5380c); /* 36 */
  HH ( a, b, c, d, in[ 1], S31, 0xa4beea44); /* 37 */
  HH ( d, a, b, c, in[ 4], S32, 0x4bdecfa9); /* 38 */
  HH ( c, d, a, b, in[ 7], S33, 0xf6bb4b60); /* 39 */
  HH ( b, c, d, a, in[10], S34, 0xbebfbc70); /* 40 */
  HH ( a, b, c, d, in[13], S31, 0x289b7ec6); /* 41 */
  HH ( d, a, b, c, in[ 0], S32, 0xeaa127fa); /* 42 */
  HH ( c, d, a, b, in[ 3], S33, 0xd4ef3085); /* 43 */
  HH ( b, c, d, a, in[ 6], S34,  0x4881d05); /* 44 */
  HH ( a, b, c, d, in[ 9], S31, 0xd9d4d039); /* 45 */
  HH ( d, a, b, c, in[12], S32, 0xe6db99e5); /* 46 */
  HH ( c, d, a, b, in[15], S33, 0x1fa27cf8); /* 47 */
  HH ( b, c, d, a, in[ 2], S34, 0xc4ac5665); /* 48 */

  /* Round 4 */
  II ( a, b, c, d, in[ 0], S41, 0xf4292244); /* 49 */
  II ( d, a, b, c, in[ 7], S42, 0x432aff97); /* 50 */
  II ( c, d, a, b, in[14], S43, 0xab9423a7); /* 51 */
  II ( b, c, d, a, in[ 5], S44, 0xfc93a039); /* 52 */
  II ( a, b, c, d, in[12], S41, 0x655b59c3); /* 53 */
  II ( d, a, b, c, in[ 3], S42, 0x8f0ccc92); /* 54 */
  II ( c, d, a, b, in[10], S43, 0xffeff47d); /* 55 */
  II ( b, c, d, a, in[ 1], S44, 0x85845dd1); /* 56 */
  II ( a, b, c, d, in[ 8], S41, 0x6fa87e4f); /* 57 */
  II ( d, a, b, c, in[15], S42, 0xfe2ce6e0); /* 58 */
  II ( c, d, a, b, in[ 6], S43, 0xa3014314); /* 59 */
  II ( b, c, d, a, in[13], S44, 0x4e0811a1); /* 60 */
  II ( a, b, c, d, in[ 4], S41, 0xf7537e82); /* 61 */
  II ( d, a, b, c, in[11], S42, 0xbd3af235); /* 62 */
  II ( c, d, a, b, in[ 2], S43, 0x2ad7d2bb); /* 63 */
  II ( b, c, d, a, in[ 9], S44, 0xeb86d391); /* 64 */

  buf[0] += a;
  buf[1] += b;
  buf[2] += c;
  buf[3] += d;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\xtcb\mgroup.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       mgroup.c
//
//  Contents:   LSA Mode Context API
//
//  Classes:
//
//  Functions:
//
//  History:    2-24-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include "xtcbpkg.h"
#include <cryptdll.h>

LIST_ENTRY MachineGroupList ;
CRITICAL_SECTION MachineGroupLock ;
WCHAR MachineLocalName[ MAX_PATH ];

#define LOOPBACK_KEY    L"Loopback"
#define GROUPKEY_VALUE  L"$$GroupKey"

PXTCB_MACHINE_GROUP_ENTRY
MGpCreateGroupEntry(
    PWSTR MachineName,
    PUCHAR Key
    )
{
    PXTCB_MACHINE_GROUP_ENTRY Entry ;
    ULONG Length ;

    Length = wcslen( MachineName ) + 1;
    
    Entry = LocalAlloc( LMEM_FIXED, 
                        sizeof( XTCB_MACHINE_GROUP_ENTRY ) + (Length * sizeof(WCHAR) ) );

    if ( Entry )
    {
        Entry->MachineName = (PWSTR) (Entry + 1);
        CopyMemory( Entry->UniqueKey, 
                    Key, 
                    SEED_KEY_SIZE );

        CopyMemory( Entry->MachineName,
                    MachineName,
                    Length * sizeof(WCHAR) );

        if ( _wcsicmp( MachineName, MachineLocalName ) == 0 )
        {
            Entry->Flags = MGROUP_ENTRY_SELF ;
        }
        else 
        {
            Entry->Flags = 0;
        }

    }

    return Entry ;
    
}

VOID
MGpFreeGroup(
    PXTCB_MACHINE_GROUP Group
    )
{
    ULONG i ;

    for ( i = 0 ; i < Group->Count ; i++ )
    {
        LocalFree( Group->GroupList[ i ] );
    }

    LocalFree( Group );
}

PXTCB_MACHINE_GROUP
MGpCreateMachineGroup(
    HKEY Root,
    PWSTR KeyName
    )
{
    ULONG Count ;
    ULONG Size ;
    ULONG Type ;
    UCHAR Key[ SEED_KEY_SIZE ];
    PWSTR Name ;
    ULONG MaxName ;
    ULONG NameSize ;
    ULONG Index ;
    PXTCB_MACHINE_GROUP Group ;
    int err ;


    err = RegQueryInfoKey(
                Root,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                &Count,
                &MaxName,
                NULL,
                NULL,
                NULL );

    if ( err )
    {
        return NULL ;
    }

    MaxName++;

    Name = LocalAlloc( LMEM_FIXED, (MaxName) * sizeof( WCHAR ) );

    if ( !Name )
    {
        return NULL ;
    }

    Group = LocalAlloc( LMEM_FIXED,
                        sizeof( XTCB_MACHINE_GROUP ) +
                            ( Count ) * sizeof( PXTCB_MACHINE_GROUP_ENTRY ) +
                            ( wcslen( KeyName ) + 1 ) * sizeof( WCHAR ) );

    if ( !Group )
    {
        LocalFree( Name );
        return NULL ;
    }

    //
    // We've got all the base structures.  Let's load it in:
    //

    Group->List.Flink = NULL ;
    Group->List.Blink = NULL ;
    Group->Count = 0 ;
    Group->GroupList = (PXTCB_MACHINE_GROUP_ENTRY *) (Group + 1);
    Group->Group.Buffer = (PWSTR) ((PUCHAR) Group->GroupList + 
                               (Count * sizeof( PXTCB_MACHINE_GROUP_ENTRY ) ) );

    wcscpy( Group->Group.Buffer, KeyName );
    Group->Group.Length = wcslen( Group->Group.Buffer ) * sizeof( WCHAR );
    Group->Group.MaximumLength = Group->Group.Length + sizeof( WCHAR );

    for ( Index = 0 ; Index < Count ; Index++ )
    {
        NameSize = MaxName ;
        Size = SEED_KEY_SIZE ;

        err = RegEnumValue(
                    Root,
                    Index,
                    Name,
                    &NameSize,
                    NULL,
                    &Type,
                    Key,
                    &Size );

        if ( (err == 0) && (Type == REG_BINARY) )
        {
            if ( _wcsicmp( Name, GROUPKEY_VALUE ) == 0 )
            {
                CopyMemory(
                    Group->SeedKey,
                    Key,
                    Size );

                continue;
            }

            Group->GroupList[ Group->Count ] = MGpCreateGroupEntry( Name, Key );
            if ( Group->GroupList[ Group->Count ] )
            {
                Group->Count++ ;
            }
        }

    }

    LocalFree( Name );

    if ( Group->Count == 0 )
    {
        DebugLog(( DEB_ERROR, "No machines found in group %ws\n", KeyName ));
        LocalFree( Group );
        Group = NULL ;
    }

    if ( Group )
    {
        for ( Index = 0 ; Index < Group->Count ; Index++ )
        {
            if ( Group->GroupList[ Index ]->Flags & MGROUP_ENTRY_SELF )
            {
                break;
            }
        }

        if ( Index == Group->Count )
        {
            DebugLog(( DEB_ERROR, "No entry for self found in group %ws\n", KeyName ));
            MGpFreeGroup( Group );
            Group = NULL ;
        }
    }


    return Group ;
}

VOID
MGpCreateLoopback(
    HKEY RootKey
    )
{
    int err ;
    DWORD Disp ;
    HKEY LoopbackKey ;
    UCHAR Random1[ XTCB_SEED_LENGTH ];
    UCHAR Random2[ XTCB_SEED_LENGTH ];


    err =  RegCreateKeyEx(
            RootKey,
            LOOPBACK_KEY,
            0,
            NULL,
            REG_OPTION_VOLATILE,
            KEY_READ | KEY_WRITE,
            NULL,
            &LoopbackKey,
            &Disp );

    if ( err == 0 )
    {
        if ( Disp == REG_OPENED_EXISTING_KEY )
        {
            RegCloseKey( LoopbackKey );
            return;
        }

        CDGenerateRandomBits( Random1, XTCB_SEED_LENGTH );
        CDGenerateRandomBits( Random2, XTCB_SEED_LENGTH );

        (VOID) RegSetValueEx(
                    LoopbackKey,
                    GROUPKEY_VALUE,
                    0,
                    REG_BINARY,
                    Random2,
                    XTCB_SEED_LENGTH );

        (VOID) RegSetValueEx(
                    LoopbackKey,
                    L"LocalHost",
                    0,
                    REG_BINARY,
                    Random1,
                    XTCB_SEED_LENGTH );

        (VOID) RegSetValueEx(
                    LoopbackKey,
                    XtcbUnicodeDnsName.Buffer,
                    0,
                    REG_BINARY,
                    Random1,
                    XTCB_SEED_LENGTH );

        //
        // Enumerate and stick aliases for this machine in the key here.
        //

        RegCloseKey( LoopbackKey );
                
    }
}



BOOL
MGpLoadGroups(
    VOID
    )
{
    HKEY RootKey = NULL ;
    HKEY Enum ;
    int err ;
    DWORD Index ;
    DWORD Disp ;
    PXTCB_MACHINE_GROUP Group ;
    DWORD MaxLen ;
    PWSTR KeyName = NULL ;
    WCHAR Buffer[ 32 ];
    DWORD Len ;
    BOOL Success = FALSE ;
    ULONG KeyCount ;

    err = RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            L"System\\CurrentControlSet\\Control\\LSA\\XTCB\\Groups",
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_READ | KEY_WRITE,
            NULL,
            &RootKey,
            &Disp );

    if ( err )
    {
        return FALSE ;
    }

    MGpCreateLoopback( RootKey );

    err = RegQueryInfoKey(
            RootKey,
            NULL,
            NULL,
            NULL,
            &KeyCount,
            &MaxLen,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL );

    if ( err )
    {
        goto Cleanup ;

    }

    DebugLog(( DEB_TRACE, "Found %d groups\n", KeyCount ));

    if ( MaxLen < 32 )
    {
        KeyName = Buffer ;
        MaxLen = 32 ;
    }
    else 
    {
        KeyName = LocalAlloc( LMEM_FIXED, (MaxLen + 1) * sizeof( WCHAR ) );

        if ( KeyName == NULL )
        {
            goto Cleanup ;
        }
    }

    Index = 0 ;

    while ( Index < KeyCount )
    {

        Len = MaxLen ;
        
        err = RegEnumKeyEx(
                    RootKey,
                    Index,
                    KeyName,
                    &Len,
                    NULL,
                    NULL,
                    NULL,
                    NULL );

        if ( err )
        {
            Index++ ;
            continue;
        }

        err = RegOpenKeyEx(
                RootKey,
                KeyName,
                REG_OPTION_NON_VOLATILE,
                KEY_READ,
                &Enum );

        if ( err )
        {
            err = RegOpenKeyEx(
                        RootKey,
                        KeyName,
                        REG_OPTION_VOLATILE,
                        KEY_READ,
                        &Enum );
        }

        if ( err == 0 )
        {
            DebugLog(( DEB_TRACE, "Processing group %d:%ws\n", Index, KeyName ));

            Group = MGpCreateMachineGroup( Enum, KeyName );

            RegCloseKey( Enum );

            if ( Group )
            {
                InsertTailList( &MachineGroupList, &Group->List );
            }
        }
        else 
        {
            DebugLog(( DEB_TRACE, "Unable to open key %ws\n", KeyName ));
        }

        Index++ ;

    }
    
    Success = TRUE ;


Cleanup:
    if ( RootKey )
    {
        RegCloseKey( RootKey );
    }

    if ( KeyName )
    {
        if ( KeyName != Buffer )
        {
            LocalFree( KeyName );
        }
    }

    return Success ;

}



BOOL
MGroupReload(
    VOID
    )
{
    PLIST_ENTRY List ;
    PXTCB_MACHINE_GROUP Group ;
    BOOL Success ;
    DWORD Size = MAX_PATH ;

    EnterCriticalSection( &MachineGroupLock );

    while ( !IsListEmpty( &MachineGroupList ) )
    {
        List = RemoveHeadList( &MachineGroupList );

        Group = CONTAINING_RECORD( List, XTCB_MACHINE_GROUP, List );

        MGpFreeGroup( Group );
    }

    GetComputerNameEx( ComputerNamePhysicalDnsFullyQualified,
                       MachineLocalName,
                       &Size );

    Success = MGpLoadGroups();

    LeaveCriticalSection( &MachineGroupLock );

    return Success ;

}


BOOL
MGroupInitialize(
    VOID
    )
{
    BOOL Success = TRUE ;
    try {

        InitializeCriticalSection( &MachineGroupLock );
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        Success = FALSE ;
    }

    InitializeListHead( &MachineGroupList );

    if ( Success )
    {
        Success = MGroupReload();
    }

    return Success ;
}

BOOL
MGroupLocateInboundKey(
    IN PSECURITY_STRING GroupName,
    IN PSECURITY_STRING Origin,
    OUT PUCHAR TargetKey,
    OUT PUCHAR GroupKey,
    OUT PUCHAR MyKey
    )
{
    PLIST_ENTRY Scan ;
    PXTCB_MACHINE_GROUP Group ;
    PXTCB_MACHINE_GROUP_ENTRY Entry ;
    PXTCB_MACHINE_GROUP_ENTRY Self = NULL ;
    ULONG i ;
    BOOL Success = FALSE ;


    EnterCriticalSection( &MachineGroupLock );

    Scan = MachineGroupList.Flink ;

    while ( Scan != &MachineGroupList )
    {
        Group = CONTAINING_RECORD( Scan, XTCB_MACHINE_GROUP, List );

        if ( RtlEqualUnicodeString( GroupName,
                                    &Group->Group,
                                    TRUE ) )
        {
            for ( i = 0 ; i < Group->Count ; i++ )
            {
                Entry = Group->GroupList[ i ];
                if ( Entry->Flags & MGROUP_ENTRY_SELF )
                {
                    Self = Entry ;
                }
                if ( _wcsicmp( Origin->Buffer, Entry->MachineName ) == 0 )
                {
                    //
                    // We have a hit:
                    //

                    Success = TRUE ;
                    CopyMemory( TargetKey, Entry->UniqueKey, SEED_KEY_SIZE );
                    CopyMemory( GroupKey, Group->SeedKey, SEED_KEY_SIZE );
                    break;
                }
            }

        }


        if ( Success )
        {
            break;
        }

        Scan = Scan->Flink ;
        Self = NULL ;

    }

    if ( Success && ( Self == NULL ) )
    {
        //
        // Continue through the group, looking for the 
        // self entry
        //
        for (  ; i < Group->Count ; i++ )
        {
            if ( Group->GroupList[ i ]->Flags & MGROUP_ENTRY_SELF )
            {
                Self = Group->GroupList[ i ];
                break;
            }
        }
    }

    if ( Success )
    {
        CopyMemory( MyKey, Self->UniqueKey, SEED_KEY_SIZE );
    }

    LeaveCriticalSection( &MachineGroupLock );

    return Success ;

}

BOOL
MGroupLocateKeys(
    IN PWSTR Target,
    OUT PSECURITY_STRING * GroupName,
    OUT PUCHAR TargetKey,
    OUT PUCHAR GroupKey,
    OUT PUCHAR MyKey
    )
{
    PLIST_ENTRY Scan ;
    PXTCB_MACHINE_GROUP Group ;
    PXTCB_MACHINE_GROUP_ENTRY Entry ;
    PXTCB_MACHINE_GROUP_ENTRY Self = NULL ;
    ULONG i ;
    BOOL Success = FALSE ;


    EnterCriticalSection( &MachineGroupLock );

    Scan = MachineGroupList.Flink ;

    while ( Scan != &MachineGroupList )
    {
        Group = CONTAINING_RECORD( Scan, XTCB_MACHINE_GROUP, List );

        for ( i = 0 ; i < Group->Count ; i++ )
        {
            Entry = Group->GroupList[ i ];
            if ( Entry->Flags & MGROUP_ENTRY_SELF )
            {
                Self = Entry ;
            }
            if ( _wcsicmp( Target, Entry->MachineName ) == 0 )
            {
                //
                // We have a hit:
                //

                Success = TRUE ;
                CopyMemory( TargetKey, Entry->UniqueKey, SEED_KEY_SIZE );
                CopyMemory( GroupKey, Group->SeedKey, SEED_KEY_SIZE );
                *GroupName = &Group->Group ;
                break;
            }
        }

        if ( Success )
        {
            break;
        }

        Scan = Scan->Flink ;
        Self = NULL ;

    }

    if ( Success && ( Self == NULL ) )
    {
        //
        // Continue through the group, looking for the 
        // self entry
        //
        for (  ; i < Group->Count ; i++ )
        {
            if ( Group->GroupList[ i ]->Flags & MGROUP_ENTRY_SELF )
            {
                Self = Group->GroupList[ i ];
                break;
            }
        }
    }

    if ( Success )
    {
        CopyMemory( MyKey, Self->UniqueKey, SEED_KEY_SIZE );
    }

    LeaveCriticalSection( &MachineGroupLock );

    return Success ;
}

BOOL
MGroupParseTarget(
    PWSTR TargetSpn,
    PWSTR * MachineName
    )
{
    PWSTR Scan ;
    PWSTR Tail ;
    PWSTR Copy ;
    ULONG Length ;

    *MachineName = NULL ;

    Scan = wcschr( TargetSpn, L'/' );

    if ( !Scan )
    {
        return FALSE ;
    }

    Scan++ ;
    Tail = wcschr( Scan, L'/' );

    if ( Tail != NULL )
    {
        //
        // three-part SPN (e.g. HOST/hostname.domain.com).
        // null out this slash for now
        //

        *Tail = L'\0';

    }

    Length = wcslen( Scan );

    Copy = LocalAlloc( LMEM_FIXED, (Length + 1) * sizeof( WCHAR ) );

    if ( Copy )
    {
        CopyMemory( Copy, Scan, (Length + 1) * sizeof( WCHAR ) );
    }

    if ( Tail )
    {
        *Tail = L'/' ;
    }

    *MachineName = Copy ;

    return ( Copy != NULL );
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\xtcb\debug.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       debug.c
//
//  Contents:   Debug support
//
//  Classes:
//
//  Functions:
//
//  History:    2-19-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include "xtcbpkg.h"

DEFINE_DEBUG2( XtcbPkg );
DEBUG_KEY   XtcbPkgDebugKeys[] = { {DEB_ERROR,            "Error"},
                                 {DEB_WARN,             "Warning"},
                                 {DEB_TRACE,            "Trace"},
                                 {DEB_TRACE_CREDS,      "Creds"},
                                 {DEB_TRACE_CTXT,       "Context"},
                                 {DEB_TRACE_CALLS,      "Calls"},
                                 {DEB_TRACE_AUTH,       "Auth"},
                                 {0, NULL},
                                 };

void
InitDebugSupport(void)
{
    XtcbPkgInitDebug( XtcbPkgDebugKeys );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\xtcb\ctxtapi.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       ctxtapi.c
//
//  Contents:   LSA Mode Context API
//
//  Classes:
//
//  Functions:
//
//  History:    2-24-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include "xtcbpkg.h"
#include "md5.h"

typedef struct _XTCB_ATTR_MAP {
    ULONG Request ; 
    ULONG Return ;
} XTCB_ATTR_MAP ;

XTCB_ATTR_MAP AcceptMap[] = {
    { ASC_REQ_DELEGATE, ASC_RET_DELEGATE },
    { ASC_REQ_MUTUAL_AUTH, ASC_RET_MUTUAL_AUTH },
    { ASC_REQ_REPLAY_DETECT, ASC_RET_REPLAY_DETECT },
    { ASC_REQ_SEQUENCE_DETECT, ASC_RET_SEQUENCE_DETECT },
    { ASC_REQ_CONFIDENTIALITY, ASC_RET_CONFIDENTIALITY },
    { ASC_REQ_ALLOCATE_MEMORY, ASC_RET_ALLOCATED_MEMORY },
    { ASC_REQ_CONNECTION, ASC_RET_CONNECTION },
    { ASC_REQ_INTEGRITY, ASC_RET_INTEGRITY }
};

XTCB_ATTR_MAP InitMap[] = {
    { ISC_REQ_DELEGATE, ISC_RET_DELEGATE },
    { ISC_REQ_MUTUAL_AUTH, ISC_RET_MUTUAL_AUTH },
    { ISC_REQ_SEQUENCE_DETECT, ISC_RET_MUTUAL_AUTH },
    { ISC_REQ_REPLAY_DETECT, ISC_RET_REPLAY_DETECT },
    { ISC_REQ_CONFIDENTIALITY, ISC_RET_CONFIDENTIALITY },
    { ISC_REQ_ALLOCATE_MEMORY, ISC_RET_ALLOCATED_MEMORY },
    { ISC_REQ_INTEGRITY, ISC_RET_INTEGRITY }
};


ULONG
XtcbMapAttributes(
    ULONG Input,
    BOOL Init
    )
{
    int i;
    ULONG Result = 0 ;

    if ( Init )
    {
        for ( i = 0 ; i < sizeof( InitMap ) / sizeof( XTCB_ATTR_MAP ) ; i++ )
        {
            if ( InitMap[i].Request & Input )
            {
                Result |= InitMap[i].Return ;
            }
        }
    }
    else
    {
        for ( i = 0 ; i < sizeof( AcceptMap ) / sizeof( XTCB_ATTR_MAP ) ; i++ )
        {
            if ( AcceptMap[i].Request & Input )
            {
                Result |= AcceptMap[i].Return ;
            }
        }
    }

    return Result ;
}

//+---------------------------------------------------------------------------
//
//  Function:   XtcbGetState
//
//  Synopsis:   Translates handles to their structures, and pulls out the
//              interesting bits of the input and output buffers
//
//  Arguments:  [dwCredHandle] --
//              [dwCtxtHandle] --
//              [pInput]       --
//              [pOutput]      --
//              [Client]       --
//              [pContext]     --
//              [pCredHandle]  --
//              [pInToken]     --
//              [pOutToken]    --
//
//  History:    3-05-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
XtcbGetState(
    LSA_SEC_HANDLE  dwCredHandle,
    LSA_SEC_HANDLE  dwCtxtHandle,
    PSecBufferDesc  pInput,
    PSecBufferDesc  pOutput,
    BOOL    Client,
    PXTCB_CONTEXT * pContext,
    PXTCB_CRED_HANDLE * pCredHandle,
    PSecBuffer * pInToken,
    PSecBuffer * pOutToken)
{
    SECURITY_STATUS scRet;
    PXTCB_CONTEXT   Context ;
    PXTCB_CRED_HANDLE CredHandle ;
    PSecBuffer  OutToken ;
    PSecBuffer  InToken ;
    ULONG   i;


    if ( dwCtxtHandle )
    {
        Context = (PXTCB_CONTEXT) dwCtxtHandle ;

        if ( !XtcbRefContextRecord( Context ) )
        {
            return SEC_E_INVALID_HANDLE ;
        }

        CredHandle = (PXTCB_CRED_HANDLE) Context->CredHandle ;
    }
    else
    {
        CredHandle = (PXTCB_CRED_HANDLE) dwCredHandle ;

        if ( !CredHandle )
        {
            return SEC_E_INVALID_HANDLE ;
        }

        Context = XtcbCreateContextRecord( (Client ?
                                                XtcbContextClient :
                                                XtcbContextServer),
                                           CredHandle );

        if ( !Context )
        {
            return SEC_E_INSUFFICIENT_MEMORY ;
        }
    }

    //
    // Find the output token buffer:
    //

    OutToken = NULL ;

    for ( i = 0 ; i < pOutput->cBuffers ; i++ )
    {
        if ( (pOutput->pBuffers[i].BufferType & (~SECBUFFER_ATTRMASK)) ==
                    SECBUFFER_TOKEN )
        {
            OutToken = &pOutput->pBuffers[i] ;
            LsaTable->MapBuffer( OutToken, OutToken );
            break;
        }
    }

    //
    // Find the input token buffer:
    //

    InToken = NULL ;

    for ( i = 0 ; i < pInput->cBuffers ; i++ )
    {
        if ( (pInput->pBuffers[i].BufferType & (~SECBUFFER_ATTRMASK)) ==
                    SECBUFFER_TOKEN )
        {
            InToken = &pInput->pBuffers[i] ;
            LsaTable->MapBuffer( InToken, InToken );
            break;
        }
    }

    *pContext = Context ;
    *pCredHandle = CredHandle ;
    *pInToken = InToken ;
    *pOutToken = OutToken ;

    return SEC_E_OK ;
}

//+---------------------------------------------------------------------------
//
//  Function:   XtcbInitLsaModeContext
//
//  Synopsis:   Creates a client side context and blob
//
//  Arguments:  [dwCredHandle]  --
//              [dwCtxtHandle]  --
//              [pszTargetName] --
//              [fContextReq]   --
//              [TargetDataRep] --
//              [pInput]        --
//              [pdwNewContext] --
//              [pOutput]       --
//              [pfContextAttr] --
//              [ptsExpiry]     --
//              [pfMapContext]  --
//              [pContextData]  --
//
//  History:    8-15-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
XtcbInitLsaModeContext(
    LSA_SEC_HANDLE      dwCredHandle,
    LSA_SEC_HANDLE      dwCtxtHandle,
    PSECURITY_STRING    TargetName,
    ULONG               fContextReq,
    ULONG               TargetDataRep,
    PSecBufferDesc      pInput,
    PLSA_SEC_HANDLE     pdwNewContext,
    PSecBufferDesc      pOutput,
    PULONG              pfContextAttr,
    PTimeStamp          ptsExpiry,
    PBYTE               pfMapContext,
    PSecBuffer          pContextData)
{
    SECURITY_STATUS scRet;
    PXTCB_CONTEXT   Context ;
    PXTCB_CRED_HANDLE CredHandle ;
    PSecBuffer  OutToken ;
    PSecBuffer  InToken ;
    UCHAR GroupKey[ SEED_KEY_SIZE ];
    UCHAR UniqueKey[ SEED_KEY_SIZE ];
    UCHAR MyKey[ SEED_KEY_SIZE ];
    PWSTR Target ;
    BOOL RealTarget = FALSE ;
    PUCHAR Buffer;
    ULONG BufferLen ;
    PUNICODE_STRING Group ;


    DebugLog(( DEB_TRACE_CALLS, "InitLsaModeContext( %p, %p, %ws, ... )\n",
                dwCredHandle, dwCtxtHandle,
                (TargetName->Buffer ? TargetName->Buffer : L"<none>") ));

    if ( fContextReq & 
         ( ISC_REQ_PROMPT_FOR_CREDS |
           ISC_REQ_USE_SUPPLIED_CREDS |
           ISC_REQ_DATAGRAM |
           ISC_REQ_STREAM |
           ISC_REQ_NULL_SESSION |
           ISC_REQ_MANUAL_CRED_VALIDATION ) )
    {
        return STATUS_INVALID_PARAMETER ;
    }

    //
    // Determine what kind of call this is (first or second)
    //

    scRet = XtcbGetState(   dwCredHandle,
                            dwCtxtHandle,
                            pInput,
                            pOutput,
                            TRUE,
                            &Context,
                            &CredHandle,
                            &InToken,
                            &OutToken );

    if ( FAILED( scRet ) )
    {
        return scRet ;
    }


    //
    // Decide what to do:
    //


    if ( Context->Core.State == ContextFirstCall )
    {
        if ( InToken )
        {
            //
            // Something there
            //
            scRet = SEC_E_INVALID_TOKEN ;
        }
        else
        {

            if ( !OutToken )
            {
                scRet = SEC_E_INVALID_TOKEN ;
            }
            else 
            {
                //
                // Examine the target name.  See if we can handle it:
                //

                if ( MGroupParseTarget( TargetName->Buffer,
                                        &Target ) )
                {
                    //
                    // See if we have a group with that machine as a member:
                    //

                    if ( MGroupLocateKeys( Target,
                                           &Group,
                                           UniqueKey,
                                           GroupKey,
                                           MyKey ) )
                    {
                        //
                        // We do have one!  Calooh!  Calay!
                        //

                        RealTarget = TRUE ;

                    }

                }

                if ( !RealTarget )
                {
                    //
                    // Not one of ours.  Delete the context, 
                    // clean up
                    //

                    scRet = SEC_E_TARGET_UNKNOWN ;
                }

            }

            if ( RealTarget )
            {
                //
                // We've got a live target.  Fill in the context, and construct
                // the blob
                //

                scRet = XtcbBuildInitialToken(
                            CredHandle->Creds,
                            Context,
                            TargetName,
                            Group,
                            UniqueKey,
                            GroupKey,
                            MyKey,
                            &Buffer,
                            &BufferLen );



            }


            if ( NT_SUCCESS( scRet ) )
            {

                if ( fContextReq & ISC_REQ_ALLOCATE_MEMORY )
                {
                    OutToken->pvBuffer = Buffer ;
                    OutToken->cbBuffer = BufferLen ;
                }
                else 
                {
                    if ( BufferLen <= OutToken->cbBuffer )
                    {
                        RtlCopyMemory( 
                            OutToken->pvBuffer,
                            Buffer,
                            BufferLen );

                        OutToken->cbBuffer = BufferLen ;
                    }
                    else 
                    {
                        scRet = SEC_E_INSUFFICIENT_MEMORY ;
                    }
                }


            }

            if ( NT_SUCCESS( scRet ) )
            {

                Context->Core.State = ContextSecondCall ;
                Context->Core.Attributes = fContextReq ;

                *pdwNewContext = (LSA_SEC_HANDLE) Context ;
            }
            else 
            {
                XtcbDerefContextRecord( Context );

            }


            return scRet ;
        }
    }
    else
    {
        //
        // Second round
        //

        
    }


    return( scRet );


}


//+---------------------------------------------------------------------------
//
//  Function:   XtcbDeleteContext
//
//  Synopsis:   Deletes the LSA side of a context
//
//  Arguments:  [dwCtxtHandle] --
//
//  History:    8-15-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
XtcbDeleteContext(
    LSA_SEC_HANDLE dwCtxtHandle
    )
{
    PXTCB_CONTEXT Context ;

    DebugLog(( DEB_TRACE_CALLS, "DeleteContext( %x )\n", dwCtxtHandle ));

    Context = (PXTCB_CONTEXT) dwCtxtHandle ;

    if ( XtcbRefContextRecord( Context ) )
    {
        XtcbDerefContextRecord( Context );

        XtcbDerefContextRecord( Context );

        return SEC_E_OK ;
    }

    return( SEC_E_INVALID_HANDLE );
}


//+---------------------------------------------------------------------------
//
//  Function:   XtcbApplyControlToken
//
//  Synopsis:   Apply a control token to a context
//
//  Effects:    not supported
//
//  Arguments:  [dwCtxtHandle] --
//              [pInput]       --
//
//  History:    8-15-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------


SECURITY_STATUS
SEC_ENTRY
XtcbApplyControlToken(
    LSA_SEC_HANDLE dwCtxtHandle,
    PSecBufferDesc  pInput)
{
    DebugLog(( DEB_TRACE_CALLS, "ApplyControlToken( %x )\n", dwCtxtHandle ));

    return(SEC_E_UNSUPPORTED_FUNCTION);
}


//+---------------------------------------------------------------------------
//
//  Function:   XtcbAcceptLsaModeContext
//
//  Synopsis:   Creates a server side context representing the user connecting
//
//  Arguments:  [dwCredHandle]  --
//              [dwCtxtHandle]  --
//              [pInput]        --
//              [fContextReq]   --
//              [TargetDataRep] --
//              [pdwNewContext] --
//              [pOutput]       --
//              [pfContextAttr] --
//              [ptsExpiry]     --
//              [pfMapContext]  --
//              [pContextData]  --
//
//  History:    8-15-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
XtcbAcceptLsaModeContext(
    LSA_SEC_HANDLE  dwCredHandle,
    LSA_SEC_HANDLE  dwCtxtHandle,
    PSecBufferDesc  pInput,
    ULONG           fContextReq,
    ULONG           TargetDataRep,
    PLSA_SEC_HANDLE pdwNewContext,
    PSecBufferDesc  pOutput,
    PULONG          pfContextAttr,
    PTimeStamp      ptsExpiry,
    PBYTE           pfMapContext,
    PSecBuffer      pContextData)
{
    SECURITY_STATUS scRet;
    PXTCB_CONTEXT   Context ;
    PXTCB_CRED_HANDLE CredHandle ;
    PSecBuffer  OutToken ;
    PSecBuffer  InToken ;
    HANDLE      Token ;
    UNICODE_STRING Client;
    UNICODE_STRING Group ;
    UCHAR GroupKey[ SEED_KEY_SIZE ];
    UCHAR UniqueKey[ SEED_KEY_SIZE ];
    UCHAR MyKey[ SEED_KEY_SIZE ];
    BOOL Success = FALSE ;

    DebugLog(( DEB_TRACE_CALLS, "AcceptLsaModeContext( %x, %x, ... )\n",
                    dwCredHandle, dwCtxtHandle ));


    //
    // Determine what kind of call this is (first or second)
    //

    *pfMapContext = FALSE ;

    scRet = XtcbGetState(   dwCredHandle,
                            dwCtxtHandle,
                            pInput,
                            pOutput,
                            FALSE,
                            &Context,
                            &CredHandle,
                            &InToken,
                            &OutToken );

    if ( FAILED( scRet ) )
    {
        return scRet ;
    }


    //
    // Decide what to do:
    //

    if ( Context->Core.State == ContextFirstCall )
    {
        if ( !InToken )
        {
            return SEC_E_INVALID_TOKEN ;
        }

        if ( !XtcbParseInputToken(
                    InToken->pvBuffer,
                    InToken->cbBuffer,
                    &Client,
                    &Group ) )
        {
            DebugLog((DEB_TRACE, "Unable to parse input token\n" ));

            return SEC_E_INVALID_TOKEN ;
        }

        Success = MGroupLocateInboundKey(
                            &Group,
                            &Client,
                            UniqueKey,
                            GroupKey,
                            MyKey );

        LocalFree( Client.Buffer );
        LocalFree( Group.Buffer );

        if ( Success )
        {
            scRet = XtcbAuthenticateClient(
                        Context,
                        InToken->pvBuffer,
                        InToken->cbBuffer,
                        UniqueKey,
                        GroupKey,
                        MyKey
                        );
                        

        }
        else 
        {
            DebugLog(( DEB_TRACE, "Unable to find group entry for Group %ws, Client %ws\n",
                        Group.Buffer, Client.Buffer ));

            scRet = SEC_E_INVALID_TOKEN ;
        }

        if ( NT_SUCCESS( scRet ) )
        {
            scRet = XtcbBuildReplyToken(
                        Context,
                        fContextReq,
                        OutToken );
        }

        if ( NT_SUCCESS( scRet ) )
        {

            Context->Core.State = ContextSecondCall ;
            //
            // Ok, we've done the authentication.  Now, we need to map
            // the security context back to the client process
            //

            scRet = LsaTable->DuplicateHandle(
                                Context->Token,
                                &Token );

            if ( NT_SUCCESS( scRet ) )
            {
                Context->Core.CoreTokenHandle = HandleToUlong( Token );

                *pfMapContext = TRUE ;

                pContextData->BufferType = SECBUFFER_TOKEN ;
                pContextData->cbBuffer = sizeof( XTCB_CONTEXT_CORE );
                pContextData->pvBuffer = &Context->Core ;

                *pfContextAttr = ASC_RET_DELEGATE |
                                 ASC_RET_MUTUAL_AUTH |
                                 ASC_RET_REPLAY_DETECT |
                                 ASC_RET_SEQUENCE_DETECT |
                                 ASC_RET_CONFIDENTIALITY |
                                 ASC_
            }

            
        }


    }

    return( scRet );
}

//+---------------------------------------------------------------------------
//
//  Function:   XtcbQueryLsaModeContext
//
//  Synopsis:   Lifespan is thunked to LSA mode for demonstration purposes
//
//  Arguments:  [ContextHandle]    --
//              [ContextAttribute] --
//              [pBuffer]          --
//
//  History:    3-30-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
NTAPI
XtcbQueryLsaModeContext(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG ContextAttribute,
    IN OUT PVOID pBuffer
    )
{
    PXTCB_CONTEXT Context ;
    NTSTATUS Status ;

    Context = (PXTCB_CONTEXT) ContextHandle ;

    if ( !XtcbRefContextRecord( Context ))
    {
        return SEC_E_INVALID_HANDLE ;
    }

    Status = SEC_E_UNSUPPORTED_FUNCTION ;

    XtcbDerefContextRecord( Context );

    return( Status );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\xtcb\protocol.h ===
#ifndef __PROTOCOL_H__
#define __PROTOCOL_H__


#define XTCB_SEED_LENGTH    16
#define XTCB_HMAC_LENGTH    16

typedef struct _XTCB_INIT_MESSAGE {
    ULONG   Version ;
    ULONG   Length ;
    UCHAR   Seed[ XTCB_SEED_LENGTH ];
    UCHAR   HMAC[ XTCB_HMAC_LENGTH ];
    UNICODE_STRING32 OriginatingNode ;
    UNICODE_STRING32 Group ;
    ULONG   PacOffset ;
    ULONG   PacLength ;
} XTCB_INIT_MESSAGE, * PXTCB_INIT_MESSAGE ;

typedef struct _XTCB_INIT_MESSAGE_REPLY {
    ULONG   Version ;
    ULONG   Length ;
    UCHAR   ReplySeed[ XTCB_SEED_LENGTH ];
    UCHAR   HMAC[ XTCB_HMAC_LENGTH ];
} XTCB_INIT_MESSAGE_REPLY, * PXTCB_INIT_MESSAGE_REPLY ;

typedef struct _XTCB_MESSAGE_SIGNATURE {
    ULONG   Version ;
    UCHAR   HMAC[ XTCB_HMAC_LENGTH ];
    ULONG   SequenceNumber ;
} XTCB_MESSAGE_SIGNATURE, * PXTCB_MESSAGE_SIGNATURE ;

typedef struct _XTCB_PAC {
    ULONG   Tag ;
    ULONG   Length ;

    ULONG   UserOffset ;
    ULONG   GroupCount ;
    ULONG   GroupOffset ;
    ULONG   UserLength ;
    ULONG   GroupLength ;
    ULONG   RestrictionCount ;
    ULONG   RestrictionOffset ;
    ULONG   RestrictionLength ;
    ULONG   NameOffset;
    ULONG   NameLength;
    ULONG   DomainOffset;
    ULONG   DomainLength;
    ULONG   CredentialOffset ;
    ULONG   CredentialLength ;

    UCHAR   UniqueTag[ XTCB_SEED_LENGTH ];
} XTCB_PAC, * PXTCB_PAC ;    

#define XTCB_PAC_TAG    'BCTX'

                      
#endif // __PROTOCOL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\xtcb\protocol.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       protocol.c
//
//  Contents:   Implements the XTCB protocol
//
//  Classes:
//
//  Functions:
//
//  History:    3-01-00   RichardW   Created
//
//----------------------------------------------------------------------------

#include "xtcbpkg.h"
#include "md5.h"
#include "hmac.h"
#include <cryptdll.h>

//
// The protocol is very straight-forward.  For any group, we have the following:
//
//      A Group Key (G)
//      A Client Key (C)
//      A Server Key (S)
//
//
// The protocol is as follows:
//
//  Client (C) sends a message to the server, consisting of:
//          A random seed [ R ]
//          The client's PAC
//          Name of the client and group
//          HMAC( G, S, R, PAC, Name )
//
//  Both sides create CS and SC keys by:
//          CS = HMAC( [S], G, R, "string1")
//          SC = HMAC( [C], G, R, "string2")
//
//  The server (S) verifies the HMAC, and replies with:
//          A different seed [ R2 ]
//          HMAC( G, C, R2 )
//

#define CS_HMAC_STRING  "Fairly long string for the client-server session key derivation"
#define SC_HMAC_STRING  "Equally long string to derive server-client session key for now"

LARGE_INTEGER XtcbExpirationTime = { 0xFFFFFFFF, 0x6FFFFFFF };

typedef struct _XTCB_HMAC {
    HMACMD5_CTX Context ;
} XTCB_HMAC, * PXTCB_HMAC;

PXTCB_HMAC
XtcbInitHmac(
    PUCHAR IndividualKey,
    PUCHAR GroupKey
    )
{
    PXTCB_HMAC HMac;
    UCHAR Key[ XTCB_SEED_LENGTH * 2 ];

    HMac = LocalAlloc( LMEM_FIXED, sizeof( XTCB_HMAC ) );

    if ( HMac )
    {
        RtlCopyMemory( Key,
                       IndividualKey,
                       XTCB_SEED_LENGTH );

        RtlCopyMemory( Key+XTCB_SEED_LENGTH,
                       GroupKey,
                       XTCB_SEED_LENGTH );

        HMACMD5Init( &HMac->Context,
                     Key,
                     XTCB_SEED_LENGTH * 2 );


    }

    return HMac ;
}

PXTCB_HMAC
XtcbPrepareHmac(
    PXTCB_HMAC HMac
    )
{
    PXTCB_HMAC Working ;

    Working = LocalAlloc( LMEM_FIXED, sizeof( XTCB_HMAC ) );

    return Working ;
}

#define XtcbHmacUpdate( H, p, s ) \
    HMACMD5Update( &((PXTCB_HMAC)H)->Context, p, s )



VOID
XtcbDeriveKeys(
    PXTCB_CONTEXT Context,
    PUCHAR ServerKey,
    PUCHAR GroupKey,
    PUCHAR ClientKey,
    PUCHAR RandomSeed
    )
{
    HMACMD5_CTX HMac ;

    HMACMD5Init( &HMac, ServerKey, XTCB_SEED_LENGTH );

    HMACMD5Update( &HMac, GroupKey, XTCB_SEED_LENGTH );

    HMACMD5Update( &HMac, RandomSeed, XTCB_SEED_LENGTH );

    HMACMD5Update( &HMac, CS_HMAC_STRING, sizeof( CS_HMAC_STRING ) );

    if ( Context->Core.Type == XtcbContextServer )
    {
        HMACMD5Final( &HMac, Context->Core.InboundKey );
    }
    else 
    {
        HMACMD5Final( &HMac, Context->Core.OutboundKey );
    }

    HMACMD5Init( &HMac, ClientKey, XTCB_SEED_LENGTH );
    
    HMACMD5Update( &HMac, GroupKey, XTCB_SEED_LENGTH );

    HMACMD5Update( &HMac, RandomSeed, XTCB_SEED_LENGTH );

    HMACMD5Update( &HMac, SC_HMAC_STRING, sizeof( SC_HMAC_STRING ) );

    if ( Context->Core.Type == XtcbContextServer )
    {
        HMACMD5Final( &HMac, Context->Core.OutboundKey );
    }
    else 
    {
        HMACMD5Final( &HMac, Context->Core.InboundKey );
    }
}



SECURITY_STATUS
XtcbBuildInitialToken(
    PXTCB_CREDS Creds,
    PXTCB_CONTEXT Context,
    PSECURITY_STRING Target,
    PSECURITY_STRING Group,
    PUCHAR ServerKey,
    PUCHAR GroupKey,
    PUCHAR ClientKey,
    PUCHAR * Token,
    PULONG TokenLen
    )
{
    PXTCB_HMAC HMac ;
    PXTCB_INIT_MESSAGE Message ;
    PUCHAR CopyTo ;
    PUCHAR Base ;

    Message = LsaTable->AllocateLsaHeap( sizeof( XTCB_INIT_MESSAGE ) +
                                         Creds->Pac->Length +
                                         XtcbUnicodeDnsName.Length +
                                         Group->Length );

    if ( !Message )
    {
        return SEC_E_INSUFFICIENT_MEMORY ;
    }

    CDGenerateRandomBits( Message->Seed, XTCB_SEED_LENGTH );

    //
    // Create keys in the context
    //

    XtcbDeriveKeys(
        Context,
        ServerKey,
        GroupKey,
        ClientKey,
        Message->Seed );

    //
    // Set random seed in the context
    //

    RtlCopyMemory(
        Context->Core.RootKey,
        Message->Seed,
        XTCB_SEED_LENGTH );


    //
    // Fill it in:
    //

    Message->Version = 1 ;
    Message->Length = sizeof( XTCB_INIT_MESSAGE ) +
                      Creds->Pac->Length +
                      XtcbUnicodeDnsName.Length +
                      Group->Length ;




    RtlZeroMemory( Message->HMAC, XTCB_HMAC_LENGTH );

    CopyTo = (PUCHAR) ( Message + 1 );
    Base = (PUCHAR) Message;

    RtlCopyMemory(
        CopyTo,
        Creds->Pac,
        Creds->Pac->Length );

    Message->PacOffset = (ULONG) (CopyTo - Base);
    Message->PacLength = Creds->Pac->Length ;
    CopyTo += Creds->Pac->Length ;
    RtlCopyMemory(
        CopyTo,
        XtcbUnicodeDnsName.Buffer,
        XtcbUnicodeDnsName.Length );

    Message->OriginatingNode.Buffer = (ULONG) (CopyTo - Base );
    Message->OriginatingNode.Length = XtcbUnicodeDnsName.Length ;
    Message->OriginatingNode.MaximumLength = XtcbUnicodeDnsName.Length ;

    CopyTo+= XtcbUnicodeDnsName.Length ;
    RtlCopyMemory(
        CopyTo,
        Group->Buffer,
        Group->Length );

    Message->Group.Buffer = (ULONG) (CopyTo - Base );
    Message->Group.Length = Group->Length ;
    Message->Group.MaximumLength = Group->Length ;
    

    //
    // Structure complete.
    //

    //
    // Do HMAC
    //


    *Token = (PUCHAR) Message ;
    *TokenLen = Message->Length ;

    return SEC_I_CONTINUE_NEEDED ;

}

BOOL
XtcbParseInputToken(
    IN PUCHAR Token,
    IN ULONG TokenLength,
    OUT PSECURITY_STRING Client,
    OUT PSECURITY_STRING Group
    )
{
    PXTCB_INIT_MESSAGE Message ;
    PWSTR Scan ;
    PUCHAR End ;
    ULONG Chars;
    UNICODE_STRING String = { 0 };
    BOOL Success = FALSE ;

    *Client = String ;
    *Group = String ;

    if ( TokenLength < sizeof( XTCB_INIT_MESSAGE ) )
    {
        goto ParseExit;

    }

    Message = (PXTCB_INIT_MESSAGE) Token ;

    if ( Message->Length != TokenLength )
    {
        goto ParseExit;
    }

    End = Token + Message->Length ;

    String.Length = Message->OriginatingNode.Length ;
    String.Buffer = (PWSTR) (Token + Message->OriginatingNode.Buffer );
    String.MaximumLength = String.Length ;

    if ( (PUCHAR) String.Buffer + String.Length > End )
    {
        goto ParseExit;
    }

    if ( !XtcbDupSecurityString( Client, &String ) )
    {
        goto ParseExit;
    }

    String.Length = Message->Group.Length ;
    String.Buffer = (PWSTR) (Token + Message->Group.Buffer );
    String.MaximumLength = String.Length ;
    
    if ( (PUCHAR) String.Buffer + String.Length > End )
    {
        goto ParseExit;
    }

    if ( !XtcbDupSecurityString( Group, &String ))
    {
        goto ParseExit ;
    }

    Success = TRUE ;


ParseExit:

    if ( !Success )
    {
        if ( Client->Buffer )
        {
            LocalFree( Client->Buffer );
        }

        if ( Group->Buffer )
        {
            LocalFree( Group->Buffer );
        }
    }

    return Success ;

}


SECURITY_STATUS
XtcbAuthenticateClient(
    PXTCB_CONTEXT Context,
    PUCHAR Token,
    ULONG TokenLength,
    PUCHAR ClientKey,
    PUCHAR GroupKey,
    PUCHAR MyKey
    )
{
    PXTCB_INIT_MESSAGE Message ;
    PXTCB_PAC Pac ;
    PLSA_TOKEN_INFORMATION_V2 TokenInfo ;
    ULONG Size ;
    PTOKEN_GROUPS Groups ;
    PUCHAR Scan ;
    PUCHAR Sid1 ;
    NTSTATUS Status = SEC_E_INVALID_TOKEN ;
    PSID Sid ;
    PUCHAR Target ;
    ULONG i ;
    LUID LogonId ;
    UNICODE_STRING UserName ;
    UNICODE_STRING DomainName ;
    HANDLE hToken ;
    NTSTATUS SubStatus ;



    //
    // On entry, we know that the message is in general ok, that the general 
    // bounds are ok, but not the PAC.  So validate the PAC first before using 
    // it.
    //

    Message = (PXTCB_INIT_MESSAGE) Token ;


    XtcbDeriveKeys(
        Context,
        MyKey,
        GroupKey,
        ClientKey,
        Message->Seed );

    //
    // Got the keys.  Let's examine the PAC/
    //

    Pac = (PXTCB_PAC) ( Token + Message->PacOffset );

    if ( ( Pac->Length != Message->PacLength ) ||
         ( Message->PacLength > TokenLength ) ||
         ( Pac->Length > TokenLength ) )
    {
        return SEC_E_INVALID_TOKEN ;
    }

    //
    // Make sure offsets are within bounds.  Each area
    // will still have to confirm that offset + length
    // within limits
    //

    if ( ( Pac->UserOffset > Pac->Length )    ||
         ( Pac->GroupOffset > Pac->Length )   ||
         ( Pac->RestrictionOffset > Pac->Length ) ||
         ( Pac->NameOffset > Pac->Length ) ||
         ( Pac->DomainOffset > Pac->Length ) ||
         ( Pac->CredentialOffset > Pac->Length ) )
    {
        return SEC_E_INVALID_TOKEN ;
    }


    //
    // 1000 is the current LSA limit.  This is not exported to the packages
    // for some reason.  This is hard coded right now, but needs to be 
    // a global define, or a queryable value out of the LSA.
    //

    if ( Pac->GroupCount > 1000 )
    {
        return SEC_E_INVALID_TOKEN ;
    }

    //
    // Looks good, lets start assembling the token information.
    //

    if ( Pac->GroupLength + Pac->GroupOffset > Pac->Length )
    {
        return SEC_E_INVALID_TOKEN ;
    }

    Size = sizeof( LSA_TOKEN_INFORMATION_V2 ) +       // Basic info
            ( Pac->GroupLength ) +                    // All the group SIDs
            ( Pac->UserLength ) +                     // User SID
            ROUND_UP_COUNT( ( ( Pac->GroupCount * sizeof( SID_AND_ATTRIBUTES ) ) +
                            sizeof( TOKEN_GROUPS ) ), ALIGN_LPVOID ) ;

    TokenInfo = LsaTable->AllocateLsaHeap( Size );

    if ( TokenInfo == NULL )
    {
        return SEC_E_INSUFFICIENT_MEMORY ;
    }

    //
    // Now fill in this structure.  
    //

    TokenInfo->ExpirationTime = XtcbExpirationTime ;

    TokenInfo->DefaultDacl.DefaultDacl = NULL ;

    TokenInfo->Privileges = NULL ;

    TokenInfo->Owner.Owner = NULL ;

    //
    // Set up initial pointers:
    //

    Groups = (PTOKEN_GROUPS) ( TokenInfo + 1 );
    Target = (PSID) ( (PUCHAR) Groups + 
                      ROUND_UP_COUNT( ( ( Pac->GroupCount * sizeof( SID_AND_ATTRIBUTES ) ) +
                                    sizeof( TOKEN_GROUPS ) ), ALIGN_LPVOID )  );

    //
    // Copy over the user SID
    //

    if ( Pac->UserOffset + Pac->UserLength > Pac->Length )
    {
        Status = SEC_E_INVALID_TOKEN ;

        goto Cleanup ;
    }

    Sid = (PSID) ((PUCHAR) Pac + Pac->UserOffset) ;

    if ( !RtlValidSid( Sid ) )
    {
        Status = SEC_E_INVALID_TOKEN ;
        
        goto Cleanup ;

    }

    if ( RtlLengthSid( Sid ) != Pac->UserLength )
    {
        Status = SEC_E_INVALID_TOKEN ;

        goto Cleanup ;
    }

    RtlCopySid( Pac->UserLength,
                (PSID) Target,
                Sid );

    Target += RtlLengthSid( Sid );

    TokenInfo->User.User.Sid = (PSID) Target ;
    TokenInfo->User.User.Attributes = 0 ;


    //
    // Now, do the groups.  Since all the SIDs are in one
    // contiguous block, the plan is to copy them over 
    // whole, then iterate through the list and fix up the 
    // pointers in the group list.
    //

    RtlCopyMemory(
        Target,
        (PUCHAR) Pac + Pac->GroupOffset,
        Pac->GroupLength );


    Scan = Target ;
    Target += Pac->GroupLength ;
    i = 0 ;

    while ( Scan < Target )
    {
        Sid = (PSID) Scan ;

        if ( RtlValidSid( Sid ) )
        {
            //
            // This is an ok SID.
            //

            Groups->Groups[ i ].Sid = Sid ;
            Groups->Groups[ i ].Attributes = SE_GROUP_MANDATORY |
                                             SE_GROUP_ENABLED |
                                             SE_GROUP_ENABLED_BY_DEFAULT ;

            if ( i == 0 )
            {
                TokenInfo->PrimaryGroup.PrimaryGroup = Sid ;
            }

            i++ ;

            Scan += RtlLengthSid( Sid );
        }
        else 
        {
            break;
        }

    }
                
    //
    // On exit, if Scan is less than Target, then we failed to
    // process all the SIDs.  Bail out
    //

    if ( Scan < Target )
    {
        Status = SEC_E_INVALID_TOKEN ;
        goto Cleanup ;
    }

    //
    // Pull out the user name/etc
    //

    if ( Pac->NameLength + Pac->NameOffset > Pac->Length )
    {
        Status = SEC_E_INVALID_TOKEN ;
        goto Cleanup ;
    }

    UserName.Buffer = (PWSTR) ((PUCHAR) Pac + Pac->NameOffset);
    UserName.Length = (WORD) Pac->NameLength ;
    UserName.MaximumLength = UserName.Length ;


    if ( Pac->DomainLength + Pac->DomainOffset > Pac->Length )
    {
        Status = SEC_E_INVALID_TOKEN ;
        goto Cleanup ;
    }

    DomainName.Buffer = (PWSTR) ((PUCHAR) Pac + Pac->DomainOffset );
    DomainName.Length = (WORD) Pac->DomainLength ;
    DomainName.MaximumLength = DomainName.Length ;

    //
    // We've assembled the token info.  Now, create the logon session
    //

    DebugLog(( DEB_TRACE, "Creating logon for %wZ\\%wZ\n", &DomainName, 
               &UserName ));


    AllocateLocallyUniqueId( &LogonId );

    Status = LsaTable->CreateLogonSession( &LogonId );

    if ( !NT_SUCCESS( Status ) )
    {
        goto Cleanup ;
    }

    //
    // Create the token to represent this user:
    //

    Status = LsaTable->CreateToken(
                    &LogonId,
                    &XtcbSource,
                    Network,
                    TokenImpersonation,
                    LsaTokenInformationV2,
                    TokenInfo,
                    NULL,
                    &UserName,
                    &DomainName,
                    &XtcbComputerName,
                    NULL,
                    &hToken,
                    &SubStatus );

    TokenInfo = NULL ;

    if ( NT_SUCCESS( Status ) )
    {
        Status = SubStatus ;
    }

    if ( NT_SUCCESS( Status ) )
    {
        Context->Token = hToken ;
    }

Cleanup:
    
    if ( TokenInfo )
    {
        LsaTable->FreeLsaHeap( TokenInfo );
    }

    return Status ;
}


SECURITY_STATUS
XtcbBuildReplyToken(
    PXTCB_CONTEXT Context,
    ULONG   fContextReq,
    PSecBuffer pOutput
    )
{
    PXTCB_INIT_MESSAGE_REPLY Reply ;
    NTSTATUS Status ;

    if ( fContextReq & ASC_REQ_ALLOCATE_MEMORY )
    {
        Reply = LsaTable->AllocateLsaHeap( sizeof( XTCB_INIT_MESSAGE_REPLY ) );
    }
    else 
    {
        if ( pOutput->cbBuffer >= sizeof( XTCB_INIT_MESSAGE_REPLY ) )
        {
            Reply = pOutput->pvBuffer ;
        }
        else 
        {
            Reply = NULL ;
        }
    }

    if ( Reply == NULL )
    {
        Status = SEC_E_INSUFFICIENT_MEMORY ;

        goto Cleanup ;
    }

    Reply->Version = 1;
    Reply->Length = sizeof( XTCB_INIT_MESSAGE_REPLY );

    CDGenerateRandomBits( 
            Reply->ReplySeed, 
            XTCB_SEED_LENGTH );

    pOutput->cbBuffer = sizeof( XTCB_INIT_MESSAGE_REPLY );
    pOutput->pvBuffer = Reply ;
    Reply = NULL ;
    

Cleanup:
    if ( Reply )
    {
        LsaTable->FreeLsaHeap( Reply );
    }
    return Status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\xtcb\protos.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       protos.h
//
//  Contents:   Xtcb Security Package Prototypes
//
//  Classes:
//
//  Functions:
//
//  History:    2-19-97   RichardW   Created
//
//----------------------------------------------------------------------------


SpInitializeFn                  XtcbInitialize;
SpGetInfoFn                     XtcbGetInfo;

SpAcceptCredentialsFn           XtcbAcceptCredentials;
SpAcquireCredentialsHandleFn    XtcbAcquireCredentialsHandle;
SpFreeCredentialsHandleFn       XtcbFreeCredentialsHandle;
SpQueryCredentialsAttributesFn  XtcbQueryCredentialsAttributes;
SpSaveCredentialsFn             XtcbSaveCredentials;
SpGetCredentialsFn              XtcbGetCredentials;
SpDeleteCredentialsFn           XtcbDeleteCredentials;

SpInitLsaModeContextFn          XtcbInitLsaModeContext;
SpDeleteContextFn               XtcbDeleteContext;
SpAcceptLsaModeContextFn        XtcbAcceptLsaModeContext;

LSA_AP_LOGON_TERMINATED         XtcbLogonTerminated;
SpApplyControlTokenFn           XtcbApplyControlToken;
LSA_AP_CALL_PACKAGE             XtcbCallPackage;
LSA_AP_CALL_PACKAGE             XtcbCallPackageUntrusted;
SpShutdownFn                    XtcbShutdown;
SpGetUserInfoFn                 XtcbGetUserInfo;

SpInstanceInitFn                XtcbInstanceInit;
SpInitUserModeContextFn         XtcbInitUserModeContext;
SpMakeSignatureFn               XtcbMakeSignature;
SpVerifySignatureFn             XtcbVerifySignature;
SpSealMessageFn                 XtcbSealMessage;
SpUnsealMessageFn               XtcbUnsealMessage;
SpGetContextTokenFn             XtcbGetContextToken;
SpQueryContextAttributesFn      XtcbQueryContextAttributes;
SpDeleteContextFn               XtcbDeleteUserModeContext;
SpCompleteAuthTokenFn           XtcbCompleteAuthToken;
SpFormatCredentialsFn           XtcbFormatCredentials;
SpMarshallSupplementalCredsFn   XtcbMarshallSupplementalCreds;

SpGetExtendedInformationFn      XtcbGetExtendedInformation ;
SpQueryContextAttributesFn      XtcbQueryLsaModeContext ;


//////////////////////////////
//
// Misc. Utility functions
//
//////////////////////////////


BOOL
XtcbDupSecurityString(
    PSECURITY_STRING    Dest,
    PSECURITY_STRING    Source
    );

BOOL
XtcbDupStringToSecurityString(
    PSECURITY_STRING    Dest,
    PWSTR               Source
    );

BOOL
XtcbCaptureAuthData(
    PVOID   pvAuthData,
    PSEC_WINNT_AUTH_IDENTITY * AuthData
    );

BOOL
XtcbGenerateChallenge(
    PUCHAR  Challenge,
    ULONG   Length,
    PULONG  Actual
    );

BOOL
XtcbAnsiStringToSecurityString(
    PSECURITY_STRING    Dest,
    PSTRING             Source
    );

BOOL
XtcbSecurityStringToAnsiString(
    PSTRING Dest,
    PSECURITY_STRING Source
    );

PXTCB_PAC
XtcbCreatePacForCaller(
    VOID
    );

SECURITY_STATUS
XtcbBuildInitialToken(
    PXTCB_CREDS Creds,
    PXTCB_CONTEXT Context,
    PSECURITY_STRING Target,
    PSECURITY_STRING Group,
    PUCHAR ServerKey,
    PUCHAR GroupKey,
    PUCHAR ClientKey,
    PUCHAR * Token,
    PULONG TokenLen
    );

BOOL
XtcbParseInputToken(
    IN PUCHAR Token,
    IN ULONG TokenLength,
    OUT PSECURITY_STRING Client,
    OUT PSECURITY_STRING Group
    );

SECURITY_STATUS
XtcbAuthenticateClient(
    PXTCB_CONTEXT Context,
    PUCHAR Token,
    ULONG TokenLength,
    PUCHAR ClientKey,
    PUCHAR GroupKey,
    PUCHAR MyKey
    );

SECURITY_STATUS
XtcbBuildReplyToken(
    PXTCB_CONTEXT Context,
    ULONG   fContextReq,
    PSecBuffer pOutput
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\xtcb\server.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       server.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    3-14-97   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __SERVER_H__
#define __SERVER_H__


typedef struct _XTCB_AUTH_REQ_MESSAGE {
    STRING  Challenge ;
    STRING  Response ;
    STRING  UserName ;
} XTCB_AUTH_REQ_MESSAGE, * PXTCB_AUTH_REQ_MESSAGE ;

typedef struct _XTCB_AUTH_RESP_MESSAGE {
    NTSTATUS Result ;
    NTSTATUS SubCode ;
    PUCHAR  AuthInfo ;
    ULONG   AuthInfoLength ;
} XTCB_AUTH_RESP_MESSAGE, * PXTCB_AUTH_RESP_MESSAGE ;

typedef enum {
    XtcbSrvAuthReq,
    XtcbSrvAuthResp,
    XtcbSrvMax
} XTCB_SERVER_MESSAGE_CODE ;

#define XTCB_SERVER_MESSAGE_TAG      'S5DM'
#define XTCB_MESSAGE_SELF_RELATIVE   0x00000001      // Pointers are offsets
#define XTCB_MESSAGE_ONE_BLOCK       0x00000002      // Pointers are within block

typedef struct _XTCB_SERVER_MESSAGE {
    ULONG Tag ;
    XTCB_SERVER_MESSAGE_CODE Code ;
    ULONG Flags ;
    ULONG DataLength ;
    union {
        XTCB_AUTH_REQ_MESSAGE AuthReq ;
        XTCB_AUTH_RESP_MESSAGE AuthResp ;
    } Message ;
    UCHAR   Data[1] ;
} XTCB_SERVER_MESSAGE, * PXTCB_SERVER_MESSAGE ;

#define XtcbMessageLength( x )   ( sizeof( XTCB_SERVER_MESSAGE ) - 1 + \
                                  ((PXTCB_SERVER_MESSAGE) x)->DataLength )


NTSTATUS
XtcbRemoteAuthHandler(
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );


SECURITY_STATUS
XtcbAuthenticateResponse(
    PSTRING Challenge,
    PSTRING UserName,
    PSTRING Response,
    PVOID * AuthInfo,
    PULONG  AuthInfoLength
    );

SECURITY_STATUS
XtcbLocalLogon(
    PVOID   AuthInfo,
    ULONG   AuthInfoLength,
    PLUID   NewLogonId,
    PHANDLE NewToken
    );

#endif // __SERVER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\xtcb\userctxt.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       userctxt.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    3-26-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include <rc4.h>

#ifndef __USERCTXT_H__
#define __USERCTXT_H__

typedef struct _XTCB_USER_CONTEXT {
    LIST_ENTRY      List ;
    LSA_SEC_HANDLE  LsaHandle ;
    HANDLE          Token ;
    XTCB_CONTEXT_CORE Context ;
    ULONGLONG       Align ;
    RC4_KEYSTRUCT   InboundKey ;
    RC4_KEYSTRUCT   OutboundKey ;
} XTCB_USER_CONTEXT, *PXTCB_USER_CONTEXT ;

BOOL
XtcbUserContextInit(
    VOID
    );

SECURITY_STATUS
XtcbAddUserContext(
    IN LSA_SEC_HANDLE LsaHandle,
    IN PSecBuffer   ContextData
    );

PXTCB_USER_CONTEXT
XtcbFindUserContext(
    IN  LSA_SEC_HANDLE   LsaHandle
    );

VOID
XtcbDeleteUserContext(
    IN LSA_SEC_HANDLE LsaHandle
    );



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\xtcb\server.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       server.c
//
//  Contents:   Server (DC) side of XTCB authentication
//
//  Classes:
//
//  Functions:
//
//  History:    3-12-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include "xtcbpkg.h"
#include "md5.h"

//+---------------------------------------------------------------------------
//
//  Function:   XtcbGetMessageSize
//
//  Synopsis:   Determines the size of the message when serialized.
//
//  Arguments:  [Message] --
//
//  History:    3-25-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
XtcbGetMessageSize(
    PXTCB_SERVER_MESSAGE Message
    )
{
    DWORD   Size ;
    switch ( Message->Code )
    {
        case XtcbSrvAuthReq:
            Size = Message->Message.AuthReq.Challenge.Length + 1 +
                   Message->Message.AuthReq.Response.Length + 1 +
                   Message->Message.AuthReq.UserName.Length + 1 ;
            break;

        case XtcbSrvAuthResp:
            Size = Message->Message.AuthResp.AuthInfoLength ;
            break;

        default:
            Size = 0 ;

    }
    return Size ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\xtcb\userctxt.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       userctxt.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    3-26-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include "xtcbpkg.h"

LIST_ENTRY  XtcbContextList ;
CRITICAL_SECTION XtcbContextListLock ;

#define LockContextList()   EnterCriticalSection( &XtcbContextListLock )
#define UnlockContextList() LeaveCriticalSection( &XtcbContextListLock )

BOOL
XtcbUserContextInit(
    VOID
    )
{
    InitializeListHead( &XtcbContextList );

    InitializeCriticalSection( &XtcbContextListLock );

    return TRUE ;
}


SECURITY_STATUS
XtcbAddUserContext(
    IN LSA_SEC_HANDLE LsaHandle,
    IN PSecBuffer   ContextData)
{
    DWORD   Size;
    PXTCB_USER_CONTEXT Context ;

    Context = XtcbFindUserContext( LsaHandle );

    if ( Context )
    {
        DebugLog(( DEB_TRACE, "Replacing existing context!\n" ));

    }

    if ( ContextData->cbBuffer < sizeof( XTCB_CONTEXT_CORE ) )
    {
        return( SEC_E_INVALID_TOKEN );
    }

    Size = sizeof( XTCB_CONTEXT_CORE );

    Context = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                        sizeof( XTCB_USER_CONTEXT ) + Size );

    if ( !Context )
    {
        return( SEC_E_INSUFFICIENT_MEMORY );
    }

    Context->LsaHandle = LsaHandle ;

    CopyMemory( &Context->Context,
                ContextData->pvBuffer,
                ContextData->cbBuffer );

    LockContextList();

    InsertTailList( &XtcbContextList, &Context->List );

    UnlockContextList();

    return( SEC_E_OK );
}

PXTCB_USER_CONTEXT
XtcbFindUserContext(
    IN  LSA_SEC_HANDLE   LsaHandle
    )
{
    PLIST_ENTRY List ;
    PXTCB_USER_CONTEXT Context = NULL ;


    LockContextList();

    List = XtcbContextList.Flink ;

    while ( List != &XtcbContextList )
    {
        Context = CONTAINING_RECORD( List, XTCB_USER_CONTEXT, List.Flink );

        if ( Context->LsaHandle == LsaHandle )
        {
            break;
        }

        Context = NULL ;

        List = List->Flink ;
    }

    UnlockContextList();

    return( Context );
}

VOID
XtcbDeleteUserContext(
    IN LSA_SEC_HANDLE LsaHandle
    )
{
    PXTCB_USER_CONTEXT Context ;

    Context = XtcbFindUserContext( LsaHandle );

    if ( Context )
    {
        LockContextList();

        RemoveEntryList( &Context->List );

        UnlockContextList();

        DebugLog(( DEB_TRACE, "Deleting user mode context %x, handle = %x\n",
                        Context, LsaHandle ));

        LocalFree( Context );
    }
    else
    {
        DebugLog(( DEB_TRACE, "No context found for handle %x\n", LsaHandle ));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\xtcb\usermode.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       usermode.c
//
//  Contents:   User mode entry points for test package
//
//  Classes:
//
//  Functions:
//
//  History:    2-21-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include "xtcbpkg.h"

PSECPKG_DLL_FUNCTIONS    UserTable ;

SECPKG_USER_FUNCTION_TABLE  XtcbUserTable =
        {
            XtcbInstanceInit,
            XtcbInitUserModeContext,
            XtcbMakeSignature,
            XtcbVerifySignature,
            XtcbSealMessage,
            XtcbUnsealMessage,
            XtcbGetContextToken,
            XtcbQueryContextAttributes,
            XtcbCompleteAuthToken,
            XtcbDeleteUserModeContext
        };


NTSTATUS
SEC_ENTRY
SpUserModeInitialize(
    IN ULONG    LsaVersion,
    OUT PULONG  PackageVersion,
    OUT PSECPKG_USER_FUNCTION_TABLE * UserFunctionTable,
    OUT PULONG  pcTables)
{
    if (LsaVersion != SECPKG_INTERFACE_VERSION)
    {
        DebugLog((DEB_ERROR,"Invalid LSA version: %d\n", LsaVersion));
        return(STATUS_INVALID_PARAMETER);
    }


    *PackageVersion = SECPKG_INTERFACE_VERSION ;

    *UserFunctionTable = &XtcbUserTable;
    *pcTables = 1;


    return( STATUS_SUCCESS );

}


NTSTATUS NTAPI
XtcbInstanceInit(
    IN ULONG Version,
    IN PSECPKG_DLL_FUNCTIONS DllFunctionTable,
    OUT PVOID * UserFunctionTable
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    XtcbUserContextInit();

    UserTable = DllFunctionTable ;

    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   XtcbDeleteUserModeContext
//
//  Synopsis:   Deletes a user mode context by unlinking it and then
//              dereferencing it.
//
//  Effects:
//
//  Arguments:  ContextHandle - Lsa context handle of the context to delete
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success, STATUS_INVALID_HANDLE if the
//              context can't be located
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
XtcbDeleteUserModeContext(
    IN LSA_SEC_HANDLE ContextHandle
    )
{
    XtcbDeleteUserContext( ContextHandle );

    return( SEC_E_OK );

}


//+-------------------------------------------------------------------------
//
//  Function:   XtcbInitUserModeContext
//
//  Synopsis:   Creates a user-mode context from a packed LSA mode context
//
//  Effects:
//
//  Arguments:  ContextHandle - Lsa mode context handle for the context
//              PackedContext - A marshalled buffer containing the LSA
//                  mode context.
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
XtcbInitUserModeContext(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBuffer PackedContext
    )
{
    SECURITY_STATUS scRet = SEC_E_INVALID_HANDLE ;

    scRet = XtcbAddUserContext( ContextHandle, PackedContext );

    if ( NT_SUCCESS( scRet ) )
    {
        FreeContextBuffer( PackedContext->pvBuffer );
    }

    return( scRet );
}


//+-------------------------------------------------------------------------
//
//  Function:   XtcbMakeSignature
//
//  Synopsis:   Signs a message buffer by calculatinga checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  ContextHandle - Handle of the context to use to sign the
//                      message.
//              QualityOfProtection - Unused flags.
//              MessageBuffers - Contains an array of buffers to sign and
//                      to store the signature.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found.
//              STATUS_BUFFER_TOO_SMALL - the signature buffer is too small
//                      to hold the signature
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
XtcbMakeSignature(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG QualityOfProtection,
    IN PSecBufferDesc MessageBuffers,
    IN ULONG MessageSequenceNumber
    )
{
    return( SEC_E_UNSUPPORTED_FUNCTION );
}

//+-------------------------------------------------------------------------
//
//  Function:   XtcbVerifySignature
//
//  Synopsis:   Verifies a signed message buffer by calculating a checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  ContextHandle - Handle of the context to use to sign the
//                      message.
//              MessageBuffers - Contains an array of signed buffers  and
//                      a signature buffer.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//              QualityOfProtection - Unused flags.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found or was too small.
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------



NTSTATUS NTAPI
XtcbVerifySignature(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBufferDesc MessageBuffers,
    IN ULONG MessageSequenceNumber,
    OUT PULONG QualityOfProtection
    )
{
    return( SEC_E_UNSUPPORTED_FUNCTION );
}

NTSTATUS NTAPI
XtcbSealMessage(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG QualityOfProtection,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSequenceNumber
    )
{
    return( SEC_E_CONTEXT_EXPIRED );


}

NTSTATUS NTAPI
XtcbUnsealMessage(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSequenceNumber,
    OUT PULONG QualityOfProtection
    )
{
    // Output Buffer Types
    return( SEC_E_CONTEXT_EXPIRED );

}


//+-------------------------------------------------------------------------
//
//  Function:   SpGetContextToken
//
//  Synopsis:   returns a pointer to the token for a server-side context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
XtcbGetContextToken(
    IN LSA_SEC_HANDLE ContextHandle,
    OUT PHANDLE ImpersonationToken
    )
{
    PXTCB_USER_CONTEXT Context ;

    Context = XtcbFindUserContext( ContextHandle );

    if ( Context )
    {
        *ImpersonationToken = Context->Token ;

        return SEC_E_OK ;
    }
    else
    {
        return SEC_E_INVALID_HANDLE ;
    }

}


//+-------------------------------------------------------------------------
//
//  Function:   SpQueryContextAttributes
//
//  Synopsis:   Querys attributes of the specified context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
XtcbQueryContextAttributes(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG ContextAttribute,
    IN OUT PVOID pBuffer
    )
{
    PXTCB_USER_CONTEXT   Context ;
    PSecPkgContext_Sizes    Sizes ;
    PSecPkgContext_NamesW   Names ;
    PSecPkgContext_Lifespan Lifespan ;
    PSecPkgContext_DceInfo  DceInfo ;
    PSecPkgContext_Authority Authority ;
    SECURITY_STATUS Status ;
    int len ;

    Context = XtcbFindUserContext( ContextHandle );

    if ( !Context )
    {
        return SEC_E_INVALID_HANDLE ;
    }

    switch ( ContextAttribute )
    {
        case SECPKG_ATTR_SIZES:
            Sizes = (PSecPkgContext_Sizes) pBuffer ;
            ZeroMemory( Sizes, sizeof( SecPkgContext_Sizes ) );
            Status = SEC_E_OK ;
            break;

        case SECPKG_ATTR_NAMES:
            Status = SEC_E_OK ;
            break;

        case SECPKG_ATTR_LIFESPAN:
            Status = SEC_E_OK ;
            break;

        default:
            Status = SEC_E_UNSUPPORTED_FUNCTION ;


    }
    return Status ;
}



//+-------------------------------------------------------------------------
//
//  Function:   SpCompleteAuthToken
//
//  Synopsis:   Completes a context (in Kerberos case, does nothing)
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
NTAPI
XtcbCompleteAuthToken(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBufferDesc InputBuffer
    )
{
    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\xtcb\util.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       util.c
//
//  Contents:   General utility functions
//
//  Functions:
//
//  History:    2-20-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include "xtcbpkg.h"
#include "stdio.h"

BOOL
XtcbDupSecurityString(
    PSECURITY_STRING    Dest,
    PSECURITY_STRING    Source
    )
{
    if ( Source->Buffer == NULL )
    {
        ZeroMemory( Dest, sizeof( SECURITY_STRING ) );
        return TRUE ;
    }
    Dest->Buffer = LocalAlloc( LMEM_FIXED, Source->Length + sizeof(WCHAR) );
    if ( Dest->Buffer )
    {
        Dest->MaximumLength = Source->Length + sizeof( WCHAR ) ;
        Dest->Length = Source->Length ;
        CopyMemory( Dest->Buffer, Source->Buffer, Source->Length);
        Dest->Buffer[ Dest->Length / sizeof( WCHAR ) ] = L'\0';
        return TRUE ;
    }
    return FALSE ;
}

BOOL
XtcbAnsiStringToSecurityString(
    PSECURITY_STRING    Dest,
    PSTRING             Source
    )
{
    int len;

    len = (Source->Length + 1) * sizeof(WCHAR) ;

    // overkill, but safe

    Dest->Buffer = LocalAlloc( LMEM_FIXED, len );

    if ( Dest->Buffer )
    {
        Dest->Length = (USHORT) (len - sizeof(WCHAR)) ;
        Dest->MaximumLength = (USHORT) len ;

        MultiByteToWideChar( CP_ACP, 0,
                             Source->Buffer, -1,
                             Dest->Buffer, len / sizeof(WCHAR) );

        return TRUE ;
    }

    return FALSE ;


}

BOOL
XtcbSecurityStringToAnsiString(
    PSTRING Dest,
    PSECURITY_STRING Source
    )
{
    int len ;

    len = (Source->Length / sizeof(WCHAR)) + 1 ;

    Dest->Buffer = LocalAlloc( LMEM_FIXED, len );

    if ( Dest->Buffer )
    {
        Dest->Length = (USHORT) (len - 1) ;
        Dest->MaximumLength = (USHORT) len ;

        WideCharToMultiByte( CP_ACP, 0,
                             Source->Buffer, -1,
                             Dest->Buffer, len,
                             NULL, NULL );

        return TRUE ;
    }

    return FALSE ;
}

BOOL
XtcbDupStringToSecurityString(
    PSECURITY_STRING    Dest,
    PWSTR               Source
    )
{
    ULONG   Len ;

    Len = (wcslen( Source ) + 1) * 2 ;

    Dest->Buffer = LocalAlloc( LMEM_FIXED, Len );

    if ( Dest->Buffer )
    {
        Dest->MaximumLength = (USHORT) Len ;
        Dest->Length = (USHORT) Len - 2 ;

        CopyMemory( Dest->Buffer, Source, Len );

        return TRUE ;
    }
    return FALSE ;
}

BOOL
XtcbGenerateChallenge(
    PUCHAR  Challenge,
    ULONG   Length,
    PULONG  Actual
    )
{
    CHAR    Temp[ MAX_PATH ];
    LUID    Unique;
    ULONG   Len ;

    AllocateLocallyUniqueId( &Unique );

    _snprintf( Temp, MAX_PATH, "<%x%x.%x%x@%s>",
                GetCurrentProcessId(), GetCurrentThreadId(),
                Unique.HighPart, Unique.LowPart,
                XtcbDnsName.Buffer
             );

    Len = strlen( Temp );

    if ( Len < Length )
    {
        strcpy( Challenge, Temp );
        *Actual = Len;
        return TRUE ;
    }

    *Actual = Len + 1;

    return FALSE ;

}

BOOL
XtcbCaptureAuthData(
    PVOID   pvAuthData,
    PSEC_WINNT_AUTH_IDENTITY * AuthData
    )
{
    SEC_WINNT_AUTH_IDENTITY Auth ;
    PSEC_WINNT_AUTH_IDENTITY pAuth ;
    SECURITY_STATUS Status ;
    ULONG   TotalSize ;
    PWSTR   Current ;

    ZeroMemory( &Auth, sizeof( Auth ) );

    Status = LsaTable->CopyFromClientBuffer(
                            NULL,
                            sizeof( SEC_WINNT_AUTH_IDENTITY ),
                            & Auth,
                            pvAuthData );

    if ( !NT_SUCCESS( Status ) )
    {
        return FALSE ;
    }

    if ( Auth.Flags & SEC_WINNT_AUTH_IDENTITY_ANSI )
    {
        return FALSE ;
    }

    TotalSize = sizeof( SEC_WINNT_AUTH_IDENTITY ) +
                ( Auth.UserLength + 1 +
                  Auth.DomainLength + 1 +
                  Auth.PasswordLength + 1 ) * sizeof( WCHAR );

    pAuth = (PSEC_WINNT_AUTH_IDENTITY) LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                            TotalSize );

    if ( !pAuth )
    {
        return FALSE ;
    }

    pAuth->Flags = Auth.Flags ;

    Current = (PWSTR) (pAuth + 1);

    if ( Auth.User )
    {
        pAuth->User = Current ;
        pAuth->UserLength = Auth.UserLength ;

        Status = LsaTable->CopyFromClientBuffer(
                            NULL,
                            (Auth.UserLength + 1) * sizeof(WCHAR) ,
                            pAuth->User,
                            Auth.User );

        if ( !NT_SUCCESS( Status ) )
        {
            goto Error_Cleanup ;
        }

        Current += Auth.UserLength + 1;
    }

    if ( Auth.Domain )
    {
        pAuth->Domain = Current ;
        pAuth->DomainLength = Auth.DomainLength ;

        Status = LsaTable->CopyFromClientBuffer(
                            NULL,
                            (Auth.DomainLength + 1) * sizeof( WCHAR ),
                            pAuth->Domain,
                            Auth.Domain );

        if ( !NT_SUCCESS( Status ) )
        {
            goto Error_Cleanup ;
        }

        Current += Auth.DomainLength + 1;

    }

    if ( Auth.Password )
    {
        pAuth->Password = Current ;
        pAuth->PasswordLength = Auth.PasswordLength ;

        Status = LsaTable->CopyFromClientBuffer(
                            NULL,
                            (Auth.PasswordLength + 1) * sizeof( WCHAR ),
                            pAuth->Password,
                            Auth.Password );

        if ( !NT_SUCCESS( Status ) )
        {
            goto Error_Cleanup ;
        }

        Current += Auth.PasswordLength + 1;

    }

    *AuthData = pAuth ;

    return TRUE ;

Error_Cleanup:

    LocalFree( pAuth );

    return FALSE ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\xtcb\xtcbpkg.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       xtcbpkg.c
//
//  Contents:   Xtcb Security Package
//
//  Classes:
//
//  Functions:  Basic management
//
//  History:    2-19-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include "xtcbpkg.h"

SECPKG_FUNCTION_TABLE   XtcbTable = {
            NULL,                               // InitializePackage
            NULL,                               // LogonUser
            XtcbCallPackage,                    
            XtcbLogonTerminated,
            XtcbCallPackageUntrusted,
            NULL,                               // CallPackagePassthrough
            NULL,                               // LogonUserEx
            NULL,                               // LogonUserEx2
            XtcbInitialize,
            XtcbShutdown,
            XtcbGetInfo,
            XtcbAcceptCredentials,
            XtcbAcquireCredentialsHandle,
            XtcbQueryCredentialsAttributes,
            XtcbFreeCredentialsHandle,
            NULL,
            NULL,
            NULL,
            XtcbInitLsaModeContext,
            XtcbAcceptLsaModeContext,
            XtcbDeleteContext,
            XtcbApplyControlToken,
            XtcbGetUserInfo,
            XtcbGetExtendedInformation,
            XtcbQueryLsaModeContext
            };


ULONG_PTR   XtcbPackageId;
PLSA_SECPKG_FUNCTION_TABLE LsaTable ;
TimeStamp   XtcbNever = { 0xFFFFFFFF, 0x7FFFFFFF };
TOKEN_SOURCE XtcbSource ;
SECURITY_STRING XtcbComputerName ;
SECURITY_STRING XtcbUnicodeDnsName ;
SECURITY_STRING XtcbDomainName ;
STRING XtcbDnsName ;
PSID XtcbMachineSid ;

ULONG   ThunkedContextLevels[] = { SECPKG_ATTR_LIFESPAN };


//+---------------------------------------------------------------------------
//
//  Function:   SpLsaModeInitialize
//
//  Synopsis:   Initializes connection with LSA.  Allows the DLL to specify all the
//              packages contained within it, and their function tables.
//
//  Arguments:  [LsaVersion]     -- Version of the LSA
//              [PackageVersion] -- Version of the package (out)
//              [Table]          -- Table of package functions
//              [TableCount]     -- Count of tables
//
//  History:    2-19-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
SpLsaModeInitialize(
    IN ULONG LsaVersion,
    OUT PULONG PackageVersion,
    OUT PSECPKG_FUNCTION_TABLE * Table,
    OUT PULONG TableCount)
{
    *PackageVersion = SECPKG_INTERFACE_VERSION ;
    *Table = &XtcbTable ;
    *TableCount = 1;

#if DBG
    InitDebugSupport();
#endif

    DebugLog(( DEB_TRACE, "XtcbPkg DLL Loaded\n" ));

    return( SEC_E_OK );
}

BOOL
XtcbReadParameters(
    VOID
    )
{
    MGroupReload();

    return TRUE ;

}




//+---------------------------------------------------------------------------
//
//  Function:   XtcbInitialize
//
//  Synopsis:   Actual initialization function for the security package
//
//  Arguments:  [dwPackageID] -- Assigned package ID
//              [pParameters] -- Initialization parameters
//              [Table]       -- Table of callbacks into the LSA for support
//
//  History:    2-19-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
XtcbInitialize(
    ULONG_PTR   dwPackageID,
    PSECPKG_PARAMETERS  Parameters,
    PLSA_SECPKG_FUNCTION_TABLE  Table
    )
{
    WCHAR ComputerName[ MAX_PATH ];
    DWORD Size ;
    XtcbPackageId = dwPackageID ;
    LsaTable = Table ;

    //
    // Initialize our control structures
    //

    XtcbInitCreds();

    XtcbInitializeContexts();

    //
    // Set up the source name that we will use for tokens
    //

    CopyMemory( XtcbSource.SourceName, "XTCBPKG", sizeof( "XTCBPKG" ) );
    AllocateLocallyUniqueId( &XtcbSource.SourceIdentifier );

    //
    // Get the names for the XTCB protocol.
    //

    Size = sizeof( ComputerName ) / sizeof( WCHAR );

    GetComputerName( ComputerName, &Size );

    XtcbDupStringToSecurityString( &XtcbComputerName, ComputerName );

    Size = MAX_PATH ;

    if ( GetComputerNameEx( ComputerNameDnsFullyQualified,
                            ComputerName,
                            &Size ) )
    {
        XtcbDupStringToSecurityString( &XtcbUnicodeDnsName, ComputerName );
    }

    XtcbDupSecurityString( &XtcbDomainName, &Parameters->DomainName );

    if ( !MGroupInitialize() )
    {
        return STATUS_UNSUCCESSFUL ;
    }

    //
    // Start a watch on our reg key to reload any parameter change
    //

    

    DebugLog(( DEB_TRACE_CALLS, "Initialized in LSA mode\n" ));

    return(S_OK);
}


//+---------------------------------------------------------------------------
//
//  Function:   XtcbGetInfo
//
//  Synopsis:   Returns information about the package to the LSA
//
//  Arguments:  [pInfo] --
//
//  History:    2-19-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
XtcbGetInfo(PSecPkgInfo pInfo)
{

    DebugLog(( DEB_TRACE_CALLS, "GetInfo\n" ));

    pInfo->wVersion         = 1;
    pInfo->wRPCID           = 0x15 ;
    pInfo->fCapabilities    =
                              SECPKG_FLAG_CONNECTION |
                              SECPKG_FLAG_MULTI_REQUIRED |
                              SECPKG_FLAG_EXTENDED_ERROR |
                              SECPKG_FLAG_IMPERSONATION |
                              SECPKG_FLAG_ACCEPT_WIN32_NAME |
                              SECPKG_FLAG_NEGOTIABLE ;

    pInfo->cbMaxToken       = 8000;
    pInfo->Name             = L"XTCB";
    pInfo->Comment          = L"Extended TCB package";

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   XtcbGetExtendedInformation
//
//  Synopsis:   Return extended information to the LSA
//
//  Arguments:  [Class] -- Information Class
//              [pInfo] -- Returned Information Pointer
//
//  History:    3-04-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
XtcbGetExtendedInformation(
    SECPKG_EXTENDED_INFORMATION_CLASS   Class,
    PSECPKG_EXTENDED_INFORMATION *      pInfo
    )
{
    PSECPKG_EXTENDED_INFORMATION    Info ;
    SECURITY_STATUS Status ;

    DebugLog(( DEB_TRACE_CALLS, "GetExtendedInfo( %d )\n", Class ));

    switch ( Class )
    {
        case SecpkgContextThunks:

            //
            // Which context information levels do we want
            // thunked over to the LSA, and which can we handle
            // in the user process?
            //

            Info = (PSECPKG_EXTENDED_INFORMATION) LsaTable->AllocateLsaHeap(
                            sizeof( SECPKG_EXTENDED_INFORMATION ) +
                            sizeof( ThunkedContextLevels ) );

            if ( Info )
            {
                Info->Class = Class ;
                Info->Info.ContextThunks.InfoLevelCount =
                                sizeof( ThunkedContextLevels ) / sizeof( ULONG );
                CopyMemory( Info->Info.ContextThunks.Levels,
                            ThunkedContextLevels,
                            sizeof( ThunkedContextLevels ) );

                Status = SEC_E_OK ;

            }
            else
            {
                Status = SEC_E_INSUFFICIENT_MEMORY ;
            }

            break;


        default:
            Status = SEC_E_UNSUPPORTED_FUNCTION ;
            Info = NULL ;
            break;

    }

    *pInfo = Info ;
    return Status ;
}


NTSTATUS
NTAPI
XtcbCallPackage(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    PULONG TagType ;
    NTSTATUS Status ;


    return( SEC_E_UNSUPPORTED_FUNCTION );
}

NTSTATUS
NTAPI
XtcbCallPackageUntrusted(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    return( SEC_E_UNSUPPORTED_FUNCTION );
}


//+---------------------------------------------------------------------------
//
//  Function:   XtcbShutdown
//
//  Synopsis:   Called at shutdown to clean up state
//
//  Arguments:  (none)
//
//  History:    8-15-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
XtcbShutdown(void)
{
    return( STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\protocols\xtcb\xtcbpkg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       md5ref.h
//
//  Contents:   XTCB Reference Security Package
//
//  Classes:
//
//  Functions:
//
//  History:    9-20-96   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __XTCBREF_H__
#define __XTCBREF_H__

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rpc.h>
#include <stdio.h>
#include <align.h>

#define SECURITY_PACKAGE
#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif
#include <security.h>
#include <secpkg.h>
#include <secint.h>

//
// Useful constants:
//

#define SEED_KEY_SIZE   16


#include "debug.h"
#include "protocol.h"
#include "creds.h"
#include "context.h"
#include "server.h"
#include "userctxt.h"
#include "protos.h"


extern PLSA_SECPKG_FUNCTION_TABLE   LsaTable ;
extern TimeStamp    XtcbNever ;
extern TOKEN_SOURCE XtcbSource ;
extern SECURITY_STRING XtcbComputerName ;
extern SECURITY_STRING XtcbUnicodeDnsName ;
extern SECURITY_STRING XtcbDomainName ;
extern STRING XtcbDnsName ;
extern PSID XtcbMachineSid ;

void InitDebugSupport( void );



typedef struct _XTCB_MACHINE_GROUP_ENTRY {
    PWSTR   MachineName ;
    UCHAR   UniqueKey[ SEED_KEY_SIZE ];
    ULONG   Flags ;
} XTCB_MACHINE_GROUP_ENTRY, * PXTCB_MACHINE_GROUP_ENTRY ;

#define MGROUP_ENTRY_SELF   0x00000001

typedef struct _XTCB_MACHINE_GROUP {
    LIST_ENTRY List ;
    SECURITY_STRING Group;
    UCHAR   SeedKey[ SEED_KEY_SIZE ];
    ULONG   Count ;
    PXTCB_MACHINE_GROUP_ENTRY * GroupList ;
} XTCB_MACHINE_GROUP, * PXTCB_MACHINE_GROUP ;


BOOL
MGroupParseTarget(
    PWSTR TargetSpn,
    PWSTR * MachineName
    );


BOOL
MGroupLocateKeys(
    IN PWSTR Target,
    OUT PSECURITY_STRING * GroupName,
    OUT PUCHAR TargetKey,
    OUT PUCHAR GroupKey,
    OUT PUCHAR MyKey
    );

BOOL
MGroupLocateInboundKey(
    IN PSECURITY_STRING Group,
    IN PSECURITY_STRING Origin,
    OUT PUCHAR TargetKey,
    OUT PUCHAR GroupKey,
    OUT PUCHAR MyKey
    );


BOOL
MGroupReload(
    VOID
    );

BOOL
MGroupInitialize(
    VOID
    );

#endif // __TESTREF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\capesnpn\certifct.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       Certifct.cpp
//
//  Contents:   Implementation of CCertmgrApp and DLL registration.
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "certca.h"
#include "tfcprop.h"
#include "genpage.h"

#include "Certifct.h"


/////////////////////////////////////////////////////////////////////////////
//
enum {
	FIELD_CAN_DELETE = 0x00000001
};

CCertificate::CCertificate(const PCCERT_CONTEXT pCertContext,
		HCERTSTORE hCertStore) 
:	m_pCertContext (::CertDuplicateCertificateContext (pCertContext)),
	m_pCertInfo (0),
	m_hCertStore (::CertDuplicateStore (hCertStore)),
	m_bCertContextFreed (false),
	m_fieldChecked (0),
	m_bCanDelete (false)
{
	ASSERT (m_pCertContext);
	if ( m_pCertContext )
		m_pCertInfo = m_pCertContext->pCertInfo;
}



CCertificate::~CCertificate()
{

	if ( m_pCertContext && !m_bCertContextFreed )
		::CertFreeCertificateContext (m_pCertContext);

	if ( m_hCertStore )
		::CertCloseStore (m_hCertStore, 0);
}


HRESULT CCertificate::GetIssuerName (PWSTR *ppszIssuerName)
{
	HRESULT	hResult = S_OK;

	ASSERT (m_pCertInfo && ppszIssuerName);
	if ( m_pCertInfo && ppszIssuerName )
	{
		// Decode issuer name if not already present
		if ( m_szIssuerName.IsEmpty() )
		{
			hResult = GetNameString (CERT_NAME_ISSUER_FLAG, m_szIssuerName);
		}
		if ( SUCCEEDED (hResult) )
		{
			if ( *ppszIssuerName )
				delete [] *ppszIssuerName;
			*ppszIssuerName = new WCHAR[wcslen (m_szIssuerName) + 1];
			if ( *ppszIssuerName )
			{
				wcscpy (*ppszIssuerName, m_szIssuerName);
			}
			else
				hResult = E_OUTOFMEMORY;
		}
	}
	else
		hResult = E_POINTER;


	return hResult;
}

///////////////////////////////////////////////////////////////////////////
//	GetSubjectName ()
//
//	pszName (IN / OPTIONAL)	 - returns the alternate issuer name.  An empty 
//								string is a valid return value
//	cbName	(IN / OUT)		 - If pszName is NULL, then the required length
//								of pszName is returned.  
//								Otherwise, contains the length of pszName.
///////////////////////////////////////////////////////////////////////////
HRESULT CCertificate::GetSubjectName(PWSTR *ppszSubjectName)
{
	HRESULT	hResult = S_OK;

	ASSERT (m_pCertInfo && ppszSubjectName);
	if ( m_pCertInfo && ppszSubjectName )
	{
		// Decode issuer name if not already present
		if ( m_szSubjectName.IsEmpty() )
		{
			hResult = GetNameString (0, m_szSubjectName);
		}
		if ( SUCCEEDED (hResult) )
		{
			if ( *ppszSubjectName )
				delete [] *ppszSubjectName;
			*ppszSubjectName = new WCHAR[wcslen (m_szSubjectName) + 1];
			if ( *ppszSubjectName )
			{
				wcscpy (*ppszSubjectName, m_szSubjectName);
			}
			else
				hResult = E_OUTOFMEMORY;
		}
	}
	else
		hResult = E_POINTER;


	return hResult;
}


///////////////////////////////////////////////////////////////////////////
//	GetValidNotAfter ()
//
//	pszDateTime (IN / OPTIONAL)	 - returns the formatted date and time.
//	cbDateTime	(IN / OUT)		 - If pszDateTime is NULL, then the required length
//								of pszDateTime is returned.  
//								Otherwise, contains the length of pszDateTime.
///////////////////////////////////////////////////////////////////////////
HRESULT CCertificate::GetValidNotAfter (PWSTR* ppszValidNotAfter)
{
	HRESULT	hResult = S_OK;

	ASSERT (m_pCertInfo && ppszValidNotAfter);
	if ( m_pCertInfo && ppszValidNotAfter )
	{
		// Format date/time string if not already present
		if ( m_szValidNotAfter.IsEmpty() )
		{
			hResult = FormatDate (m_pCertInfo->NotAfter, m_szValidNotAfter);
			if ( SUCCEEDED (hResult) )
			{
				if ( *ppszValidNotAfter )
					delete [] *ppszValidNotAfter;
				*ppszValidNotAfter = new WCHAR[wcslen (m_szValidNotAfter)+1];
				if ( *ppszValidNotAfter )
				{
					wcscpy (*ppszValidNotAfter, m_szValidNotAfter);
				}
				else
					hResult = E_OUTOFMEMORY;
			}
		}
	}
	else
		hResult = E_POINTER;

	return hResult;
}


HRESULT CCertificate::GetEnhancedKeyUsage (PWSTR* ppszUsages)
{
	HRESULT	hResult = S_OK;

	ASSERT (m_pCertInfo && ppszUsages);
	if ( m_pCertInfo && ppszUsages )
	{
		// Format date/time string if not already present
		if ( m_szEnhancedKeyUsage.IsEmpty() )
		{
			hResult = FormatEnhancedKeyUsagePropertyString ();
			if ( SUCCEEDED (hResult) && !m_szEnhancedKeyUsage.IsEmpty() )
			{
				if ( *ppszUsages )
					delete [] *ppszUsages;
				*ppszUsages = new WCHAR[wcslen (m_szEnhancedKeyUsage)+1];
				if ( *ppszUsages )
				{
					wcscpy (*ppszUsages, m_szEnhancedKeyUsage);
				}
				else
					hResult = E_OUTOFMEMORY;
			}
		}
	}
	else
		hResult = E_POINTER;

	return hResult;
}


HRESULT CCertificate::FormatEnhancedKeyUsagePropertyString ()
{
	HRESULT	hResult = S_OK;
	DWORD	cbUsage = 0;
	DWORD	dwErr = 0;
    LPWSTR wszEnhUsage = NULL;
	BOOL	bReturn = ::CertGetEnhancedKeyUsage (m_pCertContext,  0, // get extension and property
			NULL, &cbUsage);
	if ( bReturn )
	{
		PCERT_ENHKEY_USAGE pUsage = (PCERT_ENHKEY_USAGE) new BYTE[cbUsage];
		if ( pUsage )
		{
			bReturn = ::CertGetEnhancedKeyUsage (m_pCertContext,  0, // get extension and property
					pUsage, &cbUsage);
			if ( bReturn )
			{
				size_t	dwLen = 0;
				PWSTR	pszComma = _T(", ");
				size_t	dwCommaLen = wcslen (pszComma);
				PWSTR	pszUsageName = 0;


				// Get accumulated lengths first
				for (DWORD dwIndex = 0; dwIndex < pUsage->cUsageIdentifier; dwIndex++)
				{
					hResult = GetOIDInfo (&pszUsageName, pUsage->rgpszUsageIdentifier[dwIndex]);
					if ( SUCCEEDED (hResult) )
					{
						// add delimeter if not first iteration
						if ( dwIndex != 0 )
							dwLen += dwCommaLen;
						dwLen += wcslen (pszUsageName);
						delete [] pszUsageName;
						pszUsageName = 0;
					}
					else
						break;
				}

				// Allocate buffer and get strings

				wszEnhUsage  = m_szEnhancedKeyUsage.GetBuffer(dwLen+1);
				if ( wszEnhUsage )
				{
					::ZeroMemory (wszEnhUsage, (dwLen+1)* sizeof (WCHAR));
					for (DWORD dwIndex = 0; dwIndex < pUsage->cUsageIdentifier; dwIndex++)
					{
						hResult = GetOIDInfo (&pszUsageName, pUsage->rgpszUsageIdentifier[dwIndex]);
						if ( SUCCEEDED (hResult) )
						{
							// add delimeter if not first iteration
							if ( dwIndex != 0 )
								wcscat (wszEnhUsage, pszComma);
							wcscat (wszEnhUsage, pszUsageName);
							ASSERT (wcslen (wszEnhUsage) <= dwLen);
							delete [] pszUsageName;
							pszUsageName = 0;
						}
						else
							break;
					}
				}
				else
					hResult = E_OUTOFMEMORY;
			}
			else
			{
				dwErr = GetLastError ();
				ASSERT (dwErr == CRYPT_E_NOT_FOUND);
				if ( dwErr == CRYPT_E_NOT_FOUND )
				{
					if ( !m_szEnhancedKeyUsage.LoadString (IDS_ANY) )
						hResult = E_UNEXPECTED;
				}
				else
				{
					hResult = HRESULT_FROM_WIN32(dwErr);
				}
			}
			delete [] pUsage;
		}
		else
			hResult = E_OUTOFMEMORY;
	}
	else
	{
		dwErr = GetLastError ();
		ASSERT (dwErr == CRYPT_E_NOT_FOUND);
		if ( dwErr != CRYPT_E_NOT_FOUND )
		{
			hResult = HRESULT_FROM_WIN32(dwErr);
		}
	}
    return hResult;
}

///////////////////////////////////////////////////////////////////////////
//	GetAlternateIssuerName ()
//
//	pszName (IN / OPTIONAL)	 - returns the alternate issuer name.  An empty 
//								string is a valid return value
//	cbName	(IN / OUT)		 - If pszName is NULL, then the required length
//								of pszName is returned.  
//								Otherwise, contains the length of pszName.
///////////////////////////////////////////////////////////////////////////
HRESULT CCertificate::GetAlternateIssuerName (PWSTR* ppszAltIssuerName)
{
	HRESULT	hResult = S_OK;

	ASSERT (m_pCertInfo && ppszAltIssuerName);
	if ( m_pCertInfo && ppszAltIssuerName )
	{
		if ( m_szAltIssuerName.IsEmpty() )
		{
			hResult = ConvertAltNameToString (_T(szOID_ISSUER_ALT_NAME),
					CERT_ALT_NAME_URL, m_szAltIssuerName);
			ASSERT (SUCCEEDED (hResult));
			if ( SUCCEEDED (hResult) )
			{
				if ( *ppszAltIssuerName )
					delete [] *ppszAltIssuerName;
				*ppszAltIssuerName = new WCHAR[wcslen (m_szAltIssuerName)+1];
				if ( *ppszAltIssuerName )
				{
					wcscpy (*ppszAltIssuerName, m_szAltIssuerName);
				}
				else
					hResult = E_OUTOFMEMORY;
			}
		}
	}
	else
		hResult = E_POINTER;
	
	return hResult;
}

///////////////////////////////////////////////////////////////////////////
//	GetAlternateSubjectName ()
//
//	pszName (IN / OPTIONAL)	 - returns the alternate issuer name.  An empty 
//								string is a valid return value
//	cbName	(IN / OUT)		 - If pszName is NULL, then the required length
//								of pszName is returned.  
//								Otherwise, contains the length of pszName.
///////////////////////////////////////////////////////////////////////////
HRESULT CCertificate::GetAlternateSubjectName (PWSTR* ppszAltSubjectName)
{
	HRESULT	hResult = S_OK;
	ASSERT (m_pCertInfo && ppszAltSubjectName);
	if ( m_pCertInfo && ppszAltSubjectName )
	{
		if ( m_szAltSubjectName.IsEmpty() )
		{
			hResult = ConvertAltNameToString (_T(szOID_SUBJECT_ALT_NAME),
					CERT_ALT_NAME_URL, m_szAltSubjectName);
			ASSERT (SUCCEEDED (hResult));
			if ( SUCCEEDED (hResult) )
			{
				if ( *ppszAltSubjectName )
					delete [] *ppszAltSubjectName;
				*ppszAltSubjectName = new WCHAR[wcslen (m_szAltSubjectName)+1];
				if ( *ppszAltSubjectName )
				{
					wcscpy (*ppszAltSubjectName, m_szAltSubjectName);
				}
				else
					hResult = E_OUTOFMEMORY;
			}
		}
	}
	else
		hResult = E_POINTER;
	
	return hResult;
}


//////////////////////////////////////////////////////////////////////////////
//	ConvertAltNameToString ()
//
//  szOID (IN)			- The OID of the alternate name to retrieve
//	dwNameChoice (IN)	- The type of alternate name to return
//	altName (OUT)		- The version of the desired alternate name indicated
//							by dwNameChoice
//////////////////////////////////////////////////////////////////////////////
HRESULT CCertificate::ConvertAltNameToString (PWSTR szOID, const DWORD dwNameChoice, CString & strAltName)
{
	HRESULT	hResult = S_OK;
	ASSERT (szOID);
	if ( !szOID )
		return E_POINTER;

	// Iterate through the extensions until the one indicated by the
	// passed-in szOID is found.
	for (DWORD	index = 0; index < m_pCertInfo->cExtension; index++)
	{
		ASSERT (m_pCertInfo->rgExtension);
		size_t	len = strlen (m_pCertInfo->rgExtension[index].pszObjId);
		LPTSTR	wcsObjId = new WCHAR[len];
		if ( !wcsObjId )
		{
			hResult = E_OUTOFMEMORY;
			break;
		}
                else
                    wcsObjId[0] = L'\0';
		mbstowcs (wcsObjId,  m_pCertInfo->rgExtension[index].pszObjId, len);

		if ( !wcscmp (wcsObjId, szOID) )
		{
			CERT_ALT_NAME_INFO	nameInfo;
			DWORD				cbNameInfo = sizeof (CERT_ALT_NAME_INFO);

			BOOL	bResult = CryptDecodeObject(
					MY_ENCODING_TYPE,
					X509_ALTERNATE_NAME,	// in
					m_pCertInfo->rgExtension[index].Value.pbData,	// in
					m_pCertInfo->rgExtension[index].Value.cbData,	// in
					0,	// in
					(void *) &nameInfo,	// out
					&cbNameInfo);	// in/out
			ASSERT (bResult);
			if ( bResult )
			{
				//  We've found the right extension, now iterate through
				//	the alternate names until we find the desired type.
				for (DWORD	index1 = 0; index1 < nameInfo.cAltEntry; index1++)
				{
					if ( nameInfo.rgAltEntry[index1].dwAltNameChoice ==
							dwNameChoice )
					{
                        strAltName = nameInfo.rgAltEntry[index1].pwszURL;
						break;
					}
				}
			}
			else
				hResult = E_UNEXPECTED;
			break;
		}
		delete [] wcsObjId;
	}

	return hResult;
}



HCERTSTORE CCertificate::GetCertStore() const	
{
	return m_hCertStore;
}

PCCERT_CONTEXT CCertificate::GetCertContext() const
{
	return m_pCertContext;
}


HRESULT CCertificate::GetNameString (DWORD dwFlag, CString &strName)
{
	HRESULT	hResult = S_OK;

	DWORD	dwTypePara = CERT_SIMPLE_NAME_STR;
	DWORD	cchNameString = 0;
	DWORD	dwResult = ::CertGetNameString (m_pCertContext,
					CERT_NAME_SIMPLE_DISPLAY_TYPE, 
					dwFlag,
					&dwTypePara,
					NULL,
					cchNameString);
	if ( dwResult > 1 )
	{
		cchNameString = dwResult;
		dwResult = ::CertGetNameString (m_pCertContext,
						CERT_NAME_SIMPLE_DISPLAY_TYPE,
						dwFlag,
						&dwTypePara,
						strName.GetBuffer(cchNameString),
						cchNameString);
		ASSERT (dwResult > 1);
		if ( dwResult <= 1 )
		{
			if ( !strName.LoadString (IDS_NOT_AVAILABLE) )
				hResult = E_FAIL;
		}
	}
	else
	{
		dwResult = ::CertGetNameString (m_pCertContext,
						CERT_NAME_EMAIL_TYPE,
						dwFlag,
						NULL,
						NULL,
						cchNameString);
		if ( dwResult > 1 )
		{
			cchNameString = dwResult;
			dwResult = ::CertGetNameString (m_pCertContext,
							CERT_NAME_EMAIL_TYPE,
							dwFlag,
							NULL,
							strName.GetBuffer(cchNameString),
							cchNameString);
			ASSERT (dwResult > 1);
			if ( dwResult <= 1 )
			{
				if ( !strName.LoadString (IDS_NOT_AVAILABLE) )
					hResult = E_FAIL;
			}
		}
		else
		{
			if ( !strName.LoadString (IDS_NOT_AVAILABLE))
				hResult = E_FAIL;
		}
	}


	return hResult;
}


int CCertificate::CompareExpireDate(const CCertificate & cert) const
{
	int	compVal = 0;

	ASSERT (m_pCertInfo && cert.m_pCertInfo);
	if ( m_pCertInfo && cert.m_pCertInfo )
	{
		compVal = ::CompareFileTime (&m_pCertInfo->NotAfter, 
				&cert.m_pCertInfo->NotAfter);
	}

	return compVal;
}

HRESULT CCertificate::GetOIDInfo (PWSTR* ppszString, PSTR pszObjId)
{   
	HRESULT	hResult = S_OK;
	ASSERT (pszObjId && ppszString);
	if ( pszObjId && ppszString )
	{
		PCCRYPT_OID_INFO	pOIDInfo;
		BOOL				bResult = TRUE;
            
		pOIDInfo = ::CryptFindOIDInfo (CRYPT_OID_INFO_OID_KEY, (void *) pszObjId, 0);

		if ( pOIDInfo )
		{
			if ( *ppszString )
				delete [] *ppszString;
			*ppszString = new WCHAR[wcslen (pOIDInfo->pwszName)+1];
			if ( *ppszString )
			{
				wcscpy (*ppszString, pOIDInfo->pwszName);
			}
			else
				hResult = E_OUTOFMEMORY;
		}
		else
		{
			int nLen = ::MultiByteToWideChar (CP_ACP, 0, pszObjId, -1, NULL, 0);
			ASSERT (nLen);
			if ( nLen )
			{
				if ( *ppszString )
					delete [] *ppszString;
				*ppszString = new WCHAR[nLen];
				if ( *ppszString )
				{
					nLen = ::MultiByteToWideChar (CP_ACP, 0, pszObjId, -1, 
							*ppszString, nLen);
					ASSERT (nLen);
					if ( !nLen )
						hResult = E_UNEXPECTED;
				}
				else
					hResult = E_OUTOFMEMORY;
			}
			else
				hResult = E_FAIL;
		}
	}
	else
		hResult = E_POINTER;

	return hResult;
}


///////////////////////////////////////////////////////////////////////////////
//	FormatDate ()
//
//	utcDateTime (IN)	-	A FILETIME in UTC format.
//	pszDateTime (OUT)	-	A string containing the local date and time 
//							formatted by locale and user preference
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CCertificate::FormatDate (FILETIME utcDateTime, CString &strDateTime)
{
	//	Time is returned as UTC, will be displayed as local.  
	//	Use FileTimeToLocalFileTime () to make it local, 
	//	then call FileTimeToSystemTime () to convert to system time, then 
	//	format with GetDateFormat () and GetTimeFormat () to display 
	//	according to user and locale preferences	
	HRESULT		hResult = S_OK;
	FILETIME	localDateTime;


	BOOL bResult = FileTimeToLocalFileTime (&utcDateTime, // pointer to UTC file time to convert 
			&localDateTime); // pointer to converted file time 
	ASSERT (bResult);
	if ( bResult )
	{
		SYSTEMTIME	sysTime;

		bResult = FileTimeToSystemTime (
				&localDateTime, // pointer to file time to convert 
				&sysTime); // pointer to structure to receive system time 
		if ( bResult )
		{

			// Get date
			// Get length to allocate buffer of sufficient size
			int iLen = GetDateFormat (
					LOCALE_USER_DEFAULT, // locale for which date is to be formatted 
					0, // flags specifying function options 
					&sysTime, // date to be formatted 
					0, // date format string 
					0, // buffer for storing formatted string 
					0); // size of buffer 
			ASSERT (iLen > 0);
			if ( iLen > 0 )
			{
				int iResult = GetDateFormat (
						LOCALE_USER_DEFAULT, // locale for which date is to be formatted 
						0, // flags specifying function options 
						&sysTime, // date to be formatted 
						0, // date format string 
						strDateTime.GetBuffer(iLen), // buffer for storing formatted string 
						iLen); // size of buffer 
				ASSERT (iResult);
				if ( !iResult )
				{
				    hResult = GetLastError();
				    hResult = HRESULT_FROM_WIN32(hResult);
				}
			}
			else
			{
				hResult = GetLastError();
				hResult = HRESULT_FROM_WIN32(hResult);
			}
		}
		else
		{
			hResult = GetLastError();
			hResult = HRESULT_FROM_WIN32(hResult);
		}
	}
	else
	{
		hResult = GetLastError();
		hResult = HRESULT_FROM_WIN32(hResult);
	}

	return hResult;
}


void CCertificate::Refresh()
{
}

HRESULT CCertificate::WriteToFile(HANDLE hFile)
{
	ASSERT (hFile && hFile != INVALID_HANDLE_VALUE && m_pCertContext);
	HRESULT	hResult = S_OK;

	if ( hFile && hFile != INVALID_HANDLE_VALUE && m_pCertContext )
	{
		DWORD	dwBytesWritten = 0;
		BOOL	bResult = ::WriteFile (hFile, 
					m_pCertContext->pbCertEncoded,  
					m_pCertContext->cbCertEncoded,  
					&dwBytesWritten,
					NULL);
		ASSERT (bResult && (dwBytesWritten == m_pCertContext->cbCertEncoded));
		if ( !bResult )
			hResult = E_FAIL;
	}
	else
		hResult = E_FAIL;

	return hResult;
}

BOOL CCertificate::DeleteFromStore()
{
	BOOL bResult = ::CertDeleteCertificateFromStore (m_pCertContext);
	if ( bResult )
	{
		// NB: PhilH says "CertDeleteCertificateFromStore (), always does an 
		// implicit CertFreeCertificateContext."
		// Can't set m_pCertContext to 0 because it is const - set this flag instead
		m_bCertContextFreed = true;
	}

	return bResult;
}




bool CCertificate::CanDelete()
{
	if ( m_pCertContext && !(m_fieldChecked & FIELD_CAN_DELETE) )
	{	
		DWORD	dwAccessFlags = 0;
		DWORD	cbData = sizeof (DWORD);
		BOOL bResult = ::CertGetCertificateContextProperty (
				m_pCertContext,
				CERT_ACCESS_STATE_PROP_ID,
				&dwAccessFlags,
				&cbData);
		if ( bResult )
		{
			if ( dwAccessFlags & CERT_ACCESS_STATE_WRITE_PERSIST_FLAG )
				m_bCanDelete = true;
		}
		m_fieldChecked |= FIELD_CAN_DELETE;
    }

	return m_bCanDelete;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\capesnpn\about.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include <stdafx.h>


CCAPolicyAboutImpl::CCAPolicyAboutImpl()
{
}


CCAPolicyAboutImpl::~CCAPolicyAboutImpl()
{
}


HRESULT CCAPolicyAboutImpl::AboutHelper(UINT nID, LPOLESTR* lpPtr)
{
    if (lpPtr == NULL)
        return E_POINTER;

    CString s;

    // Needed for Loadstring
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    s.LoadString(nID);
    *lpPtr = reinterpret_cast<LPOLESTR>
            (CoTaskMemAlloc((s.GetLength() + 1)* sizeof(wchar_t)));

    if (*lpPtr == NULL)
        return E_OUTOFMEMORY;

	USES_CONVERSION;

    wcscpy(*lpPtr, T2OLE((LPTSTR)(LPCTSTR)s));

    return S_OK;
}


STDMETHODIMP CCAPolicyAboutImpl::GetSnapinDescription(LPOLESTR* lpDescription)
{
    return AboutHelper(IDS_CAPOLICY_DESCRIPTION, lpDescription);
}


STDMETHODIMP CCAPolicyAboutImpl::GetProvider(LPOLESTR* lpName)
{
    return AboutHelper(IDS_COMPANY, lpName);
}


STDMETHODIMP CCAPolicyAboutImpl::GetSnapinVersion(LPOLESTR* lpVersion)
{
    return AboutHelper(IDS_CAPOLICY_VERSION, lpVersion);
}


STDMETHODIMP CCAPolicyAboutImpl::GetSnapinImage(HICON* hAppIcon)
{
    if (hAppIcon == NULL)
        return E_POINTER;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // in MMC 1.1, this will be used as root node icon!!
    *hAppIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDI_APPICON));

    ASSERT(*hAppIcon != NULL);
    return (*hAppIcon != NULL) ? S_OK : E_FAIL;
}


STDMETHODIMP CCAPolicyAboutImpl::GetStaticFolderImage(HBITMAP* hSmallImage, 
                                                    HBITMAP* hSmallImageOpen,
                                                    HBITMAP* hLargeImage, 
                                                    COLORREF* cLargeMask)
{
	ASSERT(hSmallImage != NULL);
	ASSERT(hSmallImageOpen != NULL);
	ASSERT(hLargeImage != NULL);
	ASSERT(cLargeMask != NULL);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());	// Required for AfxGetInstanceHandle()
	HINSTANCE hInstance = AfxGetInstanceHandle();

    *hSmallImage = ::LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_FOLDER_SMALL));
	*hSmallImageOpen = ::LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_FOLDER_SMALL));
	*hLargeImage = ::LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_FOLDER_LARGE));

	*cLargeMask = RGB(255, 0, 255);

	#ifdef _DEBUG
	if (NULL == *hSmallImage || NULL == *hSmallImageOpen || NULL == *hLargeImage)
		{
        OutputDebugString(L"WRN: CSnapinAbout::GetStaticFolderImage() - Unable to load all the bitmaps.\n"); 
		return E_FAIL;
		}
	#endif

    return S_OK;
}


CCertTypeAboutImpl::CCertTypeAboutImpl()
{
}


CCertTypeAboutImpl::~CCertTypeAboutImpl()
{
}


HRESULT CCertTypeAboutImpl::AboutHelper(UINT nID, LPOLESTR* lpPtr)
{
    if (lpPtr == NULL)
        return E_POINTER;

    CString s;

    // Needed for Loadstring
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    s.LoadString(nID);
    *lpPtr = reinterpret_cast<LPOLESTR>
            (CoTaskMemAlloc((s.GetLength() + 1)* sizeof(wchar_t)));

    if (*lpPtr == NULL)
        return E_OUTOFMEMORY;

	USES_CONVERSION;

    wcscpy(*lpPtr, T2OLE((LPTSTR)(LPCTSTR)s));

    return S_OK;
}


STDMETHODIMP CCertTypeAboutImpl::GetSnapinDescription(LPOLESTR* lpDescription)
{
    return AboutHelper(IDS_CERTTYPE_DESCRIPTION, lpDescription);
}


STDMETHODIMP CCertTypeAboutImpl::GetProvider(LPOLESTR* lpName)
{
    return AboutHelper(IDS_COMPANY, lpName);
}


STDMETHODIMP CCertTypeAboutImpl::GetSnapinVersion(LPOLESTR* lpVersion)
{
    return AboutHelper(IDS_CERTTYPE_VERSION, lpVersion);
}


STDMETHODIMP CCertTypeAboutImpl::GetSnapinImage(HICON* hAppIcon)
{
    if (hAppIcon == NULL)
        return E_POINTER;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // in MMC 1.1, this will be used as root node icon!!
    *hAppIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDI_APPICON));

    ASSERT(*hAppIcon != NULL);
    return (*hAppIcon != NULL) ? S_OK : E_FAIL;
}


STDMETHODIMP CCertTypeAboutImpl::GetStaticFolderImage(HBITMAP* hSmallImage, 
                                                    HBITMAP* hSmallImageOpen,
                                                    HBITMAP* hLargeImage, 
                                                    COLORREF* cLargeMask)
{
	ASSERT(hSmallImage != NULL);
	ASSERT(hSmallImageOpen != NULL);
	ASSERT(hLargeImage != NULL);
	ASSERT(cLargeMask != NULL);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());	// Required for AfxGetInstanceHandle()
	HINSTANCE hInstance = AfxGetInstanceHandle();

    *hSmallImage = ::LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_FOLDER_SMALL));
	*hSmallImageOpen = ::LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_FOLDER_SMALL));
	*hLargeImage = ::LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_FOLDER_LARGE));

	*cLargeMask = RGB(255, 0, 255);

	#ifdef _DEBUG
	if (NULL == *hSmallImage || NULL == *hSmallImageOpen || NULL == *hLargeImage)
		{
		OutputDebugString(L"WRN: CSnapinAbout::GetStaticFolderImage() - Unable to load all the bitmaps.\n");
		return E_FAIL;
		}
	#endif

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\capesnpn\caprop.h ===
//+----------------------------------------------------------------------------
//
//  Class:      CDsCACertPage
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       caprop.h
//
//  Contents:   CA DS object property pages
//
//  Classes:    CDsCACertPage
//
//  History:    16-Mar-99 petesk copied from bryanwal
//
//-----------------------------------------------------------------------------

#ifndef _CAPROP_H_
#define _CAPROP_H_
#include "genpage.h"
#include <wincrypt.h>
#include <cryptui.h>
#include "certifct.h"
#include <shlobj.h>
#include <dsclient.h>
enum {
	CERTCOL_ISSUED_TO = 0,
	CERTCOL_ISSUED_BY,
	CERTCOL_PURPOSES,
	CERTCOL_EXP_DATE
};

//
//  Purpose:    property page object class for the User Certificates page.
//
//-----------------------------------------------------------------------------
class CDsCACertPage : public CAutoDeletePropPage 
{
public:

    enum { IID_DEFAULT = IDD_CACERTS };


    CDsCACertPage(LPWSTR wszObjectDN, UINT uIDD = IDD_CACERTS);
    virtual ~CDsCACertPage(void);

    //
    //  Instance specific wind proc
    //
    LRESULT DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:

    CString     m_strObjectDN;
	CRYPTUI_SELECTCERTIFICATE_STRUCT m_selCertStruct;
	HBITMAP		m_hbmCert;
	HIMAGELIST	m_hImageList;
	int			m_nCertImageIndex;
	HRESULT AddListViewColumns ();
	HCERTSTORE m_hCertStore;


public:

    // Overrides

    BOOL OnApply(void );
    BOOL OnInitDialog();


protected:
    // Implementation
    void OnDestroy();
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    BOOL OnNotify(UINT idCtrl, NMHDR* pNMHDR);

    int MessageBox (int caption, int text, UINT flags);
	HRESULT AddCertToStore (PCCERT_CONTEXT pCertContext);
	void OnNotifyItemChanged (LPNMLISTVIEW item);
	void OnNotifyStateChanged (LPNMLVODSTATECHANGE pnlvo);
	void EnableControls ();
	void DisplaySystemError (DWORD dwErr, int iCaptionText);
	HRESULT InsertCertInList (CCertificate* pCert, int nItem);
	void RefreshItemInList (CCertificate * pCert, int nItem);
	CCertificate* GetSelectedCertificate (int& nSelItem);
	HRESULT PopulateListView ();
	HRESULT	OnDeleteItemCertList (LPNMLISTVIEW pNMListView);
	HRESULT OnColumnClickCertList (LPNMHDR pNMHdr);
	HRESULT OnDblClkCertList (LPNMHDR pNMHdr);
	HRESULT OnClickedCopyToFile ();
	HRESULT OnClickedRemove();
	HRESULT OnClickedAddFromFile();
	HRESULT OnClickedAddFromStore ();
	HRESULT OnClickedViewCert ();
};





/////////////////////////////////////////////////////////////////////////////
// CCAShellExt
//
// Shell Extension class
// 
class ATL_NO_VTABLE CCAShellExt : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CCAShellExt, &CLSID_CAShellExt>,
	public IShellExtInit,
	public IShellPropSheetExt,
    public IContextMenu
{
public:
	CCAShellExt()
	{
        m_Names = NULL;
        m_idManage = 0;
        m_idOpen = 0;
        m_idExport = 0;
	}

	~CCAShellExt()
	{
        if(m_Names)
        {
            GlobalFree(m_Names);
        }
	}

    //Simple ALL 1.0 based registry entry
    DECLARE_REGISTRY(   CCAShellExt,
                        _T("CAPESNPN.CCAShellExt.1"),
                        _T("CAPESNPN.CCAShellExt"),
                        IDS_CCASHELLEXT_DESC,
                        THREADFLAGS_APARTMENT)

BEGIN_COM_MAP(CCAShellExt)
	COM_INTERFACE_ENTRY(IShellExtInit)
	COM_INTERFACE_ENTRY(IShellPropSheetExt)
	COM_INTERFACE_ENTRY(IContextMenu)
END_COM_MAP()

// IDfsShell
public:


// IShellExtInit Methods

	STDMETHOD (Initialize)
	(
		IN LPCITEMIDLIST	pidlFolder,		// Points to an ITEMIDLIST structure
		IN LPDATAOBJECT	lpdobj,			// Points to an IDataObject interface
		IN HKEY			hkeyProgID		// Registry key for the file object or folder type
	);	

    //IShellPropSheetExt methods
    STDMETHODIMP AddPages
	(
		IN LPFNADDPROPSHEETPAGE lpfnAddPage, 
		IN LPARAM lParam
	);
    
    STDMETHODIMP ReplacePage
	(
		IN UINT uPageID, 
		IN LPFNADDPROPSHEETPAGE lpfnReplaceWith, 
		IN LPARAM lParam
	);

    // IContextMenu methods
    STDMETHODIMP GetCommandString
    (    
        UINT_PTR idCmd,    
        UINT uFlags,    
        UINT *pwReserved,
        LPSTR pszName,    
        UINT cchMax   
    );

    STDMETHODIMP InvokeCommand
    (    
        LPCMINVOKECOMMANDINFO lpici   
    );	



    STDMETHODIMP QueryContextMenu
    (
        HMENU hmenu,
        UINT indexMenu,
        UINT idCmdFirst,
        UINT idCmdLast,
        UINT uFlags
    );


private:
    STDMETHODIMP _SpawnCertServerSnapin(LPWSTR wszServiceDN);
    STDMETHODIMP _CRLFromDN(LPWSTR wszCDPDN, PCCRL_CONTEXT *ppCRL);
    STDMETHODIMP _LaunchCRLDialog(PCCRL_CONTEXT pCRL);
    STDMETHODIMP _OnExportCRL (PCCRL_CONTEXT pCRL);

    LPDSOBJECTNAMES m_Names;
    DWORD           m_idManage;
    DWORD           m_idOpen;
    DWORD           m_idExport;


};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\capesnpn\compdata.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

// Compdata.h : Declaration of the CComponentDataImpl

#ifndef _COMPDATA_H_
#define _COMPDATA_H_

#include "resource.h"       // main symbols



#ifndef __mmc_h__
#include <mmc.h>
#endif

class CFolder; 

// Note - This is the offset in my image list that represents the folder
enum IMAGE_INDEXES
{
    IMGINDEX_FOLDER = 0,
    IMGINDEX_FOLDER_OPEN,
    IMGINDEX_CERTTYPE
};

// Event Values
#define IDC_STOPSERVER      0x100
#define IDC_STARTSERVER     0x101

#ifdef DBX
  void DbxPrint(LPTSTR pszFmt, ...)
  {
      va_list va;
      va_start (va, pszFmt);
      TCHAR buf[250];
      wsprintf(buf, pszFmt, va);
      OutputDebugString(buf);
      va_end(va);
  }
  //#define DBX_PRINT     DbxPrint
  inline void __DummyTrace(LPTSTR, ...) { }
  #define DBX_PRINT     1 ? (void)0 : ::__DummyTrace
#else
  inline void __DummyTrace(LPTSTR, ...) { }
  #define DBX_PRINT     1 ? (void)0 : ::__DummyTrace
#endif 


#define HTMLHELP_FILENAME L"cs.chm"
#define HTMLHELP_COLLECTION_FILENAME 	L"\\help\\" HTMLHELP_FILENAME 
#define HTMLHELP_COLLECTIONLINK_FILENAME 	L"\\help\\csconcepts.chm"

#define SZ_VERB_OPEN L"open"
#define SZ_CERTTMPL_MSC L"certtmpl.msc"

CONTEXTMENUITEM menuItems[];
CONTEXTMENUITEM viewItems[];


class CComponentDataImpl:
    public IComponentData,
    public IExtendPropertySheet,
    public IExtendContextMenu,
    public IPersistStream,
    public CComObjectRoot,
    public ISnapinHelp2
{
BEGIN_COM_MAP(CComponentDataImpl)
    COM_INTERFACE_ENTRY(IComponentData)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(ISnapinHelp2)
END_COM_MAP()

    friend class CSnapin;
    friend class CDataObject;

    CComponentDataImpl();
    ~CComponentDataImpl();

public:
    virtual const CLSID& GetCoClassID() = 0;
    virtual const BOOL IsPrimaryImpl() = 0;

public:
// ISnapinHelp2 interface members
    STDMETHOD(GetHelpTopic)(LPOLESTR* lpCompiledHelpFile);
    STDMETHOD(GetLinkedTopics)(LPOLESTR* lpCompiledHelpFiles);

// IComponentData interface members
    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);
    STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy)();
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM* pScopeDataItem);       
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

// IExtendPropertySheet interface
public:
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider, 
                        LONG_PTR handle, 
                        LPDATAOBJECT lpIDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);

// IExtendContextMenu 
public:
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pCallbackUnknown, 
                            long *pInsertionAllowed);
    STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

public:
// IPersistStream interface members
    //STDMETHOD(GetClassID)(CLSID *pClassID);
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)(IStream *pStm);
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);

#if DBG
    bool m_bInitializedCD;
    bool m_bLoadedCD;
    bool m_bDestroyedCD;
#endif

// Notify handler declarations
private:
    HRESULT OnDelete(MMC_COOKIE cookie);
    HRESULT OnRemoveChildren(LPARAM arg);
    HRESULT OnRename(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnExpand(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param);
    HRESULT OnSelect(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnProperties(LPARAM param);

#if DBG==1
public:
    ULONG InternalAddRef()
    {
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        return CComObjectRoot::InternalRelease();
    }
#endif // DBG==1

// Scope item creation helpers
private:
    CFolder* FindObject(MMC_COOKIE cookie); 
    void DeleteList();
    BOOL IsScopePaneNode(LPDATAOBJECT lpDataObject);    

private:
    LPCONSOLENAMESPACE      m_pScope;       // My interface pointer to the scope pane
    LPCONSOLE2               m_pConsole;     // My interface pointer to the console
    HSCOPEITEM              m_pStaticRoot;
    BOOL                    m_bIsDirty;

    void SetDirty(BOOL b = TRUE) { m_bIsDirty = b; }
    void ClearDirty() { m_bIsDirty = FALSE; }
    BOOL ThisIsDirty() { return m_bIsDirty; }

    void AddScopeItemToResultPane(MMC_COOKIE cookie);

    ////////
    // persist
    enum 
    {   // Bit fields for m_dwFlagsPersist
		mskfAllowOverrideMachineName = 0x0001
    };

	DWORD m_dwFlagsPersist;				// General-purpose flags to be persisted into .msc file
	BOOL m_fAllowOverrideMachineName;	// TRUE => Allow the machine name to be overriden by the command line

    void SetPersistentFlags(DWORD dwFlags)
	{
		m_dwFlagsPersist = dwFlags;
		m_fAllowOverrideMachineName = (m_dwFlagsPersist & mskfAllowOverrideMachineName);
	}

	DWORD GetPersistentFlags()
	{
		if (m_fAllowOverrideMachineName)
			m_dwFlagsPersist |= mskfAllowOverrideMachineName;
		else
			m_dwFlagsPersist &= ~mskfAllowOverrideMachineName;
		return m_dwFlagsPersist;
	}
    // end persist
    ///////////////
    HRESULT StartCertificateTemplatesSnapin();

public:
    HRESULT GetCreateFolderHRESULT() { return m_hrCreateFolder; };

private:
    CList<CFolder*, CFolder*> m_scopeItemList; 
    bool m_fAdvancedServer;
    HRESULT m_hrCreateFolder;

#ifdef _DEBUG
    friend class CDataObject;
    int     m_cDataObjects;

#endif
};


class CComponentDataPolicySettings : public CComponentDataImpl,
    public CComCoClass<CComponentDataPolicySettings, &CLSID_CAPolicyExtensionSnapIn>
{
public:
    DECLARE_REGISTRY(CSnapin, _T("Snapin.PolicySettings.1"), _T("Snapin.PolicySettings"), IDS_SNAPIN_DESC, THREADFLAGS_APARTMENT)
    virtual const CLSID & GetCoClassID() { return CLSID_CAPolicyExtensionSnapIn; }
    virtual const BOOL IsPrimaryImpl() { return TRUE; }

    STDMETHOD(GetClassID)(CLSID __RPC_FAR *pClassID)
    {
        *pClassID = CLSID_CAPolicyExtensionSnapIn;
        return S_OK;
    }
};

class CComponentDataGPEExtension : public CComponentDataImpl,
    public CComCoClass<CComponentDataGPEExtension, &CLSID_CACertificateTemplateManager>
{
public:
    // reid fix - IDS_SNAPIN_DESC is not right here
    DECLARE_REGISTRY(CSnapin, _T("Snapin.CertTempMgr.1"), _T("Snapin.CertTempMgr"), IDS_SNAPIN_DESC, THREADFLAGS_APARTMENT)
    virtual const CLSID & GetCoClassID() { return CLSID_CACertificateTemplateManager; }
    virtual const BOOL IsPrimaryImpl() { return TRUE; }

    STDMETHOD(GetClassID)(CLSID __RPC_FAR *pClassID)
    {
        *pClassID = CLSID_CACertificateTemplateManager;
        return S_OK;
    }
};

#endif // #define _COMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\capesnpn\caprop.cpp ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       UserCert.cxx
//
//  Contents:   
//
//  History:    12-November-97 BryanWal created
//
//-----------------------------------------------------------------------------
#include "stdafx.h"
#include "certca.h"
#include "tfcprop.h"
#include "genpage.h"

#include "commdlg.h"
#include "caprop.h"


#define ByteOffset(base, offset) (((LPBYTE)base)+offset)


//+----------------------------------------------------------------------------
//
//  Member:     CDsCACertPage::CDsCACertPage
//
//-----------------------------------------------------------------------------
CDsCACertPage::CDsCACertPage(LPWSTR wszObjectDN,  UINT uIDD) : CAutoDeletePropPage(uIDD),
    m_strObjectDN(wszObjectDN),
	m_hCertStore (0),
	m_hImageList (0),
	m_hbmCert (0),
	m_nCertImageIndex (0)
{

	::ZeroMemory (&m_selCertStruct, sizeof (m_selCertStruct));
}


//+----------------------------------------------------------------------------
//
//  Member:     CDsCACertPage::~CDsCACertPage
//
//-----------------------------------------------------------------------------
CDsCACertPage::~CDsCACertPage()
{

	// Clean up enumerated store list
	for (DWORD dwIndex = 0; dwIndex < m_selCertStruct.cDisplayStores; dwIndex++)
	{
		ASSERT (m_selCertStruct.rghDisplayStores);
		::CertCloseStore (m_selCertStruct.rghDisplayStores[dwIndex], CERT_CLOSE_STORE_FORCE_FLAG);
	}
	if ( m_selCertStruct.rghDisplayStores )
		delete [] m_selCertStruct.rghDisplayStores;


	if ( m_hImageList )
		ImageList_Destroy (m_hImageList);
	if ( m_hbmCert )
		DeleteObject (m_hbmCert);
}



typedef struct _ENUM_ARG {
    DWORD				dwFlags;
    DWORD*              pcDisplayStores;          
    HCERTSTORE **       prghDisplayStores;        
} ENUM_ARG, *PENUM_ARG;

static BOOL WINAPI EnumStoresSysCallback(
    IN const void* pwszSystemStore,
    IN DWORD dwFlags,
    IN PCERT_SYSTEM_STORE_INFO pStoreInfo,
    IN OPTIONAL void *pvReserved,
    IN OPTIONAL void *pvArg
    )
{
    PENUM_ARG pEnumArg = (PENUM_ARG) pvArg;
	void*		pvPara = (void*)pwszSystemStore;



	HCERTSTORE	hNewStore  = ::CertOpenStore (CERT_STORE_PROV_SYSTEM, 
				X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, NULL, 
				CERT_SYSTEM_STORE_CURRENT_USER, pvPara);
	if ( !hNewStore )
	{
		hNewStore = ::CertOpenStore (CERT_STORE_PROV_SYSTEM, 
				X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, NULL, 
				CERT_SYSTEM_STORE_CURRENT_USER | CERT_STORE_READONLY_FLAG, pvPara);
	}
	if ( hNewStore )
	{
		DWORD		dwCnt = *(pEnumArg->pcDisplayStores);
		HCERTSTORE*	phStores = 0;

		phStores = new HCERTSTORE[dwCnt+1];
		if ( phStores )
		{
			DWORD	dwIndex = 0;
			if ( *(pEnumArg->prghDisplayStores) )
			{
				for (; dwIndex < dwCnt; dwIndex++)
				{
					phStores[dwIndex] = (*(pEnumArg->prghDisplayStores))[dwIndex];
				}
				delete [] (*(pEnumArg->prghDisplayStores));
			}
			(*(pEnumArg->pcDisplayStores))++;
			(*(pEnumArg->prghDisplayStores)) = phStores;
			(*(pEnumArg->prghDisplayStores))[dwIndex] = hNewStore;
		}
		else
		{
			SetLastError (ERROR_NOT_ENOUGH_MEMORY);
			return FALSE;
		}
	}

    return TRUE;
}



//+----------------------------------------------------------------------------
//
//  Method:     CDsCACertPage::OnInitDialog
//
//  Synopsis:   Set the initial control values from the corresponding DS
//              attributes.
//
//-----------------------------------------------------------------------------
BOOL CDsCACertPage::OnInitDialog(void)
{
    HRESULT hResult = S_OK;
    CWaitCursor WaitCursor;
	const	LPWSTR	CERT_PROPERTY_EXT = L"?cACertificate?base?objectclass=certificationAuthority";


	// Get the object name and open its Published Certificate store
	ASSERT (m_strObjectDN);
	if ( m_strObjectDN )
	{
		LPWSTR	pvPara = new WCHAR[wcslen (m_strObjectDN) + 
					wcslen (CERT_PROPERTY_EXT) + 1];
		if ( pvPara )
		{
			wcscpy (pvPara, m_strObjectDN);
			wcscat (pvPara, CERT_PROPERTY_EXT);

			m_hCertStore = ::CertOpenStore ("LDAP",
				X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, NULL,
				0,
				(void*) pvPara);
			if ( !m_hCertStore )
			{
				MessageBox (IDS_USER_TITLE_PUBLISHED_CERTS, IDS_CANT_OPEN_STORE,
						MB_ICONINFORMATION | MB_OK);
				hResult = E_FAIL;
				::EnableWindow (GetDlgItem (m_hWnd, IDC_ADD_FROM_STORE), FALSE);
				::EnableWindow (GetDlgItem (m_hWnd, IDC_ADD_FROM_FILE), FALSE);
			}
		}
	}


	// Set up result list view
	COLORREF	crMask = RGB (255, 0, 255);
	m_hImageList = ImageList_Create (16, 16, ILC_MASK, 10, 10);
	ASSERT (m_hImageList);
	if ( m_hImageList )
	{
		m_hbmCert = ::LoadBitmap (g_hInstance, MAKEINTRESOURCE (IDB_CERTIFICATE));
		ASSERT (m_hbmCert);
		if ( m_hbmCert )
		{
			m_nCertImageIndex = ImageList_AddMasked (m_hImageList, m_hbmCert,
					crMask);
			ASSERT (m_nCertImageIndex != -1);
			if ( m_nCertImageIndex != -1 )
			{
				ListView_SetImageList (::GetDlgItem (m_hWnd, IDC_CERT_LIST),
						m_hImageList, LVSIL_SMALL);		
			}
		}
	}


	hResult = AddListViewColumns ();
	if ( SUCCEEDED  (hResult) && m_hCertStore )
		hResult = PopulateListView ();

	EnableControls ();

	// Enumerate User's certificate stores for use in selecting certificates
	// from stores.
	ENUM_ARG	EnumArg;

	m_selCertStruct.dwSize = sizeof (CRYPTUI_SELECTCERTIFICATE_STRUCT);
	m_selCertStruct.hwndParent = m_hWnd;
	EnumArg.pcDisplayStores = &m_selCertStruct.cDisplayStores;
	EnumArg.prghDisplayStores = &m_selCertStruct.rghDisplayStores;

	::CertEnumSystemStore (CERT_SYSTEM_STORE_CURRENT_USER, 0, &EnumArg, 
			EnumStoresSysCallback);

    return (hResult == S_OK);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsCACertPage::OnApply
//
//  Synopsis:   Handles the Apply notification.
//
//-----------------------------------------------------------------------------
BOOL CDsCACertPage::OnApply(void)
{
    HRESULT hResult = S_OK;
    CWaitCursor WaitCursor;

	if ( m_hCertStore )
	{
		BOOL	bResult = ::CertControlStore (m_hCertStore, 0, 
				CERT_STORE_CTRL_COMMIT, NULL);
		if ( !bResult )
		{

			DWORD	dwErr = GetLastError ();
			ASSERT (dwErr == ERROR_NOT_SUPPORTED);
			if ( dwErr != ERROR_NOT_SUPPORTED )
			{
				MessageBox (IDS_USER_TITLE_PUBLISHED_CERTS, IDS_CANT_SAVE_STORE,
						MB_ICONINFORMATION | MB_OK);
				hResult = E_FAIL;
			}
		}
	}

    if(SUCCEEDED(hResult))
    {
        return CAutoDeletePropPage::OnApply();
    }
    else
    {
        return FALSE;
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsCACertPage::OnCommand
//
//  Synopsis:   Handle control notifications.
//
//-----------------------------------------------------------------------------
BOOL CDsCACertPage::OnCommand(WPARAM wParam, LPARAM lParam)
{
    switch (HIWORD(wParam))
    {
	case BN_CLICKED:
		switch (LOWORD(wParam))
		{
		case IDC_VIEW_CERT:
			return S_OK == OnClickedViewCert ();
			break;

		case IDC_ADD_FROM_STORE:
			return S_OK == OnClickedAddFromStore ();
			break;

		case IDC_ADD_FROM_FILE:
			return S_OK == OnClickedAddFromFile ();
			break;

		case IDC_REMOVE:
			return S_OK == OnClickedRemove ();
			break;

		case IDC_COPY_TO_FILE:
			return S_OK == OnClickedCopyToFile ();
			break;

		default:
			_ASSERT (0);
			return FALSE;
			break;
		}
		break;

	default:
        break;
    }
    return TRUE;
}


//+----------------------------------------------------------------------------
//
//  Method:     CDsCACertPage::OnNotify
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
BOOL
CDsCACertPage::OnNotify(UINT idCtrl, NMHDR* pNMHdr)
{
	if ( !pNMHdr )
		return FALSE;

	switch (pNMHdr->code)
	{
	case NM_DBLCLK:
        if ( idCtrl == IDC_CERT_LIST )
			return S_OK == OnDblClkCertList (pNMHdr);
		break;

	case LVN_COLUMNCLICK:

		if ( idCtrl == IDC_CERT_LIST )
			return S_OK == OnColumnClickCertList (pNMHdr);
		break;

	case LVN_DELETEALLITEMS:

		if ( idCtrl == IDC_CERT_LIST )
			return FALSE;	// Do not suppress LVN_DELETEITEM messages
		break;

	case LVN_DELETEITEM:
		if ( idCtrl == IDC_CERT_LIST )
			return S_OK == OnDeleteItemCertList ((LPNMLISTVIEW)pNMHdr);
		break;

	case LVN_ODSTATECHANGED:
		OnNotifyStateChanged ((LPNMLVODSTATECHANGE)pNMHdr);
		return TRUE;

	case LVN_ITEMCHANGED:
		OnNotifyItemChanged ((LPNMLISTVIEW)pNMHdr); 
		return TRUE;

	default:
        return FALSE;
        break;
	}

    return TRUE;
}


//+----------------------------------------------------------------------------
//
//  Method:     CDsCACertPage::OnDestroy
//
//  Synopsis:   Exit cleanup
//
//-----------------------------------------------------------------------------
void CDsCACertPage::OnDestroy(void)
{
	ListView_DeleteAllItems (::GetDlgItem (m_hWnd, IDC_CERT_LIST));

	if ( m_hCertStore )
	{
		// Back out of uncommitted changes before closing the store.
		BOOL	bResult = ::CertControlStore (m_hCertStore, 
			CERT_STORE_CTRL_COMMIT_CLEAR_FLAG, 
			CERT_STORE_CTRL_COMMIT, NULL);
		if ( !bResult )
		{
			DWORD	dwErr = GetLastError ();
			ASSERT (dwErr != ERROR_NOT_SUPPORTED && dwErr != ERROR_CALL_NOT_IMPLEMENTED);
		}
		::CertCloseStore (m_hCertStore, 0);
		m_hCertStore = 0;
	}

    // If an application processes this message, it should return zero.
    CAutoDeletePropPage::OnDestroy();
}




HRESULT CDsCACertPage::AddListViewColumns()
{
	// Add list view columns
	LVCOLUMN	lvCol;
	::ZeroMemory (&lvCol, sizeof (lvCol));
    CString strTemp;

    VERIFY(strTemp.LoadString (IDS_CERTCOL_ISSUED_TO) );

	lvCol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM; 
    lvCol.fmt = LVCFMT_LEFT;
	lvCol.cx = 90;
    lvCol.pszText = const_cast<LPWSTR>((LPCWSTR)strTemp);     
	lvCol.iSubItem = CERTCOL_ISSUED_TO; 
	HWND	hWndList = ::GetDlgItem (m_hWnd, IDC_CERT_LIST);
	int	nIndex = ListView_InsertColumn (hWndList, CERTCOL_ISSUED_TO, &lvCol);
	_ASSERT (nIndex != -1);
	if ( nIndex == -1 )
		return E_UNEXPECTED;

    VERIFY(strTemp.LoadString (IDS_CERTCOL_ISSUED_BY) );

	lvCol.cx = 90;
    lvCol.pszText = const_cast<LPWSTR>((LPCWSTR)strTemp);      
	lvCol.iSubItem = CERTCOL_ISSUED_BY; 
	nIndex = ListView_InsertColumn (hWndList, IDS_CERTCOL_ISSUED_BY, &lvCol);
	_ASSERT (nIndex != -1);
	if ( nIndex == -1 )
		return E_UNEXPECTED;

    VERIFY(strTemp.LoadString (IDS_CERTCOL_PURPOSES) );

	lvCol.cx = 125;
    lvCol.pszText = const_cast<LPWSTR>((LPCWSTR)strTemp);      
	lvCol.iSubItem = CERTCOL_PURPOSES; 
	nIndex = ListView_InsertColumn (hWndList, IDS_CERTCOL_PURPOSES, &lvCol);
	_ASSERT (nIndex != -1);
	if ( nIndex == -1 )
		return E_UNEXPECTED;

    VERIFY(strTemp.LoadString (IDS_CERTCOL_EXP_DATE) );
	lvCol.cx = 125;
    lvCol.pszText = const_cast<LPWSTR>((LPCWSTR)strTemp);     
	lvCol.iSubItem = CERTCOL_EXP_DATE; 
	nIndex = ListView_InsertColumn (hWndList, IDS_CERTCOL_EXP_DATE, &lvCol);
	_ASSERT (nIndex != -1);
	if ( nIndex == -1 )
		return E_UNEXPECTED;

	return S_OK;
}

HRESULT CDsCACertPage::OnClickedViewCert()
{
	HRESULT	hResult = S_OK;
	int				nSelItem = -1;
	CCertificate*	pCert = GetSelectedCertificate (nSelItem);
	if ( pCert )
	{
		CRYPTUI_VIEWCERTIFICATE_STRUCT	vcs;
		HCERTSTORE						hCertStore = ::CertDuplicateStore (pCert->GetCertStore ());


		::ZeroMemory (&vcs, sizeof (vcs));
		vcs.dwSize = sizeof (vcs);
		vcs.hwndParent = m_hWnd;
		vcs.dwFlags = 0;
		vcs.cStores = 1;
		vcs.rghStores = &hCertStore;
		vcs.pCertContext = pCert->GetCertContext ();

		BOOL fPropertiesChanged = FALSE;
		BOOL bResult = ::CryptUIDlgViewCertificate (&vcs, &fPropertiesChanged);
		if ( bResult )
		{
			if ( fPropertiesChanged )
			{
				pCert->Refresh ();
				RefreshItemInList (pCert, nSelItem);
			}
		}
		::CertCloseStore (hCertStore, 0);
	}
	
	::SetFocus (::GetDlgItem (m_hWnd, IDC_CERT_LIST));
	return hResult;
}

HRESULT CDsCACertPage::OnClickedAddFromStore()
{
	HRESULT								hResult = S_OK;

	PCCERT_CONTEXT	pCertContext = ::CryptUIDlgSelectCertificate (&m_selCertStruct);
	if ( pCertContext )
	{
		hResult = AddCertToStore (pCertContext);
        SetModified();
	}
	

	::SetFocus (::GetDlgItem (m_hWnd, IDC_CERT_LIST));
	return hResult;
}

HRESULT CDsCACertPage::OnClickedAddFromFile()
{
	HRESULT			hResult = S_OK;
	HWND			hwndList = ::GetDlgItem (m_hWnd, IDC_CERT_LIST);


	CString strFilter;
	CString strDlgTitle;
	VERIFY(strFilter.LoadString (IDS_CERT_SAVE_FILTER));
	VERIFY(strDlgTitle.LoadString (IDS_OPEN_FILE_DLG_TITLE));

	{
		LPWSTR			pszDefExt = _T("cer");
		OPENFILENAME	ofn;
		WCHAR			szFile[MAX_PATH];



		::ZeroMemory (szFile, MAX_PATH * sizeof (WCHAR));
		::ZeroMemory (&ofn, sizeof (ofn));
		ofn.lStructSize = sizeof (OPENFILENAME);     
		ofn.hwndOwner = m_hWnd;
		ofn.lpstrFilter = const_cast<LPWSTR>((LPCWSTR)strFilter);
		ofn.lpstrFile = szFile;
		ofn.nMaxFile = MAX_PATH;     
		ofn.lpstrTitle = const_cast<LPWSTR>((LPCWSTR)strDlgTitle);
		ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST; 
		ofn.lpstrDefExt = pszDefExt;     


		BOOL bResult = GetOpenFileName (&ofn);
		if ( bResult )
		{
			DWORD			dwMsgAndCertEncodingType = 0;
			DWORD			dwContentType = 0;
			DWORD			dwFormatType = 0;
			PCERT_CONTEXT	pCertContext = 0;

			bResult = ::CryptQueryObject (
					CERT_QUERY_OBJECT_FILE,
					(void *) ofn.lpstrFile,
					CERT_QUERY_CONTENT_FLAG_SERIALIZED_CERT |
						CERT_QUERY_CONTENT_FLAG_CERT |
						CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED | 
						CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED |  
						CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED,
					CERT_QUERY_FORMAT_FLAG_ALL,
					0,
					&dwMsgAndCertEncodingType,
					&dwContentType,
					&dwFormatType,
					NULL,
					NULL,
					(const void **) &pCertContext);
			if ( bResult && pCertContext )
			{		
				hResult = AddCertToStore (pCertContext);
//				::CertFreeCertificateContext (pCertContext);
                SetModified();
			}
			else
			{
                MessageBox (IDS_UNKNOWN_CERT_FILE_TYPE, IDS_OPEN_FILE_DLG_TITLE, MB_ICONWARNING | MB_OK);

			}
		}
	}


	::SetFocus (hwndList);
	return hResult;
}

HRESULT CDsCACertPage::OnClickedRemove()
{
	HRESULT			hResult = S_OK;
	int				nSelItem = -1;
	HWND			hwndList = ::GetDlgItem (m_hWnd, IDC_CERT_LIST);
	bool			bConfirmationRequested = false;
	int				iResult = 0;
	int				nSelCnt = ListView_GetSelectedCount (hwndList);

	if ( nSelCnt < 1 )
		return E_FAIL;

	while (1)
	{
		CCertificate*	pCert = GetSelectedCertificate (nSelItem);
		if ( pCert )
		{
			if ( !bConfirmationRequested )
			{
	            CString strCaption;
	            CString strMsg;
				int		textId = 0;


                iResult = MessageBox (( 1 == nSelCnt )?IDS_CONFIRM_DELETE_CERT:IDS_CONFIRM_DELETE_CERTS, IDS_REMOVE_CERT,
						MB_YESNO);
				
				bConfirmationRequested = true;
				if ( IDYES != iResult )
					break;
			}

			BOOL bResult = pCert->DeleteFromStore ();
			ASSERT (bResult);
			if ( bResult )
			{
				bResult = ListView_DeleteItem (
						hwndList, 
						nSelItem);
				ASSERT (bResult);
				if ( bResult )
                    SetModified();
				else
					hResult = E_FAIL;
			}
			else
			{
				DWORD dwErr = GetLastError ();
				DisplaySystemError (dwErr, IDS_REMOVE_CERT);
				hResult = HRESULT_FROM_WIN32 (dwErr);
				break;
			}
		}
		else
			break;
	}

	::SetFocus (hwndList);
	EnableControls ();

	return hResult;
}

HRESULT CDsCACertPage::OnClickedCopyToFile()
{
	HRESULT			hResult = S_OK;

	CString strFilter;
	CString strDlgTitle;
	VERIFY(strFilter.LoadString (IDS_CERT_SAVE_FILTER));
	VERIFY(strDlgTitle.LoadString (IDS_SAVE_FILE_DLG_TITLE));
	{
		LPWSTR			pszDefExt = _T("cer");
		OPENFILENAME	ofn;
		WCHAR			szFile[MAX_PATH];


		::ZeroMemory (szFile, MAX_PATH * sizeof (WCHAR));
		::ZeroMemory (&ofn, sizeof (ofn));
		ofn.lStructSize = sizeof (OPENFILENAME);     
		ofn.hwndOwner = m_hWnd;
		ofn.lpstrFilter = const_cast<LPWSTR>((LPCWSTR)strFilter);
		ofn.lpstrFile = szFile;
		ofn.nMaxFile = MAX_PATH;     
		ofn.lpstrTitle = const_cast<LPWSTR>((LPCWSTR)strDlgTitle);
		ofn.Flags = OFN_PATHMUSTEXIST | OFN_CREATEPROMPT | OFN_OVERWRITEPROMPT | OFN_HIDEREADONLY; 
		ofn.lpstrDefExt = pszDefExt;     

		BOOL bResult = ::GetSaveFileName (&ofn);
		if ( bResult )
		{
			if ( wcsstr (_wcsupr (ofn.lpstrFile), _T(".CER")) )
			{
				HANDLE hFile = ::CreateFile (ofn.lpstrFile, // pointer to name of the file
					  GENERIC_READ | GENERIC_WRITE,         // access (read-write) mode
					  0,									// share mode
					  NULL,									// pointer to security attributes
					  CREATE_ALWAYS,						// how to create
					  FILE_ATTRIBUTE_NORMAL,				// file attributes
					  NULL);								// handle to file with attributes to copy
				ASSERT (hFile != INVALID_HANDLE_VALUE);
				if ( hFile != INVALID_HANDLE_VALUE )
				{
					int	iSelItem = -1;

					CCertificate* pCert = GetSelectedCertificate (iSelItem);
					ASSERT (pCert);
					if ( pCert )
					{
						// To cer file -> put out encoded blob
						// pbEncodedCert
						hResult = pCert->WriteToFile (hFile);
						if ( !SUCCEEDED (hResult) )
							DisplaySystemError (GetLastError (), IDS_COPY_TO_FILE);
					}

					if ( !CloseHandle (hFile) )
					{
						ASSERT (0);
						DisplaySystemError (GetLastError (), IDS_COPY_TO_FILE);
					}
				}
				else
					DisplaySystemError (GetLastError (), IDS_COPY_TO_FILE);
			}
			else
			{
				void* pvSaveToPara = (void*) ofn.lpstrFile;

				HCERTSTORE hCertStore = ::CertOpenStore (CERT_STORE_PROV_MEMORY, 
						X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, NULL, 
						CERT_FILE_STORE_COMMIT_ENABLE_FLAG, 0);
				if ( hCertStore )
				{
					int	iSelItem = -1;

					CCertificate* pCert = GetSelectedCertificate (iSelItem);
					ASSERT (pCert);
					if ( pCert )
					{
						bResult = ::CertAddCertificateContextToStore (
								hCertStore,
								::CertDuplicateCertificateContext (pCert->GetCertContext ()),
								CERT_STORE_ADD_ALWAYS,
								NULL);
						ASSERT (bResult);
						if ( bResult )
						{
							bResult = ::CertSaveStore (
									hCertStore,
									X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
									CERT_STORE_SAVE_AS_PKCS7,
									CERT_STORE_SAVE_TO_FILENAME,
									pvSaveToPara,
									0);
							ASSERT (bResult);
							if ( !bResult )
								DisplaySystemError (GetLastError (), IDS_COPY_TO_FILE);
						}
						else
							DisplaySystemError (GetLastError (), IDS_COPY_TO_FILE);
					}
					::CertCloseStore (hCertStore, 0);
				}
			}
		}
	}

	
	::SetFocus (::GetDlgItem (m_hWnd, IDC_CERT_LIST));
	return hResult;
}

HRESULT CDsCACertPage::OnDblClkCertList(LPNMHDR pNMHdr)
{
	HRESULT	hResult = S_OK;
	
	hResult = OnClickedViewCert ();
	return hResult;
}

HRESULT CDsCACertPage::OnColumnClickCertList(LPNMHDR pNMHdr)
{
	HRESULT	hResult = S_OK;
	
	return hResult;
}

HRESULT	CDsCACertPage::OnDeleteItemCertList (LPNMLISTVIEW pNMListView)
{
	HRESULT	hResult = S_OK;

	ASSERT (pNMListView);
	if ( pNMListView )
	{
		LVITEM	lvItem;

		::ZeroMemory (&lvItem, sizeof (lvItem));

		lvItem.mask = LVIF_PARAM;
		lvItem.iItem = pNMListView->iItem;

		if ( ListView_GetItem (::GetDlgItem (m_hWnd, IDC_CERT_LIST), &lvItem) )
		{
			CCertificate* pCert = (CCertificate*) lvItem.lParam;
			ASSERT (pCert);
			if ( pCert )
			{
				delete pCert;
			}
			else
				hResult = E_UNEXPECTED;
		}
		else
			hResult = E_UNEXPECTED;
	}
	else
		hResult = E_POINTER;

	return hResult;
}

HRESULT CDsCACertPage::PopulateListView()
{
	CWaitCursor			cursor;
    PCCERT_CONTEXT		pCertContext = 0;
	HRESULT				hResult = S_OK;
	CCertificate*		pCert = 0;

	//	Iterate through the list of certificates in the system store,
	//	allocate new certificates with the CERT_CONTEXT returned,
	//	and store them in the certificate list.
	int	nIndex = 0;
	int	nItem = -1;
	while ( SUCCEEDED (hResult) )
	{
		pCertContext = ::CertEnumCertificatesInStore (m_hCertStore, pCertContext);
		if ( !pCertContext )
			break;

		pCert = new CCertificate (pCertContext,	m_hCertStore);
		if ( pCert )
		{
			nItem++;

			hResult = InsertCertInList (pCert, nItem);
			if ( !SUCCEEDED (hResult) )
				delete pCert;
		}
		else
		{
			hResult = E_OUTOFMEMORY;
		}
	}


	return hResult;
}

// Get the first selected certificate, starting at the end of the list
// and previous to the passed in nSelItem.  Pass in a -1 to search
// the entire list
CCertificate* CDsCACertPage::GetSelectedCertificate (int& nSelItem)
{
	HWND			hWndList = ::GetDlgItem (m_hWnd, IDC_CERT_LIST);
	int				nCnt = ListView_GetItemCount (hWndList);
	CCertificate*	pCert = 0;
	PCCERT_CONTEXT	pCertContext = 0;
	int				nSelCnt = ListView_GetSelectedCount (hWndList);
	LVITEM			lvItem;

	::ZeroMemory (&lvItem, sizeof (lvItem));
	lvItem.mask = LVIF_PARAM;


	if ( nSelCnt >= 1 )
	{
		if ( -1 != nSelItem )
			nCnt = nSelItem;

		while (--nCnt >= 0)
		{
			UINT	flag = ListView_GetItemState (hWndList, 
				nCnt, LVIS_SELECTED);
			if ( flag & LVNI_SELECTED )
			{
				lvItem.iItem = nCnt;

				if ( ListView_GetItem (::GetDlgItem (m_hWnd, 
						IDC_CERT_LIST),
						&lvItem) )
				{
					pCert = (CCertificate*) lvItem.lParam;
					ASSERT (pCert);
					if ( pCert )
					{
						nSelItem = nCnt;
					}
				}
				else
				{
					ASSERT (0);
				}
				break; 
			}
		}
	}

	return pCert;
}

void CDsCACertPage::RefreshItemInList (CCertificate * pCert, int nItem)
{
	HWND			hWndList = ::GetDlgItem (m_hWnd, IDC_CERT_LIST);
	BOOL	bResult = (BOOL)::SendMessage (hWndList, LVM_DELETEITEM, nItem, 0);
	ASSERT (bResult);

	HRESULT	hResult = InsertCertInList (pCert, nItem);
	if ( SUCCEEDED (hResult) )
	{
		bResult = ListView_Update (hWndList, nItem);
		ASSERT (bResult);
	}
	else
		delete pCert;	
}


HRESULT CDsCACertPage::InsertCertInList(CCertificate * pCert, int nItem)
{
	HRESULT			hResult = S_OK;
	HWND			hWndList = ::GetDlgItem (m_hWnd, IDC_CERT_LIST);
	LVITEM			lvItem;
	PWSTR			pszText = 0;
	BOOL			bResult = FALSE;
	int				nIndex = 0;


	// Insert icon and subject name
	::ZeroMemory (&lvItem, sizeof (lvItem));
	lvItem.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
	lvItem.iItem = nItem;
	lvItem.iSubItem = CERTCOL_ISSUED_TO;
	lvItem.iImage = m_nCertImageIndex;
	lvItem.lParam = (LPARAM) pCert;
	hResult = pCert->GetSubjectName (&pszText);
	if ( SUCCEEDED (hResult) )
		lvItem.pszText = pszText;
	else
	{
		hResult = pCert->GetAlternateSubjectName (&pszText);
		if ( SUCCEEDED (hResult) )
			lvItem.pszText = pszText;
	}
	if ( SUCCEEDED (hResult) )
	{
		nIndex = ListView_InsertItem (hWndList, &lvItem);		
		_ASSERT (nIndex != -1);
		if ( nIndex == -1 )
		{
			delete pCert;
			hResult = E_UNEXPECTED;
		}
	}
	else
	{
		delete pCert;
		hResult = E_UNEXPECTED;
	}


	if ( SUCCEEDED (hResult) )
	{
		// Insert issuer name
		::ZeroMemory (&lvItem, sizeof (lvItem));
		HRESULT	hResult1 = pCert->GetIssuerName (&pszText);
		if ( !SUCCEEDED (hResult1) )
		{
			hResult1 = pCert->GetAlternateIssuerName (&pszText);
		}
		if ( SUCCEEDED (hResult1) )
		{
			ListView_SetItemText (hWndList, nIndex, CERTCOL_ISSUED_BY, pszText);
		}
	}

	// Insert intended purpose
	if ( SUCCEEDED (hResult) )
	{
		HRESULT	hResult1 = pCert->GetEnhancedKeyUsage (&pszText);
		if ( SUCCEEDED (hResult1) && pszText )
		{
			ListView_SetItemText (hWndList, nIndex, CERTCOL_PURPOSES, pszText);
		}
	}

	// Insert expiration date
	if ( SUCCEEDED (hResult) )
	{
		HRESULT	hResult1 = pCert->GetValidNotAfter (&pszText);
		if ( SUCCEEDED (hResult1) )
		{
			ListView_SetItemText (hWndList, nIndex, CERTCOL_EXP_DATE, pszText);
		}
	}

	if ( pszText )
		delete [] pszText;

	return hResult;
}

void CDsCACertPage::DisplaySystemError(DWORD dwErr, int iCaptionText)
{
	LPVOID lpMsgBuf = 0;
		
	if (0 != FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,    
			NULL,
			dwErr,
			MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
			(LPTSTR) &lpMsgBuf, 0, NULL))
        {
		
	// Display the string.
	CString	strCaption;	
	VERIFY(strCaption.LoadString(iCaptionText));

	::MessageBox (m_hWnd, (LPWSTR) lpMsgBuf, strCaption, MB_ICONWARNING | MB_OK);

	// Free the buffer.
	LocalFree (lpMsgBuf);
        }
}

void CDsCACertPage::EnableControls()
{
	HWND	hWndDlg = m_hWnd;
	HWND	hWndList = ::GetDlgItem (hWndDlg, IDC_CERT_LIST);
	int		nSelCnt = ListView_GetSelectedCount (hWndList);
	int		nSelItem = -1;
	bool	bCanDelete = true;

	while (bCanDelete)
	{
		CCertificate*	pCert = GetSelectedCertificate (nSelItem);
		if ( pCert )
			bCanDelete = pCert->CanDelete ();
		else
			break;
	}

	::EnableWindow (::GetDlgItem (hWndDlg, IDC_REMOVE), bCanDelete && nSelCnt > 0);
	::EnableWindow (::GetDlgItem (hWndDlg, IDC_COPY_TO_FILE), nSelCnt == 1);
	::EnableWindow (::GetDlgItem (hWndDlg, IDC_VIEW_CERT), nSelCnt == 1);
}

void CDsCACertPage::OnNotifyStateChanged(LPNMLVODSTATECHANGE pStateChange)
{
	EnableControls ();
}

void CDsCACertPage::OnNotifyItemChanged (LPNMLISTVIEW pnmv)
{
	EnableControls ();
}

HRESULT CDsCACertPage::AddCertToStore(PCCERT_CONTEXT pCertContext)
{
	HRESULT	hResult = S_OK;

	BOOL bResult = ::CertAddCertificateContextToStore (
				m_hCertStore,
				pCertContext,
				CERT_STORE_ADD_NEW,
				0);
	if ( bResult )
	{
		CCertificate* pCert = new CCertificate (pCertContext, m_hCertStore); 
		if ( pCert )
		{
			hResult = InsertCertInList (pCert, 
					ListView_GetItemCount (
					::GetDlgItem (m_hWnd, IDC_CERT_LIST)));
			if ( !SUCCEEDED (hResult) )
				delete pCert;
		}
		else
		{
			hResult = E_OUTOFMEMORY;
		}
	}
	else
	{
		DWORD	dwErr = GetLastError ();
		if ( dwErr == CRYPT_E_EXISTS )
		{
			MessageBox (IDS_DUPLICATE_CERT, IDS_ADD_FROM_STORE, 
					MB_ICONINFORMATION | MB_OK);
			hResult = E_FAIL;

		}
		else
		{
			DisplaySystemError (dwErr, IDS_ADD_FROM_STORE);
			hResult = HRESULT_FROM_WIN32 (dwErr);
		}
	}

	return hResult;
}

int CDsCACertPage::MessageBox(int caption, int text, UINT flags)
{
	int	iReturn = -1;

	CString strCaption;
	CString strMsg;
	VERIFY(strCaption.LoadString (caption));
	VERIFY(strMsg.LoadString (text));

	iReturn = ::MessageBox (m_hWnd, strMsg, strCaption, flags);

	return iReturn;
}

/*----------------------------------------------------------------------
					IShellExtInit Implementation.
------------------------------------------------------------------------*/

STDMETHODIMP CCAShellExt::Initialize
(
	IN LPCITEMIDLIST	pidlFolder,		// Points to an ITEMIDLIST structure
	IN LPDATAOBJECT	    pDataObj,		// Points to an IDataObject interface
	IN HKEY			    hkeyProgID		// Registry key for the file object or folder type
)
{

  HRESULT hr = 0;
  FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
  STGMEDIUM medium = { TYMED_NULL };
  CString csClass, csPath;
  USES_CONVERSION;

  LPWSTR wszTypeDN = NULL, wszType = NULL;

  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  // if we have a pDataObj then try and get the first name from it

  if ( pDataObj ) 
  {
    // get path and class

    fmte.cfFormat = (CLIPFORMAT) RegisterClipboardFormat(CFSTR_DSOBJECTNAMES);
    if ( SUCCEEDED(pDataObj->GetData(&fmte, &medium)) ) 
    {
        // Note:  We take ownership of the HGLOBAL, so it needs to be freed with a GlobalFree.
        m_Names = (LPDSOBJECTNAMES)medium.hGlobal;
    }
  }
  hr = S_OK;                  // success
  
  
  return hr;

}


STDMETHODIMP CCAShellExt::AddPages
(
	IN LPFNADDPROPSHEETPAGE lpfnAddPage, 
	IN LPARAM lParam
)

{
    PropertyPage* pBasePage;
    LPWSTR        wszClassType = NULL;
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if(m_Names->cItems != 1)
    {
        // Don't add the properties page if we have no or many objects selected
        return S_OK;
    }

    if(m_Names->aObjects[0].offsetName == 0)
    {
        return E_UNEXPECTED;
    }
    if(m_Names->aObjects[0].offsetClass)
    {
        wszClassType = (LPWSTR)ByteOffset(m_Names, m_Names->aObjects[0].offsetClass);
    }

    if(wszClassType == NULL)
    {
        return S_OK;
    }

    if(_wcsicmp(wszClassType, L"certificationAuthority") == 0)
    {
    
        CDsCACertPage* pControlPage = new CDsCACertPage((LPWSTR)ByteOffset(m_Names, m_Names->aObjects[0].offsetName));
        if(pControlPage)
        {
            pBasePage = pControlPage;
            HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pBasePage->m_psp);
            if (hPage == NULL)
            {
                delete (pControlPage);
                return E_UNEXPECTED;
            }
            lpfnAddPage(hPage, lParam);                          
        }
    }
                                                                         
    return S_OK;                                                            
}


STDMETHODIMP CCAShellExt::ReplacePage
(
	IN UINT uPageID, 
    IN LPFNADDPROPSHEETPAGE lpfnReplaceWith, 
    IN LPARAM lParam
)
{
    return E_FAIL;
}


// IContextMenu methods
STDMETHODIMP CCAShellExt::GetCommandString
(    
    UINT_PTR idCmd,    
    UINT uFlags,    
    UINT *pwReserved,
    LPSTR pszName,    
    UINT cchMax   
)
{
    return E_NOTIMPL;
}


STDMETHODIMP CCAShellExt::InvokeCommand
(    
    LPCMINVOKECOMMANDINFO lpici   
)
{
    HRESULT hr = S_OK;

    LPWSTR        wszClassType = NULL;
    if(m_Names->cItems != 1)
    {
        // Don't add the properties page if we have no or many objects selected
        return S_OK;
    }

    if(m_Names->aObjects[0].offsetName == 0)
    {
        return E_UNEXPECTED;
    }
    if(m_Names->aObjects[0].offsetClass)
    {
        wszClassType = (LPWSTR)ByteOffset(m_Names, m_Names->aObjects[0].offsetClass);
    }

    if(wszClassType == NULL)
    {
        return S_OK;
    }


    if (!HIWORD(lpici->lpVerb))    
    {        
        UINT idCmd = LOWORD(lpici->lpVerb);
        if(_wcsicmp(wszClassType, L"pKIEnrollmentService") == 0)
        {
            if(idCmd == m_idManage)
            {
                return _SpawnCertServerSnapin((LPWSTR)ByteOffset(m_Names, m_Names->aObjects[0].offsetName));
            }
        }
        else if(_wcsicmp(wszClassType, L"cRLDistributionPoint") == 0)
        {
            PCCRL_CONTEXT pCRL = NULL;
            _CRLFromDN((LPWSTR)ByteOffset(m_Names, m_Names->aObjects[0].offsetName),
                       &pCRL);
            if(pCRL)
            {
                if(idCmd == m_idOpen)
                {
                    hr = _LaunchCRLDialog(pCRL);
                }
                else if(idCmd == m_idExport)
                {
                    hr = _OnExportCRL(pCRL);
                }

                CertFreeCRLContext(pCRL);
                return hr;
            }

        }
    }

    return E_NOTIMPL;
}


STDMETHODIMP CCAShellExt::_SpawnCertServerSnapin(LPWSTR wszServiceDN)
{
    // Determine the config string.  Strinp the CN out of the service DN, look it up via certca.h api's.

    HRESULT hr = S_OK;
    HCAINFO hCAInfo = NULL;
    LPWSTR wszTypeDN;
    LPWSTR *awszDNSName = NULL;
    LPWSTR wszArgs = NULL;
    
    LPWSTR wszCN= NULL;


    wszTypeDN = wcsstr(wszServiceDN, L"CN=");
    if(wszTypeDN == NULL)
    {
        return E_UNEXPECTED;
    }
    wszTypeDN += 3;


    wszCN = (LPWSTR)LocalAlloc(LMEM_FIXED, sizeof(WCHAR)*(wcslen(wszTypeDN)+1));
    if(wszCN == NULL)
    {
        return E_OUTOFMEMORY;
    }
    wcscpy(wszCN, wszTypeDN);
    wszTypeDN = wcschr(wszCN, L',');
    if(wszTypeDN)
    {
        *wszTypeDN = 0;
    }

    hr = CAFindByName(
		wszCN,
		NULL,
		CA_FIND_INCLUDE_UNTRUSTED | CA_FIND_INCLUDE_NON_TEMPLATE_CA,
		&hCAInfo);
    if(hr != S_OK)
    {
        goto error;
    }

    hr = CAGetCAProperty(hCAInfo, CA_PROP_DNSNAME, &awszDNSName);
    if(hr != S_OK)
    {
        goto error;
    }
    if((awszDNSName == NULL) || (awszDNSName[0] == NULL))
    {
        hr = E_UNEXPECTED;
        goto error;
    }



    wszArgs = (LPWSTR) LocalAlloc (LMEM_FIXED, (wcslen (awszDNSName[0]) + wcslen(wszCN) + 30) * sizeof(WCHAR));

    if (!wszArgs)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    //
    // Build the command line arguments
    //

    wsprintf (wszArgs, L"/s /machine:%s", awszDNSName[0]);


    ShellExecute (NULL, TEXT("open"), TEXT("certsrv.msc"), wszArgs,
                  NULL, SW_SHOWNORMAL);

error:
    if(wszArgs)
    {
        LocalFree(wszArgs);
    }

    if(wszCN)
    {
        LocalFree(wszCN);
    }
    if(hCAInfo)
    {
        if(awszDNSName)
        {
            CAFreeCAProperty(hCAInfo, awszDNSName);
        }
        CACloseCA(hCAInfo);
    }
    return hr;
}


STDMETHODIMP CCAShellExt::_CRLFromDN(LPWSTR wszCDPDN, PCCRL_CONTEXT *ppCRL)
{
    HCERTSTORE              hStore = NULL;
    HRESULT                 hResult = S_OK;
	const	LPWSTR	CDP_PROPERTY_EXT = L"?certificateRevocationList?base?objectclass=cRLDistributionPoint";

    LPWSTR  pvPara = NULL;

	ASSERT (wszCDPDN);
    *ppCRL = NULL;
	if ( wszCDPDN )
	{
		pvPara = new WCHAR[wcslen (wszCDPDN) + 
					wcslen (CDP_PROPERTY_EXT) + 1];
		if ( pvPara )
		{
			wcscpy (pvPara, wszCDPDN);
			wcscat (pvPara, CDP_PROPERTY_EXT);

			hStore = ::CertOpenStore ("LDAP",
				X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, NULL,
				0,
				(void*) pvPara);
			if ( !hStore )
			{
				hResult = E_FAIL;
                goto error;
			}
		}
	}

    if (NULL != hStore)
    {
    *ppCRL = CertFindCRLInStore(hStore, 
                              X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                              0,
                              CRL_FIND_ANY,
                              NULL,
                              NULL);
    }

error:
    if(hStore)
    {
        CertCloseStore(hStore, 0);
    }

    if(pvPara)
    {
        LocalFree(pvPara);
    }
    return hResult;
}

STDMETHODIMP CCAShellExt::_LaunchCRLDialog(PCCRL_CONTEXT pCRL)
{

        CRYPTUI_VIEWCRL_STRUCT  vcs;
        HWND                    hwndParent = NULL;
        HRESULT                 hr = S_OK;

        ::ZeroMemory (&vcs, sizeof (vcs));
        vcs.dwSize = sizeof (vcs);
        vcs.hwndParent = hwndParent;
        vcs.dwFlags = 0;
        vcs.pCRLContext = pCRL;

        if(!::CryptUIDlgViewCRL (&vcs))
        {
            hr = GetLastError();
            hr = HRESULT_FROM_WIN32(hr);
        }

        return hr;
}

HRESULT CCAShellExt::_OnExportCRL (PCCRL_CONTEXT pCRL)
{
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	HRESULT	hr = S_OK;


	CRYPTUI_WIZ_EXPORT_INFO	cwi;
	HWND	hwndParent = 0;

	::ZeroMemory (&cwi, sizeof (cwi));
	cwi.dwSize = sizeof (cwi);

	cwi.dwSubjectChoice = CRYPTUI_WIZ_EXPORT_CRL_CONTEXT;
	ASSERT (pCRL);
	if ( pCRL )
		cwi.pCRLContext = pCRL;
	else
		return E_UNEXPECTED;

	if(!::CryptUIWizExport (
			0,
			hwndParent,
			0,
			&cwi,
			NULL))
    {
	hr = GetLastError();
	hr = HRESULT_FROM_WIN32(hr);
    }

	return hr;
}

STDMETHODIMP CCAShellExt::QueryContextMenu
(
    HMENU hmenu,
    UINT indexMenu,
    UINT idCmdFirst,
    UINT idCmdLast,
    UINT uFlags
)
{
    LPWSTR        wszClassType = NULL;
    if(m_Names->cItems != 1)
    {
        // Don't add the properties page if we have no or many objects selected
        return S_OK;
    }

    if(m_Names->aObjects[0].offsetName == 0)
    {
        return E_UNEXPECTED;
    }
    if(m_Names->aObjects[0].offsetClass)
    {
        wszClassType = (LPWSTR)ByteOffset(m_Names, m_Names->aObjects[0].offsetClass);
    }

    if(wszClassType == NULL)
    {
        return S_OK;
    }

    if(((m_Names->aObjects[0].dwProviderFlags & DSPROVIDER_ADVANCED) != 0) &&
        (_wcsicmp(wszClassType, L"pKIEnrollmentService") == 0))
    {
        // Add a "manage" option
        CString szEdit;
        MENUITEMINFO mii;
        UINT idLastUsedCmd = idCmdFirst;
        AFX_MANAGE_STATE(AfxGetStaticModuleState());


        ZeroMemory(&mii, sizeof(mii));


        mii.cbSize = sizeof(mii);   
        mii.fMask = MIIM_TYPE | MIIM_ID;
        mii.fType = MFT_STRING;    
        mii.wID = idLastUsedCmd; 

        szEdit.LoadString(IDS_MANAGE);

        mii.dwTypeData = (LPTSTR)(LPCTSTR)szEdit;
        mii.cch = szEdit.GetLength();

        m_idManage = indexMenu;

        // Add new menu items to the context menu.    //
        ::InsertMenuItem(hmenu, 
                     indexMenu++, 
                     TRUE,
                     &mii);

        idLastUsedCmd++;

        return ResultFromScode (MAKE_SCODE (SEVERITY_SUCCESS, 0,
                                USHORT (idLastUsedCmd )));


    }
    else if(((m_Names->aObjects[0].dwProviderFlags & DSPROVIDER_ADVANCED) != 0) &&
            (_wcsicmp(wszClassType, L"cRLDistributionPoint") == 0))
    {
        // Add a "manage" option
        CString szName;
        MENUITEMINFO mii;
        UINT idLastUsedCmd = idCmdFirst;
        AFX_MANAGE_STATE(AfxGetStaticModuleState());


        ZeroMemory(&mii, sizeof(mii));


        mii.cbSize = sizeof(mii);   
        mii.fMask = MIIM_TYPE | MIIM_ID;
        mii.fType = MFT_STRING;    
        mii.wID = idLastUsedCmd; 

        szName.LoadString(IDS_OPEN);

        mii.dwTypeData = (LPTSTR)(LPCTSTR)szName;
        mii.cch = szName.GetLength();

        m_idOpen = indexMenu;
        // Add new menu items to the context menu.    //
        ::InsertMenuItem(hmenu, 
                     indexMenu++, 
                     TRUE,
                     &mii);
         idLastUsedCmd++;



        ZeroMemory(&mii, sizeof(mii));


        mii.cbSize = sizeof(mii);   
        mii.fMask = MIIM_TYPE | MIIM_ID;
        mii.fType = MFT_STRING;    
        mii.wID = idLastUsedCmd; 

        szName.LoadString(IDS_EXPORT);

        mii.dwTypeData = (LPTSTR)(LPCTSTR)szName;
        mii.cch = szName.GetLength();

        m_idExport = indexMenu;
        // Add new menu items to the context menu.    //
        ::InsertMenuItem(hmenu, 
                     indexMenu++, 
                     TRUE,
                     &mii);
        idLastUsedCmd++;



        return ResultFromScode (MAKE_SCODE (SEVERITY_SUCCESS, 0,
                                USHORT (idLastUsedCmd)));


    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\capesnpn\certifct.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       certifct.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
#ifndef __CERTIFICT_H
#define __CERTIFICT_H

#include "wincrypt.h"

#define MY_ENCODING_TYPE (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING)

/////////////////////////////////////////////////////////////////////////////
// CCertificate

class CCertificate
{
public:
	CCertificate(const PCCERT_CONTEXT pCertContext, HCERTSTORE hCertStore);
	virtual ~CCertificate();


public:
	bool CanDelete();
	BOOL DeleteFromStore ();
	HRESULT WriteToFile (HANDLE hFile);
	void Refresh ();
	int CompareExpireDate (const CCertificate& cert) const;
	BOOL IsMyStore () const;
	PCCERT_CONTEXT GetCertContext () const;
	HCERTSTORE GetCertStore () const;
	HRESULT GetAlternateSubjectName (PWSTR* ppszAltIssuerName);
	HRESULT GetAlternateIssuerName (PWSTR* ppszAltIssuerName);
	HRESULT GetEnhancedKeyUsage (PWSTR* ppszUsages);
	HRESULT GetValidNotAfter (PWSTR* pszValidNotAfter);
	HRESULT GetSubjectName (PWSTR *ppszSubjectName);
	HRESULT GetIssuerName (PWSTR *ppszIssuerName);

private:
	HRESULT FormatEnhancedKeyUsagePropertyString ();
	HRESULT ConvertAltNameToString (PWSTR szOID, const DWORD dwNameChoice, CString &strName);

private:	// data
	bool					m_bCanDelete;
	DWORD					m_fieldChecked;
	bool					m_bCertContextFreed;
	CString					m_szEnhancedKeyUsage;
	HCERTSTORE				m_hCertStore;
	CString					m_szAltSubjectName;
	CString					m_szAltIssuerName;
	CString					m_szValidNotAfter;
	CString					m_szSubjectName;
	CString					m_szIssuerName;
	PCERT_INFO				m_pCertInfo;
	const PCCERT_CONTEXT	m_pCertContext;
protected:
	HRESULT GetNameString (DWORD dwFlag, CString &strString);
	HRESULT GetOIDInfo (PWSTR* string, PSTR pszObjId);
	HRESULT FormatDate (FILETIME utcDateTime, CString &strDateTime);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\capesnpn\compdata.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.



#include "stdafx.h"
//#include <atlimpl.cpp>
//#include <gpedit.h>
#include <sceattch.h>
#include "wiz.h"
//#include <userenv.h>
#include "genpage.h"

#include <atlimpl.cpp>

// Array of menu item commands to be inserted into the contest menu.
// Note - the first item is the menu text, // CCM_SPECIAL_DEFAULT_ITEM
// the second item is the status string



///////////////////////////////////////////////////////////////////////////////
// IComponentData implementation

DEBUG_DECLARE_INSTANCE_COUNTER(CComponentDataImpl);

CComponentDataImpl::CComponentDataImpl()
    : m_bIsDirty(TRUE), m_pScope(NULL), m_pConsole(NULL),
#if DBG
     m_bInitializedCD(false), m_bDestroyedCD(false),
#endif
     m_fAdvancedServer(false), m_hrCreateFolder(S_OK)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CComponentDataImpl);

#ifdef _DEBUG
    m_cDataObjects = 0;
#endif
}

CComponentDataImpl::~CComponentDataImpl()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CComponentDataImpl);

    ASSERT(m_pScope == NULL);
    
    ASSERT(!m_bInitializedCD || m_bDestroyedCD);
    
    // Some snap-in is hanging on to data objects.
    // If they access, it will crash!!!
    ASSERT(m_cDataObjects <= 1);
}

STDMETHODIMP CComponentDataImpl::Initialize(LPUNKNOWN pUnknown)
{
    DBX_PRINT(_T(" ----------  CComponentDataImpl::Initialize<0x08x>\n"), this);
#if DBG
    m_bInitializedCD = true;
#endif

    ASSERT(pUnknown != NULL);
    HRESULT hr;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // MMC should only call ::Initialize once!
    ASSERT(m_pScope == NULL);
    pUnknown->QueryInterface(IID_IConsoleNameSpace, 
                    reinterpret_cast<void**>(&m_pScope));

    // add the images for the scope tree
    ::CBitmap bmp16x16;
    LPIMAGELIST lpScopeImage;

    hr = pUnknown->QueryInterface(IID_IConsole2, reinterpret_cast<void**>(&m_pConsole));
    ASSERT(hr == S_OK);

    hr = m_pConsole->QueryScopeImageList(&lpScopeImage);

    ASSERT(hr == S_OK);

    // Load the bitmaps from the dll
    bmp16x16.LoadBitmap(IDB_16x16);

    // Set the images
    lpScopeImage->ImageListSetStrip(reinterpret_cast<LONG_PTR *>(static_cast<HBITMAP>(bmp16x16)),
                      reinterpret_cast<LONG_PTR *>(static_cast<HBITMAP>(bmp16x16)),
                       0, RGB(255, 0, 255));

    lpScopeImage->Release();


    // Add any init code here NOT based on info from .MSC file
    
    return S_OK;
}

STDMETHODIMP CComponentDataImpl::CreateComponent(LPCOMPONENT* ppComponent)
{
    ASSERT(ppComponent != NULL);

    CComObject<CSnapin>* pObject;
    CComObject<CSnapin>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);

    // Store IComponentData
    pObject->SetIComponentData(this);

    return  pObject->QueryInterface(IID_IComponent, 
                    reinterpret_cast<void**>(ppComponent));
}

STDMETHODIMP CComponentDataImpl::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    ASSERT(m_pScope != NULL);
    HRESULT     hr = S_OK;
    HWND        hwndConsole;
    
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    INTERNAL* pInternal;
    MMC_COOKIE cookie;

    // Since it's my folder it has an internal format.
    // Design Note: for extension.  I can use the fact, that the data object doesn't have 
    // my internal format and I should look at the node type and see how to extend it.

    // switch on events where we don't care about pInternal->m_cookie
    switch(event)
    {
    case MMCN_PROPERTY_CHANGE:
        hr = OnProperties(param);
        goto Ret;

    case MMCN_EXPAND:
        hr = OnExpand(lpDataObject, arg, param);
        goto Ret;

    default:
        break;
    }

    // handle cases where we do care about pInternal->m_cookie
    pInternal = ExtractInternalFormat(lpDataObject);
    if (pInternal == NULL)
        return S_OK;

    cookie = pInternal->m_cookie;
    ::GlobalFree(reinterpret_cast<HANDLE>(pInternal));

    switch(event)
    {
    case MMCN_PASTE:
        break;
    
    case MMCN_DELETE:
        hr = OnDelete(cookie);
        break;

    case MMCN_REMOVE_CHILDREN:
        hr = OnRemoveChildren(arg);
        break;

    case MMCN_RENAME:
        hr = OnRename(cookie, arg, param);
        break;

    default:
        break;
    }

Ret:
    return hr;
}

STDMETHODIMP CComponentDataImpl::Destroy()
{
    DBX_PRINT(_T(" ----------  CComponentDataImpl::Destroy<0x08x>\n"), this);
    ASSERT(m_bInitializedCD);
#if DBG
    m_bDestroyedCD = true;
#endif
    
    // Delete enumerated scope items
    DeleteList(); 

    SAFE_RELEASE(m_pScope);
    SAFE_RELEASE(m_pConsole);

    return S_OK;
}

STDMETHODIMP CComponentDataImpl::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
#ifdef _DEBUG
    if (cookie == 0)
    {
        ASSERT(type != CCT_RESULT);
    }
    else 
    {
        ASSERT(type == CCT_SCOPE);
        
        DWORD dwItemType = GetItemType(cookie);
        ASSERT(dwItemType == SCOPE_LEVEL_ITEM);
        //ASSERT((dwItemType == SCOPE_LEVEL_ITEM) || (dwItemType == CA_LEVEL_ITEM));
    }
#endif 

    return _QueryDataObject(cookie, type, this, ppDataObject);
}



///////////////////////////////////////////////////////////////////////////////
//// ISnapinHelp interface
STDMETHODIMP CComponentDataImpl::GetHelpTopic(LPOLESTR* lpCompiledHelpFile)
{
  if (lpCompiledHelpFile == NULL)
     return E_POINTER;

  UINT cbWindows = 0;
  WCHAR szWindows[MAX_PATH+1];
  cbWindows = GetSystemWindowsDirectory(szWindows, MAX_PATH);
  if (cbWindows == 0)
     return S_FALSE;
  cbWindows++;  // include null term
  cbWindows *= sizeof(WCHAR);   // make this bytes, not chars

  *lpCompiledHelpFile = (LPOLESTR) CoTaskMemAlloc(sizeof(HTMLHELP_COLLECTION_FILENAME) + cbWindows);
  if (*lpCompiledHelpFile == NULL)
     return E_OUTOFMEMORY;
  myRegisterMemFree(*lpCompiledHelpFile, CSM_COTASKALLOC);  // this is freed by mmc, not our tracking


  USES_CONVERSION;
  wcscpy(*lpCompiledHelpFile, T2OLE(szWindows));
  wcscat(*lpCompiledHelpFile, T2OLE(HTMLHELP_COLLECTION_FILENAME));

  return S_OK;
}

// tells of other topics my chm links to
STDMETHODIMP CComponentDataImpl::GetLinkedTopics(LPOLESTR* lpCompiledHelpFiles)
{
  if (lpCompiledHelpFiles == NULL)
     return E_POINTER;

  UINT cbWindows = 0;
  WCHAR szWindows[MAX_PATH+1];
  cbWindows = GetSystemWindowsDirectory(szWindows, MAX_PATH);
  if (cbWindows == 0)
     return S_FALSE;
  cbWindows++;  // include null term
  cbWindows *= sizeof(WCHAR);   // make this bytes, not chars

  *lpCompiledHelpFiles = (LPOLESTR) CoTaskMemAlloc(sizeof(HTMLHELP_COLLECTIONLINK_FILENAME) + cbWindows);
  if (*lpCompiledHelpFiles == NULL)
     return E_OUTOFMEMORY;
  myRegisterMemFree(*lpCompiledHelpFiles, CSM_COTASKALLOC);  // this is freed by mmc, not our tracking


  USES_CONVERSION;
  wcscpy(*lpCompiledHelpFiles, T2OLE(szWindows));
  wcscat(*lpCompiledHelpFiles, T2OLE(HTMLHELP_COLLECTIONLINK_FILENAME));

  return S_OK;
}



///////////////////////////////////////////////////////////////////////////////
//// IPersistStream interface members
/*
STDMETHODIMP CComponentDataImpl::GetClassID(CLSID *pClassID)
{
    ASSERT(pClassID != NULL);

    // Copy the CLSID for this snapin
    *pClassID = CLSID_CAPolicyExtensionSnapIn;

    return E_NOTIMPL;
}
*/
STDMETHODIMP CComponentDataImpl::IsDirty()
{
    // Always save / Always dirty.
    return ThisIsDirty() ? S_OK : S_FALSE;
}

STDMETHODIMP CComponentDataImpl::Load(IStream *pStm)
{
    DBX_PRINT(_T(" ----------  CComponentDataImpl::Load<0x08x>\n"), this);

    ASSERT(pStm);
    ASSERT(m_bInitializedCD);

    // Read the string
    DWORD dwVer;
    ULONG nBytesRead;
    HRESULT hr = pStm->Read(&dwVer, sizeof(DWORD), &nBytesRead);

    // Verify that the read succeeded
    ASSERT(SUCCEEDED(hr) && nBytesRead == sizeof(DWORD));

    // check to see if this is the correct version
    if (dwVer != 0x1)
    {
        return STG_E_OLDFORMAT;
    }

    ClearDirty();

    return SUCCEEDED(hr) ? S_OK : E_FAIL;
}

STDMETHODIMP CComponentDataImpl::Save(IStream *pStm, BOOL fClearDirty)
{
    DBX_PRINT(_T(" ----------  CComponentDataImpl::Save<0x08x>\n"), this);

    ASSERT(pStm);
    ASSERT(m_bInitializedCD);

    // Write the string
    ULONG nBytesWritten;
    DWORD dwVer = 0x1;
    HRESULT hr = pStm->Write(&dwVer, sizeof(DWORD), &nBytesWritten);

    // Verify that the write operation succeeded
    ASSERT(SUCCEEDED(hr) && nBytesWritten == sizeof(DWORD));
    if (FAILED(hr))
        return STG_E_CANTSAVE;

    if (fClearDirty)
        ClearDirty();
    return S_OK;
}

STDMETHODIMP CComponentDataImpl::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    ASSERT(pcbSize);

    DWORD cbSize;
    cbSize = sizeof(DWORD); // version

    // Set the size of the string to be saved
    ULISet32(*pcbSize, cbSize);

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//// Notify handlers for IComponentData

HRESULT CComponentDataImpl::OnDelete(MMC_COOKIE cookie)
{
    return S_OK;
}

HRESULT CComponentDataImpl::OnRemoveChildren(LPARAM arg)
{
    return S_OK;
}

HRESULT CComponentDataImpl::OnRename(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    if (arg == 0)
        return S_OK;
    
    LPOLESTR pszNewName = reinterpret_cast<LPOLESTR>(param);
    if (pszNewName == NULL)
        return E_INVALIDARG;

    CFolder* pFolder = reinterpret_cast<CFolder*>(cookie);
    ASSERT(pFolder != NULL);
    if (pFolder == NULL)
        return E_INVALIDARG;

    pFolder->SetName(pszNewName);
    
    return S_OK;
}

HRESULT CComponentDataImpl::OnExpand(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;

    GUID*       pNodeGUID = NULL;
    CFolder*    pFolder=NULL;
    bool fInsertFolder = false;

    STGMEDIUM stgmediumNodeType = { TYMED_HGLOBAL, NULL };
    STGMEDIUM stgmediumCAType = { TYMED_HGLOBAL, NULL };
    STGMEDIUM stgmediumCAName = { TYMED_HGLOBAL, NULL };

    LPWSTR pszDSName = NULL;

    if (arg == TRUE)
    {
        // Did Initialize get called?
        ASSERT(m_pScope != NULL);

        //
        // get the guid of the current node
        //
        UINT s_cfNodeType;
        s_cfNodeType = RegisterClipboardFormat(W2T(CCF_NODETYPE));
    
        FORMATETC formatetcNodeType = { (CLIPFORMAT)s_cfNodeType, NULL, 
                                        DVASPECT_CONTENT, -1, TYMED_HGLOBAL 
                                      };
    
        hr = lpDataObject->GetDataHere(&formatetcNodeType, &stgmediumNodeType);
        _JumpIfError(hr, Ret, "GetDataHere NodeType");
            
        pNodeGUID = (GUID*) GlobalLock(stgmediumNodeType.hGlobal);
        if (pNodeGUID == NULL)
        {
            hr = E_UNEXPECTED;
            _JumpError(hr, Ret, "GlobalLock failed");
        }

        //
        // if this is the parents node then add our node undeneath it
        //

        // CA Manager parent
        if (memcmp(pNodeGUID, (void *)&cCAManagerParentNodeID, sizeof(GUID)) == 0)
        {
            fInsertFolder = true;
            CString     szFolderName;

            // Only add node under ENT ROOT, ENT SUB 
            UINT    cfCAType = RegisterClipboardFormat(W2T((LPWSTR)SNAPIN_CA_INSTALL_TYPE));
            FORMATETC formatetcCAType = { (CLIPFORMAT)cfCAType, NULL, 
                DVASPECT_CONTENT, -1, TYMED_HGLOBAL 
                };
        
            hr = lpDataObject->GetDataHere(&formatetcCAType, &stgmediumCAType);
            _JumpIfError(hr, Ret, "GetDataHere CAType");
        
            PDWORD rgdw = (DWORD*)GlobalLock(stgmediumCAType.hGlobal);
            ENUM_CATYPES caType = (ENUM_CATYPES)rgdw[0];
        
            DBGPRINT((DBG_SS_CERTMMC, "CA Type: %d\n", caType));

            // return immediately if we're not an ENT {ROOT | SUB}
            if ((caType != ENUM_ENTERPRISE_SUBCA) &&
                (caType != ENUM_ENTERPRISE_ROOTCA))
            {
                hr = S_OK;
                goto Ret;
            }
        
            m_fAdvancedServer = (rgdw[1]!=0)?true:false;

            DBGPRINT((DBG_SS_CERTMMC, "Advanced Server: %s\n", 
                m_fAdvancedServer?"yes":"no"));

            VERIFY(szFolderName.LoadString(IDS_POLICYSETTINGS));
            pFolder = new CFolder();
            if(pFolder == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Ret;
            }

            pFolder->Create(
                    (LPWSTR)((LPCTSTR)szFolderName), 
                    IMGINDEX_FOLDER, 
                    IMGINDEX_FOLDER_OPEN,
                    SCOPE_LEVEL_ITEM, 
                    POLICYSETTINGS, 
                    FALSE); 

            m_scopeItemList.AddTail(pFolder);
            pFolder->m_pScopeItem->relativeID = param;

            // Set the folder as the cookie
            pFolder->m_pScopeItem->mask |= SDI_PARAM;
            pFolder->m_pScopeItem->lParam = reinterpret_cast<LPARAM>(pFolder);
            pFolder->SetCookie(reinterpret_cast<LONG_PTR>(pFolder));

            // get the name of the CA that we are administering
            LPWSTR  pCAName = NULL;
        
            // nab CA Name
            UINT    cfCAName = RegisterClipboardFormat(W2T((LPWSTR)CA_SANITIZED_NAME));
            FORMATETC formatetcCAName = { (CLIPFORMAT)cfCAName, NULL, 
                                            DVASPECT_CONTENT, -1, TYMED_HGLOBAL 
                                          };

            hr = lpDataObject->GetDataHere(&formatetcCAName, &stgmediumCAName);
            _JumpIfError(hr, Ret, "GetDataHere CAName");

            pCAName = (LPWSTR)GlobalLock(stgmediumCAName.hGlobal);
            if (pCAName == NULL)
            {
                hr = E_UNEXPECTED;
                _JumpError(hr, Ret, "GlobalLock");
            }

            pFolder->m_szCAName = pCAName;

            hr = mySanitizedNameToDSName(pCAName, &pszDSName);
            _JumpIfError(hr, Ret, "mySanitizedNameToDSName");

            //
            // get a handle to the CA based on the name
            //
            hr = CAFindByName(
                        pszDSName,
                        NULL,
                        CA_FIND_INCLUDE_UNTRUSTED,
                        &pFolder->m_hCAInfo);
            _JumpIfErrorStr(hr, Ret, "CAFindByName", pszDSName);

            // if we made it here then everything is initialized, so add the folder
        }
    }

    // undo fix to add folder under all circumstances -- we were
    // inserting a NULL ptr!
    if(fInsertFolder && (NULL != pFolder))
    {
        m_hrCreateFolder = hr;
        m_pScope->InsertItem(pFolder->m_pScopeItem);
    }

    // Note - On return, the ID member of 'm_pScopeItem' 
    // contains the handle to the newly inserted item!
    ASSERT(pFolder->m_pScopeItem->ID != NULL);

Ret:

    if (stgmediumNodeType.hGlobal)
    {
        GlobalUnlock(stgmediumNodeType.hGlobal);
        ReleaseStgMedium(&stgmediumNodeType);
    }
    if (stgmediumCAType.hGlobal)
    {
        GlobalUnlock(stgmediumCAType.hGlobal);
        ReleaseStgMedium(&stgmediumCAType);
    }
    if (stgmediumCAName.hGlobal)
    {
        GlobalUnlock(stgmediumCAName.hGlobal);
        ReleaseStgMedium(&stgmediumCAName);
    }

    if (pszDSName)
        LocalFree(pszDSName);

    return hr;
}

HRESULT CComponentDataImpl::OnSelect(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    return E_UNEXPECTED;
}

HRESULT CComponentDataImpl::OnProperties(LPARAM param)
{
    HRESULT hr = S_OK;

    CFolder* pItem = NULL;
    CFolder* pFolder = NULL;
    POSITION pos = 0;

    if (param == NULL)
    {
        goto error;
    }

    ASSERT(param != NULL);
    pFolder = new CFolder();
    if(pFolder == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    // Create a new folder object
    pFolder->Create( reinterpret_cast<LPOLESTR>(param), 0, 0, SCOPE_LEVEL_ITEM, STATIC, FALSE);

    // The static folder in the last item in the list
    pos = m_scopeItemList.GetTailPosition();
    ASSERT(pos);

    // Add it to the internal list
    if (pos)
    {
        pItem = m_scopeItemList.GetAt(pos);
        if(pItem == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }
        m_scopeItemList.AddTail(pFolder);

        if((pFolder->m_pScopeItem == NULL) || (pItem->m_pScopeItem == NULL))
        {
            hr = E_POINTER;
            goto error;
        }
        pFolder->m_pScopeItem->relativeID = pItem->m_pScopeItem->relativeID;

        // Set the folder as the cookie
        pFolder->m_pScopeItem->mask |= SDI_PARAM;
        pFolder->m_pScopeItem->lParam = reinterpret_cast<LPARAM>(pFolder);
        pFolder->SetCookie(reinterpret_cast<LONG_PTR>(pFolder));
        m_pScope->InsertItem(pFolder->m_pScopeItem);
        pFolder = NULL;
    }

    ::GlobalFree(reinterpret_cast<void*>(param));

error:

    if(pFolder)
    {
        delete pFolder;
    }
    return hr;
}

void CComponentDataImpl::DeleteList()
{
    POSITION pos = m_scopeItemList.GetHeadPosition();

    while (pos)
        delete m_scopeItemList.GetNext(pos);
    
    m_scopeItemList.RemoveAll();
}

CFolder* CComponentDataImpl::FindObject(MMC_COOKIE cookie)
{
    CFolder* pFolder = NULL;
    POSITION pos = m_scopeItemList.GetHeadPosition();

    while(pos)
    {
        pFolder = m_scopeItemList.GetNext(pos);

        if (*pFolder == cookie)
            return pFolder;
    }

    return NULL;
}

STDMETHODIMP CComponentDataImpl::GetDisplayInfo(SCOPEDATAITEM* pScopeDataItem)
{
    ASSERT(pScopeDataItem != NULL);
    if (pScopeDataItem == NULL)
        return E_POINTER;

    CFolder* pFolder = reinterpret_cast<CFolder*>(pScopeDataItem->lParam);

    
    if (pScopeDataItem->mask & SDI_STR)
    {
        //
        // if this is certtype folder, and it is for the second column, then add usages string
        //
        if (FALSE)//(pFolder->m_hCertType != NULL) && (pScopeDataItem-> == ))
        {

        }
        else
        {
            pScopeDataItem->displayname = pFolder->m_pszName;
        }
    }

    if (pScopeDataItem->mask & SDI_IMAGE)
        pScopeDataItem->nImage = pFolder->m_pScopeItem->nImage;

    if (pScopeDataItem->mask & SDI_OPENIMAGE)
        pScopeDataItem->nOpenImage = pFolder->m_pScopeItem->nOpenImage;


    return S_OK;
}

STDMETHODIMP CComponentDataImpl::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    // Make sure both data object are mine
    INTERNAL* pA;
    INTERNAL* pB;
    HRESULT hr = S_FALSE;

    pA = ExtractInternalFormat(lpDataObjectA);
    pB = ExtractInternalFormat(lpDataObjectA);

   if (pA != NULL && pB != NULL)
        hr = (*pA == *pB) ? S_OK : S_FALSE;

   if(pA != NULL)
   {
        ::GlobalFree(reinterpret_cast<HANDLE>(pA));
   }

   if(pB != NULL)
   {
        ::GlobalFree(reinterpret_cast<HANDLE>(pB));
   }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IExtendPropertySheet Implementation

STDMETHODIMP CComponentDataImpl::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, 
                    LONG_PTR handle, 
                    LPDATAOBJECT lpIDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Look at the data object and determine if this an extension or a primary
    ASSERT(lpIDataObject != NULL);


#if DBG
    CLSID* pCoClassID = ExtractClassID(lpIDataObject);
    if(pCoClassID == NULL)
    {
        ASSERT(FALSE);
        return E_UNEXPECTED;
    }
    // Which page is needed? (determined by which node is active)
    ASSERT(IsEqualCLSID(*pCoClassID, GetCoClassID()));

    FREE_DATA(pCoClassID);
#endif

    PropertyPage* pBasePage;

    INTERNAL* pInternal = ExtractInternalFormat(lpIDataObject);
    if (pInternal == NULL)
    {
        return S_OK;
    }
    ASSERT(pInternal->m_type == CCT_SCOPE);
    ASSERT(pInternal->m_cookie);
                           
    CFolder* pFolder = reinterpret_cast<CFolder*>(pInternal->m_cookie);
    ASSERT(pFolder != NULL);
    
    if (pFolder == NULL)
        return E_INVALIDARG;

    switch (pFolder->m_type) 
    {
    case POLICYSETTINGS:
    {
        //1 
    /*
        CPolicySettingsGeneralPage* pControlPage = new CPolicySettingsGeneralPage(pFolder->m_szCAName, pFolder->m_hCAInfo);
        if(pControlPage == NULL)
        {
            return E_OUTOFMEMORY;
        }

        {
            pControlPage->m_hConsoleHandle = handle;   // only do this on primary
            pBasePage = pControlPage;
            HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pBasePage->m_psp);
            if (hPage == NULL)
            {
                delete(pControlPage);
                return E_UNEXPECTED;
            }
            lpProvider->AddPage(hPage);
        }

        //2
        {
            CSvrSettingsPolicyPage* pPage = new CSvrSettingsPolicyPage(pControlPage);
            pBasePage = pPage;
            HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pBasePage->m_psp);
            if (hPage == NULL)
                return E_UNEXPECTED;
            lpProvider->AddPage(hPage);
        }
    */
        
        return S_OK;
    }

        break;
    
    default:
        break;
    }

    return S_OK;
}

STDMETHODIMP CComponentDataImpl::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Get the node type and see if it's one of mine

    BOOL bResult = FALSE;
    INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);
    if (pInternal == NULL)
    {
        return S_OK;
    }  
    ASSERT(pInternal);
    ASSERT(pInternal->m_cookie);

    CFolder* pFolder = reinterpret_cast<CFolder*>(pInternal->m_cookie);
    switch(pFolder->m_type)
    {
    case POLICYSETTINGS:
    case SCE_EXTENSION:
        bResult = TRUE;
        break;
    default:
        bResult = FALSE;
        break;
    }
            
    FREE_DATA(pInternal);
    return (bResult) ? S_OK : S_FALSE;
}


///////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu implementation
//
STDMETHODIMP CComponentDataImpl::AddMenuItems(LPDATAOBJECT pDataObject, 
                                    LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                    long *pInsertionAllowed)
{
    HRESULT         hr = S_OK;
    CONTEXTMENUITEM	menuItem;
    CString			szMenu;
    CString			szHint; 

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Note - snap-ins need to look at the data object and determine
    // in what context, menu items need to be added. They must also
    // observe the insertion allowed flags to see what items can be 
    // added.

    if (IsMMCMultiSelectDataObject(pDataObject) == TRUE)
        return S_FALSE;

    INTERNAL* pInternal = ExtractInternalFormat(pDataObject);
    if (pInternal == NULL)
    {
        return S_OK;
    }
    CFolder* pFolder = reinterpret_cast<CFolder*>(pInternal->m_cookie);
    
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW)
    {
        ::ZeroMemory (&menuItem, sizeof (menuItem));
	    menuItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
	    menuItem.fFlags = 0;
	    menuItem.fSpecialFlags = 0;

        switch(pFolder->m_type)
        {
        case POLICYSETTINGS:
            VERIFY (szMenu.LoadString (IDS_CERTIFICATE_TYPE));
	        menuItem.strName = (LPTSTR)(LPCTSTR) szMenu;
            VERIFY (szHint.LoadString (IDS_CERTIFICATE_TYPE_HINT));
	        menuItem.strStatusBarText = (LPTSTR)(LPCTSTR) szHint;
	        menuItem.lCommandID = IDM_NEW_CERTTYPE;
	        hr = pContextMenuCallback->AddItem (&menuItem);
	        ASSERT (SUCCEEDED (hr));
            break;


        default:
            break;
        }
    }

    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
    {
        ::ZeroMemory (&menuItem, sizeof (menuItem));
	    menuItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
	    menuItem.fFlags = 0;
	    menuItem.fSpecialFlags = 0;

        switch(pFolder->m_type)
        {
        case POLICYSETTINGS:
            VERIFY (szMenu.LoadString (IDS_MANAGETASK));
	        menuItem.strName = (LPTSTR)(LPCTSTR) szMenu;
            VERIFY (szHint.LoadString (IDS_MANAGETASK_HINT));
	        menuItem.strStatusBarText = (LPTSTR)(LPCTSTR) szHint;
	        menuItem.lCommandID = IDM_MANAGE;
	        hr = pContextMenuCallback->AddItem (&menuItem);
	        ASSERT (SUCCEEDED (hr));
            break;
        }
    }

    return hr;
}


STDMETHODIMP CComponentDataImpl::Command(long nCommandID, LPDATAOBJECT pDataObject)
{
    // Note - snap-ins need to look at the data object and determine
    // in what context the command is being called.
    DWORD       dwErr;
    HCERTTYPE   hNewCertType;
    HWND        hwndConsole;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    INTERNAL* pi = ExtractInternalFormat(pDataObject);

    if(pi == NULL)
    {
        return E_POINTER;
    }
    ASSERT(pi);
    ASSERT(pi->m_type == CCT_SCOPE);
    CFolder* pFolder = reinterpret_cast<CFolder*>(pi->m_cookie);

        // Handle each of the commands.
    switch (nCommandID)
    {
    case IDM_NEW_CERTTYPE:
    {
        if (pFolder)
        {

            switch(pFolder->m_type)
            {
            case POLICYSETTINGS:
                {
                    // NOMFC
                    CCertTemplateSelectDialog TemplateSelectDialog;
                    TemplateSelectDialog.SetCA(pFolder->m_hCAInfo, m_fAdvancedServer);

                    // if fails, NULL will work
                    HWND hWnd = NULL;
                    m_pConsole->GetMainWindow(&hWnd);

                    DialogBoxParam(
                        g_hInstance,
                        MAKEINTRESOURCE(IDD_SELECT_CERTIFICATE_TEMPLATE),
                        hWnd,
                        SelectCertTemplateDialogProc,
                        (LPARAM)&TemplateSelectDialog);

                    break;
                }
            default:
                break;
            }

        }
            
        m_pConsole->UpdateAllViews(pDataObject, 0, 0);
        break;
    }

    case IDM_MANAGE:
    if (pFolder && pFolder->m_type == POLICYSETTINGS)
    {
        StartCertificateTemplatesSnapin();
    }
    break;
   
    default:
        ASSERT(FALSE); // Unknown command!
        break;
    }

    return S_OK;
}

HRESULT CComponentDataImpl::StartCertificateTemplatesSnapin()
{
    HRESULT hr = S_OK;
    SHELLEXECUTEINFO shi;
    HWND hwnd = NULL;

    m_pConsole->GetMainWindow(&hwnd);

    ZeroMemory(&shi, sizeof(shi));
    shi.cbSize = sizeof(shi);
    shi.hwnd = hwnd;
    shi.lpVerb = SZ_VERB_OPEN;
    shi.lpFile = SZ_CERTTMPL_MSC;
    shi.fMask = SEE_MASK_FLAG_NO_UI;

    if(!ShellExecuteEx(&shi))
    {
        hr = myHLastError();
        _JumpError(hr, error, "ShellExecuteEx");
    }

error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\capesnpn\ctshlext.h ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    ctextshl.h

Abstract:
    This is the header for the Cert Type shell extension object.

Author:

    petesk 27-aug-98

Environment:
	
	 NT only.
--*/


#ifndef __CTSHLEXT_H_
#define __CTSHLEXT_H_


#include <shlobj.h>

/////////////////////////////////////////////////////////////////////////////
// CDfsShell
class ATL_NO_VTABLE CCertTypeShlExt : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CCertTypeShlExt, &CLSID_CertTypeShellExt>,
	public IShellExtInit,
	public IShellPropSheetExt,
    public IContextMenu
{
public:
	CCertTypeShlExt()
	{
        m_Count = 0;
        m_ahCertTemplates = NULL;
        m_uiEditId = 0;
	}

	~CCertTypeShlExt()
	{	
	}

    //Simple ALL 1.0 based registry entry
    DECLARE_REGISTRY(   CCertTypeShlExt,
                        _T("CAPESNPN.CCTShellExt.1"),
                        _T("CAPESNPN.CCTShellExt"),
                        IDS_CCTSHELLEXT_DESC,
                        THREADFLAGS_APARTMENT)

BEGIN_COM_MAP(CCertTypeShlExt)
	COM_INTERFACE_ENTRY(IShellExtInit)
	COM_INTERFACE_ENTRY(IShellPropSheetExt)
	COM_INTERFACE_ENTRY(IContextMenu)
END_COM_MAP()

// IDfsShell
public:


// IShellExtInit Methods

	STDMETHOD (Initialize)
	(
		IN LPCITEMIDLIST	pidlFolder,		// Points to an ITEMIDLIST structure
		IN LPDATAOBJECT	lpdobj,			// Points to an IDataObject interface
		IN HKEY			hkeyProgID		// Registry key for the file object or folder type
	);	

    //IShellPropSheetExt methods
    STDMETHODIMP AddPages
	(
		IN LPFNADDPROPSHEETPAGE lpfnAddPage, 
		IN LPARAM lParam
	);
    
    STDMETHODIMP ReplacePage
	(
		IN UINT uPageID, 
		IN LPFNADDPROPSHEETPAGE lpfnReplaceWith, 
		IN LPARAM lParam
	);

    // IContextMenu methods
    STDMETHODIMP GetCommandString
    (    
        UINT_PTR idCmd,    
        UINT uFlags,    
        UINT *pwReserved,
        LPSTR pszName,    
        UINT cchMax   
    );

    STDMETHODIMP InvokeCommand
    (    
        LPCMINVOKECOMMANDINFO lpici   
    );	



    STDMETHODIMP QueryContextMenu
    (
        HMENU hmenu,
        UINT indexMenu,
        UINT idCmdFirst,
        UINT idCmdLast,
        UINT uFlags
    );


private:

    DWORD       m_Count;
    HCERTTYPE   *m_ahCertTemplates;

    UINT        m_uiEditId;


};

#endif //__CTSHLEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\capesnpn\csnapin.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

// CSnapin.h : Declaration of the CSnapin

#ifndef _CSNAPIN_H_
#define _CSNAPIN_H_

#include "resource.h"       // main symbols

#ifndef __mmc_h__
#include <mmc.h>
#endif

using namespace CertSrv;

enum
{
    // Identifiers for each of the commands/views to be inserted into the context menu.
    IDM_COMMAND1,
    IDM_COMMAND2,
    IDM_SAMPLE_OCX_VIEW,
    IDM_SAMPLE_WEB_VIEW
};


template <class TYPE>
TYPE* Extract(LPDATAOBJECT lpDataObject, CLIPFORMAT cf);
BOOL IsMMCMultiSelectDataObject(IDataObject* pDataObject);
CLSID* ExtractClassID(LPDATAOBJECT lpDataObject);
GUID* ExtractNodeType(LPDATAOBJECT lpDataObject);
wchar_t* ExtractWorkstation(LPDATAOBJECT lpDataObject);
INTERNAL* ExtractInternalFormat(LPDATAOBJECT lpDataObject);
HRESULT _QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, 
                         CComponentDataImpl* pImpl, LPDATAOBJECT* ppDataObject);
DWORD GetItemType(MMC_COOKIE cookie);


/////////////////////////////////////////////////////////////////////////////
// Snapin

//
// helper methods extracting data from data object
//
INTERNAL *   ExtractInternalFormat(LPDATAOBJECT lpDataObject);
wchar_t *    ExtractWorkstation(LPDATAOBJECT lpDataObject);
GUID *       ExtractNodeType(LPDATAOBJECT lpDataObject);
CLSID *      ExtractClassID(LPDATAOBJECT lpDataObject);





enum CUSTOM_VIEW_ID
{
    VIEW_DEFAULT_LV = 0,
    VIEW_ERROR_OCX = 1,
};

class CSnapin : 
    public IComponent,
    public IExtendContextMenu,   // Step 3
    public IExtendControlbar,
    public IExtendPropertySheet,
    public IResultDataCompare,
    public IPersistStream,
    public CComObjectRoot
{
public:
    CSnapin();
    ~CSnapin();

BEGIN_COM_MAP(CSnapin)
    COM_INTERFACE_ENTRY(IComponent)
    COM_INTERFACE_ENTRY(IExtendContextMenu)   // Step 3
    COM_INTERFACE_ENTRY(IExtendControlbar)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IResultDataCompare)
    COM_INTERFACE_ENTRY(IPersistStream)
END_COM_MAP()

    friend class CDataObject;
    static long lDataObjectRefCount;

// IComponent interface members
public:
    STDMETHOD(Initialize)(LPCONSOLE lpConsole);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy)(MMC_COOKIE cookie);
    STDMETHOD(GetResultViewType)(MMC_COOKIE cookie,  LPOLESTR* ppViewType, long* pViewOptions);
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                        LPDATAOBJECT* ppDataObject);

    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM*  pResultDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

// IResultDataCompare
    STDMETHOD(Compare)(LPARAM lUserParam, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int* pnResult);

// IExtendControlbar
    STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar);
    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);

// IExtendPropertySheet interface
public:
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider, 
                        LONG_PTR handle, 
                        LPDATAOBJECT lpIDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);

public:
// IPersistStream interface members
    STDMETHOD(GetClassID)(CLSID *pClassID);
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)(IStream *pStm);
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);

    // Only for debug purpose
    bool m_bInitializedC;
    bool m_bLoadedC;
    bool m_bDestroyedC;

// Helpers for CSnapin
public:
    void SetIComponentData(CComponentDataImpl* pData);
    void GetItemName(LPDATAOBJECT lpDataObject, LPWSTR pszName, DWORD *pcName);
    BOOL IsPrimaryImpl() 
    {
        CComponentDataImpl* pData = 
            dynamic_cast<CComponentDataImpl*>(m_pComponentData);
        ASSERT(pData != NULL);
        if (pData != NULL)
            return pData->IsPrimaryImpl();

        return FALSE;
    }

#if DBG==1
public:
    int dbg_cRef;
    ULONG InternalAddRef()
    {
        ++dbg_cRef;
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        --dbg_cRef;
        return CComObjectRoot::InternalRelease();
    }
#endif // DBG==1

// Notify event handlers
protected:
    HRESULT OnFolder(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnAddImages(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnShow(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnDelete(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param);
    HRESULT OnActivate(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnMinimize(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnPropertyChange(LPDATAOBJECT lpDataObject); // Step 3
    HRESULT OnUpdateView(LPDATAOBJECT lpDataObject);
    HRESULT OnResultItemClk(DATA_OBJECT_TYPES type, MMC_COOKIE cookie);
    HRESULT OnContextHelp(LPDATAOBJECT lpDataObject);
    void OnButtonClick(LPDATAOBJECT pdtobj, int idBtn);

    HRESULT QueryMultiSelectDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                                   LPDATAOBJECT* ppDataObject);

// IExtendContextMenu 
public:
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pCallbackUnknown,
                            long *pInsertionAllowed);
    STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

// End step 3

// Helper functions
protected:
    void Construct();
    void LoadResources();
    HRESULT InitializeHeaders(MMC_COOKIE cookie);

    HRESULT Enumerate(MMC_COOKIE cookie, HSCOPEITEM pParent);
    HRESULT EnumerateResultPane(MMC_COOKIE cookie);

// Result pane helpers
    void RemoveResultItems(MMC_COOKIE cookie);
    void AddUser(CFolder* pFolder);
    void AddExtUser(CFolder* pFolder);
    void AddVirtual();
    HRESULT AddCACertTypesToResults(CFolder* pParentFolder);

    RESULT_DATA* GetVirtualResultItem(int iIndex);

// UI Helpers
    void HandleStandardVerbs(bool bDeselectAll, LPARAM arg, LPDATAOBJECT lpDataObject);
    void HandleExtToolbars(bool bDeselectAll, LPARAM arg, LPARAM param);
	void HandleExtMenus(LPARAM arg, LPARAM param);
    void _OnRefresh(LPDATAOBJECT pDataObject);

// Interface pointers
protected:
    LPCONSOLE2           m_pConsole;         // Console's IFrame interface
    LPHEADERCTRL        m_pHeader;          // Result pane's header control interface
    LPCOMPONENTDATA     m_pComponentData;   
    LPRESULTDATA        m_pResult;          // My interface pointer to the result pane
    LPIMAGELIST         m_pImageResult;     // My interface pointer to the result pane image list

    LPCONTROLBAR        m_pControlbar;      // control bar to hold my tool bars
    LPCONSOLEVERB       m_pConsoleVerb;     // pointer the console verb

#ifdef INSERT_DEBUG_FOLDERS
    LPMENUBUTTON        m_pMenuButton1;     // Menu Button for view
#endif // INSERT_DEBUG_FOLDERS

    LPTOOLBAR           m_pSvrMgrToolbar1;    // Toolbar for view
    CBitmap*            m_pbmpSvrMgrToolbar1; // Imagelist for the toolbar

    CFolder*            m_pCurrentlySelectedScopeFolder;    // keep track of who has focus

private:
    BOOL                m_bIsDirty;
    CUSTOM_VIEW_ID      m_CustomViewID;
    BOOL                m_bVirtualView;
    DWORD               m_dwVirtualSortOptions; 
    
    void SetDirty(BOOL b = TRUE) { m_bIsDirty = b; }
    void ClearDirty() { m_bIsDirty = FALSE; }
    BOOL ThisIsDirty() { return m_bIsDirty; }
};

inline void CSnapin::SetIComponentData(CComponentDataImpl* pData)
{
    ASSERT(pData);
    ASSERT(m_pComponentData == NULL);
    LPUNKNOWN pUnk = pData->GetUnknown();
    HRESULT hr;
    
    hr = pUnk->QueryInterface(IID_IComponentData, reinterpret_cast<void**>(&m_pComponentData));

    ASSERT(hr == S_OK);
}

class CCertTypeAboutImpl : 
    public ISnapinAbout,
    public CComObjectRoot,
    public CComCoClass<CCertTypeAboutImpl, &CLSID_CertTypeAbout>
{
public:
    CCertTypeAboutImpl();
    ~CCertTypeAboutImpl();

public:
DECLARE_REGISTRY(CSnapin, _T("Snapin.PolicySettingsAbout.1"), _T("Snapin.PolicySettingsAbout"), IDS_SNAPIN_DESC, THREADFLAGS_BOTH)

BEGIN_COM_MAP(CCertTypeAboutImpl)
    COM_INTERFACE_ENTRY(ISnapinAbout)
END_COM_MAP()

public:
    STDMETHOD(GetSnapinDescription)(LPOLESTR* lpDescription);
    STDMETHOD(GetProvider)(LPOLESTR* lpName);
    STDMETHOD(GetSnapinVersion)(LPOLESTR* lpVersion);
    STDMETHOD(GetSnapinImage)(HICON* hAppIcon);
    STDMETHOD(GetStaticFolderImage)(HBITMAP* hSmallImage, 
                                    HBITMAP* hSmallImageOpen, 
                                    HBITMAP* hLargeImage, 
                                    COLORREF* cLargeMask);

// Internal functions
private:
    HRESULT AboutHelper(UINT nID, LPOLESTR* lpPtr);
};

class CCAPolicyAboutImpl : 
    public ISnapinAbout,
    public CComObjectRoot,
    public CComCoClass<CCAPolicyAboutImpl, &CLSID_CAPolicyAbout>
{
public:
    CCAPolicyAboutImpl();
    ~CCAPolicyAboutImpl();

public:
DECLARE_REGISTRY(CSnapin, _T("Snapin.PolicySettingsAbout.1"), _T("Snapin.PolicySettingsAbout"), IDS_SNAPIN_DESC, THREADFLAGS_BOTH)

BEGIN_COM_MAP(CCAPolicyAboutImpl)
    COM_INTERFACE_ENTRY(ISnapinAbout)
END_COM_MAP()

public:
    STDMETHOD(GetSnapinDescription)(LPOLESTR* lpDescription);
    STDMETHOD(GetProvider)(LPOLESTR* lpName);
    STDMETHOD(GetSnapinVersion)(LPOLESTR* lpVersion);
    STDMETHOD(GetSnapinImage)(HICON* hAppIcon);
    STDMETHOD(GetStaticFolderImage)(HBITMAP* hSmallImage, 
                                    HBITMAP* hSmallImageOpen, 
                                    HBITMAP* hLargeImage, 
                                    COLORREF* cLargeMask);

// Internal functions
private:
    HRESULT AboutHelper(UINT nID, LPOLESTR* lpPtr);
};


#define FREE_DATA(pData) \
    ASSERT(pData != NULL); \
    do { if (pData != NULL) \
        GlobalFree(pData); } \
    while(0); 
    

#endif // #define _CSNAPIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\capesnpn\ctshlext.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

DfsShell.cpp

Abstract:
	This is the implementation file for Dfs Shell Extension object which implements
	IShellIExtInit and IShellPropSheetExt.

Author:

    Constancio Fernandes (ferns@qspl.stpp.soft.net) 12-Jan-1998

Environment:
	
	 NT only.
*/
    
#include "stdafx.h"
#include <dsclient.h>
#include "ctshlext.h"	
#include "wiz.h"
#include "genpage.h"

#define ByteOffset(base, offset) (((LPBYTE)base)+offset)

/*----------------------------------------------------------------------
					IShellExtInit Implementation.
------------------------------------------------------------------------*/

STDMETHODIMP CCertTypeShlExt::Initialize
(
	IN LPCITEMIDLIST	pidlFolder,		// Points to an ITEMIDLIST structure
	IN LPDATAOBJECT	    pDataObj,		// Points to an IDataObject interface
	IN HKEY			    hkeyProgID		// Registry key for the file object or folder type
)
{

  HRESULT hr = 0;
  FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
  STGMEDIUM medium = { TYMED_NULL };
  LPDSOBJECTNAMES pDsObjects;
  CString csClass, csPath;
  USES_CONVERSION;

  LPWSTR wszTypeDN = NULL, wszType = NULL;

  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  // if we have a pDataObj then try and get the first name from it

  if ( pDataObj ) 
  {
    // get path and class

    fmte.cfFormat = (CLIPFORMAT) RegisterClipboardFormat(CFSTR_DSOBJECTNAMES);
    if ( SUCCEEDED(pDataObj->GetData(&fmte, &medium)) ) 
    {
        pDsObjects = (LPDSOBJECTNAMES)medium.hGlobal;
        m_Count = pDsObjects->cItems;

        if(m_Count > 0)
        {

            m_ahCertTemplates = (HCERTTYPE *)LocalAlloc(LMEM_FIXED, sizeof(HCERTTYPE)*m_Count);
            if(m_ahCertTemplates == NULL)
            {
              hr = E_OUTOFMEMORY;
              goto error;
            }
            ZeroMemory(m_ahCertTemplates, sizeof(HCERTTYPE)*m_Count);

            for (UINT index = 0; index < m_Count ; index++) 
            {
                LPWSTR wszEnd = NULL;
                wszTypeDN = (LPWSTR)ByteOffset(pDsObjects, pDsObjects->aObjects[index].offsetName);
                if(wszTypeDN == NULL)
                {
                    continue;
                }
                wszTypeDN = wcsstr(wszTypeDN, L"CN=");
                if(wszTypeDN == NULL)
                {
                    continue;
                }
                wszTypeDN += 3;


                wszType = (LPWSTR)LocalAlloc(LMEM_FIXED, sizeof(WCHAR)*(wcslen(wszTypeDN)+1));
                if(wszType == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto error;
                }
                wcscpy(wszType, wszTypeDN);
                wszEnd = wcschr(wszType, L',');
                if(wszEnd)
                {
                    *wszEnd = 0;
                }

                hr = CAFindCertTypeByName(wszType, NULL, CT_ENUM_MACHINE_TYPES | 
                                                         CT_ENUM_USER_TYPES | 
                                                         CT_FLAG_NO_CACHE_LOOKUP, 
                                                         &m_ahCertTemplates[index]);
                LocalFree(wszType);
                wszType = NULL;
            }

        }
        ReleaseStgMedium(&medium);
    }
  }
  hr = S_OK;                  // success
  
error:
  
  return hr;

}


STDMETHODIMP CCertTypeShlExt::AddPages
(
	IN LPFNADDPROPSHEETPAGE lpfnAddPage, 
	IN LPARAM lParam
)

{
    PropertyPage* pBasePage;
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if(m_ahCertTemplates[0] == NULL)
    {
        return E_UNEXPECTED;
    }

    CCertTemplateGeneralPage* pControlPage = new CCertTemplateGeneralPage(m_ahCertTemplates[0]);
    if(pControlPage)
    {
        pBasePage = pControlPage;
        HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pBasePage->m_psp);
        if (hPage == NULL)
        {
            delete (pControlPage);
            return E_UNEXPECTED;
        }
        lpfnAddPage(hPage, lParam);                          
    }
                                                                         
    return S_OK;                                                            
}


STDMETHODIMP CCertTypeShlExt::ReplacePage
(
	IN UINT uPageID, 
    IN LPFNADDPROPSHEETPAGE lpfnReplaceWith, 
    IN LPARAM lParam
)
{
    return E_FAIL;
}


// IContextMenu methods
STDMETHODIMP CCertTypeShlExt::GetCommandString
(    
    UINT_PTR idCmd,    
    UINT uFlags,    
    UINT *pwReserved,
    LPSTR pszName,    
    UINT cchMax   
)
{
    if((idCmd == m_uiEditId) && (m_uiEditId != 0))
    {
        if (uFlags == GCS_HELPTEXT)    
        {
            LoadString(AfxGetResourceHandle( ), IDS_EDIT_HINT, (LPTSTR)pszName, cchMax);
            return S_OK;    
        }    
    }
    return E_NOTIMPL;
}


STDMETHODIMP CCertTypeShlExt::InvokeCommand
(    
    LPCMINVOKECOMMANDINFO lpici   
)
{
    if (!HIWORD(lpici->lpVerb))    
    {        
        UINT idCmd = LOWORD(lpici->lpVerb);
        switch(idCmd)
        {
        case 0: // Edit 
            InvokeCertTypeWizard(m_ahCertTemplates[0],
                             lpici->hwnd);
            return S_OK;

        }
    }

    return E_NOTIMPL;
}



STDMETHODIMP CCertTypeShlExt::QueryContextMenu
(
    HMENU hmenu,
    UINT indexMenu,
    UINT idCmdFirst,
    UINT idCmdLast,
    UINT uFlags
)
{

    CString szEdit;
    MENUITEMINFO mii;
    UINT idLastUsedCmd = idCmdFirst;
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ZeroMemory(&mii, sizeof(mii));
    
    if(IsCerttypeEditingAllowed())
    {

        mii.cbSize = sizeof(mii);   
        mii.fMask = MIIM_TYPE | MIIM_ID;
        mii.fType = MFT_STRING;    
        mii.wID = idCmdFirst; 

        szEdit.LoadString(IDS_EDIT);

        mii.dwTypeData = (LPTSTR)(LPCTSTR)szEdit;
        mii.cch = szEdit.GetLength();


        // Add new menu items to the context menu.    //
        ::InsertMenuItem(hmenu, 
                     indexMenu++, 
                     TRUE,
                     &mii);

    }

    return ResultFromScode (MAKE_SCODE (SEVERITY_SUCCESS, 0,
                            USHORT (idLastUsedCmd  + 1)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\capesnpn\csnapin.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include "stdafx.h"
#include "wiz.h"
#include <userenv.h>
#include "genpage.h"


static MMCBUTTON SvrMgrToolbar1Buttons[] =
{
    { 0, IDC_STARTSERVER, TBSTATE_ENABLED, TBSTYLE_BUTTON, L"Start", L"Start this service" },
    { 1, IDC_STOPSERVER,  TBSTATE_ENABLED, TBSTYLE_BUTTON, L"Stop",  L"Stop this service" },
};

static int n_count = 0;

//
// Extracts the coclass guid format from the data object
//
template <class TYPE>
TYPE* Extract(LPDATAOBJECT lpDataObject, unsigned int cf)
{
    ASSERT(lpDataObject != NULL);

    TYPE* p = NULL;

    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC formatetc = { (CLIPFORMAT)cf, NULL,
                            DVASPECT_CONTENT, -1, TYMED_HGLOBAL
                          };

    // Allocate memory for the stream
    int len = (int)((cf == CDataObject::m_cfWorkstation) ?
        ((MAX_COMPUTERNAME_LENGTH+1) * sizeof(TYPE)) : sizeof(TYPE));

    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, len);

    // Get the workstation name from the data object
    do
    {
        if (stgmedium.hGlobal == NULL)
            break;

        if (FAILED(lpDataObject->GetDataHere(&formatetc, &stgmedium)))
        {
            GlobalFree(stgmedium.hGlobal);
            break;
        }

        p = reinterpret_cast<TYPE*>(stgmedium.hGlobal);

        if (p == NULL)
            break;


    } while (FALSE);

    return p;
}

BOOL IsMMCMultiSelectDataObject(LPDATAOBJECT pDataObject)
{
    if (pDataObject == NULL)
        return FALSE;

    FORMATETC fmt = {(CLIPFORMAT)CDataObject::m_cfIsMultiSel, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    return (pDataObject->QueryGetData(&fmt) == S_OK);
}

// Data object extraction helpers
CLSID* ExtractClassID(LPDATAOBJECT lpDataObject)
{
    return Extract<CLSID>(lpDataObject, CDataObject::m_cfCoClass);
}

GUID* ExtractNodeType(LPDATAOBJECT lpDataObject)
{
    return Extract<GUID>(lpDataObject, CDataObject::m_cfNodeType);
}

wchar_t* ExtractWorkstation(LPDATAOBJECT lpDataObject)
{
    return Extract<wchar_t>(lpDataObject, CDataObject::m_cfWorkstation);
}

INTERNAL* ExtractInternalFormat(LPDATAOBJECT lpDataObject)
{
    return Extract<INTERNAL>(lpDataObject, CDataObject::m_cfInternal);
}


HRESULT _QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                         CComponentDataImpl* pImpl, LPDATAOBJECT* ppDataObject)
{
    ASSERT(ppDataObject != NULL);
    ASSERT(pImpl != NULL);

    CComObject<CDataObject>* pObject;

    CComObject<CDataObject>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);

    if(pObject == NULL)
    {
        return E_FAIL;
    }

    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);

    // Store the coclass with the data object
    pObject->SetClsid(pImpl->GetCoClassID());

    return  pObject->QueryInterface(IID_IDataObject,
                    reinterpret_cast<void**>(ppDataObject));

}

DWORD GetItemType(MMC_COOKIE cookie)
{
    // folder = CFoder* is cookie
    // result = RESULT_DATA* is the cookie

    return (*reinterpret_cast<DWORD*>(cookie));
}


/////////////////////////////////////////////////////////////////////////////
// CSnapin's IComponent implementation

STDMETHODIMP CSnapin::GetResultViewType(MMC_COOKIE cookie,  LPOLESTR* ppViewType, long* pViewOptions)
{
	if (m_CustomViewID == VIEW_ERROR_OCX)
	{
		StringFromCLSID (CLSID_MessageView, ppViewType);
		return S_FALSE;
	}
	else
	{
		*pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;

		// if list view
		if (m_CustomViewID == VIEW_DEFAULT_LV)
		{
			return S_FALSE;
		}
	}

    return S_FALSE;
}

STDMETHODIMP CSnapin::Initialize(LPCONSOLE lpConsole)
{
    DBX_PRINT(_T(" ----------  CSnapin::Initialize<0x08x>\n"), this);
    ASSERT(lpConsole != NULL);
    m_bInitializedC = true;
    HRESULT hr; 

    AFX_MANAGE_STATE(AfxGetStaticModuleState());


    // Save the IConsole pointer
    if (lpConsole == NULL)
        return E_POINTER;

    hr = lpConsole->QueryInterface(IID_IConsole2,
                        reinterpret_cast<void**>(&m_pConsole));
    _JumpIfError(hr, Ret, "QI IID_IConsole2");

    // Load resource strings
    LoadResources();

    // QI for a IHeaderCtrl
    hr = m_pConsole->QueryInterface(IID_IHeaderCtrl,
                        reinterpret_cast<void**>(&m_pHeader));
    _JumpIfError(hr, Ret, "QI IID_IHeaderCtrl");

    // Give the console the header control interface pointer
    if (SUCCEEDED(hr))
        m_pConsole->SetHeader(m_pHeader);

    hr = m_pConsole->QueryInterface(IID_IResultData,
                        reinterpret_cast<void**>(&m_pResult));
    _JumpIfError(hr, Ret, "QI IID_IResultData");

    hr = m_pConsole->QueryResultImageList(&m_pImageResult);
    _JumpIfError(hr, Ret, "ImageResult");

    hr = m_pConsole->QueryConsoleVerb(&m_pConsoleVerb);
    _JumpIfError(hr, Ret, "m_pConsoleVerb");

Ret:
    
    return hr;
}

STDMETHODIMP CSnapin::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (IS_SPECIAL_DATAOBJECT(lpDataObject))
    {
        if (event == MMCN_BTN_CLICK)
        {
            if (m_CustomViewID != VIEW_DEFAULT_LV)
            {
                switch (param)
                {
                case MMC_VERB_REFRESH:
                    ::AfxMessageBox(_T("MMCN_BTN_CLICK::MMC_VERB_REFRESH"));
                    _OnRefresh(lpDataObject);
                    break;

                case MMC_VERB_PROPERTIES:
                    ::AfxMessageBox(_T("MMCN_BTN_CLICK::MMC_VERB_PROPERTIES"));
                    break;

                default:
                    ::AfxMessageBox(_T("MMCN_BTN_CLICK::param unknown"));
                    break;
                }
            }
        }
        else
        {
            switch (event)
            {
            case MMCN_REFRESH:
                ::AfxMessageBox(_T("MMCN_BTN_CLICK::MMCN_REFRESH"));
                _OnRefresh(lpDataObject);
                break;
            }
        }

        return S_OK;
    }

    HRESULT hr = S_OK;
    MMC_COOKIE cookie = NULL;

    switch(event)
    {
    case MMCN_COLUMNS_CHANGED:
        hr = S_OK;
        break;
    case MMCN_PROPERTY_CHANGE:
        hr = OnPropertyChange(lpDataObject);
        break;
    case MMCN_VIEW_CHANGE:
        hr = OnUpdateView(lpDataObject);
        break;
    case MMCN_DESELECT_ALL:
        DBX_PRINT(_T("CSnapin::Notify -> MMCN_DESELECT_ALL \n"));
        break;
    case MMCN_COLUMN_CLICK:
        DBX_PRINT(_T("CSnapin::Notify -> MMCN_COLUMN_CLICK \n"));
        break;
    case MMCN_SNAPINHELP:
        AfxMessageBox(_T("CSnapin::Notify ->MMCN_SNAPINHELP"));
        break;
    default:
        {
            INTERNAL* pInternal = NULL;

            if (IsMMCMultiSelectDataObject(lpDataObject) == FALSE)
            {
                pInternal = ExtractInternalFormat(lpDataObject);

                if (pInternal == NULL)
                {
                    //ASSERT(FALSE);
                    return S_OK;
                }
                cookie = pInternal->m_cookie;
            }

            switch(event)
            {
            case MMCN_ACTIVATE:
                break;

            case MMCN_CLICK:
                if (NULL == pInternal)
                {
                    hr = S_FALSE;
                    break;
                }

                hr = OnResultItemClk(pInternal->m_type, cookie);
                break;

            case MMCN_DBLCLICK:
                hr = S_FALSE; // do the default verb
                break;

            case MMCN_ADD_IMAGES:
                OnAddImages(cookie, arg, param);
                break;

            case MMCN_SHOW:
                hr = OnShow(cookie, arg, param);
                break;

            case MMCN_MINIMIZED:
                hr = OnMinimize(cookie, arg, param);
                break;

            case MMCN_DESELECT_ALL:
            case MMCN_SELECT:
                HandleStandardVerbs((event == MMCN_DESELECT_ALL),
                                    arg, lpDataObject);
                break;

            case MMCN_PASTE:
                AfxMessageBox(_T("CSnapin::MMCN_PASTE"));
                break;

            case MMCN_DELETE:
                hr = OnDelete(lpDataObject, arg, param);
                // fall through to refresh -- break;

            case MMCN_REFRESH:
                {
                    _OnRefresh(lpDataObject);
                }
                break;

            case MMCN_CONTEXTHELP:
                hr = OnContextHelp(lpDataObject);
                break;

            case MMCN_RENAME:
                OutputDebugString(_T("\n\n\t\tCSnapin::MMCN_RENAME\n\n"));
                break;

            // Note - Future expansion of notify types possible
            default:
                hr = E_UNEXPECTED;
                break;
            }

            if (pInternal != NULL)
                FREE_DATA(pInternal);

            break;
        }
    }
    return hr;
}

HRESULT CSnapin::OnUpdateView(LPDATAOBJECT pDataObject)
{
    _OnRefresh(pDataObject);
    return S_OK;
}

void CSnapin::_OnRefresh(LPDATAOBJECT pDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    INTERNAL* pInternal = ExtractInternalFormat(pDataObject);
    if (pInternal == NULL)
        return;

    if (pInternal->m_type == CCT_SCOPE)
    {
        CComponentDataImpl* pData = dynamic_cast<CComponentDataImpl*>(m_pComponentData);
        CFolder* pFolder = pData->FindObject(pInternal->m_cookie);

        // only do if this is the currently selected folder!!
        if (m_pCurrentlySelectedScopeFolder == pFolder)
        {
            // HIDE, remove all items, remove header, SHOW
            OnShow(pInternal->m_cookie, FALSE, 0);              // emulate HIDE
            m_pResult->DeleteAllRsltItems();                    // delete items from m_pResult
            while(S_OK == m_pHeader->DeleteColumn(0)) {};       // remove all cols from header
            OnShow(pInternal->m_cookie, TRUE, 0);               // emulate SHOW
        }
    }
    else
    {
        RESULT_DATA* pData = reinterpret_cast<RESULT_DATA*>(pInternal->m_cookie);
    }

    FREE_DATA(pInternal);
}


HRESULT CSnapin::OnContextHelp(LPDATAOBJECT pdtobj)
{
    HRESULT	hr = S_OK;

    CString cstrHelpFile;
    IDisplayHelp*	pDisplayHelp = NULL;
    WCHAR szWindows[MAX_PATH];
    szWindows[0] = L'\0';

    hr = m_pConsole->QueryInterface (IID_IDisplayHelp, (void**)&pDisplayHelp);
    _JumpIfError(hr, Ret, "QI IDisplayHelp");

    if (0 == GetSystemWindowsDirectory(szWindows, MAX_PATH))
    {
        hr = myHLastError();
        _JumpError(hr, Ret, "GetSystemWindowsDirectory");
    }

    cstrHelpFile = szWindows;
    cstrHelpFile += HTMLHELP_COLLECTIONLINK_FILENAME;
    cstrHelpFile += L"::/sag_cs_topnode.htm";

    hr = pDisplayHelp->ShowTopic (T2OLE ((LPWSTR)(LPCWSTR)cstrHelpFile));
    _JumpIfError(hr, Ret, "ShowTopic");

Ret:
    if (pDisplayHelp)
        pDisplayHelp->Release();

    return hr;
}


STDMETHODIMP CSnapin::Destroy(MMC_COOKIE cookie)
{
    DBX_PRINT(_T(" ----------  CSnapin::Destroy<0x08x>\n"), this);
    ASSERT(m_bInitializedC);

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    m_bDestroyedC = true;

    // Release the interfaces that we QI'ed
    if (m_pConsole != NULL)
    {
        // Tell the console to release the header control interface
        m_pConsole->SetHeader(NULL);
        SAFE_RELEASE(m_pHeader);

        SAFE_RELEASE(m_pResult);
        SAFE_RELEASE(m_pImageResult);

        // Release the IConsole interface last
        SAFE_RELEASE(m_pConsole);
        SAFE_RELEASE(m_pComponentData); // QI'ed in IComponentDataImpl::CreateComponent

        SAFE_RELEASE(m_pConsoleVerb);
    }

    return S_OK;
}


HRESULT CSnapin::QueryMultiSelectDataObject(MMC_COOKIE cookie,
                                                        DATA_OBJECT_TYPES type,
                                                        LPDATAOBJECT* ppDataObject)
{

    CComponentDataImpl* pImpl = dynamic_cast<CComponentDataImpl*>(m_pComponentData);
    CComObject<CDataObject>* pObject = NULL;
	HRESULT		    hr = S_OK;
    LPRESULTDATA    pResultData = NULL;
    RESULTDATAITEM  rdi;

    ASSERT(ppDataObject != NULL);

    if (ppDataObject == NULL)
    {
        hr = E_POINTER;
        goto error;
    }


    hr = m_pConsole->QueryInterface(IID_IResultData,
        reinterpret_cast<void**>(&pResultData));
    if(hr != S_OK)
    {
        goto error;
    }
    ASSERT(pResultData != NULL);


    CComObject<CDataObject>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);

    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);

    // tell dataobj who we are
    // pObject->SetComponentData(pImpl);


    // Determine the items selected

    ZeroMemory(&rdi, sizeof(rdi));
    rdi.mask = RDI_STATE;
    rdi.nIndex = -1;
    rdi.nState = TVIS_SELECTED;

    while (pResultData->GetNextItem (&rdi) == S_OK)
    {
        CFolder* pFolder = reinterpret_cast <CFolder *> (rdi.lParam);

        if ( pFolder )
        {
            if(pFolder->GetType() == CA_CERT_TYPE)
            {
                pObject->AddCookie((MMC_COOKIE)pFolder);
            }
        }
        else
        {
			hr = E_INVALIDARG;
            goto error;
        }
    }
    // We're always adding things from policy settings these days.

    pObject->SetMultiSelDobj();
    pObject->SetClsid(pImpl->GetCoClassID());

    SMMCObjectTypes sObjGuids; // one is fine for now
    sObjGuids.count = 1;
    CopyMemory(&sObjGuids.guid[0], &cNodeTypePolicySettings, sizeof(GUID));

    // Store the coclass with the data object
    pObject->SetMultiSelData(&sObjGuids, sizeof(SMMCObjectTypes));

    hr = pObject->QueryInterface(IID_IDataObject,
                    reinterpret_cast<void**>(ppDataObject));
    pObject = NULL;

error:
    if(pObject)
    {
        pObject->Release();
    }
    if (pResultData)
    {
        pResultData->Release();
    }

    return hr;
}

STDMETHODIMP CSnapin::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                        LPDATAOBJECT* ppDataObject)
{
    if (cookie == MMC_MULTI_SELECT_COOKIE)
    {
        return QueryMultiSelectDataObject(cookie, type, ppDataObject);
    }

    ASSERT(type == CCT_RESULT);

    // Delegate it to the IComponentData
    ASSERT(m_pComponentData != NULL);
    CComponentDataImpl* pImpl = dynamic_cast<CComponentDataImpl*>(m_pComponentData);
    ASSERT(pImpl != NULL);
    return _QueryDataObject(cookie, type, pImpl, ppDataObject);
}

/////////////////////////////////////////////////////////////////////////////
// CSnapin's implementation specific members

DEBUG_DECLARE_INSTANCE_COUNTER(CSnapin);

CSnapin::CSnapin()
: m_bIsDirty(TRUE), m_bInitializedC(false), m_bDestroyedC(false)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CSnapin);
    Construct();
}

CSnapin::~CSnapin()
{
#if DBG==1
    ASSERT(dbg_cRef == 0);
#endif

    DEBUG_DECREMENT_INSTANCE_COUNTER(CSnapin);

    if (m_pSvrMgrToolbar1)
        SAFE_RELEASE(m_pSvrMgrToolbar1);

#ifdef INSERT_DEBUG_FOLDERS
    SAFE_RELEASE(m_pMenuButton1);
#endif // INSERT_DEBUG_FOLDERS

    if (m_pControlbar)
        SAFE_RELEASE(m_pControlbar);

    // Make sure the interfaces have been released
    ASSERT(m_pConsole == NULL);
    ASSERT(m_pHeader == NULL);
    ASSERT(m_pSvrMgrToolbar1 == NULL);

    delete m_pbmpSvrMgrToolbar1;

    ASSERT(!m_bInitializedC || m_bDestroyedC);

    Construct();
}

void CSnapin::Construct()
{
#if DBG==1
    dbg_cRef = 0;
#endif

    m_pConsole = NULL;
    m_pHeader = NULL;

    m_pResult = NULL;
    m_pImageResult = NULL;
    m_pComponentData = NULL;

    m_pControlbar = NULL;

#ifdef INSERT_DEBUG_FOLDERS
    m_pMenuButton1 = NULL;
#endif // INSERT_DEBUG_FOLDERS

    m_pSvrMgrToolbar1 = NULL;
    m_pbmpSvrMgrToolbar1 = NULL;

    m_pConsoleVerb = NULL;

    m_CustomViewID = VIEW_DEFAULT_LV;
}

CString g_ColumnHead_Name;
CString g_ColumnHead_Size;
CString g_ColumnHead_Type;
CString g_ColumnHead_IntendedPurpose;

void CSnapin::LoadResources()
{
    // Load strings from resources
    g_ColumnHead_Name.LoadString(IDS_COLUMN_NAME);
    g_ColumnHead_Size.LoadString(IDS_COLUMN_SIZE);
    g_ColumnHead_Type.LoadString(IDS_COLUMN_TYPE);
    g_ColumnHead_IntendedPurpose.LoadString(IDS_COLUMN_INTENDED_PURPOSE);
}

HRESULT CSnapin::InitializeHeaders(MMC_COOKIE cookie)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    ASSERT(m_pHeader);

    HRESULT hr = S_OK;
    BOOL fInsertedHeaders=FALSE;

    USES_CONVERSION;

    CFolder* pFolder = reinterpret_cast<CFolder*>(cookie);

    switch (pFolder->m_type)
    {
    case POLICYSETTINGS:
    case SCE_EXTENSION:

        m_pHeader->InsertColumn(0, W2COLE(g_ColumnHead_Name), LVCFMT_LEFT, 230);     // Name
        m_pHeader->InsertColumn(1, W2COLE(g_ColumnHead_IntendedPurpose), LVCFMT_LEFT, 230);     // Intended Purpose
        fInsertedHeaders = TRUE;
        break;

    default:
        // other scopes
        m_pHeader->InsertColumn(0, W2COLE(g_ColumnHead_Name), LVCFMT_LEFT, 180);     // Name
        m_pHeader->InsertColumn(1, W2COLE(g_ColumnHead_Size), LVCFMT_LEFT, 90);     // Size
        m_pHeader->InsertColumn(2, W2COLE(g_ColumnHead_Type), LVCFMT_LEFT, 160);     // Type
        fInsertedHeaders = TRUE;
    }

    return hr;
}

STDMETHODIMP CSnapin::GetDisplayInfo(LPRESULTDATAITEM pResult)
{
    static WCHAR* s_szSize = L"200";
    static WCHAR* s_szUnnamedItems = L"Unnamed subitem";
    ASSERT(pResult != NULL);

    CFolder* pFolder = reinterpret_cast<CFolder*>(pResult->lParam);
    ASSERT(pFolder);

    if (pResult)
    {
        // a folder or a result?
        if (pResult->bScopeItem == TRUE)
        {
            if (pResult->mask & RDI_STR)
            {
                switch (pFolder->m_type)
                {
                case POLICYSETTINGS:
                case SCE_EXTENSION:
                    // just a single column here
                    pResult->str = pFolder->m_pszName;

                    break;
                default:
                    break;
                }

                ASSERT(pResult->str != NULL);

                if (pResult->str == NULL)
                    pResult->str = (LPOLESTR)L"";
            }

            if (pResult->mask & RDI_IMAGE)
            {
                if (pResult->nState & TVIS_EXPANDED)
                    pResult->nImage = pFolder->m_pScopeItem->nOpenImage;
                else
                    pResult->nImage = pFolder->m_pScopeItem->nImage;
            }
        }
        else
        {
            RESULT_DATA* pData;

            // lParam is the item pointer
            pData= reinterpret_cast<RESULT_DATA*>(pResult->lParam);

            if (pResult->mask & RDI_STR)
            {
                ASSERT(pFolder->m_hCertType != NULL);

                if (pResult->nCol == 0)
                    pResult->str = pFolder->m_pszName;
                else if (pResult->nCol == 1)
                    pResult->str = (LPWSTR)((LPCWSTR) pFolder->m_szIntendedUsages);


                ASSERT(pResult->str != NULL);

                if (pResult->str == NULL)
                    pResult->str = (LPOLESTR)L"";
            }

            // MMC can request image and indent for virtual data
            if (pResult->mask & RDI_IMAGE)
            {
                // UNDONE: what to do here?
                ASSERT(0);
                pResult->nImage = IMGINDEX_CERTTYPE;
            }
        }
    }

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu Implementation
STDMETHODIMP CSnapin::AddMenuItems(LPDATAOBJECT pDataObject,
                                    LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                    LONG *pInsertionAllowed)
{

    return dynamic_cast<CComponentDataImpl*>(m_pComponentData)->
            AddMenuItems(pDataObject, pContextMenuCallback, pInsertionAllowed);
}


STDMETHODIMP CSnapin::Command(long nCommandID, LPDATAOBJECT pDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    INTERNAL*   pInternal = ExtractInternalFormat(pDataObject);
    HRESULT     hr;
    HWND        hwndConsole;

    if (pInternal == NULL)
        return E_FAIL;

    CFolder* pFolder = reinterpret_cast<CFolder*>(pInternal->m_cookie);

    if (pInternal->m_type == CCT_SCOPE)
    {
        // Handle view specific commands here
        switch (nCommandID)
        {
        case MMCC_STANDARD_VIEW_SELECT:
            m_CustomViewID = VIEW_DEFAULT_LV;
            break;

        default:
            // Pass non-view specific commands to ComponentData
            return dynamic_cast<CComponentDataImpl*>(m_pComponentData)->
                Command(nCommandID, pDataObject);
        }
    }
    else if (pInternal->m_type == CCT_RESULT)
    {
        // snag the selected items

        // only support single selection for now
        m_pResult->ModifyViewStyle(MMC_SINGLESEL, (MMC_RESULT_VIEW_STYLE)0);

        RESULTDATAITEM rdi;
        ZeroMemory(&rdi, sizeof(rdi));

        rdi.mask = RDI_STATE;
        rdi.nState = LVIS_SELECTED;
        rdi.nIndex = -1;
        m_pResult->GetNextItem(&rdi);

        int iSel = rdi.nIndex;

        RESULT_DATA* pData;

        ZeroMemory(&rdi, sizeof(rdi));
        rdi.mask = RDI_PARAM;
        rdi.nIndex = iSel;
        hr = m_pResult->GetItem(&rdi);
        ASSERT(SUCCEEDED(hr));
        ASSERT(rdi.lParam != 0);

        pData = reinterpret_cast<RESULT_DATA*>(rdi.lParam);


        // No current commands :(
    }
    else
    {
        ASSERT(0);
    }

    FREE_DATA(pInternal);

    return S_OK;
}

STDMETHODIMP CSnapin::GetClassID(CLSID *pClassID)
{
    ASSERT(pClassID != NULL);

    ASSERT(0);

    // Copy the CLSID for this snapin
    // reid fix - what is up with this?
    *pClassID = CLSID_CAPolicyExtensionSnapIn;

    return E_NOTIMPL;
}

STDMETHODIMP CSnapin::IsDirty()
{
    // Always save / Always dirty.
    return ThisIsDirty() ? S_OK : S_FALSE;
}

STDMETHODIMP CSnapin::Load(IStream *pStm)
{
    DBX_PRINT(_T(" ----------  CSnapin::Load<0x08x>\n"), this);
    ASSERT(m_bInitializedC);

    ASSERT(pStm);
    // Read the string
    DWORD dwVer;
    ULONG nBytesRead;
    HRESULT hr = pStm->Read(&dwVer, sizeof(DWORD), &nBytesRead);
    ASSERT(SUCCEEDED(hr) && nBytesRead == sizeof(DWORD));

    if (dwVer != 0x1)
    {
        return (STG_E_OLDFORMAT);
    }

    ClearDirty();

    return SUCCEEDED(hr) ? S_OK : E_FAIL;
}

STDMETHODIMP CSnapin::Save(IStream *pStm, BOOL fClearDirty)
{
    DBX_PRINT(_T(" ----------  CSnapin::Save<0x08x>\n"), this);
    ASSERT(m_bInitializedC);

    ASSERT(pStm);

    // Write the string
    ULONG nBytesWritten;
    DWORD dwVersion = 0x1;
    HRESULT hr = pStm->Write(&dwVersion, sizeof(DWORD), &nBytesWritten);

    // Verify that the write operation succeeded
    ASSERT(SUCCEEDED(hr) && nBytesWritten == sizeof(DWORD));
    if (FAILED(hr))
        return STG_E_CANTSAVE;

    if (fClearDirty)
        ClearDirty();
    return S_OK;
}

STDMETHODIMP CSnapin::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    ASSERT(pcbSize);

    DWORD cbSize;
    cbSize = sizeof(DWORD); // version


    // Set the size of the string to be saved
    ULISet32(*pcbSize, cbSize);

    return S_OK;
}



///////////////////////////////////////////////////////////////////////////////
// IExtendControlbar implementation
//


STDMETHODIMP CSnapin::SetControlbar(LPCONTROLBAR pControlbar)
{
/*    TRACE(_T("CSnapin::SetControlbar(%ld)\n"),pControlbar);
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (m_pControlbar)
        SAFE_RELEASE(m_pControlbar);

    if (pControlbar != NULL)
    {
        // Hold on to the controlbar interface.
        m_pControlbar = pControlbar;
        m_pControlbar->AddRef();

        HRESULT hr=S_FALSE;

#ifdef INSERT_DEBUG_FOLDERS
        if (!m_pMenuButton1)
        {
            hr = m_pControlbar->Create(MENUBUTTON, this,
                                reinterpret_cast<LPUNKNOWN*>(&m_pMenuButton1));
            ASSERT(SUCCEEDED(hr));
        }

        if (m_pMenuButton1)
        {
            // Unlike toolbar buttons, menu buttons need to be added every time.
            hr = m_pMenuButton1->AddButton(FOLDEREX_MENU, L"FolderEx", L"Extended Folder Menu");
            ASSERT(SUCCEEDED(hr));
            hr = m_pMenuButton1->AddButton(FILEEX_MENU, L"FileEx", L"Extended File Menu");
            ASSERT(SUCCEEDED(hr));
        }
#endif // INSERT_DEBUG_FOLDERS


        // SvrMgrToolbar1
        if (!m_pSvrMgrToolbar1)
        {
            hr = m_pControlbar->Create(TOOLBAR, this, reinterpret_cast<LPUNKNOWN*>(&m_pSvrMgrToolbar1));
            ASSERT(SUCCEEDED(hr));

            // Add the bitmap
            m_pbmpSvrMgrToolbar1 = new ::CBitmap;
            m_pbmpSvrMgrToolbar1->LoadBitmap(IDB_TOOLBAR_SVRMGR1);
            hr = m_pSvrMgrToolbar1->AddBitmap(36, *m_pbmpSvrMgrToolbar1, 16, 16, RGB(192,192,192));
            ASSERT(SUCCEEDED(hr));

            // Add the buttons to the toolbar
            hr = m_pSvrMgrToolbar1->AddButtons(ARRAYLEN(SvrMgrToolbar1Buttons), SvrMgrToolbar1Buttons);
            ASSERT(SUCCEEDED(hr));
        }

    }
*/

    return S_OK;
}


void CSnapin::OnButtonClick(LPDATAOBJECT pdtobj, int idBtn)
{
    WCHAR name[128];
    DWORD cName = sizeof(name)/sizeof(WCHAR);
    GetItemName(pdtobj, name, &cName);

    switch(idBtn)
    {
    case IDC_STOPSERVER:
    case IDC_STARTSERVER:
        // bubble this to our other handler
        dynamic_cast<CComponentDataImpl*>(m_pComponentData)->
                Command(idBtn, pdtobj);
        break;
    default:
        {
#ifdef _DEBUG
        TCHAR buf[150];
        wsprintf(buf, L"Toolbar button<%d> was clicked.\nThe currently selected result item is <%s>", idBtn, name);
        OutputDebugString(buf);
#endif // _DEBUG
        }
        break;
    }
}


STDMETHODIMP CSnapin::ControlbarNotify(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
  /*  HRESULT hr=S_FALSE;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    switch (event)
    {
    case MMCN_BTN_CLICK:
        //TCHAR szMessage[MAX_PATH];
        //wsprintf(szMessage, _T("CommandID %ld"),param);
        //AfxMessageBox(szMessage);
        OnButtonClick(reinterpret_cast<LPDATAOBJECT>(arg), param);
        break;

    case MMCN_DESELECT_ALL:
    case MMCN_SELECT:
        HandleExtToolbars((event == MMCN_DESELECT_ALL), arg, param);
        break;

    case MMCN_MENU_BTNCLICK:
        HandleExtMenus(arg, param);
        break;

    default:
        break;
    }

*/
    return S_OK;
}

// This compares two data objects to see if they are the same object.
// return
//    S_OK if equal otherwise S_FALSE
//
// Note: check to make sure both objects belong to the snap-in.
//

STDMETHODIMP CSnapin::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    return S_FALSE;
}


// This compare is used to sort the item's in the listview
//
// Parameters:
//
// lUserParam - user param passed in when IResultData::Sort() was called
// cookieA - first item to compare
// cookieB - second item to compare
// pnResult [in, out]- contains the col on entry,
//          -1, 0, 1 based on comparison for return value.
//
// Note: Assum sort is ascending when comparing.


STDMETHODIMP CSnapin::Compare(LPARAM lUserParam, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int* pnResult)
{
    if (pnResult == NULL)
    {
        ASSERT(FALSE);
        return E_POINTER;
    }

    // check col range
    int nCol = *pnResult;
    ASSERT(nCol >=0);

    *pnResult = 0;

    USES_CONVERSION;

    LPWSTR szStringA;
    LPWSTR szStringB;

    CFolder* pDataA = reinterpret_cast<CFolder*>(cookieA);
    CFolder* pDataB = reinterpret_cast<CFolder*>(cookieB);


    ASSERT(pDataA != NULL && pDataB != NULL);

    if (nCol == 0)
    {
        szStringA = OLE2W(pDataA->m_pszName);
        szStringB = OLE2W(pDataB->m_pszName);
    }
    else if (nCol == 1)
    {
        szStringA = OLE2W((LPWSTR)((LPCWSTR) pDataA->m_szIntendedUsages));
        szStringB = OLE2W((LPWSTR)((LPCWSTR) pDataB->m_szIntendedUsages));
    }
    else
        return S_OK;

    if ((szStringA == NULL) || (szStringB == NULL))
        return E_POINTER;

    *pnResult = wcscmp(szStringA, szStringB);


    return S_OK;
}



void CSnapin::HandleStandardVerbs(bool bDeselectAll, LPARAM arg,
                                  LPDATAOBJECT lpDataObject)
{

    if(m_pConsoleVerb == NULL)
    {
        return;
    }

    if (m_CustomViewID != VIEW_DEFAULT_LV)
    {
        m_pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, FALSE);
        m_pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);

        m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, FALSE);
        m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);

        return;
    }

    if (!bDeselectAll && lpDataObject == NULL)
        return;

    // You should crack the data object and enable/disable/hide standard
    // commands appropriately.  The standard commands are reset everytime you get
    // called. So you must reset them back.

    WORD bScope = LOWORD(arg);
    WORD bSelect = HIWORD(arg);

    DBX_PRINT(_T("      %4d - CSnapin::OnSelect<%d, %d>\n"), ++n_count, bScope, bSelect);


    if (!bDeselectAll && IsMMCMultiSelectDataObject(lpDataObject) == TRUE)
    {
        m_pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, FALSE);
        m_pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);
        return;
    }
    if (bDeselectAll || !bSelect)
    {
        // we have no items selected, so add the Refresh verb
        m_pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, FALSE);
        m_pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);

        // bail
        return;
    }

    INTERNAL*   pInternal = lpDataObject ? ExtractInternalFormat(lpDataObject) : NULL;
    DWORD       dwCertTypeFlags;
    HRESULT     hr;
    CFolder*    pFolder = NULL;

    if (pInternal != NULL)
    {
        pFolder = reinterpret_cast<CFolder*>(pInternal->m_cookie);
    }

    // Standard funcitonality NOT support by all items
    m_pConsoleVerb->SetVerbState(MMC_VERB_COPY, HIDDEN, TRUE);
    m_pConsoleVerb->SetVerbState(MMC_VERB_COPY, ENABLED, FALSE);

    m_pConsoleVerb->SetVerbState(MMC_VERB_PASTE, HIDDEN, TRUE);
    m_pConsoleVerb->SetVerbState(MMC_VERB_PASTE, ENABLED, FALSE);

    m_pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, FALSE);

    m_pConsoleVerb->SetVerbState(MMC_VERB_OPEN, HIDDEN, TRUE);
    m_pConsoleVerb->SetVerbState(MMC_VERB_OPEN, ENABLED, FALSE);

    m_pConsoleVerb->SetDefaultVerb(MMC_VERB_NONE);

    if (pInternal)
    {
        if (pInternal->m_type == CCT_SCOPE)
        {

            // Common verbs through all states
            m_pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, FALSE);
            m_pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);


            // Scope items can't be deleted
            m_pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, TRUE);
            m_pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, FALSE);

            // No properties on the scope item
            m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, TRUE);
            m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, FALSE);

            // default folder verb is open
            m_pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);
        }
        else
        {
            // check to see if this is a default cert type and we are in GPT,
            // if so then don't enable delete
            if (pFolder != NULL)
            {
                // Common verbs through all states
                m_pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, TRUE);
                m_pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, FALSE);

                // They do have properties
                m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, FALSE);
                m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);

                // They can be deleted
                m_pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, FALSE);
                m_pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);

                m_pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
            }

        }

    }


    FREE_DATA(pInternal);
}

void EnableToolbar(LPTOOLBAR pToolbar, MMCBUTTON rgSnapinButtons[], int nRgSize,
                   BOOL bEnable)
{
    for (int i=0; i < nRgSize; ++i)
    {
        if (rgSnapinButtons[i].idCommand != 0)
            pToolbar->SetButtonState(rgSnapinButtons[i].idCommand, ENABLED,
                                     bEnable);
    }
}


void EnableMenuBtns(LPMENUBUTTON pMenuBtn, MMCBUTTON rgSnapinButtons[], int nRgSize,
                   BOOL bEnable)
{
    for (int i=0; i < nRgSize; ++i)
    {
        if (rgSnapinButtons[i].idCommand != 0)
            pMenuBtn->SetButtonState(rgSnapinButtons[i].idCommand, ENABLED,
                                     bEnable);
    }
}

void CSnapin::HandleExtToolbars(bool bDeselectAll, LPARAM arg, LPARAM param)
{
    INTERNAL* pInternal = NULL;
    HRESULT hr;

    BOOL bScope = (BOOL) LOWORD(arg);
    BOOL bSelect = (BOOL) HIWORD(arg);

    if (param)
    {
        LPDATAOBJECT pDataObject = reinterpret_cast<LPDATAOBJECT>(param);
        pInternal = ExtractInternalFormat(pDataObject);
    }

#ifdef _DEBUG
    TCHAR buf[200];
    wsprintf(buf, _T("      %4d - CExtendControlbar::OnSelect<%d, %d> = %d\n"),
             ++n_count, bScope, bSelect, pInternal ? pInternal->m_cookie : 0);
    OutputDebugString(buf);
#endif //_DEBUG

    // Deselection Notification?
    if (bDeselectAll || bSelect == FALSE)
    {
        ASSERT(m_pSvrMgrToolbar1);
        EnableToolbar(m_pSvrMgrToolbar1, SvrMgrToolbar1Buttons,
                      ARRAYLEN(SvrMgrToolbar1Buttons), FALSE);

#ifdef INSERT_DEBUG_FOLDERS
        ASSERT(m_pMenuButton1 != NULL);
        m_pMenuButton1->SetButtonState(FOLDEREX_MENU, ENABLED, FALSE);
        m_pMenuButton1->SetButtonState(FILEEX_MENU, ENABLED, FALSE);
#endif // INSERT_DEBUG_FOLDERS
        return;
    }

    ASSERT(bSelect == TRUE);
    bool bFileExBtn = false;
    if (bScope == TRUE)
    {
        // at SCOPE level?
        LPDATAOBJECT pDataObject = reinterpret_cast<LPDATAOBJECT>(param);

        pInternal = ExtractInternalFormat(pDataObject);
        if (pInternal == NULL)
            return;

        CFolder* pFolder = reinterpret_cast<CFolder*>(pInternal->m_cookie);

        if (pInternal->m_cookie == 0)
        {
            if (IsPrimaryImpl() == TRUE)
            {
                // Attach the SvrMgrToolbar1 to the window
                hr = m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pSvrMgrToolbar1);
                ASSERT(SUCCEEDED(hr));
            }
        }
        else if (IsPrimaryImpl() == TRUE /*&&
            (   pFolder->GetType() == SERVER_INSTANCE ||
                pFolder->GetType() ==  SERVERFUNC_CRL_PUBLICATION ||
                pFolder->GetType() ==  SERVERFUNC_ISSUED_CERTIFICATES ||
                pFolder->GetType() ==  SERVERFUNC_PENDING_CERTIFICATES )*/)
        {
            // Attach the SvrMgrToolbar1 to the window
            hr = m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pSvrMgrToolbar1);
            ASSERT(SUCCEEDED(hr));
        }
        else
        {
            // Detach the SvrMgrToolbar1 to the window
            hr = m_pControlbar->Detach((LPUNKNOWN) m_pSvrMgrToolbar1);
            ASSERT(SUCCEEDED(hr));
        }

    }
    else // result item selected: result or subfolder
    {
        // at RESULTS level
        LPDATAOBJECT pDataObject = reinterpret_cast<LPDATAOBJECT>(param);

        if (pDataObject != NULL)
            pInternal = ExtractInternalFormat(pDataObject);

        if (pInternal == NULL)
            return;

        if (pInternal->m_type == CCT_RESULT)
        {
            bFileExBtn = true;

            // UNDONE: what to do here with SvrMgrToolbar1Buttons1?
            // For now, do nothing: allow them to remain in same state

        }
        else // sub folder slected
        {
            CFolder* pFolder = reinterpret_cast<CFolder*>(pInternal->m_cookie);

            ASSERT(m_pControlbar);

            if (pInternal->m_cookie == 0)
            {
                if (IsPrimaryImpl() == TRUE)
                {
                    // Attach the SvrMgrToolbar1 to the window
                    hr = m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pSvrMgrToolbar1);
                    ASSERT(SUCCEEDED(hr));
                }
            }
            else if (IsPrimaryImpl() == TRUE /*&&
                (   pFolder->GetType() == SERVER_INSTANCE ||
                    pFolder->GetType() ==  SERVERFUNC_CRL_PUBLICATION ||
                    pFolder->GetType() ==  SERVERFUNC_ISSUED_CERTIFICATES ||
                    pFolder->GetType() ==  SERVERFUNC_PENDING_CERTIFICATES )*/)
            {
                // Attach the SvrMgrToolbar1 to the window
                hr = m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pSvrMgrToolbar1);
                ASSERT(SUCCEEDED(hr));
            }
            else
            {
                // Detach the SvrMgrToolbar1 to the window
                hr = m_pControlbar->Detach((LPUNKNOWN) m_pSvrMgrToolbar1);
                ASSERT(SUCCEEDED(hr));
            }
        }
    }

#ifdef INSERT_DEBUG_FOLDERS
    if (m_pMenuButton1)
    {
        // Always make sure the menuButton is attached
        m_pControlbar->Attach(MENUBUTTON, m_pMenuButton1);

        if (bFileExBtn)
        {
            m_pMenuButton1->SetButtonState(FILEEX_MENU, HIDDEN, FALSE);
            m_pMenuButton1->SetButtonState(FOLDEREX_MENU, HIDDEN, TRUE);
            m_pMenuButton1->SetButtonState(FILEEX_MENU, ENABLED, TRUE);
        }
        else
        {
            m_pMenuButton1->SetButtonState(FOLDEREX_MENU, HIDDEN, FALSE);
            m_pMenuButton1->SetButtonState(FILEEX_MENU, HIDDEN, TRUE);
            m_pMenuButton1->SetButtonState(FOLDEREX_MENU, ENABLED, TRUE);
        }
    }
#endif // INSERT_DEBUG_FOLDERS
    FREE_DATA(pInternal);
}

// dropdown menu addition
void CSnapin::HandleExtMenus(LPARAM arg, LPARAM param)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    LPDATAOBJECT* ppDataObject = reinterpret_cast<LPDATAOBJECT*>(arg);
    LPMENUBUTTONDATA pMenuData = reinterpret_cast<LPMENUBUTTONDATA>(param);

    if (ppDataObject == NULL || pMenuData == NULL)
    {
        ASSERT(FALSE);
        return;
    }


    HMENU hMenu = NULL;
    HMENU hSubMenu = NULL;

    switch (pMenuData->idCommand)
    {
    case FOLDEREX_MENU:
        hMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(FOLDEREX_MENU));
        if (NULL == hMenu)
           break;
        hSubMenu = GetSubMenu(hMenu, 0);
        break;

    case FILEEX_MENU:
        hMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(FILEEX_MENU));
        if (NULL == hMenu)
           break;
        hSubMenu = GetSubMenu(hMenu, 0);
        break;

    default:
        ASSERT(FALSE);
    }

    if (hSubMenu == NULL)
    {
        // might've already loaded hMenu -- free if we have
        if (NULL != hMenu)
            DestroyMenu(hMenu);

        return;
    }

    //pMenu->TrackPopupMenu(TPM_RETURNCMD | TPM_NONOTIFY, pMenuData->x, pMenuData->y, AfxGetMainWnd());
    HWND hwndMain = NULL;
    m_pConsole->GetMainWindow(&hwndMain);
    TrackPopupMenu(hSubMenu, TPM_RETURNCMD | TPM_NONOTIFY, pMenuData->x, pMenuData->y, 0, hwndMain, NULL);
}


void CSnapin::GetItemName(LPDATAOBJECT pdtobj, LPWSTR pszName, DWORD *pcName)
{
    ASSERT(pszName != NULL);
    pszName[0] = 0;

    INTERNAL* pInternal = ExtractInternalFormat(pdtobj);
    ASSERT(pInternal != NULL);
    if (pInternal == NULL)
        return;

    ASSERT(pcName != NULL);
    if (pcName == NULL)
        return;



    OLECHAR *pszTemp;

    if (pInternal->m_type == CCT_RESULT)
    {
        RESULT_DATA* pData;
        pData = reinterpret_cast<RESULT_DATA*>(pInternal->m_cookie);

        ASSERT(pData != NULL);
        pszTemp = pData->szStringArray[RESULTDATA_ARRAYENTRY_NAME]; // szName
    }
    else
    {
        CFolder* pFolder = reinterpret_cast<CFolder*>(pInternal->m_cookie);
        if (pFolder == 0)
            pszTemp = L"Static folder";
        else
            pszTemp = OLE2W(pFolder->m_pszName);
    }

    USES_CONVERSION;


    lstrcpyn(pszName, OLE2W(pszTemp), *pcName);
    if(*pcName > wcslen(pszName))
    {
        *pcName = wcslen(pszName) + 1;
    }

    FREE_DATA(pInternal);
}



/////////////////////////////////////////////////////////////////////////////
// IExtendPropertySheet Implementation

STDMETHODIMP CSnapin::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                    LONG_PTR handle,
                    LPDATAOBJECT lpIDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Look at the data object and determine if this an extension or a primary
    ASSERT(lpIDataObject != NULL);

    PropertyPage* pBasePage;

    INTERNAL* pInternal = ExtractInternalFormat(lpIDataObject);

    if(pInternal == NULL)
    {
        return E_POINTER;
    }

    switch (pInternal->m_type)
    {
    case CCT_RESULT:
    {
        if (0 == pInternal->m_cookie)
        {
            // base scope

            // Create the primary property page
            CGeneralPage* pPage = new CGeneralPage();
            if(pPage == NULL)
            {
                return E_OUTOFMEMORY;
            }
            pPage->m_hConsoleHandle = handle;
            pBasePage = pPage;

            break;
        }
        else
        {
            // switch on folder type
            CFolder* pFolder = reinterpret_cast<CFolder*>(pInternal->m_cookie);
            ASSERT(pFolder != NULL);
            if (pFolder == NULL)
                return E_INVALIDARG;

            //1
            CCertTemplateGeneralPage* pControlPage = new CCertTemplateGeneralPage(pFolder->m_hCertType);
            if(pControlPage == NULL)
            {
                return E_OUTOFMEMORY;
            }
            {
                pControlPage->m_hConsoleHandle = handle;   // only do this on primary
                pBasePage = pControlPage;
                HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pBasePage->m_psp);
                if (hPage == NULL)
                {
                    delete (pControlPage);
                    return E_UNEXPECTED;
                }
                lpProvider->AddPage(hPage);
            }



            return S_OK;
        }
    }
        break;
    default:
            return S_OK;
    }


    // Object gets deleted when the page is destroyed
    ASSERT(lpProvider != NULL);


    HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pBasePage->m_psp);
    if (hPage == NULL)
        return E_UNEXPECTED;

    lpProvider->AddPage(hPage);

    return S_OK;
}

STDMETHODIMP CSnapin::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);

    if(pInternal == NULL)
    {
        return E_POINTER;
    }
    ASSERT(pInternal);
    ASSERT(pInternal->m_type == CCT_RESULT);

    CFolder* pFolder = reinterpret_cast<CFolder*>(pInternal->m_cookie);

    FREE_DATA(pInternal);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\capesnpn\dataobj.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#ifndef _DATAOBJ_H
#define _DATAOBJ_H

typedef CArray<MMC_COOKIE, MMC_COOKIE> CCookiePtrArray;


class CDataObject : public IDataObject, public CComObjectRoot

{
    friend class CSnapin;

// ATL Maps
DECLARE_NOT_AGGREGATABLE(CDataObject)
BEGIN_COM_MAP(CDataObject)
	COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()


// Construction/Destruction
    CDataObject();
    ~CDataObject() {}

// Clipboard formats that are required by the console
public:
    static unsigned int    m_cfNodeType;        // Required by the console
    static unsigned int    m_cfNodeTypeString;  // Required by the console
    static unsigned int    m_cfDisplayName;     // Required by the console
    static unsigned int    m_cfCoClass;         // Required by the console
    static unsigned int    m_cfIsMultiSel;        // Required by the console

    static unsigned int    m_cfInternal;        // Step 3
	static unsigned int	   m_cfWorkstation;     // Published information

// Standard IDataObject methods
public:
// Implemented
    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium);
    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);
    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc);

    ULONG InternalAddRef()
    {
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        return CComObjectRoot::InternalRelease();
    }

// Not Implemented
private:
    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc);

    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };

    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };

    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf,
                LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };
    
    STDMETHOD(DUnadvise)(DWORD dwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };

// Implementation
public:
    void SetType(DATA_OBJECT_TYPES type) // Step 3
    { ASSERT(m_internal.m_type == CCT_UNINITIALIZED); m_internal.m_type = type; }

public:
    void SetCookie(MMC_COOKIE cookie) { m_internal.m_cookie = cookie; } // Step 3
    void SetString(LPTSTR lpString) { m_internal.m_string = lpString; }
    void SetClsid(const CLSID& clsid) { m_internal.m_clsid = clsid; }

    void SetMultiSelData(SMMCObjectTypes* psGuidObjTypes, UINT cbMultiSelData)
    {
        // make sure [1] still good enough
        ASSERT(cbMultiSelData == sizeof(m_sGuidObjTypes));
        if (cbMultiSelData == sizeof(m_sGuidObjTypes))
        {
            m_cbMultiSelData = cbMultiSelData;
            CopyMemory(&m_sGuidObjTypes, psGuidObjTypes, cbMultiSelData);
        }
    }

    ULONG AddCookie(MMC_COOKIE Cookie);


    ULONG QueryCookieCount(VOID)
    {
        return m_rgCookies.GetSize();
    }

    STDMETHODIMP GetCookieAt(ULONG iCookie, MMC_COOKIE *pCookie);
    
    STDMETHODIMP RemoveCookieAt(ULONG iCookie);

    void SetMultiSelDobj()
    {
        m_bMultiSelDobj = TRUE;
    }

#ifdef _DEBUG
    UINT dbg_refCount;
 

    void AddRefMultiSelDobj()
    {
        ASSERT(m_bMultiSelDobj == TRUE);
        ++dbg_refCount;
    }

    void ReleaseMultiSelDobj()
    {
        ASSERT(m_bMultiSelDobj == TRUE);
        --dbg_refCount;
        //if (dbg_refCount == 0)
        //    ::MessageBox(NULL, _T("Final release on multi-sel-dobj"), _T("Sample snapin"), MB_OK);
    }
#endif

private:
    HRESULT CreateNodeTypeData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);
    HRESULT CreateDisplayName(LPSTGMEDIUM lpMedium);
    HRESULT CreateInternal(LPSTGMEDIUM lpMedium); // Step 3
    HRESULT CreateWorkstationName(LPSTGMEDIUM lpMedium);
    HRESULT CreateCoClassID(LPSTGMEDIUM lpMedium);
    HRESULT CreateMultiSelData(LPSTGMEDIUM lpMedium);

    HRESULT Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium);
    HRESULT CreateVariableLen(const void* pBuffer, int len, LPSTGMEDIUM lpMedium);


    INTERNAL        m_internal;    // Step 3

    SMMCObjectTypes m_sGuidObjTypes; // length[1] good enough for now
    UINT            m_cbMultiSelData;
    BOOL            m_bMultiSelDobj;

    CCookiePtrArray m_rgCookies;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\capesnpn\events.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////
// Event handlers for IFrame::Notify

HRESULT CSnapin::OnFolder(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    ASSERT(FALSE);

    return S_OK;
}

HRESULT CSnapin::OnAddImages(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    if (arg == 0)
        return E_INVALIDARG;
    
    // if cookie is from a different snapin
    // if (IsMyCookie(cookie) == FALSE)
    if (0)
    {
        // add the images for the scope tree only
        ::CBitmap bmp16x16;
        ::CBitmap bmp32x32;
        LPIMAGELIST lpImageList = reinterpret_cast<LPIMAGELIST>(arg);
    
        // Load the bitmaps from the dll
        bmp16x16.LoadBitmap(IDB_16x16);
        bmp32x32.LoadBitmap(IDB_32x32);
    
        // Set the images
        lpImageList->ImageListSetStrip(
                        reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp16x16)),
                        reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp32x32)),
                        0, RGB(255, 0, 255));
    
        lpImageList->Release();
    }
    else 
    {
        ASSERT(m_pImageResult != NULL);

        ::CBitmap bmp16x16;
        ::CBitmap bmp32x32;

        // Load the bitmaps from the dll
        bmp16x16.LoadBitmap(IDB_16x16);
        bmp32x32.LoadBitmap(IDB_32x32);

        // Set the images
        m_pImageResult->ImageListSetStrip(reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp16x16)),
                          reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp32x32)),
                           0, RGB(255, 0, 255));
    }
    return S_OK;
}

typedef IMessageView *LPMESSAGEVIEW;

HRESULT CSnapin::OnShow(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    CComponentDataImpl* pComp = dynamic_cast<CComponentDataImpl*>(m_pComponentData);
    CFolder* pFolder = pComp->FindObject(cookie);

    if ((cookie == NULL) || (pFolder == NULL))
    {
        return S_OK;
    }

    // Note - arg is TRUE when it is time to enumerate
    if (arg == TRUE)
    {
        m_pCurrentlySelectedScopeFolder = pFolder;

        // if list view on display
        if (m_CustomViewID == VIEW_DEFAULT_LV)
        {
            // Show the headers for this nodetype
            if (S_OK != InitializeHeaders(cookie))
            {
                // UNDONE: add informative "server down" result object
                goto done;
            }

            return Enumerate(cookie, param);
        }
		else if (m_CustomViewID == VIEW_ERROR_OCX)
		{
			HRESULT hr; 
                        CString strMessage;
                        strMessage.LoadString(IDS_ERROR_CANNOT_LOAD_TEMPLATES);

			LPUNKNOWN pUnk = NULL;
			LPMESSAGEVIEW pMessageView = NULL;

			hr = m_pConsole->QueryResultView(&pUnk);
			_JumpIfError(hr, done, "QueryResultView IUnk");

			hr = pUnk->QueryInterface(IID_IMessageView, reinterpret_cast<void**>(&pMessageView));
			_JumpIfError(hr, done, "IID_IMessageView");

			pMessageView->SetIcon(Icon_Error);

                        CAutoLPWSTR pwszErrorCode = BuildErrorMessage(pComp->GetCreateFolderHRESULT());

			pMessageView->SetTitleText(strMessage);
			pMessageView->SetBodyText(pwszErrorCode);
			
			pUnk->Release();
			pMessageView->Release();
		}

    }
    else
    {
        m_pCurrentlySelectedScopeFolder = NULL;

        // if list view is on display
        if (m_CustomViewID == VIEW_DEFAULT_LV)
        {
            RemoveResultItems(cookie);
        }

        // Free data associated with the result pane items, because
        // your node is no longer being displayed.
        // Note: The console will remove the items from the result pane

    }

done:

    return S_OK;
}

HRESULT CSnapin::OnDelete(LPDATAOBJECT pDataObject, LPARAM arg, LPARAM param)
{
    HRESULT     hr;
    WCHAR **    aszCertTypesCurrentlySupported;
    WCHAR **    aszNewCertTypesSupported;
    WCHAR **    aszNameOfDeleteType;
    HRESULTITEM	itemID;
    HWND        hwndConsole;
    CTemplateList TemplateList;

    CString cstrMsg, cstrTitle;
    cstrMsg.LoadString(IDS_ASK_CONFIRM_DELETETEMPLATES);
    cstrTitle.LoadString(IDS_TITLE_ASK_CONFIRM_DELETETEMPLATES);
    HWND hwndMain = NULL;

    m_pConsole->GetMainWindow(&hwndMain);

    if (IDYES != MessageBox(
                    hwndMain, 
                    (LPCWSTR)cstrMsg, 
                    (LPCWSTR)cstrTitle, 
                    MB_YESNO))
        return ERROR_CANCELLED;

    CWaitCursor hourglass;
    
    ASSERT(m_pResult != NULL); // make sure we QI'ed for the interface
    ASSERT(m_pComponentData != NULL);

    if(!IsMMCMultiSelectDataObject(pDataObject)) 
    {
        INTERNAL * pInternal = ExtractInternalFormat(pDataObject);
    
        if ((pInternal == NULL) ||
            (pInternal->m_cookie == NULL))
        {
            //ASSERT(FALSE);
            return S_OK;
        }

        CFolder* pFolder = reinterpret_cast<CFolder*>(pInternal->m_cookie);

        hr = RetrieveCATemplateList(
            pFolder->m_hCAInfo,
            TemplateList);
        if (FAILED(hr))
        {
            m_pConsole->GetMainWindow(&hwndConsole);
            MyErrorBox(hwndConsole, IDS_CERTTYPE_INFO_FAIL ,IDS_SNAPIN_NAME, hr);
            return hr;
        }

        ASSERT(pFolder != NULL);
        ASSERT(pFolder->m_hCertType != NULL);

        FOLDER_TYPES type = pFolder->GetType();

        if(type == CA_CERT_TYPE)
        {
            hr = RemoveFromCATemplateList(
                pFolder->m_hCAInfo,
                TemplateList,
                pFolder->m_hCertType);

            if (FAILED(hr))
            {
                m_pConsole->GetMainWindow(&hwndConsole);
                MyErrorBox(hwndConsole, IDS_CERTTYPE_INFO_FAIL ,IDS_SNAPIN_NAME, hr);
                return hr;
            }

        
            hr = UpdateCATemplateList(
                    pFolder->m_hCAInfo,
                    TemplateList);

            if (FAILED(hr))
            {
                m_pConsole->GetMainWindow(&hwndConsole);
                MyErrorBox(hwndConsole, IDS_DELETE_ERROR ,IDS_SNAPIN_NAME, hr);
                return hr;
            }
    
	        hr = m_pResult->FindItemByLParam ((LPARAM)pFolder, &itemID);
            hr = m_pResult->DeleteItem (itemID, 0);

            delete(pFolder);
        }
    }
    else
    {
		// Is multiple select, get all selected items and paste each one
        MMC_COOKIE currentCookie = NULL;
        HCAINFO hCAInfo = NULL;

        CDataObject* pDO = dynamic_cast <CDataObject*>(pDataObject);
        ASSERT (pDO);
        if ( pDO )
        {
            INT i;
            bool fTemplateListRetrieved = false;

            for(i=pDO->QueryCookieCount()-1; i >= 0; i--)
            {

                hr = pDO->GetCookieAt(i, &currentCookie);
                if(hr != S_OK)
                {
                    return hr;
                }

                CFolder* pFolder = reinterpret_cast<CFolder*>(currentCookie);

                if(!fTemplateListRetrieved)
                {
                    hr = RetrieveCATemplateList(
                        pFolder->m_hCAInfo,
                        TemplateList);
                    if (FAILED(hr))
                    {
                        m_pConsole->GetMainWindow(&hwndConsole);
                        MyErrorBox(hwndConsole, IDS_CERTTYPE_INFO_FAIL ,IDS_SNAPIN_NAME, hr);
                        return hr;
                    }
                    fTemplateListRetrieved = true;
                }

                ASSERT(pFolder != NULL);
                ASSERT(pFolder->m_hCertType != NULL);

                FOLDER_TYPES type = pFolder->GetType();

                if(type == CA_CERT_TYPE)
                {
                    if(hCAInfo == NULL)
                    {
                        // Grab the CA this type belongs to.
                        hCAInfo = pFolder->m_hCAInfo;
                    }

                    hr = RemoveFromCATemplateList(
                        hCAInfo,
                        TemplateList,
                        pFolder->m_hCertType);

                    if (FAILED(hr))
                    {
                        m_pConsole->GetMainWindow(&hwndConsole);
                        MyErrorBox(hwndConsole, IDS_CERTTYPE_INFO_FAIL ,IDS_SNAPIN_NAME, hr);
                        return hr;
                    }
                    hr = m_pResult->FindItemByLParam ((LPARAM)pFolder, &itemID);
                    if(hr != S_OK)
                    {
                        return hr;
                    }

                    // We must delete the actual CFolder backing this item if we do this
                    // or we leak.
                    hr = m_pResult->DeleteItem (itemID, 0);
                    if(hr != S_OK)
                    {
                        return hr;
                    }

                    hr = pDO->RemoveCookieAt(i);
                    if(hr != S_OK)
                    {
                        return hr;
                    }


                    // Note, since this is a type folder, the CAInfo will not be closed on delete
                    delete pFolder;
                }
            }

            if(hCAInfo)
            {
                hr = UpdateCATemplateList(
                        hCAInfo,
                        TemplateList);


                if (FAILED(hr))
                {
                    m_pConsole->GetMainWindow(&hwndConsole);
                    MyErrorBox(hwndConsole, IDS_DELETE_ERROR ,IDS_SNAPIN_NAME, hr);
                    return hr;
                }
            }
        }
    }
    
    return S_OK;
}

HRESULT CSnapin::OnActivate(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    return S_OK;
}

HRESULT CSnapin::OnResultItemClk(DATA_OBJECT_TYPES type, MMC_COOKIE cookie)
{
    RESULT_DATA* pResult;
    DWORD* pdw = reinterpret_cast<DWORD*>(cookie);
    if (*pdw == RESULT_ITEM)
    {
        pResult = reinterpret_cast<RESULT_DATA*>(cookie);
    }

    return S_OK;
}

HRESULT CSnapin::OnMinimize(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    return S_OK;
}

HRESULT CSnapin::OnPropertyChange(LPDATAOBJECT lpDataObject)
{
    return S_OK;
}

HRESULT CSnapin::Enumerate(MMC_COOKIE cookie, HSCOPEITEM pParent)
{
    return EnumerateResultPane(cookie);
}

HRESULT CSnapin::EnumerateResultPane(MMC_COOKIE cookie)
{
    ASSERT(m_pResult != NULL); // make sure we QI'ed for the interface
    ASSERT(m_pComponentData != NULL);

    // don't bother enumerating base
    if (cookie == NULL)
        return S_FALSE;

    // Our static folders must be displayed in the result pane
    // by use because the console doesn't do it.
    CFolder* pFolder = dynamic_cast<CComponentDataImpl*>(m_pComponentData)->FindObject(cookie);

    // The dynamic folder must be in our list
    ASSERT(pFolder != NULL);

    FOLDER_TYPES type = pFolder->GetType();

    switch(type)
    {
    case STATIC:
        break;

    case POLICYSETTINGS:
        return AddCACertTypesToResults(pFolder);
        break;
    default:
        break;
    }

    return S_FALSE;
}

void CSnapin::RemoveResultItems(MMC_COOKIE cookie)
{
    if (cookie == NULL)
        return;

    // Our static folders must be displayed in the result pane
    // by use because the console doesn't do it.
    CFolder* pFolder = dynamic_cast<CComponentDataImpl*>(m_pComponentData)->FindObject(cookie);

    // The dynamic folder must be in our list
    ASSERT(pFolder != NULL);

    FOLDER_TYPES type = pFolder->GetType();

    RESULTDATAITEM resultItem;
    ZeroMemory(&resultItem, sizeof(RESULTDATAITEM));
    
    // look for first rdi by index
    resultItem.mask = RDI_INDEX | RDI_PARAM;    // fill in index & param
    resultItem.nIndex = 0;

    switch (type)
    {
    case POLICYSETTINGS:
    case SCE_EXTENSION:
        while (S_OK == m_pResult->GetItem(&resultItem))
        {
            CFolder* pResult = reinterpret_cast<CFolder*>(resultItem.lParam);
            resultItem.lParam = NULL;

            delete pResult;
            
            // next item
            resultItem.nIndex++;
        }
        break;
    default:
        break;
    }

    return;
}

HRESULT CSnapin::AddCACertTypesToResults(CFolder* pFolder)
{
    HRESULT     hr = S_OK;
    CFolder     *pNewFolder;
    WCHAR **    aszCertTypeName;
    HWND        hwndConsole;
    BOOL        fMachine = FALSE;
    CTemplateList CATemplateList;
    CTemplateListEnum CATemplateListEnum(CATemplateList);
    CTemplateInfo *pTemplateInfo;
    HCERTTYPE hCertType;
    bool fNoCacheLookup = true;
    CWaitCursor WaitCursor;
    
    m_pConsole->GetMainWindow(&hwndConsole);    

    hr = RetrieveCATemplateList(pFolder->m_hCAInfo, CATemplateList);
    if(FAILED(hr)) 
    {
		m_CustomViewID = VIEW_ERROR_OCX; // change the view type
		m_pConsole->SelectScopeItem(m_pCurrentlySelectedScopeFolder->m_pScopeItem->ID); // select this node again

		// done, let's bail and let the error page do its job
		return S_OK;
    }

    CATemplateListEnum.Reset();

    for(pTemplateInfo=CATemplateListEnum.Next();
        pTemplateInfo;
        pTemplateInfo=CATemplateListEnum.Next())
    {
        hCertType = pTemplateInfo->GetCertType();
        
        if(!hCertType)
        {
            CSASSERT(pTemplateInfo->GetName());
            hr = CAFindCertTypeByName(
                    pTemplateInfo->GetName(), 
                    NULL, 
                    CT_ENUM_MACHINE_TYPES |
                    CT_ENUM_USER_TYPES |
                    (fNoCacheLookup?CT_FLAG_NO_CACHE_LOOKUP:0),
                    &hCertType);
            if(FAILED(hr))
            {
                MyErrorBox(hwndConsole, IDS_CERTTYPE_INFO_FAIL ,IDS_SNAPIN_NAME, hr);
                _JumpErrorStr(hr, error, "CAFindCertTypeByName", pTemplateInfo->GetName());
            }
            fNoCacheLookup = false;
        }

        hr = CAGetCertTypeProperty(
                    hCertType,
                    CERTTYPE_PROP_FRIENDLY_NAME,
                    &aszCertTypeName);

        if (FAILED(hr) || (aszCertTypeName == NULL))
        {
            MyErrorBox(hwndConsole, IDS_CERTTYPE_INFO_FAIL ,IDS_SNAPIN_NAME, hr);
            _JumpErrorStr(hr, error, "CAGetCertTypeProperty", pTemplateInfo->GetName());
        }

        pNewFolder = new CFolder();
        _JumpIfAllocFailed(pNewFolder, error);

        pNewFolder->Create(
                aszCertTypeName[0], 
                IMGINDEX_CERTTYPE, 
                IMGINDEX_CERTTYPE,
                RESULT_ITEM, 
                CA_CERT_TYPE, 
                FALSE);

        CAFreeCertTypeProperty(
                hCertType,
                aszCertTypeName);

        //
        // get the key usage string
        // 
        GetIntendedUsagesString(hCertType, &(pNewFolder->m_szIntendedUsages));
        if (pNewFolder->m_szIntendedUsages == L"")
        {
            pNewFolder->m_szIntendedUsages.LoadString(IDS_ALL);
        }

        pNewFolder->m_hCertType = hCertType;
        pNewFolder->m_hCAInfo = pFolder->m_hCAInfo;

        RESULTDATAITEM resultItem;
        ZeroMemory(&resultItem, sizeof(RESULTDATAITEM));
        resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
        resultItem.bScopeItem = FALSE;
        resultItem.itemID = (LONG_PTR) pNewFolder;
        resultItem.str = MMC_CALLBACK;
        resultItem.nImage = IMGINDEX_CERTTYPE;
        resultItem.lParam = reinterpret_cast<LPARAM>(pNewFolder);
        
        // add to result pane
        resultItem.nCol = 0;
        hr = m_pResult->InsertItem(&resultItem);
        _JumpIfError(hr, error, "InsertItem");
    }


error:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\capesnpn\dataobj.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.


#include "stdafx.h"


///////////////////////////////////////////////////////////////////////////////
// Sample code to show how to Create DataObjects
// Minimal error checking for clarity

///////////////////////////////////////////////////////////////////////////////
// Snap-in NodeType in both GUID format and string format
// Note - Typically there is a node type for each different object, sample
// only uses one node type.

unsigned int CDataObject::m_cfNodeType       = 0;
unsigned int CDataObject::m_cfNodeTypeString = 0;  
unsigned int CDataObject::m_cfDisplayName    = 0; 
unsigned int CDataObject::m_cfCoClass        = 0; 

unsigned int CDataObject::m_cfInternal       = 0; 
unsigned int CDataObject::m_cfIsMultiSel     = 0;



    
// The only additional clipboard format supported is to get the workstation name.
unsigned int CDataObject::m_cfWorkstation    = 0;

/////////////////////////////////////////////////////////////////////////////
// CDataObject implementations

CDataObject::CDataObject()
{
	USES_CONVERSION;

	m_cfNodeType       = RegisterClipboardFormat(W2T(CCF_NODETYPE));
	m_cfNodeTypeString = RegisterClipboardFormat(W2T(CCF_SZNODETYPE));  
	m_cfDisplayName    = RegisterClipboardFormat(W2T(CCF_DISPLAY_NAME)); 
	m_cfCoClass        = RegisterClipboardFormat(W2T(CCF_SNAPIN_CLASSID)); 
    m_cfIsMultiSel     = RegisterClipboardFormat(W2T(CCF_OBJECT_TYPES_IN_MULTI_SELECT));
	m_cfInternal       = RegisterClipboardFormat(W2T((LPWSTR)SNAPIN_INTERNAL)); 
	m_cfWorkstation    = RegisterClipboardFormat(W2T((LPWSTR)SNAPIN_WORKSTATION));

    m_cbMultiSelData = 0;
    m_bMultiSelDobj = FALSE;
}

STDMETHODIMP CDataObject::QueryGetData(LPFORMATETC lpFormatetc)
{
	HRESULT hr = S_FALSE;

    if ( lpFormatetc )
    {
        const CLIPFORMAT cf = lpFormatetc->cfFormat;

        if ( cf == m_cfIsMultiSel )
        {
            // hr = S_FALSE; // always return this; MMC returns S_OK if ptr to SI_MS_DO
            hr = (m_bMultiSelDobj ? S_OK : S_FALSE);
        }
        else if (	cf == m_cfNodeType ||
                    cf == m_cfCoClass ||
                    cf == m_cfNodeTypeString ||
                    cf == m_cfDisplayName ||
                    cf == m_cfInternal 
		        )
        {
	        hr = S_OK;
        }
    }

    return hr;
}
STDMETHODIMP CDataObject::GetData(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = DV_E_CLIPFORMAT;

    if (lpFormatetc->cfFormat == m_cfIsMultiSel)
    {
        ASSERT(m_internal.m_cookie == MMC_MULTI_SELECT_COOKIE);
        if (m_internal.m_cookie != MMC_MULTI_SELECT_COOKIE)
            return E_FAIL;
        
        return CreateMultiSelData(lpMedium);
    }

    return hr;
}

STDMETHODIMP CDataObject::GetDataHere(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if (cf == m_cfNodeType)
    {
        hr = CreateNodeTypeData(lpMedium);
    }
    else if (cf == m_cfCoClass)
    {
        hr = CreateCoClassID(lpMedium);
    }
    else if(cf == m_cfNodeTypeString) 
    {
        hr = CreateNodeTypeStringData(lpMedium);
    }
    else if (cf == m_cfDisplayName)
    {
        hr = CreateDisplayName(lpMedium);
    }
    else if (cf == m_cfInternal)
    {
        hr = CreateInternal(lpMedium);
    }
    else if (cf == m_cfWorkstation)
    {
        hr = CreateWorkstationName(lpMedium);
    }

    return hr;
}

STDMETHODIMP CDataObject::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CDataObject creation members

HRESULT CDataObject::Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_TYMED;

    // Do some simple validation
    if (pBuffer == NULL || lpMedium == NULL)
        return E_POINTER;

    // Make sure the type medium is HGLOBAL
    if (lpMedium->tymed == TYMED_HGLOBAL)
    {
        // Create the stream on the hGlobal passed in
        LPSTREAM lpStream;
        hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

        if (SUCCEEDED(hr))
        {
            // Write to the stream the number of bytes
            unsigned long written;

            if (NULL == lpMedium->hGlobal) 
            {
                // always return a valid hGlobal for the caller
                hr = GetHGlobalFromStream(lpStream, &lpMedium->hGlobal);
                if (hr != S_OK)
                    goto err;
            }

            hr = lpStream->Write(pBuffer, len, &written);

            // Because we told CreateStreamOnHGlobal with 'FALSE', 
            // only the stream is released here.
            // Note - the caller (i.e. snap-in, object) will free the HGLOBAL 
            // at the correct time.  This is according to the IDataObject specification.
            lpStream->Release();
        }
    }

err:
    return hr;
}

HRESULT CDataObject::CreateVariableLen(const void* pBuffer, int len, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_TYMED;
    BYTE* pb;

    // Do some simple validation
    if (pBuffer == NULL || lpMedium == NULL)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "Invalid args");
    }

    // Make sure the type medium is HGLOBAL
    lpMedium->tymed = TYMED_HGLOBAL; 

    lpMedium->hGlobal = ::GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE, (len));
    if (NULL == lpMedium->hGlobal)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "GlobalAlloc");
    }

    pb = reinterpret_cast<BYTE*>(::GlobalLock(lpMedium->hGlobal));
    CopyMemory(pb, pBuffer, len);
    ::GlobalUnlock(lpMedium->hGlobal);

    hr = S_OK;

error:
    return hr;
}


HRESULT CDataObject::CreateMultiSelData(LPSTGMEDIUM lpMedium)
{
    ASSERT(m_internal.m_cookie == MMC_MULTI_SELECT_COOKIE);

    ASSERT(m_cbMultiSelData != 0);

    return CreateVariableLen(&m_sGuidObjTypes, m_cbMultiSelData, lpMedium);
}

HRESULT CDataObject::CreateNodeTypeData(LPSTGMEDIUM lpMedium)
{
    // Create the node type object in GUID format
    const GUID* pcObjectType = NULL;

    if (m_internal.m_type == CCT_SCOPE)
    {
        // reid fix
        CFolder* pFolder = reinterpret_cast<CFolder*>(m_internal.m_cookie);

        switch (pFolder->GetType())
        {
        case POLICYSETTINGS:
        case CA_CERT_TYPE:
            pcObjectType = &cNodeTypePolicySettings;
            break;

        case SCE_EXTENSION:
        case GLOBAL_CERT_TYPE:
            pcObjectType = &cNodeTypeCertificateTemplate;
            break;
        }
    }
    else if (m_internal.m_type == CCT_RESULT)
    {
        pcObjectType = &cObjectTypeResultItem;
    }

    return Create(reinterpret_cast<const void*>(pcObjectType), sizeof(GUID), 
                  lpMedium);
}

HRESULT CDataObject::CreateNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
    // Create the node type object in GUID string format
    const WCHAR* cszObjectType = L"";

    if (m_internal.m_type == CCT_SCOPE)
    {
        CFolder* pFolder = reinterpret_cast<CFolder*>(m_internal.m_cookie);

        switch (pFolder->GetType())
        {
        case POLICYSETTINGS:
        case CA_CERT_TYPE:
            cszObjectType = cszNodeTypePolicySettings;
            break;

        case SCE_EXTENSION:
        case GLOBAL_CERT_TYPE:
            cszObjectType = cszNodeTypeCertificateTemplate;
            break;
        }
    }
    else if (m_internal.m_type == CCT_RESULT)
    {
        cszObjectType = cszObjectTypeResultItem;
    }

    ASSERT(cszObjectType[0] != 0);

    return Create(cszObjectType, ((wcslen(cszObjectType)+1) * sizeof(WCHAR)), lpMedium);
}

HRESULT CDataObject::CreateDisplayName(LPSTGMEDIUM lpMedium)
{
    // This is the display named used in the scope pane and snap-in manager

    // Load the name to display
    // Note - if this is not provided, the console will used the snap-in name
    CString szDispName;
    szDispName.LoadString(IDS_NODENAME_PREFIX);

    USES_CONVERSION;

	return Create(szDispName, ((szDispName.GetLength()+1) * sizeof(WCHAR)), lpMedium);
}

HRESULT CDataObject::CreateInternal(LPSTGMEDIUM lpMedium)
{
    return Create(&m_internal, sizeof(INTERNAL), lpMedium);
}

HRESULT CDataObject::CreateWorkstationName(LPSTGMEDIUM lpMedium)
{
    TCHAR pzName[MAX_COMPUTERNAME_LENGTH+1] = {0};
    DWORD len = MAX_COMPUTERNAME_LENGTH+1;

    if (GetComputerName(pzName, &len) == FALSE)
        return E_FAIL;

    // Add 1 for the NULL and calculate the bytes for the stream
	USES_CONVERSION;
    return Create(T2W(pzName), ((len+1)* sizeof(WCHAR)), lpMedium);
}

HRESULT CDataObject::CreateCoClassID(LPSTGMEDIUM lpMedium)
{
    // Create the CoClass information
    return Create(reinterpret_cast<const void*>(&m_internal.m_clsid), sizeof(CLSID), lpMedium);
}

ULONG CDataObject::AddCookie(MMC_COOKIE Cookie)
{
    m_rgCookies.Add(Cookie);
    return m_rgCookies.GetSize()-1;
}


STDMETHODIMP CDataObject::GetCookieAt(ULONG iCookie, MMC_COOKIE *pCookie)
{
    if((LONG)iCookie > m_rgCookies.GetSize())
    {
        return S_FALSE;
    }

    *pCookie = m_rgCookies[iCookie];

    return  S_OK;
}

STDMETHODIMP CDataObject::RemoveCookieAt(ULONG iCookie)
{
    if((LONG)iCookie > m_rgCookies.GetSize())
    {
        return S_FALSE;
    }
    m_rgCookies.RemoveAt(iCookie);

    return  S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\capesnpn\helparr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       helparr.h
//
//--------------------------------------------------------------------------



#define CAPESNPN_HELPFILENAME TEXT("capesnpn.hlp")

#define	IDH_AC_ADD_BUTTON	70007001
#define	IDH_AC_REMOVE_BUTTON	70007002
#define	IDH_AC_USER_ACCESS_LIST	70007000
#define	IDH_GTP_ADDCSPS_BUTTON	70007051
#define	IDH_GTP_CSP_LIST	70007050
#define	IDH_GTP_REMOVECSPS_BUTTON	70007052
#define	IDH_OC_DOWN_BUTTON	70007077
#define	IDH_OC_ORDERED_CSP_LIST	70007075
#define	IDH_OC_UP_BUTTON	70007076
#define	IDH_PP_DURATION_EDIT	70007100
#define	IDH_PP_DURATION_UNIT_COMBO	70007101
#define	IDH_SCT_CERTIFICATE_TYPE_LIST	70007125
#define	IDH_TP_CERTIFICATE_TEMPLATE_NAME	70007025
#define	IDH_TP_OTHER_INFO_LIST	70007027
#define	IDH_TP_PURPOSE_LIST	70007026
#define	IDH_UP_EDIT1	70007150

const DWORD g_aHelpIDs_IDD_CERTIFICATE_TEMPLATE_ACCESS_CONTROL_PAGE[]=
{
	IDC_ADD_BUTTON,IDH_AC_ADD_BUTTON,
	IDC_REMOVE_BUTTON,IDH_AC_REMOVE_BUTTON,
	IDC_USER_ACCESS_LIST,IDH_AC_USER_ACCESS_LIST,
	0,0
};

const DWORD g_aHelpIDs_IDD_CERTIFICATE_TEMPLATE_PROPERTIES_GENERAL_PAGE[]=
{
	IDC_CERTIFICATE_TEMPLATE_NAME,IDH_TP_CERTIFICATE_TEMPLATE_NAME,
	IDC_PURPOSE_LIST,IDH_TP_PURPOSE_LIST,
	IDC_OTHER_INFO_LIST,IDH_TP_OTHER_INFO_LIST,
	0, 0
};

const DWORD g_aHelpIDs_IDD_GLOBAL_TEMPLATE_PROPERTIES[]=
{
	IDC_REMOVECSPS_BUTTON,IDH_GTP_REMOVECSPS_BUTTON,
	IDC_ADDCSPS_BUTTON,IDH_GTP_ADDCSPS_BUTTON,
	IDC_CSP_LIST,IDH_GTP_CSP_LIST,
	0, 0
};

const DWORD g_aHelpIDs_IDD_ORDER_CSPS[]=
{
	IDC_ORDERED_CSP_LIST,IDH_OC_ORDERED_CSP_LIST,
	IDC_UP_BUTTON,IDH_OC_UP_BUTTON,
	IDC_DOWN_BUTTON,IDH_OC_DOWN_BUTTON,
	0, 0
};

const DWORD g_aHelpIDs_IDD_POLICYSETTINGS_PROPPAGE1[]=
{
	IDC_DURATION_EDIT,IDH_PP_DURATION_EDIT,
	IDC_DURATION_UNIT_COMBO,IDH_PP_DURATION_UNIT_COMBO,
	0, 0
};

const DWORD g_aHelpIDs_IDD_SELECT_CERTIFICATE_TEMPLATE[]=
{
	IDC_CERTIFICATE_TYPE_LIST,IDH_SCT_CERTIFICATE_TYPE_LIST,
	0, 0
};

const DWORD g_aHelpIDs_IDD_USER_PURPOSE[]=
{
	IDC_EDIT1,IDH_UP_EDIT1,
	0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\capesnpn\genpage.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       genpage.h
//
//--------------------------------------------------------------------------

#ifndef _GENPAGE_H
#define _GENPAGE_H
// genpage.h : header file
//

#include <tfcprop.h>

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
//	class CAutoDeletePropPage
//
//	This object is the backbone for property page
//	that will *destroy* itself when no longer needed.
//	The purpose of this object is to maximize code reuse
//	among the various pages in the snapin wizards.
//
//
class CAutoDeletePropPage : public PropertyPage
{
public:
    // Construction
    CAutoDeletePropPage(UINT uIDD);
    virtual ~CAutoDeletePropPage();

protected:
    // Dialog Data

    // Overrides
    virtual BOOL OnSetActive();
    virtual BOOL UpdateData(BOOL fSuckFromDlg = TRUE);
    void OnHelp(LPHELPINFO lpHelp);
    void OnContextHelp(HWND hwnd);

    // Implementation
protected:
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);

    // This mechanism deletes the CAutoDeletePropPage object
    // when the wizard is finished
    struct
    {
        INT cWizPages;	// Number of pages in wizard
        LPFNPSPCALLBACK pfnOriginalPropSheetPageProc;
    } m_autodeleteStuff;

    static UINT CALLBACK S_PropSheetPageProc(HWND hwnd,	UINT uMsg, LPPROPSHEETPAGE ppsp);


protected:
    CString m_strHelpFile;				// Name for the .hlp file
    CString m_strCaption;				// Name for the .hlp file
    const DWORD * m_prgzHelpIDs;		// Optional: Pointer to an array of help IDs

public:
    void SetCaption(UINT uStringID);
    void SetCaption(LPCTSTR pszCaption);
    void SetHelp(LPCTSTR szHelpFile, const DWORD rgzHelpIDs[]);
    void EnableDlgItem(INT nIdDlgItem, BOOL fEnable);

}; // CAutoDeletePropPage


/////////////////////////////////////////////////////////////////////////////
// CGeneralPage dialog

class CGeneralPage : public CAutoDeletePropPage
{
public:
    enum { IID_DEFAULT = IDD_GENERAL };

    // Construction
public:
    CGeneralPage(UINT uIDD = IID_DEFAULT);
    ~CGeneralPage();

    // Dialog Data


    // Overrides
public:
    BOOL OnApply();
protected:
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

    // Implementation
protected:
    void OnDestroy();
    void OnEditChange();
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);

public:
    LONG_PTR m_hConsoleHandle; // Handle given to the snap-in by the console

private:
    BOOL    m_bUpdate;
};

//////////////////////////////
// hand-hewn pages
class CPolicySettingsGeneralPage : public CAutoDeletePropPage
{
public:
    enum { IID_DEFAULT = IDD_POLICYSETTINGS_PROPPAGE1 };

    // Construction
public:
    CPolicySettingsGeneralPage(CString szCAName, HCAINFO hCAInfo, UINT uIDD = IID_DEFAULT);
    ~CPolicySettingsGeneralPage();

    // Dialog Data
    CString     m_szCAName;
    CComboBox   m_cboxDurationUnits;
    HCAINFO     m_hCAInfo;


    // Overrides
public:
    BOOL OnApply();
    BOOL OnInitDialog();
protected:
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

    // Implementation
protected:
    void OnDestroy();
    void OnEditChange();
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    BOOL OnNotify(UINT idCtrl, NMHDR* pnmh);

public:
    long        m_hConsoleHandle; // Handle given to the snap-in by the console

private:
    BOOL    m_bUpdate;
};


#include <gpedit.h>
//////////////////////////////
// hand-hewn pages
class CGlobalCertTemplateCSPPage : public CAutoDeletePropPage
{
public:
    enum { IID_DEFAULT = IDD_GLOBAL_TEMPLATE_PROPERTIES };

    // Construction
public:
    CGlobalCertTemplateCSPPage(IGPEInformation *pGPTInformation, UINT uIDD = IID_DEFAULT);
    ~CGlobalCertTemplateCSPPage();

    // Dialog Data
    HWND        m_hwndCSPList;

    // Overrides
public:
    BOOL OnApply();
    BOOL OnInitDialog();
protected:
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

    // Implementation
protected:
    void OnAddButton();
    void OnRemoveButton();
    void OnDestroy();
    void OnSelChange(NMHDR * pNotifyStruct);
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    BOOL OnNotify(UINT idCtrl, NMHDR* pnmh);

public:
    long        m_hConsoleHandle; // Handle given to the snap-in by the console

private:
    BOOL    m_bUpdate;
    IGPEInformation * m_pGPTInformation;

    BOOL CSPDoesntExist(LPWSTR);
};


/////////////////////////////////////////
// CCertTemplateGeneralPage
class CCertTemplateGeneralPage : public CAutoDeletePropPage
{
public:
    enum { IID_DEFAULT = IDD_CERTIFICATE_TEMPLATE_PROPERTIES_GENERAL_PAGE };

    // Construction
public:
    CCertTemplateGeneralPage(HCERTTYPE hCertType, UINT uIDD = IID_DEFAULT);
    ~CCertTemplateGeneralPage();

    void SetItemTextWrapper(UINT nID, int *piItem, BOOL fDoInsert, BOOL *pfFirstUsageItem);

    // Dialog Data
    HWND        m_hwndPurposesList;
    HWND        m_hwndOtherInfoList;

    // Overrides
public:
    BOOL OnApply();
    BOOL OnInitDialog();
protected:
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

    // Implementation
protected:
    void OnDestroy();
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);

public:
    LONG_PTR    m_hConsoleHandle; // Handle given to the snap-in by the console
    HCERTTYPE   m_hCertType;

private:
    BOOL    m_bUpdate;
};



/////////////////////////////////////////
// CCertTemplateSelectPage
INT_PTR SelectCertTemplateDialogProc(
                                  HWND hwndDlg,
                                  UINT uMsg,
                                  WPARAM wParam,
                                  LPARAM lParam);

class CCertTemplateSelectDialog
{
    // Construction
public:
    CCertTemplateSelectDialog(HWND hParent = NULL);
    ~CCertTemplateSelectDialog();

    // Dialog Data
    enum { IDD = IDD_SELECT_CERTIFICATE_TEMPLATE };
    HWND        m_hDlg;
    HWND        m_hwndCertTypeList;


    // Overrides
public:
    BOOL OnInitDialog(HWND hDlg);
    void OnOK();
    void OnHelp(LPHELPINFO lpHelp);
    void OnContextHelp(HWND hwnd);

protected:
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);



public:
    void SetCA(HCAINFO hCAInfo, bool fAdvancedServer);
    void SetHelp(LPCTSTR szHelpFile, const DWORD rgzHelpIDs[]);

    // Implementation
    //protected:
public:
    void OnDestroy();
    void OnSelChange(NMHDR * pNotifyStruct);
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    BOOL OnNotify(UINT idCtrl, NMHDR* pnmh);

protected:
	CString m_strHelpFile;				// Name for the .hlp file
	const DWORD * m_prgzHelpIDs;		// Optional: Pointer to an array of help IDs
    bool m_fAdvancedServer;
    CTemplateList m_TemplateList;

public:
    HCAINFO     m_hCAInfo;
};

#endif // _GENPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\capesnpn\misc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       misc.cpp
//
//--------------------------------------------------------------------------

#include <stdafx.h>

// sddl.h requires this value to be at least
// 0x0500.  Bump it up if necessary.  NOTE:  This
// 'bump' comes after all other H files that may
// be sensitive to this value.
#if(_WIN32_WINNT < 0x500)
#undef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif

#include <sddl.h>
#include <shlobj.h>
#include <dsclient.h>
#include <dsgetdc.h>
#include <lm.h>
#include <lmapibuf.h>
#include <objsel.h>

CLIPFORMAT g_cfDsObjectPicker = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);


// returns (if cstr.IsEmpty()) ? NULL : cstr)
LPCWSTR GetNullMachineName(CString* pcstr)
{
    LPCWSTR     szMachine = (pcstr->IsEmpty()) ? NULL : (LPCWSTR)*pcstr;
    return szMachine;
}

BOOL StringFromDurationUnit(DWORD dwExpirationUnits, CString* pcstr, BOOL fLocalized)
{
    if (NULL == pcstr)
        return FALSE;

    UINT uiRsc = 0;

    switch (dwExpirationUnits) 
    {
    case(ENUM_PERIOD_YEARS):
        if (fLocalized)
            uiRsc = IDS_PERIOD_YEARS;
        else
            *pcstr = wszPERIODYEARS;
        break;
    case(ENUM_PERIOD_MONTHS):
        if (fLocalized)
            uiRsc = IDS_PERIOD_MONTHS;
        else
            *pcstr = wszPERIODMONTHS;
        break;
    case(ENUM_PERIOD_WEEKS):
        if (fLocalized)
            uiRsc = IDS_PERIOD_WEEKS;
        else
            *pcstr = wszPERIODWEEKS;
        break;
    case(ENUM_PERIOD_DAYS):
        if (fLocalized)
            uiRsc = IDS_PERIOD_DAYS;
        else
            *pcstr = wszPERIODDAYS;
        break;
    default:
        break;
    }

    if (uiRsc)
        pcstr->LoadString(uiRsc);

    return !pcstr->IsEmpty();
}


/////////////////////////////////////////
// fxns to load/save cstrings to a streams
STDMETHODIMP CStringLoad(CString& cstr, IStream *pStm)
{
    ASSERT(pStm);
    HRESULT hr;

    DWORD cbSize=0;
    ULONG nBytesRead;

    // get cbSize (bytes)
    hr = pStm->Read(&cbSize, sizeof(cbSize), &nBytesRead);
    ASSERT(SUCCEEDED(hr) && (nBytesRead == sizeof(cbSize)) );

    if (FAILED(hr))
        return E_FAIL;

    // get string
    hr = pStm->Read(cstr.GetBuffer(cbSize), cbSize, &nBytesRead);
    ASSERT(SUCCEEDED(hr) && (nBytesRead == cbSize));

    cstr.ReleaseBuffer();

    return SUCCEEDED(hr) ? S_OK : E_FAIL;
}

STDMETHODIMP CStringSave(CString& cstr, IStream *pStm, BOOL fClearDirty)
{
    // Write the string
    DWORD cbSize = (cstr.GetLength()+1)*sizeof(WCHAR);
    ULONG nBytesWritten;
    HRESULT hr;

    // write size in bytes
    hr = pStm->Write(&cbSize, sizeof(cbSize), &nBytesWritten);
    ASSERT(SUCCEEDED(hr) && (nBytesWritten == sizeof(cbSize)) );

    if (FAILED(hr))
        return STG_E_CANTSAVE;

    // write string
    hr = pStm->Write((LPCWSTR)cstr, cbSize, &nBytesWritten);
    ASSERT(SUCCEEDED(hr) && (nBytesWritten == cbSize));

    // Verify that the write operation succeeded
    return SUCCEEDED(hr) ? S_OK : STG_E_CANTSAVE;
}

LPSTR AllocAndCopyStr(LPCSTR psz)
{
    LPSTR pszReturn;

    pszReturn = (LPSTR) new(BYTE[strlen(psz)+1]);
    if(pszReturn)
    {
        strcpy(pszReturn, psz);
    }
    return pszReturn;
}


LPWSTR AllocAndCopyStr(LPCWSTR pwsz)
{
    LPWSTR pwszReturn;

    pwszReturn = (LPWSTR) new(WCHAR[wcslen(pwsz)+1]);
    if(pwszReturn)
    {
        wcscpy(pwszReturn, pwsz);
    }
    return pwszReturn;
}

LPWSTR BuildErrorMessage(DWORD dwErr)
{
    LPWSTR lpMsgBuf = NULL;
    FormatMessageW(
                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                dwErr,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
                (LPWSTR) &lpMsgBuf,    
                0,    
                NULL );
    return lpMsgBuf;
}

//////////////////////////////////////////////////////////////////
// given an error code and a console pointer, will pop error dlg
void DisplayGenericCertSrvError(LPCONSOLE2 pConsole, DWORD dwErr)
{
    ASSERT(pConsole);
    LPWSTR lpMsgBuf = BuildErrorMessage(dwErr);


    if(lpMsgBuf)
    {    
    // ...
    // Display the string.
    pConsole->MessageBoxW(lpMsgBuf, L"Certificate Services Error", MB_OK | MB_ICONINFORMATION, NULL);
    
    // Free the buffer.
    LocalFree( lpMsgBuf );
    }
}
// returns localized, stringized time
BOOL FileTimeToLocalTimeString(FILETIME* pftGMT, LPWSTR* ppszTmp)
{
    FILETIME ftLocal;
    if (FileTimeToLocalFileTime(pftGMT, &ftLocal))
    {
        SYSTEMTIME sysLocal;
        if (FileTimeToSystemTime(
                &ftLocal, 
                &sysLocal))
        {
            WCHAR rgTmpDate[128], rgTmpTime[128];
            DWORD dwLen;
            dwLen = GetDateFormatW(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &sysLocal,
                NULL, rgTmpDate, ARRAYLEN(rgTmpDate));

            dwLen += GetTimeFormatW(LOCALE_USER_DEFAULT, TIME_NOSECONDS, &sysLocal,
                NULL, rgTmpTime, ARRAYLEN(rgTmpTime));

            dwLen += sizeof(L" ");

            *ppszTmp = new WCHAR[dwLen];
            if(*ppszTmp == NULL)
            {
                return FALSE;
            }
            wcscpy(*ppszTmp, rgTmpDate);
            wcscat(*ppszTmp, L" ");
            wcscat(*ppszTmp, rgTmpTime);
        }
    }
    
    return TRUE;
}


void MyErrorBox(HWND hwndParent, UINT nIDText, UINT nIDCaption, DWORD dwErrorCode)
{
    CString cstrTitle, cstrFormatText, cstrFullText;
    cstrTitle.LoadString(nIDCaption);
    cstrFormatText.LoadString(nIDText);

    WCHAR const *pwszError = NULL;
    if (dwErrorCode != ERROR_SUCCESS)
    {
        pwszError = myGetErrorMessageText(dwErrorCode, TRUE);

        cstrFullText.Format(cstrFormatText, pwszError);

        // Free the buffer
        if (NULL != pwszError)
	{
            LocalFree(const_cast<WCHAR *>(pwszError));
	}
    }

    ::MessageBoxW(hwndParent, cstrFullText, cstrTitle, MB_OK | MB_ICONERROR);
}


BOOL MyGetOIDInfo(LPWSTR string, DWORD stringSize, LPSTR pszObjId)
{   
    PCCRYPT_OID_INFO pOIDInfo;
            
    pOIDInfo = CryptFindOIDInfo(
                CRYPT_OID_INFO_OID_KEY, 
                pszObjId, 
                0);

    if (pOIDInfo != NULL)
    {
        if (wcslen(pOIDInfo->pwszName)+1 <= stringSize)
        {
            wcscpy(string, pOIDInfo->pwszName);
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return (MultiByteToWideChar(CP_ACP, 0, pszObjId, -1, string, stringSize) != 0);
    }
    return TRUE;
}


BOOL MyGetEnhancedKeyUsages(HCERTTYPE hCertType, CString **aszUsages, DWORD *cUsages, BOOL *pfCritical, BOOL fGetOIDSNotNames)
{
    PCERT_EXTENSIONS    pCertExtensions;
    CERT_ENHKEY_USAGE   *pehku;
    DWORD               cb = 0;
    WCHAR               OIDName[256];
    unsigned int        i;
    LPWSTR              pwszOID;
    HRESULT hr;

    CSASSERT(cUsages);

    if(aszUsages)
        *aszUsages = NULL;

    hr = CAGetCertTypeExtensions(hCertType, &pCertExtensions);

    if(hr != S_OK)
    {
        return FALSE;
    }

    i = 0;
    while ((i<pCertExtensions->cExtension) && 
           (strcmp(pCertExtensions->rgExtension[i].pszObjId, szOID_ENHANCED_KEY_USAGE) != 0))
    {
        i++;   
    }

    if (i >= pCertExtensions->cExtension)
    {
        CAFreeCertTypeExtensions(hCertType, pCertExtensions);
        return FALSE;
    }

    if (pfCritical != NULL)
    {
        *pfCritical = pCertExtensions->rgExtension[i].fCritical;
    }

    CryptDecodeObject(
            X509_ASN_ENCODING,
            X509_ENHANCED_KEY_USAGE,
            pCertExtensions->rgExtension[i].Value.pbData, 
            pCertExtensions->rgExtension[i].Value.cbData,
            0,
            NULL,
            &cb);

    if (NULL == (pehku = (CERT_ENHKEY_USAGE *) new(BYTE[cb])))
    {
        CAFreeCertTypeExtensions(hCertType, pCertExtensions);
        return FALSE;
    }

    CryptDecodeObject(
            X509_ASN_ENCODING,
            X509_ENHANCED_KEY_USAGE,
            pCertExtensions->rgExtension[i].Value.pbData, 
            pCertExtensions->rgExtension[i].Value.cbData,
            0,
            pehku,
            &cb);

    if(!aszUsages)
    {
        // only retrieving the usage count
        *cUsages = pehku->cUsageIdentifier;
    }
    else
    {
        // retrieving usage strings, count better match
        CSASSERT(*cUsages == pehku->cUsageIdentifier);

        for (i=0; i<pehku->cUsageIdentifier; i++)
        {
            if (fGetOIDSNotNames)
            {
                pwszOID = MyMkWStr(pehku->rgpszUsageIdentifier[i]);
                aszUsages[i]= new CString(pwszOID);
                delete(pwszOID);
                if(aszUsages[i] == NULL)
                {
                    return FALSE;
                }

            }
            else
            {
                MyGetOIDInfo(OIDName, sizeof(OIDName)/sizeof(WCHAR), pehku->rgpszUsageIdentifier[i]);
                aszUsages[i]= new CString(OIDName);
                if(aszUsages[i] == NULL)
                {
                    return FALSE;
                }
            }
        }
    }

    delete[](pehku);

    CAFreeCertTypeExtensions(hCertType, pCertExtensions);
    return TRUE;
}


BOOL GetIntendedUsagesString(HCERTTYPE hCertType, CString *pUsageString)
{
    CString **aszUsages = NULL;
    DWORD   cNumUsages = 0;
    unsigned int     i;

    if(!MyGetEnhancedKeyUsages(hCertType, NULL, &cNumUsages, NULL, FALSE))
        return FALSE;

    if(0==cNumUsages)
    {
        *pUsageString = "";
        return TRUE;
    }

    aszUsages = new CString*[cNumUsages];
    if(!aszUsages)
        return FALSE;

    if(!MyGetEnhancedKeyUsages(hCertType, aszUsages, &cNumUsages, NULL, FALSE))
    {
        delete[] aszUsages;
        return FALSE;
    }

    *pUsageString = "";

    for (i=0; i<cNumUsages; i++)
    {
        if (i != 0)
        {
            *pUsageString += ", ";
        }
        *pUsageString += *(aszUsages[i]);

        delete(aszUsages[i]);
    }

    delete[] aszUsages;

    return TRUE;
}


BOOL MyGetKeyUsages(HCERTTYPE hCertType, CRYPT_BIT_BLOB **ppBitBlob, BOOL *pfPublicKeyUsageCritical)
{
    PCERT_EXTENSIONS    pCertExtensions;
    DWORD               cb = 0;
    unsigned int                 i;
    
    HRESULT hr;
    hr = CAGetCertTypeExtensions(hCertType, &pCertExtensions);

    if(hr != S_OK)
    {
        return FALSE;
    }

    i = 0;
    while ((i<pCertExtensions->cExtension) && (strcmp(pCertExtensions->rgExtension[i].pszObjId, szOID_KEY_USAGE) != 0))
    {
        i++;   
    }

    if (i >= pCertExtensions->cExtension)
    {
        CAFreeCertTypeExtensions(hCertType, pCertExtensions);
        return FALSE;
    }

    if (pfPublicKeyUsageCritical != NULL)
    {
        *pfPublicKeyUsageCritical = pCertExtensions->rgExtension[i].fCritical;
    }

    CryptDecodeObject(
            X509_ASN_ENCODING,
            X509_KEY_USAGE,
            pCertExtensions->rgExtension[i].Value.pbData, 
            pCertExtensions->rgExtension[i].Value.cbData,
            0,
            NULL,
            &cb);

    if (NULL == (*ppBitBlob = (CRYPT_BIT_BLOB *) new(BYTE[cb])))
    {
        CAFreeCertTypeExtensions(hCertType, pCertExtensions);
        return FALSE;
    }

    CryptDecodeObject(
            X509_ASN_ENCODING,
            X509_KEY_USAGE,
            pCertExtensions->rgExtension[i].Value.pbData, 
            pCertExtensions->rgExtension[i].Value.cbData,
            0,
            *ppBitBlob,
            &cb);

    CAFreeCertTypeExtensions(hCertType, pCertExtensions);
    return TRUE;
}

BOOL MyGetBasicConstraintInfo(HCERTTYPE hCertType, BOOL *pfCA, BOOL *pfPathLenConstraint, DWORD *pdwPathLenConstraint)
{
    PCERT_EXTENSIONS                pCertExtensions;
    DWORD                           cb = sizeof(CERT_BASIC_CONSTRAINTS2_INFO);
    unsigned int                    i;
    CERT_BASIC_CONSTRAINTS2_INFO    basicConstraintsInfo;
    
    HRESULT hr;
    hr = CAGetCertTypeExtensions(hCertType, &pCertExtensions);

    if(hr != S_OK)
    {
        return FALSE;
    }

    i = 0;
    while ((i<pCertExtensions->cExtension) && (strcmp(pCertExtensions->rgExtension[i].pszObjId, szOID_BASIC_CONSTRAINTS2) != 0))
    {
        i++;   
    }

    if (i >= pCertExtensions->cExtension)
    {
        CAFreeCertTypeExtensions(hCertType, pCertExtensions);
        return FALSE;
    }

    CryptDecodeObject(
            X509_ASN_ENCODING,
            X509_BASIC_CONSTRAINTS2,
            pCertExtensions->rgExtension[i].Value.pbData, 
            pCertExtensions->rgExtension[i].Value.cbData,
            0,
            &basicConstraintsInfo,
            &cb);

    *pfCA = basicConstraintsInfo.fCA;
    *pfPathLenConstraint = basicConstraintsInfo.fPathLenConstraint;
    *pdwPathLenConstraint = basicConstraintsInfo.dwPathLenConstraint;

    CAFreeCertTypeExtensions(hCertType, pCertExtensions);
    return TRUE;
}


LPSTR MyMkMBStr(LPCWSTR pwsz)
{
    int     cb;
    LPSTR   psz;

    if (pwsz == NULL)
    {
        return NULL;
    }
    
    cb = WideCharToMultiByte(
                    0,
                    0,
                    pwsz,
                    -1,
                    NULL,
                    0,
                    NULL,
                    NULL);
            
    if (NULL == (psz = (LPSTR) new BYTE[cb]))
    {
        return NULL;
    }

    cb = WideCharToMultiByte(
                0,
                0,
                pwsz,
                -1,
                psz,
                cb,
                NULL,
                NULL);

    if (cb==0)
    { 
       delete [] psz;
       return NULL;
    }
    return(psz);
}

LPWSTR MyMkWStr(LPCSTR psz)
{
    int     cWChars;
    LPWSTR   pwsz;

    if (psz == NULL)
    {
        return NULL;
    }

    cWChars = MultiByteToWideChar(
                    0,
                    0,
                    psz,
                    -1,
                    NULL,
                    0);
            
    if (NULL == (pwsz = (LPWSTR) new BYTE[cWChars * sizeof(WCHAR)] ))
    {
        return NULL;
    }

    cWChars = MultiByteToWideChar(
                    0,
                    0,
                    psz,
                    -1,
                    pwsz,
                    cWChars);

    if (cWChars == 0)
    {
        delete [] pwsz;
        return NULL;
    }
    return(pwsz);
}


BOOL  IsCerttypeEditingAllowed()
{
    DWORD   lResult;
    HKEY    hKey = NULL;
    DWORD   dwType;
    DWORD   dwEnabled = 0;
    DWORD   cbEnabled = sizeof(dwEnabled);
    lResult = RegOpenKeyEx (HKEY_CURRENT_USER, 
                            L"Software\\Microsoft\\Cryptography\\CertificateTemplateCache", 
                            0, 
                            KEY_READ,
                            &hKey);

    if (lResult == ERROR_SUCCESS) 
    {
        lResult = RegQueryValueEx(hKey, 
                  REGSZ_ENABLE_CERTTYPE_EDITING,  
                  NULL,
                  &dwType,
                  (PBYTE)&dwEnabled,
                  &cbEnabled);
        if(lResult == ERROR_SUCCESS)
        {
            if(dwType != REG_DWORD)
            {
                dwEnabled = 0;
            }
        }
        RegCloseKey (hKey);
    }


    return (dwEnabled != 0);
}

HRESULT RetrieveCATemplateListFromCA(
    HCAINFO hCAInfo,
    CTemplateList& list)
{
    HRESULT hr = S_OK;
    LPWSTR *ppwszDNSName = NULL;
    LPWSTR *ppwszAuthority = NULL;
    ICertAdminD2 *pAdminD2 = NULL;
    DWORD dwServerVersion = 2;
    CERTTRANSBLOB ctbSD;

    ZeroMemory(&ctbSD, sizeof(CERTTRANSBLOB));

    hr = CAGetCAProperty(hCAInfo, CA_PROP_DNSNAME, &ppwszDNSName);
    _JumpIfError(hr, error, "CAGetCAProperty CA_PROP_DNSNAME");

    hr = CAGetCAProperty(hCAInfo, CA_PROP_NAME, &ppwszAuthority);
    _JumpIfError(hr, error, "CAGetCAProperty CA_PROP_DNSNAME");

    ASSERT(ppwszDNSName[0]);

    hr = myOpenAdminDComConnection(
                    ppwszDNSName[0],
                    NULL,
                    NULL,
                    &dwServerVersion,
                    &pAdminD2);
    _JumpIfError(hr, error, "myOpenAdminDComConnection");

    if (2 > dwServerVersion)
    {
        hr = RPC_E_VERSION_MISMATCH;
        _JumpError(hr, error, "old server");
    }

    CSASSERT(ppwszAuthority[0]);

    hr = pAdminD2->GetCAProperty(
        ppwszAuthority[0],
        CR_PROP_TEMPLATES,
        0,
        PROPTYPE_STRING,
        &ctbSD);
    _JumpIfErrorStr(hr, error, "ICertAdminD2::GetCAProperty CR_PROP_TEMPLATES",
        ppwszDNSName[0]);

    hr = list.Unmarshal(ctbSD.pb, ctbSD.cb);
    _JumpIfError(hr, error, "CTemplateList::Unmarshal");

error:
    if(ppwszDNSName)
        CAFreeCAProperty(hCAInfo, ppwszDNSName);
    
    if(ppwszAuthority)
        CAFreeCAProperty(hCAInfo, ppwszAuthority);

    if(pAdminD2)
        pAdminD2->Release();

    return hr;
}

HRESULT RetrieveCATemplateListFromDS(
    HCAINFO hCAInfo,
    CTemplateList& list)
{
    HRESULT hr = S_OK;
    HCERTTYPE hCertTypeNext, hCertTypePrev;

    hr = CAEnumCertTypesForCA(
            hCAInfo,
            CT_ENUM_MACHINE_TYPES |
            CT_ENUM_USER_TYPES |
            CT_FLAG_NO_CACHE_LOOKUP,
            &hCertTypeNext);
    _JumpIfError(hr, error, "CAEnumCertTypesForCA");

    while (hCertTypeNext != NULL)
    {
        hr = list.AddTemplateInfo(hCertTypeNext);
        _JumpIfError(hr, error, "CTemplateList::AddTemplate");

        hCertTypePrev = hCertTypeNext;
        hr = CAEnumNextCertType(hCertTypePrev, &hCertTypeNext);
        _JumpIfError(hr, error, "CAEnumNextCertType");
    }

error:
    return hr;
}

HRESULT RetrieveCATemplateList(
    HCAINFO hCAInfo,
    CTemplateList& list)
{
    HRESULT hr = S_OK;

    hr = RetrieveCATemplateListFromCA(hCAInfo, list);
    if(S_OK != hr)
    {
        // if failed to retrieve from the CA for any reason, try
        // fetching from DS

        hr = RetrieveCATemplateListFromDS(hCAInfo, list);
    }

    return hr;
}



HRESULT UpdateCATemplateListToDS(
    HCAINFO hCAInfo,
    const CTemplateList& list)
{
    HRESULT hr = S_OK;

    hr = CAUpdateCA(hCAInfo);
    _JumpIfError(hr, error, "CAUpdateCA");

error:
    return hr;
}


HRESULT UpdateCATemplateListToCA(
    HCAINFO hCAInfo,
    const CTemplateList& list)
{
    HRESULT hr = S_OK;
    LPWSTR *ppwszDNSName = NULL;
    LPWSTR *ppwszAuthority = NULL;
    ICertAdminD2 *pAdminD2 = NULL;
    DWORD dwServerVersion = 2;
    CERTTRANSBLOB ctbSD;

    ZeroMemory(&ctbSD, sizeof(CERTTRANSBLOB));

    hr = CAGetCAProperty(hCAInfo, CA_PROP_DNSNAME, &ppwszDNSName);
    _JumpIfError(hr, error, "CAGetCAProperty CA_PROP_DNSNAME");

    hr = CAGetCAProperty(hCAInfo, CA_PROP_NAME, &ppwszAuthority);
    _JumpIfError(hr, error, "CAGetCAProperty CA_PROP_DNSNAME");

    ASSERT(ppwszDNSName[0]);

    hr = myOpenAdminDComConnection(
                    ppwszDNSName[0],
                    NULL,
                    NULL,
                    &dwServerVersion,
                    &pAdminD2);
    _JumpIfError(hr, error, "myOpenAdminDComConnection");

    if (2 > dwServerVersion)
    {
        hr = RPC_E_VERSION_MISMATCH;
        _JumpError(hr, error, "old server");
    }

    CSASSERT(ppwszAuthority[0]);

    hr = list.Marshal(ctbSD.pb, ctbSD.cb);
    _JumpIfError(hr, error, "CTemplateList::Marshal");

    CSASSERT(S_OK==list.ValidateMarshalBuffer(ctbSD.pb, ctbSD.cb));

    hr = pAdminD2->SetCAProperty(
        ppwszAuthority[0],
        CR_PROP_TEMPLATES,
        0,
        PROPTYPE_STRING,
        &ctbSD);
    _JumpIfErrorStr(hr, error, "ICertAdminD2::SetCAProperty CR_PROP_TEMPLATES",
        ppwszDNSName[0]);

error:
    if(ppwszDNSName)
        CAFreeCAProperty(hCAInfo, ppwszDNSName);
    
    if(ppwszAuthority)
        CAFreeCAProperty(hCAInfo, ppwszAuthority);

    if(pAdminD2)
        pAdminD2->Release();

    if(ctbSD.pb)
        MIDL_user_free(ctbSD.pb);
    return hr;
}

       
HRESULT UpdateCATemplateList(
    HCAINFO hCAInfo,
    const CTemplateList& list)
{
    HRESULT hr = UpdateCATemplateListToCA(hCAInfo, list);
    if(S_OK != hr)
    {
        // if failed to update through the CA for any reason, try
        // writing directly to DS

        hr = UpdateCATemplateListToDS(hCAInfo, list);
    }

    return hr;
}

HRESULT AddToCATemplateList(
    HCAINFO hCAInfo,
    CTemplateList& list,
    HCERTTYPE hCertType)
{
    HRESULT hr = S_OK;
    hr = CAAddCACertificateType(hCAInfo, hCertType);
    _JumpIfError(hr, error, "CAAddCACertificateType");

    hr = list.AddTemplateInfo(hCertType);
    _JumpIfError(hr, error, "CTemplateList::AddTemplateInfo HCERTTYPE");

error:
    return hr;
}

HRESULT RemoveFromCATemplateList(
    HCAINFO hCAInfo,
    CTemplateList& list,
    HCERTTYPE hCertType)
{
    HRESULT hr = S_OK;

    hr = CARemoveCACertificateType(hCAInfo, hCertType);
    _JumpIfError(hr, error, "CARemoveCACertificateType");

    hr = list.RemoveTemplateInfo(hCertType);
    _JumpIfError(hr, error, "CTemplateList::RemoveTemplateInfo HCERTTYPE");

error:
    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\capesnpn\genpage.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       genpage.cpp
//
//--------------------------------------------------------------------------

// genpage.cpp : implementation file
//

#include "stdafx.h"
#include "certca.h"
#include "tfcprop.h"
#include "genpage.h"

// sddl.h requires this value to be at least
// 0x0500.  Bump it up if necessary.  NOTE:  This
// 'bump' comes after all other H files that may
// be sensitive to this value.
#if(_WIN32_WINNT < 0x500)
#undef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif

#include <sddl.h>
#include "helparr.h"


#define DURATION_INDEX_YEARS    0
#define DURATION_INDEX_MONTHS   1
#define DURATION_INDEX_WEEKS    2
#define DURATION_INDEX_DAYS     3

void myDisplayError(HWND hwnd, HRESULT hr, UINT id)
{
    CString cstrTitle, cstrFullText;
    cstrTitle.LoadString(IDS_SNAPIN_NAME);

    if (hr != S_OK)
    {
        WCHAR const *pwszError = myGetErrorMessageText(hr, TRUE);

        cstrFullText = pwszError;

        // Free the buffer
        if (NULL != pwszError)
	{
            LocalFree(const_cast<WCHAR *>(pwszError));
	}
    }

    if (id != -1)
    {
        CString cstrMsg;
        cstrMsg.LoadString(id);
        cstrFullText += cstrMsg;
    }

    ::MessageBoxW(hwnd, cstrFullText, cstrTitle, MB_OK | MB_ICONERROR);
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// replacement for DoDataExchange
BOOL CAutoDeletePropPage::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
//        m_cstrModuleName.FromWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
    }
    else
    {
//        m_cstrModuleName.ToWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
    }
    return TRUE;
}

// replacement for BEGIN_MESSAGE_MAP
BOOL CAutoDeletePropPage::OnCommand(WPARAM wParam, LPARAM lParam)
{

/*
    switch(LOWORD(wParam))
    {
    default:
        return FALSE;
        break;
    }
*/
    return TRUE;
}

/////////////////////////////////////////////////////////////////////
//	Constructor
CAutoDeletePropPage::CAutoDeletePropPage(UINT uIDD) : PropertyPage(uIDD)
{
	m_prgzHelpIDs = NULL;
	m_autodeleteStuff.cWizPages = 1; // Number of pages in wizard
	m_autodeleteStuff.pfnOriginalPropSheetPageProc = m_psp.pfnCallback;


    m_psp.dwFlags |= PSP_USECALLBACK;
	m_psp.pfnCallback = S_PropSheetPageProc;
	m_psp.lParam = reinterpret_cast<LPARAM>(this);
}

CAutoDeletePropPage::~CAutoDeletePropPage()
{
}


/////////////////////////////////////////////////////////////////////
void CAutoDeletePropPage::SetCaption(LPCTSTR pszCaption)
{
    m_strCaption = pszCaption;		// Copy the caption
    m_psp.pszTitle = m_strCaption;	// Set the title
    m_psp.dwFlags |= PSP_USETITLE;
}

/////////////////////////////////////////////////////////////////////
void CAutoDeletePropPage::SetCaption(UINT uStringID)
{
    VERIFY(m_strCaption.LoadString(uStringID));
    SetCaption(m_strCaption);
}

/////////////////////////////////////////////////////////////////////
void CAutoDeletePropPage::SetHelp(LPCTSTR szHelpFile, const DWORD rgzHelpIDs[])
{
    //szHelpFile == NULL;	// TRUE => No help file supplied (meaning no help)
    //rgzHelpIDs == NULL;	// TRUE => No help at all
    m_strHelpFile = szHelpFile;
    m_prgzHelpIDs = rgzHelpIDs;
}

/////////////////////////////////////////////////////////////////////
void CAutoDeletePropPage::EnableDlgItem(INT nIdDlgItem, BOOL fEnable)
{
    ASSERT(IsWindow(::GetDlgItem(m_hWnd, nIdDlgItem)));
    ::EnableWindow(::GetDlgItem(m_hWnd, nIdDlgItem), fEnable);
}

/////////////////////////////////////////////////////////////////////
BOOL CAutoDeletePropPage::OnSetActive()
{
    HWND hwndParent = ::GetParent(m_hWnd);
    ASSERT(IsWindow(hwndParent));
    ::PropSheet_SetWizButtons(hwndParent, PSWIZB_FINISH);
    return PropertyPage::OnSetActive();
}

/////////////////////////////////////////////////////////////////////
void CAutoDeletePropPage::OnContextHelp(HWND hwnd)
{
    if (m_prgzHelpIDs == NULL || m_strHelpFile.IsEmpty())
        return;
    ASSERT(IsWindow(hwnd));
    ::WinHelp(hwnd, m_strHelpFile, HELP_CONTEXTMENU, (ULONG_PTR)(LPVOID)m_prgzHelpIDs);
    return;
}

/////////////////////////////////////////////////////////////////////
void CAutoDeletePropPage::OnHelp(LPHELPINFO pHelpInfo)
{
    if (m_prgzHelpIDs == NULL || m_strHelpFile.IsEmpty())
        return;
    if (pHelpInfo != NULL && pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        // Display context help for a control
        ::WinHelp((HWND)pHelpInfo->hItemHandle, m_strHelpFile,
            HELP_WM_HELP, (ULONG_PTR)(LPVOID)m_prgzHelpIDs);
    }
    return;
}


/////////////////////////////////////////////////////////////////////
//	S_PropSheetPageProc()
//
//	Static member function used to delete the CAutoDeletePropPage object
//	when wizard terminates
//
UINT CALLBACK CAutoDeletePropPage::S_PropSheetPageProc(
                                                       HWND hwnd,	
                                                       UINT uMsg,	
                                                       LPPROPSHEETPAGE ppsp)
{
    ASSERT(ppsp != NULL);
    CAutoDeletePropPage *pThis;
    pThis = reinterpret_cast<CAutoDeletePropPage*>(ppsp->lParam);
    ASSERT(pThis != NULL);

    BOOL fDefaultRet;

    switch (uMsg)
    {
    case PSPCB_RELEASE:
        fDefaultRet = FALSE;
        if (--(pThis->m_autodeleteStuff.cWizPages) <= 0)
        {
            // Remember callback on stack since "this" will be deleted
            LPFNPSPCALLBACK pfnOrig = pThis->m_autodeleteStuff.pfnOriginalPropSheetPageProc;
            delete pThis;

            if (pfnOrig)
                return (pfnOrig)(hwnd, uMsg, ppsp);
            else
                return fDefaultRet;
        }
        break;
    case PSPCB_CREATE:
        fDefaultRet = TRUE;
        // do not increase refcount, PSPCB_CREATE may or may not be called
        // depending on whether the page was created.  PSPCB_RELEASE can be
        // depended upon to be called exactly once per page however.
        break;

    } // switch
    if (pThis->m_autodeleteStuff.pfnOriginalPropSheetPageProc)
        return (pThis->m_autodeleteStuff.pfnOriginalPropSheetPageProc)(hwnd, uMsg, ppsp);
    else
        return fDefaultRet;
} // CAutoDeletePropPage::S_PropSheetPageProc()


/////////////////////////////////////////////////////////////////////////////
// CGeneralPage property page
CGeneralPage::CGeneralPage(UINT uIDD) : CAutoDeletePropPage(uIDD)
{
    m_hConsoleHandle = NULL;
    m_bUpdate = FALSE;
    SetHelp(CAPESNPN_HELPFILENAME , g_aHelpIDs_IDD_CERTIFICATE_TEMPLATE_PROPERTIES_GENERAL_PAGE);
}

CGeneralPage::~CGeneralPage()
{
}

// replacement for DoDataExchange
BOOL CGeneralPage::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
//        m_cstrModuleName.FromWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
    }
    else
    {
//        m_cstrModuleName.ToWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
    }
    return TRUE;
}
// replacement for BEGIN_MESSAGE_MAP
BOOL CGeneralPage::OnCommand(WPARAM wParam, LPARAM lParam)
{
/*
    switch(LOWORD(wParam))
    {
    default:
        return FALSE;
        break;
    }
*/
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CGeneralPage message handlers

void CGeneralPage::OnDestroy()
{
    // Note - This needs to be called only once.
    // If called more than once, it will gracefully return an error.
    if (m_hConsoleHandle)
        MMCFreeNotifyHandle(m_hConsoleHandle);
    m_hConsoleHandle = NULL;

    CAutoDeletePropPage::OnDestroy();
}


void CGeneralPage::OnEditChange()
{
    if (!m_bUpdate)
    {
        // Page is dirty, mark it.
	    SetModified();	
        m_bUpdate = TRUE;
    }
}


BOOL CGeneralPage::OnApply()
{
	if (m_bUpdate == TRUE)
    {
/*
		USES_CONVERSION;
        // Simple string cookie, could be anything!
        LPWSTR lpString =
            reinterpret_cast<LPWSTR>(
          ::GlobalAlloc(GMEM_SHARE,
                        (sizeof(wchar_t) *
                        (m_szName.GetLength() + 1))
                        ));

        wcscpy(lpString, T2COLE(m_szName));

        // Send a property change notify to the console
        MMCPropertyChangeNotify(m_hConsoleHandle, reinterpret_cast<LONG_PTR>(lpString));
        m_bUpdate = FALSE;
*/
    }
	
    return CAutoDeletePropPage::OnApply();
}


//////////////////////////////
// hand-hewn pages

////
// 1

/////////////////////////////////////////////////////////////////////////////
// CPolicySettingsGeneralPage property page
CPolicySettingsGeneralPage::CPolicySettingsGeneralPage(CString szCAName, HCAINFO hCAInfo, UINT uIDD)
    : CAutoDeletePropPage(uIDD), m_hCAInfo(hCAInfo), m_szCAName(szCAName)
{
    m_hConsoleHandle = NULL;
    m_bUpdate = FALSE;
    SetHelp(CAPESNPN_HELPFILENAME , g_aHelpIDs_IDD_POLICYSETTINGS_PROPPAGE1);

}

CPolicySettingsGeneralPage::~CPolicySettingsGeneralPage()
{
}

// replacement for DoDataExchange
BOOL CPolicySettingsGeneralPage::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
//        m_cstrModuleName.FromWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
    }
    else
    {
//        m_cstrModuleName.ToWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
    }
    return TRUE;
}
// replacement for BEGIN_MESSAGE_MAP
BOOL CPolicySettingsGeneralPage::OnCommand(WPARAM wParam, LPARAM lParam)
{
/*
    switch(LOWORD(wParam))
    {
    default:
        return FALSE;
        break;
    }
*/
    return TRUE;
}

BOOL CPolicySettingsGeneralPage::OnNotify(UINT idCtrl, NMHDR* pnmh)
{
    switch(idCtrl)
    {
    case IDC_DURATION_EDIT:
        if (EN_CHANGE == pnmh->code)
        {
            OnEditChange();
            break;
        }
    case IDC_DURATION_UNIT_COMBO:
        if (CBN_SELCHANGE == pnmh->code)
        {
            OnEditChange();
            break;
        }
    default:
        return FALSE;
    }

    return TRUE;
}
/////////////////////////////////////////////////////////////////////////////
// CPolicySettingsGeneralPage message handlers
BOOL CPolicySettingsGeneralPage::OnInitDialog()
{
    // does parent init and UpdateData call
    CAutoDeletePropPage::OnInitDialog();

    DWORD dwExpiration;
    DWORD dwExpirationUnits;
    WCHAR szNumberString[256];
    int iEntry;

    m_cboxDurationUnits.ResetContent();

    CString cstr;
    cstr.LoadString(IDS_PERIOD_YEARS);
    iEntry = m_cboxDurationUnits.AddString(cstr);
    if (iEntry >= 0)
        m_cboxDurationUnits.SetItemData(iEntry, DURATION_INDEX_YEARS);

    cstr.LoadString(IDS_PERIOD_MONTHS);
    iEntry = m_cboxDurationUnits.AddString(cstr);
    if (iEntry >= 0)
        m_cboxDurationUnits.SetItemData(iEntry, DURATION_INDEX_MONTHS);

    cstr.LoadString(IDS_PERIOD_WEEKS);
    iEntry = m_cboxDurationUnits.AddString(cstr);
    if (iEntry >= 0)
        m_cboxDurationUnits.SetItemData(iEntry, DURATION_INDEX_WEEKS);

    cstr.LoadString(IDS_PERIOD_DAYS);
    iEntry = m_cboxDurationUnits.AddString(cstr);
    if (iEntry >= 0)
        m_cboxDurationUnits.SetItemData(iEntry, DURATION_INDEX_DAYS);

    //
    // use m_hCAInfo find out the initial durations times
    //
    CAGetCAExpiration(m_hCAInfo, &dwExpiration, &dwExpirationUnits);

    wsprintf(szNumberString, L"%u", dwExpiration);
    SetWindowText(GetDlgItem(m_hWnd, IDC_DURATION_EDIT), szNumberString);

    StringFromDurationUnit(dwExpirationUnits, &cstr, TRUE);
    m_cboxDurationUnits.SelectString(
            -1,
            cstr);

    UpdateData(FALSE);
    return TRUE;
}


void CPolicySettingsGeneralPage::OnDestroy()
{
    // Note - This needs to be called only once.
    // If called more than once, it will gracefully return an error.
    if (m_hConsoleHandle)
        MMCFreeNotifyHandle(m_hConsoleHandle);
    m_hConsoleHandle = NULL;

    CAutoDeletePropPage::OnDestroy();
}

void CPolicySettingsGeneralPage::OnEditChange()
{
    if (!m_bUpdate)
    {
        // Page is dirty, mark it.
	    SetModified();	
        m_bUpdate = TRUE;
    }
}


BOOL CPolicySettingsGeneralPage::OnApply()
{
	HRESULT hr;
    CString szNumberString;
    LPSTR   psz;
    DWORD   dwExpiration;

    if (m_bUpdate == TRUE)
    {
        if (FALSE == szNumberString.FromWindow(GetDlgItem(m_hWnd, IDC_DURATION_EDIT)))
           return FALSE;

        psz = MyMkMBStr((LPCTSTR)szNumberString);
        if(psz == NULL)
        {
            return FALSE;
        }
        dwExpiration = atoi(psz);
        delete(psz);

        UINT iSel = m_cboxDurationUnits.GetCurSel();
        switch (m_cboxDurationUnits.GetItemData(iSel))
        {
        case DURATION_INDEX_DAYS:
            hr = CASetCAExpiration(m_hCAInfo, dwExpiration, CA_UNITS_DAYS);
            break;
        case DURATION_INDEX_WEEKS:
            hr = CASetCAExpiration(m_hCAInfo, dwExpiration, CA_UNITS_WEEKS);
            break;
        case DURATION_INDEX_MONTHS:
            hr = CASetCAExpiration(m_hCAInfo, dwExpiration, CA_UNITS_MONTHS);
            break;
        case DURATION_INDEX_YEARS:
            hr = CASetCAExpiration(m_hCAInfo, dwExpiration, CA_UNITS_YEARS);
            break;
        }

        hr = CAUpdateCA(m_hCAInfo);

        if (FAILED(hr))
        {
            MyErrorBox(m_hWnd, IDS_FAILED_CA_UPDATE ,IDS_SNAPIN_NAME, hr);
            return FALSE;
        }

        m_bUpdate = FALSE;
    }

    return CAutoDeletePropPage::OnApply();
}


/////////////////////////////////////////////////////////////////////////////
// CGlobalCertTemplateCSPPage property page
CGlobalCertTemplateCSPPage::CGlobalCertTemplateCSPPage(IGPEInformation * pGPTInformation, UINT uIDD)
    : CAutoDeletePropPage(uIDD), m_pGPTInformation(pGPTInformation)
{
    m_hConsoleHandle = NULL;
    m_bUpdate = FALSE;
}

CGlobalCertTemplateCSPPage::~CGlobalCertTemplateCSPPage()
{

}

// replacement for DoDataExchange
BOOL CGlobalCertTemplateCSPPage::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
//        m_cstrModuleName.FromWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
    }
    else
    {
//        m_cstrModuleName.ToWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
    }
    return TRUE;
}

// replacement for BEGIN_MESSAGE_MAP
BOOL CGlobalCertTemplateCSPPage::OnCommand(WPARAM wParam, LPARAM lParam)
{
    switch(LOWORD(wParam))
    {
    case IDC_ADDCSPS_BUTTON:
        if (HIWORD(wParam) == BN_CLICKED)
        {
            OnAddButton();
            break;
        }
    case IDC_REMOVECSPS_BUTTON:
        if (HIWORD(wParam) == BN_CLICKED)
        {
            OnRemoveButton();
            break;
        }
    default:
        return FALSE;
        break;
    }
    return TRUE;
}

BOOL CGlobalCertTemplateCSPPage::OnNotify(UINT idCtrl, NMHDR* pnmh)
{
    switch(idCtrl)
    {
    case IDC_CSP_LIST:
        if (LVN_ITEMCHANGED == pnmh->code)
        {
            OnSelChange(pnmh);
            break;
        }
    default:
        return FALSE;
    }

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CGlobalCertTemplateCSPPage message handlers
BOOL CGlobalCertTemplateCSPPage::OnInitDialog()
{
    // does parent init and UpdateData call
    CAutoDeletePropPage::OnInitDialog();

    m_hwndCSPList = GetDlgItem(m_hWnd, IDC_CSP_LIST);
    HRESULT hr = S_OK;


    DWORD   dwIndex = 0;
    DWORD   dwFlags = 0;
    DWORD   dwCharCount = 0;
    LPWSTR  pwszProvName = NULL;

    LVCOLUMN lvcol;
    lvcol.mask = LVCF_FMT | LVCF_WIDTH;
    lvcol.fmt = LVCFMT_LEFT;
    lvcol.cx = 200;
    ListView_InsertColumn(m_hwndCSPList, 0, &lvcol);

    EnableWindow(GetDlgItem(m_hWnd, IDC_REMOVECSPS_BUTTON), FALSE);

    //
    // add the current default list
    //
  /*  while (S_OK == (hr = CAEnumGPTGlobalProviders(m_pGPTInformation, dwIndex, &dwFlags, NULL, &dwCharCount)))
    {
        if (NULL == (pwszProvName = (LPWSTR) new(WCHAR[dwCharCount+1])))
        {
            break;
        }

        if (S_OK != (hr = CAEnumGPTGlobalProviders(m_pGPTInformation, dwIndex, &dwFlags, pwszProvName, &dwCharCount)))
        {
            delete[](pwszProvName);
            break;
        }

        ListView_NewItem(m_hwndCSPList, dwIndex, pwszProvName);

        //
        // setup for next pass
        //
        dwCharCount = 0;
        delete[](pwszProvName);
        pwszProvName = NULL;
        dwIndex++;
    }        */

    ListView_SetColumnWidth(m_hwndCSPList, 0, LVSCW_AUTOSIZE);

    if (hr != S_OK)
        myDisplayError(m_hWnd, hr, -1);

    UpdateData(FALSE);
    return TRUE;
}


void CGlobalCertTemplateCSPPage::OnDestroy()
{
    // Note - This needs to be called only once.
    // If called more than once, it will gracefully return an error.
    if (m_hConsoleHandle)
        MMCFreeNotifyHandle(m_hConsoleHandle);
    m_hConsoleHandle = NULL;

    CAutoDeletePropPage::OnDestroy();
}

BOOL CGlobalCertTemplateCSPPage::OnApply()
{
    DWORD   dwFlags = 0;
    DWORD   dwCharCount = 0;
    LPWSTR  pwszProvName = NULL;
    int     i;
    CString szProvName;


    if (m_bUpdate == TRUE)
    {
        //
        // since there is really no good way to know which csps in the
        // list box aren't already in the global list, just delete all
        // csps in the global list and re-add all the ones in the list box
        //
       /* while (S_OK == CAEnumGPTGlobalProviders(m_pGPTInformation, 0, &dwFlags, NULL, &dwCharCount))
        {
            if (NULL == (pwszProvName = (LPWSTR) new(WCHAR[dwCharCount+1])))
            {
                break;
            }

            if (S_OK != CAEnumGPTGlobalProviders(m_pGPTInformation, 0, &dwFlags, pwszProvName, &dwCharCount))
            {
                delete[](pwszProvName);
                break;
            }

            CARemoveGPTGlobalProvider(m_pGPTInformation, pwszProvName);

            //
            // setup for next pass
            //
            dwCharCount = 0;
            delete[](pwszProvName);
            pwszProvName = NULL;
        } */

        int iListCount = ListView_GetItemCount(m_hwndCSPList);
        for (i=0; i<iListCount; i++)
        {
            ListView_GetItemText(m_hwndCSPList, i, 0, szProvName.GetBuffer(MAX_PATH), MAX_PATH*sizeof(WCHAR));
           // CAAddGPTGlobalProvider(m_pGPTInformation, 0, (LPWSTR) (LPCWSTR) szProvName);
        }

        GUID guidExtension = REGISTRY_EXTENSION_GUID;
        GUID guidSnapin = CLSID_CAPolicyExtensionSnapIn;

        m_pGPTInformation->PolicyChanged(TRUE, TRUE, &guidExtension, &guidSnapin);
        m_bUpdate = FALSE;
    }

    return CAutoDeletePropPage::OnApply();
}

BOOL CGlobalCertTemplateCSPPage::CSPDoesntExist(LPWSTR pwszCSPName)
{
    LV_FINDINFO findInfo;

    findInfo.flags = LVFI_STRING;
    findInfo.psz = pwszCSPName;

    return ( ListView_FindItem(m_hwndCSPList, -1, &findInfo) == -1 );
}

void CGlobalCertTemplateCSPPage::OnAddButton()
{
    DWORD dwProvIndex;


    //
    // enumerate all the CSPs on the machine, and if they are not
    // already in the list, then add them.
    //
    for (dwProvIndex = 0; TRUE; dwProvIndex++)
    {
        BOOL fResult;
        LPWSTR pwszProvName;
        DWORD cbProvName;
        HCRYPTPROV hProv;
        DWORD dwProvType;

        cbProvName = 0;
        dwProvType = 0;

        if (!CryptEnumProvidersW(
                dwProvIndex,
                NULL,               // pdwReserved
                0,                  // dwFlags
                &dwProvType,
                NULL,               // pwszProvName,
                &cbProvName
                ) || 0 == cbProvName)
        {
            if (ERROR_NO_MORE_ITEMS != GetLastError())
            {
                // error
            }
            break;
        }

        if (NULL == (pwszProvName = (LPWSTR) new(WCHAR[cbProvName + 1])))
        {
            break;
        }

        if (!CryptEnumProvidersW(
                dwProvIndex,
                NULL,               // pdwReserved
                0,                  // dwFlags
                &dwProvType,
                pwszProvName,
                &cbProvName
                )) {
            delete[](pwszProvName);
            break;
        }

        if (CSPDoesntExist(pwszProvName))
        {
	        ListView_NewItem(m_hwndCSPList, ListView_GetItemCount(m_hwndCSPList), pwszProvName);
            m_bUpdate = TRUE;
            SetModified();
        }

        delete[](pwszProvName);
    }

    ListView_SetColumnWidth(m_hwndCSPList, 0, LVSCW_AUTOSIZE);
}

void CGlobalCertTemplateCSPPage::OnRemoveButton()
{
    int i;

    for (i=ListView_GetItemCount(m_hwndCSPList)-1; i>=0; i--)
    {
        if (ListView_GetItemState(m_hwndCSPList, i, LVIS_SELECTED) == LVIS_SELECTED)
        {
            ListView_DeleteItem(m_hwndCSPList, i);
            m_bUpdate = TRUE;
            SetModified();
        }
    }

    EnableWindow(GetDlgItem(m_hWnd, IDC_REMOVECSPS_BUTTON), FALSE);
}

void CGlobalCertTemplateCSPPage::OnSelChange(NMHDR * pNotifyStruct)
{
    BOOL fEmpty = (ListView_GetSelectedCount(m_hwndCSPList) == 0);

    EnableWindow(GetDlgItem(m_hWnd, IDC_REMOVECSPS_BUTTON), !fEmpty);
}

///////////////////////////////////////////
// CCertTemplateGeneralPage
/////////////////////////////////////////////////////////////////////////////
// CCertTemplateGeneralPage property page
CCertTemplateGeneralPage::CCertTemplateGeneralPage(HCERTTYPE hCertType, UINT uIDD)
    : CAutoDeletePropPage(uIDD), m_hCertType(hCertType)
{
    m_hConsoleHandle = NULL;
    m_bUpdate = FALSE;
    SetHelp(CAPESNPN_HELPFILENAME , g_aHelpIDs_IDD_CERTIFICATE_TEMPLATE_PROPERTIES_GENERAL_PAGE);
}

CCertTemplateGeneralPage::~CCertTemplateGeneralPage()
{
}

// replacement for DoDataExchange
BOOL CCertTemplateGeneralPage::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
//        m_cstrModuleName.FromWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
    }
    else
    {
//        m_cstrModuleName.ToWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
    }
    return TRUE;
}
// replacement for BEGIN_MESSAGE_MAP
BOOL CCertTemplateGeneralPage::OnCommand(WPARAM wParam, LPARAM lParam)
{
/*
    switch(LOWORD(wParam))
    {
    default:
        return FALSE;
        break;
    }
    */
    return TRUE;
}
/////////////////////////////////////////////////////////////////////////////
// CCertTemplateGeneralPage message handlers

void CCertTemplateGeneralPage::OnDestroy()
{
    // Note - This needs to be called only once.
    // If called more than once, it will gracefully return an error.
    if (m_hConsoleHandle)
        MMCFreeNotifyHandle(m_hConsoleHandle);
    m_hConsoleHandle = NULL;

    CAutoDeletePropPage::OnDestroy();
}


void CCertTemplateGeneralPage::SetItemTextWrapper(UINT nID, int *piItem, BOOL fDoInsert, BOOL *pfFirstUsageItem)
{
    CString szOtherInfoName;

    if (fDoInsert)
    {
        szOtherInfoName.LoadString(nID);
        if (!(*pfFirstUsageItem))
        {
	        ListView_NewItem(m_hwndOtherInfoList, *piItem, L"");
        }
        else
        {
            *pfFirstUsageItem = FALSE;
        }

        ListView_SetItemText(m_hwndOtherInfoList, *piItem, 1, (LPWSTR)(LPCWSTR)szOtherInfoName);
        (*piItem)++;
    }
}

BOOL CCertTemplateGeneralPage::OnInitDialog()
{
    // does parent init and UpdateData call
    CAutoDeletePropPage::OnInitDialog();

    m_hwndPurposesList = GetDlgItem(m_hWnd, IDC_PURPOSE_LIST);
    m_hwndOtherInfoList = GetDlgItem(m_hWnd, IDC_OTHER_INFO_LIST);

    int                 i=0;
    CString             **aszUsages = NULL;
    DWORD               cNumUsages;
    WCHAR               **pszNameArray = NULL;
    CString             szOtherInfoName;
    CRYPT_BIT_BLOB      *pBitBlob;
    BOOL                fPublicKeyUsageCritical;
    BOOL                bKeyUsageFirstItem = TRUE;
    BOOL                fCA;
    BOOL                fPathLenConstraint;
    DWORD               dwPathLenConstraint;
    WCHAR               szNumberString[256];
    CString             szAll;
    BOOL                fEKUCritical;
    DWORD               dwFlags;
    HRESULT             hr;

    //
    // get the name of the certificate template and set it in the dialog
    //
    if((S_OK == CAGetCertTypeProperty(m_hCertType, CERTTYPE_PROP_FRIENDLY_NAME, &pszNameArray)) &&
        (pszNameArray != NULL))
    {
        SendMessage(GetDlgItem(m_hWnd, IDC_CERTIFICATE_TEMPLATE_NAME), EM_SETSEL, 0, -1);
        SendMessage(GetDlgItem(m_hWnd, IDC_CERTIFICATE_TEMPLATE_NAME), EM_REPLACESEL, FALSE, (LPARAM)(LPCWSTR)pszNameArray[0]);
        CAFreeCertTypeProperty(m_hCertType, pszNameArray);
    }

    //
    // get the list of purposes for this certificate template and
    // add all of them to the list in the dialog
    //
    ListView_NewColumn(m_hwndPurposesList, 0, 200);

    if(!MyGetEnhancedKeyUsages(m_hCertType, NULL, &cNumUsages, &fEKUCritical, FALSE))
    {
        return FALSE;
    }

    if (cNumUsages == 0)
    {
        szAll.LoadString(IDS_ALL);
		ListView_NewItem(m_hwndPurposesList, i, szAll);
    }
    else
    {

        aszUsages = new CString*[cNumUsages];
        if(!aszUsages)
            return FALSE;

        if(!MyGetEnhancedKeyUsages(m_hCertType, aszUsages, &cNumUsages, &fEKUCritical, FALSE))
        {
            delete[] aszUsages;
            return FALSE;
        }

        for (i=0; i<(LONG)cNumUsages; i++)
        {
			ListView_NewItem(m_hwndPurposesList, i, *(aszUsages[i]));
            delete(aszUsages[i]);
        }

        delete[] aszUsages;
    }

    ListView_SetColumnWidth(m_hwndPurposesList, 0, LVSCW_AUTOSIZE);

    //
    // add the other certificate type info
    //

    ListView_NewColumn(m_hwndOtherInfoList, 0, 200);
    ListView_NewColumn(m_hwndOtherInfoList, 1, 200);

    //
    // add include email address flag to other certificate type info
    //
    szOtherInfoName.LoadString(IDS_INCLUDE_EMAIL_ADDRESS);

    i = 0;
	ListView_NewItem(m_hwndOtherInfoList, i, szOtherInfoName);

    hr = CAGetCertTypeFlags(m_hCertType, &dwFlags);
    if (FAILED(hr))
    {
        return FALSE;
    }

    if (dwFlags & CT_FLAG_ADD_EMAIL)
        szOtherInfoName.LoadString(IDS_YES);
    else
        szOtherInfoName.LoadString(IDS_NO);

    ListView_SetItemText(m_hwndOtherInfoList, i++, 1, (LPWSTR)(LPCWSTR)szOtherInfoName);

    //
    // add key usages to other certificate type info
    //

    if (MyGetKeyUsages(m_hCertType, &pBitBlob, &fPublicKeyUsageCritical))
    {
        szOtherInfoName.LoadString(IDS_PUBLIC_KEY_USAGE_LIST);
		ListView_NewItem(m_hwndOtherInfoList, i, szOtherInfoName);


        if (pBitBlob->cbData >= 1)
        {
            SetItemTextWrapper(
                    IDS_DIGITAL_SIGNATURE_KEY_USAGE,
                    &i,
                    pBitBlob->pbData[0] & CERT_DIGITAL_SIGNATURE_KEY_USAGE,
                    &bKeyUsageFirstItem);

            SetItemTextWrapper(
                    IDS_NON_REPUDIATION_KEY_USAGE,
                    &i,
                    pBitBlob->pbData[0] & CERT_NON_REPUDIATION_KEY_USAGE,
                    &bKeyUsageFirstItem);

            SetItemTextWrapper(
                    IDS_KEY_ENCIPHERMENT_KEY_USAGE,
                    &i,
                    pBitBlob->pbData[0] & CERT_KEY_ENCIPHERMENT_KEY_USAGE,
                    &bKeyUsageFirstItem);

            SetItemTextWrapper(
                    IDS_DATA_ENCIPHERMENT_KEY_USAGE,
                    &i,
                    pBitBlob->pbData[0] & CERT_DATA_ENCIPHERMENT_KEY_USAGE,
                    &bKeyUsageFirstItem);

            SetItemTextWrapper(
                    IDS_KEY_AGREEMENT_KEY_USAGE,
                    &i,
                    pBitBlob->pbData[0] & CERT_KEY_AGREEMENT_KEY_USAGE,
                    &bKeyUsageFirstItem);

            SetItemTextWrapper(
                    IDS_KEY_CERT_SIGN_KEY_USAGE,
                    &i,
                    pBitBlob->pbData[0] & CERT_KEY_CERT_SIGN_KEY_USAGE,
                    &bKeyUsageFirstItem);

           SetItemTextWrapper(
                    IDS_OFFLINE_CRL_SIGN_KEY_USAGE,
                    &i,
                    pBitBlob->pbData[0] & CERT_OFFLINE_CRL_SIGN_KEY_USAGE,
                    &bKeyUsageFirstItem);

           SetItemTextWrapper(
                    IDS_ENCIPHER_ONLY_KEY_USAGE,
                    &i,
                    pBitBlob->pbData[0] & CERT_ENCIPHER_ONLY_KEY_USAGE,
                    &bKeyUsageFirstItem);
        }

        if (pBitBlob->cbData >= 2)
        {
            SetItemTextWrapper(
                    IDS_DECIPHER_ONLY_KEY_USAGE,
                    &i,
                    pBitBlob->pbData[1] & CERT_DECIPHER_ONLY_KEY_USAGE,
                    &bKeyUsageFirstItem);
        }

        szOtherInfoName.LoadString(IDS_PUBLIC_KEY_USAGE_CRITICAL);
		ListView_NewItem(m_hwndOtherInfoList, i, szOtherInfoName);


        if (fPublicKeyUsageCritical)
            szOtherInfoName.LoadString(IDS_YES);
        else
            szOtherInfoName.LoadString(IDS_NO);
        ListView_SetItemText(m_hwndOtherInfoList, i++, 1, (LPWSTR)(LPCWSTR)szOtherInfoName);

        delete[]((BYTE *)pBitBlob);
    }

    //
    // maybe we should add a display of whether this is a ca cert or not
    //
/*
    if (MyGetBasicConstraintInfo(m_hCertType, &fCA, &fPathLenConstraint, &dwPathLenConstraint))
    {

    }
*/

    ListView_SetColumnWidth(m_hwndOtherInfoList, 0, LVSCW_AUTOSIZE);
    ListView_SetColumnWidth(m_hwndOtherInfoList, 1, LVSCW_AUTOSIZE);

    return TRUE;
}

BOOL CCertTemplateGeneralPage::OnApply()
{
	DWORD dwRet;

    if (m_bUpdate == TRUE)
    {
        m_bUpdate = FALSE;
    }
	
    return CAutoDeletePropPage::OnApply();
}




/////////////////////////////////////////////////////////////////////////////
// CCertTemplateSelectDialog property page
CCertTemplateSelectDialog::CCertTemplateSelectDialog(HWND hParent) :
    m_hCAInfo(NULL)
{
     SetHelp(CAPESNPN_HELPFILENAME , g_aHelpIDs_IDD_SELECT_CERTIFICATE_TEMPLATE);

}

CCertTemplateSelectDialog::~CCertTemplateSelectDialog()
{
}

// replacement for DoDataExchange
BOOL CCertTemplateSelectDialog::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
//        m_cstrModuleName.FromWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
    }
    else
    {
//        m_cstrModuleName.ToWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
    }
    return TRUE;
}
// replacement for BEGIN_MESSAGE_MAP
BOOL CCertTemplateSelectDialog::OnCommand(WPARAM wParam, LPARAM lParam)
{
/*
    switch(LOWORD(wParam))
    {
    default:
        return FALSE;
        break;
    }
    */
    return TRUE;
}

BOOL CCertTemplateSelectDialog::OnNotify(UINT idCtrl, NMHDR* pnmh)
{
    switch(idCtrl)
    {
    case IDC_CERTIFICATE_TYPE_LIST:
        if (LVN_ITEMCHANGED == pnmh->code)
        {
            OnSelChange(pnmh);
            break;
        }
        else if (NM_DBLCLK == pnmh->code)
        {
            SendMessage(m_hDlg, WM_COMMAND, IDOK, NULL);
            break;
        }
    default:
        return FALSE;
    }

    return TRUE;
}

BOOL CertTypeAlreadyExists(WCHAR *szCertTypeName, WCHAR **aszCertTypesCurrentlySupported)
{
    int i = 0;

    //
    // if there are no cert types then obvisously this one doesn't already exist
    //
    if (aszCertTypesCurrentlySupported == NULL)
    {
        return FALSE;
    }

    while (aszCertTypesCurrentlySupported[i] != NULL)
    {
        if (wcscmp(szCertTypeName, aszCertTypesCurrentlySupported[i]) == 0)
        {
            return TRUE;
        }
        i++;
    }

    return FALSE;
}

/////////////////////////////////////////////////////////////////////
void CCertTemplateSelectDialog::SetHelp(LPCTSTR szHelpFile, const DWORD rgzHelpIDs[])
	{
	//szHelpFile == NULL;	// TRUE => No help file supplied (meaning no help)
	//rgzHelpIDs == NULL;	// TRUE => No help at all
	m_strHelpFile = szHelpFile;
	m_prgzHelpIDs = rgzHelpIDs;
	}

/////////////////////////////////////////////////////////////////////
void CCertTemplateSelectDialog::OnContextHelp(HWND hwnd)
{
    if (m_prgzHelpIDs == NULL || m_strHelpFile.IsEmpty())
        return;
    ASSERT(IsWindow(hwnd));
    ::WinHelp(hwnd, m_strHelpFile, HELP_CONTEXTMENU, (ULONG_PTR)(LPVOID)m_prgzHelpIDs);
    return;
}

/////////////////////////////////////////////////////////////////////
void CCertTemplateSelectDialog::OnHelp(LPHELPINFO pHelpInfo)
{
    if (m_prgzHelpIDs == NULL || m_strHelpFile.IsEmpty())
        return;
    if (pHelpInfo != NULL && pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        // Display context help for a control
        ::WinHelp((HWND)pHelpInfo->hItemHandle, m_strHelpFile,
            HELP_WM_HELP, (ULONG_PTR)(LPVOID)m_prgzHelpIDs);
    }
    return;
}

int CALLBACK CertTemplCompareFunc(
    LPARAM lParam1, 
    LPARAM lParam2, 
	LPARAM lParamSort)
{
    BOOL fSortAscending = (BOOL)lParamSort;
    HCERTTYPE hCertTypeLeft = (HCERTTYPE)lParam1;
    HCERTTYPE hCertTypeRight = (HCERTTYPE)lParam2;
    WCHAR ** ppwszFriendlyNameLeft = NULL;
    WCHAR ** ppwszFriendlyNameRight = NULL;
    int nRet;

    CAGetCertTypeProperty(
            hCertTypeLeft,
            CERTTYPE_PROP_FRIENDLY_NAME,
            &ppwszFriendlyNameLeft);

    CAGetCertTypeProperty(
            hCertTypeRight,
            CERTTYPE_PROP_FRIENDLY_NAME,
            &ppwszFriendlyNameRight);


    if(!ppwszFriendlyNameLeft ||  
       !ppwszFriendlyNameLeft[0] ||
       !ppwszFriendlyNameRight ||  
       !ppwszFriendlyNameRight[0])
       return 0; // couldn't figure it out

    nRet = wcscmp(ppwszFriendlyNameLeft[0], ppwszFriendlyNameRight[0]);

    CAFreeCertTypeProperty(
            hCertTypeLeft,
            ppwszFriendlyNameLeft);

    CAFreeCertTypeProperty(
            hCertTypeRight,
            ppwszFriendlyNameRight);

    return nRet;
}


/////////////////////////////////////////////////////////////////////////////
// CCertTemplateSelectDialog message handlers
BOOL CCertTemplateSelectDialog::OnInitDialog(HWND hDlg)
{
    // does parent init and UpdateData call
    m_hwndCertTypeList = GetDlgItem(hDlg, IDC_CERTIFICATE_TYPE_LIST);

    CString             szColumnHeading;
    HRESULT             hr;
    HCERTTYPE           hCertTypeNext;
    HCERTTYPE           hCertTypePrev;
    WCHAR **            aszCertTypeName;
    WCHAR **            aszCertTypeCN;
    int                 i = 0;
    CString             szUsageString;
    DWORD               dwVersion;

    m_hDlg = hDlg;

    ::SetWindowLong(m_hDlg, GWL_EXSTYLE, ::GetWindowLong(m_hDlg, GWL_EXSTYLE) | WS_EX_CONTEXTHELP);

    hr = RetrieveCATemplateList(
            m_hCAInfo,
            m_TemplateList);
    if(S_OK != hr)
    {
        myDisplayError(hDlg, hr, IDS_CERTTYPE_INFO_FAIL);
        return TRUE;
    }

    HIMAGELIST hImgList = ImageList_LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_16x16), 16, 1, RGB(255, 0, 255));
    ListView_SetImageList(m_hwndCertTypeList, hImgList, LVSIL_SMALL);


    szColumnHeading.LoadString(IDS_COLUMN_NAME);
    ListView_NewColumn(m_hwndCertTypeList, 0, 200, szColumnHeading);


    szColumnHeading.LoadString(IDS_COLUMN_INTENDED_PURPOSE);
    ListView_NewColumn(m_hwndCertTypeList, 1, 200, szColumnHeading);

    hr = CAEnumCertTypes(CT_ENUM_USER_TYPES |
                         CT_ENUM_MACHINE_TYPES |
                         CT_FLAG_NO_CACHE_LOOKUP,
                         &hCertTypeNext
                         );
    // display error in getting 1st element
    if (hr != S_OK)
    {
        myDisplayError(hDlg, hr, -1);
    }
    else if (hCertTypeNext == NULL)
    {
        myDisplayError(hDlg, S_OK, IDS_NO_TEMPLATES);
    }

    while ((hCertTypeNext != NULL) && (!FAILED(hr)))
    {
        //
        // get the CN of the cert type being processed, and if it already
        // exists in the list of currently supported types then move on
        // to the next one
        //
        hr = CAGetCertTypeProperty(
                    hCertTypeNext,
                    CERTTYPE_PROP_DN,
                    &aszCertTypeCN);

        if(hr == S_OK)
        {

            hr = CAGetCertTypePropertyEx (
                hCertTypeNext,
                CERTTYPE_PROP_SCHEMA_VERSION,
                &dwVersion);

            if(S_OK == hr &&
               (m_fAdvancedServer || dwVersion==CERTTYPE_SCHEMA_VERSION_1))
            {

                if((aszCertTypeCN != NULL) &&
                    (aszCertTypeCN[0] != NULL) &&
                   (_wcsicmp(aszCertTypeCN[0], wszCERTTYPE_CA) != 0) &&
                   (!m_TemplateList.TemplateExistsName(aszCertTypeCN[0])))
                {
                    //
                    // the cert type is not already supported so add it to the list of choices
                    //
                    CAGetCertTypeProperty(
                            hCertTypeNext,
                            CERTTYPE_PROP_FRIENDLY_NAME,
                            &aszCertTypeName);

                    GetIntendedUsagesString(hCertTypeNext, &szUsageString);
                    if (szUsageString == L"")
                    {
                        szUsageString.LoadString(IDS_ALL);
                    }

                    LVITEM lvItem;
                    lvItem.mask = LVIF_IMAGE | LVIF_TEXT;
                    lvItem.iImage = 2; // nImage - the certificate template image is #2
                    lvItem.iSubItem = 0;
                    lvItem.pszText = aszCertTypeName[0];
				    lvItem.iItem = ListView_NewItem(m_hwndCertTypeList, i, aszCertTypeName[0], (LPARAM)hCertTypeNext);
				    ListView_SetItem(m_hwndCertTypeList, &lvItem);	// set other attribs

                    ListView_SetItemText(m_hwndCertTypeList, i++, 1, (LPWSTR)(LPCTSTR)szUsageString);

                    CAFreeCertTypeProperty(
                            hCertTypeNext,
                            aszCertTypeName);
                }
            }

            CAFreeCertTypeProperty(
                        hCertTypeNext,
                        aszCertTypeCN);
        }

        hCertTypePrev = hCertTypeNext;
        hCertTypeNext = NULL;
        hr = CAEnumNextCertType(hCertTypePrev, &hCertTypeNext);
    }

    ListView_SetColumnWidth(m_hwndCertTypeList, 0, LVSCW_AUTOSIZE);
    ListView_SetColumnWidth(m_hwndCertTypeList, 1, LVSCW_AUTOSIZE);

    ListView_SortItems(m_hwndCertTypeList, CertTemplCompareFunc, TRUE);

    UpdateData(FALSE);
    return TRUE;
}

void CCertTemplateSelectDialog::OnDestroy()
{
    int         i = 0;
    int         iCount = ListView_GetItemCount(m_hwndCertTypeList);


    for (i=0; i<iCount; i++)
    {
        HCERTTYPE hCT = (HCERTTYPE)ListView_GetItemData(m_hwndCertTypeList, i);
        CACloseCertType(hCT);
    }

    //
    // does this actually need to be done?
    //
    //(m_CertTypeCListCtrl.GetImageList(LVSIL_SMALL))->DeleteImageList();
}

void CCertTemplateSelectDialog::OnSelChange(NMHDR * pNotifyStruct/*, LRESULT * result*/)
{
    LPNMLISTVIEW        pListItem = (LPNMLISTVIEW) pNotifyStruct;

    if (pListItem->uNewState & LVIS_SELECTED)
    {
    }
}


void CCertTemplateSelectDialog::OnOK()
{
    int         i;
    HRESULT     hr;
    UINT        cSelectedItems;
    HCERTTYPE   hSelectedCertType;
    int         itemIndex;

    cSelectedItems = ListView_GetSelectedCount(m_hwndCertTypeList);

    if (cSelectedItems != 0)
    {
        //
        // get each selected item and add its cert type to the array
        //
        itemIndex = ListView_GetNextItem(m_hwndCertTypeList, -1, LVNI_ALL | LVNI_SELECTED);
        while (itemIndex != -1)
        {
			HCERTTYPE hCT = (HCERTTYPE)ListView_GetItemData(m_hwndCertTypeList, itemIndex);
            hr = AddToCATemplateList(m_hCAInfo, m_TemplateList, hCT);
            if(FAILED(hr))
                return;
            itemIndex = ListView_GetNextItem(m_hwndCertTypeList, itemIndex, LVNI_ALL | LVNI_SELECTED);
        }

        hr = UpdateCATemplateList(m_hCAInfo, m_TemplateList);
        if (FAILED(hr))
        {
            MyErrorBox(m_hDlg, IDS_FAILED_CA_UPDATE ,IDS_SNAPIN_NAME, hr);

            // Set the old values back.
            itemIndex = ListView_GetNextItem(m_hwndCertTypeList, -1, LVNI_ALL | LVNI_SELECTED);
            while (itemIndex != -1)
            {
				HCERTTYPE hCT = (HCERTTYPE)ListView_GetItemData(m_hwndCertTypeList, itemIndex);
                RemoveFromCATemplateList(m_hCAInfo, m_TemplateList, hCT);

                itemIndex = ListView_GetNextItem(m_hwndCertTypeList, itemIndex, LVNI_ALL | LVNI_SELECTED);
            }
        }
    }
}


void CCertTemplateSelectDialog::SetCA(HCAINFO hCAInfo, bool fAdvancedServer)
{
    m_hCAInfo = hCAInfo;
    m_fAdvancedServer = fAdvancedServer;
}


INT_PTR SelectCertTemplateDialogProc(
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    CCertTemplateSelectDialog* pParam;

    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
            // remember PRIVATE_DLGPROC_QUERY_LPARAM
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, lParam);
            pParam = (CCertTemplateSelectDialog*)lParam;

			return pParam->OnInitDialog(hwndDlg);
			break;
        }
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
			pParam = (CCertTemplateSelectDialog*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
			if (pParam == NULL)
				break;
			pParam->OnOK();
            EndDialog(hwndDlg, LOWORD(wParam));
			break;

        case IDCANCEL:
			pParam = (CCertTemplateSelectDialog*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
			if (pParam == NULL)
				break;
			//pParam->OnCancel();
            EndDialog(hwndDlg, LOWORD(wParam));
            break;
        default:
			pParam = (CCertTemplateSelectDialog*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
			if (pParam == NULL)
				break;
			return pParam->OnCommand(wParam, lParam);
            break;
        }
	case WM_NOTIFY:
		pParam = (CCertTemplateSelectDialog*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
		if (pParam == NULL)
			break;
		return pParam->OnNotify((int)wParam, (NMHDR*)lParam);
		break;

	case WM_DESTROY:
		pParam = (CCertTemplateSelectDialog*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
		if (pParam == NULL)
			break;
		pParam->OnDestroy();
		break;
    case WM_HELP:
    {
        pParam = (CCertTemplateSelectDialog*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
        if (pParam == NULL)
            break;
        pParam->OnHelp((LPHELPINFO) lParam);
        break;
    }
    case WM_CONTEXTMENU:
    {
        pParam = (CCertTemplateSelectDialog*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
        if (pParam == NULL)
            break;
        pParam->OnContextHelp((HWND)wParam);
        break;
    }
    default:
        break;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\capesnpn\misc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       misc.h
//
//--------------------------------------------------------------------------

#ifndef __MISC_H_
#define __MISC_H_


// count the number of bytes needed to fully store the WSZ
#define WSZ_BYTECOUNT(__z__)   \
    ( (__z__ == NULL) ? 0 : (wcslen(__z__)+1)*sizeof(WCHAR) )


#define IDM_NEW_CERTTYPE 1
#define IDM_EDIT_GLOBAL_CERTTYPE 2
#define IDM_MANAGE 3

LPCWSTR GetNullMachineName(CString* pcstr);

BOOL StringFromDurationUnit(DWORD dwExpirationUnits, CString* pcstr, BOOL fLocalized);

STDMETHODIMP CStringLoad(CString& cstr, IStream *pStm);
STDMETHODIMP CStringSave(CString& cstr, IStream *pStm, BOOL fClearDirty);

void DisplayGenericCertSrvError(LPCONSOLE2 pConsole, DWORD dwErr);
LPWSTR BuildErrorMessage(DWORD dwErr);
BOOL FileTimeToLocalTimeString(FILETIME* pftGMT, LPWSTR* ppszTmp);

BOOL MyGetEnhancedKeyUsages(HCERTTYPE hCertType, CString **aszUsages, DWORD *cUsages, BOOL *pfCritical, BOOL fGetOIDSNotNames);
BOOL GetIntendedUsagesString(HCERTTYPE hCertType, CString *pUsageString);
BOOL MyGetKeyUsages(HCERTTYPE hCertType, CRYPT_BIT_BLOB **ppBitBlob, BOOL *pfPublicKeyUsageCritical);
BOOL MyGetBasicConstraintInfo(HCERTTYPE hCertType, BOOL *pfCA, BOOL *pfPathLenConstraint, DWORD *pdwPathLenConstraint);

LPSTR MyMkMBStr(LPCWSTR pwsz);
LPWSTR MyMkWStr(LPCSTR psz);

void MyErrorBox(HWND hwndParent, UINT nIDText, UINT nIDCaption, DWORD dwErrorCode = 0);

LPSTR AllocAndCopyStr(LPCSTR psz);
LPWSTR AllocAndCopyStr(LPCWSTR pwsz);
BOOL MyGetOIDInfo(LPWSTR string, DWORD stringSize, LPSTR pszObjId);


#define WIZ_DEFAULT_SD L"O:DAG:DAD:(A;;0x00000001;;;DA)"

#define REGSZ_ENABLE_CERTTYPE_EDITING L"EnableCertTypeEditing"

typedef struct _WIZARD_HELPER{
    // KeyUsage
    CRYPT_BIT_BLOB                  *pKeyUsage;
    BYTE                            KeyUsageBytes[2];
    BOOL                            fMarkKeyUsageCritical;
    
    // EnhancedKeyUsage
    CERT_ENHKEY_USAGE               EnhancedKeyUsage;
    BOOL                            fMarkEKUCritical;

    // Basic Constraints
    CERT_BASIC_CONSTRAINTS2_INFO    BasicConstraints2;
   
    // other cert type info
    CString*                        pcstrFriendlyName;
    BOOL                            fIncludeEmail;
    BOOL                            fAllowAutoEnroll;
    BOOL                            fAllowCAtoFillInInfo;
    BOOL                            fMachine;
    BOOL                            fPublishToDS;
    BOOL                            fAddTemplateName;
    BOOL                            fAddDirectoryPath;

    // CSP info
    BOOL                            fPrivateKeyExportable;
    BOOL                            fDigitalSignatureContainer;
    BOOL                            fKeyExchangeContainer;
    CString*                        rgszCSPList;
    DWORD                           cCSPs;
    
    // page control varaibles
    BOOL                            fShowAdvanced;
    BOOL                            fBaseCertTypeUsed;
    BOOL                            fInEditCertTypeMode;
    BOOL                            fCleanupOIDCheckBoxes;
    CString*                        pcstrBaseCertName;

    // fonts
    CFont                           BigBoldFont;
    CFont                           BoldFont;

    // ACL's
    PSECURITY_DESCRIPTOR            pSD;


    BOOL                            fKeyUsageInitialized;
} WIZARD_HELPER, *PWIZARD_HELPER;




BOOL  IsCerttypeEditingAllowed();

HRESULT RetrieveCATemplateList(
    HCAINFO hCAInfo,
    CTemplateList& list);

HRESULT UpdateCATemplateList(
    HCAINFO hCAInfo,
    const CTemplateList& list);

HRESULT AddToCATemplateList(
    HCAINFO hCAInfo,
    CTemplateList& list,
    HCERTTYPE hCertType);

HRESULT RemoveFromCATemplateList(
    HCAINFO hCAInfo,
    CTemplateList& list,
    HCERTTYPE hCertType);


#endif //__MISC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\capesnpn\service.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include "stdafx.h"


CFolder::~CFolder()
{ 

    if (m_pScopeItem)
    {
        delete m_pScopeItem; 
    }
    CoTaskMemFree(m_pszName); 

    if (m_hCertType != NULL)
    {
        CACloseCertType(m_hCertType);
    }
    // dont close the m_hCAInfo if this is a result folder, it is the same as the scope folders m_hCAInfo
    else if (m_hCAInfo != NULL)
    {
        CACloseCA(m_hCAInfo);
    }
}

void CFolder::Create(LPCWSTR szName, int nImage, int nOpenImage, SCOPE_TYPES itemType,
                                FOLDER_TYPES type, BOOL bHasChildren)
{
    ASSERT(m_pScopeItem == NULL); // Calling create twice on this item?

    // Two-stage construction
    m_pScopeItem = new SCOPEDATAITEM;
    if(m_pScopeItem == NULL)
    {
        return;
    }

    ZeroMemory(m_pScopeItem, sizeof(SCOPEDATAITEM));

    // Set folder type 
    m_type = type;

    // Set scope
    m_itemType = itemType;


    // Add node name
    if (szName != NULL)
    {
        m_pScopeItem->mask = SDI_STR;
    	m_pScopeItem->displayname = (unsigned short*)(-1);
        
        UINT uiByteLen = (wcslen(szName) + 1) * sizeof(OLECHAR);
        LPOLESTR psz = (LPOLESTR)::CoTaskMemAlloc(uiByteLen);
    
        if (psz != NULL)
        {
            wcscpy(psz, szName);
            m_pszName = psz;
        }
    }

    // Add close image
    if (nImage != 0)
    {
        m_pScopeItem->mask |= SDI_IMAGE;
        m_pScopeItem->nImage = nImage;
    }

    // Add open image
    if (nOpenImage != 0)
    {
        m_pScopeItem->mask |= SDI_OPENIMAGE;
        m_pScopeItem->nOpenImage = nOpenImage;
    }

    // Children value is valid
    m_pScopeItem->mask |= SDI_CHILDREN;
    
    // Add button to node if the folder has children
    if (bHasChildren == TRUE)
    {
        m_pScopeItem->cChildren = 1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\capesnpn\service.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#ifndef _SERVICE_H
#define _SERVICE_H

#include "certca.h"

// Forward declarations
class CSnapin;
class CFolder;

// Internal structure used for cookies
struct FOLDER_DATA
{
    wchar_t*    szName;
    wchar_t*    szSize;
    wchar_t*    szType;

    FOLDER_TYPES    type;
};

#define MAX_RESULTDATA_STRINGS 64

struct RESULT_DATA
{
    SCOPE_TYPES itemType; 
    CFolder*    pParentFolder;

    DWORD       cStringArray;
    LPWSTR      szStringArray[MAX_RESULTDATA_STRINGS];
};

enum 
{
    RESULTDATA_ARRAYENTRY_NAME =0,
    RESULTDATA_ARRAYENTRY_SIZE,
    RESULTDATA_ARRAYENTRY_TYPE,
};

class CFolder 
{
    SCOPE_TYPES  m_itemType;   // Used for debug purposes. This should be the first 
                            // member. The class should not have any virtual fuctions.

    friend class CSnapin;
    friend class CComponentDataImpl;

public:
    // UNINITIALIZED is an invalid memory address and is a good cookie initializer
    CFolder() 
    { 
        m_itemType = UNINITIALIZED_ITEM;  
        m_cookie = UNINITIALIZED; 
        m_enumed = FALSE; 
        m_pScopeItem = NULL; 
        m_type = NONE;
        m_pszName = NULL;
        m_hCAInfo = NULL;
        m_hCertType = NULL;
        m_dwSCEMode = 0;
        m_fGlobalCertType = FALSE;
        m_fMachineFolder = FALSE;
    }; 

    ~CFolder();

// Interface
public:
    BOOL IsEnumerated() { return  m_enumed; };
    void Set(BOOL state) { m_enumed = state; };
    void SetCookie(MMC_COOKIE cookie) { m_cookie = cookie; }
    FOLDER_TYPES GetType() { ASSERT(m_type != NONE); return m_type; };
    BOOL operator == (const CFolder& rhs) const { return rhs.m_cookie == m_cookie; };
    BOOL operator == (MMC_COOKIE cookie) const { return cookie == m_cookie; };
    void SetName(LPWSTR pszIn) 
    { 
        UINT len = wcslen(pszIn) + 1;
        LPWSTR psz = (LPWSTR)CoTaskMemAlloc(len * sizeof(WCHAR));
        if (psz != NULL)
        {
            wcscpy(psz, pszIn);
            CoTaskMemFree(m_pszName);
            m_pszName = psz;
        }
    }

// Implementation
private:
    void Create(
                LPCWSTR szName, 
                int nImage, 
                int nOpenImage,
                SCOPE_TYPES itemType,
                FOLDER_TYPES type, 
                BOOL bHasChildren = FALSE);

// Attributes
private:
    LPSCOPEDATAITEM     m_pScopeItem;
    MMC_COOKIE                m_cookie;
    BOOL                m_enumed;
    FOLDER_TYPES        m_type;
    LPOLESTR            m_pszName;
    CString             m_szCAName;
    CString             m_szIntendedUsages;
    HCAINFO             m_hCAInfo;
    HCERTTYPE           m_hCertType;
    DWORD               m_dwSCEMode;
    BOOL                m_fGlobalCertType;
    BOOL                m_fMachineFolder;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\capesnpn\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by snapin.rc
//
#define IDS_SNAPIN_DESC                 1
#define IDS_NAME                        2
#define IDS_COLUMN_NAME                 2
#define IDC_REMOVE_BUTTON               2
#define IDS_SIZE                        3
#define IDS_COLUMN_SIZE                 3
#define IDS_TYPE                        4
#define IDS_COLUMN_TYPE                 4
#define IDS_NODENAME                    5
#define IDS_COLUMN_INTENDED_PURPOSE     5
#define IDS_SCOPE_MYCOMPUTER            9
#define IDS_SCOPE_MYCOMPUTER_OVERRIDE   10
#define IDS_LOCALMACHINE                11
#define IDS_NODENAME_PREFIX             12
#define IDS_COLUMN_OTHER                13
#define IDS_COLUMN_DESCRIPTION          14
#define IDS_SNAPIN_NAME                 15
#define IDS_CERTIFICATE_TYPE            16
#define IDS_CERTIFICATE_TYPE_HINT       17
#define IDS_POLICYSETTINGS              18
#define IDS_INCLUDE_EMAIL_ADDRESS       19
#define IDS_PUBLIC_KEY_USAGE_LIST       20
#define IDS_PUBLIC_KEY_USAGE_CRITICAL   21
#define IDS_MAXIMUM_CHILD_CA_LEVELS     22
#define IDS_DIGITAL_SIGNATURE_KEY_USAGE 23
#define IDS_NON_REPUDIATION_KEY_USAGE   24
#define IDS_KEY_ENCIPHERMENT_KEY_USAGE  25
#define IDS_DATA_ENCIPHERMENT_KEY_USAGE 26
#define IDS_KEY_AGREEMENT_KEY_USAGE     27
#define IDS_KEY_CERT_SIGN_KEY_USAGE     28
#define IDS_OFFLINE_CRL_SIGN_KEY_USAGE  29
#define IDS_ENCIPHER_ONLY_KEY_USAGE     30
#define IDS_YES                         31
#define IDS_NO                          32
#define IDS_DECIPHER_ONLY_KEY_USAGE     33
#define IDS_NO_MAXIMUM                  34
#define IDS_SELECT_CERTIFICATE_TEMPLATE 35
#define IDS_ALL                         36
#define IDS_NEW_CERTIFICATE_TEMPLATE    37
#define IDS_CERTIFICATE_TEMPLATE        37
#define IDS_NEW_CERTIFICATE_TEMPLATE_HINT 38
#define IDS_CERTIFICATE_TEMPLATE_HINT   38
#define IDS_NO_TEMPLATES                39
#define IDS_MANAGETASK                  40
#define IDS_MANAGETASK_HINT             41

#define IDS_PERIOD_YEARS          	100
#define IDS_PERIOD_MONTHS         	101
#define IDD_NEWCERTTYPE_COMPLETION      101
#define IDS_PERIOD_WEEKS          	102
#define IDD_NEWCERTTYPE_TYPE            102
#define IDS_PERIOD_DAYS           	103
#define IDD_NEWCERTTYPE_INFORMATION     103
#define IDS_PERIOD_HOURS          	104
#define IDS_PERIOD_MINUTES        	105
#define IDD_NEWCERTTYPE_CONTROL         105
#define IDS_PERIOD_SECONDS        	106
#define IDD_NEWCERTTYPE_KEY_USAGE       106
#define IDD_GENERAL                     107
#define IDS_EDIT                        107
#define IDD_EXTENSION_PAGE              108
#define IDD_NEWCERTTYPE_CA_CERTIFICATE  108
#define IDS_EDIT_HINT                   108
#define IDD_POLICYSETTINGS_PROPPAGE1    109
#define IDS_CERTIFICATE_TEMPLATE_WIZARD 109
#define IDD_CERTSRV_PROPPAGE            110
#define IDD_CERTSRV_PROPPAGE2           110
#define IDD_CERTIFICATE_TEMPLATE_PROPERTIES_GENERAL_PAGE 110
#define IDS_LARGEFONTNAME               110
#define IDS_LARGEFONTSIZE               111
#define IDD_CERTSRV_PROPPAGE4           112
#define IDS_BASE_TYPE_TITLE             112
#define IDD_CERTSRV_PROPPAGE5           113
#define IDS_BASE_TYPE_SUB_TITLE         113
#define IDD_NEWCERTTYPE_CSP_SELECTION   113
#define IDD_CERTSRV_PROPPAGE3           114
#define IDS_BASIC_INFORMATION_TITLE     114
#define IDD_CRL_PROPPAGE                115
#define IDS_BASIC_INFORMATION_SUB_TITLE 115
#define IDS_ACCESS_CONTROL_TITLE        116
#define IDS_ACCESS_CONTROL_SUB_TITLE    117
#define IDS_KEY_USAGE_TITLE             118
#define IDS_KEY_USAGE_SUB_TITLE         119
#define IDS_CA_CERTIFICATE_TITLE        120
#define IDS_CA_CERTIFICATE_SUB_TITLE    121
#define IDS_NO_BASE_TYPE                122
#define IDS_CERTIFICATE_TEMPLATES       123
#define IDS_SNAPIN_NAME_FOR_GPT         124
#define IDS_NEW_CERTIFICATE_TEMPLATE2   126
#define IDS_BASE_CERTIFICATE_TEMPLATE   127
#define IDS_CERTIFICATE_PURPOSE_LIST    128
#define IDS_CERTIFICATE_PURPOSES_CRITICAL 129
#define IDS_NONE                        130
#define IDS_ALLOW_CA_TO_FILL_IN         131
#define IDS_ENTER_CERTTYPE_NAME         132
#define IDS_ERRORINOID                  133
#define IDS_DELETE_ERROR                135
#define IDS_FAILED_LINK_GPT             136
#define IDS_FAILED_TO_GET_GPT_REGKEY    137
#define IDS_UNABLE_TO_FIND_CA           138
#define IDS_CERTTYPE_INFO_FAIL          139
#define IDS_FAILED_CA_UPDATE            141
#define IDS_FAILED_TO_GET_IGPTUNKNOWN   142
#define IDS_FONTSIZE                    143
#define IDS_SMALLFONTNAME               144
#define IDS_SMALLFONTSIZE               145
#define IDS_CSP_PAGE_TITLE              146
#define IDS_CSP_PAGE_SUB_TITLE          147
#define IDS_NOSPECIALOID                148
#define IDS_ENABLED_FOR_AUTOENROLL      149
#define IDS_DLL_INSTALL_USAGE_TEXT      150
#define IDS_DLL_INSTALL_USAGE_TITLE     151
#define IDS_CERTTYPE_DESCRIPTION        152
#define IDS_CERTTYPE_VERSION            153
#define IDS_COMPANY                     154
#define IDS_CAPOLICY_DESCRIPTION        155
#define IDS_CAPOLICY_VERSION            156
#define IDC_NEW_FOLDER                  201
#define IDB_16x16                       202
#define IDC_EXT_STATIC                  202
#define IDC_ORGANIZATION                202
#define IDB_32x32                       203
#define IDC_EXT_TEXT                    203
#define IDC_ORGUNIT                     203
#define IDI_COMPUTER                    204
#define IDC_LOCALITY                    204
#define IDI_FOLDER                      205
#define IDC_CERTSRV_PROPPAGE_TAB1       205
#define IDC_STATE                       205
#define IDC_COUNTRY                     206
#define IDB_TOOLBAR1                    207
#define IDC_DESCRIPTION                 207
#define IDB_TOOLBAR2                    208
#define IDC_CANAME                      208
#define IDI_APPICON                     209
#define IDC_COUNTRY2                    209
#define IDB_SMALLBMP                    210
#define IDC_COUNTRY3                    210
#define IDB_LARGE                       211
#define IDC_COUNTRY4                    211
#define IDC_CA_HIERARCHY                211
#define IDR_MENU1                       212
#define IDC_BUTTON_INSTALLCERT          212
#define FILEEX_MENU                     213
#define IDC_BUTTON_VIEWCERT             213
#define FOLDEREX_MENU                   214
#define IDC_RADIO1                      214
#define IDC_RADIO2                      215
#define IDC_EDIT1                       216
#define IDC_EDIT_SHAREDFOLDER           216
#define IDC_DURATION_EDIT               216
#define IDC_BUTTON1                     217
#define IDC_UP_BUTTON                   217
#define IDB_COMPUTER_LARGE              218
#define IDC_EDIT2                       218
#define IDC_BUTTON4                     218
#define IDD_SELECT_CERTIFICATE_TEMPLATE 218
#define IDB_COMPUTER_SMALL              219
#define IDC_BUTTON5                     219
#define IDC_EDIT4                       219
#define IDC_EDIT_NUMUNITS               219
#define IDB_TOOLBAR_SVRMGR1             220
#define IDC_BUTTON2                     220
#define IDD_CERTIFICATE_TEMPLATE_ACCESS_CONTROL_PAGE 220
#define IDC_DOWN_BUTTON                 220
#define IDC_EDIT3                       221
#define IDB_USER_GROUP_BITMAP           221
#define IDD_NEWCERTTYPE_WELCOME         221
#define IDC_BUTTON3                     222
#define IDD_USER_PURPOSE                222
#define IDC_EDIT5                       223
#define IDC_EDIT_UNITS                  223
#define IDB_WIZ_WATERMARK               223
#define IDC_CHECK1                      224
#define IDB_WIZ_BANNER                  224
#define IDC_ALLOW_AUTOENROLL_CHECK      224
#define IDC_COMBO1                      225
#define IDD_GLOBAL_TEMPLATE_PROPERTIES  225
#define IDC_CHECK2                      226
#define IDD_ORDER_CSPS                  226
#define IDC_EDIT6                       227
#define IDI_CERT_TEMPLATE               227
#define IDC_COMBO_UNITS                 228
#define IDC_CHECK3                      229
#define IDC_EDIT_LASTUPDATE             230
#define IDC_CSP_NAME                    231
#define IDC_HASHALG                     232
#define IDC_EDIT_DATABASE_LOC           233
#define IDC_EDIT_LOG_LOC                234
#define IDC_DURATION_UNIT_COMBO         236
#define IDC_CERTIFICATE_TEMPLATE_NAME   237
#define IDC_PURPOSE_LIST                239
#define IDC_OTHER_INFO_LIST             240
#define IDC_CERTIFICATE_TYPE_LIST       240
#define IDC_USER_ACCESS_LIST            242
#define IDC_ADD_BUTTON                  243
#define IDC_SUMMARY_LIST                244
#define IDC_ACCESS_LIST                 245
#define IDC_CA_FILL_IN_CHECK            246
#define IDC_BOLB_STATIC_CA_CERTIFICATE  247
#define IDC_BOLD_STATIC_CA_CERTIFICATE  247
#define IDC_BOLB_STATIC_ACCESS_CONTROL  248
#define IDC_BOLD_STATIC_ACCESS_CONTROL  248
#define IDC_BOLB_STATIC_BASIC_INFORMATION 249
#define IDC_BOLD_STATIC_BASIC_INFORMATION 249
#define IDC_BOLB_STATIC_KEYUSAGE        250
#define IDC_BOLD_STATIC_KEYUSAGE        250
#define IDC_BOLB_STATIC_BASETYPE        251
#define IDC_BOLD_STATIC_BASETYPE        251
#define IDC_WELCOME_BIGBOLD_STATIC      252
#define IDC_WELCOM_BOLD_STATIC          253
#define IDC_COMPLETION_BIGBOLD_STATIC   254
#define IDC_CSP_LIST                    255
#define IDC_ADDCSPS_BUTTON              256
#define IDC_REMOVECSPS_BUTTON           257
#define IDC_ORDERED_CSP_LIST            259
#define IDB_SID_ICONS                   260
#define IDB_FOLDER_SMALL                261
#define IDB_FOLDER_LARGE                262
#define IDI_CERTIFICATION_AUTHORITY     263
#define IDI_CDP                         264
#define IDI_ENROLLMENT_SERVICE          265

#define IDC_BASE_CERT_TYPE_LIST         1001
#define IDC_VERIFY_SIGNATURE_CHECK      1002
#define IDC_CRITICAL_CHECK              1002
#define IDC_DIGITAL_SIGNATURE_CHECK     1002
#define IDC_ISSUE_CRL_CHECK             1003
#define IDC_INCLUDE_EMAIL_CHECK         1003
#define IDC_PREVENT_CHECK               1003
#define IDC_SPECIFY_MAX_CA_LEVELS_CHECK 1004
#define IDC_ADVANCED_OPTIONS_CHECK      1004
#define IDC_DATA_ENCRYPTION_CHECK       1004
#define IDC_NEW_PURPOSE_BUTTON          1005
#define IDC_MAX_CA_EDIT                 1006
#define IDC_CERTIFICATE_TEMPLATE_EDIT   1006
#define IDC_DIGSIG_RADIO                1006
#define IDC_KEYEX_RADIO                 1007
#define IDC_KEY_ENCRYPTION_CHECK        1009
#define IDC_ENCIPHER_ONLY_CHECK         1010
#define IDC_EXPORTABLE_CHECK            1010
#define IDC_KEY_AGREEMENT_CHECK         1011
#define IDC_DECIPHER_ONLY_CHECK         1012
#define IDC_KEYUSAGE_CRITICAL_CHECK     1013
#define IDC_MOVEUP_BUTTON               1016
#define IDC_MOVEDOWN_BUTTON             1018
#define IDC_ORDER_BUTTON                1018
#define IDR_CTSHELL                     1019
#define IDS_USER_TITLE_PUBLISHED_CERTS  1020
#define IDC_ADD_FROM_STORE              1021
#define IDC_ADD_FROM_FILE               1022
#define IDB_CERTIFICATE                 1023
#define IDC_CERT_LIST                   1024
#define IDS_CANT_SAVE_STORE             1025
#define IDS_CERTCOL_ISSUED_TO           1026
#define IDS_CERTCOL_ISSUED_BY           1027
#define IDS_CERTCOL_PURPOSES            1028
#define IDS_CERTCOL_EXP_DATE            1029
#define IDS_CERT_SAVE_FILTER            1030
#define IDS_OPEN_FILE_DLG_TITLE         1031
#define IDS_UNKNOWN_CERT_FILE_TYPE      1032
#define IDS_CONFIRM_DELETE_CERT         1033
#define IDS_CONFIRM_DELETE_CERTS        1034
#define IDS_REMOVE_CERT                 1035
#define IDS_SAVE_FILE_DLG_TITLE         1036
#define IDS_COPY_TO_FILE                1037
#define IDS_CANT_OPEN_STORE             1038
#define IDC_VIEW_CERT                   1039
#define IDC_REMOVE                      1040
#define IDC_COPY_TO_FILE                1041
#define IDS_DUPLICATE_CERT              1042
#define IDS_ADD_FROM_STORE              1043
#define IDD_CACERTS                     1044
#define IDS_NOT_AVAILABLE               1045
#define IDS_ANY                         1046
#define IDR_CASHELL                     1047
#define IDS_CCASHELLEXT_DESC            1048
#define IDS_CCTSHELLEXT_DESC            1049
#define IDS_MANAGE                      1050
#define IDS_OPEN                        1051
#define IDS_EXPORT                      1052
#define IDS_ASK_CONFIRM_DELETETEMPLATES 1053
#define IDS_TITLE_ASK_CONFIRM_DELETETEMPLATES 1054
#define IDS_ERROR_CANNOT_LOAD_TEMPLATES 1055

#define ID_TEST2_ITEM1                  32770
#define ID_TEST2_ITEM2                  32771
#define ID_TEST2_ITEM3                  32773
#define ID_TEST2_ITEM4_ITEMA            32774
#define ID_TEST2_ITEM4_ITEMB            32775
#define ID_TEST2_ITEM4_ITEMC            32776
#define ID_TEST2_ITEM5                  32777
#define ID_TEST2_COLOR1                 32779
#define ID_TEST2_COLOR2                 32780
#define ID_TEST2_COLOR3                 32781
#define ID_MENUITEM32782                32782
#define ID_MENUITEM32783                32783
#define ID_MENUITEM32784                32784
#define ID_MENUITEM32785                32785
#define ID_MENUITEM32786                32786

#define IDC_STATIC			(-1)

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        228
#define _APS_NEXT_COMMAND_VALUE         32787
#define _APS_NEXT_CONTROL_VALUE         260
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\capesnpn\stdafx.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\capesnpn\resstr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resstr.h
//
//--------------------------------------------------------------------------

    RESSTR(IDS_SNAPIN_DESC),
    RESSTR(IDS_NAME),
    RESSTR(IDS_COLUMN_NAME),
    RESSTR(IDS_SIZE),
    RESSTR(IDS_COLUMN_SIZE),
    RESSTR(IDS_TYPE),
    RESSTR(IDS_COLUMN_TYPE),
    RESSTR(IDS_NODENAME),
    RESSTR(IDS_COLUMN_INTENDED_PURPOSE),
    RESSTR(IDS_SCOPE_MYCOMPUTER),
    RESSTR(IDS_SCOPE_MYCOMPUTER_OVERRIDE),
    RESSTR(IDS_LOCALMACHINE),
    RESSTR(IDS_NODENAME_PREFIX),
    RESSTR(IDS_COLUMN_OTHER),
    RESSTR(IDS_COLUMN_DESCRIPTION),
    RESSTR(IDS_SNAPIN_NAME),
    RESSTR(IDS_CERTIFICATE_TYPE),
    RESSTR(IDS_CERTIFICATE_TYPE_HINT),
    RESSTR(IDS_POLICYSETTINGS),
    RESSTR(IDS_INCLUDE_EMAIL_ADDRESS),
    RESSTR(IDS_PUBLIC_KEY_USAGE_LIST),
    RESSTR(IDS_PUBLIC_KEY_USAGE_CRITICAL),
    RESSTR(IDS_MAXIMUM_CHILD_CA_LEVELS),
    RESSTR(IDS_DIGITAL_SIGNATURE_KEY_USAGE),
    RESSTR(IDS_NON_REPUDIATION_KEY_USAGE),
    RESSTR(IDS_KEY_ENCIPHERMENT_KEY_USAGE),
    RESSTR(IDS_DATA_ENCIPHERMENT_KEY_USAGE),
    RESSTR(IDS_KEY_AGREEMENT_KEY_USAGE),
    RESSTR(IDS_KEY_CERT_SIGN_KEY_USAGE),
    RESSTR(IDS_OFFLINE_CRL_SIGN_KEY_USAGE),
    RESSTR(IDS_ENCIPHER_ONLY_KEY_USAGE),
    RESSTR(IDS_YES),
    RESSTR(IDS_NO),
    RESSTR(IDS_DECIPHER_ONLY_KEY_USAGE),
    RESSTR(IDS_NO_MAXIMUM),
    RESSTR(IDS_SELECT_CERTIFICATE_TEMPLATE),
    RESSTR(IDS_ALL),
    RESSTR(IDS_NEW_CERTIFICATE_TEMPLATE),
    RESSTR(IDS_CERTIFICATE_TEMPLATE),
    RESSTR(IDS_NEW_CERTIFICATE_TEMPLATE_HINT),
    RESSTR(IDS_CERTIFICATE_TEMPLATE_HINT),
    RESSTR(IDS_NO_TEMPLATES),
    RESSTR(IDS_MANAGETASK),
    RESSTR(IDS_MANAGETASK_HINT),
    RESSTR(IDS_PERIOD_YEARS),
    RESSTR(IDS_PERIOD_MONTHS),
    RESSTR(IDS_PERIOD_WEEKS),
    RESSTR(IDS_PERIOD_DAYS),
    RESSTR(IDS_PERIOD_HOURS),
    RESSTR(IDS_PERIOD_MINUTES),
    RESSTR(IDS_PERIOD_SECONDS),
    RESSTR(IDS_EDIT),
    RESSTR(IDS_EDIT_HINT),
    RESSTR(IDS_CERTIFICATE_TEMPLATE_WIZARD),
    RESSTR(IDS_LARGEFONTNAME),
    RESSTR(IDS_LARGEFONTSIZE),
    RESSTR(IDS_BASE_TYPE_TITLE),
    RESSTR(IDS_BASE_TYPE_SUB_TITLE),
    RESSTR(IDS_BASIC_INFORMATION_TITLE),
    RESSTR(IDS_BASIC_INFORMATION_SUB_TITLE),
    RESSTR(IDS_ACCESS_CONTROL_TITLE),
    RESSTR(IDS_ACCESS_CONTROL_SUB_TITLE),
    RESSTR(IDS_KEY_USAGE_TITLE),
    RESSTR(IDS_KEY_USAGE_SUB_TITLE),
    RESSTR(IDS_CA_CERTIFICATE_TITLE),
    RESSTR(IDS_CA_CERTIFICATE_SUB_TITLE),
    RESSTR(IDS_NO_BASE_TYPE),
    RESSTR(IDS_CERTIFICATE_TEMPLATES),
    RESSTR(IDS_SNAPIN_NAME_FOR_GPT),
    RESSTR(IDS_NEW_CERTIFICATE_TEMPLATE2),
    RESSTR(IDS_BASE_CERTIFICATE_TEMPLATE),
    RESSTR(IDS_CERTIFICATE_PURPOSE_LIST),
    RESSTR(IDS_CERTIFICATE_PURPOSES_CRITICAL),
    RESSTR(IDS_NONE),
    RESSTR(IDS_ALLOW_CA_TO_FILL_IN),
    RESSTR(IDS_ENTER_CERTTYPE_NAME),
    RESSTR(IDS_ERRORINOID),
    RESSTR(IDS_DELETE_ERROR),
    RESSTR(IDS_FAILED_LINK_GPT),
    RESSTR(IDS_FAILED_TO_GET_GPT_REGKEY),
    RESSTR(IDS_UNABLE_TO_FIND_CA),
    RESSTR(IDS_CERTTYPE_INFO_FAIL),
    RESSTR(IDS_FAILED_CA_UPDATE),
    RESSTR(IDS_FAILED_TO_GET_IGPTUNKNOWN),
    RESSTR(IDS_FONTSIZE),
    RESSTR(IDS_SMALLFONTNAME),
    RESSTR(IDS_SMALLFONTSIZE),
    RESSTR(IDS_CSP_PAGE_TITLE),
    RESSTR(IDS_CSP_PAGE_SUB_TITLE),
    RESSTR(IDS_NOSPECIALOID),
    RESSTR(IDS_ENABLED_FOR_AUTOENROLL),
    RESSTR(IDS_DLL_INSTALL_USAGE_TEXT),
    RESSTR(IDS_DLL_INSTALL_USAGE_TITLE),
    RESSTR(IDS_CERTTYPE_DESCRIPTION),
    RESSTR(IDS_CERTTYPE_VERSION),
    RESSTR(IDS_COMPANY),
    RESSTR(IDS_CAPOLICY_DESCRIPTION),
    RESSTR(IDS_CAPOLICY_VERSION),
    RESSTR(IDS_USER_TITLE_PUBLISHED_CERTS),
    RESSTR(IDS_CANT_SAVE_STORE),
    RESSTR(IDS_CERTCOL_ISSUED_TO),
    RESSTR(IDS_CERTCOL_ISSUED_BY),
    RESSTR(IDS_CERTCOL_PURPOSES),
    RESSTR(IDS_CERTCOL_EXP_DATE),
    RESSTR(IDS_CERT_SAVE_FILTER),
    RESSTR(IDS_OPEN_FILE_DLG_TITLE),
    RESSTR(IDS_UNKNOWN_CERT_FILE_TYPE),
    RESSTR(IDS_CONFIRM_DELETE_CERT),
    RESSTR(IDS_CONFIRM_DELETE_CERTS),
    RESSTR(IDS_REMOVE_CERT),
    RESSTR(IDS_SAVE_FILE_DLG_TITLE),
    RESSTR(IDS_COPY_TO_FILE),
    RESSTR(IDS_CANT_OPEN_STORE),
    RESSTR(IDS_DUPLICATE_CERT),
    RESSTR(IDS_ADD_FROM_STORE),
    RESSTR(IDS_NOT_AVAILABLE),
    RESSTR(IDS_ANY),
    RESSTR(IDS_CCASHELLEXT_DESC),
    RESSTR(IDS_CCTSHELLEXT_DESC),
    RESSTR(IDS_MANAGE),
    RESSTR(IDS_OPEN),
    RESSTR(IDS_EXPORT),
    RESSTR(IDS_ASK_CONFIRM_DELETETEMPLATES),
    RESSTR(IDS_TITLE_ASK_CONFIRM_DELETETEMPLATES),
    RESSTR(IDS_ERROR_CANNOT_LOAD_TEMPLATES),
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\capesnpn\snapin.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this 
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f Snapinps.mak in the project directory.

#include "stdafx.h"

#define myHLastError GetLastError
#include "csresstr.h"

CComModule _Module;
HINSTANCE  g_hInstance = NULL;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CAPolicyExtensionSnapIn, CComponentDataPolicySettings)
    OBJECT_ENTRY(CLSID_CACertificateTemplateManager, CComponentDataGPEExtension)
	OBJECT_ENTRY(CLSID_CAPolicyAbout, CCAPolicyAboutImpl)
	OBJECT_ENTRY(CLSID_CertTypeAbout, CCertTypeAboutImpl)
	OBJECT_ENTRY(CLSID_CertTypeShellExt, CCertTypeShlExt)
	OBJECT_ENTRY(CLSID_CAShellExt, CCAShellExt)
END_OBJECT_MAP()


STDAPI UnregisterGPECertTemplates(void);


BOOL WINAPI DllMain(  
    HINSTANCE hinstDLL,  // handle to DLL module
    DWORD dwReason,     // reason for calling function
    LPVOID lpvReserved)
{
    switch (dwReason)
    {
    case  DLL_PROCESS_ATTACH:
    {
        g_hInstance = hinstDLL;
	myVerifyResourceStrings(hinstDLL);
        _Module.Init(ObjectMap, hinstDLL);

        DisableThreadLibraryCalls(hinstDLL);
        break;
    }
    case DLL_PROCESS_DETACH:
    {
        _Module.Term();

        DEBUG_VERIFY_INSTANCE_COUNT(CSnapin);
        DEBUG_VERIFY_INSTANCE_COUNT(CComponentDataImpl);
        break;
    }

    default:
        break;
    }
    
    return TRUE;
}




/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (_Module.GetLockCount() == 0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT hResult = S_OK;
    CString cstrSubKey;
    DWORD   dwDisp;
    LONG    lResult;
    HKEY    hKey;
    CString cstrSnapInKey;
    CString cstrCAPolicyAboutKey;
    CString cstrSnapInName;
    LPWSTR pszTmp;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cstrSnapInName.LoadString(IDS_SNAPIN_NAME);

    // be sure this is alloced
    if (NULL == (pszTmp = cstrSubKey.GetBuffer(MAX_PATH)))
         return SELFREG_E_CLASS;
    StringFromGUID2( CLSID_CAPolicyExtensionSnapIn, 
                       pszTmp, 
                       MAX_PATH);
    cstrSnapInKey = cstrSubKey;


    // be sure this is alloced
    if (NULL == (pszTmp = cstrSubKey.GetBuffer(MAX_PATH)))
         return SELFREG_E_CLASS;
    StringFromGUID2( CLSID_CAPolicyAbout, 
                       pszTmp, 
                       MAX_PATH);
    cstrCAPolicyAboutKey = cstrSubKey;


    //
    // Register Policy Extensions SnapIn with MMC
    //

    cstrSubKey.Format(L"Software\\Microsoft\\MMC\\SnapIns\\%s", (LPCWSTR)cstrSnapInKey);
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, cstrSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, L"NameString", 0, REG_SZ, (LPBYTE)((LPCTSTR)cstrSnapInName),
                   (cstrSnapInName.GetLength() + 1) * sizeof(WCHAR));

    RegSetValueEx (hKey, L"About", 0, REG_SZ, (LPBYTE)((LPCTSTR)cstrCAPolicyAboutKey),
                   (cstrCAPolicyAboutKey.GetLength() + 1) * sizeof(WCHAR));

    RegCloseKey (hKey);

    cstrSubKey.Format(L"Software\\Microsoft\\MMC\\SnapIns\\%s\\NodeTypes", (LPCWSTR)cstrSnapInKey);
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, cstrSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegCloseKey (hKey);

    cstrSubKey.Format(L"Software\\Microsoft\\MMC\\SnapIns\\%s\\NodeTypes\\%s", (LPCWSTR)cstrSnapInKey, cszNodeTypePolicySettings);
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, cstrSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegCloseKey (hKey);



    //
    // Register Policy Settings in the NodeTypes key
    //
    cstrSubKey.Format(L"Software\\Microsoft\\MMC\\NodeTypes\\%s", cszNodeTypePolicySettings);
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, cstrSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_SZ, (LPBYTE)((LPCTSTR)cstrSnapInName),
                   (cstrSnapInName.GetLength() + 1) * sizeof(WCHAR));

    RegCloseKey (hKey);


    //
    // register as an extension under the CA snapin
    //
    cstrSubKey.Format(L"Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\NameSpace", cszCAManagerParentNodeID);
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, cstrSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, cstrSnapInKey, 0, REG_SZ, (LPBYTE)((LPCTSTR)cstrSnapInName),
                   (cstrSnapInName.GetLength() + 1) * sizeof(WCHAR));

    RegCloseKey (hKey);


    // kill beta2 GPT cert type editing
    UnregisterGPECertTemplates();

    // registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(FALSE);
    //return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    CString cstrSubKey;
    LONG    lResult;
    HKEY    hKey;
    WCHAR   szSnapInKey[50];

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    _Module.UnregisterServer();

    StringFromGUID2 (CLSID_CAPolicyExtensionSnapIn, szSnapInKey, 50);

    cstrSubKey.Format(L"Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\NameSpace", cszCAManagerParentNodeID);
    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE, cstrSubKey, 0,
                              KEY_WRITE, &hKey);

    if (lResult == ERROR_SUCCESS) {
        RegDeleteValue (hKey, szSnapInKey);
        RegCloseKey (hKey);
    }
    
    cstrSubKey.Format(L"Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\NameSpace", cszNodeTypePolicySettings);
    RegDeleteKey (HKEY_LOCAL_MACHINE, cstrSubKey);

    cstrSubKey.Format(L"Software\\Microsoft\\MMC\\NodeTypes\\%s", cszNodeTypePolicySettings);
    RegDeleteKey (HKEY_LOCAL_MACHINE, cstrSubKey);

    cstrSubKey.Format(L"Software\\Microsoft\\MMC\\SnapIns\\%s\\NodeTypes\\%s", szSnapInKey, cszNodeTypePolicySettings);
    RegDeleteKey (HKEY_LOCAL_MACHINE, cstrSubKey);

    cstrSubKey.Format(L"Software\\Microsoft\\MMC\\SnapIns\\%s\\NodeTypes", szSnapInKey);
    RegDeleteKey (HKEY_LOCAL_MACHINE, cstrSubKey);

    cstrSubKey.Format(L"Software\\Microsoft\\MMC\\SnapIns\\%s", szSnapInKey);
    RegDeleteKey (HKEY_LOCAL_MACHINE, cstrSubKey);


    // kill beta2 GPT cert type editing
    UnregisterGPECertTemplates();
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// UnregisterGPECertTemplates - Removes GPECertTemplateEditing from the registry

STDAPI UnregisterGPECertTemplates(void)
{
	CString cstrSubKey;
    LONG    lResult;
    HKEY    hKey;
    WCHAR   szSnapInKeyForGPT[50];
    WCHAR   szSnapInKey[50];

    StringFromGUID2 (CLSID_CACertificateTemplateManager, szSnapInKeyForGPT, 50);
    StringFromGUID2 (CLSID_CAPolicyExtensionSnapIn, szSnapInKey, 50);

    cstrSubKey.Format(L"Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\NameSpace", cszSCEParentNodeIDUSER);
    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE, cstrSubKey, 0,
                              KEY_WRITE, &hKey);

    if (lResult == ERROR_SUCCESS) {
        RegDeleteValue (hKey, szSnapInKeyForGPT);
        RegCloseKey (hKey);
    }

    cstrSubKey.Format(L"Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\NameSpace", cszSCEParentNodeIDCOMPUTER);
    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE, cstrSubKey, 0,
                              KEY_WRITE, &hKey);

    if (lResult == ERROR_SUCCESS) {
        RegDeleteValue (hKey, szSnapInKeyForGPT);
        RegCloseKey (hKey);
    }    

    cstrSubKey.Format(L"Software\\Microsoft\\MMC\\NodeTypes\\%s", cszNodeTypeCertificateTemplate);
    RegDeleteKey (HKEY_LOCAL_MACHINE, cstrSubKey);

    cstrSubKey.Format(L"Software\\Microsoft\\MMC\\SnapIns\\%s\\NodeTypes\\%s", (LPCWSTR)szSnapInKey, cszNodeTypeCertificateTemplate);
    RegDeleteKey (HKEY_LOCAL_MACHINE, cstrSubKey);

    cstrSubKey.Format(L"Software\\Microsoft\\MMC\\SnapIns\\%s\\NodeTypes", (LPCWSTR)szSnapInKeyForGPT);
    RegDeleteKey (HKEY_LOCAL_MACHINE, cstrSubKey);

    cstrSubKey.Format(L"Software\\Microsoft\\MMC\\SnapIns\\%s", (LPCWSTR)szSnapInKeyForGPT);
    RegDeleteKey (HKEY_LOCAL_MACHINE, cstrSubKey);

    return S_OK;
}

VOID Usage()
{
    CString cstrDllInstallUsageText;
    CString cstrDllInstallUsageTitle;
    cstrDllInstallUsageText.LoadString(IDS_DLL_INSTALL_USAGE_TEXT);
    cstrDllInstallUsageTitle.LoadString(IDS_DLL_INSTALL_USAGE_TITLE);

    MessageBox(NULL, cstrDllInstallUsageText, cstrDllInstallUsageTitle, MB_OK);
    
}

STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    DWORD   dwDisp;
    LONG    lResult;
    HKEY    hKey;
    LPCWSTR wszCurrentCmd = pszCmdLine;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    BOOL fEnableTypeEditing = FALSE;



    // parse the cmd line
    while(wszCurrentCmd && *wszCurrentCmd)
    {
        while(*wszCurrentCmd == L' ')
            wszCurrentCmd++;
        if(*wszCurrentCmd == 0)
            break;

        switch(*wszCurrentCmd++)
        {
            case L'?':
            
                Usage();
                return S_OK;
            case L'c':
                fEnableTypeEditing = TRUE;
                break;
        }
    }

    //
    // Register Certificate Templates in the NodeTypes key
    //

   
    if(fEnableTypeEditing)
    {
        DWORD dwEnable = bInstall;
        lResult = RegCreateKeyEx (HKEY_CURRENT_USER, L"Software\\Microsoft\\Cryptography\\CertificateTemplateCache", 0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegSetValueEx (hKey, 
                       REGSZ_ENABLE_CERTTYPE_EDITING, 
                       0, 
                       REG_DWORD, 
                       (LPBYTE)(&dwEnable),
                       sizeof(dwEnable));

        RegCloseKey (hKey);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\capesnpn\stdafx.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#undef _MSC_EXTENSIONS

#define __DIR__		"capesnpn"

#include <windows.h>
#include <objbase.h>
#include <coguid.h>

#include <wincrypt.h>
#include <certsrv.h>
#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

extern const CLSID CLSID_CAPolicyExtensionSnapIn;    // In-Proc server GUID
extern const CLSID CLSID_CACertificateTemplateManager;    // In-Proc server GUID
extern const CLSID CLSID_Extension; // In-Proc server GUID
extern const CLSID CLSID_CAPolicyAbout; 
extern const CLSID CLSID_CertTypeAbout; 
#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

#include <atlcom.h>

#pragma comment(lib, "mmc")
#include <mmc.h>

extern HINSTANCE g_hInstance;

// Thomlinson Foundation Classes
#include "tfc.h"

// most common private includes
#include "certsrvd.h"
#include "certcli.h"
#include "certlib.h"
#include "tmpllist.h"
#include "uuids.h"
#include "service.h"
#include "compdata.h"
#include "CSnapin.h"
#include "DataObj.h"
#include "resource.h"
#include "ctshlext.h"
#include "misc.h"
#include "genpage.h"
#include "caprop.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\capesnpn\uuids.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       uuids.cpp
//
//--------------------------------------------------------------------------


#include <stdafx.h>

#include <initguid.h>
#include <gpedit.h>

const CLSID CLSID_CAPolicyExtensionSnapIn = /*3F276EB4-70EE-11d1-8A0F-00C04FB93753*/\
{0x3f276eb4,0x70ee,0x11d1,{0x8a,0x0f,0x00,0xc0,0x4f,0xb9,0x37,0x53}};

const CLSID CLSID_CACertificateTemplateManager = /*ACE10358-974C-11d1-A48D-00C04FB93753*/\
{0xace10358,0x974c,0x11d1,{0xa4,0x8d,0x0,0xc0,0x4f,0xb9,0x37,0x53}};

const CLSID CLSID_CAPolicyAbout = /*{1F823A6A-863F-11d1-A484-00C04FB93753}*/ \
{0x1f823a6a,0x863f,0x11d1,{0xa4,0x84,0x0,0xc0,0x4f,0xb9,0x37,0x53}};

const CLSID CLSID_CertTypeAbout = /* {BF84C0C5-0C80-11d2-A497-00C04FB93209} */
{ 0xbf84c0c5, 0xc80, 0x11d2, { 0xa4, 0x97, 0x0, 0xc0, 0x4f, 0xb9, 0x32, 0x9 } };

const CLSID CLSID_CertTypeShellExt = /* {9bff616c-3e02-11d2-a4ca-00c04fb93209} */
{ 0x9bff616c, 0x3e02, 0x11d2, { 0xa4, 0xca, 0x0, 0xc0, 0x4f, 0xb9, 0x32, 0x9 } };

const CLSID CLSID_CAShellExt = { /* a4e91b6a-dcae-11d2-a045-00c04f79dc55 */
    0xa4e91b6a, 0xdcae, 0x11d2, {0xa0, 0x45, 0x00, 0xc0, 0x4f, 0x79, 0xdc, 0x55} };


///////////////////////////////////////////////////////////////////////////////
//
//                  OBJECT TYPES
//

//
// OBJECT TYPE for Scope Nodes.
//

// Static NodeType GUID in numeric & string formats.
const GUID cNodeTypePolicySettings = 
{0x3f276eb3,0x70ee,0x11d1,{0x8a, 0x0f, 0x00, 0xc0, 0x4f, 0xb9, 0x37, 0x53}};
const WCHAR*  cszNodeTypePolicySettings = L"{3F276EB3-70EE-11d1-8A0F-00C04FB93753}";

// Static NodeType GUID in numeric & string formats.
const GUID cNodeTypeCertificateTemplate = 
{0x3e3dcd02,0x9755,0x11d1,{0xa4,0x8d,0x0,0xc0,0x4f,0xb9,0x37,0x53}};
const WCHAR*  cszNodeTypeCertificateTemplate = L"{3E3DCD02-9755-11d1-A48D-00C04FB93753}";

//
// OBJECT TYPE for result items.
//

// Result items object type GUID in numeric & string formats.
extern const GUID cObjectTypeResultItem = 
{0x1f823a69,0x863f,0x11d1,{0xa4,0x84,0x0,0xc0,0x4f,0xb9,0x37,0x53}};
extern const wchar_t*  cszObjectTypeResultItem = L"{1F823A69-863F-11d1-A484-00C04FB93753}";


//
//
//////////////////////////////////////////////////////////////////////////////

// Internal private format
const wchar_t* SNAPIN_INTERNAL = L"CAPESNPN_SNAPIN_INTERNAL"; // Step 3

// Published formats
const wchar_t* SNAPIN_WORKSTATION = L"CAPESNPN_SNAPIN_WORKSTATION"; // Extension 

// format for getting CA name from parent node
const wchar_t* CA_COMMON_NAME = L"SNAPIN_CA_COMMON_NAME"; // Extension

// format for getting the type of CA
const wchar_t* SNAPIN_CA_INSTALL_TYPE = L"SNAPIN_CA_INSTALL_TYPE";

// format for getting CA name from parent node
const wchar_t* CA_SANITIZED_NAME = L"SNAPIN_CA_SANITIZED_NAME"; // Extension

// Clipboard format for SCE's mode DWORD
const wchar_t* CCF_SCE_MODE_TYPE = L"CCF_SCE_MODE_TYPE";

// Clipboard format for GPT's IUnknown interface
const wchar_t* CCF_SCE_GPT_UNKNOWN = L"CCF_SCE_GPT_UNKNOWN";



// CA manager snapin parent node 
const CLSID cCAManagerParentNodeID = /*5d972ee4-7576-11d1-8cbe-00c04fc297eb*/ \
{0x5d972ee4,0x7576,0x11d1,{0x8c,0xbe,0x00,0xc0,0x4f,0xc2,0x97,0xeb}};
const WCHAR* cszCAManagerParentNodeID = L"{5d972ee4-7576-11d1-8cbe-00c04fc297eb}";

// SCE-GPT parent node
const CLSID cSCEParentNodeIDUSER = /*A6B4EEBC-B681-11D0-9484-080036B11A03*/ \
{0xc4a92b42,0x91ee,0x11d1,{0x85,0xfd,0x0,0xc0,0x4f,0xb9,0x4f,0x17}};
const WCHAR* cszSCEParentNodeIDUSER = L"{C4A92B42-91EE-11D1-85FD-00C04FB94F17}";

const CLSID cSCEParentNodeIDCOMPUTER = /*A6B4EEBB-B681-11D0-9484-080036B11A03*/ \
{0xc4a92b43,0x91ee,0x11d1,{0x85,0xfd,0x0,0xc0,0x4f,0xb9,0x4f,0x17}};
const WCHAR* cszSCEParentNodeIDCOMPUTER = L"{C4A92B43-91EE-11D1-85FD-00C04FB94F17}";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\capesnpn\wiz.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       wiz.h
//
//--------------------------------------------------------------------------

#ifndef __WIZ_H_
#define __WIZ_H_

#include "stdafx.h"

#include "csw97sht.h"
#include "csw97ppg.h"

/////////////////////////////////////////////////////////////////////////////
// CNewCertTypeWelcome dialog

class CNewCertTypeWelcome : public CWizard97PropertyPage
{
    enum { IDD = IDD_NEWCERTTYPE_WELCOME };
    
    // Construction
public:
    CNewCertTypeWelcome();
    ~CNewCertTypeWelcome();
    
    // Dialog Data
    
    // Overrides
public:
    LRESULT OnWizardNext();
    BOOL OnSetActive();
    BOOL UpdateData(BOOL fSuckFromDialog=TRUE);
    
    // Implementation
protected:
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    BOOL OnInitDialog();
    
public:
    PWIZARD_HELPER m_pwizHelp;
};



/////////////////////////////////////////////////////////////////////////////
// CNewCertTypeBaseType dialog

class CNewCertTypeBaseType : public CWizard97PropertyPage
{
    
    // Construction
public:
    CNewCertTypeBaseType();
    ~CNewCertTypeBaseType();
    
    // Dialog Data
    enum { IDD = IDD_NEWCERTTYPE_TYPE };
    
    // Overrides
public:
    LRESULT OnWizardBack();
    LRESULT OnWizardNext();
    BOOL OnSetActive();
    BOOL UpdateData(BOOL fSuckFromDialog=TRUE);
    
    // Implementation
protected:
    BOOL OnInitDialog();
    void OnSelChange(NMHDR * pNotifyStruct); 
    void OnDestroy();
    
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    BOOL OnNotify(UINT idCtrl, NMHDR* pnmh);
    
public:
    HCERTTYPE       m_hSelectedCertType;
    HCERTTYPE       m_hLastSelectedCertType;
    PWIZARD_HELPER  m_pwizHelp;
    int             m_selectedIndex;
    HWND            m_hBaseCertTypeList;
};



/////////////////////////////////////////////////////////////////////////////
// CNewCertTypeBasicInformation dialog

class CNewCertTypeBasicInformation : public CWizard97PropertyPage
{
    DECLARE_DYNCREATE(CNewCertTypeBasicInformation)
        
        // Construction
public:
    CNewCertTypeBasicInformation();
    ~CNewCertTypeBasicInformation();
    
    void UpdateWizHelp();
    BOOL OIDAlreadyExist(LPSTR pszNewOID);
    void InitializeOIDList();
    
    // Dialog Data
    enum { IDD = IDD_NEWCERTTYPE_INFORMATION };
    
    
    // Overrides
public:
    LRESULT OnWizardBack();
    LRESULT OnWizardNext();
    BOOL OnSetActive();
    BOOL UpdateData(BOOL fSuckFromDialog=TRUE);
    
    // Implementation
protected:
    BOOL OnInitDialog();
    void OnNewPurposeButton();
    void OnDestroy();
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    
public:
    void AddEnumedEKU(PCCRYPT_OID_INFO pInfo);
    PWIZARD_HELPER m_pwizHelp;
    HWND    m_hPurposeList;
    
    HWND m_hButtonCAFillIn;
    HWND m_hButtonCritical;
    HWND m_hButtonIncludeEmail;
    HWND m_hButtonAllowAutoEnroll;
    HWND m_hButtonAdvanced;
};



/////////////////////////////////////////////////////////////////////////////
// CNewCertTypeKeyUsage dialog

class CNewCertTypeKeyUsage : public CWizard97PropertyPage
{
    
    // Construction
public:
    CNewCertTypeKeyUsage();
    ~CNewCertTypeKeyUsage();
    
    void UpdateWizHelp();
    
    // Dialog Data
    enum { IDD = IDD_NEWCERTTYPE_KEY_USAGE };
    
    // Overrides
public:
    LRESULT OnWizardBack();
    LRESULT OnWizardNext();
    BOOL OnSetActive();
    BOOL UpdateData(BOOL fSuckFromDialog=TRUE);
    
    // Implementation
protected:
    BOOL OnInitDialog();
    void OnDestroy();
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);
public:
    PWIZARD_HELPER m_pwizHelp;
    
    HWND m_hButtonDataEncryption;
    HWND m_hButtonDecipherOnly;
    HWND m_hButtonDigitalSignature;
    HWND m_hButtonEncipherOnly;
    HWND m_hButtonKeyAgreement;
    HWND m_hButtonKeyEncryption;
    HWND m_hButtonKeyUsageCritical;
    HWND m_hButtonPrevent;
};


/////////////////////////////////////////////////////////////////////////////
// CNewCertTypeCACertificate dialog

class CNewCertTypeCACertificate : public CWizard97PropertyPage
{
    
    // Construction
public:
    CNewCertTypeCACertificate();
    ~CNewCertTypeCACertificate();
    
    void UpdateWizHelp();
    
    // Dialog Data
    enum { IDD = IDD_NEWCERTTYPE_CA_CERTIFICATE };
    
    // Overrides
public:
    LRESULT OnWizardBack();
    LRESULT OnWizardNext();
    BOOL OnSetActive();
    BOOL UpdateData(BOOL fSuckFromDialog=TRUE);
    
    // Implementation
protected:
    BOOL OnInitDialog();
    void OnDestroy();
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);
public:
    PWIZARD_HELPER m_pwizHelp;
    
    HWND m_hButtonVerifySignature;
    HWND m_hButtonIssueCRL;
};



/////////////////////////////////////////////////////////////////////////////
// CNewCertTypeCompletion dialog

class CNewCertTypeCompletion : public CWizard97PropertyPage
{
    
    // Construction
public:
    CNewCertTypeCompletion();
    ~CNewCertTypeCompletion();
    
    void SetItemTextWrapper(UINT nID, int *piItem, BOOL fDoInsert, BOOL *pfFirstUsageItem);
    void AddResultsToSummaryList();
    
    // Dialog Data
    enum { IDD = IDD_NEWCERTTYPE_COMPLETION };
    HWND m_hSummaryList;
    
    // Overrides
public:
    BOOL OnWizardFinish();
    LRESULT OnWizardBack();
    BOOL OnSetActive();
    BOOL UpdateData(BOOL fSuckFromDialog=TRUE);
    
    // Implementation
protected:
    BOOL OnInitDialog();
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);
public:
    PWIZARD_HELPER m_pwizHelp;
};

HCERTTYPE InvokeCertTypeWizard(HCERTTYPE hEditCertType, HWND hwndConsole);

#endif //__WIZ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\celib\cedebug.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//	File:		cedebug.cpp
//
//	Contents:	Debug support
//
//----------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "celib.h"
#include <stdarg.h>


//+-------------------------------------------------------------------------
//
//  Function:  ceDbgPrintf
//
//  Synopsis:  outputs debug info to stdout and debugger
//
//  Returns:   number of chars output
//
//--------------------------------------------------------------------------

int WINAPIV
ceDbgPrintf(
    IN BOOL fDebug,
    IN LPCSTR lpFmt,
    ...)
{
    va_list arglist;
    CHAR ach[4096];
    int cch = 0;
    HANDLE hStdOut;
    DWORD dwErr;

    dwErr = GetLastError();
    if (fDebug)
    {
	__try 
	{
	    va_start(arglist, lpFmt);
	    cch = _vsnprintf(ach, sizeof(ach), lpFmt, arglist);
	    va_end(arglist);

	    if (0 > cch)
	    {
		strcpy(&ach[sizeof(ach) - 5], "...\n");
	    }

	    if (!IsDebuggerPresent())
	    {
		hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
		if (hStdOut != INVALID_HANDLE_VALUE)
		{
		    fputs(ach, stdout);
		    fflush(stdout);
		}
	    }
	    OutputDebugStringA(ach);
	}
	__except(EXCEPTION_EXECUTE_HANDLER) 
	{
	    // return failure
	    cch = 0;
	}
    }
    SetLastError(dwErr);
    return(cch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\celib\ceerror.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        ceerror.cpp
//
// Contents:    Cert Server error wrapper routines
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "celib.h"
#include <assert.h>
#include <ntdsbmsg.h>
#include <delayimp.h>


#define CERTLIB_12BITERRORMASK	0x00000fff
#define CERTLIB_WIN32ERRORMASK	0x0000ffff


//+--------------------------------------------------------------------------
// Jet errors:

#define HRESULT_FROM_JETWARNING(jerr) \
	(ERROR_SEVERITY_WARNING | (FACILITY_NTDSB << 16) | jerr)

#define HRESULT_FROM_JETERROR(jerr) \
	(ERROR_SEVERITY_ERROR | (FACILITY_NTDSB << 16) | -jerr)

#define JETERROR_FROM_HRESULT(hr) \
	(-(LONG) (CERTLIB_WIN32ERRORMASK & (hr)))

#define ISJETERROR(hr) \
        ((~CERTLIB_WIN32ERRORMASK & (hr)) == (HRESULT) ~CERTLIB_WIN32ERRORMASK)

#define ISJETHRESULT(hr) \
    ((~CERTLIB_WIN32ERRORMASK & (hr)) == (HRESULT) (ERROR_SEVERITY_ERROR | \
					      (FACILITY_NTDSB << 16)))

#define wszJETERRORPREFIX	L"ESE"


//+--------------------------------------------------------------------------
// Win32 errors:

#define ISWIN32ERROR(hr) \
    ((~CERTLIB_WIN32ERRORMASK & (hr)) == 0)

#define ISWIN32HRESULT(hr) \
    ((~CERTLIB_WIN32ERRORMASK & (hr)) == (HRESULT) (ERROR_SEVERITY_WARNING | \
					      (FACILITY_WIN32 << 16)))

#define WIN32ERROR_FROM_HRESULT(hr) \
    (CERTLIB_WIN32ERRORMASK & (hr))

#define wszWIN32ERRORPREFIX	L"WIN32"


//+--------------------------------------------------------------------------
// Delayload errors:

#define DELAYLOAD_FROM_WIN32(hr)  VcppException(ERROR_SEVERITY_ERROR, (hr))

#define WIN32ERROR_FROM_DELAYLOAD(hr)  (CERTLIB_WIN32ERRORMASK & (hr))

#define ISDELAYLOADHRESULTFACILITY(hr) \
    ((~CERTLIB_WIN32ERRORMASK & (hr)) == (HRESULT) (ERROR_SEVERITY_ERROR | \
                                              (FACILITY_VISUALCPP << 16)))

// E_DELAYLOAD_MOD_NOT_FOUND	0xc06d007e
#define E_DELAYLOAD_MOD_NOT_FOUND   DELAYLOAD_FROM_WIN32(ERROR_MOD_NOT_FOUND)

// E_DELAYLOAD_PROC_NOT_FOUND	0xc06d007f
#define E_DELAYLOAD_PROC_NOT_FOUND  DELAYLOAD_FROM_WIN32(ERROR_PROC_NOT_FOUND)

#define ISDELAYLOADHRESULT(hr) \
        ((HRESULT) E_DELAYLOAD_MOD_NOT_FOUND == (hr) || \
         (HRESULT) E_DELAYLOAD_PROC_NOT_FOUND == (hr) || \
         HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND) == (hr) || \
         HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND) == (hr))


//+--------------------------------------------------------------------------
// ASN encoding errors:

#define ISOSSERROR(hr) \
    ((~CERTLIB_12BITERRORMASK & (hr)) == CRYPT_E_OSS_ERROR)

#define OSSERROR_FROM_HRESULT(hr) \
    (CERTLIB_12BITERRORMASK & (hr))

#define wszOSSERRORPREFIX	L"ASN"




HRESULT
ceJetHResult(
    IN HRESULT hr)
{
#if DBG_CERTSRV
    HRESULT hrIn = hr;
#endif
    if (S_OK != hr)
    {
        if (SUCCEEDED(hr))
        {
#if 0
	    hr = HRESULT_FROM_JETWARNING(hr);
#else
            if (S_FALSE != hr)
	    {
		ceERRORPRINTLINE("JetHResult: mapping to S_FALSE", hr);
	    }
            assert(S_FALSE == hr);
            hr = S_FALSE;
#endif
        }
        else if (ISJETERROR(hr))
        {
	    hr = HRESULT_FROM_JETERROR(hr);
        }
    }
    assert(S_OK == hr || S_FALSE == hr || FAILED(hr));
    return(hr);
}


HRESULT
ceHExceptionCode(
    IN EXCEPTION_POINTERS const *pep)
{
    HRESULT hr = pep->ExceptionRecord->ExceptionCode;

    return(ceHError(hr));
}


BOOL
ceIsDelayLoadHResult(
    IN HRESULT hr)
{
    return(ISDELAYLOADHRESULT(hr));
}


#define wszCOLONSPACE	L": "

WCHAR const *
ceHResultToStringEx(
    IN OUT WCHAR *awchr,
    IN HRESULT hr,
    IN BOOL fRaw)
{
    HRESULT hrd;
    WCHAR const *pwszType;

    hrd = hr;
    pwszType = L"";
    if (ISJETERROR(hr))
    {
	pwszType = wszJETERRORPREFIX wszCOLONSPACE;
    }
    else if (ISJETHRESULT(hr))
    {
	hrd = JETERROR_FROM_HRESULT(hr);
	pwszType = wszJETERRORPREFIX wszCOLONSPACE;
    }
    else if (ISWIN32HRESULT(hr))
    {
	hrd = WIN32ERROR_FROM_HRESULT(hr);
	pwszType = wszWIN32ERRORPREFIX wszCOLONSPACE;
    }
    else if (ISDELAYLOADHRESULTFACILITY(hr))
    {
	hrd = WIN32ERROR_FROM_DELAYLOAD(hr);
	pwszType = wszWIN32ERRORPREFIX wszCOLONSPACE;
    }
    else if (ISOSSERROR(hr))
    {
	hrd = OSSERROR_FROM_HRESULT(hr);
	pwszType = wszOSSERRORPREFIX wszCOLONSPACE;
    }
    if (fRaw)
    {
	pwszType = L"";
    }

    _snwprintf(
	awchr,
	cwcHRESULTSTRING,
	L"0x%x (%ws%d)",
	hr,
	pwszType,
	hrd);
    return(awchr);
}


WCHAR const *
ceHResultToString(
    IN OUT WCHAR *awchr,
    IN HRESULT hr)
{
    return(ceHResultToStringEx(awchr, hr, FALSE));
}


WCHAR const *
ceHResultToStringRaw(
    IN OUT WCHAR *awchr,
    IN HRESULT hr)
{
    return(ceHResultToStringEx(awchr, hr, TRUE));
}


static HMODULE s_hMod = NULL;
static DWORD s_idsUnexpected = 0;
static DWORD s_idsUnknownErrorCode = 0;	// L"Error %ws %ws"

VOID
ceInitErrorMessageText(
    IN HMODULE hMod,
    IN DWORD idsUnexpected,
    IN DWORD idsUnknownErrorCode)	// L"Error %ws %ws"
{
    s_hMod = hMod;
    s_idsUnexpected = idsUnexpected;
    s_idsUnknownErrorCode = idsUnknownErrorCode;
}


// Alloc and return error message string

WCHAR *
ceGetErrorMessageText(
    IN HRESULT hr,
    IN BOOL fHResultString)
{
    static WCHAR s_wszUknownDefault[] = L"Error %ws %ws";
    WCHAR *pwszRet = NULL;
    WCHAR *pwszMsgT;
    WCHAR const *pwszUnknown;
    WCHAR wszUnknown[10 * ARRAYSIZE(s_wszUknownDefault)];
    WCHAR wszUnexpected[512];
    WCHAR awchr[cwcHRESULTSTRING];
    DWORD cwc;
    DWORD cwcUnexpected = 0;
    HMODULE hMod = NULL;

    wszUnexpected[0] = L'\0';
    if (E_UNEXPECTED == hr && 0 != s_idsUnexpected)
    {
	cwcUnexpected = LoadString(
		    s_hMod,
		    s_idsUnexpected,	// L"Unexpected method call sequence."
		    wszUnknown,
		    ARRAYSIZE(wszUnknown));
    }
    cwc = FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER |
		    FORMAT_MESSAGE_FROM_SYSTEM |
		    FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                hr,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
                (WCHAR *) &pwszRet,    
                0,    
                NULL);
    if (0 == cwc)
    {
	hMod = LoadLibrary(L"ntdsbmsg.dll");
	if (NULL != hMod)
	{
	    cwc = FormatMessage(
		    FORMAT_MESSAGE_ALLOCATE_BUFFER |
			FORMAT_MESSAGE_FROM_HMODULE |
			FORMAT_MESSAGE_IGNORE_INSERTS,
		    hMod,
		    hr,
		    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
		    (WCHAR *) &pwszRet,    
		    0,    
		    NULL);
	}
    }
    if (0 == cwc)
    {
	// couldn't find error, _snwprintf it instead

	if (0 != s_idsUnknownErrorCode)
	{
	    cwc = LoadString(
			s_hMod,
			s_idsUnknownErrorCode,	// L"Error %ws %ws"
			wszUnknown,
			ARRAYSIZE(wszUnknown));
	}
	if (0 == cwc)
	{
	    pwszUnknown = s_wszUknownDefault;
	}
	else
	{
	    pwszUnknown = wszUnknown;
	}
	cwc = wcslen(pwszUnknown) + cwcUnexpected + ARRAYSIZE(awchr) + 1;
        pwszRet = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
	if (NULL == pwszRet)
	{
	    ceERRORPRINTLINE("LocalAlloc", E_OUTOFMEMORY);
	    goto error;
	}
        _snwprintf(
		pwszRet,
		cwc,
		pwszUnknown,
		wszUnexpected,
		ceHResultToString(awchr, hr));
    }
    else
    {
        // strip trailing \r\n

        cwc = wcslen(pwszRet);

        if (2 <= cwc &&
	    L'\r' == pwszRet[cwc - 2] &&
	    L'\n' == pwszRet[cwc - 1])
	{
            pwszRet[cwc - 2] = L'\0';
	}
	awchr[0] = L'\0';
	if (fHResultString)
	{
	    ceHResultToString(awchr, hr);
	}
	if (fHResultString || 0 != cwcUnexpected)
	{
	    cwc = wcslen(pwszRet) + 1 + cwcUnexpected + 1 + wcslen(awchr) + 1;
	    pwszMsgT = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
	    if (NULL == pwszMsgT)
	    {
		ceERRORPRINTLINE("LocalAlloc", E_OUTOFMEMORY);
		goto error;
	    }
	    _snwprintf(
		    pwszMsgT,
		    cwc,
		    L"%ws %ws %ws",
		    pwszRet,
		    wszUnexpected,
		    awchr);
	    LocalFree(pwszRet);
	    pwszRet = pwszMsgT;
	}
    }

error:
    if (NULL != hMod)
    {
	FreeLibrary(hMod);
    }
    return(pwszRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\capesnpn\uuids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       uuids.h
//
//--------------------------------------------------------------------------

#ifndef __UUIDS_H_
#define __UUIDS_H_

const long UNINITIALIZED = -1;

// Constants used in samples
const int MAX_ITEM_NAME = 64;

enum SCOPE_TYPES
{
    UNINITIALIZED_ITEM  = 0,

    SCOPE_LEVEL_ITEM    = 111,
    RESULT_ITEM         = 222,
    //CA_LEVEL_ITEM       = 333,
};

// Sample folder types
enum FOLDER_TYPES
{
    STATIC = 0x8000,

    // policy settings node
    POLICYSETTINGS = 0x8007,

    // cert types manager node
    SCE_EXTENSION = 0x8100,

    // cert types displayed in results pane for policy settings node
    CA_CERT_TYPE = 0x8107,

    // cert types displayed in results pane for cert types manager node
    GLOBAL_CERT_TYPE = 0x8110,
    
    NONE = 0xFFFF
};

/////////////////////////////////////////////////////////////////////////////
// Helper functions

template<class TYPE>
inline void SAFE_RELEASE(TYPE*& pObj)
{
    if (pObj != NULL) 
    { 
        pObj->Release(); 
        pObj = NULL; 
    } 
    else 
    { 
#ifdef _DEBUG
        OutputDebugString(L"CAPESNPN: Release called on NULL interface ptr\n"); 
#endif
    }
}

extern const CLSID CLSID_CAPolicyExtensionSnapIn;
extern const CLSID CLSID_CACertificateTemplateManager;
extern const CLSID CLSID_CertTypeAbout; 
extern const CLSID CLSID_CAPolicyAbout;
extern const CLSID CLSID_CertTypeShellExt;
extern const CLSID CLSID_CAShellExt;
///////////////////////////////////////////////////////////////////////////////
//
//                  OBJECT TYPES
//

//
// OBJECT TYPE for Scope Nodes.
//

// Static NodeType GUID in numeric & string formats.
extern const GUID cNodeTypePolicySettings;
extern const WCHAR*  cszNodeTypePolicySettings;
extern const GUID cNodeTypeCertificateTemplate;
extern const WCHAR*  cszNodeTypeCertificateTemplate;

//
// OBJECT TYPE for result items.
//

// Result items object type GUID in numeric & string formats.
extern const GUID cObjectTypeResultItem;
extern const wchar_t*  cszObjectTypeResultItem;


// CA Manager snapin parent node
extern const CLSID cCAManagerParentNodeID;
extern const WCHAR* cszCAManagerParentNodeID;

// CA Manager snapin parent node
extern const CLSID cSCEParentNodeIDUSER;
extern const WCHAR* cszSCEParentNodeIDUSER;
extern const CLSID cSCEParentNodeIDCOMPUTER;
extern const WCHAR* cszSCEParentNodeIDCOMPUTER;

//
//
//////////////////////////////////////////////////////////////////////////////



// New Clipboard format that has the Type and Cookie
extern const wchar_t* SNAPIN_INTERNAL;

// Published context information for extensions to extend
extern const wchar_t* SNAPIN_WORKSTATION;

// format for getting CA name from parent node
extern const wchar_t* CA_COMMON_NAME;

// format for getting CA name from parent node
extern const wchar_t* CA_SANITIZED_NAME;

extern const wchar_t* SNAPIN_CA_INSTALL_TYPE;

// Clipboard format for SCE's mode DWORD
extern const wchar_t* CCF_SCE_MODE_TYPE;

// Clipboard format for GPT's IUnknown interface
extern const wchar_t* CCF_SCE_GPT_UNKNOWN;

struct INTERNAL 
{
    INTERNAL() 
    {
        m_type = CCT_UNINITIALIZED; 
        m_cookie = -1;
        ZeroMemory(&m_clsid, sizeof(CLSID));
    };

    ~INTERNAL() {}

    DATA_OBJECT_TYPES   m_type;         // What context is the data object.
    MMC_COOKIE                m_cookie;       // What object the cookie represents
    CString             m_string;       // 
    CLSID               m_clsid;       // Class ID of who created this data object

    INTERNAL & operator=(const INTERNAL& rhs) 
    { 
        if (&rhs == this)
            return *this;

        // Deep copy the information
        m_type = rhs.m_type; 
        m_cookie = rhs.m_cookie; 
        m_string = rhs.m_string;
        memcpy(&m_clsid, &rhs.m_clsid, sizeof(CLSID));

        return *this;
    } 

    BOOL operator==(const INTERNAL& rhs) 
    {
        return rhs.m_string == m_string;
    }
};

// Debug instance counter
#ifdef _DEBUG
inline void DbgInstanceRemaining(char * pszClassName, int cInstRem)
{
    char buf[100];
    wsprintfA(buf, "%s has %d instances left over.", pszClassName, cInstRem);
    ::MessageBoxA(NULL, buf, "CAPESNPN: Memory Leak!!!", MB_OK);
}
    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)      extern int s_cInst_##cls = 0;
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)    ++(s_cInst_##cls);
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)    --(s_cInst_##cls);
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)    \
        extern int s_cInst_##cls; \
        if (s_cInst_##cls) DbgInstanceRemaining(#cls, s_cInst_##cls);
#else
    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)   
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)    
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)    
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)    
#endif 


#endif //__UUIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\capesnpn\wiz.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       wiz.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "wiz.h"
#include <rpc.h>

// sddl.h requires this value to be at least
// 0x0500.  Bump it up if necessary.  NOTE:  This
// 'bump' comes after all other H files that may
// be sensitive to this value.
#if(_WIN32_WINNT < 0x500)
#undef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#include <sddl.h>


UINT g_aidFont[] =
{
    IDS_LARGEFONTNAME,
    IDS_LARGEFONTSIZE,
    IDS_SMALLFONTNAME,
    IDS_SMALLFONTSIZE,
};

static BOOL IsDisallowedOID(LPCSTR pszOID)
{
    if ((strcmp(pszOID, szOID_SGC_NETSCAPE) == 0) ||
        (strcmp(pszOID, szOID_SERVER_GATED_CRYPTO) == 0) ||
        (strcmp(pszOID, szOID_WHQL_CRYPTO) == 0) ||
        (strcmp(pszOID, szOID_NT5_CRYPTO) == 0) ||
        (strcmp(pszOID, szOID_KP_TIME_STAMP_SIGNING) == 0))
    {
        return TRUE;
    }

    return FALSE;
}

HRESULT 
SetupFonts(
    HINSTANCE    hInstance,
    HWND         hwnd,
    CFont        *pBigBoldFont,
    CFont        *pBoldFont
    )
{
    HRESULT hr = S_OK;

    //
	// Create the fonts we need based on the dialog font
    //
	NONCLIENTMETRICS ncm = {0};
	ncm.cbSize = sizeof(ncm);
	SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

	LOGFONT BigBoldLogFont  = ncm.lfMessageFont;
	LOGFONT BoldLogFont     = ncm.lfMessageFont;

    //
	// Create Big Bold Font and Bold Font
    //
    BigBoldLogFont.lfWeight   = FW_BOLD;
    BoldLogFont.lfWeight      = FW_BOLD;

    TCHAR FontSizeString[MAX_PATH];
    INT BigBoldFontSize;
    INT BoldFontSize;

    //
    // Load size and name from resources, since these may change
    // from locale to locale based on the size of the system font, etc.
    //
    if(!LoadString(hInstance,IDS_LARGEFONTNAME,BigBoldLogFont.lfFaceName,LF_FACESIZE)) 
    {
        lstrcpy(BigBoldLogFont.lfFaceName,TEXT("MS Shell Dlg"));
    }

    if(LoadString(hInstance,IDS_LARGEFONTSIZE,FontSizeString,sizeof(FontSizeString)/sizeof(TCHAR))) 
    {
        BigBoldFontSize = _tcstoul( FontSizeString, NULL, 10 );
    } 
    else 
    {
        BigBoldFontSize = 12;
    }

    if(LoadString(hInstance,IDS_FONTSIZE,FontSizeString,sizeof(FontSizeString)/sizeof(TCHAR))) 
    {
        BoldFontSize = _tcstoul( FontSizeString, NULL, 10 );
    } 
    else 
    {
        BoldFontSize = 10;
    }

    HDC hdc = GetDC(hwnd);
	
    if (hdc)
    {
        BigBoldLogFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * BigBoldFontSize / 72);
        BoldLogFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * BoldFontSize / 72);

        if (!pBigBoldFont->CreateFontIndirect(&BigBoldLogFont) ||
            !pBoldFont->CreateFontIndirect(&BoldLogFont))
        {
            hr = GetLastError();
            hr = HRESULT_FROM_WIN32(hr);
        }
		

        ReleaseDC(hwnd,hdc);
    }
    else
    {
	hr = GetLastError();
	hr = HRESULT_FROM_WIN32(hr);
    }

    return hr;
}


void CleanUpCertTypeInfo(PWIZARD_HELPER pwizHelp)
{
    unsigned int i;

    if (pwizHelp->pKeyUsage != NULL)
    {
        delete(pwizHelp->pKeyUsage);
        pwizHelp->pKeyUsage = NULL;
    }
    ZeroMemory(pwizHelp->KeyUsageBytes, 2);
    pwizHelp->fMarkKeyUsageCritical = FALSE;
    
    if (pwizHelp->EnhancedKeyUsage.cUsageIdentifier != 0)
    {
        for (i=0; i<pwizHelp->EnhancedKeyUsage.cUsageIdentifier; i++)
        {
            delete(pwizHelp->EnhancedKeyUsage.rgpszUsageIdentifier[i]);
        }   
        delete(pwizHelp->EnhancedKeyUsage.rgpszUsageIdentifier);
        pwizHelp->EnhancedKeyUsage.rgpszUsageIdentifier = NULL;
        pwizHelp->EnhancedKeyUsage.cUsageIdentifier = 0;
    }
    pwizHelp->fMarkEKUCritical = FALSE;

    
    pwizHelp->BasicConstraints2.fCA = FALSE; 
    pwizHelp->BasicConstraints2.fPathLenConstraint = FALSE;
    pwizHelp->BasicConstraints2.dwPathLenConstraint = 0;

    pwizHelp->fAllowCAtoFillInInfo = FALSE;
    pwizHelp->fIncludeEmail = FALSE;
    pwizHelp->fAllowAutoEnroll = FALSE;
    pwizHelp->fMachine = FALSE;

    pwizHelp->fPublishToDS = FALSE;
    pwizHelp->fAddTemplateName = FALSE;
    pwizHelp->fAddDirectoryPath = FALSE;



    if(pwizHelp->pSD)
    {
        LocalFree(pwizHelp->pSD);
        pwizHelp->pSD = NULL;
    }

    if (pwizHelp->rgszCSPList != NULL)
    {
        delete[](pwizHelp->rgszCSPList);
        pwizHelp->rgszCSPList = NULL;
        pwizHelp->cCSPs = 0;
    }
    pwizHelp->fPrivateKeyExportable = FALSE;
    pwizHelp->fDigitalSignatureContainer = TRUE;
    pwizHelp->fKeyExchangeContainer = FALSE;
}


void FillInCertTypeInfo(HCERTTYPE hCertType, PWIZARD_HELPER pwizHelp)
{
    DWORD       cNumUsages;
    CString     **aszUsages = NULL;
    unsigned int         i;
    WCHAR       **pszNameArray;
    DWORD       dwFlags, dwKeySpec;
    LPWSTR      *rgpwszSupportedCSPs;


    CleanUpCertTypeInfo(pwizHelp);

    //
    // key usage
    //
    if (MyGetKeyUsages(hCertType, &(pwizHelp->pKeyUsage), &(pwizHelp->fMarkKeyUsageCritical)))
    {
        // copy the key usage bits to the local byte array that has two bytes for sure
        ZeroMemory(pwizHelp->KeyUsageBytes, 2);
        CopyMemory(pwizHelp->KeyUsageBytes, pwizHelp->pKeyUsage->pbData, pwizHelp->pKeyUsage->cbData);
        pwizHelp->pKeyUsage->cUnusedBits = 7; // there are currently 9 key usage bits defined
        pwizHelp->pKeyUsage->pbData = pwizHelp->KeyUsageBytes;
        pwizHelp->pKeyUsage->cbData = 2;
    }

    //
    // enhanced key usage count
    //
    if(!MyGetEnhancedKeyUsages(
            hCertType, 
            NULL, 
            &cNumUsages, 
            &(pwizHelp->fMarkEKUCritical), 
            TRUE))
    {
        return;
    }

    if (cNumUsages == 0)
    {
        pwizHelp->EnhancedKeyUsage.cUsageIdentifier = 0;
        pwizHelp->EnhancedKeyUsage.rgpszUsageIdentifier = NULL;
    }
    else
    {
        aszUsages = new CString*[cNumUsages];
        if(!aszUsages)
            return;

        if(!MyGetEnhancedKeyUsages(
                hCertType, 
                aszUsages, 
                &cNumUsages, 
                &(pwizHelp->fMarkEKUCritical), 
                TRUE))
        {
            delete[] aszUsages;
            return;
        }

        pwizHelp->EnhancedKeyUsage.cUsageIdentifier = cNumUsages; 
        pwizHelp->EnhancedKeyUsage.rgpszUsageIdentifier = (LPSTR *) new (LPSTR[cNumUsages]);
        if(pwizHelp->EnhancedKeyUsage.rgpszUsageIdentifier == NULL)
        {
            delete[] aszUsages;
            return;
        }

        for (i=0; i<cNumUsages; i++)
        {
            pwizHelp->EnhancedKeyUsage.rgpszUsageIdentifier[i] = MyMkMBStr((LPCTSTR)*(aszUsages[i]));
            delete(aszUsages[i]);
        }
    }

    //
    // basic constraints
    //
    if(!MyGetBasicConstraintInfo(
            hCertType, 
            &(pwizHelp->BasicConstraints2.fCA), 
            &(pwizHelp->BasicConstraints2.fPathLenConstraint), 
            &(pwizHelp->BasicConstraints2.dwPathLenConstraint)))
    {
        delete[] aszUsages;
        return;
    }

    // if the fInEditCertTypeMode flag is set, then we need to initialize the
    // cert template name
    if (pwizHelp->fInEditCertTypeMode)
    {
        CAGetCertTypeProperty(hCertType, CERTTYPE_PROP_FRIENDLY_NAME, &pszNameArray);
        if (pszNameArray != NULL)
        {
            *(pwizHelp->pcstrFriendlyName) = pszNameArray[0];
            CAFreeCertTypeProperty(hCertType, pszNameArray);
        }
    }

    //
    // ACL info
    //
    CACertTypeGetSecurity(hCertType, &pwizHelp->pSD);


    CAGetCertTypeFlags(hCertType, &dwFlags);

    pwizHelp->fAllowCAtoFillInInfo = 
        ((dwFlags & CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT) == 0);

    pwizHelp->fAllowAutoEnroll = 
        ((dwFlags & CT_FLAG_AUTO_ENROLLMENT) == 0);
       
    pwizHelp->fMachine = 
        ((dwFlags & CT_FLAG_MACHINE_TYPE) == 0);

    pwizHelp->fPublishToDS = 
        ((dwFlags & CT_FLAG_PUBLISH_TO_DS) == 0);


    pwizHelp->fIncludeEmail = 
        ((dwFlags & CT_FLAG_ADD_EMAIL) != 0);

    pwizHelp->fAddTemplateName = 
        ((dwFlags & CT_FLAG_ADD_TEMPLATE_NAME) == 0);

    pwizHelp->fAddDirectoryPath = 
        ((dwFlags & CT_FLAG_ADD_DIRECTORY_PATH) == 0);

    //
    // CSP info
    //
    if ((CAGetCertTypeProperty(hCertType, CERTTYPE_PROP_CSP_LIST, &rgpwszSupportedCSPs) == S_OK) &&
        (rgpwszSupportedCSPs != NULL))
    {
        //
        // count number of CSPs
        //
        i = 0;
        while (rgpwszSupportedCSPs[i++] != NULL);

        pwizHelp->cCSPs = i-1;

        //
        // allocate array and copy CSP names to it
        //
        if (NULL != (pwizHelp->rgszCSPList = (CString *) new(CString[pwizHelp->cCSPs])))
        {
            i = 0;
            while (rgpwszSupportedCSPs[i] != NULL)
            {
                pwizHelp->rgszCSPList[i] = rgpwszSupportedCSPs[i];
                i++;
            }
        }

        CAFreeCertTypeProperty(hCertType, rgpwszSupportedCSPs);
    }
    pwizHelp->fPrivateKeyExportable = dwFlags & CT_FLAG_EXPORTABLE_KEY;
    CAGetCertTypeKeySpec(hCertType, &dwKeySpec);
    if (dwKeySpec == AT_KEYEXCHANGE)
    {
        pwizHelp->fDigitalSignatureContainer = FALSE;
        pwizHelp->fKeyExchangeContainer = TRUE;
    }
    else
    {
        pwizHelp->fDigitalSignatureContainer = TRUE;
        pwizHelp->fKeyExchangeContainer = FALSE;
    }

    delete[] aszUsages;
}


/////////////////////////////////////////////////////////////////////////////
// CNewCertTypeWelcome property page

CNewCertTypeWelcome::CNewCertTypeWelcome() :
    CWizard97PropertyPage(
	g_hInstance,
	CNewCertTypeWelcome::IDD,
	g_aidFont)
{
    InitWizard97 (TRUE);
}

CNewCertTypeWelcome::~CNewCertTypeWelcome()
{
}

// replacement for DoDataExchange
BOOL CNewCertTypeWelcome::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
//        m_cstrModuleName.FromWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
    }
    else
    {
//        m_cstrModuleName.ToWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
    }
    return TRUE;
}


// replacement for BEGIN_MESSAGE_MAP
BOOL CNewCertTypeWelcome::OnCommand(WPARAM wParam, LPARAM lParam)
{
/*
    switch(LOWORD(wParam))
    {
    default:
        return FALSE;
        break;
    }
*/
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CNewCertTypeWelcome message handlers

LRESULT CNewCertTypeWelcome::OnWizardNext() 
{
	if (m_pwizHelp->fInEditCertTypeMode)
        return (IDD_NEWCERTTYPE_INFORMATION);
    else
        return 0;
}

BOOL CNewCertTypeWelcome::OnInitDialog() 
{
	CWizard97PropertyPage::OnInitDialog();

    CString szPropSheetTitle;
    szPropSheetTitle.LoadString(IDS_CERTIFICATE_TEMPLATE_WIZARD);
    SetWindowText(m_hWnd, szPropSheetTitle);
	
    SendMessage(GetDlgItem(IDC_WELCOME_BIGBOLD_STATIC), WM_SETFONT, (WPARAM)GetBigBoldFont(), MAKELPARAM(TRUE, 0));
    SendMessage(GetDlgItem(IDC_WELCOM_BOLD_STATIC), WM_SETFONT, (WPARAM)GetBigBoldFont(), MAKELPARAM(TRUE, 0));

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CNewCertTypeWelcome::OnSetActive() 
{
    PropSheet_SetWizButtons(GetParent(), PSWIZB_NEXT);
	
	return CWizard97PropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CNewCertTypeBaseType property page

CNewCertTypeBaseType::CNewCertTypeBaseType() :
    CWizard97PropertyPage(
	g_hInstance,
	CNewCertTypeBaseType::IDD,
	g_aidFont)
{
    m_szHeaderTitle.LoadString(IDS_BASE_TYPE_TITLE);
    m_szHeaderSubTitle.LoadString(IDS_BASE_TYPE_SUB_TITLE);
    InitWizard97 (FALSE);

    m_hLastSelectedCertType = NULL;
}

CNewCertTypeBaseType::~CNewCertTypeBaseType()
{
}

// replacement for DoDataExchange
BOOL CNewCertTypeBaseType::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
//        m_cstrModuleName.FromWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
    }
    else
    {
//        m_cstrModuleName.ToWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
    }
    return TRUE;
}

// replacement for BEGIN_MESSAGE_MAP
BOOL CNewCertTypeBaseType::OnCommand(WPARAM wParam, LPARAM lParam)
{
/*

    switch(LOWORD(wParam))
    {
    default:
        return FALSE;
        break;
    }
*/
    return TRUE;
}

BOOL CNewCertTypeBaseType::OnNotify(UINT idCtrl, NMHDR* pnmh)
{
    switch(idCtrl)
    {
    case IDC_BASE_CERT_TYPE_LIST:
        if (LVN_ITEMCHANGED == pnmh->code)
        {
            OnSelChange(pnmh);
            break;
        }
    default:
        return FALSE;
    }

    return TRUE;
}
/////////////////////////////////////////////////////////////////////////////
// CNewCertTypeBaseType message handlers

LRESULT CNewCertTypeBaseType::OnWizardBack() 
{
	return CWizard97PropertyPage::OnWizardBack();
}

LRESULT CNewCertTypeBaseType::OnWizardNext() 
{
	if (m_hSelectedCertType != m_hLastSelectedCertType)
    {
        if (m_hSelectedCertType == NULL)
        {
            m_pwizHelp->fBaseCertTypeUsed = FALSE;
            CleanUpCertTypeInfo(m_pwizHelp);
            m_pwizHelp->fCleanupOIDCheckBoxes = TRUE;

            // since there is no base type the key usage structure will not be initialized
            // with date, therefore we need to initialize the key usage structure with 0's
            m_pwizHelp->pKeyUsage = new(CRYPT_BIT_BLOB);
            if(m_pwizHelp->pKeyUsage == NULL)
            {
                return  CWizard97PropertyPage::OnWizardNext();
            }
            m_pwizHelp->pKeyUsage->cbData = 2;
            m_pwizHelp->pKeyUsage->pbData = m_pwizHelp->KeyUsageBytes;
            m_pwizHelp->pKeyUsage->cUnusedBits = 7;
        }
        else 
        {
            m_pwizHelp->fBaseCertTypeUsed = TRUE;
            FillInCertTypeInfo(m_hSelectedCertType, m_pwizHelp);
        }

        m_pwizHelp->fKeyUsageInitialized = FALSE;
        m_hLastSelectedCertType = m_hSelectedCertType;
    }

    
    ListView_GetItemText(m_hBaseCertTypeList, m_selectedIndex, 0, m_pwizHelp->pcstrBaseCertName->GetBuffer(MAX_PATH), MAX_PATH*sizeof(WCHAR));

    return CWizard97PropertyPage::OnWizardNext();
}

BOOL CNewCertTypeBaseType::OnSetActive() 
{
    PropSheet_SetWizButtons(GetParent(), PSWIZB_BACK | PSWIZB_NEXT);

	return CWizard97PropertyPage::OnSetActive();
}

void CNewCertTypeBaseType::OnSelChange(NMHDR * pNotifyStruct) 
{
    LPNMLISTVIEW        pListItem = (LPNMLISTVIEW) pNotifyStruct;

    if (pListItem->uNewState & LVIS_SELECTED)
    {
        m_hSelectedCertType = (HCERTTYPE) ListView_GetItemData(m_hBaseCertTypeList, pListItem->iItem);
        m_selectedIndex = pListItem->iItem;
    }
}


BOOL CNewCertTypeBaseType::OnInitDialog() 
{
	CWizard97PropertyPage::OnInitDialog();

    m_hBaseCertTypeList = GetDlgItem(m_hWnd, IDC_BASE_CERT_TYPE_LIST);
	
	HRESULT         hr;
    HCERTTYPE       hCertTypeNext;
    HCERTTYPE       hCertTypePrev;
    WCHAR **        aszCertTypeName;
    CString         szUsageString;
    int             i = 0;
    CString         szColumnHeading;
    CString         szNoBaseType;

    szColumnHeading.LoadString(IDS_COLUMN_NAME);
    ListView_NewColumn(m_hBaseCertTypeList, 0, 200, szColumnHeading, LVCFMT_LEFT);

    szColumnHeading.LoadString(IDS_COLUMN_INTENDED_PURPOSE);
    ListView_NewColumn(m_hBaseCertTypeList, 1, 200, szColumnHeading, LVCFMT_LEFT);

    // initialize the list with the <No Base Type> string selected
    szNoBaseType.LoadString(IDS_NO_BASE_TYPE);
    ListView_NewItem(m_hBaseCertTypeList, i++, szNoBaseType);
    ListView_SetItemState(m_hBaseCertTypeList, 0, LVIS_SELECTED, LVIS_SELECTED);
    m_selectedIndex = 0;

    // since there is no base type selected we need to initialize
    // the key usage structure
    m_pwizHelp->pKeyUsage = new(CRYPT_BIT_BLOB);
    if(m_pwizHelp->pKeyUsage == NULL)
    {
        return FALSE;
    }

    m_pwizHelp->pKeyUsage->cbData = 2;
    m_pwizHelp->pKeyUsage->pbData = m_pwizHelp->KeyUsageBytes;
    m_pwizHelp->pKeyUsage->cUnusedBits = 7;

    hr = CAEnumCertTypes(CT_ENUM_MACHINE_TYPES | CT_ENUM_USER_TYPES,
                         &hCertTypeNext);

    while ((hCertTypeNext != NULL) && (!FAILED(hr)))
    {
        //
        // add the cert type to the list of choices
        //
        hr = CAGetCertTypeProperty(
                hCertTypeNext,
                CERTTYPE_PROP_FRIENDLY_NAME,
                &aszCertTypeName);
    
	    ListView_NewItem(m_hBaseCertTypeList, i, aszCertTypeName[0], (LPARAM)hCertTypeNext);


        GetIntendedUsagesString(hCertTypeNext, &szUsageString);
        if (szUsageString == L"")
        {
            szUsageString.LoadString(IDS_ALL);
        }
        ListView_SetItemText(m_hBaseCertTypeList, i++, 1, (LPWSTR)(LPCTSTR)szUsageString);

        CAFreeCertTypeProperty(
                hCertTypeNext,
                aszCertTypeName);

        hCertTypePrev = hCertTypeNext;
        hCertTypeNext = NULL;
        hr = CAEnumNextCertType(hCertTypePrev, &hCertTypeNext);
    }

    ListView_SetColumnWidth(m_hBaseCertTypeList, 0, LVSCW_AUTOSIZE);
    ListView_SetColumnWidth(m_hBaseCertTypeList, 1, LVSCW_AUTOSIZE);

    
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CNewCertTypeBaseType::OnDestroy() 
{
	CWizard97PropertyPage::OnDestroy();
    
    int         i = 0;
    HCERTTYPE   hCertType;
    
    int iCount = ListView_GetItemCount(m_hBaseCertTypeList);

    for (i=0; i<iCount; i++)
    {
        hCertType = (HCERTTYPE) ListView_GetItemData(m_hBaseCertTypeList, i);

        if (hCertType != NULL)
            CACloseCertType(hCertType);
    }
}



/////////////////////////////////////////////////////////////////////////////
// CNewCertTypeBasicInformation property page

CNewCertTypeBasicInformation::CNewCertTypeBasicInformation() :
    CWizard97PropertyPage(
	g_hInstance,
	CNewCertTypeBasicInformation::IDD,
	g_aidFont)
{
    m_szHeaderTitle.LoadString(IDS_BASIC_INFORMATION_TITLE);
    m_szHeaderSubTitle.LoadString(IDS_BASIC_INFORMATION_SUB_TITLE);
    InitWizard97 (FALSE);
}

CNewCertTypeBasicInformation::~CNewCertTypeBasicInformation()
{
}

// replacement for DoDataExchange
BOOL CNewCertTypeBasicInformation::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
//        m_cstrModuleName.FromWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
    }
    else
    {
//        m_cstrModuleName.ToWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
    }
    return TRUE;
}

// replacement for BEGIN_MESSAGE_MAP
BOOL CNewCertTypeBasicInformation::OnCommand(WPARAM wParam, LPARAM lParam)
{
    switch(LOWORD(wParam))
    {
    case IDC_NEW_PURPOSE_BUTTON:
        if (HIWORD(wParam) == BN_CLICKED)
        {
            OnNewPurposeButton();
            break;
        }
    default:
        return FALSE;
        break;
    }
    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CNewCertTypeBasicInformation message handlers

BOOL WINAPI EnumCallback(PCCRYPT_OID_INFO pInfo, void *pvArg)
{
    CNewCertTypeBasicInformation *pDlg = (CNewCertTypeBasicInformation *) pvArg; 
    
    pDlg->AddEnumedEKU(pInfo);

    return TRUE;
}

void CNewCertTypeBasicInformation::AddEnumedEKU(PCCRYPT_OID_INFO pInfo)
{
    LPSTR pszOIDCopy;

    //
    // don't allow SGC oids
    //
    if (IsDisallowedOID(pInfo->pszOID))
    {
        return;
    }

    pszOIDCopy = (LPSTR) new(BYTE[strlen(pInfo->pszOID)+1]);

    if (pszOIDCopy != NULL)
    {
        strcpy(pszOIDCopy, pInfo->pszOID);
        
	    ListView_NewItem(m_hPurposeList, 0, pInfo->pwszName, (LPARAM)pszOIDCopy);
    }
}

void CNewCertTypeBasicInformation::UpdateWizHelp()
{
    unsigned int     i;
    int     cNumUsages;

    CString szName;
    szName.FromWindow(GetDlgItem(this->m_hWnd, IDC_CERTIFICATE_TEMPLATE_EDIT));
    *(m_pwizHelp->pcstrFriendlyName) = szName;

    m_pwizHelp->fAllowCAtoFillInInfo = (SendMessage(m_hButtonCAFillIn, BM_GETCHECK, 0, 0) == BST_CHECKED);
    m_pwizHelp->fAllowCAtoFillInInfo = (SendMessage(m_hButtonCritical, BM_GETCHECK, 0, 0) == BST_CHECKED);
    m_pwizHelp->fAllowCAtoFillInInfo = (SendMessage(m_hButtonIncludeEmail, BM_GETCHECK, 0, 0) == BST_CHECKED);
    m_pwizHelp->fAllowCAtoFillInInfo = (SendMessage(m_hButtonAllowAutoEnroll, BM_GETCHECK, 0, 0) == BST_CHECKED);
    m_pwizHelp->fAllowCAtoFillInInfo = (SendMessage(m_hButtonAdvanced, BM_GETCHECK, 0, 0) == BST_CHECKED);

    // clean up any EKU that alraedy exists
    for (i=0; i<m_pwizHelp->EnhancedKeyUsage.cUsageIdentifier; i++)
    {
        delete(m_pwizHelp->EnhancedKeyUsage.rgpszUsageIdentifier[i]);
    }
    if (m_pwizHelp->EnhancedKeyUsage.rgpszUsageIdentifier != NULL)
        delete(m_pwizHelp->EnhancedKeyUsage.rgpszUsageIdentifier);
    
    cNumUsages = ListView_GetSelectedCount(m_hPurposeList);

    // allocate memory and copy the oids
    m_pwizHelp->EnhancedKeyUsage.cUsageIdentifier = cNumUsages; 
    m_pwizHelp->EnhancedKeyUsage.rgpszUsageIdentifier = (LPSTR *) new (LPSTR[cNumUsages]);

    if(m_pwizHelp->EnhancedKeyUsage.rgpszUsageIdentifier == NULL)
    {
        return;
    }
    i = -1;
    while(-1 != (i = ListView_GetNextItem(m_hPurposeList, i, LVNI_SELECTED)) )
    {
        LPCSTR sz = (LPCSTR)ListView_GetItemData(m_hPurposeList, i);
        m_pwizHelp->EnhancedKeyUsage.rgpszUsageIdentifier[cNumUsages++] = AllocAndCopyStr(sz);
    }
}

LRESULT CNewCertTypeBasicInformation::OnWizardBack() 
{
	UpdateWizHelp();

    if (m_pwizHelp->fInEditCertTypeMode)
        return (IDD_NEWCERTTYPE_WELCOME);
    else
        return 0;
}

LRESULT CNewCertTypeBasicInformation::OnWizardNext() 
{
	CString szText0;

    szText0.FromWindow(GetDlgItem(m_hWnd, IDC_CERTIFICATE_TEMPLATE_EDIT));

    if (szText0 == L"")
    {
        CString szCaption;
        CString szText;

        szCaption.LoadString(IDS_CERTIFICATE_TEMPLATE_WIZARD);
        szText.LoadString(IDS_ENTER_CERTTYPE_NAME);
        MessageBox(m_hWnd, szText, szCaption, MB_OK | MB_ICONEXCLAMATION);
        SetFocus(GetDlgItem(m_hWnd, IDC_CERTIFICATE_TEMPLATE_EDIT));
        return -1;
    }

    UpdateWizHelp();

    return CWizard97PropertyPage::OnWizardNext();
}

BOOL CNewCertTypeBasicInformation::OnInitDialog() 
{
	CWizard97PropertyPage::OnInitDialog();

    m_hPurposeList = GetDlgItem(m_hWnd, IDC_PURPOSE_LIST);
    m_hButtonCAFillIn = GetDlgItem(m_hWnd, IDC_CA_FILL_IN_CHECK);
    m_hButtonCritical = GetDlgItem(m_hWnd, IDC_CRITICAL_CHECK);
    m_hButtonIncludeEmail = GetDlgItem(m_hWnd, IDC_INCLUDE_EMAIL_CHECK);
    m_hButtonAllowAutoEnroll = GetDlgItem(m_hWnd, IDC_ALLOW_AUTOENROLL_CHECK);
    m_hButtonAdvanced = GetDlgItem(m_hWnd, IDC_ADVANCED_OPTIONS_CHECK);

    CString szNewCertName;

    // set the name if we are in cert type edit mode
    if (m_pwizHelp->fInEditCertTypeMode)
    {
        SetDlgItemText(m_hWnd, IDC_CERTIFICATE_TEMPLATE_EDIT, *(m_pwizHelp->pcstrFriendlyName));
    }
    else
    {
        szNewCertName.LoadString(IDS_NEW_CERTIFICATE_TEMPLATE2);
        SetDlgItemText(m_hWnd, IDC_CERTIFICATE_TEMPLATE_EDIT, szNewCertName);
    }

    SendMessage(m_hButtonAdvanced, BM_SETCHECK, FALSE, 0);

    ListView_NewColumn(m_hPurposeList, 0, 0);
    ListView_SetExtendedListViewStyle(m_hPurposeList, LVS_EX_CHECKBOXES); 
    ListView_SetColumnWidth(m_hPurposeList, 0, LVSCW_AUTOSIZE);

	CryptEnumOIDInfo(CRYPT_ENHKEY_USAGE_OID_GROUP_ID, 0, (void *) this, EnumCallback);
	
	// set focus to the name edit
    SetFocus(GetDlgItem(m_hWnd, IDC_CERTIFICATE_TEMPLATE_EDIT));

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CNewCertTypeBasicInformation::OnDestroy() 
{
	CWizard97PropertyPage::OnDestroy();

    int     i, iCount;
    
    // clean up the OID strings that were set as the LPARAM's of each item
    iCount = ListView_GetItemCount(m_hPurposeList);

    for (i=0; i<iCount; i++)
    {
        delete (LPSTR) ListView_GetItemData(m_hPurposeList, i);
    }
}

void CNewCertTypeBasicInformation::InitializeOIDList()
{
    unsigned int     i,j;
    LPSTR   pszOID;
    BOOL    bFound;
    WCHAR   szOIDName[MAX_PATH];
    LPSTR   pszNewOID;

    // this means all usages are supported
    if (m_pwizHelp->EnhancedKeyUsage.cUsageIdentifier == 0)
    {
        unsigned int iCount = ListView_GetItemCount(m_hPurposeList);

        for (i=0; i<iCount; i++)
            ListView_SetCheckState(m_hPurposeList, i, TRUE);
    }
    else
    {
        // loop for each EKU that this certificate template supports
        for (i=0; i<m_pwizHelp->EnhancedKeyUsage.cUsageIdentifier; i++)
        {
            unsigned int iCount = ListView_GetItemCount(m_hPurposeList);

            bFound = FALSE;

            // see if this EKU is in the global list
            for (j=0; j<iCount; j++)
            {
                pszOID = (LPSTR)ListView_GetItemData(m_hPurposeList, j);

                if (strcmp(pszOID, m_pwizHelp->EnhancedKeyUsage.rgpszUsageIdentifier[i]) == 0)
                {
                    // if the EKU is in the global list, then just set the check box,
                    // and set the flag that it was found
                    ListView_SetCheckState(m_hPurposeList, j, TRUE);
                    bFound = TRUE;
                }
            }
            
            // if the EKU was not in the global list then insert it into the list view,
            // and set its check box
            if (!bFound)
            {
                if (!MyGetOIDInfo(szOIDName, ARRAYSIZE(szOIDName), m_pwizHelp->EnhancedKeyUsage.rgpszUsageIdentifier[i]))
                {
                    continue;
                }

                pszNewOID = (LPSTR) new(BYTE[strlen(m_pwizHelp->EnhancedKeyUsage.rgpszUsageIdentifier[i])+1]);
                if (pszNewOID == NULL)
                {
                    continue;
                }

                strcpy(pszNewOID, m_pwizHelp->EnhancedKeyUsage.rgpszUsageIdentifier[i]);
			    ListView_NewItem(m_hPurposeList, 0, szOIDName, (LPARAM)pszNewOID);
                ListView_SetCheckState(m_hPurposeList, 0, TRUE);
            }
        }
    }
}

BOOL CNewCertTypeBasicInformation::OnSetActive() 
{
    int     i;
    LPSTR   pszOID;

    PropSheet_SetWizButtons(GetParent(), PSWIZB_BACK | PSWIZB_NEXT);

    SendMessage(m_hButtonCAFillIn, BM_SETCHECK, m_pwizHelp->fAllowCAtoFillInInfo, 0);
    SendMessage(m_hButtonCritical, BM_SETCHECK, m_pwizHelp->fMarkEKUCritical, 0);
    SendMessage(m_hButtonIncludeEmail, BM_SETCHECK, m_pwizHelp->fIncludeEmail, 0);
    SendMessage(m_hButtonAllowAutoEnroll, BM_SETCHECK, m_pwizHelp->fAllowAutoEnroll, 0);

    if (m_pwizHelp->fBaseCertTypeUsed || m_pwizHelp->fInEditCertTypeMode)
    {
        InitializeOIDList();
    }
    else
    {
        if (m_pwizHelp->fCleanupOIDCheckBoxes)
        {
            int iCount = ListView_GetItemCount(m_hPurposeList);

            for (i=0; i<iCount; i++)
            {
                ListView_SetCheckState(m_hPurposeList, i, FALSE);
            }

            m_pwizHelp->fCleanupOIDCheckBoxes = FALSE;
        }
    }
	
	return CWizard97PropertyPage::OnSetActive();
}

#include <richedit.h>

INT_PTR APIENTRY NewOIDDialogProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    DWORD   i;
    char    szText[256];
    WCHAR   errorString[256];
    WCHAR   errorTitle[256];
    LPSTR   pszText = NULL;
        
    switch ( msg ) {

    case WM_INITDIALOG:

        SendDlgItemMessage(hwndDlg, IDC_EDIT1, EM_EXLIMITTEXT, 0, (LPARAM) 255);
        SetDlgItemText(hwndDlg, IDC_EDIT1, L"");
        SetFocus(GetDlgItem(hwndDlg, IDC_EDIT1));
        break;
    
    case WM_COMMAND:
        switch (LOWORD(wParam)) 
        {
        
        case IDOK:
            if (GetDlgItemTextA(
                        hwndDlg,
                        IDC_EDIT1,
                        szText,
                        ARRAYSIZE(szText)))
            {
                BOOL                fError = FALSE;
                CERT_ENHKEY_USAGE   KeyUsage;
                DWORD               cbData = 0;
                LPSTR               pszCheckOID;

                // 
                // make sure there are not weird characters
                //
                for (i=0; i<strlen(szText); i++)
                {
                    if (((szText[i] < '0') || (szText[i] > '9')) && (szText[i] != '.'))
                    {
                        fError = TRUE;
                        break;
                    }
                }

                //
                // check the first and last chars, and for the empty string
                //
                if (!fError)
                {
                    if ((szText[0] == '.') || (szText[strlen(szText)-1] == '.') || (strcmp(szText, "") == 0))
                    {
                        fError = TRUE; 
                    }
                }

                //
                // finally, make sure that it encodes properly
                //
                if (!fError)
                {
                    pszCheckOID = szText;
                    KeyUsage.rgpszUsageIdentifier = &pszCheckOID;
                    KeyUsage.cUsageIdentifier = 1;

                    if (!CryptEncodeObject(
                              X509_ASN_ENCODING,
                              szOID_ENHANCED_KEY_USAGE,
                              &KeyUsage,
                              NULL,
                              &cbData))
                    {
                        fError = TRUE;
                    }
                }


                //
                // if an error has occurred then display error
                //
                if (fError)
                {
                    LoadString(g_hInstance, IDS_ERRORINOID, errorString, ARRAYSIZE(errorString));
                    LoadString(g_hInstance, IDS_CERTIFICATE_TEMPLATE_WIZARD, errorTitle, ARRAYSIZE(errorTitle));
                    MessageBox(hwndDlg, errorString, errorTitle, MB_OK | MB_ICONERROR);
                    SendDlgItemMessage(hwndDlg, IDC_EDIT1, EM_SETSEL, 0, -1);
                    SetFocus(GetDlgItem(hwndDlg, IDC_EDIT1));
                    return FALSE;
                }

                //
                // don't allow SGC oids
                //
                if (IsDisallowedOID(szText))
                {
                    LoadString(g_hInstance, IDS_NOSPECIALOID, errorString, ARRAYSIZE(errorString));
                    LoadString(g_hInstance, IDS_CERTIFICATE_TEMPLATE_WIZARD, errorTitle, ARRAYSIZE(errorTitle));
                    MessageBox(hwndDlg, errorString, errorTitle, MB_OK | MB_ICONERROR);
                    SendDlgItemMessage(hwndDlg, IDC_EDIT1, EM_SETSEL, 0, -1);
                    SetFocus(GetDlgItem(hwndDlg, IDC_EDIT1));
                    return FALSE;
                }

                //
                // allocate space for the string and pass the string back
                //
                pszText = (LPSTR) new(BYTE[strlen(szText)+1]);
                if (pszText != NULL)
                {
                    strcpy(pszText, szText);
                }
            }

            EndDialog(hwndDlg, (INT_PTR) pszText);
            break;

        case IDCANCEL:
            EndDialog(hwndDlg, NULL);
            break;
        }
            
        break;
    }

    return FALSE;
}



BOOL CNewCertTypeBasicInformation::OIDAlreadyExist(LPSTR pszNewOID)
{
    int     i;
    LPSTR   pszOID;
    
    int iCount = ListView_GetItemCount(m_hPurposeList);
    for (i=0; i<iCount; i++)
    {
        pszOID = (LPSTR) ListView_GetItemData(m_hPurposeList, i);
        if (strcmp(pszOID, pszNewOID) == 0)
        {
            ListView_SetItemState(m_hPurposeList, i, LVIS_SELECTED, LVIS_SELECTED);
            ListView_SetCheckState(m_hPurposeList, i, TRUE);
            ListView_EnsureVisible(m_hPurposeList, i, FALSE);
            return TRUE;
        }
    }

    return FALSE;
}

void CNewCertTypeBasicInformation::OnNewPurposeButton() 
{   
    LPSTR   pszNewOID;
    WCHAR   szOIDName[MAX_PATH];

    pszNewOID = (LPSTR) ::DialogBox(
                            g_hInstance, 
                            MAKEINTRESOURCE(IDD_USER_PURPOSE),
                            m_hWnd,
                            NewOIDDialogProc);

    if (pszNewOID != NULL)
    {
        DWORD       chStores = 0;
        HCERTSTORE  *phStores = NULL;

        //
        // if the OID already exists then don't add it 
        //
        if (!OIDAlreadyExist(pszNewOID))
        {
            if (!MyGetOIDInfo(szOIDName, ARRAYSIZE(szOIDName), pszNewOID))
            {
                delete[](pszNewOID);
                return;
            }

            ListView_NewItem(m_hPurposeList, 0, szOIDName, (LPARAM)pszNewOID);
            ListView_SetCheckState(m_hPurposeList, 0, TRUE);
            ListView_EnsureVisible(m_hPurposeList, 0, FALSE);
        } 
    }
}
 



/////////////////////////////////////////////////////////////////////////////
// CNewCertTypeKeyUsage property page
CNewCertTypeKeyUsage::CNewCertTypeKeyUsage() :
    CWizard97PropertyPage(
	g_hInstance,
	CNewCertTypeKeyUsage::IDD,
	g_aidFont)
{
    m_szHeaderTitle.LoadString(IDS_KEY_USAGE_TITLE);
    m_szHeaderSubTitle.LoadString(IDS_KEY_USAGE_SUB_TITLE);
    InitWizard97 (FALSE); 
}

CNewCertTypeKeyUsage::~CNewCertTypeKeyUsage()
{
}

// replacement for DoDataExchange
BOOL CNewCertTypeKeyUsage::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
//        m_cstrModuleName.FromWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
    }
    else
    {
//        m_cstrModuleName.ToWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
    }
    return TRUE;
}

// replacement for BEGIN_MESSAGE_MAP
BOOL CNewCertTypeKeyUsage::OnCommand(WPARAM wParam, LPARAM lParam)
{
/*
    switch(LOWORD(wParam))
    {
    default:
        return FALSE;
        break;
    }
*/
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CNewCertTypeKeyUsage message handlers

void CNewCertTypeKeyUsage::UpdateWizHelp()
{
    if (BST_CHECKED == SendMessage(m_hButtonDataEncryption, BM_GETCHECK, 0, 0))
        m_pwizHelp->KeyUsageBytes[0] |= CERT_DATA_ENCIPHERMENT_KEY_USAGE;   
    else
        m_pwizHelp->KeyUsageBytes[0] &= ~CERT_DATA_ENCIPHERMENT_KEY_USAGE;   

    if (BST_CHECKED == SendMessage(m_hButtonDigitalSignature, BM_GETCHECK, 0, 0))
        m_pwizHelp->KeyUsageBytes[0] |= CERT_DIGITAL_SIGNATURE_KEY_USAGE;   
    else
        m_pwizHelp->KeyUsageBytes[0] &= ~CERT_DIGITAL_SIGNATURE_KEY_USAGE;   

    if (BST_CHECKED == SendMessage(m_hButtonEncipherOnly, BM_GETCHECK, 0, 0))
        m_pwizHelp->KeyUsageBytes[0] |= CERT_ENCIPHER_ONLY_KEY_USAGE;   
    else
        m_pwizHelp->KeyUsageBytes[0] &= ~CERT_ENCIPHER_ONLY_KEY_USAGE;   

    if (BST_CHECKED == SendMessage(m_hButtonKeyAgreement, BM_GETCHECK, 0, 0))
        m_pwizHelp->KeyUsageBytes[0] |= CERT_KEY_AGREEMENT_KEY_USAGE;   
    else
        m_pwizHelp->KeyUsageBytes[0] &= ~CERT_KEY_AGREEMENT_KEY_USAGE;   

    if (BST_CHECKED == SendMessage(m_hButtonKeyEncryption, BM_GETCHECK, 0, 0))
        m_pwizHelp->KeyUsageBytes[0] |= CERT_KEY_ENCIPHERMENT_KEY_USAGE;   
    else
        m_pwizHelp->KeyUsageBytes[0] &= ~CERT_KEY_ENCIPHERMENT_KEY_USAGE; 
    
    if (BST_CHECKED == SendMessage(m_hButtonPrevent, BM_GETCHECK, 0, 0))
        m_pwizHelp->KeyUsageBytes[0] |= CERT_NON_REPUDIATION_KEY_USAGE;   
    else
        m_pwizHelp->KeyUsageBytes[0] &= ~CERT_NON_REPUDIATION_KEY_USAGE; 

    if (BST_CHECKED == SendMessage(m_hButtonDecipherOnly, BM_GETCHECK, 0, 0))
        m_pwizHelp->KeyUsageBytes[1] |= CERT_DECIPHER_ONLY_KEY_USAGE;   
    else
        m_pwizHelp->KeyUsageBytes[1] &= ~CERT_DECIPHER_ONLY_KEY_USAGE; 


    m_pwizHelp->fMarkKeyUsageCritical = (BST_CHECKED == SendMessage(m_hButtonKeyUsageCritical, BM_GETCHECK, 0, 0));
}

LRESULT CNewCertTypeKeyUsage::OnWizardBack() 
{
	UpdateWizHelp();
	
	return CWizard97PropertyPage::OnWizardBack();
}

LRESULT CNewCertTypeKeyUsage::OnWizardNext() 
{
	UpdateWizHelp();
    
    //if (m_pwizHelp->BasicConstraints2.fCA)
     //   return (IDD_NEWCERTTYPE_CA_CERTIFICATE);
    //else
        return 0;
}

BOOL CNewCertTypeKeyUsage::OnInitDialog() 
{
	CWizard97PropertyPage::OnInitDialog();

    m_hButtonDataEncryption = GetDlgItem(m_hWnd, IDC_DATA_ENCRYPTION_CHECK);
    m_hButtonDecipherOnly = GetDlgItem(m_hWnd, IDC_DECIPHER_ONLY_CHECK);
    m_hButtonDigitalSignature = GetDlgItem(m_hWnd, IDC_DIGITAL_SIGNATURE_CHECK);
    m_hButtonEncipherOnly = GetDlgItem(m_hWnd, IDC_ENCIPHER_ONLY_CHECK);
    m_hButtonKeyAgreement = GetDlgItem(m_hWnd, IDC_KEY_AGREEMENT_CHECK);
    m_hButtonKeyEncryption = GetDlgItem(m_hWnd, IDC_KEY_ENCRYPTION_CHECK);
    m_hButtonKeyUsageCritical = GetDlgItem(m_hWnd, IDC_KEYUSAGE_CRITICAL_CHECK);
    m_hButtonPrevent = GetDlgItem(m_hWnd, IDC_PREVENT_CHECK);

    SendMessage(m_hButtonKeyUsageCritical, BM_SETCHECK, 0, 0);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CNewCertTypeKeyUsage::OnDestroy() 
{
	CWizard97PropertyPage::OnDestroy();
}

BOOL CNewCertTypeKeyUsage::OnSetActive() 
{
    PropSheet_SetWizButtons(GetParent(), PSWIZB_BACK | PSWIZB_NEXT);

    SendMessage(m_hButtonDataEncryption, BM_SETCHECK, ((m_pwizHelp->KeyUsageBytes[0] & CERT_DATA_ENCIPHERMENT_KEY_USAGE) != 0), 0);

    if (!m_pwizHelp->fKeyUsageInitialized && m_pwizHelp->fDigitalSignatureContainer && !m_pwizHelp->fBaseCertTypeUsed)
    {
        SendMessage(m_hButtonDigitalSignature, BM_SETCHECK, TRUE, 0);
        m_pwizHelp->fKeyUsageInitialized = TRUE;
    }
    else
    {
        SendMessage(m_hButtonDigitalSignature, BM_SETCHECK, ((m_pwizHelp->KeyUsageBytes[0] & CERT_DIGITAL_SIGNATURE_KEY_USAGE) != 0), 0);
    }

    SendMessage(m_hButtonEncipherOnly, BM_SETCHECK, ((m_pwizHelp->KeyUsageBytes[0] & CERT_ENCIPHER_ONLY_KEY_USAGE) != 0), 0);
    SendMessage(m_hButtonKeyAgreement, BM_SETCHECK, ((m_pwizHelp->KeyUsageBytes[0] & CERT_KEY_AGREEMENT_KEY_USAGE) != 0), 0);
    SendMessage(m_hButtonKeyEncryption, BM_SETCHECK, ((m_pwizHelp->KeyUsageBytes[0] & CERT_KEY_ENCIPHERMENT_KEY_USAGE) != 0), 0);
    SendMessage(m_hButtonPrevent, BM_SETCHECK, ((m_pwizHelp->KeyUsageBytes[0] & CERT_NON_REPUDIATION_KEY_USAGE) != 0), 0);
    SendMessage(m_hButtonDecipherOnly, BM_SETCHECK, ((m_pwizHelp->KeyUsageBytes[1] & CERT_DECIPHER_ONLY_KEY_USAGE) != 0), 0);
    SendMessage(m_hButtonKeyUsageCritical, BM_SETCHECK, m_pwizHelp->fMarkKeyUsageCritical, 0);

    //
    // now set the enable/disable state
    //
    if (m_pwizHelp->fDigitalSignatureContainer)
    {
        EnableWindow(m_hButtonDataEncryption, FALSE);     
        EnableWindow(m_hButtonDigitalSignature, TRUE);
        EnableWindow(m_hButtonEncipherOnly, FALSE);
        EnableWindow(m_hButtonKeyAgreement, FALSE);
        EnableWindow(m_hButtonKeyEncryption, FALSE);
        EnableWindow(m_hButtonPrevent, TRUE);
        EnableWindow(m_hButtonDecipherOnly, FALSE);
    }
    else
    {
        EnableWindow(m_hButtonDataEncryption, TRUE);     
        EnableWindow(m_hButtonDigitalSignature, TRUE);     
        EnableWindow(m_hButtonEncipherOnly, TRUE);     
        EnableWindow(m_hButtonKeyAgreement, TRUE);     
        EnableWindow(m_hButtonKeyEncryption, TRUE);     
        EnableWindow(m_hButtonPrevent, TRUE);     
        EnableWindow(m_hButtonDecipherOnly, TRUE);     
    }
	
	return CWizard97PropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CNewCertTypeCACertificate property page
CNewCertTypeCACertificate::CNewCertTypeCACertificate() :
    CWizard97PropertyPage(
	g_hInstance,
	CNewCertTypeCACertificate::IDD,
	g_aidFont)
{
    m_szHeaderTitle.LoadString(IDS_CA_CERTIFICATE_TITLE);
    m_szHeaderSubTitle.LoadString(IDS_CA_CERTIFICATE_SUB_TITLE);
    InitWizard97 (FALSE);
}

CNewCertTypeCACertificate::~CNewCertTypeCACertificate()
{
}

// replacement for DoDataExchange
BOOL CNewCertTypeCACertificate::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
//        m_cstrModuleName.FromWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
    }
    else
    {
//        m_cstrModuleName.ToWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
    }
    return TRUE;
}

// replacement for BEGIN_MESSAGE_MAP
BOOL CNewCertTypeCACertificate::OnCommand(WPARAM wParam, LPARAM lParam)
{
/*
    switch(LOWORD(wParam))
    {
    default:
        return FALSE;
        break;
    }
*/
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CNewCertTypeCACertificate message handlers

void CNewCertTypeCACertificate::UpdateWizHelp()
{
    if (BST_CHECKED == SendMessage(m_hButtonVerifySignature, BM_GETCHECK, 0, 0))
        m_pwizHelp->KeyUsageBytes[0] |= CERT_KEY_CERT_SIGN_KEY_USAGE;
    else
        m_pwizHelp->KeyUsageBytes[0] &= ~CERT_KEY_CERT_SIGN_KEY_USAGE;

    if (BST_CHECKED == SendMessage(m_hButtonIssueCRL, BM_GETCHECK, 0, 0))
        m_pwizHelp->KeyUsageBytes[0] |= CERT_CRL_SIGN_KEY_USAGE;
    else
        m_pwizHelp->KeyUsageBytes[0] &= ~CERT_CRL_SIGN_KEY_USAGE;
}

LRESULT CNewCertTypeCACertificate::OnWizardBack() 
{
	UpdateWizHelp();
	
	return CWizard97PropertyPage::OnWizardBack();
}

LRESULT CNewCertTypeCACertificate::OnWizardNext() 
{
	UpdateWizHelp();
	
	return CWizard97PropertyPage::OnWizardNext();
}

BOOL CNewCertTypeCACertificate::OnInitDialog() 
{
	CWizard97PropertyPage::OnInitDialog();

    m_hButtonVerifySignature = GetDlgItem(m_hWnd, IDC_VERIFY_SIGNATURE_CHECK);
    m_hButtonIssueCRL = GetDlgItem(m_hWnd, IDC_ISSUE_CRL_CHECK);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CNewCertTypeCACertificate::OnDestroy() 
{
	CWizard97PropertyPage::OnDestroy();
}

BOOL CNewCertTypeCACertificate::OnSetActive() 
{
    PropSheet_SetWizButtons(GetParent(), PSWIZB_BACK | PSWIZB_NEXT);

    SendMessage(m_hButtonIssueCRL, BM_SETCHECK, ((m_pwizHelp->KeyUsageBytes[0] & CERT_KEY_CERT_SIGN_KEY_USAGE) != 0), 0);
    SendMessage(m_hButtonIssueCRL, BM_SETCHECK, ((m_pwizHelp->KeyUsageBytes[0] & CERT_CRL_SIGN_KEY_USAGE) != 0), 0);

	return CWizard97PropertyPage::OnSetActive();
}




/////////////////////////////////////////////////////////////////////////////
// CNewCertTypeCompletion property page
CNewCertTypeCompletion::CNewCertTypeCompletion() :
    CWizard97PropertyPage(
	g_hInstance,
	CNewCertTypeCompletion::IDD,
	g_aidFont)
{
    InitWizard97 (TRUE);
}

CNewCertTypeCompletion::~CNewCertTypeCompletion()
{
}

// replacement for DoDataExchange
BOOL CNewCertTypeCompletion::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
//        m_cstrModuleName.FromWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
    }
    else
    {
//        m_cstrModuleName.ToWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
    }
    return TRUE;
}

// replacement for BEGIN_MESSAGE_MAP
BOOL CNewCertTypeCompletion::OnCommand(WPARAM wParam, LPARAM lParam)
{
/*
    switch(LOWORD(wParam))
    {
    default:
        return FALSE;
        break;
    }
*/
    return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// CNewCertTypeCompletion message handlers

BOOL CNewCertTypeCompletion::OnWizardFinish() 
{
	return CWizard97PropertyPage::OnWizardFinish();
}

LRESULT CNewCertTypeCompletion::OnWizardBack() 
{
	if (!m_pwizHelp->fShowAdvanced)
        return (IDD_NEWCERTTYPE_CONTROL);
    else if (m_pwizHelp->BasicConstraints2.fCA)
        return (IDD_NEWCERTTYPE_KEY_USAGE);
    else
        return 0;
}

void CNewCertTypeCompletion::AddResultsToSummaryList()
{
    int                 i = 0;
    unsigned int                 j;
    int                 listIndex = 0;
    CString             szItemName;
    CString             szItemText;
    PCCRYPT_OID_INFO    pOIDInfo;
    LPWSTR              pszOIDName;
    BOOL                bKeyUsageFirstItem = TRUE;
    WCHAR               szNumberString[256];

    // friendly name of cert template
    szItemName.LoadString(IDS_CERTIFICATE_TEMPLATE);

	ListView_NewItem(m_hSummaryList, i, szItemName);
    ListView_SetItemText(m_hSummaryList, i++, 1, (LPWSTR)(LPCTSTR) (*(m_pwizHelp->pcstrFriendlyName)) );
    
    // the base cert template that was used
    if (!m_pwizHelp->fInEditCertTypeMode)
    {
        szItemName.LoadString(IDS_BASE_CERTIFICATE_TEMPLATE);
		ListView_NewItem(m_hSummaryList, i, szItemName);
        ListView_SetItemText(m_hSummaryList, i++, 1, (LPWSTR)(LPCTSTR) (*(m_pwizHelp->pcstrBaseCertName)) );
    }

    // enhanced key usage list
    szItemName.LoadString(IDS_CERTIFICATE_PURPOSE_LIST);
	ListView_NewItem(m_hSummaryList, i, szItemName);

    if (m_pwizHelp->EnhancedKeyUsage.cUsageIdentifier == 0)
    {
        szItemText.LoadString(IDS_NONE);
        ListView_SetItemText(m_hSummaryList, i++, 1, (LPWSTR)(LPCTSTR)szItemText );
    }
    for (j=0; j<m_pwizHelp->EnhancedKeyUsage.cUsageIdentifier; j++)
    {
        if (j != 0)
        {
			ListView_NewItem(m_hSummaryList, i, L"");
        }
        
        pOIDInfo = CryptFindOIDInfo(
                        CRYPT_OID_INFO_OID_KEY,
                        m_pwizHelp->EnhancedKeyUsage.rgpszUsageIdentifier[j],
                        CRYPT_ENHKEY_USAGE_OID_GROUP_ID);

        if (pOIDInfo == NULL)
        {
            pszOIDName = MyMkWStr(m_pwizHelp->EnhancedKeyUsage.rgpszUsageIdentifier[j]);
            ListView_SetItemText(m_hSummaryList, i++, 1, pszOIDName);
            delete(pszOIDName);
        }
        else
        {
            ListView_SetItemText(m_hSummaryList, i++, 1, (LPWSTR)(LPCWSTR)pOIDInfo->pwszName);
        }
    }

    // enhanced key usage critical
    szItemName.LoadString(IDS_CERTIFICATE_PURPOSES_CRITICAL);
	ListView_NewItem(m_hSummaryList, i, szItemName);

    if (m_pwizHelp->fMarkEKUCritical)
        szItemText.LoadString(IDS_YES);
    else
        szItemText.LoadString(IDS_NO);
    ListView_SetItemText(m_hSummaryList, i++, 1, (LPWSTR)(LPCWSTR)szItemText);

    // include email address
    szItemName.LoadString(IDS_INCLUDE_EMAIL_ADDRESS);
	ListView_NewItem(m_hSummaryList, i, szItemName);

    if (m_pwizHelp->fIncludeEmail)
        szItemText.LoadString(IDS_YES);
    else
        szItemText.LoadString(IDS_NO);
    ListView_SetItemText(m_hSummaryList, i++, 1, (LPWSTR)(LPCWSTR)szItemText);

    // allow CA to fill in info
    szItemName.LoadString(IDS_ALLOW_CA_TO_FILL_IN);
	ListView_NewItem(m_hSummaryList, i, szItemName);

    if (m_pwizHelp->fAllowCAtoFillInInfo)
        szItemText.LoadString(IDS_YES);
    else
        szItemText.LoadString(IDS_NO);
    ListView_SetItemText(m_hSummaryList, i++, 1, (LPWSTR)(LPCWSTR)szItemText);

    // enabled for auto enroll
    szItemName.LoadString(IDS_ENABLED_FOR_AUTOENROLL);
	ListView_NewItem(m_hSummaryList, i, szItemName);

    if (m_pwizHelp->fAllowAutoEnroll)
        szItemText.LoadString(IDS_YES);
    else
        szItemText.LoadString(IDS_NO);
    ListView_SetItemText(m_hSummaryList, i++, 1, (LPWSTR)(LPCWSTR)szItemText);

    // KeyUsage
    szItemName.LoadString(IDS_PUBLIC_KEY_USAGE_LIST);
	ListView_NewItem(m_hSummaryList, i, szItemName);

    SetItemTextWrapper(
            IDS_DIGITAL_SIGNATURE_KEY_USAGE, 
            &i, 
            m_pwizHelp->KeyUsageBytes[0] & CERT_DIGITAL_SIGNATURE_KEY_USAGE, 
            &bKeyUsageFirstItem);

    SetItemTextWrapper(
            IDS_NON_REPUDIATION_KEY_USAGE, 
            &i, 
            m_pwizHelp->KeyUsageBytes[0] & CERT_NON_REPUDIATION_KEY_USAGE, 
            &bKeyUsageFirstItem);

    SetItemTextWrapper(
            IDS_DATA_ENCIPHERMENT_KEY_USAGE, 
            &i, 
            m_pwizHelp->KeyUsageBytes[0] & CERT_DATA_ENCIPHERMENT_KEY_USAGE, 
            &bKeyUsageFirstItem);
    
    SetItemTextWrapper(
            IDS_KEY_ENCIPHERMENT_KEY_USAGE, 
            &i, 
            m_pwizHelp->KeyUsageBytes[0] & CERT_KEY_ENCIPHERMENT_KEY_USAGE, 
            &bKeyUsageFirstItem);
    
    SetItemTextWrapper(
            IDS_KEY_AGREEMENT_KEY_USAGE, 
            &i, 
            m_pwizHelp->KeyUsageBytes[0] & CERT_KEY_AGREEMENT_KEY_USAGE, 
            &bKeyUsageFirstItem);

    SetItemTextWrapper(
            IDS_KEY_CERT_SIGN_KEY_USAGE, 
            &i, 
            m_pwizHelp->KeyUsageBytes[0] & CERT_KEY_CERT_SIGN_KEY_USAGE, 
            &bKeyUsageFirstItem);

    SetItemTextWrapper(
            IDS_OFFLINE_CRL_SIGN_KEY_USAGE, 
            &i, 
            m_pwizHelp->KeyUsageBytes[0] & CERT_CRL_SIGN_KEY_USAGE, 
            &bKeyUsageFirstItem);
    
    SetItemTextWrapper(
            IDS_ENCIPHER_ONLY_KEY_USAGE, 
            &i, 
            m_pwizHelp->KeyUsageBytes[0] & CERT_ENCIPHER_ONLY_KEY_USAGE, 
            &bKeyUsageFirstItem);

    SetItemTextWrapper(
            IDS_DECIPHER_ONLY_KEY_USAGE, 
            &i, 
            m_pwizHelp->KeyUsageBytes[1] & CERT_DECIPHER_ONLY_KEY_USAGE, 
            &bKeyUsageFirstItem);

    // KeyUsage critical
    szItemName.LoadString(IDS_PUBLIC_KEY_USAGE_CRITICAL);
	ListView_NewItem(m_hSummaryList, i, szItemName);

    if (m_pwizHelp->fMarkKeyUsageCritical)
        szItemText.LoadString(IDS_YES);
    else
        szItemText.LoadString(IDS_NO);
    ListView_SetItemText(m_hSummaryList, i++, 1, (LPWSTR)(LPCWSTR)szItemText);

    ListView_SetColumnWidth(m_hSummaryList, 0, LVSCW_AUTOSIZE);
    ListView_SetColumnWidth(m_hSummaryList, 1, LVSCW_AUTOSIZE);
}

BOOL CNewCertTypeCompletion::OnInitDialog() 
{
	CWizard97PropertyPage::OnInitDialog();

    m_hSummaryList = GetDlgItem(m_hWnd, IDC_SUMMARY_LIST);

    // firstlast page
    SendMessage(GetDlgItem(IDC_COMPLETION_BIGBOLD_STATIC), WM_SETFONT, (WPARAM)GetBigBoldFont(), MAKELPARAM(TRUE, 0));

    ListView_NewColumn(m_hSummaryList, 0, 50);
    ListView_NewColumn(m_hSummaryList, 1, 50);
    
    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CNewCertTypeCompletion::SetItemTextWrapper(UINT nID, int *piItem, BOOL fDoInsert, BOOL *pfFirstUsageItem)
{
    CString szOtherInfoName;
    
    if (fDoInsert)
    {
        szOtherInfoName.LoadString(nID);
        if (!(*pfFirstUsageItem))
        {
            LVITEM lvItem;
            lvItem.iItem = *piItem;
            lvItem.iSubItem = 0;
            ListView_InsertItem(m_hSummaryList, &lvItem);
        }
        else
        {
            *pfFirstUsageItem = FALSE;
        }
        ListView_SetItemText(m_hSummaryList, *piItem, 1, (LPWSTR)(LPCTSTR)szOtherInfoName);
        (*piItem)++;
    }
}

BOOL CNewCertTypeCompletion::OnSetActive() 
{
    PropSheet_SetWizButtons(GetParent(), PSWIZB_BACK | PSWIZB_FINISH);
    
    ListView_DeleteAllItems(m_hSummaryList);
    AddResultsToSummaryList();
    
    return CWizard97PropertyPage::OnSetActive();
}


HRESULT UpdateCertType(HCERTTYPE hCertType, 
                       PWIZARD_HELPER pwizHelp)
{
    HRESULT hr;
    LPWSTR  aszCertName[2];
    LPWSTR  *aszCSPList = NULL;
    DWORD   dwFlags;
    BOOL    fUseKeyUsage;
    BOOL    fUseBasicConstraints;
    unsigned int     i;

    //
    // get the flags for the cert type, then modify those, and reset the
    // flags at the end of this function
    //
    hr = CAGetCertTypeFlags(hCertType, &dwFlags);

    _JumpIfError(hr, error, "CAGetCertTypeFlags");

    //
    // key usage
    //
    fUseKeyUsage = (pwizHelp->KeyUsageBytes[0] != 0) || (pwizHelp->KeyUsageBytes[1] != 0);
    hr = CASetCertTypeExtension(
                hCertType,
                TEXT(szOID_KEY_USAGE),
                pwizHelp->fMarkKeyUsageCritical ? CA_EXT_FLAG_CRITICAL : 0,
                fUseKeyUsage ? pwizHelp->pKeyUsage : NULL);

    _JumpIfError(hr, error, "CASetCertTypeExtension");


    //
    // enhanced key usage
    //
    hr = CASetCertTypeExtension(
            hCertType,
            TEXT(szOID_ENHANCED_KEY_USAGE),
            pwizHelp->fMarkEKUCritical ? CA_EXT_FLAG_CRITICAL : 0,
            &(pwizHelp->EnhancedKeyUsage));
    _JumpIfError(hr, error, "CASetCertTypeExtension");


    //
    // basic constraints
    //
    fUseBasicConstraints = pwizHelp->BasicConstraints2.fCA;
    hr = CASetCertTypeExtension(
                hCertType,
                TEXT(szOID_BASIC_CONSTRAINTS2),
                0,
                fUseBasicConstraints ? &(pwizHelp->BasicConstraints2) : NULL);
    _JumpIfError(hr, error, "CASetCertTypeExtension");
    
    //
    // friendly name
    //
    aszCertName[0] = (LPWSTR) ((LPCTSTR) *(pwizHelp->pcstrFriendlyName));
    aszCertName[1] = NULL;
    hr = CASetCertTypeProperty(
                hCertType,
                CERTTYPE_PROP_FRIENDLY_NAME,
                aszCertName);
    _JumpIfError(hr, error, "CASetCertTypeProperty");

    //
    // digsig/exchange
    //
    if (pwizHelp->fDigitalSignatureContainer)
    {
        hr = CASetCertTypeKeySpec(hCertType, AT_SIGNATURE);
    }
    else
    {
        hr = CASetCertTypeKeySpec(hCertType, AT_KEYEXCHANGE);
    }
    _JumpIfError(hr, error, "CASetCertTypeKeySpec");

    //
    // csp list
    //
    aszCSPList = (LPWSTR *) new(LPWSTR[pwizHelp->cCSPs+1]);

    if(aszCSPList == NULL)
    {
        hr = E_OUTOFMEMORY;
        _JumpIfError(hr, error, "new");

    }

    ZeroMemory(aszCSPList, sizeof(LPWSTR)*(pwizHelp->cCSPs+1));

    //
    // copy each the array of CStrings to an array of LPWSTRs
    //
    for (i=0; i<pwizHelp->cCSPs; i++)
    {
        aszCSPList[i] = new(WCHAR[wcslen((LPCTSTR)pwizHelp->rgszCSPList[i])+1]);

        if (aszCSPList[i] == NULL)
        {
            hr = E_OUTOFMEMORY;
            _JumpIfError(hr, error, "new");
            break;
        }

        wcscpy(aszCSPList[i], (LPCTSTR)pwizHelp->rgszCSPList[i]);
    }

    //
    // NULL terminate the LPWSTR array and set the CSPlist property
    //
    if (i == pwizHelp->cCSPs)
    {
        aszCSPList[i] = NULL;
        hr = CASetCertTypeProperty(
                    hCertType,
                    CERTTYPE_PROP_CSP_LIST,
                    aszCSPList);
        _JumpIfError(hr, error, "CASetCertTypeProperty");
    }

    //
    // Acls
    //
    if(pwizHelp->pSD)
    {
        hr = CACertTypeSetSecurity(hCertType, pwizHelp->pSD);
        _JumpIfError(hr, error, "CACertTypeSetSecurity");

    }

    //
    // private key exportable, include email, allow CA to fill in name
    //
    if (pwizHelp->fPrivateKeyExportable)
    {
        dwFlags |= CT_FLAG_EXPORTABLE_KEY;
    }
    else
    {
        dwFlags &= ~CT_FLAG_EXPORTABLE_KEY;
    }

    if (pwizHelp->fIncludeEmail)
    {
        dwFlags |= CT_FLAG_ADD_EMAIL;
    }
    else
    {
        dwFlags &= ~CT_FLAG_ADD_EMAIL;
    }

    if (pwizHelp->fAllowAutoEnroll)
    {
        dwFlags |= CT_FLAG_AUTO_ENROLLMENT;
    }
    else
    {
        dwFlags &= ~CT_FLAG_AUTO_ENROLLMENT;
    }

    if (!pwizHelp->fAllowCAtoFillInInfo)
    {
        dwFlags |= CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT;
    }
    else
    {
        dwFlags &= ~CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT;
    }

    if (pwizHelp->fMachine)
    {
        dwFlags |= CT_FLAG_MACHINE_TYPE;
    }
    else
    {
        dwFlags &= ~CT_FLAG_MACHINE_TYPE;
    }

    if (pwizHelp->fPublishToDS)
    {
        dwFlags |= CT_FLAG_PUBLISH_TO_DS;
    }
    else
    {
        dwFlags &= ~CT_FLAG_PUBLISH_TO_DS;
    }

    if (pwizHelp->fAddTemplateName)
    {
        dwFlags |= CT_FLAG_ADD_TEMPLATE_NAME;
    }
    else
    {
        dwFlags &= ~CT_FLAG_ADD_TEMPLATE_NAME;
    }

    if (pwizHelp->fAddDirectoryPath)
    {
        dwFlags |= CT_FLAG_ADD_DIRECTORY_PATH;
    }
    else
    {
        dwFlags &= ~CT_FLAG_ADD_DIRECTORY_PATH;
    }

    hr = CASetCertTypeFlags(hCertType, dwFlags);

    _JumpIfError(hr, error, "CASetCertTypeFlags");
    //
    // make the call that actually writes the cached information
    //

     hr = CAUpdateCertType(hCertType);
     // So we can get logging
    _JumpIfError(hr, error, "CAUpdateCertType");

error:

    if(aszCSPList)
    {

        for (i=0; i<pwizHelp->cCSPs; i++)
        {
            if(aszCSPList[i])
            {
                delete[](aszCSPList[i]);
            }
        }
        delete[](aszCSPList);
    }

    return hr;
}

// returns the new certtype if a new one is being created, returns NULL
// if the hEditCertType parameter is non-NULL which means it is in edit mode
HCERTTYPE InvokeCertTypeWizard(HCERTTYPE hEditCertType, 
                               HWND hwndConsole)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    WIZARD_HELPER   wizHelp;
    ZeroMemory(&wizHelp, sizeof(wizHelp));

    int             i;
    HCERTTYPE       hNewCertType;
    HCERTTYPE       hRetCertType;
    HRESULT         hr;

    CWizard97PropertySheet PropSheet(
				g_hInstance,
				IDS_CERTIFICATE_TEMPLATE_WIZARD,
				IDB_WIZ_WATERMARK,
				IDB_WIZ_BANNER,
				TRUE);

    CString                         szPropSheetTitle;
    CNewCertTypeWelcome             WelcomePage;
    CNewCertTypeBaseType            BaseTypePage;
    CNewCertTypeBasicInformation    BasicInformationPage;
    CNewCertTypeKeyUsage            KeyUsagePage;
    CNewCertTypeCACertificate       CACertificatePage;
    CNewCertTypeCompletion          CompletionPage;

    wizHelp.pcstrFriendlyName = new(CString);
    if (wizHelp.pcstrFriendlyName == NULL)
        return NULL;

    wizHelp.pcstrBaseCertName = new(CString);
    if(wizHelp.pcstrBaseCertName == NULL)
        return NULL;

    hr = SetupFonts(g_hInstance, NULL, &wizHelp.BigBoldFont, &wizHelp.BoldFont);
    
    if (hEditCertType != NULL)
    {
        wizHelp.fInEditCertTypeMode = TRUE;
        FillInCertTypeInfo(hEditCertType, &wizHelp);
    }

    WelcomePage.m_pwizHelp = &wizHelp;
    WelcomePage.m_pWiz = &PropSheet;
    PropSheet.AddPage(&WelcomePage);
    
    BaseTypePage.m_pwizHelp = &wizHelp;
    BaseTypePage.m_pWiz = &PropSheet;
    PropSheet.AddPage(&BaseTypePage);

    BasicInformationPage.m_pwizHelp = &wizHelp;
    BasicInformationPage.m_pWiz = &PropSheet;
    PropSheet.AddPage(&BasicInformationPage);

    KeyUsagePage.m_pwizHelp = &wizHelp;
    KeyUsagePage.m_pWiz = &PropSheet;
    PropSheet.AddPage(&KeyUsagePage);

    CACertificatePage.m_pwizHelp = &wizHelp;
    CACertificatePage.m_pWiz = &PropSheet;
    PropSheet.AddPage(&CACertificatePage);

    CompletionPage.m_pwizHelp = &wizHelp;
    CompletionPage.m_pWiz = &PropSheet;
    PropSheet.AddPage(&CompletionPage);

    if (PropSheet.DoWizard(hwndConsole))
    {
        if (hEditCertType != NULL)
        {
            hr = UpdateCertType(hEditCertType, &wizHelp);
            hRetCertType = NULL;
        }
        else
        {
            GUID    guidContainerName;
            WCHAR   *sz = NULL;

            // generate a CN name for the new certtype
            RPC_STATUS rpcs = UuidCreate(&guidContainerName);
            rpcs = UuidToStringW(&guidContainerName, &sz);
            ASSERT(sz != NULL);

            hr = CACreateCertType(sz, NULL, 0, &hNewCertType);
            RpcStringFree(&sz);
            hr = UpdateCertType(hNewCertType, &wizHelp);
            hRetCertType = hNewCertType;
        }
    }
    else
    {
        hRetCertType = NULL;
    }

    CleanUpCertTypeInfo(&wizHelp);

    delete(wizHelp.pcstrFriendlyName);
    delete(wizHelp.pcstrBaseCertName);

    return hRetCertType;   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\celib\ceformat.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       ceformat.cpp
//
//  Contents:   helper functions
//
//--------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include "celib.h"
#include <assert.h>
#include <wininet.h>



HRESULT
ceDupString(
    IN WCHAR const *pwszIn,
    IN WCHAR **ppwszOut)
{
    DWORD cb;
    HRESULT hr;

    cb = (wcslen(pwszIn) + 1) * sizeof(WCHAR);
    *ppwszOut = (WCHAR *) LocalAlloc(LMEM_FIXED, cb);
    if (NULL == *ppwszOut)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(*ppwszOut, pwszIn, cb);
    hr = S_OK;

error:
    return(hr);
}


#define cwcCNMAX 	64		// 64 chars max for CN
#define cwcCHOPHASHMAX	(1 + 5)		// "-%05hu" decimal USHORT hash digits
#define cwcCHOPBASE 	(cwcCNMAX - (cwcCHOPHASHMAX + cwcSUFFIXMAX))

HRESULT
ceSanitizedNameToDSName(
    IN WCHAR const *pwszSanitizedName,
    OUT WCHAR **ppwszNameOut)
{
    HRESULT hr;
    DWORD cwc;
    DWORD cwcCopy;
    WCHAR wszDSName[cwcCHOPBASE + cwcCHOPHASHMAX + 1];

    *ppwszNameOut = NULL;

    cwc = wcslen(pwszSanitizedName);
    cwcCopy = cwc;
    if (cwcCHOPBASE < cwcCopy)
    {
	cwcCopy = cwcCHOPBASE;
    }
    CopyMemory(wszDSName, pwszSanitizedName, cwcCopy * sizeof(WCHAR));
    wszDSName[cwcCopy] = L'\0';

    if (cwcCHOPBASE < cwc)
    {
        // Hash the rest of the name into a USHORT
        USHORT usHash = 0;
	DWORD i;
	WCHAR *pwsz;

	// Truncate an incomplete sanitized Unicode character
	
	pwsz = wcsrchr(wszDSName, L'!');
	if (NULL != pwsz && wcslen(pwsz) < 5)
	{
	    cwcCopy -= wcslen(pwsz);
	    *pwsz = L'\0';
	}

        for (i = cwcCopy; i < cwc; i++)
        {
            USHORT usLowBit = (0x8000 & usHash)? 1 : 0;

	    usHash = ((usHash << 1) | usLowBit) + pwszSanitizedName[i];
        }
	wsprintf(&wszDSName[cwcCopy], L"-%05hu", usHash);
	assert(wcslen(wszDSName) < ARRAYSIZE(wszDSName));
    }

    hr = ceDupString(wszDSName, ppwszNameOut);
    _JumpIfError(hr, error, "ceDupString");

error:
    return(hr);
}


HRESULT
ceInternetCanonicalizeUrl(
    IN WCHAR const *pwszIn,
    OUT WCHAR **ppwszOut)
{
    HRESULT hr;
    WCHAR *pwsz = NULL;

    assert(NULL != pwszIn);

    // Calculate required buffer size by passing a very small buffer
    // The call will fail, and tell us how big the buffer should be.

    WCHAR wszPlaceHolder[1];
    DWORD cwc = ARRAYSIZE(wszPlaceHolder);
    BOOL bResult;

    bResult = InternetCanonicalizeUrl(
				pwszIn,		// lpszUrl
				wszPlaceHolder,	// lpszBuffer
				&cwc,		// lpdwBufferLength
				0);		// dwFlags
    assert(!bResult);	// This will always fail

    hr = ceHLastError();
    if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) != hr)
    {
        // unexpected error

        _JumpError(hr, error, "InternetCanonicalizeUrl");
    }

    // NOTE: InternetCanonicalizeUrl counts characters, not bytes as doc'd
    // cwc includes trailing L'0'

    pwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwsz)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    // canonicalize
    if (!InternetCanonicalizeUrl(
			    pwszIn,	// lpszUrl
			    pwsz,	// lpszBuffer
			    &cwc,	// lpdwBufferLength
			    0))		// dwFlags
    {
        hr = ceHLastError();
        _JumpError(hr, error, "InternetCanonicalizeUrl");
    }
    *ppwszOut = pwsz;
    pwsz = NULL;
    hr = S_OK;

error:
    if (NULL != pwsz)
    {
        LocalFree(pwsz);
    }
    return(hr);
}


// ceFormatCertsrvStringArray FormatMessage arguments:
//
// %1 -- Machine full DNS name: pwszServerName_p1_2;
//
// %2 -- Machine short name: first DNS component of pwszServerName_p1_2
//
// %3 -- Sanitized CA name: pwszSanitizedName_p3_7 
//
// %4 -- Cert Filename Suffix: L"" if 0 == iCert_p4; else L"(%u)"
//
// %5 -- DS DN path to Domain root: pwszDomainDN_p5
//
// %6 -- DS DN path to Configuration container: pwszConfigDN_p6
//
// %7 -- Sanitized CA name, truncated and hash suffix added if too long:
//	 pwszSanitizedName_p3_7
//
// %8 -- CRL Filename/Key Name Suffix: L"" if 0 == iCRL_p8; else L"(%u)"
//
// %9 -- CRL Filename Suffix: L"" if !fDeltaCRL_p9; else L"+"
//
// %10 -- DS CRL attribute: L"" if !fDSAttrib_p10_11; depends on fDeltaCRL_p9
//
// %11 -- DS CA Cert attribute: L"" if !fDSAttrib_p10_11

#ifndef wszDSSEARCHBASECRLATTRIBUTE
#define wszDSSEARCHBASECRLATTRIBUTE L"?certificateRevocationList?base?objectclass=cRLDistributionPoint"
#endif

#ifndef wszDSSEARCHDELTACRLATTRIBUTE
#define wszDSSEARCHDELTACRLATTRIBUTE L"?deltaRevocationList?base?objectclass=cRLDistributionPoint"
#endif

#ifndef wszDSSEARCHCACERTATTRIBUTE
#define wszDSSEARCHCACERTATTRIBUTE L"?cACertificate?base?objectclass=certificationAuthority"
#endif

HRESULT 
ceFormatCertsrvStringArray(
    IN BOOL    fURL,
    IN LPCWSTR pwszServerName_p1_2,
    IN LPCWSTR pwszSanitizedName_p3_7, 
    IN DWORD   iCert_p4,
    IN LPCWSTR pwszDomainDN_p5,
    IN LPCWSTR pwszConfigDN_p6, 
    IN DWORD   iCRL_p8,
    IN BOOL    fDeltaCRL_p9,
    IN BOOL    fDSAttrib_p10_11,
    IN DWORD   cStrings,
    IN LPCWSTR *apwszStringsIn,
    OUT LPWSTR *apwszStringsOut)
{
    HRESULT hr = S_OK;
    LPCWSTR apwszInsertionArray[100];  // 100 'cause this is the max number of insertion numbers allowed by FormatMessage
    LPWSTR    pwszCurrent = NULL;
    BSTR      strShortMachineName = NULL;
    DWORD     i;
    WCHAR *pwszSanitizedDSName = NULL;
    WCHAR wszCertSuffix[cwcFILENAMESUFFIXMAX];
    WCHAR wszCRLSuffix[cwcFILENAMESUFFIXMAX];
    WCHAR wszDeltaCRLSuffix[cwcFILENAMESUFFIXMAX];
    WCHAR const *pwszT;


    ZeroMemory(apwszStringsOut, cStrings * sizeof(apwszStringsOut[0]));
    ZeroMemory(apwszInsertionArray, sizeof(apwszInsertionArray));

    // Format the template into a real name

    // Initialize the insertion string array.
    // Machine DNS name (%1)    

    assert(L'1' == wszFCSAPARM_SERVERDNSNAME[1]);
    apwszInsertionArray[1 - 1] = pwszServerName_p1_2;

    // Short Machine Name (%2)

    assert(L'2' == wszFCSAPARM_SERVERSHORTNAME[1]);
    strShortMachineName = SysAllocString(pwszServerName_p1_2);
    if (strShortMachineName == NULL)
    {
        hr = E_OUTOFMEMORY;
        _JumpIfError(hr, error, "SysAllocString");
    }

    pwszCurrent = wcschr(strShortMachineName, L'.');
    if(pwszCurrent)
    {
        *pwszCurrent = 0;
    }
    apwszInsertionArray[2 - 1] = strShortMachineName;

    // sanitized name (%3)

    assert(L'3' == wszFCSAPARM_SANITIZEDCANAME[1]);
    apwszInsertionArray[3 - 1] = pwszSanitizedName_p3_7;  

    // Cert filename suffix (%4)

    assert(L'4' == wszFCSAPARM_CERTFILENAMESUFFIX[1]);
    wszCertSuffix[0] = L'\0';
    if (0 != iCert_p4)
    {
        wsprintf(wszCertSuffix, L"(%u)", iCert_p4);
    }
    apwszInsertionArray[4 - 1] = wszCertSuffix;  

    assert(L'5' == wszFCSAPARM_DOMAINDN[1]);
    apwszInsertionArray[5 - 1] = pwszDomainDN_p5;

    assert(L'6' == wszFCSAPARM_CONFIGDN[1]);
    apwszInsertionArray[6 - 1] = pwszConfigDN_p6;

    // Don't pass pwszSanitizedName_p3_7 to SysAllocStringLen with the extended
    // length to avoid faulting past end of pwszSanitizedName_p3_7.

    assert(L'7' == wszFCSAPARM_SANITIZEDCANAMEHASH[1]);
    hr = ceSanitizedNameToDSName(pwszSanitizedName_p3_7, &pwszSanitizedDSName);
    _JumpIfError(hr, error, "ceSanitizedNameToDSName");

    apwszInsertionArray[7 - 1] = pwszSanitizedDSName;

    // CRL filename suffix (%8)

    assert(L'8' == wszFCSAPARM_CRLFILENAMESUFFIX[1]);
    wszCRLSuffix[0] = L'\0';
    if (0 != iCRL_p8)
    {
        wsprintf(wszCRLSuffix, L"(%u)", iCRL_p8);
    }
    apwszInsertionArray[8 - 1] = wszCRLSuffix;  

    assert(L'9' == wszFCSAPARM_CRLDELTAFILENAMESUFFIX[1]);
    wszDeltaCRLSuffix[0] = L'\0';
    if (fDeltaCRL_p9)
    {
        wcscpy(wszDeltaCRLSuffix, L"+");
    }
    apwszInsertionArray[9 - 1] = wszDeltaCRLSuffix;  

    assert(L'1' == wszFCSAPARM_DSCRLATTRIBUTE[1]);
    assert(L'0' == wszFCSAPARM_DSCRLATTRIBUTE[2]);
    pwszT = L"";
    if (fDSAttrib_p10_11)
    {
	pwszT = fDeltaCRL_p9?
		    wszDSSEARCHDELTACRLATTRIBUTE :
		    wszDSSEARCHBASECRLATTRIBUTE;
    }
    apwszInsertionArray[10 - 1] = pwszT;  

    assert(L'1' == wszFCSAPARM_DSCACERTATTRIBUTE[1]);
    assert(L'1' == wszFCSAPARM_DSCACERTATTRIBUTE[2]);
    pwszT = L"";
    if (fDSAttrib_p10_11)
    {
	pwszT = wszDSSEARCHCACERTATTRIBUTE;
    }
    apwszInsertionArray[11 - 1] = pwszT;  

    for (i = 0; i < cStrings; i++)
    {
        if (0 == FormatMessage(
			FORMAT_MESSAGE_ALLOCATE_BUFFER |
			    FORMAT_MESSAGE_FROM_STRING |
			    FORMAT_MESSAGE_ARGUMENT_ARRAY,
			(VOID *) apwszStringsIn[i],
			0,              // dwMessageID
			0,              // dwLanguageID
			(LPWSTR) &apwszStringsOut[i], 
			wcslen(apwszStringsIn[i]),
			(va_list *) apwszInsertionArray))
        {
            hr = ceHLastError();
	    _JumpError(hr, error, "FormatMessage");
        }
	if (fURL)
	{
	    WCHAR *pwsz;
	    
	    hr = ceInternetCanonicalizeUrl(apwszStringsOut[i], &pwsz);
	    _JumpIfError(hr, error, "ceInternetCanonicalizeUrl");

	    LocalFree(apwszStringsOut[i]);
	    apwszStringsOut[i] = pwsz;
	}
    }

error:
    if (S_OK != hr)
    {
	for (i = 0; i < cStrings; i++)
	{
	    if (NULL != apwszStringsOut[i])
	    {
		LocalFree(apwszStringsOut[i]);
		apwszStringsOut[i] = NULL;
	    }
	}
    }
    if(strShortMachineName)
    {
        SysFreeString(strShortMachineName);
    }
    if (NULL != pwszSanitizedDSName)
    {
        LocalFree(pwszSanitizedDSName);
    }
    return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\celib\celib.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       celib.cpp
//
//  Contents:   helper functions
//
//--------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include "celib.h"
#include <assert.h>

//+--------------------------------------------------------------------------
// ceDecodeObject -- call CryptDecodeObject, and allocate memory for output
//
//+--------------------------------------------------------------------------

BOOL
ceDecodeObject(
    IN DWORD dwEncodingType,
    IN LPCSTR lpszStructType,
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN BOOL fCoTaskMemAlloc,
    OUT VOID **ppvStructInfo,
    OUT DWORD *pcbStructInfo)
{
    BOOL b;

    assert(!fCoTaskMemAlloc);
    *ppvStructInfo = NULL;
    *pcbStructInfo = 0;
    while (TRUE)
    {
	b = CryptDecodeObject(
		    dwEncodingType,
		    lpszStructType,
		    pbEncoded,
		    cbEncoded,
		    0,                  // dwFlags
		    *ppvStructInfo,
		    pcbStructInfo);
	if (b && 0 == *pcbStructInfo)
	{
	    SetLastError(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
	    b = FALSE;
	}
	if (!b)
	{
	    if (NULL != *ppvStructInfo)
	    {
		HRESULT hr = GetLastError();

		LocalFree(*ppvStructInfo);
		*ppvStructInfo = NULL;
		SetLastError(hr);
	    }
	    break;
	}
	if (NULL != *ppvStructInfo)
	{
	    break;
	}
	*ppvStructInfo = (BYTE *) LocalAlloc(LMEM_FIXED, *pcbStructInfo);
	if (NULL == *ppvStructInfo)
	{
	    b = FALSE;
	    break;
	}
    }
    return(b);
}


BOOL
ceEncodeObject(
    IN DWORD dwEncodingType,
    IN LPCSTR lpszStructType,
    IN VOID const *pvStructInfo,
    IN DWORD dwFlags,
    IN BOOL fCoTaskMemAlloc,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded)
{
    BOOL b;

    assert(0 == dwFlags);
    assert(!fCoTaskMemAlloc);
    *ppbEncoded = NULL;
    *pcbEncoded = 0;
    while (TRUE)
    {
	b = CryptEncodeObject(
		    dwEncodingType,
		    lpszStructType,
		    const_cast<VOID *>(pvStructInfo),
		    *ppbEncoded,
		    pcbEncoded);
	if (b && 0 == *pcbEncoded)
	{
	    SetLastError(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
	    b = FALSE;
	}
	if (!b)
	{
	    if (NULL != *ppbEncoded)
	    {
		HRESULT hr = GetLastError();

		LocalFree(*ppbEncoded);
		*ppbEncoded = NULL;
		SetLastError(hr);
	    }
	    break;
	}
	if (NULL != *ppbEncoded)
	{
	    break;
	}
	*ppbEncoded = (BYTE *) LocalAlloc(LMEM_FIXED, *pcbEncoded);
	if (NULL == *ppbEncoded)
	{
	    b = FALSE;
	    break;
	}
    }
    return(b);
}


// The returned pszObjId is a constant that must not be freed.  CryptFindOIDInfo
// has a static internal database that is valid until crypt32.dll is unloaded.

WCHAR const *
ceGetOIDNameA(
    IN char const *pszObjId)
{
    CRYPT_OID_INFO const *pInfo = NULL;
    WCHAR const *pwszName = L"";

    // First try looking up the ObjectId as an Extension or Attribute, because
    // we get a better Display Name, especially for Subject RDNs: CN, L, etc.
    // If that fails, look it up withoput restricting the group.

    pInfo = CryptFindOIDInfo(
			CRYPT_OID_INFO_OID_KEY,
			(VOID *) pszObjId,
			CRYPT_EXT_OR_ATTR_OID_GROUP_ID);

    if (NULL == pInfo || NULL == pInfo->pwszName || L'\0' == pInfo->pwszName[0])
    {
	pInfo = CryptFindOIDInfo(CRYPT_OID_INFO_OID_KEY, (VOID *) pszObjId, 0);
    }
    if (NULL != pInfo && NULL != pInfo->pwszName && L'\0' != pInfo->pwszName[0])
    {
	pwszName = pInfo->pwszName;
    }
    return(pwszName);
}


WCHAR const *
ceGetOIDName(
    IN WCHAR const *pwszObjId)
{
    char *pszObjId = NULL;
    WCHAR const *pwszName = L"";

    if (!ceConvertWszToSz(&pszObjId, pwszObjId, -1))
    {
	_JumpError(E_OUTOFMEMORY, error, "ceConvertWszToSz");
    }
    pwszName = ceGetOIDNameA(pszObjId);

error:
    if (NULL != pszObjId)
    {
	LocalFree(pszObjId);
    }
    return(pwszName);
}


WCHAR *
ceDuplicateString(
    IN WCHAR const *pwsz)
{
    WCHAR *pwszOut;

    pwszOut = (WCHAR *) LocalAlloc(
				LMEM_FIXED,
				(wcslen(pwsz) + 1) * sizeof(pwsz[0]));
    if (NULL != pwszOut)
    {
	wcscpy(pwszOut, pwsz);
    }
    return(pwszOut);
}


BOOL
ceConvertWszToSz(
    OUT CHAR **ppsz,
    IN WCHAR const *pwc,
    IN LONG cwc)
{
    BOOL fOk = FALSE;
    LONG cch = 0;

    *ppsz = NULL;
    while (TRUE)
    {
	cch = WideCharToMultiByte(
			GetACP(),
			0,          // dwFlags
			pwc,
			cwc,        // cchWideChar, -1 => null terminated
			*ppsz,
			cch,
			NULL,
			NULL);
	if (0 >= cch)
	{
	    DWORD err;

	    err = GetLastError();
	    ceERRORPRINTLINE("WideCharToMultiByte", err);
	    if (NULL != *ppsz)
	    {
		LocalFree(*ppsz);
		*ppsz = NULL;
	    }
	    break;
	}
	if (NULL != *ppsz)
	{
	    fOk = TRUE;
	    break;
	}
	*ppsz = (CHAR *) LocalAlloc(LMEM_FIXED, cch + 1);
	if (NULL == *ppsz)
	{
	    break;
	}
    }
    return(fOk);
}


BOOL
ceConvertWszToBstr(
    OUT BSTR *pbstr,
    IN WCHAR const *pwc,
    IN LONG cb)
{
    BOOL fOk = FALSE;
    BSTR bstr;

    ceFreeBstr(pbstr);
    do
    {
	bstr = NULL;
	if (NULL != pwc)
	{
	    if (-1 == cb)
	    {
		cb = wcslen(pwc) * sizeof(WCHAR);
	    }
	    bstr = SysAllocStringByteLen((char const *) pwc, cb);
	    if (NULL == bstr)
	    {
		break;
	    }
	}
	*pbstr = bstr;
	fOk = TRUE;
    } while (FALSE);
    return(fOk);
}


BOOL
ceConvertSzToWsz(
    OUT WCHAR **ppwsz,
    IN char const *pch,
    IN LONG cch)
{
    BOOL fOk = FALSE;
    LONG cwc = 0;

    *ppwsz = NULL;
    while (TRUE)
    {
	cwc = MultiByteToWideChar(GetACP(), 0, pch, cch, *ppwsz, cwc);
	if (0 >= cwc)
	{
	    DWORD err;

	    err = GetLastError();
	    ceERRORPRINTLINE("MultiByteToWideChar", err);
	    if (NULL != *ppwsz)
	    {
		LocalFree(*ppwsz);
		*ppwsz = NULL;
	    }
	    break;
	}
	if (NULL != *ppwsz)
	{
	    fOk = TRUE;
	    break;
	}
	*ppwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
	if (NULL == *ppwsz)
	{
	    break;
	}
    }
    return(fOk);
}


BOOL
ceConvertSzToBstr(
    OUT BSTR *pbstr,
    IN CHAR const *pch,
    IN LONG cch)
{
    BOOL fOk = FALSE;
    BSTR bstr = NULL;
    LONG cwc = 0;

    ceFreeBstr(pbstr);
    if (-1 == cch)
    {
	cch = strlen(pch);
    }
    while (TRUE)
    {
	cwc = MultiByteToWideChar(GetACP(), 0, pch, cch, bstr, cwc);
	if (0 >= cwc)
	{
	    //hr = ceHLastError();
	    //printf("MultiByteToWideChar returned %d (%x)\n", hr, hr);
	    break;
	}
	if (NULL != bstr)
	{
	    bstr[cwc] = L'\0';
	    *pbstr = bstr;
	    fOk = TRUE;
	    break;
	}
	bstr = SysAllocStringLen(NULL, cwc);
	if (NULL == bstr)
	{
	    break;
	}
    }
    return(fOk);
}


VOID
ceFreeBstr(
    IN OUT BSTR *pstr)
{
    if (NULL != *pstr)
    {
	SysFreeString(*pstr);
	*pstr = NULL;
    }
}


HRESULT
ceHError(
    IN HRESULT hr)
{
    assert(S_FALSE != hr);

    if (S_OK != hr && S_FALSE != hr && !FAILED(hr))
    {
        hr = HRESULT_FROM_WIN32(hr);
	if ((HRESULT) 0 == HRESULT_CODE(hr))
	{
	    // A call failed without properly setting an error condition!
	    hr = E_UNEXPECTED;
	}
	assert(FAILED(hr));
    }
    return(hr);
}


HRESULT
ceHLastError(VOID)
{
    return(ceHError(GetLastError()));
}


VOID
ceErrorPrintLine(
    IN char const *pszFile,
    IN DWORD line,
    IN char const *pszMessage,
    IN WCHAR const *pwszData,
    IN HRESULT hr)
{
    CHAR ach[4096];
    DWORD cch;

    cch = _snprintf(
		ach,
		sizeof(ach),
		"CeLib: Error: %hs(%u): %hs%hs%ws%hs 0x%x (%d)\n",
		pszFile,
		line,
		pszMessage,
		NULL == pwszData? "" : szLPAREN,
		NULL == pwszData? L"" : pwszData,
		NULL == pwszData? "" : szRPAREN,
		hr,
		hr);
    if (0 < cch)
    {
	strcpy(&ach[sizeof(ach) - 5], "...\n");
    }
    OutputDebugStringA(ach);
    wprintf(L"%hs", ach);
}


HRESULT
ceDateToFileTime(
    IN DATE const *pDate,
    OUT FILETIME *pft)
{
    SYSTEMTIME st;
    HRESULT hr = S_OK;

    if (*pDate == 0.0)
    {
        GetSystemTime(&st);
    }
    else
    {
	if (!VariantTimeToSystemTime(*pDate, &st))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "VariantTimeToSystemTime");
	}
    }

    if (!SystemTimeToFileTime(&st, pft))
    {
        hr = ceHLastError();
        _JumpError(hr, error, "SystemTimeToFileTime");
    }

error:
    return(hr);
}


HRESULT
ceFileTimeToDate(
    IN FILETIME const *pft,
    OUT DATE *pDate)
{
    SYSTEMTIME st;
    HRESULT hr = S_OK;

    if (!FileTimeToSystemTime(pft, &st))
    {
        hr = ceHLastError();
        _JumpError(hr, error, "FileTimeToSystemTime");
    }
    if (!SystemTimeToVariantTime(&st, pDate))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        _JumpError(hr, error, "SystemTimeToVariantTime");
    }

error:
    return(hr);
}


VOID
ceMakeExprDateTime(
    IN OUT FILETIME *pft,
    IN LONG lDelta,
    IN enum ENUM_PERIOD enumPeriod)
{
    LLFILETIME llft;
    LONGLONG llDelta;
    BOOL fSysTimeDelta;

    llft.ft = *pft;
    llDelta = lDelta;
    fSysTimeDelta = FALSE;
    switch (enumPeriod)
    {
	case ENUM_PERIOD_WEEKS:   llDelta *= CVT_WEEKS;    break;
	case ENUM_PERIOD_DAYS:    llDelta *= CVT_DAYS;     break;
	case ENUM_PERIOD_HOURS:   llDelta *= CVT_HOURS;    break;
	case ENUM_PERIOD_MINUTES: llDelta *= CVT_MINUTES;  break;
	case ENUM_PERIOD_SECONDS: 			   break;
	default:
	    fSysTimeDelta = TRUE;
	    break;
    }
    if (fSysTimeDelta)
    {
	SYSTEMTIME SystemTime;

	FileTimeToSystemTime(&llft.ft, &SystemTime);
	switch (enumPeriod)
	{
	    case ENUM_PERIOD_MONTHS:
		if (0 > lDelta)
		{
		    DWORD dwDelta = (DWORD) -lDelta;

		    SystemTime.wYear -= (WORD) (dwDelta / 12) + 1;
		    SystemTime.wMonth += 12 - (WORD) (dwDelta % 12);
		}
		else
		{
		    SystemTime.wMonth += (WORD) lDelta;
		}
		if (12 < SystemTime.wMonth)
		{
		    SystemTime.wYear += (SystemTime.wMonth - 1) / 12;
		    SystemTime.wMonth = ((SystemTime.wMonth - 1) % 12) + 1;
		}
		break;

	    case ENUM_PERIOD_YEARS:
		SystemTime.wYear += (WORD) lDelta;
		break;

	    default:
		SystemTime.wYear += 1;
		break;
	}

DoConvert:
        if (!SystemTimeToFileTime(&SystemTime, &llft.ft))
        {
            if (GetLastError() != ERROR_INVALID_PARAMETER)
            {
                assert(!"Unable to do time conversion");
                return;
            }

            // In some cases we'll convert to an invalid month-end

            // only one month changes length from year to year
            if (SystemTime.wMonth == 2)
            {
                // > 29? try leap year
                if (SystemTime.wDay > 29)
                {
                    SystemTime.wDay = 29;
                    goto DoConvert;
                }
                // == 29? try non-leap year
                else if (SystemTime.wDay == 29)
                {
                    SystemTime.wDay = 28;
                    goto DoConvert;
                }
            }
            // sept (9), apr(4), jun(6), nov(11) all have 30 days
            else if ((SystemTime.wMonth == 9) ||
                     (SystemTime.wMonth == 4) ||
                     (SystemTime.wMonth == 6) ||
                     (SystemTime.wMonth == 11))
            {
                if (SystemTime.wDay > 30)
                {
                    SystemTime.wDay = 30;
                    goto DoConvert;
                }
            }

            // should never get here
            assert(!"Month/year processing: inaccessible code");
            return;
        }
    }
    else
    {
	llft.ll += llDelta * CVT_BASE;
    }
    *pft = llft.ft;
}


HRESULT
ceMakeExprDate(
    IN OUT DATE *pDate,
    IN LONG lDelta,
    IN enum ENUM_PERIOD enumPeriod)
{
    HRESULT hr;
    FILETIME ft;

    hr = ceDateToFileTime(pDate, &ft);
    _JumpIfError(hr, error, "ceDateToFileTime");

    ceMakeExprDateTime(&ft, lDelta, enumPeriod);

    hr = ceFileTimeToDate(&ft, pDate);
    _JumpIfError(hr, error, "ceFileTimeToDate");

error:
    return(hr);
}


typedef struct _UNITSTABLE
{
    WCHAR const     *pwszString;
    enum ENUM_PERIOD enumPeriod;
} UNITSTABLE;


UNITSTABLE g_aut[] =
{
    { wszPERIODSECONDS, ENUM_PERIOD_SECONDS },
    { wszPERIODMINUTES, ENUM_PERIOD_MINUTES },
    { wszPERIODHOURS,   ENUM_PERIOD_HOURS },
    { wszPERIODDAYS,    ENUM_PERIOD_DAYS },
    { wszPERIODWEEKS,   ENUM_PERIOD_WEEKS },
    { wszPERIODMONTHS,  ENUM_PERIOD_MONTHS },
    { wszPERIODYEARS,   ENUM_PERIOD_YEARS },
};
#define CUNITSTABLEMAX	(sizeof(g_aut)/sizeof(g_aut[0]))


HRESULT
ceTranslatePeriodUnits(
    IN WCHAR const *pwszPeriod,
    IN LONG lCount,
    OUT enum ENUM_PERIOD *penumPeriod,
    OUT LONG *plCount)
{
    HRESULT hr;
    UNITSTABLE const *put;

    for (put = g_aut; put < &g_aut[CUNITSTABLEMAX]; put++)
    {
	if (0 == lstrcmpi(pwszPeriod, put->pwszString))
	{
	    *penumPeriod = put->enumPeriod;
	    if (0 > lCount)
	    {
		lCount = MAXLONG;
	    }
	    *plCount = lCount;
	    hr = S_OK;
	    goto error;
	}
    }
    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

error:
    return(hr);
}


//+-------------------------------------------------------------------------
// ceVerifyObjIdA - verify the passed pszObjId is valid as per X.208
//
// Encode and Decode the Object Id and make sure it suvives the round trip.
// The first number must be 0, 1 or 2.
// Enforce all characters are digits and dots.
// Enforce that no dot starts or ends the Object Id, and disallow double dots.
// Enforce there is at least one dot separator.
// If the first number is 0 or 1, the second number must be between 0 & 39.
// If the first number is 2, the second number can be any value.
//--------------------------------------------------------------------------

HRESULT
ceVerifyObjIdA(
    IN CHAR const *pszObjId)
{
    HRESULT hr;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    CRYPT_ATTRIBUTE ainfo;
    CRYPT_ATTRIBUTE *painfo = NULL;
    DWORD cbainfo;
    char const *psz;
    int i;

    ainfo.pszObjId = const_cast<char *>(pszObjId);
    ainfo.cValue = 0;
    ainfo.rgValue = NULL;

    if (!ceEncodeObject(
		    X509_ASN_ENCODING,
		    PKCS_ATTRIBUTE,
		    &ainfo,
		    0,
		    FALSE,
		    &pbEncoded,
		    &cbEncoded))
    {
	hr = ceHLastError();
	_JumpError(hr, error, "ceEncodeObject");
    }

    if (!ceDecodeObject(
		    X509_ASN_ENCODING,
		    PKCS_ATTRIBUTE,
		    pbEncoded,
		    cbEncoded,
		    FALSE,
		    (VOID **) &painfo,
		    &cbainfo))
    {
	hr = ceHLastError();
	_JumpError(hr, error, "ceDecodeObject");
    }

    hr = E_INVALIDARG;
    if (0 != strcmp(ainfo.pszObjId, painfo->pszObjId))
    {
	_JumpError(hr, error, "bad ObjId: decode mismatch");
    }
    for (psz = painfo->pszObjId; '\0' != *psz; psz++)
    {
	// must be a digit or a dot separator
	
	if (!isdigit(*psz))
	{
	    if ('.' != *psz)
	    {
		_JumpError(hr, error, "bad ObjId: bad char");
	    }

	    // can't have dot at start, double dots or dot at end

	    if (psz == painfo->pszObjId || '.' == psz[1] || '\0' == psz[1])
	    {
		_JumpError(hr, error, "bad ObjId: dot location");
	    }
	}
    }
    psz = strchr(painfo->pszObjId, '.');
    if (NULL == psz)
    {
	_JumpError(hr, error, "bad ObjId: must have at least one dot");
    }
    i = atoi(painfo->pszObjId);
    switch (i)
    {
	case 0:
	case 1:
	    i = atoi(++psz);
	    if (0 > i || 39 < i)
	    {
		_JumpError(hr, error, "bad ObjId: 0. or 1. must be followed by 0..39");
	    }
	    break;

	case 2:
	    break;

	default:
	    _JumpError(hr, error, "bad ObjId: must start with 0, 1 or 2");
    }
    hr = S_OK;

error:
    if (NULL != pbEncoded)
    {
    	LocalFree(pbEncoded);
    }
    if (NULL != painfo)
    {
    	LocalFree(painfo);
    }
    return(hr);
}


HRESULT
ceVerifyObjId(
    IN WCHAR const *pwszObjId)
{
    HRESULT hr;
    CHAR *pszObjId = NULL;

    if (!ceConvertWszToSz(&pszObjId, pwszObjId, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ceConvertWszToSz");
    }
    hr = ceVerifyObjIdA(pszObjId);
    _JumpIfErrorStr(hr, error, "ceVerifyObjIdA", pwszObjId);

error:
    if (NULL != pszObjId)
    {
    	LocalFree(pszObjId);
    }
    return(hr);
}


HRESULT
ceVerifyAltNameString(
    IN LONG NameChoice,
    IN WCHAR const *pwszName)
{
    HRESULT hr = S_OK;
    CERT_ALT_NAME_INFO AltName;
    CERT_ALT_NAME_ENTRY Entry;
    char *pszObjectId = NULL;
    DWORD cbEncoded;

    ZeroMemory(&AltName, sizeof(AltName));
    AltName.cAltEntry = 1;
    AltName.rgAltEntry = &Entry;

    ZeroMemory(&Entry, sizeof(Entry));
    Entry.dwAltNameChoice = NameChoice;

    switch (NameChoice)
    {
	case CERT_ALT_NAME_RFC822_NAME:
	    Entry.pwszRfc822Name = const_cast<WCHAR *>(pwszName);
	    break;

	case CERT_ALT_NAME_DNS_NAME:
	    Entry.pwszDNSName = const_cast<WCHAR *>(pwszName);
	    break;

	case CERT_ALT_NAME_URL:
	    Entry.pwszURL = const_cast<WCHAR *>(pwszName);
	    break;

	case CERT_ALT_NAME_REGISTERED_ID:
	    if (!ceConvertWszToSz(&pszObjectId, pwszName, -1))
	    {
		hr = E_OUTOFMEMORY;
		ceERRORPRINTLINE("ceConvertWszToSz", hr);
		goto error;
	    }
	    Entry.pszRegisteredID = pszObjectId;
	    break;

	//case CERT_ALT_NAME_DIRECTORY_NAME:
	//case CERT_ALT_NAME_OTHER_NAME:
	//case CERT_ALT_NAME_X400_ADDRESS:
	//case CERT_ALT_NAME_EDI_PARTY_NAME:
	//case CERT_ALT_NAME_IP_ADDRESS:
	default:
	    hr = E_INVALIDARG;
	    ceERRORPRINTLINE("NameChoice", hr);
	    goto error;
		
    }

    // Encode CERT_ALT_NAME_INFO:

    if (!CryptEncodeObject(
		    X509_ASN_ENCODING,
		    X509_ALTERNATE_NAME,
		    &AltName,
		    NULL,
		    &cbEncoded))
    {
	hr = ceHLastError();
	ceERRORPRINTLINE("ceEncodeObject", hr);
	goto error;
    }

error:
    if (NULL != pszObjectId)
    {
	LocalFree(pszObjectId);
    }
    return(hr);
}


HRESULT
ceDispatchSetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription,
    OPTIONAL IN WCHAR const *pwszProgId,
    OPTIONAL IN IID const *piid)
{
    HRESULT hr;
    ICreateErrorInfo *pCreateErrorInfo = NULL;
    IErrorInfo *pErrorInfo = NULL;
    WCHAR *pwszError = NULL;
    WCHAR *pwszText = NULL;

    if (NULL == pwszDescription)
    {
        hr = E_POINTER;
        ceERRORPRINTLINE("NULL pointer", hr);        
        goto error;
    }

    assert(FAILED(hrError));
    pwszError = ceGetErrorMessageText(hrError, TRUE);
    if (NULL == pwszError)
    {
	ceERRORPRINTLINE("ceGetErrorMessageText", E_OUTOFMEMORY);
    }
    else
    {
	pwszText = (WCHAR *) LocalAlloc(
	    LMEM_FIXED,
	    (wcslen(pwszDescription) + 1 + wcslen(pwszError) + 1) *
	     sizeof(WCHAR));
	if (NULL == pwszText)
	{
	    ceERRORPRINTLINE("LocalAlloc", E_OUTOFMEMORY);
	}
	else
	{
	    wcscpy(pwszText, pwszDescription);
	    wcscat(pwszText, L" ");
	    wcscpy(pwszText, pwszError);
	}
    }

    hr = CreateErrorInfo(&pCreateErrorInfo);
    if (S_OK != hr)
    {
        ceERRORPRINTLINE("CreateErrorInfo", hr);
        goto error;
    }

    if (NULL != piid)
    {
	hr = pCreateErrorInfo->SetGUID(*piid);
	if (S_OK != hr)
	{
	    ceERRORPRINTLINE("SetGUID", hr);
	}
    }

    hr = pCreateErrorInfo->SetDescription(
		    NULL != pwszText?
			pwszText : const_cast<WCHAR *>(pwszDescription));
    if (S_OK != hr)
    {
	ceERRORPRINTLINE("SetDescription", hr);
    }

    // Set ProgId:

    if (NULL != pwszProgId)
    {
	hr = pCreateErrorInfo->SetSource(const_cast<WCHAR *>(pwszProgId));
	if (S_OK != hr)
	{
	    ceERRORPRINTLINE("SetSource", hr);
	}
    }

    hr = pCreateErrorInfo->QueryInterface(
				    IID_IErrorInfo,
				    (VOID **) &pErrorInfo);
    if (S_OK != hr)
    {
        ceERRORPRINTLINE("QueryInterface", hr);
        goto error;
    }

    SetErrorInfo(0, pErrorInfo);

error:
    if (NULL != pErrorInfo)
    {
	pErrorInfo->Release();
    }
    if (NULL != pCreateErrorInfo)
    {
	pCreateErrorInfo->Release();
    }
    if (NULL != pwszText)
    {
	LocalFree(pwszText);
    }
    if (NULL != pwszError)
    {
	LocalFree(pwszError);
    }
    return(hrError);	// return input error!
}


int 
ceWtoI(
    IN WCHAR const *string,
    OUT BOOL *pfValid)
{
    HRESULT hr;
    WCHAR szBuf[16];
    WCHAR *szTmp = szBuf;
    int cTmp = ARRAYSIZE(szBuf);
    int i = 0;
    WCHAR const *pwsz;
    BOOL fSawDigit = FALSE;

    if (pfValid == NULL)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULLPARAM");
    }
    *pfValid = FALSE;
 
    assert(NULL != pfValid);
    cTmp = FoldString(
        MAP_FOLDDIGITS, 
        string,
        -1,
        szTmp,
        cTmp);
    if (cTmp == 0)
    {
        hr = ceHLastError();
        if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hr)
        {
            hr = S_OK;
            cTmp = FoldString(
                MAP_FOLDDIGITS, 
                string,
                -1,
                NULL,
                0);

            szTmp = (WCHAR*)LocalAlloc(LMEM_FIXED, cTmp*sizeof(WCHAR));
	    if (NULL == szTmp)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }

            cTmp = FoldString(
                MAP_FOLDDIGITS, 
                string,
                -1,
                szTmp,
                cTmp);

            if (cTmp == 0)
                hr = ceHLastError();
        }
        _JumpIfError(hr, error, "FoldString");
    }    
    pwsz = szTmp;
    while (iswspace(*pwsz))
    {
	pwsz++;
    }
    while (iswdigit(*pwsz))
    {
	fSawDigit = TRUE;
	pwsz++;
    }
    while (iswspace(*pwsz))
    {
	pwsz++;
    }
    if (L'\0' == *pwsz)
    {
	*pfValid = fSawDigit;
    }
    i = _wtoi(szTmp);

error:
    if (szTmp && (szTmp != szBuf))
       LocalFree(szTmp);

    return i;
}


HRESULT
ceGetMachineDnsName(
    OUT WCHAR **ppwszDnsName)
{
    HRESULT hr;
    WCHAR *pwszDnsName = NULL;
    DWORD cwc;
    COMPUTER_NAME_FORMAT NameType = ComputerNameDnsFullyQualified;

    *ppwszDnsName = NULL;
    while (TRUE)
    {
	cwc = 0;
	if (!GetComputerNameEx(NameType, NULL, &cwc))
	{
	    hr = ceHLastError();
	    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr &&
		ComputerNameDnsFullyQualified == NameType)
	    {
		_PrintError(hr, "GetComputerNameEx(DnsFullyQualified) -- switching to NetBIOS");
		NameType = ComputerNameNetBIOS;
		continue;
	    }
	    if (HRESULT_FROM_WIN32(ERROR_MORE_DATA) != hr)
	    {
		_JumpError(hr, error, "GetComputerNameEx");
	    }
	    break;
	}
    }
    pwszDnsName = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwszDnsName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    if (!GetComputerNameEx(NameType, pwszDnsName, &cwc))
    {
	hr = ceHLastError();
	_JumpError(hr, error, "GetComputerNameEx");
    }

    *ppwszDnsName = pwszDnsName;
    pwszDnsName = NULL;
    hr = S_OK;

error:
    if (NULL != pwszDnsName)
    {
	LocalFree(pwszDnsName);
    }
    return(hr);
}


HRESULT
ceGetComputerNames(
    OUT WCHAR **ppwszDnsName,
    OUT WCHAR **ppwszOldName)
{
    HRESULT hr;
    DWORD cwc;
    WCHAR *pwszOldName = NULL;

    *ppwszOldName = NULL;
    *ppwszDnsName = NULL;

    cwc = MAX_COMPUTERNAME_LENGTH + 1;
    pwszOldName = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwszOldName)
    {
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
    }
    if (!GetComputerName(pwszOldName, &cwc))
    {
        hr = ceHLastError();
        _JumpError(hr, error, "GetComputerName");
    }

    hr = ceGetMachineDnsName(ppwszDnsName);
    _JumpIfError(hr, error, "ceGetMachineDnsName");

    *ppwszOldName = pwszOldName;
    pwszOldName = NULL;

error:
    if (NULL != pwszOldName)
    {
	LocalFree(pwszOldName);
    }
    return(hr);
}


HRESULT
_IsConfigLocal(
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszDnsName,
    IN WCHAR const *pwszOldName,
    OPTIONAL OUT WCHAR **ppwszMachine,
    OUT BOOL *pfLocal)
{
    HRESULT hr;
    WCHAR *pwszMachine = NULL;
    WCHAR const *pwsz;
    DWORD cwc;

    *pfLocal = FALSE;
    if (NULL != ppwszMachine)
    {
	*ppwszMachine = NULL;
    }

    while (L'\\' == *pwszConfig)
    {
	pwszConfig++;
    }
    pwsz = wcschr(pwszConfig, L'\\');
    if (NULL != pwsz)
    {
	cwc = SAFE_SUBTRACT_POINTERS(pwsz, pwszConfig);
    }
    else
    {
	cwc = wcslen(pwszConfig);
    }
    pwszMachine = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
    if (NULL == pwszMachine)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(pwszMachine, pwszConfig, cwc * sizeof(WCHAR));
    pwszMachine[cwc] = L'\0';

    if (0 == lstrcmpi(pwszMachine, pwszDnsName) ||
	0 == lstrcmpi(pwszMachine, pwszOldName))
    {
	*pfLocal = TRUE;
    }
    if (NULL != ppwszMachine)
    {
	*ppwszMachine = pwszMachine;
	pwszMachine = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pwszMachine)
    {
	LocalFree(pwszMachine);
    }
    return(hr);
}


HRESULT
ceIsConfigLocal(
    IN WCHAR const *pwszConfig,
    OPTIONAL OUT WCHAR **ppwszMachine,
    OUT BOOL *pfLocal)
{
    HRESULT hr;
    WCHAR *pwszDnsName = NULL;
    WCHAR *pwszOldName = NULL;

    *pfLocal = FALSE;
    if (NULL != ppwszMachine)
    {
	*ppwszMachine = NULL;
    }

    hr = ceGetComputerNames(&pwszDnsName, &pwszOldName);
    _JumpIfError(hr, error, "ceGetComputerNames");

    hr = _IsConfigLocal(
		    pwszConfig,
		    pwszDnsName,
		    pwszOldName,
		    ppwszMachine,
		    pfLocal);
    _JumpIfError(hr, error, "_IsConfigLocal");

error:
    if (NULL != pwszDnsName)
    {
	LocalFree(pwszDnsName);
    }
    if (NULL != pwszOldName)
    {
	LocalFree(pwszOldName);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certadm\certadm.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certadm.cpp
//
// Contents:    Cert Server client implementation
//
// History:     24-Aug-96       vich created
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include <objbase.h>
#include "certsrvd.h"

#include "admin.h"
#include "csview.h"		// CertView includes

#include "manage.h"

CComModule _Module;

HINSTANCE g_hInstance = NULL;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CCertAdmin, CCertAdmin)
#include "csviewm.h"		// CertView object map entries
    OBJECT_ENTRY(CLSID_CCertManagePolicyModule, CCertManagePolicyModule)
    OBJECT_ENTRY(CLSID_CCertManageExitModule, CCertManageExitModule)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    switch (dwReason)
    {
	case DLL_PROCESS_ATTACH:
            g_hInstance = hInstance;
	    _Module.Init(ObjectMap, hInstance);
	    DisableThreadLibraryCalls(hInstance);
	    break;

        case DLL_PROCESS_DETACH:
	    _Module.Term();
            break;
    }
    return(TRUE);    // ok
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI
DllCanUnloadNow(void)
{
    return(_Module.GetLockCount() == 0? S_OK : S_FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI
DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;
    
    hr = _Module.GetClassObject(rclsid, riid, ppv);
    if (S_OK == hr && NULL != *ppv)
    {
	myRegisterMemFree(*ppv, CSM_NEW | CSM_GLOBALDESTRUCTOR);
    }
    return(hr);
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI
DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return(_Module.RegisterServer(TRUE));
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI
DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certadm\admin.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        admin.cpp
//
// Contents:    Cert Server admin implementation
//
// History:     24-Aug-96       vich created
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include <objbase.h>
#include "certsrvd.h"

#include "certbcli.h"
#include "csprop.h"
#include "csdisp.h"
#include "admin.h"
#include "certadmp.h"
#include "config.h"

#define __dwFILE__	__dwFILE_CERTADM_ADMIN_CPP__


//+--------------------------------------------------------------------------
// CCertAdmin::~CCertAdmin -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertAdmin::~CCertAdmin()
{
    _Cleanup();
}


//+--------------------------------------------------------------------------
// CCertAdmin::_CleanupOldConnection -- free memory
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

VOID
CCertAdmin::_CleanupOldConnection()
{
    _CleanupCAPropInfo();
}


//+--------------------------------------------------------------------------
// CCertAdmin::_Cleanup -- free memory
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

VOID
CCertAdmin::_Cleanup()
{
    _CloseConnection();
    _CleanupOldConnection();
}


//+--------------------------------------------------------------------------
// CCertAdmin::_OpenConnection -- get DCOM object interface
//
//+--------------------------------------------------------------------------

HRESULT
CCertAdmin::_OpenConnection(
    IN WCHAR const *pwszConfig,
    IN DWORD RequiredVersion,
    OUT WCHAR const **ppwszAuthority)
{
    HRESULT hr;

    hr = myOpenAdminDComConnection(
			pwszConfig,
			ppwszAuthority,
			&m_pwszServerName,
			&m_dwServerVersion,
			&m_pICertAdminD);
    _JumpIfError(hr, error, "myOpenAdminDComConnection");

    CSASSERT(NULL != m_pICertAdminD);
    CSASSERT(0 != m_dwServerVersion);

    if (m_dwServerVersion < RequiredVersion)
    {
	hr = RPC_E_VERSION_MISMATCH;
	_JumpError(hr, error, "old server");
    }

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertAdmin::_CloseConnection -- release DCOM object
//
//+--------------------------------------------------------------------------

VOID
CCertAdmin::_CloseConnection()
{
    myCloseDComConnection((IUnknown **) &m_pICertAdminD, &m_pwszServerName);
    m_dwServerVersion = 0;
}


//+--------------------------------------------------------------------------
// CCertAdmin::IsValidCertificate -- Verify certificate validity
//
// ...
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertAdmin::IsValidCertificate(
    /* [in] */ BSTR const strConfig,
    /* [in] */ BSTR const strSerialNumber,
    /* [out, retval] */ LONG *pDisposition)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;

    if (NULL == strSerialNumber || NULL == pDisposition)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    hr = _OpenConnection(strConfig, 1, &pwszAuthority);
    _JumpIfError(hr, error, "_OpenConnection");

    m_fRevocationReasonValid = FALSE;
    __try
    {
	hr = m_pICertAdminD->IsValidCertificate(
					    pwszAuthority,
					    strSerialNumber,
					    &m_RevocationReason,
					    pDisposition);

        if (S_OK != hr || CA_DISP_REVOKED != *pDisposition)
        {
            m_fRevocationReasonValid = FALSE;
        }
        else
        {
	    m_fRevocationReasonValid = TRUE;
        }
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "IsValidCertificate");

    m_fRevocationReasonValid = TRUE;

error:
    hr = myHError(hr);
    return(_SetErrorInfo(hr, L"CCertAdmin::IsValidCertificate"));
}


//+--------------------------------------------------------------------------
// CCertAdmin::GetRevocationReason -- Get Revocation Reason
//
// ...
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertAdmin::GetRevocationReason(
    /* [out, retval] */ LONG *pReason)
{
    HRESULT hr = S_OK;

    if (NULL == pReason)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (!m_fRevocationReasonValid)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "m_fRevocationReasonValid");
    }
    *pReason = m_RevocationReason;

error:
    return(_SetErrorInfo(hr, L"CCertAdmin::GetRevocationReason"));
}


//+--------------------------------------------------------------------------
// CCertAdmin::RevokeCertificate -- Revoke a certificate
//
// ...
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertAdmin::RevokeCertificate(
    /* [in] */ BSTR const strConfig,
    /* [in] */ BSTR const strSerialNumber,
    /* [in] */ LONG Reason,
    /* [in] */ DATE Date)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;
    FILETIME ft;

    if (NULL == strConfig || NULL == strSerialNumber)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    hr = myDateToFileTime(&Date, &ft);
    _JumpIfError(hr, error, "myDateToFileTime");

    hr = _OpenConnection(strConfig, 1, &pwszAuthority);
    _JumpIfError(hr, error, "_OpenConnection");

    __try
    {
	hr = m_pICertAdminD->RevokeCertificate(
					pwszAuthority,
					strSerialNumber,
					Reason,
					ft);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "RevokeCertificate");

error:
    hr = myHError(hr);
    return(_SetErrorInfo(hr, L"CCertAdmin::RevokeCertificate"));
}


//+--------------------------------------------------------------------------
// CCertAdmin::SetRequestAttributes -- Add request attributes
//
// ...
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertAdmin::SetRequestAttributes(
    /* [in] */ BSTR const strConfig,
    /* [in] */ LONG RequestId,
    /* [in] */ BSTR const strAttributes)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;

    if (NULL == strAttributes)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    hr = _OpenConnection(strConfig, 1, &pwszAuthority);
    _JumpIfError(hr, error, "_OpenConnection");

    __try
    {
	hr = m_pICertAdminD->SetAttributes(
				    pwszAuthority,
				    (DWORD) RequestId,
				    strAttributes);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "SetAttributes");

error:
    hr = myHError(hr);
    return(_SetErrorInfo(hr, L"CCertAdmin::SetRequestAttributes"));
}


//+--------------------------------------------------------------------------
// CCertAdmin::SetCertificateExtension -- Set a Certificate Extension
//
// ...
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertAdmin::SetCertificateExtension(
    /* [in] */ BSTR const strConfig,
    /* [in] */ LONG RequestId,
    /* [in] */ BSTR const strExtensionName,
    /* [in] */ LONG Type,
    /* [in] */ LONG Flags,
    /* [in] */ VARIANT const *pvarValue)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;
    BSTR str;
    CERTTRANSBLOB ctbValue;
    LONG lval;

    ctbValue.pb = NULL;

    if (NULL == strExtensionName || NULL == pvarValue)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    hr = _OpenConnection(strConfig, 1, &pwszAuthority);
    _JumpIfError(hr, error, "_OpenConnection");

    hr = myMarshalVariant(pvarValue, Type, &ctbValue.cb, &ctbValue.pb);
    _JumpIfError(hr, error, "myMarshalVariant");

    __try
    {
	hr = m_pICertAdminD->SetExtension(
				    pwszAuthority,
				    (DWORD) RequestId,
				    strExtensionName,
				    Type,
				    Flags,
				    &ctbValue);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "SetExtension");

error:
    if (NULL != ctbValue.pb)
    {
        LocalFree(ctbValue.pb);
    }
    hr = myHError(hr);
    return(_SetErrorInfo(hr, L"CCertAdmin::SetCertificateExtension"));
}


//+--------------------------------------------------------------------------
// CCertAdmin::ResubmitRequest -- Resubmit a certificate request
//
// ...
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertAdmin::ResubmitRequest(
    /* [in] */ BSTR const strConfig,
    /* [in] */ LONG RequestId,
    /* [out, retval] */ LONG *pDisposition)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;

    if (NULL == pDisposition)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *pDisposition = 0;

    hr = _OpenConnection(strConfig, 1, &pwszAuthority);
    _JumpIfError(hr, error, "_OpenConnection");

    __try
    {
	hr = m_pICertAdminD->ResubmitRequest(
					pwszAuthority,
					(DWORD) RequestId,
					(DWORD *) pDisposition);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "ResubmitRequest");

error:
    hr = myHError(hr);
    return(_SetErrorInfo(hr, L"CCertAdmin::ResubmitRequest"));
}


//+--------------------------------------------------------------------------
// CCertAdmin::DenyRequest -- Deny a certificate request
//
// ...
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertAdmin::DenyRequest(
    /* [in] */ BSTR const strConfig,
    /* [in] */ LONG RequestId)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;

    hr = _OpenConnection(strConfig, 1, &pwszAuthority);
    _JumpIfError(hr, error, "_OpenConnection");

    __try
    {
	hr = m_pICertAdminD->DenyRequest(pwszAuthority, (DWORD) RequestId);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "DenyRequest");

error:
    hr = myHError(hr);
    return(_SetErrorInfo(hr, L"CCertAdmin::DenyRequest"));
}


//+--------------------------------------------------------------------------
// CCertAdmin::PublishCRL -- Puhlish a new CRL
//
// ...
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertAdmin::PublishCRL(
    /* [in] */ BSTR const strConfig,
    /* [in] */ DATE Date)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;
    FILETIME ft;

    // Date = 0.0 means pass ft = 0 to the DCOM interface

    if (Date == 0.0)
    {
        ZeroMemory(&ft, sizeof(FILETIME));
    }
    else  // translate date to ft
    {
        hr = myDateToFileTime(&Date, &ft);
        _JumpIfError(hr, error, "myDateToFileTime");
    }

    hr = _OpenConnection(strConfig, 1, &pwszAuthority);
    _JumpIfError(hr, error, "_OpenConnection");

    __try
    {
	hr = m_pICertAdminD->PublishCRL(pwszAuthority, ft);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "PublishCRL");

error:
    hr = myHError(hr);
    return(_SetErrorInfo(hr, L"CCertAdmin::PublishCRL"));
}


//+--------------------------------------------------------------------------
// CCertAdmin::PublishCRLs -- Publish new base CRL, delta CRL or both
//
// ...
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertAdmin::PublishCRLs(
    /* [in] */ BSTR const strConfig,
    /* [in] */ DATE Date,
    /* [in] */ LONG CRLFlags)		// CA_CRL_*
{
    HRESULT hr;
    WCHAR const *pwszAuthority;
    FILETIME ft;

    // Date = 0.0 means pass ft = 0 to the DCOM interface

    if (Date == 0.0)
    {
        ZeroMemory(&ft, sizeof(FILETIME));
    }
    else  // translate date to ft
    {
        hr = myDateToFileTime(&Date, &ft);
        _JumpIfError(hr, error, "myDateToFileTime");
    }

    hr = _OpenConnection(strConfig, 2, &pwszAuthority);
    _JumpIfError(hr, error, "_OpenConnection");

    __try
    {
	hr = m_pICertAdminD->PublishCRLs(pwszAuthority, ft, CRLFlags);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "PublishCRLs");

error:
    hr = myHError(hr);
    return(_SetErrorInfo(hr, L"CCertAdmin::PublishCRLs"));
}


//+--------------------------------------------------------------------------
// CCertAdmin::GetCRL -- Get the latest CRL
//
// ...
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertAdmin::GetCRL(
    /* [in] */ BSTR const strConfig,
    /* [in] */ LONG Flags,
    /* [out, retval] */ BSTR *pstrCRL)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;
    CERTTRANSBLOB ctbCRL;

    ctbCRL.pb = NULL;

    if (NULL == pstrCRL)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    hr = _OpenConnection(strConfig, 1, &pwszAuthority);
    _JumpIfError(hr, error, "_OpenConnection");

    __try
    {
	hr = m_pICertAdminD->GetCRL(pwszAuthority, &ctbCRL);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "GetCRL");

    myRegisterMemAlloc(ctbCRL.pb, ctbCRL.cb, CSM_COTASKALLOC);

    CSASSERT(CR_OUT_BASE64HEADER == CRYPT_STRING_BASE64HEADER);

    if (CR_OUT_BASE64HEADER == Flags)
    {
	Flags = CRYPT_STRING_BASE64X509CRLHEADER;
    }
    hr = EncodeCertString(ctbCRL.pb, ctbCRL.cb, Flags, pstrCRL);
    _JumpIfError(hr, error, "EncodeCertString");

error:
    if (NULL != ctbCRL.pb)
    {
    	CoTaskMemFree(ctbCRL.pb);
    }
    hr = myHError(hr);
    return(_SetErrorInfo(hr, L"CCertAdmin::GetCRL"));
}


#define CCERTADMIN
#include "csprop2.cpp"


//+--------------------------------------------------------------------------
// CCertAdmin::ImportCertificate -- Import a certificate into the database
//
// ...
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertAdmin::ImportCertificate(
    /* [in] */ BSTR const strConfig,
    /* [in] */ BSTR const strCertificate,
    /* [in] */ LONG Flags,
    /* [out, retval] */ LONG *pRequestId)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;
    CERTTRANSBLOB ctbCert;

    ctbCert.pb = NULL;
    if (NULL == strCertificate)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    hr = DecodeCertString(
		    strCertificate,
		    Flags & CR_IN_ENCODEMASK,
		    &ctbCert.pb,
		    &ctbCert.cb);
    _JumpIfError(hr, error, "DecodeCertString");

    hr = _OpenConnection(strConfig, 1, &pwszAuthority);
    _JumpIfError(hr, error, "_OpenConnection");

    __try
    {
	hr = m_pICertAdminD->ImportCertificate(
					pwszAuthority,
					&ctbCert,
					Flags,
					pRequestId);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError3(
	    hr,
	    error,
	    "ImportCertificate",
	    NTE_BAD_SIGNATURE,
	    HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS));

error:
    if (NULL != ctbCert.pb)
    {
    	LocalFree(ctbCert.pb);
    }
    hr = myHError(hr);
    return(_SetErrorInfo(hr, L"CCertAdmin::ImportCertificate"));
}


//+--------------------------------------------------------------------------
// CCertAdmin::GetArchivedKey --  Get archived, encrypted key in a PKCS7
//
// ...
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertAdmin::GetArchivedKey(
    /* [in] */ BSTR const strConfig,
    /* [in] */ LONG RequestId,
    /* [in] */ LONG Flags,
    /* [out, retval] */ BSTR *pstrArchivedKey)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;
    CERTTRANSBLOB ctbArchivedKey;

    ctbArchivedKey.pb = NULL;

    if (NULL == pstrArchivedKey)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    hr = _OpenConnection(strConfig, 2, &pwszAuthority);
    _JumpIfError(hr, error, "_OpenConnection");

    __try
    {
	hr = m_pICertAdminD->GetArchivedKey(
					pwszAuthority,
					RequestId,
					&ctbArchivedKey);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "GetArchivedKey");

    myRegisterMemAlloc(
		ctbArchivedKey.pb,
		ctbArchivedKey.cb,
		CSM_COTASKALLOC);

    CSASSERT(CR_OUT_BASE64HEADER == CRYPT_STRING_BASE64HEADER);

    hr = EncodeCertString(
		    ctbArchivedKey.pb,
		    ctbArchivedKey.cb,
		    Flags,
		    pstrArchivedKey);
    _JumpIfError(hr, error, "EncodeCertString");

error:
    if (NULL != ctbArchivedKey.pb)
    {
    	CoTaskMemFree(ctbArchivedKey.pb);
    }
    hr = myHError(hr);
    return(_SetErrorInfo(hr, L"CCertAdmin::GetArchivedKey"));
}


//+--------------------------------------------------------------------------
// CCertAdmin::GetConfigEntry --  get CA configuration entry
//
// ...
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertAdmin::GetConfigEntry(
    /* [in] */ BSTR const strConfig,
    /* [in] */ BSTR const strNodePath,
    /* [in] */ BSTR const strEntryName,
    /* [out, retval] */ VARIANT *pvarEntry)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;

    if (NULL == strEntryName || NULL == pvarEntry)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    hr = _OpenConnection(strConfig, 2, &pwszAuthority);

    __try
    {
        if(S_OK != hr)
        {
            hr = _GetConfigEntryFromRegistry(
                strConfig,
                strNodePath,
                strEntryName,
                pvarEntry);
            _JumpIfError(hr, error, "_GetConfigEntryFromRegistry");
        }
        else
        {
	        hr = m_pICertAdminD->GetConfigEntry(
				            pwszAuthority,
				            strNodePath,
				            strEntryName,
				            pvarEntry);
        }
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

    _JumpIfError2(hr, error, "GetConfigEntry", 
        HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

error:
    hr = myHError(hr);
    return(_SetErrorInfo(hr, L"CCertAdmin::GetConfigEntry"));
}


//+--------------------------------------------------------------------------
// CCertAdmin::SetConfigEntry --  set CA configuration entry
//
// ...
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertAdmin::SetConfigEntry(
    /* [in] */ BSTR const strConfig,
    /* [in] */ BSTR const strNodePath,
    /* [in] */ BSTR const strEntryName,
    /* [in] */ VARIANT *pvarEntry)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;

    if (NULL == strEntryName || NULL == pvarEntry)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    hr = _OpenConnection(strConfig, 2, &pwszAuthority);

    __try
    {
        if(S_OK != hr)
        {
            hr = _SetConfigEntryFromRegistry(
                strConfig,
                strNodePath,
                strEntryName,
                pvarEntry);
        }
        else
        {
	        hr = m_pICertAdminD->SetConfigEntry(
				            pwszAuthority,
				            strNodePath,
				            strEntryName,
				            pvarEntry);
        }
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

    _JumpIfError(hr, error, "SetConfigEntry");

error:
    hr = myHError(hr);
    return(_SetErrorInfo(hr, L"CCertAdmin::SetConfigEntry"));
}


//+--------------------------------------------------------------------------
// CCertAdmin::ImportKey --  Archive Private Key
//
// ...
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertAdmin::ImportKey(
    /* [in] */ BSTR const strConfig,
    /* [in] */ LONG RequestId,
    /* [in] */ BSTR const strCertHash,
    /* [in] */ LONG Flags,
    /* [in] */ BSTR const strKey)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;
    CERTTRANSBLOB ctbKey;

    ctbKey.pb = NULL;
    if (NULL == strKey)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    hr = DecodeCertString(
		    strKey,
		    Flags & CR_IN_ENCODEMASK,
		    &ctbKey.pb,
		    &ctbKey.cb);
    _JumpIfError(hr, error, "DecodeCertString");

    hr = _OpenConnection(strConfig, 2, &pwszAuthority);
    _JumpIfError(hr, error, "_OpenConnection");

    __try
    {
	hr = m_pICertAdminD->ImportKey(
				    pwszAuthority,
				    RequestId,
				    strCertHash,
				    Flags,
				    &ctbKey);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError2(
	    hr,
	    error,
	    "ImportKey",
	    HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS));

error:
    if (NULL != ctbKey.pb)
    {
    	LocalFree(ctbKey.pb);
    }
    hr = myHError(hr);
    return(_SetErrorInfo(hr, L"CCertAdmin::ImportKey"));
}


HRESULT
CCertAdmin::_SetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription)
{
    CSASSERT(FAILED(hrError) || S_OK == hrError || S_FALSE == hrError);
    if (FAILED(hrError))
    {
	HRESULT hr;

	hr = DispatchSetErrorInfo(
			    hrError,
			    pwszDescription,
			    wszCLASS_CERTADMIN,
			    &IID_ICertAdmin);
	CSASSERT(hr == hrError);
    }
    return(hrError);
}

//+--------------------------------------------------------------------------
// CCertAdmin::GetMyRoles -- Gets current user roles
//
// ...
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertAdmin::GetMyRoles(
    /* [in] */ BSTR const strConfig,
    /* [out, retval] */ LONG *pRoles)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;
    LONG Roles = 0;

    if (NULL == strConfig || NULL == pRoles)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    hr = _OpenConnection(strConfig, 2, &pwszAuthority);
    _JumpIfError(hr, error, "_OpenConnection");

    __try
    {
    hr = m_pICertAdminD->GetMyRoles(
                        pwszAuthority,
                        pRoles);
    } 
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "GetMyRoles");

error:
    hr = myHError(hr);
    return(_SetErrorInfo(hr, L"CCertAdmin::GetMyRoles"));
}


//+--------------------------------------------------------------------------
// CCertAdmin::DeleteRow -- Delete row from database
//
// ...
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertAdmin::DeleteRow(
    /* [in] */ BSTR const strConfig,
    /* [in] */ LONG Flags,		// CDR_*
    /* [in] */ DATE Date,
    /* [in] */ LONG Table,		// CVRC_TABLE_*
    /* [in] */ LONG RowId,
    /* [out, retval]*/ LONG *pcDeleted)
{
    HRESULT hr;
    FILETIME ft;
    WCHAR const *pwszAuthority;

    if (NULL == strConfig)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    // Date = 0.0 means pass ft = 0 to the DCOM interface

    if (Date == 0.0)
    {
        ZeroMemory(&ft, sizeof(FILETIME));
    }
    else  // translate date to ft
    {
        hr = myDateToFileTime(&Date, &ft);
        _JumpIfError(hr, error, "myDateToFileTime");
    }

    hr = _OpenConnection(strConfig, 2, &pwszAuthority);
    _JumpIfError(hr, error, "_OpenConnection");

    __try
    {
	hr = m_pICertAdminD->DeleteRow(
				pwszAuthority,
				Flags,
				ft,
				Table,
				RowId,
				pcDeleted);
    } 
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "DeleteRow");

error:
    hr = myHError(hr);
    return(_SetErrorInfo(hr, L"CCertAdmin::DeleteRow"));
}


HRESULT 
CCertAdmin::_GetConfigEntryFromRegistry(
    IN BSTR const strConfig,
    IN BSTR const strNodePath,
    IN BSTR const strEntryName,
    IN OUT VARIANT *pvarEntry)
{
    HRESULT hr;
    CertSrv::CConfigStorage stg;
    LPWSTR pwszMachine = NULL;
    LPWSTR pwszCAName = NULL;

    hr = mySplitConfigString(
        strConfig,
        &pwszMachine, 
        &pwszCAName);
    _JumpIfErrorStr(hr, error, "mySplitConfigString", strConfig);

    hr = stg.InitMachine(pwszMachine);
    _JumpIfError(hr, error, "CConfigStorage::InitMachine");

    hr = stg.GetEntry(
        pwszCAName,
        strNodePath,
        strEntryName,
        pvarEntry);
    _JumpIfError(hr, error, "CConfigStorage::GetEntry");

error:
    LOCAL_FREE(pwszMachine);
    LOCAL_FREE(pwszCAName);
    return hr;
}

HRESULT 
CCertAdmin::_SetConfigEntryFromRegistry(
    IN BSTR const strConfig,
    IN BSTR const strNodePath,
    IN BSTR const strEntryName,
    IN const VARIANT *pvarEntry)
{
    HRESULT hr;
    CertSrv::CConfigStorage stg;
    LPWSTR pwszMachine = NULL;
    LPWSTR pwszCAName = NULL;

    hr = mySplitConfigString(
        strConfig,
        &pwszMachine, 
        &pwszCAName);
    _JumpIfErrorStr(hr, error, "mySplitConfigString", strConfig);

    hr = stg.InitMachine(pwszMachine);
    _JumpIfError(hr, error, "CConfigStorage::InitMachine");

    hr = stg.SetEntry(
        pwszCAName,
        strNodePath,
        strEntryName,
        const_cast<VARIANT*>(pvarEntry));
    _JumpIfError(hr, error, "CConfigStorage::GetEntry");

error:
    LOCAL_FREE(pwszMachine);
    LOCAL_FREE(pwszCAName);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certadm\atl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       atl.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp: source file that includes just the standard includes
// stdafx.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include <pch.cpp>

#pragma hdrstop

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certadm\admin.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        admin.h
//
// Contents:    Declaration of CCertAdmin
//
//---------------------------------------------------------------------------


#include "cscomres.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// certadm


class ATL_NO_VTABLE CCertAdmin: 
    public IDispatchImpl<ICertAdmin2, &IID_ICertAdmin2, &LIBID_CERTADMINLib>, 
    public ISupportErrorInfoImpl<&IID_ICertAdmin2>,
    public CComObjectRoot,
    public CComCoClass<CCertAdmin, &CLSID_CCertAdmin>
{
public:
    CCertAdmin()
    {
	m_fRevocationReasonValid = FALSE;
	m_dwServerVersion = 0;
	m_pICertAdminD = NULL;
	m_pwszServerName = NULL;
	_InitCAPropInfo();
	_Cleanup();
    }
    ~CCertAdmin();

BEGIN_COM_MAP(CCertAdmin)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(ICertAdmin)
    COM_INTERFACE_ENTRY(ICertAdmin2)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertAdmin) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(
    CCertAdmin,
    wszCLASS_CERTADMIN TEXT(".1"),
    wszCLASS_CERTADMIN,
    IDS_CERTADMIN_DESC,
    THREADFLAGS_BOTH)

// ICertAdmin
public:
    STDMETHOD(IsValidCertificate)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ BSTR const strSerialNumber,
		/* [out, retval] */ LONG *pDisposition);

    STDMETHOD(GetRevocationReason)(
		/* [out, retval] */ LONG *pReason);

    STDMETHOD(RevokeCertificate)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ BSTR const strSerialNumber,
		/* [in] */ LONG Reason,
		/* [in] */ DATE Date);

    STDMETHOD(SetRequestAttributes)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ LONG RequestId,
		/* [in] */ BSTR const strAttributes);

    STDMETHOD(SetCertificateExtension)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ LONG RequestId,
		/* [in] */ BSTR const strExtensionName,
		/* [in] */ LONG Type,
		/* [in] */ LONG Flags,
		/* [in] */ VARIANT const *pvarValue);

    STDMETHOD(DenyRequest)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ LONG RequestId);

    STDMETHOD(ResubmitRequest)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ LONG RequestId,
		/* [out, retval] */ LONG __RPC_FAR *pDisposition);

    STDMETHOD(PublishCRL)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ DATE Date);

    STDMETHOD(GetCRL)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ LONG Flags,
		/* [out, retval] */ BSTR *pstrCRL);

    STDMETHOD(ImportCertificate)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ BSTR const strCertificate,
		/* [in] */ LONG Flags,
		/* [out, retval] */ LONG *pRequestId);

// ICertAdmin2
public:
    STDMETHOD(PublishCRLs)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ DATE Date,
		/* [in] */ LONG CRLFlags);		// CA_CRL_*

    STDMETHOD(GetCAProperty)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ LONG PropId,			// CR_PROP_*
		/* [in] */ LONG PropIndex,
		/* [in] */ LONG PropType,		// PROPTYPE_*
		/* [in] */ LONG Flags,			// CR_OUT_*
		/* [out, retval] */ VARIANT *pvarPropertyValue);

    STDMETHOD(SetCAProperty)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ LONG PropId,			// CR_PROP_*
		/* [in] */ LONG PropIndex,
		/* [in] */ LONG PropType,		// PROPTYPE_*
		/* [in] */ VARIANT *pvarPropertyValue);

    STDMETHOD(GetCAPropertyFlags)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ LONG PropId,			// CR_PROP_*
		/* [out, retval] */ LONG *pPropFlags);

    STDMETHOD(GetCAPropertyDisplayName)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ LONG PropId,			// CR_PROP_*
		/* [out, retval] */ BSTR *pstrDisplayName);

    STDMETHOD(GetArchivedKey)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ LONG RequestId,
		/* [in] */ LONG Flags,			// CR_OUT_*
		/* [out, retval] */ BSTR *pstrArchivedKey);

    STDMETHOD(GetConfigEntry)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ BSTR const strNodePath,
		/* [in] */ BSTR const strEntryName,
		/* [out, retval] */ VARIANT *pvarEntry);

    STDMETHOD(SetConfigEntry)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ BSTR const strNodePath,
		/* [in] */ BSTR const strEntryName,
		/* [in] */ VARIANT *pvarEntry);

    STDMETHOD(ImportKey)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ LONG RequestId,
		/* [in] */ BSTR const strCertHash,
		/* [in] */ LONG Flags,
		/* [in] */ BSTR const strKey);

    STDMETHOD(GetMyRoles)(
		/* [in] */ BSTR const strConfig,
		/* [out, retval] */ LONG *pRoles);

    STDMETHOD(DeleteRow)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ LONG Flags,		// CDR_*
		/* [in] */ DATE Date,
		/* [in] */ LONG Table,		// CVRC_TABLE_*
		/* [in] */ LONG RowId,
		/* [out, retval] */ LONG *pcDeleted);

private:
    HRESULT _OpenConnection(
		IN WCHAR const *pwszConfig,
		IN DWORD RequiredVersion,
		OUT WCHAR const **ppwszAuthority);

    VOID _CloseConnection();

    VOID _InitCAPropInfo();
    VOID _CleanupCAPropInfo();

    VOID _Cleanup();
    VOID _CleanupOldConnection();

    HRESULT _FindCAPropInfo(
		IN BSTR const strConfig,
		IN LONG PropId,
		OUT CAPROP const **ppcap);

    HRESULT _SetErrorInfo(
		IN HRESULT hrError,
		IN WCHAR const *pwszDescription);

    HRESULT _GetConfigEntryFromRegistry(
		IN BSTR const strConfig,
		IN BSTR const strNodePath,
		IN BSTR const strEntryName,
		IN OUT VARIANT *pvarEntry);

    HRESULT _SetConfigEntryFromRegistry(
		IN BSTR const strConfig,
		IN BSTR const strNodePath,
		IN BSTR const strEntryName,
		IN const VARIANT *pvarEntry);

    DWORD         m_dwServerVersion;
    ICertAdminD2 *m_pICertAdminD;

    LONG    m_RevocationReason;
    BOOL    m_fRevocationReasonValid;

    BYTE   *m_pbCACertState;
    DWORD   m_cbCACertState;

    BYTE   *m_pbCRLState;
    DWORD   m_cbCRLState;

    CAPROP *m_pCAPropInfo;
    LONG    m_cCAPropInfo;
    CAINFO *m_pCAInfo;
    DWORD   m_cbCAInfo;

    WCHAR  *m_pwszServerName;

    BYTE   *m_pbKRACertState;
    DWORD   m_cbKRACertState;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certadm\backup.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        backup.cpp
//
// Contents:    Cert Server client database backup APIs
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "certsrvd.h"
#include "csdisp.h"
#include "certadmp.h"

#define __dwFILE__	__dwFILE_CERTADM_BACKUP_CPP__


#if DBG
#define _CERTBCLI_TYPECHECK
#endif

#include <certbcli.h>


WCHAR g_wszBackupAnnotation[] = L"backup";
WCHAR g_wszRestoreAnnotation[] = L"restore";


HRESULT
AllocateContext(
    IN WCHAR const *pwszConfig,
    OUT CSBACKUPCONTEXT **ppcsbc)
{
    HRESULT hr;
    WCHAR *pwszT = NULL;

    CSASSERT(NULL != pfnCertSrvIsServerOnline);
    pwszT = (WCHAR *) LocalAlloc(
			    LMEM_FIXED,
			    (wcslen(pwszConfig) + 1) * sizeof(WCHAR));
    if (NULL == pwszT)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(pwszT, pwszConfig);
    
    *ppcsbc = (CSBACKUPCONTEXT *) LocalAlloc(
					LMEM_FIXED | LMEM_ZEROINIT,
					sizeof(**ppcsbc));
    if (NULL == *ppcsbc)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    (*ppcsbc)->pwszConfig = pwszT;
    pwszT = NULL;
    hr = S_OK;

error:
    if (NULL != pwszT)
    {
	LocalFree(pwszT);
    }
    return(hr);
}


VOID
ReleaseContext(
    IN OUT CSBACKUPCONTEXT *pcsbc)
{
    CSASSERT(NULL != pcsbc);
    if (NULL != pcsbc->pwszConfig)
    {
	LocalFree(const_cast<WCHAR *>(pcsbc->pwszConfig));
	pcsbc->pwszConfig = NULL;
    }
    if (NULL != pcsbc->pICertAdminD)
    {
	CloseAdminServer(&pcsbc->pICertAdminD);
	CSASSERT(NULL == pcsbc->pICertAdminD);
    }
    if (NULL != pcsbc->pbReadBuffer)
    {
	VirtualFree(pcsbc->pbReadBuffer, 0, MEM_RELEASE);
    }
    LocalFree(pcsbc);
}


HRESULT
OpenAdminServer(
    IN WCHAR const *pwszConfig,
    OUT WCHAR const **ppwszAuthority,
    OUT DWORD *pdwServerVersion,
    OUT ICertAdminD2 **ppICertAdminD)
{
    HRESULT hr;
    BOOL fCoInitialized = FALSE;

    hr = CoInitialize(NULL);
    if (RPC_E_CHANGED_MODE == hr)
    {
	_PrintError(hr, "CoInitialize");
	hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    }
    if (S_OK != hr && S_FALSE != hr)
    {
	_JumpError(hr, error, "CoInitialize");
    }
    fCoInitialized = TRUE;

    *pdwServerVersion = 0;
    hr = myOpenAdminDComConnection(
			pwszConfig,
			ppwszAuthority,
			NULL,
			pdwServerVersion,
			ppICertAdminD);
    _JumpIfError(hr, error, "myOpenDComConnection");

    CSASSERT(0 != *pdwServerVersion);

error:
    if (S_OK != hr && fCoInitialized)
    {
	CoUninitialize();
    }
    return(hr);
}


VOID
CloseAdminServer(
    IN OUT ICertAdminD2 **ppICertAdminD)
{
    myCloseDComConnection((IUnknown **) ppICertAdminD, NULL);
    CoUninitialize();
}


//+--------------------------------------------------------------------------
// CertSrvIsServerOnline -- check to see if the Cert Server is Online on the
//	given server. This call is guaranteed to return quickly.
//
// Parameters:
//	[in]  pwszConfig - name of the server to check
//	[out] pfServerOnline - pointer to receive the bool result
//		(TRUE if Cert Server is online; FALSE, otherwise)
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//+--------------------------------------------------------------------------

HRESULT
CERTBCLI_API
CertSrvIsServerOnlineW(
    IN WCHAR const *pwszConfig,
    OPTIONAL OUT BOOL *pfServerOnline)
{
    HRESULT hr;
    ICertAdminD2 *pICertAdminD = NULL;
    WCHAR const *pwszAuthority;
    DWORD State;
    DWORD dwServerVersion;

    if (NULL == pwszConfig)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    __try
    {
	if (NULL != pfServerOnline)
	{
	    *pfServerOnline = FALSE;
	}
	hr = OpenAdminServer(
		    pwszConfig,
		    &pwszAuthority,
		    &dwServerVersion,
		    &pICertAdminD);

	// OpenAdminServer etc might get E_ACCESSDENIED -- meaning server down

	if (S_OK != hr)
	{
	    _PrintError(hr, "OpenAdminServer");
	    if (E_ACCESSDENIED == hr || (HRESULT) ERROR_ACCESS_DENIED == hr)
	    {
		hr = S_OK;
	    }
	    __leave;
	}
	hr = pICertAdminD->GetServerState(pwszAuthority, &State);
	_LeaveIfError(hr, "GetServerState");

	if (NULL != pfServerOnline && 0 != State)
	{
	    *pfServerOnline = TRUE;
	}
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    if (NULL != pICertAdminD)
    {
	CloseAdminServer(&pICertAdminD);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CertSrvBackupPrepare -- prepare the DS for the online backup and return a
//	Backup Context Handle to be used for subsequent calls to backup
//	functions.
//
// Parameters:
//	[in]  pwszConfig - server name to prepare for online backup
//	[in]  grbitJet - flag to be passed to jet while backing up dbs
//	[in]  dwBackupFlags - CSBACKUP_TYPE_FULL or CSBACKUP_TYPE_LOGS_ONLY
//	[out] phbc - pointer that will receive the backup context handle
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

HRESULT
CERTBCLI_API
CertSrvBackupPrepareW(
    IN  WCHAR const *pwszConfig,
    IN  ULONG grbitJet,
    IN  ULONG dwBackupFlags,
    OUT HCSBC *phbc)
{
    HRESULT hr;
    CSBACKUPCONTEXT *pcsbc = NULL;

    if (NULL == pwszConfig || NULL == phbc)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *phbc = NULL;
    if (CSBACKUP_TYPE_LOGS_ONLY == dwBackupFlags)
    {
	grbitJet |= JET_bitBackupIncremental;
    }
    else if (CSBACKUP_TYPE_FULL != dwBackupFlags)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "dwBackupFlags");
    }

    __try
    {
	hr = AllocateContext(pwszConfig, &pcsbc);
	_LeaveIfError(hr, "AllocateContext");

	hr = OpenAdminServer(
		    pcsbc->pwszConfig,
		    &pcsbc->pwszAuthority,
		    &pcsbc->dwServerVersion,
		    &pcsbc->pICertAdminD);
	_LeaveIfError(hr, "OpenAdminServer");

	hr = pcsbc->pICertAdminD->BackupPrepare(	
				    pcsbc->pwszAuthority,
				    grbitJet,
				    dwBackupFlags,
				    g_wszBackupAnnotation,
				    0);		// dwClientIdentifier
	_LeaveIfError(hr, "BackupPrepare");

	*phbc = (HCSBC) pcsbc;
	pcsbc = NULL;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    if (NULL != pcsbc)
    {
	ReleaseContext(pcsbc);
    }
    return(hr);
}


// Return the length of a double '\0' terminated string -- includes the
// trailing '\0's.


DWORD
mySzzLen(
    CHAR const *pszz)
{
    CHAR const *psz;
    DWORD cb;

    psz = pszz;
    do
    {
	cb = strlen(psz);
	psz += cb + 1;
    } while (0 != cb);
    return SAFE_SUBTRACT_POINTERS(psz, pszz); // includes double trailing '\0's
}


HRESULT
myLocalAllocCopy(
    IN VOID *pbIn,
    IN DWORD cbIn,
    OUT VOID **pbOut)
{
    HRESULT hr;
    
    *pbOut = LocalAlloc(LMEM_FIXED, cbIn);
    if (NULL == *pbOut)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(*pbOut, pbIn, cbIn);
    hr = S_OK;

error:
    return(hr);
}


HRESULT
BackupRestoreGetFileList(
    IN  DWORD FileListType,
    IN  HCSBC hbc,
    OUT WCHAR **ppwszzFileList,
    OUT DWORD *pcbList)
{
    HRESULT hr;
    CSBACKUPCONTEXT *pcsbc;
    WCHAR *pwszzFileList = NULL;
    LONG cwcList;
    DWORD cbList;

    if (NULL == hbc)
    {
	hr = E_HANDLE;
	_JumpError(hr, error, "NULL handle");
    }
    if (NULL != ppwszzFileList)
    {
	*ppwszzFileList = NULL;
    }
    if (NULL != pcbList)
    {
	*pcbList = 0;
    }
    if (NULL == ppwszzFileList || NULL == pcbList)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    pcsbc = (CSBACKUPCONTEXT *) hbc;

    __try
    {
	if (NULL == pcsbc->pICertAdminD)
	{
	    hr = OpenAdminServer(
			pcsbc->pwszConfig,
			&pcsbc->pwszAuthority,
			&pcsbc->dwServerVersion,
			&pcsbc->pICertAdminD);
	    _LeaveIfError(hr, "OpenAdminServer");
	}
	CSASSERT(NULL != pcsbc->pICertAdminD);

	if (FLT_DBFILES == FileListType)
	{
	    hr = pcsbc->pICertAdminD->BackupGetAttachmentInformation(
							&pwszzFileList,
							&cwcList);
	    _LeaveIfError(hr, "BackupGetAttachmentInformation");
	}
	else if (FLT_LOGFILES == FileListType)
	{
	    hr = pcsbc->pICertAdminD->BackupGetBackupLogs(
						&pwszzFileList,
						&cwcList);
	    _LeaveIfError(hr, "BackupGetBackupLogs");
	}
	else if (FLT_DYNAMICFILES == FileListType)
	{
	    hr = pcsbc->pICertAdminD->BackupGetDynamicFiles(
						&pwszzFileList,
						&cwcList);
	    _LeaveIfError(hr, "BackupGetDynamicFileList");
	}
	else
	{
	    CSASSERT(FLT_RESTOREDBLOCATIONS == FileListType);
	    hr = pcsbc->pICertAdminD->RestoreGetDatabaseLocations(
						    &pwszzFileList,
						    &cwcList);
	    _LeaveIfError(hr, "RestoreGetDatabaseLocations");
	}

	cbList = cwcList * sizeof(WCHAR);
	myRegisterMemAlloc(pwszzFileList, cbList, CSM_COTASKALLOC);

	hr = myLocalAllocCopy(pwszzFileList, cbList, (VOID **) ppwszzFileList);
	_JumpIfError(hr, error, "myLocalAllocCopy");

	*pcbList = cbList;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    if (NULL != pwszzFileList)
    {
	CoTaskMemFree(pwszzFileList);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CertSrvBackupGetDatabaseNames -- return the list of data bases that need to
//	be backed up for the given backup context The information returned in
//	ppwszzFileList should not be interpreted, as it only has meaning on
//	the server being backed up.
//
//	This API will allocate a buffer of sufficient size to hold the entire
//	attachment list, which must be later freed with CertSrvBackupFree.
//
// Parameters:
//	[in]  hbc - backup context handle
//	[out] ppwszzFileList - pointer that will receive the pointer to the
//		attachment info; allocated memory should be freed using
//		CertSrvBackupFree() API by the caller when it is no longer
//		needed; ppwszzFileList info is an array of null-terminated
//		filenames and the list is terminated by two L'\0's.
//	[out] pcbList - will receive the number of bytes returned
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

HRESULT
CERTBCLI_API
CertSrvBackupGetDatabaseNamesW(
    IN  HCSBC hbc,
    OUT WCHAR **ppwszzFileList,
    OUT DWORD *pcbList)
{
    HRESULT hr;

    hr = BackupRestoreGetFileList(FLT_DBFILES, hbc, ppwszzFileList, pcbList);
    _JumpIfError(hr, error, "BackupRestoreGetFileList");

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CertSrvBackupGetDynamicFileList -- return the list of dynamic files that
//	need to be backed up for the given backup context The information
//	returned in ppwszzFileList should not be interpreted, as it only has
//	meaning on the server being backed up.
//
//	This API will allocate a buffer of sufficient size to hold the entire
//	attachment list, which must be later freed with CertSrvBackupFree.
//
// Parameters:
//	[in]  hbc - backup context handle
//	[out] ppwszzFileList - pointer that will receive the pointer to the
//		attachment info; allocated memory should be freed using
//		CertSrvBackupFree() API by the caller when it is no longer
//		needed; ppwszzFileList info is an array of null-terminated
//		filenames and the list is terminated by two L'\0's.
//	[out] pcbList - will receive the number of bytes returned
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

HRESULT
CERTBCLI_API
CertSrvBackupGetDynamicFileListW(
    IN  HCSBC hbc,
    OUT WCHAR **ppwszzFileList,
    OUT DWORD *pcbList)
{
    HRESULT hr;

    hr = BackupRestoreGetFileList(
				FLT_DYNAMICFILES,
				hbc,
				ppwszzFileList,
				pcbList);
    _JumpIfError(hr, error, "BackupRestoreGetFileList");

error:
    return(hr);
}


#define CBREADMIN	(64 * 1024)		// 64k minimum buffer
#define CBREADDEFAULT	(512 * 1024)		// 512k recommended
#define CBREADMAX	(4 * 1024 * 1024)	// 4mb maximum buffer

HRESULT
BufferAllocate(
    IN  DWORD cbHintSize,
    OUT BYTE **ppbBuffer,
    OUT DWORD *pcbBuffer)
{
    HRESULT hr;
    DWORD cb;

    *ppbBuffer = NULL;
    if (0 == cbHintSize)
    {
	// at 512k the server begins doing efficient backups

	cbHintSize = CBREADDEFAULT;
    }
    else if (CBREADMIN > cbHintSize)
    {
	cbHintSize = CBREADMIN;
    }

    for (cb = CBREADMAX; (cb >> 1) >= cbHintSize; cb >>= 1)
    	;

    while (TRUE)
    {
        *ppbBuffer = (BYTE *) VirtualAlloc(
					NULL,
					cb,
					MEM_COMMIT,
					PAGE_READWRITE);
        if (NULL != *ppbBuffer)
        {
	    break;
	}
	hr = myHLastError();
	CSASSERT(S_OK == hr);
	_PrintError(hr, "VirtualAlloc");

	cb >>= 1;
	if (CBREADMIN > cb)
	{
	    goto error;
	}
    }
    *pcbBuffer = cb;
    hr = S_OK;

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CertSrvBackupOpenFile -- open a remote file for backup, and perform whatever
//	client and server side operations to prepare for the backup.
//	It takes in a hint of the size of the buffer that will later be passed
//	into the CertSrvBackupRead API that can be used to optimize the network
//	traffic for the API.
//
// Parameters:
//	[in]  hbc - backup context handle
//	[in]  pwszPath - name of the attachment to be opened for read
//	[in]  cbReadHintSize - suggested size in bytes that might be used
//		during the subsequent reads on this attachment
//	[out] pliFileSize - pointer to a large integer that would receive the
//		size in bytes of the given attachment
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

HRESULT
CERTBCLI_API
CertSrvBackupOpenFileW(
    IN  HCSBC hbc,
    IN  WCHAR const *pwszPath,
    IN  DWORD cbReadHintSize,
    OUT LARGE_INTEGER *pliFileSize)
{
    HRESULT hr;
    CSBACKUPCONTEXT *pcsbc;

    if (NULL == hbc)
    {
	hr = E_HANDLE;
	_JumpError(hr, error, "NULL handle");
    }
    if (NULL == pwszPath || NULL == pliFileSize)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    pcsbc = (CSBACKUPCONTEXT *) hbc;
    if (pcsbc->fFileOpen)
    {
	hr = HRESULT_FROM_WIN32(ERROR_BUSY);
	_JumpError(hr, error, "File already open");
    }

    __try
    {
	hr = pcsbc->pICertAdminD->BackupOpenFile(
					    pwszPath,
					    (ULONGLONG *) pliFileSize);
	_LeaveIfErrorStr(hr, "BackupOpenFile", pwszPath);

	if (NULL == pcsbc->pbReadBuffer)
	{
	    hr = BufferAllocate(
			    cbReadHintSize,
			    &pcsbc->pbReadBuffer,
			    &pcsbc->cbReadBuffer);
	    _LeaveIfError(hr, "BufferAllocate");
	}
	pcsbc->fFileOpen = TRUE;
	pcsbc->cbCache = 0;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CertSrvBackupRead -- read the currently open attachment bytes into the given
//	buffer.  The client application is expected to call this function
//	repeatedly until it gets the entire file (the application would have
//	received the file size through the CertSrvBackupOpenFile call before.
//
// Parameters:
//	[in]  hbc - backup context handle
//	[in]  pvBuffer - pointer to the buffer that would receive the read data.
//	[in]  cbBuffer - specifies the size of the above buffer
//	[out] pcbRead - pointer to receive the actual number of bytes read.
//
// Returns:
//	HRESULT - The status of the operation.
//	S_OK if successful.
//	ERROR_END_OF_FILE if the end of file was reached while being backed up
//	Other Win32 and RPC error code.
//
// Note:
//	It is important to realize that pcbRead may be less than cbBuffer.
//	This does not indicate an error, some transports may choose to fragment
//	the buffer being transmitted instead of returning the entire buffers
//	worth of data.
//---------------------------------------------------------------------------

HRESULT
CERTBCLI_API
CertSrvBackupRead(
    IN  HCSBC hbc,
    IN  VOID *pvBuffer,
    IN  DWORD cbBuffer,
    OUT DWORD *pcbRead)
{
    HRESULT hr;
    CSBACKUPCONTEXT *pcsbc;
    BYTE *pbBuffer = (BYTE *) pvBuffer;
    DWORD cbRead;
    DWORD cb;

    hr = E_HANDLE;
    if (NULL == hbc)
    {
	_JumpError(hr, error, "NULL handle");
    }
    if (NULL == pvBuffer || NULL == pcbRead)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *pcbRead = 0;
    pcsbc = (CSBACKUPCONTEXT *) hbc;
    if (NULL == pcsbc->pbReadBuffer)
    {
	_JumpError(hr, error, "NULL buffer");
    }
    if (!pcsbc->fFileOpen)
    {
	_JumpError(hr, error, "File not open");
    }

    while (TRUE)
    {
	if (0 != pcsbc->cbCache)
	{
	    cb = min(pcsbc->cbCache, cbBuffer);
	    CopyMemory(pbBuffer, pcsbc->pbCache, cb);
	    pbBuffer += cb;
	    cbBuffer -= cb;
	    pcsbc->pbCache += cb;
	    pcsbc->cbCache -= cb;
	    *pcbRead += cb;
	}
	if (0 == cbBuffer)
	{
	    hr = S_OK;
	    break;		// request satisfied
	}

	pcsbc->cbCache = 0;
	__try
	{
	    hr = pcsbc->pICertAdminD->BackupReadFile(
						pcsbc->pbReadBuffer,
						pcsbc->cbReadBuffer,
						(LONG *) &cbRead);
	    _LeaveIfError(hr, "BackupReadFile");
	}
	__except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
	{
	}
	if (S_OK != hr || 0 == cbRead)
	{
	    break;		// EOF
	}
	pcsbc->cbCache = cbRead;
	pcsbc->pbCache = pcsbc->pbReadBuffer;
    }

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CertSrvBackupClose -- called by the application after it completes reading
//	all the data in the currently opened attachement.
//
// Parameters:
//	[in] hbc - backup context handle
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

HRESULT
CERTBCLI_API
CertSrvBackupClose(
    IN HCSBC hbc)
{
    HRESULT hr;
    CSBACKUPCONTEXT *pcsbc;

    hr = E_HANDLE;
    if (NULL == hbc)
    {
	_JumpError(hr, error, "NULL handle");
    }
    pcsbc = (CSBACKUPCONTEXT *) hbc;
    if (!pcsbc->fFileOpen)
    {
	_JumpError(hr, error, "File not open");
    }

    __try
    {
	hr = pcsbc->pICertAdminD->BackupCloseFile();
	_LeaveIfError(hr, "BackupCloseFile");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

    // Clear flag even on failure...

    pcsbc->fFileOpen = FALSE;

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CertSrvBackupGetBackupLogs -- return the list of log files that need to be
//	backed up for the given backup context
//
//	This API will allocate a buffer of sufficient size to hold the entire
//	backup log list, which must be later freed with CertSrvBackupFree.
//
// Parameters:
//	[in]  hbc - backup context handle
//	[out] pszBackupLogFiles - pointer that will receive the pointer to the
//		list of log files; allocated memory should be freed using
//		CertSrvBackupFree() API by the caller when it is no longer
//		needed; Log files are returned in an array of null-terminated
//		filenames and the list is terminated by two L'\0's.
//	[out] pcbList - will receive the number of bytes returned
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

HRESULT
CERTBCLI_API
CertSrvBackupGetBackupLogsW(
    IN  HCSBC hbc,
    OUT WCHAR **ppwszzFileList,
    OUT DWORD *pcbList)
{
    HRESULT hr;

    hr = BackupRestoreGetFileList(
			    FLT_LOGFILES,
			    hbc,
			    ppwszzFileList,
			    pcbList);
    _JumpIfError(hr, error, "BackupRestoreGetFileList");

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CertSrvBackupTruncateLogs -- terminate the backup operation.  Called when
//	the backup has completed successfully.
//
// Parameters:
//	[in] hbc - backup context handle
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//
// Note:
//	Again, this API may have to take a grbit parameter to be passed to the
//	server to indicate the backup type.
//---------------------------------------------------------------------------

HRESULT
CERTBCLI_API
CertSrvBackupTruncateLogs(
    IN HCSBC hbc)
{
    HRESULT hr;
    CSBACKUPCONTEXT *pcsbc;

    if (NULL == hbc)
    {
	hr = E_HANDLE;
	_JumpError(hr, error, "NULL handle");
    }
    pcsbc = (CSBACKUPCONTEXT *) hbc;

    __try
    {
	hr = pcsbc->pICertAdminD->BackupTruncateLogs();
	_LeaveIfError(hr, "BackupTruncateLogs");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CertSrvBackupEnd -- clean up after a backup operation has been performed.
//	This API will close outstanding binding handles, and do whatever is
//	necessary to clean up after successful/unsuccesful backup attempts.
//
// Parameters:
//	[in] hbc - backup context handle of the backup session
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

HRESULT
CERTBCLI_API
CertSrvBackupEnd(
    IN HCSBC hbc)
{
    HRESULT hr;
    CSBACKUPCONTEXT *pcsbc;

    if (NULL == hbc)
    {
	hr = E_HANDLE;
	_JumpError(hr, error, "NULL handle");
    }
    pcsbc = (CSBACKUPCONTEXT *) hbc;

    __try
    {
	hr = pcsbc->pICertAdminD->BackupEnd();
	_LeaveIfError(hr, "BackupEnd");

    ReleaseContext((CSBACKUPCONTEXT *) hbc);
	hr = S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CertSrvBackupFree -- free any buffer allocated by certbcli.dll APIs.
//
// Parameters:
//	[in] pv - pointer to the buffer that is to be freed.
//
// Returns:
//	None.
//---------------------------------------------------------------------------

VOID
CERTBCLI_API
CertSrvBackupFree(
    IN VOID *pv)
{
    LocalFree(pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certadm\certadmp.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1998 - 1999
//
// File:        certadmnp.h
//
// Contents:    private certadm declarations
//
//---------------------------------------------------------------------------

#define FLT_DBFILES			0
#define FLT_LOGFILES			1
#define FLT_DYNAMICFILES		2
#define FLT_RESTOREDBLOCATIONS		3

typedef struct _CSBACKUPCONTEXT
{
    DWORD dwServerVersion;
    ICertAdminD2 *pICertAdminD;
    WCHAR const *pwszConfig;
    WCHAR const *pwszAuthority;
    DWORD RestoreFlags;
    BOOL fFileOpen;
    BYTE *pbReadBuffer;
    DWORD cbReadBuffer;
    BYTE *pbCache;
    DWORD cbCache;
} CSBACKUPCONTEXT;


HRESULT
AllocateContext(
    IN  WCHAR const *pwszConfig,
    OUT CSBACKUPCONTEXT **ppcsbc);

VOID
ReleaseContext(
    IN OUT CSBACKUPCONTEXT *pcsbc);

HRESULT
BackupRestoreGetFileList(
    IN  DWORD FileListType,
    IN  HCSBC hbc,
    OUT WCHAR **ppwszzFileList,
    OUT DWORD *pcbList);

HRESULT
OpenAdminServer(
    IN WCHAR const *pwszConfig,
    OUT WCHAR const **ppwszAuthority,
    OUT DWORD *pdwServerVersion,
    OUT ICertAdminD2 **ppICertAdminD);

VOID
CloseAdminServer(
    IN OUT ICertAdminD2 **ppICertAdminD);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certadm\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1998 - 1998

Module Name:

    makefile.inc.

!ENDIF

$(O)\$(TARGETNAME).res:    ..\idl\com\$(O)\$(TARGETNAME).tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certadm\manage.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       manage.h
//
//--------------------------------------------------------------------------

#include "legacy.h"
#include "cscomres.h"

// LEGACY policy modules don't have a CCertManagePolicyModule -- create one for them!
// They only have one name: "CertificateAuthority.Policy", so they only need one 
// manage: "CertificateAuthority.PolicyManage"

// Once we create this, all legacy modules will be displayed through this managemodule.


class CCertManagePolicyModule: 
    public CComDualImpl<ICertManageModule, &IID_ICertManageModule, &LIBID_CERTPOLICYLib>, 
    public CComObjectRoot,
    public CComCoClass<CCertManagePolicyModule, &CLSID_CCertManagePolicyModule>
{
public:
    CCertManagePolicyModule() {};
    ~CCertManagePolicyModule() {};

BEGIN_COM_MAP(CCertManagePolicyModule)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ICertManageModule)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertManagePolicyModule) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

#define WSZ_LEGACY_POLICYPREFIX L"CertificateAuthority"
#define WSZ_LEGACY_POLICYMANAGE WSZ_LEGACY_POLICYPREFIX wszCERTMANAGEPOLICY_POSTFIX

DECLARE_REGISTRY(
    CCertManagePolicyModule,
    WSZ_LEGACY_POLICYMANAGE TEXT(".1"),
    WSZ_LEGACY_POLICYMANAGE,
    IDS_CERTMANAGEPOLICYMODULE_DESC,    
    THREADFLAGS_BOTH)

// ICertManageModule
public:

    STDMETHOD (GetProperty) (
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty);
        
    STDMETHOD (SetProperty)(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [in] */ VARIANT const __RPC_FAR *pvarProperty);

        
    STDMETHOD (Configure)( 
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ LONG dwFlags);

};


// LEGACY exit modules don't have a CCertManageExitModule -- create one for them!
// They only have one name: "CertificateAuthority.Exit", so they only need one 
// manage: "CertificateAuthority.ExitManage"

// Once we create this, all legacy modules will be displayed through this managemodule.

class CCertManageExitModule: 
    public CComDualImpl<ICertManageModule, &IID_ICertManageModule, &LIBID_CERTPOLICYLib>, 
    public CComObjectRoot,
    public CComCoClass<CCertManageExitModule, &CLSID_CCertManageExitModule>
{
public:
    CCertManageExitModule() {};
    ~CCertManageExitModule() {};

BEGIN_COM_MAP(CCertManageExitModule)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ICertManageModule)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertManageExitModule) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

#define WSZ_LEGACY_EXITPREFIX L"CertificateAuthority"
#define WSZ_LEGACY_EXITMANAGE WSZ_LEGACY_EXITPREFIX wszCERTMANAGEEXIT_POSTFIX

DECLARE_REGISTRY(
    CCertManageExitModule,
    WSZ_LEGACY_EXITMANAGE TEXT(".1"),
    WSZ_LEGACY_EXITMANAGE,
    IDS_CERTMANAGEEXITMODULE_DESC,    
    THREADFLAGS_BOTH)

// ICertManageModule
public:

    STDMETHOD (GetProperty) (
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty);
        
    STDMETHOD (SetProperty)(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [in] */ VARIANT const __RPC_FAR *pvarProperty);

        
    STDMETHOD (Configure)( 
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ LONG dwFlags);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certcli\atl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       atl.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp: source file that includes just the standard includes
// stdafx.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include <pch.cpp>

#pragma hdrstop

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certadm\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
// History:     25-Jul-96       vich created
//
//---------------------------------------------------------------------------

#define __DIR__		"certadm"

#include <windows.h>
#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>

#include <certsrv.h>
#include "certlib.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certadm\manage.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        module.cpp
//
// Contents:    LEGACY Policy Manage Module implementation
// Contents:    LEGACY Exit   Manage Module implementation
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#pragma hdrstop

#include "manage.h"

extern HINSTANCE g_hInstance;

// LEGACY Policy module

STDMETHODIMP
CCertManagePolicyModule::GetProperty(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty)
{
    UINT uiStr = 0;
    HRESULT hr;
    WCHAR *pwszStr = NULL;

    if (NULL == strPropertyName)
    {
        hr = S_FALSE;
        _JumpError(hr, error, "NULL in parm");
    }
    if (NULL == pvarProperty)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL parm");
    }

    if (0 == wcscmp(strPropertyName, wszCMM_PROP_NAME))
        uiStr = IDS_LEGACYPOLICYMODULE_NAME;
    else
    {
        hr = S_FALSE;  
        _JumpError(hr, error, "invalid property name");
    }

    // load string from resource
    hr = myLoadRCString(g_hInstance, uiStr, &pwszStr);
    _JumpIfError(hr, error, "myLoadRCString");

    pvarProperty->bstrVal = SysAllocString(pwszStr);
    if (NULL == pvarProperty->bstrVal)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "out of memory");
    }

    myRegisterMemFree(pvarProperty->bstrVal, CSM_SYSALLOC);  // this mem owned by caller

    pvarProperty->vt = VT_BSTR;

    hr = S_OK;
error:
    if (NULL != pwszStr)
    {
        LocalFree(pwszStr);
    }
    return hr;
}
        
STDMETHODIMP 
CCertManagePolicyModule::SetProperty(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [in] */ VARIANT const __RPC_FAR *pvalProperty)
{
     // no settable properties supported
     return S_FALSE;
}

        
STDMETHODIMP
CCertManagePolicyModule::Configure( 
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ LONG dwFlags)
{
     // no settable properties supported
     return S_FALSE;
}


// LEGACY Exit module

STDMETHODIMP
CCertManageExitModule::GetProperty(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty)
{
    UINT uiStr = 0;
    HRESULT hr;
    WCHAR *pwszStr = NULL;

    if (NULL == strPropertyName)
    {
        hr = S_FALSE;
        _JumpError(hr, error, "NULL in parm");
    }
    if (NULL == pvarProperty)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL parm");
    }

    if (0 == wcscmp(strPropertyName, wszCMM_PROP_NAME))
        uiStr = IDS_LEGACYEXITMODULE_NAME;
    else
    {
        hr = S_FALSE;  
        _JumpError(hr, error, "invalid property name");
    }

    // load string from resource
    hr = myLoadRCString(g_hInstance, uiStr, &pwszStr);
    _JumpIfError(hr, error, "myLoadRCString");

    pvarProperty->bstrVal = SysAllocString(pwszStr);
    if (NULL == pvarProperty->bstrVal)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "out of memory");
    }
    myRegisterMemFree(pvarProperty->bstrVal, CSM_SYSALLOC);  // this mem owned by caller

    pvarProperty->vt = VT_BSTR;

    hr = S_OK;
error:
    if (NULL != pwszStr)
    {
        LocalFree(pwszStr);
    }
    return hr;
}
        
STDMETHODIMP 
CCertManageExitModule::SetProperty(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [in] */ VARIANT const __RPC_FAR *pvalProperty)
{
     // no settable properties supported
     return S_FALSE;
}

        
STDMETHODIMP
CCertManageExitModule::Configure( 
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ LONG dwFlags)
{
     // no settable properties supported
     return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certcli\certcli.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certcli.cpp
//
// Contents:    Cert Server client implementation
//
// History:     24-Aug-96       vich created
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include "certsrvd.h"
#include "configp.h"
#include "config.h"
#include "getconf.h"
#include "request.h"
#include "certtype.h"

#include "csif.h"		// CertIf includes
#include "csprxy.h"		// CertPrxy includes
#include "resource.h"
#include "csresstr.h"


HINSTANCE g_hInstance = NULL; 

extern CRITICAL_SECTION g_csDomainSidCache;
extern CRITICAL_SECTION g_csOidURL;
extern BOOL g_fInitDone = FALSE;
extern BOOL g_fOidURL = FALSE;

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CCertConfig, CCertConfig)
    OBJECT_ENTRY(CLSID_CCertGetConfig, CCertGetConfig)
    OBJECT_ENTRY(CLSID_CCertRequest, CCertRequest)
#include "csifm.h"		// CertIf object map entries
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    BOOL fRet = TRUE;	// assume OK
    
    __try
    {
	fRet = CertPrxyDllMain(hInstance, dwReason, lpReserved);
	switch (dwReason)
	{
	    case DLL_PROCESS_ATTACH:
		myVerifyResourceStrings(hInstance);
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
		g_hInstance = hInstance;
		InitializeCriticalSection(&g_csDomainSidCache);
		g_fInitDone = TRUE;
		InitializeCriticalSection(&g_csOidURL);
        g_fOidURL = TRUE;
		break;

	    case DLL_PROCESS_DETACH:
		myFreeColumnDisplayNames();
		if (g_fOidURL)
		{
		    DeleteCriticalSection(&g_csOidURL);
		}
		if (g_fInitDone)
		{
		    DeleteCriticalSection(&g_csDomainSidCache);
		}
		_Module.Term();
		g_hInstance = NULL;
		break;
	}
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
	// return failure
	fRet = FALSE;
    }
    return(fRet);
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI
DllCanUnloadNow(void)
{
    return(
	(S_OK == CertPrxyDllCanUnloadNow() && 0 == _Module.GetLockCount())?
	S_OK : S_FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI
DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;
    
    hr = CertPrxyDllGetClassObject(rclsid, riid, ppv);
    if (S_OK != hr)
    {
	hr = _Module.GetClassObject(rclsid, riid, ppv);
	if (S_OK == hr && NULL != *ppv)
	{
	    myRegisterMemFree(*ppv, CSM_NEW | CSM_GLOBALDESTRUCTOR);
	}
    }
    return(hr);
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI
DllRegisterServer(void)
{
    HRESULT hr;
    HRESULT hr2;
    HKEY hGPOExtensions;

    // we remove the registration of GPO Processing call backs.  This was
    // intended for upgrading B2 clients.

    hr = RegOpenKeyEx(
		HKEY_LOCAL_MACHINE,
		TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions"),
                0,
                KEY_WRITE | KEY_READ,
                &hGPOExtensions);

    if (S_OK == hr)
    {
        RegDeleteKey(hGPOExtensions, TEXT("PublicKeyPolicy"));
        RegCloseKey(hGPOExtensions);
    }

    hr = CertPrxyDllRegisterServer();

    // registers object, typelib and all interfaces in typelib
    hr2 = _Module.RegisterServer(TRUE);

    if (S_OK == hr)
    {
	hr = hr2;
    }

    //register the evenlog
    hr2 =  myAddLogSourceToRegistry(L"%SystemRoot%\\System32\\pautoenr.dll",
                                    L"AutoEnrollment");

    if (S_OK == hr)
    {
	hr = hr2;
    }
    return(hr);
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI
DllUnregisterServer(void)
{
    HRESULT hr;
    HRESULT hr2;
    HKEY hGPOExtensions;

    hr = RegOpenKeyEx(
		HKEY_LOCAL_MACHINE,
		TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions"),
                0,
                KEY_WRITE | KEY_READ,
                &hGPOExtensions);
    if (S_OK == hr)
    {
        hr = RegDeleteKey(hGPOExtensions, TEXT("PublicKeyPolicy"));
        RegCloseKey(hGPOExtensions);
    }

    hr = CertPrxyDllUnregisterServer();
    hr2 = _Module.UnregisterServer();
    if (S_OK == hr)
    {
	hr = hr2;
    }
    return(hr);
}


// Register certcli.dll with the following command line to install templates:
//	regsvr32 /i:i /n certcli.dll

STDAPI
DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    LONG    lResult;
    LPCWSTR wszCurrentCmd = pszCmdLine;

    // parse the cmd line

    while(wszCurrentCmd && *wszCurrentCmd)
    {
        while(*wszCurrentCmd == L' ')
            wszCurrentCmd++;
        if(*wszCurrentCmd == 0)
            break;

        switch(*wszCurrentCmd++)
        {
            case L'i':
            
                CCertTypeInfo::InstallDefaultTypes();
                return S_OK;
        }
    }
    return S_OK;
}


void __RPC_FAR *__RPC_USER
MIDL_user_allocate(
    IN size_t cb)
{
    return(CoTaskMemAlloc(cb));
}


void __RPC_USER
MIDL_user_free(
    IN void __RPC_FAR *pb)
{
    CoTaskMemFree(pb);
}


VOID
myFreeColumnDisplayNames()
{
    extern VOID myFreeColumnDisplayNames2();

    CACleanup();
    myFreeColumnDisplayNames2();
    myFreeResourceStrings("certcli.dll");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certadm\restore.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        restore.cpp
//
// Contents:    Cert Server client database restore APIs
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "certsrvd.h"
#include "csdisp.h"
#include "certadmp.h"

#define __dwFILE__	__dwFILE_CERTADM_RESTORE_CPP__


extern WCHAR g_wszRestoreAnnotation[];


//+--------------------------------------------------------------------------
// CertSrvServerControl -- send a control command to the cert server.
//
// Parameters:
//	[in]  pwszConfig - name or config string of the server to control
//	[in]  dwControlFlags - control command and flags
//	[out] pcbOut - pointer to receive the size of command output data
//	[out] ppbOut - pointer to receive command output data.  Use the
//		CertSrvBackupFree() API to free the buffer.
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//+--------------------------------------------------------------------------

HRESULT
CERTBCLI_API
CertSrvServerControlW(
    IN WCHAR const *pwszConfig,
    IN DWORD dwControlFlags,
    OPTIONAL OUT DWORD *pcbOut,
    OPTIONAL OUT BYTE **ppbOut)
{
    HRESULT hr;
    ICertAdminD2 *pICertAdminD = NULL;
    DWORD dwServerVersion;
    WCHAR const *pwszAuthority;
    CERTTRANSBLOB ctbOut = { 0, NULL };

    if (NULL != pcbOut)
    {
	*pcbOut = 0;
    }
    if (NULL != ppbOut)
    {
	*ppbOut = NULL;
    }
    if (NULL == pwszConfig)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    __try
    {
	hr = OpenAdminServer(
		    pwszConfig,
		    &pwszAuthority,
		    &dwServerVersion,
		    &pICertAdminD);
	_LeaveIfError(hr, "OpenAdminServer");

	hr = pICertAdminD->ServerControl(
				    pwszAuthority,
				    dwControlFlags,
				    &ctbOut);
	_LeaveIfError(hr, "ServerControl");

	if (NULL != ctbOut.pb && NULL != ppbOut)
	{
	    *ppbOut = (BYTE *) LocalAlloc(LMEM_FIXED, ctbOut.cb);
	    if (NULL == *ppbOut)
	    {
		hr = E_OUTOFMEMORY;
		_LeaveError(hr, "LocalAlloc");
	    }
	    CopyMemory(*ppbOut, ctbOut.pb, ctbOut.cb);
	    if (NULL != pcbOut)
	    {
		*pcbOut = ctbOut.cb;
	    }
	}
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    if (NULL != ctbOut.pb)
    {
	CoTaskMemFree(ctbOut.pb);
    }
    if (NULL != pICertAdminD)
    {
	CloseAdminServer(&pICertAdminD);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CertSrvRestorePrepare -- indicate beginning of a restore session.
//
// Parameters:
//	[in]  pwszConfig - name of the server into which the restore
//		operation is going to be performed.
//	[in]  dwRestoreFlags -  Or'ed combination of RESTORE_TYPE_* flags; 0 if
//		no special flags are to be specified
//	[out] phbc - pointer to receive the backup context handle which is to
//		be passed to the subsequent restore APIs
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

HRESULT
CERTBCLI_API
CertSrvRestorePrepareW(
    IN  WCHAR const *pwszConfig,
    IN  ULONG dwRestoreFlags,
    OUT HCSBC *phbc)
{
    HRESULT hr;
    CSBACKUPCONTEXT *pcsbc = NULL;
    WCHAR const *pwszAuthority;

    if (NULL == pwszConfig || NULL == phbc)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *phbc = NULL;
    if (~CSRESTORE_TYPE_FULL & dwRestoreFlags)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "dwRestoreFlags");
    }

    hr = AllocateContext(pwszConfig, &pcsbc);
    _JumpIfError(hr, error, "AllocateContext");

    pcsbc->RestoreFlags = dwRestoreFlags;

    *phbc = (HCSBC) pcsbc;
    pcsbc = NULL;

error:
    if (NULL != pcsbc)
    {
	ReleaseContext(pcsbc);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CertSrvRestoreGetDatabaseLocations -- called both at backup time as well as at
//	restore time to get data base locations for different types of files.
//
// Parameters:
//	[in]  hbc - backup context handle which would have been obtained
//		through CertSrvBackupPrepare in the backup case and through
//		CertSrvRestorePrepare in the restore case.
//	[out] ppwszzFileList - pointer that will receive the pointer
//		to the list of database locations; allocated memory should be
//		freed using CertSrvBackupFree() API by the caller when it is no
//		longer needed; locations are returned in an array of null
//		terminated names and and the list is terminated by two L'\0's.
//		The first character of each name is the BFT character that
//		indicates the type of the file and the rest of the name tells
//		gives the path into which that particular type of file should
//		be restored.
//	[out] pcbList - will receive the number of bytes returned
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//
// Note:
//    This API returns only the fully qualified path of the databases, not the
//    name of the databases.
//---------------------------------------------------------------------------

HRESULT
CERTBCLI_API
CertSrvRestoreGetDatabaseLocationsW(
    IN  HCSBC hbc,
    OUT WCHAR **ppwszzFileList,
    OUT DWORD *pcbList)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;

    if (NULL == hbc)
    {
	hr = E_HANDLE;
	_JumpError(hr, error, "NULL handle");
    }
    if (NULL == ppwszzFileList || NULL == pcbList)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    __try
    {
	hr = BackupRestoreGetFileList(
				FLT_RESTOREDBLOCATIONS,
				hbc,
				ppwszzFileList,
				pcbList);
	_LeaveIfError(hr, "BackupRestoreGetFileList");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    return(hr);
}


HRESULT
CleanupOldLogs(
    OPTIONAL IN WCHAR const *pwszConfig,
    IN HKEY hkey,
    OPTIONAL IN WCHAR const *pwszLogPath, 
    IN ULONG genLow, 
    IN ULONG genHigh)
{
    HRESULT hr;
    DWORD cb;
    DWORD dwType;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    WCHAR *pwsz;
    WCHAR *pwszLogPathUNC = NULL;
    WCHAR *pwszLogPathLocal = NULL;
    WCHAR *pwszLogPathWild = NULL;

    WIN32_FIND_DATA wfd;
    WCHAR wszServer[MAX_PATH];
    WCHAR wszLogFileName[2 * MAX_PATH]; // UNC logfile name
    WCHAR *pwszFileName;		// filename (edb0006A.log)   

    if (genHigh < genLow)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad parm");
    }

    wszServer[0] = L'\0';
    if (NULL != pwszConfig)
    {
	// Allow UNC-style config strings: \\server\CAName

	while (L'\\' == *pwszConfig)
	{
	    pwszConfig++;
	}
	wcscpy(wszServer, pwszConfig);
	pwsz = wcschr(wszServer, L'\\');
	if (NULL != pwsz)
	{
	    *pwsz = L'\0';
	}
    }

    // If the Log Path wasn't passed in, fetch it from the server's registry

    if (NULL == pwszLogPath)
    {
	cb = sizeof(wszLogFileName);
	hr = RegQueryValueEx(
			hkey,
			wszREGDBLOGDIRECTORY,
			0,
			&dwType,
			(BYTE *) wszLogFileName,
			&cb);
	_JumpIfError(hr, error, "RegQueryValueEx");

	// Assume remote access -- convert to UNC path

	hr = myConvertLocalPathToUNC(
				wszServer,
				wszLogFileName,
				&pwszLogPathUNC);
	_JumpIfError(hr, error, "myConvertLocalPathToUNC");

	pwszLogPath = pwszLogPathUNC;
    }

    // If local machine -- convert UNC path to Local Path

    if (NULL == pwszConfig)
    {
	hr = myConvertUNCPathToLocal(pwszLogPath, &pwszLogPathLocal);
	_JumpIfError(hr, error, "myConvertUNCPathToLocal");

	pwszLogPath = pwszLogPathLocal;
    }

    // copy the LogPath -- it's of the form "\\server\c$\winnt\ntlog" or
    // "c:\winnt\ntlog", possibly with a trailing backslash
    //
    // make two copies of the logpath - one to pass a wildcard string for
    // searching and other to create filenames with full path for the logfiles

    hr = myBuildPathAndExt(
		    pwszLogPath,
		    L"edb*.log",
		    NULL, 		// pwszExt
		    &pwszLogPathWild);
    _JumpIfError(hr, error, "myBuildPathAndExt");

    // make pwszFileName point past the last backslash in wszLogFileName

    wcscpy(wszLogFileName, pwszLogPathWild);
    pwszFileName = wcsrchr(wszLogFileName, L'\\');
    CSASSERT(NULL != pwszFileName);
    pwszFileName++;

    hFind = FindFirstFile(pwszLogPathWild, &wfd);
    if (INVALID_HANDLE_VALUE != hFind)
    {
	do
	{
	    // wfd.cFileName points to the name of edb*.log file found

	    ULONG ulLogNo = wcstoul(wfd.cFileName + 3, NULL, 16);

	    if (ulLogNo < genLow || ulLogNo > genHigh)
	    {
		// This is an old logfile which was not copied down by ntbackup
		// -- clean it up.  First append the filename to the logpath
		// (Note: pwszFileName already points past the end of the final
		// backslash in logpath).  Then delete the file by passing in
		// the full path.

		wcscpy(pwszFileName, wfd.cFileName); 
		//printf("Deleting: %ws\n", wszLogFileName);
		if (!DeleteFile(wszLogFileName))
		{
		    // Unable to delete the old logfile; not cleaning up will
		    // cause problems later.  Return failure code.

		    hr = myHLastError();
		    _JumpError(hr, error, "DeleteFile");
		}
	    }

	} while (FindNextFile(hFind, &wfd));
	
	hr = myHLastError();
	if (HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES) != hr)
	{
	    // we came out of the loop for some unexpected error -- return the
	    // error code.

	    _JumpError(hr, error, "FindNextFile");
	}
    }
    hr = S_OK;

error:
    if (NULL != pwszLogPathUNC)
    {
	LocalFree(pwszLogPathUNC);
    }
    if (NULL != pwszLogPathLocal)
    {
	LocalFree(pwszLogPathLocal);
    }
    if (NULL != pwszLogPathWild)
    {
	LocalFree(pwszLogPathWild);
    }
    if (INVALID_HANDLE_VALUE != hFind)
    {
	FindClose(hFind);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CertSrvRestoreRegister -- register a restore operation. It will interlock all
//	subsequent restore operations, and will prevent the restore target from
//	starting until the call to CertSrvRestoreRegisterComplete is made.
//
// Parameters:
//	[in] hbc - backup context handle for the restore session.
//	[in] pwszCheckPointFilePath - path to restore the check point files
//	[in] pwszLogPath - path where the log files are restored
//	[in] rgrstmap - restore map
//	[in] crstmap - tells if there is a new restore map
//	[in] pwszBackupLogPath - path where the backup logs are located
//	[in] genLow - Lowest log# that was restored in this restore session
//	[in] genHigh - Highest log# that was restored in this restore session
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

HRESULT
CERTBCLI_API
CertSrvRestoreRegisterW(
    OPTIONAL IN HCSBC hbc,
    OPTIONAL IN WCHAR const *pwszCheckPointFilePath,
    OPTIONAL IN WCHAR const *pwszLogPath,
    OPTIONAL IN CSEDB_RSTMAPW rgrstmap[],
    IN LONG crstmap,
    OPTIONAL IN WCHAR const *pwszBackupLogPath,
    IN ULONG genLow,
    IN ULONG genHigh)
{
    HRESULT hr;
    WCHAR const *pwszConfig = NULL;
    HKEY hkey = NULL;
    HKEY hkeyRestore = NULL;
    WCHAR *pwszPath = NULL;
    DWORD cwcRstMap;
    WCHAR *pwszRstMap = NULL;
    WCHAR *pwsz;
    LONG i;
    DWORD dwDisposition;
    DWORD dwType;
    DWORD cbGen;
    ULONG genCurrent;
    BOOLEAN fDatabaseRecovered = FALSE;

    if (0 != crstmap && NULL == rgrstmap)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (NULL != hbc)
    {
	CSBACKUPCONTEXT *pcsbc = (CSBACKUPCONTEXT *) hbc;

	pwszConfig = pcsbc->pwszConfig;
    }

    hr = myRegOpenRelativeKey(
			pwszConfig,
			L"",
			RORKF_CREATESUBKEYS,
			&pwszPath,
			NULL,		// ppwszName
			&hkey);

    // If the registry key doesn't exist, and we're restoring the local
    // machine, create it now.  The rest of the registry will be restored
    // prior to starting the cert server to recover the cert server database.

    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {
	BOOL fLocal = TRUE;

	if (NULL != pwszConfig)
	{
	    hr = myIsConfigLocal(pwszConfig, NULL, &fLocal);
	    _JumpIfErrorStr(hr, error, "myIsConfigLocal", pwszConfig);
	}
	if (fLocal)
	{
	    hr = RegCreateKeyEx(
			    HKEY_LOCAL_MACHINE,
			    wszREGKEYCONFIGPATH,
			    0,			// Reserved
			    NULL,		// lpClass
			    0,			// dwOptions
			    KEY_ALL_ACCESS,
			    NULL,
			    &hkey,
			    &dwDisposition);
	    _JumpIfError(hr, error, "RegCreateKeyEx");
	}
	else
	{
	    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	}
    }
    _JumpIfErrorStr(hr, error, "myRegOpenRelativeKey", pwszConfig);

    hr = RegCreateKeyEx(
		    hkey,
		    wszREGKEYRESTOREINPROGRESS,
		    0,			// Reserved
		    NULL,		// lpClass
		    0,			// dwOptions
		    KEY_ALL_ACCESS,
		    NULL,
		    &hkeyRestore,
		    &dwDisposition);
    _JumpIfError(hr, error, "RegCreateKeyEx");

    // Seed the restore-in-progress in the registry.

    hr = CERTSRV_E_SERVER_SUSPENDED;

    hr = RegSetValueEx(
		    hkeyRestore,
		    wszREGRESTORESTATUS,
		    0,
		    REG_DWORD,
		    (BYTE *) &hr,
		    sizeof(DWORD));
    _JumpIfError(hr, error, "RegSetValueEx");

    // We've now interlocked other restore operations from coming in from other
    // machines.

    if (0 != crstmap)
    {
	// Full backup:
	//
	// The restore map should only be set on a full backup.  If there's
	// already a restore map size (or restore map), then this full backup
	// is overriding a previously incomplete full backup.

	// Save away the size of the restore map.

	hr = RegSetValueEx(
			hkeyRestore,
			wszREGRESTOREMAPCOUNT,
			0,
			REG_DWORD,
			(BYTE *) &crstmap,
			sizeof(DWORD));

	// We now need to convert the restore map into one that we can put
	// into the registry.  First figure out how big it will be.

	cwcRstMap = 1;
	for (i = 0 ; i < crstmap ; i++)
	{
	    cwcRstMap +=
		myLocalPathwcslen(rgrstmap[i].pwszDatabaseName) + 1 +
		myLocalPathwcslen(rgrstmap[i].pwszNewDatabaseName) + 1;
	}

	pwszRstMap = (WCHAR *) LocalAlloc(
				    LMEM_FIXED,
				    cwcRstMap * sizeof(WCHAR));
	if (NULL == pwszRstMap)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}

	pwsz = pwszRstMap;
	for (i = 0 ; i < crstmap ; i++)
	{
	    myLocalPathwcscpy(pwsz, rgrstmap[i].pwszDatabaseName);
	    pwsz += wcslen(pwsz) + 1;

	    myLocalPathwcscpy(pwsz, rgrstmap[i].pwszNewDatabaseName);
	    pwsz += wcslen(pwsz) + 1;
	}

	*pwsz++ = L'\0';

	hr = RegSetValueEx(
			hkeyRestore,
			wszREGRESTOREMAP,
			0,
			REG_MULTI_SZ,
			(BYTE *) pwszRstMap,
			SAFE_SUBTRACT_POINTERS(
					(BYTE *) pwsz,
					(BYTE *) pwszRstMap));
    }
    else
    {
	// Incremental backup:
	//
	// Fail if no restore map exists -- Insist that a full backup be in
	// progress...

	cbGen = sizeof(genCurrent);
	hr = RegQueryValueEx(
			hkeyRestore,
			wszREGRESTOREMAPCOUNT,
			0,
			&dwType,
			(BYTE *) &genCurrent,
			&cbGen);
	_JumpIfError(hr, error, "RegQueryValueEx");

	// Expand genLow and genHigh to include previously registered log files

	cbGen = sizeof(genCurrent);
	hr = RegQueryValueEx(
			hkeyRestore,
			wszREGLOWLOGNUMBER,
			0,
			&dwType,
			(BYTE *) &genCurrent,
			&cbGen);
	if (S_OK == hr &&
	    REG_DWORD == dwType &&
	    sizeof(genCurrent) == cbGen &&
	    genLow > genCurrent)
	{
	    genLow = genCurrent;
	}

	cbGen = sizeof(genCurrent);
	hr = RegQueryValueEx(
			hkeyRestore,
			wszREGHIGHLOGNUMBER,
			0,
			&dwType,
			(BYTE *) &genCurrent,
			&cbGen);
	if (S_OK == hr &&
	    REG_DWORD == dwType &&
	    sizeof(genCurrent) == cbGen &&
	    genHigh < genCurrent)
	{
	    genHigh = genCurrent;
	}
    }

    hr = RegSetValueEx(
		    hkeyRestore,
		    wszREGLOWLOGNUMBER,
		    0,
		    REG_DWORD,
		    (BYTE *) &genLow,
		    sizeof(DWORD));
    _JumpIfError(hr, error, "RegSetValueEx");

    hr = RegSetValueEx(
		    hkeyRestore,
		    wszREGHIGHLOGNUMBER,
		    0,
		    REG_DWORD,
		    (BYTE *) &genHigh,
		    sizeof(DWORD));
    _JumpIfError(hr, error, "RegSetValueEx");

    if (NULL != pwszBackupLogPath)
    {
	hr = SetRegistryLocalPathString(
				    hkeyRestore,
				    wszREGBACKUPLOGDIRECTORY,
				    pwszBackupLogPath);
	_JumpIfError(hr, error, "SetRegistryLocalPathString");
    }

    if (NULL != pwszCheckPointFilePath)
    {
	hr = SetRegistryLocalPathString(
				    hkeyRestore,
				    wszREGCHECKPOINTFILE,
				    pwszCheckPointFilePath);
	_JumpIfError(hr, error, "SetRegistryLocalPathString");
    }

    if (NULL != pwszLogPath)
    {
	hr = SetRegistryLocalPathString(
				    hkeyRestore,
				    wszREGLOGPATH,
				    pwszLogPath);
	_JumpIfError(hr, error, "SetRegistryLocalPathString");
    }

    // Reset the "database recovered" bit.

    hr = RegSetValueEx(
		    hkeyRestore,
		    wszREGDATABASERECOVERED,
		    0,
		    REG_BINARY,
		    (BYTE *) &fDatabaseRecovered,
		    sizeof(BOOLEAN));
    _JumpIfError(hr, error, "RegSetValueEx");

    // We have successfully registered the restore, now cleanup any
    // pre-existing logfiles in the logdir to avoid JetExternalRestore using
    // logfiles that are not specified by the low and high log numbers.

    hr = CleanupOldLogs(pwszConfig, hkey, pwszLogPath, genLow, genHigh);
    _JumpIfError(hr, error, "CleanupOldLogs");

error:
    if (NULL != pwszRstMap)
    {
	LocalFree(pwszRstMap);
    }
    if (NULL != hkeyRestore)
    {
        RegCloseKey(hkeyRestore);
    }
    if (NULL != hkey)
    {
        RegCloseKey(hkey);
    }
    if (NULL != pwszPath)
    {
	LocalFree(pwszPath);
    }

    hr = myHError(hr);

    return hr;
}


//+--------------------------------------------------------------------------
// CertSrvRestoreRegisterComplete -- indicate that a previously registered restore
//	is complete.
//
// Parameters:
//	[in] hbc - backup context handle
//	[in] hrRestoreState - success code if the restore was successful
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

HRESULT
CERTBCLI_API
CertSrvRestoreRegisterComplete(
    OPTIONAL IN HCSBC hbc,
    IN HRESULT hrRestore)
{
    HRESULT hr;
    WCHAR const *pwszConfig = NULL;
    HKEY hkey = NULL;
    HKEY hkeyRestore = NULL;
    WCHAR *pwszPath = NULL;
    DWORD dwDisposition;

    if (NULL != hbc)
    {
	CSBACKUPCONTEXT *pcsbc = (CSBACKUPCONTEXT *) hbc;

	pwszConfig = pcsbc->pwszConfig;
    }
    if (S_OK != hrRestore && SUCCEEDED(hrRestore))
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "hrRestore");
    }

    hr = myRegOpenRelativeKey(
			pwszConfig,
			L"",
			RORKF_CREATESUBKEYS,
			&pwszPath,
			NULL,		// ppwszName
			&hkey);
    _JumpIfErrorStr(hr, error, "myRegOpenRelativeKey", pwszConfig);

    hr = RegCreateKeyEx(
		    hkey,
		    wszREGKEYRESTOREINPROGRESS,
		    0,			// Reserved
		    NULL,		// lpClass
		    0,			// dwOptions
		    KEY_ALL_ACCESS,
		    NULL,
		    &hkeyRestore,
		    &dwDisposition);
    _JumpIfError(hr, error, "RegCreateKeyEx");

    // If the restore status is not S_OK, then set the status to the error.
    // If the restore status is success, then clear the restore-in-progress
    // indicator.

    if (S_OK != hrRestore)
    {
	hr = RegSetValueEx(
			hkeyRestore,
			wszREGRESTORESTATUS,
			0,
			REG_DWORD,
			(BYTE *) &hrRestore,
			sizeof(DWORD));
	_JumpIfError(hr, error, "RegSetValueEx");
    }
    else
    {
	hr = RegDeleteValue(hkeyRestore, wszREGRESTORESTATUS);
	_JumpIfError(hr, error, "RegDeleteValue");
    }

error:
    if (NULL != hkeyRestore)
    {
        RegCloseKey(hkeyRestore);
    }
    if (NULL != hkey)
    {
        RegCloseKey(hkey);
    }
    if (NULL != pwszPath)
    {
	LocalFree(pwszPath);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CertSrvRestoreEnd -- end a restore session
//
// Parameters:
//	[in] hbc - backup context handle
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

HRESULT
CERTBCLI_API
CertSrvRestoreEnd(
    IN HCSBC hbc)
{
    HRESULT hr;

    if (NULL == hbc)
    {
	hr = E_HANDLE;
	_JumpError(hr, error, "NULL handle");
    }

    __try
    {
	ReleaseContext((CSBACKUPCONTEXT *) hbc);
	hr = S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    return(hr);
}


HRESULT
CERTBCLI_API
CertSrvRestoreRegisterThroughFile(
    IN HCSBC hbc,
    OPTIONAL IN WCHAR const *pwszCheckPointFilePath,
    OPTIONAL IN WCHAR const *pwszLogPath,
    OPTIONAL IN CSEDB_RSTMAPW rgrstmap[],
    IN LONG crstmap,
    OPTIONAL IN WCHAR const *pwszBackupLogPath,
    IN ULONG genLow,
    IN ULONG genHigh)
{
    HRESULT hr = S_OK;
    WCHAR const *pwszConfig = NULL;
    LONG i;
    DWORD dwType;
    DWORD cbGen;
    ULONG genCurrent;
    BOOLEAN fDatabaseRecovered = FALSE;
    WCHAR wszLogPath[MAX_PATH+1];
    WCHAR wszFormat[256]; // must fit MAXDWORD
    WCHAR wszKeyName[256]; // must fit RestoreMapN
    LPWSTR pwszLogPathUNC = NULL;
    HKEY hkey = NULL;
    LPWSTR pwszPath = NULL;
    LPWSTR pwszRestoreFile = NULL;
    LPWSTR pwszServer = NULL;
    LPWSTR pwszAuthority = NULL;

    if (!hbc ||
        (0 != crstmap && NULL == rgrstmap))
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL parm");
    }

    pwszConfig = ((CSBACKUPCONTEXT *) hbc)->pwszConfig;

    hr = myRegOpenRelativeKey(
			pwszConfig,
			L"",
			0,
			&pwszPath,
			NULL,		// ppwszName
			&hkey);
	_JumpIfError(hr, error, "RegQueryValueEx");

    if (NULL == pwszLogPath)
    {
        DWORD cb = sizeof(wszLogPath);
        hr = RegQueryValueEx(
		        hkey,
		        wszREGDBLOGDIRECTORY,
		        0,
		        &dwType,
		        (BYTE *) wszLogPath,
		        &cb);
        _JumpIfError(hr, error, "RegQueryValueEx");

        pwszLogPath = wszLogPath;
    }

    if(pwszConfig)
    {
        // remote access - convert to UNC
        hr = mySplitConfigString(
            pwszConfig,
            &pwszServer,
            &pwszAuthority);
        _JumpIfError(hr, error, "mySplitConfigString");

	    hr = myConvertLocalPathToUNC(
				    pwszServer,
				    pwszLogPath,
				    &pwszLogPathUNC);
	    _JumpIfError(hr, error, "myConvertLocalPathToUNC");

	    pwszLogPath = pwszLogPathUNC;
    }

    pwszRestoreFile = (LPWSTR)LocalAlloc(LMEM_FIXED,
        sizeof(WCHAR)*(wcslen(pwszLogPath)+wcslen(wszRESTORE_FILENAME)+2));
    _JumpIfAllocFailed(pwszRestoreFile, error);

    wcscpy(pwszRestoreFile, pwszLogPathUNC);
    wcscat(pwszRestoreFile, L"\\");
    wcscat(pwszRestoreFile, wszRESTORE_FILENAME);

    wsprintf(wszFormat, L"%d", CERTSRV_E_SERVER_SUSPENDED);
    if(!WritePrivateProfileString(
            wszRESTORE_SECTION,
            wszREGRESTORESTATUS,
            wszFormat,
            pwszRestoreFile))
    {
        hr = myHLastError();
        _JumpError(hr, error, "WritePrivateProfileString");
    }
    
    if (0 != crstmap)
    {
	    // Full backup:
	    //
	    // The restore map should only be set on a full backup.  If there's
	    // already a restore map size (or restore map), then this full backup
	    // is overriding a previously incomplete full backup.

        wsprintf(wszFormat, L"%d", crstmap);
        if(!WritePrivateProfileString(
                wszRESTORE_SECTION,
                wszREGRESTOREMAPCOUNT,
                wszFormat,
                pwszRestoreFile))
        {
            hr = myHLastError();
            _JumpError(hr, error, "WritePrivateProfileString");
        }

        for (i = 0 ; i < crstmap ; i++)
        {
            WCHAR wszPath[MAX_PATH];
            wsprintf(wszKeyName, L"%s%d", wszREGRESTOREMAP, i);

            myLocalPathwcscpy(wszPath, rgrstmap[i].pwszDatabaseName);
        
            if(!WritePrivateProfileString(
                    wszRESTORE_SECTION,
                    wszKeyName,
                    wszPath,
                    pwszRestoreFile))
            {
                hr = myHLastError();
                _JumpError(hr, error, "WritePrivateProfileInt");
            }

            wsprintf(wszKeyName, L"%s%s%d", wszREGRESTOREMAP, 
                wszRESTORE_NEWLOGSUFFIX, i);

            myLocalPathwcscpy(wszPath, rgrstmap[i].pwszNewDatabaseName);

            if(!WritePrivateProfileString(
                    wszRESTORE_SECTION,
                    wszKeyName,
                    wszPath,
                    pwszRestoreFile))
            {
                hr = myHLastError();
                _JumpError(hr, error, "WritePrivateProfileInt");
            }

        }
    }
    else
    {
	    // Incremental backup:
	    //
	    // Fail if no restore map exists -- Insist that a full backup be in
	    // progress...

	    cbGen = sizeof(genCurrent);
	    hr = RegQueryValueEx(
			    hkey,
			    wszREGRESTOREMAPCOUNT,
			    0,
			    &dwType,
			    (BYTE *) &genCurrent,
			    &cbGen);
	    _JumpIfError(hr, error, "RegQueryValueEx");

	    // Expand genLow and genHigh to include previously registered log files

	    cbGen = sizeof(genCurrent);
	    hr = RegQueryValueEx(
			    hkey,
			    wszREGLOWLOGNUMBER,
			    0,
			    &dwType,
			    (BYTE *) &genCurrent,
			    &cbGen);
	    if (S_OK == hr &&
	        REG_DWORD == dwType &&
	        sizeof(genCurrent) == cbGen &&
	        genLow > genCurrent)
	    {
	        genLow = genCurrent;
	    }

	    cbGen = sizeof(genCurrent);
	    hr = RegQueryValueEx(
			    hkey,
			    wszREGHIGHLOGNUMBER,
			    0,
			    &dwType,
			    (BYTE *) &genCurrent,
			    &cbGen);
	    if (S_OK == hr &&
	        REG_DWORD == dwType &&
	        sizeof(genCurrent) == cbGen &&
	        genHigh < genCurrent)
	    {
	        genHigh = genCurrent;
	    }
    }

    // dword wszREGLOWLOGNUMBER=genLow
    wsprintf(wszFormat, L"%d", genLow);
    if(!WritePrivateProfileString(
            wszRESTORE_SECTION,
            wszREGLOWLOGNUMBER,
            wszFormat,
            pwszRestoreFile))
    {
        hr = myHLastError();
        _JumpError(hr, error, "WritePrivateProfileString");
    }

    // dword wszREGHIGHLOGNUMBER=genHigh
    wsprintf(wszFormat, L"%d", genHigh);
    if(!WritePrivateProfileString(
            wszRESTORE_SECTION,
            wszREGHIGHLOGNUMBER,
            wszFormat,
            pwszRestoreFile))
    {
        hr = myHLastError();
        _JumpError(hr, error, "WritePrivateProfileString");
    }

    // string wszREGBACKUPLOGDIRECTORY=pwszBackupLogPath
    if(!WritePrivateProfileString(
            wszRESTORE_SECTION,
            wszREGBACKUPLOGDIRECTORY,
            pwszBackupLogPath,
            pwszRestoreFile))
    {
        hr = myHLastError();
        _JumpError(hr, error, "WritePrivateProfileString");
    }

    // string wszREGCHECKPOINTFILE=pwszCheckPointFilePath
    if(!WritePrivateProfileString(
            wszRESTORE_SECTION,
            wszREGCHECKPOINTFILE,
            pwszCheckPointFilePath,
            pwszRestoreFile))
    {
        hr = myHLastError();
        _JumpError(hr, error, "WritePrivateProfileString");
    }

    // string wszREGLOGPATH=pwszLogPath
    if(!WritePrivateProfileString(
            wszRESTORE_SECTION,
            wszREGLOGPATH,
            pwszLogPath,
            pwszRestoreFile))
    {
        hr = myHLastError();
        _JumpError(hr, error, "WritePrivateProfileString");
    }

    // dword wszREGDATABASERECOVERED=fDatabaseRecovered
    wsprintf(wszFormat, L"%d", fDatabaseRecovered);
    if(!WritePrivateProfileString(
            wszRESTORE_SECTION,
            wszREGDATABASERECOVERED,
            wszFormat,
            pwszRestoreFile))
    {
        hr = myHLastError();
        _JumpError(hr, error, "WritePrivateProfileString");
    }

    // We have successfully registered the restore, now cleanup any
    // pre-existing logfiles in the logdir to avoid JetExternalRestore using
    // logfiles that are not specified by the low and high log numbers.

    hr = CleanupOldLogs(pwszConfig, hkey, pwszLogPath, genLow, genHigh);
    _JumpIfError(hr, error, "CleanupOldLogs");

    // delete restore status error
    if(!WritePrivateProfileString(
            wszRESTORE_SECTION,
            wszREGRESTORESTATUS,
            NULL,
            pwszRestoreFile))
    {
        hr = myHLastError();
        _JumpError(hr, error, "WritePrivateProfileString");
    }

error:

    // in case of failure, try to delete restore file
    if(S_OK!=hr)
    {
        if(!DeleteFile(pwszRestoreFile))
        {
            _PrintIfError(myHLastError(), "DeleteFile");
        }
    }

    LOCAL_FREE(pwszPath);
    LOCAL_FREE(pwszLogPathUNC);
    LOCAL_FREE(pwszRestoreFile);
    LOCAL_FREE(pwszServer);
    LOCAL_FREE(pwszAuthority);

    if (NULL != hkey)
    {
        RegCloseKey(hkey);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certcli\column.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        column.cpp
//
// Contents:    CertCli implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include "csprop.h"
#include "resource.h"


extern HINSTANCE g_hInstance;


typedef struct _COLUMNTRANSLATE
{
    WCHAR const *pwszColumnName;
    DWORD        idMsgDisplayName;
    WCHAR const *pwszDisplayName;
} COLUMNTRANSLATE;


COLUMNTRANSLATE g_aColTable[] =
{
    { wszPROPREQUESTDOT wszPROPREQUESTREQUESTID, IDS_COLUMN_REQUESTID, },
    { wszPROPREQUESTDOT wszPROPREQUESTRAWREQUEST, IDS_COLUMN_REQUESTRAWREQUEST, },
    { wszPROPREQUESTDOT wszPROPREQUESTRAWARCHIVEDKEY, IDS_COLUMN_REQUESTRAWARCHIVEDKEY, },
    { wszPROPREQUESTDOT wszPROPREQUESTKEYRECOVERYHASHES, IDS_COLUMN_REQUESTKEYRECOVERYHASHES, },
    { wszPROPREQUESTDOT wszPROPREQUESTRAWOLDCERTIFICATE, IDS_COLUMN_REQUESTRAWOLDCERTIFICATE, },
    { wszPROPREQUESTDOT wszPROPREQUESTATTRIBUTES, IDS_COLUMN_REQUESTATTRIBUTES, },
    { wszPROPREQUESTDOT wszPROPREQUESTTYPE, IDS_COLUMN_REQUESTTYPE, },
    { wszPROPREQUESTDOT wszPROPREQUESTFLAGS, IDS_COLUMN_REQUESTFLAGS, },
    { wszPROPREQUESTDOT L"Status", IDS_COLUMN_REQUESTSTATUS, },
    { wszPROPREQUESTDOT wszPROPREQUESTSTATUSCODE, IDS_COLUMN_REQUESTSTATUSCODE, },
    { wszPROPREQUESTDOT wszPROPREQUESTDISPOSITION, IDS_COLUMN_REQUESTDISPOSITION, },
    { wszPROPREQUESTDOT wszPROPREQUESTDISPOSITIONMESSAGE, IDS_COLUMN_REQUESTDISPOSITIONMESSAGE, },
    { wszPROPREQUESTDOT wszPROPREQUESTSUBMITTEDWHEN, IDS_COLUMN_REQUESTSUBMITTEDWHEN, },
    { wszPROPREQUESTDOT wszPROPREQUESTRESOLVEDWHEN, IDS_COLUMN_REQUESTRESOLVEDWHEN, },
    { wszPROPREQUESTDOT wszPROPREQUESTREVOKEDWHEN, IDS_COLUMN_REQUESTREVOKEDWHEN, },
    { wszPROPREQUESTDOT wszPROPREQUESTREVOKEDEFFECTIVEWHEN, IDS_COLUMN_REQUESTREVOKEDEFFECTIVEWHEN, },
    { wszPROPREQUESTDOT wszPROPREQUESTREVOKEDREASON, IDS_COLUMN_REQUESTREVOKEDREASON, },
    { wszPROPREQUESTDOT wszPROPREQUESTERNAME, IDS_COLUMN_REQUESTERNAME, },
    { wszPROPREQUESTDOT wszPROPCALLERNAME, IDS_COLUMN_CALLERNAME, },
    { wszPROPREQUESTDOT wszPROPREQUESTERADDRESS, IDS_COLUMN_REQUESTERADDRESS, },

    { wszPROPREQUESTDOT wszPROPDISTINGUISHEDNAME, IDS_COLUMN_REQUESTDISTINGUISHEDNAME, },
    { wszPROPREQUESTDOT wszPROPRAWNAME, IDS_COLUMN_REQUESTRAWNAME, },
    { wszPROPREQUESTDOT wszPROPCOUNTRY, IDS_COLUMN_REQUESTCOUNTRY, },
    { wszPROPREQUESTDOT wszPROPORGANIZATION, IDS_COLUMN_REQUESTORGANIZATION, },
    { wszPROPREQUESTDOT wszPROPORGUNIT, IDS_COLUMN_REQUESTORGUNIT, },
    { wszPROPREQUESTDOT wszPROPCOMMONNAME, IDS_COLUMN_REQUESTCOMMONNAME, },
    { wszPROPREQUESTDOT wszPROPLOCALITY, IDS_COLUMN_REQUESTLOCALITY, },
    { wszPROPREQUESTDOT wszPROPSTATE, IDS_COLUMN_REQUESTSTATE, },
    { wszPROPREQUESTDOT wszPROPTITLE, IDS_COLUMN_REQUESTTITLE, },
    { wszPROPREQUESTDOT wszPROPGIVENNAME, IDS_COLUMN_REQUESTGIVENNAME, },
    { wszPROPREQUESTDOT wszPROPINITIALS, IDS_COLUMN_REQUESTINITIALS, },
    { wszPROPREQUESTDOT wszPROPSURNAME, IDS_COLUMN_REQUESTSURNAME, },
    { wszPROPREQUESTDOT wszPROPDOMAINCOMPONENT, IDS_COLUMN_REQUESTDOMAINCOMPONENT, },
    { wszPROPREQUESTDOT wszPROPEMAIL, IDS_COLUMN_REQUESTEMAIL, },
    { wszPROPREQUESTDOT wszPROPSTREETADDRESS, IDS_COLUMN_REQUESTSTREETADDRESS, },
    { wszPROPREQUESTDOT wszPROPUNSTRUCTUREDNAME, IDS_COLUMN_REQUESTUNSTRUCTUREDNAME, },
    { wszPROPREQUESTDOT wszPROPUNSTRUCTUREDADDRESS, IDS_COLUMN_REQUESTUNSTRUCTUREDADDRESS, },
    { wszPROPREQUESTDOT wszPROPDEVICESERIALNUMBER, IDS_COLUMN_REQUESTDEVICESERIALNUMBER },
    { wszPROPREQUESTDOT wszPROPSIGNERPOLICIES, IDS_COLUMN_REQUESTSIGNERPOLICIES },
    { wszPROPREQUESTDOT wszPROPSIGNERAPPLICATIONPOLICIES, IDS_COLUMN_REQUESTSIGNERAPPLICATIONPOLICIES },

    { wszPROPCERTIFICATEREQUESTID, IDS_COLUMN_CERTIFICATEREQUESTID, },
    { wszPROPRAWCERTIFICATE, IDS_COLUMN_CERTIFICATERAWCERTIFICATE, },
    { wszPROPCERTIFICATEHASH, IDS_COLUMN_CERTIFICATECERTIFICATEHASH, },
    { wszPROPCERTIFICATETEMPLATE, IDS_COLUMN_PROPCERTIFICATETEMPLATE, },
    { wszPROPCERTIFICATEENROLLMENTFLAGS, IDS_COLUMN_PROPCERTIFICATEENROLLMENTFLAGS, },
    { wszPROPCERTIFICATEGENERALFLAGS, IDS_COLUMN_PROPCERTIFICATEGENERALFLAGS, },
    { wszPROPCERTIFICATESERIALNUMBER, IDS_COLUMN_CERTIFICATESERIALNUMBER, },
    { wszPROPCERTIFICATEISSUERNAMEID, IDS_COLUMN_CERTIFICATEISSUERNAMEID, },
    { wszPROPCERTIFICATENOTBEFOREDATE, IDS_COLUMN_CERTIFICATENOTBEFOREDATE, },
    { wszPROPCERTIFICATENOTAFTERDATE, IDS_COLUMN_CERTIFICATENOTAFTERDATE, },
    { wszPROPCERTIFICATESUBJECTKEYIDENTIFIER, IDS_COLUMN_CERTIFICATESUBJECTKEYIDENTIFIER , },
    { wszPROPCERTIFICATERAWPUBLICKEY, IDS_COLUMN_CERTIFICATERAWPUBLICKEY, },
    { wszPROPCERTIFICATEPUBLICKEYLENGTH, IDS_COLUMN_CERTIFICATEPUBLICKEYLENGTH, },
    { wszPROPCERTIFICATEPUBLICKEYALGORITHM, IDS_COLUMN_CERTIFICATEPUBLICKEYALGORITHM, },
    { wszPROPCERTIFICATERAWPUBLICKEYALGORITHMPARAMETERS, IDS_COLUMN_CERTIFICATERAWPUBLICKEYALGORITHMPARAMETERS, },
    { wszPROPCERTIFICATEUPN, IDS_COLUMN_CERTIFICATEUPN, },

    { wszPROPDISTINGUISHEDNAME, IDS_COLUMN_CERTIFICATEDISTINGUISHEDNAME, },
    { wszPROPRAWNAME, IDS_COLUMN_CERTIFICATERAWNAME, },
    { wszPROPCOUNTRY, IDS_COLUMN_CERTIFICATECOUNTRY, },
    { wszPROPORGANIZATION, IDS_COLUMN_CERTIFICATEORGANIZATION, },
    { wszPROPORGUNIT, IDS_COLUMN_CERTIFICATEORGUNIT, },
    { wszPROPCOMMONNAME, IDS_COLUMN_CERTIFICATECOMMONNAME, },
    { wszPROPLOCALITY, IDS_COLUMN_CERTIFICATELOCALITY, },
    { wszPROPSTATE, IDS_COLUMN_CERTIFICATESTATE, },
    { wszPROPTITLE, IDS_COLUMN_CERTIFICATETITLE, },
    { wszPROPGIVENNAME, IDS_COLUMN_CERTIFICATEGIVENNAME, },
    { wszPROPINITIALS, IDS_COLUMN_CERTIFICATEINITIALS, },
    { wszPROPSURNAME, IDS_COLUMN_CERTIFICATESURNAME, },
    { wszPROPDOMAINCOMPONENT, IDS_COLUMN_CERTIFICATEDOMAINCOMPONENT, },
    { wszPROPEMAIL, IDS_COLUMN_CERTIFICATEEMAIL, },
    { wszPROPSTREETADDRESS, IDS_COLUMN_CERTIFICATESTREETADDRESS, },
    { wszPROPUNSTRUCTUREDNAME, IDS_COLUMN_CERTIFICATEUNSTRUCTUREDNAME, },
    { wszPROPUNSTRUCTUREDADDRESS, IDS_COLUMN_CERTIFICATEUNSTRUCTUREDADDRESS, },
    { wszPROPDEVICESERIALNUMBER, IDS_COLUMN_CERTIFICATEDEVICESERIALNUMBER },

    { wszPROPEXTREQUESTID, IDS_COLUMN_EXTREQUESTID, },
    { wszPROPEXTNAME, IDS_COLUMN_EXTNAME, },
    { wszPROPEXTFLAGS, IDS_COLUMN_EXTFLAGS, },
    { wszPROPEXTRAWVALUE, IDS_COLUMN_EXTRAWVALUE, },

    { wszPROPATTRIBREQUESTID, IDS_COLUMN_ATTRIBREQUESTID, },
    { wszPROPATTRIBNAME, IDS_COLUMN_ATTRIBNAME, },
    { wszPROPATTRIBVALUE, IDS_COLUMN_ATTRIBVALUE, },

    { wszPROPCRLROWID, IDS_COLUMN_CRLROWID, },
    { wszPROPCRLNUMBER, IDS_COLUMN_CRLNUMBER, },
    { wszPROPCRLMINBASE, IDS_COLUMN_CRLMINBASE, },
    { wszPROPCRLNAMEID, IDS_COLUMN_CRLNAMEID, },
    { wszPROPCRLCOUNT, IDS_COLUMN_CRLCOUNT, },
    { wszPROPCRLTHISUPDATE, IDS_COLUMN_CRLTHISUPDATE, },
    { wszPROPCRLNEXTUPDATE, IDS_COLUMN_CRLNEXTUPDATE, },
    { wszPROPCRLTHISPUBLISH, IDS_COLUMN_CRLTHISPUBLISH, },
    { wszPROPCRLNEXTPUBLISH, IDS_COLUMN_CRLNEXTPUBLISH, },
    { wszPROPCRLEFFECTIVE, IDS_COLUMN_CRLEFFECTIVE, },
    { wszPROPCRLPROPAGATIONCOMPLETE, IDS_COLUMN_CRLPROPAGATIONCOMPLETE, },
    { wszPROPCRLLASTPUBLISHED, IDS_COLUMN_CRLLASTPUBLISHED, },
    { wszPROPCRLPUBLISHATTEMPTS, IDS_COLUMN_CRLPUBLISHATTEMPTS, },
    { wszPROPCRLPUBLISHFLAGS, IDS_COLUMN_CRLPUBLISHFLAGS, },
    { wszPROPCRLPUBLISHSTATUSCODE, IDS_COLUMN_CRLPUBLISHSTATUSCODE, },
    { wszPROPCRLPUBLISHERROR, IDS_COLUMN_CRLPUBLISHERROR, },
    { wszPROPCRLRAWCRL, IDS_COLUMN_CRLRAWCRL, },

    // Obsolete:
    { wszPROPCERTIFICATETYPE, IDS_COLUMN_CERTIFICATETYPE, },
    { wszPROPCERTIFICATERAWSMIMECAPABILITIES, IDS_COLUMN_CERTIFICATERAWSMIMECAPABILITIES },
    { wszPROPNAMETYPE, IDS_COLUMN_CERTIFICATENAMETYPE, },
    { wszPROPREQUESTDOT wszPROPNAMETYPE, IDS_COLUMN_REQUESTNAMETYPE, },

    { NULL, 0, },
};

#define CCOL_MAX	(ARRAYSIZE(g_aColTable) - 1)


typedef struct _CAPROPTRANSLATE
{
    LONG         lPropId;
    DWORD        idMsgDisplayName;
    WCHAR const *pwszDisplayName;
} CAPROPTRANSLATE;


CAPROPTRANSLATE g_aCAPropTable[] =
{
    { CR_PROP_FILEVERSION,	 IDS_CAPROP_FILEVERSION, },
    { CR_PROP_PRODUCTVERSION,	 IDS_CAPROP_PRODUCTVERSION, },
    { CR_PROP_EXITCOUNT,	 IDS_CAPROP_EXITCOUNT, },
    { CR_PROP_EXITDESCRIPTION,	 IDS_CAPROP_EXITDESCRIPTION, },
    { CR_PROP_POLICYDESCRIPTION, IDS_CAPROP_POLICYDESCRIPTION, },
    { CR_PROP_CANAME,		 IDS_CAPROP_CANAME, },
    { CR_PROP_SANITIZEDCANAME,	 IDS_CAPROP_SANITIZEDCANAME, },
    { CR_PROP_SHAREDFOLDER,	 IDS_CAPROP_SHAREDFOLDER, },
    { CR_PROP_PARENTCA,		 IDS_CAPROP_PARENTCA, },

    { CR_PROP_CATYPE,		 IDS_CAPROP_CATYPE, },
    { CR_PROP_CASIGCERTCOUNT,	 IDS_CAPROP_CASIGCERTCOUNT, },
    { CR_PROP_CASIGCERT,	 IDS_CAPROP_CASIGCERT, },
    { CR_PROP_CASIGCERTCHAIN,	 IDS_CAPROP_CASIGCERTCHAIN, },
    { CR_PROP_CAXCHGCERTCOUNT,	 IDS_CAPROP_CAXCHGCERTCOUNT, },
    { CR_PROP_CAXCHGCERT,	 IDS_CAPROP_CAXCHGCERT, },
    { CR_PROP_CAXCHGCERTCHAIN,	 IDS_CAPROP_CAXCHGCERTCHAIN, },
    { CR_PROP_BASECRL,		 IDS_CAPROP_BASECRL, },
    { CR_PROP_DELTACRL,		 IDS_CAPROP_DELTACRL, },
    { CR_PROP_CACERTSTATE,	 IDS_CAPROP_CACERTSTATE, },
    { CR_PROP_CRLSTATE,		 IDS_CAPROP_CRLSTATE, },
    { CR_PROP_CAPROPIDMAX,	 IDS_CAPROP_CAPROPIDMAX, },
    { CR_PROP_DNSNAME,	 	 IDS_CAPROP_DNSNAME, },
    { CR_PROP_KRACERTUSEDCOUNT,	 IDS_CAPROP_KRACERTUSEDCOUNT, },
    { CR_PROP_KRACERTCOUNT,	 IDS_CAPROP_KRACERTCOUNT, },
    { CR_PROP_KRACERT,		 IDS_CAPROP_KRACERT, },
    { CR_PROP_KRACERTSTATE,	 IDS_CAPROP_KRACERTSTATE, },
    { CR_PROP_ADVANCEDSERVER,	 IDS_CAPROP_ADVANCEDSERVER, },
    { CR_PROP_TEMPLATES,	 IDS_CAPROP_TEMPLATES, },
    { CR_PROP_BASECRLPUBLISHSTATUS,	 IDS_CAPROP_BASECRLPUBLISHSTATUS, },
    { CR_PROP_DELTACRLPUBLISHSTATUS,	 IDS_CAPROP_DELTACRLPUBLISHSTATUS, },
    { CR_PROP_CASIGCERTCRLCHAIN, IDS_CAPROP_CASIGCERTCRLCHAIN, },
    { CR_PROP_CAXCHGCERTCRLCHAIN,IDS_CAPROP_CAXCHGCERTCRLCHAIN, },
    { CR_PROP_CACERTSTATUSCODE,	 IDS_CAPROP_CACERTSTATUSCODE, },
    { 0, 0, },
};

#define CAPROP_MAX	(ARRAYSIZE(g_aCAPropTable) - 1)


HRESULT
LoadDisplayNames()
{
    HRESULT hr;
    COLUMNTRANSLATE *pct;
    CAPROPTRANSLATE *pcapt;
    WCHAR awc[512];

    for (pct = g_aColTable; NULL != pct->pwszColumnName; pct++)
    {
	WCHAR *pwsz;

	if (!LoadString(
		    g_hInstance,
		    pct->idMsgDisplayName,
		    awc,
		    ARRAYSIZE(awc)))
	{
	    hr = myHLastError();
	    CSASSERT(S_OK != hr);
	    _JumpError(hr, error, "LoadString");
	}
	pwsz = (WCHAR *) LocalAlloc(
				LMEM_FIXED,
				(wcslen(awc) + 1) * sizeof(WCHAR));
	if (NULL == pwsz)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc display name");
	}
	wcscpy(pwsz, awc);
	pct->pwszDisplayName = pwsz;
	DBGPRINT((
	    DBG_SS_CERTLIBI,
	    "%x: '%ws' --> '%ws'\n",
	    SAFE_SUBTRACT_POINTERS(pct, g_aColTable),
	    pct->pwszColumnName,
	    pct->pwszDisplayName));
    }
    for (pcapt = g_aCAPropTable; 0 != pcapt->lPropId; pcapt++)
    {
	WCHAR *pwsz;

	if (!LoadString(
		    g_hInstance,
		    pcapt->idMsgDisplayName,
		    awc,
		    ARRAYSIZE(awc)))
	{
	    hr = myHLastError();
	    CSASSERT(S_OK != hr);
	    _JumpError(hr, error, "LoadString");
	}
	pwsz = (WCHAR *) LocalAlloc(
				LMEM_FIXED,
				(wcslen(awc) + 1) * sizeof(WCHAR));
	if (NULL == pwsz)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc display name");
	}
	wcscpy(pwsz, awc);
	pcapt->pwszDisplayName = pwsz;
	DBGPRINT((
	    DBG_SS_CERTLIBI,
	    "%x: %x --> '%ws'\n",
	    SAFE_SUBTRACT_POINTERS(pcapt, g_aCAPropTable),
	    pcapt->lPropId,
	    pcapt->pwszDisplayName));
    }
    hr = S_OK;

error:
    if(S_OK != hr)
    {
        for (pct = g_aColTable; NULL != pct->pwszColumnName; pct++)
        {
            if(pct->pwszDisplayName)
            {
                LocalFree(const_cast<WCHAR *>(pct->pwszDisplayName));
                pct->pwszDisplayName = NULL;
            }
        }
    }
    return(hr);
}


HRESULT
myGetColumnDisplayName(
    IN  WCHAR const  *pwszColumnName,
    OUT WCHAR const **ppwszDisplayName)
{
    HRESULT hr;
    COLUMNTRANSLATE *pct;

    *ppwszDisplayName = NULL;
    if (NULL == g_aColTable[0].pwszDisplayName)
    {
	hr = LoadDisplayNames();
	_JumpIfError(hr, error, "LoadDisplayNames");
    }
    
    hr = E_INVALIDARG;
    for (pct = g_aColTable; NULL != pct->pwszColumnName; pct++)
    {
	if (0 == lstrcmpi(pct->pwszColumnName, pwszColumnName))
	{
	    *ppwszDisplayName = pct->pwszDisplayName;
	    hr = S_OK;
	    break;
	}
    }
    _JumpIfError(hr, error, "Bad Column Name");

    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myGetColumnDisplayName(%ws) --> '%ws'\n",
	pwszColumnName,
	*ppwszDisplayName));
error:
    return(hr);
}


HRESULT
myGetColumnName(
    IN  DWORD         Index,
    IN  BOOL          fDisplayName,
    OUT WCHAR const **ppwszName)
{
    HRESULT hr;
    COLUMNTRANSLATE *pct;

    *ppwszName = NULL;
    if (NULL == g_aColTable[0].pwszDisplayName)
    {
	hr = LoadDisplayNames();
	_JumpIfError(hr, error, "LoadDisplayNames");
    }
    if (CCOL_MAX <= Index)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Bad Index");
    }
    pct = &g_aColTable[Index];
    *ppwszName = fDisplayName? pct->pwszDisplayName : pct->pwszColumnName;
    hr = S_OK;

    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myGetColumnName(%x, fDisplay=%d) --> '%ws'\n",
	Index,
	fDisplayName,
	*ppwszName));

error:
    return(hr);
}


VOID
myFreeColumnDisplayNames2()
{
    COLUMNTRANSLATE *pct;
    CAPROPTRANSLATE *pcapt;

    if (NULL != g_aColTable[0].pwszDisplayName)
    {
	for (pct = g_aColTable; NULL != pct->pwszColumnName; pct++)
	{
	    LocalFree(const_cast<WCHAR *>(pct->pwszDisplayName));
	    pct->pwszDisplayName = NULL;
	}
	for (pcapt = g_aCAPropTable; 0 != pcapt->lPropId; pcapt++)
	{
	    LocalFree(const_cast<WCHAR *>(pcapt->pwszDisplayName));
	    pcapt->pwszDisplayName = NULL;
	}
    }
}


HRESULT
myCAPropGetDisplayName(
    IN  LONG          lPropId,
    OUT WCHAR const **ppwszDisplayName)
{
    HRESULT hr;
    CAPROPTRANSLATE *pcapt;

    *ppwszDisplayName = NULL;
    if (NULL == g_aColTable[0].pwszDisplayName)
    {
	hr = LoadDisplayNames();
	_JumpIfError(hr, error, "LoadDisplayNames");
    }
    
    hr = E_INVALIDARG;
    for (pcapt = g_aCAPropTable; 0 != pcapt->lPropId; pcapt++)
    {
	if (lPropId == pcapt->lPropId)
	{
	    *ppwszDisplayName = pcapt->pwszDisplayName;
	    hr = S_OK;
	    break;
	}
    }
    _JumpIfError(hr, error, "Bad PropId");

error:
    DBGPRINT((
	S_OK == hr? DBG_SS_CERTLIBI : DBG_SS_CERTLIB,
	"myCAPropGetDisplayName(%x) --> hr=%x, '%ws'\n",
	lPropId,
	hr,
	*ppwszDisplayName));
    return(hr);
}


HRESULT
myCAPropInfoUnmarshal(
    IN OUT CAPROP *pCAPropInfo,
    IN LONG cCAPropInfo,
    IN DWORD cbCAPropInfo)
{
    HRESULT hr;
    CAPROP *pcap;
    CAPROP *pcapEnd;
    BYTE *pbEnd;
    LONG i;

    if (NULL == pCAPropInfo)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    pbEnd = (BYTE *) Add2Ptr(pCAPropInfo, cbCAPropInfo);
    pcapEnd = &pCAPropInfo[cCAPropInfo];
    for (pcap = pCAPropInfo; pcap < pcapEnd; pcap++)
    {
	WCHAR const *pwszDisplayName;
	WCHAR const *pwszT;
	
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	if ((BYTE *) (pcap + 1) > pbEnd)
	{
	    _JumpError(hr, error, "bad marshalled data");
	}
	pwszDisplayName = NULL;
	if (NULL != pcap->pwszDisplayName)
	{
	    pwszDisplayName = (WCHAR *) Add2Ptr(
					    pCAPropInfo,
					    pcap->pwszDisplayName);
	    if ((BYTE *) pwszDisplayName < (BYTE *) (pcap + 1) ||
		(BYTE *) pwszDisplayName >= pbEnd)
	    {
		_JumpError(hr, error, "bad marshalled pointer");
	    }
	    pwszT = pwszDisplayName + wcslen(pwszDisplayName) + 1;
	    if ((BYTE *) pwszT > pbEnd)
	    {
		_JumpError(hr, error, "bad marshalled string");
	    }
	}

	hr = myCAPropGetDisplayName(pcap->lPropId, &pwszT);
	_PrintIfError(hr, "myCAPropGetDisplayName");
	if (S_OK == hr)
	{
	    pwszDisplayName = pwszT;
	}
	pcap->pwszDisplayName = const_cast<WCHAR *>(pwszDisplayName);

	DBGPRINT((
	    DBG_SS_CERTLIBI,
	    "RequestGetCAPropertyInfo: ielt=%d idx=%x t=%x \"%ws\"\n",
	    SAFE_SUBTRACT_POINTERS(pcap, pCAPropInfo),
	    pcap->lPropId,
	    pcap->lPropFlags,
	    pcap->pwszDisplayName));
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myCAPropInfoLookup(
    IN CAPROP const *pCAPropInfo,
    IN LONG cCAPropInfo,
    IN LONG lPropId,
    OUT CAPROP const **ppcap)
{
    HRESULT hr;
    CAPROP const *pcap;
    CAPROP const *pcapEnd;

    if (NULL == ppcap)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppcap = NULL;

    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    pcapEnd = &pCAPropInfo[cCAPropInfo];
    for (pcap = pCAPropInfo; pcap < pcapEnd; pcap++)
    {
	if (lPropId == pcap->lPropId)
	{
	    *ppcap = pcap;
	    hr = S_OK;
	    break;
	}
    }
    _JumpIfError(hr, error, "Bad lPropId");

error:
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certcli\config.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        config.cpp
//
// Contents:    Cert Server client implementation
//
// History:     24-Aug-96       vich created
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include "csdisp.h"
#include "configp.h"
#include "config.h"

#include <limits.h>


//+--------------------------------------------------------------------------
// CCertConfig::~CCertConfig -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertConfig::~CCertConfig()
{
}


//+--------------------------------------------------------------------------
// CCertConfig::Reset -- load config data, reset to indexed entry, return count
//
// Load the configuration data if not already loaded.  To reload the data after
// the data have changed, CCertConfig must be released and reinstantiated.
//
// Resets the current config entry to the Certification Authority configuration
// listed in the configuration file, indexed by the Index parameter.  0 indexes
// the first configuration.
//
// Upon successful completion, *pCount will be set to the number of Certificate
// Authority configurations listed in the configuration file.
//
// Returns S_FALSE if no entries are available at or after the passed Index.
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertConfig::Reset(
    /* [in] */ LONG Index,
    /* [retval][out] */ LONG __RPC_FAR *pCount)
{
    HRESULT hr;
    
    hr = CCertConfigPrivate::Reset(Index, pCount);
    return(_SetErrorInfo(hr, L"CCertConfig::Reset"));
}


//+--------------------------------------------------------------------------
// CCertConfig::Next -- skip to next config entry
//
// Changes the current config entry to the next Certification Authority
// configuration listed in the configuration file.
//
// Upon successful completion, *pIndex will be set to the index of Certificate
// Authority configurations listed in the configuration file.
//
// Returns S_FALSE if no more entries are available.  *pIndex is set to -1.
// Returns S_OK on success.  *pIndex is set to index the current configuration.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertConfig::Next(
    /* [retval][out] */ LONG __RPC_FAR *pIndex)
{
    HRESULT hr;
    
    hr = CCertConfigPrivate::Next(pIndex);
    return(_SetErrorInfo(hr, L"CCertConfig::Next"));
}


//+--------------------------------------------------------------------------
// CCertConfig::GetField -- return a field from the current config entry.
//
// pstrOut points to a BSTR string filled in by this routine.  If *pstrOut is
// non-NULL and this method is successful, the old string is freed.  If any
// value other than S_OK is returned, the string pointer will not be modified.
//
// Upon successful completion, *pstrOut will point to a string that contains
// the requested field from the current config entry.
//
// When the caller no longer needs the string, it must be freed by calling
// SysFreeString().
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertConfig::GetField(
    /* [in] */ BSTR const strFieldName,
    /* [retval][out] */ BSTR __RPC_FAR *pstrOut)
{
    HRESULT hr;
    
    hr = CCertConfigPrivate::GetField(strFieldName, pstrOut);
    return(_SetErrorInfo(hr, L"CCertConfig::GetField"));
}


//+--------------------------------------------------------------------------
// CCertConfig::GetConfig -- select a certificate issuer, return config data.
//
// pstrOut points to a BSTR string filled in by this routine.  If *pstrOut is
// non-NULL and this method is successful, the old string is freed.  If any
// value other than S_OK is returned, the string pointer will not be modified.
//
// Flags must be set to 0.
//
// Upon successful completion, *pstrOut will point to a string that contains
// the server name and Certification Authority name.
//
// When the caller no longer needs the string, it must be freed by calling
// SysFreeString().
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertConfig::GetConfig(
    /* [in] */ LONG Flags,
    /* [retval][out] */ BSTR __RPC_FAR *pstrOut)
{
    HRESULT hr;
    
    hr = CCertConfigPrivate::GetConfig(Flags, pstrOut);
    return(_SetErrorInfo(hr, L"CCertConfig::GetConfig"));
}


//+--------------------------------------------------------------------------
// CCertConfig::SetSharedFolder -- set the shared folder
//
// strSharedFolder is the new shared folder directory path.
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertConfig::SetSharedFolder( 
    /* [in] */ const BSTR strSharedFolder)
{
    HRESULT hr;
    
    hr = CCertConfigPrivate::SetSharedFolder(strSharedFolder);
    return(_SetErrorInfo(hr, L"CCertConfig::SetSharedFolder"));
}


HRESULT
CCertConfig::_SetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription)
{
    CSASSERT(FAILED(hrError) || S_OK == hrError || S_FALSE == hrError);
    if (FAILED(hrError))
    {
	HRESULT hr;

	hr = DispatchSetErrorInfo(
			    hrError,
			    pwszDescription,
			    wszCLASS_CERTCONFIG,
			    &IID_ICertConfig);
	CSASSERT(hr == hrError);
    }
    return(hrError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certcli\configp.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        config.cpp
//
// Contents:    Cert Server client implementation
//
// History:     24-Aug-96       vich created
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include "csdisp.h"
#include "certca.h"
#include "configp.h"
#include <assert.h>

#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmwksta.h>

#include <limits.h>

#define __dwFILE__	__dwFILE_CERTCLI_CONFIGP_CPP__


WCHAR g_wszConfigFile[] = L"\\certsrv.txt";

WCHAR const g_wszRegDirectory[] = wszREGDIRECTORY;
#define cwcCONFIGLINEMAX	(12 * 1024)

extern "C"
{
HWND GetDeskTopWindow(VOID);
}

HRESULT
certRequestGetConfigInfo(
    IN WCHAR *pwszSharedFolder,
    IN OUT LONG *pIndex,
    IN OUT LONG *pCount,
    OUT CERT_AUTHORITY_INFO **ppCertAuthorityInfo);

VOID
_CleanupCAInfo(
    IN OUT CERT_AUTHORITY_INFO *pCA)
{
    if (NULL != pCA->pwszSanitizedName)
    {
	LocalFree(pCA->pwszSanitizedName);
    }
    if (NULL != pCA->pwszSanitizedShortName)
    {
	LocalFree(pCA->pwszSanitizedShortName);
    }
    if (NULL != pCA->pwszSanitizedOrgUnit)
    {
	LocalFree(pCA->pwszSanitizedOrgUnit);
    }
    if (NULL != pCA->pwszSanitizedOrganization)
    {
	LocalFree(pCA->pwszSanitizedOrganization);
    }
    if (NULL != pCA->pwszSanitizedLocality)
    {
	LocalFree(pCA->pwszSanitizedLocality);
    }
    if (NULL != pCA->pwszSanitizedState)
    {
	LocalFree(pCA->pwszSanitizedState);
    }
    if (NULL != pCA->pwszSanitizedCountry)
    {
	LocalFree(pCA->pwszSanitizedCountry);
    }
    if (NULL != pCA->pwszSanitizedConfig)
    {
	LocalFree(pCA->pwszSanitizedConfig);
    }
    if (NULL != pCA->pwszSanitizedExchangeCertificate)
    {
	LocalFree(pCA->pwszSanitizedExchangeCertificate);
    }
    if (NULL != pCA->pwszSanitizedSignatureCertificate)
    {
	LocalFree(pCA->pwszSanitizedSignatureCertificate);
    }
    if (NULL != pCA->pwszSanitizedDescription)
    {
	LocalFree(pCA->pwszSanitizedDescription);
    }
    ZeroMemory(pCA, sizeof(*pCA));
}


//+--------------------------------------------------------------------------
// CCertConfigPrivate::~CCertConfigPrivate -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertConfigPrivate::~CCertConfigPrivate()
{
    LONG i;

    if (NULL != m_pCertAuthorityInfo)
    {
        if (0 != m_Count)
        {
            for (i = 0; i < m_Count; ++i)
            {
		_CleanupCAInfo(&m_pCertAuthorityInfo[i]);
            }
        }
        LocalFree(m_pCertAuthorityInfo);
    }
    if (NULL != m_pwszSharedFolder)
    {
	LocalFree(m_pwszSharedFolder);
    }
}


HRESULT
fillEmptyField(
    WCHAR **ppwszField)
{
    HRESULT hr;

    *ppwszField = (WCHAR *) LocalAlloc(LMEM_FIXED, sizeof(WCHAR));
    if (NULL == *ppwszField)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    *ppwszField[0] = L'\0';

    hr = S_OK;
error:
    return(hr);
}


VOID
dsFreeCAConfig(
    LONG                 cCA,
    CERT_AUTHORITY_INFO *pCA)
{
    LONG i;

    if (NULL != pCA && 0 < cCA)
    {
        for (i = 0; i < cCA; ++i)
        {
            if (NULL != pCA[i].pwszSanitizedName)
            {
                LocalFree(pCA[i].pwszSanitizedName);
            }
            if (NULL != pCA[i].pwszSanitizedShortName)
            {
                LocalFree(pCA[i].pwszSanitizedShortName);
            }
            if (NULL != pCA[i].pwszSanitizedConfig)
            {
                LocalFree(pCA[i].pwszSanitizedConfig);
            }
            if (NULL != pCA[i].pwszSanitizedOrganization)
            {
                LocalFree(pCA[i].pwszSanitizedOrganization);
            }
            if (NULL != pCA[i].pwszSanitizedOrgUnit)
            {
                LocalFree(pCA[i].pwszSanitizedOrgUnit);
            }
            if (NULL != pCA[i].pwszSanitizedLocality)
            {
                LocalFree(pCA[i].pwszSanitizedLocality);
            }
            if (NULL != pCA[i].pwszSanitizedState)
            {
                LocalFree(pCA[i].pwszSanitizedState);
            }
            if (NULL != pCA[i].pwszSanitizedCountry)
            {
                LocalFree(pCA[i].pwszSanitizedCountry);
            }
        }
        LocalFree(pCA);
    }
}


HRESULT
ConfigGetCertNameDNInfo(
    IN CERT_NAME_INFO const *pCertNameInfo,
    IN CHAR const *pszObjId,
    IN OUT WCHAR **ppwszDNInfo)
{
    HRESULT hr;
    WCHAR const *pwszProperty = NULL;

    if (NULL != *ppwszDNInfo && L'\0' != **ppwszDNInfo)
    {
	hr = S_OK;
	goto error;
    }
    hr = myGetCertNameProperty(pCertNameInfo, pszObjId, &pwszProperty);
    if (CERTSRV_E_PROPERTY_EMPTY == hr)
    {
	hr = S_OK;
	goto error;
    }
    _JumpIfError(hr, error, "myGetCertNameProperty");

    if (NULL != pwszProperty)
    {
	WCHAR *pwsz;
	
	hr = myDupString(pwszProperty, &pwsz);
	_JumpIfError(hr, error, "myDupString");

	if (NULL != *ppwszDNInfo)
	{
	    LocalFree(*ppwszDNInfo);
	}
	*ppwszDNInfo = pwsz;
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
ConfigLoadDNInfo(
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN OUT CERT_AUTHORITY_INFO *pCA)
{
    HRESULT hr;
    CERT_NAME_INFO *pCertNameInfo = NULL;
    DWORD cbCertNameInfo;

    // decode to name info
    if (!myDecodeName(
	    X509_ASN_ENCODING,
	    X509_UNICODE_NAME,
	    pbEncoded,
	    cbEncoded,
	    CERTLIB_USE_LOCALALLOC,
	    &pCertNameInfo,
	    &cbCertNameInfo))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeName");
    }

    hr = ConfigGetCertNameDNInfo(
	     pCertNameInfo,
	     szOID_ORGANIZATION_NAME,
	     &pCA->pwszSanitizedOrganization);
    _JumpIfError(hr, error, "ConfigGetCertNameDNInfo");

    hr = ConfigGetCertNameDNInfo(
	     pCertNameInfo,
	     szOID_ORGANIZATIONAL_UNIT_NAME,
	     &pCA->pwszSanitizedOrgUnit);
    _JumpIfError(hr, error, "ConfigGetCertNameDNInfo");

    hr = ConfigGetCertNameDNInfo(
	     pCertNameInfo,
	     szOID_LOCALITY_NAME,
	     &pCA->pwszSanitizedLocality);
    _JumpIfError(hr, error, "ConfigGetCertNameDNInfo");

    hr = ConfigGetCertNameDNInfo(
	     pCertNameInfo,
	     szOID_STATE_OR_PROVINCE_NAME,
	     &pCA->pwszSanitizedState);
    _JumpIfError(hr, error, "ConfigGetCertNameDNInfo");

    hr = ConfigGetCertNameDNInfo(
	     pCertNameInfo,
	     szOID_COUNTRY_NAME,
	     &pCA->pwszSanitizedCountry);
    _JumpIfError(hr, error, "ConfigGetCertNameDNInfo");

error:
    if (NULL != pCertNameInfo)
    {
        LocalFree(pCertNameInfo);
    }
    return(hr);
}


HRESULT
dsGetCAConfig(
    OUT CERT_AUTHORITY_INFO **ppCAConfig,
    OUT LONG                 *pcCAConfig)
{
    HRESULT  hr;
    HCAINFO  hCACurrent = NULL;
    HCAINFO  hCANext = NULL;
    WCHAR    **ppwszCommonName = NULL;
    WCHAR    **ppwszSanitizedShortName = NULL;
    WCHAR    **ppwszDescription = NULL;
    WCHAR    **ppwszMachine = NULL;
    WCHAR    **ppwszDN = NULL;
    LONG     cCA;
    LONG     iDst;
    LONG     iSrc;
    CERT_AUTHORITY_INFO *pCA = NULL;
    BYTE           *pbEncoded = NULL;
    DWORD           cbEncoded;

    *ppCAConfig = NULL;
    *pcCAConfig = 0;

    cCA = 0;

    hr = CAEnumFirstCA(
		NULL,
		CA_FIND_INCLUDE_UNTRUSTED | CA_FIND_INCLUDE_NON_TEMPLATE_CA,
		&hCACurrent);
    if (HRESULT_FROM_WIN32(ERROR_NETWORK_UNREACHABLE) != hr)
    {
	_PrintIfErrorStr4(
		    hr,
		    "CAEnumFirstCA",
		    L"Ignored!",
		    HRESULT_FROM_WIN32(ERROR_SERVER_DISABLED),
		    HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN),
		    HRESULT_FROM_WIN32(ERROR_WRONG_PASSWORD));
    }

    cCA = CACountCAs(hCACurrent);  // 0 on error
    if (0 < cCA)
    {
        pCA = (CERT_AUTHORITY_INFO *) LocalAlloc(
                               LMEM_FIXED | LMEM_ZEROINIT,
			       cCA * sizeof(CERT_AUTHORITY_INFO));
        if (NULL == pCA)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }

        for (iDst = 0, iSrc = 0; iSrc < cCA; iSrc++)
        {
            CSASSERT(NULL == ppwszCommonName);
            CSASSERT(NULL == ppwszSanitizedShortName);
            CSASSERT(NULL == ppwszDescription);
            CSASSERT(NULL == ppwszMachine);
            CSASSERT(NULL == ppwszDN);
            CSASSERT(NULL == pCA[iDst].pwszSanitizedName);
            CSASSERT(NULL == pCA[iDst].pwszSanitizedShortName);
            CSASSERT(NULL == pCA[iDst].pwszSanitizedConfig);

            hr = CAGetCAProperty(
			    hCACurrent,
			    CA_PROP_DISPLAY_NAME,
			    &ppwszCommonName);
	    _JumpIfError(hr, error, "CAGetCAProperty(CA_PROP_DISPLAY_NAME)");

            hr = CAGetCAProperty(hCACurrent, CA_PROP_NAME, &ppwszSanitizedShortName);
	    _JumpIfError(hr, error, "CAGetCAProperty(CA_PROP_NAME)");

            hr = CAGetCAProperty(hCACurrent, CA_PROP_DESCRIPTION, &ppwszDescription);
	    _JumpIfError(hr, error, "CAGetCAProperty(CA_PROP_DESCRIPTION)");

            hr = CAGetCAProperty(hCACurrent, CA_PROP_DNSNAME, &ppwszMachine);
	    _JumpIfError(hr, error, "CAGetCAProperty(CA_PROP_DNSNAME)");

            hr = CAGetCAProperty(hCACurrent, CA_PROP_CERT_DN, &ppwszDN);
	    _JumpIfError(hr, error, "CAGetCAProperty(CA_PROP_CERT_DN)");

	    if (NULL == ppwszCommonName ||
		NULL == ppwszSanitizedShortName ||
		NULL == ppwszMachine ||
		NULL == ppwszDN)
            {
                _PrintError(E_INVALIDARG, "missing CA property");
                goto skipca; // skip and don't take the CA
            }

	    hr = mySanitizeName(*ppwszCommonName, &pCA[iDst].pwszSanitizedName);
	    _JumpIfError(hr, error, "mySanitizeName");

	    // already sanitized:

	    hr = myDupString(*ppwszSanitizedShortName, &pCA[iDst].pwszSanitizedShortName);
	    _JumpIfError(hr, error, "myDupString");

	    if (NULL != ppwszDescription)
	    {
		hr = myDupString(*ppwszDescription, &pCA[iDst].pwszSanitizedDescription);
		_JumpIfError(hr, error, "myDupString");
	    }

            pCA[iDst].pwszSanitizedConfig = (WCHAR *) LocalAlloc(
		    LMEM_FIXED,
		    (wcslen(*ppwszMachine) + wcslen(pCA[iDst].pwszSanitizedName) + 2) *
			sizeof(WCHAR));
            if (NULL == pCA[iDst].pwszSanitizedConfig)
            {
                hr = E_OUTOFMEMORY;
                _JumpError(hr, error, "LocalAlloc(pwszSanitizedConfig)");
            }
            wcscpy(pCA[iDst].pwszSanitizedConfig, *ppwszMachine);
            wcscat(pCA[iDst].pwszSanitizedConfig, L"\\");
            wcscat(pCA[iDst].pwszSanitizedConfig, pCA[iDst].pwszSanitizedName);

            pbEncoded = NULL;
            while (TRUE)
            {
                // convert dn string to name blob
                if (!CertStrToName(
                         X509_ASN_ENCODING,
                         *ppwszDN,
                         CERT_X500_NAME_STR,
                         NULL,
                         pbEncoded,
                         &cbEncoded,
                         NULL))
                {
                    hr = myHLastError();
                    _JumpIfError(hr, error, "CertStrToName");
                }
                if (NULL != pbEncoded)
                {
                    // get name
                    break;
                }
                pbEncoded = (BYTE*)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                       cbEncoded);
		if (NULL == pbEncoded)
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "LocalAlloc");
		}
            }

	    hr = ConfigLoadDNInfo(pbEncoded, cbEncoded, &pCA[iDst]);
            _JumpIfError(hr, error, "ConfigLoadDNInfo");

            // fill empty for the rest
            CSASSERT(NULL == pCA[iDst].pwszSanitizedExchangeCertificate);
            CSASSERT(NULL == pCA[iDst].pwszSanitizedSignatureCertificate);
            pCA[iDst].Flags = CAIF_DSENTRY;
            ++iDst;

            // free dn blobs
            if (NULL != pbEncoded)
            {
                LocalFree(pbEncoded);
                pbEncoded = NULL;
            }
skipca:
            // free ds out properties

	    if (NULL != ppwszCommonName)
	    {
		CAFreeCAProperty(hCACurrent, ppwszCommonName);
		ppwszCommonName = NULL;
	    }
	    if (NULL != ppwszSanitizedShortName)
	    {
		CAFreeCAProperty(hCACurrent, ppwszSanitizedShortName);
		ppwszSanitizedShortName = NULL;
	    }
	    if (NULL != ppwszDescription)
	    {
		CAFreeCAProperty(hCACurrent, ppwszDescription);
		ppwszDescription = NULL;
	    }
	    if (NULL != ppwszMachine)
	    {
		CAFreeCAProperty(hCACurrent, ppwszMachine);
		ppwszMachine = NULL;
	    }
	    if (NULL != ppwszDN)
	    {
		CAFreeCAProperty(hCACurrent, ppwszDN);
		ppwszDN = NULL;
	    }

            hr = CAEnumNextCA(hCACurrent, &hCANext);
            CACloseCA(hCACurrent);
            hCACurrent = hCANext;
	    if (S_OK != hr || NULL == hCACurrent)
	    {
		break;
	    }
        }
        *pcCAConfig = iDst;
        *ppCAConfig = pCA;
        pCA = NULL;
    }
    hr = S_OK;

error:
    if (NULL != hCACurrent)
    {
        CACloseCA(hCACurrent);
    }
    if (NULL != pbEncoded)
    {
        LocalFree(pbEncoded);
    }
    if (NULL != ppwszCommonName)
    {
        CAFreeCAProperty(hCACurrent, ppwszCommonName);
    }
    if (NULL != ppwszSanitizedShortName)
    {
        CAFreeCAProperty(hCACurrent, ppwszSanitizedShortName);
    }
    if (NULL != ppwszMachine)
    {
        CAFreeCAProperty(hCACurrent, ppwszMachine);
    }
    if (NULL != ppwszDN)
    {
        CAFreeCAProperty(hCACurrent, ppwszDN);
    }
    if (NULL != pCA)
    {
        dsFreeCAConfig(cCA, pCA);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


BOOL
FindSharedCAInDSList(
    IN CERT_AUTHORITY_INFO       *pDSCA,
    IN LONG                       countDSCA,
    IN CERT_AUTHORITY_INFO const *pCAFromShared,
    OUT CERT_AUTHORITY_INFO     **ppDSCA)
{
    BOOL found = FALSE;
    LONG i;

    *ppDSCA = NULL;
    for (i = 0; i < countDSCA; ++i)
    {
        if (0 == lstrcmpi(pDSCA[i].pwszSanitizedConfig, pCAFromShared->pwszSanitizedConfig) &&
            0 == lstrcmpi(pDSCA[i].pwszSanitizedName, pCAFromShared->pwszSanitizedName))
        {
            *ppDSCA = &pDSCA[i];
	    found = TRUE;
            break;
        }
    }
    return(found);
}


HRESULT
updateField(
   IN WCHAR const *pwszSource,
   OUT WCHAR **ppwszDest)
{
    HRESULT hr;

    if (NULL != pwszSource &&
	(NULL == *ppwszDest || L'\0' == **ppwszDest))
    {
	if (NULL != *ppwszDest)
	{
	    LocalFree(*ppwszDest);
	}
	hr = myDupString(pwszSource, ppwszDest);
	_JumpIfError(hr, error, "myDupString");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
mergeConfigFields(
    IN CERT_AUTHORITY_INFO const *pCAIn,
    IN OUT CERT_AUTHORITY_INFO *pCA)
{
    HRESULT hr;

    if (NULL == pCAIn || NULL == pCA)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "Internal Error");
    }

    hr = updateField(pCAIn->pwszSanitizedName, &pCA->pwszSanitizedName);
    _JumpIfError(hr, error, "updateField(pwszSanitizedName)");

    hr = updateField(pCAIn->pwszSanitizedOrgUnit, &pCA->pwszSanitizedOrgUnit);
    _JumpIfError(hr, error, "updateField(pwszSanitizedOrgUnit)");

    hr = updateField(pCAIn->pwszSanitizedOrganization, &pCA->pwszSanitizedOrganization);
    _JumpIfError(hr, error, "updateField(pwszSanitizedOrganization)");

    hr = updateField(pCAIn->pwszSanitizedLocality, &pCA->pwszSanitizedLocality);
    _JumpIfError(hr, error, "updateField(pwszSanitizedLocality)");

    hr = updateField(pCAIn->pwszSanitizedState, &pCA->pwszSanitizedState);
    _JumpIfError(hr, error, "updateField(pwszSanitizedState)");

    hr = updateField(pCAIn->pwszSanitizedCountry, &pCA->pwszSanitizedCountry);
    _JumpIfError(hr, error, "updateField(pwszSanitizedCountry)");

    hr = updateField(pCAIn->pwszSanitizedConfig, &pCA->pwszSanitizedConfig);
    _JumpIfError(hr, error, "updateField(pwszSanitizedConfig)");

    hr = updateField(pCAIn->pwszSanitizedExchangeCertificate, &pCA->pwszSanitizedExchangeCertificate);
    _JumpIfError(hr, error, "updateField(pwszSanitizedExchangeCertificate)");

    hr = updateField(pCAIn->pwszSanitizedSignatureCertificate, &pCA->pwszSanitizedSignatureCertificate);
    _JumpIfError(hr, error, "updateField(pwszSanitizedSignatureCertificate)");

    hr = updateField(pCAIn->pwszSanitizedDescription, &pCA->pwszSanitizedDescription);
    _JumpIfError(hr, error, "updateField(pwszSanitizedDescription)");

    hr = mySanitizedNameToDSName(pCAIn->pwszSanitizedName, &pCA->pwszSanitizedShortName);
    _JumpIfError(hr, error, "mySanitizedNameToDSName");

    pCA->Flags |= pCAIn->Flags;

error:
    return(hr);
}


HRESULT
CCertConfigPrivate::_ResizeCAInfo(
    IN LONG Count)
{
   HRESULT hr = E_OUTOFMEMORY;
   
   if (NULL == m_pCertAuthorityInfo)
   {
	m_pCertAuthorityInfo = (CERT_AUTHORITY_INFO *) LocalAlloc(
					   LMEM_FIXED | LMEM_ZEROINIT,
					   Count * sizeof(CERT_AUTHORITY_INFO));
	if (NULL == m_pCertAuthorityInfo)
	{
	    _JumpError(hr, error, "LocalAlloc");
	}
   }
   else
   {
	CERT_AUTHORITY_INFO *pCAI;

	pCAI = (CERT_AUTHORITY_INFO *) LocalReAlloc(
					   m_pCertAuthorityInfo,
					   Count * sizeof(CERT_AUTHORITY_INFO),
					   LMEM_MOVEABLE);
	if (NULL == pCAI)
	{
	    _JumpError(hr, error, "LocalReAlloc");
	}
	m_pCertAuthorityInfo = pCAI;

	// LocalReAlloc won't zero memory when old size was already > m_Count

	if (Count > m_Count)
	{
	    ZeroMemory(
		&m_pCertAuthorityInfo[m_Count],
		(Count - m_Count) * sizeof(m_pCertAuthorityInfo[0]));
	}
   }
   hr = S_OK;

error:
    return(hr);
}


HRESULT
CCertConfigPrivate::_AddRegistryConfigEntry(
    IN WCHAR const *pwszDnsName,
    IN WCHAR const *pwszOldName,
    IN WCHAR const *pwszSanitizedCAName,
    IN BOOL fParentCA,
    OPTIONAL IN CERT_CONTEXT const *pccCAChild,
    OPTIONAL OUT CERT_CONTEXT const **ppccCAOut) // non-NULL means local CA
{
    HRESULT hr;
    HCERTSTORE hMyStore = NULL;
    LONG i;
    BOOL fFoundCA = FALSE;
    WCHAR *pwszDescription = NULL;
    WCHAR *pwszSanitizedShortName = NULL;
    CERT_CONTEXT const *pccCA = NULL;
    CERT_AUTHORITY_INFO *pCA = NULL;
    WCHAR *pwsz;
    WCHAR *pwszRegPath = NULL;
    HKEY hKey = NULL;

    if (NULL != ppccCAOut)
    {
	CSASSERT(NULL == pccCAChild);
	*ppccCAOut = NULL;
    }

    for (i = 0; i < m_Count; ++i)
    {
	BOOL fMachineNameMatch;
	
	hr = myIsConfigLocal2(
			m_pCertAuthorityInfo[i].pwszSanitizedConfig,
			pwszDnsName,
			pwszOldName,
			&fMachineNameMatch);
	_JumpIfError(hr, error, "myIsConfigLocal2");

	if (fMachineNameMatch)
	{
	    if (!fParentCA)	// Local CA
	    {
		m_pCertAuthorityInfo[i].Flags |= CAIF_LOCAL;
	    }

	    if (0 == lstrcmpi(
			pwszSanitizedCAName,
			m_pCertAuthorityInfo[i].pwszSanitizedName))
	    {
		fFoundCA = TRUE;

		pCA = &m_pCertAuthorityInfo[i];
		pCA->Flags |= CAIF_REGISTRY;
		if (fParentCA)
		{
		    pCA->Flags |= CAIF_REGISTRYPARENT;
		}
		break;
	    }
	}
    }
    if (!fFoundCA)
    {
	hr = _ResizeCAInfo(m_Count + 1);
	_JumpIfError(hr, error, "_ResizeCAInfo");

	pCA = &m_pCertAuthorityInfo[m_Count];

	hr = myFormConfigString(
			pwszDnsName,
			pwszSanitizedCAName,
			&pCA->pwszSanitizedConfig);
	_JumpIfError(hr, error, "myFormConfigString");

	hr = myDupString(pwszSanitizedCAName, &pCA->pwszSanitizedName);
	_JumpIfError(hr, error, "myDupString");

	hr = mySanitizedNameToDSName(
			pwszSanitizedCAName,
			&pCA->pwszSanitizedShortName);
	_JumpIfError(hr, error, "mySanitizedNameToDSName");

	pCA->Flags = CAIF_REGISTRY;
	if (fParentCA)
	{
	    pCA->Flags |= CAIF_REGISTRYPARENT;
	}
	else
	{
	    pCA->Flags |= CAIF_LOCAL;
	}

    }

    CSASSERT(NULL != pCA);	// either found or added

    if (NULL == pCA->pwszSanitizedDescription ||
	L'\0' == *pCA->pwszSanitizedDescription)
    {
	if (!fParentCA)	// Local CA
	{
	    hr = myGetCertRegStrValue(
			pCA->pwszSanitizedName,
			NULL,
			NULL,
			wszREGCADESCRIPTION,
			&pwszDescription);
	    _PrintIfErrorStr2(
			hr,
			"myGetCertRegStrValue",
			wszREGCADESCRIPTION,
			HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));
	}
	else
	{
	    hr = myRegOpenRelativeKey(
			    pwszDnsName,
			    L"ca",
			    0,
			    &pwszRegPath,
			    NULL,
			    &hKey);
	    _PrintIfErrorStr(hr, "myGetCertRegStrValue", wszREGCADESCRIPTION);
	    if (S_OK == hr)
	    {
		DWORD cb;
		DWORD cwc;
		DWORD dwType;

		hr = RegQueryValueEx(
				hKey,
				wszREGCADESCRIPTION,
				NULL,
				&dwType,
				NULL,
				&cb);
		if (S_OK == hr && REG_SZ == dwType && sizeof(WCHAR) < cb)
		{
		    cwc = cb / sizeof(WCHAR);

		    pwszDescription = (WCHAR *) LocalAlloc(
					LMEM_FIXED,
					(cwc + 1) * sizeof(WCHAR));
		    if (NULL == pwszDescription)
		    {
			hr = E_OUTOFMEMORY;
			_JumpError(hr, error, "LocalAlloc");
		    }
		    hr = RegQueryValueEx(
				    hKey,
				    wszREGCADESCRIPTION,
				    NULL,
				    &dwType,
				    (BYTE *) pwszDescription,
				    &cb);
		    _JumpIfError(hr, error, "RegQueryValueEx");
		    pwszDescription[cwc] = L'\0';
		}
	    }
	}
	if (NULL != pwszDescription)
	{
	    hr = mySanitizeName(pwszDescription, &pwsz);
	    _JumpIfError(hr, error, "mySanitizeName");

	    if (NULL != pCA->pwszSanitizedDescription)
	    {
		LocalFree(pCA->pwszSanitizedDescription);
	    }
	    pCA->pwszSanitizedDescription = pwsz;
	}
    }
    if (fParentCA)
    {
	pccCA = pccCAChild;
    }
    else
    {
	DWORD ccert;

	CSASSERT(NULL == pccCAChild);

	hr = myGetCARegHashCount(
			    pCA->pwszSanitizedName,
			    CSRH_CASIGCERT,
			    &ccert);
	_PrintIfError(hr, "myGetCARegHashCount");
	if (S_OK == hr && 0 != ccert)
	{
	    DWORD NameId;
		
	    // open MY store

	    hMyStore = CertOpenStore(
			   CERT_STORE_PROV_SYSTEM_W,
			   X509_ASN_ENCODING,
			   NULL,			// hProv
			   CERT_SYSTEM_STORE_LOCAL_MACHINE |
			   CERT_STORE_READONLY_FLAG,
			   wszMY_CERTSTORE);
	    if (NULL == hMyStore)
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CertOpenStore");
	    }

	    hr = myFindCACertByHashIndex(
				hMyStore,
				pCA->pwszSanitizedName,
				CSRH_CASIGCERT,
				ccert - 1,
				&NameId,
				&pccCA);
	}
    }
    if (NULL != pccCA)
    {
	CERT_NAME_BLOB *pName = !fParentCA? 
			&pccCA->pCertInfo->Subject :
			&pccCA->pCertInfo->Issuer;

	hr = ConfigLoadDNInfo(pName->pbData, pName->cbData, pCA);
	_PrintIfError(hr, "ConfigLoadDNInfo");
    }
    if (NULL == pCA->pwszSanitizedSignatureCertificate ||
	L'\0' == *pCA->pwszSanitizedSignatureCertificate)
    {
	DWORD cwc;

	// pwszDnsName + "_" + pwszSanitizedCAName + ".crt"

	cwc = wcslen(pwszDnsName) + 1 + wcslen(pwszSanitizedCAName) + 4;

	pwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
	if (NULL == pwsz)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	wcscpy(pwsz, pwszDnsName);
	wcscat(pwsz, L"_");
	wcscat(pwsz, pwszSanitizedCAName);
	wcscat(pwsz, L".crt");
	CSASSERT(wcslen(pwsz) == cwc);

	if (NULL != pCA->pwszSanitizedSignatureCertificate)
	{
	    LocalFree(pCA->pwszSanitizedSignatureCertificate);
	}
	pCA->pwszSanitizedSignatureCertificate = pwsz;
    }
    if (!fFoundCA)
    {
	m_Count++;
    }
    if (NULL != pccCA && NULL != ppccCAOut)
    {
	*ppccCAOut = CertDuplicateCertificateContext(pccCA);
    }
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"%ws %ws CA entry: %ws\n",
	fFoundCA? L"Merged" : L"Added",
	fParentCA? L"Parent" : L"Local",
	pCA->pwszSanitizedConfig));
    pCA = NULL;
    hr = S_OK;

error:
    if (NULL != hKey)
    {
	RegCloseKey(hKey);
    }
    if (NULL != pwszRegPath)
    {
	LocalFree(pwszRegPath);
    }
    if (!fFoundCA && NULL != pCA)
    {
	_CleanupCAInfo(pCA);
    }
    if (NULL != pwszDescription)
    {
        LocalFree(pwszDescription);
    }
    if (NULL != pwszSanitizedShortName)
    {
        LocalFree(pwszSanitizedShortName);
    }
    if (NULL != pccCA && pccCAChild != pccCA)
    {
        CertFreeCertificateContext(pccCA);
    }
    if (NULL != hMyStore)
    {
        CertCloseStore(hMyStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertConfigPrivate::_LoadTable -- load config data into class instance
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertConfigPrivate::_LoadTable(VOID)
{
    HRESULT hr;
    LONG Index;
    LONG CountShared = 0;
    LONG i;
    LONG actualSharedCount;
    CERT_AUTHORITY_INFO *pCAFromShared = NULL;
    BOOL fDSCA = TRUE;
    WCHAR *pwszSanitizedCAName = NULL;
    WCHAR *pwszDnsName = NULL;
    WCHAR *pwszOldName = NULL;
    CERT_CONTEXT const *pccCA = NULL;
    WCHAR *pwszParentMachine = NULL;
    WCHAR *pwszParentMachineOld = NULL;
    WCHAR *pwszParentCAName = NULL;
    WCHAR *pwszParentSanitizedCAName = NULL;

    m_Index = -1;
    m_Count = 0;

    if (m_fUseDS)
    {
	hr = dsGetCAConfig(&m_pCertAuthorityInfo, &m_Count);
	_JumpIfError(hr, error, "dsGetCAConfig");
    }

    DBGPRINT((
	DBG_SS_CERTLIBI,
	"%x DS entries @%x\n",
	m_Count,
	m_pCertAuthorityInfo));
    if (NULL == m_pCertAuthorityInfo && 0 == m_Count)
    {
        fDSCA = FALSE;
    }

    Index = 0;
    CountShared = INT_MAX;
    hr = certRequestGetConfigInfo(
			    m_pwszSharedFolder,
			    &Index,
			    &CountShared,
			    &pCAFromShared);
    // Don't fail if file not found or unc path is bad

    CSASSERT(S_OK == hr || FAILED(hr));
    _PrintIfError4(
		hr,
		"certRequestGetConfigInfo",
		HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND),
		HRESULT_FROM_WIN32(ERROR_NETWORK_UNREACHABLE),
		HRESULT_FROM_WIN32(ERROR_INVALID_NETNAME));

    DBGPRINT((
	DBG_SS_CERTLIBI,
	"%x Shared Folder entries @%x\n",
	CountShared,
	pCAFromShared));

    actualSharedCount = 0;
    if (0 < CountShared)
    {
	hr = _ResizeCAInfo(m_Count + CountShared);
	_JumpIfError(hr, error, "_ResizeCAInfo");

	DBGPRINT((
	    DBG_SS_CERTLIBI,
	    "%x %ws @%x\n",
	    m_Count + CountShared,
	    fDSCA? L"Total entries" : L"new Shared Folder entries",
	    m_pCertAuthorityInfo));

        for (i = 0; i < CountShared; ++i)
        {
	    CERT_AUTHORITY_INFO *pCAInDS = NULL;
	    CERT_AUTHORITY_INFO *pCAUpdate;
	    
	    if (fDSCA)
	    {
		FindSharedCAInDSList(
				m_pCertAuthorityInfo,
				m_Count,
				&pCAFromShared[i],
				&pCAInDS);
            }

	    if (NULL != pCAInDS)
	    {
		pCAUpdate = pCAInDS;
	    }
	    else
	    {
		pCAUpdate = &m_pCertAuthorityInfo[m_Count + actualSharedCount];
		ZeroMemory(pCAUpdate, sizeof(*pCAUpdate));
	    }

	    hr = mergeConfigFields(&pCAFromShared[i], pCAUpdate);
	    _JumpIfError(hr, error, "mergeConfigFields");

	    DBGPRINT((
		DBG_SS_CERTLIBI,
		"%hs CA entry: %ws\n",
		NULL != pCAInDS? "Merged" : "Added",
		pCAUpdate->pwszSanitizedConfig));

	    if (NULL == pCAInDS)
	    {
                ++actualSharedCount;
	    }
        }
    }
    m_Count += actualSharedCount;

    // Add local CA to the table.  Merge entry if it already exists.
    // Also flags all local CAs.

    hr = myGetCertRegStrValue(
			NULL,
			NULL,
			NULL,
			wszREGACTIVE,
			&pwszSanitizedCAName);
    _PrintIfErrorStr(hr, "myGetCertRegStrValue", wszREGACTIVE);

    if (S_OK == hr)
    {
	hr = myGetComputerNames(&pwszDnsName, &pwszOldName);
	_JumpIfError(hr, error, "myGetComputerNames");

	hr = _AddRegistryConfigEntry(
			pwszDnsName,
			pwszOldName,
			pwszSanitizedCAName,
			FALSE,		// fParentCA
			NULL,
			&pccCA);
	_JumpIfError(hr, error, "_AddRegistryConfigEntry");

	// Add parent CA to the table.  Merge entry if it already exists.

	hr = myGetCertRegStrValue(
		    pwszSanitizedCAName,
		    NULL,
		    NULL,
		    wszREGPARENTCANAME,
		    &pwszParentCAName);
	_PrintIfErrorStr2(
		    hr,
		    "myGetCertRegStrValue",
		    wszREGPARENTCANAME,
		    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));
	if (S_OK == hr)
	{
	    hr = myGetCertRegStrValue(
			pwszSanitizedCAName,
			NULL,
			NULL,
			wszREGPARENTCAMACHINE,
			&pwszParentMachine);
	    _PrintIfErrorStr(hr, "myGetCertRegStrValue", wszREGPARENTCAMACHINE);
	}

	if (NULL != pwszParentMachine && NULL != pwszParentCAName)
	{
	    WCHAR *pwsz;
	    
	    hr = mySanitizeName(pwszParentCAName, &pwszParentSanitizedCAName);
	    _JumpIfError(hr, error, "mySanitizeName");

	    hr = myDupString(pwszParentMachine, &pwszParentMachineOld);
	    _JumpIfError(hr, error, "myDupString");

	    pwsz = wcschr(pwszParentMachineOld, L'.');
	    if (NULL != pwsz)
	    {
		*pwsz = L'\0';
	    }
	    hr = _AddRegistryConfigEntry(
			    pwszParentMachine,
			    pwszParentMachineOld,
			    pwszParentSanitizedCAName,
			    TRUE,		// fParentCA
			    pccCA,
			    NULL);
	    _JumpIfError(hr, error, "_AddRegistryConfigEntry");
	}
    }
    hr = S_OK;

error:
    if (NULL != pwszDnsName)
    {
        LocalFree(pwszDnsName);
    }
    if (NULL != pwszOldName)
    {
        LocalFree(pwszOldName);
    }
    if (NULL != pwszSanitizedCAName)
    {
        LocalFree(pwszSanitizedCAName);
    }
    if (NULL != pwszParentCAName)
    {
	LocalFree(pwszParentCAName);
    }
    if (NULL != pwszParentMachine)
    {
	LocalFree(pwszParentMachine);
    }
    if (NULL != pwszParentMachineOld)
    {
	LocalFree(pwszParentMachineOld);
    }
    if (NULL != pwszParentSanitizedCAName)
    {
        LocalFree(pwszParentSanitizedCAName);
    }
    if (NULL != pCAFromShared)
    {
        LocalFree(pCAFromShared);
    }
    if (NULL != pccCA)
    {
        CertFreeCertificateContext(pccCA);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertConfigPrivate::Reset -- load config data, reset to indexed entry,
// return count
//
// Load the configuration data if not already loaded.  To reload the data after
// the data have changed, CCertConfigPrivate must be released and reloaded.
//
// Resets the current config entry to the Certification Authority configuration
// listed in the configuration file, indexed by the Index parameter.  0 indexes
// the first configuration.
//
// Upon successful completion, *pCount will be set to the number of Certificate
// Authority configurations listed in the configuration file.
//
// Returns S_FALSE if no entries are available at or after the passed Index.
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertConfigPrivate::Reset(
    /* [in] */ LONG Index,
    /* [retval][out] */ LONG __RPC_FAR *pCount)
{
    HRESULT hr = S_OK;

    if (NULL == pCount)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "pCount");
    }
    if (NULL == m_pCertAuthorityInfo)
    {
	hr = _LoadTable();
	_JumpIfError(hr, error, "_LoadTable");
    }
    *pCount = m_Count;
    if (0 > Index || Index > m_Count)
    {
	Index = m_Count + 1;
	hr = S_FALSE;
    }
    m_Index = Index - 1;

error:
    CSASSERT(S_OK == hr || S_FALSE == hr || FAILED(hr));
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertConfigPrivate::Next -- skip to next config entry
//
// Changes the current config entry to the next Certification Authority
// configuration listed in the configuration file.
//
// Upon successful completion, *pIndex will be set to the index of Certificate
// Authority configurations listed in the configuration file.
//
// Returns S_FALSE if no more entries are available.  *pIndex is set to -1.
// Returns S_OK on success.  *pIndex is set to index the current configuration.
//+--------------------------------------------------------------------------

HRESULT
CCertConfigPrivate::Next(
    /* [retval][out] */ LONG __RPC_FAR *pIndex)
{
    HRESULT hr = S_OK;

    if (NULL == pIndex)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "pIndex");
    }
    *pIndex = -1;
    if (NULL == m_pCertAuthorityInfo)
    {
	hr = _LoadTable();
	_JumpIfError(hr, error, "_LoadTable");
    }
    if (m_Index < m_Count)
    {
	m_Index++;
    }
    if (m_Index < m_Count)
    {
	*pIndex = m_Index;
    }
    else
    {
	hr = S_FALSE;
    }

error:
    CSASSERT(S_OK == hr || S_FALSE == hr || FAILED(hr));
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertConfigPrivate::GetField -- return a field from the current config entry.
//
// pstrOut points to a BSTR string filled in by this routine.  If *pstrOut is
// non-NULL and this method is successful, the old string is freed.  If any
// value other than S_OK is returned, the string pointer will not be modified.
//
// Upon successful completion, *pstrOut will point to a string that contains
// the requested field from the current config entry.
//
// When the caller no longer needs the string, it must be freed by calling
// SysFreeString().
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertConfigPrivate::GetField(
    /* [in] */ BSTR const strFieldName,
    /* [retval][out] */ BSTR __RPC_FAR *pstrOut)
{
    HRESULT hr = S_OK;
    CERT_AUTHORITY_INFO *pcai;
    BSTR bstr;
    DWORD cwc;
    WCHAR *pwsz = NULL;
    WCHAR *pwszRevert = NULL;
    WCHAR *pwszT = NULL;
    BOOL fDesanitize = TRUE;
    WCHAR awc[12];

    if (NULL == pstrOut || NULL == strFieldName)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "pstrOut|strFieldName");
    }
    if (NULL != *pstrOut)
    {
	SysFreeString(*pstrOut);
	*pstrOut = NULL;
    }
    if (NULL == m_pCertAuthorityInfo)
    {
	hr = _LoadTable();
	_JumpIfError(hr, error, "_LoadTable");
    }

    if (-1 == m_Index)
    {
	m_Index++;	// implicit Next() for compatibility with Version 1
    }
    if (0 > m_Index || m_Index >= m_Count)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "m_Index");
    }

    pcai = &m_pCertAuthorityInfo[m_Index];
    bstr = strFieldName;

    if (0 == lstrcmpi(bstr, wszCONFIG_COMMONNAME))
    {
	pwsz = pcai->pwszSanitizedName;
    }
    else
    if (0 == lstrcmpi(bstr, wszCONFIG_SANITIZEDNAME))
    {
	pwsz = pcai->pwszSanitizedName;
	fDesanitize = FALSE;
    }
    else
    if (0 == lstrcmpi(bstr, wszCONFIG_SHORTNAME))
    {
	pwsz = pcai->pwszSanitizedShortName;
    }
    else
    if (0 == lstrcmpi(bstr, wszCONFIG_SANITIZEDSHORTNAME))
    {
	pwsz = pcai->pwszSanitizedShortName;
	fDesanitize = FALSE;
    }
    else
    if (0 == lstrcmpi(bstr, wszCONFIG_ORGUNIT))
    {
	pwsz = pcai->pwszSanitizedOrgUnit;
    }
    else
    if (0 == lstrcmpi(bstr, wszCONFIG_ORGANIZATION))
    {
	pwsz = pcai->pwszSanitizedOrganization;
    }
    else
    if (0 == lstrcmpi(bstr, wszCONFIG_LOCALITY))
    {
	pwsz = pcai->pwszSanitizedLocality;
    }
    else
    if (0 == lstrcmpi(bstr, wszCONFIG_STATE))
    {
	pwsz = pcai->pwszSanitizedState;
    }
    else
    if (0 == lstrcmpi(bstr, wszCONFIG_COUNTRY))
    {
	pwsz = pcai->pwszSanitizedCountry;
    }
    else
    if (0 == lstrcmpi(bstr, wszCONFIG_CONFIG))
    {
	pwsz = pcai->pwszSanitizedConfig;
    }
    else
    if (0 == lstrcmpi(bstr, wszCONFIG_EXCHANGECERTIFICATE))
    {
	pwsz = pcai->pwszSanitizedExchangeCertificate;
	fDesanitize = FALSE;
    }
    else
    if (0 == lstrcmpi(bstr, wszCONFIG_SIGNATURECERTIFICATE))
    {
	pwsz = pcai->pwszSanitizedSignatureCertificate;
	fDesanitize = FALSE;
    }
    else
    if (0 == lstrcmpi(bstr, wszCONFIG_DESCRIPTION) ||
	0 == lstrcmpi(bstr, wszCONFIG_COMMENT))	// obsolete
    {
	pwsz = pcai->pwszSanitizedDescription;
    }
    else
    if (0 == lstrcmpi(bstr, wszCONFIG_SERVER))
    {
	pwsz = wcschr(pcai->pwszSanitizedConfig, L'\\');
	if (NULL == pwsz)
	{
	    cwc = wcslen(pcai->pwszSanitizedConfig);
	}
	else
	{
	    cwc = SAFE_SUBTRACT_POINTERS(pwsz, pcai->pwszSanitizedConfig);
	}
	pwszT = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
	if (NULL == pwszT)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	CopyMemory(pwszT, pcai->pwszSanitizedConfig, cwc * sizeof(WCHAR));
	pwszT[cwc] = L'\0';
	pwsz = pwszT;
    }
    else
    if (0 == lstrcmpi(bstr, wszCONFIG_AUTHORITY))
    {
	pwsz = wcschr(pcai->pwszSanitizedConfig, L'\\');
	if (NULL == pwsz)
	{
	    pwsz = L"";
	}
	else
	{
	    pwsz++;
	}
    }
    else
    if (0 == lstrcmpi(bstr, wszCONFIG_FLAGS))
    {
	wsprintf(awc, L"%u", pcai->Flags);
	CSASSERT(ARRAYSIZE(awc) > wcslen(awc));
	pwsz = awc;
    }

    if (NULL == pwsz)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpError2(hr, error, "ConvertWszToBstr", CERTSRV_E_PROPERTY_EMPTY);
    }

    if (fDesanitize)
    {
	hr = myRevertSanitizeName(pwsz, &pwszRevert);
	_JumpIfError(hr, error, "myRevertSanitizeName");

	pwsz = pwszRevert;
    }

    if (!ConvertWszToBstr(pstrOut, pwsz, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }

error:
    if (NULL != pwszT)
    {
	LocalFree(pwszT);
    }
    if (NULL != pwszRevert)
    {
	LocalFree(pwszRevert);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


HRESULT
CCertConfigPrivate::GetConfigFromPicker(
    OPTIONAL IN HWND               hwndParent,
    OPTIONAL IN WCHAR const       *pwszPrompt,
    OPTIONAL IN WCHAR const       *pwszTitle,
    OPTIONAL IN WCHAR const       *pwszSharedFolder,
    IN BOOL                        fUseDS,
    IN BOOL                        fCountOnly,
    OUT DWORD                     *pdwCount,
    OUT CRYPTUI_CA_CONTEXT const **ppCAContext)
{
    HRESULT   hr = S_OK;
    CRYPTUI_CA_CONTEXT   *prgCAC = NULL;
    const CRYPTUI_CA_CONTEXT  **pprgCAC = NULL;
    CRYPTUI_SELECT_CA_STRUCT    UISelectCA;
    CRYPTUI_CA_CONTEXT const *pCAContext = NULL;

    LONG           i;
    LONG           realCount = 0;
    LONG           cCA = 0;
    BSTR           bsFieldName = NULL;
    BSTR           bsFieldValue = NULL;
    WCHAR          *pwszPtr;
    WCHAR          **ppwszCAName = NULL;
    WCHAR          **ppwszCAMachineName = NULL;

    if ((NULL == ppCAContext) || (NULL == pdwCount))
    {
        hr = E_POINTER;
        _JumpError (hr, error, "NULL parm");
    }

    *ppCAContext = NULL;
    *pdwCount = 0;

    m_fUseDS = fUseDS;
    if (NULL != pwszSharedFolder)
    {
	hr = SetSharedFolder(const_cast<WCHAR *>(pwszSharedFolder));
	_JumpIfError(hr, error, "configPrivate.SetSharedFolder");
    }

    hr = Reset(0, &cCA);
    if (S_OK != hr && S_FALSE != hr)
    {
       _JumpError(hr, error, "configPrivate.Reset");
    }
    hr = S_OK; // in case of S_FALSE;

    if (0 < cCA)
    {
	prgCAC = (CRYPTUI_CA_CONTEXT *) LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, 
		       cCA * sizeof(CRYPTUI_CA_CONTEXT));
	if (NULL == prgCAC)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}

	pprgCAC = (const CRYPTUI_CA_CONTEXT **) LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, 
		       cCA * sizeof(const CRYPTUI_CA_CONTEXT *));
	if (NULL == pprgCAC)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}

	ppwszCAName = (WCHAR **) LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, cCA * sizeof(WCHAR *));
	if (NULL == ppwszCAName)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}

	ppwszCAMachineName = (WCHAR **) LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, cCA * sizeof(WCHAR *));
	if (NULL == ppwszCAMachineName)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}

	if (!ConvertWszToBstr(&bsFieldName, wszCONFIG_CONFIG, -1))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "ConvertWszToBstr");
	}
	realCount = 0;
	while (realCount < cCA)
	{
	    hr = GetField(bsFieldName, &bsFieldValue);
	    _JumpIfError(hr, error, "configPrivate.GetField");
	    
	    pwszPtr = wcsstr(bsFieldValue, L"\\");
	    if (NULL == pwszPtr)
	    {
		continue;
	    }
	    // change \ to null terminator
	    pwszPtr[0] = L'\0';
	    // point to CA name
	    pwszPtr = &pwszPtr[1];

	    ppwszCAName[realCount] = (WCHAR *) LocalAlloc(
				    LMEM_FIXED, 
				    (wcslen(pwszPtr) + 1) * sizeof(WCHAR));
	    if (NULL == ppwszCAName[realCount])
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    ppwszCAMachineName[realCount] = (WCHAR *) LocalAlloc(
				LMEM_FIXED, 
				(wcslen(bsFieldValue) + 1) * sizeof(WCHAR));
	    if (NULL == ppwszCAMachineName[realCount])
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    prgCAC[realCount].dwSize = sizeof(CRYPTUI_CA_CONTEXT);
	    wcscpy(ppwszCAName[realCount], pwszPtr);
	    wcscpy(ppwszCAMachineName[realCount], bsFieldValue);
	    prgCAC[realCount].pwszCAName = ppwszCAName[realCount];
	    prgCAC[realCount].pwszCAMachineName = ppwszCAMachineName[realCount];
	    ++realCount;

	    hr = Next(&i);
	    if (S_OK != hr)
	    {
		if (S_FALSE == hr)
		{
		    hr = S_OK;  // no more entry is not an error
		}
		break;
	    }
	    if (NULL != bsFieldValue)
	    {
		SysFreeString(bsFieldValue);
		bsFieldValue = NULL;
	    }
	}
        
	for (i = 0; i < realCount; ++i)
	{
	    pprgCAC[i] = &prgCAC[i];
	}
    }

    *pdwCount = realCount;
    if (fCountOnly || 1 > realCount)
    {
        // done
        goto error; // normal return
    }

    ZeroMemory(&UISelectCA, sizeof(CRYPTUI_SELECT_CA_STRUCT));
    UISelectCA.cCAContext = realCount;
    UISelectCA.rgCAContext = pprgCAC;
    UISelectCA.dwSize = sizeof(UISelectCA);
    UISelectCA.wszDisplayString = pwszPrompt;
    UISelectCA.wszTitle = pwszTitle;
    UISelectCA.hwndParent = hwndParent;

    // cryptui called via delay load, wrap with try/except
    __try
    {
        // invoke dialog
        pCAContext = (CRYPTUI_CA_CONTEXT const *) CryptUIDlgSelectCA(&UISelectCA);  // DelayLoad Wrapped

        if (NULL == pCAContext) // user cancel?
        {
	    hr = myHLastError();
            if (S_OK == hr)		
	    {
	        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
            }
            _JumpError(hr, error, "CryptUIDlgSelectCA");
         }
    
        *ppCAContext = pCAContext;

        hr = S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }


error:
    // change to default
    m_fUseDS = TRUE;

    if (NULL != ppwszCAName)
    {
        for (i = 0; i < realCount; ++i)
        {
            if (NULL != ppwszCAName[i])
            {
                LocalFree(ppwszCAName[i]);
            }
        }
        LocalFree(ppwszCAName);
    }
    if (NULL != ppwszCAMachineName)
    {
        for (i = 0; i < realCount; ++i)
        {
            if (NULL != ppwszCAMachineName[i])
            {
                LocalFree(ppwszCAMachineName[i]);
            }
        }
        LocalFree(ppwszCAMachineName);
    }
    if (NULL != pprgCAC)
    {
        LocalFree(pprgCAC);
    }
    if (NULL != prgCAC)
    {
        LocalFree(prgCAC);
    }
    if (NULL != bsFieldName)
    {
        SysFreeString(bsFieldName);
    }
    if (NULL != bsFieldValue)
    {
	SysFreeString(bsFieldValue);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertConfigPrivate::GetConfig -- select a cert issuer, return config data.
//
// pstrOut points to a BSTR string filled in by this routine.  If *pstrOut is
// non-NULL and this method is successful, the old string is freed.  If any
// value other than S_OK is returned, the string pointer will not be modified.
//
// Flags must be set to 0.
//
// Upon successful completion, *pstrOut will point to a string that contains
// the server name and Certification Authority name.
//
// When the caller no longer needs the string, it must be freed by calling
// SysFreeString().
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertConfigPrivate::GetConfig(
    /* [in] */ LONG Flags,
    /* [retval][out] */ BSTR __RPC_FAR *pstrOut)
{
    HRESULT hr = S_OK;
    WCHAR *pwszSanitizedConfig = NULL;
    WCHAR *pwszConfigRevert = NULL;
    WCHAR *pwszSanitize = NULL;
    HMODULE hMod = NULL;
    CRYPTUI_CA_CONTEXT const *pCAContext = NULL;
    DWORD dwCACount;
    LONG lIndex;
    LONG cCA;
    LONG i;

    if (NULL == pstrOut)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "pstrOut");
    }
    if (NULL != *pstrOut)
    {
	SysFreeString(*pstrOut);
	*pstrOut = NULL;
    }
    if (NULL == m_pCertAuthorityInfo)
    {
	hr = _LoadTable();
	_JumpIfError(hr, error, "_LoadTable");
    }
    if (0 > m_Count)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "m_Count");
    }

    switch (Flags)
    {
        case CC_UIPICKCONFIG:
	    hMod = LoadLibrary(L"cryptui.dll");
	    if (NULL != hMod)
	    {
		hr = GetConfigFromPicker(
				    GetDesktopWindow(),	// hDlg
				    NULL,	// pwszPrompt
				    NULL,	// pwszTitle
				    m_pwszSharedFolder,
				    TRUE,	// fUseDS
				    FALSE,	// fCountOnly
				    &dwCACount,
				    &pCAContext);
		_JumpIfError(hr, error, "GetConfigFromPicker");

		if (NULL == pCAContext)
		{
		    hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
		    _JumpError(hr, error, "No CA Config");
		}

                // ca name in UI has been reverted so sanitize it

                hr = mySanitizeName(pCAContext->pwszCAName, &pwszSanitize);
                _JumpIfError(hr, error, "mySanitizeName");

		pwszSanitizedConfig = (WCHAR *) LocalAlloc(
			    LMEM_FIXED,
			    (wcslen(pwszSanitize) +
			     wcslen(pCAContext->pwszCAMachineName) + 2) *
				sizeof(WCHAR));
		if (NULL == pwszSanitizedConfig)
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "LocalAlloc");
		}
		wcscpy(pwszSanitizedConfig, pCAContext->pwszCAMachineName);
		wcscat(pwszSanitizedConfig, L"\\");
		wcscat(pwszSanitizedConfig, pwszSanitize);
                for (lIndex = 0; lIndex < m_Count; ++lIndex)
                {
                    if (0 == lstrcmpi(pwszSanitizedConfig, m_pCertAuthorityInfo[lIndex].pwszSanitizedConfig))
                    {
                        // update index
                        Reset(lIndex + 1, &cCA);
                        break;
                    }
                }
		break;
	    }
	    // FALLTHROUGH
        
        case CC_LOCALCONFIG:
        case CC_LOCALACTIVECONFIG:
        case CC_DEFAULTCONFIG:
	    if (NULL == m_pCertAuthorityInfo)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
		_JumpError(hr, error, "no CAs");
	    }
	    if (CC_LOCALCONFIG != Flags && CC_LOCALACTIVECONFIG != Flags)
	    {
		// Make a recursive call to first look for a local pingable CA.
		// If that fails, pick any pingable CA.

		hr = GetConfig(CC_LOCALACTIVECONFIG, pstrOut);
		if (S_OK == hr)
		{
		    break;
		}
		_PrintError(hr, "GetConfig(CC_LOCALACTIVECONFIG)");
	    }
            for (i = 0; i < m_Count; i++)
            {
		CSASSERT(NULL != m_pCertAuthorityInfo[i].pwszSanitizedConfig);

		pwszSanitizedConfig = m_pCertAuthorityInfo[i].pwszSanitizedConfig;

		if (CC_LOCALCONFIG == Flags || CC_LOCALACTIVECONFIG == Flags)
		{
		    DWORD InfoFlags;

		    InfoFlags = m_pCertAuthorityInfo[i].Flags;
		    if (0 == (CAIF_LOCAL & InfoFlags))
		    {
			continue;
		    }
		    if (0 == (CAIF_REGISTRY & InfoFlags))
		    {
			LONG j;

			for (j = i + 1; j < m_Count; j++)
			{
			    InfoFlags = m_pCertAuthorityInfo[j].Flags;

			    if ((CAIF_LOCAL & InfoFlags) &&
				(CAIF_REGISTRY & InfoFlags))
			    {
				break;
			    }
			}
			if (j < m_Count)
			{
			    i = j;
			}
		    }
		}
		if (CC_LOCALCONFIG == Flags)
		{
		    hr = S_OK;
		}
		else
		{
		    hr = myRevertSanitizeName(pwszSanitizedConfig, &pwszConfigRevert);
		    _JumpIfError(hr, error, "myRevertSanitizeName");

		    hr = myPingCertSrv(
				pwszConfigRevert,
				NULL,
				NULL,
				NULL,
				NULL,
				NULL,
                                NULL);
		}
		if (S_OK == hr)
		{
		    // update index
		    Reset(i + 1, &cCA);
		    break; // take it
		}
		if (NULL != pwszConfigRevert)
		{
		    LocalFree(pwszConfigRevert);
		    pwszConfigRevert = NULL;
		}
            }
            if (S_OK != hr || i >= m_Count)
            {
                hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
                _JumpError(hr, error, "No matching CA");
            }
	    break;

        case CC_FIRSTCONFIG:
	    if (NULL == m_pCertAuthorityInfo)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
		_JumpError(hr, error, "no CAs");
	    }
	    pwszSanitizedConfig = m_pCertAuthorityInfo[0].pwszSanitizedConfig;
            // update index
            Reset(1, &cCA);
	    break;

        default:
            hr = E_INVALIDARG;
           _JumpError(hr, error, "Flags");
    }

    if(!*pstrOut)
    {
        if (NULL == pwszConfigRevert)
        {
	    // always revert

	    hr = myRevertSanitizeName(pwszSanitizedConfig, &pwszConfigRevert);
	    _JumpIfError(hr, error, "myRevertSanitizeName");
        }
        if (!ConvertWszToBstr(pstrOut, pwszConfigRevert, -1))
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "ConvertWszToBstr");
        }
    }
    hr = S_OK;

error:
    if (NULL != hMod)
    {
	FreeLibrary(hMod);
        if (NULL != pwszSanitizedConfig)
        {
            LocalFree(pwszSanitizedConfig);
        }
    }
    if (NULL != pwszConfigRevert)
    {
        LocalFree(pwszConfigRevert);
    }
    if (NULL != pwszSanitize)
    {
        LocalFree(pwszSanitize);
    }
    if (NULL != pCAContext)
    {
        CryptUIDlgFreeCAContext(pCAContext);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertConfigPrivate::SetSharedFolder -- set the shared folder
//
// strSharedFolder is the new shared folder dorectory path.
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertConfigPrivate::SetSharedFolder(
    /* [in] */ const BSTR strSharedFolder)
{
    HRESULT hr;
    WCHAR *pwsz;

    pwsz = NULL;
    if (NULL != strSharedFolder)
    {
	hr = myDupString(strSharedFolder, &pwsz);
	_JumpIfError(hr, error, "myDupString");
    }
    if (NULL != m_pwszSharedFolder)
    {
	LocalFree(m_pwszSharedFolder);
    }
    m_pwszSharedFolder = pwsz;
    hr = S_OK;

error:
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


HRESULT WINAPI
certLoadFile(
    WCHAR const *pwszfn,
    BYTE **ppbData,
    DWORD *pcbData)
{
    HANDLE hFile;
    DWORD cbLow, cbHigh, cbRead;
    HRESULT hr;

    hFile = CreateFile(
                    pwszfn,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    0);
    if (INVALID_HANDLE_VALUE == hFile)
    {
        hr = myHLastError();
	_JumpErrorStr(hr, error, "CreateFile", pwszfn);
    }

    cbLow = GetFileSize(hFile, &cbHigh);
    if (0xffffffff == cbLow)
    {
        hr = myHLastError();
	_JumpError(hr, error, "GetFileSize");
    }

    *ppbData = (BYTE *) LocalAlloc(LMEM_FIXED, cbLow + 1);
    if (NULL == *ppbData)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    if (!ReadFile(hFile, *ppbData, cbLow, &cbRead, NULL))
    {
        hr = myHLastError();
        LocalFree(*ppbData);
        *ppbData = NULL;
	_JumpError(hr, error, "ReadFile");
    }
    (*ppbData)[cbLow] = '\0';
    *pcbData = cbLow;
    hr = S_OK;

error:
    if (INVALID_HANDLE_VALUE != hFile)
    {
        CloseHandle(hFile);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


// certTrimToken -- trim white space from the beginning and end of a line.
// Bump caller's string pointer, reduce the caller's input buffer count,
// and L'\0' terminate the result -- IN PLACE!

VOID
certTrimToken(
    WCHAR **ppwsz)
{
    WCHAR *pwsz;
    WCHAR *pwszEnd;
    static WCHAR wszTrim[] = L" \t\r\n";

    pwsz = *ppwsz;
    while (L'\0' != *pwsz)
    {
	if (NULL == wcschr(wszTrim, *pwsz))
	{
	    break;
	}
	pwsz++;
    }

    pwszEnd = wcschr(pwsz, L'\0');
    assert(NULL != pwszEnd);

    while (pwsz < pwszEnd)
    {
	if (NULL == wcschr(wszTrim, *--pwszEnd))
	{
	    break;
	}
	*pwszEnd = L'\0';
    }
    *ppwsz = pwsz;
}


BOOL
certExtractToken(
    WCHAR **ppwszIn,
    WCHAR const **ppwszOut)
{
    WCHAR *pwsz;
    WCHAR *pwszNext;
    WCHAR *pwsz2;
    BOOL fQuoted = FALSE;

    pwsz = *ppwszIn;
    while (L' ' == *pwsz || L'\t' == *pwsz)
    {
	pwsz++;
    }

    pwszNext = pwsz;
    if (L'"' == *pwsz)
    {
	fQuoted = TRUE;
	pwsz++;
	pwszNext++;

	while (TRUE)
	{
	    // Find a mid-string escaped quote or the terminating quote.

	    pwszNext = wcschr(pwszNext, L'"');

	    if (NULL == pwszNext)
	    {
		break;		// missing terminating quote!
	    }

	    // If a terminating quote, terminate the string with L'\0',
	    // and point past the quoted string.  Break to search for a comma.

	    if (L'"' != pwszNext[1])
	    {
		*pwszNext++ = L'\0';
		break;
	    }

	    // Found a mid-string escaped quote.  Move the first part of the
	    // string forward one character position, overwriting the first
	    // quote character.  Bump the string pointer to the new location,
	    // point pwszNext past the remaining quote character, and loop.

	    MoveMemory(
		&pwsz[1],
		pwsz,
		SAFE_SUBTRACT_POINTERS(pwszNext, pwsz) * sizeof(*pwsz));
	    pwsz++;
	    pwszNext += 2;
	}
    }

    if (NULL != pwszNext)
    {
	pwszNext = wcschr(pwszNext, L',');
    }
    if (NULL != pwszNext)
    {
	*pwszNext++ = L'\0';
    }
    else
    {
	pwszNext = wcschr(pwsz, L'\0');
	assert(NULL != pwszNext);
    }

    certTrimToken(&pwsz);

    *ppwszOut = pwsz;
    *ppwszIn = pwszNext;

    return(fQuoted || L'\0' != *pwsz);
}


// certExtractLine -- convert one line to Unicode and return it in a L'\0'
// terminated output buffer.  Bump caller's input buffer pointer and reduce
// the caller's input buffer count.

HRESULT
certExtractLine(
    IN char const **ppchLine,
    IN OUT LONG *pcchLine,
    OUT WCHAR *pwc,
    IN OUT LONG *pcwc)
{
    char const *pch;
    char const *pchEnd;
    LONG cch;
    HRESULT hr = S_OK;
    int cwc;

    pch = *ppchLine;
    cch = *pcchLine;
    pchEnd = &pch[cch];

    while (pch < pchEnd)
    {
	if ('\n' == *pch++)
	{
	    pchEnd = pch;
	    cch = SAFE_SUBTRACT_POINTERS(pchEnd, *ppchLine);
	    break;
	}
    }

    do
    {
	cwc = MultiByteToWideChar(GetACP(), 0, *ppchLine, cch, pwc, *pcwc - 1);
	if (0 == cwc)
	{
	    hr = myHLastError();
	    break;
	}
	pwc[cwc] = L'\0';
	*pcwc = cwc;
	*pcchLine -= cch;
	*ppchLine = pchEnd;
    } while (FALSE);

    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


// Format of each line is:
// <name>, <OrgUnit>, <Organization>, <Locality>, <State>, <Country>, <Server Name>, <Exchange Cert>, <Self signed cert>, <Comment>

HRESULT
certParseLine(
    char const **ppchLine,
    LONG *pcchLine,
    CERT_AUTHORITY_INFO *pcai,
    WCHAR *pwsz,
    LONG *pcwc)
{
    HRESULT hr;
    LONG cwc;

    do
    {
	if (0 == *pcchLine)
	{
	    hr = S_OK;
	    *pcwc = 0;
	    goto error;
	}
	cwc = *pcwc;
	hr = certExtractLine(ppchLine, pcchLine, pwsz, &cwc);
	if (S_OK != hr)
	{
	    goto error;
	}
	*pcwc = cwc + 1;
	certTrimToken(&pwsz);
    } while (L'\0' == *pwsz || L'#' == *pwsz);

    if (!certExtractToken(&pwsz, (WCHAR const **) &pcai->pwszSanitizedName) ||
	!certExtractToken(&pwsz, (WCHAR const **) &pcai->pwszSanitizedOrgUnit) ||
	!certExtractToken(&pwsz, (WCHAR const **) &pcai->pwszSanitizedOrganization) ||
	!certExtractToken(&pwsz, (WCHAR const **) &pcai->pwszSanitizedLocality) ||
	!certExtractToken(&pwsz, (WCHAR const **) &pcai->pwszSanitizedState) ||
	!certExtractToken(&pwsz, (WCHAR const **) &pcai->pwszSanitizedCountry) ||
	!certExtractToken(&pwsz, (WCHAR const **) &pcai->pwszSanitizedConfig) ||
	!certExtractToken(&pwsz, (WCHAR const **) &pcai->pwszSanitizedExchangeCertificate) ||
	!certExtractToken(&pwsz, (WCHAR const **) &pcai->pwszSanitizedSignatureCertificate))
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	goto error;
    }
    certExtractToken(&pwsz, (WCHAR const **) &pcai->pwszSanitizedDescription);
    pcai->Flags = CAIF_SHAREDFOLDERENTRY;

error:
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


LONG
certSkipLine(
    IN char const **ppchData,
    IN LONG *pcchData)
{
    LONG cb = 0;
    HRESULT hr;

    do
    {
	CERT_AUTHORITY_INFO cai;
	WCHAR awcLine[cwcCONFIGLINEMAX];
	LONG cwc;
	char const *pchData;
	LONG cchData;

	pchData = *ppchData;
	cchData = *pcchData;
	cwc = sizeof(awcLine)/sizeof(awcLine[0]);
	hr = certParseLine(&pchData, &cchData, &cai, awcLine, &cwc);
	if (S_OK != hr || 0 == cwc)
	{
	    break;
	}
	cb = sizeof(cai) + cwc * sizeof(WCHAR);
	*ppchData = pchData;
	*pcchData = cchData;
    } while (FALSE);
    //printf("certSkipLine: %u bytes\n", cb);
    CSASSERT(S_OK == hr || FAILED(hr));
    return(cb);
}


VOID
certAppendBSFileName(
    IN OUT WCHAR *pwszPath,
    IN WCHAR *pwszBSFN)		// backslash + filename.ext
{
    DWORD cwc;

    cwc = wcslen(pwszPath);
    if (0 < cwc--)
    {
	if (L'\\' == pwszPath[cwc])
	{
	    pwszPath[cwc] = L'\0';
	}
    }
    wcscat(pwszPath, pwszBSFN);
}


HRESULT
certGetConfigFileName(
    OUT WCHAR **ppwszFileConfig)
{
    HRESULT hr;
    DWORD dwLen;
    DWORD dwType;
    HKEY hKeyConfig = NULL;
    WCHAR *pwszFileName = NULL;

    *ppwszFileConfig = NULL;

    do
    {
	hr = RegOpenKeyEx(
			HKEY_LOCAL_MACHINE,
			wszREGKEYCONFIGPATH,
			0,
			KEY_READ,
			&hKeyConfig);
	if (S_OK != hr)
	{
	    _PrintErrorStr2(
		    hr,
		    "RegOpenKeyEx",
		    wszREGKEYCONFIGPATH,
		    ERROR_FILE_NOT_FOUND);
	   break;
	}

	// Get the size of the value first

	hr = RegQueryValueEx(
			    hKeyConfig,
			    g_wszRegDirectory,
			    0,
			    &dwType,
			    NULL,
			    &dwLen);
	if (S_OK != hr)
	{
	    _PrintErrorStr2(
		    hr,
		    "RegQueryValueEx",
		    g_wszRegDirectory,
		    ERROR_FILE_NOT_FOUND);
	    break;
	}

	if (0 == dwLen)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _PrintErrorStr2(hr, "RegQueryValueEx", g_wszRegDirectory, hr);
	    break;
	}

	// Allocate enough memory for the directory path plus the file name.

	pwszFileName = (WCHAR *) LocalAlloc(LMEM_FIXED,
			dwLen + (wcslen(g_wszConfigFile) + 1) * sizeof(WCHAR));
	if (NULL == pwszFileName)
	{
	    hr = E_OUTOFMEMORY;
	    _PrintError2(hr, "LocalAlloc", hr);
	    break;
	}

	hr = RegQueryValueEx(
			    hKeyConfig,
			    g_wszRegDirectory,
			    0,
			    &dwType,
			    (BYTE *) pwszFileName,
			    &dwLen);
	if (S_OK != hr)
	{
	    _PrintErrorStr(hr, "RegQueryValueEx", g_wszRegDirectory);
	    break;
	}
	if (L'\0' == *pwszFileName)
	{
	    hr = S_OK;
	    break;
	}

	// Place config file name on end of path to open

	certAppendBSFileName(pwszFileName, g_wszConfigFile);
	*ppwszFileConfig = pwszFileName;
	pwszFileName = NULL;

    } while (FALSE);

    if (NULL != pwszFileName)
    {
	LocalFree(pwszFileName);
    }
    if (NULL != hKeyConfig)
    {
	RegCloseKey(hKeyConfig);
    }
    return(myHError(hr));
}


HRESULT
certLoadConfigFile(
    IN WCHAR const *pwszSharedFolder,
    OUT BYTE **ppchData,
    OUT DWORD *pcchData)
{
    HRESULT hr;
    WCHAR *pwszfn = NULL;

    *ppchData = NULL;
    *pcchData = 0;

    if (NULL == pwszSharedFolder)
    {
	hr = certGetConfigFileName(&pwszfn);
	_JumpIfError2(
		    hr,
		    error,
		    "certGetConfigFileName",
		    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));
    }
    else
    {
        pwszfn = (WCHAR *) LocalAlloc(
	    LMEM_FIXED,
            (wcslen(pwszSharedFolder) + wcslen(g_wszConfigFile) + 1) *
		sizeof(WCHAR));
        if (NULL == pwszfn)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
        wcscpy(pwszfn, pwszSharedFolder);
	certAppendBSFileName(pwszfn, g_wszConfigFile);
    }
    if (NULL != pwszfn)
    {
	hr = certLoadFile(pwszfn, ppchData, pcchData);
	_JumpIfError3(
		hr,
		error,
		"certLoadFile",
		HRESULT_FROM_WIN32(ERROR_NETWORK_UNREACHABLE),
		HRESULT_FROM_WIN32(ERROR_INVALID_NETNAME));
    }
    hr = S_OK;

error:
    if (NULL != pwszfn)
    {
	LocalFree(pwszfn);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


//+--------------------------------------------------------------------------
// certRequestGetConfig -- return config data for all requested authorities.
//
// *pIndex should be set to 0 prior to the first call.  It will be modified by
// certRequestGetConfig to index the next entry after those returned.
//
// *pCount is a pointer to the number of authorities for which information is
// requested.  Upon successful completion, *pCount will contain the number of
// authorities for which information is returned.  If the returned value is
// less than requested (or 0) no more entries are available.
//
// ppCertAuthorityInfo is a pointer to an uninitialized pointer on input.
// Upon successful completion, a pointer to an array of CERT_AUTHORITY_INFO
// structures is returned.  When the caller no longer needs the array, it must
// be freed by calling CertFreeMemory.
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
certRequestGetConfigInfo(
    IN WCHAR *pwszSharedFolder,
    IN OUT LONG *pIndex,
    IN OUT LONG *pCount,
    OUT CERT_AUTHORITY_INFO **ppCertAuthorityInfo)
{
    HRESULT hr = S_OK;
    LONG cSkip = *pIndex;
    LONG cLine = *pCount;
    DWORD cchData;
    char const *pchData = NULL;
    LONG cLineReturned = 0;
    CERT_AUTHORITY_INFO *pcaiBase = NULL;

    *ppCertAuthorityInfo = NULL;

    do
    {
        char const *pch;
        LONG cch;
        char const *pchSave;
        LONG cchSave;
        LONG cbTotal;
        CERT_AUTHORITY_INFO *pcai;
        WCHAR *pwc;
        LONG cwc;
        LONG cwcRemain;
        LONG i;
        
        hr = certLoadConfigFile(pwszSharedFolder, (BYTE **) &pchData, &cchData);
        if (S_OK != hr || (NULL == pchData && 0 == cchData))
        {
            break;
        }
        pch = pchData;
        cch = cchData;
        
        // Skip cSkip entries:
        
        //printf("Skipping lines:\n");
        for (i = 0; i < cSkip; i++)
        {
            if (0 == certSkipLine(&pch, &cch))
            {
                break;			// ran out of config data
            }
        }
        if (i < cSkip)
        {
            break;			// no data to return
        }
        pchSave = pch;
        cchSave = cch;
        
        // Compute total size of cLine entries:
        
        //printf("Sizing lines:\n");
        cbTotal = 0;
        for (i = 0; i < cLine; i++)
        {
            LONG cb;
            
            cb = certSkipLine(&pch, &cch);
            if (0 == cb)
            {
                cLine = i;		// reduce return line count
                break;			// ran out of config data
            }
            cbTotal += cb;
        }
        if (0 == cLine)
        {
            break;			// no data to return
        }
        
        pcaiBase = (CERT_AUTHORITY_INFO *) LocalAlloc(LMEM_FIXED, cbTotal);
        if (NULL == pcaiBase)
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        //printf("Returning lines:\n");
        pch = pchSave;
        cch = cchSave;
        pcai = pcaiBase;
        pwc = (WCHAR *) &pcai[cLine];
        cwcRemain = (cbTotal - sizeof(*pcai) * cLine)/sizeof(*pwc);
        for (i = 0; i < cLine; i++)
        {
            cwc = cwcRemain;
            hr = certParseLine(&pch, &cch, pcai, pwc, &cwc);
            if (S_OK != hr)
            {
                break;
            }
            pcai++;
            pwc += cwc;
            cwcRemain -= cwc;
        }
        if (S_OK != hr)
        {
            break;
        }
        cLineReturned = cLine;
        *ppCertAuthorityInfo = pcaiBase;
        pcaiBase = NULL;
        hr = S_OK;
    } while (FALSE);

    *pIndex += cLineReturned;
    *pCount = cLineReturned;

    if (NULL != pcaiBase)
    {
        LocalFree(pcaiBase);
    }
    if (NULL != pchData)
    {
	LocalFree(const_cast<char *>(pchData));
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


HRESULT
myGetConfigFromPicker(
    OPTIONAL IN HWND               hwndParent,
    OPTIONAL IN WCHAR const       *pwszPrompt,
    OPTIONAL IN WCHAR const       *pwszTitle,
    OPTIONAL IN WCHAR const       *pwszSharedFolder,
    IN  BOOL                       fUseDS,
    IN  BOOL                       fCountOnly,
    OUT DWORD                     *pdwCACount,
    OUT CRYPTUI_CA_CONTEXT const **ppCAContext)
{
    HRESULT hr;
    CCertConfigPrivate configPrivate;

    hr = configPrivate.GetConfigFromPicker(
				      hwndParent,
				      pwszPrompt,
				      pwszTitle,
				      pwszSharedFolder,
				      fUseDS,
				      fCountOnly,
				      pdwCACount,
				      ppCAContext);
    _JumpIfError(hr, error, "configPrivate.GetConfigFromPicker");

error:
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certcli\config.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        config.h
//
// Contents:    Declaration of CCertConfig
//
//---------------------------------------------------------------------------


#include "cscomres.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// certcli


class ATL_NO_VTABLE CCertConfig: 
    public IDispatchImpl<ICertConfig2, &IID_ICertConfig2, &LIBID_CERTCLIENTLib>, 
    public ISupportErrorInfoImpl<&IID_ICertConfig2>,
    public CComObjectRoot,
    public CComCoClass<CCertConfig, &CLSID_CCertConfig>,
    public CCertConfigPrivate
{
public:
    CCertConfig() { }
    ~CCertConfig();

BEGIN_COM_MAP(CCertConfig)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(ICertConfig)
    COM_INTERFACE_ENTRY(ICertConfig2)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertConfig) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(
    CCertConfig,
    wszCLASS_CERTCONFIG TEXT(".1"),
    wszCLASS_CERTCONFIG,
    IDS_CERTCONFIG_DESC,
    THREADFLAGS_BOTH)

// ICertConfig
public:
    STDMETHOD(Reset)( 
            /* [in] */ LONG Index,
            /* [out, retval] */ LONG __RPC_FAR *pCount);

    STDMETHOD(Next)(
            /* [out, retval] */ LONG __RPC_FAR *pIndex);

    STDMETHOD(GetField)( 
            /* [in] */ BSTR const strFieldName,
            /* [out, retval] */ BSTR __RPC_FAR *pstrOut);

    STDMETHOD(GetConfig)( 
            /* [in] */ LONG Flags,
            /* [out, retval] */ BSTR __RPC_FAR *pstrOut);

// ICertConfig2
public:
    STDMETHOD(SetSharedFolder)( 
            /* [in] */ const BSTR strSharedFolder);

private:
    HRESULT _SetErrorInfo(
	    IN HRESULT hrError,
	    IN WCHAR const *pwszDescription);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certcli\crypt.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        crypt.cpp
//
// Contents:    Cert Server wrapper routines
//
// History:     17-Oct-96       vich created
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop


HRESULT
myCryptStringToBinaryA(
    IN     LPCSTR    pszString,
    IN     DWORD     cchString,
    IN     DWORD     dwFlags,
    OUT    BYTE    **ppbBinary,
    OUT    DWORD    *pcbBinary,
    OUT    DWORD    *pdwSkip,    // OPTIONAL
    OUT    DWORD    *pdwFlags)   // OPTIONAL
{
    HRESULT hr;
    BYTE *pb = NULL;
    DWORD cb;

    while (TRUE)
    {
	if (!CryptStringToBinaryA(
			pszString,
			cchString,
			dwFlags,
			pb,
			&cb,
			pdwSkip,
			pdwFlags))
	{
	    hr = myHLastError();
	    _JumpError2(
		    hr,
		    error,
		    "CryptStringToBinaryA",
		    HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
	}
	if (NULL != pb)
	{
	    break;	// done
	}
	pb = (BYTE *) LocalAlloc(LMEM_FIXED, cb);
	if (NULL == pb)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }
    *pcbBinary = cb;
    *ppbBinary = pb;
    pb = NULL;
    hr = S_OK;

error:
    if (NULL != pb)
    {
	LocalFree(pb);
    }
    return(hr);
}


HRESULT
myCryptStringToBinary(
    IN     LPCWSTR   pwszString,
    IN     DWORD     cwcString,
    IN     DWORD     dwFlags,
    OUT    BYTE    **ppbBinary,
    OUT    DWORD    *pcbBinary,
    OUT    DWORD    *pdwSkip,    // OPTIONAL
    OUT    DWORD    *pdwFlags)   // OPTIONAL
{
    HRESULT hr;
    BYTE *pb = NULL;
    DWORD cb;

    while (TRUE)
    {
	if (!CryptStringToBinaryW(
			pwszString,
			cwcString,
			dwFlags,
			pb,
			&cb,
			pdwSkip,
			pdwFlags))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptStringToBinaryW");
	}
	if (NULL != pb)
	{
	    break;	// done
	}
	pb = (BYTE *) LocalAlloc(LMEM_FIXED, cb);
	if (NULL == pb)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }
    *pcbBinary = cb;
    *ppbBinary = pb;
    pb = NULL;
    hr = S_OK;

error:
    if (NULL != pb)
    {
	LocalFree(pb);
    }
    return(hr);
}


HRESULT
myCryptBinaryToStringA(
    IN     CONST BYTE  *pbBinary,
    IN     DWORD        cbBinary,
    IN     DWORD        dwFlags,
    OUT    LPSTR       *ppszString)
{
    HRESULT hr;
    char *psz = NULL;
    DWORD cch;

    while (TRUE)
    {
	if (!CryptBinaryToStringA(pbBinary, cbBinary, dwFlags, psz, &cch))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptBinaryToStringA");
	}
	if (NULL != psz)
	{
	    break;	// done
	}
	psz = (char *) LocalAlloc(LMEM_FIXED, cch * sizeof(char));
	if (NULL == psz)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }
    *ppszString = psz;
    psz = NULL;
    hr = S_OK;

error:
    if (NULL != psz)
    {
	LocalFree(psz);
    }
    return(hr);
}


HRESULT
myCryptBinaryToString(
    IN     CONST BYTE  *pbBinary,
    IN     DWORD        cbBinary,
    IN     DWORD        dwFlags,
    OUT    LPWSTR      *ppwszString)
{
    HRESULT hr;
    WCHAR *pwsz = NULL;
    DWORD cwc;
    DWORD cwc0;

    while (TRUE)
    {
	if (!CryptBinaryToStringW(pbBinary, cbBinary, dwFlags, pwsz, &cwc))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptBinaryToStringW");
	}
	if (NULL != pwsz)
	{
	    break;	// done
	}
        cwc0 = cwc;
	pwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
	if (NULL == pwsz)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }

    CSASSERT(cwc0 == cwc + 1);
    CSASSERT(L'\0' == pwsz[cwc]);

    *ppwszString = pwsz;
    pwsz = NULL;
    hr = S_OK;

error:
    if (NULL != pwsz)
    {
	LocalFree(pwsz);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certcli\configp.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        configp.h
//
// Contents:    Declaration of CCertConfigPrivate
//
//---------------------------------------------------------------------------


#include <cryptui.h>
#include "cscomres.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// certcli


typedef struct _CERT_AUTHORITY_INFO
{
    WCHAR *pwszSanitizedName;
    WCHAR *pwszSanitizedShortName;
    WCHAR *pwszSanitizedOrgUnit;
    WCHAR *pwszSanitizedOrganization;
    WCHAR *pwszSanitizedLocality;
    WCHAR *pwszSanitizedState;
    WCHAR *pwszSanitizedCountry;
    WCHAR *pwszSanitizedConfig;
    WCHAR *pwszSanitizedExchangeCertificate;
    WCHAR *pwszSanitizedSignatureCertificate;
    WCHAR *pwszSanitizedDescription;
    DWORD  Flags;
} CERT_AUTHORITY_INFO;


class CCertConfigPrivate
{
public:
    CCertConfigPrivate()
    {
        m_pCertAuthorityInfo = NULL;
        m_fUseDS = TRUE;
	m_pwszSharedFolder = NULL;
    }
    ~CCertConfigPrivate();

// ICertConfig
public:
    HRESULT Reset( 
            /* [in] */ LONG Index,
            /* [retval][out] */ LONG __RPC_FAR *pCount);

    HRESULT Next(
            /* [retval][out] */ LONG __RPC_FAR *pIndex);

    HRESULT GetField( 
            /* [in] */ BSTR const strFieldName,
            /* [retval][out] */ BSTR __RPC_FAR *pstrOut);

    HRESULT GetConfig( 
            /* [in] */ LONG Flags,
            /* [retval][out] */ BSTR __RPC_FAR *pstrOut);

// ICertConfig2
public:
    HRESULT SetSharedFolder( 
            /* [in] */ const BSTR strSharedFolder);

// myGetConfigFromPicker
public:
    HRESULT GetConfigFromPicker(
	    OPTIONAL IN HWND               hwndParent,
	    OPTIONAL IN WCHAR const       *pwszPrompt,
	    OPTIONAL IN WCHAR const       *pwszTitle,
	    OPTIONAL IN WCHAR const       *pwszSharedFolder,
	    IN BOOL                        fUseDS,
	    IN BOOL                        fCountOnly,
	    OUT DWORD                     *pdwCount,
	    OUT CRYPTUI_CA_CONTEXT const **ppCAContext);

private:
    HRESULT _ResizeCAInfo(
	    IN LONG Count);

    HRESULT _LoadTable(VOID);

    HRESULT _AddRegistryConfigEntry(
	    IN WCHAR const *pwszMachine,
	    IN WCHAR const *pwszMachineOld,
	    IN WCHAR const *pwszSanitizedCAName,
	    IN BOOL fParentCA,
	    OPTIONAL IN CERT_CONTEXT const *pccCAChild,
	    OPTIONAL OUT CERT_CONTEXT const **ppccCAOut); // NULL == local CA

    CERT_AUTHORITY_INFO *m_pCertAuthorityInfo;
    LONG m_Index;
    LONG m_Count;
    BOOL m_fUseDS;
    WCHAR *m_pwszSharedFolder;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certcli\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1997

Module Name:

    makefile.inc.

!ENDIF

$(O)\$(MINORCOMP).res:    ..\idl\com\$(O)\$(MINORCOMP).tlb

$(O)\$(MINORCOMP).lib : $(PRIVLIB)

$(PRIVLIB) $(PRIVLIB:.lib=.exp): $(O)\$(MINORCOMP)p.def $(LIBRARY_OBJS)
   -$(LIB_NAME) -out:$(PRIVLIB) @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\$(MINORCOMP)p.def
$(LIBRARY_OBJS)
<<NOKEEP

$(O)\$(MINORCOMP)p.def: $(MINORCOMP).src
    $(C_PREPROCESSOR) $** -DPRIVATEEXPORT= > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certcli\getconf.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        getconf.h
//
// Contents:    Declaration of CCertGetConfig
//
//---------------------------------------------------------------------------


#include "clibres.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// certcli


class CCertGetConfig: 
    public IDispatchImpl<ICertGetConfig, &IID_ICertGetConfig, &LIBID_CERTCLIENTLib>, 
    public ISupportErrorInfoImpl<&IID_ICertGetConfig>,
    public CComObjectRoot,
    public CComCoClass<CCertGetConfig, &CLSID_CCertGetConfig>,
    public CCertConfigPrivate
{
public:
    CCertGetConfig() { }
    ~CCertGetConfig();

BEGIN_COM_MAP(CCertGetConfig)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(ICertGetConfig)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertGetConfig) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(
    CCertGetConfig,
    wszCLASS_CERTGETCONFIG TEXT(".1"),
    wszCLASS_CERTGETCONFIG,
    IDS_CERTGETCONFIG_DESC,
    THREADFLAGS_BOTH)

// ICertGetConfig
public:
    STDMETHOD(GetConfig)( 
            /* [in] */ LONG Flags,
            /* [retval][out] */ BSTR __RPC_FAR *pstrOut);
private:
    HRESULT _SetErrorInfo(
	    IN HRESULT hrError,
	    IN WCHAR const *pwszDescription);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certcli\getconf.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        config.cpp
//
// Contents:    Cert Server client implementation
//
// History:     24-Aug-96       vich created
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include "csdisp.h"
#include "configp.h"
#include "getconf.h"

//+--------------------------------------------------------------------------
// CCertGetConfig::~CCertGetConfig -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertGetConfig::~CCertGetConfig()
{
}


//+--------------------------------------------------------------------------
// CCertGetConfig::GetConfig -- select a certificate issuer, return config data.
//
// pstrOut points to a BSTR string filled in by this routine.  If *pstrOut is
// non-NULL and this method is successful, the old string is freed.  If any
// value other than S_OK is returned, the string pointer will not be modified.
//
// Flags must be set to 0.
//
// Upon successful completion, *pstrOut will point to a string that contains
// the server name and Certification Authority name.
//
// When the caller no longer needs the string, it must be freed by calling
// SysFreeString().
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertGetConfig::GetConfig(
    /* [in] */ LONG Flags,
    /* [retval][out] */ BSTR __RPC_FAR *pstrOut)
{
    HRESULT hr;
    
    hr = CCertConfigPrivate::GetConfig(Flags, pstrOut);
    return(_SetErrorInfo(hr, L"CCertGetConfig::GetConfig"));
}


HRESULT
CCertGetConfig::_SetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription)
{
    CSASSERT(FAILED(hrError) || S_OK == hrError || S_FALSE == hrError);
    if (FAILED(hrError))
    {
	HRESULT hr;

	hr = DispatchSetErrorInfo(
			    hrError,
			    pwszDescription,
			    wszCLASS_CERTGETCONFIG,
			    &IID_ICertGetConfig);
	CSASSERT(hr == hrError);
    }
    return(hrError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certcli\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
// History:     25-Jul-96       vich created
//
//---------------------------------------------------------------------------

#define __DIR__		"certcli"

#include <windows.h>
#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>

#include <certsrv.h>
#include "certlib.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certcli\request.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        request.h
//
// Contents:    Declaration of CCertRequest
//
//---------------------------------------------------------------------------


#include "xelib.h"
#include "cscomres.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// certcli


class ATL_NO_VTABLE CCertRequest: 
    public IDispatchImpl<ICertRequest2, &IID_ICertRequest2, &LIBID_CERTCLIENTLib>, 
    public ISupportErrorInfoImpl<&IID_ICertRequest2>,
    public CComObjectRoot,
    public CComCoClass<CCertRequest, &CLSID_CCertRequest>
{
public:
    CCertRequest()
    {
        m_dwServerVersion = 0;
        m_pICertRequestD = NULL;
        m_hRPCCertServer = NULL;
        m_pwszDispositionMessage = NULL;
        m_pbRequest = NULL;
        m_pbCert = NULL;
        m_pbCertificateChain = NULL;
        m_pbFullResponse = NULL;
        m_pwszServerName = NULL;
        m_rpcAuthProtocol = 0;
	m_rgResponse = NULL;
	m_hStoreResponse = NULL;
	_InitCAPropInfo();
        _Cleanup();
    }
    ~CCertRequest();

BEGIN_COM_MAP(CCertRequest)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(ICertRequest)
    COM_INTERFACE_ENTRY(ICertRequest2)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertRequest) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(
    CCertRequest,
    wszCLASS_CERTREQUEST TEXT(".1"),
    wszCLASS_CERTREQUEST,
    IDS_CERTREQUEST_DESC,
    THREADFLAGS_BOTH)

// ICertRequest
public:
    STDMETHOD(Submit)(
		/* [in] */ LONG Flags,
		/* [in] */ BSTR const strRequest,
		/* [in] */ BSTR const strAttributes,
		/* [in] */ BSTR const strConfig,
		/* [out, retval] */ LONG __RPC_FAR *pDisposition);

    STDMETHOD(RetrievePending)(
		/* [in] */ LONG RequestId,
		/* [in] */ BSTR const strConfig,
		/* [out, retval] */ LONG __RPC_FAR *pDisposition);

    STDMETHOD(GetLastStatus)(
		/* [out, retval] */ LONG __RPC_FAR *pLastStatus);

    STDMETHOD(GetRequestId)(
		/* [out, retval] */ LONG __RPC_FAR *pRequestId);

    STDMETHOD(GetDispositionMessage)(
		/* [out, retval] */ BSTR __RPC_FAR *pstrDispositionMessage);

    STDMETHOD(GetCACertificate)(
		/* [in] */ LONG fExchangeCertificate,
		/* [in] */ BSTR const strConfig,
		/* [in] */ LONG Flags,
		/* [out, retval] */ BSTR __RPC_FAR *pstrCACertificate);

    STDMETHOD(GetCertificate)(
		/* [in] */ LONG Flags,
		/* [out, retval] */ BSTR __RPC_FAR *pstrCertificate);

// ICertRequest2
public:
    STDMETHOD(GetIssuedCertificate)( 
		/* [in] */ const BSTR strConfig,
		/* [in] */ LONG RequestId,
		/* [in] */ const BSTR strSerialNumber,
		/* [out, retval] */ LONG __RPC_FAR *pDisposition);
        
    STDMETHOD(GetErrorMessageText)( 
		/* [in] */ LONG hrMessage,
		/* [in] */ LONG Flags,
		/* [out, retval] */ BSTR __RPC_FAR *pstrErrorMessageText);
        
    STDMETHOD(GetCAProperty)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ LONG PropId,		// CR_PROP_*
		/* [in] */ LONG PropIndex,
		/* [in] */ LONG PropType,	// PROPTYPE_*
		/* [in] */ LONG Flags,		// CR_OUT_*
		/* [out, retval] */ VARIANT *pvarPropertyValue);

    STDMETHOD(GetCAPropertyFlags)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ LONG PropId,		// CR_PROP_*
		/* [out, retval] */ LONG *pPropFlags);

    STDMETHOD(GetCAPropertyDisplayName)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ LONG PropId,		// CR_PROP_*
		/* [out, retval] */ BSTR *pstrDisplayName);

    STDMETHOD(GetFullResponseProperty)(
		/* [in] */ LONG PropId,		// FR_PROP_*
		/* [in] */ LONG PropIndex,
		/* [in] */ LONG PropType,	// PROPTYPE_*
		/* [in] */ LONG Flags,		// CR_OUT_*
		/* [out, retval] */ VARIANT *pvarPropertyValue);

private:
    HRESULT _OpenRPCConnection(
		IN WCHAR const *pwszConfig,
		OUT BOOL *pfNewConnection,
		OUT WCHAR const **ppwszAuthority);

    HRESULT _OpenConnection(
		IN BOOL fRPC,
		IN WCHAR const *pwszConfig,
		IN DWORD RequiredVersion,
		OUT WCHAR const **ppwszAuthority);

    VOID _CloseConnection();

    VOID _InitCAPropInfo();
    VOID _CleanupCAPropInfo();

    VOID _Cleanup();
    VOID _CleanupOldConnection();

    HRESULT _FindCAPropInfo(
		IN BSTR const strConfig,
		IN LONG PropId,
		OUT CAPROP const **ppcap);

    HRESULT _RequestCertificate(
		IN LONG Flags,
		IN LONG RequestId,
		OPTIONAL IN BSTR const strRequest,
		OPTIONAL IN BSTR const strAttributes,
		OPTIONAL IN WCHAR const *pwszSerialNumber,
		IN BSTR const strConfig,
		IN DWORD RequiredVersion,
		OUT LONG *pDisposition);

    HRESULT _FindIssuedCertificate(
		OPTIONAL IN BYTE const *pbCertHash,
		IN DWORD cbCertHash,
		OUT CERT_CONTEXT const **ppccIssued);

    HRESULT _BuildIssuedCertificateChain(
		OPTIONAL IN BYTE const *pbCertHash,
		IN DWORD cbCertHash,
		IN BOOL fIncludeCRLs,
		OUT BYTE **ppbCertChain,
		OUT DWORD *pcbCertChain);

    HRESULT _SetErrorInfo(
		IN HRESULT hrError,
		IN WCHAR const *pwszDescription);

    DWORD	    m_dwServerVersion;
    ICertRequestD2 *m_pICertRequestD;
    handle_t        m_hRPCCertServer;

    LONG            m_LastStatus;
    LONG            m_RequestId;
    LONG            m_Disposition;
    WCHAR          *m_pwszDispositionMessage;

    BYTE           *m_pbRequest;
    LONG            m_cbRequest;

    BYTE           *m_pbCert;
    LONG            m_cbCert;

    BYTE           *m_pbCertificateChain;
    LONG            m_cbCertificateChain;

    BYTE           *m_pbFullResponse;
    LONG            m_cbFullResponse;

    HCERTSTORE      m_hStoreResponse;
    XCMCRESPONSE   *m_rgResponse;
    DWORD	    m_cResponse;

    BYTE           *m_pbCACertState;
    DWORD           m_cbCACertState;

    BYTE           *m_pbCRLState;
    DWORD           m_cbCRLState;

    CAPROP         *m_pCAPropInfo;
    LONG	    m_cCAPropInfo;
    CAINFO	   *m_pCAInfo;
    DWORD	    m_cbCAInfo;

    WCHAR          *m_pwszServerName;

    INT             m_rpcAuthProtocol;

    BYTE           *m_pbKRACertState;
    DWORD           m_cbKRACertState;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certcli\resource.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1997 - 1999
//
// File:        resource.h
//
// Contents:    CertCli implementation
//
//---------------------------------------------------------------------------

#define IDS_COLUMN_REQUESTID				101
#define IDS_COLUMN_REQUESTRAWREQUEST			102
#define IDS_COLUMN_REQUESTRAWOLDCERTIFICATE		103
#define IDS_COLUMN_REQUESTATTRIBUTES			104
#define IDS_COLUMN_REQUESTTYPE				105
#define IDS_COLUMN_REQUESTFLAGS				106
#define IDS_COLUMN_REQUESTSTATUS			107
#define IDS_COLUMN_REQUESTSTATUSCODE			108
#define IDS_COLUMN_REQUESTDISPOSITION			109
#define IDS_COLUMN_REQUESTDISPOSITIONMESSAGE		110
#define IDS_COLUMN_REQUESTSUBMITTEDWHEN			111
#define IDS_COLUMN_REQUESTRESOLVEDWHEN			112
#define IDS_COLUMN_REQUESTREVOKEDWHEN			113
#define IDS_COLUMN_REQUESTREVOKEDEFFECTIVEWHEN		114
#define IDS_COLUMN_REQUESTREVOKEDREASON			115
#define IDS_COLUMN_REQUESTERNAME			116
#define IDS_COLUMN_REQUESTERADDRESS			117

#define IDS_COLUMN_REQUESTDISTINGUISHEDNAME		118
#define IDS_COLUMN_REQUESTRAWNAME			119
#define IDS_COLUMN_REQUESTNAMETYPE			120
#define IDS_COLUMN_REQUESTCOUNTRY			121
#define IDS_COLUMN_REQUESTORGANIZATION			122
#define IDS_COLUMN_REQUESTORGUNIT			123
#define IDS_COLUMN_REQUESTCOMMONNAME			124
#define IDS_COLUMN_REQUESTLOCALITY			125
#define IDS_COLUMN_REQUESTSTATE				126
#define IDS_COLUMN_REQUESTTITLE				127
#define IDS_COLUMN_REQUESTGIVENNAME			128
#define IDS_COLUMN_REQUESTINITIALS			129
#define IDS_COLUMN_REQUESTSURNAME			130
#define IDS_COLUMN_REQUESTDOMAINCOMPONENT		131
#define IDS_COLUMN_REQUESTEMAIL				132
#define IDS_COLUMN_REQUESTSTREETADDRESS			133

#define IDS_COLUMN_CERTIFICATEREQUESTID			134
#define IDS_COLUMN_CERTIFICATERAWCERTIFICATE		135
#define IDS_COLUMN_CERTIFICATECERTIFICATEHASH		136
#define IDS_COLUMN_CERTIFICATETYPE			137
#define IDS_COLUMN_CERTIFICATESERIALNUMBER		138
#define IDS_COLUMN_CERTIFICATEISSUERNAMEID		139
#define IDS_COLUMN_CERTIFICATENOTBEFOREDATE		140
#define IDS_COLUMN_CERTIFICATENOTAFTERDATE		141
#define IDS_COLUMN_CERTIFICATERAWPUBLICKEY		142
#define IDS_COLUMN_CERTIFICATEPUBLICKEYALGORITHM	143
#define IDS_COLUMN_CERTIFICATERAWPUBLICKEYALGORITHMPARAMETERS	144

#define IDS_COLUMN_CERTIFICATEDISTINGUISHEDNAME		145
#define IDS_COLUMN_CERTIFICATERAWNAME			146
#define IDS_COLUMN_CERTIFICATENAMETYPE			147
#define IDS_COLUMN_CERTIFICATECOUNTRY			148
#define IDS_COLUMN_CERTIFICATEORGANIZATION		149
#define IDS_COLUMN_CERTIFICATEORGUNIT			150
#define IDS_COLUMN_CERTIFICATECOMMONNAME		151
#define IDS_COLUMN_CERTIFICATELOCALITY			152
#define IDS_COLUMN_CERTIFICATESTATE			153
#define IDS_COLUMN_CERTIFICATETITLE			154
#define IDS_COLUMN_CERTIFICATEGIVENNAME			155
#define IDS_COLUMN_CERTIFICATEINITIALS			156
#define IDS_COLUMN_CERTIFICATESURNAME			157
#define IDS_COLUMN_CERTIFICATEDOMAINCOMPONENT		158
#define IDS_COLUMN_CERTIFICATEEMAIL			159
#define IDS_COLUMN_CERTIFICATESTREETADDRESS		160
#define IDS_COLUMN_CERTIFICATEUNSTRUCTUREDNAME		161
#define IDS_COLUMN_CERTIFICATEUNSTRUCTUREDADDRESS	162

#define IDS_COLUMN_REQUESTUNSTRUCTUREDNAME		163
#define IDS_COLUMN_REQUESTUNSTRUCTUREDADDRESS		164
#define IDS_COLUMN_REQUESTDEVICESERIALNUMBER		165
#define IDS_COLUMN_CERTIFICATEDEVICESERIALNUMBER	166
#define IDS_FILESHARE_REMARK				167
#define IDS_COLUMN_CERTIFICATERAWSMIMECAPABILITIES	168

#define IDS_COLUMN_EXTREQUESTID				169
#define IDS_COLUMN_EXTNAME				170
#define IDS_COLUMN_EXTFLAGS				171
#define IDS_COLUMN_EXTRAWVALUE				172

#define IDS_COLUMN_ATTRIBREQUESTID			173
#define IDS_COLUMN_ATTRIBNAME				174
#define IDS_COLUMN_ATTRIBVALUE				175

#define IDS_COLUMN_CRLROWID				176
#define IDS_COLUMN_CRLNUMBER				177
#define IDS_COLUMN_CRLMINBASE				178
#define IDS_COLUMN_CRLNAMEID				179
#define IDS_COLUMN_CRLCOUNT				180
#define IDS_COLUMN_CRLTHISUPDATE			181
#define IDS_COLUMN_CRLNEXTUPDATE			182
#define IDS_COLUMN_CRLTHISPUBLISH			183
#define IDS_COLUMN_CRLNEXTPUBLISH			184
#define IDS_COLUMN_CRLEFFECTIVE				185
#define IDS_COLUMN_CRLPROPAGATIONCOMPLETE		186
#define IDS_COLUMN_CRLRAWCRL				187

#define IDS_CAPROP_FILEVERSION				188
#define IDS_CAPROP_PRODUCTVERSION			189
#define IDS_CAPROP_EXITCOUNT				190
#define IDS_CAPROP_EXITDESCRIPTION			191
#define IDS_CAPROP_POLICYDESCRIPTION			192
#define IDS_CAPROP_CANAME				193
#define IDS_CAPROP_SANITIZEDCANAME			194
#define IDS_CAPROP_SHAREDFOLDER				195
#define IDS_CAPROP_PARENTCA				196

#define IDS_CAPROP_CATYPE				197
#define IDS_CAPROP_CASIGCERTCOUNT			198
#define IDS_CAPROP_CASIGCERT				199
#define IDS_CAPROP_CASIGCERTCHAIN			200
#define IDS_CAPROP_CAXCHGCERTCOUNT			201
#define IDS_CAPROP_CAXCHGCERT				202
#define IDS_CAPROP_CAXCHGCERTCHAIN			203
#define IDS_CAPROP_BASECRL				204
#define IDS_CAPROP_DELTACRL				205
#define IDS_CAPROP_CACERTSTATE				206
#define IDS_CAPROP_CRLSTATE				207
#define IDS_CAPROP_CAPROPIDMAX				208

#define IDS_COLUMN_CERTIFICATESUBJECTKEYIDENTIFIER	209

#define IDS_UNKNOWN_ERROR_CODE				210
#define IDS_E_UNEXPECTED				211

#define IDS_SETUP_ERROR_EXPECTED_SECTION_NAME		212
#define IDS_SETUP_ERROR_BAD_SECTION_NAME_LINE		213
#define IDS_SETUP_ERROR_SECTION_NAME_TOO_LONG		214
#define IDS_SETUP_ERROR_GENERAL_SYNTAX			215

#define IDS_SETUP_ERROR_WRONG_INF_STYLE			216
#define IDS_SETUP_ERROR_SECTION_NOT_FOUND		217
#define IDS_SETUP_ERROR_LINE_NOT_FOUND			218

#define IDS_COLUMN_REQUESTRAWARCHIVEDKEY		219
#define IDS_COLUMN_REQUESTKEYRECOVERYHASHES		220

#define IDS_CAPROP_DNSNAME				221
#define IDS_COLUMN_PROPCERTIFICATETEMPLATE		222
#define IDS_COLUMN_REQUESTSIGNERPOLICIES		223
#define IDS_COLUMN_REQUESTSIGNERAPPLICATIONPOLICIES	224
#define IDS_COLUMN_PROPCERTIFICATEENROLLMENTFLAGS	225
#define IDS_COLUMN_PROPCERTIFICATEGENERALFLAGS		226
#define IDS_COLUMN_CERTIFICATEPUBLICKEYLENGTH		227
#define IDS_CAPROP_KRACERTUSEDCOUNT			228
#define IDS_CAPROP_KRACERTCOUNT				229
#define IDS_CAPROP_KRACERT				230
#define IDS_CAPROP_KRACERTSTATE				231
#define IDS_CAPROP_ROLESEPARATIONENABLED		232
#define IDS_CAPROP_ADVANCEDSERVER			233
#define IDS_COLUMN_CRLLASTPUBLISHED			234
#define IDS_COLUMN_CRLPUBLISHATTEMPTS			235
#define IDS_COLUMN_CRLPUBLISHFLAGS			236
#define IDS_COLUMN_CRLPUBLISHSTATUSCODE			237
#define IDS_COLUMN_CRLPUBLISHERROR			238
#define IDS_COLUMN_CALLERNAME				239
#define IDS_CAPROP_TEMPLATES				240
#define IDS_CAPROP_BASECRLPUBLISHSTATUS			241
#define IDS_CAPROP_DELTACRLPUBLISHSTATUS		242
#define IDS_CAPROP_CASIGCERTCRLCHAIN			243
#define IDS_CAPROP_CAXCHGCERTCRLCHAIN			244
#define IDS_COLUMN_CERTIFICATEUPN			245
#define IDS_E_DATA_MISALIGNMENT				246
#define IDS_CAPROP_CACERTSTATUSCODE			247
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certcli\request.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        request.cpp
//
// Contents:    Cert Server client implementation
//
// History:     24-Aug-96       vich created
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include <objbase.h>
#include "certsrvd.h"
#include "csdisp.h"
#include "certrpc.h"
#include <certca.h>

#include "request.h"

#define __dwFILE__	__dwFILE_CERTCLI_REQUEST_CPP__


#define CR_RPC_CANCEL_TIMEOUT 5
#define CR_RPC_REQUEST_TIMEOUT 60000 /* 60 seconds for the request timeout */



typedef struct _RPC_TIMEOUT_CONTEXT
{
    HANDLE hWait;
    HANDLE hEvent;
    HANDLE hThread;
    HRESULT hrRpcError;
} RPC_TIMEOUT_CONTEXT, *PRPC_TIMEOUT_CONTEXT;

typedef struct _WZR_RPC_BINDING_LIST
{
    LPWSTR pszProtSeq;
    LPWSTR pszEndpoint;
} WZR_RPC_BINDING_LIST;

WZR_RPC_BINDING_LIST g_awzrBindingList[] =
{
    { L"ncacn_ip_tcp", NULL },
    { L"ncacn_np", L"\\pipe\\cert" }
};

INT g_cwzrBindingList = sizeof(g_awzrBindingList)/sizeof(g_awzrBindingList[0]);

typedef struct _WZR_RPC_ATHN_LIST
{
    DWORD dwAuthnLevel;
    DWORD dwAuthnService;
} WZR_RPC_ATHN_LIST;

WZR_RPC_ATHN_LIST g_awzrAthnList[] =
{
    { RPC_C_AUTHN_LEVEL_PKT_INTEGRITY, RPC_C_AUTHN_GSS_NEGOTIATE},
    { RPC_C_AUTHN_LEVEL_NONE, RPC_C_AUTHN_NONE }
};

INT g_cwzrAthnList = sizeof(g_awzrAthnList)/sizeof(g_awzrAthnList[0]);

HRESULT
crRegisterRPCCallTimeout(
    IN DWORD dwMilliseconds,
    OUT PRPC_TIMEOUT_CONTEXT pTimeout);

HRESULT
crCloseRPCCallTimeout(
    IN  PRPC_TIMEOUT_CONTEXT pTimeout);



HRESULT
crSetRPCSecurity(
    IN handle_t hRPCCertServer,
    IN OUT INT *prpcAuthProtocol)
{
    HRESULT hr = S_OK;
    LPWSTR pwszCAPrinceName = NULL;
    INT rpcAuthProtocol = *prpcAuthProtocol;

    // Set the RPC connect as the SNEGO connect, which can authenticate
    // a machine if supported by the system.
    // Don't need to check the return value since not supported by NT4/Win9x.

    if (rpcAuthProtocol >= g_cwzrAthnList)
    {
        hr = RPC_S_UNKNOWN_AUTHN_SERVICE;
        goto error;
    }
    for ( ; rpcAuthProtocol < g_cwzrAthnList; rpcAuthProtocol++)
    {
        pwszCAPrinceName = NULL;
        if (RPC_C_AUTHN_NONE != g_awzrAthnList[rpcAuthProtocol].dwAuthnService)
        {
            hr = RpcMgmtInqServerPrincName(
			    hRPCCertServer,
			    g_awzrAthnList[rpcAuthProtocol].dwAuthnService,
			    &pwszCAPrinceName);
            if (hr == RPC_S_UNKNOWN_AUTHN_SERVICE)
            {
                continue;
            }
        }

        hr = RpcBindingSetAuthInfo(
			    hRPCCertServer,
			    pwszCAPrinceName,
			    g_awzrAthnList[rpcAuthProtocol].dwAuthnLevel,
			    g_awzrAthnList[rpcAuthProtocol].dwAuthnService,
			    NULL,
			    RPC_C_AUTHZ_NONE);

        if (NULL != pwszCAPrinceName)
        {
            RpcStringFree(&pwszCAPrinceName);
        }
        if (hr != RPC_S_UNKNOWN_AUTHN_SERVICE)
        {
            break;
        }
    }

error:
    *prpcAuthProtocol = rpcAuthProtocol;
    return(hr);
}


HRESULT
crOpenRPCConnection(
    IN WCHAR const *pwszServerName,
    IN OUT INT *prpcAuthProtocol,
    OUT handle_t *phRPCCertServer)
{
    HRESULT hr = S_OK;
    INT i;
    WCHAR *pwszStringBinding = NULL;

    for (i = 0; i < g_cwzrBindingList; i++)
    {
	if (RPC_S_OK != RpcNetworkIsProtseqValid(
				    g_awzrBindingList[i].pszProtSeq))
	{
	    continue;
	}

	hr = RpcStringBindingCompose(
			      NULL,
			      g_awzrBindingList[i].pszProtSeq,
			      const_cast<WCHAR *>(pwszServerName),
			      g_awzrBindingList[i].pszEndpoint,
			      NULL,
			      &pwszStringBinding);
	if (S_OK != hr)
	{
	    continue;
	}

	hr = RpcBindingFromStringBinding(
				    pwszStringBinding,
				    phRPCCertServer);
	if (NULL != pwszStringBinding)
	{
	    RpcStringFree(&pwszStringBinding);
	}
	if (S_OK != hr)
	{
	    continue;
	}

	hr = RpcEpResolveBinding(
			    *phRPCCertServer,
			    ICertPassage_v0_0_c_ifspec);
	if (S_OK == hr)
	{
	    break;
	}
    }
    _JumpIfError(hr, error, "RPC Resolve Binding Loop");

    hr = crSetRPCSecurity(*phRPCCertServer, prpcAuthProtocol);
    _JumpIfError(hr, error, "_SetRPCSecurity");

error:
    if (NULL != pwszStringBinding)
    {
        RpcStringFree(&pwszStringBinding);
    }
    return(hr);
}


VOID
crCloseRPCConnection(
    IN OUT handle_t *phRPCCertServer)
{
    if (NULL != *phRPCCertServer)
    {
        RpcBindingFree(phRPCCertServer);
        *phRPCCertServer = NULL;
    }
}


HRESULT
crCertServerRequest(
    IN handle_t hRPCCertServer,
    IN OUT INT *prpcAuthProtocol,
    IN DWORD Flags,
    IN WCHAR const *pwszAuthority,
    IN OUT DWORD *pRequestId,
    OUT DWORD *pDisposition,
    IN CERTTRANSBLOB const *pctbAttrib,
    IN CERTTRANSBLOB const *pctbSerial,
    IN CERTTRANSBLOB const *pctbRequest,
    OUT CERTTRANSBLOB *pctbCertChain,
    OUT CERTTRANSBLOB *pctbCert,
    OUT CERTTRANSBLOB *pctbDispositionMessage)
{
    HRESULT hr;

    RPC_TIMEOUT_CONTEXT Timeout = {NULL, NULL, NULL, S_OK};
    
    do
    {
	// Midl_user_allocate registers memory in RPC case

        hr = crRegisterRPCCallTimeout(CR_RPC_REQUEST_TIMEOUT, &Timeout);
	_JumpIfError(hr, error, "crRegisterRPCCallTimeout");

        __try
        {
            hr = CertServerRequest(
		            hRPCCertServer,
		            Flags,
		            pwszAuthority,
		            pRequestId,
		            pDisposition,
		            pctbAttrib,
		            pctbRequest,
		            pctbCertChain,
		            pctbCert,
		            pctbDispositionMessage);
        }
        __except(
	    HRESULT_FROM_WIN32(RPC_S_CALL_CANCELLED) == myHEXCEPTIONCODE()?
		EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
        {
            hr = Timeout.hrRpcError;
        }

        crCloseRPCCallTimeout(&Timeout);

        _PrintIfError(hr, "CertServerRequest");

        if (hr == RPC_S_UNKNOWN_AUTHN_SERVICE)
        {
            (*prpcAuthProtocol)++;
            hr = crSetRPCSecurity(hRPCCertServer, prpcAuthProtocol);
            if (hr == RPC_S_UNKNOWN_AUTHN_SERVICE)
            {
                break;
            }
            if (hr == S_OK)
            {
                continue;
            }
        }
    } while (hr == RPC_S_UNKNOWN_AUTHN_SERVICE);
error:
    return(hr);
}


HRESULT
crRequestCertificate(
    IN DWORD Flags,
    OPTIONAL IN BYTE const *pbRequest,
    IN DWORD cbRequest,
    IN DWORD RequestId,
    OPTIONAL IN WCHAR const *pwszRequestAttributes,
    OPTIONAL IN WCHAR const *pwszSerialNumber,
    IN WCHAR const *pwszServerName,
    IN WCHAR const *pwszAuthority,
    OUT CERTSERVERENROLL **ppcsEnroll) // free via CertServerFreeMemory
{
    HRESULT hr;
    handle_t hRPCCertServer = NULL;
    INT rpcAuthProtocol = 0;
    CERTTRANSBLOB ctbRequest;
    CERTTRANSBLOB ctbAttrib;
    CERTTRANSBLOB ctbSerial;
    CERTTRANSBLOB ctbCert = { 0, NULL };
    CERTTRANSBLOB ctbCertChain = { 0, NULL };
    CERTTRANSBLOB ctbDispositionMessage = { 0, NULL };
    CERTSERVERENROLL csEnroll;
    CERTSERVERENROLL *pcsEnroll = NULL;
    BYTE *pbOut;
    DWORD cbAlloc;

    if (NULL == pwszServerName || NULL == pwszAuthority || NULL == ppcsEnroll)
    {
        hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppcsEnroll = NULL;

    ZeroMemory(&csEnroll, sizeof(csEnroll));
    csEnroll.hrLastStatus = E_FAIL;
    csEnroll.Disposition = CR_DISP_ERROR;
    csEnroll.RequestId = RequestId;

    ctbRequest.pb = const_cast<BYTE *>(pbRequest);
    ctbRequest.cb = cbRequest;

    ctbAttrib.pb = (BYTE *) pwszRequestAttributes;
    ctbAttrib.cb = 0;
    if (NULL != pwszRequestAttributes)
    {
	ctbAttrib.cb = (wcslen(pwszRequestAttributes) + 1) * sizeof(WCHAR);
    }

    ctbSerial.pb = (BYTE *) pwszSerialNumber;
    ctbSerial.cb = 0;
    if (NULL != pwszSerialNumber)
    {
	ctbSerial.cb = (wcslen(pwszSerialNumber) + 1) * sizeof(WCHAR);
    }

    hr = crOpenRPCConnection(pwszServerName, &rpcAuthProtocol, &hRPCCertServer);
    _JumpIfError(hr, error, "crOpenRPCConnection");

    hr = crCertServerRequest(
			hRPCCertServer,
			&rpcAuthProtocol,
			Flags,
			pwszAuthority,
			&csEnroll.RequestId,
			&csEnroll.Disposition,
			&ctbAttrib,
			&ctbSerial,
			&ctbRequest,
			&ctbCertChain,
			&ctbCert,
			&ctbDispositionMessage);
    _JumpIfError(hr, error, "crCertServerRequest");

    csEnroll.hrLastStatus = hr;
    if (FAILED(csEnroll.Disposition))
    {
	csEnroll.hrLastStatus = csEnroll.Disposition;
	csEnroll.Disposition = CR_DISP_DENIED;
    }

    cbAlloc = sizeof(*pcsEnroll) +
		DWORDROUND(ctbCert.cb) +
		DWORDROUND(ctbCertChain.cb) +
		DWORDROUND(ctbDispositionMessage.cb);

    pcsEnroll = (CERTSERVERENROLL *) LocalAlloc(LMEM_FIXED, cbAlloc);
    if (NULL == pcsEnroll)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    *pcsEnroll = csEnroll;	// structure copy

    pbOut = (BYTE *) &pcsEnroll[1];
    if (0 != ctbCert.cb)
    {
	CSASSERT(NULL != ctbCert.pb);
	pcsEnroll->pbCert = pbOut;
	pcsEnroll->cbCert = ctbCert.cb;
	CopyMemory(pbOut, ctbCert.pb, ctbCert.cb);
	pbOut += DWORDROUND(ctbCert.cb);
    }
    if (0 != ctbCertChain.cb)
    {
	CSASSERT(NULL != ctbCertChain.pb);
	pcsEnroll->pbCertChain = pbOut;
	pcsEnroll->cbCertChain = ctbCertChain.cb;
	CopyMemory(pbOut, ctbCertChain.pb, ctbCertChain.cb);
	pbOut += DWORDROUND(ctbCertChain.cb);
    }
    if (0 != ctbDispositionMessage.cb)
    {
	CSASSERT(NULL != ctbDispositionMessage.pb);
	pcsEnroll->pwszDispositionMessage = (WCHAR *) pbOut;
	CopyMemory(pbOut, ctbDispositionMessage.pb, ctbDispositionMessage.cb);
	pbOut += DWORDROUND(ctbDispositionMessage.cb);
    }
    CSASSERT(pbOut == &((BYTE *) pcsEnroll)[cbAlloc]);

    *ppcsEnroll = pcsEnroll;

error:
    if (NULL != ctbCert.pb)
    {
	MIDL_user_free(ctbCert.pb);
    }
    if (NULL != ctbCertChain.pb)
    {
	MIDL_user_free(ctbCertChain.pb);
    }
    if (NULL != ctbDispositionMessage.pb)
    {
	MIDL_user_free(ctbDispositionMessage.pb);
    }
    crCloseRPCConnection(&hRPCCertServer);
    return(hr);
}


HRESULT
CertServerSubmitRequest(
    IN DWORD Flags,
    IN BYTE const *pbRequest,
    IN DWORD cbRequest,
    OPTIONAL IN WCHAR const *pwszRequestAttributes,
    IN WCHAR const *pwszServerName,
    IN WCHAR const *pwszAuthority,
    OUT CERTSERVERENROLL **ppcsEnroll) // free via CertServerFreeMemory
{
    HRESULT hr;

    if (NULL == pbRequest)
    {
        hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (CR_IN_BINARY != (CR_IN_ENCODEMASK & Flags))
    {
	hr = E_INVALIDARG;
        _JumpError(hr, error, "not CR_IN_BINARY");
    }
    hr = crRequestCertificate(
			Flags,
			pbRequest,
			cbRequest,
			0,		// RequestId
			pwszRequestAttributes,
			NULL,		// pwszSerialNumber
			pwszServerName,
			pwszAuthority,
			ppcsEnroll);
    _JumpIfError(hr, error, "crRequestCertificate");

error:
    return(hr);
}


HRESULT
CertServerRetrievePending(
    IN DWORD RequestId,
    OPTIONAL IN WCHAR const *pwszSerialNumber,
    IN WCHAR const *pwszServerName,
    IN WCHAR const *pwszAuthority,
    OUT CERTSERVERENROLL **ppcsEnroll) // free via CertServerFreeMemory
{
    HRESULT hr;

    if ((0 == RequestId) ^ (NULL != pwszSerialNumber))
    {
	hr = E_INVALIDARG;
        _JumpError(hr, error, "use RequestId OR pwszSerialNumber");
    }
    hr = crRequestCertificate(
			0,		// Flags
			NULL,		// pbRequest
			0,		// cbRequest
			RequestId,
			NULL,		// pwszRequestAttributes
			pwszSerialNumber,
			pwszServerName,
			pwszAuthority,
			ppcsEnroll);
    _JumpIfError(hr, error, "crRequestCertificate");

error:
    return(hr);
}


VOID
CertServerFreeMemory(
    IN VOID *pv)
{
    LocalFree(pv);
}


//+--------------------------------------------------------------------------
// CCertRequest::~CCertRequest -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertRequest::~CCertRequest()
{
    _Cleanup();
}


//+--------------------------------------------------------------------------
// CCertRequest::_CleanupOldConnection -- free memory
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

VOID
CCertRequest::_CleanupOldConnection()
{
    // bytes returned from interfaces are MIDL_user_allocate

    if (NULL != m_pwszDispositionMessage)
    {
        MIDL_user_free(m_pwszDispositionMessage);
	m_pwszDispositionMessage = NULL;
    }
    if (NULL != m_pbCert)
    {
        MIDL_user_free(m_pbCert);
	m_pbCert = NULL;
    }
    if (NULL != m_pbCertificateChain)
    {
        MIDL_user_free(m_pbCertificateChain);
	m_pbCertificateChain = NULL;
    }
    if (NULL != m_pbFullResponse)
    {
        MIDL_user_free(m_pbFullResponse);
	m_pbFullResponse = NULL;
    }
    if (NULL != m_pbRequest)
    {
    	LocalFree(m_pbRequest);
    	m_pbRequest = NULL;
    }
    if (NULL != m_pCAPropInfo)
    {
	MIDL_user_free(m_pCAPropInfo);
	m_pCAPropInfo = NULL;
    }
    if (NULL != m_rgResponse)
    {
	FreeCMCResponse(m_rgResponse, m_cResponse);
	m_rgResponse = NULL;
    }
    if (NULL != m_hStoreResponse)
    {
	CertCloseStore(m_hStoreResponse, CERT_CLOSE_STORE_CHECK_FLAG);
	m_hStoreResponse = NULL;
    }
    m_cResponse = 0;
    m_LastStatus = S_OK;
    m_RequestId = 0;
    m_Disposition = 0;
    _CleanupCAPropInfo();
}


//+--------------------------------------------------------------------------
// CCertRequest::_Cleanup -- free memory
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

VOID
CCertRequest::_Cleanup()
{
    _CloseConnection();
    _CleanupOldConnection();
}


//+--------------------------------------------------------------------------
// CCertRequest::_OpenRPCConnection -- establish RPC connection
//
// establish RPC connection
//+--------------------------------------------------------------------------

HRESULT
CCertRequest::_OpenRPCConnection(
    IN WCHAR const *pwszConfig,
    OUT BOOL *pfNewConnection,
    OUT WCHAR const **ppwszAuthority)
{
    HRESULT hr;
    WCHAR *pwszServerName = NULL;
    WCHAR *pwsz;
    DWORD cwc;

    CSASSERT(NULL != pwszConfig && NULL != pfNewConnection);

    *pfNewConnection = FALSE;
    pwsz = wcschr(pwszConfig, L'\\');
    if (NULL == pwsz)
    {
        cwc = wcslen(pwszConfig);
        *ppwszAuthority = &pwszConfig[cwc];
    }
    else
    {
        cwc = SAFE_SUBTRACT_POINTERS(pwsz, pwszConfig);
        *ppwszAuthority = &pwsz[1];
    }
    pwszServerName = (WCHAR *) LocalAlloc(
				    LMEM_FIXED,
				    (cwc + 1) * sizeof(WCHAR));
    if (NULL == pwszServerName)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(pwszServerName, pwszConfig, cwc * sizeof(WCHAR));
    pwszServerName[cwc] = L'\0';

    if (NULL == m_hRPCCertServer ||
        NULL == m_pwszServerName ||
        0 != lstrcmpi(pwszServerName, m_pwszServerName))
    {
        _CloseConnection();
        CSASSERT(NULL == m_pwszServerName);
        m_pwszServerName = pwszServerName;
        pwszServerName = NULL;

	hr = crOpenRPCConnection(
			    m_pwszServerName,
			    &m_rpcAuthProtocol,
			    &m_hRPCCertServer);
        _JumpIfError(hr, error, "crOpenRPCConnection");

	*pfNewConnection = TRUE;
    }
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	_CloseConnection();
	hr = myHError(hr);
    }
    if (NULL != pwszServerName)
    {
        LocalFree(pwszServerName);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertRequest::_OpenConnection -- establish RPC connection
//
//+--------------------------------------------------------------------------

HRESULT
CCertRequest::_OpenConnection(
    IN BOOL fRPC,
    IN WCHAR const *pwszConfig,
    IN DWORD RequiredVersion,
    OUT WCHAR const **ppwszAuthority)
{
    HRESULT hr;
    BOOL fNewConnection = FALSE;

    if (NULL == pwszConfig)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "pwszConfig");
    }
    if (fRPC)
    {
        if (NULL != m_pICertRequestD)
        {
	    _CloseConnection();		// switching to RPC
        }
        hr = _OpenRPCConnection(pwszConfig, &fNewConnection, ppwszAuthority);
        _JumpIfError(hr, error, "_OpenRPCConnection");

	CSASSERT(NULL != m_hRPCCertServer);
	CSASSERT(0 == m_dwServerVersion);
    }
    else
    {
        if (NULL != m_hRPCCertServer)
        {
            _CloseConnection();		// switching to DCOM
        }
	hr = myOpenRequestDComConnection(
			    pwszConfig,
			    ppwszAuthority,
			    &m_pwszServerName,
			    &fNewConnection,
			    &m_dwServerVersion,
			    &m_pICertRequestD);
	_JumpIfError(hr, error, "myOpenRequestDComConnection");

	CSASSERT(NULL != m_pICertRequestD);
	CSASSERT(0 != m_dwServerVersion);
    }
    if (m_dwServerVersion < RequiredVersion)
    {
	hr = RPC_E_VERSION_MISMATCH;
	_JumpError(hr, error, "old server");
    }
    if (fNewConnection)
    {
	_CleanupOldConnection();
    }

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertRequest::_CloseConnection -- release DCOM object
//
//+--------------------------------------------------------------------------

VOID
CCertRequest::_CloseConnection()
{
    crCloseRPCConnection(&m_hRPCCertServer);
    myCloseDComConnection((IUnknown **) &m_pICertRequestD, &m_pwszServerName);
    m_dwServerVersion = 0;
}


//+--------------------------------------------------------------------------
// CCertRequest::Submit -- Submit a cert request and return the disposition.
//
// Submit the passed certificate request to the Certificate Server and retrieve
// the certificate from the server, if it is immediately available.  If the
// returned disposition so indicates, other CCertRequest methods may be called
// to return the certificate or certificate chain to the caller.
//
// All state from previous method calls is cleared.
//
// After the Submit method completes execution, the GetDispositionMessage and
// GetLastStatus methods may be called to retrieve informational disposition
// text and a more specific error code.
//
// Flags contains flags that describe the input data format as defined above.
//
// strRequest points to the input request data, in base64-encoded form.
//
// strAttributes is optional.  When non-NULL, it points to a string containing
// attribute value pairs, one pair per line.  The attribute name and value
// strings may contain any text of the caller's choosing.  Only the syntax of a
// colon-separated attribute name and value string followed by a newline is
// enforced.  Attribute names that are not understood by the Certificate Server
// will be available to Policy Modules, but are otherwise ignored by the
// Certificate Server.
// Example:
//      "Phone: 0424-12-3456\r\nServer: Microsoft Key Manager for IIS 2.0\r\n"
//      "Version: 3\r\nRequestType: Client\r\n"
//
// strConfig points to a string that contains the server name and Certificate
// Authority name.  See the ICertConfig interface.
//
// pDisposition points to the returned disposition of the request as defined
// above. When the request cannot be immediately granted or denied (some off-
// line processing may be required), *pDisposition is set to
// CR_DISP_UNDER_SUBMISSION.  After CR_DISP_UNDER_SUBMISSION is returned for
// the initial request's disposition, the RetrievePending method may be called
// to interrogate the disposition again and to retrieve the certificate if it
// has been issued.  If the returned disposition so indicates, RetrievePending
// will retrieve the certificate and allow the other methods defined here to
// return the certificate to the caller.  If denied, the appropriate
// disposition code will be returned.  If the request has still not been
// processed, CR_DISP_UNDER_SUBMISSION will again be returned by the
// RetrievePending method.
//
// Returns S_OK if the method completed execution.  Errors are indicated by
// the returned disposition.
//+--------------------------------------------------------------------------


STDMETHODIMP
CCertRequest::Submit(
    /* [in] */ LONG Flags,
    /* [in] */ BSTR const strRequest,
    /* [in] */ BSTR const strAttributes,
    /* [in] */ BSTR const strConfig,
    /* [out, retval] */ LONG __RPC_FAR *pDisposition)
{
    HRESULT hr;

    if ((NULL == strRequest) || (NULL == pDisposition))
    {
	hr = E_POINTER;
	_JumpError(hr, error, "strRequest or pDisposition");
    }
    hr = _RequestCertificate(
			Flags,
			0,				// RequestId
			strRequest,
			strAttributes,
			NULL,				// pwszSerialNumber
			strConfig,
			(CR_IN_RPC & Flags)? 0 : 1,	// RequiredVersion
			pDisposition);
    _JumpIfError2(
	    hr,
	    error,
	    "_RequestCertificate",
	    HRESULT_FROM_WIN32(ERROR_INVALID_DATA));

error:
    return(_SetErrorInfo(hr, L"CCertRequest::Submit"));
}


//+--------------------------------------------------------------------------
// CCertRequest::RetrievePending -- Retrieve pending request disposition.
//
// Interrogate the Certificate Server and retrieve the certificate identified
// by the passed RequestId, if it is now available.  If the returned
// disposition so indicates, other CCertRequest methods may be called to return
// the certificate or certificate chain to the caller.
//
// All state from previous method calls is cleared.
//
// After the RetrievePending method completes execution, the
// GetDispositionMessage and GetLastStatus methods may be called to retrieve
// informational disposition text and a more specific error code.
//
// RequestId identifies a previously submitted request.
//
// strConfig points to a string that contains the server name and Certificate
// Authority name.  
//
// pDisposition points to the returned disposition of the pending request.
//
// Returns S_OK if the method completed execution.  Errors are indicated by
// the returned disposition.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertRequest::RetrievePending(
    /* [in] */ LONG RequestId,
    /* [in] */ BSTR const strConfig,
    /* [out, retval] */ LONG __RPC_FAR *pDisposition)
{
    HRESULT hr;
    WCHAR *pwszConfig = strConfig;
    WCHAR *pwszSerialNumber = NULL;

    if (NULL == pDisposition || NULL == strConfig)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL param");
    }

    if (0 == RequestId)
    {
	DWORD cwc;
	
	pwszSerialNumber = wcschr(pwszConfig, L'\\');
	if (NULL != pwszSerialNumber)
	{
	    pwszSerialNumber = wcschr(&pwszSerialNumber[1], L'\\');
	}
	if (NULL == pwszSerialNumber)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Missing SerialNumber");
	}

	cwc = SAFE_SUBTRACT_POINTERS(pwszSerialNumber, pwszConfig);
	pwszSerialNumber++;
	pwszConfig = (WCHAR *) LocalAlloc(
				    LMEM_FIXED, 
				    (cwc + 1) * sizeof(WCHAR));
	if (NULL == pwszConfig)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	CopyMemory(pwszConfig, strConfig, cwc * sizeof(WCHAR));
	pwszConfig[cwc] = L'\0';
    }

    hr = _RequestCertificate(
			0,			// Flags
			RequestId,
			NULL,			// strRequest
			pwszSerialNumber,	// strAttributes
			NULL,			// pwszSerialNumber
			pwszConfig,
			1,			// RequiredVersion
			pDisposition);
    _JumpIfError(hr, error, "_RequestCertificate");

error:
    if (NULL != pwszConfig && strConfig != pwszConfig)
    {
	LocalFree(pwszConfig);
    }
    return(_SetErrorInfo(hr, L"CCertRequest::RetrievePending"));
}


//+--------------------------------------------------------------------------
// CCertRequest::GetIssuedCertificate -- Get an issued Certificate
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertRequest::GetIssuedCertificate(
    /* [in] */ const BSTR strConfig,
    /* [in] */ LONG RequestId,
    /* [in] */ const BSTR strSerialNumber,		// OPTIONAL
    /* [out, retval] */ LONG __RPC_FAR *pDisposition)
{
    HRESULT hr;
    WCHAR const *pwszSerialNumber = NULL;

    if (NULL == pDisposition || NULL == strConfig)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL param");
    }

    // VB callers pass "" instead of NULL, so treat them identically.

    if (NULL != strSerialNumber && L'\0' != *strSerialNumber)
    {
	pwszSerialNumber = strSerialNumber;
    }
    hr = _RequestCertificate(
			0,			// Flags
			RequestId,
			NULL,			// strRequest
			NULL,			// strAttributes
			pwszSerialNumber,	// pwszSerialNumber
			strConfig,
			2,			// RequiredVersion
			pDisposition);
    _JumpIfError(hr, error, "_RequestCertificate");

error:
    return(_SetErrorInfo(hr, L"CCertRequest::GetIssuedCertificate"));
}


//+--------------------------------------------------------------------------
// CCertRequest::_RequestCertificate -- Submit the request
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertRequest::_RequestCertificate(
    IN LONG Flags,
    IN LONG RequestId,
    OPTIONAL IN BSTR const strRequest,
    OPTIONAL IN BSTR const strAttributes,
    OPTIONAL IN WCHAR const *pwszSerialNumber,
    IN BSTR const strConfig,
    IN DWORD RequiredVersion,
    OUT LONG *pDisposition)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;
    WCHAR *pwszAttrib = strAttributes;
    WCHAR *pwszAttribAlloc = NULL;
    BYTE *pbT = NULL;
    CERTTRANSBLOB ctbRequest = { 0, NULL };
    CERTTRANSBLOB ctbCert = { 0, NULL };
    CERTTRANSBLOB ctbCertChain = { 0, NULL };
    CERTTRANSBLOB ctbFullResponse = { 0, NULL };
    CERTTRANSBLOB ctbDispositionMessage = { 0, NULL };
    DWORD adwEncode[] = { CR_IN_BASE64HEADER, CR_IN_BASE64, CR_IN_BINARY };
    DWORD dwEncode;
    DWORD *pdwEncode;
    DWORD cEncode;
    WCHAR *pwszDnsName = NULL;

    if (NULL == pDisposition)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    _Cleanup();
    *pDisposition = CR_DISP_INCOMPLETE;

    hr = _OpenConnection(
		    (CR_IN_RPC & Flags)? TRUE : FALSE,
		    strConfig,
		    RequiredVersion,
		    &pwszAuthority);
    _JumpIfError(hr, error, "_OpenConnection");

    // If a new request, point at the attributes & decode the Base64 request.

    if (NULL != strRequest)
    {
	DWORD cchHeader;
	DWORD cwc;
	WCHAR *pch;

	CSASSERT(CR_IN_BASE64HEADER == CRYPT_STRING_BASE64HEADER);
	CSASSERT(CR_IN_BASE64 == CRYPT_STRING_BASE64);
	CSASSERT(CR_IN_BINARY == CRYPT_STRING_BINARY);

	hr = myGetMachineDnsName(&pwszDnsName);
	_JumpIfError(hr, error, "myGetMachineDnsName");

	dwEncode = CR_IN_ENCODEMASK & Flags;
	switch (dwEncode)
	{
	    case CR_IN_BASE64HEADER:
	    case CR_IN_BASE64:
	    case CR_IN_BINARY:
		cEncode = 1;
		pdwEncode = &dwEncode;
		break;

	    case CR_IN_ENCODEANY:
		cEncode = ARRAYSIZE(adwEncode);
		pdwEncode = adwEncode;
		break;

	    default:
		hr = E_INVALIDARG;
		_JumpError(hr, error, "Flags");
	}
	while (TRUE)
	{
	    hr = DecodeCertString(
			strRequest,
			*pdwEncode,
			&m_pbRequest,
			(DWORD *) &m_cbRequest);
	    if (S_OK == hr)
	    {
		Flags = (~CR_IN_ENCODEMASK & Flags) | *pdwEncode;
		break;
	    }
	    if (1 == cEncode || HRESULT_FROM_WIN32(ERROR_INVALID_DATA) != hr)
	    {
		_JumpError(hr, error, "DecodeCertString");
	    }
	    _PrintErrorStr2(
			hr,
			"DecodeCertString",
			L"CR_IN_ENCODEANY",
			HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
	    cEncode--;
	    pdwEncode++;
	}
	CSASSERT(0 < cEncode);
	CSASSERT(S_OK == hr);

	ctbRequest.pb = m_pbRequest;
	ctbRequest.cb = m_cbRequest;

	cchHeader = 0;
	if (CR_IN_BASE64HEADER == *pdwEncode)
	{
	    DWORD cb;

	    hr = myCryptStringToBinary(
				strRequest,
				wcslen(strRequest),
				CRYPT_STRING_BASE64HEADER,
				&pbT,
				&cb,
				&cchHeader,
				NULL);
	    if (S_OK != hr)
	    {
		cchHeader = 0;
	    }
	}
	cwc = cchHeader;
	if (NULL != pwszAttrib)
	{
	    cwc += 1 + wcslen(pwszAttrib);
	}
	cwc += 1 + WSZARRAYSIZE(wszPROPCERTCLIENTMACHINE) + 1 + wcslen(pwszDnsName);
	pwszAttribAlloc = (WCHAR *) LocalAlloc(
					LMEM_FIXED,
					(cwc + 1) * sizeof(WCHAR));
	if (NULL == pwszAttribAlloc)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "alloc attributes");
	}
	pch = pwszAttribAlloc;
	if (0 != cchHeader)
	{
	    CopyMemory(pch, strRequest, cchHeader * sizeof(WCHAR));
	    pch += cchHeader;
	}
	*pch = L'\0';
	if (NULL != pwszAttrib)
	{
	    *pch++ = L'\n';
	    wcscpy(pch, (WCHAR const *) pwszAttrib);
	}
	wcscat(pch, L"\n" wszPROPCERTCLIENTMACHINE L":");
	wcscat(pch, pwszDnsName);
	CSASSERT(wcslen(pwszAttribAlloc) == cwc);

	pwszAttrib = pwszAttribAlloc;
    }
    m_RequestId = RequestId;

    __try
    {
	Flags |= CR_IN_FULLRESPONSE;
	if (NULL != m_hRPCCertServer)
	{
	    CERTTRANSBLOB ctbAttrib;
	    CERTTRANSBLOB ctbSerial;

	    ctbAttrib.cb = 0;
	    ctbAttrib.pb = (BYTE *) pwszAttrib;
	    if (NULL != pwszAttrib)
	    {
		ctbAttrib.cb = (wcslen(pwszAttrib) + 1) * sizeof(WCHAR);
	    }

	    ctbSerial.cb = 0;
	    ctbSerial.pb = (BYTE *) pwszSerialNumber;
	    if (NULL != pwszSerialNumber)
	    {
		ctbAttrib.cb = (wcslen(pwszSerialNumber) + 1) * sizeof(WCHAR);
	    }

	    hr = crCertServerRequest(
			    m_hRPCCertServer,
			    &m_rpcAuthProtocol,
			    Flags,
			    pwszAuthority,
			    (DWORD *) &m_RequestId,
			    (DWORD *) &m_Disposition,
			    &ctbAttrib,
			    &ctbSerial,
			    &ctbRequest,
			    &ctbCertChain,
			    &ctbCert,
			    &ctbDispositionMessage);
	    _PrintIfError(hr, "crCertServerRequest");
	}
	else
	{
	    if (2 <= m_dwServerVersion)
	    {
		hr = m_pICertRequestD->Request2(
				pwszAuthority,
				Flags,
				pwszSerialNumber,
				(DWORD *) &m_RequestId,
				(DWORD *) &m_Disposition,
				pwszAttrib,
				&ctbRequest,
				&ctbFullResponse,
				&ctbCert,
				&ctbDispositionMessage);
		_PrintIfError(hr, "m_pICertRequestD->Request2");
	    }
	    else
	    {
		Flags &= ~CR_IN_FULLRESPONSE;
		hr = m_pICertRequestD->Request(
				Flags,
				pwszAuthority,
				(DWORD *) &m_RequestId,
				(DWORD *) &m_Disposition,
				pwszAttrib,
				&ctbRequest,
				&ctbCertChain,
				&ctbCert,
				&ctbDispositionMessage);
		_PrintIfError(hr, "m_pICertRequestD->Request");
	    }

	    // Midl_user_allocate registers memory in RPC case

	    if (NULL != ctbCertChain.pb)
	    {
		myRegisterMemAlloc(
				ctbCertChain.pb,
				ctbCertChain.cb,
				CSM_COTASKALLOC);
	    }
	    if (NULL != ctbFullResponse.pb)
	    {
		myRegisterMemAlloc(
				ctbFullResponse.pb,
				ctbFullResponse.cb,
				CSM_COTASKALLOC);
	    }
	    if (NULL != ctbCert.pb)
	    {
		myRegisterMemAlloc(ctbCert.pb, ctbCert.cb, CSM_COTASKALLOC);
	    }
	    if (NULL != ctbDispositionMessage.pb)
	    {
		myRegisterMemAlloc(
			    ctbDispositionMessage.pb,
			    ctbDispositionMessage.cb,
			    CSM_COTASKALLOC);
	    }
	}
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

    if (HRESULT_FROM_WIN32(RPC_X_WRONG_STUB_VERSION) == hr)
    {
	_PrintError(hr, "Compile with MIDL_NO_ROBUST=1 to run on NT 4");
    }

    m_LastStatus = hr;
    _JumpIfError(hr, error, "Request");

    if (FAILED(m_Disposition))
    {
	m_LastStatus = m_Disposition;
	m_Disposition = CR_DISP_DENIED;
    }

    *pDisposition = m_Disposition;
    m_pbCertificateChain = ctbCertChain.pb;     // CoTaskMem*
    m_cbCertificateChain = ctbCertChain.cb;
    m_pbFullResponse = ctbFullResponse.pb;	// CoTaskMem*
    m_cbFullResponse = ctbFullResponse.cb;
    m_pbCert = ctbCert.pb;      		// CoTaskMem*
    m_cbCert = ctbCert.cb;
    m_pwszDispositionMessage = (WCHAR *) ctbDispositionMessage.pb;  // CoTaskMem*
    CSASSERT(0 == (ctbDispositionMessage.cb & (sizeof(WCHAR) - 1)));
    CSASSERT(
	NULL == m_pwszDispositionMessage ||
	L'\0' ==
	m_pwszDispositionMessage[ctbDispositionMessage.cb/sizeof(WCHAR) - 1]);

    if (S_OK == hr && NULL != ctbFullResponse.pb)
    {
	hr = ParseCMCResponse(
			m_pbFullResponse,
			m_cbFullResponse,
			&m_hStoreResponse,
			&m_rgResponse,
			&m_cResponse);
#if 0 // When all Whistler servers are upgraded to return full responses...
	if (S_OK != hr && NULL != m_hRPCCertServer)
#else
	if (S_OK != hr)
#endif
	{
	    // Must be an old RPC cert server that ignored CR_IN_FULLRESPONSE,
	    // and returned a PKCS7 chain instead.

	    CSASSERT(NULL == m_pbCertificateChain);
	    m_pbCertificateChain = m_pbFullResponse;
	    m_cbCertificateChain = m_cbFullResponse;
	    m_pbFullResponse = NULL;
	    m_cbFullResponse = 0;
	    hr = S_OK;
	}
	_JumpIfError(hr, error, "ParseCMCResponse");
    }

error:
    if (NULL != pwszDnsName)
    {
        LocalFree(pwszDnsName);
    }
    if (NULL != pwszAttribAlloc)
    {
	LocalFree(pwszAttribAlloc);
    }
    if (NULL != pbT)
    {
	LocalFree(pbT);
    }
    return(myHError(hr));
}


//+--------------------------------------------------------------------------
// CCertRequest::GetLastStatus -- Get the status of the last request
//
// One of the Submit, RetrievePending or GetCACertificate methods must
// have been previously called for the returned status to be meaningful.
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertRequest::GetLastStatus(
    /* [out, retval] */ LONG __RPC_FAR *pLastStatus)
{
    HRESULT hr;

    if (NULL == pLastStatus)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "pLastStatus");
    }
    *pLastStatus = m_LastStatus;
    hr = S_OK;

error:
    return(_SetErrorInfo(hr, L"CCertRequest::GetLastStatus"));
}


//+--------------------------------------------------------------------------
// CCertRequest::GetRequestId -- Get the RequestId of the last request
//
// The Submit or RetrievePending method must have been previously called for
// the returned RequestId to be meaningful.
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertRequest::GetRequestId(
    /* [out, retval] */ LONG __RPC_FAR *pRequestId)
{
    HRESULT hr;

    if (NULL == pRequestId)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "pRequestId");
    }
    *pRequestId = m_RequestId;
    hr = S_OK;

error:
    return(_SetErrorInfo(hr, L"CCertRequest::GetRequestId"));
}


//+--------------------------------------------------------------------------
// CCertRequest::GetDispositionMessage -- Get the Disposition Message
//
// The Submit or RetrievePending method must have been previously called for
// the returned disposition message text to be meaningful.
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertRequest::GetDispositionMessage(
    /* [out, retval] */ BSTR __RPC_FAR *pstrDispositionMessage)
{
    HRESULT hr = S_OK;

    if (NULL == pstrDispositionMessage)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "pstrDispositionMessage");
    }
    if (NULL != *pstrDispositionMessage)
    {
	SysFreeString(*pstrDispositionMessage);
	*pstrDispositionMessage = NULL;
    }
    if (NULL != m_pwszDispositionMessage)
    {
	if (!ConvertWszToBstr(
			pstrDispositionMessage,
			m_pwszDispositionMessage,
			-1))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "ConvertWszToBstr");
	}
    }

error:
    return(_SetErrorInfo(hr, L"CCertRequest::GetDispositionMessage"));
}


//+--------------------------------------------------------------------------
// CCertRequest::_BuildIssuedCertificateChain -- Build issued cert chain
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertRequest::_BuildIssuedCertificateChain(
    OPTIONAL IN BYTE const *pbCertHash,
    IN DWORD cbCertHash,
    IN BOOL fIncludeCRLs,
    OUT BYTE **ppbCertChain,
    OUT DWORD *pcbCertChain)
{
    HRESULT hr;
    CERT_CONTEXT const *pccIssued = NULL;
    CERT_CHAIN_PARA CertChainPara;
    CERT_CHAIN_CONTEXT const *pCertChainContext = NULL;
    CERT_SIMPLE_CHAIN *pSimpleChain;
    CRYPT_SIGN_MESSAGE_PARA csmp;
    CRYPT_ALGORITHM_IDENTIFIER DigestAlgorithm = { szOID_OIWSEC_sha1, 0, 0 };
    CERT_CONTEXT const **ppcc;
    CRL_CONTEXT const **ppCRL;
    DWORD i;

    *ppbCertChain = NULL;

    // init csmp for empty signature

    ZeroMemory(&csmp, sizeof(csmp));
    csmp.cbSize = sizeof(csmp);
    csmp.dwMsgEncodingType = PKCS_7_ASN_ENCODING;
    //csmp.pSigningCert = NULL;
    csmp.HashAlgorithm = DigestAlgorithm;
    //csmp.cMsgCert = 0;
    //csmp.rgpMsgCert = NULL;
    //csmp.cMsgCrl = 0;
    //csmp.rgpMsgCrl = NULL;

    hr = _FindIssuedCertificate(pbCertHash, cbCertHash, &pccIssued);
    _JumpIfError(hr, error, "_FindIssuedCertificate");

    // build the user cert chain

    ZeroMemory(&CertChainPara, sizeof(CertChainPara));
    CertChainPara.cbSize = sizeof(CertChainPara);

    if (!CertGetCertificateChain(
			    HCCE_LOCAL_MACHINE,
			    pccIssued,
			    NULL,		// pTime
			    m_hStoreResponse,
			    &CertChainPara,
			    fIncludeCRLs? 
				(CERT_CHAIN_REVOCATION_CHECK_END_CERT |
				    CERT_CHAIN_REVOCATION_CHECK_CHAIN) :
				0,
			    NULL,		// pvReserved
			    &pCertChainContext))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertGetCertificateChain");
    }

    // make sure there is at least 1 simple chain

    if (0 == pCertChainContext->cChain)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "No user chain");
    }
    pSimpleChain = pCertChainContext->rgpChain[0];

    csmp.cMsgCert = pSimpleChain->cElement;
    if (0 == csmp.cMsgCert)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "no certs");
    }

    csmp.rgpMsgCert = (CERT_CONTEXT const **) LocalAlloc(
				LMEM_FIXED,
				csmp.cMsgCert * sizeof(csmp.rgpMsgCert[0]));
    if (NULL == csmp.rgpMsgCert)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    if (fIncludeCRLs)
    {
	csmp.rgpMsgCrl = (CRL_CONTEXT const **) LocalAlloc(
				LMEM_FIXED,
				2 * csmp.cMsgCert * sizeof(csmp.rgpMsgCrl[0]));
	if (NULL == csmp.rgpMsgCrl)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }

    ppcc = csmp.rgpMsgCert;
    for (i = 0; i < csmp.cMsgCert; i++)
    {
	*ppcc++ = pSimpleChain->rgpElement[i]->pCertContext;
	if (fIncludeCRLs)
	{
	    CERT_REVOCATION_INFO *pRevocationInfo;

	    pRevocationInfo = pSimpleChain->rgpElement[i]->pRevocationInfo;

	    if (NULL != pRevocationInfo &&
		CCSIZEOF_STRUCT(CERT_REVOCATION_INFO, pCrlInfo) <=
		    pRevocationInfo->cbSize &&
		NULL != pRevocationInfo->pCrlInfo)
	    {
		CERT_REVOCATION_CRL_INFO *pCrlInfo;

		pCrlInfo = pRevocationInfo->pCrlInfo;
		if (NULL != pCrlInfo)
		{
		    if (NULL != pCrlInfo->pBaseCrlContext)
		    {
			csmp.rgpMsgCrl[csmp.cMsgCrl++] = pCrlInfo->pBaseCrlContext;
		    }
		    if (NULL != pCrlInfo->pDeltaCrlContext)
		    {
			csmp.rgpMsgCrl[csmp.cMsgCrl++] = pCrlInfo->pDeltaCrlContext;
		    }
		}
	    }
	}
    }
    CSASSERT(csmp.cMsgCrl <= 2 * csmp.cMsgCert);

    if (!myCryptSignMessage(
			&csmp,
			pccIssued->pbCertEncoded,
			pccIssued->cbCertEncoded,
			CERTLIB_USE_LOCALALLOC,
			ppbCertChain,
			pcbCertChain))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myCryptSignMessage");
    }
    hr = S_OK;

error:
    if (NULL != csmp.rgpMsgCert)
    {
	LocalFree(csmp.rgpMsgCert);
    }
    if (NULL != csmp.rgpMsgCrl)
    {
	LocalFree(csmp.rgpMsgCrl);
    }
    if (NULL != pccIssued)
    {
	CertFreeCertificateContext(pccIssued);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertRequest::_FindIssuedCertificate -- Find Issued cert in store.
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertRequest::_FindIssuedCertificate(
    OPTIONAL IN BYTE const *pbCertHash,
    IN DWORD cbCertHash,
    OUT CERT_CONTEXT const **ppccIssued)
{
    HRESULT hr;
    CRYPT_HASH_BLOB BlobHash;

    *ppccIssued = NULL;

    if (NULL == pbCertHash)
    {
	if (1 < m_cResponse || NULL == m_pbCert)
	{
	    hr = CERTSRV_E_PROPERTY_EMPTY;
	    _JumpError(hr, error, "no cert");
	}
	*ppccIssued = CertCreateCertificateContext(
				    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
				    m_pbCert,
				    m_cbCert);
	if (NULL == *ppccIssued)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertCreateCertificateContext");
	}
    }
    else
    {
	BlobHash.pbData = const_cast<BYTE *>(pbCertHash);
	BlobHash.cbData = cbCertHash;

	*ppccIssued = CertFindCertificateInStore(
				m_hStoreResponse,
				X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
				0,			// dwFindFlags
				CERT_FIND_HASH,
				&BlobHash,		// pvFindPara
				NULL);		// pPrevCertContext
	if (NULL == *ppccIssued)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertFindCertificateInStore");
	}
    }
    hr = S_OK;

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertRequest::GetCertificate -- Get the Certificate encoding as requested
//
// The Submit or RetrievePending method must have previously returned
// CR_DISP_ISSUED, or this method will fail.
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertRequest::GetCertificate(
    /* [in] */ LONG Flags,
    /* [out, retval] */ BSTR __RPC_FAR *pstrCertificate)
{
    HRESULT hr;
    BYTE *pbChain = NULL;
    DWORD cbChain;
    BYTE *pbCert;
    DWORD cbCert;

    if (NULL == pstrCertificate)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "pstrCertificate");
    }
    pbCert = m_pbCert;
    cbCert = m_cbCert;
    if (CR_OUT_CHAIN & Flags)
    {
	pbCert = m_pbCertificateChain;
	cbCert = m_cbCertificateChain;
	if (NULL == m_pbCertificateChain)
	{
	    hr = _BuildIssuedCertificateChain(
					NULL,		// pbCertHash
					0,		// cbCertHash
					0 != (CR_OUT_CRLS & Flags),
					&pbChain,
					&cbChain);
	    _JumpIfError(hr, error, "_BuildIssuedCertificateChain");

	    pbCert = pbChain;
	    cbCert = cbChain;
	}
    }

    CSASSERT(CR_OUT_BASE64HEADER == CRYPT_STRING_BASE64HEADER);
    CSASSERT(CR_OUT_BASE64 == CRYPT_STRING_BASE64);
    CSASSERT(CR_OUT_BINARY == CRYPT_STRING_BINARY);

    hr = EncodeCertString(
		    pbCert,
		    cbCert,
		    ~(CR_OUT_CHAIN | CR_OUT_CRLS) & Flags,
		    pstrCertificate);
    _JumpIfError(hr, error, "EncodeCertString");

error:
    if (NULL != pbChain)
    {
	LocalFree(pbChain);
    }
    hr = myHError(hr);
    return(_SetErrorInfo(hr, L"CCertRequest::GetCertificate"));
}


//+--------------------------------------------------------------------------
// CCertRequest::GetCACertificate -- Get the specified CA Certificate
//
// Interrogate the Certificate Server and retrieve the base64-encoded exchange
// or signature site certificate as indicated by fExchangeCertificate.
//
// All state from previous method calls is cleared.
//
// After the GetCACertificate method completes execution, the GetLastStatus
// method may be called to retrieve a more specific error code.
//
// fExchangeCertificate is TRUE to retrieve the Certificate Server's Exchange
// certificate.  fExchangeCertificate is FALSE to retrieve the Certificate
// Server's Signature site certificate.
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertRequest::GetCACertificate(
    /* [in] */ LONG fExchangeCertificate,
    /* [in] */ BSTR const strConfig,
    /* [in] */ LONG Flags,
    /* [out, retval] */ BSTR __RPC_FAR *pstrCACertificate)
{
    HRESULT hr;
    CERTTRANSBLOB ctbSite = { 0, NULL };
    WCHAR const *pwszAuthority;
    WCHAR const *pwszOut = NULL;
    CAINFO const *pCAInfo;
    BYTE *pbOut;
    BOOL fCallServer;
    DWORD Index;
    WCHAR wszBuf[5 * (10 + 1)];	// enough for 5 numbers

    if (NULL == pstrCACertificate)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "pstrCACertificate");
    }

    fCallServer = TRUE;
    switch (fExchangeCertificate)
    {
	case GETCERT_ERRORTEXT1:
	case GETCERT_ERRORTEXT2:
	    pwszOut = myGetErrorMessageText(
			    Flags,	// error code passed in Flags parm
			    GETCERT_ERRORTEXT2 == fExchangeCertificate);
	    if (NULL == pwszOut)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    Flags = CR_OUT_BINARY;
	    pbOut = (BYTE *) pwszOut;
	    fCallServer = FALSE;
	    break;
    }
    switch (GETCERT_BYINDEXMASK & fExchangeCertificate)
    {
	case GETCERT_CACERTSTATEBYINDEX:
	case GETCERT_CRLSTATEBYINDEX:
	    if (CR_OUT_CHAIN & Flags)
	    {
		hr = E_INVALIDARG;
		_JumpError(hr, error, "Flags");
	    }
	    Index = GETCERT_INDEXVALUEMASK & fExchangeCertificate;
	    fExchangeCertificate &= ~GETCERT_INDEXVALUEMASK;

	    fCallServer =
		NULL == ((GETCERT_CACERTSTATEBYINDEX == fExchangeCertificate)?
			 m_pbCACertState : m_pbCRLState);
	    break;
    }
    if (fCallServer)
    {
	hr = _OpenConnection(FALSE, strConfig, 1, &pwszAuthority);
	_JumpIfError(hr, error, "_OpenConnection");

	if (CR_OUT_CHAIN & Flags)
	{
	    fExchangeCertificate |= GETCERT_CHAIN;
	    if (CR_OUT_CRLS & Flags)
	    {
		fExchangeCertificate |= GETCERT_CRLS;
	    }
	}

	__try
	{
	    hr = m_pICertRequestD->GetCACert(
					fExchangeCertificate,
					pwszAuthority,
					&ctbSite);
	}
	__except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
	{
	}
	_JumpIfError2(
		    hr,
		    error,
		    "GetCACert",
		    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

	// must register this memory
	myRegisterMemAlloc(ctbSite.pb, ctbSite.cb, CSM_COTASKALLOC);
	pbOut = ctbSite.pb;
    }

    CSASSERT(CR_OUT_BASE64HEADER == CRYPT_STRING_BASE64HEADER);
    CSASSERT(CR_OUT_BASE64 == CRYPT_STRING_BASE64);
    CSASSERT(CR_OUT_BINARY == CRYPT_STRING_BINARY);

    switch (fExchangeCertificate)
    {
	// Serialize CAType into a string:
	
	case GETCERT_CATYPE:
	    wsprintf(wszBuf, L"%u", *(ENUM_CATYPES const *) pbOut);
	    pwszOut = wszBuf;
	    pbOut = (BYTE *) pwszOut;
	    break;

	// Serialize CAInfo into a string:
	
	case GETCERT_CAINFO:
	    pCAInfo = (CAINFO const *) pbOut;
	    if (CCSIZEOF_STRUCT(CAINFO, cCASignatureCerts) > pCAInfo->cbSize)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpError(hr, error, "CAINFO size");
	    }
	    wsprintf(
		wszBuf,
		L"%u,%u",
		pCAInfo->CAType,
		pCAInfo->cCASignatureCerts);
	    pwszOut = wszBuf;
	    pbOut = (BYTE *) pwszOut;
	    break;

	case GETCERT_CACERTSTATEBYINDEX:
	case GETCERT_CRLSTATEBYINDEX:
	{
	    BYTE **ppb;
	    DWORD *pcb;
	    
	    if (GETCERT_CACERTSTATEBYINDEX == fExchangeCertificate)
	    {
		ppb = &m_pbCACertState;
		pcb = &m_cbCACertState;
	    }
	    else
	    {
		ppb = &m_pbCRLState;
		pcb = &m_cbCRLState;
	    }
	    if (fCallServer)
	    {
		CSASSERT(NULL == *ppb);
		CSASSERT(NULL != ctbSite.pb);
		*pcb = ctbSite.cb;
		*ppb = ctbSite.pb;
		ctbSite.pb = NULL;
	    }
	    if (Index >= *pcb)
	    {
		hr = E_INVALIDARG;
		_JumpError(hr, error, "Index");
	    }
	    wsprintf(wszBuf, L"%u", (*ppb)[Index]);
	    pwszOut = wszBuf;
	    pbOut = (BYTE *) pwszOut;
	    break;
	}

	// If retrieving a CRL in Base64, use "-----BEGIN X509 CRL..."
	default:
	     if (GETCERT_CRLBYINDEX !=
		 (GETCERT_BYINDEXMASK & fExchangeCertificate))
	     {
		break;
	     }
	     // FALLTHROUGH

	case GETCERT_CURRENTCRL:
	    if (CR_OUT_BASE64HEADER == (~CR_OUT_CHAIN & Flags))
	    {
		Flags = CRYPT_STRING_BASE64X509CRLHEADER;
	    }
	    break;
    }
    hr = EncodeCertString(
			pbOut,
			pbOut == (BYTE *) pwszOut? 
			    wcslen(pwszOut) * sizeof(WCHAR) : ctbSite.cb,
			~CR_OUT_CHAIN & Flags,
			pstrCACertificate);
    _JumpIfError(hr, error, "EncodeCertString");

error:
    m_LastStatus = hr;
    if (NULL != pwszOut && wszBuf != pwszOut)
    {
	LocalFree(const_cast<WCHAR *>(pwszOut));
    }
    if (NULL != ctbSite.pb)
    {
	CoTaskMemFree(ctbSite.pb);
    }
    return(_SetErrorInfo(hr, L"CCertRequest::GetCACertificate"));
}


//+--------------------------------------------------------------------------
// CCertRequest::GetErrorMessageText -- Get error message text
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertRequest::GetErrorMessageText( 
    /* [in] */ LONG hrMessage,
    /* [in] */ LONG Flags,
    /* [out, retval] */ BSTR __RPC_FAR *pstrErrorMessageText)
{
    HRESULT hr;
    WCHAR const *pwszError = NULL;

    if (~CR_GEMT_HRESULT_STRING & Flags)
    {
	hr = E_INVALIDARG;
        _JumpError(hr, error, "not CR_IN_BINARY");
    }

    pwszError = myGetErrorMessageText(
			hrMessage,
			0 != (CR_GEMT_HRESULT_STRING & Flags));
    if (NULL == pwszError)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    if (!ConvertWszToBstr(
		    pstrErrorMessageText,
		    pwszError,
		    -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    hr = S_OK;

error:
    if (NULL != pwszError)
    {
	LocalFree(const_cast<WCHAR *>(pwszError));
    }
    return(_SetErrorInfo(hr, L"CCertRequest::GetErrorMessageText"));
}


// for ICertRequest2::GetFullResponseProperty

CAPROP s_aFRProp[] = {
    { FR_PROP_FULLRESPONSE,           PROPTYPE_BINARY, },
    { FR_PROP_FULLRESPONSENOPKCS7,    PROPTYPE_BINARY, },
    { FR_PROP_STATUSINFOCOUNT,        PROPTYPE_LONG, },
    { FR_PROP_BODYPARTSTRING,         PROPTYPE_STRING | PROPFLAGS_INDEXED, },
    { FR_PROP_STATUS,                 PROPTYPE_LONG | PROPFLAGS_INDEXED, },
    { FR_PROP_STATUSSTRING,           PROPTYPE_STRING | PROPFLAGS_INDEXED, },
    { FR_PROP_OTHERINFOCHOICE,        PROPTYPE_LONG | PROPFLAGS_INDEXED, },
    { FR_PROP_FAILINFO,               PROPTYPE_LONG | PROPFLAGS_INDEXED, },
    { FR_PROP_PENDINFOTOKEN,          PROPTYPE_BINARY | PROPFLAGS_INDEXED, },
    { FR_PROP_PENDINFOTIME,           PROPTYPE_DATE | PROPFLAGS_INDEXED, },
    { FR_PROP_ISSUEDCERTIFICATEHASH,  PROPTYPE_BINARY | PROPFLAGS_INDEXED, },
    { FR_PROP_ISSUEDCERTIFICATE,      PROPTYPE_BINARY | PROPFLAGS_INDEXED, },
    { FR_PROP_ISSUEDCERTIFICATECHAIN, PROPTYPE_BINARY | PROPFLAGS_INDEXED, },
    { FR_PROP_ISSUEDCERTIFICATECRLCHAIN, PROPTYPE_BINARY | PROPFLAGS_INDEXED, },
    { FR_PROP_ENCRYPTEDKEYHASH,	      PROPTYPE_BINARY | PROPFLAGS_INDEXED, },
};


//+--------------------------------------------------------------------------
// CCertRequest::GetFullResponseProperty -- Get CMC Response property
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertRequest::GetFullResponseProperty( 
    /* [in] */ LONG PropId,		// FR_PROP_*
    /* [in] */ LONG PropIndex,
    /* [in] */ LONG PropType,		// PROPTYPE_*
    /* [in] */ LONG Flags,		// CR_OUT_*
    /* [out, retval] */ VARIANT *pvarPropertyValue)
{
    HRESULT hr;
    DWORD i;
    BYTE const *pbOut;
    WCHAR const *pwszOut;
    DWORD cbOut;
    DWORD dw;
    XCMCRESPONSE *pResponse = NULL;
    CERT_CONTEXT const *pccIssued = NULL;
    BYTE *pbChain = NULL;
    DWORD cbChain;

    if (NULL == pvarPropertyValue)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    VariantInit(pvarPropertyValue);

    hr = E_INVALIDARG;
    for (i = 0; PropId != s_aFRProp[i].lPropId; i++)
    {
	if (i >= ARRAYSIZE(s_aFRProp))
	{
	    _JumpError(hr, error, "PropId");
	}
    }
    if ((PROPTYPE_MASK & s_aFRProp[i].lPropFlags) != PropType)
    {
	_JumpError(hr, error, "PropType");
    }
    if (PROPFLAGS_INDEXED & s_aFRProp[i].lPropFlags)
    {
	if ((DWORD) PropIndex >= m_cResponse)
	{
	    _JumpError(hr, error, "PropIndex");
	}
	pResponse = &m_rgResponse[PropIndex];
    }
    else if (0 != PropIndex)
    {
	_JumpError(hr, error, "non-zero PropIndex");
    }

    
    pbOut = NULL;
    pwszOut = NULL;
    switch (PropId)
    {
    	case FR_PROP_FULLRESPONSE:
    	case FR_PROP_FULLRESPONSENOPKCS7:
	    pbOut = m_pbFullResponse;
	    cbOut = m_cbFullResponse;
	    if (NULL == pbOut && FR_PROP_FULLRESPONSE == PropId)
	    {
		pbOut = m_pbCertificateChain;
		cbOut = m_cbCertificateChain;
	    }
	    break;

    	case FR_PROP_STATUSINFOCOUNT:
	    pbOut = (BYTE const *) &m_cResponse;
	    cbOut = sizeof(m_cResponse);
	    break;

    	case FR_PROP_BODYPARTSTRING:
            if (pResponse == NULL)
            {
               hr = E_POINTER;
               _JumpError(hr, error, "Bad switch setup: NULL pResponse");
            }
	    pwszOut = pResponse->pwszBodyPart;
	    break;

    	case FR_PROP_STATUS:
            if (pResponse == NULL)
            {
               hr = E_POINTER;
               _JumpError(hr, error, "Bad switch setup: NULL pResponse");
            }
	    pbOut = (BYTE const *) &pResponse->StatusInfo.dwStatus;
	    cbOut = sizeof(pResponse->StatusInfo.dwStatus);
	    break;

    	case FR_PROP_STATUSSTRING:
            if (pResponse == NULL)
            {
               hr = E_POINTER;
               _JumpError(hr, error, "Bad switch setup: NULL pResponse");
            }
	    pwszOut = pResponse->StatusInfo.pwszStatusString;
	    break;

    	case FR_PROP_OTHERINFOCHOICE:
            if (pResponse == NULL)
            {
               hr = E_POINTER;
               _JumpError(hr, error, "Bad switch setup: NULL pResponse");
            }
	    pbOut = (BYTE const *) &pResponse->StatusInfo.dwOtherInfoChoice;
	    cbOut = sizeof(pResponse->StatusInfo.dwOtherInfoChoice);
	    break;

    	case FR_PROP_FAILINFO:
            if (pResponse == NULL)
            {
               hr = E_POINTER;
               _JumpError(hr, error, "Bad switch setup: NULL pResponse");
            }
	    if (CMC_OTHER_INFO_FAIL_CHOICE ==
		pResponse->StatusInfo.dwOtherInfoChoice)
	    {
		pbOut = (BYTE const *) &pResponse->StatusInfo.dwFailInfo;
		cbOut = sizeof(pResponse->StatusInfo.dwFailInfo);
	    }
	    break;

    	case FR_PROP_PENDINFOTOKEN:
            if (pResponse == NULL)
            {
               hr = E_POINTER;
               _JumpError(hr, error, "Bad switch setup: NULL pResponse");
            }
	    if (CMC_OTHER_INFO_PEND_CHOICE ==
		pResponse->StatusInfo.dwOtherInfoChoice)
	    {
		pbOut = (BYTE const *) &dw;
		cbOut = sizeof(dw);
		pbOut = pResponse->StatusInfo.pPendInfo->PendToken.pbData;
		cbOut = pResponse->StatusInfo.pPendInfo->PendToken.cbData;
	    }
	    break;

    	case FR_PROP_PENDINFOTIME:
            if (pResponse == NULL)
            {
               hr = E_POINTER;
               _JumpError(hr, error, "Bad switch setup: NULL pResponse");
            }
	    if (CMC_OTHER_INFO_PEND_CHOICE ==
		pResponse->StatusInfo.dwOtherInfoChoice)
	    {
		pbOut = (BYTE const *) &pResponse->StatusInfo.pPendInfo->PendTime;
		cbOut = sizeof(pResponse->StatusInfo.pPendInfo->PendTime);
	    }
	    break;

    	case FR_PROP_ISSUEDCERTIFICATEHASH:
            if (pResponse == NULL)
            {
               hr = E_POINTER;
               _JumpError(hr, error, "Bad switch setup: NULL pResponse");
            }
	    pbOut = pResponse->pbCertHash;
	    cbOut = pResponse->cbCertHash;
	    break;

    	case FR_PROP_ENCRYPTEDKEYHASH:
            if (pResponse == NULL)
            {
               hr = E_POINTER;
               _JumpError(hr, error, "Bad switch setup: NULL pResponse");
            }
	    pbOut = pResponse->pbEncryptedKeyHash;
	    cbOut = pResponse->cbEncryptedKeyHash;
	    break;

    	case FR_PROP_ISSUEDCERTIFICATE:
            if (pResponse == NULL)
            {
               hr = E_POINTER;
               _JumpError(hr, error, "Bad switch setup: NULL pResponse");
            }
	    hr = _FindIssuedCertificate(
				pResponse->pbCertHash,
				pResponse->cbCertHash,
				&pccIssued);
	    _JumpIfError(hr, error, "_FindIssuedCertificate");

	    pbOut = pccIssued->pbCertEncoded;
	    cbOut = pccIssued->cbCertEncoded;
	    break;

    	case FR_PROP_ISSUEDCERTIFICATECHAIN:
    	case FR_PROP_ISSUEDCERTIFICATECRLCHAIN:
            if (pResponse == NULL)
            {
               hr = E_POINTER;
               _JumpError(hr, error, "Bad switch setup: NULL pResponse");
            }
	    hr = _BuildIssuedCertificateChain(
			pResponse->pbCertHash,
			pResponse->cbCertHash,
			FR_PROP_ISSUEDCERTIFICATECRLCHAIN == PropId ||
			    0 != (CR_OUT_CRLS & Flags),
			&pbChain,
			&cbChain);
	    _JumpIfError(hr, error, "_BuildIssuedCertificateChain");

	    pbOut = pbChain;
	    cbOut = cbChain;
	    break;
    }
    if (NULL != pwszOut)
    {
	pbOut = (BYTE const *) pwszOut;
	cbOut = (wcslen(pwszOut) + 1) * sizeof(WCHAR);
    }
    if (NULL == pbOut || 0 == cbOut)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpError2(hr, error, "Empty", CERTSRV_E_PROPERTY_EMPTY);
    }
    __try
    {
	hr = myUnmarshalFormattedVariant(
				    Flags,
				    CR_PROP_CASIGCERT,
				    PropType,
				    cbOut,
				    pbOut,
				    pvarPropertyValue);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "myUnmarshalFormattedVariant");

error:
    if (NULL != pccIssued)
    {
	CertFreeCertificateContext(pccIssued);
    }
    if (S_OK != hr && NULL != pvarPropertyValue)
    {
	VariantClear(pvarPropertyValue);
    }
    if (NULL != pbChain)
    {
	LocalFree(pbChain);
    }
    return(_SetErrorInfo(hr, L"CCertRequest::GetFullResponseProperty"));
}


#define CCERTREQUEST
#include "csprop2.cpp"


HRESULT
CCertRequest::_SetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription)
{
    CSASSERT(FAILED(hrError) || S_OK == hrError || S_FALSE == hrError);
    if (FAILED(hrError))
    {
	HRESULT hr;

	hr = DispatchSetErrorInfo(
			    hrError,
			    pwszDescription,
			    wszCLASS_CERTREQUEST,
			    &IID_ICertRequest);
	CSASSERT(hr == hrError);
    }
    return(hrError);
}


VOID
crRPCTimeoutCallback(
    IN OUT VOID *pVoid,
    IN BOOLEAN fTimeout)
{

    PRPC_TIMEOUT_CONTEXT pTimeout = (RPC_TIMEOUT_CONTEXT *) pVoid;

    if(fTimeout)
    {
        RpcCancelThreadEx(pTimeout->hThread, CR_RPC_CANCEL_TIMEOUT);
        pTimeout->hrRpcError = RPC_E_TIMEOUT;
    }

}


HRESULT
crRegisterRPCCallTimeout(
    IN DWORD dwMilliseconds,
    OUT PRPC_TIMEOUT_CONTEXT pTimeout)
{
    HRESULT hr = S_OK;

    pTimeout->hrRpcError = RPC_S_CALL_CANCELLED;

    if (!DuplicateHandle(
		    GetCurrentProcess(),	// hSourceProcessHandle
		    GetCurrentThread(),		// hSourceHandle
		    GetCurrentProcess(),	// hTargetProcessHandle
		    &pTimeout->hThread,		// lpTargetHandle
		    0,				// dwDesiredAccess
		    FALSE,			// bInheritHandle
		    DUPLICATE_SAME_ACCESS))	// dwOptions
    {
        hr = myHLastError();
        _JumpError(hr, error, "DuplicateHandle");
    }

    pTimeout->hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if(pTimeout->hEvent == NULL)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CreateEvent");
    }


    if (!RegisterWaitForSingleObject(&pTimeout->hWait,
                                      pTimeout->hEvent, 
                                      crRPCTimeoutCallback,
                                      (PVOID)pTimeout   , 
                                      dwMilliseconds,
                                      WT_EXECUTEONLYONCE))
    {
        hr = myHLastError();
        _JumpError(hr, error, "RegisterWaitForSingleObject");
    }

error:
    if (S_OK != hr)
    {
	crCloseRPCCallTimeout(pTimeout);
    }
    return hr;

}


HRESULT
crCloseRPCCallTimeout(
    IN  PRPC_TIMEOUT_CONTEXT pTimeout)
{
    if(pTimeout->hWait)
    {
        UnregisterWait(pTimeout->hWait);
        pTimeout->hWait = NULL;
    }

    if(pTimeout->hEvent)
    {
        CloseHandle(pTimeout->hEvent);
        pTimeout->hEvent = NULL;
    }

    if(pTimeout->hThread)
    {
        CloseHandle(pTimeout->hThread);
        pTimeout->hThread = NULL;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certcli\vroot.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       vroot.cpp
//
//--------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  File:       vroot.cpp
//
//  Contents:   Code for creating IIS web server virtual roots under K2.
//
//  Functions:  AddNewVDir()
//
//  History:    5/16/97         JerryK  Created
//
//-------------------------------------------------------------------------


// Include File Voodoo
#include "pch.cpp"
#pragma hdrstop

#include <lm.h>
#include <sddl.h>
#include "resource.h"
#include "certacl.h"

#define __dwFILE__	__dwFILE_CERTCLI_VROOT_CPP__


#undef DEFINE_GUID
#define INITGUID
#ifndef INITGUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    EXTERN_C const GUID FAR name
#else

#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#endif // INITGUID

#include <iwamreg.h>
#include <iadmw.h>
#include <iiscnfg.h>


extern HINSTANCE g_hInstance;


#define MAX_METABASE_ATTEMPTS           10      // Times to bang head on wall
#define METABASE_PAUSE                  500     // Time to pause in msec

#define VRE_DELETEONLY  0x00000001      // Obsolete VRoot -- delete
#define VRE_SCRIPTMAP   0x00000002      // Add additional associations to the script map
#define VRE_ALLOWNTLM   0x00000004      // Alloc NTLM authentication
#define VRE_CREATEAPP   0x00000008      // Create an in-process Web application

typedef struct _VROOTENTRY
{
    WCHAR *pwszVRootName;
    WCHAR *pwszDirectory;       // relative to System32 directory
    DWORD  Flags;
} VROOTENTRY;

VROOTENTRY g_avr[] = {
// pwszVRootName   pwszDirectory              Flags
 { L"CertSrv",     L"\\CertSrv",              VRE_ALLOWNTLM | VRE_SCRIPTMAP | VRE_CREATEAPP},
 { L"CertControl", L"\\CertSrv\\CertControl", VRE_ALLOWNTLM },
 { L"CertEnroll",  L"\\" wszCERTENROLLSHAREPATH,  0 },
 { L"CertQue",     L"\\CertSrv\\CertQue",     VRE_DELETEONLY },
 { L"CertAdm",     L"\\CertSrv\\CertAdm",     VRE_DELETEONLY },
 { NULL }
};

typedef struct _VRFSPARMS
{
    IN DWORD Flags;                     // VFF_*
    IN ENUM_CATYPES CAType;             // CAType
    IN BOOL  fAsynchronous;
    IN DWORD csecTimeOut;
    OUT DWORD *pVRootDisposition;       // VFD_*
    OUT DWORD *pShareDisposition;       // VFD_*
} VRFSPARMS;



// Globals
WCHAR const g_wszBaseRoot[] = L"/LM/W3svc/1/ROOT";
WCHAR const g_wszCertCliDotDll[] = L"certcli.dll";
WCHAR const g_wszDotAsp[] = L".asp";
WCHAR const g_wszDotCer[] = L".cer";
WCHAR const g_wszDotP7b[] = L".p7b";
WCHAR const g_wszDotCrl[] = L".crl";

// caller must have CoInitialize()'d

BOOL
IsIISInstalled(
    OUT HRESULT *phr)
{
    IMSAdminBase *pIMeta = NULL;

    *phr = CoCreateInstance(
                    CLSID_MSAdminBase,
                    NULL,
                    CLSCTX_ALL,
                    IID_IMSAdminBase,
                    (VOID **) &pIMeta);
    _JumpIfError2(*phr, error, "CoCreateInstance(CLSID_MSAdminBase)", *phr);

error:
    if (NULL != pIMeta)
    {
        pIMeta->Release();
    }
    return(S_OK == *phr);
}


HRESULT
vrOpenRoot(
    IN IMSAdminBase *pIMeta,
    IN BOOL fReadOnly,
    OUT METADATA_HANDLE *phMetaRoot)
{
    HRESULT hr;
    DWORD i;

    __try
    {
        // Re-try a few times to see if we can get past the block

        for (i = 0; i < MAX_METABASE_ATTEMPTS; i++)
        {
            if (0 != i)
            {
                Sleep(METABASE_PAUSE);          // Pause and try again
            }

            // Make an attempt to open the root

            hr = pIMeta->OpenKey(
                            METADATA_MASTER_ROOT_HANDLE,
                            g_wszBaseRoot,
                            fReadOnly?
                                METADATA_PERMISSION_READ :
                                (METADATA_PERMISSION_READ |
                                 METADATA_PERMISSION_WRITE),
                            1000,
                            phMetaRoot);
            if (S_OK == hr)
            {
                break;                          // Success -- we're done!
            }

            // See if a previous call has things tied up

            if (HRESULT_FROM_WIN32(ERROR_PATH_BUSY) != hr)
            {
                _LeaveIfError(hr, "OpenKey");   // Detected some other error
            }
        }
        _LeaveIfError(hr, "OpenKey(timeout)"); // Detected some other error
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

//error:
    return(hr);
}


HRESULT
vrCloseKey(
    IN IMSAdminBase *pIMeta,
    IN METADATA_HANDLE hMeta,
    IN HRESULT hr)
{
    HRESULT hr2;

    __try
    {
        hr2 = pIMeta->CloseKey(hMeta);
        _LeaveIfError(hr2, "CloseKey");
    }
    __except(hr2 = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    if (S_OK != hr2)
    {
        if (S_OK == hr)
        {
            hr = hr2;
        }
        _PrintError(hr2, "CloseKey");
    }
    return(hr);
}


//+----------------------------------------------------------------------------
//
//  Function:   AddNewVDir(. . . .)
//
//  Synopsis:   Creates a new virtual root using the K2 metabase.
//
//  Arguments:  [pwszVRootName] Name to give to the virtual root
//              [pwszDirectory] Path for the directory to use as the root.
//
//  Returns:    HRESULT status code regurgitated from metabase COM interfaces
//
//
//  History:    05/16/97        JerryK  Put in this file
//              05/22/97        JerryK  Made OCM setup build with this stuff
//                                      in place.
//
//  Notes:      Originally derived from sample code provided by MikeHow;
//              hacked up a lot in between.
//
//              We do a try, fail, pause, retry loop on our attempts to open
//              the metabase master key to get around a K2 bug that can result
//              in it being left busy if this function is called too many
//              times successively.
//
//  TO DO:      COME BACK AND PUT SEMIREADABLE GUI LEVEL MESSAGEBOX REPORTING
//              THAT THE VROOTS IN QUESTION DIDN'T SET UP CORRECTLY.
//
//-----------------------------------------------------------------------------

HRESULT
AddNewVDir(
    IN LPWSTR pwszVRootName,
    IN LPWSTR pwszDirectory,
    IN BOOL fScriptMap,
    IN BOOL fNTLM,
    IN BOOL fCreateApp,
    OUT BOOL *pfExists)
{
    HRESULT hr;
    METADATA_RECORD mr;
    IMSAdminBase *pIMeta = NULL;
    IWamAdmin *pIWam = NULL;
    WCHAR *pwszNewPath = NULL;
    WCHAR *pwszCurrentScriptMap=NULL;
    WCHAR *pwszNewScriptMap=NULL;
    WCHAR wszKeyType[] = TEXT(IIS_CLASS_WEB_VDIR);
    METADATA_HANDLE hMetaRoot = NULL;   // Open key to ROOT (where VDirs live)
    DWORD dwMDData = MD_LOGON_NETWORK; // Create network token when logging on anonymous account
    METADATA_RECORD MDData = 
        {
        MD_LOGON_METHOD,
        0,
        IIS_MD_UT_SERVER,
        DWORD_METADATA,
	sizeof(dwMDData),
        (unsigned char*)&dwMDData,
        0        
        };

    *pfExists = FALSE;
    DBGPRINT((
        DBG_SS_CERTLIBI,
        "AddNewVDir(%ws, %ws, fScriptMap=%d, fNTLM=%d, fCreateApp=%d)\n",
        pwszVRootName,
        pwszDirectory,
        fScriptMap,
        fNTLM,
        fCreateApp));

    // Create an instance of the metabase object
    hr = CoCreateInstance(
        CLSID_MSAdminBase,
        NULL,
        CLSCTX_ALL,
        IID_IMSAdminBase,
        (void **) &pIMeta);
    _JumpIfError(hr, error, "CoCreateInstance");

    __try
    {
        hr = vrOpenRoot(pIMeta, FALSE, &hMetaRoot);
        _JumpIfError(hr, error, "vrOpenRoot");

        // Add new VDir called pwszVRootName

        hr = pIMeta->AddKey(hMetaRoot, pwszVRootName);

        DBGPRINT((
            DBG_SS_CERTLIBI,
            "AddNewVDir: AddKey(%ws) --> %x\n",
            pwszVRootName,
            hr));
        if (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) == hr)
        {
            *pfExists = TRUE;
        }
        else
        {
            _LeaveIfError(hr, "AddKey");
        }

        if (fScriptMap) {

            // get the current script map
            DWORD dwDataSize;
            mr.dwMDIdentifier=MD_SCRIPT_MAPS;
            mr.dwMDAttributes=METADATA_INHERIT;
            mr.dwMDUserType=IIS_MD_UT_FILE;
            mr.dwMDDataType=MULTISZ_METADATA;
            mr.dwMDDataLen=0;
            mr.pbMDData=NULL;
            hr=pIMeta->GetData(hMetaRoot, L"", &mr, &dwDataSize);
            if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)!=hr) {
                _LeaveError(hr, "GetData");
            }
            pwszCurrentScriptMap=reinterpret_cast<WCHAR *>(new unsigned char[dwDataSize]);
            if (NULL==pwszCurrentScriptMap) {
                hr=E_OUTOFMEMORY;
                _LeaveError(hr, "new");
            }
            mr.pbMDData=reinterpret_cast<unsigned char *>(pwszCurrentScriptMap);
            mr.dwMDDataLen=dwDataSize;
            hr=pIMeta->GetData(hMetaRoot, L"", &mr, &dwDataSize);
            _LeaveIfError(hr, "GetData");
        }

        hr = pIMeta->SetData(hMetaRoot, pwszVRootName, &MDData);
        _LeaveIfError(hr, "CloseKey");

        hr = pIMeta->CloseKey(hMetaRoot);
        _LeaveIfError(hr, "CloseKey");

        hMetaRoot = NULL;

        // Build the name of the new VDir
        pwszNewPath = new WCHAR[wcslen(g_wszBaseRoot) + 1 + wcslen(pwszVRootName) + 1];
        if (NULL == pwszNewPath)
        {
            hr = E_OUTOFMEMORY;
            _LeaveError(hr, "new");
        }
        wcscpy(pwszNewPath, g_wszBaseRoot);
        wcscat(pwszNewPath, L"/");
        wcscat(pwszNewPath, pwszVRootName);

        // Open the new VDir
        METADATA_HANDLE hMetaKey = NULL;

        hr = pIMeta->OpenKey(
                        METADATA_MASTER_ROOT_HANDLE,
                        pwszNewPath,
                        METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                        1000,
                        &hMetaKey);
        _LeaveIfErrorStr(hr, "OpenKey", pwszNewPath);


        // Set the physical path for this VDir

        // virtual root path
        mr.dwMDIdentifier = MD_VR_PATH;
        mr.dwMDAttributes = METADATA_INHERIT;
        mr.dwMDUserType = IIS_MD_UT_FILE;
        mr.dwMDDataType = STRING_METADATA;
        mr.dwMDDataLen = (wcslen(pwszDirectory) + 1) * sizeof(WCHAR);
        mr.pbMDData = reinterpret_cast<unsigned char *>(pwszDirectory);
        hr = pIMeta->SetData(hMetaKey, L"", &mr);
        _LeaveIfError(hr, "SetData");

        // access permissions on VRoots: read & execute scripts only
        DWORD dwAccessPerms = MD_ACCESS_SCRIPT | MD_ACCESS_READ;

        mr.dwMDIdentifier = MD_ACCESS_PERM;
        mr.dwMDAttributes = METADATA_INHERIT;
        mr.dwMDUserType = IIS_MD_UT_FILE;
        mr.dwMDDataType = DWORD_METADATA;
        mr.dwMDDataLen = sizeof(dwAccessPerms);
        mr.pbMDData = reinterpret_cast<unsigned char *>(&dwAccessPerms);
        hr = pIMeta->SetData(hMetaKey, L"", &mr);
        _LeaveIfError(hr, "SetData");

        // key type
        mr.dwMDIdentifier = MD_KEY_TYPE;
        mr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
        mr.dwMDUserType = IIS_MD_UT_SERVER;
        mr.dwMDDataType = STRING_METADATA;
        mr.dwMDDataLen = (wcslen(wszKeyType) + 1) * sizeof(WCHAR);
        mr.pbMDData = reinterpret_cast<unsigned char *>(wszKeyType);
        hr = pIMeta->SetData(hMetaKey, L"", &mr);
        _LeaveIfError(hr, "SetData");


        // set authentication to be anonymous
        DWORD dwAuthenticationType = MD_AUTH_ANONYMOUS;

        // chg to Basic/NTLM if we're told to
        if (fNTLM)
            dwAuthenticationType = MD_AUTH_BASIC | MD_AUTH_NT;

        mr.dwMDIdentifier = MD_AUTHORIZATION;
        mr.dwMDAttributes = METADATA_INHERIT;
        mr.dwMDUserType = IIS_MD_UT_FILE;
        mr.dwMDDataType = DWORD_METADATA;
        mr.dwMDDataLen = sizeof(dwAuthenticationType);
        mr.pbMDData = reinterpret_cast<unsigned char *>(&dwAuthenticationType);
        hr = pIMeta->SetData(hMetaKey, L"", &mr);
        _LeaveIfError(hr, "SetData");

        if (fScriptMap) {

            // already have current script map.

            // walk through the script map and find .asp
            WCHAR * pwszCurAssoc=pwszCurrentScriptMap;
            do {
                if (L'\0'==pwszCurAssoc[0]) {
                    hr=HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
                    _LeaveError(hr, ".asp association not found");
                } else if (0==_wcsnicmp(pwszCurAssoc, g_wszDotAsp, 4)) {
                    break;
                } else {
                    pwszCurAssoc+=wcslen(pwszCurAssoc)+1;
                }
            } while (TRUE);

            // Walk through the script map and find the last association.
            // We can't just subtract one from the total length
            // because there is a bug in IIS where sometimes it has a
            // triple terminator instead of a double terminator. <Sigh>
            unsigned int cchCurScriptMap=0;
            while(L'\0'!=pwszCurrentScriptMap[cchCurScriptMap]) {
                cchCurScriptMap+=wcslen(pwszCurrentScriptMap+cchCurScriptMap)+1;
            }

            // create a new script map that has .crl, .cer, and .p7b in it.
            // allocate enough space for the existing map, the three new associations, and the terminating \0.
            unsigned int cchAssocLen=wcslen(pwszCurAssoc)+1;
            pwszNewScriptMap=new WCHAR[cchCurScriptMap+cchAssocLen*3+1];
            if (NULL==pwszNewScriptMap) {
                hr=E_OUTOFMEMORY;
                _LeaveError(hr, "new");
            }

            // build the map
            WCHAR * pwszTravel=pwszNewScriptMap;

            // copy the existing map
            CopyMemory(pwszTravel, pwszCurrentScriptMap, cchCurScriptMap*sizeof(WCHAR));
            pwszTravel+=cchCurScriptMap;

            // add the .cer association
            wcscpy(pwszTravel, pwszCurAssoc);
            wcsncpy(pwszTravel, g_wszDotCer, 4);
            pwszTravel+=cchAssocLen;

            // add the .p7b association
            wcscpy(pwszTravel, pwszCurAssoc);
            wcsncpy(pwszTravel, g_wszDotP7b, 4);
            pwszTravel+=cchAssocLen;

            // add the .crl association
            wcscpy(pwszTravel, pwszCurAssoc);
            wcsncpy(pwszTravel, g_wszDotCrl, 4);
            pwszTravel+=cchAssocLen;

            // add the terminator
            pwszTravel[0]=L'\0';

            // set the new script map
            mr.dwMDIdentifier=MD_SCRIPT_MAPS;
            mr.dwMDAttributes=METADATA_INHERIT;
            mr.dwMDUserType=IIS_MD_UT_FILE;
            mr.dwMDDataType=MULTISZ_METADATA;
            mr.dwMDDataLen=(cchCurScriptMap+cchAssocLen*3+1) * sizeof(WCHAR);
            mr.pbMDData=reinterpret_cast<unsigned char *>(pwszNewScriptMap);
            hr=pIMeta->SetData(hMetaKey, L"", &mr);
            _LeaveIfError(hr, "SetData");
        }

        hr = pIMeta->CloseKey(hMetaKey);
        _LeaveIfError(hr, "CloseKey");

        // Flush out the changes and close
        hr = pIMeta->SaveData();

// Note: W2k used to swallow this error
        _LeaveIfError(hr, "SaveData");
//      _PrintIfError(hr, "SaveData");
//        hr = S_OK;

        // Create a 'web application' so that scrdenrl.dll runs in-process
        if (fCreateApp)
        {
            // Create an instance of the metabase object
            hr = CoCreateInstance(
                            CLSID_WamAdmin,
                            NULL,
                            CLSCTX_ALL,
                            IID_IWamAdmin,
                            (void **) &pIWam);
	    _LeaveIfError(hr, "CoCreateInstance");

            // Create the application running in-process

            hr = pIWam->AppCreate(pwszNewPath, TRUE);
            _LeaveIfError(hr, "AppCreate");
        }

    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    if (NULL != pwszCurrentScriptMap)
    {
        delete [] pwszCurrentScriptMap;
    }
    if (NULL != pwszNewScriptMap)
    {
        delete [] pwszNewScriptMap;
    }
    if (NULL != pwszNewPath)
    {
        delete [] pwszNewPath;
    }
    if (NULL != hMetaRoot)
    {
        hr = vrCloseKey(pIMeta, hMetaRoot, hr);
    }
    if (NULL != pIWam)
    {
        pIWam->Release();
    }
    if (NULL != pIMeta)
    {
        pIMeta->Release();
    }
    return(hr);
}


BOOL
TestForVDir(
    IN WCHAR *pwszVRootName)
{
    HRESULT hr;
    IMSAdminBase *pIMeta = NULL;
    BOOL fExists = FALSE;
    BOOL fCoInit = FALSE;
    METADATA_HANDLE hMetaRoot = NULL;   // Open key to ROOT (where VDirs live)
    METADATA_HANDLE hTestHandle = NULL;

    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
        _JumpError(hr, error, "CoInitialize");
    }
    fCoInit = TRUE;

    if (!IsIISInstalled(&hr))
    {
        goto error;     // Ignore if IIS is not functioning or not installed
    }

    // Create an instance of the metabase object
    hr = CoCreateInstance(
                      CLSID_MSAdminBase,
                      NULL,
                      CLSCTX_ALL,
                      IID_IMSAdminBase,
                      (void **) &pIMeta);
    _JumpIfError(hr, error, "CoCreateInstance");

    __try
    {
        hr = vrOpenRoot(pIMeta, TRUE, &hMetaRoot);
        _LeaveIfError(hr, "vrOpenRoot");

        // If we got here, we must have the master root handle
        // look for VDir

        hr = pIMeta->OpenKey(
                        hMetaRoot,
                        pwszVRootName,
                        METADATA_PERMISSION_READ,
                        1000,
                        &hTestHandle);

        DBGPRINT((
            DBG_SS_CERTLIBI,
            "TestForVDir: OpenKey(%ws) --> %x\n",
            pwszVRootName,
            hr));

        if (S_OK != hr)
        {
            hr = S_OK;
            __leave;
        }
        fExists = TRUE;

        hr = pIMeta->CloseKey(hTestHandle);
        _LeaveIfError(hr, "CloseKey");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    if (NULL != hMetaRoot)
    {
        hr = vrCloseKey(pIMeta, hMetaRoot, hr);
    }
    if (NULL != pIMeta)
    {
        pIMeta->Release();
    }
    if (fCoInit)
    {
        CoUninitialize();
    }
    return(fExists);
}

#define SZ_HKEY_IIS_REGVROOT L"SYSTEM\\CurrentControlSet\\Services\\W3SVC\\Parameters\\Virtual Roots"

HRESULT
RemoveVDir(
    IN WCHAR *pwszVRootName,
    OUT BOOL *pfExisted)
{
    HRESULT hr;
    HRESULT hr2;
    BOOL fCoInit = FALSE;
    IMSAdminBase *pIMeta = NULL;
    METADATA_HANDLE hMetaRoot = NULL;   // Open key to ROOT (where VDirs live)

    *pfExisted = FALSE;
    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
        _JumpError(hr, error, "CoInitialize");
    }
    fCoInit = TRUE;

    // Create an instance of the metabase object

    hr = CoCreateInstance(
                    CLSID_MSAdminBase,
                    NULL,
                    CLSCTX_ALL,
                    IID_IMSAdminBase,
                    (void **) &pIMeta);
    _JumpIfError(hr, error, "CoCreateInstance");

    __try
    {
        hr = vrOpenRoot(pIMeta, FALSE, &hMetaRoot);
        _LeaveIfError(hr, "vrOpenRoot");

        // If we got to here, we must have the master root handle
        // remove VDir

        hr2 = pIMeta->DeleteAllData(
                                hMetaRoot,
                                pwszVRootName,
                                ALL_METADATA,
                                ALL_METADATA);
        if (S_OK != hr2 && HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) != hr2)
        {
            hr = hr2;
            _PrintError(hr2, "DeleteAllData");
        }
        if (S_OK == hr2)
        {
            *pfExisted = TRUE;
        }

        hr2 = pIMeta->DeleteKey(hMetaRoot, pwszVRootName);
        if (S_OK != hr2 && HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) != hr2)
        {
            if (S_OK == hr)
            {
                hr = hr2;
            }
            _PrintError(hr2, "DeleteKey");
        }

        // HACKHACK: IIS reports S_OK in all cases above.  However, if IIS is
	// stopped, it will recreate vroots when restarted. We have to delete
	// them from the registry manually (bleah!).

	{
	    HKEY hKey;

	    hr2 = RegOpenKeyEx(
			HKEY_LOCAL_MACHINE,
			SZ_HKEY_IIS_REGVROOT,
			0,
			KEY_SET_VALUE,
			&hKey);
	    _PrintIfError2(hr2, "RegDeleteValue", ERROR_FILE_NOT_FOUND);
	    if (hr2 == S_OK)
	    {
		WCHAR wsz[MAX_PATH + 1];

		if (wcslen(pwszVRootName) + 2 > ARRAYSIZE(wsz))
		{
		    CSASSERT(!"pwszVRootName too long!");
		}
		else
		{
		    wsz[0] = L'/';
		    wcscpy(&wsz[1], pwszVRootName);

		    hr2 = RegDeleteValue(hKey, wsz);
		    _PrintIfError2(
			    hr2,
			    "RegDeleteValue (manual deletion of IIS VRoot)",
			    ERROR_FILE_NOT_FOUND);
		}
		RegCloseKey(hKey);
	    }

	    // ignore missing vroot entries

	    if (S_OK == hr && ERROR_FILE_NOT_FOUND != hr2)
	    {
		hr = hr2;
	    }
	}
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    if (NULL != hMetaRoot)
    {
        hr = vrCloseKey(pIMeta, hMetaRoot, hr);
    }
    if (NULL != pIMeta)
    {
        pIMeta->Release();
    }
    if (fCoInit)
    {
        CoUninitialize();
    }
    return(hr);
}


//+------------------------------------------------------------------------
//  Function:   vrModifyVirtualRoots()
//
//  Synopsis:   Creates the virtual roots needed for cert server web pages.
//
//  Effects:    Creates IIS Virtual Roots
//
//  Arguments:  None.
//-------------------------------------------------------------------------

HRESULT
vrModifyVirtualRoots(
    IN BOOL fCreate,            // else Delete
    IN BOOL fNTLM,
    OPTIONAL OUT DWORD *pDisposition)
{
    HRESULT hr;
    HRESULT hr2;
    WCHAR wszSystem32Path[MAX_PATH];
    WCHAR wszVRootPathTemp[MAX_PATH];
    BOOL fCoInit = FALSE;
    IMSAdminBase *pIMeta = NULL;
    METADATA_HANDLE hMetaRoot = NULL;   // Open key to ROOT (where VDirs live)
    VROOTENTRY *pavr;
    BOOL fExist;
    DWORD Disposition = 0;

    if (NULL != pDisposition)
    {
        *pDisposition = 0;
    }
    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
        _JumpError(hr, error, "CoInitialize");
    }
    fCoInit = TRUE;

    DBGPRINT((
        DBG_SS_CERTLIBI,
        "vrModifyVirtualRoots(tid=%x, fCreate=%d, fNTLM=%d)\n",
        GetCurrentThreadId(),
        fCreate,
        fNTLM));

    if (!IsIISInstalled(&hr))
    {
        // IIS is not functioning or not installed

        _PrintError2(hr, "IsIISInstalled", hr);
        hr = S_OK;
        Disposition = VFD_NOTSUPPORTED;
        goto error;
    }

    // Create path for SYSTEM32 directory

    if (0 == GetSystemDirectory(wszSystem32Path, ARRAYSIZE(wszSystem32Path)))
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetSystemDirectory");
    }

    // Create virtual roots

    for (pavr = g_avr; NULL != pavr->pwszVRootName; pavr++)
    {
        CSASSERT(ARRAYSIZE(wszVRootPathTemp) >
            wcslen(wszSystem32Path) + wcslen(pavr->pwszDirectory));

        wcscpy(wszVRootPathTemp, wszSystem32Path);
        wcscat(wszVRootPathTemp, pavr->pwszDirectory);

        if (fCreate)
        {
            if (0 == (VRE_DELETEONLY & pavr->Flags))    // if not obsolete
            {
                hr = AddNewVDir(
                    pavr->pwszVRootName,
                    wszVRootPathTemp,
                    (VRE_SCRIPTMAP & pavr->Flags)? TRUE : FALSE,
                    (fNTLM && (VRE_ALLOWNTLM & pavr->Flags))? TRUE : FALSE,
                    (VRE_CREATEAPP & pavr->Flags)? TRUE : FALSE,
                    &fExist);
                if (S_OK != hr)
                {
                    Disposition = VFD_CREATEERROR;
                    _JumpErrorStr(hr, error, "AddNewVDir", pavr->pwszVRootName);
                }
                Disposition = fExist? VFD_EXISTS : VFD_CREATED;
            }
        }
        else // else Delete
        {
            hr2 = RemoveVDir(pavr->pwszVRootName, &fExist);
            if (0 == (VRE_DELETEONLY & pavr->Flags))    // if not obsolete
            {
                if (S_OK != hr2)
                {
                    if (S_OK == hr)
                    {
                        hr = hr2;
                    }
                    Disposition = VFD_DELETEERROR;
                    _PrintError(hr2, "RemoveVDir");
                }
                else
                {
                    Disposition = fExist? VFD_DELETED : VFD_NOTFOUND;
                }
            }
        }
    }

error:
    if (NULL != pDisposition)
    {
        *pDisposition = Disposition;
    }
    if (fCoInit)
    {
        CoUninitialize();
    }
    DBGPRINT((
        DBG_SS_CERTLIBI,
        "vrModifyVirtualRoots(tid=%x, hr=%x, disp=%d)\n",
        GetCurrentThreadId(),
        hr,
        Disposition));
    return(hr);
}


// myAddShare: create and test new net share
HRESULT
myAddShare(
    LPCWSTR szShareName,
    LPCWSTR szShareDescr,
    LPCWSTR szSharePath,
    BOOL fOverwrite,
    OPTIONAL BOOL *pfCreated)
{
    HRESULT hr;
    BOOL fCreated = FALSE;

    HANDLE hTestFile = INVALID_HANDLE_VALUE;
    LPWSTR pwszTestComputerName = NULL;
    LPWSTR pwszTestUNCPath = NULL;

    // Share local path
    SHARE_INFO_502 shareStruct;
    ZeroMemory(&shareStruct, sizeof(shareStruct));

    shareStruct.shi502_netname = const_cast<WCHAR *>(szShareName);
    shareStruct.shi502_type = STYPE_DISKTREE;
    shareStruct.shi502_remark = const_cast<WCHAR *>(szShareDescr);
    shareStruct.shi502_max_uses = -1;
    shareStruct.shi502_path = const_cast<WCHAR *>(szSharePath);

    hr = myGetSDFromTemplate(WSZ_DEFAULT_SHARE_SECURITY,
                             NULL,
                             &shareStruct.shi502_security_descriptor);
    _JumpIfError(hr, error, "myGetSDFromTemplate");

    hr = NetShareAdd(
        NULL,               // this computer
        502,                // SHARE_LEVEL_502 struct
        (BYTE *) &shareStruct,
        NULL);
    fCreated = (S_OK == hr);

    if (hr == (HRESULT) NERR_DuplicateShare)
    {
        SHARE_INFO_2* pstructDupShare = NULL;

        hr = NetShareGetInfo(
            NULL,
            const_cast<WCHAR *>(szShareName),
            2,
            (BYTE **) &pstructDupShare);
        _JumpIfError(hr, error, "NetShareGetInfo");

        if (0 == wcscmp(pstructDupShare->shi2_path, szSharePath))
        {
            // they're the same path, so we're okay!
            hr = S_OK;
        }
        else if (fOverwrite)
        {
            // not the same path, but we've been instructed to bash existing

            // remove offending share
            hr = NetShareDel(
                NULL,
                const_cast<WCHAR *>(szShareName),
                0);
            if (S_OK == hr)
            {
                // try again
                hr = NetShareAdd(
                    NULL,               // this computer
                    502,                // SHARE_LEVEL_502 struct
                    (BYTE *) &shareStruct,
                    NULL);
                fCreated = (S_OK == hr);
            }
        }
        if (NULL != pstructDupShare)
	{
            NetApiBufferFree(pstructDupShare);
	}
    }

    // if share does not exist by this time, we bail
    _JumpIfError(hr, error, "NetShareAdd");

    // TEST: is writable?
#define UNCPATH_TEMPLATE     L"\\\\%ws\\%ws\\write.tmp"

    hr = myGetMachineDnsName(&pwszTestComputerName);
    _JumpIfError(hr, error, "myGetMachineDnsName");

    // get the local machine name
    pwszTestUNCPath = (LPWSTR)LocalAlloc(LMEM_FIXED,
            (UINT)(( ARRAYSIZE(UNCPATH_TEMPLATE) +
              wcslen(pwszTestComputerName) +
              wcslen(szShareName) )
            *sizeof(WCHAR)));
    if (NULL == pwszTestUNCPath)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    // create UNC path
    swprintf(pwszTestUNCPath, UNCPATH_TEMPLATE, pwszTestComputerName, szShareName);

    hTestFile = CreateFile(
        pwszTestUNCPath,
        GENERIC_WRITE,
        FILE_SHARE_WRITE,
        NULL,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE,
        NULL);
    if (hTestFile == INVALID_HANDLE_VALUE)
    {
        hr = myHLastError();
        _JumpErrorStr(hr, error, "CreateFile (test for UNC translation)", pwszTestUNCPath);
    }

    // if we got this far, our test went well
    hr = S_OK;

error:
    // if created and then something went wrong, clean up
    if (fCreated && (hr != S_OK))
    {
        // don't mash hr
        HRESULT hr2;
        hr2 = NetShareDel(
            NULL,
            const_cast<WCHAR *>(szShareName),
            0);
        // ignore NetShareDel hr
        _PrintIfError(hr2, "NetShareDel");    // not fatal, might already be shared
    }

    if (INVALID_HANDLE_VALUE != hTestFile)
        CloseHandle(hTestFile);

    if (NULL != pwszTestComputerName)
        LocalFree(pwszTestComputerName);

    if (NULL != pwszTestUNCPath)
        LocalFree(pwszTestUNCPath);

    if(shareStruct.shi502_security_descriptor)
    {
        LocalFree(shareStruct.shi502_security_descriptor);
    }

    if(pfCreated)
        *pfCreated = fCreated;

    return hr;
}


HRESULT
vrModifyFileShares(
    IN BOOL fCreate,            // else Delete
    OPTIONAL OUT DWORD *pDisposition)
{
    HRESULT hr;
    WCHAR wszSystem32Dir[MAX_PATH];
    WCHAR wszRemark[512];
    WCHAR *pwszDirectory = NULL;
    DWORD Disposition = 0;
    BOOL  fCreated = FALSE;

    if (NULL != pDisposition)
    {
        *pDisposition = 0;
    }
    if (fCreate)
    {
        if (0 == GetSystemDirectory(wszSystem32Dir, ARRAYSIZE(wszSystem32Dir)))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetSystemDirectory");
        }
        hr = myBuildPathAndExt(
                        wszSystem32Dir,
                        wszCERTENROLLSHAREPATH,
                        NULL,
                        &pwszDirectory);
        _JumpIfError(hr, error, "myBuildPathAndExt");

        if (!LoadString(
                    g_hInstance,
                    IDS_FILESHARE_REMARK,
                    wszRemark,
                    ARRAYSIZE(wszRemark)))
        {
            hr = myHLastError();
            CSASSERT(S_OK != hr);
            _JumpError(hr, error, "LoadString");
        }

        hr = myAddShare(wszCERTENROLLSHARENAME,
                   wszRemark,
                   pwszDirectory,
                   TRUE,
                   &fCreated);
        if (S_OK == hr)
        {
            Disposition = fCreated?VFD_CREATED:VFD_EXISTS;
        }
        else
        {
            Disposition = VFD_CREATEERROR;
            _JumpErrorStr(hr, error, "NetShareAdd", wszCERTENROLLSHARENAME);
        }
    }
    else
    {
        hr = NetShareDel(NULL, wszCERTENROLLSHARENAME, NULL);
        CSASSERT(NERR_Success == S_OK);
        if (S_OK == hr)
        {
            Disposition = VFD_DELETED;
        }
        else if ((HRESULT) NERR_NetNameNotFound == hr)
        {
            Disposition = VFD_NOTFOUND;
            hr = S_OK;
        }
        else
        {
            Disposition = VFD_DELETEERROR;
            _JumpErrorStr(hr, error, "NetShareDel", wszCERTENROLLSHARENAME);
        }
    }
    NetShareDel(NULL, L"CertSrv", NULL);        // delete old share name

error:
    if (NULL != pDisposition)
    {
        *pDisposition = Disposition;
    }
    if (NULL != pwszDirectory)
    {
        LocalFree(pwszDirectory);
    }
    return(myHError(hr));
}


// For now, this writes the entry "CertUtil -vroot", and is not generalized
HRESULT
myWriteRunOnceEntry(
    IN BOOL fAdd // Add or Remove entry?
    )
{
    DWORD err;

    // Add certutil -vroot to runonce commands
    WCHAR szRunOnceCommand[] = L"certutil -vroot";
    HKEY hkeyRunOnce = NULL;
    DWORD dwDisposition;

    err = RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce",         // address of subkey name
        0,
        NULL,
        0,
        KEY_SET_VALUE,
        NULL,
        &hkeyRunOnce,
        &dwDisposition);
    _JumpIfError(err, error, "RegCreateKeyEx");

    // add or remove entry?
    if (fAdd)
    {
        err = RegSetValueEx(
            hkeyRunOnce,
            L"Certificate Services",
            0,
            REG_SZ,
            (BYTE *) szRunOnceCommand,
            sizeof(szRunOnceCommand));
        _JumpIfError(err, error, "RegSetValueEx");
    }
    else
    {
        err = RegDeleteValue(hkeyRunOnce, L"Certificate Services");
        _PrintIfError2(err, "RegDeleteValue", ERROR_FILE_NOT_FOUND);
	if (ERROR_FILE_NOT_FOUND == err)
	{
	    err = ERROR_SUCCESS;
	}
        _JumpIfError(err, error, "RegDeleteValue");
    }

error:
    if (hkeyRunOnce)
        RegCloseKey(hkeyRunOnce);

    return (myHError(err));
}


DWORD
vrWorkerThread(
    OPTIONAL IN OUT VOID *pvparms)
{
    HRESULT hr = S_OK;
    HRESULT hr2;
    VRFSPARMS *pparms = (VRFSPARMS *) pvparms;
    DWORD Disposition;
    BOOL fFailed = FALSE;

    CSASSERT(NULL != pparms);

    if ((VFF_CREATEFILESHARES | VFF_DELETEFILESHARES) & pparms->Flags)
    {
        hr = vrModifyFileShares(
            (VFF_CREATEFILESHARES & pparms->Flags)? TRUE : FALSE,
            &Disposition);
        _PrintIfError(hr, "vrModifyFileShares");
        if (NULL != pparms->pShareDisposition)
        {
            *pparms->pShareDisposition = Disposition;
        }
        if (VFD_CREATEERROR == Disposition || VFD_DELETEERROR == Disposition)
        {
            fFailed = TRUE;
        }
    }
    if ((VFF_CREATEVROOTS | VFF_DELETEVROOTS) & pparms->Flags)
    {
        BOOL fNTLM = FALSE;             // set fNTLM iff Enterprise CA

        if (IsEnterpriseCA(pparms->CAType))
        {
            fNTLM = TRUE;
        }

        hr2 = vrModifyVirtualRoots(
            (VFF_CREATEVROOTS & pparms->Flags)? TRUE : FALSE,
            fNTLM,
            &Disposition);
        _PrintIfError2(hr2, "vrModifyVirtualRoots", S_FALSE);
        if (S_OK == hr)
        {
            hr = hr2;
        }
        if (NULL != pparms->pVRootDisposition)
        {
            *pparms->pVRootDisposition = Disposition;
        }
        if (VFD_CREATEERROR == Disposition || VFD_DELETEERROR == Disposition)
        {
            fFailed = TRUE;
        }
    }


    if ((S_OK == hr && !fFailed) || ((VFF_DELETEVROOTS) & pparms->Flags)) // on success or removal
    {
        // remove "attempt vroot" flag so we don't try again

        if (VFF_CLEARREGFLAGIFOK & pparms->Flags)
        {
            DBGPRINT((DBG_SS_CERTLIBI, "clearing registry\n"));
            hr = SetSetupStatus(NULL, SETUP_ATTEMPT_VROOT_CREATE, FALSE);
            _JumpIfError(hr, error, "SetSetupStatus");
        }

            hr = myWriteRunOnceEntry(FALSE);    // worker thread deletes on success
            _JumpIfError(hr, error, "myWriteRunOnceEntry");
    }

error:

    LocalFree(pparms);
    DBGPRINT((DBG_SS_CERTLIBI, "vrWorkerThread returns %x\n", hr));
    return(myHError(hr));
}


//+------------------------------------------------------------------------
//  Function:   myModifyVirtualRootsAndFileShares
//
//  Synopsis:   Creates the virtual roots needed for cert server web pages.
//
//  Effects:    Creates IIS Virtual Roots
//
//  Arguments:  None.
//-------------------------------------------------------------------------

HRESULT
myModifyVirtualRootsAndFileShares(
    IN DWORD Flags,             // VFF_*: Create/Delete VRoots and/or Shares
    IN ENUM_CATYPES CAType,
    IN BOOL fAsynchronous,
    IN DWORD csecTimeOut,
    OPTIONAL OUT DWORD *pVRootDisposition,      // VFD_*
    OPTIONAL OUT DWORD *pShareDisposition)      // VFD_*
{
    HRESULT hr;
    HANDLE hThread = NULL;
    HMODULE hMod = NULL;
    DWORD ThreadId;
    DWORD dw;
    BOOL fEnable = TRUE;
    DWORD SetupStatus;
    VRFSPARMS *pparms = NULL;

    if (NULL != pVRootDisposition)
    {
        *pVRootDisposition = 0;
    }
    if (NULL != pShareDisposition)
    {
        *pShareDisposition = 0;
    }
    dw = (VFF_DELETEVROOTS | VFF_DELETEFILESHARES) & Flags;
    if (0 != dw && dw != Flags)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Mixed VFF_DELETE* and create flags");
    }
    if (((VFF_CHECKREGFLAGFIRST | VFF_CLEARREGFLAGFIRST) & Flags) &&
        (VFF_SETREGFLAGFIRST & Flags))
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Mixed VFF_SETREGFLAGFIRST & VFF_*REGFLAGFIRST");
    }

    hr = GetSetupStatus(NULL, &SetupStatus);
    if (S_OK != hr)
    {
        _PrintError(hr, "GetSetupStatus(ignored)");
        hr = S_OK;
        SetupStatus = 0;
    }

    if (VFF_CHECKREGFLAGFIRST & Flags)
    {
        if (0 == (SETUP_ATTEMPT_VROOT_CREATE & SetupStatus))
        {
            fEnable = FALSE;
        }
    }
    if (VFF_CLEARREGFLAGFIRST & Flags)
    {
        // remove "attempt vroot" flag so we don't try again

        if (SETUP_ATTEMPT_VROOT_CREATE & SetupStatus)
        {
            hr = SetSetupStatus(NULL, SETUP_ATTEMPT_VROOT_CREATE, FALSE);
            _JumpIfError(hr, error, "SetSetupStatus");
        }
    }
    if (VFF_SETREGFLAGFIRST & Flags)
    {
        // set "attempt vroot" flag so we'll try again if necessary

        if (0 == (SETUP_ATTEMPT_VROOT_CREATE & SetupStatus))
        {
            hr = SetSetupStatus(NULL, SETUP_ATTEMPT_VROOT_CREATE, TRUE);
            _JumpIfError(hr, error, "SetSetupStatus");
        }
    }

    hr = S_OK;
    if (fEnable)
    {
        // only set RunOnce on a real attempt (worker thread clears this)
        if (VFF_SETRUNONCEIFERROR & Flags)
        {
            hr = myWriteRunOnceEntry(TRUE);
            _JumpIfError(hr, error, "myWriteRunOnceEntry");
        }

        pparms = (VRFSPARMS *) LocalAlloc(
            LMEM_FIXED | LMEM_ZEROINIT,
            sizeof(*pparms));
        if (NULL == pparms)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }

        pparms->Flags = Flags;
        pparms->CAType = CAType;
        pparms->csecTimeOut = csecTimeOut;
        pparms->fAsynchronous = fAsynchronous;
        if (!fAsynchronous)
        {
            pparms->pVRootDisposition = pVRootDisposition;
            pparms->pShareDisposition = pShareDisposition;
        }
        else
        {
            hMod = LoadLibrary(g_wszCertCliDotDll);
            if (NULL == hMod)
            {
                hr = myHLastError();
                _JumpError(hr, error, "LoadLibrary");
            }
        }

        hThread = CreateThread(
            NULL,       // lpThreadAttributes (Security Attr)
            0,          // dwStackSize
            vrWorkerThread,
            pparms,     // lpParameter
            0,          // dwCreationFlags
            &ThreadId);
        if (NULL == hThread)
        {
            hr = myHLastError();
            _JumpError(hr, error, "CreateThread");
        }

        pparms = NULL;          // freed by the new thread

        DBGPRINT((DBG_SS_CERTLIBI, "VRoot Worker Thread = %x\n", ThreadId));

        // asynch? proper thread creation is all we do
        if (fAsynchronous)
        {
            hr = S_OK;
            goto error;
        }

        // Wait for the worker thread to exit
        hr = WaitForSingleObject(
                   hThread,
                   (INFINITE == csecTimeOut) ? INFINITE : csecTimeOut * 1000 );
        DBGPRINT((DBG_SS_CERTLIBI, "Wait for worker thread returns %x\n", hr));
        if ((HRESULT) WAIT_OBJECT_0 == hr)
        {
            // worker thread returned.

            if (!GetExitCodeThread(hThread, (DWORD *) &hr))
            {
                hr = myHLastError();
                _JumpError(hr, error, "GetExitCodeThread");
            }
            DBGPRINT((DBG_SS_CERTLIBI, "worker thread exit: %x\n", hr));
            if (S_OK != hr)
            {
                // If not synchronous, leave DLL loaded...

                hMod = NULL;
                _JumpError(hr, error, "vrWorkerThread");
            }
        }
        else
        {
             // timeout: abandoning thread, leave the dll loaded
             hMod = NULL;
             _PrintError(hr, "WaitForSingleObject (ignored)");

             // whack error
             hr = S_OK;
        }

    }

error:
    if (NULL != pparms)
    {
        LocalFree(pparms);
    }
    if (NULL != hThread)
    {
        CloseHandle(hThread);
    }
    if (NULL != hMod)
    {
        FreeLibrary(hMod);
    }
    DBGPRINT((DBG_SS_CERTLIBI, "myModifyVirtualRootsAndFileShares returns %x\n", hr));
    return(myHError(hr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certcli\uwbase64.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        uwbase64.cpp
//
// Contents:    obsolete base64 encode/decode implementation
//              for backward compatibility
//
// History:     3-2000       xtan created
//
//---------------------------------------------------------------------------

#include <pch.cpp>
#pragma hdrstop

#include <certsrv.h>
#include "csdisp.h"


HRESULT
ObsoleteDecodeFileA(
    IN CHAR const *pszfn,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut,
    IN DWORD Flags)
{
    HRESULT hr;
    WCHAR *pwszfn = NULL;

    if (!myConvertSzToWsz(&pwszfn, pszfn, -1))
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "myConvertSzToWsz");
    }

    hr = DecodeFileW(pwszfn, ppbOut, pcbOut, Flags);

error:
    if (NULL != pwszfn)
    {
        LocalFree(pwszfn);
    }
    return hr;
}

HRESULT
ObsoleteEncodeToFileA(
    IN CHAR const *pszfn,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD Flags)
{
    HRESULT hr;
    WCHAR *pwszfn = NULL;

    if (!myConvertSzToWsz(&pwszfn, pszfn, -1))
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "myConvertSzToWsz");
    }

    hr = EncodeToFileW(pwszfn, pbIn, cbIn, Flags);

error:
    if (NULL != pwszfn)
    {
        LocalFree(pwszfn);
    }
    return hr;
}

HRESULT
ObsoleteDecodeCertX(
    IN BOOL fUnicode,
    IN void const *pchIn,
    IN DWORD cchIn,
    IN DWORD Flags,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut)
{
    HRESULT hr;
    BYTE *pbOut = NULL;
    DWORD cbOut;
    BOOL fRet;

    //init
    *ppbOut = NULL;
    *pcbOut = 0;

    while (TRUE)
    {
        if (fUnicode)
            fRet = CryptStringToBinaryW((LPCWSTR)pchIn, cchIn, Flags, pbOut, &cbOut, NULL, NULL);
        else
            fRet = CryptStringToBinaryA((LPCSTR)pchIn, cchIn, Flags, pbOut, &cbOut, NULL, NULL);
        if (!fRet)
        {
            hr = myHLastError();
            _JumpError(hr, error, "CryptStringToBinary");
        }
        if (NULL != pbOut)
        {
            break; //done
        }
        pbOut = (BYTE*)LocalAlloc(LMEM_FIXED, cbOut);
        if (NULL == pbOut)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalALloc");
        }
    }
    *ppbOut = pbOut;
    pbOut = NULL;
    *pcbOut = cbOut;

    hr = S_OK;
error:
    if (NULL != pbOut)
    {
        LocalFree(pbOut);
    }
    return hr;
}

HRESULT
ObsoleteDecodeCertA(
    IN CHAR const *pchIn,
    IN DWORD cchIn,
    IN DWORD Flags,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut)
{
    return ObsoleteDecodeCertX(
                FALSE, //ansi
                (void const *)pchIn,
                cchIn,
                Flags,
                ppbOut,
                pcbOut);
}

HRESULT
ObsoleteDecodeCertW(
    IN CHAR const *pchIn,
    IN DWORD cchIn,
    IN DWORD Flags,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut)
{
    return ObsoleteDecodeCertX(
                TRUE, //unicode
                (void const *)pchIn,
                cchIn,
                Flags,
                ppbOut,
                pcbOut);
}


HRESULT
ObsoleteEncodeCertX(
    IN BOOL fUnicode,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD Flags,
    OUT void **ppchOut,
    OUT DWORD *pcchOut)
{ 
    HRESULT hr;
    BOOL  fRet;
    void  *pOut = NULL;
    DWORD  ccOut = 0;

    //init
    *ppchOut = NULL;
    *pcchOut = 0;

    while (TRUE)
    {
        if (fUnicode)
            fRet = CryptBinaryToStringW(
                            pbIn,
                            cbIn,
                            Flags,
                            (WCHAR*)pOut,
                            &ccOut);
        else
            fRet = CryptBinaryToStringA(
                            pbIn,
                            cbIn,
                            Flags,
                            (CHAR*)pOut,
                            &ccOut);
        if (!fRet)
        {
            hr = myHLastError();
            _JumpError(hr, error, "CryptBinaryToString");
        }
        if (NULL != pOut)
        {
            break; //done
        }
        pOut = LocalAlloc(LMEM_FIXED,
                    ccOut * (fUnicode ? sizeof(WCHAR) : sizeof(CHAR)));
        if (NULL == pOut)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
    }
    *ppchOut = pOut;
    pOut = NULL;
    *pcchOut = ccOut;

    hr = S_OK;
error:
    if (NULL != pOut)
    {
        LocalFree(pOut);
    }
    return hr;
}

HRESULT
ObsoleteEncodeCertA(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD Flags,
    OUT CHAR **ppchOut,
    OUT DWORD *pcchOut)
{
    return ObsoleteEncodeCertX(
                FALSE, //ansi
                pbIn,
                cbIn,
                Flags,
                (void**)ppchOut,
                pcchOut);
}

HRESULT
ObsoleteEncodeCertW(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD Flags,
    OUT WCHAR **ppchOut,
    OUT DWORD *pcchOut)
{
    return ObsoleteEncodeCertX(
                TRUE, //unicode
                pbIn,
                cbIn,
                Flags,
                (void**)ppchOut,
                pcchOut);
}

DWORD			// cchHeader
ObsoleteSizeBase64HeaderA(
    IN char const *pchIn,
    IN DWORD cchIn,
    IN BOOL fBegin,
    OUT DWORD *pcchSkip)
{
    DWORD cchHeader = 0;
    DWORD cb;

    //??? fBegin and pcchSkip are ignored???

    if (!CryptStringToBinaryA(
			pchIn,
			cchIn,
			CRYPT_STRING_ANY,
			NULL,
			&cb,
			&cchHeader,
			NULL))
    {
        _PrintError(myHLastError(), "CryptStringToBinaryA");
        cchHeader = MAXDWORD;
    }
    return cchHeader;
}

DWORD			// cchHeader
ObsoleteSizeBase64HeaderW(
    IN WCHAR const *pchIn,
    IN DWORD cchIn,
    IN BOOL fBegin,
    OUT DWORD *pcchSkip)
{
    DWORD cchHeader = 0;
    DWORD cb;

    //??? fBegin and pcchSkip are ignored???

    if (!CryptStringToBinaryW(
			pchIn,
			cchIn,
			CRYPT_STRING_ANY,
			NULL,
			&cb,
			&cchHeader,
			NULL))
    {
        _PrintError(myHLastError(), "CryptStringToBinaryW");
        cchHeader = MAXDWORD;
    }
    return cchHeader;
}


HRESULT
ObsoleteHexDecodeA(
    IN CHAR const *pchIn,
    IN DWORD cchIn,
    IN DWORD Flags,
    OPTIONAL OUT BYTE *pbOut,
    IN OUT DWORD *pcbOut)
{
    HRESULT hr = S_OK;
    
    if (!CryptStringToBinaryA(pchIn, cchIn, Flags, pbOut, pcbOut, NULL, NULL))
    {
	hr = myHLastError();
    }
    return(hr);
}

HRESULT
ObsoleteHexDecodeW(
    IN WCHAR const *pchIn,
    IN DWORD cchIn,
    IN DWORD Flags,
    OPTIONAL OUT BYTE *pbOut,
    IN OUT DWORD *pcbOut)
{
    HRESULT hr = S_OK;
    
    if (!CryptStringToBinaryW(pchIn, cchIn, Flags, pbOut, pcbOut, NULL, NULL))
    {
	hr = myHLastError();
    }
    return(hr);
}

HRESULT
ObsoleteHexEncodeA(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD Flags,
    OPTIONAL OUT CHAR *pchOut,
    IN OUT DWORD *pcchOut)
{
    HRESULT hr = S_OK;
    
    if (!CryptBinaryToStringA(pbIn, cbIn, Flags, pchOut, pcchOut))
    {
	hr = myHLastError();
    }
    return(hr);
}

HRESULT
ObsoleteHexEncodeW(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD Flags,
    OPTIONAL OUT WCHAR *pchOut,
    IN OUT DWORD *pcchOut)
{
    HRESULT hr = S_OK;
    
    if (!CryptBinaryToStringW(pbIn, cbIn, Flags, pchOut, pcchOut))
    {
	hr = myHLastError();
    }
    return(hr);
}

HRESULT
ObsoleteBase64DecodeA(
    IN CHAR const *pchIn,
    IN DWORD cchIn,
    OPTIONAL OUT BYTE *pbOut,
    IN OUT DWORD *pcbOut)
{
    HRESULT hr = S_OK;
    
    if (!CryptStringToBinaryA(
			pchIn,
			cchIn,
			CRYPT_STRING_BASE64,
			pbOut,
			pcbOut,
			NULL,
			NULL))
    {
	hr = myHLastError();
    }
    return(hr);
}

HRESULT
ObsoleteBase64DecodeW(
    IN WCHAR const *pchIn,
    IN DWORD cchIn,
    OPTIONAL OUT BYTE *pbOut,
    IN OUT DWORD *pcbOut)
{
    HRESULT hr = S_OK;
    
    if (!CryptStringToBinaryW(
			pchIn,
			cchIn,
			CRYPT_STRING_BASE64,
			pbOut,
			pcbOut,
			NULL,
			NULL))
    {
	hr = myHLastError();
    }
    return(hr);
}

HRESULT
ObsoleteBase64EncodeA(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OPTIONAL OUT CHAR *pchOut,
    IN OUT DWORD *pcchOut)
{
    HRESULT hr = S_OK;
    
    if (!CryptBinaryToStringA(pbIn, cbIn, CRYPT_STRING_BASE64, pchOut, pcchOut))
    {
	hr = myHLastError();
    }
    return(hr);
}

HRESULT
ObsoleteBase64EncodeW(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OPTIONAL OUT WCHAR *pchOut,
    IN OUT DWORD *pcchOut)
{
    HRESULT hr = S_OK;
    
    if (!CryptBinaryToStringW(pbIn, cbIn, CRYPT_STRING_BASE64, pchOut, pcchOut))
    {
	hr = myHLastError();
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certclib\alloc.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        alloc.cpp
//
// Contents:    Cert Server debug implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include <assert.h>

#define __dwFILE__	__dwFILE_CERTCLIB_ALLOC_CPP__


#if DBG_CERTSRV

#undef FormatMessageW
#undef LocalAlloc
#undef LocalReAlloc
#undef LocalFree

#undef CoTaskMemAlloc
#undef CoTaskMemRealloc
#undef CoTaskMemFree

#undef StringFromCLSID
#undef StringFromIID

#undef SysAllocString
#undef SysReAllocString
#undef SysAllocStringLen
#undef SysReAllocStringLen
#undef SysFreeString
#undef SysAllocStringByteLen
#undef PropVariantClear
#undef VariantClear
#undef VariantChangeType
#undef VariantChangeTypeEx


DWORD g_MemTrack = 0;

#define MTF_UNREGISTERED	0x00000002
#define MTF_ALLOCTRACE		0x00000004
#define MTF_FREETRACE		0x00000008
#define MTF_STACKTRACE		0x00000010

typedef struct _RMALLOC
{
    LONG cAlloc;
    LONG cAllocTotal;
} RMALLOC;

RMALLOC g_armAlloc[CSM_MAX];

#define C_BP_FRAME		16
#define C_BACK_TRACE_CHUNK	100
#define C_MEM_HEADER_CHUNK	100

typedef struct _BACKTRACE
{
    LONG   cAlloc;			// count of outstanding allocations
    LONG   cAllocTotal;			// count of total allocations
    LONG   cbAlloc;			// size of outstanding allocations
    LONG   cbAllocTotal;		// size of total allocations
    ULONG  apCaller[C_BP_FRAME];	// stack trace
} BACKTRACE;

typedef struct _MEMHEADER
{
    DWORD       iBackTrace;	// backtrace index
    VOID const *pvMemory;	// Pointer to memory block allocated
    LONG        cbMemory;	// Size of memory block allocated
    DWORD       Flags;		// Allocator flags
} MEMHEADER;


// critical section around myRegister APIs since they
// operate on global data structures
CRITICAL_SECTION g_critsecRegisterMemory;
BOOL g_fRegisterMemoryCritSecInit = FALSE;



VOID
RegisterMemoryEnterCriticalSection(VOID)
{
    HRESULT hr;
    
    __try
    {
	if (!g_fRegisterMemoryCritSecInit)
	{
	    InitializeCriticalSection(&g_critsecRegisterMemory);
	    g_fRegisterMemoryCritSecInit = TRUE;
	}
	EnterCriticalSection(&g_critsecRegisterMemory);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
}


VOID
RegisterMemoryLeaveCriticalSection(VOID)
{
    if (g_fRegisterMemoryCritSecInit)
    {
	LeaveCriticalSection(&g_critsecRegisterMemory);
    }
}


BACKTRACE *g_rgbt = NULL;
DWORD g_cbtMax = 0;
DWORD g_cbt = 0;

MEMHEADER *g_rgmh = NULL;
DWORD g_cmhMax = 0;
DWORD g_cmh = 0;


MEMHEADER *
AllocMemHeader()
{
    if (g_cmh >= g_cmhMax)
    {
	DWORD cb = (C_MEM_HEADER_CHUNK + g_cmhMax) * sizeof(g_rgmh[0]);
	MEMHEADER *rgmhT;

	if (NULL == g_rgmh)
	{
	    rgmhT = (MEMHEADER *) LocalAlloc(LMEM_FIXED, cb);
	}
	else
	{
	    rgmhT = (MEMHEADER *) LocalReAlloc(g_rgmh, cb, LMEM_MOVEABLE);
	}
	if (NULL == rgmhT)
	{
	    DBGPRINT((
		DBG_SS_CERTLIB,
		"Error allocating memtrack header\n"));
	    return(NULL);
	}
	g_rgmh = rgmhT;
	g_cmhMax += C_MEM_HEADER_CHUNK;
    }
    return(&g_rgmh[g_cmh++]);
}


MEMHEADER *
LookupMemHeader(
    IN VOID const *pv)
{
    MEMHEADER *pmh;
    MEMHEADER *pmhEnd;

    pmh = g_rgmh;
    pmhEnd = &g_rgmh[g_cmh];

    while (pmh < pmhEnd)
    {
	if (pv == pmh->pvMemory)
	{
	    return(pmh);
	}
	pmh++;
    }
    return(NULL);
}


VOID
FreeMemHeader(
    IN MEMHEADER *pmh)
{
    MEMHEADER *pmhLast;

    assert(1 <= g_cmh);
    pmhLast = &g_rgmh[g_cmh - 1];

    *pmh = *pmhLast;
    g_cmh--;
}


BACKTRACE *
AllocBackTrace(
    OUT DWORD *pibt)
{
    if (g_cbt >= g_cbtMax)
    {
	DWORD cb = (C_BACK_TRACE_CHUNK + g_cbtMax) * sizeof(g_rgbt[0]);
	BACKTRACE *rgbtT;

	if (NULL == g_rgbt)
	{
	    rgbtT = (BACKTRACE *) LocalAlloc(LMEM_FIXED, cb);
	}
	else
	{
	    rgbtT = (BACKTRACE *) LocalReAlloc(g_rgbt, cb, LMEM_MOVEABLE);
	    DBGPRINT((
		DBG_SS_CERTLIB,
		"Realloc'd memtrack backtrace from %x to %x\n",
		g_rgbt,
		rgbtT));
	}
	if (NULL == rgbtT)
	{
	    DBGPRINT((
		DBG_SS_CERTLIB,
		"Error allocating memtrack backtrace\n"));
	    return(NULL);
	}
	g_rgbt = rgbtT;
	g_cbtMax += C_BACK_TRACE_CHUNK;
    }
    *pibt = g_cbt + 1;
    return(&g_rgbt[g_cbt++]);
}


BACKTRACE *
LookupBackTrace(
    IN BACKTRACE *pbtIn,
    OUT DWORD *pibt)
{
    BACKTRACE *pbt;
    BACKTRACE *pbtEnd;

    pbt = g_rgbt;
    pbtEnd = &g_rgbt[g_cbt];

    while (pbt < pbtEnd)
    {
	if (0 == memcmp(pbt->apCaller, pbtIn->apCaller, sizeof(pbt->apCaller)))
	{
	    *pibt = SAFE_SUBTRACT_POINTERS(pbt, g_rgbt) + 1;
	    return(pbt);
	}
	pbt++;
    }
    return(NULL);
}


BACKTRACE *
BackTraceFromIndex(
    IN DWORD ibt)
{
    BACKTRACE *pbt = NULL;

    if (0 == ibt)
    {
	DBGPRINT((DBG_SS_CERTLIB, "BackTraceFromIndex(0)\n"));
    }
    else if (g_cbt < ibt)
    {
	DBGPRINT((
	    DBG_SS_CERTLIB,
	    "BackTraceFromIndex(%u) -- out of range\n",
	    ibt));
    }
    else
    {
	pbt = &g_rgbt[ibt - 1];
    }
    return(pbt);
}


VOID
ReadEnvironmentFlags(VOID)
{
    HRESULT hr;
    DWORD MemTrack;
    DWORD cb;
    DWORD dwDisposition;
    DWORD dwType;
    HKEY hkey = NULL;
    char *pszEnvVar;

    pszEnvVar = getenv(szCERTSRV_MEMTRACK);
    if (NULL != pszEnvVar)
    {
	g_MemTrack = (DWORD) strtol(pszEnvVar, NULL, 16);
    }
    else
    {
	hr = RegOpenKeyEx(
			HKEY_LOCAL_MACHINE,
			wszREGKEYCONFIGPATH,
			0,
			KEY_READ,
			&hkey);
	if (S_OK == hr)
	{
	    cb = sizeof(MemTrack);
	    hr = RegQueryValueEx(
			    hkey,
			    wszREGCERTSRVMEMTRACK,
			    0,
			    &dwType,
			    (BYTE *) &MemTrack,
			    &cb);
	    if (S_OK == hr && REG_DWORD == dwType && sizeof(MemTrack) == cb)
	    {
		g_MemTrack = MemTrack;
	    }
	}
    }

//error:
    if (NULL != hkey)
    {
	RegCloseKey(hkey);
    }
}


VOID
CaptureStackBackTrace(
    EXCEPTION_POINTERS *pep,
    ULONG cSkip,
    ULONG cFrames,
    ULONG *aeip)
{
    ZeroMemory(aeip, cFrames * sizeof(aeip[0]));

#if i386 == 1
    ULONG ieip, *pebp;
    ULONG *pebpMax = (ULONG *) MAXLONG; // 2 * 1024 * 1024 * 1024; // 2 gig - 1
    ULONG *pebpMin = (ULONG *) (64 * 1024);	// 64k

    if (pep == NULL)
    {
        ieip = 0;
        cSkip++;                    // always skip current frame
        pebp = ((ULONG *) &pep) - 2;
    }
    else
    {
        ieip = 1;
        assert(cSkip == 0);
        aeip[0] = pep->ContextRecord->Eip;
        pebp = (ULONG *) pep->ContextRecord->Ebp;
    }
    if (pebp >= pebpMin && pebp < pebpMax)
    {
        __try
        {
            for ( ; ieip < cSkip + cFrames; ieip++)
            {
                if (ieip >= cSkip)
                {
                    aeip[ieip - cSkip] = *(pebp + 1);  // save an eip
                }

                ULONG *pebpNext = (ULONG *) *pebp;
                if (pebpNext < pebp + 2 ||
		    pebpNext >= pebpMax - 1 ||
		    pebpNext >= pebp + (256 * 1024) / sizeof(pebp[0]))
                {
                    break;
                }
                pebp = pebpNext;
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            ;
        }
    }
#endif // i386 == 1
}


WCHAR const *
wszAllocator(
    IN DWORD Flags)
{
    WCHAR const *pwsz;

    switch (Flags)
    {
	case CSM_LOCALALLOC:	pwsz = L"LocalAlloc";	  break;
	case CSM_COTASKALLOC:	pwsz = L"CoTaskMemAlloc"; break;
	case CSM_SYSALLOC:	pwsz = L"SysAllocString"; break;
	case CSM_MALLOC:	pwsz = L"malloc";	  break;
	case CSM_NEW:		pwsz = L"new";		  break;
	case CSM_NEW | CSM_GLOBALDESTRUCTOR:
				pwsz = L"new-global";	  break;
	default:		pwsz = L"???";		  break;
    }
    return(pwsz);
}


WCHAR const *
wszFreeer(
    IN DWORD Flags)
{
    WCHAR const *pwsz;

    switch (Flags)
    {
	case CSM_LOCALALLOC:	pwsz = L"LocalFree";	 break;
	case CSM_COTASKALLOC:	pwsz = L"CoTaskMemFree"; break;
	case CSM_SYSALLOC:	pwsz = L"SysFreeString"; break;
	case CSM_MALLOC:	pwsz = L"free";		 break;
	case CSM_NEW:		pwsz = L"delete";	 break;
	case CSM_NEW | CSM_GLOBALDESTRUCTOR:
				pwsz = L"delete-global"; break;
	default:		pwsz = L"???";		 break;
    }
    return(pwsz);
}


VOID
DumpMemBlock(
    IN WCHAR const *pwsz,
    IN VOID const *pvMemory,
    IN DWORD cbMemory,
    IN DWORD Flags,
    IN DWORD ibt,
    OPTIONAL IN BACKTRACE const *pbt)
{
    DBGPRINT((
	DBG_SS_CERTLIB,
	"%ws%wspv=%-6x cb=%-4x f=%x(%ws) pbt[%d]=%x:\n",
	pwsz,
	L'\0' != *pwsz? L": " : L"",
	pvMemory,
	cbMemory,
	Flags,
	wszAllocator(Flags),
	ibt,
	pbt));

    if (NULL != pbt && DbgIsSSActive(DBG_SS_CERTLIB))
    {
	DBGPRINT((MAXDWORD, "%d: ", ibt));

        for (int i = 0; i < ARRAYSIZE(pbt->apCaller); i++)
        {
            if (NULL == pbt->apCaller[i])
	    {
                break;
	    }
            DBGPRINT((MAXDWORD, "ln %x;", pbt->apCaller[i]));
        }
        DBGPRINT((MAXDWORD, "\n"));
    }
}


VOID
myRegisterMemDump()
{
    MEMHEADER *pmh;
    MEMHEADER *pmhEnd;
    LONG cTotal;
    LONG cbTotal;

    cTotal = 0;
    cbTotal = 0;

    RegisterMemoryEnterCriticalSection();

    __try
    {
        pmh = g_rgmh;
        pmhEnd = &g_rgmh[g_cmh];

        while (pmh < pmhEnd)
        {
	    if (0 == (CSM_GLOBALDESTRUCTOR & pmh->Flags) ||
		(MTF_ALLOCTRACE & g_MemTrack))
	    {
		if (0 == cTotal)
		{
		    if (DbgIsSSActive(DBG_SS_CERTLIB))
		    {
			DBGPRINT((MAXDWORD, "\n"));
		    }
		    DBGPRINT((DBG_SS_CERTLIB, "Allocated Memory Blocks:\n"));
		}
		cTotal++;
		cbTotal += pmh->cbMemory;

		DumpMemBlock(
			L"",
			pmh->pvMemory,
			pmh->cbMemory,
			pmh->Flags,
			pmh->iBackTrace,
			BackTraceFromIndex(pmh->iBackTrace));
	    }
	    pmh++;
        }
        if (0 != cTotal)
        {
	    DBGPRINT((DBG_SS_CERTLIB, "Total: c=%x cb=%x\n\n", cTotal, cbTotal));
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    RegisterMemoryLeaveCriticalSection();
}


VOID *
_VariantMemory(
    IN PROPVARIANT const *pvar,
    OUT DWORD *pFlags,
    OPTIONAL OUT DWORD *pcb)
{
    VOID *pv = NULL;
    DWORD cb = 0;
    BOOL fString = FALSE;

    *pFlags = CSM_COTASKALLOC;
    if (NULL != pcb)
    {
	*pcb = 0;
    }
    switch (pvar->vt)
    {
	case VT_BSTR:
	    pv = pvar->bstrVal;
	    fString = TRUE;
	    *pFlags = CSM_SYSALLOC;
	    break;

	case VT_BYREF | VT_BSTR:
	    pv = *pvar->pbstrVal;
	    fString = TRUE;
	    *pFlags = CSM_SYSALLOC;
	    break;

	case VT_LPWSTR:
	    pv = pvar->pwszVal;
	    fString = TRUE;
	    break;

	case VT_BLOB:
	    pv = pvar->blob.pBlobData;
	    cb = pvar->blob.cbSize;
	    break;
    }
    if (NULL != pcb)
    {
	if (fString)
	{
	    cb = (wcslen((WCHAR const *) pv) + 1) * sizeof(WCHAR);
	}
	*pcb = cb;
    }
    return(pv);
}


VOID
myRegisterMemAlloc(
    IN VOID const *pv,
    IN LONG cb,
    IN DWORD Flags)
{
    BACKTRACE bt;
    MEMHEADER *pmh;
    BACKTRACE *pbt;

    if (CSM_VARIANT == Flags)
    {
	pv = _VariantMemory((PROPVARIANT const *) pv, &Flags, (DWORD *) &cb);
	if (NULL == pv)
	{
	    return;	// nothing to register
	}
    }
    RegisterMemoryEnterCriticalSection();

    __try
    {
	static BOOL s_fFirst = TRUE;

        if (s_fFirst)
        {
	    ReadEnvironmentFlags();
	    s_fFirst = FALSE;
        }
        if (0 != g_MemTrack)
        {
            // Do not register NULL as an allocation
            CSASSERT(NULL != pv);

            // see if we already have a reference to this memory

            pmh = LookupMemHeader(pv);
            if (NULL != pmh)
            {
	        DBGPRINT((
		    DBG_SS_CERTLIB,
		    "Memory Leak: Tracked memory address reused. Previously allocated:\n"));
	        DumpMemBlock(
		        L"Memory leak",
		        pv,
		        pmh->cbMemory,
		        pmh->Flags,
			pmh->iBackTrace,
			BackTraceFromIndex(pmh->iBackTrace));

                CSASSERT(!"Tracked memory address reused");
                FreeMemHeader(pmh);
            }


	    pmh = AllocMemHeader();
	    if (NULL != pmh)
	    {
		DWORD ibt;

	        CaptureStackBackTrace(NULL, 0, C_BP_FRAME, bt.apCaller);

	        pbt = LookupBackTrace(&bt, &ibt);
	        if (NULL != pbt)
	        {
		    pbt->cAlloc++;
		    pbt->cAllocTotal++;
		    pbt->cbAlloc += cb;
		    pbt->cbAllocTotal += cb;
	        }
	        else
	        {
		    pbt = AllocBackTrace(&ibt);
		    if (NULL != pbt)
		    {
		        pbt->cAlloc = 1;
		        pbt->cAllocTotal = 1;
		        pbt->cbAlloc = cb;
		        pbt->cbAllocTotal = cb;
		        CopyMemory(pbt->apCaller, bt.apCaller, sizeof(pbt->apCaller));
		    }
	        }
	        if (NULL != pbt)
	        {
		    pmh->iBackTrace = ibt;
		    pmh->pvMemory = pv;
		    pmh->cbMemory = cb;
		    pmh->Flags = Flags;

		    CSASSERT(ARRAYSIZE(g_armAlloc) > Flags);
		    g_armAlloc[Flags].cAlloc++;
		    g_armAlloc[Flags].cAllocTotal++;
		    if (MTF_ALLOCTRACE & g_MemTrack)
		    {
		        DBGPRINT((
			    DBG_SS_CERTLIB,
			    "Alloc: pmh=%x: pv=%x cb=%x f=%x(%ws) -- pbt[%d]=%x: c=%x, cb=%x\n",
			    pmh,
			    pmh->pvMemory,
			    pmh->cbMemory,
			    pmh->Flags,
			    wszAllocator(pmh->Flags),
			    SAFE_SUBTRACT_POINTERS(pbt, g_rgbt),
			    pbt,
			    pbt->cAlloc,
			    pbt->cbAlloc));
			if (MTF_STACKTRACE & g_MemTrack)
			{
			    DumpMemBlock(
				    L"Alloc Trace memory block",
				    pv,
				    pmh->cbMemory,	// cbMemory
				    pmh->Flags,		// Flags
				    pmh->iBackTrace,	// ibt
				    pbt);
			}
		    }
	        }
	        else
	        {
		    FreeMemHeader(pmh);
	        }
	    } // if no problem allocating pmh
        } // if g_MemTrack
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    RegisterMemoryLeaveCriticalSection();
}


VOID
myRegisterMemFree(
    IN VOID const *pv,
    IN DWORD Flags)
{
    MEMHEADER *pmh;

    if (CSM_VARIANT == Flags)
    {
	pv = _VariantMemory((PROPVARIANT const *) pv, &Flags, NULL);
	if (NULL == pv)
	{
	    return;	// nothing to register
	}
    }
    RegisterMemoryEnterCriticalSection();
    CSASSERT(CSM_MAX > (~CSM_GLOBALDESTRUCTOR & Flags));

    __try
    {
        pmh = LookupMemHeader(pv);
        if (NULL != pmh)
        {
	    BACKTRACE *pbt = BackTraceFromIndex(pmh->iBackTrace);

	    if (CSM_GLOBALDESTRUCTOR & Flags)
	    {
		if ((CSM_GLOBALDESTRUCTOR | pmh->Flags) != Flags)
		{
		    BACKTRACE bt;

		    CaptureStackBackTrace(NULL, 0, C_BP_FRAME, bt.apCaller);
		    DumpMemBlock(
			    L"Wrong memory allocator for global destructor",
			    pv,
			    MAXDWORD,	// cbMemory
			    MAXDWORD,	// Flags
			    MAXDWORD,	// ibt
			    &bt);
		    CSASSERT(!"Wrong memory allocator for global destructor");
		}
		else
		{
		    pmh->Flags |= CSM_GLOBALDESTRUCTOR;
		}
	    }
	    else
	    {
		g_armAlloc[Flags].cAlloc--;

		pbt->cAlloc--;
		pbt->cbAlloc -= pmh->cbMemory;

		if (CSM_GLOBALDESTRUCTOR & pmh->Flags)
		{
		    Flags |= CSM_GLOBALDESTRUCTOR;
		}
		if (pmh->Flags != Flags)
		{
		    DBGPRINT((
			DBG_SS_CERTLIB,
			"Wrong memory allocator: Freed with %ws, Allocated by %ws\n",
			wszFreeer(Flags),
			wszAllocator(pmh->Flags)));
		    DumpMemBlock(
			    L"Wrong memory allocator",
			    pv,
			    pmh->cbMemory,
			    pmh->Flags,
			    pmh->iBackTrace,
			    BackTraceFromIndex(pmh->iBackTrace));
		    CSASSERT(pmh->Flags == Flags);
		}
		else if (MTF_FREETRACE & g_MemTrack)
		{
		    DBGPRINT((
			DBG_SS_CERTLIB,
			"Free: pmh=%x: pv=%x cb=%x f=%x(%ws) -- pbt[%d]=%x: c=%x, cb=%x\n",
			pmh,
			pv,
			pmh->cbMemory,
			pmh->Flags,
			wszAllocator(pmh->Flags),
			pmh->iBackTrace,
			pbt,
			pbt->cAlloc,
			pbt->cbAlloc));
		    if (MTF_STACKTRACE & g_MemTrack)
		    {
			BACKTRACE bt;

			CaptureStackBackTrace(NULL, 0, C_BP_FRAME, bt.apCaller);
			DumpMemBlock(
				L"Free Trace memory block(alloc)",
				pv,
				pmh->cbMemory,		// cbMemory
				pmh->Flags,		// Flags
				pmh->iBackTrace,	// ibt
				pbt);
			DumpMemBlock(
				L"Free Trace memory block(free)",
				pv,
				pmh->cbMemory,		// cbMemory
				pmh->Flags,		// Flags
				MAXDWORD,		// ibt
				&bt);
		    }
		}
		FreeMemHeader(pmh);
	    }
        }
        else if (MTF_UNREGISTERED & g_MemTrack)
        {
	    BACKTRACE bt;

	    CaptureStackBackTrace(NULL, 0, C_BP_FRAME, bt.apCaller);
	    DumpMemBlock(
		    L"Unregistered memory block",
		    pv,
		    MAXDWORD,	// cbMemory
		    MAXDWORD,	// Flags
		    MAXDWORD,	// ibt
		    &bt);
	    CSASSERT(!"Unregistered memory block");
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    RegisterMemoryLeaveCriticalSection();
}


DWORD
myFormatMessageW(
    IN DWORD dwFlags,
    IN LPCVOID lpSource,
    IN DWORD dwMessageId,
    IN DWORD dwLanguageId,
    OUT LPWSTR lpBuffer,
    IN DWORD nSize,
    IN va_list *Arguments)
{
    DWORD cwc;

    cwc = FormatMessage(
		    dwFlags,
		    lpSource,
		    dwMessageId,
		    dwLanguageId,
		    lpBuffer,
		    nSize,
		    Arguments);
    if (cwc != 0 && (FORMAT_MESSAGE_ALLOCATE_BUFFER & dwFlags))
    {
	myRegisterMemAlloc(
		    *(WCHAR **) lpBuffer,
		    (cwc + 1) * sizeof(WCHAR),
		    CSM_LOCALALLOC);
    }
    return(cwc);
}


HLOCAL
myLocalAlloc(
    IN UINT uFlags,
    IN UINT uBytes)
{
    HLOCAL hMem;

    // one of these should always be specified (see LocalAlloc specification)
    assert((LMEM_FIXED == (uFlags & LMEM_FIXED))  ||
           (LMEM_MOVEABLE == (uFlags & LMEM_MOVEABLE)) );

    hMem = LocalAlloc(uFlags, uBytes);
    if (NULL != hMem)
    {
	myRegisterMemAlloc(hMem, uBytes, CSM_LOCALALLOC);
    }
    return(hMem);
}


HLOCAL
myLocalReAlloc(
    IN HLOCAL hMem,
    IN UINT uBytes,
    IN UINT uFlags)
{
    HLOCAL hMemNew;

    // if realloc called without MOVEABLE flag, realloc can't relocate allocation
    assert(LMEM_MOVEABLE == (uFlags & LMEM_MOVEABLE));

    hMemNew = LocalReAlloc(hMem, uBytes, uFlags);
    if (NULL != hMemNew)
    {
	myRegisterMemFree(hMem, CSM_LOCALALLOC);
	myRegisterMemAlloc(hMemNew, uBytes, CSM_LOCALALLOC);
    }

    return(hMemNew);
}


HLOCAL
myLocalFree(
    IN HLOCAL hMem)
{
    myRegisterMemFree(hMem, CSM_LOCALALLOC);
    return(LocalFree(hMem));
}


VOID *
myCoTaskMemAlloc(
    IN ULONG cb)
{
    VOID *pv;

    pv = CoTaskMemAlloc(cb);
    if (NULL != pv)
    {
	myRegisterMemAlloc(pv, cb, CSM_COTASKALLOC);
    }
    return(pv);
}


VOID *
myCoTaskMemRealloc(
    IN VOID *pv,
    IN ULONG cb)
{
    VOID *pvNew;

    pvNew = CoTaskMemRealloc(pv, cb);
    if (NULL != pvNew)
    {
	myRegisterMemFree(pv, CSM_COTASKALLOC);
	myRegisterMemAlloc(pvNew, cb, CSM_COTASKALLOC);
    }
    return(pvNew);
}


VOID
myCoTaskMemFree(
    IN VOID *pv)
{
    myRegisterMemFree(pv, CSM_COTASKALLOC);
    CoTaskMemFree(pv);
}


HRESULT
myStringFromCLSID(
    IN REFCLSID rclsid,
    OUT LPOLESTR FAR *ppwsz)
{
    HRESULT hr;

    hr = StringFromCLSID(rclsid, ppwsz);
    _JumpIfError(hr, error, "StringFromCLSID");

    if (NULL != *ppwsz)
    {
	myRegisterMemAlloc(
		    *ppwsz, (wcslen(*ppwsz) + 1) * sizeof(WCHAR),
		    CSM_COTASKALLOC);
    }

error:
    return(hr);
}


HRESULT
myStringFromIID(
    IN REFIID rclsid,
    OUT LPOLESTR FAR *ppwsz)
{
    HRESULT hr;

    hr = StringFromIID(rclsid, ppwsz);
    _JumpIfError(hr, error, "StringFromIID");

    if (NULL != *ppwsz)
    {
	myRegisterMemAlloc(
		    *ppwsz, (wcslen(*ppwsz) + 1) * sizeof(WCHAR),
		    CSM_COTASKALLOC);
    }

error:
    return(hr);
}


BSTR
mySysAllocString(
    IN const OLECHAR *pwszIn)
{
    BSTR str;

    str = SysAllocString(pwszIn);
    if (NULL != str)
    {
	myRegisterMemAlloc(str, (wcslen(pwszIn) + 1) * sizeof(WCHAR), CSM_SYSALLOC);
    }
    return(str);
}


INT
mySysReAllocString(
    IN OUT BSTR *pstr,
    IN const OLECHAR *pwszIn)
{
    BSTR str = *pstr;
    INT i;

    i = SysReAllocString(pstr, pwszIn);
    if (i)
    {
	myRegisterMemFree(str, CSM_SYSALLOC);
	myRegisterMemAlloc(*pstr, (wcslen(pwszIn) + 1) * sizeof(WCHAR), CSM_SYSALLOC);
    }
    return(i);
}


BSTR
mySysAllocStringLen(
    IN const OLECHAR *pwcIn,
    IN UINT cwc)
{
    BSTR str;

    str = SysAllocStringLen(pwcIn, cwc);
    if (NULL != str)
    {
	myRegisterMemAlloc(str, cwc * sizeof(WCHAR), CSM_SYSALLOC);
    }
    return(str);
}


INT
mySysReAllocStringLen(
    IN OUT BSTR *pstr,
    IN const OLECHAR *pwcIn,
    IN UINT cwc)
{
    BSTR str = *pstr;
    INT i;

    i = SysReAllocStringLen(pstr, pwcIn, cwc);
    if (i)
    {
	myRegisterMemFree(str, CSM_SYSALLOC);
	myRegisterMemAlloc(*pstr, cwc * sizeof(WCHAR), CSM_SYSALLOC);
    }
    return(i);
}


VOID
mySysFreeString(
    IN BSTR str)
{
    if (NULL != str)
    {
	myRegisterMemFree(str, CSM_SYSALLOC);
    }
    SysFreeString(str);
}


BSTR
mySysAllocStringByteLen(
    LPCSTR pszIn,
    UINT cb)
{
    BSTR str;

    str = SysAllocStringByteLen(pszIn, cb);
    if (NULL != str)
    {
	myRegisterMemAlloc(str, cb, CSM_SYSALLOC);
    }
    return(str);
}


VOID
_RegisterVariantMemAlloc(
    IN PROPVARIANT *pvar)
{
    VOID *pv;
    DWORD Flags;
    DWORD cb;
    
    pv = _VariantMemory(pvar, &Flags, &cb);
    if (NULL != pv)
    {
	myRegisterMemAlloc(pv, cb, Flags);
    }
}


VOID
_RegisterVariantMemFree(
    IN PROPVARIANT *pvar)
{
    VOID *pv;
    DWORD Flags;
    
    pv = _VariantMemory(pvar, &Flags, NULL);
    if (NULL != pv)
    {
	myRegisterMemFree(pv, Flags);
    }
}


HRESULT
myPropVariantClear(
    IN PROPVARIANT *pvar)
{
    _RegisterVariantMemFree(pvar);
    return(PropVariantClear(pvar));
}


HRESULT
myVariantClear(
    IN VARIANTARG *pvar)
{
    _RegisterVariantMemFree((PROPVARIANT *) pvar);
    return(VariantClear(pvar));
}


HRESULT
myVariantChangeType(
    OUT VARIANTARG *pvarDest,
    IN VARIANTARG *pvarSrc,
    IN unsigned short wFlags,
    IN VARTYPE vt)
{
    HRESULT hr;

    // if converting in-place, memory will be freed by the API call

    if (pvarDest == pvarSrc)
    {
	_RegisterVariantMemFree((PROPVARIANT *) pvarSrc);
    }
    hr = VariantChangeType(pvarDest, pvarSrc, wFlags, vt);
    _RegisterVariantMemAlloc((PROPVARIANT *) pvarDest);
    return(hr);
}


HRESULT
myVariantChangeTypeEx(
    OUT VARIANTARG *pvarDest,
    IN VARIANTARG *pvarSrc,
    IN LCID lcid,
    IN unsigned short wFlags,
    IN VARTYPE vt)
{
    HRESULT hr;

    // if converting in-place, memory will be freed by the API call

    if (pvarDest == pvarSrc)
    {
	_RegisterVariantMemFree((PROPVARIANT *) pvarSrc);
    }
    hr = VariantChangeTypeEx(pvarDest, pvarSrc, lcid, wFlags, vt);
    _RegisterVariantMemAlloc((PROPVARIANT *) pvarDest);
    return(hr);
}


VOID *
myNew(
    IN size_t size)
{
    VOID *pv;
    
    pv = LocalAlloc(LMEM_FIXED, size);
    if (NULL != pv)
    {
	myRegisterMemAlloc(pv, size, CSM_NEW);
    }
    return(pv);
}


VOID
myDelete(
    IN VOID *pv)
{
    myRegisterMemFree(pv, CSM_NEW);
    LocalFree(pv);
}

#endif // DBG_CERTSRV
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certclib\assert.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        assert.cpp
//
// Contents:    Cert Server wrapper routines
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#define DBG_CERTSRV_DEBUG_PRINT

#ifdef DBG_CERTSRV_DEBUG_PRINT

__inline VOID CSDbgBreakPoint(VOID)
{
    DebugBreak();
}


//+---------------------------------------------------------------------------
// Function:    CSPrintAssert, public
//
// Synopsis:    Display message and break
//
// Arguments:   [pszFailedAssertion] -- failed assertion in string form
//              [pszFileName] -- filename
//              [LineNumber]  -- line number
//              [pszMessage]  -- optional message
//
// Returns:     None
//----------------------------------------------------------------------------


char const *
csTrimPath(
    char const *pszFile)
{
    char const *psz;
    char *pszT;
    char const *pszTrim;
    static char s_path[MAX_PATH];

    if (NULL == pszFile)
    {
	pszFile = "null.cpp";
    }
    pszTrim = pszFile;
    psz = strrchr(pszFile, '\\');
    if (NULL != psz)
    {
        DWORD count = 1;

        while (count != 0 && psz > pszFile)
        {
            if (*--psz == '\\')
            {
                if (0 == strncmp(psz, "\\..\\", 4) ||
		    0 == strncmp(psz, "\\.\\", 3))
                {
                    count++;
                }
                else
                {
                    count--;
                    pszTrim = &psz[1];
                }
            }
        }
	if (strlen(pszTrim) < ARRAYSIZE(s_path))
	{
	    pszT = s_path;
	    while ('\0' != *pszTrim)
	    {
		if ('\\' == *pszTrim)
		{
		    if (0 == strncmp(pszTrim, "\\..\\", 4))
		    {
			pszTrim += 3;
			continue;
		    }
		    if (0 == strncmp(pszTrim, "\\.\\", 3))
		    {
			pszTrim += 2;
			continue;
		    }
		}
		*pszT++ = *pszTrim++;
	    }
	    *pszT = '\0';
	    pszTrim = s_path;
	}
    }
    return(pszTrim);
}


VOID
CSPrintAssert(
    IN char const *pszFailedAssertion,
    IN char const *pszFileName,
    IN ULONG LineNumber,
    IN char const *pszMessage OPTIONAL)
{
    BOOLEAN fReprint;
    char buf[1024];

    do
    {
        fReprint = FALSE;
        DBGPRINT((
                DBG_SS_ASSERT,
                "\n"
                    "*** Certificate Services Assertion failed: %hs %hs\n"
                    "*** Source File: %hs, line %ld\n"
                    "\n",
                pszMessage == NULL? "" : pszMessage,
                pszFailedAssertion,
                csTrimPath(pszFileName),
                LineNumber));
        if (IsDebuggerPresent())
        {
#if i386
            _asm  xor  al,al
#endif
            CSDbgBreakPoint();
#if i386
            _asm  mov  byte ptr [fReprint],al
#endif
        }
    }
    while (fReprint);
}


BOOL
csShouldPrintError(
    IN HRESULT hr,
    IN HRESULT hrquiet)
{
    BOOL fPrint = TRUE;

    if (myIsDelayLoadHResult(hr))
    {
#if DBG_CERTSRV
        if (!DbgIsSSActive(DBG_SS_MODLOAD))
#endif
        {
            fPrint = FALSE;
        }
    }
    if (S_OK != hrquiet && hrquiet == hr)
    {
#if DBG_CERTSRV
        if (!DbgIsSSActive(DBG_SS_NOQUIET))
#endif
        {
            fPrint = FALSE;
        }
    }
    return(fPrint);
}



VOID
CSPrintError(
    IN char const *pszMessage,
    OPTIONAL IN WCHAR const *pwszData,
    IN char const *pszFile,
    IN DWORD dwLine,
    IN HRESULT hr,
    IN HRESULT hrquiet)
{
    char acherr[1024];
    WCHAR awchr[cwcHRESULTSTRING];

    if (csShouldPrintError(hr, hrquiet))
    {
        if (NULL != pwszData)
        {
            if (-1 == _snprintf(
                            acherr,
                            sizeof(acherr),
                            "%hs(%ws)",
                            pszMessage,
                            pwszData))
            {
                strcpy(&acherr[sizeof(acherr) - 4], "...");
            }
            pszMessage = acherr;
        }
        DBGPRINT((
                DBG_SS_ERROR,
                "%hs(%u): %hs: error %ws\n",
                csTrimPath(pszFile),
                dwLine,
                pszMessage,
                myHResultToString(awchr, hr)));
    }
}


VOID
CSPrintErrorInt(
    IN char const *pszMessage,
    IN DWORD dwData,
    IN char const *pszFile,
    IN DWORD dwLine,
    IN HRESULT hr,
    IN HRESULT hrquiet)
{
    char achdata[32];
    WCHAR awchr[cwcHRESULTSTRING];

    if (csShouldPrintError(hr, hrquiet))
    {
        if (-1 == _snprintf(achdata, sizeof(achdata), "0x%x(%d)", dwData, dwData))
        {
            strcpy(&achdata[sizeof(achdata) - 4], "...");
        }
        DBGPRINT((
                DBG_SS_ERROR,
                "%hs(%u): %hs(%hs): error %ws\n",
                csTrimPath(pszFile),
                dwLine,
                pszMessage,
                achdata,
                myHResultToString(awchr, hr)));
    }
}
#endif // DBG_CERTSRV_DEBUG_PRINT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certcli\resstr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resstr.h
//
//--------------------------------------------------------------------------

    RESSTR(IDS_COLUMN_REQUESTID),
    RESSTR(IDS_COLUMN_REQUESTRAWREQUEST),
    RESSTR(IDS_COLUMN_REQUESTRAWOLDCERTIFICATE),
    RESSTR(IDS_COLUMN_REQUESTATTRIBUTES),
    RESSTR(IDS_COLUMN_REQUESTTYPE),
    RESSTR(IDS_COLUMN_REQUESTFLAGS),
    RESSTR(IDS_COLUMN_REQUESTSTATUS),
    RESSTR(IDS_COLUMN_REQUESTSTATUSCODE),
    RESSTR(IDS_COLUMN_REQUESTDISPOSITION),
    RESSTR(IDS_COLUMN_REQUESTDISPOSITIONMESSAGE),
    RESSTR(IDS_COLUMN_REQUESTSUBMITTEDWHEN),
    RESSTR(IDS_COLUMN_REQUESTRESOLVEDWHEN),
    RESSTR(IDS_COLUMN_REQUESTREVOKEDWHEN),
    RESSTR(IDS_COLUMN_REQUESTREVOKEDEFFECTIVEWHEN),
    RESSTR(IDS_COLUMN_REQUESTREVOKEDREASON),
    RESSTR(IDS_COLUMN_REQUESTERNAME),
    RESSTR(IDS_COLUMN_REQUESTERADDRESS),
    RESSTR(IDS_COLUMN_REQUESTDISTINGUISHEDNAME),
    RESSTR(IDS_COLUMN_REQUESTRAWNAME),
    RESSTR(IDS_COLUMN_REQUESTNAMETYPE),
    RESSTR(IDS_COLUMN_REQUESTCOUNTRY),
    RESSTR(IDS_COLUMN_REQUESTORGANIZATION),
    RESSTR(IDS_COLUMN_REQUESTORGUNIT),
    RESSTR(IDS_COLUMN_REQUESTCOMMONNAME),
    RESSTR(IDS_COLUMN_REQUESTLOCALITY),
    RESSTR(IDS_COLUMN_REQUESTSTATE),
    RESSTR(IDS_COLUMN_REQUESTTITLE),
    RESSTR(IDS_COLUMN_REQUESTGIVENNAME),
    RESSTR(IDS_COLUMN_REQUESTINITIALS),
    RESSTR(IDS_COLUMN_REQUESTSURNAME),
    RESSTR(IDS_COLUMN_REQUESTDOMAINCOMPONENT),
    RESSTR(IDS_COLUMN_REQUESTEMAIL),
    RESSTR(IDS_COLUMN_REQUESTSTREETADDRESS),
    RESSTR(IDS_COLUMN_CERTIFICATEREQUESTID),
    RESSTR(IDS_COLUMN_CERTIFICATERAWCERTIFICATE),
    RESSTR(IDS_COLUMN_CERTIFICATECERTIFICATEHASH),
    RESSTR(IDS_COLUMN_CERTIFICATETYPE),
    RESSTR(IDS_COLUMN_CERTIFICATESERIALNUMBER),
    RESSTR(IDS_COLUMN_CERTIFICATEISSUERNAMEID),
    RESSTR(IDS_COLUMN_CERTIFICATENOTBEFOREDATE),
    RESSTR(IDS_COLUMN_CERTIFICATENOTAFTERDATE),
    RESSTR(IDS_COLUMN_CERTIFICATERAWPUBLICKEY),
    RESSTR(IDS_COLUMN_CERTIFICATEPUBLICKEYALGORITHM),
    RESSTR(IDS_COLUMN_CERTIFICATERAWPUBLICKEYALGORITHMPARAMETERS),
    RESSTR(IDS_COLUMN_CERTIFICATEDISTINGUISHEDNAME),
    RESSTR(IDS_COLUMN_CERTIFICATERAWNAME),
    RESSTR(IDS_COLUMN_CERTIFICATENAMETYPE),
    RESSTR(IDS_COLUMN_CERTIFICATECOUNTRY),
    RESSTR(IDS_COLUMN_CERTIFICATEORGANIZATION),
    RESSTR(IDS_COLUMN_CERTIFICATEORGUNIT),
    RESSTR(IDS_COLUMN_CERTIFICATECOMMONNAME),
    RESSTR(IDS_COLUMN_CERTIFICATELOCALITY),
    RESSTR(IDS_COLUMN_CERTIFICATESTATE),
    RESSTR(IDS_COLUMN_CERTIFICATETITLE),
    RESSTR(IDS_COLUMN_CERTIFICATEGIVENNAME),
    RESSTR(IDS_COLUMN_CERTIFICATEINITIALS),
    RESSTR(IDS_COLUMN_CERTIFICATESURNAME),
    RESSTR(IDS_COLUMN_CERTIFICATEDOMAINCOMPONENT),
    RESSTR(IDS_COLUMN_CERTIFICATEEMAIL),
    RESSTR(IDS_COLUMN_CERTIFICATESTREETADDRESS),
    RESSTR(IDS_COLUMN_CERTIFICATEUNSTRUCTUREDNAME),
    RESSTR(IDS_COLUMN_CERTIFICATEUNSTRUCTUREDADDRESS),
    RESSTR(IDS_COLUMN_REQUESTUNSTRUCTUREDNAME),
    RESSTR(IDS_COLUMN_REQUESTUNSTRUCTUREDADDRESS),
    RESSTR(IDS_COLUMN_REQUESTDEVICESERIALNUMBER),
    RESSTR(IDS_COLUMN_CERTIFICATEDEVICESERIALNUMBER),
    RESSTR(IDS_FILESHARE_REMARK),
    RESSTR(IDS_COLUMN_CERTIFICATERAWSMIMECAPABILITIES),
    RESSTR(IDS_COLUMN_EXTREQUESTID),
    RESSTR(IDS_COLUMN_EXTNAME),
    RESSTR(IDS_COLUMN_EXTFLAGS),
    RESSTR(IDS_COLUMN_EXTRAWVALUE),
    RESSTR(IDS_COLUMN_ATTRIBREQUESTID),
    RESSTR(IDS_COLUMN_ATTRIBNAME),
    RESSTR(IDS_COLUMN_ATTRIBVALUE),
    RESSTR(IDS_COLUMN_CRLROWID),
    RESSTR(IDS_COLUMN_CRLNUMBER),
    RESSTR(IDS_COLUMN_CRLMINBASE),
    RESSTR(IDS_COLUMN_CRLNAMEID),
    RESSTR(IDS_COLUMN_CRLCOUNT),
    RESSTR(IDS_COLUMN_CRLTHISUPDATE),
    RESSTR(IDS_COLUMN_CRLNEXTUPDATE),
    RESSTR(IDS_COLUMN_CRLTHISPUBLISH),
    RESSTR(IDS_COLUMN_CRLNEXTPUBLISH),
    RESSTR(IDS_COLUMN_CRLEFFECTIVE),
    RESSTR(IDS_COLUMN_CRLPROPAGATIONCOMPLETE),
    RESSTR(IDS_COLUMN_CRLRAWCRL),
    RESSTR(IDS_CAPROP_FILEVERSION),
    RESSTR(IDS_CAPROP_PRODUCTVERSION),
    RESSTR(IDS_CAPROP_EXITCOUNT),
    RESSTR(IDS_CAPROP_EXITDESCRIPTION),
    RESSTR(IDS_CAPROP_POLICYDESCRIPTION),
    RESSTR(IDS_CAPROP_CANAME),
    RESSTR(IDS_CAPROP_SANITIZEDCANAME),
    RESSTR(IDS_CAPROP_SHAREDFOLDER),
    RESSTR(IDS_CAPROP_PARENTCA),
    RESSTR(IDS_CAPROP_CATYPE),
    RESSTR(IDS_CAPROP_CASIGCERTCOUNT),
    RESSTR(IDS_CAPROP_CASIGCERT),
    RESSTR(IDS_CAPROP_CASIGCERTCHAIN),
    RESSTR(IDS_CAPROP_CAXCHGCERTCOUNT),
    RESSTR(IDS_CAPROP_CAXCHGCERT),
    RESSTR(IDS_CAPROP_CAXCHGCERTCHAIN),
    RESSTR(IDS_CAPROP_BASECRL),
    RESSTR(IDS_CAPROP_DELTACRL),
    RESSTR(IDS_CAPROP_CACERTSTATE),
    RESSTR(IDS_CAPROP_CRLSTATE),
    RESSTR(IDS_CAPROP_CAPROPIDMAX),
    RESSTR(IDS_COLUMN_CERTIFICATESUBJECTKEYIDENTIFIER),
    RESSTR(IDS_UNKNOWN_ERROR_CODE),
    RESSTR(IDS_E_UNEXPECTED),
    RESSTR(IDS_SETUP_ERROR_EXPECTED_SECTION_NAME),
    RESSTR(IDS_SETUP_ERROR_BAD_SECTION_NAME_LINE),
    RESSTR(IDS_SETUP_ERROR_SECTION_NAME_TOO_LONG),
    RESSTR(IDS_SETUP_ERROR_GENERAL_SYNTAX),
    RESSTR(IDS_SETUP_ERROR_WRONG_INF_STYLE),
    RESSTR(IDS_SETUP_ERROR_SECTION_NOT_FOUND),
    RESSTR(IDS_SETUP_ERROR_LINE_NOT_FOUND),
    RESSTR(IDS_COLUMN_REQUESTRAWARCHIVEDKEY),
    RESSTR(IDS_COLUMN_REQUESTKEYRECOVERYHASHES),
    RESSTR(IDS_CAPROP_DNSNAME),
    RESSTR(IDS_COLUMN_PROPCERTIFICATETEMPLATE),
    RESSTR(IDS_COLUMN_REQUESTSIGNERPOLICIES),
    RESSTR(IDS_COLUMN_REQUESTSIGNERAPPLICATIONPOLICIES),
    RESSTR(IDS_COLUMN_PROPCERTIFICATEENROLLMENTFLAGS),
    RESSTR(IDS_COLUMN_PROPCERTIFICATEGENERALFLAGS),
    RESSTR(IDS_COLUMN_CERTIFICATEPUBLICKEYLENGTH),
    RESSTR(IDS_CAPROP_KRACERTUSEDCOUNT),
    RESSTR(IDS_CAPROP_KRACERTCOUNT),
    RESSTR(IDS_CAPROP_KRACERT),
    RESSTR(IDS_CAPROP_KRACERTSTATE),
    RESSTR(IDS_CAPROP_ROLESEPARATIONENABLED),
    RESSTR(IDS_CAPROP_ADVANCEDSERVER),
    RESSTR(IDS_COLUMN_CRLLASTPUBLISHED),
    RESSTR(IDS_COLUMN_CRLPUBLISHATTEMPTS),
    RESSTR(IDS_COLUMN_CRLPUBLISHFLAGS),
    RESSTR(IDS_COLUMN_CRLPUBLISHSTATUSCODE),
    RESSTR(IDS_COLUMN_CRLPUBLISHERROR),
    RESSTR(IDS_COLUMN_CALLERNAME),
    RESSTR(IDS_CAPROP_TEMPLATES),
    RESSTR(IDS_CAPROP_BASECRLPUBLISHSTATUS),
    RESSTR(IDS_CAPROP_DELTACRLPUBLISHSTATUS),
    RESSTR(IDS_CAPROP_CASIGCERTCRLCHAIN),
    RESSTR(IDS_CAPROP_CAXCHGCERTCRLCHAIN),
    RESSTR(IDS_COLUMN_CERTIFICATEUPN),
    RESSTR(IDS_E_DATA_MISALIGNMENT),
    RESSTR(IDS_CAPROP_CACERTSTATUSCODE),
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certclib\autoenrl.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        autoenrl.cpp
//
// Contents:    Autoenrollment API implementation
//
// History:     3-Apr-98       petesk created
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop
#include "cainfoc.h"

#include <stdlib.h>
#include <ctype.h>
#include <windows.h>
#include <wincrypt.h>
#include <certca.h>

#define SHA_HASH_SIZE 20



//
// Build the CTL_ENTRY structure for
HRESULT BuildCTLEntry(
                 IN WCHAR ** awszCAs,
                 OUT PCTL_ENTRY *ppCTLEntry,
                 OUT DWORD *pcCTLEntry
                 )
{
    HRESULT         hr = S_OK;

    PCCERT_CONTEXT  pCertContext = NULL;
    DWORD           cbCert;
    BYTE            *pbCert = NULL;
    DWORD           cbHash = SHA_HASH_SIZE;
    PCTL_ENTRY      pCTLEntry = NULL;
    HCAINFO         hCACurrent = NULL;
    DWORD           cCA = 0;
    PBYTE           pbHash;


    // Passing in NULL or a zero length list implies that
    // we do lazy evaluation of 'pick any'.  Therefore, the
    // ctl list should be zero size.

    if((ppCTLEntry == NULL) ||
        (pcCTLEntry == NULL))
    {
        hr = E_INVALIDARG;
        goto error;
    }

    if((awszCAs == NULL) || 
       (awszCAs[0] == NULL))           
    {
        *pcCTLEntry = 0;
        *ppCTLEntry = NULL;
        goto error;
    }

    cCA = 0;
    while(awszCAs[cCA])
    {
        cCA++;
    }
    pCTLEntry = (PCTL_ENTRY)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                       sizeof(CTL_ENTRY)*cCA + SHA_HASH_SIZE*cCA);

    if(pCTLEntry == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }
    pbHash = (PBYTE)(pCTLEntry + cCA); 
    
    cCA=0;
    while(awszCAs[cCA])
    {
        hr = CAFindByName(awszCAs[cCA], NULL, 0, &hCACurrent);
        if(hr != S_OK)
        {
            goto error;
        }

        hr = CAGetCACertificate(hCACurrent, &pCertContext);
        if(hr != S_OK)
        {
            goto error;
        }

        cbHash = SHA_HASH_SIZE;

        if(!CertGetCertificateContextProperty(pCertContext,
                                          CERT_SHA1_HASH_PROP_ID,
                                          pbHash,
                                          &cbHash))
        {
            hr = myHLastError();
            goto error;
        }

        pCTLEntry[cCA].SubjectIdentifier.cbData = cbHash;
        pCTLEntry[cCA].SubjectIdentifier.pbData = pbHash;
        pbHash += cbHash;
        CertFreeCertificateContext(pCertContext);
        pCertContext = NULL;

        cCA++;
        CACloseCA(hCACurrent);
    }

    *pcCTLEntry = cCA;
    *ppCTLEntry = pCTLEntry;
    pCTLEntry = NULL;

error:

    if (pCTLEntry)
    {
        LocalFree(pCTLEntry);
    }
    if(pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
    }


    return hr;
}



HRESULT 
BuildAutoEnrollmentCTL(
             IN LPCWSTR pwszCertType,
             IN LPCWSTR pwszObjectID,
             IN BOOL    fMachine,
             IN WCHAR ** awszCAs,
             IN PCMSG_SIGNED_ENCODE_INFO pSignerInfo, 
             OUT BYTE **ppbEncodedCTL,
             OUT DWORD *pcbEncodedCTL
             )
{
    HRESULT                 hr = S_OK;

    PCERT_ENHKEY_USAGE      pKeyUsage = NULL;
    DWORD                   cbKeyUsage;
    CTL_INFO                CTLInfo;
    BYTE                    *pbEncodedCTL = NULL;
    DWORD                   cbEncodedCTL;
    LPSTR                   pszUsageIdentifier;
    CERT_EXTENSION          CertExt;
    CMSG_SIGNED_ENCODE_INFO SignerInfo;
    PCERT_EXTENSIONS        pCertExtensions = NULL;
    DWORD                   cch = 0;
    PCMSG_SIGNED_ENCODE_INFO pSigner = NULL;
    

    HCERTTYPE               hCertType = NULL;

    ZeroMemory(&CTLInfo, sizeof(CTLInfo));
    ZeroMemory(&CertExt, sizeof(CertExt));
    ZeroMemory(&SignerInfo, sizeof(SignerInfo));

    if(pSignerInfo)
    {
        pSigner = pSignerInfo;
    }
    else
    {
        pSigner = &SignerInfo;
    }
#if 0
    hr = CAFindCertTypeByName(pwszCertType, 
                              NULL, 
                              (fMachine?CT_ENUM_MACHINE_TYPES | CT_FIND_LOCAL_SYSTEM:CT_ENUM_USER_TYPES), 
                              &hCertType);

    if (S_OK != hr)
    {
        goto error;
    }

    hr = CAGetCertTypeExtensions(hCertType, &pCertExtensions);
    if (S_OK != hr)
    {
        goto error;
    }
#endif
    // set up the CTL info
    CTLInfo.dwVersion = sizeof(CTLInfo);
    CTLInfo.SubjectUsage.cUsageIdentifier = 1;
    pszUsageIdentifier = szOID_AUTO_ENROLL_CTL_USAGE;
    CTLInfo.SubjectUsage.rgpszUsageIdentifier = &pszUsageIdentifier;


    CTLInfo.ListIdentifier.cbData = (wcslen(pwszCertType) + 1) * sizeof(WCHAR);
    
    if(pwszObjectID)
    {
        CTLInfo.ListIdentifier.cbData += (wcslen(pwszObjectID)+1) * sizeof(WCHAR);
    }

    CTLInfo.ListIdentifier.pbData = (BYTE *)LocalAlloc(LMEM_ZEROINIT, CTLInfo.ListIdentifier.cbData);
    if(CTLInfo.ListIdentifier.pbData == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    if(pwszObjectID)
    {
        wcscpy((LPWSTR)CTLInfo.ListIdentifier.pbData, pwszObjectID);
        wcscat((LPWSTR)CTLInfo.ListIdentifier.pbData, L"|");
    }

    // wcscat can be used as the memory is initialized to zero
    wcscat((LPWSTR)CTLInfo.ListIdentifier.pbData, pwszCertType);

    GetSystemTimeAsFileTime(&CTLInfo.ThisUpdate); 
    CTLInfo.SubjectAlgorithm.pszObjId = szOID_OIWSEC_sha1;

    hr = BuildCTLEntry(awszCAs,
                       &CTLInfo.rgCTLEntry,
                       &CTLInfo.cCTLEntry);
    if (S_OK != hr)
    {
        goto error;
    }
#if 0
    // add all the reg info as an extension
    CTLInfo.cExtension = pCertExtensions->cExtension;
    CTLInfo.rgExtension = pCertExtensions->rgExtension;
#endif
    CTLInfo.cExtension = 0;
    CTLInfo.rgExtension = NULL;

    // encode the CTL
    *pcbEncodedCTL = 0;
    SignerInfo.cbSize = sizeof(SignerInfo);
    if (!CryptMsgEncodeAndSignCTL(PKCS_7_ASN_ENCODING,
                                  &CTLInfo, &SignerInfo, 0,
                                  NULL, pcbEncodedCTL))
    {
	hr = myHLastError();
        goto error;
    }

    if (NULL == (*ppbEncodedCTL =
        (BYTE*)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, *pcbEncodedCTL)))
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    if (!CryptMsgEncodeAndSignCTL(PKCS_7_ASN_ENCODING,
                                  &CTLInfo, pSigner, 0,
                                  *ppbEncodedCTL, 
                                  pcbEncodedCTL))
    {
	hr = myHLastError();
        goto error;
    }

error:

    if(CTLInfo.rgCTLEntry)
    {
        LocalFree(CTLInfo.rgCTLEntry);
    }
    if(CTLInfo.ListIdentifier.pbData)
    {
        LocalFree(CTLInfo.ListIdentifier.pbData);
    }
#if 0
    if (pCertExtensions)
    {
        LocalFree(pCertExtensions);
    }
#endif
    if(hCertType)
    {
        CACloseCertType(hCertType);
    }
    return hr;
}


HRESULT 
CACreateAutoEnrollmentObjectEx(
             IN LPCWSTR                     pwszCertType,
             IN LPCWSTR                     wszObjectID,
             IN WCHAR **                    awszCAs,
             IN PCMSG_SIGNED_ENCODE_INFO    pSignerInfo,
             IN LPCSTR                      StoreProvider,
             IN DWORD                       dwFlags,
             IN const void *                pvPara)
{
    HRESULT     hr = S_OK;
    BYTE        *pbEncodedCTL = NULL;
    DWORD       cbEncodedCTL;
    HCERTSTORE  hStore = 0;
    BOOL        fMachine = ((dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK) == CERT_SYSTEM_STORE_LOCAL_MACHINE);


    hr = BuildAutoEnrollmentCTL(pwszCertType,
                                wszObjectID,
                                fMachine,
                                awszCAs,
                                pSignerInfo, 
                                &pbEncodedCTL,
                                &cbEncodedCTL
                                );
    if(hr != S_OK)
    {
        goto error;
    }

    // open the Trust store and fine the CTL based on the auto enrollment usage
    hStore = CertOpenStore(StoreProvider, 0, NULL, dwFlags, pvPara);

    if(hStore == NULL)
    {
	hr = myHLastError();
        goto error;
    }

    if (!CertAddEncodedCTLToStore(hStore, 
                                  X509_ASN_ENCODING,
                                  pbEncodedCTL, 
                                  cbEncodedCTL,
                                  CERT_STORE_ADD_REPLACE_EXISTING,
                                  NULL))
    {
	hr = myHLastError();
        goto error;
    }
error:

    if (pbEncodedCTL)
    {
        LocalFree(pbEncodedCTL);
    }

    if (hStore)
    {
        CertCloseStore(hStore, 0);
    }

    return hr;
}


HRESULT 
CACreateLocalAutoEnrollmentObject(
             IN LPCWSTR                     pwszCertType,
             IN WCHAR **                    awszCAs,
             IN PCMSG_SIGNED_ENCODE_INFO    pSignerInfo,
             IN DWORD                       dwFlags)
{
    HRESULT     hr = S_OK;
    BYTE        *pbEncodedCTL = NULL;
    DWORD       cbEncodedCTL;
    HCERTSTORE  hStore = 0;
    BOOL        fMachine = ((dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK) == CERT_SYSTEM_STORE_LOCAL_MACHINE);



    hr = BuildAutoEnrollmentCTL(pwszCertType,
                                NULL,
                                fMachine,
                                awszCAs,
                                pSignerInfo, 
                                &pbEncodedCTL,
                                &cbEncodedCTL
                                );
    if(hr != S_OK)
    {
        goto error;
    }

    // open the Trust store and fine the CTL based on the auto enrollment usage
    hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_REGISTRY, 0, NULL, dwFlags, L"ACRS");

    if(hStore == NULL)
    {
	hr = myHLastError();
        goto error;
    }

    if (!CertAddEncodedCTLToStore(hStore, 
                                  X509_ASN_ENCODING,
                                  pbEncodedCTL, 
                                  cbEncodedCTL,
                                  CERT_STORE_ADD_REPLACE_EXISTING,
                                  NULL))
    {
	hr = myHLastError();
        goto error;
    }
error:

    if (pbEncodedCTL)
    {
        LocalFree(pbEncodedCTL);
    }

    if (hStore)
    {
        CertCloseStore(hStore, 0);
    }

    return hr;
}

//--------------------------------------------------------------------------------
//
//   CADeleteLocalAutoEnrollmentObject
//
//---------------------------------------------------------------------------------
HRESULT
CADeleteLocalAutoEnrollmentObject(
    IN LPCWSTR                              pwszCertType,
    IN OPTIONAL WCHAR **                    awszCAs,
    IN OPTIONAL PCMSG_SIGNED_ENCODE_INFO    pSignerInfo,
    IN DWORD                                dwFlags)
{

    HRESULT             hr=E_FAIL;
    CTL_FIND_USAGE_PARA CTLFindParam;
    LPSTR               pszUsageIdentifier=NULL;

    HCERTSTORE          hCertStore=NULL;
    PCCTL_CONTEXT       pCTLContext=NULL;   //no need to free the CTL since it is freed by the DeleteCTL call

           
    memset(&CTLFindParam, 0, sizeof(CTL_FIND_USAGE_PARA));


    if((NULL==pwszCertType)||(NULL!=awszCAs)||(NULL!=pSignerInfo))
    {
        hr=E_INVALIDARG;
        goto error;
    }

    //open the store based on dwFlags
    hCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_REGISTRY, 0, NULL, dwFlags, L"ACRS");

    if(NULL == hCertStore)
    {
	    hr = myHLastError();
        goto error;
    }

    //set up the find parameter
    CTLFindParam.cbSize=sizeof(CTLFindParam);

    CTLFindParam.SubjectUsage.cUsageIdentifier = 1;
    pszUsageIdentifier = szOID_AUTO_ENROLL_CTL_USAGE;
    CTLFindParam.SubjectUsage.rgpszUsageIdentifier = &pszUsageIdentifier;

    CTLFindParam.ListIdentifier.cbData=(wcslen(pwszCertType) + 1) * sizeof(WCHAR);
    CTLFindParam.ListIdentifier.pbData=(BYTE *)(pwszCertType);

    //only find CTLs with no signers
    CTLFindParam.pSigner=CTL_FIND_NO_SIGNER_PTR;

    //find the CTL based on the pwszCertType
    if(NULL == (pCTLContext=CertFindCTLInStore(
            hCertStore,                  
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,         
            0,                      
            CTL_FIND_USAGE,                       
            &CTLFindParam,                 
            NULL)))
    {
        hr=CRYPT_E_NOT_FOUND;
        goto error;
    }

    //delete the CTL.  The CTL is automatically freed
    if(!CertDeleteCTLFromStore(pCTLContext))
    {
	    hr = myHLastError();
        goto error;
    }

    hr=S_OK;

error:

    if(hCertStore)
        CertCloseStore(hCertStore, 0);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certclib\cainfoc.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        cainfoc.cpp
//
// Contents:    CCAInfo implemenation
//
// History:     16-Dec-97       petesk created
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include "cainfoc.h"
#include "certtype.h"
#include "csldap.h"

#include <lm.h>
#include <certca.h>
#include <polreg.h> 
#include <dsgetdc.h>
#include <winldap.h>
#include <cainfop.h>
#include <ntldap.h>

#define __dwFILE__	__dwFILE_CERTCLIB_CAINFOC_CPP__

#define wcLBRACE	L'{'
#define wcRBRACE	L'}'

LPCWSTR  g_wszEnrollmentServiceLocation = L"CN=Enrollment Services,CN=Public Key Services,CN=Services,";

#define LDAP_SECURITY_DESCRIPTOR_NAME L"NTSecurityDescriptor"

#define LDAP_CERTIFICATE_TEMPLATES_NAME L"certificateTemplates"

WCHAR *g_awszCAAttrs[] = {
                        CA_PROP_NAME, 
                        CA_PROP_DISPLAY_NAME,
                        CA_PROP_FLAGS,
                        CA_PROP_DNSNAME,
                        CA_PROP_DSLOCATION,
                        CA_PROP_CERT_DN,
                        CA_PROP_CERT_TYPES,
                        CA_PROP_SIGNATURE_ALGS,
                        CA_PROP_DESCRIPTION,
                        L"cACertificate",
                        L"objectClass",
                        LDAP_SECURITY_DESCRIPTOR_NAME,
                        NULL};


WCHAR *g_awszCANamedProps[] = {
                        CA_PROP_NAME, 
                        CA_PROP_DISPLAY_NAME,
                        CA_PROP_DNSNAME,
                        CA_PROP_DSLOCATION,
                        CA_PROP_CERT_DN,
                        CA_PROP_CERT_TYPES,
                        CA_PROP_SIGNATURE_ALGS,
                        CA_PROP_DESCRIPTION,
                        NULL};

LPWSTR g_awszSignatureAlgs[] = {
                        TEXT(szOID_RSA_MD2RSA),
                        TEXT(szOID_RSA_MD4RSA),
                        TEXT(szOID_RSA_MD5RSA),
                        TEXT(szOID_RSA_SHA1RSA),
                        NULL
                        };


//+--------------------------------------------------------------------------
// CCAInfo::~CCAInfo -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCAInfo::~CCAInfo()
{
    _Cleanup();
}


//+--------------------------------------------------------------------------
// CCAInfo::_Cleanup -- free memory
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

HRESULT
CCAInfo::_Cleanup()
{

    // Cleanup will only be called if there is no previous element
    // to reference this element, and the caller is also releaseing.

    // If there is a further element, release it.

    if (NULL != m_pNext)
    {
        m_pNext->Release();
	    m_pNext = NULL;
    }

    CCAProperty::DeleteChain(&m_pProperties);

    if (NULL != m_pCertificate)
    {
        CertFreeCertificateContext(m_pCertificate);
        m_pCertificate = NULL;
    }

    if (NULL != m_bstrDN)
    {
        CertFreeString(m_bstrDN);
        m_bstrDN = NULL;
    }

    if (NULL != m_pSD)
    {
        LocalFree(m_pSD);
        m_pSD = NULL;
    }
    return(S_OK);
}


//+--------------------------------------------------------------------------
// CCAInfo::_Cleanup -- add reference
//
// 
//+--------------------------------------------------------------------------

DWORD
CCAInfo::AddRef()
{

    return(InterlockedIncrement(&m_cRef));
}


//+--------------------------------------------------------------------------
// CCAInfo::Release -- release reference
//
// 
//+--------------------------------------------------------------------------

DWORD CCAInfo::Release()
{
    DWORD cRef;

    if (0 == (cRef = InterlockedDecrement(&m_cRef)))
    {
        delete this;
    }
    return(cRef);
}


//+--------------------------------------------------------------------------
// CCAInfo::Find -- Find CA Objects in the DS
//
// 
//+--------------------------------------------------------------------------

HRESULT 
CCAInfo::Find(
    LPCWSTR wszQuery, 
    LPCWSTR wszScope,
    DWORD   dwFlags,
    CCAInfo **ppCAInfo)

{
    HRESULT hr = S_OK;
    ULONG   ldaperr;
    LDAP *  pld = NULL;
    // Initialize LDAP session
    WCHAR * wszSearch = L"(objectCategory=pKIEnrollmentService)";
    DWORD   cSearchParam;

    CERTSTR bstrSearchParam = NULL;
    CERTSTR bstrScope = NULL;
    CERTSTR bstrConfig = NULL;
    CERTSTR bstrDomain = NULL;

    if (NULL == ppCAInfo)
    {
        hr = E_POINTER;
	    _JumpError(hr, error, "NULL parm");
    }


    // short circuit calls to a nonexistant DS
    hr = myDoesDSExist(TRUE);
    _JumpIfError4(
	    hr,
	    error,
	    "myDoesDSExist",
	    HRESULT_FROM_WIN32(ERROR_SERVER_DISABLED),
	    HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN),
	    HRESULT_FROM_WIN32(ERROR_NETWORK_UNREACHABLE));

    __try
    {

        if(CA_FLAG_SCOPE_IS_LDAP_HANDLE & dwFlags)
        {
            pld = (LDAP *)wszScope;
        }
        else
        {
	        // bind to ds
            hr = myRobustLdapBind(&pld, FALSE);

	        if(hr != S_OK)
	        {
		        _LeaveError2(
			        hr,
			        "myRobustLdapBind",
			        HRESULT_FROM_WIN32(ERROR_WRONG_PASSWORD));
	        }
	        if(wszScope)
	        {
		        bstrScope = CertAllocString((LPWSTR)wszScope);
		        if(bstrScope == NULL)
		        {
		            hr = E_OUTOFMEMORY;
		            _LeaveError(hr, "CertAllocString");
		        }
	        }
	    }


	if(bstrScope == NULL)
	{
	    // If scope is not specified, set it to the
	    // current domain scope.
	    hr = CAGetAuthoritativeDomainDn(pld, &bstrDomain, &bstrConfig);
	    if(S_OK != hr)
	    {
		    _LeaveError(hr, "CAGetAuthoritativeDomainDn");
	    }
	    bstrScope = CertAllocStringLen(
					NULL,
					wcslen(bstrConfig) + wcslen(g_wszEnrollmentServiceLocation));
	    if(bstrScope == NULL)
	    {
		    hr = E_OUTOFMEMORY;
		    _LeaveError(hr, "CertAllocStringLen");
	    }
	    wcscpy(bstrScope, g_wszEnrollmentServiceLocation);
	    wcscat(bstrScope, bstrConfig);
	}


	if (NULL != wszQuery)
	{
            // If a query is specified, then combine it with the
            // objectCategory=pKIEnrollmentService query
            cSearchParam = 2 + wcslen(wszSearch) + wcslen(wszQuery) + 2;
            bstrSearchParam = CertAllocStringLen(NULL,cSearchParam);
            if(bstrSearchParam == NULL)
            {
                hr = E_OUTOFMEMORY;
                _LeaveError(hr, "CertAllocStringLen");
            }
            wcscpy(bstrSearchParam, L"(&");
            wcscat(bstrSearchParam, wszSearch);

            wcscat(bstrSearchParam, wszQuery);
            wcscat(bstrSearchParam, L")");
	}

        hr = _ProcessFind(pld,
                          (wszQuery? bstrSearchParam : wszSearch), 
                          bstrScope,
                          dwFlags,
                          ppCAInfo);
        if(hr != S_OK)
        {
	    _LeaveError(hr, "_ProcessFind");
        }

    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    if (NULL != bstrScope)
    {
        CertFreeString(bstrScope);
    }

    if( NULL != bstrConfig)
    {
        CertFreeString(bstrConfig);
    }

    if( NULL != bstrDomain)
    {
        CertFreeString(bstrDomain);
    }

    if (NULL != bstrSearchParam)
    {
        CertFreeString(bstrSearchParam);
    }
    if(0 == (CA_FLAG_SCOPE_IS_LDAP_HANDLE & dwFlags))
    {
        if (NULL != pld)
        {
            ldap_unbind(pld);
        }
    }
    return(hr);
}




//+--------------------------------------------------------------------------
// CCAInfo::_ProcessFind -- ProcessFind CA Objects in the DS
//
// 
//+--------------------------------------------------------------------------

HRESULT 
CCAInfo::_ProcessFind(
    LDAP *  pld,
    LPCWSTR wszQuery, 
    LPCWSTR wszScope,
    DWORD   dwFlags,
    CCAInfo **ppCAInfo)

{
    HRESULT hr = S_OK;
    ULONG   ldaperr;
    CCAInfo *pCAFirst = NULL;
    CCAInfo *pCACurrent = NULL;
    // Initialize LDAP session
    CHAR sdBerValue[] = {0x30, 0x03, 0x02, 0x01, DACL_SECURITY_INFORMATION |
                                                 OWNER_SECURITY_INFORMATION |
                                                    GROUP_SECURITY_INFORMATION};

    LDAPControl se_info_control =
    {
        LDAP_SERVER_SD_FLAGS_OID_W,
        {
            5, sdBerValue
        },
        TRUE
    };

    PLDAPControl server_controls[2] =
    {
	&se_info_control,
	NULL
    };

    LDAPMessage *SearchResult = NULL, *Entry;

    struct berval **apCerts;
    struct berval **apSD;

    // Chain verification stuff
    CERT_CHAIN_PARA         ChainParams;
    CERT_CHAIN_POLICY_PARA  ChainPolicy;
    CERT_CHAIN_POLICY_STATUS PolicyStatus;
    PCCERT_CHAIN_CONTEXT    pChainContext = NULL;
    PCCERT_CONTEXT          pCert = NULL;
    DWORD cEntries;

    // search timeout
    struct l_timeval        timeout;

    if (NULL == ppCAInfo)
    {
        hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppCAInfo = NULL;

    DBGPRINT((
	DBG_SS_CERTLIBI,
	"_ProcessFind(Query=%ws, Scope=%ws, Flags=%x)\n",
	wszQuery,
	wszScope,
	dwFlags));

    timeout.tv_sec = csecLDAPTIMEOUT;
    timeout.tv_usec = 0;


    // Perform search.
    ldaperr = ldap_search_ext_sW(pld, 
		  (LPWSTR)wszScope,
		  LDAP_SCOPE_SUBTREE,
		  (LPWSTR)wszQuery,
		  g_awszCAAttrs,
		  0,
		  (PLDAPControl *)&server_controls,
		  NULL,
		  &timeout,
		  10000,
		  &SearchResult);
    if(ldaperr == LDAP_NO_SUCH_OBJECT)
    {
	// No entries were found.
	hr = S_OK;
	DBGPRINT((DBG_SS_CERTLIBI, "ldap_search_ext_sW: no entries\n"));
	goto error;
    }

    if(ldaperr != LDAP_SUCCESS)
    {
	hr = myHLdapError(pld, ldaperr, NULL);
	_JumpError(hr, error, "ldap_search_ext_sW");
    }
    cEntries = ldap_count_entries(pld, SearchResult);
    DBGPRINT((DBG_SS_CERTLIBI, "ldap_count_entries: %u entries\n", cEntries));
    if (0 == cEntries)
    {
	// No entries were found.
	hr = S_OK;
	goto error;
    }

    hr = S_OK;
    for(Entry = ldap_first_entry(pld, SearchResult); 
	Entry != NULL; 
	Entry = ldap_next_entry(pld, Entry))
    {
	CCAProperty *pProp;
	WCHAR ** pwszProp;
	WCHAR ** wszLdapVal;
	DWORD    dwCAFlags = 0;

	if(pCert)
	{
	    CertFreeCertificateContext(pCert);
	    pCert = NULL;
	}

	if(pChainContext)
	{
	    CertFreeCertificateChain(pChainContext);
	    pChainContext = NULL;
	}

	wszLdapVal = ldap_get_values(pld, Entry, CA_PROP_FLAGS);
	if(wszLdapVal != NULL)  
	{
	    if(wszLdapVal[0] != NULL)
	    {
		dwCAFlags = wcstoul(wszLdapVal[0], NULL, 10);
	    }
	    ldap_value_free(wszLdapVal);
	}
	DBGPRINT((DBG_SS_CERTLIBI, "dwCAFlags=%x\n", dwCAFlags));

	// Filter of flags

	if(( 0 == (dwFlags & CA_FIND_INCLUDE_NON_TEMPLATE_CA)) &&  
	   ( 0 != (dwCAFlags & CA_FLAG_NO_TEMPLATE_SUPPORT)))
	{
	    // Don't include standalone CA's unless instructed to
	    DBGPRINT((
		DBG_SS_CERTLIBI,
		"Skipping non-template CA, dwCAFlags=%x\n",
		dwCAFlags));
	    continue;
	}

	// Get the CA Certificate
	apCerts = ldap_get_values_len(pld, Entry, L"cACertificate");
	if(apCerts && apCerts[0])
	{
	    pCert = CertCreateCertificateContext(
					    X509_ASN_ENCODING,
					    (PBYTE)apCerts[0]->bv_val,
					    apCerts[0]->bv_len);
	    ldap_value_free_len(apCerts);
	}

	if(0 == (CA_FIND_INCLUDE_UNTRUSTED & dwFlags))
	{
	    if (NULL == pCert)
	    {
		DBGPRINT((DBG_SS_CERTLIBI, "Skipping cert-less CA\n"));
		continue;		// skip this CA
	    }

	    // Verify cert and chain...

	    hr = myVerifyCertContext(
			    pCert,
			    CA_VERIFY_FLAGS_IGNORE_OFFLINE |
				CA_VERIFY_FLAGS_NO_REVOCATION,	// dwFlags
			    0,					// cUsageOids
			    NULL,				// apszUsageOids
			    (dwFlags & CA_FIND_LOCAL_SYSTEM)?
				HCCE_LOCAL_MACHINE : HCCE_CURRENT_USER,
			    NULL,			// hAdditionalStore
			    NULL);			// ppwszMissingIssuer
	    if (S_OK != hr)
	    {
		HRESULT hr2;
		WCHAR *pwszSubject = NULL;

		hr2 = myCertNameToStr(
			    X509_ASN_ENCODING,
			    &pCert->pCertInfo->Subject,
			    CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
			    &pwszSubject);
		_PrintIfError(hr2, "myCertNameToStr");
		_PrintErrorStr(hr, "myVerifyCertContext", pwszSubject);
		if (NULL != pwszSubject)
		{
		    LocalFree(pwszSubject);
		}
		hr = S_OK;
		continue;		// skip this CA
	    }
	}


	// Is this the first one?
	if(pCACurrent)
	{
	    pCACurrent->m_pNext = new CCAInfo;
	    if(pCACurrent->m_pNext == NULL)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "new");
	    }

	    pCACurrent = pCACurrent->m_pNext;
	}
	else
	{
	    pCAFirst = pCACurrent = new CCAInfo;
	    if(pCAFirst == NULL)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "new");
	    }
	}

	pCACurrent->m_pCertificate = pCert;
	pCert = NULL;

	WCHAR* wszDN = ldap_get_dnW(pld, Entry);
	if(NULL == wszDN)
	{
	    hr = myHLdapLastError(pld, NULL);
	    _JumpError(hr, error, "ldap_get_dnW");
	}
					
	pCACurrent->m_bstrDN = CertAllocString(wszDN);

	//  ldap_get_dnW rtn value should be freed by calling ldap_memfree
	ldap_memfree(wszDN);

	// check success of CertAllocString
	if(pCACurrent->m_bstrDN == NULL)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "CertAllocString");
	}

	// Add text properties from
	// DS lookup.

	for (pwszProp = g_awszCANamedProps; *pwszProp != NULL; pwszProp++)
	{
	    pProp = new CCAProperty(*pwszProp);
	    if(pProp == NULL)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "new");
	    }

	    wszLdapVal = ldap_get_values(pld, Entry, *pwszProp);
	    hr = pProp->SetValue(wszLdapVal);
	    _PrintIfError(hr, "SetValue");

	    if(wszLdapVal)
	    {
		ldap_value_free(wszLdapVal);
	    }
	    if(hr == S_OK)
	    {
		hr = CCAProperty::Append(&pCACurrent->m_pProperties, pProp);
		_PrintIfError(hr, "Append");
	    }
	    if(hr != S_OK)
	    {
		CCAProperty::DeleteChain(&pProp);
		_JumpError(hr, error, "SetValue or Append");
	    }
	}

	pCACurrent->m_dwFlags = dwCAFlags;

	// Append the security descriptor...

	apSD = ldap_get_values_len(pld, Entry, LDAP_SECURITY_DESCRIPTOR_NAME);
	if(apSD != NULL)
	{
	    pCACurrent->m_pSD = LocalAlloc(LMEM_FIXED, (*apSD)->bv_len);
	    if(pCACurrent->m_pSD == NULL)
	    {
		hr = E_OUTOFMEMORY;
		ldap_value_free_len(apSD);
			_JumpError(hr, error, "LocalAlloc");
	    }
	    CopyMemory(pCACurrent->m_pSD, (*apSD)->bv_val, (*apSD)->bv_len);
	    ldap_value_free_len(apSD);
	}

	pCACurrent->m_fNew = FALSE;
    }

    // May be null if none found.
    *ppCAInfo = pCAFirst;
    pCAFirst = NULL;


error:

    if(SearchResult)
    {
        ldap_msgfree(SearchResult);
    }

    if (NULL != pCAFirst)
    {
        delete pCAFirst;
    }
    if(pCert)
    {
        CertFreeCertificateContext(pCert);
    }

    if(pChainContext)
    {
        CertFreeCertificateChain(pChainContext);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCAInfo::Create -- Create CA Object in the DS
//
// 
//+--------------------------------------------------------------------------

HRESULT 
CCAInfo::Create(
    LPCWSTR wszName, 
    LPCWSTR wszScope, 
    CCAInfo **ppCAInfo)

{
    HRESULT hr = S_OK;
    ULONG   ldaperr;

    CCAInfo *pCACurrent = NULL;
    LDAP *  pld = NULL;

    // Initialize LDAP session
    DWORD   cFullLocation;
    CERTSTR    bstrScope = NULL;


    LPWSTR cnVals[2];
    CCAProperty *pProp;

    struct berval **apSD;


    if (NULL == ppCAInfo || NULL == wszName)
    {
        hr = E_POINTER;
	    _JumpError(hr, error, "NULL parm");
    }

    // short circuit calls to a nonexistant DS
    hr = myDoesDSExist(TRUE);
    _JumpIfError(hr, error, "myDoesDSExist");

    __try
    {
	// bind to ds
    hr = myRobustLdapBind(&pld, FALSE);

	if(hr != S_OK)
	{
	    _LeaveError(hr, "myRobustLdapBind");
	}

       
	if(wszScope)
	{
	    bstrScope = CertAllocString(wszScope);
	    if(bstrScope == NULL)
	    {
		hr = E_OUTOFMEMORY;
		_LeaveError(hr, "CertAllocString");
	    }
	}
	else
	{
	    // If scope is not specified, set it to the
	    // current domain scope.
	    hr = CAGetAuthoritativeDomainDn(pld, NULL, &bstrScope);
	    if(S_OK != hr)
	    {
		    _LeaveError(hr, "CAGetAuthoritativeDomainDn");
	    }

	}
	pCACurrent = new CCAInfo;
	if(pCACurrent == NULL)
	{
	    hr = E_OUTOFMEMORY;
	    _LeaveError(hr, "new");
	}


	cFullLocation = 4 + wcslen(wszName) + wcslen(g_wszEnrollmentServiceLocation) + wcslen(bstrScope);
	pCACurrent->m_bstrDN = CertAllocStringLen(NULL, cFullLocation);
	if(pCACurrent->m_bstrDN == NULL)
	{
	    hr = E_OUTOFMEMORY;
	    _LeaveError(hr, "CertAllocStringLen");
	}
	wcscpy(pCACurrent->m_bstrDN, L"CN=");
	wcscat(pCACurrent->m_bstrDN, wszName);
	wcscat(pCACurrent->m_bstrDN, L",");
	wcscat(pCACurrent->m_bstrDN, g_wszEnrollmentServiceLocation);
	wcscat(pCACurrent->m_bstrDN, bstrScope);
	
	pProp = new CCAProperty(CA_PROP_NAME);

    if (pProp == NULL)
	{
	    hr = E_OUTOFMEMORY;
	    _LeaveError(hr, "new");
	}
       

	cnVals[0] = (LPWSTR)wszName;
	cnVals[1] = NULL;
	pProp->SetValue(cnVals);
	CCAProperty::Append(&pCACurrent->m_pProperties, pProp);
      
	pCACurrent->m_fNew = TRUE;
	*ppCAInfo = pCACurrent;
	pCACurrent = NULL;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    if (NULL != bstrScope)
    {
        CertFreeString(bstrScope);
    }
    if (NULL != pld)
    {
        ldap_unbind(pld);
    }
    if (NULL != pCACurrent)
    {
        delete pCACurrent;
    }
    return(hr);
}


HRESULT 
CCAInfo::Update(VOID)
{

    HRESULT hr = S_OK;
    ULONG   ldaperr;
    LDAP *pld = NULL;
    LDAPMod objectClass,
             cnmod,
             displaymod,
             certmod,
             certdnmod,
             domainidmod,
             machinednsmod,
             certtypesmod,
             sigalgmods,
             Flagsmod,
             sdmod,
             Descriptionmod;

    WCHAR *awszNull[1] = { NULL };

    DWORD err;
    DWORD cName;


    TCHAR *objectClassVals[3], *certdnVals[2];
    LDAPMod *mods[13];


    struct berval certberval;
    struct berval sdberval;
    struct berval *certVals[2], *sdVals[2];

    CHAR sdBerValue[] = {0x30, 0x03, 0x02, 0x01,  DACL_SECURITY_INFORMATION|
                                                  OWNER_SECURITY_INFORMATION |
                                                  GROUP_SECURITY_INFORMATION};

    LDAPControl se_info_control =
    {
        LDAP_SERVER_SD_FLAGS_OID_W,
        {
            5, sdBerValue
        },
        TRUE
    };

    LDAPControl permissive_modify_control =
    {
        LDAP_SERVER_PERMISSIVE_MODIFY_OID_W,
        {
            0, NULL
        },
        FALSE
    };


    PLDAPControl    server_controls[3] =
                    {
                        &se_info_control,
                        &permissive_modify_control,
                        NULL
                    };

    // for now, modifies don't try to update owner/group
    CHAR sdBerValueDaclOnly[] = {0x30, 0x03, 0x02, 0x01,  DACL_SECURITY_INFORMATION};
    LDAPControl se_info_control_dacl_only =
    {
        LDAP_SERVER_SD_FLAGS_OID_W,
        {
            5, sdBerValueDaclOnly
        },
        TRUE
    };
    PLDAPControl    server_controls_dacl_only[3] =
                    {
                        &se_info_control_dacl_only,
                        &permissive_modify_control,
                        NULL
                    };



    DWORD               cCALocation;
    CERTSTR             bstrCALocation = NULL;
    WCHAR             * wszDomainDN, *wszCAs, *wszPKS;
    WCHAR wszFlags[16], *awszFlags[2];

    DWORD               iMod = 0;

    CERTSTR bstrDomainDN = NULL;
    certdnVals[0] = NULL;

    // Things we free and must put into known state
    cnmod.mod_values = NULL;
    displaymod.mod_values = NULL;
    machinednsmod.mod_values = NULL;
    certtypesmod.mod_values = NULL;
    Descriptionmod.mod_values = NULL;


    if (NULL == m_pCertificate)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL parm");
    }

    // short circuit calls to a nonexistant DS
    hr = myDoesDSExist(TRUE);
    _JumpIfError(hr, error, "myDoesDSExist");

    __try
    {
	    // bind to ds
        hr = myRobustLdapBind(&pld, FALSE);

	if(hr != S_OK)
	{
	    _LeaveError(hr, "myRobustLdapBind");
	}

        objectClass.mod_op = LDAP_MOD_REPLACE;
        objectClass.mod_type = TEXT("objectclass");
        objectClass.mod_values = objectClassVals;
        objectClassVals[0] = wszDSTOPCLASSNAME;
        objectClassVals[1] = wszDSENROLLMENTSERVICECLASSNAME;
        objectClassVals[2] = NULL;
        mods[iMod++] = &objectClass;

        cnmod.mod_op = LDAP_MOD_REPLACE;
        cnmod.mod_type = CA_PROP_NAME;
        hr = GetProperty(CA_PROP_NAME, &cnmod.mod_values);
        if((hr != S_OK) || (cnmod.mod_values == NULL))
        {
            cnmod.mod_values = awszNull;
            if(!m_fNew)
            {
                mods[iMod++] = &cnmod;
            }

        }
        else
        {
            mods[iMod++] = &cnmod;
        }

        displaymod.mod_op = LDAP_MOD_REPLACE;
        displaymod.mod_type = CA_PROP_DISPLAY_NAME;
        hr = GetProperty(CA_PROP_DISPLAY_NAME, &displaymod.mod_values);
        if((hr != S_OK) || (displaymod.mod_values == NULL))
        {
            displaymod.mod_values = awszNull;
            if(!m_fNew)
            {
                mods[iMod++] = &displaymod;
            }
        }
        else
        {
            mods[iMod++] = &displaymod;
        }


        Flagsmod.mod_op = LDAP_MOD_REPLACE;
        Flagsmod.mod_type = CERTTYPE_PROP_FLAGS;
        Flagsmod.mod_values = awszFlags;
        awszFlags[0] = wszFlags;
        awszFlags[1] = NULL;
        wsprintf(wszFlags, L"%lu", m_dwFlags);
        mods[iMod++] = &Flagsmod;

        certmod.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_REPLACE;
        certmod.mod_type = TEXT("cACertificate");
        certmod.mod_bvalues = certVals;
        certVals[0] = &certberval;
        certVals[1] = NULL;
        certberval.bv_len = m_pCertificate->cbCertEncoded;
        certberval.bv_val = (char *)m_pCertificate->pbCertEncoded;
        mods[iMod++] = &certmod;

        certdnmod.mod_op = LDAP_MOD_REPLACE;
        certdnmod.mod_type = TEXT("cACertificateDN");
        certdnmod.mod_values = certdnVals;

        cName = CertNameToStr(X509_ASN_ENCODING,
                             &m_pCertificate->pCertInfo->Subject,
                             CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
                             NULL,
                             0);


        if (0 == cName)
        {
	        hr = myHLastError();
	        _LeaveError(hr, "CertNameToStr");
        }
        certdnVals[0] = CertAllocStringLen(NULL, cName);
        if( certdnVals[0] == NULL)
        {
            hr = E_OUTOFMEMORY;
            _LeaveError(hr, "CertAllocStringLen");
        }

        if(0 == CertNameToStr(X509_ASN_ENCODING,
                 &m_pCertificate->pCertInfo->Subject,
                 CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
                 certdnVals[0],
                 cName))
        {
            hr = myHLastError();
            _LeaveError(hr, "CertNameToStr");
        }
        certdnVals[1] = NULL;
        mods[iMod++] = &certdnmod;



        machinednsmod.mod_op = LDAP_MOD_REPLACE;
        machinednsmod.mod_type = CA_PROP_DNSNAME;
        hr = GetProperty(CA_PROP_DNSNAME, &machinednsmod.mod_values);
        if((hr != S_OK) || (machinednsmod.mod_values == NULL))
        {
            machinednsmod.mod_values = awszNull;
            if(!m_fNew)
            {
                mods[iMod++] = &machinednsmod;
            }
        }
        else
        {
            mods[iMod++] = &machinednsmod;
        }

        certtypesmod.mod_op = LDAP_MOD_REPLACE;
        certtypesmod.mod_type = LDAP_CERTIFICATE_TEMPLATES_NAME;
        hr = GetProperty(CA_PROP_CERT_TYPES, &certtypesmod.mod_values);
        if((hr != S_OK) || (certtypesmod.mod_values == NULL))
        {
            certtypesmod.mod_values = awszNull;
            if(!m_fNew)
            {
                mods[iMod++] = &certtypesmod;
            }
        }
        else
        {
            mods[iMod++] = &certtypesmod;
        }

        sdmod.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_REPLACE;
        sdmod.mod_type = LDAP_SECURITY_DESCRIPTOR_NAME;
        sdmod.mod_bvalues = sdVals;
        sdVals[0] = &sdberval;
        sdVals[1] = NULL;
        if(IsValidSecurityDescriptor(m_pSD))
        {
            sdberval.bv_len = GetSecurityDescriptorLength(m_pSD);
            sdberval.bv_val = (char *)m_pSD;
        }
        else
        {
            sdberval.bv_len = 0;
            sdberval.bv_val = NULL;

        }
        mods[iMod++] = &sdmod;


        Descriptionmod.mod_op = LDAP_MOD_REPLACE;
        Descriptionmod.mod_type = CA_PROP_DESCRIPTION;
        hr = GetProperty(CA_PROP_DESCRIPTION, &Descriptionmod.mod_values);
        if((hr != S_OK) || (Descriptionmod.mod_values == NULL))
        {
            Descriptionmod.mod_values = awszNull;
            if(!m_fNew)
            {
                mods[iMod++] = &Descriptionmod;
            }
        }
        else
        {
            mods[iMod++] = &Descriptionmod;
        }


        mods[iMod] = NULL;
	CSASSERT(ARRAYSIZE(mods) > iMod);

        hr = S_OK;

        if(m_fNew)
        {
	        DBGPRINT((DBG_SS_CERTLIBI, "Creating DS PKI Enrollment object: '%ws'\n", m_bstrDN));
            ldaperr = ldap_add_ext_sW(pld, m_bstrDN, mods, server_controls, NULL);
        }

        else
        {
            // don't attempt to set owner/group for pre-existing objects
	    DBGPRINT((DBG_SS_CERTLIBI, "Updating DS PKI Enrollment object: '%ws'\n", m_bstrDN));
            ldaperr = ldap_modify_ext_sW(pld, 
                  m_bstrDN,
                  &mods[2],
                  server_controls_dacl_only,
                  NULL);  // skip past objectClass and cn
            if(LDAP_ATTRIBUTE_OR_VALUE_EXISTS == ldaperr)
            {
                ldaperr = LDAP_SUCCESS;
            }
        }

        if (LDAP_SUCCESS != ldaperr && LDAP_ALREADY_EXISTS != ldaperr)
        {
	    hr = myHLdapError(pld, ldaperr, NULL);
	    _LeaveError(ldaperr, m_fNew? "ldap_add_s" : "ldap_modify_sW");
        }
        m_fNew = FALSE;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    if (NULL != certdnVals[0])
    {
        CertFreeString(certdnVals[0]);
    }
    if (NULL != certtypesmod.mod_values && awszNull != certtypesmod.mod_values)
    {
        FreeProperty(certtypesmod.mod_values);
    }
    if (NULL != machinednsmod.mod_values && awszNull != machinednsmod.mod_values)
    {
        FreeProperty(machinednsmod.mod_values);
    }
    if (NULL != cnmod.mod_values && awszNull != cnmod.mod_values)
    {
        FreeProperty(cnmod.mod_values);
    }
    if (NULL != displaymod.mod_values && awszNull != displaymod.mod_values)
    {
        FreeProperty(displaymod.mod_values);
    }
    if (NULL != Descriptionmod.mod_values && awszNull != Descriptionmod.mod_values)
    {
        FreeProperty(Descriptionmod.mod_values);
    }
    if (NULL != pld)
    {
        ldap_unbind(pld);
    }
    return(hr);
}


HRESULT 
CCAInfo::Delete(VOID)
{
    LDAP *pld = NULL;
    HRESULT hr = S_OK;
    DWORD ldaperr;

    // short circuit calls to a nonexistant DS
    hr = myDoesDSExist(TRUE);
    _JumpIfError(hr, error, "myDoesDSExist");

    __try
    {
	    // bind to ds
        hr = myRobustLdapBind(&pld, FALSE);
	if(hr != S_OK)
	{
	    _LeaveError(hr, "myRobustLdapBind");
	}
        ldaperr = ldap_delete_s(pld, m_bstrDN);
	hr = myHLdapError(pld, ldaperr, NULL);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }


error:
    if (NULL != pld)
    {
        ldap_unbind(pld);
    }
    return (hr);
}


//+--------------------------------------------------------------------------
// CCAInfo::FindDnsDomain -- Find CA Objects in the DS, given a scope specified
// by a dns domain name.
//
// 
//+--------------------------------------------------------------------------

HRESULT 
CCAInfo::FindDnsDomain(
    LPCWSTR wszQuery, 
    LPCWSTR wszDnsDomain, 
    DWORD   dwFlags, 
    CCAInfo **ppCAInfo)
{
    HRESULT hr = S_OK;
    DWORD err;
    WCHAR *wszScope = NULL;
    DWORD cScope;

    if (NULL != wszDnsDomain)
    {
        cScope = 0;
        err = DNStoRFC1779Name(NULL, &cScope, wszDnsDomain);
        if(err != ERROR_INSUFFICIENT_BUFFER)
        {
            hr = myHError(err);
	    _JumpError(hr, error, "DNStoRFC1779Name");
        }
        cScope += 1;
        wszScope = (WCHAR *) LocalAlloc(LMEM_FIXED, sizeof(WCHAR)*cScope);
        if (NULL == wszScope)
        {
            hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
        }
        err = DNStoRFC1779Name(wszScope, &cScope, wszDnsDomain);
        if (ERROR_SUCCESS != err)
        {
            hr = myHError(err);
	    _JumpError(hr, error, "DNStoRFC1779Name");
        }
    }
    hr = Find(wszQuery, wszScope, dwFlags, ppCAInfo);
    _JumpIfError4(
	    hr,
	    error,
	    "Find",
	    HRESULT_FROM_WIN32(ERROR_SERVER_DISABLED),
	    HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN),
	    HRESULT_FROM_WIN32(ERROR_WRONG_PASSWORD));

error:
    if (NULL != wszScope)
    {
        LocalFree(wszScope);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCAInfo::CreateDnsDomain -- Find CA Objects in the DS, given a scope specified
// by a dns domain name.
//
// 
//+--------------------------------------------------------------------------

HRESULT 
CCAInfo::CreateDnsDomain(
    LPCWSTR wszName, 
    LPCWSTR wszDnsDomain, 
    CCAInfo **ppCAInfo)
{
    HRESULT hr = S_OK;
    DWORD err;
    WCHAR *wszScope = NULL;
    DWORD cScope;

    if(wszDnsDomain)
    {
        cScope = 0;
        err = DNStoRFC1779Name(NULL, &cScope, wszDnsDomain);
        if(err != ERROR_INSUFFICIENT_BUFFER)
        {
            hr = myHError(err);
	    _JumpError(hr, error, "DNStoRFC1779Name");
        }
        cScope += 1;
        wszScope = (WCHAR *) LocalAlloc(LMEM_FIXED, sizeof(WCHAR)*cScope);
        if (NULL == wszScope)
        {
            hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
        }
        err = DNStoRFC1779Name(wszScope, &cScope, wszDnsDomain);
        if (ERROR_SUCCESS != err)
        {
            hr = myHError(err);
	    _JumpError(hr, error, "DNStoRFC1779Name");
        }
    }
    hr = Create(wszName, wszScope, ppCAInfo);
    _JumpIfError(hr, error, "Create");

error:
    if (NULL != wszScope)
    {
        LocalFree(wszScope);
    }
    return(hr);
}

//+--------------------------------------------------------------------------
// CCAInfo::Next -- Returns the next object in the chain of CA objects
//
// 
//+--------------------------------------------------------------------------

HRESULT
CCAInfo::Next(CCAInfo **ppCAInfo)
{
    HRESULT hr;
    
    if (NULL == ppCAInfo)
    {
        hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppCAInfo = m_pNext;
    if (NULL != m_pNext)
    {
        m_pNext->AddRef();
    }
    hr = S_OK;

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCAInfo::GetProperty -- Retrieves the values of a property of the CA object
//
// 
//+--------------------------------------------------------------------------

HRESULT
CCAInfo::GetProperty(
    LPCWSTR wszPropertyName,
    LPWSTR **pawszProperties)
{
    HRESULT     hr;
    DWORD       dwChar=0;
    LPWSTR      *awszResult = NULL; 
    LPWSTR      pwszName=NULL;
    CCAProperty *pProp;
    LPCWSTR     wszProp = NULL;

    if (NULL == wszPropertyName || NULL == pawszProperties)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL parm");
    }

    if(lstrcmpi(wszPropertyName, L"machineDNSName") == 0)
    {
        wszProp = CA_PROP_DNSNAME;
    }
    else if(lstrcmpi(wszPropertyName, L"supportedCertificateTemplates") == 0)
    {
        wszProp = CA_PROP_CERT_TYPES;
    }
    else if(lstrcmpi(wszPropertyName, L"signatureAlgs") == 0)
    {
        wszProp = CA_PROP_SIGNATURE_ALGS;
    }
    else
    {
        wszProp = wszPropertyName;
    }

    hr = m_pProperties->Find(wszProp, &pProp);
    _JumpIfErrorStr(hr, error, "Find", wszProp);

    if (NULL != pProp)
    {
        hr = pProp->GetValue(pawszProperties);
        _JumpIfError(hr, error, "GetValue");
    }
    else
    {
        *pawszProperties = NULL;
    }

    if((lstrcmpi(wszPropertyName, CA_PROP_DISPLAY_NAME) == 0) &&
        ((*pawszProperties == NULL) || ((*pawszProperties)[0] == NULL)))
    {
        // DISPLAY_NAME is empty, so we try to return the display name
        // of the CA's certificate. if that also failed, just pass back the CN
        if(*pawszProperties != NULL)
        {
            LocalFree(*pawszProperties);
            *pawszProperties = NULL;
        }

        if(m_pCertificate)
        {
            if((dwChar=CertGetNameStringW(
                        m_pCertificate,
                        CERT_NAME_SIMPLE_DISPLAY_TYPE,
                        0,
                        NULL,
                        NULL,
                        0)))
            {
                pwszName=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * (dwChar));
                
                if(NULL==pwszName)
                {
                    hr=E_OUTOFMEMORY;
                    _JumpIfError(hr, error, "GetPropertyDisplayName");
                }

                if(dwChar=CertGetNameStringW(
                    m_pCertificate,
                    CERT_NAME_SIMPLE_DISPLAY_TYPE,
                    0,
                    NULL,
                    pwszName,
                    dwChar))
                {
                    awszResult=(WCHAR **)LocalAlloc(LPTR, (UINT)(sizeof(WCHAR *)*2+(wcslen(pwszName)+1)*sizeof(WCHAR)));
                    if (NULL==awszResult) 
                    {
                        hr=E_OUTOFMEMORY;
                        _JumpIfError(hr, error, "GetPropertyDisplayName");
                    }
                    awszResult[0]=(WCHAR *)(&awszResult[2]);
                    awszResult[1]=NULL;
                    wcscpy(awszResult[0], pwszName);
                    LocalFree(pwszName);
                    *pawszProperties=awszResult;
                    return S_OK;
                }
            }
        }

        hr = GetProperty(CA_PROP_NAME, pawszProperties);
        _JumpIfError(hr, error, "GetProperty");
    }


error:

    if(pwszName)
        LocalFree(pwszName);

    return(hr);
}


//+--------------------------------------------------------------------------
// CCertTypeInfo::SetProperty -- Sets the value of a property
//
// 
//+--------------------------------------------------------------------------

HRESULT
CCAInfo::SetProperty(
    LPCWSTR wszPropertyName,
    LPWSTR *awszProperties)
{
    HRESULT hr;
    CCAProperty *pProp;
    CCAProperty *pNewProp = NULL;

    if (NULL == wszPropertyName)
    {
        hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    hr = m_pProperties->Find(wszPropertyName, &pProp);
    if (S_OK != hr)
    {
        pNewProp = new CCAProperty(wszPropertyName);
        if (NULL == pNewProp)
        {
            hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "new");
        }
        hr = pNewProp->SetValue(awszProperties);
	_JumpIfError(hr, error, "SetValue");

        hr = CCAProperty::Append(&m_pProperties, pNewProp);
	_JumpIfError(hr, error, "Append");
       
        pNewProp = NULL; // remove our reference if we gave it to m_pProperties
    }
    else
    {
	hr = pProp->SetValue(awszProperties);
	_JumpIfError(hr, error, "SetValue");
    }

error:
    if (NULL != pNewProp)
        CCAProperty::DeleteChain(&pNewProp);

    return(hr);
}


//+--------------------------------------------------------------------------
// CCAInfo::FreeProperty -- Free's a previously returned property array
//
// 
//+--------------------------------------------------------------------------

HRESULT
CCAInfo::FreeProperty(
    LPWSTR *pawszProperties)
{
    if (NULL != pawszProperties)
    {
        LocalFree(pawszProperties);
    }
    return(S_OK);
}


//+--------------------------------------------------------------------------
// CCAInfo::GetCertificte -- get the CA certificate
//
// 
//+--------------------------------------------------------------------------

HRESULT
CCAInfo::GetCertificate(
    PCCERT_CONTEXT *ppCert)
{
    HRESULT hr;

    if (NULL == ppCert)
    {
        hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppCert = CertDuplicateCertificateContext(m_pCertificate);
    hr = S_OK;

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCAInfo::SetCertificte -- get the CA certificate
//
// 
//+--------------------------------------------------------------------------

HRESULT
CCAInfo::SetCertificate(
    PCCERT_CONTEXT pCert)
{

    if (NULL != m_pCertificate)
    {
        CertFreeCertificateContext(m_pCertificate);
	m_pCertificate = NULL;
    }

    if (NULL != pCert)
    {
        m_pCertificate = CertDuplicateCertificateContext(pCert);
    }
    return S_OK;
}

//+--------------------------------------------------------------------------
// CCAInfo::EnumCertTypesEx -- Enumerate cert types supported by this CA
//
// 
//+--------------------------------------------------------------------------

HRESULT 
CCAInfo::EnumSupportedCertTypesEx(
    LPCWSTR         wszScope,
    DWORD           dwFlags,
    CCertTypeInfo **ppCertTypes)
{
    HRESULT hr;
    CCertTypeInfo *pCTFirst = NULL;
    CCertTypeInfo *pCTCurrent = NULL;

    LPWSTR * awszCertTypes = NULL;

    if (NULL == ppCertTypes)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL parm");
    }
    *ppCertTypes = NULL;

    hr = GetProperty(CA_PROP_CERT_TYPES, &awszCertTypes);
    _JumpIfError(hr, error, "GetProperty");


    if (NULL != awszCertTypes)
    {
	    // Build a filter based on all of the global
	    // entries in the cert list.

        hr = CCertTypeInfo::FindByNames(
                                        (LPCWSTR *)awszCertTypes,
                                        wszScope,
                                        dwFlags,
                                        ppCertTypes);
	    _JumpIfError(hr, error, "FindByNames");
    }

error:
    if (awszCertTypes)
    {
        FreeProperty(awszCertTypes);
    }

    return(hr);
}

//+--------------------------------------------------------------------------
// CCAInfo::EnumCertTypes -- Enumerate cert types supported by this CA
//
// 
//+--------------------------------------------------------------------------

HRESULT 
CCAInfo::EnumSupportedCertTypes(
    DWORD           dwFlags,
    CCertTypeInfo **ppCertTypes)
{
    return  CCAInfo::EnumSupportedCertTypesEx(NULL, dwFlags, ppCertTypes);
}

//+--------------------------------------------------------------------------
// CCAInfo::AddCertType -- Add a cert type to this CA
//
// 
//+--------------------------------------------------------------------------

HRESULT 
CCAInfo::AddCertType(
    CCertTypeInfo *pCertType)
{
    HRESULT hr;
    LPWSTR *awszCertTypes = NULL;
    LPWSTR *awszCertTypeName = NULL;
    LPWSTR *awszNewTypes = NULL;

    LPWSTR wszCertTypeShortName = NULL;

    LPWSTR awszTypeName;


    DWORD  cTypes;

    if (NULL == pCertType)
    {
        hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    hr = GetProperty(CA_PROP_CERT_TYPES, &awszCertTypes);
    _JumpIfError(hr, error, "GetProperty");

    hr = pCertType->GetProperty(CERTTYPE_PROP_DN, &awszCertTypeName);
    _JumpIfError(hr, error, "GetProperty");


    if (NULL == awszCertTypeName || NULL == awszCertTypeName[0])
    {
        hr = E_POINTER;
	    _JumpError(hr, error, "NULL CertTypeName");
    }

    if((NULL != (wszCertTypeShortName = wcschr(awszCertTypeName[0], L'|'))) ||
        (NULL != (wszCertTypeShortName = wcschr(awszCertTypeName[0], wcRBRACE))))
    {
        wszCertTypeShortName++;
    }

    if (NULL == awszCertTypes || NULL == awszCertTypes[0])
    {
        // no templates on the CA, add the new one and exit
        hr = SetProperty(CA_PROP_CERT_TYPES, awszCertTypeName);
        _JumpIfError(hr, error, "SetProperty");
    }
    else
    {
        // If cert type is already on ca, do nothing
        for (cTypes = 0; awszCertTypes[cTypes] != NULL; cTypes++)
        {
            if (0 == lstrcmpi(awszCertTypes[cTypes], awszCertTypeName[0]))
            {
                hr = S_OK;
                goto error;
            }
            if(wszCertTypeShortName)
            {
                if (0 == lstrcmpi(awszCertTypes[cTypes], wszCertTypeShortName))
                {
                    hr = S_OK;
                    goto error;
                }
            }
        }

        awszNewTypes = (WCHAR **) LocalAlloc(
				        LMEM_FIXED,
				        (cTypes + 2) * sizeof(WCHAR *));
        if (NULL == awszNewTypes)
        {
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
        }

        CopyMemory(awszNewTypes, awszCertTypes, cTypes * sizeof(WCHAR *));

        awszNewTypes[cTypes] = awszCertTypeName[0];
        awszNewTypes[cTypes + 1] = NULL;

        hr = SetProperty(CA_PROP_CERT_TYPES, awszNewTypes);
        _JumpIfError(hr, error, "SetProperty");
    }

error:
    if (NULL != awszCertTypes)
    {
        FreeProperty(awszCertTypes);
    }
    if (NULL != awszCertTypeName)
    {
        FreeProperty(awszCertTypeName);
    }
    if (NULL != awszNewTypes)
    {
        LocalFree(awszNewTypes);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCAInfo::RemoveCertType -- Remove a cert type from this CA
//
// 
//+--------------------------------------------------------------------------

HRESULT 
CCAInfo::RemoveCertType(
    CCertTypeInfo *pCertType)
{
    HRESULT hr;
    WCHAR **awszCertTypes = NULL;
    WCHAR **awszCertTypeName = NULL;
    DWORD cTypes, cTypesNew;
    LPWSTR wszCertTypeName = NULL;
    LPWSTR wszCurrentCertTypeName = NULL;

    if (NULL == pCertType)
    {
        hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    hr = GetProperty(CA_PROP_CERT_TYPES, &awszCertTypes);
    _JumpIfError(hr, error, "GetProperty");

    hr = pCertType->GetProperty(CERTTYPE_PROP_CN, &awszCertTypeName);
    _JumpIfError(hr, error, "GetProperty");
    
    if (NULL == awszCertTypeName || NULL == awszCertTypeName[0])
    {
        hr = E_POINTER;
	    _JumpError(hr, error, "NULL CertTypeName");
    }

    if (NULL == awszCertTypes || NULL == awszCertTypes[0])
    {
        hr = S_OK;
        goto error;
    }
    wszCertTypeName = wcschr(awszCertTypeName[0], wcRBRACE);
    if(wszCertTypeName != NULL)
    {
        wszCertTypeName++;
    }
    else
    {
        wszCertTypeName = awszCertTypeName[0];
    }

    cTypesNew = 0;

    // If cert type is already on ca, do nothing

    for (cTypes = 0; awszCertTypes[cTypes] != NULL; cTypes++)
    {
        if((NULL != (wszCurrentCertTypeName = wcschr(awszCertTypes[cTypes], L'|'))) ||
            (NULL != (wszCurrentCertTypeName = wcschr(awszCertTypes[cTypes], wcRBRACE))))

        {
            wszCurrentCertTypeName++;
        }
        else
        {
            wszCurrentCertTypeName = awszCertTypes[cTypes];
        }

        if (0 != lstrcmpi(wszCurrentCertTypeName, wszCertTypeName))
        {
            awszCertTypes[cTypesNew++] = awszCertTypes[cTypes];
        }
    }
    awszCertTypes[cTypesNew] = NULL;

    hr = SetProperty(CA_PROP_CERT_TYPES, awszCertTypes);
    _JumpIfError(hr, error, "SetProperty");

error:
    if (NULL != awszCertTypes)
    {
        FreeProperty(awszCertTypes);
    }
    if (NULL != awszCertTypeName)
    {
        FreeProperty(awszCertTypeName);
    }
    return(hr);
}



//+--------------------------------------------------------------------------
// CCAInfo::GetExpiration -- Get the expiration period
//
// 
//+--------------------------------------------------------------------------

HRESULT 
CCAInfo::GetExpiration(
    DWORD *pdwExpiration, 
    DWORD *pdwUnits)   
{
    HRESULT hr;

    if (NULL == pdwExpiration || NULL == pdwUnits)
    {
        hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    *pdwExpiration = m_dwExpiration;
    *pdwUnits = m_dwExpUnits;
    hr = S_OK;

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCAInfo::SetExpiration -- Set the expiration period
//
// 
//+--------------------------------------------------------------------------

HRESULT 
CCAInfo::SetExpiration(
    DWORD dwExpiration, 
    DWORD dwUnits)   
{
    m_dwExpiration = dwExpiration;
    m_dwExpUnits = dwUnits;
    return(S_OK);
}

//+--------------------------------------------------------------------------
// CCAInfo::GetSecurity --
//
// 
//+--------------------------------------------------------------------------


HRESULT CCAInfo::GetSecurity(PSECURITY_DESCRIPTOR * ppSD)
{
    HRESULT hr = S_OK;
    PSECURITY_DESCRIPTOR pResult = NULL;

    DWORD   cbSD;

    if(ppSD == NULL)
    {
        return E_POINTER;
    }
    if(m_pSD == NULL)
    {
        *ppSD = NULL;
        return S_OK;
    }

    if(!IsValidSecurityDescriptor(m_pSD))
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_SECURITY_DESCR);
    }
    cbSD = GetSecurityDescriptorLength(m_pSD);

    pResult = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, cbSD);

    if(pResult == NULL)
    {
        return E_OUTOFMEMORY;
    }

    CopyMemory(pResult, m_pSD, cbSD);

    *ppSD = pResult;

    return S_OK;
}

//+--------------------------------------------------------------------------
// CCAInfo::GetSecurity --
//
// 
//+--------------------------------------------------------------------------


HRESULT CCAInfo::SetSecurity(PSECURITY_DESCRIPTOR pSD)
{
    HRESULT hr = S_OK;
    PSECURITY_DESCRIPTOR pResult = NULL;

    DWORD   cbSD;

    if(pSD == NULL)
    {
        return E_POINTER;
    }

    if(!IsValidSecurityDescriptor(pSD))
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_SECURITY_DESCR);
    }
    cbSD = GetSecurityDescriptorLength(pSD);

    pResult = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, cbSD);

    if(pResult == NULL)
    {
        return E_OUTOFMEMORY;
    }

    CopyMemory(pResult, pSD, cbSD);

    if(m_pSD)
    {
        LocalFree(m_pSD);
    }

    m_pSD = pResult;

    return S_OK;
}

HRESULT CCAInfo::AccessCheck(HANDLE ClientToken, DWORD dwOption)
{

    return CAAccessCheckpEx(ClientToken, m_pSD, dwOption);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certclib\cainfoc.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        cainfoc.h
//
// Contents:    Declaration of CCAInfo
//
// History:     16-dec-97       petesk created
//
//---------------------------------------------------------------------------

#include "cainfop.h"
#include <certca.h>
/////////////////////////////////////////////////////////////////////////////
// certcli

class CCertTypeInfo;

class CCAInfo
{
public:
    CCAInfo()
    {
        m_cRef = 1;
        m_pNext = NULL;
        m_pProperties = NULL;
        m_pCertificate = NULL;
        m_bstrDN = NULL;
        m_fNew = TRUE;

        m_dwExpiration = 1;

        m_dwExpUnits = CA_UNITS_YEARS;

        m_pSD = NULL;

        m_dwFlags = 0;		// make sure high 16 bits are clear!
    }

    ~CCAInfo();

    DWORD Release();

    // Perform a search, returning a chain of CCAInfo objects. 
static HRESULT Find(
                    LPCWSTR wszQuery, 
                    LPCWSTR wszScope,
                    DWORD   dwFlags,
                    CCAInfo **ppCAInfo
                    );


static HRESULT FindDnsDomain(
                             LPCWSTR wszQuery, 
                             LPCWSTR wszDNSDomain,
                             DWORD   dwFlags,                             
                             CCAInfo **ppCAInfo
                             );

    // Perform a search, returning a chain of CCAInfo objects. 
static HRESULT Create(LPCWSTR wszName, LPCWSTR wszScope, CCAInfo **ppCAInfo);
static HRESULT CreateDnsDomain(LPCWSTR wszName, LPCWSTR wszDNSDomain, CCAInfo **ppCAInfo);

    HRESULT Update(VOID);

    HRESULT Delete(VOID);

    HRESULT Next(CCAInfo **ppCAInfo);

    DWORD Count()
    {
        if(m_pNext)
        {
            return m_pNext->Count()+1;
        }
        return 1;
    }

    HRESULT GetProperty(LPCWSTR wszPropertyName, LPWSTR **pawszProperties);
    HRESULT SetProperty(LPCWSTR wszPropertyName, LPWSTR *awszProperties);
    HRESULT FreeProperty(LPWSTR * awszProperties);

    DWORD GetFlags(VOID)
    {
        return m_dwFlags;
    }
    VOID SetFlags(DWORD dwFlags)
    {
        m_dwFlags = (m_dwFlags & ~CA_MASK_SETTABLE_FLAGS) | (dwFlags & CA_MASK_SETTABLE_FLAGS);
    }

    HRESULT GetCertificate(PCCERT_CONTEXT *ppCert);   
    HRESULT SetCertificate(PCCERT_CONTEXT pCert);

    HRESULT GetExpiration(DWORD *pdwExpiration, DWORD *pdwUnits);   
    HRESULT SetExpiration(DWORD dwExpiration, DWORD dwUnits);


    HRESULT EnumSupportedCertTypes(DWORD dwFlags, CCertTypeInfo **ppCertTypes);

    HRESULT EnumSupportedCertTypesEx(LPCWSTR wszScope, DWORD dwFlags, CCertTypeInfo **ppCertTypes);

    HRESULT AddCertType(CCertTypeInfo *pCertTypes);

    HRESULT RemoveCertType(CCertTypeInfo *pCertTypes);

    HRESULT SetSecurity(IN PSECURITY_DESCRIPTOR         pSD);
    HRESULT GetSecurity(OUT PSECURITY_DESCRIPTOR *     ppSD);


    HRESULT AccessCheck(
        IN HANDLE       ClientToken,
        IN DWORD        dwOption
        );

    LPCWSTR GetDN() { return m_bstrDN; }

protected:
	PCCERT_CONTEXT m_pCertificate;

    static HRESULT _ProcessFind(
                            LDAP *  pld,
                            LPCWSTR wszQuery, 
                            LPCWSTR wszScope,
                            DWORD   dwFlags,
                            CCAInfo **ppCAInfo);


    HRESULT _Cleanup();

    DWORD AddRef();

    CCAProperty *   m_pProperties;

    LONG            m_cRef;

    CCAInfo *       m_pNext;

    CERTSTR         m_bstrDN;

    BOOL            m_fNew;

    DWORD           m_dwExpiration;      

    DWORD           m_dwExpUnits;

    DWORD           m_dwFlags;


    PSECURITY_DESCRIPTOR    m_pSD;

private:
};

#define CA_PROP_FLAGS                 L"flags"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certclib\cainfo.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 2001
//
// File:        cainfo.cpp
//
// Contents:    
//
//---------------------------------------------------------------------------
#include "pch.cpp"

#pragma hdrstop

#include <certca.h>
#include <cainfop.h>
#include <polreg.h>
#include <cainfoc.h>
#include <certtype.h>

#include <winldap.h>

#define __dwFILE__	__dwFILE_CERTCLIB_CAINFO_CPP__

typedef struct _CA_DEFAULT_PROVIDER {
    DWORD dwFlags;
    LPWSTR wszName;
} CA_DEFAULT_PROVIDER;

CA_DEFAULT_PROVIDER g_DefaultProviders[] = 
{
    {0, MS_DEF_PROV_W},
    {0, MS_ENHANCED_PROV_W},
    {0, MS_DEF_RSA_SIG_PROV_W},
    {0, MS_DEF_RSA_SCHANNEL_PROV_W},
    {0, MS_DEF_DSS_PROV_W},
    {0, MS_DEF_DSS_DH_PROV_W},
    {0, MS_ENH_DSS_DH_PROV_W},
    {0, MS_DEF_DH_SCHANNEL_PROV_W},
    {0, MS_SCARD_PROV_W}
};

DWORD g_cDefaultProviders = sizeof(g_DefaultProviders)/sizeof(g_DefaultProviders[0]);

LPCWSTR
CAGetDN(
        IN HCAINFO hCAInfo
        )
{
CSASSERT(hCAInfo);
return ((CCAInfo*)hCAInfo)->GetDN();
}

HRESULT
CAFindByName(
        IN  LPCWSTR     wszCAName,
        IN  LPCWSTR     wszScope,
        IN  DWORD       fFlags,
        OUT HCAINFO *   phCAInfo
        )
{
    HRESULT hr = S_OK;
    DWORD err;
    WCHAR *wszQueryBase = L"(cn=";
    WCHAR *wszQuery = NULL;
    DWORD cQuery;
    
    if((wszCAName == NULL) || (phCAInfo == NULL))
    {
        return E_POINTER;
    }
    // Generate Query

    cQuery = wcslen(wszQueryBase) + wcslen(wszCAName) + 2; // 2 for ending paren and null
    wszQuery = (WCHAR *)LocalAlloc(LMEM_FIXED, sizeof(WCHAR)*cQuery);
    if(wszQuery == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }
    wcscpy(wszQuery, wszQueryBase);
    wcscat(wszQuery, wszCAName);
    wcscat(wszQuery, L")");

    if(fFlags & CA_FLAG_SCOPE_DNS)
    {
        hr = CCAInfo::FindDnsDomain(wszQuery, wszScope, fFlags, (CCAInfo **)phCAInfo);
    }
    else
    {
        hr = CCAInfo::Find(wszQuery, wszScope, fFlags, (CCAInfo **)phCAInfo);
    }
    if((hr == S_OK) && 
      (*phCAInfo == NULL))
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }

error:
    if(wszQuery)
    {
        LocalFree(wszQuery);
    }

    return hr;
}


HRESULT
CAFindByCertType(
        IN  LPCWSTR     wszCertType,
        IN  LPCWSTR     wszScope,
        IN  DWORD       fFlags,
        OUT HCAINFO *   phCAInfo
        )
{
    HRESULT hr = S_OK;
    DWORD err;
    WCHAR *wszQueryBase = L"(" CA_PROP_CERT_TYPES L"=";
    WCHAR *wszQuery = NULL;
    DWORD cQuery;
    
    if((wszCertType == NULL) || (phCAInfo == NULL))
    {
        return E_POINTER;
    }
    // Generate Query

    cQuery = wcslen(wszQueryBase) + wcslen(wszCertType) + 2; // 2 for ending paren and null
    wszQuery = (WCHAR *)LocalAlloc(LMEM_FIXED, sizeof(WCHAR)*cQuery);
    if(wszQuery == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }
    wcscpy(wszQuery, wszQueryBase);
    wcscat(wszQuery, wszCertType);
    wcscat(wszQuery, L")");

    if(fFlags & CA_FLAG_SCOPE_DNS)
    {
        hr = CCAInfo::FindDnsDomain(wszQuery, wszScope, fFlags, (CCAInfo **)phCAInfo);
    }
    else
    {
        hr = CCAInfo::Find(wszQuery, wszScope, fFlags, (CCAInfo **)phCAInfo);
    }
    if(*phCAInfo == NULL)
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }

error:
    if(wszQuery)
    {
        LocalFree(wszQuery);
    }

    return hr;
}


HRESULT
CAFindByIssuerDN(
        IN  CERT_NAME_BLOB const *  pIssuerDN,
        IN  LPCWSTR                 wszScope,
        IN  DWORD                   fFlags,
        OUT HCAINFO *               phCAInfo
        )
{
    HRESULT hr = S_OK;
    DWORD err;
    WCHAR *wszQueryBase = wszLPAREN L"cACertificateDN=";
    WCHAR *wszQuery = NULL;
    WCHAR *wszNameStr = NULL;

    DWORD cQuery;
    
    if((pIssuerDN == NULL) || (phCAInfo == NULL))
    {
        return E_POINTER;
    }

    // Generate Query

    // Convert the CAPI2 name to a string

    hr = myCertNameToStr(
		X509_ASN_ENCODING,
		pIssuerDN,
                CERT_X500_NAME_STR |
		    CERT_NAME_STR_REVERSE_FLAG |
		    CERT_NAME_STR_NO_QUOTING_FLAG,
		&wszNameStr);
    _JumpIfError(hr, error, "myCertNameToStr");

    // Now quote that string with double quotes
    // two for ending paren and null, two for the double quotes

    cQuery = wcslen(wszQueryBase) + wcslen(wszNameStr) + 4;
    wszQuery = (WCHAR *)LocalAlloc(LMEM_FIXED, sizeof(WCHAR)*cQuery);
    if(wszQuery == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }
    wcscpy(wszQuery, wszQueryBase);
    wcscat(wszQuery, L"\"");
    wcscat(wszQuery, wszNameStr);
    wcscat(wszQuery, L"\"" wszRPAREN);
    CSASSERT(cQuery - 1 == wcslen(wszQuery));

    if(fFlags & CA_FLAG_SCOPE_DNS)
    {
        hr = CCAInfo::FindDnsDomain(wszQuery, wszScope, fFlags, (CCAInfo **)phCAInfo);
    }
    else
    {
        hr = CCAInfo::Find(wszQuery, wszScope, fFlags, (CCAInfo **)phCAInfo);
    }

error:
    if(wszNameStr)
    {
        LocalFree(wszNameStr);
    }
    if(wszQuery)
    {
        LocalFree(wszQuery);
    }
    return hr;
}



HRESULT
CAEnumFirstCA(
    IN  LPCWSTR          wszScope,
    IN  DWORD            fFlags,
    OUT HCAINFO *        phCAInfo
    )
{
    HRESULT hr = S_OK;

    if(fFlags & CA_FLAG_SCOPE_DNS)
    {
        hr = CCAInfo::FindDnsDomain(NULL, wszScope, fFlags, (CCAInfo **)phCAInfo);
    }
    else
    {
        hr = CCAInfo::Find(NULL, wszScope, fFlags, (CCAInfo **)phCAInfo);
    }
    if (S_OK != hr)
    {
	    if (HRESULT_FROM_WIN32(ERROR_NETWORK_UNREACHABLE) != hr &&
	        HRESULT_FROM_WIN32(ERROR_WRONG_PASSWORD) != hr)
	    {
	        _PrintError3(
		        hr,
		        "FindDnsDomain/Find",
		        HRESULT_FROM_WIN32(ERROR_SERVER_DISABLED),
		        HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN));
	    }
	    goto error;
    }

error:
    return(hr);
}


HRESULT
CAEnumNextCA(
    IN  HCAINFO          hPrevCA,
    OUT HCAINFO *        phCAInfo
    )
{
    CCAInfo *pInfo;
    if(hPrevCA == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hPrevCA;

    return pInfo->Next((CCAInfo **)phCAInfo);
}




HRESULT 
CACreateNewCA(
        IN  LPCWSTR     wszCAName,
        IN  LPCWSTR     wszScope,
        IN  DWORD       fFlags,
        OUT HCAINFO *   phCAInfo
        )
{
    HRESULT hr = S_OK;
    DWORD err;

    
    if((wszCAName == NULL) || (phCAInfo == NULL))
    {
        return E_POINTER;
    }
    // Generate Query


    if(CA_FLAG_SCOPE_DNS & fFlags)
    {
        hr = CCAInfo::CreateDnsDomain(wszCAName, wszScope, (CCAInfo **)phCAInfo);
    }
    else
    {
        hr = CCAInfo::Create(wszCAName, wszScope, (CCAInfo **)phCAInfo);
    }


    return hr;
}


HRESULT 
CAUpdateCA(
        IN HCAINFO    hCAInfo
        )
{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hCAInfo;

    return pInfo->Update();
}


HRESULT 
CADeleteCA(
        IN HCAINFO    hCAInfo
        )
{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hCAInfo;

    return pInfo->Delete();
}

DWORD 
CACountCAs(IN  HCAINFO  hCAInfo)
{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return 0;
    }
    pInfo = (CCAInfo *)hCAInfo;

    return pInfo->Count();
}


HRESULT
CACloseCA(IN HCAINFO hCAInfo)
{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hCAInfo;

    return pInfo->Release();
}


HRESULT
CAGetCAProperty(
    IN  HCAINFO     hCAInfo,
    IN  LPCWSTR     wszPropertyName,
    OUT LPWSTR **   pawszPropertyValue)
{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hCAInfo;

    return pInfo->GetProperty(wszPropertyName, pawszPropertyValue);
}


HRESULT
CAFreeCAProperty(
    IN  HCAINFO     hCAInfo,
    IN  LPWSTR *    awszPropertyValue
    )
{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hCAInfo;

    return pInfo->FreeProperty(awszPropertyValue);
}


HRESULT
CASetCAProperty(
    IN HCAINFO      hCAInfo,
    IN LPCWSTR     wszPropertyName,
    IN LPWSTR *    awszPropertyValue)
{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hCAInfo;

    return pInfo->SetProperty(wszPropertyName, awszPropertyValue);
}

HRESULT 
CAGetCAFlags(
    IN  HCAINFO     hCAInfo,
    OUT DWORD *     pdwFlags
    )
{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }

    if(pdwFlags == NULL)
    {
        return E_POINTER;
    }

    pInfo = (CCAInfo *)hCAInfo;


    *pdwFlags = pInfo->GetFlags();
    return S_OK;
}

HRESULT 
CASetCAFlags(
    IN HCAINFO     hCAInfo,
    IN DWORD       dwFlags
    )
{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hCAInfo;

    pInfo->SetFlags(dwFlags);
    return S_OK;
}

HRESULT
CAGetCACertificate(
    IN  HCAINFO     hCAInfo,
    OUT PCCERT_CONTEXT *ppCert)
{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hCAInfo;

    return pInfo->GetCertificate(ppCert);

}


HRESULT
CASetCACertificate(
    IN  HCAINFO     hCAInfo,
    IN PCCERT_CONTEXT pCert)
{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hCAInfo;

    return pInfo->SetCertificate(pCert);
}



HRESULT 
CAGetCAExpiration(
                HCAINFO hCAInfo, 
                DWORD * pdwExpiration, 
                DWORD * pdwUnits
                )
{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hCAInfo;

    return pInfo->GetExpiration(pdwExpiration, pdwUnits);

}


HRESULT 
CASetCAExpiration(
                HCAINFO hCAInfo, 
                DWORD dwExpiration, 
                DWORD dwUnits
                )
{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hCAInfo;

    return pInfo->SetExpiration(dwExpiration, dwUnits);
}

HRESULT 
CASetCASecurity(
                     IN HCAINFO                 hCAInfo,
                     IN PSECURITY_DESCRIPTOR    pSD
                     )
{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hCAInfo;

    return pInfo->SetSecurity( pSD );
}


HRESULT 
CAGetCASecurity(
                     IN  HCAINFO                    hCAInfo,
                     OUT PSECURITY_DESCRIPTOR *     ppSD
                     )
{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hCAInfo;

    return pInfo->GetSecurity( ppSD ) ;
}

CERTCLIAPI
HRESULT
WINAPI
CAAccessCheck(
    IN  HCAINFO     hCAInfo,
    IN HANDLE       ClientToken
    )

{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hCAInfo;

    return pInfo->AccessCheck(ClientToken,CERTTYPE_ACCESS_CHECK_ENROLL);
}



CERTCLIAPI
HRESULT
WINAPI
CAAccessCheckEx(
    IN  HCAINFO     hCAInfo,
    IN HANDLE       ClientToken,
    IN DWORD        dwOption
    )

{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hCAInfo;

    return pInfo->AccessCheck(ClientToken,dwOption);
}


HRESULT
CAEnumCertTypesForCAEx(
    IN  HCAINFO     hCAInfo,
    IN  LPCWSTR     wszScope,
    IN  DWORD       dwFlags,
    OUT HCERTTYPE * phCertType
    )
{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hCAInfo;
    if(dwFlags & CA_FLAG_ENUM_ALL_TYPES)
    {
        return  CCertTypeInfo::Enum(wszScope, 
                                 dwFlags, 
                                 (CCertTypeInfo **)phCertType);
    }

    return pInfo->EnumSupportedCertTypesEx(wszScope,
                                         dwFlags, 
                                         (CCertTypeInfo **)phCertType);

}


HRESULT
CAEnumCertTypesForCA(
    IN  HCAINFO     hCAInfo,
    IN  DWORD       dwFlags,
    OUT HCERTTYPE * phCertType
    )
{
    return CAEnumCertTypesForCAEx(hCAInfo,
                                  NULL,
                                  dwFlags,
                                  phCertType);
}



HRESULT 
CAAddCACertificateType(
                HCAINFO hCAInfo, 
                HCERTTYPE hCertType
                )
{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hCAInfo;

    return pInfo->AddCertType((CCertTypeInfo *)hCertType);
}


HRESULT 
CARemoveCACertificateType(
                HCAINFO hCAInfo, 
                HCERTTYPE hCertType
                )
{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hCAInfo;

    return pInfo->RemoveCertType((CCertTypeInfo *)hCertType);
}


//
// Certificate Type API's
//


HRESULT
CAEnumCertTypes(
    IN  DWORD       dwFlags,
    OUT HCERTTYPE * phCertType
    )
{
    HRESULT hr;

    hr = CCertTypeInfo::Enum(NULL, 
                             dwFlags, 
                             (CCertTypeInfo **)phCertType);
    return hr;

}


HRESULT
CAEnumCertTypesEx(
    IN  LPCWSTR     wszScope,
    IN  DWORD       dwFlags,
    OUT HCERTTYPE * phCertType
    )
{
    HRESULT hr;

    hr = CCertTypeInfo::Enum(wszScope, 
                             dwFlags, 
                             (CCertTypeInfo **)phCertType);
    return hr;

}


HRESULT 
CAFindCertTypeByName(
        IN  LPCWSTR     wszCertType,
        IN  HCAINFO     hCAInfo,
        IN  DWORD       dwFlags,
        OUT HCERTTYPE * phCertType
        )
{
    HRESULT hr = S_OK;
    LPCWSTR awszTypes[2];
    if((wszCertType == NULL) || (phCertType == NULL))
    {
        return E_POINTER;
    }


    awszTypes[0] = wszCertType;
    awszTypes[1] = NULL;



    hr = CCertTypeInfo::FindByNames(awszTypes, 
                                   ((CT_FLAG_SCOPE_IS_LDAP_HANDLE & dwFlags)?(LPWSTR)hCAInfo:NULL), 
                                   dwFlags, 
                                   (CCertTypeInfo **)phCertType);
    if((hr == S_OK) && (*phCertType == NULL))
    {
         hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }

    return hr;
}

HRESULT 
CACreateCertType(
        IN  LPCWSTR             wszCertType,
        IN  LPCWSTR             wszScope,
        IN  DWORD               fFlags,
        OUT HCERTTYPE *         phCertType
        )
{
    HRESULT hr = S_OK;
    DWORD err;

    
    if((wszCertType == NULL) || (phCertType == NULL))
    {
        return E_POINTER;
    }

    hr = CCertTypeInfo::Create(wszCertType, wszScope, (CCertTypeInfo **)phCertType);

    return hr;
}
HRESULT 
CAUpdateCertType(
        IN HCERTTYPE           hCertType
        )
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hCertType;

    return pInfo->Update();
}


HRESULT 
CADeleteCertType(
        IN HCERTTYPE            hCertType
        )
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hCertType;

    return pInfo->Delete();
}

//--------------------------------------------------------------------
//
//  CertTypeRetrieveClientToken
//
//--------------------------------------------------------------------
BOOL    CertTypeRetrieveClientToken(HANDLE  *phToken)
{
    HRESULT         hr = S_OK;

    HANDLE          hHandle = NULL;
    HANDLE          hClientToken = NULL;

    hHandle = GetCurrentThread();
    if (NULL == hHandle)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {

        if (!OpenThreadToken(hHandle,
                             TOKEN_QUERY,
                             TRUE,  // open as self
                             &hClientToken))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            CloseHandle(hHandle);
            hHandle = NULL;
        }
    }

    if(hr != S_OK)
    {
        hHandle = GetCurrentProcess();
        if (NULL == hHandle)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        else
        {
            HANDLE hProcessToken = NULL;
            hr = S_OK;


            if (!OpenProcessToken(hHandle,
                                 TOKEN_DUPLICATE,
                                 &hProcessToken))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                CloseHandle(hHandle);
                hHandle = NULL;
            }
            else
            {
                if(!DuplicateToken(hProcessToken,
                               SecurityImpersonation,
                               &hClientToken))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    CloseHandle(hHandle);
                    hHandle = NULL;
                }
                CloseHandle(hProcessToken);
            }
        }
    }


    if(S_OK == hr)
        *phToken = hClientToken;

    if(hHandle)
        CloseHandle(hHandle);

    return (S_OK == hr);
}


HRESULT
CACloneCertType(
    IN  HCERTTYPE            hCertType,
    IN  LPCWSTR              wszCertType,
    IN  LPCWSTR              wszFriendlyName,
    IN  LPVOID               pvldap,
    IN  DWORD                dwFlags,
    OUT HCERTTYPE *          phCertType
    )
{
    HRESULT                 hr=E_INVALIDARG;
    DWORD                   dwFindCT=CT_FLAG_NO_CACHE_LOOKUP | CT_ENUM_MACHINE_TYPES | CT_ENUM_USER_TYPES;
    LPWSTR                  awszProp[2];
    DWORD                   dwEnrollmentFlag=0;
    DWORD                   dwSubjectNameFlag=0;
    DWORD                   dwGeneralFlag=0;
    DWORD                   dwSubjectRequirement=CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH | 
                                         CT_FLAG_SUBJECT_REQUIRE_COMMON_NAME | 
                                         CT_FLAG_SUBJECT_REQUIRE_EMAIL |
                                         CT_FLAG_SUBJECT_REQUIRE_DNS_AS_CN;
    DWORD                   dwTokenUserSize=0;
    DWORD                   dwAbsSDSize=0;
    DWORD                   dwDaclSize=0;
    DWORD                   dwSaclSize=0;
    DWORD                   dwOwnerSize=0;
    DWORD                   dwPriGrpSize=0;
    DWORD                   dwRelSDSize=0;

    HANDLE                  hToken=NULL;
    TOKEN_USER              *pTokenUser=NULL;
    PSECURITY_DESCRIPTOR    pSID=NULL;
    PSECURITY_DESCRIPTOR    pAbsSD=NULL;
    ACL                     * pAbsDacl=NULL;
    ACL                     * pAbsSacl=NULL;
    SID                     * pAbsOwner=NULL;
    SID                     * pAbsPriGrp=NULL;
    PSECURITY_DESCRIPTOR    pNewSD=NULL;
    LPWSTR *                awszCN=NULL;
    HCERTTYPE               hNewCertType=NULL;

    if((NULL==hCertType) || (NULL==wszCertType) || (NULL==phCertType))
        goto error;

    *phCertType=NULL;

    if(pvldap)
        dwFindCT |= CT_FLAG_SCOPE_IS_LDAP_HANDLE;

    //make sure the new name does not exit
    if(S_OK == CAFindCertTypeByName(
                    wszCertType,
                    (HCAINFO)pvldap,
                    dwFindCT,
                    &hNewCertType))
    {
        hr=CRYPT_E_EXISTS;
        goto error;
    }

    //get a new cert type handle
    if(S_OK != (hr = CAGetCertTypePropertyEx(hCertType,
                                            CERTTYPE_PROP_CN,
                                            &awszCN)))
        goto error;

    if((NULL==awszCN) || (NULL==awszCN[0]))
    {
        hr=HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        goto error;
    }


    if(S_OK != (hr = CAFindCertTypeByName(
                    (LPCWSTR)awszCN[0],
                    (HCAINFO)pvldap,
                    dwFindCT,
                    &hNewCertType)))
        goto error;

    if(NULL==hNewCertType)
    {
        hr=HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        goto error;
    }

    //clone by setting the CN
    awszProp[0]=(LPWSTR)wszCertType;
    awszProp[1]=NULL;

    if(S_OK != (hr=CASetCertTypePropertyEx(
                    hNewCertType,
                    CERTTYPE_PROP_CN,
                    awszProp)))
        goto error;
                    

    //set the friendly name
    if(wszFriendlyName)
    {
        awszProp[0]=(LPWSTR)wszFriendlyName;
        awszProp[1]=NULL;

        if(S_OK != (hr=CASetCertTypePropertyEx(
                    hNewCertType,
                    CERTTYPE_PROP_FRIENDLY_NAME,
                    awszProp)))
            goto error;
    }

    //turn off autoenrollment bit
    if(0 == (CT_CLONE_KEEP_AUTOENROLLMENT_SETTING & dwFlags))
    {
        if(S_OK != (hr=CAGetCertTypeFlagsEx(
                        hNewCertType,
                        CERTTYPE_ENROLLMENT_FLAG,
                        &dwEnrollmentFlag)))
            goto error;

        dwEnrollmentFlag &= (~CT_FLAG_AUTO_ENROLLMENT);

        if(S_OK != (hr=CASetCertTypeFlagsEx(
                        hNewCertType,
                        CERTTYPE_ENROLLMENT_FLAG,
                        dwEnrollmentFlag)))
            goto error;
    }


    //turn off the subject name requirement for machien template
    if(0 == (CT_CLONE_KEEP_SUBJECT_NAME_SETTING & dwFlags))
    {
        if(S_OK != (hr=CAGetCertTypeFlagsEx(
                        hNewCertType,
                        CERTTYPE_GENERAL_FLAG,
                        &dwGeneralFlag)))
            goto error;


        if(CT_FLAG_MACHINE_TYPE & dwGeneralFlag)
        {
            if(S_OK != (hr=CAGetCertTypeFlagsEx(
                            hNewCertType,
                            CERTTYPE_SUBJECT_NAME_FLAG,
                            &dwSubjectNameFlag)))
                goto error;

            dwSubjectNameFlag &= (~dwSubjectRequirement);

            if(S_OK != (hr=CASetCertTypeFlagsEx(
                            hNewCertType,
                            CERTTYPE_SUBJECT_NAME_FLAG,
                            dwSubjectNameFlag)))
                goto error;

        }
    }


    //get the client token
    if(!CertTypeRetrieveClientToken(&hToken))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }

    //get the client sid
    dwTokenUserSize=0;

    if(!GetTokenInformation(
        hToken,                             // handle to access token
        TokenUser,                          // token type
        NULL,                               // buffer
        0,                                  // size of buffer
        &dwTokenUserSize))                  // required buffer size
    {
        if (ERROR_INSUFFICIENT_BUFFER!=GetLastError()) 
        {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto error;
        }
    }

    if(NULL==(pTokenUser=(TOKEN_USER *)LocalAlloc(LPTR, dwTokenUserSize)))
    {
        hr=E_OUTOFMEMORY;
        goto error;
    }

    if(!GetTokenInformation(
        hToken,                             // handle to access token
        TokenUser,                          // token type
        pTokenUser,                         // buffer
        dwTokenUserSize,                    // size of buffer
        &dwTokenUserSize))                  // required buffer size
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }


    //update the ACLs of the template to have the caller as the owner
    //of the ACL
    if(S_OK != (hr=CACertTypeGetSecurity(
                        hNewCertType,
                        &pSID)))
        goto error;


    if(!MakeAbsoluteSD(pSID, NULL, &dwAbsSDSize, NULL, &dwDaclSize, NULL, &dwSaclSize, NULL,  &dwOwnerSize, NULL, &dwPriGrpSize))
    {
        if (ERROR_INSUFFICIENT_BUFFER!=GetLastError()) 
        {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto error;
        }
    }

    // allocate memory
    if(NULL==(pAbsSD=(PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, dwAbsSDSize)))
    {
        hr=E_OUTOFMEMORY;
        goto error;
    }

    if(NULL==(pAbsDacl=(ACL * )LocalAlloc(LPTR, dwDaclSize)))
    {
        hr=E_OUTOFMEMORY;
        goto error;
    }

    if(NULL==(pAbsSacl=(ACL * )LocalAlloc(LPTR, dwSaclSize)))
    {
        hr=E_OUTOFMEMORY;
        goto error;
    }

    if(NULL==(pAbsOwner=(SID *)LocalAlloc(LPTR, dwOwnerSize)))
    {
        hr=E_OUTOFMEMORY;
        goto error;
    }

    if(NULL==(pAbsPriGrp=(SID *)LocalAlloc(LPTR, dwPriGrpSize)))
    {
        hr=E_OUTOFMEMORY;
        goto error;
    }

    // copy the SD to the memory buffers
    if(!MakeAbsoluteSD(pSID, pAbsSD, &dwAbsSDSize, pAbsDacl, &dwDaclSize, pAbsSacl, &dwSaclSize, pAbsOwner,  &dwOwnerSize, pAbsPriGrp, &dwPriGrpSize)) 
    {
        hr=HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }

    if(!SetSecurityDescriptorOwner(
        pAbsSD,                      // SD
        (pTokenUser->User).Sid,      // SID for owner
        FALSE))                      // flag for default
    {
        hr=HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }


    //convert the absolute SD to its relative form
    if(!MakeSelfRelativeSD(pAbsSD, NULL, &dwRelSDSize))
    {
        if (ERROR_INSUFFICIENT_BUFFER!=GetLastError()) 
        {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto error;
        }
    }

    // allocate memory
    if(NULL==(pNewSD=(PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, dwRelSDSize)))
    {
        hr=E_OUTOFMEMORY;
        goto error;
    }

    // copy the SD to the new memory buffer
    if (!MakeSelfRelativeSD(pAbsSD, pNewSD, &dwRelSDSize)) 
    {
        hr=HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }

    //set the relative SID
    if(S_OK != (hr=CACertTypeSetSecurity(
                    hNewCertType,
                    pNewSD)))
        goto error;


    //update the template
  /*  if(S_OK != (hr = CAUpdateCertType(hNewCertType)))
        goto error;


    //update the local machine cache.  No need to check the return value
    //because the certificate template has been successfully cloned on the directory
    CAEnumCertTypesEx((LPCWSTR)pvldap,
                       dwFindCT | CT_FIND_LOCAL_SYSTEM,
                       &hMachineCertType); */

    *phCertType=hNewCertType;

    hNewCertType=NULL;

    hr=S_OK;

error:

    if(hToken)
        CloseHandle(hToken);

    if(pTokenUser)
        LocalFree(pTokenUser);

    if(pSID)
        LocalFree(pSID);

    if (NULL!=pAbsSD) 
        LocalFree(pAbsSD);
    
    if (NULL!=pAbsDacl) 
        LocalFree(pAbsDacl);
    
    if (NULL!=pAbsSacl) 
        LocalFree(pAbsSacl);
    
    if (NULL!=pAbsOwner) 
        LocalFree(pAbsOwner);
    
    if (NULL!=pAbsPriGrp) 
        LocalFree(pAbsPriGrp);
    
    if (NULL!=pNewSD) 
        LocalFree(pNewSD);

    if(awszCN)
        CAFreeCertTypeProperty(hCertType, awszCN);

    if(hNewCertType)
        CACloseCertType(hNewCertType);

    return hr;
}

HRESULT
CAEnumNextCertType(
    IN  HCERTTYPE          hPrevCertType,
    OUT HCERTTYPE *        phCertTypeInfo
    )
{
    CCertTypeInfo *pInfo;
    if(hPrevCertType == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hPrevCertType;

    return pInfo->Next((CCertTypeInfo **)phCertTypeInfo);
}

DWORD 
CACountCertTypes(IN  HCERTTYPE  hCertType)
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return 0;
    }
    pInfo = (CCertTypeInfo *)hCertType;

    return pInfo->Count();
}


HRESULT
CACloseCertType(IN HCERTTYPE hCertTypeInfo)
{
    CCertTypeInfo *pInfo;
    if(hCertTypeInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hCertTypeInfo;

    return pInfo->Release();
}


HRESULT
CAGetCertTypeProperty(
    IN  HCERTTYPE   hCertType,
    IN  LPCWSTR     wszPropertyName,
    OUT LPWSTR **   pawszPropertyValue)
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hCertType;

    return pInfo->GetProperty(wszPropertyName, pawszPropertyValue);
}

HRESULT
CAGetCertTypePropertyEx(
    IN  HCERTTYPE   hCertType,
    IN  LPCWSTR     wszPropertyName,
    OUT LPVOID      pPropertyValue)
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hCertType;

    return pInfo->GetPropertyEx(wszPropertyName, pPropertyValue);
}


HRESULT 
CASetCertTypeProperty(
    IN  HCERTTYPE   hCertType,
    IN  LPCWSTR     wszPropertyName,
    IN  LPWSTR *    awszPropertyValue)
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hCertType;

    return pInfo->SetProperty(wszPropertyName, awszPropertyValue) ;
}


HRESULT 
CASetCertTypePropertyEx(
    IN  HCERTTYPE   hCertType,
    IN  LPCWSTR     wszPropertyName,
    IN  LPVOID      pPropertyValue)
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hCertType;

    return pInfo->SetPropertyEx(wszPropertyName, pPropertyValue) ;
}


HRESULT
CAFreeCertTypeProperty(
    IN  HCERTTYPE   hCertType,
    LPWSTR *        awszPropertyValue
    )
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hCertType;

    return pInfo->FreeProperty(awszPropertyValue) ;
}


HRESULT
CAGetCertTypeExtensions(
    IN  HCERTTYPE           hCertType,
    OUT PCERT_EXTENSIONS *  ppCertExtensions
    )
{
    return CAGetCertTypeExtensionsEx(hCertType, 0, NULL, ppCertExtensions);
}


HRESULT
CAGetCertTypeExtensionsEx(
    IN  HCERTTYPE           hCertType,
    IN  DWORD               dwFlags,
    IN  LPVOID              pParam,
    OUT PCERT_EXTENSIONS *  ppCertExtensions
    )
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hCertType;

    return pInfo->GetExtensions(dwFlags, pParam, ppCertExtensions) ;
}

HRESULT
CAFreeCertTypeExtensions(
    IN  HCERTTYPE           hCertType,
    IN PCERT_EXTENSIONS     pCertExtensions
    )
{

    //should alreays free via LocalFree since CryptUIWizCertRequest freed
    //it via LocalFree
    CCertTypeInfo *pInfo;
    if(pCertExtensions)
    {
        LocalFree(pCertExtensions);
    }
    return S_OK;

#if 0
    if(hCertType == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hCertType;

    return pInfo->FreeExtensions(pCertExtensions) ;
#endif
}

HRESULT 
CASetCertTypeExtension(
    IN HCERTTYPE    hCertType,
    IN LPCWSTR      wszExtensionName,
    IN DWORD        dwFlags,
    IN LPVOID       pExtension
    )
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hCertType;

    return pInfo->SetExtension(wszExtensionName, pExtension, dwFlags);
}


HRESULT 
CAGetCertTypeFlags(
    IN  HCERTTYPE           hCertType,
    OUT DWORD *             pdwFlags
    )
{
    return CAGetCertTypeFlagsEx(hCertType, CERTTYPE_GENERAL_FLAG, pdwFlags);
}


HRESULT
CAGetCertTypeFlagsEx(
    IN  HCERTTYPE           hCertType,
    IN  DWORD               dwOption,
    OUT DWORD *             pdwFlags
    )
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return E_POINTER;
    }

    if(pdwFlags == NULL)
    {
        return E_POINTER;
    }

    pInfo = (CCertTypeInfo *)hCertType;


    *pdwFlags = pInfo->GetFlags(dwOption);
    return S_OK;
}


HRESULT 
CASetCertTypeFlags(
    IN HCERTTYPE           hCertType,
    IN DWORD               dwFlags
    )
{
    return CASetCertTypeFlagsEx(hCertType, CERTTYPE_GENERAL_FLAG, dwFlags);
}


HRESULT
CASetCertTypeFlagsEx(
    IN HCERTTYPE           hCertType,
    IN DWORD               dwOption,
    IN DWORD               dwFlags
    )
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hCertType;

    return pInfo->SetFlags(dwOption, dwFlags);
}


HRESULT 
CAGetCertTypeKeySpec(
    IN  HCERTTYPE           hCertType,
    OUT DWORD *             pdwKeySpec
    )
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return E_POINTER;
    }

    if(pdwKeySpec == NULL)
    {
        return E_POINTER;
    }

    pInfo = (CCertTypeInfo *)hCertType;


    *pdwKeySpec = pInfo->GetKeySpec();
    return S_OK;
}





HRESULT 
CASetCertTypeKeySpec(
    IN HCERTTYPE           hCertType,
    IN DWORD               dwKeySpec
    )
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hCertType;

    pInfo->SetKeySpec(dwKeySpec);
    return S_OK;
}

HRESULT
CAGetCertTypeExpiration(
    IN  HCERTTYPE           hCertType,
    OUT OPTIONAL FILETIME * pftExpiration,
    OUT OPTIONAL FILETIME * pftOverlap
    )
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hCertType;

    return pInfo->GetExpiration(pftExpiration, pftOverlap);


}

HRESULT
CASetCertTypeExpiration(
    IN  HCERTTYPE           hCertType,
    IN OPTIONAL FILETIME  * pftExpiration,
    IN OPTIONAL FILETIME  * pftOverlap
    )
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hCertType;

    return pInfo->SetExpiration(pftExpiration, pftOverlap);

}


HRESULT 
CACertTypeSetSecurity(
                     IN HCERTTYPE               hCertType,
                     IN PSECURITY_DESCRIPTOR    pSD
                     )
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hCertType;

    return pInfo->SetSecurity( pSD );
}


HRESULT 
CACertTypeGetSecurity(
                     IN  HCERTTYPE                  hCertType,
                     OUT PSECURITY_DESCRIPTOR *     ppSD
                     )
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hCertType;

    return pInfo->GetSecurity( ppSD ) ;
}



HRESULT 
CACertTypeAccessCheck(
    IN HCERTTYPE    hCertType,
    IN HANDLE       ClientToken
    )

{

    return CACertTypeAccessCheckEx(hCertType, ClientToken, CERTTYPE_ACCESS_CHECK_ENROLL);
}


CERTCLIAPI
HRESULT
WINAPI
CACertTypeAccessCheckEx(
    IN HCERTTYPE    hCertType,
    IN HANDLE       ClientToken,
    IN DWORD        dwOption
    )
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hCertType;

    return pInfo->AccessCheck(ClientToken, dwOption);
}

CERTCLIAPI
HRESULT
WINAPI
CAInstallDefaultCertType(
    IN DWORD dwFlags
    )
{
    return CCertTypeInfo::InstallDefaultTypes();
}

CERTCLIAPI
BOOL
WINAPI
CAIsCertTypeCurrent(
    IN DWORD    dwFlags,
    IN LPWSTR   wszCertType   
    )
{
    BOOL        fCurrent=FALSE;
    HRESULT     hr=E_FAIL;
    DWORD       dwIndex=0;
    DWORD       dwVersion=0;

    HCERTTYPE   hCertType=NULL;

    if(NULL==wszCertType)
        goto error;

    hr=CAFindCertTypeByName(
                wszCertType,
                NULL,
                CT_ENUM_USER_TYPES | CT_FLAG_NO_CACHE_LOOKUP | CT_ENUM_MACHINE_TYPES,
                &hCertType);

    if((S_OK != hr) || (NULL==hCertType))
        goto error;

    //we assume this is a V2 certificate template
    hr=CAGetCertTypePropertyEx(
                    hCertType,
                    CERTTYPE_PROP_REVISION,
                    &dwVersion);

    if(S_OK != hr)
        goto error;

    for(dwIndex=0; dwIndex < g_cDefaultCertTypes; dwIndex++)
    {
        if (0==lstrcmpi(wszCertType, g_aDefaultCertTypes[dwIndex].wszName)) 
        {
            if (dwVersion >= g_aDefaultCertTypes[dwIndex].dwRevision) 
                fCurrent=TRUE;

            break;
        }
    }

    //the template is not default
    if(dwIndex == g_cDefaultCertTypes)
        fCurrent=TRUE;

error:

    if(hCertType)
        CACloseCertType(hCertType);

    return fCurrent;
}


HANDLE
myEnterCriticalPolicySection(
    IN BOOL bMachine)
{
    HANDLE hPolicy = NULL;
    HRESULT hr = S_OK;
    
    // ?CriticalPolicySection calls are delay loaded. Protect with try/except

    __try
    {
	hPolicy = EnterCriticalPolicySection(bMachine);	   // Delayload wrapped
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

    // (S_OK == hr) does not mean EnterCriticalPolicySection succeeded.
    // It just means no exception was raised.

    if (myIsDelayLoadHResult(hr))
    {
	hPolicy = (HANDLE) (ULONG_PTR) (bMachine? 37 : 49);
	hr = S_OK;
    }
    return(hPolicy);
}


BOOL
myLeaveCriticalPolicySection(
    IN HANDLE hSection)
{
    HRESULT hr = S_OK;
    BOOL fOk = FALSE;
    
    // ?CriticalPolicySection calls are delay loaded. Protect with try/except

    __try
    {
        fOk = LeaveCriticalPolicySection(hSection);    // Delayload wrapped
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

    // (S_OK == hr) does not mean LeaveCriticalPolicySection succeeded.
    // It just means no exception was raised.

    if (myIsDelayLoadHResult(hr))
    {
	fOk = (HANDLE) (ULONG_PTR) 37 == hSection ||
	      (HANDLE) (ULONG_PTR) 49 == hSection;
	hr = S_OK;
    }
    return(fOk);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certclib\cainfop.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        cainfop.cpp
//
// Contents:
//
//---------------------------------------------------------------------------
#include "pch.cpp"

#pragma hdrstop

#include <certca.h>
#include <lm.h>
#include <cainfop.h>
#include <cainfoc.h>


#include <winldap.h>
#include <ntlsa.h>
#include <dsgetdc.h>
#include <accctrl.h>

#include "certacl.h"
#include "oidmgr.h"
#include "csldap.h"

#define __dwFILE__	__dwFILE_CERTCLIB_CAINFOP_CPP__

CRITICAL_SECTION g_csDomainSidCache;
extern BOOL g_fInitDone;

//we only keep one copy of the localSystem's sid
PSID g_pLocalSid=NULL;


#define DOMAIN_SID_CACHE_INC 10

typedef struct _DOMAIN_SID_CACHE
{
    LPWSTR wszDomain;
    PSID   pSid;
} DOMAIN_SID_CACHE, *PDOMAIN_SID_CACHE;

PDOMAIN_SID_CACHE g_DomainSidCache = NULL;
DWORD             g_cDomainSidCache = 0;
DWORD             g_cMaxDomainSidCache = 0;


LPWSTR            g_pwszEnterpriseRoot = NULL;
DWORD myGetEnterpriseDnsName(OUT LPWSTR *pwszDomain);

HRESULT
CAGetAuthoritativeDomainDn(
    IN  LDAP*   LdapHandle,
    OUT CERTSTR *DomainDn,
    OUT CERTSTR *ConfigDn
    )
/*++

Routine Description:

    This routine simply queries the operational attributes for the
    domaindn and configdn.

    The strings returned by this routine must be freed by the caller
    using RtlFreeHeap() using the process heap.

Parameters:

    LdapHandle    : a valid handle to an ldap session

    DomainDn      : a pointer to a string to be allocated in this routine

    ConfigDn      : a pointer to a string to be allocated in this routine

Return Values:

    An error from the win32 error space.

    ERROR_SUCCESS and

    Other operation errors.

--*/
{
    HRESULT     hr=E_FAIL;

    BSTR        bstrDomainDN=NULL;
    BSTR        bstrConfigDN=NULL; 

    hr=myGetAuthoritativeDomainDn(LdapHandle, &bstrDomainDN, &bstrConfigDN);

    if(S_OK != hr)
        _JumpError(hr, error, "myGetAuthoritativeDomainDn");

    //convert BSTR to CERTSTR
    if(DomainDn)
    {
        (*DomainDn) = CertAllocString(bstrDomainDN);

        if(NULL == (*DomainDn))
        {
            hr=E_OUTOFMEMORY;
            _JumpError(hr, error, "CertAllocString");
        }
    }

    if(ConfigDn)
    {
        (*ConfigDn) = CertAllocString(bstrConfigDN);

        if(NULL == (*ConfigDn))
        {
            hr=E_OUTOFMEMORY;

            if(DomainDn)
            {
                if(*DomainDn)
                {
                    CertFreeString(*DomainDn);
                    *DomainDn=NULL;
                }
            }
            _JumpError(hr, error, "CertAllocString");
        }
    }

    hr=S_OK;

error:

    if(bstrDomainDN)
        SysFreeString(bstrDomainDN);

    if(bstrConfigDN)
        SysFreeString(bstrConfigDN);

    return hr;
}


DWORD
DNStoRFC1779Name(WCHAR *rfcDomain,
                 ULONG *rfcDomainLength,
                 LPCWSTR dnsDomain)
/*++

Routine Description:

    This routine takes the DNS-style name of a domain controller and
    contructs the corresponding RFC1779 style name, using the
    domainComponent prefix.

Parameters:

    rfcDomain        - this is the destination string
    rfcDomainLength  - this is the length in wchars of rfcDomain
    dnsDomain        - NULL-terminated dns name.

Return Values:

    ERROR_SUCCESS if succesful;
    ERROR_INSUFFICIENT_BUFFER if there is not enough space in the dst string -
    rfcDomainLength will set to number of characters needed.

--*/
{
    DWORD WinError = ERROR_SUCCESS;

    WCHAR *NextToken;
    ULONG length = 1;   // include the null character
    WCHAR Buffer[DNS_MAX_NAME_LENGTH+1];

    if (!rfcDomainLength || !dnsDomain) {
        return ERROR_INVALID_PARAMETER;
    }

    if (wcslen(dnsDomain) > DNS_MAX_NAME_LENGTH) {
        return ERROR_INVALID_PARAMETER;
    }

    RtlCopyMemory(Buffer, dnsDomain, (wcslen(dnsDomain)+1)*sizeof(WCHAR));

    if (rfcDomain && *rfcDomainLength > 0) {
        RtlZeroMemory(rfcDomain, *rfcDomainLength*sizeof(WCHAR));
    }

    //
    // Start contructing the string
    //
    NextToken = wcstok(Buffer, L".");

    if ( NextToken )
    {
        //
        // Append the intial DC=
        //
        length += 3;
        if ( length <= *rfcDomainLength && rfcDomain )
        {
            wcscpy(rfcDomain, L"DC=");
        }
    }

    while ( NextToken )
    {
        length += wcslen(NextToken);

        if (length <= *rfcDomainLength && rfcDomain)
        {
            wcscat(rfcDomain, NextToken);
        }

        NextToken = wcstok(NULL, L".");

        if ( NextToken )
        {
            length += 4;

            if (length <= *rfcDomainLength && rfcDomain)
            {
                wcscat(rfcDomain, L",DC=");
            }
        }
    }


    if ( length > *rfcDomainLength )
    {
        WinError = ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // Return how much space was needed
    //
    *rfcDomainLength = length;

    return WinError;

}


VOID
FreeSidCache()
{
    if (NULL != g_DomainSidCache)
    {
	DWORD i;

	for (i = 0; i < g_cDomainSidCache; i++)
	{
	    if (NULL != g_DomainSidCache[i].wszDomain)
	    {
		LocalFree(g_DomainSidCache[i].wszDomain);
	    }
	    if (NULL != g_DomainSidCache[i].pSid)
	    {
		LocalFree(g_DomainSidCache[i].pSid);
	    }
	}
	LocalFree(g_DomainSidCache);
	g_DomainSidCache = NULL;
    }
}


DWORD
myGetSidFromDomain(
    IN LPWSTR wszDomain,
    OUT PSID *ppDomainSid)
{
    NTSTATUS dwStatus;
    DWORD dwErr = ERROR_SUCCESS;
    LSA_HANDLE hPolicy = NULL;
    LSA_UNICODE_STRING uszServer = {0};
    LSA_OBJECT_ATTRIBUTES oa;
    SECURITY_QUALITY_OF_SERVICE sqos;
    LSA_UNICODE_STRING uszDCName = {0}, *puszDCName = NULL;
    PPOLICY_DNS_DOMAIN_INFO pDomainInfo = NULL;
    PSID pSidOut = NULL;
    PDOMAIN_CONTROLLER_INFO pDcInfo = NULL;
    LPWSTR  wszDomainControllerName = NULL;

    LPWSTR  pwszDomain = wszDomain;

    if (!g_fInitDone)
    {
	return(HRESULT_FROM_WIN32(ERROR_DLL_INIT_FAILED));
    }

    __try
    {
        EnterCriticalSection(&g_csDomainSidCache);
        if(pwszDomain == NULL)
        {
            dwErr = myGetEnterpriseDnsName(&pwszDomain);
            if(dwErr != ERROR_SUCCESS)
            {
		_LeaveError(dwErr, "myGetEnterpriseDnsName");
            }
        }

        if(g_DomainSidCache && g_cDomainSidCache > 0)
        {
            DWORD i;
            for(i=0; i < g_cDomainSidCache; i++)
            {
                if(lstrcmpi(g_DomainSidCache[i].wszDomain, pwszDomain) == 0)
                {
                    pSidOut = (PSID)LocalAlloc(LMEM_FIXED, GetLengthSid(g_DomainSidCache[i].pSid));
                    if(pSidOut == NULL)
                    {
                        dwErr = ERROR_OUTOFMEMORY;
			_LeaveError(dwErr, "LocalAlloc");
                    }

                    CopySid(GetLengthSid(g_DomainSidCache[i].pSid), pSidOut, g_DomainSidCache[i].pSid);

                    *ppDomainSid = pSidOut;
                    pSidOut = NULL;
		    __leave;
                }
            }
        }

        sqos.Length = sizeof(sqos);
        sqos.ImpersonationLevel = SecurityImpersonation;
        sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        sqos.EffectiveOnly = FALSE;

        InitializeObjectAttributes(&oa, NULL, 0, NULL, NULL);
        oa.SecurityQualityOfService = &sqos;

        dwErr = DsGetDcName(
			NULL,
			pwszDomain,
			NULL,
			NULL,
			DS_RETURN_DNS_NAME,
			&pDcInfo);
        if(dwErr != ERROR_SUCCESS)
        {
            _LeaveError(dwErr, "DsGetDcName");
        }
        if((pDcInfo == NULL) ||
           ((pDcInfo->Flags & DS_DNS_CONTROLLER_FLAG) == 0) ||
           (pDcInfo->DomainControllerName == NULL))
        {
            dwErr = ERROR_CANT_ACCESS_DOMAIN_INFO;
            _LeaveError(dwErr, "DsGetDcName");
        }


        wszDomainControllerName = pDcInfo->DomainControllerName;


        // skip past forward slashes (why are they there?)
        while(*wszDomainControllerName == L'\\')
        {
            wszDomainControllerName++;
        }

        if(!RtlCreateUnicodeString(&uszDCName, wszDomainControllerName))
        {
            dwErr = GetLastError();
            _LeaveError(dwErr, "RtlCreateUnicodeString");
        }
        puszDCName = &uszDCName;


        dwStatus = LsaOpenPolicy(puszDCName, &oa, POLICY_EXECUTE, &hPolicy);
        dwErr = LsaNtStatusToWinError(dwStatus);
        RtlFreeUnicodeString(&uszDCName);

        if(dwErr != ERROR_SUCCESS)
        {
            _LeaveError(dwErr, "LsaOpenPolicy");
        }
        dwStatus = LsaQueryInformationPolicy(hPolicy,
                                        PolicyDnsDomainInformation,
                                        (LPVOID *)&pDomainInfo);
        dwErr = LsaNtStatusToWinError(dwStatus);
        if(dwErr != ERROR_SUCCESS)
        {
            _LeaveError(dwErr, "LsaQueryInformationPolicy");
        }

        pSidOut = (PSID)LocalAlloc(LMEM_FIXED, GetLengthSid(pDomainInfo->Sid));
        if(pSidOut == NULL)
        {
            dwErr = ERROR_OUTOFMEMORY;
            _LeaveError(dwErr, "LocalAlloc");
        }

        CopySid(GetLengthSid(pDomainInfo->Sid), pSidOut, pDomainInfo->Sid);

        *ppDomainSid = pSidOut;
        pSidOut = NULL;



        // Add to the cache.

        if(g_cMaxDomainSidCache < g_cDomainSidCache+1)
        {
            // Grow the cache
            PDOMAIN_SID_CACHE pNewCache = NULL;
            DWORD             cNewCacheSize = g_cMaxDomainSidCache+DOMAIN_SID_CACHE_INC;

            pNewCache = (PDOMAIN_SID_CACHE)LocalAlloc(LMEM_FIXED, sizeof(DOMAIN_SID_CACHE)*cNewCacheSize);
            if(pNewCache == NULL)
            {
                _LeaveError(dwErr, "LocalAlloc");
            }

            ZeroMemory(pNewCache, sizeof(DOMAIN_SID_CACHE)*cNewCacheSize);
            if(g_DomainSidCache)
            {
                if(g_cDomainSidCache)
                {
                    CopyMemory(pNewCache, g_DomainSidCache, sizeof(DOMAIN_SID_CACHE)*g_cDomainSidCache);
                }
                LocalFree(g_DomainSidCache);
            }
            g_DomainSidCache = pNewCache;
            g_cMaxDomainSidCache = cNewCacheSize;
        }

        g_DomainSidCache[g_cDomainSidCache].pSid = (PSID)LocalAlloc(LMEM_FIXED, GetLengthSid(pDomainInfo->Sid));
        if(g_DomainSidCache[g_cDomainSidCache].pSid == NULL)
        {
            _LeaveError(dwErr, "LocalAlloc");
        }

        CopySid(GetLengthSid(pDomainInfo->Sid), g_DomainSidCache[g_cDomainSidCache].pSid, pDomainInfo->Sid);
        g_DomainSidCache[g_cDomainSidCache].wszDomain = (LPWSTR)LocalAlloc(LMEM_FIXED, sizeof(WCHAR)*(wcslen(pwszDomain)+1));
        if(g_DomainSidCache[g_cDomainSidCache].wszDomain == NULL)
        {
            LocalFree(g_DomainSidCache[g_cDomainSidCache].pSid);
            g_DomainSidCache[g_cDomainSidCache].pSid = NULL;
            _LeaveError(dwErr, "LocalAlloc");
        }
        wcscpy(g_DomainSidCache[g_cDomainSidCache].wszDomain, pwszDomain);
        g_cDomainSidCache++;
    }
    __except(dwErr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    LeaveCriticalSection(&g_csDomainSidCache);

    if (NULL != pwszDomain && wszDomain != pwszDomain)
    {
        LocalFree(pwszDomain);
    }
    if (NULL != pDcInfo)
    {
        NetApiBufferFree(pDcInfo);
    }
    if (NULL != pDomainInfo)
    {
        LsaFreeMemory(pDomainInfo);
    }
    if (NULL != hPolicy)
    {
        LsaClose(hPolicy);
    }
    return dwErr;
}


// CACleanup is called multiple times!

VOID
CACleanup()
{
    if (NULL != g_pwszEnterpriseRoot)
    {
	LocalFree(g_pwszEnterpriseRoot);
	g_pwszEnterpriseRoot = NULL;
    }
    if (NULL != g_pLocalSid)
    {
	FreeSid(g_pLocalSid);
	g_pLocalSid = NULL;
    }
    if (NULL != g_pwszEnterpriseRootOID)
    {
	LocalFree(g_pwszEnterpriseRootOID);
	g_pwszEnterpriseRootOID = NULL;
    }
    FreeSidCache();
}


DWORD
myGetEnterpriseDnsName(
    OUT WCHAR **ppwszDomain)
{
    HRESULT hr;
    LSA_HANDLE hPolicy = NULL;
    POLICY_DNS_DOMAIN_INFO *pDomainInfo = NULL;

    if (NULL == g_pwszEnterpriseRoot)
    {
	LSA_OBJECT_ATTRIBUTES oa;
	SECURITY_QUALITY_OF_SERVICE sqos;
	NTSTATUS dwStatus;

	sqos.Length = sizeof(sqos);
	sqos.ImpersonationLevel = SecurityImpersonation;
	sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
	sqos.EffectiveOnly = FALSE;

	InitializeObjectAttributes(&oa, NULL, 0, NULL, NULL);
	oa.SecurityQualityOfService = &sqos;

	dwStatus = LsaOpenPolicy(
			    NULL,
			    &oa,
			    POLICY_READ | POLICY_EXECUTE,
			    &hPolicy);
	hr = LsaNtStatusToWinError(dwStatus);
	_JumpIfError(hr, error, "LsaOpenPolicy");

	dwStatus = LsaQueryInformationPolicy(
				    hPolicy,
                                    PolicyDnsDomainInformation,
                                    (VOID **) &pDomainInfo);
	hr = LsaNtStatusToWinError(dwStatus);
	_JumpIfError(hr, error, "LsaNtStatusToWinError");

	if (0 >= pDomainInfo->DnsForestName.Length ||
	    NULL == pDomainInfo->DnsForestName.Buffer)
	{
	    hr = ERROR_CANT_ACCESS_DOMAIN_INFO;
	    _JumpError(hr, error, "DomainInfo");
	}

        hr = myDupString(
		    pDomainInfo->DnsForestName.Buffer,
		    &g_pwszEnterpriseRoot);
	_JumpIfError(hr, error, "myDupString");
    }
    hr = myDupString(g_pwszEnterpriseRoot, ppwszDomain);
    _JumpIfError(hr, error, "myDupString");

error:
    if (NULL != pDomainInfo)
    {
        LsaFreeMemory(pDomainInfo);
    }
    if (NULL != hPolicy)
    {
        LsaClose(hPolicy);
    }
    return(hr);
}


CCAProperty::CCAProperty(LPCWSTR wszName)
{
    m_awszValues = NULL;
    m_pNext = NULL;
    m_wszName = CertAllocString(wszName);
}


CCAProperty::~CCAProperty()
{
    _Cleanup();
}

HRESULT CCAProperty::_Cleanup()
{

    // NOTE: this should only be called via
    // DeleteChain

    if(m_wszName)
    {
        CertFreeString(m_wszName);
        m_wszName = NULL;
    }

    if(m_awszValues)
    {
        LocalFree(m_awszValues);
        m_awszValues = NULL;
    }


    m_pNext = NULL;
    return S_OK;

}


HRESULT CCAProperty::Find(LPCWSTR wszName, CCAProperty **ppCAProp)
{
    CCAProperty *pCurrent = this;

    if((wszName == NULL) || (ppCAProp == NULL))
    {
        return E_POINTER;
    }

    if(this == NULL)
    {
        return E_POINTER;
    }

    if((m_wszName != NULL) &&(lstrcmpi(wszName, m_wszName) == 0))
    {
        *ppCAProp = this;
        return S_OK;
    }

    if(m_pNext)
    {
        return m_pNext->Find(wszName, ppCAProp);
    }
    // Didn't find one
    *ppCAProp = NULL;
    return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
}


HRESULT CCAProperty::Append(CCAProperty **ppCAPropChain, CCAProperty *pNewProp)
{
    CCAProperty *pCurrent;

    if((ppCAPropChain == NULL) || (pNewProp == NULL))
    {
        return E_POINTER;
    }

    if(*ppCAPropChain == NULL)
    {
        *ppCAPropChain = pNewProp;
        return S_OK;
    }

    pCurrent = *ppCAPropChain;

    while(pCurrent->m_pNext != NULL)
    {
        pCurrent = pCurrent->m_pNext;
    }

    pCurrent->m_pNext = pNewProp;

    return S_OK;

}


HRESULT CCAProperty::GetValue(LPWSTR **pawszProperties)
{
    HRESULT hr;

    if(pawszProperties == NULL)
    {
        return E_POINTER;
    }
    *pawszProperties = m_awszValues;
    m_awszValues = NULL;
    hr = SetValue(*pawszProperties);
    if(hr != S_OK)
    {
        m_awszValues = *pawszProperties;
        *pawszProperties = NULL;
    }
    return hr;
}


HRESULT CCAProperty::SetValue(LPWSTR *awszProperties)
{
    DWORD cbStringTotal = 0;
    DWORD cStrings=1;
    WCHAR **pwszAttr;
    WCHAR *wszCurString;


    if(m_awszValues)
    {
        LocalFree(m_awszValues);
        m_awszValues = NULL;
    }
    if(NULL == awszProperties)
    {
        return S_OK;
    }

    for(pwszAttr = awszProperties; *pwszAttr != NULL; pwszAttr++)
    {
        cStrings += 1;
        cbStringTotal += (wcslen(*pwszAttr) + 1)*sizeof(WCHAR);
    }
    m_awszValues = (WCHAR **)LocalAlloc(LMEM_FIXED, cStrings*sizeof(WCHAR *) + cbStringTotal);

    if(m_awszValues == NULL)
    {
        return E_OUTOFMEMORY;
    }

    wszCurString = (WCHAR *)(m_awszValues + cStrings);

    cStrings = 0;

    for(pwszAttr = awszProperties; *pwszAttr != NULL; pwszAttr++)
    {
        m_awszValues[cStrings] = wszCurString;
        wcscpy(wszCurString, *pwszAttr);
        wszCurString += wcslen(wszCurString) + 1;
        cStrings += 1;
    }

    m_awszValues[cStrings] = NULL;

    return S_OK;
}


HRESULT CCAProperty::DeleteChain(CCAProperty **ppCAProp)
{
    if(ppCAProp == NULL)
    {
        return E_POINTER;
    }
    if(*ppCAProp == NULL)
    {
        return S_OK;
    }
    DeleteChain(&(*ppCAProp)->m_pNext);

    delete *ppCAProp;
    return S_OK;

}

HRESULT CCAProperty::LoadFromRegValue(HKEY hkReg, LPCWSTR wszValue)
{
    DWORD err;
    DWORD dwType;
    DWORD dwSize;
    DWORD cbStringTotal = 0;
    WCHAR **pwszAttr;
    WCHAR *wszCurString;
    CERTSTR  bstrRegValue;
    HRESULT hr = S_OK;
    WCHAR *wszValues = NULL;


    if(m_awszValues)
    {
        LocalFree(m_awszValues);
        m_awszValues = NULL;
    }

    if((hkReg == NULL ) || (wszValue == NULL))
    {
        return E_POINTER;
    }


    err = RegQueryValueEx(hkReg,
                    wszValue,
                    NULL,
                    &dwType,
                    NULL,
                    &dwSize);

    if(ERROR_SUCCESS != err)
    {
        hr = myHError(err);
        goto error;
    }

	if(sizeof(WCHAR) != dwSize)
	{
		switch(dwType)
		{
			case REG_SZ:
				m_awszValues = (WCHAR **)LocalAlloc(LMEM_FIXED, 2*sizeof(WCHAR *) + dwSize);
				if(m_awszValues == NULL)
				{
					hr = E_OUTOFMEMORY;
					goto error;
				}
				err = RegQueryValueEx(hkReg,
								wszValue,
								NULL,
								&dwType,
								(PBYTE)(m_awszValues+2),
								&dwSize);

				if(ERROR_SUCCESS != err)
				{
					hr = myHError(err);
					goto error;
				}
				m_awszValues[0] = (WCHAR *)(m_awszValues+2);
				m_awszValues[1] = NULL;

				break;

			case REG_MULTI_SZ:
				{
					WCHAR  *wszCur;
					DWORD cStrings = 1;

					wszValues = (WCHAR *)LocalAlloc(LMEM_FIXED, dwSize);
					if(wszValues == NULL)
					{
						hr = E_OUTOFMEMORY;
						goto error;
					}
					err = RegQueryValueEx(hkReg,
									wszValue,
									NULL,
									&dwType,
									(PBYTE)wszValues,
									&dwSize);

					if(ERROR_SUCCESS != err)
					{
						hr = myHError(err);
						goto error;
					}
					wszCur = wszValues;
					while(wcslen(wszCur) > 0)
					{
						cStrings++;
						wszCur += wcslen(wszCur)+1;
					}
					m_awszValues = (WCHAR **)LocalAlloc(LMEM_FIXED, cStrings*sizeof(WCHAR *) + dwSize);
					if(m_awszValues == NULL)
					{
						hr = E_OUTOFMEMORY;
						goto error;
					}

					CopyMemory((PBYTE)(m_awszValues + cStrings), wszValues, dwSize);
					wszCur = (WCHAR *)(m_awszValues + cStrings);
					cStrings = 0;
					while(wcslen(wszCur) > 0)
					{
						m_awszValues[cStrings] = wszCur;
						cStrings++;
						wszCur += wcslen(wszCur)+1;
					}
					m_awszValues[cStrings] = NULL;
					break;
				}
			default:
				hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
				goto error;

		}
	}

error:

    if(wszValues)
    {
        LocalFree(wszValues);
    }
    return hr;
}


HRESULT CCAProperty::UpdateToRegValue(HKEY hkReg, LPCWSTR wszValue)
{
    DWORD err;
    DWORD dwType;
    DWORD dwSize;
    DWORD cbStringTotal = 0;
    WCHAR **pwszAttr;
    WCHAR *wszCurString;


    CERTSTR bstrRegValue = NULL;
    HRESULT hr = S_OK;


    if((hkReg == NULL ) || (wszValue == NULL))
    {
        return E_POINTER;
    }


    if(m_awszValues == NULL)
    {
        bstrRegValue = CertAllocString(TEXT(""));
        if(bstrRegValue == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }
    }
    else
    {
        LPWSTR *pwszCur = m_awszValues;
        LPWSTR wszCopy = NULL;
        DWORD cValues = 0;

        while(*pwszCur)
        {
            cValues += wcslen(*pwszCur) + 1;
            pwszCur++;
        }
        cValues++;
        bstrRegValue = CertAllocStringLen(NULL, cValues);
        if(bstrRegValue == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }

        pwszCur = m_awszValues;
        wszCopy =  bstrRegValue;
        while(*pwszCur)
        {
            CopyMemory(wszCopy, *pwszCur, sizeof(WCHAR)*(wcslen(*pwszCur)+1));
            wszCopy += (wcslen(*pwszCur)+1);
            pwszCur++;
        }
        *wszCopy = NULL;
    }
    err = RegSetValueEx(hkReg,
                    wszValue,
                    NULL,
                    REG_MULTI_SZ,
                    (PBYTE)bstrRegValue,
                    CertStringByteLen(bstrRegValue));
    if(ERROR_SUCCESS != err )
    {
        hr = myHError(err);
        goto error;
    }

error:

    if(bstrRegValue)
    {
        CertFreeString(bstrRegValue);
    }

    return hr;
}

HRESULT CertFreeString(CERTSTR cstrString)
{
    WCHAR *pData = (WCHAR *)(((PBYTE)cstrString)-sizeof(UINT));
    if(cstrString == NULL)
    {
        return E_POINTER;
    }
    LocalFree(pData);
    return S_OK;
}

CERTSTR CertAllocString(LPCWSTR wszString)
{
    if(wszString == NULL)
    {
        return NULL;
    }
    return CertAllocStringLen(wszString, wcslen(wszString)+1);
}


CERTSTR CertAllocStringLen(LPCWSTR wszString, UINT len)
{
    CERTSTR szResult;
    szResult = CertAllocStringByteLen(NULL, len*sizeof(WCHAR));
    if (NULL != szResult && NULL != wszString)
    {
        CopyMemory(szResult, wszString, min(wcslen(wszString)+1, len)*sizeof(WCHAR));
    }

    return szResult;
}

CERTSTR CertAllocStringByteLen(LPCSTR szString, UINT len)
{
    PBYTE  pbResult;

    pbResult = (PBYTE)LocalAlloc(LMEM_FIXED, len + sizeof(UINT) + sizeof(WCHAR));
    if (NULL == pbResult)
        return NULL;

    *((UINT *)pbResult) = len;
    pbResult += sizeof(UINT);

    *((UNALIGNED WCHAR *)(pbResult+len)) = L'\0';
    if(szString)
    {
        CopyMemory(pbResult, szString, min(len, strlen(szString)+1));
    }

    return (CERTSTR)pbResult;
}

UINT    CertStringLen(CERTSTR cstrString)
{
    if(cstrString == NULL)
    {
        return 0;
    }
    return(*((UINT *)((PBYTE)cstrString - sizeof(UINT))))/sizeof(WCHAR);
}

UINT    CertStringByteLen(CERTSTR cstrString)
{
    if(cstrString == NULL)
    {
        return 0;
    }
    return(*((UINT *)((PBYTE)cstrString - sizeof(UINT))));
}





HRESULT CAAccessCheckp(HANDLE ClientToken, PSECURITY_DESCRIPTOR pSD)
{
    return CAAccessCheckpEx(ClientToken, pSD, CERTTYPE_ACCESS_CHECK_ENROLL);
}


HRESULT CAAccessCheckpEx(HANDLE ClientToken, PSECURITY_DESCRIPTOR pSD, DWORD dwOption)
{

    HRESULT hr = S_OK;
    HANDLE        hClientToken = NULL;
    HANDLE        hHandle = NULL;

    PRIVILEGE_SET ps;
    DWORD         dwPSSize = sizeof(ps);
    GENERIC_MAPPING AccessMapping;
    BOOL          fAccessAllowed = FALSE;
    DWORD         grantAccess;
    PTOKEN_USER    pUserInfo = NULL;
    DWORD         cbUserInfo = 0;
    SID_IDENTIFIER_AUTHORITY IDAuthorityNT      = SECURITY_NT_AUTHORITY;
    OBJECT_TYPE_LIST   aObjectTypeList[] = {
                                                {
                                                    ACCESS_OBJECT_GUID, // Level
                                                    0,                  // Sbz
                                                    const_cast<GUID *>(&GUID_ENROLL)
                                                }
                                            };
    DWORD              cObjectTypeList = sizeof(aObjectTypeList)/sizeof(aObjectTypeList[0]);


    OBJECT_TYPE_LIST   aAutoEnrollList[] = {
                                                {
                                                    ACCESS_OBJECT_GUID, // Level
                                                    0,                  // Sbz
                                                    const_cast<GUID *>(&GUID_AUTOENROLL)
                                                }
                                            };
    DWORD              cAutoEnrollList = sizeof(aAutoEnrollList)/sizeof(aAutoEnrollList[0]);


    if(pSD == NULL)
    {
        hr = E_ACCESSDENIED;
        goto error;
    }

    if(ClientToken == NULL)
    {
        hHandle = GetCurrentThread();
        if (NULL == hHandle)
        {
            hr = myHLastError();
        }
        else
        {

            if (!OpenThreadToken(hHandle,
                                 TOKEN_QUERY,
                                 TRUE,  // open as self
                                 &hClientToken))
            {
		hr = myHLastError();
                CloseHandle(hHandle);
                hHandle = NULL;
            }
        }
        if(hr != S_OK)
        {
            hHandle = GetCurrentProcess();
            if (NULL == hHandle)
            {
		hr = myHLastError();
            }
            else
            {
                HANDLE hProcessToken = NULL;
                hr = S_OK;


                if (!OpenProcessToken(hHandle,
                                     TOKEN_DUPLICATE,
                                     &hProcessToken))
                {
		    hr = myHLastError();
                    CloseHandle(hHandle);
                    hHandle = NULL;
                }
                else
                {
                    if(!DuplicateToken(hProcessToken,
                                   SecurityImpersonation,
                                   &hClientToken))
                    {
			hr = myHLastError();
                        CloseHandle(hHandle);
                        hHandle = NULL;
                    }
                    CloseHandle(hProcessToken);
                }
            }
        }
    }
    else
    {
        hClientToken = ClientToken;
    }


    // First, we check the special case.  If the ClientToken
    // primary SID is for Local System, then we get the
    // real domain relative sid for this machine

    GetTokenInformation(hClientToken, TokenUser, NULL, 0, &cbUserInfo);
    if(cbUserInfo == 0)
    {
	hr = myHLastError();
        goto error;
    }
    pUserInfo = (PTOKEN_USER)LocalAlloc(LMEM_FIXED, cbUserInfo);
    if(pUserInfo == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }
    if(!GetTokenInformation(hClientToken, TokenUser, pUserInfo, cbUserInfo, &cbUserInfo))
    {
	hr = myHLastError();
        goto error;
    }

    // Check it see if we're local-system
    if(0 == (CERTTYPE_ACCESS_CHECK_NO_MAPPING & dwOption))
    { 
    if(NULL == g_pLocalSid)
    {
        if(!AllocateAndInitializeSid(&IDAuthorityNT, 1, SECURITY_LOCAL_SYSTEM_RID, 0,0,0,0,0,0,0, &g_pLocalSid))
        {
	        hr = myHLastError();
            g_pLocalSid=NULL;
            goto error;
        }
    }

    if(EqualSid(g_pLocalSid, pUserInfo->User.Sid))
    {
        // This is local system.
        // Derive the real token

        if(hClientToken != ClientToken)
        {
            CloseHandle(hClientToken);
        }
        hClientToken = NULL;

        if(!myNetLogonUser(NULL, NULL, NULL, &hClientToken))
        {
	    hr = myHLastError();
            goto error;
        }
    }
    }

    if(CERTTYPE_ACCESS_CHECK_ENROLL & dwOption)
    {
        if(!AccessCheckByType(
		  pSD,                      // security descriptor
		  NULL,                     // SID of object being checked
		  hClientToken,             // handle to client access token
		  ACTRL_DS_CONTROL_ACCESS,  // requested access rights 
		  aObjectTypeList,  // array of object types
		  cObjectTypeList,  // number of object type elements
		  &AccessMapping,   // map generic to specific rights
		  &ps,              // receives privileges used
		  &dwPSSize,        // size of privilege-set buffer
		  &grantAccess,     // retrieves mask of granted rights
		  &fAccessAllowed)) // retrieves results of access check);
{
            hr = myHLastError();
	    _JumpIfError(hr, error, "AccessCheckByType");
        }
    }
    else
    {
        if(0 == (CERTTYPE_ACCESS_CHECK_AUTO_ENROLL & dwOption))
        {
            hr=E_INVALIDARG;
	        goto error;
        }

        if(!AccessCheckByType(
		  pSD,                      // security descriptor
		  NULL,                     // SID of object being checked
		  hClientToken,             // handle to client access token
		  ACTRL_DS_CONTROL_ACCESS,  // requested access rights 
		  aAutoEnrollList,  // array of object types
		  cAutoEnrollList,  // number of object type elements
		  &AccessMapping,   // map generic to specific rights
		  &ps,              // receives privileges used
		  &dwPSSize,        // size of privilege-set buffer
		  &grantAccess,     // retrieves mask of granted rights
		  &fAccessAllowed)) // retrieves results of access check);
{
            hr = myHLastError();
	    _JumpIfError(hr, error, "AccessCheckByType");
        }
    }

    if(fAccessAllowed)
    {
        hr = S_OK;
    }
    else
    {
	    hr = myHLastError();
    }


error:
    if(pUserInfo)
    {
        LocalFree(pUserInfo);
    }
    if(hHandle)
    {
        CloseHandle(hHandle);
    }
    if(hClientToken != ClientToken)
    {
        if(hClientToken)
        {
            CloseHandle(hClientToken);
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certclib\certdec.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certdec.cpp
//
// Contents:    Cert Server main & debug support
//
// History:     25-Jul-96       vich created
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <tchar.h>

#if DBG_CERTSRV
# ifdef UNICODE
#  define szFMTTSTR		"ws"
# else
#  define szFMTTSTR		"hs"
# endif
#endif

// Read and decode uuencoded file into allocated memory.

HRESULT
DecodeFileW(
    IN TCHAR const *pszfn,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut,
    IN DWORD Flags)
{
    HANDLE hFile;
    HRESULT hr;
    CHAR *pchFile = NULL;
    BYTE *pbOut = NULL;
    DWORD cchFile;
    DWORD cbRead;
    DWORD cbOut;

    hFile = CreateFile(
		    pszfn,
		    GENERIC_READ,
		    FILE_SHARE_READ,
		    NULL,
		    OPEN_EXISTING,
		    0,
		    NULL);
    if (INVALID_HANDLE_VALUE == hFile)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CreateFile");
    }

    cchFile = GetFileSize(hFile, NULL);
    if ((DWORD) -1 == cchFile)
    {
	hr = myHLastError();
	_JumpError(hr, error, "GetFileSize");
    }

    pchFile = (CHAR *) LocalAlloc(LMEM_FIXED, cchFile);
    if (NULL == pchFile)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    if (!ReadFile(hFile, pchFile, cchFile, &cbRead, NULL))
    {
	hr = myHLastError();
	_JumpError(hr, error, "ReadFile");
    }

    CSASSERT(cbRead <= cchFile);
    if (cbRead != cchFile)
    {
	hr = HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);
        DBGPRINT((
	    DBG_SS_ERROR,
	    "ReadFile read %u bytes, requested %u\n",
	    cbRead,
	    cchFile));
	_JumpError(hr, error, "ReadFile(cbRead)");
    }

    if (CRYPT_STRING_BINARY == Flags)
    {
	pbOut = (BYTE *) pchFile;
	cbOut = cchFile;
	pchFile = NULL;
    }
    else
    {
	// Decode file contents.

	hr = myCryptStringToBinaryA(
                        pchFile,
                        cchFile,
                        Flags,
                        &pbOut,
                        &cbOut,
                        NULL,
                        NULL);
	_JumpIfError2(
		    hr,
		    error,
		    "myCryptStringToBinaryA",
		    HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
    }
    *pcbOut = cbOut;
    *ppbOut = pbOut;
    pbOut = NULL;
    hr = S_OK;

error:
    if (INVALID_HANDLE_VALUE != hFile)
    {
        CloseHandle(hFile);
    }
    if (NULL != pchFile)
    {
	LocalFree(pchFile);
    }
    if (S_OK != hr)
    {
#if DBG_CERTSRV
	if (HRESULT_FROM_WIN32(ERROR_INVALID_DATA) != hr)
	{
	    WCHAR awchr[cwcHRESULTSTRING];

	    DBGPRINT((
		DBG_SS_ERROR,
		"DecodeFileW(%" szFMTTSTR "): error = %ws\n",
		pszfn,
		myHResultToString(awchr, hr)));
	}
#endif
	if (NULL != pbOut)
	{
	    LocalFree(pbOut);
	}
    }
    return(hr);
}


HRESULT
EncodeToFileW(
    IN TCHAR const *pszfn,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD Flags)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HRESULT hr;
    DWORD cbWritten;
    DWORD cchFile;
    CHAR *pchFile = NULL;
    BOOL fForceOverWrite;

    fForceOverWrite = 0 != (DECF_FORCEOVERWRITE & Flags);
    Flags &= ~DECF_FORCEOVERWRITE;

    if (CRYPT_STRING_BINARY == Flags)
    {
	pchFile = (CHAR *) pbIn;
	cchFile = cbIn;
    }
    else
    {
	hr = myCryptBinaryToStringA(pbIn, cbIn, Flags, &pchFile);
	_JumpIfError(hr, error, "myCryptBinaryToStringA");

	cchFile = strlen(pchFile);
    }

    // Write encoded certificate to file

    hFile = CreateFile(
		    pszfn,
		    GENERIC_WRITE,
		    0,
		    NULL,
		    CREATE_NEW,
		    0,
		    NULL);

    if (INVALID_HANDLE_VALUE == hFile)
    {
	hr = myHLastError();
	if (fForceOverWrite && HRESULT_FROM_WIN32(ERROR_FILE_EXISTS) == hr)
	{
	    hFile = CreateFile(
			    pszfn,
			    GENERIC_WRITE,
			    0,
			    NULL,
			    CREATE_ALWAYS,
			    0,
			    NULL);
	}
	if (INVALID_HANDLE_VALUE == hFile)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CreateFile");
	}
    }

    if (!WriteFile(hFile, pchFile, cchFile, &cbWritten, NULL))
    {
	hr = myHLastError();
	_JumpError(hr, error, "WriteFile");
    }
    if (cbWritten != cchFile)
    {
	hr = HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);
        DBGPRINT((
	    DBG_SS_ERROR,
	    "WriteFile wrote %u bytes, requested %u\n",
	    cbWritten,
	    cchFile));
	_JumpError(hr, error, "WriteFile(cbWritten)");
    }
    hr = S_OK;

error:
    if (INVALID_HANDLE_VALUE != hFile)
    {
        CloseHandle(hFile);
    }
    if (CRYPT_STRING_BINARY != Flags && NULL != pchFile)
    {
	LocalFree(pchFile);
    }
#if DBG_CERTSRV
    if (S_OK != hr)
    {
	WCHAR awchr[cwcHRESULTSTRING];

        DBGPRINT((
	    DBG_SS_ERROR,
	    "EncodeToFileW(%" szFMTTSTR "): error = %ws\n",
	    pszfn,
	    myHResultToString(awchr, hr)));
    }
#endif
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certclib\certtype.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certtype.cpp
//
// Contents:    CCertTypeInfo implemenation
//
// History:     16-Dec-97       petesk created
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include "certtype.h"
#include "oidmgr.h"

#include <cainfop.h>
#include <certca.h>
#include <polreg.h>
#include <sddl.h>
#include <userenv.h>
#include <lm.h>

#include <certmgrd.h>
#include <dsgetdc.h>
#include <ntldap.h>
#include "certacl.h"
#include "csldap.h"

#define __dwFILE__	__dwFILE_CERTCLIB_CERTTYPE_CPP__

#define MAX_UUID_STRING_LEN 40
#define MAX_DS_PATH_STRING_LEN 256

extern HINSTANCE g_hInstance;

// the attribute list that we retrieve from the DS
WCHAR *g_awszCTAttrs[] = {
                        CERTTYPE_PROP_CN,
                        CERTTYPE_PROP_DN,
                        CERTTYPE_PROP_FRIENDLY_NAME,
                        CERTTYPE_PROP_EXTENDED_KEY_USAGE,
                        CERTTYPE_PROP_CSP_LIST,
                        CERTTYPE_PROP_CRITICAL_EXTENSIONS,
                        CERTTYPE_PROP_FLAGS,
                        CERTTYPE_PROP_DEFAULT_KEYSPEC,
                        CERTTYPE_SECURITY_DESCRIPTOR_NAME,
                        CERTTYPE_PROP_KU,
                        CERTTYPE_PROP_MAX_DEPTH,
                        CERTTYPE_PROP_EXPIRATION,
                        CERTTYPE_PROP_OVERLAP,
                        CERTTYPE_PROP_REVISION,
                        CERTTYPE_PROP_MINOR_REVISION,        //starting of the V2 templates
                        CERTTYPE_PROP_RA_SIGNATURE,		
                        CERTTYPE_RPOP_ENROLLMENT_FLAG,	
                        CERTTYPE_PROP_PRIVATE_KEY_FLAG,	
                        CERTTYPE_PROP_NAME_FLAG,			
                        CERTTYPE_PROP_MIN_KEY_SIZE,		
                        CERTTYPE_PROP_SCHEMA_VERSION,	
                        CERTTYPE_PROP_OID,				
                        CERTTYPE_PROP_SUPERSEDE,			
                        CERTTYPE_PROP_RA_POLICY,			
                        CERTTYPE_PROP_POLICY,
                        CERTTYPE_PROP_RA_APPLICATION_POLICY,
                        CERTTYPE_PROP_APPLICATION_POLICY,
                        NULL};


// the attributes that can be mapped directly to the property
WCHAR *g_awszCTNamedProps[] = {
                        CERTTYPE_PROP_CN,
                        CERTTYPE_PROP_DN,
                        CERTTYPE_PROP_FRIENDLY_NAME,
                        CERTTYPE_PROP_EXTENDED_KEY_USAGE,
                        CERTTYPE_PROP_CRITICAL_EXTENSIONS,
                        NULL};

static WCHAR * s_wszLocation = L"CN=Certificate Templates,CN=Public Key Services,CN=Services,";

//
// This struct is used for _UpdateToDs.
//
typedef struct _CERT_TYPE_PROP_MOD
{
	LDAPMod	modData;	
	WCHAR	wszData[16];	//used by DWORD properties
	WCHAR	*awszData[2];
	DWORD	dwData;
} CERT_TYPE_PROP_MOD;

typedef struct _CERT_TYPE_PROP_INFO
{
	LPWSTR					pwszProperty;
	BOOL					fStringProperty;
} CERT_TYPE_PROP_INFO;

//v2 template attributes
CERT_TYPE_PROP_INFO	g_CTV2Properties[]={
    CERTTYPE_PROP_MINOR_REVISION,           FALSE,
	CERTTYPE_PROP_RA_SIGNATURE,				FALSE,		
	CERTTYPE_RPOP_ENROLLMENT_FLAG,			FALSE,	
	CERTTYPE_PROP_PRIVATE_KEY_FLAG,			FALSE,	
	CERTTYPE_PROP_NAME_FLAG,				FALSE,			
	CERTTYPE_PROP_MIN_KEY_SIZE,				FALSE,		
	CERTTYPE_PROP_SCHEMA_VERSION,			FALSE,	
	CERTTYPE_PROP_SUPERSEDE,				TRUE,			
	CERTTYPE_PROP_POLICY,					TRUE,
	CERTTYPE_PROP_OID,						TRUE,
	CERTTYPE_PROP_RA_POLICY,				TRUE,
    CERTTYPE_PROP_RA_APPLICATION_POLICY,    TRUE,
    CERTTYPE_PROP_APPLICATION_POLICY,       TRUE,
};	

DWORD	g_CTV2PropertiesCount=sizeof(g_CTV2Properties)/sizeof(g_CTV2Properties[0]);

#define	V2_PROPERTY_COUNT					13


//the following structure are for cert tempalte flag mappings
typedef struct _CERT_TYPE_FLAG_MAP
{
    DWORD   dwOldFlag;
    DWORD   dwNewFlag;
}CERT_TYPE_FLAG_MAP;


//enrollment flags
CERT_TYPE_FLAG_MAP  g_rgdwEnrollFlagMap[]={
    CT_FLAG_PUBLISH_TO_DS,                  CT_FLAG_PUBLISH_TO_DS,
    CT_FLAG_AUTO_ENROLLMENT,                CT_FLAG_AUTO_ENROLLMENT,
};


DWORD   g_cEnrollFlagMap=sizeof(g_rgdwEnrollFlagMap)/sizeof(g_rgdwEnrollFlagMap[0]);

//subject name flags
CERT_TYPE_FLAG_MAP  g_rgdwSubjectFlagMap[]={
    CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT,      CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT,
    CT_FLAG_ADD_EMAIL,                      CT_FLAG_SUBJECT_REQUIRE_EMAIL | CT_FLAG_SUBJECT_ALT_REQUIRE_EMAIL,
    CT_FLAG_ADD_OBJ_GUID,                   CT_FLAG_SUBJECT_ALT_REQUIRE_DIRECTORY_GUID,

};


DWORD   g_cSubjectFlagMap=sizeof(g_rgdwSubjectFlagMap)/sizeof(g_rgdwSubjectFlagMap[0]);

//private key flags
CERT_TYPE_FLAG_MAP  g_rgdwPrivateKeyFlagMap[]={
    CT_FLAG_EXPORTABLE_KEY,                 CT_FLAG_EXPORTABLE_KEY,
};


DWORD   g_cPrivateKeyFlagMap=sizeof(g_rgdwPrivateKeyFlagMap)/sizeof(g_rgdwPrivateKeyFlagMap[0]);


//********************************************************************************
//
//      Default OIDs to install
//
//********************************************************************************
CERT_DEFAULT_OID_INFO g_rgDefaultOIDInfo[]={

        L"1.400",       L"Low Assurance",       CERT_OID_TYPE_ISSUER_POLICY,
        L"1.401",       L"Medium Assurance",    CERT_OID_TYPE_ISSUER_POLICY,
        L"1.402",       L"High Assurance",      CERT_OID_TYPE_ISSUER_POLICY,
};

DWORD   g_cDefaultOIDInfo=sizeof(g_rgDefaultOIDInfo)/sizeof(g_rgDefaultOIDInfo[0]);



//********************************************************************************
//
//      The certificate template description search table
//
//********************************************************************************
CERT_TYPE_DESCRIPTION	g_CTDescriptions[]={
    {
        0,
        CT_FLAG_PUBLISH_TO_KRA_CONTAINER,
        0,
        IDS_KRA_DESCRIPTION,
    },
    {
        CT_FLAG_IS_CROSS_CA,
        0,
        0,
        IDS_CROSS_CA_DESCRIPTION,
    },
    {
        CT_FLAG_IS_CA | CT_FLAG_MACHINE_TYPE,
        0,
        0,
        IDS_CA_DESCRIPTION,
    },
    {
        CT_FLAG_MACHINE_TYPE,
        0,
        CT_FLAG_SUBJECT_ALT_REQUIRE_DIRECTORY_GUID,
        IDS_EMAIL_REPLICATION_DESCRIPTION,
    },
    {
        CT_FLAG_MACHINE_TYPE,
        0,
        0,
        IDS_MACHINE_DESCRIPTION,
    },
    {
        0,
        0,
        0,
        IDS_END_USER_DESCRIPTION,
    }
};

DWORD	g_CTDescriptionCount=sizeof(g_CTDescriptions)/sizeof(g_CTDescriptions[0]);



//+--------------------------------------------------------------------------
// CCertTypeInfo::~CCertTypeInfo -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertTypeInfo::~CCertTypeInfo()
{
    _Cleanup();
}


//+--------------------------------------------------------------------------
// CCertTypeInfo::_Cleanup -- free memory
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::_Cleanup()
{

    CCertTypeInfo *pNext = m_pNext;

    // Remove this one from the chain.
    if(m_pLast)
    {
        m_pLast->m_pNext = m_pNext;
    }
    if(m_pNext)
    {
        m_pNext->m_pLast = m_pLast;
    }
    m_pNext = NULL;
    m_pLast = NULL;
    if(m_KeyUsage.pbData)
    {
        LocalFree(m_KeyUsage.pbData);
        m_KeyUsage.pbData = NULL;
        m_KeyUsage.cbData = 0;
    }


    CCAProperty::DeleteChain(&m_pProperties);

    if(m_bstrType)
    {
        CertFreeString(m_bstrType);
        m_bstrType = NULL;
    }

    if(m_pSD)
    {
        LocalFree(m_pSD);
        m_pSD = NULL;
    }

    if(pNext)
    {
        // Release the next one
        pNext->Release();
    }

    return(S_OK);
}


//+--------------------------------------------------------------------------
// CCertTypeInfo::AddRef -- add reference
//
//
//+--------------------------------------------------------------------------

DWORD CCertTypeInfo::AddRef()
{

    return(InterlockedIncrement(&m_cRef));
}


//+--------------------------------------------------------------------------
// CCertTypeInfo::_Append --
//
//
//+--------------------------------------------------------------------------

CCertTypeInfo *
CCertTypeInfo::_Append(CCertTypeInfo **ppCertTypeInfo, CCertTypeInfo *pInfo)
{
    CCertTypeInfo ** ppCurrent = ppCertTypeInfo;


    while(*ppCurrent)
    {
        ppCurrent = &(*ppCurrent)->m_pNext;
    }
    *ppCurrent = pInfo;

    return *ppCurrent;
}

//+--------------------------------------------------------------------------
// CCertTypeInfo::_FilterByFlags --
//
//
//+--------------------------------------------------------------------------

CCertTypeInfo *
CCertTypeInfo::_FilterByFlags(CCertTypeInfo **ppCertTypeInfo, DWORD dwFlags)
{

    CCertTypeInfo * pCTCurrent = NULL,
                  * pCTNext = NULL;

    if(ppCertTypeInfo == NULL)
    {
        return NULL;
    }

    pCTCurrent = *ppCertTypeInfo;
    *ppCertTypeInfo = NULL;

    while(pCTCurrent != NULL)
    {
        // Ownership of the pCTCurrent Reference is transfered
        // ot pCTNext here.
        pCTNext = pCTCurrent->m_pNext;
        pCTCurrent->m_pNext = NULL;
        pCTCurrent->m_pLast = NULL;

        if(((dwFlags & CT_ENUM_MACHINE_TYPES) != 0) &&
            ((pCTCurrent->m_dwFlags & CT_FLAG_MACHINE_TYPE)!= 0))
        {
            _Append(ppCertTypeInfo, pCTCurrent);
            pCTCurrent = NULL;
        }
        else if (((dwFlags & CT_ENUM_USER_TYPES) != 0) &&
                 ((pCTCurrent->m_dwFlags & CT_FLAG_MACHINE_TYPE) == 0))
        {
            _Append(ppCertTypeInfo, pCTCurrent);
            pCTCurrent = NULL;
        }

        if(pCTCurrent)
        {
            pCTCurrent->Release();
        }
        pCTCurrent = pCTNext;
    }

    return *ppCertTypeInfo;
}

//+--------------------------------------------------------------------------
// CCertTypeInfo::Release -- release reference
//
//
//+--------------------------------------------------------------------------

DWORD CCertTypeInfo::Release()
{
    DWORD cRef;
    if(0 == (cRef = InterlockedDecrement(&m_cRef)))
    {
        delete this;
    }
    return cRef;
}


//+--------------------------------------------------------------------------
// CCertTypeInfo::_LoadFromRegBase -- Load a certificate type object from the
// registry.
//
//
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::_LoadFromRegBase(LPCWSTR wszType, HKEY hCertTypes)
{
    CCAProperty     *pProp = NULL;
    HRESULT         hr = S_OK;
    DWORD           err;
    DWORD           iIndex;

    DWORD           dwType=0;
    DWORD           dwSize=0;
    DWORD           dwValue=0;
    HKEY            hkCertType = NULL;

    err = RegOpenKeyEx(hCertTypes,
                       wszType,
                       0,
                       KEY_ENUMERATE_SUB_KEYS |
                       KEY_EXECUTE |
                       KEY_QUERY_VALUE,
                       &hkCertType);

    if(ERROR_SUCCESS != err)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }

    pProp = new CCAProperty(CERTTYPE_PROP_FRIENDLY_NAME);
    if(pProp == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    hr = pProp->LoadFromRegValue(hkCertType, wszDISPNAME);
    if(hr != S_OK)
    {
        goto error;
    }

    hr = CCAProperty::Append(&m_pProperties, pProp);
    if(hr != S_OK)
    {
        goto error;
    }
    pProp = new CCAProperty(CERTTYPE_PROP_CSP_LIST);
    if(pProp == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    hr = pProp->LoadFromRegValue(hkCertType, wszCSPLIST);
    if(hr != S_OK)
    {
        goto error;
    }

    hr = CCAProperty::Append(&m_pProperties, pProp);
    if(hr != S_OK)
    {
        goto error;
    }

    pProp = new CCAProperty(CERTTYPE_PROP_EXTENDED_KEY_USAGE);
    if(pProp == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    hr = pProp->LoadFromRegValue(hkCertType, wszEXTKEYUSAGE);
    if(hr != S_OK)
    {
        goto error;
    }

    hr = CCAProperty::Append(&m_pProperties, pProp);
    if(hr != S_OK)
    {
        goto error;
    }
    pProp = new CCAProperty(CERTTYPE_PROP_CRITICAL_EXTENSIONS);
    if(pProp == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    hr = pProp->LoadFromRegValue(hkCertType, wszCRITICALEXTENSIONS);
    if(hr != S_OK)
    {
        goto error;
    }

    hr = CCAProperty::Append(&m_pProperties, pProp);
    if(hr != S_OK)
    {
        goto error;
    }

    pProp = NULL;

    err = RegQueryValueEx(hkCertType,
                    wszKEYUSAGE,
                    NULL,
                    &dwType,
                    NULL,
                    &dwSize);

    if(ERROR_SUCCESS != err)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }
    if(dwType != REG_BINARY)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto error;
    }

    m_KeyUsage.pbData = (PBYTE)LocalAlloc(LMEM_FIXED, dwSize);
    if(m_KeyUsage.pbData == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }
    err = RegQueryValueEx(hkCertType,
                    wszKEYUSAGE,
                    NULL,
                    &dwType,
                    m_KeyUsage.pbData,
                    &dwSize);

    if(ERROR_SUCCESS != err)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }
    if(dwType != REG_BINARY)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto error;
    }

    m_KeyUsage.cbData = dwSize;
    m_KeyUsage.cUnusedBits = 0;


    dwSize = sizeof(DWORD);
    err = RegQueryValueEx(hkCertType,
                    wszCTFLAGS,
                    NULL,
                    &dwType,
                    (PBYTE)&m_dwFlags,
                    &dwSize);

    if(ERROR_SUCCESS != err)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }
    if(dwType != REG_DWORD)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto error;
    }
    dwSize = sizeof(DWORD);
    err = RegQueryValueEx(hkCertType,
                    wszCTREVISION,
                    NULL,
                    &dwType,
                    (PBYTE)&m_Revision,
                    &dwSize);

    if(err == ERROR_FILE_NOT_FOUND)
    {
        m_Revision = 0;
    }
    else
    {
        if(ERROR_SUCCESS != err)
        {
            hr = HRESULT_FROM_WIN32(err);
            goto error;
        }
        if(dwType != REG_DWORD)
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            goto error;
        }
    }

    dwSize = sizeof(DWORD);
    err = RegQueryValueEx(hkCertType,
                    wszCTKEYSPEC,
                    NULL,
                    &dwType,
                    (PBYTE)&m_dwKeySpec,
                    &dwSize);

    if(ERROR_SUCCESS != err)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }
    if(dwType != REG_DWORD)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto error;
    }


        // Get Depth
    dwSize = sizeof(DWORD);
    err = RegQueryValueEx(hkCertType,
                    wszBASICCONSTLEN,
                    NULL,
                    &dwType,
                    (PBYTE)&m_BasicConstraints.dwPathLenConstraint,
                    &dwSize);

    if(ERROR_SUCCESS != err)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }

    m_BasicConstraints.fPathLenConstraint =
        (m_BasicConstraints.dwPathLenConstraint != -1);


    if(dwType != REG_DWORD)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto error;
    }

    dwSize = sizeof(FILETIME);
    err = RegQueryValueEx(hkCertType,
                    wszEXPIRATION,
                    NULL,
                    &dwType,
                    (PBYTE)&m_ftExpiration,
                    &dwSize);

    if(ERROR_SUCCESS != err)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }
    if(dwType != REG_BINARY)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto error;
    }

    dwSize = sizeof(FILETIME);
    err = RegQueryValueEx(hkCertType,
                    wszOVERLAP,
                    NULL,
                    &dwType,
                    (PBYTE)&m_ftOverlap,
                    &dwSize);

    if(ERROR_SUCCESS != err)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }
    if(dwType != REG_BINARY)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto error;
    }

    err = RegQueryValueEx(hkCertType,
                    wszSECURITY,
                    NULL,
                    &dwType,
                    NULL,
                    &dwSize);

    if((err == ERROR_SUCCESS) && (dwSize > 0))
    {

        if(dwType != REG_BINARY)
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            goto error;
        }

        m_pSD = LocalAlloc(LMEM_FIXED, dwSize);
        if(m_pSD == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }
        err = RegQueryValueEx(hkCertType,
                        wszSECURITY,
                        NULL,
                        &dwType,
                        (PBYTE)m_pSD,
                        &dwSize);

        if(err != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(err);
            goto error;
        }

        if(!IsValidSecurityDescriptor(m_pSD))
        {
            LocalFree(m_pSD);
            m_pSD = NULL;
        }
    }

    m_fNew = FALSE;

    //we now retrieve the V2 template properties if there exits V2 properties
    dwSize = sizeof(DWORD);
    if(ERROR_SUCCESS == RegQueryValueEx(hkCertType, CERTTYPE_PROP_SCHEMA_VERSION, NULL,
                        &dwType, (PBYTE)&dwValue, &dwSize))
    {

        pProp=NULL;
        dwType=0;
        dwSize=0;
        dwValue=0;
        hr=S_OK;

        for(iIndex=0; iIndex < g_CTV2PropertiesCount; iIndex++)
        {
            if(g_CTV2Properties[iIndex].fStringProperty)
            {
                pProp = new CCAProperty(g_CTV2Properties[iIndex].pwszProperty);
                if(pProp == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto error;
                }

                hr = pProp->LoadFromRegValue(hkCertType, g_CTV2Properties[iIndex].pwszProperty);
                if(hr != S_OK)
                {
                    goto error;
                }

                hr = CCAProperty::Append(&m_pProperties, pProp);
                if(hr != S_OK)
                {
                    goto error;
                }

                pProp=NULL;
            }
            else
            {
                //we are dealing with DWORD
                dwSize = sizeof(DWORD);
                err = RegQueryValueEx(hkCertType,
                                g_CTV2Properties[iIndex].pwszProperty,
                                NULL,
                                &dwType,
                                (PBYTE)&dwValue,
                                &dwSize);

                if(ERROR_SUCCESS != err)
                {
                    hr = HRESULT_FROM_WIN32(err);
                    goto error;
                }

                if(dwType != REG_DWORD)
                {
                    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                    goto error;
                }

                 //assign dwValue to the corresponding data members
			    if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_MINOR_REVISION)==0)
				    m_dwMinorRevision = dwValue;
			    else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_RA_SIGNATURE)==0)
				    m_dwRASignature = dwValue;
			    else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_RPOP_ENROLLMENT_FLAG)==0)
				    m_dwEnrollmentFlags = dwValue;
			    else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_PRIVATE_KEY_FLAG)==0)
				    m_dwPrivateKeyFlags = dwValue;
			    else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_NAME_FLAG)==0)
				    m_dwCertificateNameFlags = dwValue;
			    else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_MIN_KEY_SIZE)==0)
				    m_dwMinimalKeySize = dwValue;
			    else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_SCHEMA_VERSION)==0)
				    m_dwSchemaVersion = dwValue;
			    else
			    {
				    hr=E_UNEXPECTED;
				    goto error;
			    }

                dwType=0;
                dwValue=0;
            }
        }
    }

    hr=S_OK;

error:

    if(pProp)
    {
        CCAProperty::DeleteChain(&pProp);
    }

    if(hkCertType)
    {
        RegCloseKey(hkCertType);
    }

    return hr;
}



//+--------------------------------------------------------------------------
// CCertTypeInfo::_LoadCachedCTFromReg -- Load a certificate type object from the
// Registry based DS cache.
//
//
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::_LoadCachedCTFromReg(LPCWSTR wszType, HKEY hRoot)
{
    HRESULT      hr = S_OK;
    DWORD        err;

    HKEY         hkCertTypes = NULL;
    WCHAR        *awszName[2] ;



    err = RegOpenKeyEx(hRoot,
                       wszCERTTYPECACHE,
                       0,
                       KEY_ENUMERATE_SUB_KEYS |
                       KEY_EXECUTE |
                       KEY_QUERY_VALUE,
                       &hkCertTypes);

    if(ERROR_SUCCESS != err)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }


	hr = _LoadFromRegBase(wszType, hkCertTypes);

	if(hr != S_OK)
	{
		goto error;
	}

    //
    // Derive the CN
    //
    //


    m_bstrType = CertAllocString(wszType);

    awszName[0] = (LPWSTR)m_bstrType;
    awszName[1] = NULL;
    SetProperty(CERTTYPE_PROP_CN, awszName);


    awszName[0] = (LPWSTR)wszType;
    awszName[1] = NULL;
    SetProperty(CERTTYPE_PROP_DN, awszName);

    hr=S_OK;


error:

    if(hkCertTypes)
    {
        RegCloseKey(hkCertTypes);
    }

    return hr;
}


//+--------------------------------------------------------------------------
// CCertTypeInfo::_SetWszzProperty --
//
//
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::_SetWszzProperty(
    IN WCHAR const *pwszPropertyName,
    OPTIONAL IN WCHAR const *pwszzPropertyValue)
{
    HRESULT hr;
    WCHAR *rgpwsz[MAX_DEFAULT_STRING_COUNT];
    DWORD iIndex = 0;

    if (NULL != pwszzPropertyValue)
    {
        for ( ;
	     L'\0' != *pwszzPropertyValue;
	     pwszzPropertyValue += wcslen(pwszzPropertyValue) + 1)
        {
            rgpwsz[iIndex++] = const_cast<WCHAR *>(pwszzPropertyValue);
	    if (iIndex >= ARRAYSIZE(rgpwsz))
            {
		hr = E_INVALIDARG;
		_JumpError(hr, error, "too many strings");
            }
        }
	rgpwsz[iIndex] = NULL;
    }
    hr = SetProperty(pwszPropertyName, 0 == iIndex? NULL : rgpwsz);
    _JumpIfError(hr, error, "SetProperty");

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertTypeInfo::_LoadFromDefaults --
//
//
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::_LoadFromDefaults(
    PCERT_TYPE_DEFAULT pDefault,
    LPWSTR            wszDomain)
{
    HRESULT hr;
    CCAProperty *pProp;
    DWORD        dwType;
    DWORD        dwSize;
    WCHAR        *awszData[MAX_DEFAULT_STRING_COUNT];
    WCHAR        wszFriendlyName[MAX_DEFAULT_FRIENDLY_NAME];
    LPWSTR       wszDomainSid = NULL;
    PSID         pDomainSid = NULL;
    LPWSTR       wszFormattedSD = NULL;
    LPWSTR       pwszDefaultOID=NULL;
    WCHAR        **papwsz;

    if (NULL == pDefault)
    {
        hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    //CN
    m_bstrType = CertAllocString(pDefault->wszName);
    if (NULL == m_bstrType)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "CertAllocString");
    }

    awszData[0] = pDefault->wszName;
    awszData[1] = NULL;
    hr = SetProperty(CERTTYPE_PROP_CN, awszData);
    _JumpIfError(hr, error, "SetProperty");

    //FriendlyName
    papwsz = NULL;
    if(0 != pDefault->idFriendlyName)
    {
        if (!::LoadString(
		    g_hInstance,
                    pDefault->idFriendlyName,
                    wszFriendlyName,
                    ARRAYSIZE(wszFriendlyName)))
        {
	    hr = myHLastError();
	    _JumpError(hr, error, "LoadString");
        }
	awszData[0] = wszFriendlyName;
	awszData[1] = NULL;
	papwsz = awszData;
    }
    hr = SetProperty(CERTTYPE_PROP_FRIENDLY_NAME, papwsz);
    _JumpIfError(hr, error, "SetProperty");

    hr = _SetWszzProperty(CERTTYPE_PROP_CSP_LIST, pDefault->wszCSPs);
    _JumpIfError(hr, error, "_SetWszzProperty");

    hr = _SetWszzProperty(CERTTYPE_PROP_EXTENDED_KEY_USAGE, pDefault->wszEKU);
    _JumpIfError(hr, error, "_SetWszzProperty");

    hr = _SetWszzProperty(
		    CERTTYPE_PROP_CRITICAL_EXTENSIONS,
		    pDefault->wszCriticalExt);
    _JumpIfError(hr, error, "_SetWszzProperty");

    hr = _SetWszzProperty(
		    CERTTYPE_PROP_SUPERSEDE,
		    pDefault->wszSupersedeTemplates);
    _JumpIfError(hr, error, "_SetWszzProperty");

    hr = _SetWszzProperty(CERTTYPE_PROP_RA_POLICY, pDefault->wszRAPolicy);
    _JumpIfError(hr, error, "_SetWszzProperty");

    hr = _SetWszzProperty(
		    CERTTYPE_PROP_RA_APPLICATION_POLICY,
		    pDefault->wszRAAppPolicy);
    _JumpIfError(hr, error, "_SetWszzProperty");

    hr = _SetWszzProperty(
		    CERTTYPE_PROP_POLICY,
		    pDefault->wszCertificatePolicy);
    _JumpIfError(hr, error, "_SetWszzProperty");

    hr = _SetWszzProperty(
		    CERTTYPE_PROP_APPLICATION_POLICY,
		    pDefault->wszCertificateAppPolicy);
    _JumpIfError(hr, error, "_SetWszzProperty");

    //Temmplate OID
    papwsz = awszData;
    if (CT_FLAG_IS_DEFAULT & pDefault->dwFlags)
    {
        // We concatenate the predefined oid with the enterprise root.
        // Consider the NULL case valid since we should work with W2K schema

        hr = CAOIDBuildOID(0, pDefault->wszOID, &pwszDefaultOID);
	    //_JumpIfError(hr, error, "CAOIDBuildOID");
        if(S_OK != hr)
	{
	    papwsz = NULL;
	}
        else
	{
            awszData[0] = pwszDefaultOID;
	}
    }
    else
    {
        awszData[0] = pDefault->wszOID;
    }
    awszData[1] = NULL;
    hr = SetProperty(CERTTYPE_PROP_OID, papwsz);
    _JumpIfError(hr, error, "SetProperty");

    //key usages
    m_KeyUsage.pbData = (BYTE *) LocalAlloc(LMEM_FIXED, sizeof(pDefault->bKU));
    if (NULL == m_KeyUsage.pbData)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(m_KeyUsage.pbData, &pDefault->bKU, sizeof(pDefault->bKU));
    m_KeyUsage.cbData = sizeof(pDefault->bKU);
    m_KeyUsage.cUnusedBits = 0;

    //dw_Properties
    m_dwFlags = pDefault->dwFlags;
    m_Revision = pDefault->dwRevision;
    m_dwKeySpec = pDefault->dwKeySpec;
    m_dwMinorRevision = pDefault->dwMinorRevision;
    m_dwEnrollmentFlags=pDefault->dwEnrollmentFlags;
    m_dwPrivateKeyFlags=pDefault->dwPrivateKeyFlags;
    m_dwCertificateNameFlags=pDefault->dwCertificateNameFlags;
    m_dwMinimalKeySize=pDefault->dwMinimalKeySize;
    m_dwRASignature=pDefault->dwRASignature;
    m_dwSchemaVersion=pDefault->dwSchemaVersion;

    //basic contraints
    m_BasicConstraints.dwPathLenConstraint = pDefault->dwDepth;
    m_BasicConstraints.fPathLenConstraint =
        (m_BasicConstraints.dwPathLenConstraint != -1);


    ((LARGE_INTEGER UNALIGNED *)&m_ftExpiration)->QuadPart = -Int32x32To64(FILETIME_TICKS_PER_SECOND, pDefault->dwExpiration);
    ((LARGE_INTEGER UNALIGNED *)&m_ftOverlap)->QuadPart    = -Int32x32To64(FILETIME_TICKS_PER_SECOND, pDefault->dwOverlap);

    //DN
    awszData[0] = pDefault->wszName;
    awszData[1] = NULL;

    hr = SetProperty(CERTTYPE_PROP_DN, awszData);
    _JumpIfError(hr, error, "SetProperty");

    //SID
    hr = myGetSidFromDomain(wszDomain, &pDomainSid);
    if (S_OK != hr)
    {
        hr = HRESULT_FROM_WIN32(hr);
	_JumpError(hr, error, "myGetSidFromDomain");
    }
    if (!myConvertSidToStringSid(pDomainSid, &wszDomainSid))
    {
        hr = myHLastError();
	_JumpError(hr, error, "myConvertSidToStringSid");
    }
    if (0 == FormatMessage(
		    FORMAT_MESSAGE_ALLOCATE_BUFFER |
			FORMAT_MESSAGE_FROM_STRING |
			FORMAT_MESSAGE_ARGUMENT_ARRAY,
		    pDefault->wszSD,
		    0,
		    0,
		    (LPTSTR) &wszFormattedSD,
		    0,
		    (va_list *) &wszDomainSid))
    {
        hr = myHLastError();
	_JumpError(hr, error, "FormatMessage");
    }
    hr = myGetSDFromTemplate(wszFormattedSD, NULL, &m_pSD);
    _JumpIfError(hr, error, "myGetSDFromTemplate");

error:
    if (NULL != wszFormattedSD)
    {
        LocalFree(wszFormattedSD);
    }
    if (NULL != wszDomainSid)
    {
        LocalFree(wszDomainSid);
    }
    if (NULL != pDomainSid)
    {
        LocalFree(pDomainSid);
    }
    if (NULL != pwszDefaultOID)
    {
        LocalFree(pwszDefaultOID);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertTypeInfo::_LoadFromDSEntry -- ProcessFind CertTypes Objects in the DS
//
//
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::_LoadFromDSEntry(
    LDAP *  pld,
    LDAPMessage *Entry)
{
    HRESULT hr = S_OK;
    ULONG   ldaperr;
    DWORD   iIndex;
    DWORD   dwValue=0;
    BOOL    fV2Schema=FALSE;

    struct berval **apExtension;
    struct berval **apSD;
    LPWSTR awszName[2];


    LPWSTR *awszValue = NULL;

	CCAProperty *pProp;
	WCHAR ** pwszProp;
	WCHAR ** wszLdapVal;

    // This is a fix so that CERTTYPE_PROP_DN is set to CERTTYPE_PROP_CN first.
    // The real DN is found and appended later, and will never be used or
    // returned in this case.

    wszLdapVal = ldap_get_values(pld, Entry, CERTTYPE_PROP_CN);
    if (NULL == wszLdapVal)
    {
	//BUGBUG: why not use last ldap error?
	//hr = myHLdapLastError(pld, NULL);
	hr = myHLdapError(pld, LDAP_NO_SUCH_ATTRIBUTE, NULL);
	_JumpError(hr, error, "getCNFromDS");
    }
    SetProperty(CERTTYPE_PROP_DN, wszLdapVal);
    if(wszLdapVal[0])
    {
	m_bstrType = CertAllocString(wszLdapVal[0]);
    }
    ldap_value_free(wszLdapVal);

    // Add text properties from
    // DS lookup.

    for (pwszProp = g_awszCTNamedProps; *pwszProp != NULL; pwszProp++)
    {
        pProp = new CCAProperty(*pwszProp);
        if(pProp == NULL)
        {
	        hr = E_OUTOFMEMORY;
	        _JumpError(hr, error, "new");
        }

        wszLdapVal = ldap_get_values(pld, Entry, *pwszProp);
        hr = pProp->SetValue(wszLdapVal);
	    _PrintIfError(hr, "SetValue");

        if(wszLdapVal)
        {
	        ldap_value_free(wszLdapVal);
        }
        if(hr == S_OK)
        {
            hr = CCAProperty::Append(&m_pProperties, pProp);
	        _PrintIfError(hr, "Append");
        }

        if(hr != S_OK)
        {
	        CCAProperty::DeleteChain(&pProp);
	        _JumpError(hr, error, "SetValue or Append");
        }

    }
    pwszProp = NULL;

	// Append special properties

    // CSP list

    // Values of the form index,value
    wszLdapVal = ldap_get_values(pld, Entry, CERTTYPE_PROP_CSP_LIST);
    if(wszLdapVal)
    {
        LPWSTR wszValue;
        LPWSTR *pwszCurrent;
        DWORD  i;
        DWORD  cValues = 0;
        pwszCurrent = wszLdapVal;
        while(*pwszCurrent)
        {
            cValues++;
            pwszCurrent++;
        }
        pwszProp = (LPWSTR *)LocalAlloc(LMEM_FIXED, (cValues+1)*sizeof(LPWSTR));

        if(pwszProp == NULL)
        {
            ldap_value_free(wszLdapVal);
            hr = E_OUTOFMEMORY;
	        _JumpError(hr, error, "LocalAlloc");
        }
        ZeroMemory(pwszProp, (cValues+1)*sizeof(LPWSTR));

        pwszCurrent = wszLdapVal;
        while(*pwszCurrent)
        {
            i = wcstol(*pwszCurrent, &wszValue, 10);
            if(wszValue)
            {
                wszValue++;
            }
            if((i > 0) && (i <= cValues))
            {
                pwszProp[i-1] = wszValue;
            }
            pwszCurrent++;
        }
    }
    pProp = new CCAProperty(CERTTYPE_PROP_CSP_LIST);
    if(pProp == NULL)
    {
        if (NULL != pwszProp)
		{
			LocalFree(pwszProp);
		}
		if (NULL != wszLdapVal)
		{
			ldap_value_free(wszLdapVal);
		}
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "new");
    }
    hr = pProp->SetValue(pwszProp);
    _PrintIfError(hr, "SetValue");

    if (NULL != pwszProp)
    {
		LocalFree(pwszProp);
    }
    if (NULL != wszLdapVal)
    {
		ldap_value_free(wszLdapVal);
    }

    if(hr == S_OK)
    {
        hr = CCAProperty::Append(&m_pProperties, pProp);
		_PrintIfError(hr, "Append");
    }
    if(hr != S_OK)
    {

		CCAProperty::DeleteChain(&pProp);
		_JumpError(hr, error, "SetValue or Append");
    }



    // Append the security descriptor...

	apSD = ldap_get_values_len(pld, Entry, CERTTYPE_SECURITY_DESCRIPTOR_NAME);
    if(apSD != NULL)
    {
        m_pSD = LocalAlloc(LMEM_FIXED, (*apSD)->bv_len);
        if(m_pSD == NULL)
        {
            hr = E_OUTOFMEMORY;
            ldap_value_free_len(apSD);
		    _JumpError(hr, error, "LocalAlloc");
        }
        CopyMemory(m_pSD, (*apSD)->bv_val, (*apSD)->bv_len);
        ldap_value_free_len(apSD);
    }

    m_dwFlags = 0;
    awszValue = ldap_get_values(pld, Entry, CERTTYPE_PROP_FLAGS);
    if(awszValue != NULL)
    {
        if(awszValue[0] != NULL)
        {
            m_dwFlags = _wtol(awszValue[0]);
        }
        ldap_value_free(awszValue);
    }

    m_Revision = CERTTYPE_VERSION_BASE;
    awszValue = ldap_get_values(pld, Entry, CERTTYPE_PROP_REVISION);
    if(awszValue != NULL)
    {
        if(awszValue[0] != NULL)
        {
            m_Revision = _wtol(awszValue[0]);
        }
        ldap_value_free(awszValue);
    }

    m_dwKeySpec = 0;
    awszValue = ldap_get_values(pld, Entry, CERTTYPE_PROP_DEFAULT_KEYSPEC);
    if(awszValue != NULL)
    {
        if(awszValue[0] != NULL)
        {
            m_dwKeySpec = _wtol(awszValue[0]);
        }
        ldap_value_free(awszValue);
    }

    apExtension = ldap_get_values_len(pld, Entry, CERTTYPE_PROP_KU);
    if(apExtension != NULL)
    {
        m_KeyUsage.cbData = (*apExtension)->bv_len;
        m_KeyUsage.cUnusedBits = 0;
        m_KeyUsage.pbData = (PBYTE)LocalAlloc(LMEM_FIXED, m_KeyUsage.cbData);
        if(m_KeyUsage.pbData == NULL)
        {
            hr = E_OUTOFMEMORY;
            ldap_value_free_len(apExtension);
		    _JumpError(hr, error, "LocalAlloc");

        }
        CopyMemory(m_KeyUsage.pbData, (*apExtension)->bv_val, (*apExtension)->bv_len);
        ldap_value_free_len(apExtension);
    }
    m_BasicConstraints.dwPathLenConstraint = 0;
    awszValue = ldap_get_values(pld, Entry, CERTTYPE_PROP_MAX_DEPTH);
    if(awszValue != NULL)
    {
        if(awszValue[0] != NULL)
        {
            m_BasicConstraints.dwPathLenConstraint = _wtoi(awszValue[0]);

           m_BasicConstraints.fPathLenConstraint =
                (m_BasicConstraints.dwPathLenConstraint != -1);
        }
        ldap_value_free(awszValue);
    }

    ZeroMemory(&m_ftExpiration, sizeof(m_ftExpiration));
    apExtension = ldap_get_values_len(pld, Entry, CERTTYPE_PROP_EXPIRATION);
    if(apExtension != NULL)
    {
        CopyMemory(&m_ftExpiration, (*apExtension)->bv_val, min((*apExtension)->bv_len, sizeof(m_ftExpiration)));
        ldap_value_free_len(apExtension);
    }

    ZeroMemory(&m_ftOverlap, sizeof(m_ftOverlap));
    apExtension = ldap_get_values_len(pld, Entry, CERTTYPE_PROP_OVERLAP);
    if(apExtension != NULL)
    {
        CopyMemory(&m_ftOverlap, (*apExtension)->bv_val, min((*apExtension)->bv_len, sizeof(m_ftOverlap)));
        ldap_value_free_len(apExtension);
    }

    m_fNew = FALSE;

    //we load the V2 template attributes if they exist
    awszValue=NULL;
    pProp=NULL;
    hr=S_OK;

    awszValue = ldap_get_values(pld, Entry, CERTTYPE_PROP_SCHEMA_VERSION);
    if((awszValue != NULL) && (awszValue[0] != NULL))
       fV2Schema=TRUE;

    if(awszValue)
    {
	    ldap_value_free(awszValue);
        awszValue=NULL;
    }

    if(fV2Schema)
    {
        for(iIndex=0; iIndex < g_CTV2PropertiesCount; iIndex++)
        {
            if(g_CTV2Properties[iIndex].fStringProperty)
            {
                pProp = new CCAProperty(g_CTV2Properties[iIndex].pwszProperty);
                if(pProp == NULL)
                {
	                hr = E_OUTOFMEMORY;
	                _JumpError(hr, error, "new");
                }

                awszValue = ldap_get_values(pld, Entry, g_CTV2Properties[iIndex].pwszProperty);
                hr = pProp->SetValue(awszValue);
	            _PrintIfError(hr, "SetValue");

                if(awszValue)
                {
	                ldap_value_free(awszValue);
                    awszValue=NULL;
                }

                if(hr == S_OK)
                {
                    hr = CCAProperty::Append(&m_pProperties, pProp);
	                _PrintIfError(hr, "Append");
                }

                if(hr != S_OK)
                {
	                CCAProperty::DeleteChain(&pProp);
	                _JumpError(hr, error, "SetValue or Append");
                }

                pProp=NULL;
            }
            else
            {

                dwValue=0;
                awszValue = ldap_get_values(pld, Entry, g_CTV2Properties[iIndex].pwszProperty);
                if((awszValue != NULL) && (awszValue[0] != NULL))
                {
                    dwValue = _wtol(awszValue[0]);
                    ldap_value_free(awszValue);
                    awszValue=NULL;
                }
                else
                {
                    if(awszValue)
                    {
                        ldap_value_free(awszValue);
                        awszValue=NULL;
                    }
                    hr=E_UNEXPECTED;
	                _JumpError(hr, error, "ldap get values");
                }

                 //assign dwValue to the corresponding data members
			    if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_MINOR_REVISION)==0)
				    m_dwMinorRevision = dwValue;
			    else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_RA_SIGNATURE)==0)
				    m_dwRASignature = dwValue;
			    else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_RPOP_ENROLLMENT_FLAG)==0)
				    m_dwEnrollmentFlags = dwValue;
			    else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_PRIVATE_KEY_FLAG)==0)
				    m_dwPrivateKeyFlags = dwValue;
			    else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_NAME_FLAG)==0)
				    m_dwCertificateNameFlags = dwValue;
			    else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_MIN_KEY_SIZE)==0)
				    m_dwMinimalKeySize = dwValue;
			    else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_SCHEMA_VERSION)==0)
				    m_dwSchemaVersion = dwValue;
			    else
			    {
				    hr=E_UNEXPECTED;
		            _JumpError(hr, error, "Copy V2 attribute value");
			    }
            }
        }
    }


error:

    return(hr);
}



//+--------------------------------------------------------------------------
// CCertTypeInfo::_EnumFromDSCache -- Enumerate the CertType objects from the
// DS cache
//
//
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::_EnumFromDSCache(
                    DWORD               dwFlags,
                    CCertTypeInfo **    ppCTInfo
                    )

{
    HRESULT hr = S_OK;
    CCertTypeInfo *pCTFirst = NULL;
    CCertTypeInfo *pCTCurrent = NULL;
    DWORD         cTypes;
    DWORD         cMaxTypesLen;


    HKEY  hPolicyKey = NULL;
    HKEY  hEnumKey = NULL;
    WCHAR  *wszTypeName = NULL;

    DWORD err;
    DWORD i;
    DWORD disp;


    if(ppCTInfo == NULL )
    {
        return E_POINTER;
    }

    do {

        err = RegCreateKeyEx((dwFlags & CA_FIND_LOCAL_SYSTEM)?HKEY_LOCAL_MACHINE:HKEY_CURRENT_USER,
                             wszCERTTYPECACHE,
                             NULL,
                             TEXT(""),
                             REG_OPTION_NON_VOLATILE,
                               KEY_ENUMERATE_SUB_KEYS |
                               KEY_EXECUTE |
                               KEY_QUERY_VALUE,
                             NULL,
                             &hEnumKey,
                             &disp);


        if(ERROR_SUCCESS != err)
        {
            break;
        }

        err = RegQueryInfoKey(hEnumKey,
                              NULL,
                              NULL,
                              NULL,
                              &cTypes,
                              &cMaxTypesLen,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL);

        if(ERROR_SUCCESS != err)
        {
            hr = HRESULT_FROM_WIN32(err);
            break;
        }
        cMaxTypesLen++;  // Terminating NULL

        wszTypeName = (WCHAR *)LocalAlloc(LMEM_FIXED, cMaxTypesLen*sizeof(WCHAR));
        if(wszTypeName == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }

        hr = S_OK;
        for(i = 0;
            i < cTypes;
            i++)
        {
            DWORD cName;


            cName = cMaxTypesLen;
            err = RegEnumKeyEx(hEnumKey,
                               i,
                               wszTypeName,
                               &cName,
                               NULL,
                               NULL,
                               NULL,
                               NULL);
            if(ERROR_SUCCESS != err)
            {
                continue;
            }


            pCTCurrent = new CCertTypeInfo;
            if(pCTCurrent == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto error;
            }
            hr = pCTCurrent->_LoadCachedCTFromReg(wszTypeName,
                                                  (dwFlags & CA_FIND_LOCAL_SYSTEM)?HKEY_LOCAL_MACHINE:HKEY_CURRENT_USER);
            if(hr == S_OK)
            {
                if(dwFlags & CT_FIND_LOCAL_SYSTEM)
                {
                    pCTCurrent->m_fLocalSystemCache = TRUE;
                }
                _Append(&pCTFirst, pCTCurrent);
                pCTCurrent = NULL;
            }

            if(pCTCurrent)
            {
                delete pCTCurrent;
                pCTCurrent = NULL;
            }
        }
        break;
    }
    while(TRUE);

    hr = S_OK;

    // May be null if none found.
    _Append(ppCTInfo, pCTFirst);

    pCTFirst = NULL;


error:
    if(wszTypeName)
    {
        LocalFree(wszTypeName);
    }

    if(pCTFirst)
    {
        delete pCTFirst;
    }

    if(hEnumKey)
    {
        RegCloseKey(hEnumKey);
    }
    return hr;
}



//+--------------------------------------------------------------------------
// CCertTypeInfo::_HasDSCacheExpired --
//
//  return E_FAIL: expired
//         S_OK:   not expired
//
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::_HasDSCacheExpired(
                    DWORD               dwFlags
                    )

{
    HRESULT hr = S_OK;





    HKEY  hTimestampKey = NULL;

    DWORD err;
    DWORD i;
    DWORD disp;
    DWORD dwSize;
    DWORD dwType;

    LARGE_INTEGER ftTimestamp;
    FILETIME ftSystemTime;

    if(dwFlags & CT_FLAG_NO_CACHE_LOOKUP)
    {
        hr = E_FAIL;
        goto error;
    }





    err = RegCreateKeyEx((dwFlags & CA_FIND_LOCAL_SYSTEM)?HKEY_LOCAL_MACHINE:HKEY_CURRENT_USER,
                         wszCERTTYPECACHE,
                         NULL,
                         TEXT(""),
                         REG_OPTION_NON_VOLATILE,
                           KEY_ENUMERATE_SUB_KEYS |
                           KEY_EXECUTE |
                           KEY_QUERY_VALUE,
                         NULL,
                         &hTimestampKey,
                         &disp);


    if(ERROR_SUCCESS != err)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }

    dwSize = sizeof(FILETIME);
    err = RegQueryValueEx(hTimestampKey,
                    wszTIMESTAMP,
                    NULL,
                    &dwType,
                    (PBYTE)&ftTimestamp,
                    &dwSize);
    if(err != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }

    GetSystemTimeAsFileTime(&ftSystemTime);

	//the ftTimestamp time should always less than the current system clock.
	//has to reload otherwise

	if( 0 > CompareFileTime(&ftSystemTime, (FILETIME *)&ftTimestamp ))
	{
		// We need to reload.  System clock readjusted
		hr = E_FAIL;
	}
	else
	{
		ftTimestamp.QuadPart +=  Int32x32To64(CERTTYPE_REFRESH_PERIOD, FILETIME_TICKS_PER_SECOND);

		if( 0 < CompareFileTime(&ftSystemTime, (FILETIME *)&ftTimestamp ))
		{
			// Expired
			hr = E_FAIL;
		}
		else
		{
			// Not expried, so don't bother
			// renewing
			hr = S_OK;
		}

	}



error:


    if(hTimestampKey)
    {
        RegCloseKey(hTimestampKey);
    }
    return hr;
}

//+--------------------------------------------------------------------------
// CCertTypeInfo::_UpdateDSCache --
//
//
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::_UpdateDSCache(
                    DWORD               dwFlags,
                    CCertTypeInfo *     pCTInfo
                    )

{
    HRESULT hr = S_OK;

    HKEY    hEnumKey = NULL;

    LPWSTR  wszTypeName = NULL;
    DWORD   cMaxTypesLen;
    DWORD   cTypes;

    DWORD err;
    DWORD i;
    DWORD disp;
    DWORD dwSize;
    DWORD dwType;
    FILETIME ftSystemTime;

    CCertTypeInfo *     pCTCurrent = pCTInfo;



    err = RegCreateKeyEx((dwFlags & CA_FIND_LOCAL_SYSTEM)?HKEY_LOCAL_MACHINE:HKEY_CURRENT_USER,
                         wszCERTTYPECACHE,
                         NULL,
                         TEXT(""),
                         REG_OPTION_NON_VOLATILE,
                         KEY_ALL_ACCESS,
                         NULL,
                         &hEnumKey,
                         &disp);


    if(ERROR_SUCCESS != err)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }
    GetSystemTimeAsFileTime(&ftSystemTime);

    err = RegSetValueEx(hEnumKey,
                    wszTIMESTAMP,
                    NULL,
                    REG_BINARY,
                    (PBYTE)&ftSystemTime,
                    sizeof(ftSystemTime));
    if(ERROR_SUCCESS != err )
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }

    err = RegQueryInfoKey(hEnumKey,
                          NULL,
                          NULL,
                          NULL,
                          &cTypes,
                          &cMaxTypesLen,
                          NULL,
                          NULL,
                          NULL,
                          NULL,
                          NULL,
                          NULL);

    if(ERROR_SUCCESS != err)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }

    //delete existing cache information
    if(cTypes != 0)
    {

        cMaxTypesLen++;  // Terminating NULL

        wszTypeName = (LPWSTR)LocalAlloc(LMEM_FIXED,
                                  cMaxTypesLen * sizeof(WCHAR));

        if(wszTypeName == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }

        hr = S_OK;
        for(i = 0;
            i < cTypes;
            i++)
        {
            DWORD cName;
            LPCWSTR wszBaseScope = NULL;


            cName = cMaxTypesLen;
            err = RegEnumKeyEx(hEnumKey,
                               0,           // As we delete, the index changes
                               wszTypeName,
                               &cName,
                               NULL,
                               NULL,
                               NULL,
                               NULL);
            if(ERROR_SUCCESS != err)
            {
                continue;
            }

            RegDeleteKey(hEnumKey, wszTypeName);
        }
    }



    while(pCTCurrent)
    {
        pCTCurrent->_BaseUpdateToReg(hEnumKey);
        pCTCurrent = pCTCurrent->m_pNext;
    }



error:
    if(wszTypeName)
    {
        LocalFree(wszTypeName);
    }

    if(hEnumKey)
    {
        RegCloseKey(hEnumKey);
    }

    return hr;
}


//+--------------------------------------------------------------------------
// CCAInfo::_EnumScopeFromDS --
//
//      Scope means the base DN where the search starts
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::_EnumScopeFromDS(
    LDAP *  pld,
    DWORD   dwFlags,
    LPCWSTR wszScope,
    CCertTypeInfo **    ppCTInfo)

{
    HRESULT hr = S_OK;
    ULONG   ldaperr;


static WCHAR * s_wszSearch = L"(objectCategory=pKICertificateTemplate)";

    CCertTypeInfo *pCTFirst = NULL;
    CCertTypeInfo *pCTCurrent = NULL;
    // Initialize LDAP session
    CHAR sdBerValue[] = {0x30, 0x03, 0x02, 0x01, DACL_SECURITY_INFORMATION |
                                                 OWNER_SECURITY_INFORMATION |
                                                 GROUP_SECURITY_INFORMATION };

    LDAPControl se_info_control =
    {
        LDAP_SERVER_SD_FLAGS_OID_W,
        {
            5, sdBerValue
        },
        TRUE
    };

    LDAPControl permissive_modify_control =
    {
        LDAP_SERVER_PERMISSIVE_MODIFY_OID_W,
        {
            0, NULL
        },
        FALSE
    };


    PLDAPControl    server_controls[3] =
                    {
                        &se_info_control,
                        &permissive_modify_control,
                        NULL
                    };

    LDAPMessage *SearchResult = NULL, *Entry;


    // search timeout
    struct l_timeval        timeout;

    if (NULL == ppCTInfo)
    {
        hr = E_POINTER;
	    _JumpError(hr, error, "NULL parm");
    }



    timeout.tv_sec = csecLDAPTIMEOUT;
    timeout.tv_usec = 0;



    while(TRUE)
    {
	    // Perform search.  Asking for all certificate template attributes.
        // should work with both V1 and V2 templates.
	    ldaperr = ldap_search_ext_sW(pld,
		          (LPWSTR)wszScope,
		          LDAP_SCOPE_SUBTREE,
		          s_wszSearch,
		          g_awszCTAttrs,
		          0,
                  (PLDAPControl *)&server_controls,
                  NULL,
                  &timeout,
                  10000,
		          &SearchResult);
        if(ldaperr == LDAP_NO_SUCH_OBJECT)
	    {
	        // No entries were found.
	        hr = S_OK;
	        *ppCTInfo = NULL;
	        break;
	    }

	    if(ldaperr != LDAP_SUCCESS)
	    {
		hr = myHLdapError(pld, ldaperr, NULL);
	        break;
	    }
	    if(0 == ldap_count_entries(pld, SearchResult))
	    {
	        // No entries were found.
	        hr = S_OK;
	        *ppCTInfo = NULL;
	        break;
	    }

	    hr = S_OK;
	    for(Entry = ldap_first_entry(pld, SearchResult);
	        Entry != NULL;
	        Entry = ldap_next_entry(pld, Entry))
	    {

            pCTCurrent = new CCertTypeInfo;
            if(pCTCurrent == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto error;
            }

            hr =  pCTCurrent->_LoadFromDSEntry(pld,Entry);

            //filter out only the V1 and V2 templates
            if(hr == S_OK)
            {
                if(pCTCurrent->m_dwSchemaVersion <= CERTTYPE_SCHEMA_VERSION_2)
                {
                    if(dwFlags & CT_FIND_LOCAL_SYSTEM)
                    {
                        pCTCurrent->m_fLocalSystemCache = TRUE;
                    }
                    _Append(&pCTFirst, pCTCurrent);
                    pCTCurrent = NULL;
                }
            }

            if(pCTCurrent)
            {
                delete pCTCurrent;
                pCTCurrent = NULL;
            }

	    }
        break;
    }

    if(hr != S_OK)
    {
        hr = _EnumFromDSCache(dwFlags, &pCTFirst);
    }
    else
    {
        _UpdateDSCache(dwFlags,
                       pCTFirst);
    }

    if(hr == S_OK)
    {
        _Append(ppCTInfo, pCTFirst);
        pCTFirst = NULL;
    }



error:

    if(SearchResult)
    {
        ldap_msgfree(SearchResult);
    }

    if (NULL != pCTFirst)
    {
        delete pCTFirst;
    }

    return(hr);
}



//+--------------------------------------------------------------------------
// CCertTypeInfo::_EnumFromDS -- Enumerate the CertType objects from the
// DS cache
//
//
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::_EnumFromDS(
                    LDAP *              pld,
                    DWORD               dwFlags,
                    CCertTypeInfo **    ppCTInfo
                    )

{


    HRESULT         hr = S_OK;
    LDAP            *mypld = NULL;

    LPCWSTR         wszCurrentDomain = NULL;

    CCertTypeInfo   *pCTFirst = NULL;

    CERTSTR         bstrCertTemplatesContainer = NULL;
    CERTSTR         bstrConfig = NULL;

    if (NULL == ppCTInfo)
    {
        hr = E_POINTER;
	    _JumpError(hr, error, "NULL param");
    }

    hr = E_FAIL;
    while((S_OK != _HasDSCacheExpired(dwFlags)) && (S_OK == myDoesDSExist(TRUE)))
    {

	    // bind to ds
        if(pld == NULL)
        {
            hr = myRobustLdapBind(&mypld, FALSE);

	        if(hr != S_OK)
	        {
                break;
	        }
            pld = mypld;
        }

	    hr = CAGetAuthoritativeDomainDn(pld, NULL, &bstrConfig);
	    if(S_OK != hr)
	    {
            break;
	    }

        bstrCertTemplatesContainer = CertAllocStringLen(NULL, wcslen(bstrConfig) + wcslen(s_wszLocation));
        if(bstrCertTemplatesContainer == NULL)
        {
            hr = E_OUTOFMEMORY;
	        _JumpError(hr, error, "CertAllocStringLen");
        }
        wcscpy(bstrCertTemplatesContainer, s_wszLocation);
        wcscat(bstrCertTemplatesContainer, bstrConfig);

        hr = _EnumScopeFromDS(pld,
                         dwFlags,
                         bstrCertTemplatesContainer,
                         &pCTFirst);
        break;
    }


    if(hr != S_OK)
    {
        hr = _EnumFromDSCache(dwFlags, &pCTFirst);
    }

    if(hr == S_OK)
    {
        _FilterByFlags(&pCTFirst, dwFlags);
	    // May be null if none found.
        _Append(ppCTInfo, pCTFirst);
	    pCTFirst = NULL;
    }


   hr = S_OK;

error:

    if (NULL != bstrCertTemplatesContainer)
    {
        CertFreeString(bstrCertTemplatesContainer);
    }

    if(bstrConfig)
    {
        CertFreeString(bstrConfig);
    }

    if (NULL != mypld)
    {
        ldap_unbind(mypld);
    }
    return(hr);

}



//+--------------------------------------------------------------------------
// CCertTypeInfo::_FindInDS -- Find the CertType objects in the
// DS
//
//
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::_FindInDS(
                    LDAP *              pld,
                    LPCWSTR *           wszNames,
                    DWORD               dwFlags,
                    CCertTypeInfo **    ppCTInfo
                    )

{

    HRESULT             hr = S_OK;
    BOOL                fFound = FALSE;
    LPCWSTR             *pwszCurrentName = NULL;


    CCertTypeInfo *     pCTCurrent = NULL;
    LPWSTR              *rgwszOID = NULL;


    if (NULL == ppCTInfo)
    {
        hr = E_POINTER;
	    _JumpError(hr, error, "NULL param");
    }



    hr = _EnumFromDS(pld,
                     dwFlags,
                     &pCTCurrent
                     );

    // Filter Scopes by given names.

    pwszCurrentName = wszNames;

    while(pwszCurrentName && *pwszCurrentName)
    {
        CCertTypeInfo * pCTNext = pCTCurrent,
                      **ppCTLast = &pCTCurrent;

        fFound=FALSE;

        while(pCTNext != NULL)
        {
            if(CT_FIND_BY_OID & dwFlags)
            {
                if(S_OK == CAGetCertTypePropertyEx((HCERTTYPE)pCTNext, CERTTYPE_PROP_OID, &rgwszOID))
                {
                    if(rgwszOID)
                    {
                        if(rgwszOID[0])
                        {
                            if(_wcsicmp(rgwszOID[0], *pwszCurrentName) == 0)
                                fFound=TRUE;
                        }
                    }
                }
            }
            else
            {
                if(lstrcmpi(pCTNext->m_bstrType, *pwszCurrentName) == 0)
                    fFound=TRUE;
            }

            if(rgwszOID)
            {
                CAFreeCertTypeProperty((HCERTTYPE)pCTNext, rgwszOID);
                rgwszOID=NULL;
            }

            if(fFound)
            {
                *ppCTLast = pCTNext->m_pNext;
                pCTNext->m_pNext = NULL;
                _Append(ppCTInfo, pCTNext);
                break;
            }
            ppCTLast = &pCTNext->m_pNext;
            pCTNext = pCTNext->m_pNext;
        }
        pwszCurrentName++;

    }



error:

    if(pCTCurrent)
    {
        delete pCTCurrent;
    }

    return(hr);

}

//+--------------------------------------------------------------------------
// CCertTypeInfo::Enum -- Enumerate the Cert Type objects
//
//
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::Enum(
                    LPCWSTR             wszScope,
                    DWORD               dwFlags,
                    CCertTypeInfo **    ppCTInfo
                    )

{
    HRESULT hr = S_OK;
    CCertTypeInfo *pCTFirst = NULL;

    if(ppCTInfo == NULL )
    {
        return E_POINTER;
    }
    hr = _EnumFromDS(((CT_FLAG_SCOPE_IS_LDAP_HANDLE & dwFlags)?(LDAP *)wszScope:NULL), dwFlags, &pCTFirst);

    if(hr != S_OK)
    {
        goto error;
    }


    _FilterByFlags(&pCTFirst, dwFlags);
    // May be null if none found.
    *ppCTInfo = pCTFirst;
    pCTFirst = NULL;




error:

    if(pCTFirst)
    {
        delete pCTFirst;
    }

    return hr;

}

//+--------------------------------------------------------------------------
// CCertTypeInfo::Find -- Find CertType Objects in the DS
//
//
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::FindByNames(
    LPCWSTR *           wszNames,
    LPCWSTR             wszScope,
    DWORD               dwFlags,
    CCertTypeInfo **    ppCTInfo)

{
    HRESULT hr = S_OK;
    CCertTypeInfo *pCTFirst = NULL;






    if(ppCTInfo == NULL )
    {
        return E_POINTER;
    }

    hr = _FindInDS(((CT_FLAG_SCOPE_IS_LDAP_HANDLE & dwFlags)?(LDAP *)wszScope:NULL),
                   wszNames,
                   dwFlags,
                   &pCTFirst);
    if(hr != S_OK)
    {
        goto error;
    }
    // May be null if none found.
    *ppCTInfo = pCTFirst;
    pCTFirst = NULL;




error:


    if(pCTFirst)
    {
        delete pCTFirst;
    }

    return hr;

}
//+--------------------------------------------------------------------------
// CCertTypeInfo::Create -- Create CertType Object in the DS
//
//
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::Create(
    LPCWSTR             wszCertType,
    LPCWSTR             wszScope,
    CCertTypeInfo **    ppCTInfo)

{
    HRESULT             hr = S_OK;
    CERT_TYPE_DEFAULT   certTypeDefault;
    CCertTypeInfo       *pCTCurrent = NULL;
    LPWSTR              pwszDomain = NULL;

    DWORD               disp=0;

    if((ppCTInfo == NULL )|| (wszCertType == NULL))
    {
        return E_POINTER;
    }

    memset(&certTypeDefault, 0, sizeof(CERT_TYPE_DEFAULT));

    pCTCurrent = new CCertTypeInfo;
    if(pCTCurrent == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    //wszScope should always be NULL.
    if(wszScope)
    {
        hr = myDomainFromDn(wszScope, &pwszDomain);
	_JumpIfError(hr, error, "myDomainFromDn");
    }

    certTypeDefault.wszName=(LPWSTR)wszCertType;
    certTypeDefault.idFriendlyName=0;
    certTypeDefault.wszSD=ADMIN_GROUP_SD;
    certTypeDefault.dwKeySpec=AT_KEYEXCHANGE;
    certTypeDefault.dwRevision=CERTTYPE_VERSION_NEXT;
    //update the schema and revision.  If V3 properties were to be set, will
    //update the schema accordinlgy.
    certTypeDefault.dwSchemaVersion=CERTTYPE_SCHEMA_VERSION_2;
    certTypeDefault.dwCertificateNameFlags=CT_FLAG_SUBJECT_REQUIRE_COMMON_NAME;
    certTypeDefault.dwExpiration=EXPIRATION_FIVE_YEARS;
    certTypeDefault.dwOverlap=OVERLAP_TWO_WEEKS;

    if(S_OK != (hr=I_CAOIDCreateNew(CERT_OID_TYPE_TEMPLATE,
                                0,
                                &(certTypeDefault.wszOID))))
        goto error;

    hr = pCTCurrent->_LoadFromDefaults(&certTypeDefault, pwszDomain);
    if(hr != S_OK)
    {
        goto error;
    }

    *ppCTInfo = pCTCurrent;
    pCTCurrent = NULL;
error:

    if(certTypeDefault.wszOID)
        LocalFree(certTypeDefault.wszOID);

    if(pCTCurrent)
    {
        delete pCTCurrent;
    }
    if(pwszDomain)
    {
        LocalFree(pwszDomain);
    }
    return hr;
}
//+--------------------------------------------------------------------------
// CCertTypeInfo::Update -- Update CertType Objects to the DS
//
//
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::Update(VOID)

{
    HRESULT hr = S_OK;
    DWORD   err;
    HKEY    hCertTypeCache = NULL;
    DWORD   disp;

    m_dwFlags |= CT_FLAG_IS_MODIFIED;

    //we change the autoenroll flag based on the property set
    //for V2 or above template only
    if(m_dwSchemaVersion >= CERTTYPE_SCHEMA_VERSION_2)
    {
        if( (CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT & m_dwCertificateNameFlags) ||
            (CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT_ALT_NAME & m_dwCertificateNameFlags)  ||
            ((m_dwRASignature >= 2) && (0 == (CT_FLAG_PREVIOUS_APPROVAL_VALIDATE_REENROLLMENT & m_dwEnrollmentFlags)))
          )
        {
            //turn off autoenrollment flag
            m_dwEnrollmentFlags &= (~CT_FLAG_AUTO_ENROLLMENT);
        }
        else
        {
            //turn on autoenrollment flag
            m_dwEnrollmentFlags |= CT_FLAG_AUTO_ENROLLMENT;
        }
    }


    // Update to the DS
    hr = _UpdateToDS();
    if(hr != S_OK)
    {
        goto error;
    }

    // Now update to the local cache.

    err = RegCreateKeyEx(m_fLocalSystemCache?HKEY_LOCAL_MACHINE:HKEY_CURRENT_USER,
                         wszCERTTYPECACHE,
                         NULL,
                         TEXT(""),
                         REG_OPTION_NON_VOLATILE,
                         KEY_ALL_ACCESS,
                         NULL,
                         &hCertTypeCache,
                         &disp);

    if(err != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }


    hr = _BaseUpdateToReg(hCertTypeCache);

error:

    if(hCertTypeCache)
    {
        RegCloseKey(hCertTypeCache);
    }
    return hr;
}
//+--------------------------------------------------------------------------
// CCertTypeInfo::_BaseUpdateToReg -- Update CertType Objects to the registry
//
//
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::_BaseUpdateToReg(HKEY hKey)

{
    CCAProperty     *pProp;
    HRESULT         hr = S_OK;
    DWORD           err;
    DWORD           iIndex=0;
    DWORD           dwValue=0;

    WCHAR           ** awszFriendlyName = NULL;

    WCHAR           *  wszFriendlyName;
    HKEY            hkCertType = NULL;
    DWORD           disp;

    PSECURITY_DESCRIPTOR pSD = NULL;
    DWORD                cbSD = 0;


    err = RegCreateKeyEx(hKey,
                         m_bstrType,
                         NULL,
                         TEXT(""),
                         REG_OPTION_NON_VOLATILE,
                         KEY_ALL_ACCESS,
                         NULL,
                         &hkCertType,
                         &disp);

    if(ERROR_SUCCESS != err)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }


    hr = GetProperty(CERTTYPE_PROP_FRIENDLY_NAME, &awszFriendlyName);
    if(hr != S_OK)
    {
        goto error;
    }


    if(awszFriendlyName && awszFriendlyName[0])
    {
        wszFriendlyName = awszFriendlyName[0];
    }
    else
    {
        wszFriendlyName = TEXT("");

    }
    err = RegSetValueEx(hkCertType,
                    wszDISPNAME,
                    NULL,
                    REG_SZ,
                    (PBYTE)wszFriendlyName,
                    sizeof(WCHAR)*(wcslen(wszFriendlyName)+1));
    if(ERROR_SUCCESS != err )
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }

    hr = m_pProperties->Find(CERTTYPE_PROP_CSP_LIST, &pProp);
    if(hr != S_OK)
    {
        goto error;
    }

    hr = pProp->UpdateToRegValue(hkCertType, wszCSPLIST);
    if(hr != S_OK)
    {
        goto error;
    }

    hr = m_pProperties->Find(CERTTYPE_PROP_EXTENDED_KEY_USAGE, &pProp);
    if(hr != S_OK)
    {
        goto error;
    }

    hr = pProp->UpdateToRegValue(hkCertType, wszEXTKEYUSAGE);
    if(hr != S_OK)
    {
        goto error;
    }

    hr = m_pProperties->Find(CERTTYPE_PROP_CRITICAL_EXTENSIONS, &pProp);
    if(hr != S_OK)
    {
        goto error;
    }

    hr = pProp->UpdateToRegValue(hkCertType, wszCRITICALEXTENSIONS);
    if(hr != S_OK)
    {
        goto error;
    }

    err = RegSetValueEx(hkCertType,
                    wszKEYUSAGE,
                    NULL,
                    REG_BINARY,
                    m_KeyUsage.pbData,
                    m_KeyUsage.cbData);

    if(ERROR_SUCCESS != err )
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }



    err = RegSetValueEx(hkCertType,
                    wszCTFLAGS,
                    NULL,
                    REG_DWORD,
                    (PBYTE)&m_dwFlags,
                    sizeof(m_dwFlags));

    if(ERROR_SUCCESS != err )
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }

    err = RegSetValueEx(hkCertType,
                    wszCTREVISION,
                    NULL,
                    REG_DWORD,
                    (PBYTE)&m_Revision,
                    sizeof(m_Revision));

    if(ERROR_SUCCESS != err )
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }

    err = RegSetValueEx(hkCertType,
                    wszCTKEYSPEC,
                    NULL,
                    REG_DWORD,
                    (PBYTE)&m_dwKeySpec,
                    sizeof(m_dwKeySpec));

    if(ERROR_SUCCESS != err )
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }
        // Is this a CA


        // Is this a CA
    if(!m_BasicConstraints.fPathLenConstraint)
    {
        m_BasicConstraints.dwPathLenConstraint = -1;
    }

    err = RegSetValueEx(hkCertType,
                    wszBASICCONSTLEN,
                    NULL,
                    REG_DWORD,
                    (PBYTE)&m_BasicConstraints.dwPathLenConstraint,
                    sizeof(m_BasicConstraints.dwPathLenConstraint));

    if(ERROR_SUCCESS != err)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }

    err = RegSetValueEx(hkCertType,
                    wszEXPIRATION,
                    NULL,
                    REG_BINARY,
                    (PBYTE)&m_ftExpiration,
                    sizeof(m_ftExpiration));

    if(ERROR_SUCCESS != err )
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }
    err = RegSetValueEx(hkCertType,
                    wszOVERLAP,
                    NULL,
                    REG_BINARY,
                    (PBYTE)&m_ftOverlap,
                    sizeof(m_ftOverlap));

    if(ERROR_SUCCESS != err )
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }

    if(IsValidSecurityDescriptor(m_pSD))
    {
        cbSD = GetSecurityDescriptorLength(m_pSD);

        err = RegSetValueEx(hkCertType,
                        wszSECURITY,
                        NULL,
                        REG_BINARY,
                        (PBYTE)m_pSD,
                        cbSD);

    }
    else
    {
        err = RegDeleteValue(hkCertType, wszSECURITY);
    }
    if(ERROR_SUCCESS != err )
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }

    //update the V2 template attributes
    if(0 != m_dwSchemaVersion)
    {
        pProp=NULL;
        dwValue=0;

        for(iIndex=0; iIndex < g_CTV2PropertiesCount; iIndex++)
        {
            if(g_CTV2Properties[iIndex].fStringProperty)
            {
                hr = m_pProperties->Find(g_CTV2Properties[iIndex].pwszProperty, &pProp);
                if(hr != S_OK)
                {
                    goto error;
                }

                hr = pProp->UpdateToRegValue(hkCertType, g_CTV2Properties[iIndex].pwszProperty);
                if(hr != S_OK)
                {
                    goto error;
                }

                pProp=NULL;
            }
            else
            {
                //DWORD properties
				if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_MINOR_REVISION)==0)
			        dwValue= m_dwMinorRevision;
				else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_RA_SIGNATURE)==0)
					dwValue= m_dwRASignature;
				else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_RPOP_ENROLLMENT_FLAG)==0)
					dwValue= m_dwEnrollmentFlags;
				else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_PRIVATE_KEY_FLAG)==0)
					dwValue= m_dwPrivateKeyFlags;
				else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_NAME_FLAG)==0)
					dwValue= m_dwCertificateNameFlags;
				else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_MIN_KEY_SIZE)==0)
					dwValue= m_dwMinimalKeySize;
				else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_SCHEMA_VERSION)==0)
					dwValue= m_dwSchemaVersion;
				else
				{
					hr=E_UNEXPECTED;
					goto error;
				}

                err = RegSetValueEx(hkCertType,
                                g_CTV2Properties[iIndex].pwszProperty,
                                NULL,
                                REG_DWORD,
                                (PBYTE)&dwValue,
                                sizeof(dwValue));

                if(ERROR_SUCCESS != err )
                {
                    hr = HRESULT_FROM_WIN32(err);
                    goto error;
                }
            }
        }
    }


error:
    if(awszFriendlyName)
    {
        FreeProperty(awszFriendlyName);
    }
    if(hkCertType)
    {
        RegCloseKey(hkCertType);
    }
    return hr;
}

HRESULT
CCertTypeInfo::_UpdateToDS(VOID)
{

    HRESULT hr = S_OK;
    ULONG   ldaperr;
    LDAP	*pld = NULL;
    LDAPMod modObjectClass,
             modCN,
             modFriendlyName,
             modEKU,
             modCSP,
             modCriticalExts,
             modFlags,
             modKeySpec,
             modSD,
             modKU,
             modMaxDepth,
             modExpiration,
             modOverlap,
             modRevision;
	
	CERT_TYPE_PROP_MOD	rgPropMod[V2_PROPERTY_COUNT];

    LPWSTR   *pwszCSPList = NULL;

	DWORD	iIndex=0;
    DWORD   cMod = 0;
	DWORD	cV2Mod = 0;
    LDAPMod *mods[15 + V2_PROPERTY_COUNT + 1];
    LDAPMod *SDMods[2]={NULL, NULL};     //the security mod
    LPWSTR  pwszOID = NULL;
    LPWSTR  pwszFriendlyName = NULL;



    WCHAR *awszNull[1] = { NULL };

    BYTE RevList = 0;
    DWORD err;
    DWORD cName;

    CERTSTR bstrConfig = NULL;
    CERTSTR bstrDN = NULL;


    TCHAR *valObjectClass[3];

    WCHAR wszFlags[16], *awszFlags[2];
    WCHAR wszRevision[16], *awszRevision[2];
    WCHAR wszKeySpec[16], *awszKeySpec[2];
    WCHAR wszDepth[16], *awszDepth[2];

    struct berval valSD, *avalSD[2];
    struct berval valKU, *avalKU[2];
    struct berval valExpiration, *avalExpiration[2];
    struct berval valOverlap, *avalOverlap[2];

    CHAR sdBerValue[] = {0x30, 0x03, 0x02, 0x01, DACL_SECURITY_INFORMATION |
                                                 OWNER_SECURITY_INFORMATION |
                                                 GROUP_SECURITY_INFORMATION};

    LDAPControl se_info_control =
    {
        LDAP_SERVER_SD_FLAGS_OID_W,
        {
            5, sdBerValue
        },
        TRUE
    };

    LDAPControl permissive_modify_control =
    {
        LDAP_SERVER_PERMISSIVE_MODIFY_OID_W,
        {
            0, NULL
        },
        FALSE
    };


    PLDAPControl    server_controls[3] =
                    {
                        &se_info_control,
                        &permissive_modify_control,
                        NULL
                    };

    // for now, modifies don't try to update owner/group
    CHAR sdBerValueDaclOnly[] = {0x30, 0x03, 0x02, 0x01, DACL_SECURITY_INFORMATION};
    LDAPControl se_info_control_dacl_only =
    {
        LDAP_SERVER_SD_FLAGS_OID_W,
        {
            5, sdBerValueDaclOnly
        },
        TRUE
    };
    PLDAPControl    server_controls_dacl_only[3] =
                    {
                        &se_info_control_dacl_only,
                        &permissive_modify_control,
                        NULL
                    };



    modCN.mod_values = NULL;
    modFriendlyName.mod_values = NULL;
    modEKU.mod_values = NULL;
    modCSP.mod_values = NULL;
    modCriticalExts.mod_values = NULL;

    // short circuit calls to a nonexistant DS
    hr = myDoesDSExist(TRUE);
    _JumpIfError(hr, error, "myDoesDSExist");

    __try
    {
	    // bind to ds
        hr = myRobustLdapBind(&pld, FALSE);

	    if(hr != S_OK)
	    {
	        _LeaveError(hr, "myRobustLdapBind");
	    }
	    hr = CAGetAuthoritativeDomainDn(pld, NULL, &bstrConfig);
	    if(S_OK != hr)
	    {
	        _JumpError(hr, error, "CAGetAuthoritativeDomainDn");
	    }

        bstrDN = CertAllocStringLen(NULL, wcslen(bstrConfig) + wcslen(s_wszLocation)+wcslen(m_bstrType)+4);
        if(bstrDN == NULL)
        {
            hr = E_OUTOFMEMORY;
	        _JumpError(hr, error, "CertAllocStringLen");
        }
        wcscpy(bstrDN, L"CN=");
        wcscat(bstrDN, m_bstrType);
        wcscat(bstrDN, L",");
        wcscat(bstrDN, s_wszLocation);
        wcscat(bstrDN, bstrConfig);

        modObjectClass.mod_op = LDAP_MOD_REPLACE;
        modObjectClass.mod_type = TEXT("objectclass");
        modObjectClass.mod_values = valObjectClass;
        valObjectClass[0] = wszDSTOPCLASSNAME;
        valObjectClass[1] = wszDSTEMPLATELASSNAME;
        valObjectClass[2] = NULL;
        mods[cMod++] = &modObjectClass;

        modCN.mod_op = LDAP_MOD_REPLACE;
        modCN.mod_type = CERTTYPE_PROP_CN;
        hr = GetProperty(CERTTYPE_PROP_CN, &modCN.mod_values);
        if((hr != S_OK) || (modCN.mod_values == NULL) || (modCN.mod_values[0] == NULL))
        {
            if(modCN.mod_values)
            {
                FreeProperty(modCN.mod_values);
            }

	        modCN.mod_values = awszNull;

            if(!m_fNew)
            {
                mods[cMod++] = &modCN;
            }
        }
        else
        {
            mods[cMod++] = &modCN;
        }

        modFriendlyName.mod_op = LDAP_MOD_REPLACE;
        modFriendlyName.mod_type = CERTTYPE_PROP_FRIENDLY_NAME;
        hr = GetProperty(CERTTYPE_PROP_FRIENDLY_NAME, &modFriendlyName.mod_values);
        if((hr != S_OK) || (modFriendlyName.mod_values == NULL) || (modFriendlyName.mod_values[0] == NULL))
        {
            if(modFriendlyName.mod_values)
            {
                FreeProperty(modFriendlyName.mod_values);
            }
	        modFriendlyName.mod_values = awszNull;
            if(!m_fNew)
            {
                mods[cMod++] = &modFriendlyName;
            }
        }
        else
        {
            //we copy the friendly name
            pwszFriendlyName = modFriendlyName.mod_values[0];
            mods[cMod++] = &modFriendlyName;
        }

        modEKU.mod_op = LDAP_MOD_REPLACE;
        modEKU.mod_type = CERTTYPE_PROP_EXTENDED_KEY_USAGE;
        hr = GetProperty(CERTTYPE_PROP_EXTENDED_KEY_USAGE, &modEKU.mod_values);
        if((hr != S_OK) || (modEKU.mod_values == NULL) || (modEKU.mod_values[0] == NULL))
        {
            if(modEKU.mod_values)
            {
                FreeProperty(modEKU.mod_values);
            }
	        modEKU.mod_values = awszNull;
            if(!m_fNew)
            {
                mods[cMod++] = &modEKU;
            }
        }
        else
        {
            mods[cMod++] = &modEKU;
        }

        modCSP.mod_op = LDAP_MOD_REPLACE;
        modCSP.mod_type = CERTTYPE_PROP_CSP_LIST;
        hr = GetProperty(CERTTYPE_PROP_CSP_LIST, &pwszCSPList);
        if((hr != S_OK) || (pwszCSPList == NULL) || (pwszCSPList[0] == NULL))
        {
	    modCSP.mod_values = awszNull;
            if(!m_fNew)
            {
                mods[cMod++] = &modCSP;
            }
        }
        else
        {
            DWORD cCSPs = 0;
            DWORD i;
            LPWSTR *pwszCurrent = pwszCSPList;
            while(*pwszCurrent)
            {
                cCSPs++;
                pwszCurrent++;
            }

            modCSP.mod_values = (LPWSTR *)LocalAlloc(LMEM_FIXED, sizeof(LPWSTR)*(cCSPs+1));
            if(modCSP.mod_values == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto error;
            }
            ZeroMemory(modCSP.mod_values, sizeof(LPWSTR)*(cCSPs+1));

            i=0;
            pwszCurrent = pwszCSPList;
            while(*pwszCurrent)
            {

                modCSP.mod_values[i] = (LPWSTR)LocalAlloc(LMEM_FIXED, sizeof(WCHAR)*(wcslen(*pwszCurrent)+6));
                if(modCSP.mod_values[i] == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto error;
                }
                wsprintf(modCSP.mod_values[i], L"%d,%ws",i+1, *pwszCurrent);
                pwszCurrent++;
                i++;
            }

            mods[cMod++] = &modCSP;
        }

        modCriticalExts.mod_op = LDAP_MOD_REPLACE;
        modCriticalExts.mod_type = CERTTYPE_PROP_CRITICAL_EXTENSIONS;
        hr = GetProperty(CERTTYPE_PROP_CRITICAL_EXTENSIONS, &modCriticalExts.mod_values);
        if((hr != S_OK) || (modCriticalExts.mod_values == NULL) || (modCriticalExts.mod_values[0] == NULL))
        {
            if(modCriticalExts.mod_values)
            {
                FreeProperty(modCriticalExts.mod_values);
            }
	        modCriticalExts.mod_values = awszNull;
            if(!m_fNew)
            {
            	mods[cMod++] = &modCriticalExts;
            }
        }
        else
        {
            mods[cMod++] = &modCriticalExts;
        }


        modFlags.mod_op = LDAP_MOD_REPLACE;
        modFlags.mod_type = CERTTYPE_PROP_FLAGS;
        modFlags.mod_values = awszFlags;
        awszFlags[0] = wszFlags;
        awszFlags[1] = NULL;
        wsprintf(wszFlags, L"%d", m_dwFlags);
        mods[cMod++] = &modFlags;

        modRevision.mod_op = LDAP_MOD_REPLACE;
        modRevision.mod_type = CERTTYPE_PROP_REVISION;
        modRevision.mod_values = awszRevision;
        awszRevision[0] = wszRevision;
        awszRevision[1] = NULL;
        wsprintf(wszRevision, L"%d", m_Revision);
        mods[cMod++] = &modRevision;

        modKeySpec.mod_op = LDAP_MOD_REPLACE;
        modKeySpec.mod_type = CERTTYPE_PROP_DEFAULT_KEYSPEC;
        modKeySpec.mod_values = awszKeySpec;
        awszKeySpec[0] = wszKeySpec;
        awszKeySpec[1] = NULL;
        wsprintf(wszKeySpec, L"%d", m_dwKeySpec);
        mods[cMod++] = &modKeySpec;

        modSD.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_REPLACE;
        modSD.mod_type = CERTTYPE_SECURITY_DESCRIPTOR_NAME;
        modSD.mod_bvalues = avalSD;
        avalSD[0] = &valSD;
        avalSD[1] = NULL;
        if(IsValidSecurityDescriptor(m_pSD))
        {
            valSD.bv_len = GetSecurityDescriptorLength(m_pSD);
            valSD.bv_val = (char *)m_pSD;
            mods[cMod++] = &modSD;
            SDMods[0]=&modSD;
        }
        else
        {
            modSD.mod_bvalues = NULL;
            if(!m_fNew)
            {
                mods[cMod++] = &modSD;
                SDMods[0]=&modSD;
            }
        }

        modKU.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_REPLACE;
        modKU.mod_type = CERTTYPE_PROP_KU;
        modKU.mod_bvalues = avalKU;
        avalKU[0] = &valKU;
        avalKU[1] = NULL;
        valKU.bv_len = m_KeyUsage.cbData;
        valKU.bv_val = (char *)m_KeyUsage.pbData;
        mods[cMod++] = &modKU;

        modMaxDepth.mod_op = LDAP_MOD_REPLACE;
        modMaxDepth.mod_type = CERTTYPE_PROP_MAX_DEPTH;
        modMaxDepth.mod_values = awszDepth;
        awszDepth[0] = wszDepth;
        awszDepth[1] = NULL;
        wsprintf(wszDepth, L"%d", m_BasicConstraints.dwPathLenConstraint);
        mods[cMod++] = &modMaxDepth;

        modExpiration.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_REPLACE;
        modExpiration.mod_type = CERTTYPE_PROP_EXPIRATION;
        modExpiration.mod_bvalues = avalExpiration;
        avalExpiration[0] = &valExpiration;
        avalExpiration[1] = NULL;
        valExpiration.bv_len = sizeof(m_ftExpiration);
        valExpiration.bv_val = (char *)&m_ftExpiration;
        mods[cMod++] = &modExpiration;

        modOverlap.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_REPLACE;
        modOverlap.mod_type = CERTTYPE_PROP_OVERLAP;
        modOverlap.mod_bvalues = avalOverlap;
        avalOverlap[0] = &valOverlap;
        avalOverlap[1] = NULL;
        valOverlap.bv_len = sizeof(m_ftOverlap);
        valOverlap.bv_val = (char *)&m_ftOverlap;
        mods[cMod++] = &modOverlap;
		
		//mark the end of V1 properties and start processing V2 properties
        // mods[cMod++] = NULL;
		cV2Mod=cMod;

		if(V2_PROPERTY_COUNT != g_CTV2PropertiesCount)
		{
			hr = E_UNEXPECTED;
			goto error;
		}

		memset(rgPropMod, 0, sizeof(CERT_TYPE_PROP_MOD) * V2_PROPERTY_COUNT);
		for(iIndex=0; iIndex < g_CTV2PropertiesCount; iIndex++)
		{
			rgPropMod[iIndex].modData.mod_op = LDAP_MOD_REPLACE;
			rgPropMod[iIndex].modData.mod_type = g_CTV2Properties[iIndex].pwszProperty;

			if(g_CTV2Properties[iIndex].fStringProperty)
			{
				//update the LPWSTR properties
				hr = GetPropertyEx(g_CTV2Properties[iIndex].pwszProperty,
								&(rgPropMod[iIndex].modData.mod_values));

				if((hr != S_OK) || (rgPropMod[iIndex].modData.mod_values == NULL) || (rgPropMod[iIndex].modData.mod_values[0] == NULL))
				{
					if(rgPropMod[iIndex].modData.mod_values)
					{
						FreeProperty(rgPropMod[iIndex].modData.mod_values);
					}

					rgPropMod[iIndex].modData.mod_values = awszNull;

					if(!m_fNew)
					{
						mods[cMod++] = &(rgPropMod[iIndex].modData);
					}
				}
				else
				{
                    //we copy the OID value
                    if(0 == wcscmp(CERTTYPE_PROP_OID, g_CTV2Properties[iIndex].pwszProperty))
                        pwszOID = rgPropMod[iIndex].modData.mod_values[0];

					mods[cMod++] = &(rgPropMod[iIndex].modData);
				}
			}
			else
			{
				//update the DWORD properties
				if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_MINOR_REVISION)==0)
					rgPropMod[iIndex].dwData= m_dwMinorRevision;
				else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_RA_SIGNATURE)==0)
					rgPropMod[iIndex].dwData= m_dwRASignature;
				else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_RPOP_ENROLLMENT_FLAG)==0)
					rgPropMod[iIndex].dwData= m_dwEnrollmentFlags;
				else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_PRIVATE_KEY_FLAG)==0)
					rgPropMod[iIndex].dwData= m_dwPrivateKeyFlags;
				else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_NAME_FLAG)==0)
					rgPropMod[iIndex].dwData= m_dwCertificateNameFlags;
				else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_MIN_KEY_SIZE)==0)
					rgPropMod[iIndex].dwData= m_dwMinimalKeySize;
				else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_SCHEMA_VERSION)==0)
					rgPropMod[iIndex].dwData= m_dwSchemaVersion;
				else
				{
					hr=E_UNEXPECTED;
					goto error;
				}

				rgPropMod[iIndex].modData.mod_values = rgPropMod[iIndex].awszData;
				rgPropMod[iIndex].awszData[0] = rgPropMod[iIndex].wszData;
				rgPropMod[iIndex].awszData[1] = NULL;
				wsprintf(rgPropMod[iIndex].wszData, L"%d", rgPropMod[iIndex].dwData);
				mods[cMod++] = &(rgPropMod[iIndex].modData);
			}
		}

		//mark the end of V2 properties
        mods[cMod++] = NULL;

        //we should work with both V1 and V2 schema
        if(0 == m_dwSchemaVersion)
            mods[cV2Mod]=NULL;

	    //update the DS with V1 and V2 changes
        if(m_fNew)
        {
            ldaperr = ldap_add_ext_sW(pld, bstrDN, mods, server_controls, NULL);
			_PrintIfError(ldaperr, "ldap_add_s");
        }
        else
        {
            //we do the security descriptor first
            ldaperr = ldap_modify_ext_sW(pld,
                  bstrDN,
                  SDMods,
                  server_controls_dacl_only,
                  NULL);  // skip past objectClass and cn 

            ldaperr = ldap_modify_ext_sW(pld,
                  bstrDN,
                  &mods[2],
                  server_controls_dacl_only,
                  NULL);  // skip past objectClass and cn

            if(LDAP_ATTRIBUTE_OR_VALUE_EXISTS == ldaperr)
            {
                ldaperr = LDAP_SUCCESS;
            }
			_PrintIfError(ldaperr, "ldap_modify_ext_sW");
        }

        if (LDAP_SUCCESS != ldaperr && LDAP_ALREADY_EXISTS != ldaperr)
        {
            //error out if this is a V2 template
            if(CERTTYPE_SCHEMA_VERSION_2 <= m_dwSchemaVersion )
            {
		        hr = myHLdapError(pld, ldaperr, NULL);
		        _LeaveError(ldaperr, m_fNew? "ldap_add_s" : "ldap_modify_sW");
            }

 	        //This will work with both W2K schema and W2K+ schema
	        mods[cV2Mod]=NULL;


      		if(m_fNew)
        	{
            	ldaperr = ldap_add_ext_sW(pld, bstrDN, mods, server_controls, NULL);
			    _PrintIfError(ldaperr, "ldap_add_s");
        	}
        	else
        	{
            		ldaperr = ldap_modify_ext_sW(pld,
                  		bstrDN,
                  		&mods[2],
                  		server_controls_dacl_only,
                  		NULL);  // skip past objectClass and cn
            		if(LDAP_ATTRIBUTE_OR_VALUE_EXISTS == ldaperr)
            		{
                		ldaperr = LDAP_SUCCESS;
            		}
			        _PrintIfError(ldaperr, "ldap_modify_ext_sW");
        	}

        	if (LDAP_SUCCESS != ldaperr && LDAP_ALREADY_EXISTS != ldaperr)
        	{

			hr = myHLdapError(pld, ldaperr, NULL);
			_LeaveError(ldaperr, m_fNew? "ldap_add_s" : "ldap_modify_sW");
		    }
        }

        //we update the OID information on the DS
        if(pwszOID)
        {
 	        //This will work with both W2K schema and W2K+ schema

            //we only update the OID friendly name for user created OIDs and
            //default V2 template
            if(CERTTYPE_SCHEMA_VERSION_2 <= m_dwSchemaVersion)
            {
                I_CAOIDAdd(
                        CERT_OID_TYPE_TEMPLATE,
                        0,
                        pwszOID);

                I_CAOIDSetProperty(
                        pwszOID,
                        CERT_OID_PROPERTY_DISPLAY_NAME,
                        pwszFriendlyName);
            }
        }

        m_fNew = FALSE;
        hr = S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:


    if (NULL != modCN.mod_values && awszNull != modCN.mod_values)
    {
        FreeProperty(modCN.mod_values);
    }
    if (NULL != modFriendlyName.mod_values && awszNull != modFriendlyName.mod_values)
    {
        FreeProperty(modFriendlyName.mod_values);
    }
    if (NULL != modEKU.mod_values && awszNull != modEKU.mod_values)
    {
        FreeProperty(modEKU.mod_values);
    }
    if (NULL != pwszCSPList)
    {
        FreeProperty(pwszCSPList);
    }

    if((NULL != modCSP.mod_values) && (awszNull != modCSP.mod_values))
    {
        LPWSTR *pwszCurrent = modCSP.mod_values;
        while(*pwszCurrent)
        {
            LocalFree(*pwszCurrent++);
        }
        LocalFree(modCSP.mod_values);
    }

    if (NULL != modCriticalExts.mod_values && awszNull != modCriticalExts.mod_values)
    {
        FreeProperty(modCriticalExts.mod_values);
    }

	//free V2 properties
	for(iIndex=0; iIndex < V2_PROPERTY_COUNT; iIndex++)
	{
		if( (NULL != rgPropMod[iIndex].modData.mod_values) &&
			(awszNull != rgPropMod[iIndex].modData.mod_values) &&
			(g_CTV2Properties[iIndex].fStringProperty))
			FreeProperty(rgPropMod[iIndex].modData.mod_values);
	}


    if(bstrDN)
    {
        CertFreeString(bstrDN);
    }
    if(bstrConfig)
    {
        CertFreeString(bstrConfig);
    }

    if (NULL != pld)
    {
        ldap_unbind(pld);
    }
    return(hr);
}




//+--------------------------------------------------------------------------
// CCertTypeInfo::Delete -- Delete CertType Object
//
//
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::Delete(VOID)

{
    HRESULT hr = S_OK;
    DWORD   err=0;
    HKEY    hCertTypeCache = NULL;
    DWORD   disp;
    LDAP    *pld = NULL;
    ULONG   ldaperr;

    CERTSTR bstrConfig = NULL;
    CERTSTR bstrDN = NULL;


    // Delete From DS;
    __try
    {
	    // bind to ds
        hr = myRobustLdapBind(&pld, FALSE);

	    if(hr != S_OK)
	    {
	        _LeaveError(hr, "myRobustLdapBind");
	    }
	    hr = CAGetAuthoritativeDomainDn(pld, NULL, &bstrConfig);
	    if(S_OK != hr)
	    {
	        _LeaveError(hr, "CAGetAuthoritativeDomainDn");
	    }

        bstrDN = CertAllocStringLen(NULL, wcslen(bstrConfig) + wcslen(s_wszLocation)+wcslen(m_bstrType)+4);
        if(bstrDN == NULL)
        {
            hr = E_OUTOFMEMORY;
	        _LeaveError(hr, "CertAllocStringLen");
        }
        wcscpy(bstrDN, L"CN=");
        wcscat(bstrDN, m_bstrType);
        wcscat(bstrDN, L",");
        wcscat(bstrDN, s_wszLocation);
        wcscat(bstrDN, bstrConfig);

        ldaperr = ldap_delete_s(pld, bstrDN);
	hr = myHLdapError(pld, ldaperr, NULL);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

    if(hr != S_OK)
    {
        goto error;
    }

    // Delete from local cache

    err = RegCreateKeyEx((m_fLocalSystemCache)?HKEY_LOCAL_MACHINE:HKEY_CURRENT_USER,
                         wszCERTTYPECACHE,
                         NULL,
                         TEXT(""),
                         REG_OPTION_NON_VOLATILE,
                           KEY_ENUMERATE_SUB_KEYS |
                           KEY_EXECUTE |
                           KEY_QUERY_VALUE,
                         NULL,
                         &hCertTypeCache,
                         &disp);

    if(err != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }


    err = RegDeleteKey(hCertTypeCache, m_bstrType);

    if(err != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }

    hr=S_OK;

error:
    if (NULL != pld)
    {
        ldap_unbind(pld);
    }

    if(hCertTypeCache)
    {
        RegCloseKey(hCertTypeCache);
    }
    if(bstrDN)
    {
        CertFreeString(bstrDN);
    }
    if(bstrConfig)
    {
        CertFreeString(bstrConfig);
    }
    return hr;

}




//+--------------------------------------------------------------------------
// CCertTypeInfo::Next -- Returns the next object in the chain of CA objects
//
//
//+--------------------------------------------------------------------------

HRESULT CCertTypeInfo::Next(CCertTypeInfo **ppCTInfo)
{
    if(ppCTInfo == NULL)
    {
        return E_POINTER;
    }
    *ppCTInfo = m_pNext;
    if(m_pNext)
    {
        m_pNext->AddRef();
    }
    return S_OK;
}

//+--------------------------------------------------------------------------
// CCertTypeInfo::GetProperty -- Retrieves the values of a property of the CA object
//
//
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::GetProperty(
    LPCWSTR wszPropertyName,
    LPWSTR **pawszProperties)
{
    CCAProperty *pProp;
    HRESULT     hr;
    LPWSTR      *awszResult = NULL;
    UINT        idsDescription=IDS_UNKNOWN_DESCRIPTION;
    DWORD       dwIndex=0;
    DWORD       cbOID=0;

    if((wszPropertyName == NULL) || (pawszProperties == NULL))
    {
        return  E_POINTER;
    }

    //special case for eku for V2 template.  We return application policy
    //for EKU for V2 template
    if(m_dwSchemaVersion >= CERTTYPE_SCHEMA_VERSION_2)
    {
        if(0==lstrcmpi(wszPropertyName, CERTTYPE_PROP_EXTENDED_KEY_USAGE))
        {
            wszPropertyName=CERTTYPE_PROP_APPLICATION_POLICY;
        }

    }

    //special case for description, which is a derived property
    if(0==lstrcmpi(wszPropertyName, CERTTYPE_PROP_DESCRIPTION))
    {
        WCHAR * wszDescription=NULL;

        //find the string that matches the template
        for(dwIndex=0; dwIndex < g_CTDescriptionCount; dwIndex++)
        {
            if(
                (g_CTDescriptions[dwIndex].dwGeneralValue == (CERT_TYPE_GENERAL_FILTER & GetFlags(CERTTYPE_GENERAL_FLAG))) &&
                (g_CTDescriptions[dwIndex].dwEnrollValue == (CERT_TYPE_ENROLL_FILTER & GetFlags(CERTTYPE_ENROLLMENT_FLAG))) &&
                (g_CTDescriptions[dwIndex].dwNameValue == (CERT_TYPE_NAME_FILTER & GetFlags(CERTTYPE_SUBJECT_NAME_FLAG)))
              )
            {
                idsDescription = g_CTDescriptions[dwIndex].idsDescription;
                break;
            }
        }

        // load the string and build a result like GetValue returns
        hr=myLoadRCString(g_hInstance, idsDescription, &wszDescription);

        if (S_OK!=hr)
            return hr;

        awszResult=(WCHAR **)LocalAlloc(LPTR, (UINT)(sizeof(WCHAR *)*2+(wcslen(wszDescription)+1)*sizeof(WCHAR)));
        if (NULL==awszResult)
        {
            LocalFree(wszDescription);
            return E_OUTOFMEMORY;
        }

        awszResult[0]=(WCHAR *)(&awszResult[2]);
        awszResult[1]=NULL;
        wcscpy(awszResult[0], wszDescription);
        LocalFree(wszDescription);
        *pawszProperties=awszResult;
        return S_OK;
    }

    // special case for friendly name, since in a multi-lingual enterprise,
    // the language in the DS may not be the one we want.

    if (0 == lstrcmpi(wszPropertyName, CERTTYPE_PROP_FRIENDLY_NAME))
    {
        // find the common name
        hr = m_pProperties->Find(CERTTYPE_PROP_CN, &pProp);
        if (S_OK!=hr)
        {
            return hr;
        }
        hr = pProp->GetValue(&awszResult);
        if (NULL == awszResult && S_OK == hr)
	    {
           hr = E_UNEXPECTED;
	    }
        if (hr!=S_OK)
        {
            return hr;
        }

        // find the common name in our table

        unsigned int nIndex;
        for (nIndex=0; nIndex<g_cDefaultCertTypes; nIndex++)
        {
            if (0==lstrcmpi(awszResult[0] , g_aDefaultCertTypes[nIndex].wszName))
            {
                break;
            }
        }
        FreeProperty(awszResult);
        awszResult = NULL;

        // we found it
        if (g_cDefaultCertTypes!=nIndex)
        {
            WCHAR * wszFriendlyName;

            // load the string and build a result like GetValue returns
            hr=myLoadRCString(g_hInstance, g_aDefaultCertTypes[nIndex].idFriendlyName, &wszFriendlyName);
            if (S_OK!=hr)
            {
                return hr;
            }
            awszResult=(WCHAR **)LocalAlloc(LPTR, (UINT)(sizeof(WCHAR *)*2+(wcslen(wszFriendlyName)+1)*sizeof(WCHAR)));
            if (NULL==awszResult)
            {
                LocalFree(wszFriendlyName);
                return E_OUTOFMEMORY;
            }
            awszResult[0]=(WCHAR *)(&awszResult[2]);
            awszResult[1]=NULL;
            wcscpy(awszResult[0], wszFriendlyName);
            LocalFree(wszFriendlyName);
            *pawszProperties=awszResult;
            return S_OK;
        }
        else
        {
            PCCRYPT_OID_INFO    pOIDInfo=NULL;
            LPSTR               szOID=NULL;

            //this is a custom created certificate template.
            //so we have to find the friendly name based on the OID
            // find the OID for the template
            if(m_dwSchemaVersion >= CERTTYPE_SCHEMA_VERSION_2)
            {
                if(S_OK != (hr = m_pProperties->Find(CERTTYPE_PROP_OID, &pProp)))
                    return hr;

                hr = pProp->GetValue(&awszResult);
                if((NULL == awszResult) || (NULL==awszResult[0]))
                   hr = E_UNEXPECTED;

                if (S_OK != hr)
                {
                    if(awszResult)
                        FreeProperty(awszResult);
                    return hr;
                }

                //find the OID
                if(0 == (cbOID = WideCharToMultiByte(CP_ACP,
                                          0,
                                          awszResult[0],
                                          -1,
                                          NULL,
                                          0,
                                          NULL,
                                          NULL)))
                {
                    FreeProperty(awszResult);
                    hr = GetLastError();
                    return hr;
                }

                szOID=(LPSTR)LocalAlloc(LPTR, cbOID);

                if(NULL==szOID)
                {
                    FreeProperty(awszResult);
                    hr = E_OUTOFMEMORY;
                    return hr;
                }

                if(0 == WideCharToMultiByte(CP_ACP,
                                          0,
                                          awszResult[0],
                                          -1,
                                          szOID,
                                          cbOID,
                                          NULL,
                                          NULL))
                {
                    hr = GetLastError();
                    FreeProperty(awszResult);
                    LocalFree(szOID);
                    return hr;
                }

                pOIDInfo=CryptFindOIDInfo(
                            CRYPT_OID_INFO_OID_KEY,
                            szOID,
                            CRYPT_TEMPLATE_OID_GROUP_ID);

                //free the OID property
                FreeProperty(awszResult);
                awszResult = NULL;

                LocalFree(szOID);
                szOID=NULL;

                if(pOIDInfo)
                {
                    if(pOIDInfo->pwszName)
                    {
                        awszResult=(WCHAR **)LocalAlloc(LPTR, (UINT)(sizeof(WCHAR *)*2+(wcslen(pOIDInfo->pwszName)+1)*sizeof(WCHAR)));
                        if (NULL==awszResult)
                            return E_OUTOFMEMORY;

                        awszResult[0]=(WCHAR *)(&awszResult[2]);
                        awszResult[1]=NULL;
                        wcscpy(awszResult[0], pOIDInfo->pwszName);
                        *pawszProperties=awszResult;
                        return S_OK;
                    }
                }
            }
        }
    }

    hr = m_pProperties->Find(wszPropertyName, &pProp);

    if(hr != S_OK)
    {
        return hr;
    }

    hr = pProp->GetValue(&awszResult);

    if(hr != S_OK)
    {
        return hr;
    }

    if(((awszResult == NULL) || (awszResult[0] == NULL)) &&
        (lstrcmpi(wszPropertyName, CERTTYPE_PROP_FRIENDLY_NAME) == 0))
    {
        if(awszResult)
        {
            FreeProperty(awszResult);
            awszResult=NULL;
        }
        return GetProperty(CERTTYPE_PROP_CN, pawszProperties);
    }
    else
    {
        *pawszProperties = awszResult;
        return hr;
    }
}


//+--------------------------------------------------------------------------
// IsV2Property
//
//
//+--------------------------------------------------------------------------
BOOL    IsV2Property(LPCWSTR pwszPropertyName)
{
    DWORD   iIndex=0;
    BOOL    fV2=FALSE;

    for(iIndex=0; iIndex < g_CTV2PropertiesCount; iIndex++)
    {
        if(0==lstrcmpi(pwszPropertyName, g_CTV2Properties[iIndex].pwszProperty))
        {
            fV2=TRUE;
            break;
        }
    }

    return fV2;
}

//+--------------------------------------------------------------------------
// CCertTypeInfo::GetPropertyEx -- Retrieves the values of a property of the CA object
//
//
//+--------------------------------------------------------------------------
HRESULT CCertTypeInfo::GetPropertyEx(LPCWSTR wszPropertyName, LPVOID   pPropertyValue)
{
    HRESULT hr=S_OK;
    LPWSTR  *pwszValue=NULL;

    if((NULL==wszPropertyName) || (NULL==pPropertyValue))
        return E_POINTER;

    //we only allow schema version to be returned for v1 templates
    if((0 == m_dwSchemaVersion) && (IsV2Property(wszPropertyName)))
    {
        if(lstrcmpi(wszPropertyName, CERTTYPE_PROP_SCHEMA_VERSION)==0)
        {
            *((DWORD *)pPropertyValue)=CERTTYPE_SCHEMA_VERSION_1;
            return S_OK;
        }
        return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }

	if(lstrcmpi(wszPropertyName, CERTTYPE_PROP_MINOR_REVISION)==0)
		*((DWORD *)pPropertyValue)=m_dwMinorRevision;
	else if(lstrcmpi(wszPropertyName, CERTTYPE_PROP_RA_SIGNATURE)==0)
		*((DWORD *)pPropertyValue)=m_dwRASignature;
	else if(lstrcmpi(wszPropertyName, CERTTYPE_PROP_MIN_KEY_SIZE)==0)
		*((DWORD *)pPropertyValue)=m_dwMinimalKeySize;
	else if(lstrcmpi(wszPropertyName, CERTTYPE_PROP_SCHEMA_VERSION)==0)
		*((DWORD *)pPropertyValue)=m_dwSchemaVersion;
	else if(lstrcmpi(wszPropertyName, CERTTYPE_PROP_REVISION)==0)
		*((DWORD *)pPropertyValue)=m_Revision;
	else
	{
		hr=GetProperty(wszPropertyName, (LPWSTR **)pPropertyValue);

	}

    return hr;
}


//+--------------------------------------------------------------------------
// CCertTypeInfo::SetProperty -- set the values of a property of the CA object
//
//  Obsolete
//+--------------------------------------------------------------------------

HRESULT CCertTypeInfo::SetProperty(LPCWSTR wszPropertyName, LPWSTR *awszProperties)
{
    CCAProperty *pProp=NULL;
    CCAProperty *pOIDProp=NULL;
    HRESULT     hr=E_FAIL;

    if(wszPropertyName == NULL)
    {
        return  E_POINTER;
    }

    hr = m_pProperties->Find(wszPropertyName, &pProp);

    if(hr != S_OK)
    {
        pProp = new CCAProperty(wszPropertyName);
        if(pProp == NULL)
        {
            return E_OUTOFMEMORY;
        }
        pProp->SetValue(awszProperties);
        hr=CCAProperty::Append(&m_pProperties, pProp);
    }
    else
    {
        hr=pProp->SetValue(awszProperties);
    }

    return hr;
}

//+--------------------------------------------------------------------------
// CCertTypeInfo::SetPropertyEx -- set the values of a property of the CA object
//
//  If CERTTYPE_PROP_CN is set, the certificate type is a clone if the existing one.
//
//+--------------------------------------------------------------------------
HRESULT CCertTypeInfo::SetPropertyEx(LPCWSTR wszPropertyName, LPVOID   pPropertyValue)
{
    HRESULT     hr=S_OK;
    LPWSTR      awszValue[2];

    LPWSTR      *awszCN=NULL;
    LPWSTR      *awszEKU=NULL;
    LPWSTR      pwszOID=NULL;

    if(NULL==wszPropertyName)
        return E_POINTER;

    //SCHEMA VERSION and DN are not settable
    if((lstrcmpi(wszPropertyName, CERTTYPE_PROP_SCHEMA_VERSION)==0) ||
       (lstrcmpi(wszPropertyName, CERTTYPE_PROP_DN)==0)
      )
      return E_UNEXPECTED;

    if((m_dwSchemaVersion < CERTTYPE_SCHEMA_VERSION_2) && (IsV2Property(wszPropertyName)))
        return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);

    //check if CN is going to be changed
    if(lstrcmpi(wszPropertyName, CERTTYPE_PROP_CN)==0)
    {
        if(NULL == pPropertyValue)
            return E_POINTER;

        if(NULL == ((LPWSTR *)pPropertyValue)[0])
            return E_POINTER;

        if(S_OK != (hr=GetPropertyEx(wszPropertyName, &awszCN)))
            return hr;
    }

	if(lstrcmpi(wszPropertyName, CERTTYPE_PROP_MINOR_REVISION)==0)
		m_dwMinorRevision=*((DWORD *)pPropertyValue);
	else if(lstrcmpi(wszPropertyName, CERTTYPE_PROP_RA_SIGNATURE)==0)
		m_dwRASignature=*((DWORD *)pPropertyValue);
	else if(lstrcmpi(wszPropertyName, CERTTYPE_PROP_MIN_KEY_SIZE)==0)
		m_dwMinimalKeySize=*((DWORD *)pPropertyValue);
	else if(lstrcmpi(wszPropertyName, CERTTYPE_PROP_SCHEMA_VERSION)==0)
		m_dwSchemaVersion=*((DWORD *)pPropertyValue);
	else if(lstrcmpi(wszPropertyName, CERTTYPE_PROP_REVISION)==0)
		m_Revision=*((DWORD *)pPropertyValue);
	else
    {
        hr=SetProperty(wszPropertyName, (LPWSTR *)pPropertyValue);

        //check if CN is changed.
        if((S_OK == hr) && (awszCN))
        {
            if((awszCN[0]) && (0!=lstrcmpi(awszCN[0],((LPWSTR *)pPropertyValue)[0])))
            {
                if(m_bstrType)
                {
                    CertFreeString(m_bstrType);
                    m_bstrType = NULL;
                }

                m_bstrType = CertAllocString(((LPWSTR *)pPropertyValue)[0]);
                if(NULL==m_bstrType)
                    hr=E_OUTOFMEMORY;

                if(S_OK == hr)
                    hr=SetProperty(CERTTYPE_PROP_DN, (LPWSTR *)pPropertyValue);

                if(S_OK == hr)
                {
                    m_fNew=TRUE;
                    m_dwFlags &= CT_MASK_SETTABLE_FLAGS;
                    m_Revision=CERTTYPE_VERSION_NEXT;

                    //we upgrade the schema if necessary
                    //and move the EKU property to the application policy property
                    if(m_dwSchemaVersion < CERTTYPE_SCHEMA_VERSION_2)
                    {
                        if(S_OK == GetProperty(CERTTYPE_PROP_EXTENDED_KEY_USAGE, &awszEKU))
                            SetProperty(CERTTYPE_PROP_APPLICATION_POLICY, awszEKU);
                    	m_dwSchemaVersion=CERTTYPE_SCHEMA_VERSION_2;
                    }

                    //we get a new OID for the certificate template
                    hr=I_CAOIDCreateNew(CERT_OID_TYPE_TEMPLATE, 0, &pwszOID);

                    if(S_OK == hr)
                    {
                        awszValue[0]=pwszOID;
                        awszValue[1]=NULL;
                        hr=SetProperty(CERTTYPE_PROP_OID, awszValue);
                    }

                    //we then set the displayName property to NULL
                    if(S_OK == hr)
                    {
                        awszValue[0]=NULL;
                        hr=SetProperty(CERTTYPE_PROP_FRIENDLY_NAME, awszValue);
                    }

                }
            }
        }
    }

    if(awszEKU)
        FreeProperty(awszEKU);

    if(awszCN)
        FreeProperty(awszCN);

    if(pwszOID)
        LocalFree(pwszOID);

    return hr;
}


//+--------------------------------------------------------------------------
// CCertTypeInfo::FreeProperty -- Free's a previously returned property array
//
//
//+--------------------------------------------------------------------------

HRESULT CCertTypeInfo::FreeProperty(LPWSTR *pawszProperties)
{
    LocalFree(pawszProperties);
    return S_OK;
}


//+--------------------------------------------------------------------------
// MapFlags
//
//
//+--------------------------------------------------------------------------

DWORD   MapFlags(CERT_TYPE_FLAG_MAP *rgdwMap, DWORD cbSize, DWORD dwGeneralFlags)
{
    DWORD iIndex=0;
    DWORD dwFlags=0;

    for(iIndex=0; iIndex<cbSize; iIndex++)
    {
        if(rgdwMap[iIndex].dwOldFlag & dwGeneralFlags)
            dwFlags |= rgdwMap[iIndex].dwNewFlag;
    }

    return dwFlags;
}

//+--------------------------------------------------------------------------
// CCertTypeInfo::GetFlags
//
//
//+--------------------------------------------------------------------------

DWORD CCertTypeInfo::GetFlags(DWORD    dwOption)
{
    DWORD           dwFlags=0;
    HRESULT         hr=S_OK; 
    DWORD           dwIndex=0;
    CCAProperty     *pProp=NULL;

    LPWSTR          *awszResult = NULL;

    //we want to map the flags for old schema
    if(0 == m_dwSchemaVersion)
    {
        switch(dwOption)
        {
            case CERTTYPE_ENROLLMENT_FLAG:
                   dwFlags = MapFlags(g_rgdwEnrollFlagMap, g_cEnrollFlagMap, m_dwFlags);
                break;

            case CERTTYPE_SUBJECT_NAME_FLAG:
                   dwFlags = MapFlags(g_rgdwSubjectFlagMap, g_cSubjectFlagMap, m_dwFlags);

                   //we will try to get the subject name flag from our table, since
                   //new CA policy module needs the extra flags
                   if(m_pProperties)
                   {
                       if(S_OK == m_pProperties->Find(CERTTYPE_PROP_CN, &pProp))
                       {
                            if(S_OK == pProp->GetValue(&awszResult))
                            {
                                if((awszResult) && (awszResult[0]))
                                {
                                    // find the common name in our table
                                    for(dwIndex=0; dwIndex < g_cDefaultCertTypes; dwIndex++)
                                    {
                                        if(0==lstrcmpi(awszResult[0] , g_aDefaultCertTypes[dwIndex].wszName))
                                        {
                                            dwFlags=g_aDefaultCertTypes[dwIndex].dwCertificateNameFlags;
                                            break;
                                        }
                                    }
                                }
                            }

                            if(awszResult)
                                FreeProperty(awszResult);
                       }
                    }
                break;

            case CERTTYPE_PRIVATE_KEY_FLAG:
                   dwFlags = MapFlags(g_rgdwPrivateKeyFlagMap, g_cPrivateKeyFlagMap, m_dwFlags);
                break;

            case CERTTYPE_GENERAL_FLAG:
                    dwFlags = m_dwFlags;
                break;
            default:
                    dwFlags = 0;
                break;
        }
    }
    else
    {
        //for schema, return directly.  We have additional flags in general flags
        //for V1 templates, which is correct for backward compatibility
        switch(dwOption)
        {
            case CERTTYPE_ENROLLMENT_FLAG:
                    dwFlags = m_dwEnrollmentFlags;
                break;

            case CERTTYPE_SUBJECT_NAME_FLAG:
                    dwFlags = m_dwCertificateNameFlags;
                break;

            case CERTTYPE_PRIVATE_KEY_FLAG:
                   dwFlags = m_dwPrivateKeyFlags;
                break;

            case CERTTYPE_GENERAL_FLAG:
                    dwFlags = m_dwFlags;
                break;

            default:
                    dwFlags = 0;
                break;
        }
    }

    return dwFlags;
}

//+--------------------------------------------------------------------------
// CCertTypeInfo::SetFlags
//
//
//+--------------------------------------------------------------------------

HRESULT CCertTypeInfo::SetFlags(DWORD     dwOption, DWORD dwFlags)
{

    //we can not set flags for V1 template
    if(m_dwSchemaVersion < CERTTYPE_SCHEMA_VERSION_2)
        return E_UNEXPECTED;

    switch(dwOption)
    {
        case CERTTYPE_ENROLLMENT_FLAG:
                m_dwEnrollmentFlags = dwFlags;
            break;

        case CERTTYPE_SUBJECT_NAME_FLAG:
                m_dwCertificateNameFlags = dwFlags;
            break;

        case CERTTYPE_PRIVATE_KEY_FLAG:
               m_dwPrivateKeyFlags = dwFlags;
            break;

        case CERTTYPE_GENERAL_FLAG:
                m_dwFlags = (m_dwFlags & ~CT_MASK_SETTABLE_FLAGS) | (dwFlags & CT_MASK_SETTABLE_FLAGS);
            break;
        default:
            return E_INVALIDARG;
    }

    return S_OK;
}


//+--------------------------------------------------------------------------
// CCertTypeInfo::_IsCritical -- Is a particular extension critical
//
//
//+--------------------------------------------------------------------------

BOOL CCertTypeInfo::_IsCritical(LPCWSTR wszExtension, LPCWSTR *awszCriticalExtensions)
{

    LPCWSTR * pwszCurCritical = awszCriticalExtensions;

    if((awszCriticalExtensions == NULL) ||
       (wszExtension == NULL))
    {
        return FALSE;
    }


    while(*pwszCurCritical)
    {
        if(wcscmp(*pwszCurCritical, wszExtension) == 0)
        {
            return TRUE;
        }
        pwszCurCritical++;

    }

    return FALSE;
}
//+--------------------------------------------------------------------------
// CCertTypeInfo::GetExtensions --
//
//
//+--------------------------------------------------------------------------

HRESULT CCertTypeInfo::GetExtensions(IN  DWORD               dwFlags,
                                     IN  LPVOID              pParam,
                                     OUT PCERT_EXTENSIONS *  ppCertExtensions
        )
{
    HRESULT hr = S_OK;
    PCERT_EXTENSIONS pExtensions = NULL;


    CERTSTR bstrBasicConstraints = NULL;
    CERTSTR bstrEKU = NULL;
    CERTSTR bstrCertType = NULL;
    CERTSTR bstrKU = NULL;
    CERTSTR bstrPolicies=NULL;
    CERTSTR bstrAppPolicies=NULL;

    DWORD   cbTotal=0;
    PBYTE   pbData=NULL;
    DWORD   i=0;
    LPCWSTR * awszCritical = NULL;

    if(ppCertExtensions == NULL)
    {
        return E_POINTER;
    }

    hr = GetProperty(CERTTYPE_PROP_CRITICAL_EXTENSIONS, const_cast<LPWSTR **>(&awszCritical));
    _JumpIfError(hr, error, "GetProperty");

    // The extensions are built out of the
    // name extension, the eku, the ku,
    // the basic constraints, the certificate policy
    // and any additional extensions.

    if((0 == dwFlags) || (CT_EXTENSION_BASIC_CONTRAINTS & dwFlags))
    {
        hr = _GetBasicConstraintsValue(&bstrBasicConstraints);
        _JumpIfError(hr, error, "_GetBasicConstraintsValue");
        
        if((CT_EXTENSION_BASIC_CONTRAINTS & dwFlags) && (NULL == bstrBasicConstraints))
        {
            hr=CRYPT_E_NOT_FOUND;
            _JumpIfError(hr, error, "_GetBasicConstraintsValue");
        }
    }

    if((0 == dwFlags) || (CT_EXTENSION_EKU & dwFlags))
    {
        hr = _GetEKUValue(&bstrEKU);
        _JumpIfError(hr, error, "_GetEKUValue");

        if((CT_EXTENSION_EKU & dwFlags) && (NULL == bstrEKU))
        {
            hr=CRYPT_E_NOT_FOUND;
            _JumpIfError(hr, error, "_GetEKUValue");
        }
    }

    if((0 == dwFlags) || (CT_EXTENSION_KEY_USAGE & dwFlags))
    {
        hr = _GetKUValue(&bstrKU);
        _JumpIfError(hr, error, "_GetKUValue");

        if((CT_EXTENSION_KEY_USAGE & dwFlags) && (NULL == bstrKU))
        {
            hr=CRYPT_E_NOT_FOUND;
            _JumpIfError(hr, error, "_GetKUValue");
        }
    }

    
    if((0 == dwFlags) || (CT_EXTENSION_TEMPLATE & dwFlags))
    {   
        hr = _GetTypeExtensionValue(TRUE, &bstrCertType);
        _JumpIfError(hr, error, "_GetTypeExtensionValue");

        if((CT_EXTENSION_TEMPLATE & dwFlags) && (NULL == bstrCertType))
        {
            hr=CRYPT_E_NOT_FOUND;
            _JumpIfError(hr, error, "_GetTypeExtensionValue");
        }
    }

    //bstrPolicies will not be NULL only if the value is set (SCHEMA VERSION 2 or later)
    if(0!=m_dwSchemaVersion)
    {
        if((0 == dwFlags) || (CT_EXTENSION_ISSUANCE_POLICY & dwFlags))
        {
            hr = _GetPoliciesValue(CERTTYPE_PROP_POLICY, &bstrPolicies);
            _JumpIfError(hr, error, "_GetPoliciesValue");
        }
    }

    if((CT_EXTENSION_ISSUANCE_POLICY & dwFlags) && (NULL == bstrPolicies))
    {
        hr=CRYPT_E_NOT_FOUND;
        _JumpIfError(hr, error, "_GetPoliciesValue");
    }

    if(0!=m_dwSchemaVersion)
    {
        if((0 == dwFlags) || ( CT_EXTENSION_APPLICATION_POLICY & dwFlags))
        {
            hr = _GetPoliciesValue(CERTTYPE_PROP_APPLICATION_POLICY, &bstrAppPolicies);
            _JumpIfError(hr, error, "_GetAppPoliciesValue");
        }
    }

    if((CT_EXTENSION_APPLICATION_POLICY & dwFlags) && (NULL == bstrAppPolicies))
    {
        hr=CRYPT_E_NOT_FOUND;
        _JumpIfError(hr, error, "_GetAppPoliciesValue");
    }

    i = 0;

    cbTotal = sizeof(CERT_EXTENSIONS);
    if(bstrCertType)
    {
        cbTotal += CertStringByteLen(bstrCertType) + sizeof(CERT_EXTENSION);
        i++;
    }
    if(bstrEKU)
    {
        cbTotal += CertStringByteLen(bstrEKU) + sizeof(CERT_EXTENSION);
        i++;
    }
    if(bstrKU)
    {
        cbTotal += CertStringByteLen(bstrKU) + sizeof(CERT_EXTENSION);
        i++;
    }
    if(bstrBasicConstraints)
    {
        cbTotal += CertStringByteLen(bstrBasicConstraints) + sizeof(CERT_EXTENSION);
        i++;
    }

    if(bstrPolicies)
    {
        cbTotal += CertStringByteLen(bstrPolicies) + sizeof(CERT_EXTENSION);
        i++;
    }

    if(bstrAppPolicies)
    {
        cbTotal += CertStringByteLen(bstrAppPolicies) + sizeof(CERT_EXTENSION);
        i++;
    }

    pExtensions = (PCERT_EXTENSIONS)LocalAlloc(LMEM_FIXED, cbTotal);

    if(pExtensions == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    pExtensions->rgExtension = (PCERT_EXTENSION)(pExtensions+1);
    pExtensions->cExtension = i;

    i = 0;
    pbData = (PBYTE)(pExtensions->rgExtension+pExtensions->cExtension);

    if(bstrCertType)
    {
        //decide to encode as V1 or V2 template extension
        pExtensions->rgExtension[i].fCritical = _IsCritical((m_dwSchemaVersion < CERTTYPE_SCHEMA_VERSION_2) ?
            TEXT(szOID_ENROLL_CERTTYPE_EXTENSION) : TEXT(szOID_CERTIFICATE_TEMPLATE), awszCritical);
        pExtensions->rgExtension[i].pszObjId = (m_dwSchemaVersion < CERTTYPE_SCHEMA_VERSION_2) ?
            szOID_ENROLL_CERTTYPE_EXTENSION: szOID_CERTIFICATE_TEMPLATE;
        pExtensions->rgExtension[i].Value.pbData = pbData;
        pExtensions->rgExtension[i].Value.cbData = CertStringByteLen(bstrCertType);
        CopyMemory(pbData, bstrCertType, CertStringByteLen(bstrCertType));
        pbData += pExtensions->rgExtension[i].Value.cbData;
        i++;
    }

    if(bstrEKU)
    {
        pExtensions->rgExtension[i].fCritical = _IsCritical(TEXT(szOID_ENHANCED_KEY_USAGE), awszCritical);
        pExtensions->rgExtension[i].pszObjId = szOID_ENHANCED_KEY_USAGE;
        pExtensions->rgExtension[i].Value.pbData = pbData;
        pExtensions->rgExtension[i].Value.cbData = CertStringByteLen(bstrEKU);
        CopyMemory(pbData, bstrEKU, CertStringByteLen(bstrEKU));
        pbData += pExtensions->rgExtension[i].Value.cbData;
        i++;
    }

    if(bstrKU)
    {
        pExtensions->rgExtension[i].fCritical = _IsCritical(TEXT(szOID_KEY_USAGE), awszCritical);
        pExtensions->rgExtension[i].pszObjId = szOID_KEY_USAGE;
        pExtensions->rgExtension[i].Value.pbData = pbData;
        pExtensions->rgExtension[i].Value.cbData = CertStringByteLen(bstrKU);
        CopyMemory(pbData, bstrKU, CertStringByteLen(bstrKU));
        pbData += pExtensions->rgExtension[i].Value.cbData;
        i++;
    }

    if(bstrBasicConstraints)
    {
        pExtensions->rgExtension[i].fCritical = _IsCritical(TEXT(szOID_BASIC_CONSTRAINTS2), awszCritical);
        pExtensions->rgExtension[i].pszObjId = szOID_BASIC_CONSTRAINTS2;
        pExtensions->rgExtension[i].Value.pbData = pbData;
        pExtensions->rgExtension[i].Value.cbData = CertStringByteLen(bstrBasicConstraints);
        CopyMemory(pbData, bstrBasicConstraints, CertStringByteLen(bstrBasicConstraints));
        pbData += pExtensions->rgExtension[i].Value.cbData;
        i++;
    }

    if(bstrPolicies)
    {
        pExtensions->rgExtension[i].fCritical = _IsCritical(TEXT(szOID_CERT_POLICIES), awszCritical);
        pExtensions->rgExtension[i].pszObjId = szOID_CERT_POLICIES;
        pExtensions->rgExtension[i].Value.pbData = pbData;
        pExtensions->rgExtension[i].Value.cbData = CertStringByteLen(bstrPolicies);
        CopyMemory(pbData, bstrPolicies, CertStringByteLen(bstrPolicies));
        pbData += pExtensions->rgExtension[i].Value.cbData;
        i++;
    }

    if(bstrAppPolicies)
    {
        pExtensions->rgExtension[i].fCritical = _IsCritical(TEXT(szOID_APPLICATION_CERT_POLICIES), awszCritical);
        pExtensions->rgExtension[i].pszObjId = szOID_APPLICATION_CERT_POLICIES;
        pExtensions->rgExtension[i].Value.pbData = pbData;
        pExtensions->rgExtension[i].Value.cbData = CertStringByteLen(bstrAppPolicies);
        CopyMemory(pbData, bstrAppPolicies, CertStringByteLen(bstrAppPolicies));
        pbData += pExtensions->rgExtension[i].Value.cbData;
        i++;
    }

    *ppCertExtensions = pExtensions;

error:
    if(bstrCertType)
    {
        CertFreeString(bstrCertType);
    }
    if(bstrEKU)
    {
        CertFreeString(bstrEKU);
    }
    if(bstrKU)
    {
        CertFreeString(bstrKU);
    }
    if(bstrBasicConstraints)
    {
        CertFreeString(bstrBasicConstraints);
    }
    if(bstrPolicies)
    {
        CertFreeString(bstrPolicies);
    }
    if(bstrAppPolicies)
    {
        CertFreeString(bstrAppPolicies);
    }
    if(awszCritical)
    {
        FreeProperty(const_cast<LPWSTR *>(awszCritical));
    }
    return hr;
}



//+--------------------------------------------------------------------------
// CCertTypeInfo::_GetTypeExtensionValue --
//
//
//+--------------------------------------------------------------------------

HRESULT CCertTypeInfo::_GetTypeExtensionValue(IN BOOL fCheckVersion,
        OUT CERTSTR *  bstrValue
        )
{
    HRESULT                 hr = S_OK;
    CERTSTR                 bstrOut = NULL;
    CERT_NAME_VALUE         Value;
    CERT_TEMPLATE_EXT       TemplateExt;
    DWORD                   cbCertTypeExtension=0;
    DWORD                   cbOID=0;

    LPSTR                   szOID=NULL;
    LPWSTR                  *rgwszOID=NULL;

    if(bstrValue == NULL)
    {
        return E_POINTER;
    }

    //check to see we need to encode with the new cert type extention
    if((FALSE == fCheckVersion)||(m_dwSchemaVersion < CERTTYPE_SCHEMA_VERSION_2))
    {
        Value.dwValueType = CERT_RDN_UNICODE_STRING;
        Value.Value.pbData = (PBYTE)m_bstrType;
        Value.Value.cbData = 0;
    }
    else
    {
        memset(&TemplateExt, 0, sizeof(TemplateExt));

        if(S_OK != (hr=GetPropertyEx(CERTTYPE_PROP_OID, &rgwszOID)))
            goto error;

        if((rgwszOID == NULL) || (rgwszOID[0] == NULL))
        {
             hr = E_INVALIDARG;
             goto error;
        }

        if(0 == (cbOID = WideCharToMultiByte(CP_ACP,
                                  0,
                                  rgwszOID[0],
                                  wcslen(rgwszOID[0])+1,
                                  szOID,
                                  0,
                                  NULL,
                                  NULL)))
        {
            hr = GetLastError();
            goto error;
        }

        szOID=(LPSTR)LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, cbOID);

        if(NULL==szOID)
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }

        if(0 == WideCharToMultiByte(CP_ACP,
                                  0,
                                  rgwszOID[0],
                                  wcslen(rgwszOID[0])+1,
                                  szOID,
                                  cbOID,
                                  NULL,
                                  NULL))
        {
            hr = GetLastError();
            goto error;
        }

        TemplateExt.pszObjId = szOID;
        TemplateExt.dwMajorVersion = m_Revision;
        TemplateExt.fMinorVersion = TRUE;
        TemplateExt.dwMinorVersion = m_dwMinorRevision;
    }

    if(!CryptEncodeObject(X509_ASN_ENCODING,
                          rgwszOID ? szOID_CERTIFICATE_TEMPLATE : X509_UNICODE_ANY_STRING,
                          rgwszOID ? ((LPVOID)(&TemplateExt)) : ((LPVOID)(&Value)),
                          NULL,
                          &cbCertTypeExtension))
    {
        hr = myHLastError();
        goto error;
    }
    bstrOut = CertAllocStringByteLen(NULL, cbCertTypeExtension);
    if(bstrOut == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }
    if(!CryptEncodeObject(X509_ASN_ENCODING,
                          rgwszOID ? szOID_CERTIFICATE_TEMPLATE : X509_UNICODE_ANY_STRING,
                          rgwszOID ? ((LPVOID)(&TemplateExt)) : ((LPVOID)(&Value)),
                          (PBYTE)bstrOut,
                          &cbCertTypeExtension))
    {
        hr = myHLastError();
        goto error;
    }

    *bstrValue = bstrOut;
    bstrOut = NULL;

error:

    if(szOID)
        LocalFree(szOID);

    if(rgwszOID)
        FreeProperty(rgwszOID);

    if(bstrOut)
        CertFreeString(bstrOut);

    return hr;
}

//+--------------------------------------------------------------------------
// CCertTypeInfo::_GetEKUValue --
//
//
//+--------------------------------------------------------------------------

HRESULT CCertTypeInfo::_GetEKUValue(
        OUT CERTSTR *  bstrValue
        )
{
    HRESULT hr = S_OK;
    CERTSTR bstrOut = NULL;
    DWORD cbEkuAscii;
    CERT_ENHKEY_USAGE Usage;

    DWORD iEku;

    DWORD cbCertTypeExtension;


    WCHAR **awszEku = NULL;
    CHAR *szCur;
    Usage.rgpszUsageIdentifier = NULL;


    if(bstrValue == NULL)
    {
        return E_POINTER;
    }

    hr = GetProperty(CERTTYPE_PROP_EXTENDED_KEY_USAGE,&awszEku);
    if(hr != S_OK)
    {
        goto error;
    }

    if((awszEku == NULL) ||
        (awszEku[0] == NULL))
    {
         hr = S_OK;
         *bstrValue = NULL;
        goto error;
    }

    // Convert all of the widechar vals to multi byte
    // vals
    iEku =0;
    cbEkuAscii = 0;
    while(awszEku[iEku])
    {
        cbEkuAscii += WideCharToMultiByte(CP_ACP,
                                          0,
                                          awszEku[iEku],
                                          wcslen(awszEku[iEku])+1,
                                          NULL,
                                          0,
                                          NULL,
                                          NULL);
        iEku++;
    }

    Usage.rgpszUsageIdentifier = (LPSTR *)LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, sizeof(char *)*iEku + cbEkuAscii);
    if(Usage.rgpszUsageIdentifier == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    szCur = (LPSTR)(Usage.rgpszUsageIdentifier+iEku);

    iEku =0;
    while(awszEku[iEku])
    {
        cbEkuAscii -= WideCharToMultiByte(CP_ACP,
                                          0,
                                          awszEku[iEku],
                                          wcslen(awszEku[iEku])+1,
                                          szCur,
                                          cbEkuAscii,
                                          NULL,
                                          NULL);
        Usage.rgpszUsageIdentifier[iEku] = szCur;
        szCur += strlen(szCur)+1;

        iEku++;
    }

    Usage.cUsageIdentifier = iEku;


    if(!CryptEncodeObject(X509_ASN_ENCODING,
                          X509_ENHANCED_KEY_USAGE,
                          &Usage,
                          NULL,
                          &cbCertTypeExtension))
    {
        hr = myHLastError();
        goto error;
    }
    bstrOut = CertAllocStringByteLen(NULL, cbCertTypeExtension);
    if(bstrOut == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }
    if(!CryptEncodeObject(X509_ASN_ENCODING,
                          X509_ENHANCED_KEY_USAGE,
                          &Usage,
                          (PBYTE)bstrOut,
                          &cbCertTypeExtension))
    {
        hr = myHLastError();
        goto error;
    }
    *bstrValue = bstrOut;
    bstrOut = NULL;

error:
    if(awszEku)
    {
        FreeProperty(awszEku);
    }

    if(bstrOut)
    {
        CertFreeString(bstrOut);
    }
    if(Usage.rgpszUsageIdentifier)
    {
        LocalFree(Usage.rgpszUsageIdentifier);
    }
    return hr;
}

//+--------------------------------------------------------------------------
// CCertTypeInfo::_GetKUValue --
//
//
//+--------------------------------------------------------------------------

HRESULT CCertTypeInfo::_GetKUValue(
        OUT CERTSTR *  bstrValue
        )
{
    HRESULT hr = S_OK;
    CERTSTR bstrOut = NULL;




    DWORD cbCertTypeExtension;


    if(bstrValue == NULL)
    {
        return E_POINTER;
    }

    if((m_KeyUsage.cbData == 0) ||
        (m_KeyUsage.pbData == NULL))
    {
         hr = S_OK;
         *bstrValue = NULL;
         goto error;
    }


    if(!CryptEncodeObject(X509_ASN_ENCODING,
                          X509_KEY_USAGE,
                          &m_KeyUsage,
                          NULL,
                          &cbCertTypeExtension))
    {
        hr = myHLastError();
        goto error;
    }
    bstrOut = CertAllocStringByteLen(NULL, cbCertTypeExtension);
    if(bstrOut == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }
    if(!CryptEncodeObject(X509_ASN_ENCODING,
                          X509_KEY_USAGE,
                          &m_KeyUsage,
                          (PBYTE)bstrOut,
                          &cbCertTypeExtension))
    {
        hr = myHLastError();
        goto error;
    }
    *bstrValue = bstrOut;
    bstrOut = NULL;

error:
    if(bstrOut)
    {
        CertFreeString(bstrOut);
    }
    return hr;
}

//+--------------------------------------------------------------------------
// CCertTypeInfo::_GetBasicConstraintsValue --
//
//
//+--------------------------------------------------------------------------

HRESULT CCertTypeInfo::_GetBasicConstraintsValue(
        OUT CERTSTR *  bstrValue
        )
{
    HRESULT hr = S_OK;
    CERTSTR bstrOut = NULL;




    DWORD cbCertTypeExtension;


    if(bstrValue == NULL)
    {
        return E_POINTER;
    }

    if((m_dwFlags & CT_FLAG_IS_CA) || (m_dwFlags & CT_FLAG_IS_CROSS_CA))
        m_BasicConstraints.fCA = TRUE;
    else
	    m_BasicConstraints.fCA = FALSE;

     if(!m_BasicConstraints.fCA)
    {
        hr = S_OK;
        *bstrValue = NULL;
        goto error;
    }

    if(!CryptEncodeObject(X509_ASN_ENCODING,
                          X509_BASIC_CONSTRAINTS2,
                          &m_BasicConstraints,
                          NULL,
                          &cbCertTypeExtension))
    {
        hr = myHLastError();
        goto error;
    }
    bstrOut = CertAllocStringByteLen(NULL, cbCertTypeExtension);
    if(bstrOut == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }
    if(!CryptEncodeObject(X509_ASN_ENCODING,
                          X509_BASIC_CONSTRAINTS2,
                          &m_BasicConstraints,
                          (PBYTE)bstrOut,
                          &cbCertTypeExtension))
    {
        hr = myHLastError();
        goto error;
    }
    *bstrValue = bstrOut;
    bstrOut = NULL;

error:
    if(bstrOut)
    {
        CertFreeString(bstrOut);
    }
    return hr;
}

//+--------------------------------------------------------------------------
// CCertTypeInfo::__GetPoliciesValue --
//
//
//+--------------------------------------------------------------------------
HRESULT CCertTypeInfo::_GetPoliciesValue(IN LPCWSTR pwszPropertyName, OUT  CERTSTR *  bstrValue)
{
    HRESULT                     hr=S_OK;
    CERT_POLICIES_INFO          CertPolicyInfo;
    DWORD                       cbData=0;
    DWORD                       iCount=0;
    DWORD                       iIndex=0;
    LPWSTR                      pwsz=NULL;
    CERT_NAME_VALUE             nameValue;
    DWORD                       cbChar=0;
    DWORD                       i=0;

    LPWSTR                      *rgwszPolicy=NULL;
    LPWSTR                      *rgPolicy1=NULL;
    CERTSTR                     bstrOut = NULL;
    BYTE                        **ppbData=NULL;
    CERT_POLICY_INFO            *pPolicyInfo=NULL;
    CERT_POLICY_QUALIFIER_INFO  *pQualifierInfo=NULL;
    LPWSTR                      pwszCPS=NULL;

    if(bstrValue == NULL)
    {
        return E_POINTER;
    }

    //init the output
    *bstrValue=NULL;

    if(S_OK != (hr=GetPropertyEx(pwszPropertyName, &rgPolicy1)))
        goto error;

    iCount=0;
    if(rgPolicy1)
    {
        i=0;
        while(rgPolicy1[i])
        {
            i++;
            iCount++;
        }
    }


    if(0==iCount)
    {
         hr = S_OK;
         goto error;
    }

    //copy the pointers
    rgwszPolicy=(LPWSTR * )LocalAlloc(LPTR, sizeof(LPWSTR) * (iCount + 1));
    if (NULL == rgwszPolicy)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }


    iIndex=0;
    if(rgPolicy1)
    {
        i=0;
        while(rgPolicy1[i])
        {
            rgwszPolicy[iIndex]=rgPolicy1[i];
            i++;
            iIndex++;
        }
    }

    rgwszPolicy[iIndex]=NULL;

    memset(&CertPolicyInfo, 0, sizeof(CertPolicyInfo));


    //allocate memory
    pPolicyInfo=(CERT_POLICY_INFO  *)LocalAlloc(LPTR, iCount * sizeof(CERT_POLICY_INFO));

    pQualifierInfo=(CERT_POLICY_QUALIFIER_INFO  *)LocalAlloc(LPTR, iCount * sizeof(CERT_POLICY_QUALIFIER_INFO));

    ppbData=(BYTE **)LocalAlloc(LPTR, iCount * sizeof(BYTE *));

    if((NULL==pPolicyInfo) || (NULL==pQualifierInfo) ||(NULL==ppbData))
    {
        hr=E_OUTOFMEMORY;
        goto error;
    }

    for(iIndex=0; iIndex < iCount; iIndex++)
    {
        cbChar=0;
        cbData=0;
        ppbData[iIndex]=NULL;

        //the string is in the form of "oid;CPS"; we do not consider the CPS
        //part.  We obtain the CPS from the OID container
        pwsz=wcschr(rgwszPolicy[iIndex], L';');
        if(pwsz)
        {
            *pwsz=L'\0';
        }

			if(S_OK == I_CAOIDGetProperty(rgwszPolicy[iIndex], CERT_OID_PROPERTY_CPS, &pwszCPS))
			{
				memset(&nameValue, 0, sizeof(nameValue));

				nameValue.dwValueType = CERT_RDN_UNICODE_STRING;
				nameValue.Value.cbData = 0;
				nameValue.Value.pbData = (PBYTE)(pwszCPS);

				if( !CryptEncodeObject(
						CRYPT_ASN_ENCODING,
						X509_UNICODE_ANY_STRING,
						&nameValue,
						NULL,
						&cbData
						) )
				{
					hr = myHLastError();
					goto error;
				}

				if(NULL==(ppbData[iIndex]=(BYTE *)LocalAlloc(LPTR, cbData)))
				{
					hr = E_OUTOFMEMORY;
					goto error;
				}


				if( !CryptEncodeObject(
						CRYPT_ASN_ENCODING,
						X509_UNICODE_ANY_STRING,
						&nameValue,
						ppbData[iIndex],
						&cbData
						) )
				{
					hr = myHLastError();
					goto error;
				}

				if(pwszCPS)
				   I_CAOIDFreeProperty(pwszCPS);

				pwszCPS=NULL;
			}

        cbChar= WideCharToMultiByte(
                    CP_ACP,                // codepage
                    0,                      // dwFlags
                    rgwszPolicy[iIndex],
                    -1,
                    NULL,
                    0,
                    NULL,
                    NULL);

        if(0 == cbChar)
        {
            hr=E_UNEXPECTED;
            goto error;
        }

        if(NULL==(pPolicyInfo[iIndex].pszPolicyIdentifier=(LPSTR)LocalAlloc(
                        LPTR, cbChar)))
        {
            hr=E_OUTOFMEMORY;
            goto error;
        }

        cbChar= WideCharToMultiByte(
                    CP_ACP,                // codepage
                    0,                      // dwFlags
                    rgwszPolicy[iIndex],
                    -1,
                    pPolicyInfo[iIndex].pszPolicyIdentifier,
                    cbChar,
                    NULL,
                    NULL);

        if(0 == cbChar)
        {
            hr=E_UNEXPECTED;
            goto error;
        }


        if(cbData)
        {
            pPolicyInfo[iIndex].cPolicyQualifier=1;
            pPolicyInfo[iIndex].rgPolicyQualifier=&(pQualifierInfo[iIndex]);
        }
        else
        {
            pPolicyInfo[iIndex].cPolicyQualifier=0;
            pPolicyInfo[iIndex].rgPolicyQualifier=NULL;
        }

        pQualifierInfo[iIndex].pszPolicyQualifierId=szOID_PKIX_POLICY_QUALIFIER_CPS;
        pQualifierInfo[iIndex].Qualifier.cbData=cbData;
        pQualifierInfo[iIndex].Qualifier.pbData=ppbData[iIndex];
    }


    //encode the extension
    CertPolicyInfo.cPolicyInfo=iCount;
    CertPolicyInfo.rgPolicyInfo=pPolicyInfo;

    cbData=0;
    if(!CryptEncodeObject(X509_ASN_ENCODING,
                          szOID_CERT_POLICIES,
                          &CertPolicyInfo,
                          NULL,
                          &cbData))
    {
        hr = myHLastError();
        goto error;
    }

    bstrOut = CertAllocStringByteLen(NULL, cbData);
    if(bstrOut == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    if(!CryptEncodeObject(X509_ASN_ENCODING,
                          szOID_CERT_POLICIES,
                          &CertPolicyInfo,
                          (PBYTE)bstrOut,
                          &cbData))
    {
        hr = myHLastError();
        goto error;
    }

    *bstrValue = bstrOut;
    bstrOut = NULL;

error:
    if(pPolicyInfo)
    {
        for(iIndex=0; iIndex < iCount; iIndex++)
        {
            if(pPolicyInfo[iIndex].pszPolicyIdentifier)
                LocalFree(pPolicyInfo[iIndex].pszPolicyIdentifier);
        }

        LocalFree(pPolicyInfo);
    }

    if(pQualifierInfo)
        LocalFree(pQualifierInfo);

    if(ppbData)
    {
        for(iIndex=0; iIndex < iCount; iIndex++)
        {
            if(ppbData[iIndex])
                LocalFree(ppbData[iIndex]);
        }

        LocalFree(ppbData);
    }

    if(bstrOut)
        CertFreeString(bstrOut);

    if(rgwszPolicy)
        LocalFree(rgwszPolicy);

    if(rgPolicy1)
        FreeProperty(rgPolicy1);

    if(pwszCPS)
        I_CAOIDFreeProperty(pwszCPS);

    return hr;
}


//+--------------------------------------------------------------------------
// CCertTypeInfo::GetSecurity --
//
//
//+--------------------------------------------------------------------------


HRESULT CCertTypeInfo::GetSecurity(PSECURITY_DESCRIPTOR * ppSD)
{
    HRESULT hr = S_OK;
    PSECURITY_DESCRIPTOR pResult = NULL;

    DWORD   cbSD;

    if(ppSD == NULL)
    {
        return E_POINTER;
    }
    if(m_pSD == NULL)
    {
        *ppSD = NULL;
        return S_OK;
    }

    if(!IsValidSecurityDescriptor(m_pSD))
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_SECURITY_DESCR);
    }
    cbSD = GetSecurityDescriptorLength(m_pSD);

    pResult = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, cbSD);

    if(pResult == NULL)
    {
        return E_OUTOFMEMORY;
    }

    CopyMemory(pResult, m_pSD, cbSD);

    *ppSD = pResult;

    return S_OK;
}

//+--------------------------------------------------------------------------
// CCertTypeInfo::GetSecurity --
//
//
//+--------------------------------------------------------------------------


HRESULT CCertTypeInfo::SetSecurity(PSECURITY_DESCRIPTOR pSD)
{
    HRESULT hr = S_OK;
    PSECURITY_DESCRIPTOR pResult = NULL;

    DWORD   cbSD;

    if(pSD == NULL)
    {
        return E_POINTER;
    }

    if(!IsValidSecurityDescriptor(pSD))
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_SECURITY_DESCR);
    }
    cbSD = GetSecurityDescriptorLength(pSD);

    pResult = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, cbSD);

    if(pResult == NULL)
    {
        return E_OUTOFMEMORY;
    }

    CopyMemory(pResult, pSD, cbSD);

    if(m_pSD)
    {
        LocalFree(m_pSD);
    }

    m_pSD = pResult;

    return S_OK;
}



//+--------------------------------------------------------------------------
// CCertTypeInfo::AccessCheck -- Check for enroll and autoenroll access rights
//
//
//+--------------------------------------------------------------------------

HRESULT CCertTypeInfo::AccessCheck(HANDLE ClientToken, DWORD dwOption)
{
    //for autoenrollment, we only allow for V2 or later
    if((CERTTYPE_ACCESS_CHECK_AUTO_ENROLL & dwOption) && (m_dwSchemaVersion < CERTTYPE_SCHEMA_VERSION_2))
        return E_ACCESSDENIED;

    return CAAccessCheckpEx(ClientToken, m_pSD, dwOption);

}

//+--------------------------------------------------------------------------
// CCertTypeInfo::SetExtension -- Set the extension for this cert type
//
//
//+--------------------------------------------------------------------------


HRESULT CCertTypeInfo::SetExtension(IN LPCWSTR wszExtensionName,
                                    IN LPVOID pExtension,
                                    IN DWORD  dwFlags)
{
    HRESULT hr = S_OK;
    LPCWSTR  * awszCritical = NULL;
    LPCWSTR  * pwszCurCritical = NULL;
    DWORD      cCritical = 0;

    if(wszExtensionName == NULL)
    {
        return E_POINTER;
    }

    if(wcscmp(wszExtensionName, TEXT(szOID_ENHANCED_KEY_USAGE)) == 0)
    {
        PCERT_ENHKEY_USAGE pEnhKeyUsage = (PCERT_ENHKEY_USAGE)pExtension;
        WCHAR **awszEKU;
        WCHAR *wszData;
        DWORD cbEKU, cStr;
        DWORD i;
        if(pExtension == NULL)
        {
            hr = SetProperty(CERTTYPE_PROP_EXTENDED_KEY_USAGE, NULL);
            return hr;
        }
        // Add an extra NULL to the end of the list of strings,
        // and convert them to WCHAR
        cbEKU = (pEnhKeyUsage->cUsageIdentifier +1)* sizeof(WCHAR *);
        for(i=0; i < pEnhKeyUsage->cUsageIdentifier; i++)
        {
            cbEKU += sizeof(WCHAR)*MultiByteToWideChar(CP_ACP,
                                  0,
                                  pEnhKeyUsage->rgpszUsageIdentifier[i],
                                  strlen(pEnhKeyUsage->rgpszUsageIdentifier[i])+1,
                                  NULL,
                                  0);
        }
        awszEKU = (WCHAR **)LocalAlloc(LMEM_FIXED, cbEKU);
        if(awszEKU == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }
        wszData = (WCHAR *)(awszEKU + (pEnhKeyUsage->cUsageIdentifier+1));
        cbEKU -= sizeof(WCHAR *)*(pEnhKeyUsage->cUsageIdentifier+1);
        for(i=0; i < pEnhKeyUsage->cUsageIdentifier; i++)
        {
            awszEKU[i] = wszData;
            cStr = MultiByteToWideChar(CP_ACP,
                                  0,
                                  pEnhKeyUsage->rgpszUsageIdentifier[i],
                                  strlen(pEnhKeyUsage->rgpszUsageIdentifier[i])+1,
                                  awszEKU[i],
                                  cbEKU);
            if(cStr <= 0)
            {
                hr = myHLastError();
                LocalFree(awszEKU);
                goto error;
            }
            cbEKU -= cStr*sizeof(WCHAR);
            wszData += cStr;

        }

        awszEKU[i] = NULL;
        hr = SetProperty(CERTTYPE_PROP_EXTENDED_KEY_USAGE, awszEKU);
        LocalFree(awszEKU);

    }
    else if (wcscmp(wszExtensionName, TEXT(szOID_KEY_USAGE)) == 0)
    {
        PCRYPT_BIT_BLOB pKeyUsage = (PCRYPT_BIT_BLOB)pExtension;

        if(m_KeyUsage.pbData)
        {
            LocalFree(m_KeyUsage.pbData);
            m_KeyUsage.pbData = NULL;
            m_KeyUsage.cbData = 0;
            m_KeyUsage.cUnusedBits = 0;
        }
        if(pExtension == NULL)
        {
            return S_OK;
        }

        m_KeyUsage.cbData = pKeyUsage->cbData;
        m_KeyUsage.cUnusedBits = pKeyUsage->cUnusedBits;
        if(pKeyUsage->pbData == NULL)
        {
            hr = S_OK;
            goto error;
        }

        m_KeyUsage.pbData = (PBYTE)LocalAlloc(LMEM_FIXED, pKeyUsage->cbData);
        if(m_KeyUsage.pbData == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }
        CopyMemory(m_KeyUsage.pbData, pKeyUsage->pbData, pKeyUsage->cbData);
    }
    else if (wcscmp(wszExtensionName, TEXT(szOID_BASIC_CONSTRAINTS2)) == 0)
    {
        PCERT_BASIC_CONSTRAINTS2_INFO pInfo = (PCERT_BASIC_CONSTRAINTS2_INFO)pExtension;
        if(pExtension == NULL)
        {
            m_BasicConstraints.fCA = FALSE;
            m_BasicConstraints.fPathLenConstraint = FALSE;
            m_BasicConstraints.fPathLenConstraint = 0;
            return E_POINTER;
        }
        CopyMemory(&m_BasicConstraints, pInfo, sizeof(CERT_BASIC_CONSTRAINTS2_INFO));
    }
    else
    {
        hr = E_NOTIMPL;
        goto error;
    }

    //mark the critical for the extension
    hr = GetProperty(CERTTYPE_PROP_CRITICAL_EXTENSIONS, const_cast<LPWSTR **>(&awszCritical));
    _JumpIfError(hr, error, "GetProperty");

    if(((dwFlags & CA_EXT_FLAG_CRITICAL) != 0) == _IsCritical(wszExtensionName, awszCritical))
    {
        // already in the right state, do nothing
        hr = S_OK;
        goto error;
    }

    // Count the critical extensions
    if(awszCritical)
    {
        for(pwszCurCritical = awszCritical; *pwszCurCritical != NULL; pwszCurCritical++)
            cCritical++;
    }
    else
    {
        cCritical=0;
    }

    if(dwFlags & CA_EXT_FLAG_CRITICAL)
    {
        LPCWSTR *awszNewCritical = (LPCWSTR *)LocalAlloc(LMEM_ZEROINIT, (cCritical + 2)*sizeof(LPWSTR));
        // We need to add a critical extension

        if(awszNewCritical == NULL)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr , error, "LocalAlloc");
        }

        if(awszCritical)
        {
            CopyMemory(awszNewCritical, awszCritical, cCritical*sizeof(LPWSTR));
        }

        awszNewCritical[cCritical] = wszExtensionName;
        hr = SetProperty(CERTTYPE_PROP_CRITICAL_EXTENSIONS, const_cast<LPWSTR *>(awszNewCritical));

        LocalFree(awszNewCritical);
    }
    else
    {
        //only need to reset the critical extension if there were existing ones
        if(awszCritical)
        {

            LPCWSTR *awszNewCritical = (LPCWSTR *)LocalAlloc(LMEM_ZEROINIT, (cCritical)*sizeof(LPWSTR));
            DWORD i=0;
            if(awszNewCritical == NULL)
            {
                hr = E_OUTOFMEMORY;
                _JumpError(hr , error, "LocalAlloc");
            }

            for(pwszCurCritical = awszCritical; *pwszCurCritical != NULL; pwszCurCritical++)
            {
                if(wcscmp(*pwszCurCritical, wszExtensionName) != 0)
                {
                    awszNewCritical[i++] = *pwszCurCritical;
                }
            }
            hr = SetProperty(CERTTYPE_PROP_CRITICAL_EXTENSIONS, const_cast<LPWSTR *>(awszNewCritical));

            LocalFree(awszNewCritical);
        }
    }

error:

    if(awszCritical)
    {
        FreeProperty(const_cast<LPWSTR *>(awszCritical));
    }
    return hr;
}

//+--------------------------------------------------------------------------
// CCertTypeInfo::GetExpiration --
//
//
//+--------------------------------------------------------------------------


HRESULT CCertTypeInfo::GetExpiration(
                          OUT OPTIONAL FILETIME  * pftExpiration,
                          OUT OPTIONAL FILETIME  * pftOverlap)
{
    HRESULT hr = S_OK;

    if(pftExpiration)
    {
        *pftExpiration = m_ftExpiration;
    }

    if(pftOverlap)
    {
        *pftOverlap = m_ftOverlap;
    }

    return hr;
}

//+--------------------------------------------------------------------------
// CCertTypeInfo::GetExpiration --
//
//
//+--------------------------------------------------------------------------


HRESULT CCertTypeInfo::SetExpiration(
                          IN OPTIONAL FILETIME  * pftExpiration,
                          IN OPTIONAL FILETIME  * pftOverlap)
{
    HRESULT hr = S_OK;

    if(pftExpiration)
    {
        m_ftExpiration = *pftExpiration;
    }

    if(pftOverlap)
    {
        m_ftOverlap = *pftOverlap;
    }

    return hr;
}

//+--------------------------------------------------------------------------
//	IsDSInfoNewer
//
//+--------------------------------------------------------------------------
BOOL	IsDSInfoNewer(CCertTypeInfo         *pDSCertType,
				      CERT_TYPE_DEFAULT	    *pDefault)
{
    DWORD   dwSchemaVersion=0;
    DWORD   dwRevision=0;
    DWORD   dwMinorRevision=0;

    //no need to update the DS if something is wrong
    if((!pDSCertType) || (!pDefault))
        return TRUE;

    if((S_OK != pDSCertType->GetPropertyEx(CERTTYPE_PROP_SCHEMA_VERSION, &dwSchemaVersion))||
       (S_OK != pDSCertType->GetPropertyEx(CERTTYPE_PROP_REVISION, &dwRevision))||
       (S_OK != pDSCertType->GetPropertyEx(CERTTYPE_PROP_MINOR_REVISION, &dwMinorRevision))
      )
        return FALSE;

    //we consider in the order of schema version, major version (m_revision),
    //and minor revision
    if(dwSchemaVersion == pDefault->dwSchemaVersion)
    {
        if(dwRevision == pDefault->dwRevision)
        {
            return (dwMinorRevision >= pDefault->dwMinorRevision);
        }
        else
        {
            return (dwRevision >= pDefault->dwRevision);
        }
    }

    return (dwSchemaVersion >= pDefault->dwSchemaVersion);
}

//+--------------------------------------------------------------------------
// InstallDefaultOID()
//
//
//      Install default OIDs
//+--------------------------------------------------------------------------
HRESULT InstallDefaultOID()
{
    HRESULT     hr=E_FAIL;
    DWORD       dwIndex=0;

    LPWSTR      pwszDefaultOID=NULL;

    for(dwIndex=0; dwIndex < g_cDefaultOIDInfo; dwIndex++)
    {
        hr = CAOIDBuildOID(0, g_rgDefaultOIDInfo[dwIndex].pwszOID, &pwszDefaultOID);

        _JumpIfError(hr, error, "CAOIDBuildOID");

        hr = I_CAOIDAdd(g_rgDefaultOIDInfo[dwIndex].dwType,
                        0,
                        pwszDefaultOID);

        //CRYPT_E_EXISTS will be returned if the OID already exist
        if(CRYPT_E_EXISTS == hr)
            hr=S_OK;

        _JumpIfError(hr, error, "I_CAOIDADD");

        hr = I_CAOIDSetProperty(
                        pwszDefaultOID,
                        CERT_OID_PROPERTY_DISPLAY_NAME,
                        g_rgDefaultOIDInfo[dwIndex].pwszName);

        _JumpIfError(hr, error, "I_CAOIDSetProperty");

        if(pwszDefaultOID)
        {
            LocalFree(pwszDefaultOID);
            pwszDefaultOID=NULL;
        }

    }

    hr=S_OK;

error:

    if(pwszDefaultOID)
    {
        LocalFree(pwszDefaultOID);
        pwszDefaultOID=NULL;
    }

    return hr;
}


//+--------------------------------------------------------------------------
// CCertTypeInfo::InstallDefaultTypes --
//
//
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::InstallDefaultTypes(VOID)
{
    HRESULT hr=S_OK;
    DWORD i;
    LPWSTR wszContainer = NULL;
    LPWSTR wszDNRoot = NULL;

    ULONG ldaperr;
    LDAP *pld = NULL;
    LDAPMod objectClass;

    CCertTypeInfo *pDSTypes = NULL;
    CCertTypeInfo *pFindDSType = NULL;

    WCHAR *objectClassVals[3];
    LDAPMod *mods[2];
    CERTSTR bstrConfig = NULL;

    // bind to ds
    hr = myRobustLdapBind(&pld, FALSE);
    _JumpIfError(hr, error, "myRobustLdapBind");

    hr = CAGetAuthoritativeDomainDn(pld, NULL, &bstrConfig);
    _JumpIfError(hr, error, "CAGetAuthoritativeDomainDn");

    wszDNRoot = (LPWSTR)LocalAlloc(LMEM_FIXED, (wcslen(s_wszLocation) + wcslen(bstrConfig) +1)*sizeof(WCHAR));
    if(wszDNRoot == NULL)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(wszDNRoot, s_wszLocation);
    wcscat(wszDNRoot, bstrConfig);


    // Build the Public Key Services container
    mods[0] = &objectClass;
    mods[1] = NULL;

    objectClass.mod_op = 0;
    objectClass.mod_type = TEXT("objectclass");
    objectClass.mod_values = objectClassVals;

    objectClassVals[0] = wszDSTOPCLASSNAME;
    objectClassVals[1] = wszDSCONTAINERCLASSNAME;
    objectClassVals[2] = NULL;

    wszContainer = wcsstr(wszDNRoot, L"CN=Public Key Services");
    if (NULL != wszContainer)
    {
        ldaperr = ldap_add_s(pld, wszContainer, mods);
        if (LDAP_SUCCESS != ldaperr && LDAP_ALREADY_EXISTS != ldaperr)
        {
	    _JumpError(hr, error, "ldap_add_s");
        }
    }

    wszContainer = wcsstr(wszDNRoot, L"CN=Certificate Templates");
    if (NULL != wszContainer)
    {
        ldaperr = ldap_add_s(pld, wszContainer, mods);
        if (LDAP_SUCCESS != ldaperr && LDAP_ALREADY_EXISTS != ldaperr)
        {
	    _JumpError(hr, error, "ldap_add_s");
        }
    }

    // Grab the types currently in the DS (do not use local cache)
    hr = _EnumFromDS(
		pld,
		CT_ENUM_MACHINE_TYPES |
		    CT_ENUM_USER_TYPES |
		    CT_FLAG_NO_CACHE_LOOKUP,
		&pDSTypes);
    _JumpIfError(hr, error, "_EnumFromDS");

    for (i = 0; i < g_cDefaultCertTypes; i++)
    {
        CCertTypeInfo *pCTCurrent = NULL;

        // Find the current default type in our enumeration from the DS
        pFindDSType = pDSTypes;
        while (NULL != pFindDSType)
        {
            if (0 == lstrcmpi(
			g_aDefaultCertTypes[i].wszName,
			pFindDSType->m_bstrType))
            {
                break;
            }
            pFindDSType = pFindDSType->m_pNext;
        }

        // Don't bother to update cert types of our own or grater revision
        if (NULL != pFindDSType &&
	    IsDSInfoNewer(pFindDSType, &g_aDefaultCertTypes[i]))
        {
            continue;
        }

        pCTCurrent = new CCertTypeInfo;
        if (NULL == pCTCurrent)
        {
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "new");
        }

        // we need to build the key into the registry.
        hr = pCTCurrent->_LoadFromDefaults(&g_aDefaultCertTypes[i], NULL);
	    _PrintIfError(hr, "_LoadFromDefaults");
        if(hr == S_OK)
        {
            if (NULL != pFindDSType && 0 == pFindDSType->m_dwSchemaVersion)
            {
                // We're updating a W2K cert type.  Since W2K only allows
		        // modification of security descriptors for this and previous
		        // builds, copy over the security descriptor.

                pCTCurrent->SetSecurity(pFindDSType->m_pSD);
            }
            if (NULL != pFindDSType)
            {
                pCTCurrent->m_fNew = FALSE;
            }
            pCTCurrent->_UpdateToDS();
        }
        delete pCTCurrent;
    }


    // Flush the cache
    if (NULL != pDSTypes)
    {
        pDSTypes->Release();
        pDSTypes = NULL;
    }

    hr = _EnumFromDS(
		pld,
		CT_ENUM_MACHINE_TYPES |
		    CT_ENUM_USER_TYPES |
		    CT_FLAG_NO_CACHE_LOOKUP,
		&pDSTypes);
    _JumpIfError(hr, error, "_EnumFromDS");

    //install default issurance policy OIDs
    hr = InstallDefaultOID();
    _JumpIfError(hr, error, "InstallDefaultOID");

    hr=S_OK;

error:
    if (NULL != pDSTypes)
    {
        pDSTypes->Release();
    }
    if (NULL != bstrConfig)
    {
        CertFreeString(bstrConfig);
    }
    if (NULL != wszDNRoot)
    {
        LocalFree(wszDNRoot);
    }
    if (NULL != pld)
    {
        ldap_unbind(pld);
        pld = NULL;
    }
    _PrintIfError(hr, "InstallDefaultTypes");

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certclib\ctnotify.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        ctnotify.h
//
// Contents:    Declaration of ctnotify.cpp
//
// History:     10-17-00 xiaohs  Created
//
//---------------------------------------------------------------------------
#ifndef __CTNOTIFY_H__
#define __CTNOTIFY_H__

typedef struct _CERTTYPE_QUERY_INFO
{
    DWORD       dwChangeSequence;
    BOOL        fUnbind;
    LDAP        *pldap;
    ULONG       msgID;
    HANDLE      hThread;
}CERTTYPE_QUERY_INFO;


#endif //__CTNOTIFY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certclib\deftypes.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        deftypes.cpp
//
// Contents:    Default cert types
//
// History:     12-Jan-98       petesk created
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop
#include <winldap.h>

#include "certtype.h"
#include "certacl.h"

#include <cainfop.h>
#include <certca.h>
#include <polreg.h>
#include <clibres.h>


#define SMARTCARD_LOGON_CSPS  L"\0"

#define ENCRYPT_USER_CSPS  \
         MS_ENHANCED_PROV_W L"\0" \
         MS_DEF_PROV_W L"\0"

#define SIGN_USER_CSPS \
         MS_ENHANCED_PROV_W L"\0" \
         MS_DEF_PROV_W L"\0" \
         MS_DEF_DSS_PROV_W L"\0"

#define SSL_SERVER_CSPS \
         MS_DEF_RSA_SCHANNEL_PROV_W L"\0" 

#define WEB_SERVER_CSPS \
         MS_DEF_RSA_SCHANNEL_PROV_W L"\0" \
         MS_DEF_DH_SCHANNEL_PROV_W L"\0" 

#define CA_SERVER_CSPS \
         MS_ENHANCED_PROV_W L"\0" 

//we reserver the 1.1-1.500 as the default OIDs for certifcate types


CERT_TYPE_DEFAULT g_aDefaultCertTypes[] =
{
    {
         wszCERTTYPE_USER,				// wszName
         IDS_CERTTYPE_USER,				// idFriendlyName
         USER_GROUP_SD,					// wszSD
         ENCRYPT_USER_CSPS,					// wszCSPs
         // wszEKU
             TEXT(szOID_PKIX_KP_CLIENT_AUTH) L"\0"
             TEXT(szOID_PKIX_KP_EMAIL_PROTECTION) L"\0"
             TEXT(szOID_KP_EFS) L"\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE |
             CERT_KEY_ENCIPHERMENT_KEY_USAGE,
         // dwFlags
             CT_FLAG_ADD_EMAIL |
             CT_FLAG_PUBLISH_TO_DS |
             CT_FLAG_EXPORTABLE_KEY |
             CT_FLAG_AUTO_ENROLLMENT |
             CT_FLAG_ADD_TEMPLATE_NAME |
			 CT_FLAG_IS_DEFAULT,
         AT_KEYEXCHANGE,						// dwKeySpec
         0,										// dwDepth
         NULL,									// wszCriticalExtensions
         EXPIRATION_ONE_YEAR,					// dwExpiration
         OVERLAP_SIX_WEEKS,						// dwOverlap
         CERTTYPE_VERSION_BASE + 2,				// Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
             CT_FLAG_PUBLISH_TO_DS |			
             CT_FLAG_AUTO_ENROLLMENT |
			 CT_FLAG_INCLUDE_SYMMETRIC_ALGORITHMS,
		 // dwPrivateKeyFlags	
			 CT_FLAG_EXPORTABLE_KEY,
		 // dwCertificateNameFlags	 
			 CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH |
			 CT_FLAG_SUBJECT_REQUIRE_EMAIL |
			 CT_FLAG_SUBJECT_ALT_REQUIRE_EMAIL |
			 CT_FLAG_SUBJECT_ALT_REQUIRE_UPN,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.1",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_USER_SIGNATURE,			// wszName
         IDS_CERTTYPE_USER_SIGNATURE,			// idFriendlyName
         USER_GROUP_SD,							// wszSD
         SIGN_USER_CSPS,					    // wszCSPs
         // wszEKU
             TEXT(szOID_PKIX_KP_CLIENT_AUTH) L"\0"
             TEXT(szOID_PKIX_KP_EMAIL_PROTECTION) L"\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE,
         // dwFlags
             CT_FLAG_ADD_EMAIL |
             CT_FLAG_AUTO_ENROLLMENT |
             CT_FLAG_ADD_TEMPLATE_NAME |
	         CT_FLAG_IS_DEFAULT,
         AT_SIGNATURE,							// dwKeySpec
         0,										// dwDepth
         NULL,									// wszCriticalExtensions
         EXPIRATION_ONE_YEAR,					// dwExpiration
         OVERLAP_SIX_WEEKS,						// dwOverlap
         CERTTYPE_VERSION_BASE + 3,				// Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
             CT_FLAG_AUTO_ENROLLMENT,
		 // dwPrivateKeyFlags	
			 0,
		 // dwCertificateNameFlags	 
			 CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH |
			 CT_FLAG_SUBJECT_REQUIRE_EMAIL |
			 CT_FLAG_SUBJECT_ALT_REQUIRE_EMAIL |
			 CT_FLAG_SUBJECT_ALT_REQUIRE_UPN,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.2",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_SMARTCARD_USER,			// wszName
         IDS_CERTTYPE_SMARTCARD_USER,			// idFriendlyName
         ADMIN_GROUP_SD,						// wszSD
         SMARTCARD_LOGON_CSPS,					// wszCSPs
         // wszEKU
             TEXT(szOID_KP_SMARTCARD_LOGON) L"\0"
             TEXT(szOID_PKIX_KP_CLIENT_AUTH) L"\0"
             TEXT(szOID_PKIX_KP_EMAIL_PROTECTION) L"\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE,
	 // dwFlags
	     CT_FLAG_ADD_EMAIL |
	     CT_FLAG_PUBLISH_TO_DS |
	     CT_FLAG_ADD_TEMPLATE_NAME |
	     CT_FLAG_IS_DEFAULT,
         AT_KEYEXCHANGE,						// dwKeySpec
         0,										// dwDepth
         NULL,									// wszCriticalExtensions
         EXPIRATION_ONE_YEAR,					// dwExpiration
         OVERLAP_SIX_WEEKS,						// dwOverlap
         CERTTYPE_VERSION_BASE + 4,				// Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
             CT_FLAG_PUBLISH_TO_DS |			
			 CT_FLAG_INCLUDE_SYMMETRIC_ALGORITHMS,
		 // dwPrivateKeyFlags	
			 0,
		 // dwCertificateNameFlags	 
			 CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH |
			 CT_FLAG_SUBJECT_REQUIRE_EMAIL |
			 CT_FLAG_SUBJECT_ALT_REQUIRE_EMAIL |
			 CT_FLAG_SUBJECT_ALT_REQUIRE_UPN,
		 CERTTYPE_MINIMAL_KEY_SMART_CARD,		// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.3",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_USER_AS,					// wszName
         IDS_CERTTYPE_USER_AS,					// idFriendlyName
         USER_GROUP_SD,							// wszSD
         SIGN_USER_CSPS,					    // wszCSPs
         // wszEKU
	     TEXT(szOID_PKIX_KP_CLIENT_AUTH) L"\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE,
         // dwFlags
             CT_FLAG_ADD_TEMPLATE_NAME |
             CT_FLAG_AUTO_ENROLLMENT |
             CT_FLAG_IS_DEFAULT,
         AT_SIGNATURE,						    // dwKeySpec
         0,										// dwDepth
         NULL,									// wszCriticalExtensions
         EXPIRATION_ONE_YEAR,					// dwExpiration
         OVERLAP_SIX_WEEKS,						// dwOverlap
         CERTTYPE_VERSION_BASE + 2,				// Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
			 CT_FLAG_AUTO_ENROLLMENT,
		 // dwPrivateKeyFlags	
			 0,
		 // dwCertificateNameFlags	 
			 CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH |
			 CT_FLAG_SUBJECT_ALT_REQUIRE_UPN,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.4",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
   },
    {
         wszCERTTYPE_USER_SMARTCARD_LOGON,		// wszName
         IDS_CERTTYPE_USER_SMARTCARD_LOGON,		// idFriendlyName
         ADMIN_GROUP_SD,				// wszSD
         SMARTCARD_LOGON_CSPS,				// wszCSPs
         // wszEKU
             TEXT(szOID_KP_SMARTCARD_LOGON ) L"\0"
             TEXT(szOID_PKIX_KP_CLIENT_AUTH) L"\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE,
         // dwFlags
	     CT_FLAG_ADD_TEMPLATE_NAME |
	     CT_FLAG_IS_DEFAULT,
         AT_KEYEXCHANGE,				        // dwKeySpec
         0,						                // dwDepth
         NULL,						            // wszCriticalExtensions
         EXPIRATION_ONE_YEAR,				    // dwExpiration
         OVERLAP_SIX_WEEKS,				        // dwOverlap
         CERTTYPE_VERSION_BASE + 4,			    // Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
             0,
		 // dwPrivateKeyFlags	
			 0,
		 // dwCertificateNameFlags	 
			 CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH |
			 CT_FLAG_SUBJECT_ALT_REQUIRE_UPN,
		 CERTTYPE_MINIMAL_KEY_SMART_CARD,		// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.5",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_EFS,				// wszName
         IDS_CERTTYPE_EFS,				// idFriendlyName
         USER_GROUP_SD,					// wszSD  
         ENCRYPT_USER_CSPS,				// wszCSPs
         // wszEKU
             TEXT(szOID_KP_EFS) L"\0",
         // bKU
             CERT_KEY_ENCIPHERMENT_KEY_USAGE,
         // dwFlags
             CT_FLAG_PUBLISH_TO_DS |
             CT_FLAG_EXPORTABLE_KEY |
             CT_FLAG_AUTO_ENROLLMENT |
             CT_FLAG_ADD_TEMPLATE_NAME |
             CT_FLAG_IS_DEFAULT,
         AT_KEYEXCHANGE,				// dwKeySpec
         0,						// dwDepth
         NULL,						// wszCriticalExtensions
         EXPIRATION_ONE_YEAR,				// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 2,				    // Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
             CT_FLAG_PUBLISH_TO_DS |
             CT_FLAG_INCLUDE_SYMMETRIC_ALGORITHMS |
             CT_FLAG_AUTO_ENROLLMENT,
		 // dwPrivateKeyFlags	
			 CT_FLAG_EXPORTABLE_KEY,
		 // dwCertificateNameFlags	 
			 CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH |
			 CT_FLAG_SUBJECT_ALT_REQUIRE_UPN,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.6",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_ADMIN,				// wszName
         IDS_CERTTYPE_ADMIN,				// idFriendlyName
         ADMIN_GROUP_SD,				// wszSD
         ENCRYPT_USER_CSPS,					// wszCSPs
         // wszEKU
             TEXT(szOID_PKIX_KP_CLIENT_AUTH) L"\0"
             TEXT(szOID_PKIX_KP_EMAIL_PROTECTION) L"\0"
             TEXT(szOID_KP_EFS) L"\0"
             TEXT(szOID_KP_CTL_USAGE_SIGNING) L"\0"
             TEXT(szOID_PKIX_KP_CODE_SIGNING) L"\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE |
             CERT_KEY_ENCIPHERMENT_KEY_USAGE,
         // dwFlags
             CT_FLAG_ADD_EMAIL |
             CT_FLAG_PUBLISH_TO_DS |
             CT_FLAG_EXPORTABLE_KEY |
             CT_FLAG_AUTO_ENROLLMENT |
             CT_FLAG_ADD_TEMPLATE_NAME |
             CT_FLAG_IS_DEFAULT,
         AT_KEYEXCHANGE,				// dwKeySpec
         0,						// dwDepth
         NULL,						// wszCriticalExtensions
         EXPIRATION_ONE_YEAR,				// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 2,				    // Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
             CT_FLAG_PUBLISH_TO_DS |
             CT_FLAG_AUTO_ENROLLMENT |
			 CT_FLAG_INCLUDE_SYMMETRIC_ALGORITHMS,
		 // dwPrivateKeyFlags	
			 CT_FLAG_EXPORTABLE_KEY,
		 // dwCertificateNameFlags	 
			 CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH |
			 CT_FLAG_SUBJECT_REQUIRE_EMAIL |
			 CT_FLAG_SUBJECT_ALT_REQUIRE_EMAIL |
			 CT_FLAG_SUBJECT_ALT_REQUIRE_UPN,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.7",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_EFS_RECOVERY,			// wszName
         IDS_CERTTYPE_EFS_RECOVERY,			// idFriendlyName
         ADMIN_GROUP_SD,				// wszSD
         ENCRYPT_USER_CSPS,				// wszCSPs
         // wszEKU
             TEXT(szOID_EFS_RECOVERY) L"\0",
         // bKU
             CERT_KEY_ENCIPHERMENT_KEY_USAGE,
         // dwFlags
             CT_FLAG_EXPORTABLE_KEY |
             CT_FLAG_AUTO_ENROLLMENT |
             CT_FLAG_ADD_TEMPLATE_NAME |
			 CT_FLAG_IS_DEFAULT,
         AT_KEYEXCHANGE,				// dwKeySpec
         0,						// dwDepth
         NULL,						// wszCriticalExtensions
         EXPIRATION_FIVE_YEARS,				// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 5,			// Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
             CT_FLAG_AUTO_ENROLLMENT |
             CT_FLAG_INCLUDE_SYMMETRIC_ALGORITHMS,
		 // dwPrivateKeyFlags	
			 CT_FLAG_EXPORTABLE_KEY,
		 // dwCertificateNameFlags	 
			 CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH |
			 CT_FLAG_SUBJECT_ALT_REQUIRE_UPN,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.8",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_CODE_SIGNING,			// wszName
         IDS_CERTTYPE_CODE_SIGNING,			// idFriendlyName
         ADMIN_GROUP_SD,				// wszSD
         SIGN_USER_CSPS,				// wszCSPs
         // wszEKU
             TEXT(szOID_PKIX_KP_CODE_SIGNING) L"\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE,
         // dwFlags
             CT_FLAG_AUTO_ENROLLMENT |
             CT_FLAG_ADD_TEMPLATE_NAME |
             CT_FLAG_IS_DEFAULT,
         AT_SIGNATURE,				    // dwKeySpec
         0,								// dwDepth
         NULL,							// wszCriticalExtensions
         EXPIRATION_ONE_YEAR,			// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 2,				    // Revision
         1,                                     // Minor Revision
 		 // dwEnrollmentFlags
             CT_FLAG_AUTO_ENROLLMENT,
		 // dwPrivateKeyFlags	
			 0,
		 // dwCertificateNameFlags	 
			 CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH |
			 CT_FLAG_SUBJECT_ALT_REQUIRE_UPN,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.9",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
   },
    {
         wszCERTTYPE_CTL_SIGNING,			// wszName
         IDS_CERTTYPE_CTL_SIGNING,			// idFriendlyName
         ADMIN_GROUP_SD,				// wszSD
         SIGN_USER_CSPS,				// wszCSPs
         // wszEKU
             TEXT(szOID_KP_CTL_USAGE_SIGNING) L"\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE,
         // dwFlags
             CT_FLAG_AUTO_ENROLLMENT |
             CT_FLAG_ADD_TEMPLATE_NAME |
             CT_FLAG_IS_DEFAULT ,
         AT_SIGNATURE,				// dwKeySpec
         0,						// dwDepth
         NULL,						// wszCriticalExtensions
         EXPIRATION_ONE_YEAR,				// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 2,				    // Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
             CT_FLAG_AUTO_ENROLLMENT,
		 // dwPrivateKeyFlags	
			 0,
		 // dwCertificateNameFlags	 
			 CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH |
			 CT_FLAG_SUBJECT_ALT_REQUIRE_UPN,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.10",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_ENROLLMENT_AGENT,			// wszName
         IDS_CERTTYPE_ENROLLMENT_AGENT,			// idFriendlyName
         ADMIN_GROUP_SD,				// wszSD
         SIGN_USER_CSPS,			// wszCSPs
         // wszEKU
             TEXT(szOID_ENROLLMENT_AGENT) L"\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE,
         // dwFlags
             CT_FLAG_AUTO_ENROLLMENT |
             CT_FLAG_ADD_TEMPLATE_NAME |
             CT_FLAG_IS_DEFAULT,
         AT_SIGNATURE,				// dwKeySpec
         0,						// dwDepth
         NULL,						// wszCriticalExtensions
         EXPIRATION_TWO_YEARS,				// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 3,				    // Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
             CT_FLAG_AUTO_ENROLLMENT,
		 // dwPrivateKeyFlags	
			 0,
		 // dwCertificateNameFlags	 
			 CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH |
			 CT_FLAG_SUBJECT_ALT_REQUIRE_UPN,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.11",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
 		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
   },
    {
         wszCERTTYPE_ENROLLMENT_AGENT_OFFLINE,		// wszName
         IDS_CERTTYPE_ENROLLMENT_AGENT_OFFLINE,		// idFriendlyName
         ADMIN_GROUP_SD,				// wszSD
         SIGN_USER_CSPS,			// wszCSPs
         // wszEKU
             TEXT(szOID_ENROLLMENT_AGENT) L"\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE,
         // dwFlags
             CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT |
             CT_FLAG_ADD_TEMPLATE_NAME |
             CT_FLAG_IS_DEFAULT,
         AT_SIGNATURE,				// dwKeySpec
         0,						// dwDepth
         NULL,						// wszCriticalExtensions
         EXPIRATION_TWO_YEARS,				// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 3,				    // Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
			 0,
		 // dwPrivateKeyFlags	
			 0,
		 // dwCertificateNameFlags	 
			 CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.12",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_MACHINE_ENROLLMENT_AGENT,		// wszName
         IDS_CERTTYPE_MACHINE_ENROLLMENT_AGENT,		// idFriendlyName
         ADMIN_GROUP_SD,				// wszSD
         SIGN_USER_CSPS,			// wszCSPs
         // wszEKU
             TEXT(szOID_ENROLLMENT_AGENT) L"\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE,
         // dwFlags
             CT_FLAG_AUTO_ENROLLMENT |
             CT_FLAG_MACHINE_TYPE |
             CT_FLAG_ADD_TEMPLATE_NAME |
             CT_FLAG_IS_DEFAULT,
         AT_SIGNATURE,				// dwKeySpec
         0,						// dwDepth
         NULL,						// wszCriticalExtensions
         EXPIRATION_TWO_YEARS,				// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 3,				    // Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
             CT_FLAG_AUTO_ENROLLMENT,
		 // dwPrivateKeyFlags	
			 0,
		 // dwCertificateNameFlags	 
			 CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH |
			 CT_FLAG_SUBJECT_REQUIRE_DNS_AS_CN |
			 CT_FLAG_SUBJECT_ALT_REQUIRE_DNS,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.13",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_MACHINE,				// wszName
         IDS_CERTTYPE_MACHINE,				// idFriendlyName
         MACHINE_GROUP_SD,				// wszSD
         SSL_SERVER_CSPS,				// wszCSPs
         // wszEKU
             TEXT(szOID_PKIX_KP_SERVER_AUTH) L"\0"
             TEXT(szOID_PKIX_KP_CLIENT_AUTH) L"\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE |
             CERT_KEY_ENCIPHERMENT_KEY_USAGE,
         // dwFlags
             CT_FLAG_AUTO_ENROLLMENT |
             CT_FLAG_MACHINE_TYPE |
             CT_FLAG_ADD_TEMPLATE_NAME |
             CT_FLAG_IS_DEFAULT,
         AT_KEYEXCHANGE,				// dwKeySpec
         0,						// dwDepth
         NULL,						// wszCriticalExtensions
         EXPIRATION_ONE_YEAR,				// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 3,				    // Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
             CT_FLAG_AUTO_ENROLLMENT,
		 // dwPrivateKeyFlags	
			 0,
		 // dwCertificateNameFlags	 
             CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH |
			 CT_FLAG_SUBJECT_REQUIRE_DNS_AS_CN |
             CT_FLAG_SUBJECT_ALT_REQUIRE_DNS,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.14",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_DC,				// wszName
         IDS_CERTTYPE_DC,				// idFriendlyName
         DOMAIN_CONTROLLERS_GROUP_SD,			// wszSD
         SSL_SERVER_CSPS,				// wszCSPs
         // wszEKU
             TEXT(szOID_PKIX_KP_SERVER_AUTH) L"\0"
             TEXT(szOID_PKIX_KP_CLIENT_AUTH) L"\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE |
             CERT_KEY_ENCIPHERMENT_KEY_USAGE,
         // dwFlags
             CT_FLAG_ADD_OBJ_GUID |
             CT_FLAG_PUBLISH_TO_DS |
             CT_FLAG_AUTO_ENROLLMENT |
             CT_FLAG_MACHINE_TYPE |
             CT_FLAG_ADD_TEMPLATE_NAME |
             CT_FLAG_IS_DEFAULT,
         AT_KEYEXCHANGE,				// dwKeySpec
         0,						// dwDepth
         NULL,						// wszCriticalExtensions
         EXPIRATION_ONE_YEAR,				// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 2,				    // Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
             CT_FLAG_PUBLISH_TO_DS |
             CT_FLAG_INCLUDE_SYMMETRIC_ALGORITHMS |
             CT_FLAG_AUTO_ENROLLMENT,
		 // dwPrivateKeyFlags	
			 0,
		 // dwCertificateNameFlags	 
             CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH |
			 CT_FLAG_SUBJECT_ALT_REQUIRE_DIRECTORY_GUID |
			 CT_FLAG_SUBJECT_REQUIRE_DNS_AS_CN |
			 CT_FLAG_SUBJECT_ALT_REQUIRE_DNS,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.15",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_WEBSERVER,				// wszName
         IDS_CERTTYPE_WEBSERVER,			// idFriendlyName
         ADMIN_GROUP_SD,				// wszSD
         WEB_SERVER_CSPS,				// wszCSPs
         // wszEKU
             TEXT(szOID_PKIX_KP_SERVER_AUTH) L"\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE |
             CERT_KEY_ENCIPHERMENT_KEY_USAGE,
         // dwFlags
             CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT |
             CT_FLAG_MACHINE_TYPE |
             CT_FLAG_ADD_TEMPLATE_NAME |
             CT_FLAG_IS_DEFAULT,
         AT_KEYEXCHANGE,				// dwKeySpec
         0,						// dwDepth
         NULL,						// wszCriticalExtensions
         EXPIRATION_TWO_YEARS,				// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 3,				    // Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
             0,
		 // dwPrivateKeyFlags	
			 0,
		 // dwCertificateNameFlags	 
			 CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.16",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_CA,				// wszName
         IDS_CERTTYPE_ROOT_CA,				// idFriendlyName
         ADMIN_GROUP_SD,				// wszSD
         CA_SERVER_CSPS,				// wszCSPs
         // wszEKU
             L"\0\0",
         // bKU
	     myCASIGN_KEY_USAGE,
         // dwFlags
             CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT |
             CT_FLAG_EXPORTABLE_KEY |
             CT_FLAG_MACHINE_TYPE |
             CT_FLAG_IS_CA |
             CT_FLAG_IS_DEFAULT,
         AT_SIGNATURE,					// dwKeySpec
         -1,						// dwDepth
         TEXT(szOID_BASIC_CONSTRAINTS2) L"\0",		// wszCriticalExtensions
         EXPIRATION_FIVE_YEARS,				// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 3,			// Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
			 0,
		 // dwPrivateKeyFlags	
			 CT_FLAG_EXPORTABLE_KEY,
		 // dwCertificateNameFlags	 
			 CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.17",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_SUBORDINATE_CA,			// wszName
         IDS_CERTTYPE_SUBORDINATE_CA,			// idFriendlyName
         ADMIN_GROUP_SD,				// wszSD
         CA_SERVER_CSPS,				// wszCSPs
         // wszEKU
             L"\0\0",
         // bKU
	     myCASIGN_KEY_USAGE,
         // dwFlags
             CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT |
             CT_FLAG_EXPORTABLE_KEY |
             CT_FLAG_MACHINE_TYPE |
             CT_FLAG_IS_CA |
             CT_FLAG_ADD_TEMPLATE_NAME |
             CT_FLAG_IS_DEFAULT,
         AT_SIGNATURE,					// dwKeySpec
         -1,						// dwDepth
         TEXT(szOID_BASIC_CONSTRAINTS2) L"\0",		// wszCriticalExtensions
         EXPIRATION_FIVE_YEARS,				// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 3,			// Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
             0,
		 // dwPrivateKeyFlags	
			 CT_FLAG_EXPORTABLE_KEY,
		 // dwCertificateNameFlags	 
			 CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.18",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
 		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
   },
    {
         wszCERTTYPE_IPSEC_INTERMEDIATE_ONLINE,		// wszName
         IDS_CERTTYPE_IPSEC_INTERMEDIATE_ONLINE,	// idFriendlyName
         IPSEC_GROUP_SD,				// wszSD
         SSL_SERVER_CSPS,				// wszCSPs
         // wszEKU
             TEXT(szOID_IPSEC_KP_IKE_INTERMEDIATE) L"\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE |
             CERT_KEY_ENCIPHERMENT_KEY_USAGE |
             CERT_KEY_AGREEMENT_KEY_USAGE,
         // dwFlags
             CT_FLAG_AUTO_ENROLLMENT |
             CT_FLAG_MACHINE_TYPE |
             CT_FLAG_ADD_TEMPLATE_NAME |
             CT_FLAG_IS_DEFAULT,
         AT_KEYEXCHANGE,				// dwKeySpec
         0,						// dwDepth
         NULL,						// wszCriticalExtensions
         EXPIRATION_TWO_YEARS,				// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 2,				    // Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
             CT_FLAG_AUTO_ENROLLMENT,
		 // dwPrivateKeyFlags	
			 0,
		 // dwCertificateNameFlags	 
			 CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH |
			 CT_FLAG_SUBJECT_REQUIRE_DNS_AS_CN |
			 CT_FLAG_SUBJECT_ALT_REQUIRE_DNS,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.19",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_IPSEC_INTERMEDIATE_OFFLINE,	// wszName
         IDS_CERTTYPE_IPSEC_INTERMEDIATE_OFFLINE,	// idFriendlyName
         ADMIN_GROUP_SD,				// wszSD
         SSL_SERVER_CSPS,				// wszCSPs
         // wszEKU
             TEXT(szOID_IPSEC_KP_IKE_INTERMEDIATE) L"\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE |
             CERT_KEY_ENCIPHERMENT_KEY_USAGE |
             CERT_KEY_AGREEMENT_KEY_USAGE,
         // dwFlags
             CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT |
             CT_FLAG_MACHINE_TYPE |
             CT_FLAG_ADD_TEMPLATE_NAME |
             CT_FLAG_IS_DEFAULT,
         AT_KEYEXCHANGE,				// dwKeySpec
         0,						// dwDepth
         NULL,						// wszCriticalExtensions
         EXPIRATION_TWO_YEARS,				// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 2,				    // Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
             0,
		 // dwPrivateKeyFlags	
			 0,
		 // dwCertificateNameFlags	 
			 CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.20",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_ROUTER_OFFLINE,			// wszName
         IDS_CERTTYPE_ROUTER_OFFLINE,			// idFriendlyName
         ADMIN_GROUP_SD,				// wszSD
         SSL_SERVER_CSPS,				// wszCSPs
         // wszEKU
             TEXT(szOID_PKIX_KP_CLIENT_AUTH) L"\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE |
             CERT_KEY_ENCIPHERMENT_KEY_USAGE |
             CERT_KEY_AGREEMENT_KEY_USAGE,
         // dwFlags
             CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT |
             CT_FLAG_MACHINE_TYPE |
             CT_FLAG_ADD_TEMPLATE_NAME |
             CT_FLAG_IS_DEFAULT,
         AT_KEYEXCHANGE,				// dwKeySpec
         0,						// dwDepth
         NULL,						// wszCriticalExtensions
         EXPIRATION_TWO_YEARS,				// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 2,				    // Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
             0,
		 // dwPrivateKeyFlags	
			 0,
		 // dwCertificateNameFlags	 
			 CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.21",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_CEP_ENCRYPTION,			// wszName
         IDS_CERTTYPE_CEP_ENCRYPTION,			// idFriendlyName
         ADMIN_GROUP_SD,				// wszSD
         SSL_SERVER_CSPS,				// wszCSPs
         // wszEKU
             TEXT(szOID_ENROLLMENT_AGENT) L"\0",
         // bKU
             CERT_KEY_ENCIPHERMENT_KEY_USAGE |
             CERT_KEY_AGREEMENT_KEY_USAGE,
         // dwFlags
             CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT |
             CT_FLAG_MACHINE_TYPE |
             CT_FLAG_ADD_TEMPLATE_NAME |
             CT_FLAG_IS_DEFAULT,
         AT_KEYEXCHANGE,				// dwKeySpec
         0,						// dwDepth
         NULL,						// wszCriticalExtensions
         EXPIRATION_TWO_YEARS,				// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 2,				    // Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
             0,
		 // dwPrivateKeyFlags	
			 0,
		 // dwCertificateNameFlags	 
			 CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.22",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_EXCHANGE_USER,			// wszName
         IDS_CERTTYPE_EXCHANGE_USER,			// idFriendlyName
         USER_GROUP_SD,					// wszSD
         ENCRYPT_USER_CSPS,					// wszCSPs
         // wszEKU
             TEXT(szOID_PKIX_KP_EMAIL_PROTECTION) L"\0",
         // bKU
             CERT_KEY_ENCIPHERMENT_KEY_USAGE,
         // dwFlags
             CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT |
             CT_FLAG_EXPORTABLE_KEY |
             CT_FLAG_PUBLISH_TO_DS |
             CT_FLAG_ADD_TEMPLATE_NAME |
             CT_FLAG_IS_DEFAULT,
         AT_KEYEXCHANGE,				// dwKeySpec
         0,						// dwDepth
         NULL,						// wszCriticalExtensions
         EXPIRATION_ONE_YEAR,				// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 3,			// Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
             CT_FLAG_PUBLISH_TO_DS |
			 CT_FLAG_INCLUDE_SYMMETRIC_ALGORITHMS,
		 // dwPrivateKeyFlags	
			 CT_FLAG_EXPORTABLE_KEY,
		 // dwCertificateNameFlags	 
			 CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.23",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_EXCHANGE_USER_SIGNATURE,		// wszName
         IDS_CERTTYPE_EXCHANGE_USER_SIGNATURE,		// idFriendlyName
         USER_GROUP_SD,					// wszSD
         SIGN_USER_CSPS,				// wszCSPs
         // wszEKU
             TEXT(szOID_PKIX_KP_EMAIL_PROTECTION) L"\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE,
         // dwFlags
             CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT |
             CT_FLAG_ADD_TEMPLATE_NAME |
             CT_FLAG_IS_DEFAULT,
         AT_SIGNATURE,					// dwKeySpec
         0,						// dwDepth
         NULL,						// wszCriticalExtensions
         EXPIRATION_ONE_YEAR,				// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 2,				    // Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
			 CT_FLAG_INCLUDE_SYMMETRIC_ALGORITHMS,
		 // dwPrivateKeyFlags	
			 0,
		 // dwCertificateNameFlags	 
			 CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.24",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_CROSS_CA,			// wszName
         IDS_CERTTYPE_CROSS_CA,			// idFriendlyName
         ADMIN_GROUP_SD,				// wszSD
         CA_SERVER_CSPS,				// wszCSPs
         // wszEKU
             L"\0\0",
         // bKU
	     myCASIGN_KEY_USAGE,
         // dwFlags
             CT_FLAG_IS_CROSS_CA |
             CT_FLAG_EXPORTABLE_KEY |
             CT_FLAG_IS_DEFAULT,
         AT_SIGNATURE,								// dwKeySpec
         -1,										// dwDepth
         TEXT(szOID_BASIC_CONSTRAINTS2) L"\0",		// wszCriticalExtensions
         EXPIRATION_FIVE_YEARS,						// dwExpiration
         OVERLAP_SIX_WEEKS,							// dwOverlap
         CERTTYPE_VERSION_NEXT + 4,					// Revision
         0,                                         // Minor Revision
		 // dwEnrollmentFlags
         0,
		 // dwPrivateKeyFlags	
	     CT_FLAG_EXPORTABLE_KEY,
		 // dwCertificateNameFlags	 
		 CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 1,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_2,				// dwSchemaVersion;			     
		 L"1.25",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 TEXT(szOID_KP_QUALIFIED_SUBORDINATION) L"\0",	// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_CA_EXCHANGE,			    // wszName
         IDS_CERTTYPE_CA_EXCHANGE,			    // idFriendlyName
         ADMIN_GROUP_SD,				        // wszSD
         ENCRYPT_USER_CSPS,				// wszCSPs
         // wszEKU
             L"\0\0",
         // bKU
             CERT_KEY_ENCIPHERMENT_KEY_USAGE,
         // dwFlags
             CT_FLAG_MACHINE_TYPE |
             CT_FLAG_IS_CA |
             CT_FLAG_IS_DEFAULT,
         AT_KEYEXCHANGE,							// dwKeySpec
         -1,										// dwDepth
         TEXT(szOID_BASIC_CONSTRAINTS2) L"\0",		// wszCriticalExtensions
         EXPIRATION_THREE_MONTHS,					// dwExpiration
         OVERLAP_SIX_WEEKS,							// dwOverlap
         CERTTYPE_VERSION_NEXT + 4,						// Revision
         0,                                         // Minor Revision
		 // dwEnrollmentFlags
         CT_FLAG_INCLUDE_SYMMETRIC_ALGORITHMS,
		 // dwPrivateKeyFlags	
         0,
		 // dwCertificateNameFlags	 
         CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_2,				// dwSchemaVersion;			     
		 L"1.26",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 TEXT(szOID_KP_CA_EXCHANGE) L"\0",		// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_KEY_RECOVERY_AGENT,	    // wszName
         IDS_CERTTYPE_KEY_RECOVERY_AGENT,	    // idFriendlyName
         ADMIN_GROUP_SD,			            // wszSD
         ENCRYPT_USER_CSPS,			    // wszCSPs
         // wszEKU
            L"\0\0",
         // bKU
             CERT_KEY_ENCIPHERMENT_KEY_USAGE,
         // dwFlags
			 CT_FLAG_IS_DEFAULT |
             CT_FLAG_AUTO_ENROLLMENT,
         AT_KEYEXCHANGE,								// dwKeySpec
         0,										    // dwDepth
         NULL,		                                // wszCriticalExtensions
         EXPIRATION_TWO_YEARS,						// dwExpiration
         OVERLAP_SIX_WEEKS,							// dwOverlap
         CERTTYPE_VERSION_NEXT + 4,						// Revision
         0,                                         // Minor Revision
		 // dwEnrollmentFlags
         CT_FLAG_AUTO_ENROLLMENT |
         CT_FLAG_INCLUDE_SYMMETRIC_ALGORITHMS |
         CT_FLAG_PEND_ALL_REQUESTS |
         CT_FLAG_PUBLISH_TO_KRA_CONTAINER,
		 // dwPrivateKeyFlags	
		 CT_FLAG_EXPORTABLE_KEY,
		 // dwCertificateNameFlags	 
		 CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH |
		 CT_FLAG_SUBJECT_ALT_REQUIRE_UPN,
		 CERTTYPE_2K_KEY,					    // dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_2,				// dwSchemaVersion;			     
		 L"1.27",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 TEXT(szOID_KP_KEY_RECOVERY_AGENT) L"\0",	// *wszCertificateAppPolicy;
   },
   {
         wszCERTTYPE_DC_AUTH,				    // wszName
         IDS_CERTTYPE_DC_AUTH,				    // idFriendlyName
         V2_DOMAIN_CONTROLLERS_GROUP_SD,	    // wszSD
         SSL_SERVER_CSPS,				        // wszCSPs
         // wszEKU
            L"\0\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE |
             CERT_KEY_ENCIPHERMENT_KEY_USAGE,
         // dwFlags
             CT_FLAG_AUTO_ENROLLMENT |
             CT_FLAG_MACHINE_TYPE |
             CT_FLAG_IS_DEFAULT,
         AT_KEYEXCHANGE,			    	// dwKeySpec
         0,						            // dwDepth
         NULL,						        // wszCriticalExtensions
         EXPIRATION_ONE_YEAR,				// dwExpiration
         OVERLAP_SIX_WEEKS,				    // dwOverlap
         CERTTYPE_VERSION_NEXT + 6,			// Revision
         0,                                 // Minor Revision
	     // dwEnrollmentFlags
             CT_FLAG_AUTO_ENROLLMENT,
	     // dwPrivateKeyFlags	
		     0,
	     // dwCertificateNameFlags	 
		     CT_FLAG_SUBJECT_ALT_REQUIRE_DNS,
	     CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
	     0,										// dwRASignature;				 
	     CERTTYPE_SCHEMA_VERSION_2,				// dwSchemaVersion;			     
	     L"1.28",								// *wszOID;						 
         wszCERTTYPE_DC L"\0",					// *wszSupersedeTemplates;		 
	     NULL,									// *wszRAPolicy;				     
	     NULL,									// *wszCertificatePolicy;
	     NULL,									// *wszRAAppPolicy;				     
	     TEXT(szOID_KP_SMARTCARD_LOGON)  L"\0"
         TEXT(szOID_PKIX_KP_SERVER_AUTH) L"\0"
         TEXT(szOID_PKIX_KP_CLIENT_AUTH) L"\0",	// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_DS_EMAIL_REPLICATION,		// wszName
         IDS_CERTTYPE_DS_EMAIL_REPLICATION,		// idFriendlyName
         V2_DOMAIN_CONTROLLERS_GROUP_SD,		// wszSD
         SSL_SERVER_CSPS,				        // wszCSPs
         // wszEKU
            L"\0\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE |
             CERT_KEY_ENCIPHERMENT_KEY_USAGE,
         // dwFlags
             CT_FLAG_AUTO_ENROLLMENT |
             CT_FLAG_MACHINE_TYPE |
             CT_FLAG_IS_DEFAULT,
         AT_KEYEXCHANGE,			    	// dwKeySpec
         0,						            // dwDepth
         NULL,						        // wszCriticalExtensions
         EXPIRATION_ONE_YEAR,				// dwExpiration
         OVERLAP_SIX_WEEKS,				    // dwOverlap
         CERTTYPE_VERSION_NEXT + 7,				// Revision
         0,                                 // Minor Revision
	     // dwEnrollmentFlags
             CT_FLAG_PUBLISH_TO_DS |
             CT_FLAG_INCLUDE_SYMMETRIC_ALGORITHMS |
             CT_FLAG_AUTO_ENROLLMENT,
	     // dwPrivateKeyFlags	
		     0,
	     // dwCertificateNameFlags	 
			 CT_FLAG_SUBJECT_ALT_REQUIRE_DIRECTORY_GUID |
             CT_FLAG_SUBJECT_ALT_REQUIRE_DNS,
	     CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
	     0,										// dwRASignature;				 
	     CERTTYPE_SCHEMA_VERSION_2,				// dwSchemaVersion;			     
	     L"1.29",								// *wszOID;						 
         wszCERTTYPE_DC L"\0",					// *wszSupersedeTemplates;		 
	     NULL,									// *wszRAPolicy;				     
	     NULL,									// *wszCertificatePolicy;
	     NULL,									// *wszRAAppPolicy;				     
	     TEXT(szOID_DS_EMAIL_REPLICATION)  L"\0",	// *wszCertificateAppPolicy;
    }
};

DWORD g_cDefaultCertTypes = ARRAYSIZE(g_aDefaultCertTypes);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certclib\debug.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//	File:		debug.cpp
//
//	Contents:	Debug sub system APIs implementation
//
//----------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#define DBG_CERTSRV_DEBUG_PRINT

#ifdef DBG_CERTSRV_DEBUG_PRINT

#include <stdarg.h>


FILE *g_pfLog;
DWORD g_dwPrintMask = ~(DBG_SS_INFO | DBG_SS_MODLOAD | DBG_SS_NOQUIET);
CRITICAL_SECTION g_DBGCriticalSection;
BOOL g_fDBGCSInit = FALSE;

FNLOGSTRING *s_pfnLogString = NULL;


const char *
DbgGetSSString(
    IN DWORD dwSubSystemId)
{
    char const *psz = NULL;

    if (MAXDWORD != dwSubSystemId)
    {
	switch (dwSubSystemId & ~DBG_SS_INFO)
	{
	    case DBG_SS_ERROR:	   psz = "CertError";	break;
	    case DBG_SS_ASSERT:	   psz = "CertAssert";	break;
	    case DBG_SS_CERTHIER:  psz = "CertHier";	break;
	    case DBG_SS_CERTREQ:   psz = "CertReq";	break;
	    case DBG_SS_CERTUTIL:  psz = "CertUtil";	break;
	    case DBG_SS_CERTSRV:   psz = "CertSrv";	break;
	    case DBG_SS_CERTADM:   psz = "CertAdm";	break;
	    case DBG_SS_CERTCLI:   psz = "CertCli";	break;
	    case DBG_SS_CERTDB:	   psz = "CertDB";	break;
	    case DBG_SS_CERTENC:   psz = "CertEnc";	break;
	    case DBG_SS_CERTEXIT:  psz = "CertExit";	break;
	    case DBG_SS_CERTIF:	   psz = "CertIF";	break;
	    case DBG_SS_CERTMMC:   psz = "CertMMC";	break;
	    case DBG_SS_CERTOCM:   psz = "CertOCM";	break;
	    case DBG_SS_CERTPOL:   psz = "CertPol";	break;
	    case DBG_SS_CERTVIEW:  psz = "CertView";	break;
	    case DBG_SS_CERTBCLI:  psz = "CertBCli";	break;
	    case DBG_SS_CERTJET:   psz = "CertJet";	break;
	    case DBG_SS_CERTLIBXE: psz = "CertLibXE";	break;
	    case DBG_SS_CERTLIB:   psz = "CertLib";	break;
            case DBG_SS_AUDIT:     psz = "CertAudit";   break;
	    default:		   psz = "Cert";	break;
	}
    }
    return(psz);
}


DWORD
myatolx(
    char const *psz)
{
    DWORD dw = 0;

    while (isxdigit(*psz))
    {
	char ch = *psz++;

	if (isdigit(ch))
	{
	    ch -= '0';
	}
	else if (isupper(ch))
	{
	    ch += 10 - 'A';
	}
	else
	{
	    ch += 10 - 'a';
	}
	dw = (dw << 4) | ch;
    }
    return(dw);
}


VOID
DbgLogDateTime(
    IN CHAR const *pszPrefix)
{
    if (NULL != g_pfLog)
    {
	WCHAR *pwszDate;
	FILETIME ft;
	SYSTEMTIME st;

	fprintf(g_pfLog, "%hs: ", pszPrefix);
	GetSystemTime(&st);
	if (SystemTimeToFileTime(&st, &ft))
	{
	    if (S_OK == myGMTFileTimeToWszLocalTime(&ft, TRUE, &pwszDate))
	    {
		fprintf(g_pfLog, "%ws", pwszDate);
		LocalFree(pwszDate);
	    }
	}
	fprintf(g_pfLog, "\n");
    }
}


VOID
DbgCloseLogFile()
{
    if(g_fDBGCSInit)
    {
        EnterCriticalSection(&g_DBGCriticalSection);
        if (NULL != g_pfLog)
        {
	    DbgLogDateTime("Closed Log");
	    fclose(g_pfLog);
	    g_pfLog = NULL;
        }
        LeaveCriticalSection(&g_DBGCriticalSection);
    }
}


char const szHeader[] = "\n========================================================================\n";

VOID
DbgOpenLogFile(
    OPTIONAL IN CHAR const *pszFile)
{
    if (NULL != pszFile)
    {
	BOOL fAppend = FALSE;
	UINT cch;
	char aszLogFile[MAX_PATH];

	if ('+' == *pszFile)
	{
	    pszFile++;
	    fAppend = TRUE;
	}
	if (NULL == strchr(pszFile, '\\'))
	{
	    cch = GetWindowsDirectoryA(aszLogFile, ARRAYSIZE(aszLogFile));
	    if (0 != cch)
	    {
		if (L'\\' != aszLogFile[cch - 1])
		{
		    strcat(aszLogFile, "\\");
		}
		strcat(aszLogFile, pszFile);
		pszFile = aszLogFile;
	    }
	}

	DbgCloseLogFile();

	if (g_fDBGCSInit)
	{
	    EnterCriticalSection(&g_DBGCriticalSection);
	    while (TRUE)
	    {
		g_pfLog = fopen(pszFile, fAppend? "at" : "wt");
		if (NULL == g_pfLog)
		{
		    _PrintError(E_FAIL, "fopen(Log)");
		}
		else
		{
		    if (fAppend)
		    {
			DWORD cbLogMax = 0;
			char const *pszEnvVar;

			pszEnvVar = getenv(szCERTSRV_LOGMAX);
			if (NULL != pszEnvVar)
			{
			    cbLogMax = myatolx(pszEnvVar);
			}
			if (CBLOGMAXAPPEND > cbLogMax)
			{
			    cbLogMax = CBLOGMAXAPPEND;
			}
			if (0 == fseek(g_pfLog, 0L, SEEK_END) &&
			    MAXDWORD != cbLogMax)
			{
			    LONG lcbLog = ftell(g_pfLog);
			    
			    if (0 > lcbLog || cbLogMax < (DWORD) lcbLog)
			    {
				fclose(g_pfLog);
				g_pfLog = NULL;
				fAppend = FALSE;
				continue;
			    }
			}
			fprintf(g_pfLog, szHeader);
		    }
		    DbgLogDateTime("Opened Log");
		}
		break;
	    }
	    LeaveCriticalSection(&g_DBGCriticalSection);
	}
    }
}


VOID
DbgInit(
    IN BOOL fOpenDefaultLog)
{
    static BOOL s_fFirst = TRUE;

    if (s_fFirst)
    {
	char const *pszEnvVar;

	__try
	{
	    InitializeCriticalSection(&g_DBGCriticalSection);
	    g_fDBGCSInit = TRUE;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
	    return;
	}
	s_fFirst = FALSE;

	pszEnvVar = getenv(szCERTSRV_DEBUG);
	if (NULL != pszEnvVar)
	{
	    g_dwPrintMask = myatolx(pszEnvVar);
	}
	else
	{
	    HRESULT hr;
	    DWORD PrintMask;
	    
	    hr = myGetCertRegDWValue(
				NULL,
				NULL,
				NULL,
				wszREGCERTSRVDEBUG,
				&PrintMask);
	    if (S_OK == hr)
	    {
		g_dwPrintMask = PrintMask;
	    }
	}

	if (fOpenDefaultLog && NULL == g_pfLog)
	{
	    pszEnvVar = getenv(szCERTSRV_LOGFILE);
	    DbgOpenLogFile(pszEnvVar);
	}
    }
}


BOOL
DbgIsSSActive(
    IN DWORD dwSSIn)
{
    DbgInit(TRUE);
    if (MAXDWORD == dwSSIn)
    {
	return(TRUE);
    }
    if ((DBG_SS_INFO & dwSSIn) && 0 == (DBG_SS_INFO & g_dwPrintMask))
    {
	return(FALSE);
    }
    return(0 != (~DBG_SS_INFO & g_dwPrintMask & dwSSIn));
}


VOID
DbgLogStringInit(
    IN FNLOGSTRING *pfnLogString)
{
    if (NULL == s_pfnLogString)
    {
	s_pfnLogString = pfnLogString;
    }
}


VOID
DbgPrintfInit(
    OPTIONAL IN CHAR const *pszFile)
{
    DbgInit(NULL == pszFile);
    DbgOpenLogFile(pszFile);
}


VOID
fputsStripCR(
    IN BOOL fUnicode,
    IN char const *psz,
    IN FILE *pf)
{
    while ('\0' != *psz)
    {
	DWORD i;

	i = strcspn(psz, "\r");
	if (0 != i)
	{
	    if (fUnicode)
	    {
		if (IOBUNALIGNED(pf))
		{
		    fflush(pf);	// fails when running as a service
		}
		if (IOBUNALIGNED(pf))
		{
		    fprintf(pf, " ");
		    fflush(pf);
		}
		fwprintf(pf, L"%.*hs", i, psz);
	    }
	    else
	    {
		fprintf(pf, "%.*hs", i, psz);
	    }
	    psz += i;
	}
	if ('\r' == *psz)
	{
	    psz++;
	}
    }
}


//+-------------------------------------------------------------------------
//
//  Function:  DbgPrintf
//
//  Synopsis:  outputs debug info to stdout and debugger
//
//  Returns:   number of chars output
//
//--------------------------------------------------------------------------

int WINAPIV
DbgPrintf(
    IN DWORD dwSubSystemId,
    IN LPCSTR lpFmt,
    ...)
{
    va_list arglist;
    CHAR ach1[4096];
    CHAR ach2[4096 + 56];
    char *pch = NULL;
    char const *pszPrefix;
    int cch = 0;
    HANDLE hStdOut;
    DWORD cb;
    DWORD dwErr;
    BOOL fCritSecEntered = FALSE;

    dwErr = GetLastError();

    if (DbgIsSSActive(dwSubSystemId))
    {
	_try
	{
	    va_start(arglist, lpFmt);

	    cch = _vsnprintf(ach1, sizeof(ach1), lpFmt, arglist);

	    va_end(arglist);

	    if (0 > cch)
	    {
		pch = &ach1[sizeof(ach1) - 5];
		strcpy(pch, "...\n");
	    }
	    pch = ach1;

	    pszPrefix = DbgGetSSString(dwSubSystemId);
	    if (NULL != pszPrefix)
	    {
		cch = _snprintf(
			    ach2,
			    sizeof(ach2),
			    "%hs: %hs",
			    DbgGetSSString(dwSubSystemId),
			    ach1);
		if (0 > cch)
		{
		    pch = &ach2[sizeof(ach2) - 5];
		    strcpy(pch, "...\n");
		}
		pch = ach2;
	    }

	    EnterCriticalSection(&g_DBGCriticalSection);
	    fCritSecEntered = TRUE;
	    if (!IsDebuggerPresent())
	    {
		hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
		if (hStdOut != INVALID_HANDLE_VALUE)
		{
		    // WriteConsoleA drops the output on the floor when stdout
		    // is redirected to a file.
		    // WriteConsoleA(hStdOut, pch, strlen(pch), &cb, NULL);

		    fputsStripCR(TRUE, pch, stdout);
		    fflush(stdout);
		}
	    }
	    if (NULL != g_pfLog)
	    {
		fputsStripCR(FALSE, pch, g_pfLog);
		fflush(g_pfLog);
	    }
	    OutputDebugStringA(pch);
	}
	_except(EXCEPTION_EXECUTE_HANDLER)
	{
	    // return failure
	    cch = 0;
	}
    }
    if (fCritSecEntered)
    {
	LeaveCriticalSection(&g_DBGCriticalSection);
    }
    if (NULL != pch && NULL != s_pfnLogString)
    {
	(*s_pfnLogString)(pch);
    }
    SetLastError(dwErr);
    return(cch);
}
#endif // DBG_CERTSRV_DEBUG_PRINT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certclib\dstest.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        dstest.cpp
//
// Contents:    DS ping test
//
// History:     13-Mar-98       mattt created
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include <winldap.h>
#include <dsrole.h>
#include <dsgetdc.h>

#include <lmaccess.h>
#include <lmapibuf.h>
#include <cainfop.h>
#include "csldap.h"

#define __dwFILE__	__dwFILE_CERTCLIB_DSTEST_CPP__


#define DS_RETEST_SECONDS   3

HRESULT
myDoesDSExist(
    IN BOOL fRetry)
{
    HRESULT hr = S_OK;

    static BOOL s_fKnowDSExists = FALSE;
    static HRESULT s_hrDSExists = HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN);
    static FILETIME s_ftNextTest = {0,0};
    
    if (s_fKnowDSExists && (s_hrDSExists != S_OK) && fRetry)
    //    s_fKnowDSExists = FALSE;	// force a retry
    {
        FILETIME ftCurrent;
        GetSystemTimeAsFileTime(&ftCurrent);

        // if Compare is < 0 (next < current), force retest
        if (0 > CompareFileTime(&s_ftNextTest, &ftCurrent))
            s_fKnowDSExists = FALSE;    
    }

    if (!s_fKnowDSExists)
    {
        GetSystemTimeAsFileTime(&s_ftNextTest);

	// set NEXT in 100ns increments

        ((LARGE_INTEGER *) &s_ftNextTest)->QuadPart +=
	    (__int64) (CVT_BASE * CVT_SECONDS * 60) * DS_RETEST_SECONDS;

        // NetApi32 is delay loaded, so wrap to catch problems when it's not available
        __try
        {
            DOMAIN_CONTROLLER_INFO *pDCI;
            DSROLE_PRIMARY_DOMAIN_INFO_BASIC *pDsRole;
        
            // ensure we're not standalone
            pDsRole = NULL;
            hr = DsRoleGetPrimaryDomainInformation(	// Delayload wrapped
				    NULL,
				    DsRolePrimaryDomainInfoBasic,
				    (BYTE **) &pDsRole);

            _PrintIfError(hr, "DsRoleGetPrimaryDomainInformation");
            if (S_OK == hr &&
                (pDsRole->MachineRole == DsRole_RoleStandaloneServer ||
                 pDsRole->MachineRole == DsRole_RoleStandaloneWorkstation))
            {
                hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN);
		_PrintError(hr, "DsRoleGetPrimaryDomainInformation(no domain)");
            }

            if (NULL != pDsRole) 
	    {
                DsRoleFreeMemory(pDsRole);     // Delayload wrapped
	    }
            if (S_OK == hr)
            {
                // not standalone; return info on our DS

                pDCI = NULL;
                hr = DsGetDcName(    // Delayload wrapped
			    NULL,
			    NULL,
			    NULL,
			    NULL,
			    DS_DIRECTORY_SERVICE_PREFERRED,
			    &pDCI);
		_PrintIfError(hr, "DsGetDcName");
            
                if (S_OK == hr && 0 == (pDCI->Flags & DS_DS_FLAG))
                {
                    hr = HRESULT_FROM_WIN32(ERROR_CANT_ACCESS_DOMAIN_INFO);
		    _PrintError(hr, "DsGetDcName(no domain info)");
                }
                if (NULL != pDCI)
                {
                   NetApiBufferFree(pDCI);    // Delayload wrapped
                }
            }
            s_fKnowDSExists = TRUE;
        }
        __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
        {
        }

        // else just allow users without netapi flounder with timeouts
        // if ds not available...

        s_hrDSExists = myHError(hr);
	_PrintIfError2(
		s_hrDSExists,
		"DsRoleGetPrimaryDomainInformation/DsGetDcName",
		HRESULT_FROM_WIN32(ERROR_NETWORK_UNREACHABLE));
    }
    return(s_hrDSExists);
}


HRESULT
myRobustLdapBind(
    OUT LDAP **ppldap,
    IN BOOL fGC)
{
    return(myRobustLdapBindEx(fGC, FALSE, LDAP_VERSION2, NULL, ppldap, NULL));
}


HRESULT
myRobustLdapBindEx(
    IN BOOL fGC,
    IN BOOL fRediscover,
    IN ULONG uVersion,
    OPTIONAL IN WCHAR const *pwszDomainName,
    OUT LDAP **ppldap,
    OPTIONAL OUT WCHAR **ppwszForestDNSName)
{
    HRESULT hr;
    ULONG ldaperr;
    DWORD GetDSNameFlags;
    LDAP *pld = NULL;

    GetDSNameFlags = DS_RETURN_DNS_NAME;
    if (fGC)
    {
        GetDSNameFlags |= DS_GC_SERVER_REQUIRED;
    }

    // bind to ds

    while (TRUE)
    {
        if (NULL != pld)
        {
            ldap_unbind(pld);
        }

	pld = ldap_init(
		    const_cast<WCHAR *>(pwszDomainName),
		    fGC? LDAP_GC_PORT : LDAP_PORT);
	if (NULL == pld)
	{
	    hr = myHLdapLastError(NULL, NULL);
	    if (!fRediscover)
	    {
		_PrintError2(hr, "ldap_init", hr);
		fRediscover = TRUE;
		continue;
	    }
	    _JumpError(hr, error, "ldap_init");
	}

	if (fRediscover)
	{
	   GetDSNameFlags |= DS_FORCE_REDISCOVERY;
	}
	ldaperr = ldap_set_option(
			    pld,
			    LDAP_OPT_GETDSNAME_FLAGS,
			    (VOID *) &GetDSNameFlags);
	if (LDAP_SUCCESS != ldaperr)
	{
	    hr = myHLdapError(pld, ldaperr, NULL);
	    if (!fRediscover)
	    {
		_PrintError2(hr, "ldap_set_option", hr);
		fRediscover = TRUE;
		continue;
	    }
	    _JumpError(hr, error, "ldap_set_option");
	}

	// do not want this to turn on if uVersion is not LDAP_VERSION2

	//if (LDAP_VERSION2 == uVersion)
	if (IsWhistler())
	{
	    ldaperr = ldap_set_option(pld, LDAP_OPT_SIGN, LDAP_OPT_ON);
	    if (LDAP_SUCCESS != ldaperr)
	    {
		hr = myHLdapError2(pld, ldaperr, LDAP_PARAM_ERROR, NULL);
		if (!fRediscover)
		{
		    _PrintError2(hr, "ldap_set_option", hr);
		    fRediscover = TRUE;
		    continue;
		}
		_JumpError(hr, error, "ldap_set_option");
	    }
	}

	// set the client version.  No need to set LDAP_VERSION2 since 
	// this is the default

	if (LDAP_VERSION2 != uVersion)
	{
	    ldaperr = ldap_set_option(pld, LDAP_OPT_VERSION, &uVersion);
	    if (LDAP_SUCCESS != ldaperr)
	    {
		hr = myHLdapError(pld, ldaperr, NULL);
		if (!fRediscover)
		{
		    _PrintError2(hr, "ldap_set_option", hr);
		    fRediscover = TRUE;
		    continue;
		}
		_JumpError(hr, error, "ldap_set_option");
	    }
	}

	ldaperr = ldap_bind_s(pld, NULL, NULL, LDAP_AUTH_NEGOTIATE);
	if (LDAP_SUCCESS != ldaperr)
	{
	    hr = myHLdapError(pld, ldaperr, NULL);
	    if (!fRediscover)
	    {
		_PrintError2(hr, "ldap_bind_s", hr);
		fRediscover = TRUE;
		continue;
	    }
	    _JumpError(hr, error, "ldap_bind_s");
	}

	if (NULL != ppwszForestDNSName)
	{
	    WCHAR *pwszDomainControllerName;

	    hr = myLdapGetDSHostName(pld, &pwszDomainControllerName);
	    if (S_OK != hr)
	    {
		if (!fRediscover)
		{
		    _PrintError2(hr, "myLdapGetDSHostName", hr);
		    fRediscover = TRUE;
		    continue;
		}
		_JumpError(hr, error, "myLdapGetDSHostName");
	    }
	    hr = myDupString(pwszDomainControllerName, ppwszForestDNSName);
	    _JumpIfError(hr, error, "myDupString");
	}
	break;
    }
    *ppldap = pld;
    pld = NULL;
    hr = S_OK;

error:
    if (NULL != pld)
    {
        ldap_unbind(pld);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certclib\ctnotify.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 2000
//
// File:        ctnotify.cpp
//
// Contents:    Cert Type Change Notification APIS
//
//---------------------------------------------------------------------------
#include "pch.cpp"

#pragma hdrstop

#include <winldap.h>
#include <ntldap.h>
#include <cainfop.h>
#include <ctnotify.h>
#include <certca.h>
#include "csldap.h"

static WCHAR * s_wszLocation = L"CN=Certificate Templates,CN=Public Key Services,CN=Services,";

//-----------------------------------------------------------------------
//
//  CertTypeQueryProc
//
//      The thread to recieve change notification from DS
//
//-----------------------------------------------------------------------
DWORD WINAPI CertTypeQueryProc(LPVOID lpParameter)
{
    CERTTYPE_QUERY_INFO     *pCertTypeQueryInfo=NULL;
    ULONG                   ldaperr=0;

    LDAPMessage             *results = NULL;

    if(NULL==lpParameter)
        return FALSE;

    pCertTypeQueryInfo = (CERTTYPE_QUERY_INFO *)lpParameter;

    //we wait for the notifications
    while(TRUE)
    {
        ldaperr = ldap_result(
            pCertTypeQueryInfo->pldap, 
            pCertTypeQueryInfo->msgID,      // message identifier
            LDAP_MSG_ONE,                   // retrieve one message at a time
            NULL,                           // no timeout
            &results);                      // receives the search results
    
        if ((ldaperr == (ULONG) -1) || ((results) == NULL)) 
        {
            //the result failed
            break;
        }

        //some change has happened.
        (pCertTypeQueryInfo->dwChangeSequence)++;

        //make sure that we will never return 0
        if(0 == (pCertTypeQueryInfo->dwChangeSequence))
        {
            (pCertTypeQueryInfo->dwChangeSequence)++;
        }

        ldap_msgfree(results);
        results=NULL;
    }

    return TRUE;
}

//---------------------------------------------------------------------------
//
// CACertTypeRegisterQuery
//
//---------------------------------------------------------------------------
HRESULT
CACertTypeRegisterQuery(
    IN	DWORD               dwFlag,
    IN  LPVOID              pvldap,
    OUT HCERTTYPEQUERY      *phCertTypeQuery)
{
 

    HRESULT                 hr=E_INVALIDARG;
    LDAPControl             simpleControl;
    PLDAPControl            controlArray[2];
    LPWSTR                  rgwszAttribs[2];
    ULONG                   ldaperr=0;    
    DWORD                   dwThreadID=0;
    LDAP                    *pldap=NULL;   

    CERTSTR                 bstrConfig = NULL;
    CERTSTR                 bstrCertTemplatesContainer = NULL;
    //memory is freed via the thread proc
    CERTTYPE_QUERY_INFO     *pCertTypeQueryInfo=NULL;


    //assign the input parameter
    pldap = (LDAP *)pvldap;   


    if(NULL==phCertTypeQuery)
	    _JumpError(hr, error, "NULL param");

    pCertTypeQueryInfo=(CERTTYPE_QUERY_INFO *)LocalAlloc(LPTR, sizeof(CERTTYPE_QUERY_INFO));

    if(NULL==pCertTypeQueryInfo)
    {
        hr=E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
    }

    memset(pCertTypeQueryInfo, 0, sizeof(CERTTYPE_QUERY_INFO));

    //we start the change sequence as 1
    pCertTypeQueryInfo->dwChangeSequence = 1;

    //bind to DS
    if(pldap)
    {
        pCertTypeQueryInfo->pldap=pldap;
    }
    else
    {
        //retrieve the ldap handle
        if(S_OK != (hr = myDoesDSExist(TRUE)))
            _JumpError(hr , error, "myDoesDSExist");

        hr = myRobustLdapBindEx(
                        FALSE,			// fGC
                        FALSE,			// fRediscover
                        LDAP_VERSION3,		// uVersion
			NULL,			// pwszDomainName
                        &pCertTypeQueryInfo->pldap, 
                        NULL);			// ppwszForestDNSName
	_JumpIfError(hr , error, "myRobustLdapBindEx");

        pCertTypeQueryInfo->fUnbind=TRUE;
    }

    //retrieve the config string
	hr = CAGetAuthoritativeDomainDn(pCertTypeQueryInfo->pldap, NULL, &bstrConfig);
	if(S_OK != hr)
	{
        _JumpError(hr , error, "CAGetAuthoritativeDomainDn");
	}

    //build the template container DN
    bstrCertTemplatesContainer = CertAllocStringLen(NULL, wcslen(bstrConfig) + wcslen(s_wszLocation));
    if(bstrCertTemplatesContainer == NULL)
    {
        hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "CertAllocStringLen");
    }
    wcscpy(bstrCertTemplatesContainer, s_wszLocation);
    wcscat(bstrCertTemplatesContainer, bstrConfig);

    // Set up the change notification control.
    simpleControl.ldctl_oid = LDAP_SERVER_NOTIFICATION_OID_W;
    simpleControl.ldctl_iscritical = TRUE;
    simpleControl.ldctl_value.bv_len = 0;
    simpleControl.ldctl_value.bv_val = NULL;
    controlArray[0] = &simpleControl;
    controlArray[1] = NULL;

    rgwszAttribs[0] = L"cn";
    rgwszAttribs[1] = NULL;
 

    // Start a persistent asynchronous search.
    ldaperr   = ldap_search_ext( 
                     pCertTypeQueryInfo->pldap,
                     (PWCHAR) bstrCertTemplatesContainer,   // Template container DN
                     LDAP_SCOPE_ONELEVEL,
                     L"ObjectClass=*",
                     rgwszAttribs,                          // Attributes to retrieve
                     1,                                     // Retrieve attributes only
                     (PLDAPControl *) &controlArray,        // Server size controls
                     NULL,                                  // Client controls
                     0,                                     // Timeout
                     0,                                     // Sizelimit
                     (PULONG)&(pCertTypeQueryInfo->msgID)   // Receives identifier for results
                      );

    if (LDAP_SUCCESS != ldaperr) 
    {
	hr = myHLdapError(pCertTypeQueryInfo->pldap, ldaperr, NULL);
	_JumpError(hr, error, "ldap_search_ext");
    }

    //start a thread to wait for the notification
    pCertTypeQueryInfo->hThread = CreateThread(
                            NULL,
                            0,
                            CertTypeQueryProc,
                            pCertTypeQueryInfo,
                            0,          //execute immediately
                            &dwThreadID);  

    if(NULL == pCertTypeQueryInfo->hThread)
    {
        hr=myHError(GetLastError());
	    _JumpError(hr, error, "CreateThread");
    }

    *phCertTypeQuery=pCertTypeQueryInfo;

    pCertTypeQueryInfo=NULL;

    hr=S_OK;

error:

    if(bstrConfig)
        CertFreeString(bstrConfig);

    if(bstrCertTemplatesContainer)
    {
        CertFreeString(bstrCertTemplatesContainer);
    }

    if(pCertTypeQueryInfo)
    {
        if(pCertTypeQueryInfo->fUnbind)
        {
            if(pCertTypeQueryInfo->pldap)
                ldap_unbind(pCertTypeQueryInfo->pldap);
        }

        if(pCertTypeQueryInfo->hThread)
            CloseHandle(pCertTypeQueryInfo->hThread);

        LocalFree(pCertTypeQueryInfo);

	pCertTypeQueryInfo=NULL;
    }

    return hr;

}



//---------------------------------------------------------------------------
//
// CACertTypeQuery
//
//---------------------------------------------------------------------------
HRESULT
CACertTypeQuery(
    IN	HCERTTYPEQUERY  hCertTypeQuery,
    OUT DWORD           *pdwChangeSequence)
{
    CERTTYPE_QUERY_INFO *pCertTypeQueryInfo=NULL;

    if((NULL==pdwChangeSequence) || (NULL==hCertTypeQuery))
        return E_INVALIDARG;

    pCertTypeQueryInfo = (CERTTYPE_QUERY_INFO *)hCertTypeQuery;

    *pdwChangeSequence = pCertTypeQueryInfo->dwChangeSequence;

    return S_OK;
}



//---------------------------------------------------------------------------
//
// CACertTypeUnregisterQuery
//
//---------------------------------------------------------------------------
HRESULT
CACertTypeUnregisterQuery(
    IN	HCERTTYPEQUERY  hCertTypeQuery)
{
    CERTTYPE_QUERY_INFO *pCertTypeQueryInfo=NULL;
    ULONG               ldaperr=0;
    HRESULT             hr=E_INVALIDARG;
    DWORD               dwWait=0;

    if(NULL==hCertTypeQuery)
	    _JumpError(hr, error, "NULL param");

    pCertTypeQueryInfo = (CERTTYPE_QUERY_INFO *)hCertTypeQuery;

    if(NULL == (pCertTypeQueryInfo->pldap))
	    _JumpError(hr, error, "NULL pldap");

    //abandom the in-progress asynchronous ldap_result call
    ldaperr=ldap_abandon(pCertTypeQueryInfo->pldap, pCertTypeQueryInfo->msgID);

    if(LDAP_SUCCESS != ldaperr)
    {
	hr = myHLdapError(pCertTypeQueryInfo->pldap, ldaperr, NULL);
	_JumpError(hr, error, "ldap_abandon");
    }

    //wait for the thread to finish
    dwWait = WaitForSingleObject(pCertTypeQueryInfo->hThread, INFINITE);

    if(WAIT_OBJECT_0 != dwWait)
    {
        hr = myHError(GetLastError());
        _JumpError(hr, error, "WaitForSingleObject");
    }

    hr=S_OK;

error:

    //free the memory
    if(pCertTypeQueryInfo)
    {
        if(pCertTypeQueryInfo->fUnbind)
        {
            if(pCertTypeQueryInfo->pldap)
                ldap_unbind(pCertTypeQueryInfo->pldap);
        }

        if(pCertTypeQueryInfo->hThread)
            CloseHandle(pCertTypeQueryInfo->hThread);

        LocalFree(pCertTypeQueryInfo);

	pCertTypeQueryInfo=NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certclib\oidmgr.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        oidmgr.cpp
//
// Contents:    DS OID management functions.
//
//---------------------------------------------------------------------------
#include "pch.cpp"

#pragma hdrstop

#include <winldap.h>
#include <ntldap.h>
#include <cainfop.h>
#include <oidmgr.h>
#include <certca.h>
#include "csldap.h"

#define __dwFILE__	__dwFILE_CERTCLIB_OIDMGR_CPP__


//the global critical section
CRITICAL_SECTION        g_csOidURL;
extern BOOL             g_fOidURL;
ULARGE_INTEGER          g_ftOidTime;
BOOL                    g_fFailedTime=FALSE;

//the # of seconds in which we will not re-find a DC
#define     CA_OID_MGR_FAIL_PERIOD              5
#define     FILETIME_TICKS_PER_SECOND           10000000

//the cache of the enterprise root oid
LPWSTR   g_pwszEnterpriseRootOID=NULL;  

static WCHAR * s_wszOIDContainerSearch = L"(&(CN=OID)(objectCategory=" wszDSOIDCLASSNAME L"))";
static WCHAR * s_wszOIDContainerDN = L"CN=OID,CN=Public Key Services,CN=Services,";
 
WCHAR *g_awszOIDContainerAttrs[] = {OID_CONTAINER_PROP_OID,
                                    OID_CONTAINER_PROP_GUID,
                                    NULL};

//---------------------------------------------------------------------------
//
//  CAOIDAllocAndCopy
//
//---------------------------------------------------------------------------
HRESULT CAOIDAllocAndCopy(LPWSTR    pwszSrc,
                          LPWSTR    *ppwszDest)
{
    if((NULL==ppwszDest) || (NULL==pwszSrc))
        return E_INVALIDARG;

    *ppwszDest=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * (wcslen(pwszSrc) + 1));
    if(NULL==(*ppwszDest))
        return E_OUTOFMEMORY;

    wcscpy(*ppwszDest, pwszSrc);
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  CAOIDGetRandom
//
//  We build a random x1.x2 string.  X is a 32 bit unsigned integer.  x1 > 1
//  and x2 > 500.
//---------------------------------------------------------------------------
HRESULT CAOIDGetRandom(LPWSTR   *ppwszRandom)
{
    HRESULT         hr=E_FAIL;
    DWORD           dwRandom1=0;
    DWORD           dwRandom2=0;
    DWORD           cbData=sizeof(DWORD);
    WCHAR           wszRandom1[DWORD_STRING_LENGTH];
    WCHAR           wszRandom2[DWORD_STRING_LENGTH];

    HCRYPTPROV      hProv=NULL;
    
    //there is a bug in cryptAcquireContextW that if container is NULL, provider
    //can not be ansi.
	if(!CryptAcquireContextA(
                &hProv,
                NULL,
                MS_DEF_PROV_A,
                PROV_RSA_FULL,
                CRYPT_VERIFYCONTEXT))
    {
        hr= myHLastError();
        _JumpError(hr, error, "CryptAcquireContextA");
    }

	if(!CryptGenRandom(hProv, cbData, (BYTE *)&dwRandom1))
    {
        hr= myHLastError();
        _JumpError(hr, error, "CryptGenRandom");
    }

	if(!CryptGenRandom(hProv, cbData, (BYTE *)&dwRandom2))
    {
        hr= myHLastError();
        _JumpError(hr, error, "CryptGenRandom");
    }

    if(dwRandom1 <= OID_RESERVE_DEFAULT_ONE)
        dwRandom1 +=OID_RESERVE_DEFAULT_ONE;
    
    if(dwRandom2 <= OID_RESERVR_DEFAULT_TWO)
        dwRandom2 += OID_RESERVR_DEFAULT_TWO;

    wszRandom1[0]=L'\0';
    wsprintf(wszRandom1, L"%lu", dwRandom1);
    wszRandom2[0]=L'\0';
    wsprintf(wszRandom2, L"%lu", dwRandom2);

    *ppwszRandom=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * 
        (wcslen(wszRandom1) + wcslen(wszOID_DOT) + wcslen(wszRandom2) + 1));

    if(NULL==(*ppwszRandom))
    {
        hr= E_OUTOFMEMORY;
        _JumpError(hr, error, "CryptGenRandom");
    }

    wcscpy(*ppwszRandom, wszRandom1);
    wcscat(*ppwszRandom, wszOID_DOT);
    wcscat(*ppwszRandom, wszRandom2);

    hr=S_OK;

error:
    
    if(hProv)
        CryptReleaseContext(hProv, 0);

    return hr;
}

//---------------------------------------------------------------------------
//
//  CAOIDMapGUIDToOID
//
//  GUID string is in the form of DWORD.DWORD.DWORD.DWORD
//  12 characters are sufficient to present a 2^32 value.
//---------------------------------------------------------------------------
HRESULT     CAOIDMapGUIDToOID(LDAP_BERVAL *pGuidVal, LPWSTR   *ppwszGUID)
{
    HRESULT     hr=E_INVALIDARG;
    DWORD       iIndex=0;
    WCHAR       wszString[DWORD_STRING_LENGTH];

    *ppwszGUID=NULL;

    if((4 * sizeof(DWORD)) != (pGuidVal->bv_len))
	    _JumpError(hr, error, "ArgumentCheck");
    
    *ppwszGUID=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * GUID_STRING_LENGTH);
    if(NULL==(*ppwszGUID))
    {
        hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
    }

    for(iIndex=0; iIndex < 4; iIndex++)
    {
        wszString[0]=L'\0';
        wsprintf(wszString, L"%lu",  ((DWORD *)(pGuidVal->bv_val))[iIndex]);
        
        if(0==iIndex)
        {
            wcscpy(*ppwszGUID, wszString);
        }
        else
        {
            wcscat(*ppwszGUID, wszOID_DOT);
            wcscat(*ppwszGUID, wszString);
        }
    }

    hr = S_OK;

error:
    return hr;
    
}
//--------------------------------------------------------------------------
//
//	  FormatMessageUnicode
//
//--------------------------------------------------------------------------
HRESULT	FormatMessageUnicode(LPWSTR	*ppwszFormat,LPWSTR pwszString,...)
{
	va_list		argList;
	DWORD		cbMsg=0;

    // format message into requested buffer
    va_start(argList, pwszString);

    cbMsg = FormatMessageW(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
        pwszString,
        0,                  // dwMessageId
        0,                  // dwLanguageId
        (LPWSTR) (ppwszFormat),
        0,                  // minimum size to allocate
        &argList);

    va_end(argList);

	if(0 != cbMsg)
	    return S_OK;

	return E_INVALIDARG;
}

//---------------------------------------------------------------------------
//
//  DoesOIDExist
//
//
//---------------------------------------------------------------------------
BOOL    DoesOIDExist(LDAP       *pld, 
                     LPWSTR     bstrConfig, 
                     LPCWSTR     pwszOID)
{
    BOOL                fExit=FALSE;
    struct l_timeval    timeout;
    ULONG               ldaperr=0;
    DWORD               dwCount=0;
    LPWSTR              awszAttr[2];

    CERTSTR             bstrDN = NULL;
    LDAPMessage         *SearchResult = NULL;
    LPWSTR              pwszFilter = NULL;

    if(NULL==pwszOID)
        goto error;

    bstrDN = CertAllocStringLen(NULL, wcslen(bstrConfig) + wcslen(s_wszOIDContainerDN));
    if(NULL == bstrDN)
        goto error;

    wcscpy(bstrDN, s_wszOIDContainerDN);
    wcscat(bstrDN, bstrConfig);

    timeout.tv_sec = csecLDAPTIMEOUT;
    timeout.tv_usec = 0;

    awszAttr[0]=OID_PROP_OID;
    awszAttr[1]=NULL;
    
    if(S_OK != FormatMessageUnicode(&pwszFilter, L"(%1!s!=%2!s!)",
                                    OID_PROP_OID, pwszOID))
        goto error;

    __try
    {
	    ldaperr = ldap_search_stW(
                  pld, 
		          (LPWSTR)bstrDN,
		          LDAP_SCOPE_ONELEVEL,
		          pwszFilter,
		          awszAttr,
		          0,
                  &timeout,
		          &SearchResult);

        if(LDAP_SUCCESS != ldaperr)
            goto error;

        dwCount = ldap_count_entries(pld, SearchResult);

        if(0 != dwCount)
            fExit=TRUE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }
error:
    if(pwszFilter)
        LocalFree((HLOCAL)pwszFilter);

    if(SearchResult)
        ldap_msgfree(SearchResult);

    if(bstrDN)
        CertFreeString(bstrDN);

    return fExit;
}
//---------------------------------------------------------------------------
//
// CAOIDUpdateDS
//
//
//---------------------------------------------------------------------------
HRESULT     CAOIDUpdateDS(LDAP          *pld, 
                          LPWSTR        pwszConfig, 
                          ENT_OID_INFO  *pOidInfo)
{
    HRESULT         hr=E_INVALIDARG;
    BOOL            fNew=FALSE;
    ULONG           ldaperr=0;
    LDAPMod         modObjectClass,
                    modCN,
                    modType,
                    modOID,
                    modDisplayName,
                    modCPS;
    LDAPMod         *mods[OID_ATTR_COUNT + 1];
    DWORD           cMod=0;
    WCHAR           wszType[DWORD_STRING_LENGTH];
    LPWSTR          awszObjectClass[3],
                    awszCN[2],
                    awszType[2],
                    awszOID[2],
                    awszDisplayName[2],
                    awszCPS[2];
    CHAR            sdBerValue[] = {0x30, 0x03, 0x02, 0x01,  DACL_SECURITY_INFORMATION | 
                                                  OWNER_SECURITY_INFORMATION | 
                                                  GROUP_SECURITY_INFORMATION};
    LDAPControl     se_info_control =
                        {
                            LDAP_SERVER_SD_FLAGS_OID_W,
                            {
                                5, sdBerValue
                            },
                            TRUE
                        };

    LDAPControl     permissive_modify_control =
                        {
                            LDAP_SERVER_PERMISSIVE_MODIFY_OID_W,
                            {
                                0, NULL
                            },
                            FALSE
                        };

    PLDAPControl    server_controls[3] =
                        {
                            &se_info_control,
                            &permissive_modify_control,
                            NULL
                        };
    CHAR            sdBerValueDaclOnly[] = {0x30, 0x03, 0x02, 0x01,  DACL_SECURITY_INFORMATION};
    LDAPControl     se_info_control_dacl_only =
                        {
                            LDAP_SERVER_SD_FLAGS_OID_W,
                            {
                                5, sdBerValueDaclOnly
                            },
                            TRUE
                        };
    PLDAPControl    server_controls_dacl_only[3] =
                        {
                            &se_info_control_dacl_only,
                            &permissive_modify_control,
                            NULL
                        };



    CERTSTR         bstrDN = NULL;
    LPWSTR          pwszCN = NULL;

    if(NULL== (pOidInfo->pwszOID))
        _JumpError(hr , error, "ArgumentCheck");

    //if we are changing the OID value, we are creating a new oid
    fNew = OID_ATTR_OID & (pOidInfo->dwAttr);

    //set up the base DN
    if(S_OK != (hr = myOIDHashOIDToString(pOidInfo->pwszOID,  &pwszCN)))
        _JumpError(hr , error, "myOIDHashOIDToString");

    bstrDN = CertAllocStringLen(NULL, wcslen(pwszConfig) + wcslen(s_wszOIDContainerDN)+wcslen(pwszCN)+4);
    if(bstrDN == NULL)
    {
        hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "CertAllocStringLen");
    }
    wcscpy(bstrDN, L"CN=");
    wcscat(bstrDN, pwszCN);
    wcscat(bstrDN, L",");
    wcscat(bstrDN, s_wszOIDContainerDN);
    wcscat(bstrDN, pwszConfig);

    //set up all the mods
    modObjectClass.mod_op = LDAP_MOD_REPLACE;
    modObjectClass.mod_type = L"objectclass";
    modObjectClass.mod_values = awszObjectClass;
    awszObjectClass[0] = wszDSTOPCLASSNAME;
    awszObjectClass[1] = wszDSOIDCLASSNAME;
    awszObjectClass[2] = NULL;
    mods[cMod++] = &modObjectClass;

    modCN.mod_op = LDAP_MOD_REPLACE;
    modCN.mod_type =  L"cn";
    modCN.mod_values = awszCN;
    awszCN[0] = pwszCN;
    awszCN[1] = NULL;
    mods[cMod++] = &modCN;

    modOID.mod_op = LDAP_MOD_REPLACE;
    modOID.mod_type = OID_PROP_OID;
    modOID.mod_values = awszOID;
    awszOID[0] = pOidInfo->pwszOID;
    awszOID[1] = NULL;
    mods[cMod++] = &modOID;

    if(OID_ATTR_DISPLAY_NAME & (pOidInfo->dwAttr))
    {
        modDisplayName.mod_op = LDAP_MOD_REPLACE;
        modDisplayName.mod_type = OID_PROP_DISPLAY_NAME;

        if(pOidInfo->pwszDisplayName)
        {
            modDisplayName.mod_values = awszDisplayName;
            awszDisplayName[0] = pOidInfo->pwszDisplayName;
            awszDisplayName[1] = NULL;
        }
        else
            modDisplayName.mod_values = NULL;

	    if(!fNew)
        	mods[cMod++] = &modDisplayName;
    }

    if(OID_ATTR_CPS & (pOidInfo->dwAttr))
    {
        modCPS.mod_op = LDAP_MOD_REPLACE;
        modCPS.mod_type = OID_PROP_CPS;

        if(pOidInfo->pwszCPS)
        {
            modCPS.mod_values = awszCPS;
            awszCPS[0] = pOidInfo->pwszCPS;
            awszCPS[1] = NULL;
        }
        else
            modCPS.mod_values = NULL;

	    if(!fNew)
        	mods[cMod++] = &modCPS;
    }

    if(OID_ATTR_TYPE & (pOidInfo->dwAttr))
    {
        modType.mod_op = LDAP_MOD_REPLACE;
        modType.mod_type = OID_PROP_TYPE;
        modType.mod_values = awszType;
        awszType[0] = wszType;
        awszType[1] = NULL;
        wsprintf(wszType, L"%d", pOidInfo->dwType);
        mods[cMod++] = &modType;
    }

    mods[cMod++]=NULL;

	//update the DS 
    __try
    {
        if(fNew)
        {
            ldaperr = ldap_add_ext_sW(pld, bstrDN, mods, server_controls, NULL);
		    _PrintIfError(ldaperr, "ldap_add_s");
        }
        else
        {
            ldaperr = ldap_modify_ext_sW(
                  pld, 
                  bstrDN,
                  &mods[2],
                  server_controls_dacl_only,
                  NULL);  // skip past objectClass and cn

            if(LDAP_ATTRIBUTE_OR_VALUE_EXISTS == ldaperr)
                ldaperr = LDAP_SUCCESS;

		    _PrintIfError(ldaperr, "ldap_modify_ext_sW");
        }

        if ((LDAP_SUCCESS != ldaperr) && (LDAP_ALREADY_EXISTS != ldaperr))
        {
	    hr = myHLdapError(pld, ldaperr, NULL);
	    _JumpError(ldaperr, error, fNew? "ldap_add_s" : "ldap_modify_sW");
        }

        hr=S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    if(pwszCN)
        LocalFree(pwszCN);

    if(bstrDN)
        CertFreeString(bstrDN);

    return hr;
}

//---------------------------------------------------------------------------
//
//  CAOIDRetrieveEnterpriseRootWithConfig
//
//  Get the enterpriseRoot from the displayName attribute of the container.
//  If the attribute is missing, add the one with GUID of the container.
//
//  Free memory via LocalFree().
//---------------------------------------------------------------------------
HRESULT     CAOIDRetrieveEnterpriseRootWithConfig(LDAP  *pld,
                                        LPWSTR  pwszConfig,
                                        DWORD   dwFlag, 
                                        LPWSTR  *ppwszOID)
{
    HRESULT             hr=E_INVALIDARG;
    struct l_timeval    timeout;
    ULONG               ldaperr=0;
    DWORD               dwCount=0;
    LDAPMessage         *Entry=NULL;
    LDAPMod             *mods[2];
    LDAPMod             modOIDName;
    LPWSTR              valOIDName[2];
    CHAR                sdBerValueDaclOnly[] = {0x30, 0x03, 0x02, 0x01,  DACL_SECURITY_INFORMATION};
    LDAPControl         se_info_control_dacl_only =
                            {
                                LDAP_SERVER_SD_FLAGS_OID_W,
                                {
                                    5, sdBerValueDaclOnly
                                },
                                TRUE
                            };
    LDAPControl         permissive_modify_control =
                            {
                                LDAP_SERVER_PERMISSIVE_MODIFY_OID_W,
                                {
                                    0, NULL
                                },
                                FALSE
                            };
    PLDAPControl        server_controls_dacl_only[3] =
                            {
                                &se_info_control_dacl_only,
                                &permissive_modify_control,
                                NULL
                            };


    CERTSTR             bstrOIDContainer = NULL;
    LDAPMessage         *SearchResult = NULL;
    WCHAR               **wszLdapVal = NULL;
    LDAP_BERVAL         **pGuidVal = NULL;
    LPWSTR              pwszGUID = NULL;

    __try
    {

        if(NULL==ppwszOID)
            _JumpError(hr , error, "ArgumentCheck");

        *ppwszOID=NULL;

        //retrive the displayName attribute of the container if available
        bstrOIDContainer = CertAllocStringLen(NULL, wcslen(pwszConfig) + wcslen(s_wszOIDContainerDN));
        if(NULL == bstrOIDContainer)
        {
            hr = E_OUTOFMEMORY;
	        _JumpError(hr, error, "CertAllocStringLen");
        }
    
        wcscpy(bstrOIDContainer, s_wszOIDContainerDN);
        wcscat(bstrOIDContainer, pwszConfig);

        timeout.tv_sec = csecLDAPTIMEOUT;
        timeout.tv_usec = 0;
    
	    ldaperr = ldap_search_stW(
			  pld, 
		          (LPWSTR)bstrOIDContainer,
		          LDAP_SCOPE_BASE,
		          s_wszOIDContainerSearch,
		          g_awszOIDContainerAttrs,
		          0,
			  &timeout,
		          &SearchResult);

        if(LDAP_SUCCESS != ldaperr)
        {
	    hr = myHLdapError(pld, ldaperr, NULL);
	    _JumpError(hr, error, "ldap_search_stW");
        }

        dwCount = ldap_count_entries(pld, SearchResult);

        //we should only find one container
        if((1 != dwCount) || (NULL == (Entry = ldap_first_entry(pld, SearchResult))))
	    {
	        // No entries were found.
		hr = myHLdapError(pld, LDAP_NO_SUCH_OBJECT, NULL);
	        _JumpError(hr, error, "ldap_search_stW");
	    }

        wszLdapVal = ldap_get_values(pld, Entry, OID_CONTAINER_PROP_OID);

        //make sure the displayName is a valud enterprise OID
        if(wszLdapVal && wszLdapVal[0])
        {
            hr=CAOIDAllocAndCopy(wszLdapVal[0], ppwszOID);

            if(S_OK == hr)
            {
                //cache the enterprise root
                CAOIDAllocAndCopy(*ppwszOID, &g_pwszEnterpriseRootOID);
                goto error;
            }
        }

        //no displayName is present or valid, we have to derive the displayName
        //from the GUID of the container
        pGuidVal = ldap_get_values_len(pld, Entry, OID_CONTAINER_PROP_GUID);

        if((NULL==pGuidVal) || (NULL==pGuidVal[0]))
        {
	    hr = myHLdapError(pld, LDAP_NO_SUCH_ATTRIBUTE, NULL);
            _JumpError(hr, error, "getGUIDFromDS");
        }

        if(S_OK != (hr=CAOIDMapGUIDToOID(pGuidVal[0], &pwszGUID)))
            _JumpError(hr, error, "CAOIDMapGUIDToOID");

        //contantenate the strings
        *ppwszOID=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * 
                (wcslen(wszOID_ENTERPRISE_ROOT) + wcslen(wszOID_DOT) + wcslen(pwszGUID) + 1));

        if(NULL==(*ppwszOID))
        {
            hr=E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }

        wcscpy(*ppwszOID, wszOID_ENTERPRISE_ROOT);
        wcscat(*ppwszOID, wszOID_DOT);
        wcscat(*ppwszOID, pwszGUID);

        //cache the newly created displayName to the DS
        //no need to check for error since this is just a performance enhancement
        valOIDName[0]=*ppwszOID;
        valOIDName[1]=NULL;

        modOIDName.mod_op = LDAP_MOD_REPLACE;
        modOIDName.mod_type = OID_CONTAINER_PROP_OID;
        modOIDName.mod_values = valOIDName;

        mods[0]=&modOIDName;
        mods[1]=NULL;

        ldap_modify_ext_sW(
                pld, 
                bstrOIDContainer,
                mods,
                server_controls_dacl_only,
                NULL); 

        //cache the oid root in memory
        CAOIDAllocAndCopy(*ppwszOID, &g_pwszEnterpriseRootOID);

        hr = S_OK;

    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:

    if(pwszGUID)
        LocalFree(pwszGUID);

    if(pGuidVal)
        ldap_value_free_len(pGuidVal);

    if(wszLdapVal)
        ldap_value_free(wszLdapVal);

    if(SearchResult)
        ldap_msgfree(SearchResult);

    if (bstrOIDContainer)
        CertFreeString(bstrOIDContainer);

    return hr;
}



//---------------------------------------------------------------------------
//
//  CAOIDRetrieveEnterpriseRoot
//
//  Get the enterpriseRoot from the displayName attribute of the container.
//  If the attribute is missing, add the one with GUID of the container.
//
//  Free memory via LocalFree().
//---------------------------------------------------------------------------
HRESULT     CAOIDRetrieveEnterpriseRoot(DWORD   dwFlag, LPWSTR  *ppwszOID)
{
    HRESULT             hr=E_INVALIDARG;

    LDAP                *pld = NULL;
    CERTSTR             bstrConfig = NULL;


    if(NULL==ppwszOID)
        _JumpError(hr , error, "ArgumentCheck");

    *ppwszOID=NULL;

    //retrieve the memory cache if available
    if(g_pwszEnterpriseRootOID)
    {
        hr=CAOIDAllocAndCopy(g_pwszEnterpriseRootOID, ppwszOID);
        goto error;
    }

    //retrieve the ldap handle and the config string
    if(S_OK != (hr = myDoesDSExist(TRUE)))
        _JumpError(hr , error, "myDoesDSExist");

    if(S_OK != (hr = myRobustLdapBind(&pld, FALSE)))
        _JumpError(hr , error, "myRobustLdapBind");


	hr = CAGetAuthoritativeDomainDn(pld, NULL, &bstrConfig);
	if(S_OK != hr)
	{
        _JumpError(hr , error, "CAGetAuthoritativeDomainDn");
	}


    hr = CAOIDRetrieveEnterpriseRootWithConfig(pld, bstrConfig,
                                            dwFlag, ppwszOID);
error:
    if(bstrConfig)
        CertFreeString(bstrConfig);

    if (pld)
        ldap_unbind(pld);

    return hr;
}

//---------------------------------------------------------------------------
//
//  CAOIDBuildOIDWithRoot
//
//
//  Free memory via LocalFree().
//---------------------------------------------------------------------------
HRESULT     CAOIDBuildOIDWithRoot(DWORD dwFlag, LPCWSTR pwszRoot, LPCWSTR  pwszEndOID, LPWSTR *ppwszOID)
{
    HRESULT     hr=E_INVALIDARG;

    if(NULL==pwszRoot)
        _JumpError(hr , error, "ArgumentCheck");

    *ppwszOID=NULL;

    *ppwszOID=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * 
            (wcslen(pwszRoot) + wcslen(wszOID_DOT) + wcslen(pwszEndOID) + 1));

    if(NULL==(*ppwszOID))
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr , error, "LocalAlloc");
    }

    wcscpy(*ppwszOID, pwszRoot);
    wcscat(*ppwszOID, wszOID_DOT);
    wcscat(*ppwszOID, pwszEndOID);

    hr= S_OK;

error:

    return hr;
}


//---------------------------------------------------------------------------
//
//  CAOIDBuildOID
//
//
//  Free memory via LocalFree().
//---------------------------------------------------------------------------
HRESULT     CAOIDBuildOID(DWORD dwFlag, LPCWSTR  pwszEndOID, LPWSTR *ppwszOID)
{
    HRESULT     hr=E_INVALIDARG;

    LPWSTR      pwszRoot=NULL;

    if((NULL==ppwszOID) || (NULL==pwszEndOID))
        _JumpError(hr , error, "ArgumentCheck");

    *ppwszOID=NULL;

    if(S_OK != (hr=CAOIDRetrieveEnterpriseRoot(0, &pwszRoot)))
         _JumpError(hr , error, "RetrieveEnterpriseRoot");

    hr= CAOIDBuildOIDWithRoot(dwFlag, pwszRoot, pwszEndOID, ppwszOID);

error:

    if(pwszRoot)
        LocalFree(pwszRoot);

    return hr;
}

//------------------------------------------------------------------------
//	   Convert the byte to its Hex presentation.
//
//
//------------------------------------------------------------------------
ULONG	ByteToHex(BYTE	byte,	LPWSTR	wszZero, LPWSTR wszA)
{
	ULONG	uValue=0;

	if(((ULONG)byte)<=9)
	{
		uValue=((ULONG)byte)+ULONG(*wszZero);	
	}
	else
	{
		uValue=(ULONG)byte-10+ULONG(*wszA);

	}

	return uValue;

}
//--------------------------------------------------------------------------
//
//	  ConvertByteToWstr
//
//		If fSpace is TRUE, we add a space every 2 bytes.
//--------------------------------------------------------------------------
HRESULT ConvertByteToWstr(BYTE			*pbData, 
						  DWORD			cbData, 
						  LPWSTR		*ppwsz)
{
	HRESULT hr=E_INVALIDARG;
	DWORD	dwBufferSize=0;
	DWORD	dwBufferIndex=0;
	DWORD	dwEncodedIndex=0;

	LPWSTR	pwszZero=L"0";
	LPWSTR	pwszA=L"A";

	if(!pbData || !ppwsz)
        _JumpError(hr , error, "ArgumentCheck");

	//calculate the memory needed, in bytes
	//we need 2 wchars per byte, along with the NULL terminator
	dwBufferSize=sizeof(WCHAR)*(cbData*2+1);

	*ppwsz=(LPWSTR)LocalAlloc(LPTR, dwBufferSize);

	if(NULL==(*ppwsz))
    {
        hr=E_OUTOFMEMORY;
        _JumpError(hr , error, "LocalAlloc");
    }

	dwBufferIndex=0;

	//format the wchar buffer one byte at a time
	for(dwEncodedIndex=0; dwEncodedIndex<cbData; dwEncodedIndex++)
	{

		//format the higher 4 bits
		(*ppwsz)[dwBufferIndex]=(WCHAR)ByteToHex(
			 (pbData[dwEncodedIndex]&UPPER_BITS)>>4,
			 pwszZero, pwszA);

		dwBufferIndex++;

		//format the lower 4 bits
		(*ppwsz)[dwBufferIndex]=(WCHAR)ByteToHex(
			 pbData[dwEncodedIndex]&LOWER_BITS,
			 pwszZero, pwszA);

		dwBufferIndex++;

	}

	//add the NULL terminator to the string
	(*ppwsz)[dwBufferIndex]=L'\0';

	hr=S_OK;

error:

    return hr;

}

//---------------------------------------------------------------------------
// myOIDHashOIDToString
//
//  Map the OID to a hash string in the format of oid.hash. 
//---------------------------------------------------------------------------

HRESULT
myOIDHashOIDToString(
    IN WCHAR const *pwszOID,
    OUT WCHAR **ppwsz)
{
    HRESULT     hr=E_INVALIDARG;
    BYTE	pbHash[CERT_OID_MD5_HASH_SIZE];
    DWORD	cbData=CERT_OID_MD5_HASH_SIZE;
    LPCWSTR     pwszChar=NULL;
    DWORD       dwIDLength=CERT_OID_IDENTITY_LENGTH;

    LPWSTR      pwszHash=NULL;

    if((NULL==pwszOID) || (NULL==ppwsz))
        _JumpError(hr , error, "ArgumentCheck");

    *ppwsz=NULL;

    hr = myVerifyObjId(pwszOID);
    _JumpIfErrorStr2(hr, error, "myVerifyObjId", pwszOID, E_INVALIDARG);

    if(!CryptHashCertificate(
			NULL,
			CALG_MD5,
			0,
			(BYTE * )pwszOID,
			sizeof(WCHAR) * wcslen(pwszOID),
			pbHash,
			&cbData))
    {
        hr= myHLastError();
        _JumpError(hr , error, "CryptHashCertificate");
    }

    //convert the hash to a string
    if(S_OK != (hr=ConvertByteToWstr(pbHash, CERT_OID_MD5_HASH_SIZE, &pwszHash)))
        _JumpError(hr , error, "ConvertByteToWstr");

    //find the last component of the oid.  Take the first 16 characters
    pwszChar=wcsrchr(pwszOID, L'.');

    if(NULL==pwszChar)
        pwszChar=pwszOID;
    else
	pwszChar++;

    if(dwIDLength > wcslen(pwszChar))
        dwIDLength=wcslen(pwszChar);

    //the result string is oid.hash
    *ppwsz=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * 
        (dwIDLength + wcslen(pwszHash) + wcslen(wszOID_DOT) +1));
    if(NULL==*ppwsz)
    {
        hr= E_OUTOFMEMORY;
        _JumpError(hr , error, "LocalAlloc");
    }

    wcsncpy(*ppwsz, pwszChar, dwIDLength);
    (*ppwsz)[dwIDLength]=L'\0';
    wcscat(*ppwsz, wszOID_DOT);
    wcscat(*ppwsz, pwszHash);
    
    hr=S_OK;

error:

    if(pwszHash)
        LocalFree(pwszHash);
    
    return hr;
}


//---------------------------------------------------------------------------
// I_CAOIDCreateNew
// Create a new OID based on the enterprise base
//
// Returns S_OK if successful.
//---------------------------------------------------------------------------
HRESULT     I_CAOIDCreateNew(DWORD dwType,  DWORD   dwFlag,   LPWSTR	*ppwszOID)
{
    HRESULT             hr=E_INVALIDARG;
    ENT_OID_INFO        oidInfo;
    DWORD               iIndex=0;

    LDAP                *pld = NULL;
    CERTSTR             bstrConfig = NULL;
    LPWSTR              pwszRoot = NULL;
    LPWSTR              pwszNewOID = NULL;
    LPWSTR              pwszRandom = NULL;

    if(NULL==ppwszOID)
        _JumpError(hr , error, "ArgumentCheck");

    *ppwszOID=NULL;

    //retrieve the root oid if available
    if(g_pwszEnterpriseRootOID)
    {
        if(S_OK != (hr=CAOIDAllocAndCopy(g_pwszEnterpriseRootOID, &pwszRoot)))
            goto error;
    }

    //retrieve the ldap handle and the config string
    if(S_OK != (hr = myDoesDSExist(TRUE)))
        _JumpError(hr , error, "myDoesDSExist");

    if(S_OK != (hr = myRobustLdapBind(&pld, FALSE)))
        _JumpError(hr , error, "myRobustLdapBind");


	hr = CAGetAuthoritativeDomainDn(pld, NULL, &bstrConfig);
	if(S_OK != hr)
	{
        _JumpError(hr , error, "CAGetAuthoritativeDomainDn");
	}

    if(NULL==pwszRoot)
    {
        if(S_OK != (hr = CAOIDRetrieveEnterpriseRootWithConfig(pld, bstrConfig, 0, &pwszRoot)))
            _JumpError(hr , error, "CAOIDRetrieveEnterpriseRootWithConfig");
    }

    //we try to generate a random x1.x2 oid.  x > 1 and x2 > 500
    for(iIndex=0; iIndex < OID_RANDOM_CREATION_TRIAL; iIndex++)
    {
        if(S_OK != (hr = CAOIDGetRandom(&pwszRandom)))
            _JumpError(hr , error, "CAOIDGetRandom");

        if(S_OK != (hr = CAOIDBuildOIDWithRoot(0, pwszRoot, pwszRandom, &pwszNewOID)))
            _JumpError(hr , error, "CAOIDBuildOIDWithRoot");

        if(!DoesOIDExist(pld, bstrConfig, pwszNewOID))
            break;

        LocalFree(pwszRandom);
        pwszRandom=NULL;

        LocalFree(pwszNewOID);
        pwszNewOID=NULL;
    }

    if(iIndex == OID_RANDOM_CREATION_TRIAL)
    {
        hr=E_FAIL;
        _JumpError(hr , error, "CAOIDGetRandom");
    }

    //update the oid information on the DS
    memset(&oidInfo, 0, sizeof(ENT_OID_INFO));
    oidInfo.dwAttr=OID_ATTR_ALL;
    oidInfo.dwType=dwType;
    oidInfo.pwszOID=pwszNewOID;

    if(S_OK != (hr=CAOIDUpdateDS(pld, bstrConfig, &oidInfo)))
        _JumpError(hr , error, "CAOIDUpdateDS");

    *ppwszOID=pwszNewOID;
    pwszNewOID=NULL;

    hr=S_OK;

error:
    if(pwszRandom)
        LocalFree(pwszRandom);

    if(pwszNewOID)
        LocalFree(pwszNewOID);

    if(pwszRoot)
        LocalFree(pwszRoot);

    if(bstrConfig)
        CertFreeString(bstrConfig);

    if (pld)
        ldap_unbind(pld);

    return hr;
}

//---------------------------------------------------------------------------
//
// CAOIDCreateNew
//
//---------------------------------------------------------------------------
HRESULT
CAOIDCreateNew(
    IN  DWORD   dwType,
    IN	DWORD   dwFlag,
    OUT LPWSTR	*ppwszOID)
{
    return I_CAOIDCreateNew(dwType, dwFlag, ppwszOID);
}

//---------------------------------------------------------------------------
// I_CAOIDSetProperty
// Set a property on an oid.  
//
//
// Returns S_OK if successful.
//---------------------------------------------------------------------------
HRESULT
I_CAOIDSetProperty(
    IN  LPCWSTR pwszOID,
    IN  DWORD   dwProperty,
    IN  LPVOID  pPropValue)
{
    HRESULT             hr=E_INVALIDARG;
    ENT_OID_INFO        oidInfo;

    LDAP                *pld = NULL;
    CERTSTR             bstrConfig = NULL;


    if(NULL==pwszOID)
        _JumpError(hr , error, "ArgumentCheck");


    //retrieve the ldap handle and the config string
    if(S_OK != (hr = myDoesDSExist(TRUE)))
        _JumpError(hr , error, "myDoesDSExist");

    if(S_OK != (hr = myRobustLdapBind(&pld, FALSE)))
        _JumpError(hr , error, "myRobustLdapBind");

	hr = CAGetAuthoritativeDomainDn(pld, NULL, &bstrConfig);
	if(S_OK != hr)
	{
        _JumpError(hr , error, "CAGetAuthoritativeDomainDn");
	}

    //make sure the OID exist on the DS
    if(!DoesOIDExist(pld, bstrConfig, pwszOID))
    {
        hr=NTE_NOT_FOUND;
        _JumpError(hr , error, "OIDExits");
    }
    
    //update the oid information on the DS
    memset(&oidInfo, 0, sizeof(ENT_OID_INFO));

    oidInfo.pwszOID=(LPWSTR)pwszOID;
    switch(dwProperty)
    {
        case CERT_OID_PROPERTY_DISPLAY_NAME:
                oidInfo.dwAttr = OID_ATTR_DISPLAY_NAME;
                oidInfo.pwszDisplayName=(LPWSTR)pPropValue;
            break;
        case CERT_OID_PROPERTY_CPS:
                oidInfo.dwAttr = OID_ATTR_CPS;
                oidInfo.pwszCPS=(LPWSTR)pPropValue;
           break;
        default:
                hr=E_INVALIDARG;
                _JumpError(hr , error, "ArgumentCheck");
    }
        
    hr=CAOIDUpdateDS(pld, bstrConfig, &oidInfo);

error:

    if(bstrConfig)
        CertFreeString(bstrConfig);

    if (pld)
        ldap_unbind(pld);

    return hr;
}

//---------------------------------------------------------------------------
//
// CAOIDSetProperty
//
//---------------------------------------------------------------------------
HRESULT
CAOIDSetProperty(
    IN  LPCWSTR pwszOID,
    IN  DWORD   dwProperty,
    IN  LPVOID  pPropValue)
{
    return I_CAOIDSetProperty(pwszOID, dwProperty, pPropValue);
}


//---------------------------------------------------------------------------
// I_CAOIDAdd
//
// Returns S_OK if successful.
// Returns CRYPT_E_EXISTS if the OID alreay exits in the DS repository
//---------------------------------------------------------------------------
HRESULT
I_CAOIDAdd(
    IN	DWORD       dwType,
    IN  DWORD       dwFlag,
    IN  LPCWSTR	    pwszOID)
{
    HRESULT             hr=E_INVALIDARG;
    ENT_OID_INFO        oidInfo;

    LDAP                *pld = NULL;
    CERTSTR             bstrConfig = NULL;


    if(NULL==pwszOID)
        _JumpError(hr , error, "ArgumentCheck");

    //retrieve the ldap handle and the config string
    if(S_OK != (hr = myDoesDSExist(TRUE)))
        _JumpError(hr , error, "myDoesDSExist");

    if(S_OK != (hr = myRobustLdapBind(&pld, FALSE)))
        _JumpError(hr , error, "myRobustLdapBind");

	hr = CAGetAuthoritativeDomainDn(pld, NULL, &bstrConfig);
	if(S_OK != hr)
	{
        _JumpError(hr , error, "CAGetAuthoritativeDomainDn");
	}

    //make sure the OID does not exist on the DS
    if(DoesOIDExist(pld, bstrConfig, pwszOID))
    {
        hr=CRYPT_E_EXISTS;
        _JumpError(hr , error, "OIDExits");
    }

    //update the oid information on the DS
    memset(&oidInfo, 0, sizeof(ENT_OID_INFO));
    oidInfo.dwAttr=OID_ATTR_ALL;
    oidInfo.dwType=dwType;
    oidInfo.pwszOID=(LPWSTR)pwszOID;

    hr=CAOIDUpdateDS(pld, bstrConfig, &oidInfo);

error:

    if(bstrConfig)
        CertFreeString(bstrConfig);

    if (pld)
        ldap_unbind(pld);

    return hr;
 }



//---------------------------------------------------------------------------
// CAOIDAdd
//
// Returns S_OK if successful.
// Returns CRYPT_E_EXISTS if the OID alreay exits in the DS repository
//---------------------------------------------------------------------------
HRESULT
CAOIDAdd(
    IN	DWORD       dwType,
    IN  DWORD       dwFlag,
    IN  LPCWSTR	    pwszOID)
{
    return I_CAOIDAdd(dwType, dwFlag, pwszOID);
}

//---------------------------------------------------------------------------
//
// I_CAOIDDelete
//
//---------------------------------------------------------------------------
HRESULT
I_CAOIDDelete(
    IN LPCWSTR	pwszOID)
{

    HRESULT             hr=E_INVALIDARG;
    ULONG               ldaperr=0;

    LDAP                *pld = NULL;
    CERTSTR             bstrConfig = NULL;
    CERTSTR             bstrDN = NULL;
    LPWSTR              pwszCN = NULL;
    

    if(NULL==pwszOID)
        _JumpError(hr , error, "ArgumentCheck");

    //retrieve the ldap handle and the config string
    if(S_OK != (hr = myDoesDSExist(TRUE)))
        _JumpError(hr , error, "myDoesDSExist");

    if(S_OK != (hr = myRobustLdapBind(&pld, FALSE)))
        _JumpError(hr , error, "myRobustLdapBind");

	hr = CAGetAuthoritativeDomainDn(pld, NULL, &bstrConfig);
	if(S_OK != hr)
	{
        _JumpError(hr , error, "CAGetAuthoritativeDomainDn");
	}

    //set up the base DN
    if(S_OK != (hr = myOIDHashOIDToString((LPWSTR)pwszOID,  &pwszCN)))
        _JumpError(hr , error, "myOIDHashOIDToString");

    bstrDN = CertAllocStringLen(NULL, wcslen(bstrConfig) + wcslen(s_wszOIDContainerDN)+wcslen(pwszCN)+4);
    if(bstrDN == NULL)
    {
        hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "CertAllocStringLen");
    }
    wcscpy(bstrDN, L"CN=");
    wcscat(bstrDN, pwszCN);
    wcscat(bstrDN, L",");
    wcscat(bstrDN, s_wszOIDContainerDN);
    wcscat(bstrDN, bstrConfig);

    ldaperr = ldap_delete_s(pld, bstrDN);

    if(LDAP_NO_SUCH_OBJECT == ldaperr)
        ldaperr = LDAP_SUCCESS;

    hr = myHLdapError(pld, ldaperr, NULL);

error:
    if(pwszCN)
        LocalFree(pwszCN);

    if(bstrDN)
        CertFreeString(bstrDN);

    if(bstrConfig)
        CertFreeString(bstrConfig);

    if (pld)
        ldap_unbind(pld);

    return hr;
}



//---------------------------------------------------------------------------
//
// CAOIDDelete
//
//---------------------------------------------------------------------------
HRESULT
CAOIDDelete(
    IN LPCWSTR	pwszOID)
{
    return I_CAOIDDelete(pwszOID);
}

//---------------------------------------------------------------------------
//
// I_CAOIDGetProperty
//
//---------------------------------------------------------------------------
HRESULT
I_CAOIDGetProperty(
    IN  LPCWSTR pwszOID,
    IN  DWORD   dwProperty,
    OUT LPVOID  pPropValue)
{
    HRESULT             hr=E_INVALIDARG;
    ULONG               ldaperr=0;
    DWORD               dwCount=0;
    struct l_timeval    timeout;
    LPWSTR              awszAttr[4];
    LDAPMessage         *Entry=NULL;

    WCHAR               **wszLdapVal = NULL;
    LPWSTR              pwszFilter = NULL;
    LDAPMessage         *SearchResult = NULL;
    LDAP                *pld = NULL;
    CERTSTR             bstrConfig = NULL;
    CERTSTR             bstrDN = NULL;
    LPWSTR              pwszCN = NULL;
    

    if((NULL==pwszOID) || (NULL==pPropValue))
        _JumpError(hr , error, "ArgumentCheck");

    //retrieve the ldap handle and the config string
    if(S_OK != (hr = myDoesDSExist(TRUE)))
        _JumpError(hr , error, "myDoesDSExist");

    if(S_OK != (hr = myRobustLdapBind(&pld, FALSE)))
        _JumpError(hr , error, "myRobustLdapBind");

	hr = CAGetAuthoritativeDomainDn(pld, NULL, &bstrConfig);
	if(S_OK != hr)
	{
        _JumpError(hr , error, "CAGetAuthoritativeDomainDn");
	}

    //set up the base DN
    if(S_OK != (hr = myOIDHashOIDToString((LPWSTR)pwszOID,  &pwszCN)))
        _JumpError(hr , error, "myOIDHashOIDToString");

    bstrDN = CertAllocStringLen(NULL, wcslen(bstrConfig) + wcslen(s_wszOIDContainerDN)+wcslen(pwszCN)+4);
    if(bstrDN == NULL)
    {
        hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "CertAllocStringLen");
    }
    wcscpy(bstrDN, L"CN=");
    wcscat(bstrDN, pwszCN);
    wcscat(bstrDN, L",");
    wcscat(bstrDN, s_wszOIDContainerDN);
    wcscat(bstrDN, bstrConfig);

    //search for the OID, asking for all its attributes
    timeout.tv_sec = csecLDAPTIMEOUT;
    timeout.tv_usec = 0;

    awszAttr[0]=OID_PROP_TYPE;
    awszAttr[1]=OID_PROP_DISPLAY_NAME;
    awszAttr[2]=OID_PROP_CPS;
    awszAttr[3]=NULL;

    if(S_OK != (hr=FormatMessageUnicode(&pwszFilter, L"(%1!s!=%2!s!)",
                                    OID_PROP_OID, pwszOID)))
    _JumpError(hr , error, "FormatMessageUnicode");

    ldaperr = ldap_search_stW(
		      pld, 
		      (LPWSTR)bstrDN,
		      LDAP_SCOPE_BASE,
		      pwszFilter,
		      awszAttr,
		      0,
		      &timeout,
		      &SearchResult);

    if(LDAP_SUCCESS != ldaperr)
    {
	hr = myHLdapError2(pld, ldaperr, LDAP_NO_SUCH_OBJECT, NULL);
	_JumpErrorStr2(
		hr,
		error,
		"ldap_search_stW",
		pwszFilter,
		HRESULT_FROM_WIN32(ERROR_DS_OBJ_NOT_FOUND));
    }

    dwCount = ldap_count_entries(pld, SearchResult);

    //we should only find one container
    if((1 != dwCount) || (NULL == (Entry = ldap_first_entry(pld, SearchResult))))
	{
	    // No entries were found.
	    //BUGBUG: why not use last ldap error?
	    //hr = myHLdapLastError(pld, NULL);
	    hr = myHLdapError(pld, LDAP_NO_SUCH_OBJECT, NULL);
	    _JumpError(hr, error, "ldap_search_stW");
	}

    switch(dwProperty)
    {
        case CERT_OID_PROPERTY_DISPLAY_NAME:
                wszLdapVal = ldap_get_values(pld, Entry, OID_PROP_DISPLAY_NAME);
                
                if(wszLdapVal && wszLdapVal[0])
                {
                    hr=CAOIDAllocAndCopy(wszLdapVal[0], (LPWSTR *)pPropValue);
                }
                else
		    hr = myHLdapError(pld, LDAP_NO_SUCH_ATTRIBUTE, NULL);

            break;
        case CERT_OID_PROPERTY_CPS:

                wszLdapVal = ldap_get_values(pld, Entry, OID_PROP_CPS);
                
                if(wszLdapVal && wszLdapVal[0])
                {
                    hr=CAOIDAllocAndCopy(wszLdapVal[0], (LPWSTR *)pPropValue);
                }
                else
		    hr = myHLdapError(pld, LDAP_NO_SUCH_ATTRIBUTE, NULL);

            break;
        case CERT_OID_PROPERTY_TYPE:
                wszLdapVal = ldap_get_values(pld, Entry, OID_PROP_TYPE);
                
                if(wszLdapVal && wszLdapVal[0])
                {
                    *((DWORD *)pPropValue)=_wtol(wszLdapVal[0]);
                    hr=S_OK;
                }
                else
		    hr = myHLdapError(pld, LDAP_NO_SUCH_ATTRIBUTE, NULL);
            break;
        default:
                hr=E_INVALIDARG;
    }

    if(hr != S_OK)
        _JumpError(hr , error, "GetAttibuteValue");

error:

    if(wszLdapVal)
        ldap_value_free(wszLdapVal);

    if(pwszFilter)
        LocalFree((HLOCAL)pwszFilter);

    if(SearchResult)
        ldap_msgfree(SearchResult);

    if(pwszCN)
        LocalFree(pwszCN);

    if(bstrDN)
        CertFreeString(bstrDN);

    if(bstrConfig)
        CertFreeString(bstrConfig);

    if (pld)
        ldap_unbind(pld);

    return hr;
}


//---------------------------------------------------------------------------
//
// CAOIDGetProperty
//
//---------------------------------------------------------------------------
HRESULT
CAOIDGetProperty(
    IN  LPCWSTR pwszOID,
    IN  DWORD   dwProperty,
    OUT LPVOID  pPropValue)
{
    return I_CAOIDGetProperty(pwszOID, dwProperty, pPropValue);
}

//---------------------------------------------------------------------------
//
// I_CAOIDFreeProperty
//
//---------------------------------------------------------------------------
HRESULT
I_CAOIDFreeProperty(
    IN LPVOID  pPropValue)
{
    if(pPropValue)
        LocalFree(pPropValue);

    return S_OK;
}


//---------------------------------------------------------------------------
//
// CAOIDFreeProperty
//
//---------------------------------------------------------------------------
HRESULT
CAOIDFreeProperty(
    IN LPVOID  pPropValue)
{

    return I_CAOIDFreeProperty(pPropValue);
}

//---------------------------------------------------------------------------
//
// CAOIDGetLdapURL
//
// Get the LDAP URL for the DS OID repository in the format of 
// LDAP:///DN of the Repository/all attributes?one?filter.
//---------------------------------------------------------------------------
HRESULT
CAOIDGetLdapURL(
    IN  DWORD   dwType,
    IN  DWORD   dwFlag,
    OUT LPWSTR  *ppwszURL)
{
    HRESULT             hr=E_INVALIDARG;
    ULONG               ldaperr=0;
    LPWSTR              wszFilterFormat=L"ldap:///%1!s!%2!s!?%3!s!,%4!s!,%5!s!,%6!s!,%7!s!?one?%8!s!=%9!d!";
    LPWSTR              pwsz=NULL;
    BOOL                fDomainFail=FALSE;
    FILETIME            ftTime;

    LPWSTR              pwszURL=NULL;
    LDAP                *pld = NULL;
    CERTSTR             bstrConfig = NULL;
    

    //the critical section has to be initalized
    if (!g_fOidURL)
	    return(HRESULT_FROM_WIN32(ERROR_DLL_INIT_FAILED));

    EnterCriticalSection(&g_csOidURL);

    //check if the previous failure has happened with 10 seconds
    if(TRUE == g_fFailedTime)
    {
        //get the current time
        GetSystemTimeAsFileTime(&ftTime);

        g_ftOidTime.QuadPart += FILETIME_TICKS_PER_SECOND * CA_OID_MGR_FAIL_PERIOD;

        if(0 > CompareFileTime(&ftTime, (LPFILETIME)&g_ftOidTime))
        {
            g_ftOidTime.QuadPart -= FILETIME_TICKS_PER_SECOND * CA_OID_MGR_FAIL_PERIOD;

            hr=HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN);

            _JumpError2(hr , error, "myDoesDSExist", HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN));
        }
        else
        {
            //clear up the error recording
            g_fFailedTime=FALSE;
        }
    }

    if(NULL==ppwszURL)
        _JumpError(hr , error, "ArgumentCheck");

    fDomainFail=TRUE;

    //retrieve the ldap handle and the config string
    if(S_OK != (hr = myDoesDSExist(TRUE)))
        _JumpError2(hr , error, "myDoesDSExist", HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN));

    if(S_OK != (hr = myRobustLdapBind(&pld, FALSE)))
        _JumpError(hr , error, "myRobustLdapBind");

    fDomainFail=FALSE;

	hr = CAGetAuthoritativeDomainDn(pld, NULL, &bstrConfig);
	if(S_OK != hr)
	{
        _JumpError(hr , error, "CAGetAuthoritativeDomainDn");
	}

    if(S_OK != (hr=FormatMessageUnicode(
                    &pwszURL, 
                    wszFilterFormat,
                    s_wszOIDContainerDN, 
                    bstrConfig,
                    OID_PROP_TYPE,
                    OID_PROP_OID,
                    OID_PROP_DISPLAY_NAME,
                    OID_PROP_CPS,
                    OID_PROP_LOCALIZED_NAME,
                    OID_PROP_TYPE,
                    dwType
                    )))
        _JumpError(hr , error, "FormatMessageUnicode");

    //we eliminate the filter if dwType is CERT_OID_TYPE_ALL
    if(CERT_OID_TYPE_ALL == dwType)
    {
        pwsz=wcsrchr(pwszURL, L'?');

        if(NULL==pwsz)
        {
            //something serious is wrong
            hr=E_UNEXPECTED;
            _JumpError(hr , error, "FormatMessageUnicode");
        }

        *pwsz=L'\0';
    }

    *ppwszURL=pwszURL;
    pwszURL=NULL;

    hr=S_OK;

error:
    
    //remember the time if we failed due to lack of domain
    if((S_OK != hr) && (TRUE == fDomainFail) && (FALSE==g_fFailedTime))
    {
        GetSystemTimeAsFileTime((LPFILETIME)&(g_ftOidTime));
        g_fFailedTime=TRUE;
    }

    if(pwszURL)
        LocalFree((HLOCAL)pwszURL);

    if(bstrConfig)
        CertFreeString(bstrConfig);

    if (pld)
        ldap_unbind(pld);

    LeaveCriticalSection(&g_csOidURL);

    return hr;
}



//---------------------------------------------------------------------------
//
// CAOIDFreeLdapURL
//
//---------------------------------------------------------------------------
HRESULT
CAOIDFreeLdapURL(
    IN LPCWSTR      pwszURL)
{
    if(pwszURL)
        LocalFree((HLOCAL)pwszURL);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certclib\error.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        error.cpp
//
// Contents:    Cert Server error wrapper routines
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <assert.h>
#include <ntdsbmsg.h>
#include <delayimp.h>
#include "resource.h"


#define CERTLIB_12BITERRORMASK  0x00000fff
#define CERTLIB_WIN32ERRORMASK  0x0000ffff


//+--------------------------------------------------------------------------
// Jet errors:

#define HRESULT_FROM_JETWARNING(jerr) \
        (ERROR_SEVERITY_WARNING | (FACILITY_NTDSB << 16) | jerr)

#define HRESULT_FROM_JETERROR(jerr) \
        (ERROR_SEVERITY_ERROR | (FACILITY_NTDSB << 16) | -jerr)

#define JETERROR_FROM_HRESULT(hr) \
        (-(LONG) (CERTLIB_WIN32ERRORMASK & (hr)))

#define ISJETERROR(hr) \
        ((~CERTLIB_WIN32ERRORMASK & (hr)) == (HRESULT) ~CERTLIB_WIN32ERRORMASK)

#define ISJETHRESULT(hr) \
    ((~CERTLIB_WIN32ERRORMASK & (hr)) == (HRESULT) (ERROR_SEVERITY_ERROR | \
					      (FACILITY_NTDSB << 16)))

#define wszJETERRORPREFIX       L"ESE"


//+--------------------------------------------------------------------------
// Setup API errors:

#define ISSETUPHRESULT(hr) \
    ((~CERTLIB_WIN32ERRORMASK & (hr)) == (HRESULT) (ERROR_SEVERITY_ERROR | \
                                              APPLICATION_ERROR_MASK | \
                                              (FACILITY_NULL << 16)))

#define wszSETUPERRORPREFIX       L"INF"


//+--------------------------------------------------------------------------
// Win32 errors:

#define ISWIN32ERROR(hr) \
        ((~CERTLIB_WIN32ERRORMASK & (hr)) == 0)

#define ISWIN32HRESULT(hr) \
    ((~CERTLIB_WIN32ERRORMASK & (hr)) == (HRESULT) (ERROR_SEVERITY_WARNING | \
					      (FACILITY_WIN32 << 16)))

#define WIN32ERROR_FROM_HRESULT(hr) \
        (CERTLIB_WIN32ERRORMASK & (hr))

#define wszWIN32ERRORPREFIX     L"WIN32"


//+--------------------------------------------------------------------------
// Delayload errors:

#define DELAYLOAD_FROM_WIN32(hr)  VcppException(ERROR_SEVERITY_ERROR, (hr))

#define WIN32ERROR_FROM_DELAYLOAD(hr)  (CERTLIB_WIN32ERRORMASK & (hr))

#define ISDELAYLOADHRESULTFACILITY(hr) \
    ((~CERTLIB_WIN32ERRORMASK & (hr)) == (HRESULT) (ERROR_SEVERITY_ERROR | \
                                              (FACILITY_VISUALCPP << 16)))

// E_DELAYLOAD_MOD_NOT_FOUND    0xc06d007e
#define E_DELAYLOAD_MOD_NOT_FOUND   DELAYLOAD_FROM_WIN32(ERROR_MOD_NOT_FOUND)

// E_DELAYLOAD_PROC_NOT_FOUND   0xc06d007f
#define E_DELAYLOAD_PROC_NOT_FOUND  DELAYLOAD_FROM_WIN32(ERROR_PROC_NOT_FOUND)

#define ISDELAYLOADHRESULT(hr) \
        ((HRESULT) E_DELAYLOAD_MOD_NOT_FOUND == (hr) || \
         (HRESULT) E_DELAYLOAD_PROC_NOT_FOUND == (hr) || \
         HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND) == (hr) || \
         HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND) == (hr))


//+--------------------------------------------------------------------------
// ASN encoding errors:

#define ISOSSERROR(hr) \
        ((~CERTLIB_12BITERRORMASK & (hr)) == CRYPT_E_OSS_ERROR)

#define OSSERROR_FROM_HRESULT(hr) \
        (CERTLIB_12BITERRORMASK & (hr))

#define wszOSSERRORPREFIX       L"ASN"




HRESULT
myJetHResult(
    IN HRESULT hr)
{
#if DBG_CERTSRV
    HRESULT hrIn = hr;
#endif
    if (S_OK != hr)
    {
        if (SUCCEEDED(hr))
        {
#if 0
            hr = HRESULT_FROM_JETWARNING(hr);
#else
            if (S_FALSE != hr)
            {
                _PrintError(hr, "JetHResult: mapping to S_FALSE");
            }
            CSASSERT(S_FALSE == hr);
            hr = S_FALSE;
#endif
        }
        else if (ISJETERROR(hr))
        {
            hr = HRESULT_FROM_JETERROR(hr);
        }
    }
#if DBG_CERTSRV
    DBGPRINT((
            DBG_SS_CERTLIBI,
            "myJetHResult(%x (%d)) --> %x (%d)\n",
            hrIn,
            hrIn,
            hr,
            hr));
#endif
    CSASSERT(S_OK == hr || S_FALSE == hr || FAILED(hr));
    return(hr);
}


HRESULT
myHExceptionCode(
    IN EXCEPTION_POINTERS const *pep)
{
    HRESULT hr = pep->ExceptionRecord->ExceptionCode;

#ifndef CERTSRV_E_ALIGNMENT_FAULT
#define CERTSRV_E_ALIGNMENT_FAULT        _HRESULT_TYPEDEF_(0x80094010L)
#endif

#if (0 == i386)
    if ((HRESULT) STATUS_DATATYPE_MISALIGNMENT == hr)
    {
	hr = CERTSRV_E_ALIGNMENT_FAULT;
    }
#endif
    return(myHError(hr));
}


#ifdef DBG_CERTSRV_DEBUG_PRINT

VOID
myCaptureStackBackTrace(
    EXCEPTION_POINTERS const *pep,
    ULONG cSkip,
    ULONG cFrames,
    ULONG *aeip)
{
    ZeroMemory(aeip, cFrames * sizeof(aeip[0]));

#if i386 == 1
    ULONG ieip, *pebp;
    ULONG *pebpMax = (ULONG *) MAXLONG; // 2 * 1024 * 1024 * 1024; // 2 gig - 1
    ULONG *pebpMin = (ULONG *) (64 * 1024);	// 64k

    if (pep == NULL)
    {
        ieip = 0;
        cSkip++;                    // always skip current frame
        pebp = ((ULONG *) &pep) - 2;
    }
    else
    {
        ieip = 1;
        assert(cSkip == 0);
        aeip[0] = pep->ContextRecord->Eip;
        pebp = (ULONG *) pep->ContextRecord->Ebp;
    }
    if (pebp >= pebpMin && pebp < pebpMax)
    {
        __try
        {
            for ( ; ieip < cSkip + cFrames; ieip++)
            {
                if (ieip >= cSkip)
                {
                    aeip[ieip - cSkip] = *(pebp + 1);  // save an eip
                }

                ULONG *pebpNext = (ULONG *) *pebp;
                if (pebpNext < pebp + 2 || pebpNext >= pebpMax - 1)
                {
                    break;
                }
                pebp = pebpNext;
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            ;
        }
    }
#endif // i386 == 1
}

#endif // ifdef DBG_CERTSRV_DEBUG_PRINT


FNLOGEXCEPTION *s_pfnLogException = NULL;

VOID
myLogExceptionInit(
    OPTIONAL IN FNLOGEXCEPTION *pfnLogException)
{
    s_pfnLogException = pfnLogException;
}


HRESULT
myHExceptionCodePrint(
    IN EXCEPTION_POINTERS const *pep,
    OPTIONAL IN char const *pszFile,
    IN DWORD dwFile,
    IN DWORD dwLine)
{
    HRESULT hr;
#ifdef DBG_CERTSRV_DEBUG_PRINT
    WCHAR awc[35 + 3 * cwcDWORDSPRINTF];

    wsprintf(
	awc,
	L"Flags=0x%x, Address=0x%p",
	pep->ExceptionRecord->ExceptionFlags,
	pep->ExceptionRecord->ExceptionAddress);

    CSPrintError(
	    "Exception",
	    awc,
	    pszFile,
	    dwLine,
	    pep->ExceptionRecord->ExceptionCode,
	    S_OK);

    if (!myIsDelayLoadHResult(pep->ExceptionRecord->ExceptionCode) ||
	DbgIsSSActive(DBG_SS_MODLOAD))
    {
	ULONG aeip[16];

	myCaptureStackBackTrace(pep, 0, ARRAYSIZE(aeip), aeip);

	if (DbgIsSSActive(DBG_SS_ERROR))
	{
	    DBGPRINT((DBG_SS_ERROR, "aeip: "));
	    for (int i = 0; i < ARRAYSIZE(aeip); i++)
	    {
		if (0 == aeip[i])
		{
		    break;
		}
#if i386 == 1
		DBGPRINT((MAXDWORD, "ln %x;", aeip[i]));
#endif // i386 == 1
	    }
	    DBGPRINT((MAXDWORD, "\n"));
	}
    }
#endif // DBG_CERTSRV_DEBUG_PRINT

    hr = myHExceptionCode(pep);
    if (NULL != s_pfnLogException)
    {
	(*s_pfnLogException)(hr, pep, pszFile, dwFile, dwLine);
    }
    return(hr);
}


BOOL
myIsDelayLoadHResult(
    IN HRESULT hr)
{
    return(ISDELAYLOADHRESULT(hr));
}


#define wszCOLONSPACE   L": "

WCHAR const *
myHResultToStringEx(
    IN OUT WCHAR *awchr,
    IN HRESULT hr,
    IN BOOL fRaw)
{
    HRESULT hrd;
    WCHAR const *pwszType;

    hrd = hr;
    pwszType = L"";
    if (ISJETERROR(hr))
    {
        pwszType = wszJETERRORPREFIX wszCOLONSPACE;
    }
    else if (ISJETHRESULT(hr))
    {
        hrd = JETERROR_FROM_HRESULT(hr);
        pwszType = wszJETERRORPREFIX wszCOLONSPACE;
    }
    else if (ISWIN32HRESULT(hr))
    {
        hrd = WIN32ERROR_FROM_HRESULT(hr);
        pwszType = wszWIN32ERRORPREFIX wszCOLONSPACE;
    }
    else if (ISDELAYLOADHRESULTFACILITY(hr))
    {
        hrd = WIN32ERROR_FROM_DELAYLOAD(hr);
        pwszType = wszWIN32ERRORPREFIX wszCOLONSPACE;
    }
    else if (ISOSSERROR(hr))
    {
        hrd = OSSERROR_FROM_HRESULT(hr);
        pwszType = wszOSSERRORPREFIX wszCOLONSPACE;
    }
    else if (ISSETUPHRESULT(hr))
    {
        pwszType = wszSETUPERRORPREFIX wszCOLONSPACE;
    }
    if (fRaw)
    {
        pwszType = L"";
    }

    _snwprintf(
        awchr,
        cwcHRESULTSTRING,
        L"0x%x (%ws%d)",
        hr,
        pwszType,
        hrd);
    return(awchr);
}


WCHAR const *
myHResultToString(
    IN OUT WCHAR *awchr,
    IN HRESULT hr)
{
    return(myHResultToStringEx(awchr, hr, FALSE));
}


WCHAR const *
myHResultToStringRaw(
    IN OUT WCHAR *awchr,
    IN HRESULT hr)
{
    return(myHResultToStringEx(awchr, hr, TRUE));
}


typedef struct _SETUPERRORMAP
{
    HRESULT hr;
    UINT    idMessage;
} SETUPERRORMAP;

SETUPERRORMAP g_aSetup[] = {
  { ERROR_EXPECTED_SECTION_NAME, IDS_SETUP_ERROR_EXPECTED_SECTION_NAME, },
  { ERROR_BAD_SECTION_NAME_LINE, IDS_SETUP_ERROR_BAD_SECTION_NAME_LINE, },
  { ERROR_SECTION_NAME_TOO_LONG, IDS_SETUP_ERROR_SECTION_NAME_TOO_LONG, },
  { ERROR_GENERAL_SYNTAX,	 IDS_SETUP_ERROR_GENERAL_SYNTAX, },
  { ERROR_WRONG_INF_STYLE,	 IDS_SETUP_ERROR_WRONG_INF_STYLE, },
  { ERROR_SECTION_NOT_FOUND,	 IDS_SETUP_ERROR_SECTION_NOT_FOUND, },
  { ERROR_LINE_NOT_FOUND,	 IDS_SETUP_ERROR_LINE_NOT_FOUND, },
};



DWORD
errLoadSetupMessage(
    IN HRESULT hr,
    OUT WCHAR const **ppwszOut)
{
    DWORD cwc = 0;
    SETUPERRORMAP *pmap;
    WCHAR wszBuf[512];

    for (pmap = g_aSetup; pmap < &g_aSetup[ARRAYSIZE(g_aSetup)]; pmap++)
    {
	if (hr == pmap->hr)
	{
	    *ppwszOut = myLoadResourceString(pmap->idMessage);
	    if (NULL != *ppwszOut)
	    {
		cwc = wcslen(*ppwszOut);
	    }
	    break;
	}
    }
//error:
    return(cwc);
}


DWORD
errFormatMessage(
    IN HMODULE hMod,
    IN HRESULT hr,
    OUT WCHAR const **ppwszOut,
    OPTIONAL IN WCHAR const * const *ppwszArgs)
{
    DWORD dwFlags;

    dwFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER;
    if (NULL == hMod)
    {
	dwFlags |= FORMAT_MESSAGE_FROM_SYSTEM;
    }
    else
    {
	dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
    }
    if (NULL == ppwszArgs || NULL == ppwszArgs[0])
    {
	dwFlags |= FORMAT_MESSAGE_IGNORE_INSERTS;
    }
    else
    {
	dwFlags |= FORMAT_MESSAGE_ARGUMENT_ARRAY;
    }
    return(FormatMessage(
		dwFlags,
                hMod,
                hr,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
                (WCHAR *) ppwszOut,
                1,    
		(va_list *) ppwszArgs));
}


// Alloc and return error message string

WCHAR const *
myGetErrorMessageText(
    IN HRESULT hr,
    IN BOOL fHResultString)
{
    return(myGetErrorMessageTextEx(hr, fHResultString, NULL));
}


WCHAR const *
myGetErrorMessageText1(
    IN HRESULT hr,
    IN BOOL fHResultString,
    IN OPTIONAL WCHAR const *pwszInsertionText)
{
    WCHAR const *apwszInsertionText[2];
    WCHAR const * const *papwsz = NULL;

    if (NULL != pwszInsertionText)
    {
	apwszInsertionText[0] = pwszInsertionText;
	apwszInsertionText[1] = NULL;
	papwsz = apwszInsertionText;
    }
    return(myGetErrorMessageTextEx(hr, fHResultString, papwsz));
}


WCHAR const *
myGetErrorMessageTextEx(
    IN HRESULT hr,
    IN BOOL fHResultString,
    IN OPTIONAL WCHAR const * const *papwszInsertionText)
{
    static WCHAR s_wszUnknownDefault[] = L"Error";
    WCHAR const *pwszRet = NULL;
    WCHAR const *pwszRetStatic = NULL;
    WCHAR *pwszMsgT;
    WCHAR awchr[cwcHRESULTSTRING];
    DWORD cwc;
    DWORD cwcCopy;
    DWORD cwcUnexpected;
    WCHAR const *pwszUnexpected = NULL;
    WCHAR wszEmpty[] = L"";
    HMODULE hMod = NULL;

    if (E_UNEXPECTED == hr)
    {
	pwszUnexpected = myLoadResourceString(IDS_E_UNEXPECTED); // L"Unexpected method call sequence."
    }
#if (0 == i386)
    else if (STATUS_DATATYPE_MISALIGNMENT == hr)
    {
	pwszUnexpected = myLoadResourceString(IDS_E_DATA_MISALIGNMENT); // L"Possible data alignment fault."
    }
#endif
    if (NULL == pwszUnexpected)
    {
	pwszUnexpected = wszEmpty;
    }
    cwcUnexpected = wcslen(pwszUnexpected);

    cwc = errFormatMessage(NULL, hr, &pwszRet, papwszInsertionText);
    if (0 == cwc && ISDELAYLOADHRESULTFACILITY(hr))
    {
	cwc = errFormatMessage(
			NULL,
			WIN32ERROR_FROM_DELAYLOAD(hr),
			&pwszRet,
			papwszInsertionText);
    }
    if (0 == cwc && ISSETUPHRESULT(hr))
    {
	cwc = errLoadSetupMessage(hr, &pwszRetStatic);
	pwszRet = pwszRetStatic;
    }
    if (0 == cwc)
    {
        hMod = LoadLibrary(L"ntdsbmsg.dll");
        if (NULL != hMod)
        {
            HRESULT hrEDB = hr;
            HRESULT hrFormat;
            BOOL fFirst = TRUE;

            while (TRUE)
            {
                cwc = errFormatMessage(hMod, hrEDB, &pwszRet, papwszInsertionText);
                if (0 == cwc && FAILED(hrEDB) && fFirst)
                {
                    hrFormat = myHLastError();
                    if (HRESULT_FROM_WIN32(ERROR_MR_MID_NOT_FOUND) == hrFormat)
                    {
                        hrEDB = myJetHResult(hrEDB);
                        if (hrEDB != hr)
                        {
                            fFirst = FALSE;
                            continue;
                        }
                    }
                }
                break;
            }
        }
    }

    if (0 == cwc)	// couldn't find error, use default & error code
    {
	fHResultString = TRUE;
    }
    awchr[0] = L'\0';
    if (fHResultString)
    {
	myHResultToString(awchr, hr);
    }

    if (0 == cwc)
    {
	pwszRetStatic = myLoadResourceString(IDS_UNKNOWN_ERROR_CODE); // L"Error"
	if (NULL == pwszRetStatic)
	{
            pwszRetStatic = s_wszUnknownDefault;
        }
	pwszRet = pwszRetStatic;
    }

    // strip trailing \r\n

    cwcCopy = wcslen(pwszRet);
    if (2 <= cwcCopy &&
	L'\r' == pwszRet[cwcCopy - 2] &&
	L'\n' == pwszRet[cwcCopy - 1])
    {
	cwcCopy -= 2;
    }
    cwc = cwcCopy + 1 + cwcUnexpected + 1 + wcslen(awchr) + 1;
    pwszMsgT = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwszMsgT)
    {
	_JumpError(E_OUTOFMEMORY, error, "LocalAlloc");
    }
    CopyMemory(pwszMsgT, pwszRet, cwcCopy * sizeof(WCHAR));
    pwszMsgT[cwcCopy] = L'\0';

    if (0 != cwcUnexpected)
    {
	wcscat(pwszMsgT, L" ");
	wcscat(pwszMsgT, pwszUnexpected);
    }
    if (fHResultString)
    {
	wcscat(pwszMsgT, L" ");
	wcscat(pwszMsgT, awchr);
    }
    CSASSERT(wcslen(pwszMsgT) < cwc);
    if (NULL != pwszRet && pwszRetStatic != pwszRet)
    {
	LocalFree(const_cast<WCHAR *>(pwszRet));
    }
    pwszRet = pwszMsgT;

error:
    if (NULL != hMod)
    {
        FreeLibrary(hMod);
    }
    return(pwszRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certclib\logon.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       logon.cpp
//
//--------------------------------------------------------------------------

/*++

Copyright (c) 1995, 1996  Scott A. Field

Module Name:

    logon.c

Abstract:

    This module implements the network logon type by interfacing
    with the NT Lan Man Security Support Provider (NTLMSSP).

    If the logon succeds via the provided credentials, we duplicate
    the resultant Impersonation token to a Primary level token.
    This allows the result to be used in a call to CreateProcessAsUser

Author:

    Scott Field (sfield)    09-Jun-96

Revision History:

--*/
#include "pch.cpp"

#pragma hdrstop
#define SECURITY_WIN32



#include <windows.h>

#include <rpc.h>
#include <security.h>


BOOL
myNetLogonUser(
    LPTSTR UserName,
    LPTSTR DomainName,
    LPTSTR Password,
    PHANDLE phToken
    )
{
    SECURITY_STATUS SecStatus;
    CredHandle CredentialHandle1;
    CredHandle CredentialHandle2;

    CtxtHandle ClientContextHandle;
    CtxtHandle ServerContextHandle;
    SecPkgCredentials_Names sNames;

    ULONG ContextAttributes;

    ULONG PackageCount;
    ULONG PackageIndex;
    PSecPkgInfo PackageInfo;
    DWORD cbMaxToken;

    TimeStamp Lifetime;
    SEC_WINNT_AUTH_IDENTITY AuthIdentity;

    SecBufferDesc NegotiateDesc;
    SecBuffer NegotiateBuffer;

    SecBufferDesc ChallengeDesc;
    SecBuffer ChallengeBuffer;


    HANDLE hImpersonationToken;
    BOOL bSuccess = FALSE ; // assume this function will fail

    NegotiateBuffer.pvBuffer = NULL;
    ChallengeBuffer.pvBuffer = NULL;
    sNames.sUserName = NULL;
    ClientContextHandle.dwUpper = -1;
    ClientContextHandle.dwLower = -1;
    ServerContextHandle.dwUpper = -1;
    ServerContextHandle.dwLower = -1;
    CredentialHandle1.dwUpper = -1;
    CredentialHandle1.dwLower = -1;
    CredentialHandle2.dwUpper = -1;
    CredentialHandle2.dwLower = -1;


//
// << this section could be cached in a repeat caller scenario >>
//

    //
    // Get info about the security packages.
    //

    if(EnumerateSecurityPackages(
        &PackageCount,
        &PackageInfo
        ) != NO_ERROR) return FALSE;

    //
    // loop through the packages looking for NTLM
    //

    for(PackageIndex = 0 ; PackageIndex < PackageCount ; PackageIndex++ ) {
        if(PackageInfo[PackageIndex].Name != NULL) {
            if(lstrcmpi(PackageInfo[PackageIndex].Name, MICROSOFT_KERBEROS_NAME) == 0) {
                cbMaxToken = PackageInfo[PackageIndex].cbMaxToken;
                bSuccess = TRUE;
                break;
            }
        }
    }

    FreeContextBuffer( PackageInfo );

    if(!bSuccess) return FALSE;

    bSuccess = FALSE; // reset to assume failure

//
// << end of cached section >>
//

    //
    // Acquire a credential handle for the server side
    //

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    MICROSOFT_KERBEROS_NAME,    // Package Name
                    SECPKG_CRED_INBOUND,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &CredentialHandle1,
                    &Lifetime
                    );

    if ( SecStatus != NO_ERROR ) {
        goto cleanup;
    }


    //
    // Acquire a credential handle for the client side
    //

    ZeroMemory( &AuthIdentity, sizeof(AuthIdentity) );

    if ( DomainName != NULL ) {
        AuthIdentity.Domain = DomainName;
        AuthIdentity.DomainLength = lstrlen(DomainName);
    }

    if ( UserName != NULL ) {
        AuthIdentity.User = UserName;
        AuthIdentity.UserLength = lstrlen(UserName);
    }

    if ( Password != NULL ) {
        AuthIdentity.Password = Password;
        AuthIdentity.PasswordLength = lstrlen(Password);
    }

#ifdef UNICODE
    AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
#else
    AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
#endif

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    MICROSOFT_KERBEROS_NAME,    // Package Name
                    SECPKG_CRED_OUTBOUND,
                    NULL,
                    (DomainName == NULL && UserName == NULL && Password == NULL) ?
                        NULL : &AuthIdentity,
                    NULL,
                    NULL,
                    &CredentialHandle2,
                    &Lifetime
                    );

    if ( SecStatus != NO_ERROR ) {
        goto cleanup;
    }

    SecStatus =  QueryCredentialsAttributes(&CredentialHandle1, SECPKG_CRED_ATTR_NAMES, &sNames);
    if ( SecStatus != NO_ERROR ) {
        goto cleanup;
    }
    //
    // Get the NegotiateMessage (ClientSide)
    //

    NegotiateDesc.ulVersion = 0;
    NegotiateDesc.cBuffers = 1;
    NegotiateDesc.pBuffers = &NegotiateBuffer;

    NegotiateBuffer.cbBuffer = cbMaxToken;
    NegotiateBuffer.BufferType = SECBUFFER_TOKEN;
    NegotiateBuffer.pvBuffer = LocalAlloc( LMEM_FIXED, NegotiateBuffer.cbBuffer );

    if ( NegotiateBuffer.pvBuffer == NULL ) {
        goto cleanup;
    }

    SecStatus = InitializeSecurityContext(
                    &CredentialHandle2,
                    NULL,                       // No Client context yet
                    sNames.sUserName,                       // target name
                    ISC_REQ_SEQUENCE_DETECT,
                    0,                          // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,                       // No initial input token
                    0,                          // Reserved 2
                    &ClientContextHandle,
                    &NegotiateDesc,
                    &ContextAttributes,
                    &Lifetime
                    );
    if(SecStatus != NO_ERROR)
    {
        goto cleanup;
    }


    //
    // Get the ChallengeMessage (ServerSide)
    //

    NegotiateBuffer.BufferType |= SECBUFFER_READONLY;
    ChallengeDesc.ulVersion = 0;
    ChallengeDesc.cBuffers = 1;
    ChallengeDesc.pBuffers = &ChallengeBuffer;

    ChallengeBuffer.cbBuffer = cbMaxToken;
    ChallengeBuffer.BufferType = SECBUFFER_TOKEN;
    ChallengeBuffer.pvBuffer = LocalAlloc( LMEM_FIXED, ChallengeBuffer.cbBuffer );

    if ( ChallengeBuffer.pvBuffer == NULL ) {
        goto cleanup;
    }

    SecStatus = AcceptSecurityContext(
                    &CredentialHandle1,
                    NULL,               // No Server context yet
                    &NegotiateDesc,
                    ISC_REQ_SEQUENCE_DETECT,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    &ChallengeDesc,
                    &ContextAttributes,
                    &Lifetime
                    );
    if(SecStatus != NO_ERROR)
    {
        goto cleanup;
    }


    if(QuerySecurityContextToken(&ServerContextHandle, phToken) != NO_ERROR)
        goto cleanup;

    bSuccess = TRUE;

cleanup:

    //
    // Delete context
    //

    if((ClientContextHandle.dwUpper != -1) ||
        (ClientContextHandle.dwLower != -1))
    {
        DeleteSecurityContext( &ClientContextHandle );
    }
    if((ServerContextHandle.dwUpper != -1) ||
        (ServerContextHandle.dwLower != -1))
    {
        DeleteSecurityContext( &ServerContextHandle );
    }

    //
    // Free credential handles
    //
    if((CredentialHandle1.dwUpper != -1) ||
        (CredentialHandle1.dwLower != -1))
    {
        FreeCredentialsHandle( &CredentialHandle1 );
    }
    if((CredentialHandle2.dwUpper != -1) ||
        (CredentialHandle2.dwLower != -1))
    {
        FreeCredentialsHandle( &CredentialHandle2 );
    }

    if ( NegotiateBuffer.pvBuffer != NULL ) {
        ZeroMemory( NegotiateBuffer.pvBuffer, NegotiateBuffer.cbBuffer );
        LocalFree( NegotiateBuffer.pvBuffer );
    }

    if ( ChallengeBuffer.pvBuffer != NULL ) {
        ZeroMemory( ChallengeBuffer.pvBuffer, ChallengeBuffer.cbBuffer );
        LocalFree( ChallengeBuffer.pvBuffer );
    }

    if ( sNames.sUserName != NULL ) {
        FreeContextBuffer( sNames.sUserName );
    }

    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certclib\oidmgr.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        oidmgr.h
//
// Contents:    Declaration of oidmgr.cpp
//
// History:     2-17-00 xiaohs  Created
//
//---------------------------------------------------------------------------
#ifndef __OIDMGR_H__
#define __OIDMGR_H__


//---------------------------------------------------------------------------
//
//  Constants
//
//---------------------------------------------------------------------------


#define OID_CONTAINER_PROP_OID          OID_PROP_OID
#define OID_CONTAINER_PROP_GUID         L"objectGUID"

#define wszOID_DOT                      L"."
#define wszOID_ENTERPRISE_ROOT          TEXT(szOID_ENTERPRISE_OID_ROOT)

//the GUID string is in the form of DWORD.DWORD.DWORD.DWORD
#define DWORD_STRING_LENGTH             12
#define GUID_STRING_LENGTH              4 * (DWORD_STRING_LENGTH + 1)

//OID flags/types definition
#define CERT_OID_SETTABLE_FLAGS         0xFFFF0000

#define CERT_OID_MD5_HASH_SIZE			16
//the lenght of oid component that is part of the CN
#define CERT_OID_IDENTITY_LENGTH        16

#define	UPPER_BITS			            0xF0
#define	LOWER_BITS			            0x0F

#define OID_RANDOM_CREATION_TRIAL       50
//the number of attribute for the enterprise OID class
#define OID_ATTR_COUNT                  6

//we reserver the 1.1-1.500 as the default OIDs for certifcate types
#define OID_RESERVE_DEFAULT_ONE         1
#define OID_RESERVR_DEFAULT_TWO         500

//---------------------------------------------------------------------------
//
//  Data type defines
//
//---------------------------------------------------------------------------
#define OID_ATTR_OID                    0x01
#define OID_ATTR_TYPE                   0x02
#define OID_ATTR_DISPLAY_NAME           0x04
#define OID_ATTR_CPS                    0x08

#define OID_ATTR_ALL                    (OID_ATTR_OID | OID_ATTR_TYPE | OID_ATTR_DISPLAY_NAME | OID_ATTR_CPS)

typedef struct _ENT_OID_INFO
{
    DWORD       dwAttr;
    LPWSTR      pwszOID;
    DWORD       dwType;
    LPWSTR      pwszDisplayName;
    LPWSTR      pwszCPS;
}ENT_OID_INFO;


extern LPWSTR g_pwszEnterpriseRootOID;

//---------------------------------------------------------------------------
//
//  Function Prototypes
//
//---------------------------------------------------------------------------
HRESULT     I_CAOIDCreateNew(DWORD dwType, DWORD   dwFlag,   LPWSTR	*ppwszOID);

HRESULT     CAOIDRetrieveEnterpriseRoot(DWORD   dwFlag, LPWSTR  *ppwszOID);

HRESULT     CAOIDBuildOID(DWORD dwFlag, LPCWSTR  pwszEndOID, LPWSTR *ppwszOID);

HRESULT     I_CAOIDSetProperty(LPCWSTR pwszOID, DWORD   dwProperty, LPVOID  pPropValue);

HRESULT     I_CAOIDAdd(DWORD   dwType,  DWORD  dwFlag, LPCWSTR  pwszOID);

HRESULT
I_CAOIDGetProperty(
    IN  LPCWSTR pwszOID,
    IN  DWORD   dwProperty,
    OUT LPVOID  pPropValue);

HRESULT
I_CAOIDFreeProperty(
    IN LPVOID  pPropValue);




#endif //__OIDMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certclib\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
// History:     25-Jul-96       vich created
//
//---------------------------------------------------------------------------

#define __DIR__		"certclib"

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#ifndef MAXDWORD
# define MAXDWORD MAXULONG
#endif

#include <windows.h>
#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>
#include "certlib.h"

#ifndef MAXDWORD
#define MAXDWORD MAXULONG
#endif

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certdb\backup.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        backup.cpp
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "csprop.h"
#include "db.h"
#include "backup.h"


#if DBG
LONG g_cCertDBBackup;
LONG g_cCertDBBackupTotal;
#endif

CCertDBBackup::CCertDBBackup()
{
    DBGCODE(InterlockedIncrement(&g_cCertDBBackup));
    DBGCODE(InterlockedIncrement(&g_cCertDBBackupTotal));
    m_pdb = NULL;
    m_pcs = NULL;
    m_fFileOpen = FALSE;
    m_fBegin = FALSE;
    m_fTruncated = FALSE;
    m_cRef = 1;
}


CCertDBBackup::~CCertDBBackup()
{
    DBGCODE(InterlockedDecrement(&g_cCertDBBackup));
    _Cleanup();
}


VOID
CCertDBBackup::_Cleanup()
{
    HRESULT hr;

    if (NULL != m_pdb)
    {
	if (m_fFileOpen)
	{
	    CloseFile();
	}
	if (m_fBegin)
	{
	    hr = ((CCertDB *) m_pdb)->BackupEnd();
	    _PrintIfError(hr, "BackupEnd");
	    m_fBegin = FALSE;
	}
	if (NULL != m_pcs)
	{
	    hr = ((CCertDB *) m_pdb)->ReleaseSession(m_pcs);
	    _PrintIfError(hr, "ReleaseSession");
	    m_pcs = NULL;
	}
	m_pdb->Release();
	m_pdb = NULL;
    }
}


HRESULT
CCertDBBackup::Open(
    IN LONG grbitJet,
    IN CERTSESSION *pcs,
    IN ICertDB *pdb)
{
    HRESULT hr;

    _Cleanup();

    if (NULL == pcs || NULL == pdb)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    m_pdb = pdb;
    m_pdb->AddRef();

    m_grbitJet = grbitJet;

    CSASSERT(0 == pcs->cTransact);
    hr = ((CCertDB *) m_pdb)->BackupBegin(m_grbitJet);
    _JumpIfError(hr, error, "BackupBegin");

    m_pcs = pcs;
    m_fBegin = TRUE;

error:
    if (S_OK != hr)
    {
	_Cleanup();
    }
    return(hr);
}


STDMETHODIMP
CCertDBBackup::GetDBFileList(
    IN OUT DWORD *pcwcList,
    OPTIONAL OUT WCHAR *pwszzList)
{
    HRESULT hr;

    hr = E_UNEXPECTED;
    if (!m_fBegin)
    {
	_JumpError(hr, error, "!m_fBegin");
    }
    if (NULL == pcwcList)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    hr = ((CCertDB *) m_pdb)->BackupGetDBFileList(pcwcList, pwszzList);
    _JumpIfError(hr, error, "BackupGetDBFileList");

error:
    return(hr);
}


STDMETHODIMP
CCertDBBackup::GetLogFileList(
    IN OUT DWORD *pcwcList,
    OPTIONAL OUT WCHAR *pwszzList)
{
    HRESULT hr;

    if (!m_fBegin)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "!m_fBegin");
    }
    if (NULL == pcwcList)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    hr = ((CCertDB *) m_pdb)->BackupGetLogFileList(pcwcList, pwszzList);
    _JumpIfError(hr, error, "BackupGetLogFileList");

error:
    return(hr);
}



STDMETHODIMP
CCertDBBackup::OpenFile(
    IN WCHAR const *pwszFile,
    OPTIONAL OUT ULARGE_INTEGER *pliSize)
{
    HRESULT hr;

    hr = E_UNEXPECTED;
    if (!m_fBegin)
    {
	_JumpError(hr, error, "!m_fBegin");
    }
    if (m_fFileOpen)
    {
	_JumpError(hr, error, "m_fFileOpen");
    }
    if (m_fTruncated)
    {
	_JumpError(hr, error, "m_fTruncated");
    }

    hr = ((CCertDB *) m_pdb)->BackupOpenFile(pwszFile, &m_hFileDB, pliSize);
    _JumpIfErrorStr(hr, error, "BackupOpenFile", pwszFile);

    m_fFileOpen = TRUE;

error:
    return(hr);
}


STDMETHODIMP
CCertDBBackup::ReadFile(
    IN OUT DWORD *pcb,
    OUT    BYTE *pb)
{
    HRESULT hr;

    if (!m_fFileOpen)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "!m_fFileOpen");
    }
    if (NULL == pcb || NULL == pb)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    hr = ((CCertDB *) m_pdb)->BackupReadFile(m_hFileDB, pb, *pcb, pcb);
    _JumpIfError(hr, error, "BackupReadFile");

error:
    return(hr);
}


STDMETHODIMP
CCertDBBackup::CloseFile()
{
    HRESULT hr;

    if (!m_fFileOpen)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "!m_fFileOpen");
    }

    hr = ((CCertDB *) m_pdb)->BackupCloseFile(m_hFileDB);
    _JumpIfError(hr, error, "BackupCloseFile");

    m_fFileOpen = FALSE;

error:
    return(hr);
}


STDMETHODIMP
CCertDBBackup::TruncateLog()
{
    HRESULT hr;

    hr = E_UNEXPECTED;
    if (!m_fBegin)
    {
	_JumpError(hr, error, "!m_fBegin");
    }
    if (m_fFileOpen)
    {
	_JumpError(hr, error, "m_fFileOpen");
    }

    hr = ((CCertDB *) m_pdb)->BackupTruncateLog();
    _JumpIfError(hr, error, "BackupTruncateLog");

    m_fTruncated = TRUE;

error:
    return(hr);
}


// IUnknown implementation
STDMETHODIMP
CCertDBBackup::QueryInterface(
    const IID& iid,
    void **ppv)
{
    HRESULT hr;
    
    if (NULL == ppv)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (iid == IID_IUnknown)
    {
	*ppv = static_cast<ICertDBBackup *>(this);
    }
    else if (iid == IID_ICertDBBackup)
    {
	*ppv = static_cast<ICertDBBackup *>(this);
    }
    else
    {
	*ppv = NULL;
	hr = E_NOINTERFACE;
	_JumpError(hr, error, "IID");
    }
    reinterpret_cast<IUnknown *>(*ppv)->AddRef();
    hr = S_OK;

error:
    return(hr);
}


ULONG STDMETHODCALLTYPE
CCertDBBackup::AddRef()
{
    return(InterlockedIncrement(&m_cRef));
}


ULONG STDMETHODCALLTYPE
CCertDBBackup::Release()
{
    ULONG cRef = InterlockedDecrement(&m_cRef);

    if (0 == cRef)
    {
	delete this;
    }
    return(cRef);
}


#if 0
STDMETHODIMP
CCertDBBackup::InterfaceSupportsErrorInfo(
    IN REFIID riid)
{
    static const IID *arr[] =
    {
	&IID_ICertDBBackup,
    };

    for (int i = 0; i < sizeof(arr)/sizeof(arr[0]); i++)
    {
	if (InlineIsEqualGUID(*arr[i], riid))
	{
	    return(S_OK);
	}
    }
    return(S_FALSE);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certdb\atl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       atl.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp: source file that includes just the standard includes
// stdafx.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include <pch.cpp>

#pragma hdrstop

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certdb\backup.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        backup.h
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------


#include "resource.h"       // main symbols

class CCertDBBackup: public ICertDBBackup
{
public:
    CCertDBBackup();
    ~CCertDBBackup();

public:

    // IUnknown
    STDMETHODIMP QueryInterface(const IID& iid, void **ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // ICertDBBackup
    STDMETHOD(GetDBFileList)(
	IN OUT DWORD *pcwcList,
	OUT    WCHAR *pwszzList);		// OPTIONAL

    STDMETHOD(GetLogFileList)(
	IN OUT DWORD *pcwcList,
	OUT    WCHAR *pwszzList);		// OPTIONAL

    STDMETHOD(OpenFile)(
	IN WCHAR const *pwszFile,
	OPTIONAL OUT ULARGE_INTEGER *pliSize);

    STDMETHOD(ReadFile)(
	IN OUT DWORD *pcb,
	OUT    BYTE *pb);

    STDMETHOD(CloseFile)();

    STDMETHOD(TruncateLog)();

    // CCertDBBackup
    HRESULT Open(
	IN LONG grbitJet,
	IN CERTSESSION *pcs,
	IN ICertDB *pdb);

private:
    VOID _Cleanup();

    ICertDB     *m_pdb;
    CERTSESSION *m_pcs;

    LONG         m_grbitJet;
    BOOL         m_fBegin;
    BOOL         m_fFileOpen;
    BOOL         m_fTruncated;
    JET_HANDLE   m_hFileDB;

    // Reference count
    long         m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certdb\column.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        column.cpp
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "csprop.h"
#include "column.h"
#include "enum.h"
#include "db.h"
#include "row.h"
#include "dbw.h"


#if DBG
LONG g_cCertDBColumn;
LONG g_cCertDBColumnTotal;
#endif

CEnumCERTDBCOLUMN::CEnumCERTDBCOLUMN()
{
    DBGCODE(InterlockedIncrement(&g_cCertDBColumn));
    DBGCODE(InterlockedIncrement(&g_cCertDBColumnTotal));
    m_pdb = NULL;
    m_ielt = 0;
    m_dwTable = CVRC_TABLE_REQCERT;
    m_cRef = 1;
}


CEnumCERTDBCOLUMN::~CEnumCERTDBCOLUMN()
{
    DBGCODE(InterlockedDecrement(&g_cCertDBColumn));
    if (NULL != m_pdb)
    {
	m_pdb->Release();
	m_pdb = NULL;
    }
}


HRESULT
CEnumCERTDBCOLUMN::Open(
    IN DWORD    dwTable,	// CVRC_TABLE_*
    IN ICertDB *pdb)
{
    HRESULT hr;
    
    if (NULL == pdb)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    m_dwTable = dwTable;
    m_pdb = pdb;
    m_pdb->AddRef();
    hr = S_OK;

error:
    return(hr);
}


STDMETHODIMP
CEnumCERTDBCOLUMN::Next(
    /* [in] */  ULONG         celt,
    /* [out] */ CERTDBCOLUMN *rgelt,
    /* [out] */ ULONG        *pceltFetched)
{
    HRESULT hr;
    DWORD ieltNext;

    if (NULL == rgelt || NULL == pceltFetched)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (NULL == m_pdb)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_pdb");
    }
    hr = ((CCertDB *) m_pdb)->EnumCertDBColumnNext(
						m_dwTable,
						m_ielt,
						celt,
						rgelt,
						&ieltNext,
						pceltFetched);
    if (S_FALSE != hr)
    {
	_JumpIfError(hr, error, "EnumCertDBColumnNext");
    }
    m_ielt = ieltNext;

error:
    return(hr);
}


STDMETHODIMP
CEnumCERTDBCOLUMN::Skip(
    /* [in] */  LONG  celt,
    /* [out] */ LONG *pielt)
{
    HRESULT hr;

    if (NULL == pielt)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    m_ielt += celt;
    *pielt = m_ielt;
    hr = S_OK;

error:
    return(hr);
}


STDMETHODIMP
CEnumCERTDBCOLUMN::Reset(VOID)
{
    m_ielt = 0;
    return(S_OK);
}


STDMETHODIMP
CEnumCERTDBCOLUMN::Clone(
    /* [out] */ IEnumCERTDBCOLUMN **ppenum)
{
    HRESULT hr;
    LONG iDummy;
    IEnumCERTDBCOLUMN *penum = NULL;

    if (NULL == ppenum)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    hr = m_pdb->EnumCertDBColumn(m_dwTable, &penum);
    _JumpIfError(hr, error, "EnumCertDBColumn");

    if (0 != m_ielt)
    {
	penum->Skip(m_ielt, &iDummy);
    }

error:
    if (NULL != ppenum)
    {
	*ppenum = penum;
    }
    return(hr);
}


// IUnknown implementation
STDMETHODIMP
CEnumCERTDBCOLUMN::QueryInterface(const IID& iid, void **ppv)
{
    HRESULT hr;
    
    if (NULL == ppv)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (iid == IID_IUnknown)
    {
	*ppv = static_cast<IEnumCERTDBCOLUMN *>(this);
    }
    else if (iid == IID_IEnumCERTDBCOLUMN)
    {
	*ppv = static_cast<IEnumCERTDBCOLUMN *>(this);
    }
    else
    {
	*ppv = NULL;
	hr = E_NOINTERFACE;
	_JumpError(hr, error, "IID");
    }
    reinterpret_cast<IUnknown *>(*ppv)->AddRef();
    hr = S_OK;

error:
    return(hr);
}


ULONG STDMETHODCALLTYPE
CEnumCERTDBCOLUMN::AddRef()
{
    return(InterlockedIncrement(&m_cRef));
}


ULONG STDMETHODCALLTYPE
CEnumCERTDBCOLUMN::Release()
{
    ULONG cRef = InterlockedDecrement(&m_cRef);

    if (0 == cRef)
    {
	delete this;
    }
    return(cRef);
}


#if 0
STDMETHODIMP
CEnumCERTDBCOLUMN::InterfaceSupportsErrorInfo(
    IN REFIID riid)
{
    static const IID *arr[] =
    {
	&IID_IEnumCERTDBCOLUMN,
    };

    for (int i = 0; i < sizeof(arr)/sizeof(arr[0]); i++)
    {
	if (InlineIsEqualGUID(*arr[i], riid))
	{
	    return(S_OK);
	}
    }
    return(S_FALSE);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certclib\serial.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        serial.cpp
//
// Contents:    serial number string encode/decode implementation
//
//---------------------------------------------------------------------------

#include <pch.cpp>
#pragma hdrstop


HRESULT
ObsoleteMultiByteIntegerToWszBuf(
    IN BOOL fOctetString,
    IN DWORD cbIn,
    IN BYTE const *pbIn,
    IN OUT DWORD *pcbOut,
    OPTIONAL OUT WCHAR *pwszOut)
{
    return MultiByteIntegerToWszBuf(
                fOctetString,
                cbIn,
                pbIn,
                pcbOut,
                pwszOut);
}

HRESULT
ObsoleteMultiByteIntegerToBstr(
    IN BOOL fOctetString,
    IN DWORD cbIn,
    IN BYTE const *pbIn,
    OUT BSTR *pstrOut)
{
    return MultiByteIntegerToBstr(
                fOctetString,
                cbIn,
                pbIn,
                pstrOut);
}

BOOL
AsciiToNibble(
    IN WCHAR wc,
    BYTE *pb)
{
    BOOL fOk = TRUE;

    do
    {
	wc -= L'0';
	if (wc <= 9)
	{
	    break;
	}
	wc += (WCHAR) (L'0' - L'a' + 10);
	if (wc <= 15)
	{
	    break;
	}
	wc += L'a' - L'A';
	if (wc <= 15)
	{
	    break;
	}
	fOk = FALSE;
    } while (FALSE);

    *pb = (BYTE) wc;
    return(fOk);
}


__inline BOOL
IsMultiByteSkipChar(
    IN WCHAR wc)
{
    return(L' ' == wc || L'\t' == wc);
}


// WszToMultiByteIntegerBuf - convert a big endian null-terminated ascii-hex
// encoded WCHAR string of even length to a little-endian integer blob.
// If fOctetString is TRUE, preserve endian order, as in a hex dump

HRESULT
WszToMultiByteIntegerBuf(
    IN BOOL fOctetString,
    IN WCHAR const *pwszIn,
    IN OUT DWORD *pcbOut,
    OPTIONAL OUT BYTE *pbOut)
{
    HRESULT hr;
    WCHAR const *pwsz;
    DWORD cbOut;

    cbOut = 0;
    hr = E_INVALIDARG;

    if (fOctetString)
    {
	for (pwsz = pwszIn; L'\0' != *pwsz; )
	{
	    BYTE blo, bhi;

	    while (IsMultiByteSkipChar(*pwsz))
	    {
		pwsz++;
	    }
	    if (!AsciiToNibble(*pwsz, &bhi))
	    {
		_JumpError2(
			hr,
			error,
			"WszToMultiByteInteger: bad string",
			E_INVALIDARG);
	    }
	    pwsz++;

	    while (IsMultiByteSkipChar(*pwsz))
	    {
		pwsz++;
	    }
	    if (!AsciiToNibble(*pwsz, &blo))
	    {
		_JumpError(hr, error, "WszToMultiByteInteger: bad string");
	    }
	    pwsz++;

	    cbOut++;
	    if (NULL != pbOut)
	    {
		if (cbOut > *pcbOut)
		{
		    hr = TYPE_E_BUFFERTOOSMALL;
		    _JumpError(hr, error, "WszToMultiByteInteger: overflow");
		}
		*pbOut++ = blo | (bhi << 4);
	    }
	}
    }
    else
    {
	for (pwsz = &pwszIn[wcslen(pwszIn) - 1]; pwsz >= pwszIn; )
	{
	    BYTE blo, bhi;

	    while (pwsz >= pwszIn && IsMultiByteSkipChar(*pwsz))
	    {
		pwsz--;
	    }
	    if (pwsz < pwszIn)
	    {
		break;
	    }
	    if (!AsciiToNibble(*pwsz, &blo))
	    {
		_JumpError(hr, error, "WszToMultiByteInteger: bad string");
	    }
	    pwsz--;

	    while (pwsz >= pwszIn && IsMultiByteSkipChar(*pwsz))
	    {
		pwsz--;
	    }
	    if (pwsz < pwszIn || !AsciiToNibble(*pwsz, &bhi))
	    {
		_JumpError(hr, error, "WszToMultiByteInteger: bad string");
	    }
	    pwsz--;

	    cbOut++;
	    if (NULL != pbOut)
	    {
		if (cbOut > *pcbOut)
		{
		    hr = TYPE_E_BUFFERTOOSMALL;
		    _JumpError(hr, error, "WszToMultiByteInteger: overflow");
		}
		*pbOut++ = blo | (bhi << 4);
	    }
	}
    }
    *pcbOut = cbOut;
    hr = S_OK;

error:
    return(hr);
}


// WszToMultiByteInteger - convert a big endian null-terminated ascii-hex
// encoded WCHAR string of even length to a little-endian integer blob.
// If fOctetString is TRUE, preserve endian order, as in a hex dump

HRESULT
WszToMultiByteInteger(
    IN BOOL fOctetString,
    IN WCHAR const *pwszIn,
    OUT DWORD *pcbOut,
    OUT BYTE **ppbOut)
{
    HRESULT hr = S_OK;

    *pcbOut = 0;
    *ppbOut = NULL;

    while (TRUE)
    {
	hr = WszToMultiByteIntegerBuf(fOctetString, pwszIn, pcbOut, *ppbOut);
	if (S_OK != hr)
	{
	    if (NULL != *ppbOut)
	    {
		LocalFree(*ppbOut);
		*ppbOut = NULL;
	    }
	    _JumpError2(hr, error, "WszToMultiByteIntegerBuf", E_INVALIDARG);
	}
	if (NULL != *ppbOut)
	{
	    break;
	}
	*ppbOut = (BYTE *) LocalAlloc(LMEM_FIXED, *pcbOut);
	if (NULL == *ppbOut)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }

error:
    return(hr);
}


HRESULT
caTranslateFileTimePeriodToPeriodUnits(
    IN FILETIME const *pftGMT,
    IN BOOL fExact,
    OUT DWORD *pcPeriodUnits,
    OUT PERIODUNITS **prgPeriodUnits)
{
    HRESULT hr;
    LLFILETIME llft;
    LONGLONG llRemain;
    DWORD i;
    DWORD cPeriodUnits;
    PERIODUNITS *rgPeriodUnits;
#define IC_YEARS	0
#define IC_MONTHS	1
#define IC_WEEKS	2
#define IC_DAYS		3
#define IC_HOURS	4
#define IC_MINUTES	5
#define IC_SECONDS	6
#define IC_MAX		7
    LONG alCount[IC_MAX];
    static const enum ENUM_PERIOD s_aenumPeriod[] =
    {
	ENUM_PERIOD_YEARS,
	ENUM_PERIOD_MONTHS,
	ENUM_PERIOD_WEEKS,
	ENUM_PERIOD_DAYS,
	ENUM_PERIOD_HOURS,
	ENUM_PERIOD_MINUTES,
	ENUM_PERIOD_SECONDS,
    };
    
    llft.ft = *pftGMT;
    if (0 <= llft.ll)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Not a time period");
    }
    llft.ll = -llft.ll;
    llft.ll /= CVT_BASE; // now in seconds

    ZeroMemory(alCount, sizeof(alCount));
    alCount[IC_DAYS] = (LONG) (llft.ll / (60 * 60 * 24));

    llRemain = llft.ll - (LONGLONG) alCount[IC_DAYS] * (60 * 60 * 24);
    if (fExact || 4 > alCount[IC_DAYS])	// if less than 96 hrs
    {
	alCount[IC_HOURS] = (LONG) llRemain / (60 * 60);
	if (fExact || 2 > alCount[IC_HOURS])	// if less than 120 mins
	{
	    alCount[IC_MINUTES] = ((LONG) llRemain / 60) % 60;
	    if (fExact || 2 > alCount[IC_MINUTES]) // if less than 120 secs
	    {
		alCount[IC_SECONDS] = (LONG) llRemain % 60;
	    }
	}
    }

    if (0 != alCount[IC_DAYS])
    {
	if (0 == (alCount[IC_DAYS] % 365))
	{
	    alCount[IC_YEARS] = alCount[IC_DAYS] / 365;
	    alCount[IC_DAYS] = 0;
	}
	else if (0 == (alCount[IC_DAYS] % 30))
	{
	    alCount[IC_MONTHS] = alCount[IC_DAYS] / 30;
	    alCount[IC_DAYS] = 0;
	}
	else if (0 == (alCount[IC_DAYS] % 7))
	{
	    alCount[IC_WEEKS] = alCount[IC_DAYS] / 7;
	    alCount[IC_DAYS] = 0;
	}
    }
    cPeriodUnits = 0;
    for (i = 0; i < IC_MAX; i++)
    {
	if (0 != alCount[i])
	{
	    cPeriodUnits++;
	}
    }
    if (0 == cPeriodUnits)
    {
	cPeriodUnits++;
    }
    rgPeriodUnits = (PERIODUNITS *) LocalAlloc(
				LMEM_FIXED,
				cPeriodUnits * sizeof(rgPeriodUnits[0]));
    if (NULL == rgPeriodUnits)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    *pcPeriodUnits = cPeriodUnits;
    *prgPeriodUnits = rgPeriodUnits;

    cPeriodUnits = 0;
    for (i = 0; i < IC_MAX; i++)
    {
	if (0 != alCount[i] || (0 == cPeriodUnits && i + 1 == IC_MAX))
	{
	    rgPeriodUnits[cPeriodUnits].lCount = alCount[i];
	    rgPeriodUnits[cPeriodUnits].enumPeriod = s_aenumPeriod[i];
	    cPeriodUnits++;
	}
    }
    CSASSERT(cPeriodUnits == *pcPeriodUnits);
    hr = S_OK;

error:
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certdb\column.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        column.h
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------


#include "resource.h"       // main symbols

class CEnumCERTDBCOLUMN: public IEnumCERTDBCOLUMN
{
public:
    CEnumCERTDBCOLUMN();
    ~CEnumCERTDBCOLUMN();

public:

    // IUnknown
    STDMETHODIMP QueryInterface(const IID& iid, void **ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IEnumCERTDBCOLUMN


    STDMETHOD(Next)(
	/* [in] */  ULONG         celt,		// celt OR (CVRC_TABLE_* | 0)
	/* [out] */ CERTDBCOLUMN *rgelt,
	/* [out] */ ULONG        *pceltFetched);
    
    STDMETHOD(Skip)(
	/* [in] */  LONG  celt,
	/* [out] */ LONG *pielt);
    
    STDMETHOD(Reset)(VOID);
    
    STDMETHOD(Clone)(
	/* [out] */ IEnumCERTDBCOLUMN **ppenum);


    HRESULT Open(
	IN DWORD    dwTable,	// CVRC_TABLE_*
	IN ICertDB *pdb);
	
private:
    ICertDB *m_pdb;
    ULONG    m_ielt;
    ULONG    m_dwTable;

    // Reference count
    long     m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certdb\certdb.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certdb.cpp
//
// Contents:    Cert Server Database Access implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include "db.h"
#include "backup.h"
#include "restore.h"


// for new jet snapshotting
#ifndef _DISABLE_VSS_
#include <vss.h>
#include <vswriter.h>
#include "jetwriter.h"
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CCertDB, CCertDB)
    OBJECT_ENTRY(CLSID_CCertDBRestore, CCertDBRestore)
END_OBJECT_MAP()

#ifndef _DISABLE_VSS_
const GUID cGuidCertSrvWriter = {0x6f5b15b5,0xda24,0x4d88,{0xb7, 0x37, 0x63, 0x06, 0x3e, 0x3a, 0x1f, 0x86}}; // 6f5b15b5-da24-4d88-b737-63063e3a1f86
CVssJetWriter* g_pWriter = NULL;
#endif


HRESULT
InitGlobalWriterState(VOID)
{
   HRESULT hr;

#ifndef _DISABLE_VSS_
   if (NULL == g_pWriter && IsWhistler())
   {
       // create writer object

       g_pWriter = new CVssJetWriter;
       if (NULL == g_pWriter)
       {
	   hr = E_OUTOFMEMORY;
	   _JumpError(hr, error, "new CVssJetWriter");
       }

       hr = g_pWriter->Initialize(
			cGuidCertSrvWriter,		// id of writer
			L"Certificate Server Writer",	// name of writer
			TRUE,				// system service
			TRUE,				// bootable state
			NULL,				// files to include
			NULL);				// files to exclude
       _JumpIfError(hr, error, "CVssJetWriter::Initialize");
   }
#endif
   hr = S_OK;

#ifndef _DISABLE_VSS_
error:
#endif
   return hr;
}


HRESULT
UnInitGlobalWriterState(VOID)
{
#ifndef _DISABLE_VSS_
    if (NULL != g_pWriter)
    {
	g_pWriter->Uninitialize();
	delete g_pWriter;
	g_pWriter = NULL;
    }
#endif
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    switch (dwReason)
    {
	case DLL_PROCESS_ATTACH:
	    _Module.Init(ObjectMap, hInstance);
	    DisableThreadLibraryCalls(hInstance);
	    break;

        case DLL_PROCESS_DETACH:
	    _Module.Term();
            break;
    }
    return(TRUE);    // ok
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI
DllCanUnloadNow(void)
{
    return(_Module.GetLockCount() == 0? S_OK : S_FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI
DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;
    
    hr = _Module.GetClassObject(rclsid, riid, ppv);
    if (S_OK == hr && NULL != *ppv)
    {
	myRegisterMemFree(*ppv, CSM_NEW | CSM_GLOBALDESTRUCTOR);
    }
    return(hr);
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI
DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return(_Module.RegisterServer(TRUE));
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI
DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certdb\dbtable.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        dbtable.h
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------

#ifndef __DBTABLE_H__
#define __DBTABLE_H__ 1


#define DTR_REQUESTID				0
#define DTR_REQUESTRAWREQUEST			1
#define DTR_REQUESTRAWARCHIVEDKEY		2
#define DTR_REQUESTKEYRECOVERYHASHES		3
#define DTR_REQUESTRAWOLDCERTIFICATE		4
#define DTR_REQUESTATTRIBUTES			5
#define DTR_REQUESTTYPE				6
#define DTR_REQUESTFLAGS			7
#define DTR_REQUESTSTATUSCODE			8
#define DTR_REQUESTDISPOSITION			9
#define DTR_REQUESTDISPOSITIONMESSAGE		10
#define DTR_REQUESTSUBMITTEDWHEN		11
#define DTR_REQUESTRESOLVEDWHEN			12
#define DTR_REQUESTREVOKEDWHEN			13
#define DTR_REQUESTREVOKEDEFFECTIVEWHEN		14
#define DTR_REQUESTREVOKEDREASON		15
#define DTR_REQUESTERNAME			16
#define DTR_CALLERNAME				17
#define DTR_SIGNERPOLICIES			18
#define DTR_SIGNERAPPLICATIONPOLICIES		19
#define DTR_DISTINGUISHEDNAME			20
#define DTR_RAWNAME				21
#define DTR_COUNTRY				22
#define DTR_ORGANIZATION			23
#define DTR_ORGUNIT				24
#define DTR_COMMONNAME				25
#define DTR_LOCALITY				26
#define DTR_STATE				27
#define DTR_TITLE				28
#define DTR_GIVENNAME				29
#define DTR_INITIALS				30
#define DTR_SURNAME				31
#define DTR_DOMAINCOMPONENT			32
#define DTR_EMAIL				33
#define DTR_STREETADDRESS			34
#define DTR_UNSTRUCTUREDNAME			35
#define DTR_UNSTRUCTUREDADDRESS			36
#define DTR_DEVICESERIALNUMBER			37
#define DTR_MAX					38


#define DTC_REQUESTID					0
#define DTC_RAWCERTIFICATE				1
#define DTC_CERTIFICATEHASH				2
#define DTC_CERTIFICATETEMPLATE				3
#define DTC_CERTIFICATEENROLLMENTFLAGS			4
#define DTC_CERTIFICATEGENERALFLAGS			5
#define DTC_CERTIFICATESERIALNUMBER			6
#define DTC_CERTIFICATEISSUERNAMEID			7
#define DTC_CERTIFICATENOTBEFOREDATE			8
#define DTC_CERTIFICATENOTAFTERDATE			9
#define DTC_CERTIFICATESUBJECTKEYIDENTIFIER		10
#define DTC_CERTIFICATERAWPUBLICKEY			11
#define DTC_CERTIFICATEPUBLICKEYLENGTH			12
#define DTC_CERTIFICATEPUBLICKEYALGORITHM		13
#define DTC_CERTIFICATERAWPUBLICKEYALGORITHMPARAMETERS	14
#define DTC_CERTIFICATEUPN				15
#define DTC_DISTINGUISHEDNAME				16
#define DTC_RAWNAME					17
#define DTC_COUNTRY					18
#define DTC_ORGANIZATION				19
#define DTC_ORGUNIT					20
#define DTC_COMMONNAME					21
#define DTC_LOCALITY					22
#define DTC_STATE					23
#define DTC_TITLE					24
#define DTC_GIVENNAME					25
#define DTC_INITIALS					26
#define DTC_SURNAME					27
#define DTC_DOMAINCOMPONENT				28
#define DTC_EMAIL					29
#define DTC_STREETADDRESS				30
#define DTC_UNSTRUCTUREDNAME				31
#define DTC_UNSTRUCTUREDADDRESS				32
#define DTC_DEVICESERIALNUMBER				33
#define DTC_MAX						34


#define DTA_REQUESTID				0
#define DTA_ATTRIBUTENAME			1
#define DTA_ATTRIBUTEVALUE			2
#define DTA_MAX					3


#define DTE_REQUESTID				0
#define DTE_EXTENSIONNAME			1
#define DTE_EXTENSIONFLAGS			2
#define DTE_EXTENSIONRAWVALUE			3
#define DTE_MAX					4


#define DTL_ROWID				0
#define DTL_NUMBER				1
#define DTL_MINBASE				2
#define DTL_NAMEID				3
#define DTL_COUNT				4
#define DTL_THISUPDATEDATE			5
#define DTL_NEXTUPDATEDATE			6
#define DTL_THISPUBLISHDATE			7
#define DTL_NEXTPUBLISHDATE			8
#define DTL_EFFECTIVEDATE			9
#define DTL_PROPAGATIONCOMPLETEDATE		10
#define DTL_LASTPUBLISHEDDATE			11
#define DTL_PUBLISHATTEMPTS			12
#define DTL_PUBLISHFLAGS			13
#define DTL_PUBLISHSTATUSCODE			14
#define DTL_PUBLISHERROR			15
#define DTL_RAWCRL				16
#define DTL_MAX					17


#define DTI_REQUESTTABLE			0x00001000
#define DTI_CERTIFICATETABLE			0x00002000
#define DTI_ATTRIBUTETABLE			0x00003000
#define DTI_EXTENSIONTABLE			0x00004000
#define DTI_CRLTABLE				0x00005000
#define DTI_TABLEMASK				0x0000f000
#define DTI_COLUMNMASK				0x00000fff


#define ISTEXTCOLTYP(coltyp) \
	(JET_coltypText == (coltyp) || JET_coltypLongText == (coltyp))

#define IsValidJetTableId(tableid) (0 != (tableid) && 0xffffffff != (tableid))


const DWORD DBTF_POLICYWRITEABLE = 0x00000001;
const DWORD DBTF_INDEXPRIMARY	 = 0x00000002;	// Primary DB Index
const DWORD DBTF_INDEXREQUESTID	 = 0x00000004;	// Combine Index with RequestID
const DWORD DBTF_SUBJECT	 = 0x00000008;	// Is a "Subject." property
const DWORD DBTF_INDEXUNIQUE     = 0x00000010;  // Force uniqueness constraint
const DWORD DBTF_INDEXIGNORENULL = 0x00000020;  // don't index NULLs
const DWORD DBTF_SOFTFAIL        = 0x00000040;  // optional column (it's new)
const DWORD DBTF_MISSING         = 0x00000080;  // optional column is missing
const DWORD DBTF_OLDCOLUMNID     = 0x00000100;  // old column id still exists
const DWORD DBTF_COLUMNRENAMED   = 0x00000200;  // renamed, old name appended
const DWORD DBTF_INDEXRENAMED    = 0x00000400;  // renamed, old name appended

typedef struct _DBTABLE
{
    WCHAR const *pwszPropName;
    WCHAR const *pwszPropNameObjId;
    DWORD        dwFlags;
    DWORD        dwcbMax;	// maximum allowed strlen/wcslen(value string)
    DWORD        dwTable;
    CHAR const  *pszFieldName;
    CHAR const  *pszIndexName;
    DWORD        dbcolumnMax;
    JET_GRBIT    dbgrbit;
    JET_COLTYP   dbcoltyp;
    JET_COLUMNID dbcolumnid;
    JET_COLUMNID dbcolumnidOld;	// Old column Id if DBTF_OLDCOLUMNID
} DBTABLE;

#define DBTABLE_NULL \
    { NULL, NULL, 0, 0, 0, NULL, NULL, 0, 0, 0, 0 } // Termination marker


typedef struct _DUPTABLE
{
    CHAR const  *pszFieldName;
    WCHAR const *pwszPropName;
} DUPTABLE;


typedef struct _DBAUXDATA
{
    char const    *pszTable;
    char const    *pszRowIdIndex;
    char const    *pszRowIdNameIndex;
    char const    *pszNameIndex;
    DBTABLE const *pdtRowId;
    DBTABLE const *pdtName;
    DBTABLE const *pdtFlags;
    DBTABLE const *pdtValue;
    DBTABLE const *pdtIssuerNameId;
} DBAUXDATA;


typedef struct _DBCREATETABLE {
    char const *pszTableName;
    DBAUXDATA  *pdbaux;
    DBTABLE    *pdt;
} DBCREATETABLE;


const DWORD TABLE_REQCERTS	= 0;
const DWORD TABLE_REQUESTS	= 1;
const DWORD TABLE_CERTIFICATES	= 2;
const DWORD TABLE_ATTRIBUTES	= 3;
const DWORD TABLE_EXTENSIONS	= 4;
const DWORD TABLE_CRLS		= 5;

const DWORD CSF_TABLEMASK =       0x0000000f;
const DWORD CSF_TABLESET =        0x00000010;
const DWORD CSF_INUSE =           0x00000020;
const DWORD CSF_READONLY =        0x00000040;
const DWORD CSF_CREATE =          0x00000080;
const DWORD CSF_DELETE =          0x00000100;
const DWORD CSF_VIEW =            0x00000200;
const DWORD CSF_VIEWRESET =       0x00000400;


const DWORD CST_SEEKINDEXRANGE =  0x00000001;
const DWORD CST_SEEKNOTMOVE =     0x00000002;
const DWORD CST_SEEKUSECURRENT =  0x00000004;
const DWORD CST_SEEKASCEND =      0x00000008;


const DWORD CVF_NOMOREDATA  = 0x00010000;
const DWORD CVF_COLUMNVALUE = 0x00020000;

char const szCERTIFICATE_REQUESTIDINDEX[] = "CertificateReqIdIndex";
char const szCERTIFICATE_COMMONNAMEINDEX[] = "$CertificateCommonNameIndex";
#define szCERTIFICATE_SERIALNUMBERINDEX "$CertificateSerialNumberIndex2"
#define szCERTIFICATE_SERIALNUMBERINDEX_OLD "$CertificateSerialNumberIndex"
char const szCERTIFICATE_HASHINDEX[] = "$CertificateHashIndex";
char const szCERTIFICATE_TEMPLATEINDEX[] = "$CertificateTemplateIndex";
#define szCERTIFICATE_NOTAFTERINDEX "CertificateNotAfterIndex"
#define szCERTIFICATE_NOTAFTERINDEX_OLD "$CertificateNotAfterIndex"
char const szCERTIFICATE_UPNINDEX[] = "$CertificateUPNIndex";

char const szREQUEST_REQUESTIDINDEX[] = "RequestReqIdIndex";
char const szREQUEST_DISPOSITIONINDEX[] = "RequestDispositionIndex";
char const szREQUEST_REQUESTERNAMEINDEX[] = "$RequestRequesterNameIndex";
char const szREQUEST_CALLERNAMEINDEX[] = "$RequestCallerNameIndex";
#define szREQUEST_RESOLVEDWHENINDEX "RequestResolvedWhenIndex"
#define szREQUEST_RESOLVEDWHENINDEX_OLD "$RequestResolvedWhenIndex"
#define szREQUEST_REVOKEDEFFECTIVEWHENINDEX "RequestRevokedEffectiveWhenIndex"
#define szREQUEST_REVOKEDEFFECTIVEWHENINDEX_OLD "$RequestRevokedEffectiveWhenIndex"

char const szEXTENSION_REQUESTIDINDEX[] = "ExtensionReqIdIndex";
char const szEXTENSION_REQUESTIDNAMEINDEX[] = "$ExtensionReqIdNameIndex";

char const szATTRIBUTE_REQUESTIDINDEX[] = "AttributeReqIdIndex";
char const szATTRIBUTE_REQUESTIDNAMEINDEX[] = "$AttributeReqIdNameIndex";

char const szCRL_ROWIDINDEX[] = "CRLRowIdIndex";
char const szCRL_CRLNUMBERINDEX[] = "CRLCRLNumberIndex";
char const szCRL_CRLNEXTUPDATEINDEX[] = "CRLCRLNextUpdateIndex";
char const szCRL_CRLNEXTPUBLISHINDEX[] = "CRLCRLNextPublishIndex";
char const szCRL_CRLPROPAGATIONCOMPLETEINDEX[] = "CRLCRLPropagationCompleteIndex";
char const szCRL_CRLLASTPUBLISHEDINDEX[] = "CRLLastPublishedIndex";
char const szCRL_CRLPUBLISHATTEMPTSINDEX[] = "CRLPublishAttemptsIndex";
char const szCRL_CRLPUBLSTATUSCODEISHINDEX[] = "CRLPublishStatusCodeIndex";


char const szCERTIFICATETABLE[] = "Certificates";
char const szREQUESTTABLE[] = "Requests";
char const szCERTIFICATEEXTENSIONTABLE[] = "CertificateExtensions";
char const szREQUESTATTRIBUTETABLE[] = "RequestAttributes";
char const szCRLTABLE[] = "CRLs";

#define wszCERTIFICATETABLE		L"Certificates"
#define wszREQUESTTABLE			L"Requests"
#define wszCERTIFICATEEXTENSIONTABLE	L"CertificateExtensions"
#define wszREQUESTATTRIBUTETABLE	L"RequestAttributes"
#define wszCRLTABLE			L"CRLs"

#define chTEXTPREFIX		'$'

#define szREQUESTID		"RequestID"
#define szRAWREQUEST		"RawRequest"
#define szRAWARCHIVEDKEY	"RawArchivedKey"
#define szKEYRECOVERYHASHES	"$KeyRecoveryHashes"
#define szRAWOLDCERTIFICATE	"RawOldCertificate"
#define szREQUESTATTRIBUTES	"$RequestAttributes"
#define szREQUESTTYPE		"RequestType"
#define szREQUESTFLAGS		"RequestFlags"
#define szSTATUSCODE		"StatusCode"
#define szDISPOSITION		"Disposition"
#define szDISPOSITIONMESSAGE	"$DispositionMessage"
#define szSUBMITTEDWHEN		"SubmittedWhen"
#define szRESOLVEDWHEN		"ResolvedWhen"
#define szREVOKEDWHEN		"RevokedWhen"
#define szREVOKEDEFFECTIVEWHEN	"RevokedEffectiveWhen"
#define szREVOKEDREASON		"RevokedReason"
#define szREQUESTERNAME		"$RequesterName"
#define szCALLERNAME		"$CallerName"
#define szSIGNERPOLICIES	"$SignerPolicies"
#define szSIGNERAPPLICATIONPOLICIES "$SignerApplicationPolicies"
#define szDISTINGUISHEDNAME	"$DistinguishedName"
#define szRAWNAME		"RawName"

#define szCOUNTRY		"$Country"
#define szORGANIZATION		"$Organization"
#define szORGANIZATIONALUNIT	"$OrganizationalUnit"
#define szCOMMONNAME		"$CommonName"
#define szLOCALITY		"$Locality"
#define szSTATEORPROVINCE	"$StateOrProvince"
#define szTITLE			"$Title"
#define szGIVENNAME		"$GivenName"
#define szINITIALS		"$Initials"
#define szSURNAME		"$SurName"
#define szDOMAINCOMPONENT	"$DomainComponent"
#define szEMAIL			"$EMail"
#define szSTREETADDRESS		"$StreetAddress"
#define szUNSTRUCTUREDNAME	"$UnstructuredName"
#define szUNSTRUCTUREDADDRESS	"$UnstructuredAddress"
#define szDEVICESERIALNUMBER	"$DeviceSerialNumber"


//#define szREQUESTID		"RequestID"
#define szRAWCERTIFICATE	"RawCertificate"
#define szCERTIFICATETEMPLATE	"$CertificateTemplate"
#define szCERTIFICATEENROLLMENTFLAGS	"EnrollmentFlags"
#define szCERTIFICATEGENERALFLAGS	"GeneralFlags"
#define szCERTIFICATEHASH	"$CertificateHash2"	// 2nd revision
#define szSERIALNUMBER		"$SerialNumber"
#define szISSUERNAMEID		"IssuerNameID"
#define szNOTBEFORE		"NotBefore"
#define szNOTAFTER		"NotAfter"
#define szUPN			"$UPN"
#define szSUBJECTKEYIDENTIFIER	"$SubjectKeyIdentifier"
#define szSUBJECTKEYIDENTIFIER_OLD "$CertificateHash"	// 2nd revision
#define szPUBLICKEY		"PublicKey"
#define szPUBLICKEYLENGTH	"PublicKeyLength"
#define szPUBLICKEYALGORITHM	"$PublicKeyAlgorithm"
#define szPUBLICKEYPARAMS	"PublicKeyParams"

//#define szDISTINGUISHEDNAME	"$DistinguishedName"
//#define szRAWNAME		"RawName"

//#define szCOUNTRY		"Country"
//#define ...

//#define szREQUESTID		"RequestID"
#define szATTRIBUTENAME		"$AttributeName"
#define szATTRIBUTEVALUE	"$AttributeValue"

//#define szREQUESTID		"RequestID"
#define szEXTENSIONNAME		"$ExtensionName"
#define szEXTENSIONFLAGS	"ExtensionFlags"
#define szEXTENSIONRAWVALUE	"ExtensionRawValue"

#define szCRLROWID		"RowId"
#define szCRLNUMBER		"Number"
#define szCRLMINBASE		"MinBase"
#define szCRLNAMEID		"NameId"
#define szCRLCOUNT		"Count"
#define szCRLTHISUPDATE		"ThisUpdate"
#define szCRLNEXTUPDATE		"NextUpdate"
#define szCRLTHISPUBLISH	"ThisPublish"
#define szCRLNEXTPUBLISH	"NextPublish"
#define szCRLEFFECTIVE		"Effective"
#define szCRLPROPAGATIONCOMPLETE "PropgationComplete"
#define szCRLLASTPUBLISHED	"CRLLastPublished"
#define szCRLPUBLISHATTEMPTS	"CRLPublishAttempts"
#define szCRLPUBLISHFLAGS	"CRLPublishFlags"
#define szCRLPUBLISHSTATUSCODE	"CRLPublishStatusCode"
#define szCRLPUBLISHERROR	"$CRLPublishError"
#define szCRLPUBLISHERROR_OLD	"CRLPublishError"
#define szRAWCRL		"RawCRL"

#define CSTI_PRIMARY		0
#define CSTI_CERTIFICATE	1
#define CSTI_ATTRIBUTE		2
#define CSTI_EXTENSION		3
#define CSTI_MAX		4
#define CSTI_MAXDIRECT		(CSTI_CERTIFICATE + 1)

typedef struct _CERTSESSIONTABLE
{
    JET_TABLEID		TableId;
    DWORD		TableFlags;
} CERTSESSIONTABLE;

typedef struct _CERTSESSION
{
    JET_SESID             SesId;
    JET_DBID              DBId;
    DWORD	          RowId;
    DWORD	          SesFlags;
    CERTSESSIONTABLE      aTable[CSTI_MAX];
    DWORD                 cTransact;
    ICertDBRow           *prow;
    IEnumCERTDBRESULTROW *pview;
    DWORD                 dwThreadId;
} CERTSESSION;


extern DBTABLE g_adtRequests[];
extern DBTABLE g_adtCertificates[];
extern DBTABLE g_adtRequestAttributes[];
//extern DBTABLE g_adtNameExtensions[];
extern DBTABLE g_adtCertExtensions[];
extern DBTABLE g_adtCRLs[];

extern DBAUXDATA g_dbauxRequests;
extern DBAUXDATA g_dbauxCertificates;
extern DBAUXDATA g_dbauxAttributes;
extern DBAUXDATA g_dbauxExtensions;
extern DBAUXDATA g_dbauxCRLs;

extern DBCREATETABLE const g_actDataBase[];

extern DUPTABLE const g_dntr[];

extern DWORD g_aColumnViewQueue[];
extern DWORD g_cColumnViewQueue;

extern DWORD g_aColumnViewLog[];
extern DWORD g_cColumnViewLog;

extern DWORD g_aColumnViewRevoked[];
extern DWORD g_cColumnViewRevoked;

extern DWORD g_aColumnViewExtension[];
extern DWORD g_cColumnViewExtension;

extern DWORD g_aColumnViewAttribute[];
extern DWORD g_cColumnViewAttribute;

extern DWORD g_aColumnViewCRL[];
extern DWORD g_cColumnViewCRL;

#endif // #ifndef __DBTABLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certdb\db.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        db.cpp
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "csprop.h"
#include "db.h"
#include "column.h"
#include "row.h"
#include "view.h"
#include "backup.h"
#include "restore.h"
#include "dbw.h"

#define __dwFILE__	__dwFILE_CERTDB_DB_CPP__


#define SEEKPOS_FIRST		0
#define SEEKPOS_LAST		1
#define SEEKPOS_INDEXFIRST	2
#define SEEKPOS_INDEXLAST	3

LONG g_cCertDB = 0;
LONG g_cCertDBTotal = 0;
LONG g_cXactCommit = 0;
LONG g_cXactAbort = 0;
LONG g_cXactTotal = 0;

char *g_pszDBFile = NULL;

typedef struct _DBJETPARM {
    DWORD paramid;
    DWORD lParam;
    char *pszParam;
    BOOL fString;
} DBJETPARM;


DBJETPARM g_aParm[] = {

#define JP_LOGPATH	0
    { JET_paramLogFilePath,        0,               NULL, TRUE },

#define JP_SYSTEMPATH	1
    { JET_paramSystemPath,         0,               NULL, TRUE },

#define JP_TEMPPATH	2
    { JET_paramTempPath,           0,               NULL, TRUE },

#define JP_EVENTSOURCE	3
    { JET_paramEventSource,        0,               NULL, TRUE },

#define JP_SESSIONMAX	4
    { JET_paramMaxSessions,        0,               NULL, FALSE },

#define JP_CACHESIZEMIN	5
    { JET_paramCacheSizeMin,	   64,		    NULL, FALSE },

#define JP_CACHESIZEMAX	6
    { JET_paramCacheSizeMax,	   512,		    NULL, FALSE },

#define JP_VERPAGESMAX	7	// 16k units: 64k per session
    { JET_paramMaxVerPages,	   4 * DBSESSIONCOUNTDEFAULT, NULL, FALSE },

    { JET_paramRecovery,           0,               "on", TRUE },
    { JET_paramMaxVerPages,        64,              NULL, FALSE },
    { JET_paramMaxTemporaryTables, 5,               NULL, FALSE },
    { JET_paramLogBuffers,         41,              NULL, FALSE },
    { JET_paramLogFileSize,        1024,            NULL, FALSE },
    { JET_paramAssertAction,       JET_AssertBreak, NULL, FALSE },
    { JET_paramBaseName,           0,               szDBBASENAMEPARM, TRUE } // "edb"
};
#define CDBPARM	(sizeof(g_aParm)/sizeof(g_aParm[0]))


VOID
DBFreeParms()
{
    if (NULL != g_aParm[JP_LOGPATH].pszParam)
    {
	LocalFree(g_aParm[JP_LOGPATH].pszParam);
	g_aParm[JP_LOGPATH].pszParam = NULL;
    }
    if (NULL != g_aParm[JP_SYSTEMPATH].pszParam)
    {
	LocalFree(g_aParm[JP_SYSTEMPATH].pszParam);
	g_aParm[JP_SYSTEMPATH].pszParam = NULL;
    }
    if (NULL != g_aParm[JP_TEMPPATH].pszParam)
    {
	LocalFree(g_aParm[JP_TEMPPATH].pszParam);
	g_aParm[JP_TEMPPATH].pszParam = NULL;
    }
    if (NULL != g_aParm[JP_EVENTSOURCE].pszParam)
    {
	LocalFree(g_aParm[JP_EVENTSOURCE].pszParam);
	g_aParm[JP_EVENTSOURCE].pszParam = NULL;
    }
}


HRESULT
DBInitParms(
    IN DWORD cSession,
    IN BOOL fCircularLogging,
    OPTIONAL IN WCHAR const *pwszEventSource,
    OPTIONAL IN WCHAR const *pwszLogDir,
    OPTIONAL IN WCHAR const *pwszSystemDir,
    OPTIONAL IN WCHAR const *pwszTempDir,
    OUT JET_INSTANCE *pInstance)
{
    HRESULT hr = E_OUTOFMEMORY;
    DBJETPARM const *pjp;
    WCHAR awc[MAX_PATH];
    DWORD dwPerfTweak = 0;    

    DBFreeParms();

    if (NULL != pwszLogDir)
    {
	wcscpy(awc, pwszLogDir);
	wcscat(awc, L"\\");
	if (!ConvertWszToSz(&g_aParm[JP_LOGPATH].pszParam, awc, -1))
	{
	    _JumpError(hr, error, "ConvertWszToSz(LogDir)");
	}
    }

    if (NULL != pwszSystemDir)
    {
	wcscpy(awc, pwszSystemDir);
	wcscat(awc, L"\\");
	if (!ConvertWszToSz(&g_aParm[JP_SYSTEMPATH].pszParam, awc, -1))
	{
	    _JumpError(hr, error, "ConvertWszToSz(SystemDir)");
	}
    }

    if (NULL != pwszTempDir)
    {
	wcscpy(awc, pwszTempDir);
	wcscat(awc, L"\\");
	if (!ConvertWszToSz(&g_aParm[JP_TEMPPATH].pszParam, awc, -1))
	{
	    _JumpError(hr, error, "ConvertWszToSz(TempDir)");
	}
    }

    if (NULL != pwszEventSource)
    {
	if (!ConvertWszToSz(
			&g_aParm[JP_EVENTSOURCE].pszParam,
			pwszEventSource,
			-1))
	{
	    _JumpError(hr, error, "ConvertWszToSz(EventSource)");
	}
    }

    g_aParm[JP_SESSIONMAX].lParam = cSession + 1;
    if (8 * cSession > g_aParm[JP_CACHESIZEMIN].lParam)
    {
	g_aParm[JP_CACHESIZEMIN].lParam = 8 * cSession;
    }
    if (8 * 8 * cSession > g_aParm[JP_CACHESIZEMAX].lParam)
    {
	g_aParm[JP_CACHESIZEMAX].lParam = 8 * 8 * cSession;
    }
    if (4 * cSession > g_aParm[JP_VERPAGESMAX].lParam)
    {
	g_aParm[JP_VERPAGESMAX].lParam = 4 * cSession;
    }
    for (pjp = g_aParm; pjp < &g_aParm[CDBPARM]; pjp++)
    {
	if (!pjp->fString || NULL != pjp->pszParam)
	{
	    _dbgJetSetSystemParameter(
				  pInstance,
				  0,
				  pjp->paramid,
				  pjp->lParam,
				  pjp->pszParam);
	}
    }

if (fCircularLogging)
{
    DBGPRINT((DBG_SS_CERTSRV, "Jet: circular logging enabled\n"));
    _dbgJetSetSystemParameter(
		  pInstance,
		  0,
		  JET_paramCircularLog,
		  TRUE,
		  NULL);
}


if (S_OK == myGetCertRegDWValue(NULL, NULL, NULL, L"PerfTweak", &dwPerfTweak))
{
if (dwPerfTweak & 0x1)
{
    _dbgJetSetSystemParameter(
		  pInstance,
		  0,
		  JET_paramLogBuffers,	
		  480,   // should be logfilesize (1024k) - 64k, specified in 512b units
		  NULL);
}

if (dwPerfTweak & 0x2)
{
    _dbgJetSetSystemParameter(
		  pInstance,
		  0,
		  JET_paramCommitDefault,	
		  JET_bitCommitLazyFlush,
		  NULL);
}

if (dwPerfTweak & 0x4)
{
    // real fix is not to set this at all, but setting it to a large number should suffice
    _dbgJetSetSystemParameter(
		  pInstance,
		  0,
		  JET_paramCacheSizeMax,	
		  512*100,	// 100x the size we usually run with
		  NULL);
}

if (dwPerfTweak & 0x8)
{
    _dbgJetSetSystemParameter(
		  pInstance,
		  0,
		  JET_paramCheckpointDepthMax,	
		  60 * 1024 * 1024,	// 60MB -- triple the size we usually run with (20MB)
		  NULL);
}


if (dwPerfTweak & 0x10)
{
    _dbgJetSetSystemParameter(
		  pInstance,
		  0,
		  JET_paramLogFileSize,	
		  16384,	// 16x the size we usually run with (1MB)
		  NULL);
}

if (dwPerfTweak & 0x20)
{
    _dbgJetSetSystemParameter(
		  pInstance,
		  0,
		  JET_paramLogBuffers,	
		  256,	// usually run with 41
		  NULL);
}
}

    hr = S_OK;

error:
    return(hr);
}





#if DBG_CERTSRV

WCHAR const *
wszCSFFlags(
    IN LONG Flags)
{
    static WCHAR s_awc[256];

    wsprintf(s_awc, L"{%x", Flags);

    if (CSF_INUSE & Flags)                 dbgcat(s_awc, L"InUse");
    if (CSF_READONLY & Flags)              dbgcat(s_awc, L"ReadOnly");
    if (CSF_CREATE & Flags)                dbgcat(s_awc, L"Create");
    if (CSF_VIEW & Flags)                  dbgcat(s_awc, L"View");
    if (CSF_VIEWRESET & Flags)             dbgcat(s_awc, L"ViewReset");

    wcscat(s_awc, L"}");
    CSASSERT(wcslen(s_awc) < ARRAYSIZE(s_awc));
    return(s_awc);
}


WCHAR const *
wszCSTFlags(
    IN LONG Flags)
{
    static WCHAR s_awc[256];

    wsprintf(s_awc, L"{%x", Flags);

    if (CST_SEEKINDEXRANGE & Flags)        dbgcat(s_awc, L"IndexRange");
    if (CST_SEEKNOTMOVE & Flags)           dbgcat(s_awc, L"SeekNotMove");
    if (CST_SEEKUSECURRENT & Flags)        dbgcat(s_awc, L"UseCurrent");
    if (0 == (CST_SEEKUSECURRENT & Flags)) dbgcat(s_awc, L"SkipCurrent");
    if (CST_SEEKASCEND & Flags)            dbgcat(s_awc, L"Ascend");
    if (0 == (CST_SEEKASCEND & Flags))     dbgcat(s_awc, L"Descend");

    wcscat(s_awc, L"}");
    CSASSERT(wcslen(s_awc) < ARRAYSIZE(s_awc));
    return(s_awc);
}


WCHAR const *
wszTable(
    IN DWORD dwTable)
{
    WCHAR const *pwsz;

    switch (dwTable)
    {
	case TABLE_REQUESTS:
	    pwsz = wszREQUESTTABLE;
	    break;

	case TABLE_CERTIFICATES:
	    pwsz = wszCERTIFICATETABLE;
	    break;

	case TABLE_ATTRIBUTES:
	    pwsz = wszREQUESTATTRIBUTETABLE;
	    break;

	case TABLE_EXTENSIONS:
	    pwsz = wszCERTIFICATEEXTENSIONTABLE;
	    break;

	case TABLE_CRLS:
	    pwsz = wszCRLTABLE;
	    break;

	default:
	    pwsz = L"???";
	    break;
    }
    return(pwsz);
}


WCHAR const *
wszSeekOperator(
    IN LONG SeekOperator)
{
    WCHAR const *pwsz;
    static WCHAR s_wszBuf[20];

    switch (CVR_SEEK_MASK & SeekOperator)
    {
	case CVR_SEEK_NONE: pwsz = L"None"; break;
	case CVR_SEEK_EQ:   pwsz = L"==";   break;
	case CVR_SEEK_LT:   pwsz = L"<";    break;
	case CVR_SEEK_LE:   pwsz = L"<=";   break;
	case CVR_SEEK_GE:   pwsz = L">=";   break;
	case CVR_SEEK_GT:   pwsz = L">";    break;
	default:
	    wsprintf(s_wszBuf, L"???=%x", SeekOperator);
	    pwsz = s_wszBuf;
	    break;
    }
    if (s_wszBuf != pwsz && (CVR_SEEK_NODELTA & SeekOperator))
    {
	wcscpy(s_wszBuf, pwsz);
	wcscat(s_wszBuf, L",NoDelta");
	pwsz = s_wszBuf;
    }

    return(pwsz);
}


WCHAR const *
wszSortOperator(
    IN LONG SortOrder)
{
    WCHAR const *pwsz;
    static WCHAR s_wszBuf[20];

    switch (SortOrder)
    {
	case CVR_SORT_NONE:    pwsz = L"None";    break;
	case CVR_SORT_ASCEND:  pwsz = L"Ascend";  break;
	case CVR_SORT_DESCEND: pwsz = L"Descend"; break;
	default:
	    wsprintf(s_wszBuf, L"???=%x", SortOrder);
	    pwsz = s_wszBuf;
	    break;
    }
    return(pwsz);
}


VOID
dbDumpFileTime(
    IN DWORD dwSubSystemId,
    IN CHAR const *pszPrefix,
    IN FILETIME const *pft)
{
    HRESULT hr;
    WCHAR *pwsz;

    hr = myGMTFileTimeToWszLocalTime(pft, TRUE, &pwsz);
    if (S_OK == hr)
    {
	DBGPRINT((dwSubSystemId, "%hs%ws\n", pszPrefix, pwsz));
	LocalFree(pwsz);
    }
}


VOID
dbDumpValue(
    IN DWORD dwSubSystemId,
    OPTIONAL IN DBTABLE const *pdt,
    IN BYTE const *pbValue,
    IN DWORD cbValue)
{
    if (NULL != pdt && NULL != pbValue && ISTEXTCOLTYP(pdt->dbcoltyp))
    {
	cbValue += sizeof(WCHAR);
    }
    if (JET_coltypDateTime == pdt->dbcoltyp && sizeof(FILETIME) == cbValue)
    {
	dbDumpFileTime(dwSubSystemId, "", (FILETIME const *) pbValue);
    }
    DBGDUMPHEX((dwSubSystemId, DH_NOADDRESS, pbValue, cbValue));
}


VOID
CCertDB::DumpRestriction(
    IN DWORD dwSubSystemId,
    IN LONG i,
    IN CERTVIEWRESTRICTION const *pcvr)
{
    HRESULT hr;
    WCHAR wszColumn[20];
    DBTABLE const *pdt;
    WCHAR const *pwszTable = L"???";
    WCHAR const *pwszCol;

    hr = _MapPropIdIndex(pcvr->ColumnIndex, &pdt, NULL);
    if (S_OK != hr)
    {
	_PrintError(hr, "_MapPropIdIndex");
	wsprintf(wszColumn, L"???=%x", pcvr->ColumnIndex);
	pdt = NULL;
	pwszCol = wszColumn;
    }
    else
    {
	pwszCol = pdt->pwszPropName;
	pwszTable = wszTable(pdt->dwTable);
    }


    DBGPRINT((
	dwSubSystemId,
	"Restriction[%d]: Col=%ws.%ws\n"
	    "        Seek='%ws' Sort=%ws cb=%x, pb=%x\n",
	i,
	pwszTable,
	pwszCol,
	wszSeekOperator(pcvr->SeekOperator),
	wszSortOperator(pcvr->SortOrder),
	pcvr->cbValue,
	pcvr->pbValue));
    dbDumpValue(dwSubSystemId, pdt, pcvr->pbValue, pcvr->cbValue);
}


VOID
dbDumpColumn(
    IN DWORD dwSubSystemId,
    IN DBTABLE const *pdt,
    IN BYTE const *pbValue,
    IN DWORD cbValue)
{
    DBGPRINT((dwSubSystemId, "Column: cb=%x pb=%x\n", cbValue, pbValue));
    dbDumpValue(dwSubSystemId, pdt, pbValue, cbValue);
}


DBAUXDATA const *
dbGetAuxTable(
    IN CERTSESSION *pcs,
    IN JET_TABLEID  tableid)
{
    DBAUXDATA const *pdbaux;

    CSASSERT(IsValidJetTableId(tableid));
    if (tableid == pcs->aTable[CSTI_CERTIFICATE].TableId)
    {
	pdbaux = &g_dbauxCertificates;
    }
    else if (tableid == pcs->aTable[CSTI_ATTRIBUTE].TableId)
    {
	pdbaux = &g_dbauxAttributes;
    }
    else if (tableid == pcs->aTable[CSTI_EXTENSION].TableId)
    {
	pdbaux = &g_dbauxExtensions;
    }
    else
    {
	CSASSERT(tableid == pcs->aTable[CSTI_PRIMARY].TableId);

	pdbaux = &g_dbauxRequests;
	switch (CSF_TABLEMASK & pcs->SesFlags)
	{
	    case TABLE_CERTIFICATES:
		pdbaux = &g_dbauxCertificates;
		break;

	    case TABLE_ATTRIBUTES:
		pdbaux = &g_dbauxAttributes;
		break;

	    case TABLE_EXTENSIONS:
		pdbaux = &g_dbauxExtensions;
		break;

	    case TABLE_CRLS:
		pdbaux = &g_dbauxCRLs;
		break;
	}
    }
    return(pdbaux);
}


HRESULT
CCertDB::_DumpRowId(
    IN CHAR const  *psz,
    IN CERTSESSION *pcs,
    IN JET_TABLEID  tableid)
{
    HRESULT hr;

#define DBG_SS_DUMPREQUESTID	DBG_SS_CERTDBI

    CSASSERT(IsValidJetTableId(tableid));
    if (DbgIsSSActive(DBG_SS_DUMPREQUESTID))
    {
	DWORD cb;
	DWORD dwTmp;
	DBAUXDATA const *pdbaux = dbGetAuxTable(pcs, tableid);
	WCHAR awchr[cwcHRESULTSTRING];

	cb = sizeof(dwTmp);
	hr = _RetrieveColumn(
			pcs,
			tableid,
			pdbaux->pdtRowId->dbcolumnid,
			pdbaux->pdtRowId->dbcoltyp,
			&cb,
			(BYTE *) &dwTmp);
	if (S_OK != hr)
	{
	    DBGPRINT((
		    DBG_SS_DUMPREQUESTID,
		    "%hs: %hs.RowId: pcs=%d: %ws\n",
		    psz,
		    pdbaux->pszTable,
		    pcs->RowId,
		    myHResultToString(awchr, hr)));
	    _JumpError2(hr, error, "_RetrieveColumn", hr);
	}

	DBGPRINT((
		DBG_SS_DUMPREQUESTID,
		"%hs: %hs.RowId: pcs=%d dbcol=%d\n",
		psz,
		pdbaux->pszTable,
		pcs->RowId,
		dwTmp));
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CCertDB::_DumpColumn(
    IN CHAR const    *psz,
    IN CERTSESSION   *pcs,
    IN JET_TABLEID    tableid,
    IN DBTABLE const *pdt)
{
    HRESULT hr;

    CSASSERT(IsValidJetTableId(tableid));
    CSASSERT(0 != pdt->dbcolumnid);
    if (DbgIsSSActive(DBG_SS_CERTDBI))
    {
	DWORD cb;
	BYTE ab[64 * 1024];
	DBAUXDATA const *pdbaux = dbGetAuxTable(pcs, tableid);
	BOOL fIsText;

	cb = sizeof(ab);
	hr = _RetrieveColumn(
			pcs,
			tableid,
			pdt->dbcolumnid,
			pdt->dbcoltyp,
			&cb,
			ab);
	_JumpIfError(hr, error, "_RetrieveColumn");

	fIsText = ISTEXTCOLTYP(pdt->dbcoltyp);

	DBGPRINT((
		DBG_SS_CERTDBI,
		"%hs: _DumpColumn(%hs, %hs): Value:%hs%ws%hs\n",
		psz,
		pdbaux->pszTable,
		pdt->pszFieldName,
		fIsText? " '" : "",
		fIsText? (WCHAR *) ab : L"",
		fIsText? "'" : ""));
	dbDumpValue(DBG_SS_CERTDBI, pdt, ab, cb);
    }
    hr = S_OK;

error:
    return(hr);
}
#endif // DBG_CERTSRV



CCertDB::CCertDB()
{
    HRESULT hr;
    
    InterlockedIncrement(&g_cCertDB);
    InterlockedIncrement(&g_cCertDBTotal);
    m_Instance = 0;
    m_fDBOpen = FALSE;
    m_fDBRestart = FALSE;
    m_fPendingShutDown = FALSE;
    m_fFoundOldColumns = FALSE;
    m_fAddedNewColumns = FALSE;
    m_aSession = NULL;
    m_cSession = 0;
    m_cbPage = 0;
    m_cCritSec = 0;
    __try
    {
	InitializeCriticalSection(&m_critsecSession);
	m_cCritSec++;
	InitializeCriticalSection(&m_critsecAutoIncTables);
	m_cCritSec++;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
}


CCertDB::~CCertDB()
{
    ShutDown(0);
    if (0 < m_cCritSec)
    {
	DeleteCriticalSection(&m_critsecSession);
	if (1 < m_cCritSec)
	{
	    DeleteCriticalSection(&m_critsecAutoIncTables);
	}
    }
    InterlockedDecrement(&g_cCertDB);
}


STDMETHODIMP
CCertDB::Open(
    /* [in] */ DWORD Flags,
    /* [in] */ DWORD cSession,
    /* [in] */ WCHAR const *pwszEventSource,
    /* [in] */ WCHAR const *pwszDBFile,
    /* [in] */ WCHAR const *pwszLogDir,
    /* [in] */ WCHAR const *pwszSystemDir,
    /* [in] */ WCHAR const *pwszTempDir)
{
    HRESULT hr;
    DWORD i;
    DBCREATETABLE const *pct;
    JET_GRBIT grbit;
    DWORD CreateFlags;
    CERTSESSION *pcs = NULL;

    if (NULL == pwszDBFile ||
	NULL == pwszLogDir ||
	NULL == pwszSystemDir ||
	NULL == pwszTempDir)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    hr = InitGlobalWriterState();
//    _JumpIfError(hr, error, "InitGlobalWriterState");

    m_fDBOpen = FALSE;
    m_fDBRestart = FALSE;
    m_fDBReadOnly = (CDBOPEN_READONLY & Flags)? TRUE : FALSE;

    CSASSERT(NULL == m_aSession); // code assumes we do not have session
    m_cSession = 0;
    m_aSession = (CERTSESSION *) LocalAlloc(
					LMEM_FIXED | LMEM_ZEROINIT,
					cSession * sizeof(m_aSession[0]));
    hr = E_OUTOFMEMORY;
    if (NULL == m_aSession)
    {
	_JumpError(hr, error, "LocalAlloc(m_aSession)");
    }
    for (i = 0; i < cSession; i++)
    {
	m_aSession[i].SesId = -1;
	m_aSession[i].DBId = -1;
    }

    if (!ConvertWszToSz(&g_pszDBFile, pwszDBFile, -1))
    {
	_JumpError(hr, error, "ConvertWszToSz(DBFile)");
    }

    hr = DBInitParms(
		cSession,
                (CDBOPEN_CIRCULARLOGGING & Flags)? TRUE : FALSE,
		pwszEventSource,
		pwszLogDir,
		pwszSystemDir,
		pwszTempDir,
		&m_Instance);
    _JumpIfError(hr, error, "DBInitParms");

    hr = _dbgJetInit(&m_Instance);
    if ((HRESULT) JET_errLogFileSizeMismatchDatabasesConsistent == hr ||
	(HRESULT) JET_errLogFileSizeMismatch == hr)
    {
	_PrintError(hr, "JetInit(old log file size)");
	_dbgJetSetSystemParameter(
			    &m_Instance,
			    0,
			    JET_paramLogFileSize,
			    1000,
			    NULL);
	hr = _dbgJetInit(&m_Instance);
    }
    _JumpIfError(
	    hr,
	    error,
	    JET_errFileAccessDenied == hr?
		"JetInit(Server already running?)" :
		"JetInit(JetSetSystemParameter problem?)");

    for (i = 0; i < cSession; i++)
    {
	hr = _dbgJetBeginSession(m_Instance, &m_aSession[i].SesId, NULL, NULL);
	_JumpIfError(hr, error, "_dbgJetBeginSession");

	m_cSession++;

	if (0 == i)
	{
	    CreateFlags = 0;
	    grbit = m_fDBReadOnly?
		JET_bitDbReadOnly : JET_bitDbDeleteCorruptIndexes;

	    hr = _dbgJetAttachDatabase(
			        m_aSession[i].SesId,
			        g_pszDBFile,
				grbit);
	    if ((HRESULT) JET_errFileNotFound == hr &&
		(CDBOPEN_CREATEIFNEEDED & Flags))
	    {
		DBGPRINT((DBG_SS_CERTDB, "Creating Database\n"));
		CreateFlags |= CF_DATABASE;
	    }
	    else
	    if ((HRESULT) JET_wrnCorruptIndexDeleted == hr)
	    {
		// Rebuild deleted indexes over Unicode columns...

		DBGPRINT((DBG_SS_CERTDB, "Creating Database Indexes\n"));
		CreateFlags |= CF_MISSINGINDEXES;
	    }
	    else
	    if ((HRESULT) JET_wrnDatabaseAttached != hr)
	    {
		_JumpIfError(hr, error, "JetAttachDatabase");
	    }
	    if (m_fDBReadOnly)
	    {
		if (CreateFlags)
		{
		    hr = E_ACCESSDENIED;
		    _JumpError(hr, error, "ReadOnly");
		}
	    }
	    else
	    {
		CreateFlags |= CF_MISSINGTABLES | CF_MISSINGCOLUMNS;
		hr = _Create(CreateFlags, g_pszDBFile);
		_JumpIfError(hr, error, "_Create");
	    }
	}

	hr = _dbgJetOpenDatabase(
			  m_aSession[i].SesId,
			  g_pszDBFile,
			  NULL,
			  &m_aSession[i].DBId,
			  0);
	_JumpIfError(hr, error, "JetOpenDatabase");
    }

    hr = _AllocateSession(&pcs);
    _JumpIfError(hr, error, "_AllocateSession");

    for (pct = g_actDataBase; NULL != pct->pszTableName; pct++)
    {
	hr = _BuildColumnIds(pcs, pct->pszTableName, pct->pdt);
	_JumpIfError(hr, error, "_BuildColumnIds");
    }
    if (!m_fDBReadOnly)
    {
	for (pct = g_actDataBase; NULL != pct->pszTableName; pct++)
	{
	    hr = _ConvertOldColumnData(
				pcs,
				pct->pszTableName,
				pct->pdbaux,
				pct->pdt);
	    _JumpIfError(hr, error, "_ConvertOldColumnData");
	}
    }
    m_fDBOpen = TRUE;

error:
    if (NULL != pcs)
    {
	ReleaseSession(pcs);
    }
    hr = myJetHResult(hr);
    if (S_OK == hr && m_fDBRestart)
    {
	hr = S_FALSE;	// Restart required for DB changes to take effect.
	_PrintError(hr, "m_fDBRestart");
    }
    return(hr);
}


STDMETHODIMP
CCertDB::ShutDown(
    /* [in] */ DWORD dwFlags)
{
    HRESULT hr;
    DWORD i;

    if (CDBSHUTDOWN_PENDING == dwFlags)
    {
	m_fPendingShutDown = TRUE;
	goto error;
    }
    if (NULL != m_aSession)
    {
	DBGPRINT((DBG_SS_CERTDB, "Database shutdown...\n"));
	for (i = 0; i < m_cSession; i++)
	{
	    hr = _dbgJetEndSession(
				m_aSession[i].SesId,
				JET_bitForceSessionClosed);
	    _PrintIfError(hr, "JetEndSession");
	}

	hr = _dbgJetTerm2(m_Instance, JET_bitTermComplete);
	DBGPRINT((DBG_SS_CERTDB, "Database shutdown complete\n"));

	LocalFree(m_aSession);
	m_aSession = NULL;
    }
    if (NULL != g_pszDBFile)
    {
	LocalFree(g_pszDBFile);
	g_pszDBFile = NULL;
    }
    DBFreeParms();
    UnInitGlobalWriterState();

error:
    return(S_OK);
}


HRESULT
CCertDB::BeginTransaction(
    IN CERTSESSION *pcs,
    IN BOOL fPrepareUpdate)
{
    HRESULT hr;
    BOOL fTransacted = FALSE;
    DWORD i;

    if (NULL == pcs)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (0 != pcs->cTransact)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "Nested transaction");
    }
    CSASSERTTHREAD(pcs);
    hr = _dbgJetBeginTransaction(pcs->SesId);
    _JumpIfError(hr, error, "JetBeginTransaction");

    fTransacted = TRUE;

    if (fPrepareUpdate)
    {
        CSASSERTTHREAD(pcs);
	for (i = 0; i < CSTI_MAX; i++)
	{
	    if (IsValidJetTableId(pcs->aTable[i].TableId))
	    {
		hr = _dbgJetPrepareUpdate(
				    pcs->SesId,
				    pcs->aTable[i].TableId,
				    JET_prepReplace);
		_JumpIfError(hr, error, "JetPrepareUpdate");
	    }
	}
    }
    pcs->cTransact++;
    InterlockedIncrement(&g_cXactTotal);
    hr = S_OK;

error:
    if (S_OK != hr && fTransacted)
    {
	HRESULT hr2;

	CSASSERTTHREAD(pcs);
	hr2 = _Rollback(pcs);
	_PrintIfError(hr2, "_Rollback");
    }
    return(myJetHResult(hr));
}


HRESULT
CCertDB::CommitTransaction(
    IN CERTSESSION *pcs,
    IN BOOL fCommit)
{
    HRESULT hr;
    DWORD i;

    if (NULL == pcs)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    CSASSERT(0 != pcs->cTransact);

    if (fCommit)
    {
	if (0 == (CSF_DELETE & pcs->SesFlags))
	{
	    for (i = 0; i < CSTI_MAXDIRECT; i++)
	    {
		if (IsValidJetTableId(pcs->aTable[i].TableId))
		{
		    hr = _UpdateTable(pcs, pcs->aTable[i].TableId);
		    _JumpIfError(hr, error, "_UpdateTable");
		}
	    }
	}
	CSASSERTTHREAD(pcs);
	hr = _dbgJetCommitTransaction(pcs->SesId, 0);
	_JumpIfError(hr, error, "JetCommitTransaction");
    }
    else
    {
	hr = _Rollback(pcs);
	_JumpIfError(hr, error, "_Rollback");
    }
    pcs->cTransact--;
    if (fCommit)
    {
	InterlockedIncrement(&g_cXactCommit);
    }
    else
    {
	InterlockedIncrement(&g_cXactAbort);
    }

error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::_AllocateSession(
    OUT CERTSESSION **ppcs)
{
    HRESULT hr;
    DWORD i;
    BOOL fEnterCritSec = FALSE;

    CSASSERT(NULL != ppcs);

    *ppcs = NULL;

    if (0 == m_cCritSec)
    {
	hr = HRESULT_FROM_WIN32(ERROR_DLL_INIT_FAILED);
	_JumpError(hr, error, "InitializeCriticalSection failure");
    }
    EnterCriticalSection(&m_critsecSession);
    fEnterCritSec = TRUE;

    for (i = 0; 0 != m_aSession[i].SesFlags; i++)
    {
	if (i + 1 == m_cSession)
	{
	    hr = CERTSRV_E_NO_DB_SESSIONS;
	    _JumpIfError(hr, error, "no more sessions");
	}
    }
    *ppcs = &m_aSession[i];
    CSASSERT(0 == (*ppcs)->RowId);
    (*ppcs)->SesFlags = CSF_INUSE;
    (*ppcs)->dwThreadId = GetCurrentThreadId();
    ZeroMemory((*ppcs)->aTable, sizeof((*ppcs)->aTable));
    hr = S_OK;

error:
    if (fEnterCritSec)
    {
	LeaveCriticalSection(&m_critsecSession);
    }
    return(hr);
}


HRESULT
CCertDB::_OpenTableRow(
    IN CERTSESSION *pcs,
    IN DBAUXDATA const *pdbaux,
    OPTIONAL IN CERTVIEWRESTRICTION const *pcvr,
    OUT CERTSESSIONTABLE *pTable,
    OUT DWORD *pdwRowIdMismatch)
{
    HRESULT hr;
    DWORD dwRowId;
    DWORD cb;

    CSASSERT(NULL == pTable->TableId);
    CSASSERT(0 == pTable->TableFlags);
    *pdwRowIdMismatch = 0;

    if (CSF_CREATE & pcs->SesFlags)
    {
	CSASSERT(NULL == pcvr);
        CSASSERTTHREAD(pcs);
	hr = _dbgJetOpenTable(
			   pcs->SesId,
			   pcs->DBId,
			   pdbaux->pszTable,
			   NULL,
			   0,
			   0,
			   &pTable->TableId);
	_JumpIfError(hr, error, "JetOpenTable");
    }
    else
    {
	if (NULL == pcvr)
	{
	    hr = E_POINTER;
	    _JumpError(hr, error, "NULL parm");
	}
	hr = _OpenTable(pcs, pdbaux, pcvr, pTable);
	if (S_FALSE == hr)
	{
	    hr = CERTSRV_E_PROPERTY_EMPTY;
	}
	_JumpIfError2(hr, error, "_OpenTable", CERTSRV_E_PROPERTY_EMPTY);
    }

    if (!((CSF_READONLY | CSF_DELETE) & pcs->SesFlags))
    {
        CSASSERTTHREAD(pcs);
	hr = _dbgJetPrepareUpdate(
			    pcs->SesId,
			    pTable->TableId,
			    (CSF_CREATE & pcs->SesFlags)?
				JET_prepInsert : JET_prepReplace);
	_JumpIfError(hr, error, "JetPrepareUpdate");
    }

    // Requests table RequestId column is JET_bitColumnAutoincrement.
    // Certificates table RequestId column is manually initialized here.
    //
    // When creating a Certificates table row, the RequestId column must be
    // set from pcs->RowId, which must already have been set by first creating
    // the Requests table row.
    //
    // When opening an existing row in either table, just fetch the column.

    CSASSERTTHREAD(pcs);
    hr = _dbgJetRetrieveColumn(
			pcs->SesId,
			pTable->TableId,
			pdbaux->pdtRowId->dbcolumnid,
			&dwRowId,
			sizeof(dwRowId),
			&cb,
			JET_bitRetrieveCopy,
			NULL);
    if ((HRESULT) JET_wrnColumnNull == hr)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
    }
    _PrintIfError2(hr, "JetRetrieveColumn", CERTSRV_E_PROPERTY_EMPTY);
    if (S_OK != hr || 0 == dwRowId)
    {
	CSASSERT(CSF_CREATE & pcs->SesFlags);
	if (0 == (CSF_CREATE & pcs->SesFlags))
	{
	    if (S_OK == hr)
	    {
		hr = CERTSRV_E_PROPERTY_EMPTY;
	    }
	    _JumpError(hr, error, "JetRetrieveColumn");
	}
	dwRowId = pcs->RowId;
	hr = _dbgJetSetColumn(
			pcs->SesId,
			pTable->TableId,
			pdbaux->pdtRowId->dbcolumnid,
			&dwRowId,
			sizeof(dwRowId),
			0,
			NULL);
	_JumpIfError(hr, error, "JetSetColumn");
    }
    else if (0 == pcs->RowId)
    {
	pcs->RowId = dwRowId;
    }

    DBGPRINT((
	    DBG_SS_CERTDBI,
	    "_OpenTableRow:%hs %hs --> RowId=%d(dwRowId(RetrieveColumn)=%d)\n",
	    (CSF_CREATE & pcs->SesFlags)? " (Create)" : "",
	    pdbaux->pszTable,
	    pcs->RowId,
            dwRowId));
    CSASSERT(0 != pcs->RowId);
    if (pcs->RowId > dwRowId)
    {
	*pdwRowIdMismatch = dwRowId;
	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpError(hr, error, "Missing autoincrement RowId");
    }
    CSASSERT(pcs->RowId == dwRowId);

error:
    if (S_OK != hr)
    {
	if (IsValidJetTableId(pTable->TableId))
	{
	    HRESULT hr2;

            CSASSERTTHREAD(pcs);
	    hr2 = _dbgJetCloseTable(pcs->SesId, pTable->TableId);
	    _PrintIfError(hr2, "JetCloseTable");
	}
	ZeroMemory(pTable, sizeof(*pTable));
    }
    return(myJetHResult(hr));
}


HRESULT
CCertDB::OpenTables(
    IN CERTSESSION *pcs,
    OPTIONAL IN CERTVIEWRESTRICTION const *pcvr)
{
    HRESULT hr;
    BOOL fCertTableFirst = FALSE;
    BOOL fCertTableLast = FALSE;
    CERTVIEWRESTRICTION cvrRowId;
    CERTVIEWRESTRICTION const *pcvrPrimary;
    CERTVIEWRESTRICTION const *pcvrCertificates;
    BOOL fEnterCritSec = FALSE;
    DBAUXDATA const *pdbauxPrimary;

    if (NULL == pcs)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    pcvrPrimary = pcvr;
    pcvrCertificates = NULL;
    pdbauxPrimary = &g_dbauxRequests;
    if (TABLE_REQCERTS == (CSF_TABLEMASK & pcs->SesFlags))
    {
	fCertTableLast = TRUE;
	if (NULL != pcvr)
	{
	    cvrRowId.SeekOperator = CVR_SEEK_EQ;
	    cvrRowId.SortOrder = CVR_SORT_ASCEND;
	    cvrRowId.pbValue = (BYTE *) &pcs->RowId;
	    cvrRowId.cbValue = sizeof(pcs->RowId);

	    switch (DTI_TABLEMASK & pcvr->ColumnIndex)
	    {
		case DTI_REQUESTTABLE:
		    pcvrCertificates = &cvrRowId;
		    cvrRowId.ColumnIndex = DTI_CERTIFICATETABLE | DTC_REQUESTID;
		    break;

		case DTI_CERTIFICATETABLE:
		    fCertTableLast = FALSE;
		    fCertTableFirst = TRUE;
		    pcvrCertificates = pcvr;
		    pcvrPrimary = &cvrRowId;
		    cvrRowId.ColumnIndex = DTI_REQUESTTABLE | DTR_REQUESTID;
		    break;

		default:
		    hr = E_INVALIDARG;
		    _JumpError(hr, error, "ColumnIndex Table");
	    }
	}
    }
    else
    {
	switch (CSF_TABLEMASK & pcs->SesFlags)
	{
	    case TABLE_ATTRIBUTES:
		pdbauxPrimary = &g_dbauxAttributes;
		break;

	    case TABLE_EXTENSIONS:
		pdbauxPrimary = &g_dbauxExtensions;
		break;

	    case TABLE_CRLS:
		pdbauxPrimary = &g_dbauxCRLs;
		break;

	    default:
		hr = E_INVALIDARG;
		_JumpError(hr, error, "bad table");
	}
    }

    if (1 >= m_cCritSec)
    {
	hr = HRESULT_FROM_WIN32(ERROR_DLL_INIT_FAILED);
	_JumpError(hr, error, "InitializeCriticalSection failure");
    }

    EnterCriticalSection(&m_critsecAutoIncTables);
    fEnterCritSec = TRUE;

    __try
    {
	DWORD dwRowIdMismatch;

	if (fCertTableFirst)
	{
	    hr = _OpenTableRow(
			pcs,
			&g_dbauxCertificates,
			pcvrCertificates,
			&pcs->aTable[CSTI_CERTIFICATE],
			&dwRowIdMismatch);
	    _LeaveIfError2(hr, "_OpenTableRow", CERTSRV_E_PROPERTY_EMPTY);

	    CSASSERT(0 != pcs->RowId);
	    CSASSERT(IsValidJetTableId(pcs->aTable[CSTI_CERTIFICATE].TableId));
	    DBGPRINT((
		DBG_SS_CERTDBI,
		"OpenTables: %hs: %ws\n",
		g_dbauxCertificates.pszTable,
		wszCSTFlags(pcs->aTable[CSTI_CERTIFICATE].TableFlags)));
	}

	hr = _OpenTableRow(
		pcs,
		pdbauxPrimary,
		pcvrPrimary,
		&pcs->aTable[CSTI_PRIMARY],
		&dwRowIdMismatch);
	_LeaveIfError2(hr, "_OpenTableRow", CERTSRV_E_PROPERTY_EMPTY);

	CSASSERT(0 != pcs->RowId);
	CSASSERT(IsValidJetTableId(pcs->aTable[CSTI_PRIMARY].TableId));
	DBGPRINT((
	    DBG_SS_CERTDBI,
	    "OpenTables: %hs: %ws\n",
	    g_dbauxRequests.pszTable,
	    wszCSTFlags(pcs->aTable[CSTI_PRIMARY].TableFlags)));

	if (fCertTableLast)
	{
	    while (TRUE)
	    {
		hr = _OpenTableRow(
			    pcs,
			    &g_dbauxCertificates,
			    pcvrCertificates,
			    &pcs->aTable[CSTI_CERTIFICATE],
			    &dwRowIdMismatch);
		_PrintIfError(hr, "_OpenTableRow");
		if (S_OK == hr || 0 == dwRowIdMismatch)
		{
		    break;
		}
	    }
	    _PrintIfError(hr, "_OpenTableRow");
	    //_LeaveIfError(hr, "_OpenTableRow");
	    if (S_OK == hr)
	    {
		CSASSERT(IsValidJetTableId(pcs->aTable[CSTI_CERTIFICATE].TableId));
		DBGPRINT((
		    DBG_SS_CERTDBI,
		    "OpenTables: %hs: %ws\n",
		    g_dbauxCertificates.pszTable,
		    wszCSTFlags(pcs->aTable[CSTI_CERTIFICATE].TableFlags)));
	    }
	    hr = S_OK;
	}
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    if (S_OK != hr)
    {
        __try
        {
	    HRESULT hr2;
	    DWORD i;

	    for (i = 0; i < CSTI_MAX; i++)
	    {
		if (NULL != pcs)
		{
		    CSASSERTTHREAD(pcs);
		    if (IsValidJetTableId(pcs->aTable[i].TableId))
		    {
			hr2 = _dbgJetCloseTable(
					    pcs->SesId,
					    pcs->aTable[i].TableId);
			_PrintIfError(hr2, "JetCloseTable");
		    }
		}
		ZeroMemory(&pcs->aTable[i], sizeof(pcs->aTable[i]));
	    }
	}
        __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
        {
        }
    }
    if (fEnterCritSec)
    {
        LeaveCriticalSection(&m_critsecAutoIncTables);
    }
    return(myJetHResult(hr));
}


HRESULT
CCertDB::CloseTables(
    IN CERTSESSION *pcs)
{
    HRESULT hr = S_OK;
    HRESULT hr2;
    DWORD i;

    if (NULL == pcs)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    for (i = 0; i < CSTI_MAX; i++)
    {
	if (IsValidJetTableId(pcs->aTable[i].TableId))
	{
	    hr2 = CloseTable(pcs, pcs->aTable[i].TableId);
	    _PrintIfError(hr2, "CloseTable");
	    if (S_OK == hr)
	    {
		hr = hr2;
	    }
	}
    }

error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::Delete(
    IN CERTSESSION *pcs)
{
    HRESULT hr = S_OK;
    HRESULT hr2;
    DWORD i;

    if (NULL == pcs)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    for (i = 0; i < CSTI_MAXDIRECT; i++)
    {
	if (IsValidJetTableId(pcs->aTable[i].TableId))
	{
	    hr2 = _dbgJetDelete(pcs->SesId, pcs->aTable[i].TableId);
	    _PrintIfError(hr2, "JetDelete");
	    if (S_OK == hr)
	    {
		hr = hr2;
	    }
	}
    }

error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::_UpdateTable(
    IN CERTSESSION *pcs,
    IN JET_TABLEID tableid)
{
    HRESULT hr;

    CSASSERT(IsValidJetTableId(tableid));
    CSASSERTTHREAD(pcs);
    hr = _dbgJetUpdate(pcs->SesId, tableid, NULL, 0, NULL);
    _JumpIfError(hr, error, "JetUpdate");

error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::CloseTable(
    IN CERTSESSION *pcs,
    IN JET_TABLEID tableid)
{
    HRESULT hr;

    if (NULL == pcs)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }    
    CSASSERT(IsValidJetTableId(tableid));
    CSASSERTTHREAD(pcs);
    hr = _dbgJetCloseTable(pcs->SesId, tableid);
    _JumpIfError(hr, error, "JetCloseTable");

error:
    return(myJetHResult(hr));
}


STDMETHODIMP
CCertDB::OpenRow(
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD RowId,
    /* [in] */ WCHAR const *pwszSerialNumberOrCertHash,	// OPTIONAL
    /* [out] */ ICertDBRow **pprow)
{
    HRESULT hr;
    ICertDBRow *prow = NULL;
    DWORD SesFlags = 0;
    BOOL fCreate;
    DWORD i;
    CERTSESSION *pcs = NULL;
    CERTVIEWRESTRICTION cvr;
    CERTVIEWRESTRICTION *pcvr;

    if (NULL == pprow)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *pprow = NULL;

    switch (PROPTABLE_MASK & dwFlags)
    {
	case PROPTABLE_REQCERT:
	    SesFlags |= TABLE_REQCERTS;
	    cvr.ColumnIndex = DTI_REQUESTTABLE | DTC_REQUESTID;
	    break;

	case PROPTABLE_ATTRIBUTE:
	    SesFlags |= TABLE_ATTRIBUTES;
	    cvr.ColumnIndex = DTI_ATTRIBUTETABLE | DTA_REQUESTID;
	    break;

	case PROPTABLE_EXTENSION:
	    SesFlags |= TABLE_EXTENSIONS;
	    cvr.ColumnIndex = DTI_EXTENSIONTABLE | DTE_REQUESTID;
	    break;

	case PROPTABLE_CRL:
	    SesFlags |= TABLE_CRLS;
	    cvr.ColumnIndex = DTI_CRLTABLE | DTL_ROWID;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "bad table");
    }
    if ((PROPOPEN_CERTHASH & dwFlags) && NULL == pwszSerialNumberOrCertHash)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad PROPOPEN_CERTHASH");
    }
    if (PROPTABLE_REQCERT != (PROPTABLE_MASK & dwFlags) &&
	NULL != pwszSerialNumberOrCertHash)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad pwszSerialNumberOrCertHash");
    }
    if ((PROPOPEN_READONLY | PROPOPEN_DELETE) ==
	((PROPOPEN_READONLY | PROPOPEN_DELETE) & dwFlags))
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "delete + read-only");
    }

    if (0 == RowId && NULL == pwszSerialNumberOrCertHash)
    {
	if ((PROPOPEN_READONLY | PROPOPEN_DELETE) & dwFlags)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "OpenRow: create vs. delete or read-only");
	}
	SesFlags |= CSF_CREATE;
	pcvr = NULL;
    }
    else
    {
	cvr.SeekOperator = CVR_SEEK_EQ;
	cvr.SortOrder = CVR_SORT_ASCEND;
	if (NULL != pwszSerialNumberOrCertHash)
	{
	    cvr.ColumnIndex = (PROPOPEN_CERTHASH & dwFlags)?
		(DTI_CERTIFICATETABLE | DTC_CERTIFICATEHASH) :
		(DTI_CERTIFICATETABLE | DTC_CERTIFICATESERIALNUMBER);

	    cvr.cbValue = wcslen(pwszSerialNumberOrCertHash) * sizeof(WCHAR);
	    cvr.pbValue = (BYTE *) pwszSerialNumberOrCertHash;
	}
	else
	{
	    cvr.cbValue = sizeof(RowId);
	    cvr.pbValue = (BYTE *) &RowId;
	}
	pcvr = &cvr;
    }

    if (PROPOPEN_READONLY & dwFlags)
    {
	SesFlags |= CSF_READONLY;
    }
    else
    {
	if (PROPOPEN_DELETE & dwFlags)
	{
	    SesFlags |= CSF_DELETE;
	}
	if (m_fDBReadOnly)
	{
	    hr = E_ACCESSDENIED;
	    _JumpError(hr, error, "OpenRow: read-only DB");
	}
    }

    prow = new CCertDBRow;
    if (NULL == prow)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "new CCertDBRow");
    }

    hr = _AllocateSession(&pcs);
    _JumpIfError(hr, error, "_AllocateSession");

    pcs->RowId = RowId;
    pcs->SesFlags |= SesFlags;
    pcs->prow = prow;

    hr = ((CCertDBRow *) prow)->Open(pcs, this, pcvr);
    _JumpIfError2(hr, error, "Open", CERTSRV_E_PROPERTY_EMPTY);

    *pprow = prow;
    prow = NULL;
    pcs = NULL;

error:
    if (NULL != prow)
    {
	prow->Release();
    }
    if (NULL != pcs)
    {
	ReleaseSession(pcs);
    }
    return(hr);
}


STDMETHODIMP
CCertDB::OpenView(
    /* [in] */  DWORD ccvr,
    /* [in] */  CERTVIEWRESTRICTION const *acvr,
    /* [in] */  DWORD ccolOut,
    /* [in] */  DWORD const *acolOut,
    /* [in] */  DWORD const dwFlags,
    /* [out] */ IEnumCERTDBRESULTROW **ppenum)
{
    HRESULT hr;
    IEnumCERTDBRESULTROW *penum = NULL;
    BOOL fCreate;
    CERTSESSION *pcs;

    if ((NULL == acvr && 0 != ccvr) || NULL == acolOut || NULL == ppenum)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppenum = NULL;

    penum = new CEnumCERTDBRESULTROW(0 != (CDBOPENVIEW_WORKERTHREAD & dwFlags));
    if (NULL == penum)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "new CEnumCERTDBRESULTROW");
    }

    hr = _AllocateSession(&pcs);
    _JumpIfError(hr, error, "_AllocateSession");

    pcs->SesFlags |= CSF_READONLY | CSF_VIEW;
    pcs->pview = penum;

    hr = ((CEnumCERTDBRESULTROW *) penum)->Open(
					pcs,
					this,
					ccvr,
					acvr,
					ccolOut,
					acolOut);
    _JumpIfError(hr, error, "Open");

    *ppenum = penum;
    penum = NULL;

error:
    if (NULL != penum)
    {
	penum->Release();
    }
    return(hr);
}


HRESULT
CCertDB::OpenBackup(
    /* [in] */  LONG grbitJet,
    /* [out] */ ICertDBBackup **ppBackup)
{
    HRESULT hr;
    ICertDBBackup *pBackup = NULL;
    CERTSESSION *pcs = NULL;

    if (NULL == ppBackup)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppBackup = NULL;

    pBackup = new CCertDBBackup;
    if (NULL == pBackup)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "new CCertDBBackup");
    }

    hr = _AllocateSession(&pcs);
    _JumpIfError(hr, error, "_AllocateSession");

    hr = ((CCertDBBackup *) pBackup)->Open(grbitJet, pcs, this);
    _JumpIfError(hr, error, "Open");

    *ppBackup = pBackup;
    pBackup = NULL;
    pcs = NULL;
    hr = S_OK;

error:
    if (NULL != pBackup)
    {
	pBackup->Release();
    }
    if (NULL != pcs)
    {
	ReleaseSession(pcs);
    }
    return(hr);
}


HRESULT
CCertDB::ReleaseSession(
    IN CERTSESSION *pcs)
{
    HRESULT hr = S_OK;
    HRESULT hr2;

    if (NULL == pcs)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    CSASSERT(CSF_INUSE & pcs->SesFlags);
    while (0 != pcs->cTransact)
    {
        CSASSERTTHREAD(pcs);
	hr2 = _dbgJetRollback(pcs->SesId, 0);
	if (S_OK == hr)
	{
	    hr = hr2;
	}
	_JumpIfError(hr2, loop, "JetRollback");

	DBGPRINT((
	    (CSF_READONLY & pcs->SesFlags)? DBG_SS_CERTDBI : DBG_SS_CERTDB,
	    "ReleaseSession: Rollback transaction: %x\n",
	    pcs->cTransact));
loop:
	CSASSERT(0 == pcs->cTransact);
	pcs->cTransact--;
	InterlockedIncrement(&g_cXactAbort);
    }
    //EnterCriticalSection(&m_critsecSession);
    pcs->RowId = 0;
    pcs->prow = NULL;
    pcs->SesFlags = 0;		// turn off CSF_INUSE -- must be LAST!
    //LeaveCriticalSection(&m_critsecSession);

error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::_Rollback(
    IN CERTSESSION *pcs)
{
    HRESULT hr = S_OK;
    DWORD i;

    if (NULL == pcs)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    CSASSERT(CSF_INUSE & pcs->SesFlags);

    for (i = 0; i < CSTI_MAX; i++)
    {
	pcs->aTable[i].TableId = 0;
    }

    CSASSERTTHREAD(pcs);
    hr = _dbgJetRollback(pcs->SesId, 0);
    _JumpIfError(hr, error, "JetRollback");

error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::BackupBegin(
    IN LONG grbitJet)
{
    HRESULT hr;

    hr = _dbgJetBeginExternalBackup(grbitJet);
    _JumpIfError(hr, error, "JetBeginExternalBackup");

error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::_BackupGetFileList(
    IN     BOOL   fDBFiles,
    IN OUT DWORD *pcwcList,
    OUT    WCHAR *pwszzList)		// OPTIONAL
{
    HRESULT hr;
    CHAR buf[12];
    CHAR *pszz = buf;
    DWORD cbbuf = ARRAYSIZE(buf);
    DWORD cbActual;
    WCHAR *pwszz = NULL;
    DWORD cwc;
    WCHAR *pwsz;
    DWORD cwcActual;

    while (TRUE)
    {
	if (fDBFiles)
	{
	    hr = _dbgJetGetAttachInfo(pszz, cbbuf, &cbActual);
	    _JumpIfError(hr, error, "JetGetAttachInfo");
	}
	else
	{
	    hr = _dbgJetGetLogInfo(pszz, cbbuf, &cbActual);
	    _JumpIfError(hr, error, "JetGetLogInfo");
	}
	if (cbbuf >= cbActual)
	{
	    break;
	}
	CSASSERT(buf == pszz);
	pszz = (CHAR *) LocalAlloc(LMEM_FIXED, cbActual);
	if (NULL == pszz)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	cbbuf = cbActual;
    }
    if (!ConvertSzToWsz(&pwszz, pszz, cbActual))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertSzToWsz");
    }

    pwsz = pwszz;
    do
    {
	cwc = wcslen(pwsz);
	pwsz += cwc + 1;
    } while (0 != cwc);
    cwc = SAFE_SUBTRACT_POINTERS(pwsz, pwszz);	// includes double trailing L'\0's
    if (NULL != pwszzList)
    {
	CopyMemory(pwszzList, pwszz, min(cwc, *pcwcList) * sizeof(WCHAR));
	if (cwc > *pcwcList)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	}
    }
    *pcwcList = cwc;
    _JumpIfError(hr, error, "Buffer Overflow");

error:
    if (NULL != pszz && buf != pszz)
    {
	LocalFree(pszz);
    }
    if (NULL != pwszz)
    {
	LocalFree(pwszz);
    }
    return(myJetHResult(hr));
}


HRESULT
CCertDB::BackupGetDBFileList(
    IN OUT DWORD *pcwcList,
    OUT    WCHAR *pwszzList)		// OPTIONAL
{
    HRESULT hr;

    hr = _BackupGetFileList(TRUE, pcwcList, pwszzList);
    _JumpIfError(hr, error, "_BackupGetFileList");

error:
    return(hr);
}


HRESULT
CCertDB::BackupGetLogFileList(
    IN OUT DWORD *pcwcList,
    OUT    WCHAR *pwszzList)		// OPTIONAL
{
    HRESULT hr;

    hr = _BackupGetFileList(FALSE, pcwcList, pwszzList);
    _JumpIfError(hr, error, "_BackupGetFileList");

error:
    return(hr);
}


HRESULT
CCertDB::BackupOpenFile(
    IN WCHAR const *pwszFile,
    OUT JET_HANDLE *phFileDB,
    OPTIONAL OUT ULARGE_INTEGER *pliSize)
{
    HRESULT hr;
    CHAR *pszFile = NULL;

    if (!ConvertWszToSz(&pszFile, pwszFile, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToSz(pwszFile)");
    }
    hr = _dbgJetOpenFile(
		    pszFile,
		    phFileDB,
		    &pliSize->LowPart,
		    &pliSize->HighPart);
    _JumpIfErrorStr(hr, error, "JetOpenFile", pwszFile);

error:
    if (NULL != pszFile)
    {
	LocalFree(pszFile);
    }
    return(myJetHResult(hr));
}


HRESULT
CCertDB::BackupReadFile(
    IN  JET_HANDLE hFileDB,
    OUT BYTE *pb,
    IN  DWORD cb,
    OUT DWORD *pcb)
{
    HRESULT hr;
    BYTE *pbAlloc = NULL;
    BYTE *pbRead;

    if (0 == m_cbPage)
    {
	SYSTEM_INFO si;

	GetSystemInfo(&si);
	m_cbPage = si.dwPageSize;
    }
    if ((m_cbPage - 1) & cb)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad read size");
	
    }
    pbRead = pb;

    // If the caller's buffer is not page aligned, allocate an aligned buffer
    // and copy the data.

    if ((m_cbPage - 1) & (DWORD_PTR) pb)
    {
	pbAlloc = (BYTE *) VirtualAlloc(NULL, cb, MEM_COMMIT, PAGE_READWRITE);
	if (NULL == pbAlloc)
	{
	    hr = myHLastError();
	    _JumpIfError(hr, error, "VirtualAlloc");
	}
	pbRead = pbAlloc;
    }

    hr = _dbgJetReadFile(hFileDB, pbRead, cb, pcb);
    _JumpIfError(hr, error, "JetReadFile");

    if (NULL != pbAlloc)
    {
	CopyMemory(pb, pbAlloc, *pcb);
    }

error:
    if (NULL != pbAlloc)
    {
	VirtualFree(pbAlloc, 0, MEM_RELEASE);
    }
    return(myJetHResult(hr));
}


HRESULT
CCertDB::BackupCloseFile(
    IN JET_HANDLE hFileDB)
{
    HRESULT hr;

    hr = _dbgJetCloseFile(hFileDB);
    _JumpIfError(hr, error, "JetCloseFile");

error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::BackupTruncateLog()
{
    HRESULT hr;

    hr = _dbgJetTruncateLog();
    _JumpIfError(hr, error, "JetTruncateLog");

error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::BackupEnd()
{
    HRESULT hr;

    hr = _dbgJetEndExternalBackup();
    _JumpIfError(hr, error, "JetEndExternalBackup");

error:
    return(myJetHResult(hr));
}


DBTABLE const *
CCertDB::_MapTable(
    IN WCHAR const *pwszPropName,
    IN DBTABLE const *pdt)
{
    while (NULL != pdt->pwszPropName)
    {
        if (0 == (DBTF_MISSING & pdt->dwFlags) &&
	    (0 == lstrcmpi(pwszPropName, pdt->pwszPropName) ||
             (NULL != pdt->pwszPropNameObjId &&
	      0 == lstrcmpi(pwszPropName, pdt->pwszPropNameObjId))))
	{
	    return(pdt);
	}
	pdt++;
    }
    return(NULL);
}


HRESULT
CCertDB::_MapPropIdIndex(
    IN DWORD ColumnIndex,
    OUT DBTABLE const **ppdt,
    OPTIONAL OUT DWORD *pType)
{
    HRESULT hr;
    DBTABLE const *pdt = NULL;
    DWORD iCol = DTI_COLUMNMASK & ColumnIndex;

    switch (DTI_TABLEMASK & ColumnIndex)
    {
	case DTI_REQUESTTABLE:
	    if (DTR_MAX > iCol)
	    {
		pdt = g_adtRequests;
	    }
	    break;

	case DTI_CERTIFICATETABLE:
	    if (DTC_MAX > iCol)
	    {
		pdt = g_adtCertificates;
	    }
	    break;

	case DTI_ATTRIBUTETABLE:
	    if (DTA_MAX > iCol)
	    {
		pdt = g_adtRequestAttributes;
	    }
	    break;

	case DTI_EXTENSIONTABLE:
	    if (DTE_MAX > iCol)
	    {
		pdt = g_adtCertExtensions;
	    }
	    break;

	case DTI_CRLTABLE:
	    if (DTL_MAX > iCol)
	    {
		pdt = g_adtCRLs;
	    }
	    break;
    }
    if (NULL == pdt)
    {
	hr = E_INVALIDARG;
	DBGPRINT((
	    DBG_SS_CERTDB,
	    "_MapPropIdIndex(%x) -> %x\n",
	    ColumnIndex,
	    hr));
	_JumpError(hr, error, "column index");
    }
    pdt += iCol;
    if (NULL != pType)
    {
	switch (pdt->dbcoltyp)
	{
	    case JET_coltypDateTime:
		*pType = PROPTYPE_DATE;
		break;

	    case JET_coltypLong:
		*pType = PROPTYPE_LONG;
		break;

	    case JET_coltypText:
	    case JET_coltypLongText:
		*pType = PROPTYPE_STRING;
		break;

	    case JET_coltypLongBinary:
	    default:
		*pType = PROPTYPE_BINARY;
		break;
	}
	if (NULL != pdt->pszIndexName &&
	    0 == (DBTF_INDEXREQUESTID & pdt->dwFlags))
	{
	    *pType |= PROPFLAGS_INDEXED;
	}
    }
    DBGPRINT((
	DBG_SS_CERTDBI,
	"_MapPropIdIndex(%x) -> %ws.%ws\n",
	ColumnIndex,
	wszTable(pdt->dwTable),
	pdt->pwszPropName));
    hr = S_OK;

error:
    *ppdt = pdt;
    return(hr);
}


HRESULT
CCertDB::MapPropId(
    IN WCHAR const *pwszPropName,
    IN DWORD dwFlags,
    OUT DBTABLE *pdtOut)
{
    DBTABLE const *pdt = NULL;
    WCHAR wszPrefix[2 * (sizeof(wszPROPSUBJECTDOT) / sizeof(WCHAR))];
    DWORD dwTable;
    HRESULT hr = S_OK;
    DBTABLE const *pdbTable;
    WCHAR const *pwszStart;
    BOOL fSubject = FALSE;
    BOOL fRequest = FALSE;

    if (NULL == pwszPropName || NULL == pdtOut)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    dwTable = PROPTABLE_MASK & dwFlags;
    CSASSERT(
	PROPTABLE_REQUEST == dwTable ||
	PROPTABLE_CERTIFICATE == dwTable ||
	PROPTABLE_CRL == dwTable);

    // Check to see if the request is for L"Subject.".

    pwszStart = pwszPropName;

    if (PROPTABLE_CRL != dwTable)
    {
	while (!fSubject)
	{
	    WCHAR const *pwsz;

	    pwsz = wcschr(pwszStart, L'.');

	    if (NULL == pwsz ||
		pwsz - pwszStart + 2 > sizeof(wszPrefix)/sizeof(WCHAR))
	    {
		pwsz = pwszStart;
		break;
	    }
	    pwsz++;		// skip past L'.'

	    CopyMemory(
		wszPrefix,
		pwszStart,
		(SAFE_SUBTRACT_POINTERS(pwsz, pwszStart) * sizeof(WCHAR)));
	    wszPrefix[pwsz - pwszStart] = L'\0';

	    if (!fSubject)
	    {
		pwszStart = pwsz;
		if (0 == lstrcmpi(wszPrefix, wszPROPSUBJECTDOT))
		{
		    fSubject = TRUE;
		    continue;
		}
		else
		if (!fRequest &&
		    PROPTABLE_REQUEST == dwTable &&
		    0 == lstrcmpi(wszPrefix, wszPROPREQUESTDOT))
		{
		    fRequest = TRUE;
		    continue;
		}
	    }
	    hr = E_INVALIDARG;
	    _JumpErrorStr(hr, error, "Invalid prefix", pwszPropName);
	}
    }

    pdbTable = NULL;

    // Search the requested table for a matching property name or property
    // objectid string.

    switch (dwTable)
    {
	case PROPTABLE_REQUEST:
	    pdbTable = g_adtRequests;
	    break;

	case PROPTABLE_CERTIFICATE:
	    pdbTable = g_adtCertificates;
	    break;

	case PROPTABLE_CRL:
	    pdbTable = g_adtCRLs;
	    break;
    }
    CSASSERT(NULL != pdbTable);

    pdt = _MapTable(pwszStart, pdbTable);
    if (NULL == pdt || (fSubject && 0 == (DBTF_SUBJECT & pdt->dwFlags)))
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpErrorStr(
		hr,
		error,
		PROPTABLE_REQUEST == dwTable?
		    "unknown Request property" :
		    PROPTABLE_CERTIFICATE == dwTable?
			"unknown Certificate property" :
			"unknown CRL property",
		pwszPropName);
    }
    *pdtOut = *pdt;	// structure copy
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CCertDB::TestShutDownState()
{
    HRESULT hr;
    
    if (m_fPendingShutDown)
    {
	hr = HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS);
	_JumpError(hr, error, "m_fPendingShutDown");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CCertDB::SetProperty(
    IN CERTSESSION *pcs,
    IN DBTABLE const *pdt,
    IN DWORD cbProp,
    IN BYTE const *pbProp)	// OPTIONAL
{
    HRESULT hr;
    JET_TABLEID tableid;

    if (NULL == pcs ||
	NULL == pdt ||
	(NULL == pbProp && !ISTEXTCOLTYP(pdt->dbcoltyp)))
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    DBGPRINT((
	DBG_SS_CERTDBI,
	"SetProperty for %hs into table %d\n",
	pdt->pszFieldName,
	pdt->dwTable));

    if (ISTEXTCOLTYP(pdt->dbcoltyp))
    {
    	DBGPRINT((DBG_SS_CERTDBI, "SetProperty setting string %ws\n", pbProp));
    }
    if (JET_coltypDateTime == pdt->dbcoltyp)
    {
	DBGPRINT((
	    DBG_SS_CERTDBI,
	    "SetProperty setting date: %x:%x\n",
	    ((DWORD *) pbProp)[0],
	    ((DWORD *) pbProp)[1]));
    }

    switch (pdt->dwTable)
    {
	case TABLE_CRLS:
	case TABLE_REQUESTS:
            tableid = pcs->aTable[CSTI_PRIMARY].TableId;
	    break;

	case TABLE_CERTIFICATES:
            tableid = pcs->aTable[CSTI_CERTIFICATE].TableId;
	    break;

        default:
	    hr = E_INVALIDARG;
            _JumpError(hr, error, "unknown table type");
    }
    CSASSERT(IsValidJetTableId(tableid));
    hr = _SetColumn(
		pcs->SesId,
		tableid,
		pdt->dbcolumnid,
		cbProp,
		pbProp);
    _JumpIfErrorStr(hr, error, "_SetColumn", pdt->pwszPropName);

error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::GetProperty(
    IN     CERTSESSION *pcs,
    IN     DBTABLE const *pdt,
    IN OUT DWORD *pcbProp,
    OUT    BYTE *pbProp)	// OPTIONAL
{
    HRESULT hr;
    JET_COLUMNDEF columndef;
    JET_TABLEID tableid;

    if (NULL == pcs || NULL == pdt || NULL == pcbProp)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    DBGPRINT((
	DBG_SS_CERTDBI,
	"GetProperty for %hs from table %d\n",
	pdt->pszFieldName,
	pdt->dwTable));

    if ((CSF_TABLEMASK & pcs->SesFlags) != pdt->dwTable)
    {
	if (TABLE_REQCERTS != (CSF_TABLEMASK & pcs->SesFlags) ||
	    (TABLE_REQUESTS != pdt->dwTable &&
	     TABLE_CERTIFICATES != pdt->dwTable))
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "mismatched table");
	}
    }
    if (TABLE_CERTIFICATES == pdt->dwTable)
    {
	tableid = pcs->aTable[CSTI_CERTIFICATE].TableId;
    }
    else
    {
	tableid = pcs->aTable[CSTI_PRIMARY].TableId;
    }
    CSASSERT(IsValidJetTableId(tableid));
    hr = _RetrieveColumn(
		     pcs,
		     tableid,
		     pdt->dbcolumnid,
		     pdt->dbcoltyp,
		     pcbProp,
		     pbProp);
    _JumpIfErrorStr3(
		hr,
		error,
		"_RetrieveColumn",
		pdt->pwszPropName,
		CERTSRV_E_PROPERTY_EMPTY,
		HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW));

    if (ISTEXTCOLTYP(pdt->dbcoltyp))
    {
        DBGPRINT((DBG_SS_CERTDBI, "GetProperty returning string %ws\n", pbProp));
    }

error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::CopyRequestNames(
    IN CERTSESSION *pcs)
{
    HRESULT hr = S_OK;
    DBTABLE dt;
    DWORD cbProp;
    BYTE *pbProp = NULL;
    DWORD i;

    BYTE rgbFastBuf[64];

    if (NULL == pcs)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL parm");
    }
    for (i = 0; NULL != g_dntr[i].pszFieldName; i++)
    {
        hr = MapPropId(g_dntr[i].pwszPropName, PROPTABLE_REQUEST, &dt);
	if (CERTSRV_E_PROPERTY_EMPTY == hr)
	{
	    hr = S_OK;
	    continue;		// Optional column doesn't exist
	}
        _JumpIfError(hr, error, "MapPropId");

        // re-point at fastbuf
        pbProp = rgbFastBuf;
        cbProp = sizeof(rgbFastBuf);

        hr = GetProperty(pcs, &dt, &cbProp, pbProp);
        if (S_OK != hr)
        {
            if (HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW) != hr)
            {
                if (CERTSRV_E_PROPERTY_EMPTY == hr)
                {
                    hr = S_OK;
                    continue;
                }
                _JumpIfError(hr, error, "GetProperty");
            }
            CSASSERT (ARRAYSIZE(rgbFastBuf) < cbProp);

	    DBGPRINT((
		    DBG_SS_CERTDB,
		    "FastBuf miss: CopyRequestNames(cbProp=%u)\n",
		    cbProp));

	    pbProp = (BYTE *) LocalAlloc(LMEM_FIXED, cbProp);
            if (NULL == pbProp)
            {
                hr = E_OUTOFMEMORY;
                _JumpError(hr, error, "LocalAlloc");
            }

            hr = GetProperty(pcs, &dt, &cbProp, pbProp);
            _JumpIfError(hr, error, "GetProperty");
        } // have data in hand

        hr = MapPropId(g_dntr[i].pwszPropName, PROPTABLE_CERTIFICATE, &dt);
        _JumpIfError(hr, error, "MapPropId");

        hr = SetProperty(pcs, &dt, cbProp, pbProp);
        _JumpIfError(hr, error, "SetProperty");

        if (NULL != pbProp && rgbFastBuf != pbProp)
	{
            LocalFree(pbProp);
	}
        pbProp = NULL;
    }

error:
    if (NULL != pbProp && rgbFastBuf != pbProp)
    {
        LocalFree(pbProp);
    }
    return(hr);
}


STDMETHODIMP
CCertDB::EnumCertDBColumn(
    /* [in] */ DWORD dwTable,
    /* [out] */ IEnumCERTDBCOLUMN **ppenum)
{
    HRESULT hr;
    IEnumCERTDBCOLUMN *penum = NULL;

    if (NULL == ppenum)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppenum = NULL;

    penum = new CEnumCERTDBCOLUMN;
    if (NULL == penum)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "new CEnumCERTDBCOLUMN");
    }

    hr = ((CEnumCERTDBCOLUMN *) penum)->Open(dwTable, this);
    _JumpIfError(hr, error, "Open");

    *ppenum = penum;
    hr = S_OK;

error:
    if (S_OK != hr && NULL != penum)
    {
	penum->Release();
    }
    return(hr);
}

STDMETHODIMP
CCertDB::GetDefaultColumnSet(
    /* [in] */       DWORD  iColumnSetDefault,
    /* [in] */       DWORD  cColumnIds,
    /* [out] */      DWORD *pcColumnIds,
    /* [out, ref] */ DWORD *pColumnIds)		// OPTIONAL
{
    HRESULT hr;
    DWORD *pcol;
    DWORD ccol;

    if (NULL == pcColumnIds)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    switch (iColumnSetDefault)
    {
	case CV_COLUMN_LOG_FAILED_DEFAULT:
	case CV_COLUMN_QUEUE_DEFAULT:
	    pcol = g_aColumnViewQueue;
	    ccol = g_cColumnViewQueue;
	    break;

	case CV_COLUMN_LOG_REVOKED_DEFAULT:
	    pcol = g_aColumnViewRevoked;
	    ccol = g_cColumnViewRevoked;
	    break;

	case CV_COLUMN_LOG_DEFAULT:
	    pcol = g_aColumnViewLog;
	    ccol = g_cColumnViewLog;
	    break;

	case CV_COLUMN_EXTENSION_DEFAULT:
	    pcol = g_aColumnViewExtension;
	    ccol = g_cColumnViewExtension;
	    break;

	case CV_COLUMN_ATTRIBUTE_DEFAULT:
	    pcol = g_aColumnViewAttribute;
	    ccol = g_cColumnViewAttribute;
	    break;

	case CV_COLUMN_CRL_DEFAULT:
	    pcol = g_aColumnViewCRL;
	    ccol = g_cColumnViewCRL;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "iColumnSetDefault");
    }

    *pcColumnIds = ccol;
    hr = S_OK;

    if (NULL != pColumnIds)
    {
	if (ccol > cColumnIds)
	{
	    ccol = cColumnIds;
	    hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	}
	CopyMemory(pColumnIds, pcol, ccol * sizeof(*pColumnIds));
    }

error:
    return(hr);
}


HRESULT
CCertDB::GetColumnType(
    IN  LONG ColumnIndex,
    OUT DWORD *pType)
{
    HRESULT hr;
    DBTABLE const *pdt;

    if (NULL == pType)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    hr = _MapPropIdIndex(ColumnIndex, &pdt, pType);
    _JumpIfError(hr, error, "_MapPropIdIndex");

error:
    return(hr);
}


HRESULT
CCertDB::EnumCertDBColumnNext(
    IN  DWORD         dwTable,	// CVRC_TABLE_*
    IN  ULONG         ielt,
    IN  ULONG         celt,
    OUT CERTDBCOLUMN *rgelt,
    OUT ULONG        *pielt,
    OUT ULONG        *pceltFetched)
{
    HRESULT hr;
    ULONG ieltEnd;
    ULONG ieltMax;
    ULONG TableIndex;
    CERTDBCOLUMN *pelt;
    WCHAR const *pwszPrefix;
    WCHAR const *pwszDisplayName;

    if (NULL == rgelt || NULL == pielt || NULL == pceltFetched)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    switch (dwTable)
    {
	case CVRC_TABLE_REQCERT:
	    TableIndex = DTI_REQUESTTABLE;
	    ieltMax = DTR_MAX + DTC_MAX;
	    break;

	case CVRC_TABLE_EXTENSIONS:
	    TableIndex = DTI_EXTENSIONTABLE;
	    ieltMax = DTE_MAX;
	    break;

	case CVRC_TABLE_ATTRIBUTES:
	    TableIndex = DTI_ATTRIBUTETABLE;
	    ieltMax = DTA_MAX;
	    break;

	case CVRC_TABLE_CRL:
	    TableIndex = DTI_CRLTABLE;
	    ieltMax = DTL_MAX;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Bad table");
    }

    if (ieltMax + ielt < celt)
    {
	celt = ieltMax - ielt;
    }
    ieltEnd = ielt + celt;

    ZeroMemory(rgelt, celt * sizeof(rgelt[0]));

    hr = S_OK;
    for (pelt = rgelt; pelt < &rgelt[celt]; ielt++, pelt++)
    {
	DBTABLE const *pdt;
	ULONG ieltBase = 0;

	if (ieltMax <= ielt)
	{
	    if (pelt == rgelt)
	    {
		hr = S_FALSE;
	    }
	    break;
	}
	pwszPrefix = NULL;

	if (CVRC_TABLE_REQCERT == dwTable)
	{
	    if (DTR_MAX > ielt)
	    {
		pwszPrefix = wszPROPREQUESTDOT;
		TableIndex = DTI_REQUESTTABLE;
	    }
	    else
	    {
		ieltBase = DTR_MAX;
		TableIndex = DTI_CERTIFICATETABLE;
	    }
	}

	pelt->Index = TableIndex | (ielt - ieltBase);

	hr = _MapPropIdIndex(pelt->Index, &pdt, &pelt->Type);
	_JumpIfError(hr, error, "_MapPropIdIndex");

	pelt->cbMax = pdt->dwcbMax;
	hr = _DupString(pwszPrefix, pdt->pwszPropName, &pelt->pwszName);
	_JumpIfError(hr, error, "_DupString");

	hr = myGetColumnDisplayName(pelt->pwszName, &pwszDisplayName);
	_PrintIfError(hr, "myGetColumnDisplayName");
	if (S_OK != hr)
	{
	    pwszDisplayName = pelt->pwszName;
	}

	hr = _DupString(NULL, pwszDisplayName, &pelt->pwszDisplayName);
	_JumpIfError(hr, error, "_DupString");
    }

    *pceltFetched = SAFE_SUBTRACT_POINTERS(pelt, rgelt);
    *pielt = ielt;

error:
    if (S_OK != hr && S_FALSE != hr)
    {
	if (NULL != rgelt)
	{
	    for (pelt = rgelt; pelt < &rgelt[celt]; pelt++)
	    {
		if (NULL != pelt->pwszName)
		{
		    CoTaskMemFree(pelt->pwszName);
		    pelt->pwszName = NULL;
		}
		if (NULL != pelt->pwszDisplayName)
		{
		    CoTaskMemFree(pelt->pwszDisplayName);
		    pelt->pwszDisplayName = NULL;
		}
	    }
	}
    }
    return(hr);
}


HRESULT
CCertDB::EnumCertDBResultRowNext(
    IN  CERTSESSION               *pcs,
    IN  DWORD                      ccvr,
    IN  CERTVIEWRESTRICTION const *pcvr,
    IN  DWORD                      ccolOut,
    IN  DWORD const               *acolOut,
    IN  LONG                       cskip,
    IN  ULONG                      celt,
    OUT CERTDBRESULTROW           *rgelt,
    OUT ULONG                     *pceltFetched,
    OUT LONG			  *pcskipped)
{
    HRESULT hr;
    DWORD iRow;
    CERTDBRESULTROW *pResultRow;
    LONG cskipped;

    DBGPRINT((
	    DBG_SS_CERTDBI,
	    "EnumCertDBResultRowNext called: cskip: %d\n", cskip));

    if (NULL == pcvr ||
	NULL == acolOut ||
	NULL == rgelt ||
	NULL == pceltFetched ||
	NULL == pcskipped)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *pcskipped = 0;
    hr = S_OK;
    for (iRow = 0; iRow < celt; iRow++)
    {
	hr = TestShutDownState();
	_JumpIfError(hr, error, "TestShutDownState");

	hr = _GetResultRow(
			pcs,
			ccvr,
			pcvr,
			cskip,
			ccolOut,
			acolOut,
			&rgelt[iRow],
			&cskipped);
	if (S_FALSE == hr)
	{
	    *pcskipped += cskipped;
	    break;
	}
	DBGPRINT((
	    DBG_SS_CERTDBI,
	    "EnumCertDBResultRowNext: rowid %u\n", rgelt[iRow].rowid));

	_JumpIfError(hr, error, "_GetResultRow");

	*pcskipped += cskipped;
	cskip = 0;
    }
    *pceltFetched = iRow;
    DBGPRINT((
	    DBG_SS_CERTDBI,
	    "EnumCertDBResultRowNext: %u rows, hr=%x\n",
	    *pceltFetched,
	    hr));

error:
    if (S_OK != hr && S_FALSE != hr)
    {
	ReleaseResultRow(celt, rgelt);
    }
    return(hr);
}


HRESULT
CCertDB::_CompareColumnValue(
    IN CERTSESSION               *pcs,
    IN CERTVIEWRESTRICTION const *pcvr)
{
    HRESULT hr;
    JET_TABLEID tableid;
    DBTABLE const *pdt;
    WCHAR *pwszValue = NULL;
    BOOL fMatch;
    int r;

    BYTE rgbFastBuf[256];
    BYTE *pbProp = rgbFastBuf;
    DWORD cb = sizeof(rgbFastBuf);

    // if SEEK_NONE, short circuit tests
    if (CVR_SEEK_NONE == (CVR_SEEK_MASK & pcvr->SeekOperator))
    {
        return S_OK;
    }

    hr = _MapPropIdIndex(pcvr->ColumnIndex, &pdt, NULL);
    _JumpIfError(hr, error, "_MapPropIdIndex");

    if (TABLE_CERTIFICATES == pdt->dwTable)
    {
	tableid = pcs->aTable[CSTI_CERTIFICATE].TableId;
    }
    else
    {
	tableid = pcs->aTable[CSTI_PRIMARY].TableId;
    }
    CSASSERT(IsValidJetTableId(tableid));

    hr = _RetrieveColumn(
		    pcs,
		    tableid,
		    pdt->dbcolumnid,
		    pdt->dbcoltyp,
		    &cb,
		    rgbFastBuf);
    
    if (S_OK != hr)
    {
        if (HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW) != hr)
        {
            if (CERTSRV_E_PROPERTY_EMPTY == hr)
            {
                _PrintError2(hr, "_RetrieveColumn", hr);
                hr = S_FALSE;
            }
            _JumpError2(hr, error, "_RetrieveColumn", S_FALSE);
        }
        
        // buffer not big enough, dyn-alloc
        CSASSERT(ARRAYSIZE(rgbFastBuf) < cb);

	DBGPRINT((
		DBG_SS_CERTDB,
		"FastBuf miss: _CompareColumnValue(cbProp=%u)\n",
		cb));
        
	pbProp = (BYTE *) LocalAlloc(LMEM_FIXED, cb);
        if (NULL == pbProp)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
        
        hr = _RetrieveColumn(
			pcs,
			tableid,
			pdt->dbcolumnid,
			pdt->dbcoltyp,
			&cb,
			pbProp);
        _JumpIfError(hr, error, "_RetrieveColumn");
        
    } // we have data in-hand

#if DBG_CERTSRV
    DumpRestriction(DBG_SS_CERTDBI, -1, pcvr);
    dbDumpColumn(DBG_SS_CERTDBI, pdt, pbProp, cb);
#endif

    fMatch = FALSE;
    switch (pdt->dbcoltyp)
    {
	case JET_coltypLong:
	    if (cb == pcvr->cbValue && sizeof(LONG) == cb)
	    {
		LONG lRestriction;
		LONG lColumn;

		lRestriction = *(LONG *) pcvr->pbValue;
		lColumn = *(LONG *) pbProp;
		switch (CVR_SEEK_MASK & pcvr->SeekOperator)
		{
		    case CVR_SEEK_EQ:
			fMatch = lColumn == lRestriction;
			break;

		    case CVR_SEEK_LT:
			fMatch = lColumn < lRestriction;
			break;

		    case CVR_SEEK_LE:
			fMatch = lColumn <= lRestriction;
			break;

		    case CVR_SEEK_GE:
			fMatch = lColumn >= lRestriction;
			break;

		    case CVR_SEEK_GT:
			fMatch = lColumn > lRestriction;
			break;
		}
		DBGPRINT((
			DBG_SS_CERTDBI,
			"_CompareColumnValue(lColumn=%x %ws lRestriction=%x) -> fMatch=%x\n",
			lColumn,
			wszSeekOperator(pcvr->SeekOperator),
			lRestriction,
			fMatch));
	    }
	    break;

	case JET_coltypDateTime:
	    if (cb == pcvr->cbValue && sizeof(FILETIME) == cb)
	    {
		r = CompareFileTime(
				(FILETIME *) pcvr->pbValue,
				(FILETIME *) pbProp);
		switch (CVR_SEEK_MASK & pcvr->SeekOperator)
		{
		    case CVR_SEEK_EQ:
			fMatch = 0 == r;
			break;

		    case CVR_SEEK_LT:
			fMatch = 0 < r;
			break;

		    case CVR_SEEK_LE:
			fMatch = 0 <= r;
			break;

		    case CVR_SEEK_GE:
			fMatch = 0 >= r;
			break;

		    case CVR_SEEK_GT:
			fMatch = 0 > r;
			break;
		}
#if DBG_CERTSRV
		dbDumpFileTime(
			    DBG_SS_CERTDBI,
			    "Column: ",
			    (FILETIME const *) pbProp);
		dbDumpFileTime(
			    DBG_SS_CERTDBI,
			    "Restriction: ",
			    (FILETIME const *) pcvr->pbValue);
#endif
		DBGPRINT((
			DBG_SS_CERTDBI,
			"_CompareColumnValue(ftColumn=%08x:%08x %ws ftRestriction=%08x:%08x) -> r=%d, fMatch=%x\n",
			((LARGE_INTEGER *) pbProp)->HighPart,
			((LARGE_INTEGER *) pbProp)->LowPart,
			wszSeekOperator(pcvr->SeekOperator),
			((LARGE_INTEGER *) pcvr->pbValue)->HighPart,
			((LARGE_INTEGER *) pcvr->pbValue)->LowPart,
			r,
			fMatch));
	    }
	    break;

	case JET_coltypText:
	case JET_coltypLongText:
	    CSASSERT(
		(1 + wcslen((WCHAR const *) pcvr->pbValue)) * sizeof(WCHAR) ==
		pcvr->cbValue);
	    CSASSERT(wcslen((WCHAR const *) pbProp) * sizeof(WCHAR) == cb);
	    r = lstrcmpi((WCHAR const *) pcvr->pbValue, (WCHAR const *) pbProp); //pwszValue
	    switch (CVR_SEEK_MASK & pcvr->SeekOperator)
	    {
		case CVR_SEEK_EQ:
		    fMatch = 0 == r;
		    break;

		case CVR_SEEK_LT:
		    fMatch = 0 < r;
		    break;

		case CVR_SEEK_LE:
		    fMatch = 0 <= r;
		    break;

		case CVR_SEEK_GE:
		    fMatch = 0 >= r;
		    break;

		case CVR_SEEK_GT:
		    fMatch = 0 > r;
		    break;
	    }
	    DBGPRINT((
		    DBG_SS_CERTDBI,
		    "_CompareColumnValue(pwszColumn=%ws %ws pwszRestriction=%ws) -> r=%d, fMatch=%x\n",
		    pbProp, //pwszValue,
		    wszSeekOperator(pcvr->SeekOperator),
		    pcvr->pbValue,
		    r,
		    fMatch));
	    break;

	case JET_coltypLongBinary:
	    if (CVR_SEEK_EQ != (CVR_SEEK_MASK & pcvr->SeekOperator))
	    {
		hr = E_INVALIDARG;
		_JumpError(hr, error, "Bad dbcoltyp");
	    }
	    fMatch = cb == pcvr->cbValue &&
		    0 == memcmp(pcvr->pbValue, pbProp, cb);
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Bad dbcoltyp");
    }

    if (!fMatch)
    {
	hr = S_FALSE;
	_JumpError2(hr, error, "No match", S_FALSE);
    }

error:
    if (NULL != pwszValue)
    {
	LocalFree(pwszValue);
    }
    if (NULL != pbProp && rgbFastBuf != pbProp)
    {
	LocalFree(pbProp);
    }
    return(hr);
}


HRESULT
CCertDB::_MakeSeekKey(
    IN CERTSESSION   *pcs,
    IN JET_TABLEID    tableid,
    IN DBTABLE const *pdt,
    IN BYTE const    *pbValue,
    IN DWORD          cbValue)
{
    HRESULT hr;
    JET_GRBIT grbitKey = JET_bitNewKey;

    CSASSERT(IsValidJetTableId(tableid));
    if (DBTF_INDEXREQUESTID & pdt->dwFlags)
    {
        CSASSERTTHREAD(pcs);
	hr = _dbgJetMakeKey(
			pcs->SesId,
			tableid,
			&pcs->RowId,
			sizeof(pcs->RowId),
			grbitKey);
	_JumpIfError(hr, error, "JetMakeKey(RowId)");

	DBGPRINT((DBG_SS_CERTDBI, "_MakeSeekKey key(RowId):\n"));
	DBGDUMPHEX((DBG_SS_CERTDBI, DH_NOADDRESS, (BYTE *) &pcs->RowId, sizeof(pcs->RowId)));
	grbitKey = 0;
    }

    CSASSERTTHREAD(pcs);
    hr = _dbgJetMakeKey(pcs->SesId, tableid, pbValue, cbValue, grbitKey);
    _JumpIfErrorStr(hr, error, "JetMakeKey", pdt->pwszPropName);

    DBGPRINT((DBG_SS_CERTDBI, "_MakeSeekKey key:\n"));
    DBGDUMPHEX((DBG_SS_CERTDBI, DH_NOADDRESS, pbValue, cbValue));

error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::_SeekTable(
    IN CERTSESSION               *pcs,
    IN JET_TABLEID                tableid,
    IN CERTVIEWRESTRICTION const *pcvr,
    IN DBTABLE const             *pdt,
    IN DWORD                      dwPosition,
    OUT DWORD                    *pTableFlags
    DBGPARM(IN DBAUXDATA const   *pdbaux))
{
    HRESULT hr;
    DBSEEKDATA SeekData;
    BYTE *pbValue;
    DWORD cbValue;
    BYTE abRangeKey[JET_cbKeyMost];
    DWORD cbRangeKey;

    *pTableFlags = 0;

    CSASSERT(IsValidJetTableId(tableid));
    hr = _JetSeekFromRestriction(pcvr, dwPosition, &SeekData);
    if (CERTSRV_E_PROPERTY_EMPTY == hr)
    {
	hr = S_FALSE;
    }
    _JumpIfError2(hr, error, "_JetSeekFromRestriction", S_FALSE);

    cbValue = pcvr->cbValue;
    pbValue = pcvr->pbValue;

    if (ISTEXTCOLTYP(pdt->dbcoltyp) &&
        NULL != pbValue &&
        cbValue == -1)
    {
        cbValue = wcslen((WCHAR const *) pbValue) * sizeof(WCHAR);
    }

    // If we need to set an index limit, seek to the limit location, and save
    // a copy of the key until after the initial record is located.

    if (CST_SEEKINDEXRANGE & SeekData.SeekFlags)
    {
	hr = _MakeSeekKey(pcs, tableid, pdt, pbValue, cbValue);
	_JumpIfError(hr, error, "_MakeSeekKey");

	CSASSERTTHREAD(pcs);
	hr = _dbgJetSeek(pcs->SesId, tableid, SeekData.grbitSeekRange);
	if ((HRESULT) JET_errRecordNotFound == hr)
	{
	    // No record exists past the data we're interested in.
	    // Just use the end of the index as the limit.

	    _PrintError2(hr, "JetSeek(Range Limit): no key, index end is limit", hr);
	    SeekData.SeekFlags &= ~CST_SEEKINDEXRANGE;
	    hr = S_OK;
	}
	else if ((HRESULT) JET_wrnSeekNotEqual == hr)
	{
	    _PrintError2(hr, "JetSeek(Range): ignoring key not equal", hr);
	    hr = S_OK;		// Ignore inexact match when seeking >= or <=
	}
	//_JumpIfError2(hr, error, "JetSeek(IndexRange)", S_FALSE);
	_JumpIfError(hr, error, "JetSeek(IndexRange)");
    }

    // If we found a valid key at the limit location, save it now.

    if (CST_SEEKINDEXRANGE & SeekData.SeekFlags) 
    {
        CSASSERTTHREAD(pcs);
	hr = _dbgJetRetrieveKey(
			pcs->SesId,
			tableid,
			abRangeKey,
			ARRAYSIZE(abRangeKey),
			&cbRangeKey,
			0);
	_JumpIfError(hr, error, "JetRetrieveKey");

	DBGPRINT((DBG_SS_CERTDBI, "RetrieveKey(Range):\n"));
	DBGDUMPHEX((DBG_SS_CERTDBI, DH_NOADDRESS, abRangeKey, cbRangeKey));
    }

    // Locate the initial record: seek to a key or move to one end of the index

    if (CST_SEEKNOTMOVE & SeekData.SeekFlags)
    {
        hr = _MakeSeekKey(pcs, tableid, pdt, pbValue, cbValue);
        _JumpIfError(hr, error, "_MakeSeekKey");
        
        CSASSERTTHREAD(pcs);
        hr = _dbgJetSeek(pcs->SesId, tableid, SeekData.grbitInitial);
        if ((HRESULT) JET_errRecordNotFound == hr)
        {
            // Routine GetAttribute/Extension call:

            _PrintError2(hr, "JetSeek: Property EMPTY", hr);
            hr = S_FALSE;
        }
        else if ((HRESULT) JET_wrnSeekNotEqual == hr)
        {
            hr = S_OK;		// Ignore inexact match when seeking >= or <=
        }
        _JumpIfError2(hr, error, "JetSeek(Initial)", S_FALSE);
    }
    else
    {
        // grbitInitial is a move count here, not a grbit

        CSASSERTTHREAD(pcs);
        hr = _dbgJetMove(pcs->SesId, tableid, SeekData.grbitInitial, 0);
        if ((HRESULT) JET_errNoCurrentRecord == hr)
        {
            // Routine Enumerate call:

            // _JumpIfError(hr, error, "JetMove: no more elements");
            hr = S_FALSE;
        }
        _JumpIfError2(hr, error, "JetMove(End)", S_FALSE);

        // If moving the cursor to the last element, we want to position
	// ourselves to step over the end again (skip the last element).
	//
        // If moving to the first element, we want to position ourselves on the
	// first element and use it before stepping

	if (SEEKPOS_FIRST == dwPosition || SEEKPOS_INDEXFIRST == dwPosition)
	{
	    SeekData.SeekFlags |= CST_SEEKUSECURRENT;
	}
    }

    // We're done seeking around; set the index limit from the saved key.

    if (CST_SEEKINDEXRANGE & SeekData.SeekFlags)
    {
        CSASSERTTHREAD(pcs);
	hr = _dbgJetMakeKey(
			pcs->SesId,
			tableid,
			abRangeKey,
			cbRangeKey,
			JET_bitNormalizedKey);
	_JumpIfError(hr, error, "JetMakeKey");

	DBGPRINT((DBG_SS_CERTDBI, "RangeKey:\n"));
	DBGDUMPHEX((DBG_SS_CERTDBI, DH_NOADDRESS, abRangeKey, cbRangeKey));

        CSASSERTTHREAD(pcs);
	hr = _dbgJetSetIndexRange(
			pcs->SesId,
			tableid,
			SeekData.grbitRange);
	if ((HRESULT) JET_errNoCurrentRecord == hr)
	{
	    // No records to enumerate:
	    _PrintError2(hr, "JetSetIndexRange: no records to enumerate", hr);
	    hr = S_FALSE;
	}
	_JumpIfError2(hr, error, "JetSetIndexRange", S_FALSE);
    }

    DBGCODE(_DumpRowId("post-_SeekTable", pcs, tableid));
    DBGCODE(_DumpColumn("post-_SeekTable", pcs, tableid, pdt));

    *pTableFlags = SeekData.SeekFlags;

error:
    if (S_FALSE == hr)
    {
	DWORD dwPosition2 = dwPosition;

	switch (dwPosition)
	{
	    case SEEKPOS_FIRST:
		dwPosition2 = SEEKPOS_INDEXFIRST;
		break;

	    case SEEKPOS_LAST:
		dwPosition2 = SEEKPOS_INDEXLAST;
		break;
	}
	if (dwPosition2 != dwPosition)
	{
	    hr = _SeekTable(
			pcs,
			tableid,
			pcvr,
			pdt,
			dwPosition2,
			pTableFlags
			DBGPARM(pdbaux));
	    _PrintIfError2(hr, "_SeekTable: recurse on index first/last", S_FALSE);
	}
    }
#if DBG_CERTSRV
    if (S_OK != hr)
    {
	DumpRestriction(DBG_SS_CERTDBI, 0, pcvr);
    }
#endif
    return(myJetHResult(hr));
}


HRESULT
CCertDB::_MoveTable(
    IN  CERTSESSION               *pcs,
    IN  DWORD                      ccvr,
    IN  CERTVIEWRESTRICTION const *pcvr,
    IN  LONG	                   cskip,
    OUT LONG	                  *pcskipped)
{
    HRESULT hr;
    DWORD cb;
    DBAUXDATA const *pdbaux;
    DBTABLE const *pdt;
    DWORD icvr;
    DWORD SeekFlags;
    LONG lSeek;
    LONG skipIncrement;
    LONG cskipRemain;
    BOOL fHitEnd = FALSE;
    LONG cskippeddummy;
    CERTSESSIONTABLE *pTable;
    CERTSESSIONTABLE *pTable2;

    *pcskipped = 0;
    DBGPRINT((
	    DBG_SS_CERTDBI,
	    "_MoveTable called(ccvr=%d, cskip=%d, flags=%ws)\n",
	    ccvr,
	    cskip,
	    wszCSFFlags(pcs->SesFlags)));

    hr = _MapPropIdIndex(pcvr->ColumnIndex, &pdt, NULL);
    _JumpIfError(hr, error, "_MapPropIdIndex");

    pTable = &pcs->aTable[CSTI_PRIMARY];
    pTable2 = NULL;

    switch (DTI_TABLEMASK & pcvr->ColumnIndex)
    {
	case DTI_REQUESTTABLE:
	    pdbaux = &g_dbauxRequests;
	    pTable2 = &pcs->aTable[CSTI_CERTIFICATE];
	    break;

	case DTI_CERTIFICATETABLE:
	    pdbaux = &g_dbauxCertificates;
	    pTable = &pcs->aTable[CSTI_CERTIFICATE];
	    pTable2 = &pcs->aTable[CSTI_PRIMARY];
	    break;

	case DTI_EXTENSIONTABLE:
	    pdbaux = &g_dbauxExtensions;
	    break;

	case DTI_ATTRIBUTETABLE:
	    pdbaux = &g_dbauxAttributes;
	    break;

	case DTI_CRLTABLE:
	    pdbaux = &g_dbauxCRLs;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "ColumnIndex Table");
    }

    DBGPRINT((
	    DBG_SS_CERTDBI,
	    "_MoveTable(Table=%hs, TableFlags=%ws)\n",
	    pdbaux->pszTable,
	    wszCSTFlags(pTable->TableFlags)));

    if (NULL != pTable2 && IsValidJetTableId(pTable2->TableId))
    {
	DBGPRINT((
		DBG_SS_CERTDBI,
		"_MoveTable(Table2=%hs, TableFlags2=%ws)\n",
		&g_dbauxCertificates == pdbaux?
		    g_dbauxRequests.pszTable :
		    g_dbauxCertificates.pszTable,
		wszCSTFlags(pTable2->TableFlags)));
    }

    switch (pcvr->SortOrder)
    {
	case CVR_SORT_DESCEND:
	    lSeek = JET_MovePrevious;
	    break;

	case CVR_SORT_NONE:
	default:
	    CSASSERT(!"bad pcvr->SortOrder");	// shouldn't get this far
	    // FALL THROUGH

	case CVR_SORT_ASCEND:
	    lSeek = JET_MoveNext;
	    break;
    }

    // Add one to the skip count for the implicit Next operation.  Next
    // always moves forward one, even when a negative skip count moves
    // backward.  The net result may be a forward or backward skip.

    cskipRemain = cskip + 1;
    skipIncrement = 1;
    if (0 > cskipRemain)
    {
	CSASSERT(JET_MoveNext == -1 * JET_MovePrevious);
	lSeek *= -1;		// Seek in opposite direction
	cskipRemain *= -1;	// make the skip count positive
	skipIncrement = -1;
    }
    CSASSERT(0 <= cskipRemain);

    while (0 != cskipRemain)
    {
	DBGPRINT((
		DBG_SS_CERTDBI,
		"_MoveTable loop: ccvr=%d, cskipRemain=%d, lSeek=%d, flags=%ws\n",
		ccvr,
		cskipRemain,
		lSeek,
		wszCSFFlags(pcs->SesFlags)));

	DBGCODE(_DumpRowId("_MoveTable(loop top)", pcs, pTable->TableId));

	if (CSF_VIEW & pcs->SesFlags)
	{
	    hr = TestShutDownState();
	    _JumpIfError(hr, error, "TestShutDownState");
	}

	if (CSF_VIEWRESET & pcs->SesFlags)
	{
	    hr = _SeekTable(
			pcs,
			pTable->TableId,
			pcvr,
			pdt,
			SEEKPOS_FIRST,
			&pTable->TableFlags
			DBGPARM(pdbaux));
	    _JumpIfError(hr, error, "_SeekTable");

	    pcs->SesFlags &= ~CSF_VIEWRESET;
	}
	if (0 == (CST_SEEKUSECURRENT & pTable->TableFlags))
	{
            CSASSERTTHREAD(pcs);
	    hr = _dbgJetMove(pcs->SesId, pTable->TableId, lSeek, 0);
	    if ((HRESULT) JET_errNoCurrentRecord == hr)
	    {
		_PrintIfError2(hr, "JetMove: no more elements", hr);

		if (fHitEnd)
		{
		    // we hit the end trying to backstep! We're done
		    hr = S_FALSE;
		    _JumpError(hr, error, "JetMove: db backstep hit beginning");
		}
		fHitEnd = TRUE;

		// NOTE: Tough case
		//
		// We just hit the end of the database index, which could be a
		// virtual end or the real end.  To recover, we call _SeekTable
		// to position ourselves at the last legal element computed by
		// the 1st restriction, then allow this routine to rewind until
		// we position ourselves on the very last legal element as
		// computed by 2nd through Nth restrictions.

		// Routine Seek call to position at end of enumeration

	        hr = _SeekTable(
			    pcs,
			    pTable->TableId,
			    pcvr,
			    pdt,
			    SEEKPOS_LAST,	// cursor at end
			    &pTable->TableFlags
			    DBGPARM(pdbaux));
	        _JumpIfError(hr, error, "_SeekTable moving to last elt");

		// now fall through, allow other restrictions to test for 1st
		// valid element

	        lSeek *= -1;			// Seek in opposite direction
	        cskipRemain = 1;		// one valid element
		pcskipped = &cskippeddummy;	// stop counting skipped rows
	    }
	    _JumpIfError2(hr, error, "JetMove", S_FALSE);

	    DBGCODE(_DumpRowId("_MoveTable(post-move)", pcs, pTable->TableId));

	    hr = _CompareColumnValue(pcs, pcvr);
	    _JumpIfError2(hr, error, "_CompareColumnValue", S_FALSE);
	}
	pTable->TableFlags &= ~CST_SEEKUSECURRENT;

	// Fetch RowId from the first table, form a key for the second
	// table and seek to the corresponding record in the second table.

	cb = sizeof(pcs->RowId);
	hr = _RetrieveColumn(
			pcs,
			pTable->TableId,
			pdbaux->pdtRowId->dbcolumnid,
			pdbaux->pdtRowId->dbcoltyp,
			&cb,
			(BYTE *) &pcs->RowId);
	_JumpIfError(hr, error, "_RetrieveColumn");

	DBGPRINT((
		DBG_SS_CERTDBI,
		"_MoveTable(Primary) %hs --> RowId=%d\n",
		pdbaux->pszTable,
		pcs->RowId));

	if (NULL != pTable2 && IsValidJetTableId(pTable2->TableId))
	{
	    CSASSERTTHREAD(pcs);
	    hr = _dbgJetMakeKey(
			    pcs->SesId,
			    pTable2->TableId,
			    &pcs->RowId,
			    sizeof(pcs->RowId),
			    JET_bitNewKey);
	    _JumpIfError(hr, error, "JetMakeKey");

	    hr = _dbgJetSeek(pcs->SesId, pTable2->TableId, JET_bitSeekEQ);
	    if ((HRESULT) JET_errRecordNotFound == hr)
	    {
		// Database is inconsistent
		hr = S_FALSE;
	    }
	    _JumpIfError2(hr, error, "JetSeek", S_FALSE);

	    DBGPRINT((
		    DBG_SS_CERTDBI,
		    "_MoveTable(Secondary) %hs --> RowId=%d\n",
		    &g_dbauxCertificates == pdbaux?
			g_dbauxRequests.pszTable :
			g_dbauxCertificates.pszTable,
		    pcs->RowId));
	}

	// Now verify that any addtional restrictions are satisfied

	for (icvr = 1; icvr < ccvr; icvr++)
	{
#if 0
	    printf(
		"RowId=%u, cvr[%u]: seek=%x, *pb=%x\n",
		pcs->RowId,
		icvr,
		pcvr[icvr].SeekOperator,
		*(DWORD *) pcvr[icvr].pbValue);
#endif
	    hr = _CompareColumnValue(pcs, &pcvr[icvr]);
	    if (S_FALSE == hr)
	    {
		break;		// skip row silently
	    }
	    _JumpIfError(hr, error, "_CompareColumnValue");
	}
	if (icvr >= ccvr)
	{
	    *pcskipped += skipIncrement;
	    cskipRemain--;	// found a matching row
	}
    } // while (cskipRemain)

error:
    // if we nailed the end and rewound, return failure
    if (fHitEnd && S_OK == hr)
    {
        hr = S_FALSE;
    }
    return(myJetHResult(hr));
}


HRESULT
CCertDB::_GetResultRow(
    IN  CERTSESSION               *pcs,
    IN  DWORD                      ccvr,
    IN  CERTVIEWRESTRICTION const *pcvr,
    IN  LONG			   cskip,
    IN  DWORD                      ccolOut,
    IN  DWORD const               *acolOut,
    OUT CERTDBRESULTROW           *pelt,
    OUT LONG                      *pcskipped)
{
    HRESULT hr;
    DWORD iCol;
    BYTE *pbProp = NULL;
    BYTE *pbT;
    DWORD cbAlloc = 0;
    DWORD cbProp;
    WCHAR awc[CCH_DBMAXTEXT_LONG];

    DBGPRINT((
	    DBG_SS_CERTDBI,
	    "_GetResultRow(ccvr=%d, ccolOut=%d, cskip=%d, flags=%ws)\n",
	    ccvr,
	    ccolOut,
	    cskip,
	    wszCSFFlags(pcs->SesFlags)));

    // This may move past the end of the database index entries.
    // In that case, we're positioned at the end of the index.

    hr = _MoveTable(pcs, ccvr, pcvr, cskip, pcskipped);
    _JumpIfError2(hr, error, "_MoveTable", S_FALSE);

    DBGPRINT((DBG_SS_CERTDBI, "_GetResultRow: RowId=%d\n", pcs->RowId));

    pelt->acol = (CERTDBRESULTCOLUMN *) CoTaskMemAlloc(
					    ccolOut * sizeof(pelt->acol[0]));
    if (NULL == pelt->acol)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "alloc acol");
    }

    ZeroMemory(pelt->acol, ccolOut * sizeof(pelt->acol[0]));
    pelt->rowid = pcs->RowId;
    pelt->ccol = ccolOut;

    for (iCol = 0; iCol < ccolOut; iCol++)
    {
	DBTABLE const *pdt;
	CERTDBRESULTCOLUMN *pCol;

	pCol = &pelt->acol[iCol];
	pCol->Index = acolOut[iCol];

	hr = _MapPropIdIndex(pCol->Index, &pdt, &pCol->Type);
	_JumpIfError(hr, error, "_MapPropIdIndex");

	while (TRUE)
	{
	    cbProp = cbAlloc;
	    hr = GetProperty(pcs, pdt, &cbProp, pbProp);
	    if (CERTSRV_E_PROPERTY_EMPTY == hr)
	    {
		break;		// leave 0 size, NULL pointer
	    }
	    if (HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW) != hr)
	    {
		_JumpIfError(hr, error, "GetProperty");
	    }

	    if (cbAlloc >= cbProp)
	    {
		CSASSERT(S_OK == hr);
		CSASSERT(0 != cbProp && NULL != pbProp);
		break;		// property value is in cbProp, pbProp
	    }

	    // Property value is too large for the buffer -- grow it
	    if (NULL == pbProp)
	    {
		pbT = (BYTE *) LocalAlloc(LMEM_FIXED, cbProp);
	    }
	    else
	    {
		pbT = (BYTE *) LocalReAlloc(pbProp, cbProp, LMEM_MOVEABLE);
	    }
	    if (NULL == pbT)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc/LocalReAlloc property");
	    }
	    pbProp = pbT;
	    cbAlloc = cbProp;
	}
	if (CERTSRV_E_PROPERTY_EMPTY != hr)
	{
	    BYTE const *pb = pbProp;
	    DWORD cwc;

	    if (PROPTYPE_STRING == (PROPTYPE_MASK & pCol->Type))
	    {
		CSASSERT( *((WCHAR*) &(pbProp[cbProp])) == L'\0');
		cbProp += sizeof(WCHAR);    // include NULL term
	    }
	    pCol->cbValue = cbProp;
	    pCol->pbValue = (BYTE *) CoTaskMemAlloc(cbProp);
	    if (NULL == pCol->pbValue)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "CoTaskMemAlloc");
	    }
	    CopyMemory(pCol->pbValue, pb, pCol->cbValue);
	}
	DBGPRINT((
		DBG_SS_CERTDBI,
		"_GetResultRow: fetch %ws.%ws: type=%x cb=%x\n",
		wszTable(pdt->dwTable),
		pdt->pwszPropName,
		pCol->Type,
		pCol->cbValue));
    }
    hr = S_OK;

error:
    if (NULL != pbProp)
    {
	LocalFree(pbProp);
    }
    return(hr);
}


HRESULT
CCertDB::ReleaseResultRow(
    IN     ULONG            celt,
    IN OUT CERTDBRESULTROW *rgelt)
{
    HRESULT hr;
    DWORD iRow;
    DWORD iCol;
    CERTDBRESULTROW *pResultRow;

    if (NULL == rgelt)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    for (iRow = 0; iRow < celt; iRow++)
    {
	pResultRow = &rgelt[iRow];
	if (NULL != pResultRow->acol)
	{
	    for (iCol = 0; iCol < pResultRow->ccol; iCol++)
	    {
		if (NULL != pResultRow->acol[iCol].pbValue)
		{
		    CoTaskMemFree(pResultRow->acol[iCol].pbValue);
		    pResultRow->acol[iCol].pbValue = NULL;
		}
	    }
	    CoTaskMemFree(pResultRow->acol);
	    pResultRow->acol = NULL;
	}
	pResultRow->ccol = 0;
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CCertDB::EnumerateSetup(
    IN     CERTSESSION *pcs,
    IN OUT DWORD       *pFlags,
    OUT    JET_TABLEID *ptableid)
{
    HRESULT hr;
    JET_TABLEID tableid = 0;
    DBAUXDATA const *pdbaux;

    if (NULL == pcs || NULL == ptableid)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    switch (*pFlags)
    {
	case CIE_TABLE_ATTRIBUTES:
	    pdbaux = &g_dbauxAttributes;
	    break;

	case CIE_TABLE_EXTENSIONS:
	    pdbaux = &g_dbauxExtensions;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "*pFlags");
    }

    CSASSERTTHREAD(pcs);
    hr = _dbgJetOpenTable(
			pcs->SesId,
			pcs->DBId,
			pdbaux->pszTable,
			NULL,
			0,
			0,
			&tableid);
    _JumpIfError(hr, error, "JetOpenTable");

    CSASSERTTHREAD(pcs);
    hr = _dbgJetSetCurrentIndex2(
			    pcs->SesId,
			    tableid,
			    pdbaux->pszRowIdIndex,
			    JET_bitMoveFirst);
    _JumpIfError(hr, error, "JetSetCurrentIndex2");

    CSASSERTTHREAD(pcs);
    hr = _dbgJetMakeKey(
		    pcs->SesId,
		    tableid,
		    &pcs->RowId,
		    sizeof(pcs->RowId),
		    JET_bitNewKey);
    _JumpIfError(hr, error, "JetMakeKey");

    *pFlags |= CIE_RESET;
    CSASSERT(IsValidJetTableId(tableid));
    *ptableid = tableid;
    tableid = 0;

error:
    if (IsValidJetTableId(tableid))
    {
        CSASSERTTHREAD(pcs);
	_dbgJetCloseTable(pcs->SesId, tableid);
    }
    return(myJetHResult(hr));
}


HRESULT
CCertDB::_EnumerateMove(
    IN     CERTSESSION     *pcs,
    IN OUT DWORD           *pFlags,
    IN     DBAUXDATA const *pdbaux,
    IN     JET_TABLEID      tableid,
    IN     LONG	            cskip)
{
    HRESULT hr;
    DWORD cb;
    DWORD RowId;
    LONG lSeek;

    DBGPRINT((
	    DBG_SS_CERTDBI,
	    "_EnumerateMove(cskip=%d, flags=%x%hs)\n",
	    cskip,
	    *pFlags,
	    (CIE_RESET & *pFlags)? " Reset" : ""));

    CSASSERT(IsValidJetTableId(tableid));
    if (CIE_RESET & *pFlags)
    {
        CSASSERTTHREAD(pcs);
	hr = _dbgJetSeek(pcs->SesId, tableid, JET_bitSeekEQ);
	if ((HRESULT) JET_errRecordNotFound == hr)
	{
	    hr = S_FALSE;
	}
	_JumpIfError2(hr, error, "JetSeek", S_FALSE);

	*pFlags &= ~CIE_RESET;
    }
    else
    {
	// Add one to the skip count for the implicit Next operation.  Next
	// always moves forward one, even when a negative skip count moves
	// backward.  The net result may be a forward or backward skip.

	cskip++;
    }

    if (0 != cskip)
    {
	lSeek = JET_MoveNext * cskip;
	CSASSERT(JET_MoveNext == -1 * JET_MovePrevious);

        CSASSERTTHREAD(pcs);
	hr = _dbgJetMove(pcs->SesId, tableid, lSeek, 0);
	if ((HRESULT) JET_errNoCurrentRecord == hr)
	{
	    hr = S_FALSE;
	}
	_JumpIfError2(hr, error, "JetMove", S_FALSE);

	// Make sure this entry is for the same request:

	cb = sizeof(RowId);
	hr = _RetrieveColumn(
			pcs,
			tableid,
			pdbaux->pdtRowId->dbcolumnid,
			pdbaux->pdtRowId->dbcoltyp,
			&cb,
			(BYTE *) &RowId);
	_JumpIfError(hr, error, "_RetrieveColumn");

	if (RowId != pcs->RowId)
	{
	    hr = S_FALSE;
	    goto error;
	}
    }
    hr = S_OK;

error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::EnumerateNext(
    IN     CERTSESSION *pcs,
    IN OUT DWORD       *pFlags,
    IN     JET_TABLEID  tableid,
    IN     LONG         cskip,
    IN     ULONG        celt,
    OUT    CERTDBNAME  *rgelt,
    OUT    ULONG       *pceltFetched)
{
    HRESULT hr;
    DWORD cb;
    DWORD cwc;
    DWORD RowId;
    CERTDBNAME *pelt;
    WCHAR wszTmp[MAX_PATH];
    DBAUXDATA const *pdbaux;

    if (NULL == pcs || NULL == rgelt || NULL == pceltFetched)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    ZeroMemory(rgelt, celt * sizeof(rgelt[0]));

    CSASSERT(IsValidJetTableId(tableid));
    switch (CIE_TABLE_MASK & *pFlags)
    {
	case CIE_TABLE_ATTRIBUTES:
	    pdbaux = &g_dbauxAttributes;
	    break;

	case CIE_TABLE_EXTENSIONS:
	    pdbaux = &g_dbauxExtensions;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "*pFlags");
    }

    hr = S_OK;
    for (pelt = rgelt; pelt < &rgelt[celt]; pelt++)
    {
	hr = _EnumerateMove(pcs, pFlags, pdbaux, tableid, cskip);
	if (S_FALSE == hr)
	{
	    break;
	}
	_JumpIfError(hr, error, "_EnumerateMove");

	cskip = 0;

	cb = sizeof(wszTmp);
	hr = _RetrieveColumn(
			pcs,
			tableid,
			pdbaux->pdtName->dbcolumnid,
			pdbaux->pdtName->dbcoltyp,
			&cb,
			(BYTE *) wszTmp);
	_JumpIfError(hr, error, "_RetrieveColumn");

	CSASSERT(0 == (cb % sizeof(WCHAR)));    // integer # of wchars
    CSASSERT(L'\0' == wszTmp[cb/sizeof(WCHAR)]);    // zero term

	hr = _DupString(NULL, wszTmp, &pelt->pwszName);
	_JumpIfError(hr, error, "_DupString");
    }

    *pceltFetched = SAFE_SUBTRACT_POINTERS(pelt, rgelt);

error:
    if (S_OK != hr && S_FALSE != hr)
    {
	if (NULL != rgelt)
	{
	    for (pelt = rgelt; pelt < &rgelt[celt]; pelt++)
	    {
		if (NULL != pelt->pwszName)
		{
		    CoTaskMemFree(pelt->pwszName);
		    pelt->pwszName = NULL;
		}
	    }
	}
    }
    return(myJetHResult(hr));
}


HRESULT
CCertDB::EnumerateClose(
    IN CERTSESSION *pcs,
    IN JET_TABLEID tableid)
{
    HRESULT hr;

    if (NULL == pcs)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    CSASSERT(IsValidJetTableId(tableid));
    CSASSERTTHREAD(pcs);
    hr = _dbgJetCloseTable(pcs->SesId, tableid);
    _JumpIfError(hr, error, "JetCloseTable");

error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::_BuildColumnIds(
    IN CERTSESSION *pcs,
    IN CHAR const *pszTableName,
    IN DBTABLE *pdt)
{
    HRESULT hr;
    JET_TABLEID tableid;
    JET_COLUMNDEF columndef;
    BOOL fOpen = FALSE;

    hr = _dbgJetOpenTable(
                   pcs->SesId,
                   pcs->DBId,
                   pszTableName,
                   NULL,
                   0,
                   0,
                   &tableid);
    _JumpIfError(hr, error, "JetOpenTable");
    fOpen = TRUE;

    CSASSERT(IsValidJetTableId(tableid));
    for ( ; NULL != pdt->pwszPropName; pdt++)
    {
        hr = _dbgJetGetColumnInfo(
			    pcs->SesId,
			    pcs->DBId,
			    pszTableName,
			    pdt->pszFieldName,
			    &columndef,
			    sizeof(columndef),
			    JET_ColInfo);
	if ((HRESULT) JET_errColumnNotFound == hr &&
	    (DBTF_SOFTFAIL & pdt->dwFlags))
	{
	    pdt->dwFlags |= DBTF_MISSING;
	    pdt->dbcolumnid = -1;

	    DBGPRINT((
		DBG_SS_CERTDB,
		"_BuildColumnIds: %hs.%hs Ignoring missing column\n",
		pszTableName,
		pdt->pszFieldName));
	    hr = S_OK;
	    continue;
	}
	_JumpIfError(hr, error, "JetGetColumnInfo");

        pdt->dbcolumnid = columndef.columnid;

        CSASSERT(
	    pdt->dbcoltyp == columndef.coltyp ||
	    (ISTEXTCOLTYP(pdt->dbcoltyp) && ISTEXTCOLTYP(columndef.coltyp)));

	if (JET_coltypText == pdt->dbcoltyp)
	{
	    CSASSERT(pdt->dwcbMax == pdt->dbcolumnMax);
	    CSASSERT(0 != pdt->dbcolumnMax);
	    CSASSERT(CB_DBMAXTEXT_MAXINTERNAL >= pdt->dbcolumnMax);
	}
	else if (JET_coltypLongText == pdt->dbcoltyp)
	{
	    CSASSERT(pdt->dwcbMax == pdt->dbcolumnMax);
	    CSASSERT(CB_DBMAXTEXT_MAXINTERNAL < pdt->dbcolumnMax);
	}
	else if (JET_coltypLongBinary == pdt->dbcoltyp)
	{
	    CSASSERT(pdt->dwcbMax == pdt->dbcolumnMax);
	    CSASSERT(0 != pdt->dbcolumnMax);
	}
	else if (JET_coltypDateTime == pdt->dbcoltyp)
	{
	    CSASSERT(sizeof(DATE) == pdt->dwcbMax);
	    CSASSERT(0 == pdt->dbcolumnMax);
	}
	else if (JET_coltypLong == pdt->dbcoltyp)
	{
	    CSASSERT(sizeof(LONG) == pdt->dwcbMax);
	    CSASSERT(0 == pdt->dbcolumnMax);
	}
	else
	{
	    DBGPRINT((
		DBG_SS_CERTDB,
		"_BuildColumnIds: %hs.%hs Unknown column type %u\n",
		pszTableName,
		pdt->pszFieldName,
		pdt->dbcoltyp));
	    CSASSERT(!"Unknown column type");
	}
	if (pdt->dwcbMax != columndef.cbMax)
	{
	    DBGPRINT((
		DBG_SS_CERTDB,
		"_BuildColumnIds: %hs.%hs length %u, expected %u\n",
		pszTableName,
		pdt->pszFieldName,
		columndef.cbMax,
		pdt->dwcbMax));

	    // max size can only be increased...

	    if (pdt->dwcbMax > columndef.cbMax)
	    {
		JET_DDLMAXCOLUMNSIZE jdmcs;

		jdmcs.szTable = const_cast<char *>(pszTableName);
		jdmcs.szColumn = const_cast<char *>(pdt->pszFieldName);
		jdmcs.cbMax = pdt->dwcbMax;

		hr = _dbgJetConvertDDL(
				pcs->SesId,
				pcs->DBId,
				opDDLConvIncreaseMaxColumnSize,
				&jdmcs,
				sizeof(jdmcs));
		_PrintIfError(hr, "JetConvertDDL");
		if (S_OK == hr)
		{
		    m_fDBRestart = TRUE;
		}
	    }
	}
	pdt->dbcolumnidOld = -1;
	if (chTEXTPREFIX == *pdt->pszFieldName ||
	    (DBTF_COLUMNRENAMED & pdt->dwFlags))
	{
	    char const *pszFieldName = &pdt->pszFieldName[1];
	    
	    if (DBTF_COLUMNRENAMED & pdt->dwFlags)
	    {
		pszFieldName += strlen(pszFieldName) + 1;
	    }
	    CSASSERT(
		chTEXTPREFIX != *pszTableName ||
		ISTEXTCOLTYP(columndef.coltyp));

	    hr = _dbgJetGetColumnInfo(
				pcs->SesId,
				pcs->DBId,
				pszTableName,
				pszFieldName,
				&columndef,
				sizeof(columndef),
				JET_ColInfo);
	    if (S_OK == hr)
	    {
		CSASSERT(
		    chTEXTPREFIX != *pszTableName ||
		    ISTEXTCOLTYP(columndef.coltyp));

		DBGPRINT((
		    DBG_SS_CERTDB,
		    "Found Old Column: %hs.%hs: %x\n",
		    pszTableName,
		    pszFieldName,
		    columndef.columnid));

		pdt->dwFlags |= DBTF_OLDCOLUMNID;
		pdt->dbcolumnidOld = columndef.columnid;
		m_fFoundOldColumns = TRUE;
	    }
	    hr = S_OK;
	}
    }

error:
    if (fOpen)
    {
	HRESULT hr2;

	hr2 = _dbgJetCloseTable(pcs->SesId, tableid);
	_PrintIfError(hr2, "JetCloseTable");
	if (S_OK == hr)
	{
	    hr = hr2;
	}
    }
    return(myJetHResult(hr));
}


HRESULT
CCertDB::_AddKeyLengthColumn(
    IN CERTSESSION *pcs,
    IN JET_TABLEID tableid,
    IN DWORD RowId,
    IN DBTABLE const *pdtPublicKey,
    IN DBTABLE const *pdtPublicKeyAlgorithm,
    IN DBTABLE const *pdtPublicKeyParameters,
    IN DBTABLE const *pdtPublicKeyLength,
    IN DBAUXDATA const *pdbaux,
    IN OUT BYTE **ppbBuf,
    IN OUT DWORD *pcbBuf)
{
    HRESULT hr;
    DWORD cb;
    DWORD KeyLength;
    CERT_PUBLIC_KEY_INFO PublicKeyInfo;

    ZeroMemory(&PublicKeyInfo, sizeof(PublicKeyInfo));

    DBGPRINT((
	    DBG_SS_CERTDBI,
	    "Converting %hs[%d].%hs\n",
	    pdbaux->pszTable,
	    RowId,
	    pdtPublicKeyLength->pszFieldName));

    cb = sizeof(KeyLength);
    hr = _RetrieveColumn(
		    pcs,
		    tableid,
		    pdtPublicKeyLength->dbcolumnid,
		    pdtPublicKeyLength->dbcoltyp,
		    &cb,
		    (BYTE *) &KeyLength);
    if (S_OK == hr)
    {
	goto error;		// already set -- skip this column
    }
    if (CERTSRV_E_PROPERTY_EMPTY != hr)
    {
	_JumpError(hr, error, "_RetrieveColumn");
    }

    // Fetch the public key algorithm ObjId & copy as ansi to alloc'd memory.

    hr = _RetrieveColumnBuffer(
		    pcs,
		    tableid,
		    pdtPublicKeyAlgorithm->dbcolumnid,
		    pdtPublicKeyAlgorithm->dbcoltyp,
		    &cb,
		    ppbBuf,
		    pcbBuf);
    if (CERTSRV_E_PROPERTY_EMPTY == hr)
    {
	hr = S_OK;
	goto error;		// No old data -- skip this column
    }
    _JumpIfErrorStr(
		hr,
		error,
		"_RetrieveColumnBuffer",
		pdtPublicKeyAlgorithm->pwszPropName);

    if (!ConvertWszToSz(
		&PublicKeyInfo.Algorithm.pszObjId,
		(WCHAR const *) *ppbBuf,
		-1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToSz(LogDir)");
    }

    // Fetch the public key algorithm paramaters, and copy to alloc'd memory.

    hr = _RetrieveColumnBuffer(
		    pcs,
		    tableid,
		    pdtPublicKeyParameters->dbcolumnid,
		    pdtPublicKeyParameters->dbcoltyp,
		    &PublicKeyInfo.Algorithm.Parameters.cbData,
		    ppbBuf,
		    pcbBuf);
    if (CERTSRV_E_PROPERTY_EMPTY == hr)
    {
	hr = S_OK;
	goto error;		// No old data -- skip this column
    }
    _JumpIfErrorStr(
		hr,
		error,
		"_RetrieveColumnBuffer",
		pdtPublicKeyParameters->pwszPropName);

    PublicKeyInfo.Algorithm.Parameters.pbData = (BYTE *) LocalAlloc(
				LMEM_FIXED,
				PublicKeyInfo.Algorithm.Parameters.cbData);
    if (NULL == PublicKeyInfo.Algorithm.Parameters.pbData)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToSz(LogDir)");
    }
    CopyMemory(
	    PublicKeyInfo.Algorithm.Parameters.pbData,
	    *ppbBuf,
	    PublicKeyInfo.Algorithm.Parameters.cbData);

    // Fetch the public key, and leave in dynamic buffer.

    hr = _RetrieveColumnBuffer(
		    pcs,
		    tableid,
		    pdtPublicKey->dbcolumnid,
		    pdtPublicKey->dbcoltyp,
		    &PublicKeyInfo.PublicKey.cbData,
		    ppbBuf,
		    pcbBuf);
    if (CERTSRV_E_PROPERTY_EMPTY == hr)
    {
	hr = S_OK;
	goto error;		// No old data -- skip this column
    }
    _JumpIfErrorStr(
		hr,
		error,
		"_RetrieveColumnBuffer",
		pdtPublicKey->pwszPropName);

    PublicKeyInfo.PublicKey.pbData = *ppbBuf;
    KeyLength = CertGetPublicKeyLength(X509_ASN_ENCODING, &PublicKeyInfo);

    // Store the key length in the new column
    
    hr = _SetColumn(
		pcs->SesId,
		tableid,
		pdtPublicKeyLength->dbcolumnid,
		sizeof(KeyLength),
		(BYTE const *) &KeyLength);
    _JumpIfErrorStr(hr, error, "_SetColumn", pdtPublicKeyLength->pwszPropName);

    DBGPRINT((
	DBG_SS_CERTDB,
	"Converted %hs[%d].%hs: %u\n",
	pdbaux->pszTable,
	RowId,
	pdtPublicKeyLength->pszFieldName,
	KeyLength));

error:
    if (NULL != PublicKeyInfo.Algorithm.pszObjId)
    {
	LocalFree(PublicKeyInfo.Algorithm.pszObjId);
    }
    if (NULL != PublicKeyInfo.Algorithm.Parameters.pbData)
    {
	LocalFree(PublicKeyInfo.Algorithm.Parameters.pbData);
    }
    return(hr);
}


HRESULT
CCertDB::_AddCallerName(
    IN CERTSESSION *pcs,
    IN JET_TABLEID tableid,
    IN DWORD RowId,
    IN DBTABLE const *pdtCallerName,
    IN DBTABLE const *pdtRequesterName,
    IN DBAUXDATA const *pdbaux,
    IN OUT BYTE **ppbBuf,
    IN OUT DWORD *pcbBuf)
{
    HRESULT hr;
    DWORD cb;

    DBGPRINT((
	    DBG_SS_CERTDBI,
	    "Converting %hs[%d].%hs\n",
	    pdbaux->pszTable,
	    RowId,
	    pdtCallerName->pszFieldName));

    cb = 0;
    hr = _RetrieveColumn(
		    pcs,
		    tableid,
		    pdtCallerName->dbcolumnid,
		    pdtCallerName->dbcoltyp,
		    &cb,
		    NULL);
    if (S_OK == hr)
    {
	goto error;		// already set -- skip this column
    }
    if (CERTSRV_E_PROPERTY_EMPTY != hr)
    {
	_JumpError(hr, error, "_RetrieveColumn");
    }

    // Fetch the ReqesterName

    hr = _RetrieveColumnBuffer(
		    pcs,
		    tableid,
		    pdtRequesterName->dbcolumnid,
		    pdtRequesterName->dbcoltyp,
		    &cb,
		    ppbBuf,
		    pcbBuf);
    if (CERTSRV_E_PROPERTY_EMPTY == hr)
    {
	hr = S_OK;
	goto error;		// No old data -- skip this column
    }
    _JumpIfErrorStr(
		hr,
		error,
		"_RetrieveColumnBuffer",
		pdtRequesterName->pwszPropName);

    // Store the RequesterName as the CallerName in the new column
    
    hr = _SetColumn(
		pcs->SesId,
		tableid,
		pdtCallerName->dbcolumnid,
		cb,
		*ppbBuf);
    _JumpIfErrorStr(hr, error, "_SetColumn", pdtCallerName->pwszPropName);

    DBGPRINT((
	DBG_SS_CERTDB,
	"Converted %hs[%d].%hs: %ws\n",
	pdbaux->pszTable,
	RowId,
	pdtCallerName->pszFieldName,
	*ppbBuf));

error:
    return(hr);
}


HRESULT
CCertDB::_ConvertColumnData(
    IN CERTSESSION *pcs,
    IN JET_TABLEID tableid,
    IN DWORD RowId,
    IN DBTABLE const *pdt,
    IN DBAUXDATA const *pdbaux,
    IN OUT BYTE **ppbBuf,
    IN OUT DWORD *pcbBuf)
{
    HRESULT hr;
    WCHAR *pwszNew = NULL;
    BYTE const *pbNew;
    DWORD cb;

    DBGPRINT((
	    DBG_SS_CERTDBI,
	    "Converting %hs[%d].%hs:\n",
	    pdbaux->pszTable,
	    RowId,
	    pdt->pszFieldName));

    // Fetch old column.  Grows the buffer if necessary.

    hr = _RetrieveColumnBuffer(
		    pcs,
		    tableid,
		    pdt->dbcolumnidOld,
		    pdt->dbcoltyp,
		    &cb,
		    ppbBuf,
		    pcbBuf);
    if (CERTSRV_E_PROPERTY_EMPTY == hr)
    {
	hr = S_OK;
	goto error;		// No old data -- skip this column
    }
    _JumpIfErrorStr(hr, error, "_RetrieveColumnBuffer", pdt->pwszPropName);

    if (DBTF_COLUMNRENAMED & pdt->dwFlags)
    {
	pbNew = *ppbBuf;
    }
    else
    {
	if (!ConvertSzToWsz(&pwszNew, (char *) *ppbBuf, -1))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "ConvertSzToWsz");
	}
	pbNew = (BYTE const *) pwszNew;
	cb = wcslen(pwszNew) * sizeof(WCHAR);
    }

    // Store the converted string in the Unicode column
    
    hr = _SetColumn(pcs->SesId, tableid, pdt->dbcolumnid, cb, pbNew);
    _JumpIfErrorStr(hr, error, "_SetColumn", pdt->pwszPropName);

    if (JET_coltypLong != pdt->dbcoltyp)
    {
	// Clear out the old column

	hr = _SetColumn(pcs->SesId, tableid, pdt->dbcolumnidOld, 0, NULL);
	_JumpIfErrorStr(hr, error, "_SetColumn(Clear old)", pdt->pwszPropName);
    }

    DBGPRINT((
	DBG_SS_CERTDB,
	"Converted %hs[%d].%hs: %ws\n",
	pdbaux->pszTable,
	RowId,
	pdt->pszFieldName,
	ISTEXTCOLTYP(pdt->dbcoltyp)? (WCHAR const *) pbNew : L""));
    if (!ISTEXTCOLTYP(pdt->dbcoltyp))
    {
	DBGDUMPHEX((DBG_SS_CERTDB, DH_NOADDRESS, pbNew, cb));
    }

error:
    if (NULL != pwszNew)
    {
	LocalFree(pwszNew);
    }
    return(hr);
}


DBTABLE *
dbFindColumn(
    IN DBTABLE *adt,
    IN char const *pszFieldName)
{
    DBTABLE *pdt;
    DBTABLE *pdtRet = NULL;

    for (pdt = adt; NULL != pdt->pwszPropName; pdt++)
    {
	if (0 == _stricmp(pszFieldName, pdt->pszFieldName))
	{
	    pdtRet = pdt;
	    break;
	}
    }
    return(pdtRet);
}


HRESULT
CCertDB::_ConvertOldColumnData(
    IN CERTSESSION *pcs,
    IN CHAR const *pszTableName,
    IN DBAUXDATA const *pdbaux,
    IN DBTABLE *adt)
{
    HRESULT hr;
    HRESULT hr2;
    JET_TABLEID tableid;
    JET_COLUMNDEF columndef;
    BOOL fOpen = FALSE;
    BOOL fTransacted = FALSE;
    DBTABLE *pdt;
    DWORD RowId;
    DWORD cb;
    BYTE *pbBuf = NULL;
    DWORD cbBuf = 0;
    BOOL fZeroIssuerNameId = FALSE;
    DWORD IssuerNameId;
    DBTABLE *pdtPublicKeyLength = NULL;
    DBTABLE *pdtPublicKey;
    DBTABLE *pdtPublicKeyAlgorithm;
    DBTABLE *pdtPublicKeyParameters;
    DBTABLE *pdtCallerName = NULL;
    DBTABLE *pdtRequesterName;

    hr = _dbgJetOpenTable(
                   pcs->SesId,
                   pcs->DBId,
                   pszTableName,
                   NULL,
                   0,
                   0,
                   &tableid);
    _JumpIfError(hr, error, "JetOpenTable");

    fOpen = TRUE;

    // Step through the RowId index for this table.

    CSASSERT(IsValidJetTableId(tableid));
    hr = _dbgJetSetCurrentIndex2(
			    pcs->SesId,
			    tableid,
			    pdbaux->pszRowIdIndex,
			    JET_bitMoveFirst);
    _JumpIfError(hr, error, "JetSetCurrentIndex2");

    if (NULL != pdbaux->pdtIssuerNameId)
    {
	cb = sizeof(IssuerNameId);
	hr = _RetrieveColumn(
			pcs,
			tableid,
			pdbaux->pdtIssuerNameId->dbcolumnid,
			pdbaux->pdtIssuerNameId->dbcoltyp,
			&cb,
			(BYTE *) &IssuerNameId);
	if (CERTSRV_E_PROPERTY_EMPTY == hr)
	{
	    fZeroIssuerNameId = TRUE;
	}
        else
        {
            // swallow error if empty database

	    _PrintIfErrorStr2(
		    hr,
		    "_RetrieveColumn",
		    pdbaux->pdtIssuerNameId->pwszPropName,
		    myJetHResult(JET_errNoCurrentRecord));
	}
    }

    pdtPublicKeyLength = dbFindColumn(adt, szPUBLICKEYLENGTH);
    if (NULL != pdtPublicKeyLength)
    {
	pdtPublicKey = dbFindColumn(adt, szPUBLICKEY);
	pdtPublicKeyAlgorithm = dbFindColumn(adt, szPUBLICKEYALGORITHM);
	pdtPublicKeyParameters = dbFindColumn(adt, szPUBLICKEYPARAMS);
	if (NULL == pdtPublicKey ||
	    NULL == pdtPublicKeyAlgorithm ||
	    NULL == pdtPublicKeyParameters)
	{
	    pdtPublicKeyLength = NULL;
	}
	else
	{
	    hr = _RetrieveColumn(
			    pcs,
			    tableid,
			    pdtPublicKeyLength->dbcolumnid,
			    pdtPublicKeyLength->dbcoltyp,
			    &cb,
			    NULL);
	    if (CERTSRV_E_PROPERTY_EMPTY != hr)
	    {
		pdtPublicKeyLength = NULL;
	    }
	}
    }

    pdtCallerName = dbFindColumn(adt, szCALLERNAME);
    if (NULL != pdtCallerName)
    {
	pdtRequesterName = dbFindColumn(adt, szREQUESTERNAME);
	if (NULL == pdtRequesterName)
	{
	    pdtCallerName = NULL;
	}
	else
	{
	    // Update all rows only if the first row's CallerName is empty
	    // and the first row's RequesterName is NOT empty.

	    hr = _RetrieveColumn(
			    pcs,
			    tableid,
			    pdtCallerName->dbcolumnid,
			    pdtCallerName->dbcoltyp,
			    &cb,
			    NULL);
	    if (CERTSRV_E_PROPERTY_EMPTY != hr)
	    {
		pdtCallerName = NULL;
	    }
	    else
	    {
		hr = _RetrieveColumn(
				pcs,
				tableid,
				pdtRequesterName->dbcolumnid,
				pdtRequesterName->dbcoltyp,
				&cb,
				NULL);
		if (S_OK != hr)
		{
		    pdtCallerName = NULL;
		}
	    }
	}
    }

    if (NULL != pdtPublicKeyLength ||
	NULL != pdtCallerName ||
	m_fFoundOldColumns ||
	fZeroIssuerNameId)
    {
	DBGPRINT((DBG_SS_CERTDB, "Updating %hs table.\n", pdbaux->pszTable));

	while (TRUE)
	{
	    // Fetch RowId from the table.

	    cb = sizeof(pcs->RowId);
	    hr = _RetrieveColumn(
			    pcs,
			    tableid,
			    pdbaux->pdtRowId->dbcolumnid,
			    pdbaux->pdtRowId->dbcoltyp,
			    &cb,
			    (BYTE *) &RowId);
	    if (S_OK != hr)
	    {
		if (myJetHResult(JET_errNoCurrentRecord) == hr)
		{
		    hr = S_OK;	// Table is empty
		    break;
		}
		_JumpError(hr, error, "_RetrieveColumn");
	    }

	    hr = _dbgJetBeginTransaction(pcs->SesId);
	    _JumpIfError(hr, error, "JetBeginTransaction");

	    fTransacted = TRUE;

	    // Transact each row.
	    //
	    // If fZeroIssuerNameId, set EMPTY IssuerNameId columns to zero.
	    //
	    // if the first row's public key length column was empty
	    //  Read the public key column, compute the size and store it
	    //
	    // if the first row's CallerName was empty
	    //  Copy RequesterName to CallerName
	    //
	    // if m_fFoundOldColumns
	    //  For each text column, do the following:
	    //   Retrieve old string from the old column,
	    //   Convert to Unicode (if old column was Ansi),
	    //   Write the Unicode string to the new column,
	    //   Set the old column to NULL.

	    hr = _dbgJetPrepareUpdate(
				pcs->SesId,
				tableid,
				JET_prepReplace);
	    _JumpIfError(hr, error, "JetPrepareUpdate");

	    if (fZeroIssuerNameId)
	    {
		cb = sizeof(IssuerNameId);
		hr = _RetrieveColumn(
				pcs,
				tableid,
				pdbaux->pdtIssuerNameId->dbcolumnid,
				pdbaux->pdtIssuerNameId->dbcoltyp,
				&cb,
				(BYTE *) &IssuerNameId);
		if (CERTSRV_E_PROPERTY_EMPTY != hr)
		{
		    _JumpIfError(hr, error, "_RetrieveColumn");
		}
		else
		{
		    // Only set EMPTY columns!

		    IssuerNameId = 0;

		    hr = _SetColumn(
				pcs->SesId,
				tableid,
				pdbaux->pdtIssuerNameId->dbcolumnid,
				sizeof(IssuerNameId),
				(BYTE const *) &IssuerNameId);
		    _JumpIfError(hr, error, "_SetColumn");
		}
	    }

	    // Convert old columns first.
	    
	    if (m_fFoundOldColumns)
	    {
		for (pdt = adt; NULL != pdt->pwszPropName; pdt++)
		{
		    if (DBTF_OLDCOLUMNID & pdt->dwFlags)
		    {
			hr = _ConvertColumnData(
					pcs,
					tableid,
					RowId,
					pdt,
					pdbaux,
					&pbBuf,
					&cbBuf);
			_JumpIfErrorStr(
				hr,
				error,
				"_ConvertColumnData",
				pdt->pwszPropName);
		    }
		}
	    }

	    // Now compute new columns.

	    if (NULL != pdtPublicKeyLength)
	    {
		hr = _AddKeyLengthColumn(
				    pcs,
				    tableid,
				    RowId,
				    pdtPublicKey,
				    pdtPublicKeyAlgorithm,
				    pdtPublicKeyParameters,
				    pdtPublicKeyLength,
				    pdbaux,
				    &pbBuf,
				    &cbBuf);
		_JumpIfError(hr, error, "_AddKeyLengthColumn");
	    }
	    if (NULL != pdtCallerName)
	    {
		hr = _AddCallerName(
				pcs,
				tableid,
				RowId,
				pdtCallerName,
				pdtRequesterName,
				pdbaux,
				&pbBuf,
				&cbBuf);
		_JumpIfError(hr, error, "_AddCallerName");
	    }

	    // Done with this row.

	    hr = _dbgJetUpdate(pcs->SesId, tableid, NULL, 0, NULL);
	    _JumpIfError(hr, error, "JetUpdate");

	    hr = _dbgJetCommitTransaction(pcs->SesId, 0);
	    _JumpIfError(hr, error, "JetCommitTransaction");

	    fTransacted = FALSE;

	    hr = _dbgJetMove(pcs->SesId, tableid, JET_MoveNext, 0);
	    if ((HRESULT) JET_errNoCurrentRecord == hr)
	    {
		hr = S_OK;
		break;
	    }
	}
    }

    if (m_fFoundOldColumns)
    {
	hr = _dbgJetBeginTransaction(pcs->SesId);
	_JumpIfError(hr, error, "JetBeginTransaction");

	fTransacted = TRUE;

	for (pdt = adt; NULL != pdt->pwszPropName; pdt++)
	{
	    char const *pszFieldName;
	    
	    if (0 == (DBTF_OLDCOLUMNID & pdt->dwFlags))
	    {
		continue;
	    }

	    pszFieldName = &pdt->pszFieldName[1];
	    if (DBTF_COLUMNRENAMED & pdt->dwFlags)
	    {
		pszFieldName += strlen(pszFieldName) + 1;
	    }
	    DBGPRINT((
		    DBG_SS_CERTDB,
		    "Deleting column %hs.%hs\n",
		    pdbaux->pszTable,
		    pszFieldName));

	    hr = _dbgJetDeleteColumn(pcs->SesId, tableid, pszFieldName);
	    _PrintIfError(hr, "JetDeleteColumn");
	    if (JET_errColumnInUse == hr)
	    {
		hr = S_OK;	// we'll delete the column next time we restart
	    }
	    _JumpIfError(hr, error, "JetDeleteColumn");
	}

	hr = _dbgJetCommitTransaction(pcs->SesId, 0);
	_JumpIfError(hr, error, "JetCommitTransaction");

	fTransacted = FALSE;
    }
    hr = S_OK;

error:
    if (NULL != pbBuf)
    {
	LocalFree(pbBuf);
    }
    if (fTransacted)
    {
	hr2 = _Rollback(pcs);
	_PrintIfError(hr2, "_Rollback");
	if (S_OK == hr)
	{
	    hr = hr2;
	}
    }
    if (fOpen)
    {
	hr2 = _dbgJetCloseTable(pcs->SesId, tableid);
	_PrintIfError(hr2, "JetCloseTable");
	if (S_OK == hr)
	{
	    hr = hr2;
	}
    }
    return(myJetHResult(hr));
}


HRESULT
CCertDB::_SetColumn(
    IN JET_SESID SesId,
    IN JET_TABLEID tableid,
    IN JET_COLUMNID columnid,
    IN DWORD cbProp,
    OPTIONAL IN BYTE const *pbProp)
{
    HRESULT hr;

    CSASSERT(IsValidJetTableId(tableid));
    hr = _dbgJetSetColumn(SesId, tableid, columnid, pbProp, cbProp, 0, NULL);
    if ((HRESULT) JET_wrnColumnMaxTruncated == hr)
    {
	hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
    }
    _JumpIfError(hr, error, "JetSetColumn");

error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::SetAttribute(
    IN CERTSESSION *pcs,
    IN WCHAR const *pwszAttributeName,
    IN DWORD cbValue,
    IN BYTE const *pbValue)	// OPTIONAL
{
    return(_SetIndirect(
		    pcs,
		    &pcs->aTable[CSTI_ATTRIBUTE],
		    pwszAttributeName,
		    NULL,
		    cbValue,
		    pbValue));
}


HRESULT
CCertDB::GetAttribute(
    IN     CERTSESSION *pcs,
    IN     WCHAR const *pwszAttributeName,
    IN OUT DWORD *pcbValue,
    OUT    BYTE *pbValue)	// OPTIONAL
{
    return(_GetIndirect(
		    pcs,
		    &pcs->aTable[CSTI_ATTRIBUTE],
		    pwszAttributeName,
		    NULL,
		    pcbValue,
		    pbValue));
}


HRESULT
CCertDB::SetExtension(
    IN CERTSESSION *pcs,
    IN WCHAR const *pwszExtensionName,
    IN DWORD dwExtFlags,
    IN DWORD cbValue,
    IN BYTE const *pbValue)	// OPTIONAL
{
    return(_SetIndirect(
		    pcs,
		    &pcs->aTable[CSTI_EXTENSION],
		    pwszExtensionName,
		    &dwExtFlags,
		    cbValue,
		    pbValue));
}


HRESULT
CCertDB::GetExtension(
    IN     CERTSESSION *pcs,
    IN     WCHAR const *pwszExtensionName,
    OUT    DWORD *pdwExtFlags,
    IN OUT DWORD *pcbValue,
    OUT    BYTE *pbValue)	// OPTIONAL
{
    return(_GetIndirect(
		    pcs,
		    &pcs->aTable[CSTI_EXTENSION],
		    pwszExtensionName,
		    pdwExtFlags,
		    pcbValue,
		    pbValue));
}


HRESULT
CCertDB::_JetSeekFromRestriction(
    IN CERTVIEWRESTRICTION const *pcvr,
    IN DWORD dwPosition,
    OUT DBSEEKDATA *pSeekData)
{
    HRESULT hr;
    BOOL fAscend;
    DBSEEKDATA SeekFirst;	// seek to first element matching restriction
    DBSEEKDATA SeekLast;	// seek to last element matching restriction
    DBSEEKDATA SeekIndexFirst;	// seek to first index element
    DBSEEKDATA SeekIndexLast;	// seek to last index element
    DBSEEKDATA *pSeek;
    BOOL fValid;

    // SeekLast.SeekFlags: where to seek to retrieve end-of-range key
    // SeekLast.grbitSeekRange: where to set the cursor initially: move or seek
    // SeekLast.grbitRange: other flags to be ingested while setting range:
    // (bitRange UpperLimit, Inclusive)

#if DBG_CERTSRV
    DumpRestriction(DBG_SS_CERTDBI, 0, pcvr);
#endif

    fAscend = (CVR_SORT_DESCEND != pcvr->SortOrder);
    CSASSERT(
	CVR_SORT_NONE == pcvr->SortOrder ||
	CVR_SORT_ASCEND == pcvr->SortOrder ||
	CVR_SORT_DESCEND == pcvr->SortOrder);

    ZeroMemory(&SeekFirst, sizeof(SeekFirst));
    ZeroMemory(&SeekLast, sizeof(SeekLast));
    ZeroMemory(&SeekIndexFirst, sizeof(SeekIndexFirst));
    ZeroMemory(&SeekIndexLast, sizeof(SeekIndexLast));

    switch (CVR_SEEK_MASK & pcvr->SeekOperator)
    {
	case CVR_SEEK_EQ:
	    if (fAscend)
	    {
		SeekFirst.SeekFlags = CST_SEEKUSECURRENT |
					CST_SEEKNOTMOVE |
					CST_SEEKINDEXRANGE;

		SeekFirst.grbitSeekRange = JET_bitSeekEQ;
		SeekFirst.grbitInitial = JET_bitSeekEQ;

		SeekFirst.grbitRange = JET_bitRangeUpperLimit |
					    JET_bitRangeInclusive;
        
		SeekLast.SeekFlags = CST_SEEKINDEXRANGE;
		SeekLast.grbitSeekRange = JET_bitSeekGT;
		SeekLast.grbitInitial = JET_MovePrevious;
		SeekLast.grbitRange = JET_bitRangeUpperLimit;
	    }
	    else
	    {
		SeekFirst.SeekFlags = CST_SEEKNOTMOVE | CST_SEEKINDEXRANGE;
		SeekFirst.grbitSeekRange = JET_bitSeekEQ;
		SeekFirst.grbitInitial = JET_bitSeekGT;
		SeekFirst.grbitRange = JET_bitRangeInclusive;

		SeekLast.SeekFlags = CST_SEEKINDEXRANGE;
		SeekLast.grbitSeekRange = JET_bitSeekEQ;
		SeekLast.grbitInitial = JET_MovePrevious;
		SeekLast.grbitRange = JET_bitRangeInclusive;
	    }
	    break;

	case CVR_SEEK_LT:
	    if (fAscend)
	    {
		SeekFirst.SeekFlags = CST_SEEKUSECURRENT | CST_SEEKINDEXRANGE;
		SeekFirst.grbitSeekRange = JET_bitSeekGE;
		SeekFirst.grbitInitial = JET_MoveFirst;
		SeekFirst.grbitRange = JET_bitRangeUpperLimit;

		SeekLast.SeekFlags = CST_SEEKINDEXRANGE;
		SeekLast.grbitSeekRange = JET_bitSeekGE;
		SeekLast.grbitInitial = JET_MovePrevious;
		SeekLast.grbitRange = JET_bitRangeUpperLimit;
	    }
	    else
	    {
		SeekFirst.SeekFlags = CST_SEEKNOTMOVE;
		SeekFirst.grbitInitial = JET_bitSeekGE;

		//SeekLast.SeekFlags = 0; // not CST_SEEKUSECURRENT
		SeekLast.grbitInitial = JET_MoveFirst;

		SeekIndexFirst.SeekFlags = CST_SEEKUSECURRENT;
		SeekIndexFirst.grbitInitial = JET_MoveLast;
	    }
	    break;

	case CVR_SEEK_LE:
	    if (fAscend)
	    {
		SeekFirst.SeekFlags = CST_SEEKUSECURRENT | CST_SEEKINDEXRANGE;
		SeekFirst.grbitSeekRange = JET_bitSeekGT;
		SeekFirst.grbitInitial = JET_MoveFirst;
		SeekFirst.grbitRange = JET_bitRangeUpperLimit;

		SeekLast.SeekFlags = CST_SEEKINDEXRANGE; // !CST_SEEKUSECURRENT
		SeekLast.grbitSeekRange = JET_bitSeekGT;
		SeekLast.grbitInitial = JET_MovePrevious;
		SeekLast.grbitRange = JET_bitRangeUpperLimit;
	    }
	    else
	    {
		SeekFirst.SeekFlags = CST_SEEKNOTMOVE;
		SeekFirst.grbitInitial = JET_bitSeekGT;

		//SeekLast.SeekFlags = 0; // not CST_SEEKUSECURRENT
		SeekLast.grbitInitial = JET_MoveFirst;

		SeekIndexFirst.SeekFlags = CST_SEEKUSECURRENT;
		SeekIndexFirst.grbitInitial = JET_MoveLast;
	    }
	    break;

	case CVR_SEEK_GE:
	    if (fAscend)
	    {
		SeekFirst.SeekFlags = CST_SEEKUSECURRENT | CST_SEEKNOTMOVE;
		SeekFirst.grbitInitial = JET_bitSeekGE;

		//SeekLast.SeekFlags = 0; // not CST_SEEKUSECURRENT
		SeekLast.grbitInitial = JET_MoveLast;
	    }
	    else
	    {
		SeekFirst.SeekFlags = CST_SEEKUSECURRENT | CST_SEEKINDEXRANGE;
		SeekFirst.grbitSeekRange = JET_bitSeekLT;
		SeekFirst.grbitInitial = JET_MoveLast;
		// Implied: SeekFirst.grbitRange = JET_bitRangeLowerLimit;

		SeekLast.SeekFlags = CST_SEEKNOTMOVE;
		SeekLast.grbitInitial = JET_bitSeekLT;

		SeekIndexLast.SeekFlags = CST_SEEKUSECURRENT;
		SeekIndexLast.grbitInitial = JET_MoveFirst;
	    }
	    break;

	case CVR_SEEK_GT:
	    if (fAscend)
	    {
		SeekFirst.SeekFlags = CST_SEEKUSECURRENT | CST_SEEKNOTMOVE;
		SeekFirst.grbitInitial = JET_bitSeekGT;

		//SeekLast.SeekFlags = 0; // not CST_SEEKUSECURRENT
		SeekLast.grbitInitial = JET_MoveLast;
	    }
	    else
	    {
		SeekFirst.SeekFlags = CST_SEEKUSECURRENT | CST_SEEKINDEXRANGE;
		SeekFirst.grbitSeekRange = JET_bitSeekLE;
		SeekFirst.grbitInitial = JET_MoveLast;
		// Implied: SeekFirst.grbitRange = JET_bitRangeLowerLimit;

		SeekLast.SeekFlags = CST_SEEKNOTMOVE;
		SeekLast.grbitInitial = JET_bitSeekLE;

		SeekIndexLast.SeekFlags = CST_SEEKUSECURRENT;
		SeekIndexLast.grbitInitial = JET_MoveFirst;
	    }
	    break;

	case CVR_SEEK_NONE:
	    if (fAscend)
	    {
		SeekFirst.SeekFlags = CST_SEEKUSECURRENT;
		SeekFirst.grbitInitial = JET_MoveFirst;

		//SeekLast.SeekFlags = 0; // not CST_SEEKUSECURRENT
		SeekLast.grbitInitial = JET_MoveLast;
	    }
	    else
	    {
		SeekFirst.SeekFlags = CST_SEEKUSECURRENT;
		SeekFirst.grbitInitial = JET_MoveLast;

		//SeekLast.SeekFlags = 0; // not CST_SEEKUSECURRENT
		SeekLast.grbitInitial = JET_MoveFirst;
	    }
	    break;

	default:
	    CSASSERT(!"bad pcvr->SeekOperator"); // shouldn't get this far
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Seek value");
    }

    fValid = TRUE;
    switch (dwPosition)
    {
	case SEEKPOS_FIRST:
	    pSeek = &SeekFirst;
	    break;

	case SEEKPOS_LAST:
	    pSeek = &SeekLast;
	    break;

	case SEEKPOS_INDEXFIRST:
	    pSeek = &SeekIndexFirst;
	    fValid = 0 != pSeek->SeekFlags;
	    break;

	case SEEKPOS_INDEXLAST:
	    pSeek = &SeekIndexLast;
	    fValid = 0 != pSeek->SeekFlags;
	    break;

	default:
	    CSASSERT(!"bad dwPosition"); // shouldn't get this far
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "dwPosition value");
    }
    if (!fValid)
    {
	// For this SeekOperator, if seeking to the first or last matching
	// restriction failed, there's no point in seeking to the index end.

	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpError2(hr, error, "pSeek->SeekFlags", hr);
    }
    *pSeekData = *pSeek;		// structure copy
    if (fAscend)
    {
        pSeekData->SeekFlags |= CST_SEEKASCEND;
    }

    hr = S_OK;
    DBGPRINT((
	DBG_SS_CERTDBI,
	"_JetSeekFromRestriction: SeekFlags=%ws, grbitStart=%ws\n",
	wszCSTFlags(pSeekData->SeekFlags),
	(CST_SEEKNOTMOVE & pSeekData->SeekFlags)?
		wszSeekgrbit(pSeekData->grbitInitial) :
		wszMovecrow(pSeekData->grbitInitial)));

    if (CST_SEEKINDEXRANGE & pSeekData->SeekFlags)
    {
	DBGPRINT((
	    DBG_SS_CERTDBI,
	    "_JetSeekFromRestriction: grbitSeekRange=%ws, grbitRange=%ws\n",
	    wszSeekgrbit(pSeekData->grbitSeekRange),
	    wszSetIndexRangegrbit(pSeekData->grbitRange)));
    }

error:
    return(hr);
}


HRESULT
CCertDB::_OpenTable(
    IN CERTSESSION *pcs,
    IN DBAUXDATA const *pdbaux,
    IN CERTVIEWRESTRICTION const *pcvr,
    IN OUT CERTSESSIONTABLE *pTable)
{
    HRESULT hr;
    DBTABLE const *pdt;
    BOOL fOpened = FALSE;

    hr = _MapPropIdIndex(pcvr->ColumnIndex, &pdt, NULL);
    _JumpIfError(hr, error, "_MapPropIdIndex");

    if (NULL == pdt->pszIndexName)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Column not indexed");
    }

    if (!IsValidJetTableId(pTable->TableId))
    {
	CSASSERTTHREAD(pcs);
	hr = _dbgJetOpenTable(
			   pcs->SesId,
			   pcs->DBId,
			   pdbaux->pszTable,
			   NULL,
			   0,
			   0,
			   &pTable->TableId);
	_JumpIfError(hr, error, "JetOpenTable");

	fOpened = TRUE;

	// Find RowId and/or Named column.
	// It's more efficient to pass NULL for primary index name.

	CSASSERTTHREAD(pcs);
	hr = _dbgJetSetCurrentIndex2(
				pcs->SesId,
				pTable->TableId,
				(DBTF_INDEXPRIMARY & pdt->dwFlags)?
				    NULL : pdt->pszIndexName,
				JET_bitMoveFirst);
	_JumpIfError(hr, error, "JetSetCurrentIndex2");

	DBGPRINT((
		DBG_SS_CERTDBI,
		"_OpenTable Table=%hs, Index=%hs\n",
		pdbaux->pszTable,
		pdt->pszIndexName));

    }
    hr = _SeekTable(
		pcs,
		pTable->TableId,
		pcvr,
		pdt,
		SEEKPOS_FIRST,
		&pTable->TableFlags
		DBGPARM(pdbaux));
    _JumpIfError2(hr, error, "_SeekTable", S_FALSE);

error:
    if (S_OK != hr && S_FALSE != hr && fOpened)
    {
	if (IsValidJetTableId(pTable->TableId))
	{
	    HRESULT hr2;

            CSASSERTTHREAD(pcs);
	    hr2 = _dbgJetCloseTable(pcs->SesId, pTable->TableId);
	    _PrintIfError(hr2, "JetCloseTable");
	}
	ZeroMemory(pTable, sizeof(*pTable));
    }
    return(myJetHResult(hr));
}


HRESULT
CCertDB::_SetIndirect(
    IN CERTSESSION *pcs,
    IN OUT CERTSESSIONTABLE *pTable,
    IN WCHAR const *pwszNameValue,
    OPTIONAL IN DWORD const *pdwExtFlags,
    IN DWORD cbValue,
    OPTIONAL IN BYTE const *pbValue)
{
    HRESULT hr;
    DBAUXDATA const *pdbaux;
    BOOL fExisting = FALSE;
    BOOL fDelete;
    CERTVIEWRESTRICTION cvr;
    
    if (NULL == pcs || NULL == pwszNameValue)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL parm");
    }

    fDelete = NULL == pbValue;
    if (NULL == pdwExtFlags)
    {
        pdbaux = &g_dbauxAttributes;
        cvr.ColumnIndex = DTI_ATTRIBUTETABLE | DTA_ATTRIBUTENAME;
    }
    else
    {
	if (0 != *pdwExtFlags)
	{
	    fDelete = FALSE;
	}
        pdbaux = &g_dbauxExtensions;
        cvr.ColumnIndex = DTI_EXTENSIONTABLE | DTE_EXTENSIONNAME;
    }
    DBGPRINT((
	    DBG_SS_CERTDBI,
	    "IN: _SetIndirect(%hs.%ws) cb = %x%ws\n",
	    pdbaux->pszTable,
	    pwszNameValue,
	    cbValue,
	    fDelete? L" DELETE" : L""));
    
    cvr.SeekOperator = CVR_SEEK_EQ;
    cvr.SortOrder = CVR_SORT_NONE;
    cvr.cbValue = wcslen(pwszNameValue) * sizeof(WCHAR);
    cvr.pbValue = (BYTE *) pwszNameValue;
    
    hr = _OpenTable(pcs, pdbaux, &cvr, pTable);
    if (S_FALSE != hr)
    {
	_JumpIfError(hr, error, "_OpenTable");

	fExisting = TRUE;
    }
    _PrintIfError2(hr, "_OpenTable", S_FALSE);
    
    if (fDelete)
    {
        if (fExisting)
	{
	    CSASSERTTHREAD(pcs);
	    hr = _dbgJetDelete(pcs->SesId, pTable->TableId);
	    _JumpIfError(hr, error, "JetDelete");
	}
    }
    else
    {
	CSASSERTTHREAD(pcs);
	hr = _dbgJetPrepareUpdate(
			    pcs->SesId,
			    pTable->TableId,
			    !fExisting? JET_prepInsert : JET_prepReplace);
	_JumpIfError(hr, error, "JetPrepareUpdate");
    
	if (!fExisting)
	{
	    // No existing row -- insert a new one:

	    // Set RowId

	    hr = _SetColumn(
			pcs->SesId,
			pTable->TableId,
			pdbaux->pdtRowId->dbcolumnid,
			sizeof(pcs->RowId),
			(BYTE const *) &pcs->RowId);
	    _JumpIfError(hr, error, "_SetColumn");
	    
	    
	    // Set row's name column

	    hr = _SetColumn(
			pcs->SesId,
			pTable->TableId,
			pdbaux->pdtName->dbcolumnid,
			wcslen(pwszNameValue)*sizeof(WCHAR), //cch,
			(BYTE const *) pwszNameValue /*szTmp*/);
	    _JumpIfError(hr, error, "_SetColumn");
	    
	}
    
	if (NULL != pdwExtFlags)
	{
	    // Set or update flags
	    
	    hr = _SetColumn(
			pcs->SesId,
			pTable->TableId,
			pdbaux->pdtFlags->dbcolumnid,
			sizeof(*pdwExtFlags),
			(BYTE const *) pdwExtFlags);
	    _JumpIfError(hr, error, "_SetColumn");
	}
	
	
	// Set or update value
	
	hr = _SetColumn(
		    pcs->SesId,
		    pTable->TableId,
		    pdbaux->pdtValue->dbcolumnid,
		    cbValue,
		    pbValue);
	_JumpIfError(hr, error, "_SetColumn");
	
	CSASSERTTHREAD(pcs);
	hr = _dbgJetUpdate(pcs->SesId, pTable->TableId, NULL, 0, NULL);
	_JumpIfError(hr, error, "JetUpdate");
    }
    
error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::_GetIndirect(
    IN CERTSESSION *pcs,
    IN OUT CERTSESSIONTABLE *pTable,
    IN WCHAR const *pwszNameValue,
    OPTIONAL OUT DWORD *pdwExtFlags,
    IN OUT DWORD *pcbValue,
    OPTIONAL OUT BYTE *pbValue)
{
    HRESULT hr;
    DBAUXDATA const *pdbaux;
    CERTSESSIONTABLE Table;
    CERTVIEWRESTRICTION cvr;

    if (NULL == pcs || NULL == pwszNameValue || NULL == pcbValue)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (NULL == pdwExtFlags)
    {
	pdbaux = &g_dbauxAttributes;
	cvr.ColumnIndex = DTI_ATTRIBUTETABLE | DTA_ATTRIBUTENAME;
    }
    else
    {
	pdbaux = &g_dbauxExtensions;
	cvr.ColumnIndex = DTI_EXTENSIONTABLE | DTE_EXTENSIONNAME;
    }
    DBGPRINT((
	    DBG_SS_CERTDBI,
	    "IN: _GetIndirect(%hs.%ws) cb = %x\n",
	    pdbaux->pszTable,
	    pwszNameValue,
	    *pcbValue));

    cvr.SeekOperator = CVR_SEEK_EQ;
    cvr.SortOrder = CVR_SORT_NONE;
    cvr.cbValue = wcslen(pwszNameValue) * sizeof(WCHAR);
    cvr.pbValue = (BYTE *) pwszNameValue;

    hr = _OpenTable(pcs, pdbaux, &cvr, pTable);
    if (S_FALSE == hr)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
    }
    _JumpIfError2(hr, error, "_OpenTable", CERTSRV_E_PROPERTY_EMPTY);

    if (NULL != pdwExtFlags)
    {
	DWORD cb;

	// Get flags column

	cb = sizeof(*pdwExtFlags);
	hr = _RetrieveColumn(
			pcs,
			pTable->TableId,
			pdbaux->pdtFlags->dbcolumnid,
			pdbaux->pdtFlags->dbcoltyp,
			&cb,
			(BYTE *) pdwExtFlags);
	_JumpIfError(hr, error, "_RetrieveColumn");

	DBGPRINT((
		DBG_SS_CERTDBI,
		"_GetIndirect(%hs): Flags = %x\n",
		pdbaux->pszTable,
		*pdwExtFlags));
    }


    // Get value column

    hr = _RetrieveColumn(
                    pcs,
		    pTable->TableId,
		    pdbaux->pdtValue->dbcolumnid,
		    pdbaux->pdtValue->dbcoltyp,
                    pcbValue,
                    pbValue);
    if (CERTSRV_E_PROPERTY_EMPTY == hr && NULL != pdwExtFlags)
    {
	// return zero length property value and S_OK, so the caller can see
	// the extension flags.
	
	*pcbValue = 0;
	hr = S_OK;
    }
    _JumpIfError(hr, error, "_RetrieveColumn");

    DBGPRINT((
	    DBG_SS_CERTDBI,
	    "OUT: _GetIndirect(%hs.%ws) cb = %x\n",
	    pdbaux->pszTable,
	    pwszNameValue,
	    *pcbValue));

error:
    return(myJetHResult(hr));
}


#define CB_FETCHDELTA	256

// Fetch a column.  Loop if we have to grow the buffer.

HRESULT
CCertDB::_RetrieveColumnBuffer(
    IN CERTSESSION *pcs,
    IN JET_TABLEID tableid,
    IN JET_COLUMNID columnid,
    IN JET_COLTYP coltyp,
    OUT DWORD *pcbProp,
    IN OUT BYTE **ppbBuf,
    IN OUT DWORD *pcbBuf)
{
    HRESULT hr;
    BYTE *pbBuf = *ppbBuf;
    DWORD cbBuf = *pcbBuf;
    DWORD cb;

    cb = cbBuf;
    while (TRUE)
    {
	if (NULL == pbBuf)
	{
	    // If cbBuf == 0, allocate CB_FETCHDELTA bytes.
	    // Otherwise, allocate column size *plus* CB_FETCHDELTA bytes.
	    // Ensures we make no more than two calls to _RetrieveColumn.

	    cb += CB_FETCHDELTA;
	    pbBuf = (BYTE *) LocalAlloc(LMEM_FIXED, cb);
	    if (NULL == pbBuf)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    DBGPRINT((
		DBG_SS_CERTDB,
		"Grow buffer: %x --> %x\n", cbBuf, cb));
	    cbBuf = cb;
	}
	cb = cbBuf;
	hr = _RetrieveColumn(
			pcs,
			tableid,
			columnid,
			coltyp,
			&cb,
			pbBuf);
	if (S_OK == hr)
	{
	    *pcbProp = cb;
	    break;		// data fit in the buffer
	}
	if (HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW) != hr)
	{
	    _JumpError2(hr, error, "_RetrieveColumn", CERTSRV_E_PROPERTY_EMPTY);
	}

	// Data won't fit.  Grow the buffer.

	CSASSERT(NULL != pbBuf);
	LocalFree(pbBuf);
	pbBuf = NULL;
    }
    CSASSERT(S_OK == hr);

error:
    *ppbBuf = pbBuf;
    *pcbBuf = cbBuf;
    return(hr);
}


HRESULT
CCertDB::_RetrieveColumn(
    IN CERTSESSION *pcs,
    IN JET_TABLEID tableid,
    IN JET_COLUMNID columnid,
    IN JET_COLTYP coltyp,
    IN OUT DWORD *pcbProp,
    OPTIONAL OUT BYTE *pbProp)
{
    HRESULT hr;
    DWORD cbActual;
    DWORD cbTotal;

    CSASSERT(IsValidJetTableId(tableid));
    hr = _dbgJetRetrieveColumn(
                        pcs->SesId,
                        tableid,
                        columnid,
                        NULL,
                        0,
                        &cbActual,
                        JET_bitRetrieveCopy,
                        NULL);
    if ((HRESULT) JET_wrnColumnNull == hr)
    {
	// Routine GetProperty call:
	// _JumpIfError(hr, error, "JetRetrieveColumn: Property EMPTY");
	hr = CERTSRV_E_PROPERTY_EMPTY;
	goto error;
    }
    if ((HRESULT) JET_wrnBufferTruncated != hr)
    {
        _JumpIfError2(hr, error, "JetRetrieveColumn", JET_errNoCurrentRecord);
    }

    if (cbActual == 0)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpError(hr, error, "JetRetrieveColumn: cbActual=0: Property EMPTY");
    }

    cbTotal = cbActual;

    if (ISTEXTCOLTYP(coltyp))
    {
	DBGPRINT((DBG_SS_CERTDBI, "Size of text %d\n", cbActual));
        cbTotal += sizeof(WCHAR);
    }
    if (NULL == pbProp || cbTotal > *pcbProp)
    {
        *pcbProp = cbTotal;
	hr = S_OK;
	if (NULL != pbProp)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	    //_PrintError(hr, "output buffer too small");
	}
        goto error;
    }

    hr = _dbgJetRetrieveColumn(
                        pcs->SesId,
                        tableid,
                        columnid,
                        pbProp,
                        cbActual,
                        &cbActual,
                        JET_bitRetrieveCopy,
                        NULL);
    _JumpIfError(hr, error, "JetRetrieveColumn");

    *pcbProp = cbActual;

    if (ISTEXTCOLTYP(coltyp))
    {
        *(WCHAR *) &pbProp[cbActual] = L'\0';
    }

error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::_CreateIndex(
    IN CERTSESSION *pcs,
    IN JET_TABLEID tableid,
    IN CHAR const *pszIndexName,
    IN CHAR const *pchKey,
    IN DWORD cbKey,
    IN DWORD flags)
{
    HRESULT hr;

    CSASSERT(IsValidJetTableId(tableid));
    hr = _dbgJetCreateIndex(
                     pcs->SesId,
                     tableid,
                     pszIndexName,
                     flags,
                     pchKey,
                     cbKey,
                     0);	// lDensity %, for splits (use default of 80%)
    _JumpIfError3(
		hr,
		error,
		"JetCreateIndex",
		(HRESULT) JET_errIndexDuplicate,
		(HRESULT) JET_errIndexHasPrimary);

    DBGPRINT((
	DBG_SS_CERTDBI,
	"CreateIndex: %x:%hs idx=%hs len=%x flags=%x\n",
	tableid,
	pszIndexName,
	pchKey,
	cbKey,
	flags));

error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::_AddColumn(
    IN CERTSESSION *pcs,
    IN JET_TABLEID tableid,
    IN DBTABLE const *pdt)
{
    HRESULT hr;
    JET_COLUMNDEF columndef;
    JET_COLUMNID columnid;

    CSASSERT(IsValidJetTableId(tableid));
    ZeroMemory(&columndef, sizeof(columndef));
    columndef.cbStruct = sizeof(columndef);
    columndef.cp = 1200; // unicode (1200) instead of Ascii (1252)
    columndef.langid = 0x409;
    columndef.wCountry = 1;
    columndef.coltyp = pdt->dbcoltyp;
    columndef.cbMax = pdt->dbcolumnMax;
    columndef.grbit = pdt->dbgrbit;

    DBGPRINT((
	DBG_SS_CERTDBI,
	"AddColumn: %x:%hs coltyp=%x cbMax=%x grbit=%x\n",
	tableid,
	pdt->pszFieldName,
	pdt->dbcoltyp,
	pdt->dbcolumnMax,
	pdt->dbgrbit));

    hr = _dbgJetAddColumn(
		       pcs->SesId,	
		       tableid,
		       pdt->pszFieldName,
		       &columndef,
		       NULL,
		       0,
		       &columnid);
    CSASSERT(JET_wrnColumnMaxTruncated != hr);
    _JumpIfErrorStr3(
		hr,
		error,
		"JetAddColumn",
		pdt->pwszPropName,
		(HRESULT) JET_errColumnDuplicate,
		(HRESULT) JET_errColumnRedundant);

error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::_CreateTable(
    IN DWORD CreateFlags,		// CF_*
    IN CERTSESSION *pcs,
    IN DBCREATETABLE const *pct)
{
    HRESULT hr;
    JET_TABLEID tableid;
    BOOL fTableOpen;
    DWORD dwLength;
    CHAR achCol[MAX_PATH];
    DBTABLE const *pdt;

    DBGPRINT((
	DBG_SS_CERTDBI,
	"_CreateTable(%x, %hs)\n",
	CreateFlags,
	pct->pszTableName));

    fTableOpen = FALSE;
    if (CF_MISSINGTABLES & CreateFlags)
    {
	hr = _dbgJetCreateTable(
			    pcs->SesId,
			    pcs->DBId,
			    pct->pszTableName,
			    4,
			    0,
			    &tableid);
	if ((HRESULT) JET_errTableDuplicate != hr)
	{
	    _JumpIfError(hr, error, "JetCreateTable");

	    if (!(CF_DATABASE & CreateFlags))
	    {
		DBGPRINT((
		    DBG_SS_CERTDB,
		    "Created Missing Table: %hs:%x\n",
		    pct->pszTableName,
		    tableid));
	    }
	    hr = _dbgJetCloseTable(pcs->SesId, tableid);
	    _JumpIfError(hr, error, "JetCloseTable");
	}
    }

    hr = _dbgJetOpenTable(
		    pcs->SesId,
		    pcs->DBId,
		    pct->pszTableName,
		    NULL,			// pvParameters
		    0,				// cbParameters
		    JET_bitTableDenyRead,	// grbit
		    &tableid);
    _JumpIfError(hr, error, "JetOpenTable");
    fTableOpen = TRUE;

    CSASSERT(IsValidJetTableId(tableid));
    DBGPRINT((DBG_SS_CERTDBI, "OpenTable: %hs: %x\n", pct->pszTableName, tableid));

    if (NULL != pct->pdt)
    {
	HRESULT hrDuplicate;
	HRESULT hrRedundant;
	HRESULT hrHasPrimary;
	
	if ((CF_DATABASE | CF_MISSINGTABLES | CF_MISSINGCOLUMNS) & CreateFlags)
	{
	    hrDuplicate = myJetHResult(JET_errColumnDuplicate);
	    hrRedundant = myJetHResult(JET_errColumnRedundant);

	    for (pdt = pct->pdt; NULL != pdt->pwszPropName; pdt++)
	    {
		hr = _AddColumn(pcs, tableid, pdt);
		if (hrDuplicate == hr || hrRedundant == hr)
		{
		    _PrintError2(hr, "_AddColumn", hr);
		    hr = S_OK;
		}
		else
		if (S_OK == hr && !(CF_DATABASE & CreateFlags))
		{
		    m_fAddedNewColumns = TRUE;
		    DBGPRINT((
			DBG_SS_CERTDB,
			"Added Missing Column: %hs.%hs\n",
			pct->pszTableName,
			pdt->pszFieldName));
		}
		_JumpIfErrorStr(hr, error, "_AddColumn", pdt->pwszPropName);
	    }
	}
	if ((CF_DATABASE | CF_MISSINGTABLES | CF_MISSINGCOLUMNS | CF_MISSINGINDEXES) & CreateFlags)
	{
	    hrDuplicate = myJetHResult(JET_errIndexDuplicate);
	    hrHasPrimary = myJetHResult(JET_errIndexHasPrimary);

	    for (pdt = pct->pdt; NULL != pdt->pwszPropName; pdt++)
	    {
		if (NULL != pdt->pszIndexName)
		{
		    DWORD dwCreateIndexFlags = 0;
		    char *psz = achCol;
		    
		    if (DBTF_INDEXPRIMARY & pdt->dwFlags)
		    {
			dwCreateIndexFlags |= JET_bitIndexPrimary;
		    }
		    if (DBTF_INDEXUNIQUE & pdt->dwFlags)
		    {
			dwCreateIndexFlags |= JET_bitIndexUnique;
		    }
		    if (DBTF_INDEXIGNORENULL & pdt->dwFlags)
		    {
			dwCreateIndexFlags |= JET_bitIndexIgnoreNull;
		    }
		    
		    if (DBTF_INDEXREQUESTID & pdt->dwFlags)
		    {
			psz += sprintf(psz, "+%hs", szREQUESTID) + 1;
		    }
		    psz += sprintf(psz, "+%hs", pdt->pszFieldName) + 1;
		    *psz++ = '\0';  // double terminate
		    
	    
		    if (ISTEXTCOLTYP(pdt->dbcoltyp))
		    {
			// if text field, include 2-byte langid
			*(WORD UNALIGNED *) psz = (WORD) 0x409;
			psz += sizeof(WORD);
			*psz++ = '\0';  // double terminate
			*psz++ = '\0';  // double terminate
		    }
		    
		    hr = _CreateIndex(
				    pcs,
				    tableid,
				    pdt->pszIndexName,
				    achCol,
				    SAFE_SUBTRACT_POINTERS(psz, achCol),
				    dwCreateIndexFlags);
		    if (hrDuplicate == hr ||
			(hrHasPrimary == hr &&
			 (DBTF_INDEXPRIMARY & pdt->dwFlags)))
		    {
			_PrintError2(hr, "_CreateIndex", hr);
			hr = S_OK;
		    }
		    else
		    if (S_OK == hr && !(CF_DATABASE & CreateFlags))
		    {
			DBGPRINT((
			    DBG_SS_CERTDB,
			    "Added Missing Index: %hs.%hs\n",
			    pct->pszTableName,
			    pdt->pszIndexName));
			if (chTEXTPREFIX == *pdt->pszIndexName ||
			    (DBTF_INDEXRENAMED & pdt->dwFlags))
			{
                            char const *pszIndexName = &pdt->pszIndexName[1];
			    
			    CSASSERTTHREAD(pcs);
			    if (DBTF_INDEXRENAMED & pdt->dwFlags)
			    {
				pszIndexName += strlen(pszIndexName) + 1;
			    }
			    hr = _dbgJetDeleteIndex(
						pcs->SesId,
						tableid,
						pszIndexName);
			    _PrintIfError2(hr, "JetDeleteIndex", hr);
			    if (S_OK == hr)
			    {
				DBGPRINT((
				    DBG_SS_CERTDB,
				    "Deleted index %hs.%hs\n",
				    pct->pszTableName,
				    pszIndexName));
			    }
			    hr = S_OK;
			}
		    }
		    _JumpIfError(hr, error, "_CreateIndex");
		}
	    }
	}
    }

error:
    if (fTableOpen)
    {
	HRESULT hr2;

	hr2 = _dbgJetCloseTable(pcs->SesId, tableid);
	if (S_OK == hr)
	{
	    hr = hr2;
	    _JumpIfError(hr, error, "JetCloseTable");
	}
    }
    return(myJetHResult(hr));
}


HRESULT
CCertDB::_Create(
    IN DWORD CreateFlags,		// CF_*
    IN CHAR const *pszDataBaseName)
{
    HRESULT hr;
    DBCREATETABLE const *pct;
    CERTSESSION *pcs = NULL;

    DBGPRINT((
	DBG_SS_CERTDBI,
	"_Create(%x, %hs)\n",
	CreateFlags,
	pszDataBaseName));

    hr = _AllocateSession(&pcs);
    _JumpIfError(hr, error, "_AllocateSession");

    if (CF_DATABASE & CreateFlags)
    {
	hr = _dbgJetCreateDatabase(
				pcs->SesId,
				pszDataBaseName,
				NULL,
				&pcs->DBId,
				0);
	_JumpIfError(hr, error, "JetCreateDatabase");

	hr = _dbgJetCloseDatabase(pcs->SesId, pcs->DBId, 0);
	_JumpIfError(hr, error, "JetCloseDatabase");
    }

    hr = _dbgJetOpenDatabase(
                      pcs->SesId,
                      pszDataBaseName,
                      NULL,
                      &pcs->DBId,
                      JET_bitDbExclusive);
    _JumpIfError(hr, error, "JetOpenDatabase");

    hr = _dbgJetBeginTransaction(pcs->SesId);
    _JumpIfError(hr, error, "JetBeginTransaction");

    for (pct = g_actDataBase; NULL != pct->pszTableName; pct++)
    {
	hr = _CreateTable(CreateFlags, pcs, pct);
	_JumpIfError(hr, error, "_CreateTable");
    }

    hr = _dbgJetCommitTransaction(pcs->SesId, 0);
    _JumpIfError(hr, error, "JetCommitTransaction");

    hr = _dbgJetCloseDatabase(pcs->SesId, pcs->DBId, 0);
    _JumpIfError(hr, error, "JetCloseDatabase");

error:
    if (NULL != pcs)
    {
	ReleaseSession(pcs);
    }
    return(myJetHResult(hr));
}


HRESULT
CCertDB::_DupString(
    OPTIONAL IN WCHAR const *pwszPrefix,
    IN WCHAR const *pwszIn,
    OUT WCHAR **ppwszOut)
{
    DWORD cbPrefix;
    DWORD cb;
    HRESULT hr;

    cbPrefix = 0;
    if (NULL != pwszPrefix)
    {
	cbPrefix = wcslen(pwszPrefix) * sizeof(WCHAR);
    }
    cb = (wcslen(pwszIn) + 1) * sizeof(WCHAR);
    *ppwszOut = (WCHAR *) CoTaskMemAlloc(cbPrefix + cb);
    if (NULL == *ppwszOut)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "CoTaskMemAlloc");
    }
    if (NULL != pwszPrefix)
    {
	CopyMemory(*ppwszOut, pwszPrefix, cbPrefix);
    }
    CopyMemory((BYTE *) *ppwszOut + cbPrefix, pwszIn, cb);
    hr = S_OK;

error:
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certdb\db.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        db.h
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------


#include "resource.h"       // main symbols


typedef struct _DBSEEKDATA
{
    DWORD     SeekFlags;	    // CST_*

    JET_GRBIT grbitSeekRange;	// JetSeek flags if CST_SEEKINDEXRANGE
                                // this is where to seek to retrieve
				// end-of-range key

    JET_GRBIT grbitInitial;	// JetMove or JetSeek flags: set initial cursor
                                // Where to set the cursor initially

    JET_GRBIT grbitRange;	// JetSetIndexRange flags if CST_SEEKINDEXRANGE
                                // other flags to be ingested while setting
				// range (bitRange UpperLimit, Inclusive)
} DBSEEKDATA;


// _Create() CreateFlags:

#define CF_DATABASE		0x00000001
#define CF_MISSINGTABLES	0x00000002
#define CF_MISSINGCOLUMNS	0x00000004
#define CF_MISSINGINDEXES	0x00000008

#ifdef DBG_CERTSRV
#define CSASSERTTHREAD(pcs)  \
{ \
    DWORD dwThreadId = GetCurrentThreadId(); \
    if ((pcs)->dwThreadId != dwThreadId) \
    { \
	DBGPRINT((DBG_SS_CERTDB, "Session tid=%d, Current tid=%d\n", (pcs)->dwThreadId, dwThreadId)); \
    } \
    CSASSERT((pcs)->dwThreadId == dwThreadId); \
}
#endif

HRESULT
InitGlobalWriterState(VOID);

HRESULT
UnInitGlobalWriterState(VOID);

VOID
DBFreeParms();

HRESULT
DBInitParms(
    IN DWORD cSession,
    IN BOOL fCircularLogging,
    OPTIONAL IN WCHAR const *pwszEventSource,
    OPTIONAL IN WCHAR const *pwszLogDir,
    OPTIONAL IN WCHAR const *pwszSystemDir,
    OPTIONAL IN WCHAR const *pwszTempDir,
    OUT JET_INSTANCE *pInstance);

#if DBG_CERTSRV

VOID
dbgcat(
    IN OUT WCHAR *pwszBuf,
    IN WCHAR const *pwszAdd);

WCHAR const *
wszSeekgrbit(
    JET_GRBIT grbit);

WCHAR const *
wszMovecrow(
    IN LONG cRow);

WCHAR const *
wszSetIndexRangegrbit(
    JET_GRBIT grbit);

WCHAR const *
wszMakeKeygrbit(
    JET_GRBIT grbit);

WCHAR const *
wszCSFFlags(
    IN LONG Flags);

WCHAR const *
wszCSTFlags(
    IN LONG Flags);

WCHAR const *
wszSeekOperator(
    IN LONG SeekOperator);

WCHAR const *
wszSortOperator(
    IN LONG SortOrder);

VOID
dbDumpValue(
    IN DWORD dwSubSystemId,
    OPTIONAL IN DBTABLE const *pdt,
    IN BYTE const *pbValue,
    IN DWORD cbValue);

VOID
dbDumpColumn(
    IN DWORD dwSubSystemId,
    IN DBTABLE const *pdt,
    IN BYTE const *pbValue,
    IN DWORD cbValue);

#endif // DBG_CERTSRV


class CCertDB:
    public ICertDB,
    //public ISupportErrorInfoImpl<&IID_ICertDB>,
    public CComObjectRoot,
    public CComCoClass<CCertDB, &CLSID_CCertDB>
{
public:
    CCertDB();
    ~CCertDB();

BEGIN_COM_MAP(CCertDB)
    COM_INTERFACE_ENTRY(ICertDB)
    //COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertDB) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(
    CCertDB,
    wszCLASS_CERTDB TEXT(".1"),
    wszCLASS_CERTDB,
    IDS_CERTDB_DESC,
    THREADFLAGS_BOTH)

// ICertDB
public:
    STDMETHOD(Open)(
	/* [in] */ DWORD Flags,
	/* [in] */ DWORD cSession,
	/* [in] */ WCHAR const *pwszEventSource,
	/* [in] */ WCHAR const *pwszDBFile,
	/* [in] */ WCHAR const *pwszLogDir,
	/* [in] */ WCHAR const *pwszSystemDir,
	/* [in] */ WCHAR const *pwszTempDir);

    STDMETHOD(ShutDown)(
	/* [in] */ DWORD dwFlags);

    STDMETHOD(OpenRow)(
	/* [in] */ DWORD dwFlags,
	/* [in] */ DWORD RowId,
	/* [in] */ WCHAR const *pwszSerialNumberOrCertHash,	// OPTIONAL
	/* [out] */ ICertDBRow **pprow);

    STDMETHOD(OpenView)(
	/* [in] */  DWORD ccvr,
	/* [in] */  CERTVIEWRESTRICTION const *acvr,
	/* [in] */  DWORD ccolOut,
	/* [in] */  DWORD const *acolOut,
	/* [in] */  DWORD const dwFlags,
	/* [out] */ IEnumCERTDBRESULTROW **ppenum);

    STDMETHOD(EnumCertDBColumn)(
	/* [in] */  DWORD dwTable,
	/* [out] */ IEnumCERTDBCOLUMN **ppenum);

    STDMETHOD(OpenBackup)(
	/* [in] */  LONG grbitJet,
	/* [out] */ ICertDBBackup **ppBackup);

    STDMETHOD(GetDefaultColumnSet)(
        /* [in] */       DWORD  iColumnSetDefault,
        /* [in] */       DWORD  cColumnIds,
        /* [out] */      DWORD *pcColumnIds,
	/* [out, ref] */ DWORD *pColumnIds);

// CCertDB
    HRESULT BeginTransaction(
	IN CERTSESSION *pcs,
	IN BOOL fPrepareUpdate);

    HRESULT CommitTransaction(
	IN CERTSESSION *pcs,
	IN BOOL fCommit);

    HRESULT ReleaseSession(
	IN CERTSESSION *pcs);

    HRESULT BackupBegin(
	IN LONG grbitJet);

    HRESULT BackupGetDBFileList(
	IN OUT DWORD *pcwcList,
	OUT    WCHAR *pwszzList);		// OPTIONAL

    HRESULT BackupGetLogFileList(
	IN OUT DWORD *pcwcList,
	OUT    WCHAR *pwszzList);		// OPTIONAL

    HRESULT BackupOpenFile(
	IN WCHAR const *pwszFile,
	OUT JET_HANDLE *phFileDB,
	OPTIONAL OUT ULARGE_INTEGER *pliSize);

    HRESULT BackupReadFile(
	IN  JET_HANDLE hFileDB,
	OUT BYTE *pb,
	IN  DWORD cb,
	OUT DWORD *pcb);

    HRESULT BackupCloseFile(
	IN JET_HANDLE hFileDB);

    HRESULT BackupTruncateLog();

    HRESULT BackupEnd();

    HRESULT SetProperty(
	IN CERTSESSION *pcs,
	IN DBTABLE const *pdt,
	IN DWORD cbProp,
	IN BYTE const *pbProp);		// OPTIONAL

    HRESULT GetProperty(
	IN     CERTSESSION *pcs,
	IN     DBTABLE const *pdt,
	IN OUT DWORD *pcbProp,
	OUT    BYTE *pbProp);		// OPTIONAL

    HRESULT SetAttribute(
	IN CERTSESSION *pcs,
	IN WCHAR const *pwszAttributeName,
	IN DWORD cbValue,
	IN BYTE const *pbValue);	// OPTIONAL

    HRESULT GetAttribute(
	IN     CERTSESSION *pcs,
	IN     WCHAR const *pwszAttributeName,
	IN OUT DWORD *pcbValue,
	OUT    BYTE *pbValue);		// OPTIONAL

    HRESULT SetExtension(
	IN CERTSESSION *pcs,
	IN WCHAR const *pwszExtensionName,
	IN DWORD dwExtFlags,
	IN DWORD cbValue,
	IN BYTE const *pbValue);	// OPTIONAL

    HRESULT GetExtension(
	IN     CERTSESSION *pcs,
	IN     WCHAR const *pwszExtensionName,
	OUT    DWORD *pdwExtFlags,
	IN OUT DWORD *pcbValue,
	OUT    BYTE *pbValue);		// OPTIONAL

    HRESULT CopyRequestNames(
	IN CERTSESSION *pcs);

    HRESULT GetColumnType(
	IN  LONG ColumnIndex,
	OUT DWORD *pType);

    HRESULT EnumCertDBColumnNext(
	IN  DWORD         dwTable,
	IN  ULONG         ielt,
	IN  ULONG         celt,
	OUT CERTDBCOLUMN *rgelt,
	OUT ULONG        *pielt,
	OUT ULONG        *pceltFetched);

    HRESULT EnumCertDBResultRowNext(
	IN  CERTSESSION               *pcs,
	IN  DWORD                      ccvr,
	IN  CERTVIEWRESTRICTION const *acvr,
	IN  DWORD                      ccolOut,
	IN  DWORD const               *acolOut,
	IN  LONG                       cskip,
	IN  ULONG                      celt,
	OUT CERTDBRESULTROW           *rgelt,
	OUT ULONG                     *pceltFetched,
	OUT LONG		      *pcskipped);

    HRESULT ReleaseResultRow(
	IN     ULONG            celt,
	IN OUT CERTDBRESULTROW *rgelt);

    HRESULT EnumerateSetup(
	IN     CERTSESSION *pcs,
	IN OUT DWORD       *pFlags,
	OUT    JET_TABLEID *ptableid);

    HRESULT EnumerateNext(
	IN     CERTSESSION *pcs,
	IN OUT DWORD       *pFlags,
	IN     JET_TABLEID  tableid,
	IN     LONG         cskip,
	IN     ULONG        celt,
	OUT    CERTDBNAME  *rgelt,
	OUT    ULONG       *pceltFetched);

    HRESULT EnumerateClose(
	IN CERTSESSION *pcs,
	IN JET_TABLEID tableid);

    HRESULT OpenTables(
	IN CERTSESSION *pcs,
	OPTIONAL IN CERTVIEWRESTRICTION const *pcvr);

    HRESULT CloseTables(
	IN CERTSESSION *pcs);

    HRESULT Delete(
	IN CERTSESSION *pcs);

    HRESULT CloseTable(
	IN CERTSESSION *pcs,
	IN JET_TABLEID tableid);

    HRESULT MapPropId(
	IN  WCHAR const *pwszPropName,
	IN  DWORD dwFlags,
	OUT DBTABLE *pdtOut);

    HRESULT TestShutDownState();

#if DBG_CERTSRV
    VOID DumpRestriction(
	IN DWORD dwSubSystemId,
	IN LONG i,
	IN CERTVIEWRESTRICTION const *pcvr);
#endif // DBG_CERTSRV

private:
    HRESULT _AllocateSession(
	OUT CERTSESSION **ppcs);

    HRESULT _BackupGetFileList(
	IN           BOOL   fDBFiles,
	IN OUT       DWORD *pcwcList,
	OPTIONAL OUT WCHAR *pwszzList);

    HRESULT _CreateTable(
	IN DWORD CreateFlags,		// CF_*
	IN CERTSESSION *pcs,
	IN DBCREATETABLE const *pct);

    HRESULT _Create(
	IN DWORD CreateFlags,		// CF_*
	IN CHAR const *pszDatBaseName);

    HRESULT _CreateIndex(
	IN CERTSESSION *pcs,
	IN JET_TABLEID tableid,
	IN CHAR const *pszIndexName,
	IN CHAR const *pchKey,
	IN DWORD cbKey,
	IN DWORD flags);

    HRESULT _AddColumn(
	IN CERTSESSION *pcs,
	IN JET_TABLEID tableid,
	IN DBTABLE const *pdt);

    HRESULT _BuildColumnIds(
	IN CERTSESSION *pcs,
	IN CHAR const *pszTableName,
	IN DBTABLE *pdt);

    HRESULT _ConvertOldColumnData(
	IN CERTSESSION *pcs,
	IN CHAR const *pszTableName,
	IN DBAUXDATA const *pdbaux,
	IN DBTABLE *pdt);

    HRESULT _ConvertColumnData(
	IN CERTSESSION *pcs,
	IN JET_TABLEID tableid,
	IN DWORD RowId,
	IN DBTABLE const *pdt,
	IN DBAUXDATA const *pdbaux,
	IN OUT BYTE **ppbBuf,
	IN OUT DWORD *pcbBuf);

    HRESULT _AddKeyLengthColumn(
	IN CERTSESSION *pcs,
	IN JET_TABLEID tableid,
	IN DWORD RowId,
	IN DBTABLE const *pdtPublicKey,
	IN DBTABLE const *pdtPublicKeyAlgorithm,
	IN DBTABLE const *pdtPublicKeyParameters,
	IN DBTABLE const *pdtPublicKeyLength,
	IN DBAUXDATA const *pdbaux,
	IN OUT BYTE **ppbBuf,
	IN OUT DWORD *pcbBuf);

    HRESULT _AddCallerName(
	IN CERTSESSION *pcs,
	IN JET_TABLEID tableid,
	IN DWORD RowId,
	IN DBTABLE const *pdtCallerName,
	IN DBTABLE const *pdtRequesterName,
	IN DBAUXDATA const *pdbaux,
	IN OUT BYTE **ppbBuf,
	IN OUT DWORD *pcbBuf);

    HRESULT _SetColumn(
	IN JET_SESID SesId,
	IN JET_TABLEID tableid,
	IN JET_COLUMNID columnid,
	IN DWORD cbProp,
	IN BYTE const *pbProp);		// OPTIONAL

    HRESULT _OpenTableRow(
	IN CERTSESSION *pcs,
	IN DBAUXDATA const *pdbaux,
	OPTIONAL IN CERTVIEWRESTRICTION const *pcvr,
	OUT CERTSESSIONTABLE *pTable,
	OUT DWORD *pdwRowIdMismatch);

    HRESULT _UpdateTable(
	IN CERTSESSION *pcs,
	IN JET_TABLEID tableid);

    HRESULT _OpenTable(
	IN CERTSESSION *pcs,
	IN DBAUXDATA const *pdbaux,
	IN CERTVIEWRESTRICTION const *pcvr,
	IN OUT CERTSESSIONTABLE *pTable);

    HRESULT _SetIndirect(
	IN CERTSESSION *pcs,
	IN OUT CERTSESSIONTABLE *pTable,
	IN WCHAR const *pwszName,
	IN DWORD const *pdwExtFlags,	// OPTIONAL
	IN DWORD cbValue,
	IN BYTE const *pbValue);	// OPTIONAL

    HRESULT _GetIndirect(
	IN CERTSESSION *pcs,
	IN OUT CERTSESSIONTABLE *pTable,
	IN WCHAR const *pwszName,
	OUT DWORD *pdwExtFlags,	// OPTIONAL
	IN OUT DWORD *pcbValue,
	OUT BYTE *pbValue);		// OPTIONAL

    DBTABLE const *_MapTable(
	IN WCHAR const *pwszPropName,
	IN DBTABLE const *pdt);

    HRESULT _MapPropIdIndex(
	IN DWORD ColumnIndex,
	OUT DBTABLE const **ppdt,
	OPTIONAL OUT DWORD *pType);

    HRESULT _RetrieveColumnBuffer(
	IN CERTSESSION *pcs,
	IN JET_TABLEID tableid,
	IN JET_COLUMNID columnid,
	IN JET_COLTYP coltyp,
	IN OUT DWORD *pcbProp,
	IN OUT BYTE **ppbBuf,
	IN OUT DWORD *pcbBuf);

    HRESULT _RetrieveColumn(
	IN CERTSESSION *pcs,
	IN JET_TABLEID tableid,
	IN JET_COLUMNID columnid,
	IN JET_COLTYP coltyp,
	IN OUT DWORD *pcbData,
	OUT BYTE *pbData);

    HRESULT _CompareColumnValue(
	IN CERTSESSION               *pcs,
	IN CERTVIEWRESTRICTION const *pcvr);

    HRESULT _EnumerateMove(
	IN     CERTSESSION     *pcs,
	IN OUT DWORD           *pFlags,
	IN     DBAUXDATA const *pdbaux,
	IN     JET_TABLEID      tableid,
	IN     LONG	        cskip);

    HRESULT _MakeSeekKey(
	IN CERTSESSION   *pcs,
	IN JET_TABLEID    tableid,
	IN DBTABLE const *pdt,
	IN BYTE const    *pbValue,
	IN DWORD          cbValue);

    HRESULT _SeekTable(
	IN  CERTSESSION               *pcs,
	IN  JET_TABLEID                tableid,
	IN  CERTVIEWRESTRICTION const *pcvr,
	IN  DBTABLE const             *pdt,
	IN  DWORD                      dwPosition,
	OUT DWORD                     *pTableFlags
	DBGPARM(IN DBAUXDATA const    *pdbaux));

    HRESULT _MoveTable(
	IN  CERTSESSION               *pcs,
	IN  DWORD                      ccvr,
	IN  CERTVIEWRESTRICTION const *acvr,
	IN  LONG		       cskip,
	OUT LONG		      *pcskipped);

    HRESULT _GetResultRow(
	IN  CERTSESSION               *pcs,
	IN  DWORD                      ccvr,
	IN  CERTVIEWRESTRICTION const *acvr,
	IN  LONG		       cskip,
	IN  DWORD                      ccolOut,
	IN  DWORD const               *acolOut,
	OUT CERTDBRESULTROW           *pelt,
	OUT LONG                      *pcskipped);

    HRESULT _JetSeekFromRestriction(
	IN  CERTVIEWRESTRICTION const *pcvr,
	IN  DWORD dwPosition,
	OUT DBSEEKDATA *pSeekData);

    HRESULT _DupString(
	OPTIONAL IN WCHAR const *pwszPrefix,
	IN          WCHAR const *pwszIn,
	OUT         WCHAR **ppwszOut);

    HRESULT _Rollback(
	IN CERTSESSION *pcs);

#if DBG_CERTSRV
    HRESULT _DumpRowId(
	IN CHAR const  *psz,
	IN CERTSESSION *pcs,
	IN JET_TABLEID  tableid);

    HRESULT _DumpColumn(
	IN CHAR const    *psz,
	IN CERTSESSION   *pcs,
	IN JET_TABLEID    tableid,
	IN DBTABLE const *pdt);
#endif // DBG_CERTSRV

    BOOL             m_fDBOpen;
    BOOL             m_fDBReadOnly;
    BOOL             m_fDBRestart;
    BOOL             m_fFoundOldColumns;
    BOOL             m_fAddedNewColumns;
    JET_INSTANCE     m_Instance;
    CERTSESSION     *m_aSession;
    DWORD            m_cSession;
    DWORD            m_cbPage;
    CRITICAL_SECTION m_critsecSession;
    CRITICAL_SECTION m_critsecAutoIncTables;
    BOOL	     m_cCritSec;
    BOOL	     m_fPendingShutDown;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certdb\dbw.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        dbw.cpp
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "dbw.h"

#if DBG

BOOL g_fDebugJet = TRUE;
#define DBGJET(args)		if (g_fDebugJet) { DBGPRINT(args); }
#define DBGJETDUMPHEX(jerr, flags, pb, cb) \
    if (JET_errSuccess == (jerr) && g_fDebugJet && NULL != (pb) && 0 != (cb)) \
    { \
	DBGDUMPHEX((DBG_SS_CERTJETI, (flags), (pb), (cb))); \
    }


#define CTABLEMAX 40
JET_TABLEID g_at[CTABLEMAX];
DWORD g_ct = 0;

DWORD
TableIndex(
    JET_TABLEID tableid)
{
    DWORD i;

    for (i = 0; i < g_ct; i++)
    {
	if (g_at[i] == tableid)
	{
	    return(i);
	}
    }
    if (g_ct < CTABLEMAX)
    {
	g_at[g_ct++] = tableid;
	DBGJET((DBG_SS_CERTJETI, "TableIndex(%x) --> %x\n", tableid, i));
	return(i);
    }
    return((DWORD) -1);
}


VOID
dbgcat(
    IN OUT WCHAR *pwszBuf,
    IN WCHAR const *pwszAdd)
{
    wcscat(pwszBuf, NULL == wcschr(pwszBuf, L':')? L": " : L", ");
    wcscat(pwszBuf, pwszAdd);
}


WCHAR const *
wszOpenDatabase(
    JET_GRBIT grbit)
{
    static WCHAR s_awc[12];

    wsprintf(s_awc, L"{%x}", grbit);
    return(s_awc);
}


WCHAR const *
wszAttachDatabase(
    JET_GRBIT grbit)
{
    static WCHAR s_awc[12];

    wsprintf(s_awc, L"{%x}", grbit);
    return(s_awc);
}


WCHAR const *
wszSeekgrbit(
    JET_GRBIT grbit)
{
    static WCHAR s_awc[64];	// 1 + 2 + 6 * 2 + 5 * 2 + 13

    wsprintf(s_awc, L"{%x", grbit);
    if (JET_bitSeekEQ & grbit) dbgcat(s_awc, L"EQ");
    if (JET_bitSeekLT & grbit) dbgcat(s_awc, L"LT");
    if (JET_bitSeekLE & grbit) dbgcat(s_awc, L"LE");
    if (JET_bitSeekGE & grbit) dbgcat(s_awc, L"GE");
    if (JET_bitSeekGT & grbit) dbgcat(s_awc, L"GT");
    if (JET_bitSetIndexRange & grbit) dbgcat(s_awc, L"SetIndexRange");
    wcscat(s_awc, L"}");
    CSASSERT(wcslen(s_awc) < ARRAYSIZE(s_awc));
    return(s_awc);
}


WCHAR const *
wszMovecrow(
    IN LONG cRow)
{
    static WCHAR s_awc[16];

    switch (cRow)
    {
	case JET_MoveFirst:    wcscpy(s_awc, L"First");    break;
	case JET_MovePrevious: wcscpy(s_awc, L"Previous"); break;
	case JET_MoveNext:     wcscpy(s_awc, L"Next");     break;
	case JET_MoveLast:     wcscpy(s_awc, L"Last");     break;
	default:
	    wsprintf(s_awc, L"%d", cRow);
	    break;
    }
    CSASSERT(wcslen(s_awc) < ARRAYSIZE(s_awc));
    return(s_awc);
}


WCHAR const *
wszMovegrbit(
    JET_GRBIT grbit)
{
    static WCHAR s_awc[16];

    if (JET_bitMoveKeyNE & grbit) wcscpy(s_awc, L"MoveKeyNE");
    if (0 == grbit) wcscpy(s_awc, L"0");
    CSASSERT(wcslen(s_awc) < ARRAYSIZE(s_awc));
    return(s_awc);
}


WCHAR const *
wszSetIndexRangegrbit(
    JET_GRBIT grbit)
{
    static WCHAR s_awc[64];	// 1 + 2 + 6 * 2 + 5 * 2 + 13

    wsprintf(s_awc, L"{%x", grbit);
    if (JET_bitRangeInclusive & grbit)       dbgcat(s_awc, L"Inclusive");
    if (0 == ((JET_bitRangeInclusive | JET_bitRangeRemove) & grbit))
					     dbgcat(s_awc, L"Exclusive");

    if (JET_bitRangeUpperLimit & grbit)      dbgcat(s_awc, L"UpperLimit");
    if (0 == ((JET_bitRangeUpperLimit | JET_bitRangeRemove) & grbit))
					     dbgcat(s_awc, L"LowerLimit");

    if (JET_bitRangeInstantDuration & grbit) dbgcat(s_awc, L"InstantDuration");
    if (JET_bitRangeRemove & grbit)          dbgcat(s_awc, L"Remove");
    wcscat(s_awc, L"}");
    CSASSERT(wcslen(s_awc) < ARRAYSIZE(s_awc));
    return(s_awc);
}


WCHAR const *
wszMakeKeygrbit(
    JET_GRBIT grbit)
{
    static WCHAR s_awc[128];

    wsprintf(s_awc, L"{%x", grbit);
    if (JET_bitNewKey & grbit)            dbgcat(s_awc, L"NewKey");
    if (JET_bitStrLimit & grbit)          dbgcat(s_awc, L"StrLimit");
    if (JET_bitSubStrLimit & grbit)       dbgcat(s_awc, L"SubStrLimit");
    if (JET_bitNormalizedKey & grbit)     dbgcat(s_awc, L"NormalizedKey");
    if (JET_bitKeyDataZeroLength & grbit) dbgcat(s_awc, L"KeyDataZeroLength");
    wcscat(s_awc, L"}");
    CSASSERT(wcslen(s_awc) < ARRAYSIZE(s_awc));
    return(s_awc);
}


JET_ERR JET_API
_dbgJetInit(
    JET_INSTANCE *pinstance)
{
    JET_ERR jerr;

    jerr = JetInit(pinstance);
    DBGJET((DBG_SS_CERTJETI, "JetInit() --> %d\n", jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetTerm(
    JET_INSTANCE instance)
{
    JET_ERR jerr;

    jerr = JetTerm(instance);
    DBGJET((DBG_SS_CERTJETI, "JetTerm() --> %d\n", jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetTerm2(
    JET_INSTANCE instance,
    JET_GRBIT grbit)
{
    JET_ERR jerr;

    jerr = JetTerm2(instance, grbit);
    DBGJET((DBG_SS_CERTJETI, "JetTerm2() --> %d\n", jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetBackup(
    const char *szBackupPath,
    JET_GRBIT grbit,
    JET_PFNSTATUS pfnStatus)
{
    JET_ERR jerr;

    jerr = JetBackup(szBackupPath, grbit, pfnStatus);
    DBGJET((
	DBG_SS_CERTJETI,
	"JetBackup(%hs, %x, %x) --> %d\n",
	szBackupPath,
	grbit,
	pfnStatus,
	jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetRestore(
    const char *sz,
    JET_PFNSTATUS pfn)
{
    JET_ERR jerr;

    jerr = JetRestore(sz, pfn);
    DBGJET((DBG_SS_CERTJETI, "JetRestore(%hs, %x) --> %d\n", sz, pfn, jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetRestore2(
    const char *sz,
    const char *szDest,
    JET_PFNSTATUS pfn)
{
    JET_ERR jerr;

    jerr = JetRestore2(sz, szDest, pfn);
    DBGJET((DBG_SS_CERTJETI, "JetRestore2(%hs, %hs, %x) --> %d\n", sz, szDest, pfn, jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetSetSystemParameter(
    JET_INSTANCE *pinstance,
    JET_SESID sesid,
    unsigned long paramid,
    unsigned long lParam,
    const char *sz)
{
    JET_ERR jerr;
    char szlong[32];
    char const *sz2;

    sz2 = sz;
    if (NULL == sz2)
    {
	sprintf(szlong, "0x%x", lParam);
	sz2 = szlong;
    }
    jerr = JetSetSystemParameter(pinstance, sesid, paramid, lParam, sz);
    DBGJET((DBG_SS_CERTJETI, "JetSetSystemParameter(%x, %hs) --> %d\n", paramid, sz2, jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetBeginSession(
    JET_INSTANCE instance,
    JET_SESID *psesid,
    const char *szUserName,
    const char *szPassword)
{
    JET_ERR jerr;

    jerr = JetBeginSession(instance, psesid, szUserName, szPassword);
    DBGJET((DBG_SS_CERTJETI, "JetBeginSession() --> %d\n", jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetEndSession(
    JET_SESID sesid,
    JET_GRBIT grbit)
{
    JET_ERR jerr;

    jerr = JetEndSession(sesid, grbit);
    DBGJET((DBG_SS_CERTJETI, "JetEndSession() --> %d\n", jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetCreateDatabase(
    JET_SESID sesid,
    const char *szFilename,
    const char *szConnect,
    JET_DBID *pdbid,
    JET_GRBIT grbit)
{
    JET_ERR jerr;

    jerr = JetCreateDatabase(sesid, szFilename, szConnect, pdbid, grbit);
    DBGJET((DBG_SS_CERTJETI, "JetCreateDatabase() --> %d\n", jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetCreateTable(
    JET_SESID sesid,
    JET_DBID dbid,
    const char *szTableName,
    unsigned long lPages,
    unsigned long lDensity,
    JET_TABLEID *ptableid)
{
    JET_ERR jerr;

    jerr = JetCreateTable(
		    sesid,
		    dbid,
		    szTableName,
		    lPages,
		    lDensity,
		    ptableid);
    DBGJET((DBG_SS_CERTJETI, "JetCreateTable(%hs):%x --> %d\n", szTableName, TableIndex(*ptableid), jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetGetColumnInfo(
    JET_SESID sesid,
    JET_DBID dbid,
    const char *szTableName,
    const char *szColumnName,
    void *pvResult,
    unsigned long cbMax,
    unsigned long InfoLevel)
{
    JET_ERR jerr;

    jerr = JetGetColumnInfo(
			sesid,
			dbid,
			szTableName,
			szColumnName,
			pvResult,
			cbMax,
			InfoLevel);
    DBGJET((DBG_SS_CERTJETI, "JetGetColumnInfo(%hs, %hs, %x) --> %d\n", szTableName, szColumnName, InfoLevel, jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetConvertDDL(
    JET_SESID sesid,
    JET_DBID ifmp,
    JET_OPDDLCONV convtyp,
    void *pvData,
    unsigned long cbData)
{
    JET_ERR jerr;

    jerr = JetConvertDDL(sesid, ifmp, convtyp, pvData, cbData);

    if (opDDLConvIncreaseMaxColumnSize == convtyp)
    {
	JET_DDLMAXCOLUMNSIZE *pjdmcs = (JET_DDLMAXCOLUMNSIZE *) pvData;

	DBGJET((DBG_SS_CERTJETI, "JetConvertDDL(%hs, %hs, %x) --> %d\n", pjdmcs->szTable, pjdmcs->szColumn, pjdmcs->cbMax, jerr));
    }
    else
    {
	DBGJET((DBG_SS_CERTJETI, "JetConvertDDL(%x, %p, %x) --> %d\n", convtyp, pvData, cbData, jerr));
    }
    return(jerr);
}


JET_ERR JET_API
_dbgJetAddColumn(
    JET_SESID sesid,
    JET_TABLEID tableid,
    const char *szColumn,
    const JET_COLUMNDEF *pcolumndef,
    const void *pvDefault,
    unsigned long cbDefault,
    JET_COLUMNID *pcolumnid)
{
    JET_ERR jerr;

    jerr = JetAddColumn(
		    sesid,
		    tableid,
		    szColumn,
		    pcolumndef,
		    pvDefault,
		    cbDefault,
		    pcolumnid);
    DBGJET((DBG_SS_CERTJETI, "JetAddColumn(%x, %hs):%x --> %d\n", TableIndex(tableid), szColumn, *pcolumnid, jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetDeleteColumn(
    JET_SESID sesid,
    JET_TABLEID tableid,
    const char *szColumnName)
{
    JET_ERR jerr;

    jerr = JetDeleteColumn(sesid, tableid, szColumnName);
    DBGJET((DBG_SS_CERTJETI, "JetDeleteColumn(%x, %hs) --> %d\n", TableIndex(tableid), szColumnName, jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetCreateIndex(
    JET_SESID sesid,
    JET_TABLEID tableid,
    const char *szIndexName,
    JET_GRBIT grbit,
    const char *szKey,
    unsigned long cbKey,
    unsigned long lDensity)
{
    JET_ERR jerr;

    jerr = JetCreateIndex(
		    sesid,
		    tableid,
		    szIndexName,
		    grbit,
		    szKey,
		    cbKey,
		    lDensity);
    DBGJET((DBG_SS_CERTJETI, "JetCreateIndex(%x, %hs, %x) --> %d\n", TableIndex(tableid), szIndexName, grbit, jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetDeleteIndex(
    JET_SESID sesid,
    JET_TABLEID tableid,
    const char *szIndexName)
{
    JET_ERR jerr;

    jerr = JetDeleteIndex(sesid, tableid, szIndexName);
    DBGJET((DBG_SS_CERTJETI, "JetDeleteIndex(%x, %hs) --> %d\n", TableIndex(tableid), szIndexName, jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetBeginTransaction(
    JET_SESID sesid)
{
    JET_ERR jerr;

    jerr = JetBeginTransaction(sesid);
    DBGJET((DBG_SS_CERTJETI, "JetBeginTransaction() --> %d\n", jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetCommitTransaction(
    JET_SESID sesid,
    JET_GRBIT grbit)
{
    JET_ERR jerr;

    jerr = JetCommitTransaction(sesid, grbit);
    DBGJET((DBG_SS_CERTJETI, "JetCommitTransaction(%x) --> %d\n", grbit, jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetRollback(
    JET_SESID sesid,
    JET_GRBIT grbit)
{
    JET_ERR jerr;

    jerr = JetRollback(sesid, grbit);
    DBGJET((DBG_SS_CERTJETI, "JetRollback(%x) --> %d\n", grbit, jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetOpenDatabase(
    JET_SESID sesid,
    const char *szFilename,
    const char *szConnect,
    JET_DBID *pdbid,
    JET_GRBIT grbit)
{
    JET_ERR jerr;

    jerr = JetOpenDatabase(sesid, szFilename, szConnect, pdbid, grbit);
    DBGJET((
	DBG_SS_CERTJETI,
	"JetOpenDatabase(%hs, %ws):%x --> %d\n",
	szFilename,
	wszOpenDatabase(grbit),
	*pdbid,
	jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetAttachDatabase(
    JET_SESID sesid,
    const char *szFilename,
    JET_GRBIT grbit)
{
    JET_ERR jerr;

    jerr = JetAttachDatabase(sesid, szFilename, grbit);
    DBGJET((
	DBG_SS_CERTJETI,
	"JetAttachDatabase(%hs, %ws) --> %d\n",
	szFilename,
	wszAttachDatabase(grbit),
	jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetCloseDatabase(
    JET_SESID sesid,
    JET_DBID dbid,
    JET_GRBIT grbit)
{
    JET_ERR jerr;

    jerr = JetCloseDatabase(sesid, dbid, grbit);
    DBGJET((DBG_SS_CERTJETI, "JetCloseDatabase() --> %d\n", jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetOpenTable(
    JET_SESID sesid,
    JET_DBID dbid,
    const char *szTableName,
    const void *pvParameters,
    unsigned long cbParameters,
    JET_GRBIT grbit,
    JET_TABLEID *ptableid)
{
    JET_ERR jerr;

    jerr = JetOpenTable(
		    sesid,
		    dbid,
		    szTableName,
		    pvParameters,
		    cbParameters,
		    grbit,
		    ptableid);
    DBGJET((DBG_SS_CERTJETI, "JetOpenTable(%hs):%x --> %d\n", szTableName, TableIndex(*ptableid), jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetCloseTable(
    JET_SESID sesid,
    JET_TABLEID tableid)
{
    JET_ERR jerr;

    jerr = JetCloseTable(sesid, tableid);
    DBGJET((DBG_SS_CERTJETI, "JetCloseTable(%x) --> %d\n", TableIndex(tableid), jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetUpdate(
    JET_SESID sesid,
    JET_TABLEID tableid,
    void *pvBookmark,
    unsigned long cbBookmark,
    unsigned long *pcbActual)
{
    JET_ERR jerr;

    jerr = JetUpdate(sesid, tableid, pvBookmark, cbBookmark, pcbActual);
    DBGJET((DBG_SS_CERTJETI, "JetUpdate(%x) --> %d\n", TableIndex(tableid), jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetDelete(
    JET_SESID sesid,
    JET_TABLEID tableid)
{
    JET_ERR jerr;

    jerr = JetDelete(sesid, tableid);
    DBGJET((DBG_SS_CERTJETI, "JetDelete(%x) --> %d\n", TableIndex(tableid), jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetRetrieveColumn(
    JET_SESID sesid,
    JET_TABLEID tableid,
    JET_COLUMNID columnid,
    void *pvData,
    unsigned long cbData,
    unsigned long *pcbActual,
    JET_GRBIT grbit,
    JET_RETINFO *pretinfo)
{
    JET_ERR jerr;

    jerr = JetRetrieveColumn(
			sesid,
			tableid,
			columnid,
			pvData,
			cbData,
			pcbActual,
			grbit,
			pretinfo);
    DBGJET((
	DBG_SS_CERTJETI,
	"JetRetrieveColumn(%x, %x, %x) cb:%x->%x--> %d\n",
	TableIndex(tableid),
	columnid,
	grbit,
	cbData,
	*pcbActual,
	jerr));

    if (NULL != pvData)
    {
	DBGJETDUMPHEX(jerr, 0, (BYTE const *) pvData, min(cbData, *pcbActual));
    }
    return(jerr);
}


JET_ERR JET_API
_dbgJetSetColumn(
    JET_SESID sesid,
    JET_TABLEID tableid,
    JET_COLUMNID columnid,
    const void *pvData,
    unsigned long cbData,
    JET_GRBIT grbit,
    JET_SETINFO *psetinfo)
{
    JET_ERR jerr;

    jerr = JetSetColumn(
		    sesid,
		    tableid,
		    columnid,
		    pvData,
		    cbData,
		    grbit,
		    psetinfo);
    DBGJET((
	DBG_SS_CERTJETI,
	"JetSetColumn(%x, %x, %x) cb:%x --> %d\n",
	TableIndex(tableid),
	columnid,
	grbit,
	cbData,
	jerr));

    DBGJETDUMPHEX(jerr, 0, (BYTE const *) pvData, cbData);
    return(jerr);
}


JET_ERR JET_API
_dbgJetPrepareUpdate(
    JET_SESID sesid,
    JET_TABLEID tableid,
    unsigned long prep)
{
    JET_ERR jerr;

    jerr = JetPrepareUpdate(sesid, tableid, prep);
    DBGJET((DBG_SS_CERTJETI, "JetPrepareUpdate(%x, %x) --> %d\n", TableIndex(tableid), prep, jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetSetCurrentIndex2(
    JET_SESID sesid,
    JET_TABLEID tableid,
    const char *szIndexName,
    JET_GRBIT grbit)
{
    JET_ERR jerr;

    jerr = JetSetCurrentIndex2(sesid, tableid, szIndexName, grbit);
    DBGJET((DBG_SS_CERTJETI, "JetSetCurrentIndex2(%x) --> %d\n", TableIndex(tableid), jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetMove(
    JET_SESID sesid,
    JET_TABLEID tableid,
    long cRow,
    JET_GRBIT grbit)
{
    JET_ERR jerr;

    jerr = JetMove(sesid, tableid, cRow, grbit);
    DBGJET((
	DBG_SS_CERTJETI,
	"JetMove(%x, %ws, %ws) --> %d\n",
	TableIndex(tableid),
	wszMovecrow(cRow),
	wszMovegrbit(grbit),
	jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetMakeKey(
    JET_SESID sesid,
    JET_TABLEID tableid,
    const void *pvData,
    unsigned long cbData,
    JET_GRBIT grbit)
{
    JET_ERR jerr;

    jerr = JetMakeKey(sesid, tableid, pvData, cbData, grbit);
    DBGJET((
	DBG_SS_CERTJETI,
	"JetMakeKey(%x, %ws) --> %d\n",
	TableIndex(tableid),
	wszMakeKeygrbit(grbit),
	jerr));
    DBGJETDUMPHEX(jerr, 0, (BYTE const *) pvData, cbData);
    return(jerr);
}


JET_ERR JET_API
_dbgJetSeek(
    JET_SESID sesid,
    JET_TABLEID tableid,
    JET_GRBIT grbit)
{
    JET_ERR jerr;

    jerr = JetSeek(sesid, tableid, grbit);
    DBGJET((
	DBG_SS_CERTJETI,
	"JetSeek(%x, %ws) --> %d\n",
	TableIndex(tableid),
	wszSeekgrbit(grbit),
	jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetBeginExternalBackup(
    JET_GRBIT grbit)
{
    JET_ERR jerr;

    jerr = JetBeginExternalBackup(grbit);
    DBGJET((DBG_SS_CERTJETI, "JetBeginExternalBackup(%x) --> %d\n", grbit, jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetGetAttachInfo(
    void *pv,
    unsigned long cbMax,
    unsigned long *pcbActual)
{
    JET_ERR jerr;

    jerr = JetGetAttachInfo(pv, cbMax, pcbActual);
    DBGJET((
	DBG_SS_CERTJETI,
	"JetGetAttachInfo(%x, %x, -> %x) --> %d\n",
	pv,
	cbMax,
	*pcbActual,
	jerr));
    if (NULL != pv)
    {
	DBGJETDUMPHEX(jerr, 0, (BYTE const *) pv, min(cbMax, *pcbActual));
    }
    return(jerr);
}


JET_ERR JET_API
_dbgJetOpenFile(
    const char *szFileName,
    JET_HANDLE	*phfFile,
    unsigned long *pulFileSizeLow,
    unsigned long *pulFileSizeHigh)
{
    JET_ERR jerr;

    jerr = JetOpenFile(szFileName, phfFile, pulFileSizeLow, pulFileSizeHigh);
    DBGJET((
	DBG_SS_CERTJETI,
	"JetOpenFile(%hs, -> %x, %x, %x) --> %d\n",
	szFileName,
	*phfFile,
	*pulFileSizeLow,
	*pulFileSizeHigh,
	jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetReadFile(
    JET_HANDLE hfFile,
    void *pv,
    unsigned long cb,
    unsigned long *pcb)
{
    JET_ERR jerr;

    jerr = JetReadFile(hfFile, pv, cb, pcb);
    DBGJET((
	DBG_SS_CERTJETI,
	"JetReadFile(%x, %x, %x, -> %x) --> %d\n",
	hfFile,
	pv,
	cb,
	*pcb,
	jerr));
    return(jerr);
}


#if 0
JET_ERR JET_API
_dbgJetAsyncReadFile(
    JET_HANDLE hfFile,
    void* pv,
    unsigned long cb,
    JET_OLP *pjolp)
{
    JET_ERR jerr;

    jerr = JetAsyncReadFile(hfFile, pv, cb, pjolp);
    DBGJET((
	DBG_SS_CERTJETI,
	"JetAsyncReadFile(%x, %x, %x, %x) --> %d\n",
	hfFile,
	pv,
	cb,
	pjolp,
	jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetCheckAsyncReadFile(
    void *pv,
    int cb,
    unsigned long pgnoFirst)
{
    JET_ERR jerr;

    jerr = JetCheckAsyncReadFile(pv, cb, pgnoFirst);
    DBGJET((
	DBG_SS_CERTJETI,
	"JetCheckAsyncReadFile(%x, %x, %x) --> %d\n",
	pv,
	cb,
	pgnoFirst,
	jerr));
    return(jerr);
}
#endif


JET_ERR JET_API
_dbgJetCloseFile(
    JET_HANDLE hfFile)
{
    JET_ERR jerr;

    jerr = JetCloseFile(hfFile);
    DBGJET((DBG_SS_CERTJETI, "JetCloseFile(%x) --> %d\n", hfFile, jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetGetLogInfo(
    void *pv,
    unsigned long cbMax,
    unsigned long *pcbActual)
{
    JET_ERR jerr;

    jerr = JetGetLogInfo(pv, cbMax, pcbActual);
    DBGJET((
	DBG_SS_CERTJETI,
	"JetGetLogInfo(%x, %x, %x, -> %x) --> %d\n",
	pv,
	cbMax,
	*pcbActual,
	jerr));
    if (NULL != pv)
    {
	DBGJETDUMPHEX(jerr, 0, (BYTE const *) pv, min(cbMax, *pcbActual));
    }
    return(jerr);
}


JET_ERR JET_API
_dbgJetTruncateLog(void)
{
    JET_ERR jerr;

    jerr = JetTruncateLog();
    DBGJET((DBG_SS_CERTJETI, "JetTruncateLog() --> %d\n", jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetEndExternalBackup(void)
{
    JET_ERR jerr;

    jerr = JetEndExternalBackup();
    DBGJET((DBG_SS_CERTJETI, "JetEndExternalBackup() --> %d\n", jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetExternalRestore(
    char *szCheckpointFilePath,
    char *szLogPath,
    JET_RSTMAP *rgstmap,
    long crstfilemap,
    char *szBackupLogPath,
    long genLow,
    long genHigh,
    JET_PFNSTATUS pfn)
{
    JET_ERR jerr;

    jerr = JetExternalRestore(
			szCheckpointFilePath,
			szLogPath,
			rgstmap,
			crstfilemap,
			szBackupLogPath,
			genLow,
			genHigh,
			pfn);
    DBGJET((
	DBG_SS_CERTJETI,
	"JetExternalRestore(%hs, %hs, %x, %x, %hs, %x, %x, %x) --> %d\n",
	szCheckpointFilePath,
	szLogPath,
	rgstmap,
	crstfilemap,
	szBackupLogPath,
	genLow,
	genHigh,
	pfn,
	jerr));
    return(jerr);
}


JET_ERR JET_API 
_dbgJetSetIndexRange(
    JET_SESID sesid, 
    JET_TABLEID tableid, 
    JET_GRBIT grbit)
{
    JET_ERR jerr;

    jerr = JetSetIndexRange(sesid, tableid, grbit);
    DBGJET((
	DBG_SS_CERTJETI,
	"JetSetIndexRange(%x, %ws) --> %d\n",
	TableIndex(tableid),
	wszSetIndexRangegrbit(grbit),
	jerr));
    return(jerr);
}


JET_ERR JET_API 
_dbgJetRetrieveKey(
    JET_SESID sesid, 
    JET_TABLEID tableid, 
    void *pvData, 
    unsigned long cbData, 
    unsigned long *pcbActual, 
    JET_GRBIT grbit)
{
    JET_ERR jerr;

    jerr = JetRetrieveKey(sesid, tableid, pvData, cbData, pcbActual, grbit);
    DBGJET((
	DBG_SS_CERTJETI,
	"JetRetrieveKey(%x, %x, -> %x) --> %d\n",
	TableIndex(tableid),
	cbData,
	*pcbActual,
	jerr));
    DBGJETDUMPHEX(jerr, 0, (BYTE const *) pvData, min(*pcbActual, cbData));
    return(jerr);
}

#endif DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certdb\dbtable.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        dbtable.cpp
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "csprop.h"


// To Add a column to one of these tables:
// 1) Add a wszPROP<COLNAME> #define to ..\include\csprop.h and run mkcsinc.bat
// 2) Add a IDS_COLUMN_<COLNAME> #define to ..\certcli\resource.h and add the
//    display name to ..\certcli\certcli.rc.  Add an entry to g_aColTable in
//   ..\certcli\column.cpp that maps wszPROP<COLNAME> to IDS_COLUMN_<COLNAME>.
// 3) Add a DT?_<COLNAME> to the appropriate list of #defines in dbtable.h.
//    Renumber subsequent #defines if inserting into the table.
//    Change DT?_MAX.
//    Add a #define sz<COLNAME> "$ColName" ansi internal column name.
//    If the column is to be indexed, add a #define sz<TABLE>_<COLNAME>
//    "$<Table><ColName>Index"
//    The internal names of text columns and their indexes must begin with '$'.
// 4) Find a similar column type in the same table array (g_adt<Table>) in
//    dbtable.cpp, and copy the entry.  If inserting, fix subsequent
//    #if (DT?_<xxx> != CONSTANT) expressions to match the dbtable.h changes.
//    Fix the #if (DT?_MAX != CONSTANT) expression.
//    For the new g_adt<Table> entry, use NULL for pszIndexName if unindexed.
//
// Running the new certdb.dll on a machine will automatically create the new
// column(s) and indexes, and leave them empty.
//
// If DBTF_COLUMNRENAMED is set, the old column name is appended to
// pszFieldName.  When starting the database, if the old column exists, the
// old column data is copied to the new column FOR EVERY ROW.  Upon successful
// completion, the old column is deleted.
//
// Special case processing exists to convert ansi text column data to Unicode.
// Special case processing exists for a few missing columns: Key Length is
// computed, for example.
//
// If DBTF_INDEXRENAMED is set, the old index name is appended to pszIndexName.
// When starting the database, if the old index exists, it is deleted.


//---------------------------------------------------------------------------
//
// Requests Table:
//
//---------------------------------------------------------------------------

DBTABLE g_adtRequests[] =
{
#if (DTR_REQUESTID != 0)
#error -- bad DTR_REQUESTID index
#endif
    {	// ColumnType: DWORD
	wszPROPREQUESTREQUESTID,		// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_INDEXPRIMARY,			// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szREQUESTID,				// pszFieldName
        szREQUEST_REQUESTIDINDEX,		// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed | JET_bitColumnAutoincrement, // dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_REQUESTRAWREQUEST != 1)
#error -- bad DTR_REQUESTRAWREQUEST index
#endif
    {	// ColumnType: BLOB
	wszPROPREQUESTRAWREQUEST,		// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	CB_DBMAXRAWREQUEST,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szRAWREQUEST,				// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXRAWREQUEST,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongBinary,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_REQUESTRAWARCHIVEDKEY != 2)
#error -- bad DTR_REQUESTRAWARCHIVEDKEY index
#endif
    {	// ColumnType: BLOB
	wszPROPREQUESTRAWARCHIVEDKEY,		// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	CB_DBMAXRAWREQUEST,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szRAWARCHIVEDKEY,			// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXRAWREQUEST,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongBinary,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_REQUESTKEYRECOVERYHASHES != 3)
#error -- bad DTR_REQUESTKEYRECOVERYHASHES index
#endif
    {	// ColumnType: STRING
	wszPROPREQUESTKEYRECOVERYHASHES,	// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	CB_DBMAXTEXT_MEDIUM,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szKEYRECOVERYHASHES,			// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_MEDIUM,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_REQUESTRAWOLDCERTIFICATE != 4)
#error -- bad DTR_REQUESTRAWOLDCERTIFICATE index
#endif
    {	// ColumnType: BLOB
	wszPROPREQUESTRAWOLDCERTIFICATE,	// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	CB_DBMAXRAWCERTIFICATE,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szRAWOLDCERTIFICATE,			// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXRAWCERTIFICATE,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongBinary,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_REQUESTATTRIBUTES != 5)
#error -- bad DTR_REQUESTATTRIBUTES index
#endif
    {	// ColumnType: STRING
	wszPROPREQUESTATTRIBUTES,		// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	CB_DBMAXTEXT_ATTRSTRING,		// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szREQUESTATTRIBUTES,			// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_ATTRSTRING,		// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_REQUESTTYPE != 6)
#error -- bad DTR_REQUESTTYPE index
#endif
    {	// ColumnType: DWORD
	wszPROPREQUESTTYPE,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szREQUESTTYPE,				// pszFieldName
        NULL,					// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_REQUESTFLAGS != 7)
#error -- bad DTR_REQUESTFLAGS index
#endif
    {	// ColumnType: DWORD
	wszPROPREQUESTFLAGS,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szREQUESTFLAGS,				// pszFieldName
        NULL,					// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_REQUESTSTATUSCODE != 8)
#error -- bad DTR_REQUESTSTATUSCODE index
#endif
    {	// ColumnType: DWORD
	wszPROPREQUESTSTATUSCODE,		// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szSTATUSCODE,				// pszFieldName
        NULL,					// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_REQUESTDISPOSITION != 9)
#error -- bad DTR_REQUESTDISPOSITION index
#endif
    {	// ColumnType: DWORD
	wszPROPREQUESTDISPOSITION,		// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szDISPOSITION,				// pszFieldName
        szREQUEST_DISPOSITIONINDEX,		// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_REQUESTDISPOSITIONMESSAGE != 10)
#error -- bad DTR_REQUESTDISPOSITIONMESSAGE index
#endif
    {	// ColumnType: STRING
	wszPROPREQUESTDISPOSITIONMESSAGE,	// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	CB_DBMAXTEXT_DISPSTRING,		// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szDISPOSITIONMESSAGE,			// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_DISPSTRING,		// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_REQUESTSUBMITTEDWHEN != 11)
#error -- bad DTR_REQUESTSUBMITTEDWHEN index
#endif
    {	// ColumnType: FILETIME
	wszPROPREQUESTSUBMITTEDWHEN,		// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(DATE),				// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szSUBMITTEDWHEN,			// pszFieldName
        NULL,					// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypDateTime,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_REQUESTRESOLVEDWHEN != 12)
#error -- bad DTR_REQUESTRESOLVEDWHEN index
#endif
    {	// ColumnType: FILETIME
	wszPROPREQUESTRESOLVEDWHEN,		// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_INDEXIGNORENULL | DBTF_INDEXRENAMED, // dwFlags
	sizeof(DATE),				// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szRESOLVEDWHEN,				// pszFieldName
        szREQUEST_RESOLVEDWHENINDEX "\0" szREQUEST_RESOLVEDWHENINDEX_OLD, // pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypDateTime,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_REQUESTREVOKEDWHEN != 13)
#error -- bad DTR_REQUESTREVOKEDWHEN index
#endif
    {	// ColumnType: FILETIME
	wszPROPREQUESTREVOKEDWHEN,		// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(DATE),				// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szREVOKEDWHEN,				// pszFieldName
        NULL,					// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypDateTime,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_REQUESTREVOKEDEFFECTIVEWHEN != 14)
#error -- bad DTR_REQUESTREVOKEDEFFECTIVEWHEN index
#endif
    {	// ColumnType: FILETIME
	wszPROPREQUESTREVOKEDEFFECTIVEWHEN,	// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_INDEXIGNORENULL | DBTF_INDEXRENAMED, // dwFlags
	sizeof(DATE),				// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szREVOKEDEFFECTIVEWHEN,			// pszFieldName
        szREQUEST_REVOKEDEFFECTIVEWHENINDEX "\0" szREQUEST_REVOKEDEFFECTIVEWHENINDEX_OLD, // pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypDateTime,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_REQUESTREVOKEDREASON != 15)
#error -- bad DTR_REQUESTREVOKEDREASON index
#endif
    {	// ColumnType: DWORD
	wszPROPREQUESTREVOKEDREASON,		// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szREVOKEDREASON,			// pszFieldName
        NULL,					// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_REQUESTERNAME != 16)
#error -- bad DTR_REQUESTERNAME index
#endif
    {	// ColumnType: STRING
	wszPROPREQUESTERNAME,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	CB_DBMAXTEXT_REQUESTNAME,		// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szREQUESTERNAME,			// pszFieldName
        szREQUEST_REQUESTERNAMEINDEX,		// pszIndexName
        CB_DBMAXTEXT_REQUESTNAME,		// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_CALLERNAME != 17)
#error -- bad DTR_CALLERNAME index
#endif
    {	// ColumnType: STRING
	wszPROPCALLERNAME,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	CB_DBMAXTEXT_REQUESTNAME,		// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szCALLERNAME,				// pszFieldName
        szREQUEST_CALLERNAMEINDEX,		// pszIndexName
        CB_DBMAXTEXT_REQUESTNAME,		// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_SIGNERPOLICIES != 18)
#error -- bad DTR_SIGNERPOLICIES index
#endif
    {	// ColumnType: STRING
	wszPROPSIGNERPOLICIES,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	CB_DBMAXTEXT_MEDIUM,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szSIGNERPOLICIES,			// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_MEDIUM,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_SIGNERAPPLICATIONPOLICIES != 19)
#error -- bad DTR_SIGNERAPPLICATIONPOLICIES index
#endif
    {	// ColumnType: STRING
	wszPROPSIGNERAPPLICATIONPOLICIES,	// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	CB_DBMAXTEXT_MEDIUM,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szSIGNERAPPLICATIONPOLICIES,		// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_MEDIUM,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_DISTINGUISHEDNAME != 20)
#error -- bad DTR_DISTINGUISHEDNAME index
#endif
    {	// ColumnType: STRING
	wszPROPDISTINGUISHEDNAME,		// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_SUBJECT,				// dwFlags
        CB_DBMAXTEXT_DN,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szDISTINGUISHEDNAME,			// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_DN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_RAWNAME != 21)
#error -- bad DTR_RAWNAME index
#endif
    {	// ColumnType: BLOB
	wszPROPRAWNAME,				// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_SUBJECT,				// dwFlags
	CB_DBMAXBINARY,				// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szRAWNAME,				// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXBINARY,				// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongBinary,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_COUNTRY != 22)
#error -- bad DTR_COUNTRY index
#endif
    {	// ColumnType: STRING
	wszPROPCOUNTRY,				// pwszPropName
	TEXT(szOID_COUNTRY_NAME),		// pwszPropNameObjId
	DBTF_SUBJECT,				// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szCOUNTRY,				// pszFieldName
        NULL,					// pszIndexName
	CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_ORGANIZATION != 23)
#error -- bad DTR_ORGANIZATION index
#endif
    {	// ColumnType: STRING
	wszPROPORGANIZATION,			// pwszPropName
	TEXT(szOID_ORGANIZATION_NAME),		// pwszPropNameObjId
	DBTF_SUBJECT,				// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szORGANIZATION,				// pszFieldName
        NULL,					// pszIndexName
	CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_ORGUNIT != 24)
#error -- bad DTR_ORGUNIT index
#endif
    {	// ColumnType: STRING
	wszPROPORGUNIT,				// pwszPropName
	TEXT(szOID_ORGANIZATIONAL_UNIT_NAME),	// pwszPropNameObjId
	DBTF_SUBJECT,				// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szORGANIZATIONALUNIT,			// pszFieldName
        NULL,					// pszIndexName
	CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_COMMONNAME != 25)
#error -- bad DTR_COMMONNAME index
#endif
    {	// ColumnType: STRING
	wszPROPCOMMONNAME,			// pwszPropName
	TEXT(szOID_COMMON_NAME),		// pwszPropNameObjId
	DBTF_SUBJECT,				// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szCOMMONNAME,				// pszFieldName
        NULL,					// pszIndexName
	CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_LOCALITY != 26)
#error -- bad DTR_LOCALITY index
#endif
    {	// ColumnType: STRING
	wszPROPLOCALITY,			// pwszPropName
	TEXT(szOID_LOCALITY_NAME),		// pwszPropNameObjId
	DBTF_SUBJECT,				// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szLOCALITY,				// pszFieldName
        NULL,					// pszIndexName
	CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_STATE != 27)
#error -- bad DTR_STATE index
#endif
    {	// ColumnType: STRING
	wszPROPSTATE,				// pwszPropName
	TEXT(szOID_STATE_OR_PROVINCE_NAME),	// pwszPropNameObjId
	DBTF_SUBJECT,				// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szSTATEORPROVINCE,			// pszFieldName
        NULL,					// pszIndexName
	CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_TITLE != 28)
#error -- bad DTR_TITLE index
#endif
    {	// ColumnType: STRING
	wszPROPTITLE,				// pwszPropName
	TEXT(szOID_TITLE),			// pwszPropNameObjId
	DBTF_SUBJECT,				// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szTITLE,				// pszFieldName
        NULL,					// pszIndexName
	CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_GIVENNAME != 29)
#error -- bad DTR_GIVENNAME index
#endif
    {	// ColumnType: STRING
	wszPROPGIVENNAME,			// pwszPropName
	TEXT(szOID_GIVEN_NAME),			// pwszPropNameObjId
	DBTF_SUBJECT,				// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szGIVENNAME,				// pszFieldName
        NULL,					// pszIndexName
	CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_INITIALS != 30)
#error -- bad DTR_INITIALS index
#endif
    {	// ColumnType: STRING
	wszPROPINITIALS,			// pwszPropName
	TEXT(szOID_INITIALS),			// pwszPropNameObjId
	DBTF_SUBJECT,				// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szINITIALS,				// pszFieldName
        NULL,					// pszIndexName
	CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_SURNAME != 31)
#error -- bad DTR_SURNAME index
#endif
    {	// ColumnType: STRING
	wszPROPSURNAME,				// pwszPropName
	TEXT(szOID_SUR_NAME),			// pwszPropNameObjId
	DBTF_SUBJECT,				// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szSURNAME,				// pszFieldName
        NULL,					// pszIndexName
	CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_DOMAINCOMPONENT != 32)
#error -- bad DTR_DOMAINCOMPONENT index
#endif
    {	// ColumnType: STRING
	wszPROPDOMAINCOMPONENT,			// pwszPropName
	TEXT(szOID_DOMAIN_COMPONENT),		// pwszPropNameObjId
	DBTF_SUBJECT,				// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szDOMAINCOMPONENT,			// pszFieldName
        NULL,					// pszIndexName
	CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_EMAIL != 33)
#error -- bad DTR_EMAIL index
#endif
    {	// ColumnType: STRING
	wszPROPEMAIL,				// pwszPropName
	TEXT(szOID_RSA_emailAddr),		// pwszPropNameObjId
	DBTF_SUBJECT,				// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szEMAIL,				// pszFieldName
        NULL,					// pszIndexName
	CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_STREETADDRESS != 34)
#error -- bad DTR_STREETADDRESS index
#endif
    {	// ColumnType: STRING
	wszPROPSTREETADDRESS,			// pwszPropName
	TEXT(szOID_STREET_ADDRESS),		// pwszPropNameObjId
	DBTF_SUBJECT,				// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szSTREETADDRESS,			// pszFieldName
        NULL,					// pszIndexName
	CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_UNSTRUCTUREDNAME != 35)
#error -- bad DTR_UNSTRUCTUREDNAME index
#endif
    {	// ColumnType: STRING
	wszPROPUNSTRUCTUREDNAME,		// pwszPropName
	TEXT(szOID_RSA_unstructName),		// pwszPropNameObjId
	DBTF_SUBJECT | DBTF_SOFTFAIL,		// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szUNSTRUCTUREDNAME,			// pszFieldName
        NULL,					// pszIndexName
	CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_UNSTRUCTUREDADDRESS != 36)
#error -- bad DTR_UNSTRUCTUREDADDRESS index
#endif
    {	// ColumnType: STRING
	wszPROPUNSTRUCTUREDADDRESS,		// pwszPropName
	TEXT(szOID_RSA_unstructAddr),		// pwszPropNameObjId
	DBTF_SUBJECT | DBTF_SOFTFAIL,		// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szUNSTRUCTUREDADDRESS,			// pszFieldName
        NULL,					// pszIndexName
	CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_DEVICESERIALNUMBER != 37)
#error -- bad DTR_DEVICESERIALNUMBER index
#endif
    {	// ColumnType: STRING
	wszPROPDEVICESERIALNUMBER,		// pwszPropName
	TEXT(szOID_DEVICE_SERIAL_NUMBER),	// pwszPropNameObjId
	DBTF_SUBJECT | DBTF_SOFTFAIL,		// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szDEVICESERIALNUMBER,			// pszFieldName
        NULL,					// pszIndexName
	CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_MAX != 38)
#error -- bad DTR_MAX index
#endif
    DBTABLE_NULL	// Termination marker
};


//---------------------------------------------------------------------------
//
// Certificates Table:
//
//---------------------------------------------------------------------------

DBTABLE g_adtCertificates[] =
{
#if (DTC_REQUESTID != 0)
#error -- bad DTC_REQUESTID index
#endif
    {	// ColumnType: DWORD
	wszPROPCERTIFICATEREQUESTID,		// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_INDEXPRIMARY,			// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szREQUESTID,				// pszFieldName
	szCERTIFICATE_REQUESTIDINDEX,		// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_RAWCERTIFICATE != 1)
#error -- bad DTC_RAWCERTIFICATE index
#endif
    {	// ColumnType: BLOB
	wszPROPRAWCERTIFICATE,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	CB_DBMAXRAWCERTIFICATE,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szRAWCERTIFICATE,			// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXRAWCERTIFICATE,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongBinary,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_CERTIFICATEHASH != 2)
#error -- bad DTC_CERTIFICATEHASH index
#endif
    {	// ColumnType: STRING
	wszPROPCERTIFICATEHASH,			// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_INDEXIGNORENULL,			// dwFlags
	cchHASHMAX * sizeof(WCHAR),		// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szCERTIFICATEHASH,			// pszFieldName
        szCERTIFICATE_HASHINDEX,		// pszIndexName
        cchHASHMAX * sizeof(WCHAR),		// dbcolumnMax
        0,					// dbgrbit
        JET_coltypText,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_CERTIFICATETEMPLATE != 3)
#error -- bad DTC_CERTIFICATETEMPLATE index
#endif
    {	// ColumnType: STRING
	wszPROPCERTIFICATETEMPLATE,		// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SOFTFAIL,	// dwFlags
	CB_DBMAXTEXT_OID,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szCERTIFICATETEMPLATE,			// pszFieldName
	szCERTIFICATE_TEMPLATEINDEX,		// pszIndexName
	CB_DBMAXTEXT_OID,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypText,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_CERTIFICATEENROLLMENTFLAGS != 4)
#error -- bad DTC_CERTIFICATEENROLLMENTFLAGS index
#endif
    {   // ColumnType: DWORD
	wszPROPCERTIFICATEENROLLMENTFLAGS,	// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SOFTFAIL,	// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szCERTIFICATEENROLLMENTFLAGS,		// pszFieldName
        NULL,					// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_CERTIFICATEGENERALFLAGS != 5)
#error -- bad DTC_CERTIFICATEGENERALFLAGS index
#endif
    {   // ColumnType: DWORD
	wszPROPCERTIFICATEGENERALFLAGS,		// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SOFTFAIL,	// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szCERTIFICATEGENERALFLAGS,		// pszFieldName
        NULL,					// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_CERTIFICATESERIALNUMBER != 6)
#error -- bad DTC_CERTIFICATESERIALNUMBER index
#endif
    {	// ColumnType: STRING
	wszPROPCERTIFICATESERIALNUMBER,		// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_INDEXIGNORENULL | DBTF_INDEXRENAMED, // dwFlags
	cchSERIALNUMBERMAX * sizeof(WCHAR),	// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szSERIALNUMBER,				// pszFieldName
	szCERTIFICATE_SERIALNUMBERINDEX "\0" szCERTIFICATE_SERIALNUMBERINDEX_OLD,	// pszIndexName
	cchSERIALNUMBERMAX * sizeof(WCHAR),	// dbcolumnMax
        0,					// dbgrbit
        JET_coltypText,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_CERTIFICATEISSUERNAMEID != 7)
#error -- bad DTC_CERTIFICATEISSUERNAMEID index
#endif
    {   // ColumnType: DWORD
	wszPROPCERTIFICATEISSUERNAMEID,		// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szISSUERNAMEID,				// pszFieldName
        NULL,					// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_CERTIFICATENOTBEFOREDATE != 8)
#error -- bad DTC_CERTIFICATENOTBEFOREDATE index
#endif
    {	// ColumnType: FILETIME
	wszPROPCERTIFICATENOTBEFOREDATE,	// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_POLICYWRITEABLE,			// dwFlags
	sizeof(DATE),				// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szNOTBEFORE,				// pszFieldName
        NULL,					// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypDateTime,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_CERTIFICATENOTAFTERDATE != 9)
#error -- bad DTC_CERTIFICATENOTAFTERDATE index
#endif
    {	// ColumnType: FILETIME
	wszPROPCERTIFICATENOTAFTERDATE,		// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_INDEXIGNORENULL | DBTF_INDEXRENAMED, // dwFlags
	sizeof(DATE),				// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szNOTAFTER,				// pszFieldName
        szCERTIFICATE_NOTAFTERINDEX "\0" szCERTIFICATE_NOTAFTERINDEX_OLD, // pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypDateTime,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_CERTIFICATESUBJECTKEYIDENTIFIER != 10)
#error -- bad DTC_CERTIFICATESUBJECTKEYIDENTIFIER index
#endif
    {	// ColumnType: STRING
	wszPROPCERTIFICATESUBJECTKEYIDENTIFIER,	// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_COLUMNRENAMED,			// dwFlags
	cchHASHMAX * sizeof(WCHAR),		// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szSUBJECTKEYIDENTIFIER "\0" szSUBJECTKEYIDENTIFIER_OLD, // pszFieldName
        NULL,					// pszIndexName
        cchHASHMAX * sizeof(WCHAR),		// dbcolumnMax
        0,					// dbgrbit
        JET_coltypText,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_CERTIFICATERAWPUBLICKEY != 11)
#error -- bad DTC_CERTIFICATERAWPUBLICKEY index
#endif
    {	// ColumnType: BLOB
	wszPROPCERTIFICATERAWPUBLICKEY,		// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	CB_DBMAXBINARY,				// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szPUBLICKEY,				// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXBINARY,				// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongBinary,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_CERTIFICATEPUBLICKEYLENGTH != 12)
#error -- bad DTC_CERTIFICATEPUBLICKEYLENGTH index
#endif
    {   // ColumnType: DWORD
	wszPROPCERTIFICATEPUBLICKEYLENGTH,	// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szPUBLICKEYLENGTH,			// pszFieldName
        NULL,					// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_CERTIFICATEPUBLICKEYALGORITHM != 13)
#error -- bad DTC_CERTIFICATEPUBLICKEYALGORITHM index
#endif
    {	// ColumnType: STRING
	wszPROPCERTIFICATEPUBLICKEYALGORITHM,	// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	CB_DBMAXTEXT_OID,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szPUBLICKEYALGORITHM,			// pszFieldName
        NULL,					// pszIndexName
	CB_DBMAXTEXT_OID,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypText,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_CERTIFICATERAWPUBLICKEYALGORITHMPARAMETERS != 14)
#error -- bad DTC_CERTIFICATERAWPUBLICKEYALGORITHMPARAMETERS index
#endif
    {	// ColumnType: BLOB
	wszPROPCERTIFICATERAWPUBLICKEYALGORITHMPARAMETERS, // pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	CB_DBMAXBINARY,				// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szPUBLICKEYPARAMS,			// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXBINARY,				// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongBinary,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_CERTIFICATEUPN != 15)
#error -- bad DTC_CERTIFICATEUPN index
#endif
    {	// ColumnType: STRING
	wszPROPCERTIFICATEUPN,			// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_INDEXIGNORENULL,// dwFlags
	CB_DBMAXTEXT_REQUESTNAME,		// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szUPN,					// pszFieldName
        szCERTIFICATE_UPNINDEX,			// pszIndexName
        CB_DBMAXTEXT_REQUESTNAME,		// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_DISTINGUISHEDNAME != 16)
#error -- bad DTC_DISTINGUISHEDNAME index
#endif
    {	// ColumnType: STRING
	wszPROPDISTINGUISHEDNAME,		// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_SUBJECT,				// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szDISTINGUISHEDNAME,			// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_DN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_RAWNAME != 17)
#error -- bad DTC_RAWNAME index
#endif
    {	// ColumnType: BLOB
	wszPROPRAWNAME,				// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_SUBJECT,				// dwFlags
	CB_DBMAXBINARY,				// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szRAWNAME,				// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXBINARY,				// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongBinary,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_COUNTRY != 18)
#error -- bad DTC_COUNTRY index
#endif
    {	// ColumnType: STRING
	wszPROPCOUNTRY,				// pwszPropName
	TEXT(szOID_COUNTRY_NAME),		// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SUBJECT,	// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szCOUNTRY,				// pszFieldName
        NULL,					// pszIndexName
	CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_ORGANIZATION != 19)
#error -- bad DTC_ORGANIZATION index
#endif
    {	// ColumnType: STRING
	wszPROPORGANIZATION,			// pwszPropName
	TEXT(szOID_ORGANIZATION_NAME),		// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SUBJECT,	// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szORGANIZATION,				// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_ORGUNIT != 20)
#error -- bad DTC_ORGUNIT index
#endif
    {	// ColumnType: STRING
	wszPROPORGUNIT,				// pwszPropName
	TEXT(szOID_ORGANIZATIONAL_UNIT_NAME),	// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SUBJECT,	// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szORGANIZATIONALUNIT,			// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_COMMONNAME != 21)
#error -- bad DTC_COMMONNAME index
#endif
    {	// ColumnType: STRING
	wszPROPCOMMONNAME,			// pwszPropName
	TEXT(szOID_COMMON_NAME),		// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SUBJECT,	// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szCOMMONNAME,				// pszFieldName
        szCERTIFICATE_COMMONNAMEINDEX,		// pszIndexName
        CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_LOCALITY != 22)
#error -- bad DTC_LOCALITY index
#endif
    {	// ColumnType: STRING
	wszPROPLOCALITY,			// pwszPropName
	TEXT(szOID_LOCALITY_NAME),		// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SUBJECT,	// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szLOCALITY,				// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_STATE != 23)
#error -- bad DTC_STATE index
#endif
    {	// ColumnType: STRING
	wszPROPSTATE,				// pwszPropName
	TEXT(szOID_STATE_OR_PROVINCE_NAME),	// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SUBJECT,	// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szSTATEORPROVINCE,			// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_TITLE != 24)
#error -- bad DTC_TITLE index
#endif
    {	// ColumnType: STRING
	wszPROPTITLE,				// pwszPropName
	TEXT(szOID_TITLE),			// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SUBJECT,	// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szTITLE,				// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_GIVENNAME != 25)
#error -- bad DTC_GIVENNAME index
#endif
    {	// ColumnType: STRING
	wszPROPGIVENNAME,			// pwszPropName
	TEXT(szOID_GIVEN_NAME),			// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SUBJECT,	// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szGIVENNAME,				// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_INITIALS != 26)
#error -- bad DTC_INITIALS index
#endif
    {	// ColumnType: STRING
	wszPROPINITIALS,			// pwszPropName
	TEXT(szOID_INITIALS),			// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SUBJECT,	// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szINITIALS,				// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_SURNAME != 27)
#error -- bad DTC_SURNAME index
#endif
    {	// ColumnType: STRING
	wszPROPSURNAME,				// pwszPropName
	TEXT(szOID_SUR_NAME),			// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SUBJECT,	// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szSURNAME,				// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_DOMAINCOMPONENT != 28)
#error -- bad DTC_DOMAINCOMPONENT index
#endif
    {	// ColumnType: STRING
	wszPROPDOMAINCOMPONENT,			// pwszPropName
	TEXT(szOID_DOMAIN_COMPONENT),		// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SUBJECT,	// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szDOMAINCOMPONENT,			// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_EMAIL != 29)
#error -- bad DTC_EMAIL index
#endif
    {	// ColumnType: STRING
	wszPROPEMAIL,				// pwszPropName
	TEXT(szOID_RSA_emailAddr),		// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SUBJECT,	// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szEMAIL,				// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_STREETADDRESS != 30)
#error -- bad DTC_STREETADDRESS index
#endif
    {	// ColumnType: STRING
	wszPROPSTREETADDRESS,			// pwszPropName
	TEXT(szOID_STREET_ADDRESS),		// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SUBJECT,	// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szSTREETADDRESS,			// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_UNSTRUCTUREDNAME != 31)
#error -- bad DTC_UNSTRUCTUREDNAME index
#endif
    {	// ColumnType: STRING
	wszPROPUNSTRUCTUREDNAME,		// pwszPropName
	TEXT(szOID_RSA_unstructName),		// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SUBJECT | DBTF_SOFTFAIL, // dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szUNSTRUCTUREDNAME,			// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_UNSTRUCTUREDADDRESS != 32)
#error -- bad DTC_UNSTRUCTUREDADDRESS index
#endif
    {	// ColumnType: STRING
	wszPROPUNSTRUCTUREDADDRESS,		// pwszPropName
	TEXT(szOID_RSA_unstructAddr),		// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SUBJECT | DBTF_SOFTFAIL, // dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szUNSTRUCTUREDADDRESS,			// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_DEVICESERIALNUMBER != 33)
#error -- bad DTC_DEVICESERIALNUMBER index
#endif
    {	// ColumnType: STRING
	wszPROPDEVICESERIALNUMBER,		// pwszPropName
	TEXT(szOID_DEVICE_SERIAL_NUMBER),	// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SUBJECT | DBTF_SOFTFAIL, // dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szDEVICESERIALNUMBER,			// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_MAX != 34)
#error -- bad DTC_MAX index
#endif
    DBTABLE_NULL	// Termination marker
};


//---------------------------------------------------------------------------
//
// Request Attributes Table:
//
//---------------------------------------------------------------------------

DBTABLE g_adtRequestAttributes[] =
{
#if (DTA_REQUESTID != 0)
#error -- bad DTA_REQUESTID index
#endif
    {	// ColumnType: DWORD
	wszPROPATTRIBREQUESTID,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_ATTRIBUTES,			// dwTable
	szREQUESTID,				// pszFieldName
	szATTRIBUTE_REQUESTIDINDEX,		// pszIndexName
	0,					// dbcolumnMax
	JET_bitColumnFixed,			// dbgrbit
	JET_coltypLong,				// dbcoltyp
	0,					// dbcolumnid
    },
#if (DTA_ATTRIBUTENAME != 1)
#error -- bad DTA_ATTRIBUTENAME index
#endif
    {	// ColumnType: STRING
	wszPROPATTRIBNAME,			// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_INDEXREQUESTID,			// dwFlags
        CB_DBMAXTEXT_ATTRNAME,			// dwcbMax
	TABLE_ATTRIBUTES,			// dwTable
	szATTRIBUTENAME,			// pszFieldName
	szATTRIBUTE_REQUESTIDNAMEINDEX,		// pszIndexName
	CB_DBMAXTEXT_ATTRNAME,			// dbcolumnMax
	0,					// dbgrbit
	JET_coltypText,				// dbcoltyp
	0,					// dbcolumnid
    },
#if (DTA_ATTRIBUTEVALUE != 2)
#error -- bad DTA_ATTRIBUTEVALUE index
#endif
    {	// ColumnType: STRING
	wszPROPATTRIBVALUE,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
        CB_DBMAXTEXT_ATTRVALUE,			// dwcbMax
	TABLE_ATTRIBUTES,			// dwTable
	szATTRIBUTEVALUE,			// pszFieldName
	NULL,					// pszIndexName
	CB_DBMAXTEXT_ATTRVALUE,			// dbcolumnMax
	0,					// dbgrbit
	JET_coltypLongText,			// dbcoltyp
	0,					// dbcolumnid
    },
#if (DTA_MAX != 3)
#error -- bad DTA_MAX index
#endif
    DBTABLE_NULL	// Termination marker
};


//---------------------------------------------------------------------------
//
// Name Extensions Table:
//
//---------------------------------------------------------------------------

#if 0
WCHAR const wszDummy[] = L"Dummy Prop Name";

DBTABLE g_adtNameExtensions[] =
{
    {	// ColumnType: DWORD
	wszDummy,				// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_NAMES,				// dwTable
	szNAMEID,				// pszFieldName
	NULL,					// pszIndexName
	0,					// dbcolumnMax
	JET_bitColumnFixed,			// dbgrbit
	JET_coltypLong,				// dbcoltyp
	0,					// dbcolumnid
    },
    {	// ColumnType: STRING
	wszDummy,				// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
        CB_DBMAXTEXT_OID,			// dwcbMax
	TABLE_NAMES,				// dwTable
	szEXTENSIONNAME,			// pszFieldName
	NULL,					// pszIndexName
	CB_DBMAXTEXT_OID,			// dbcolumnMax
	0,					// dbgrbit
	JET_coltypText,				// dbcoltyp
	0,					// dbcolumnid
    },
    {	// ColumnType: STRING
	wszDummy,				// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_NAMES,				// dwTable
	szEXTENSIONVALUE,			// pszFieldName
	NULL,					// pszIndexName
	CB_DBMAXTEXT_RDN,			// dbcolumnMax
	0,					// dbgrbit
	JET_coltypLongText,			// dbcoltyp
	0,					// dbcolumnid
    },
    DBTABLE_NULL	// Termination marker
};
#endif


//---------------------------------------------------------------------------
//
// Certificate Extensions Table:
//
//---------------------------------------------------------------------------

DBTABLE g_adtCertExtensions[] =
{
#if (DTE_REQUESTID != 0)
#error -- bad DTE_REQUESTID index
#endif
    {	// ColumnType: DWORD
	wszPROPEXTREQUESTID,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_EXTENSIONS,			// dwTable
	szREQUESTID,				// pszFieldName
	szEXTENSION_REQUESTIDINDEX,		// pszIndexName
	0,					// dbcolumnMax
	JET_bitColumnFixed,			// dbgrbit
	JET_coltypLong,				// dbcoltyp
	0,					// dbcolumnid
    },
#if (DTE_EXTENSIONNAME != 1)
#error -- bad DTE_EXTENSIONNAME index
#endif
    {	// ColumnType: STRING
	wszPROPEXTNAME,				// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_INDEXREQUESTID,			// dwFlags
	CB_DBMAXTEXT_OID,			// dwcbMax
	TABLE_EXTENSIONS,			// dwTable
	szEXTENSIONNAME,			// pszFieldName
	szEXTENSION_REQUESTIDNAMEINDEX,		// pszIndexName
	CB_DBMAXTEXT_OID,			// dbcolumnMax
	0,					// dbgrbit
	JET_coltypText,				// dbcoltyp
	0,					// dbcolumnid
    },
#if (DTE_EXTENSIONFLAGS != 2)
#error -- bad DTE_EXTENSIONFLAGS index
#endif
    {	// ColumnType: DWORD
	wszPROPEXTFLAGS,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_EXTENSIONS,			// dwTable
	szEXTENSIONFLAGS,			// pszFieldName
	NULL,					// pszIndexName
	0,					// dbcolumnMax
	JET_bitColumnFixed,			// dbgrbit
	JET_coltypLong,				// dbcoltyp
	0,					// dbcolumnid
    },
#if (DTE_EXTENSIONRAWVALUE != 3)
#error -- bad DTE_EXTENSIONRAWVALUE index
#endif
    {	// ColumnType: BLOB
	wszPROPEXTRAWVALUE,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	CB_DBMAXBINARY,				// dwcbMax
	TABLE_EXTENSIONS,			// dwTable
	szEXTENSIONRAWVALUE,			// pszFieldName
	NULL,					// pszIndexName
	CB_DBMAXBINARY,				// dbcolumnMax
	0,					// dbgrbit
	JET_coltypLongBinary,			// dbcoltyp
	0,					// dbcolumnid
    },
#if (DTE_MAX != 4)
#error -- bad DTE_MAX index
#endif
    DBTABLE_NULL	// Termination marker
};


//---------------------------------------------------------------------------
//
// CRL Table:
//
//---------------------------------------------------------------------------

DBTABLE g_adtCRLs[] =
{
#if (DTL_ROWID != 0)
#error -- bad DTL_ROWID index
#endif
    {	// ColumnType: DWORD
	wszPROPCRLROWID,			// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_INDEXPRIMARY,			// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_CRLS,				// dwTable
	szCRLROWID,				// pszFieldName
        szCRL_ROWIDINDEX,			// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed | JET_bitColumnAutoincrement, // dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTL_NUMBER != 1)
#error -- bad DTL_NUMBER index
#endif
    {	// ColumnType: DWORD
	wszPROPCRLNUMBER,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_CRLS,				// dwTable
	szCRLNUMBER,				// pszFieldName
	szCRL_CRLNUMBERINDEX,			// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTL_MINBASE != 2)
#error -- bad DTL_MINBASE index
#endif
    {	// ColumnType: DWORD
	wszPROPCRLMINBASE,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_CRLS,				// dwTable
	szCRLMINBASE,				// pszFieldName
	NULL,					// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTL_NAMEID != 3)
#error -- bad DTL_NAMEID index
#endif
    {	// ColumnType: DWORD
	wszPROPCRLNAMEID,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_CRLS,				// dwTable
	szCRLNAMEID,				// pszFieldName
	NULL,					// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTL_COUNT != 4)
#error -- bad DTL_COUNT index
#endif
    {	// ColumnType: DWORD
	wszPROPCRLCOUNT,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_CRLS,				// dwTable
	szCRLCOUNT,				// pszFieldName
	NULL,					// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTL_THISUPDATEDATE != 5)
#error -- bad DTL_THISUPDATEDATE index
#endif
    {	// ColumnType: FILETIME
	wszPROPCRLTHISUPDATE,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(DATE),				// dwcbMax
	TABLE_CRLS,				// dwTable
	szCRLTHISUPDATE,			// pszFieldName
        NULL,					// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypDateTime,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTL_NEXTUPDATEDATE != 6)
#error -- bad DTL_NEXTUPDATEDATE index
#endif
    {	// ColumnType: FILETIME
	wszPROPCRLNEXTUPDATE,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(DATE),				// dwcbMax
	TABLE_CRLS,				// dwTable
	szCRLNEXTUPDATE,			// pszFieldName
	szCRL_CRLNEXTUPDATEINDEX,		// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypDateTime,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTL_THISPUBLISHDATE != 7)
#error -- bad DTL_THISPUBLISHDATE index
#endif
    {	// ColumnType: FILETIME
	wszPROPCRLTHISPUBLISH,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(DATE),				// dwcbMax
	TABLE_CRLS,				// dwTable
	szCRLTHISPUBLISH,			// pszFieldName
        NULL,					// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypDateTime,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTL_NEXTPUBLISHDATE != 8)
#error -- bad DTL_NEXTPUBLISHDATE index
#endif
    {	// ColumnType: FILETIME
	wszPROPCRLNEXTPUBLISH,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(DATE),				// dwcbMax
	TABLE_CRLS,				// dwTable
	szCRLNEXTPUBLISH,			// pszFieldName
        szCRL_CRLNEXTPUBLISHINDEX,		// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypDateTime,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTL_EFFECTIVEDATE != 9)
#error -- bad DTL_EFFECTIVEDATE index
#endif
    {	// ColumnType: FILETIME
	wszPROPCRLEFFECTIVE,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(DATE),				// dwcbMax
	TABLE_CRLS,				// dwTable
	szCRLEFFECTIVE,				// pszFieldName
	NULL,					// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypDateTime,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTL_PROPAGATIONCOMPLETEDATE != 10)
#error -- bad DTL_PROPAGATIONCOMPLETEDATE index
#endif
    {	// ColumnType: FILETIME
	wszPROPCRLPROPAGATIONCOMPLETE,		// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(DATE),				// dwcbMax
	TABLE_CRLS,				// dwTable
	szCRLPROPAGATIONCOMPLETE,		// pszFieldName
	szCRL_CRLPROPAGATIONCOMPLETEINDEX,	// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypDateTime,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTL_LASTPUBLISHEDDATE != 11)
#error -- bad DTL_LASTPUBLISHEDDATE index
#endif
    {	// ColumnType: FILETIME
	wszPROPCRLLASTPUBLISHED,		// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(DATE),				// dwcbMax
	TABLE_CRLS,				// dwTable
	szCRLLASTPUBLISHED,			// pszFieldName
	szCRL_CRLLASTPUBLISHEDINDEX,		// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypDateTime,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTL_PUBLISHATTEMPTS != 12)
#error -- bad DTL_PUBLISHATTEMPTS index
#endif
    {	// ColumnType: DWORD
	wszPROPCRLPUBLISHATTEMPTS,		// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_CRLS,				// dwTable
	szCRLPUBLISHATTEMPTS,			// pszFieldName
	szCRL_CRLPUBLISHATTEMPTSINDEX,		// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTL_PUBLISHFLAGS != 13)
#error -- bad DTL_PUBLISHFLAGS index
#endif
    {	// ColumnType: DWORD
	wszPROPCRLPUBLISHFLAGS,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_CRLS,				// dwTable
	szCRLPUBLISHFLAGS,			// pszFieldName
	NULL,					// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTL_PUBLISHSTATUSCODE != 14)
#error -- bad DTL_PUBLISHSTATUSCODE index
#endif
    {	// ColumnType: DWORD
	wszPROPCRLPUBLISHSTATUSCODE,		// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_CRLS,				// dwTable
	szCRLPUBLISHSTATUSCODE,			// pszFieldName
	szCRL_CRLPUBLSTATUSCODEISHINDEX,	// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTL_PUBLISHERROR != 15)
#error -- bad DTL_PUBLISHERROR index
#endif
    {	// ColumnType: STRING
	wszPROPCRLPUBLISHERROR,			// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_COLUMNRENAMED,			// dwFlags
	CB_DBMAXTEXT_DISPSTRING,		// dwcbMax
	TABLE_CRLS,				// dwTable
	szCRLPUBLISHERROR "\0" szCRLPUBLISHERROR_OLD, // pszFieldName
	NULL,					// pszIndexName
	CB_DBMAXTEXT_DISPSTRING,		// dwcbMax
	0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
	0,					// dbcolumnid
    },
#if (DTL_RAWCRL != 16)
#error -- bad DTL_RAWCRL index
#endif
    {	// ColumnType: BLOB
	wszPROPCRLRAWCRL,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	CB_DBMAXRAWCRL,				// dwcbMax
	TABLE_CRLS,				// dwTable
	szRAWCRL,				// pszFieldName
	NULL,					// pszIndexName
	CB_DBMAXRAWCRL,				// dbcolumnMax
	0,					// dbgrbit
	JET_coltypLongBinary,			// dbcoltyp
	0,					// dbcolumnid
    },
#if (DTL_MAX != 17)
#error -- bad DTL_MAX index
#endif
    DBTABLE_NULL	// Termination marker
};


DBAUXDATA g_dbauxRequests = {
    szREQUESTTABLE,				// pszTable
    szREQUEST_REQUESTIDINDEX,			// pszRowIdIndex
    NULL,					// pszRowIdNameIndex
    NULL,					// pszNameIndex
    &g_adtRequests[DTR_REQUESTID],		// pdtRowId
    NULL,					// pdtName
    NULL,					// pdtFlags
    NULL,					// pdtValue
    NULL,					// pdtIssuerNameId
};


DBAUXDATA g_dbauxCertificates = {
    szCERTIFICATETABLE,				// pszTable
    szCERTIFICATE_REQUESTIDINDEX,		// pszRowIdIndex
    NULL,					// pszRowIdNameIndex
    szCERTIFICATE_SERIALNUMBERINDEX,		// pszNameIndex
    &g_adtCertificates[DTC_REQUESTID],		// pdtRowId
    &g_adtCertificates[DTC_CERTIFICATESERIALNUMBER],// pdtName
    NULL,					// pdtFlags
    NULL,					// pdtValue
    &g_adtCertificates[DTC_CERTIFICATEISSUERNAMEID],// pdtIssuerNameId
};


DBAUXDATA g_dbauxAttributes = {
    szREQUESTATTRIBUTETABLE,			// pszTable
    szATTRIBUTE_REQUESTIDINDEX,			// pszRowIdIndex
    szATTRIBUTE_REQUESTIDNAMEINDEX,		// pszRowIdNameIndex
    NULL,					// pszNameIndex
    &g_adtRequestAttributes[DTA_REQUESTID],	// pdtRowId
    &g_adtRequestAttributes[DTA_ATTRIBUTENAME],	// pdtName
    NULL,					// pdtFlags
    &g_adtRequestAttributes[DTA_ATTRIBUTEVALUE],// pdtValue
    NULL,					// pdtIssuerNameId
};


DBAUXDATA g_dbauxExtensions = {
    szCERTIFICATEEXTENSIONTABLE,		// pszTable
    szEXTENSION_REQUESTIDINDEX,			// pszRowIdIndex
    szEXTENSION_REQUESTIDNAMEINDEX,		// pszRowIdNameIndex
    NULL,					// pszNameIndex
    &g_adtCertExtensions[DTE_REQUESTID],	// pdtRowId
    &g_adtCertExtensions[DTE_EXTENSIONNAME],	// pdtName
    &g_adtCertExtensions[DTE_EXTENSIONFLAGS],	// pdtFlags
    &g_adtCertExtensions[DTE_EXTENSIONRAWVALUE],// pdtValue
    NULL,					// pdtIssuerNameId
};


DBAUXDATA g_dbauxCRLs = {
    szCRLTABLE,					// pszTable
    szCRL_ROWIDINDEX,				// pszRowIdIndex
    NULL,					// pszRowIdNameIndex
    NULL,					// pszNameIndex
    &g_adtCRLs[DTL_ROWID],			// pdtRowId
    NULL,					// pdtName
    NULL,					// pdtFlags
    NULL,					// pdtValue
    &g_adtCRLs[DTL_NAMEID],			// pdtIssuerNameId
};


DBCREATETABLE const g_actDataBase[] = {
  { szCERTIFICATETABLE,          &g_dbauxCertificates, g_adtCertificates },
  { szREQUESTTABLE,		 &g_dbauxRequests,     g_adtRequests },
  { szREQUESTATTRIBUTETABLE,     &g_dbauxAttributes,   g_adtRequestAttributes },
//{ szNAMEEXTENSIONTABLE,        &g_dbauxNameExtensions, g_adtNameExtensions },
  { szCERTIFICATEEXTENSIONTABLE, &g_dbauxExtensions,   g_adtCertExtensions },
  { szCRLTABLE,                  &g_dbauxCRLs,         g_adtCRLs },
  { NULL,			 NULL,		       NULL },
};


// Note: Ordered DUPTABLE must include all Names Table columns.

DUPTABLE const g_dntr[] =
{
    { "Country",             wszPROPSUBJECTCOUNTRY, },
    { "Organization",        wszPROPSUBJECTORGANIZATION, },
    { "OrganizationalUnit",  wszPROPSUBJECTORGUNIT, },
    { "CommonName",          wszPROPSUBJECTCOMMONNAME, },
    { "Locality",            wszPROPSUBJECTLOCALITY, },
    { "StateOrProvince",     wszPROPSUBJECTSTATE, },
    { "Title",               wszPROPSUBJECTTITLE, },
    { "GivenName",           wszPROPSUBJECTGIVENNAME, },
    { "Initials",            wszPROPSUBJECTINITIALS, },
    { "SurName",             wszPROPSUBJECTSURNAME, },
    { "DomainComponent",     wszPROPSUBJECTDOMAINCOMPONENT, },
    { "EMailAddress",        wszPROPSUBJECTEMAIL, },
    { "StreetAddress",       wszPROPSUBJECTSTREETADDRESS, },
    { "UnstructuredName",    wszPROPSUBJECTUNSTRUCTUREDNAME, },
    { "UnstructuredAddress", wszPROPSUBJECTUNSTRUCTUREDADDRESS, },
    { "DeviceSerialNumber",  wszPROPSUBJECTDEVICESERIALNUMBER, },
    { NULL,		     NULL },
};


DWORD g_aColumnViewQueue[] =
{
    DTI_REQUESTTABLE | DTR_REQUESTID,
    DTI_REQUESTTABLE | DTR_REQUESTERNAME,
    DTI_REQUESTTABLE | DTR_REQUESTSUBMITTEDWHEN,
    DTI_REQUESTTABLE | DTR_REQUESTDISPOSITIONMESSAGE,
    DTI_REQUESTTABLE | DTR_COMMONNAME,
    DTI_REQUESTTABLE | DTR_EMAIL,
    DTI_REQUESTTABLE | DTR_ORGUNIT,
    DTI_REQUESTTABLE | DTR_ORGANIZATION,
    DTI_REQUESTTABLE | DTR_LOCALITY,
    DTI_REQUESTTABLE | DTR_STATE,
    DTI_REQUESTTABLE | DTR_COUNTRY,
    DTI_REQUESTTABLE | DTR_REQUESTRAWREQUEST,
    //DTI_REQUESTTABLE | DTR_REQUESTRAWARCHIVEDKEY,
    //DTI_REQUESTTABLE | DTR_REQUESTKEYRECOVERYHASHES,
    //DTI_REQUESTTABLE | DTR_STREETADDRESS,
    //DTI_REQUESTTABLE | DTR_TITLE,
    //DTI_REQUESTTABLE | DTR_GIVENNAME,
    //DTI_REQUESTTABLE | DTR_INITIALS,
    //DTI_REQUESTTABLE | DTR_SURNAME,
    //DTI_REQUESTTABLE | DTR_DOMAINCOMPONENT,
    //DTI_REQUESTTABLE | DTR_UNSTRUCTUREDNAME,
    //DTI_REQUESTTABLE | DTR_UNSTRUCTUREDADDRESS,
    //DTI_REQUESTTABLE | DTR_DEVICESERIALNUMBER,
    //DTI_REQUESTTABLE | DTR_RAWNAME,
    //DTI_REQUESTTABLE | DTR_REQUESTDISPOSITION,
    //DTI_REQUESTTABLE | DTR_REQUESTATTRIBUTES,
    //DTI_REQUESTTABLE | DTR_REQUESTTYPE,
    //DTI_REQUESTTABLE | DTR_REQUESTFLAGS,
    //DTI_REQUESTTABLE | DTR_REQUESTSTATUS,
    //DTI_REQUESTTABLE | DTR_REQUESTSTATUSCODE,
    //DTI_REQUESTTABLE | DTR_REQUESTRESOLVEDWHEN,
    //DTI_REQUESTTABLE | DTR_REQUESTREVOKEDWHEN,
    //DTI_REQUESTTABLE | DTR_REQUESTREVOKEDEFFECTIVEWHEN,
    //DTI_REQUESTTABLE | DTR_REQUESTREVOKEDREASON,
    //DTI_REQUESTTABLE | DTR_REQUESTERADDRESS,
    //DTI_REQUESTTABLE | DTR_SIGNERPOLICIES,
    //DTI_REQUESTTABLE | DTR_SIGNERAPPLICATIONPOLICIES,
    //DTI_REQUESTTABLE | DTR_DISTINGUISHEDNAME,
    //DTI_CERTIFICATETABLE | DTC_REQUESTID,
    //DTI_CERTIFICATETABLE | DTC_RAWCERTIFICATE,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATEHASH,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATETYPE,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATESERIALNUMBER,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATEISSUERNAMEID,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATENOTBEFOREDATE,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATENOTAFTERDATE,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATERAWPUBLICKEY,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATEPUBLICKEYALGORITHM,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATERAWPUBLICKEYALGORITHMPARAMETERS,
    //DTI_CERTIFICATETABLE | DTC_DISTINGUISHEDNAME,
    //DTI_CERTIFICATETABLE | DTC_RAWNAME,
    //DTI_CERTIFICATETABLE | DTC_COUNTRY,
    //DTI_CERTIFICATETABLE | DTC_ORGANIZATION,
    //DTI_CERTIFICATETABLE | DTC_ORGUNIT,
    //DTI_CERTIFICATETABLE | DTC_COMMONNAME,
    //DTI_CERTIFICATETABLE | DTC_LOCALITY,
    //DTI_CERTIFICATETABLE | DTC_STATE,
    //DTI_CERTIFICATETABLE | DTC_TITLE,
    //DTI_CERTIFICATETABLE | DTC_GIVENNAME,
    //DTI_CERTIFICATETABLE | DTC_INITIALS,
    //DTI_CERTIFICATETABLE | DTC_SURNAME,
    //DTI_CERTIFICATETABLE | DTC_DOMAINCOMPONENT,
    //DTI_CERTIFICATETABLE | DTC_EMAIL,
    //DTI_CERTIFICATETABLE | DTC_STREETADDRESS,
    //DTI_CERTIFICATETABLE | DTC_UNSTRUCTUREDNAME,
    //DTI_CERTIFICATETABLE | DTC_UNSTRUCTUREDADDRESS,
    //DTI_CERTIFICATETABLE | DTC_DEVICESERIALNUMBER,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATERAWSMIMECAPABILITIES,
};
DWORD g_cColumnViewQueue = ARRAYSIZE(g_aColumnViewQueue);


DWORD g_aColumnViewLog[] =
{
    DTI_REQUESTTABLE | DTR_REQUESTID,
    DTI_REQUESTTABLE | DTR_REQUESTERNAME,
    DTI_CERTIFICATETABLE | DTC_CERTIFICATESERIALNUMBER,
    DTI_CERTIFICATETABLE | DTC_CERTIFICATENOTBEFOREDATE,
    DTI_CERTIFICATETABLE | DTC_CERTIFICATENOTAFTERDATE,
    DTI_CERTIFICATETABLE | DTC_COMMONNAME,
    DTI_CERTIFICATETABLE | DTC_EMAIL,
    DTI_CERTIFICATETABLE | DTC_ORGUNIT,
    DTI_CERTIFICATETABLE | DTC_ORGANIZATION,
    DTI_CERTIFICATETABLE | DTC_LOCALITY,
    DTI_CERTIFICATETABLE | DTC_STATE,
    DTI_CERTIFICATETABLE | DTC_COUNTRY,
    DTI_CERTIFICATETABLE | DTC_RAWCERTIFICATE,
    //DTI_CERTIFICATETABLE | DTC_TITLE,
    //DTI_CERTIFICATETABLE | DTC_GIVENNAME,
    //DTI_CERTIFICATETABLE | DTC_INITIALS,
    //DTI_CERTIFICATETABLE | DTC_SURNAME,
    //DTI_CERTIFICATETABLE | DTC_DOMAINCOMPONENT,
    //DTI_CERTIFICATETABLE | DTC_UNSTRUCTUREDNAME,
    //DTI_CERTIFICATETABLE | DTC_UNSTRUCTUREDADDRESS,
    //DTI_CERTIFICATETABLE | DTC_DEVICESERIALNUMBER,
    //DTI_CERTIFICATETABLE | DTC_DISTINGUISHEDNAME,
    //DTI_CERTIFICATETABLE | DTC_STREETADDRESS,
    //DTI_REQUESTTABLE | DTR_REQUESTRAWREQUEST,
    //DTI_REQUESTTABLE | DTR_REQUESTRAWARCHIVEDKEY,
    //DTI_REQUESTTABLE | DTR_REQUESTKEYRECOVERYHASHES,
    //DTI_REQUESTTABLE | DTR_REQUESTATTRIBUTES,
    //DTI_REQUESTTABLE | DTR_REQUESTTYPE,
    //DTI_REQUESTTABLE | DTR_REQUESTFLAGS,
    //DTI_REQUESTTABLE | DTR_REQUESTSTATUS,
    //DTI_REQUESTTABLE | DTR_REQUESTSTATUSCODE,
    //DTI_REQUESTTABLE | DTR_REQUESTDISPOSITION,
    //DTI_REQUESTTABLE | DTR_REQUESTDISPOSITIONMESSAGE,
    //DTI_REQUESTTABLE | DTR_REQUESTSUBMITTEDWHEN,
    //DTI_REQUESTTABLE | DTR_REQUESTRESOLVEDWHEN,
    //DTI_REQUESTTABLE | DTR_REQUESTREVOKEDWHEN,
    //DTI_REQUESTTABLE | DTR_REQUESTREVOKEDEFFECTIVEWHEN,
    //DTI_REQUESTTABLE | DTR_REQUESTREVOKEDREASON,
    //DTI_REQUESTTABLE | DTR_REQUESTERADDRESS,
    //DTI_REQUESTTABLE | DTR_SIGNERPOLICIES,
    //DTI_REQUESTTABLE | DTR_SIGNERAPPLICATIONPOLICIES,
    //DTI_REQUESTTABLE | DTR_DISTINGUISHEDNAME,
    //DTI_REQUESTTABLE | DTR_RAWNAME,
    //DTI_REQUESTTABLE | DTR_COUNTRY,
    //DTI_REQUESTTABLE | DTR_ORGANIZATION,
    //DTI_REQUESTTABLE | DTR_ORGUNIT,
    //DTI_REQUESTTABLE | DTR_COMMONNAME,
    //DTI_REQUESTTABLE | DTR_LOCALITY,
    //DTI_REQUESTTABLE | DTR_STATE,
    //DTI_REQUESTTABLE | DTR_TITLE,
    //DTI_REQUESTTABLE | DTR_GIVENNAME,
    //DTI_REQUESTTABLE | DTR_INITIALS,
    //DTI_REQUESTTABLE | DTR_SURNAME,
    //DTI_REQUESTTABLE | DTR_DOMAINCOMPONENT,
    //DTI_REQUESTTABLE | DTR_EMAIL,
    //DTI_REQUESTTABLE | DTR_STREETADDRESS,
    //DTI_REQUESTTABLE | DTR_UNSTRUCTUREDNAME,
    //DTI_REQUESTTABLE | DTR_UNSTRUCTUREDADDRESS,
    //DTI_REQUESTTABLE | DTR_DEVICESERIALNUMBER,
    //DTI_CERTIFICATETABLE | DTC_REQUESTID,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATEHASH,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATETYPE,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATEISSUERNAMEID,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATERAWPUBLICKEY,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATEPUBLICKEYALGORITHM,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATERAWPUBLICKEYALGORITHMPARAMETERS,
    //DTI_CERTIFICATETABLE | DTC_RAWNAME,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATERAWSMIMECAPABILITIES,
};
DWORD g_cColumnViewLog = ARRAYSIZE(g_aColumnViewLog);


DWORD g_aColumnViewRevoked[] =
{
    DTI_REQUESTTABLE | DTR_REQUESTID,
    DTI_REQUESTTABLE | DTR_REQUESTERNAME,
    DTI_CERTIFICATETABLE | DTC_CERTIFICATESERIALNUMBER,
    DTI_CERTIFICATETABLE | DTC_CERTIFICATENOTBEFOREDATE,
    DTI_CERTIFICATETABLE | DTC_CERTIFICATENOTAFTERDATE,
    DTI_CERTIFICATETABLE | DTC_COMMONNAME,
    DTI_CERTIFICATETABLE | DTC_EMAIL,
    DTI_CERTIFICATETABLE | DTC_ORGUNIT,
    DTI_CERTIFICATETABLE | DTC_ORGANIZATION,
    DTI_CERTIFICATETABLE | DTC_LOCALITY,
    DTI_CERTIFICATETABLE | DTC_STATE,
    DTI_CERTIFICATETABLE | DTC_COUNTRY,
    DTI_CERTIFICATETABLE | DTC_RAWCERTIFICATE,
    //DTI_CERTIFICATETABLE | DTC_TITLE,
    //DTI_CERTIFICATETABLE | DTC_GIVENNAME,
    //DTI_CERTIFICATETABLE | DTC_INITIALS,
    //DTI_CERTIFICATETABLE | DTC_SURNAME,
    //DTI_CERTIFICATETABLE | DTC_DOMAINCOMPONENT,
    //DTI_CERTIFICATETABLE | DTC_UNSTRUCTUREDNAME,
    //DTI_CERTIFICATETABLE | DTC_UNSTRUCTUREDADDRESS,
    //DTI_CERTIFICATETABLE | DTC_DEVICESERIALNUMBER,
    //DTI_CERTIFICATETABLE | DTC_DISTINGUISHEDNAME,
    //DTI_CERTIFICATETABLE | DTC_STREETADDRESS,
    //DTI_REQUESTTABLE | DTR_REQUESTRAWREQUEST,
    //DTI_REQUESTTABLE | DTR_REQUESTRAWARCHIVEDKEY,
    //DTI_REQUESTTABLE | DTR_REQUESTKEYRECOVERYHASHES,
    //DTI_REQUESTTABLE | DTR_REQUESTATTRIBUTES,
    //DTI_REQUESTTABLE | DTR_REQUESTTYPE,
    //DTI_REQUESTTABLE | DTR_REQUESTFLAGS,
    //DTI_REQUESTTABLE | DTR_REQUESTSTATUS,
    //DTI_REQUESTTABLE | DTR_REQUESTSTATUSCODE,
    //DTI_REQUESTTABLE | DTR_REQUESTDISPOSITION,
    //DTI_REQUESTTABLE | DTR_REQUESTDISPOSITIONMESSAGE,
    //DTI_REQUESTTABLE | DTR_REQUESTSUBMITTEDWHEN,
    //DTI_REQUESTTABLE | DTR_REQUESTRESOLVEDWHEN,
    DTI_REQUESTTABLE | DTR_REQUESTREVOKEDWHEN,
    DTI_REQUESTTABLE | DTR_REQUESTREVOKEDEFFECTIVEWHEN,
    DTI_REQUESTTABLE | DTR_REQUESTREVOKEDREASON,
    //DTI_REQUESTTABLE | DTR_REQUESTERADDRESS,
    //DTI_REQUESTTABLE | DTR_SIGNERPOLICIES,
    //DTI_REQUESTTABLE | DTR_SIGNERAPPLICATIONPOLICIES,
    //DTI_REQUESTTABLE | DTR_DISTINGUISHEDNAME,
    //DTI_REQUESTTABLE | DTR_RAWNAME,
    //DTI_REQUESTTABLE | DTR_COUNTRY,
    //DTI_REQUESTTABLE | DTR_ORGANIZATION,
    //DTI_REQUESTTABLE | DTR_ORGUNIT,
    //DTI_REQUESTTABLE | DTR_COMMONNAME,
    //DTI_REQUESTTABLE | DTR_LOCALITY,
    //DTI_REQUESTTABLE | DTR_STATE,
    //DTI_REQUESTTABLE | DTR_TITLE,
    //DTI_REQUESTTABLE | DTR_GIVENNAME,
    //DTI_REQUESTTABLE | DTR_INITIALS,
    //DTI_REQUESTTABLE | DTR_SURNAME,
    //DTI_REQUESTTABLE | DTR_DOMAINCOMPONENT,
    //DTI_REQUESTTABLE | DTR_EMAIL,
    //DTI_REQUESTTABLE | DTR_STREETADDRESS,
    //DTI_REQUESTTABLE | DTR_UNSTRUCTUREDNAME,
    //DTI_REQUESTTABLE | DTR_UNSTRUCTUREDADDRESS,
    //DTI_REQUESTTABLE | DTR_DEVICESERIALNUMBER,
    //DTI_CERTIFICATETABLE | DTC_REQUESTID,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATEHASH,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATETYPE,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATEISSUERNAMEID,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATERAWPUBLICKEY,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATEPUBLICKEYALGORITHM,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATERAWPUBLICKEYALGORITHMPARAMETERS,
    //DTI_CERTIFICATETABLE | DTC_RAWNAME,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATERAWSMIMECAPABILITIES,
};
DWORD g_cColumnViewRevoked = ARRAYSIZE(g_aColumnViewRevoked);


DWORD g_aColumnViewExtension[] =
{
    DTI_EXTENSIONTABLE | DTE_REQUESTID,
    DTI_EXTENSIONTABLE | DTE_EXTENSIONNAME,
    DTI_EXTENSIONTABLE | DTE_EXTENSIONFLAGS,
    DTI_EXTENSIONTABLE | DTE_EXTENSIONRAWVALUE,
};
DWORD g_cColumnViewExtension = ARRAYSIZE(g_aColumnViewExtension);


DWORD g_aColumnViewAttribute[] =
{
    DTI_ATTRIBUTETABLE | DTA_REQUESTID,
    DTI_ATTRIBUTETABLE | DTA_ATTRIBUTENAME,
    DTI_ATTRIBUTETABLE | DTA_ATTRIBUTEVALUE,
};
DWORD g_cColumnViewAttribute = ARRAYSIZE(g_aColumnViewAttribute);


DWORD g_aColumnViewCRL[] =
{
    DTI_CRLTABLE | DTL_ROWID,
    DTI_CRLTABLE | DTL_NUMBER,
    DTI_CRLTABLE | DTL_MINBASE,
    DTI_CRLTABLE | DTL_NAMEID,
    DTI_CRLTABLE | DTL_COUNT,
    DTI_CRLTABLE | DTL_THISUPDATEDATE,
    DTI_CRLTABLE | DTL_NEXTUPDATEDATE,
    DTI_CRLTABLE | DTL_THISPUBLISHDATE,
    DTI_CRLTABLE | DTL_NEXTPUBLISHDATE,
    DTI_CRLTABLE | DTL_EFFECTIVEDATE,
    DTI_CRLTABLE | DTL_PROPAGATIONCOMPLETEDATE,
    DTI_CRLTABLE | DTL_RAWCRL,
};
DWORD g_cColumnViewCRL = ARRAYSIZE(g_aColumnViewCRL);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certdb\enum.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        enum.h
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------


#include "resource.h"       // main symbols

class CEnumCERTDBNAME: public IEnumCERTDBNAME
{
public:
    CEnumCERTDBNAME();
    ~CEnumCERTDBNAME();

    // IUnknown
    STDMETHODIMP QueryInterface(const IID& iid, void **ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IEnumCERTDBNAME
    STDMETHOD(Next)(
	/* [in] */  ULONG       celt,
	/* [out] */ CERTDBNAME *rgelt,
	/* [out] */ ULONG      *pceltFetched);
    
    STDMETHOD(Skip)(
	/* [in] */  LONG  celt,
	/* [out] */ LONG *pielt);
    
    STDMETHOD(Reset)(VOID);
    
    STDMETHOD(Clone)(
	/* [out] */ IEnumCERTDBNAME **ppenum);

    // CEnumCERTDBNAME
    HRESULT Open(
	IN ICertDBRow *prow,
	IN JET_TABLEID tableid,
	IN DWORD Flags);

private:
    VOID _Cleanup();

    ICertDBRow *m_prow;
    JET_TABLEID m_tableid;
    DWORD       m_Flags;
    BOOL        m_fNoMoreData;
    LONG        m_ielt;
    LONG        m_cskip;

    // Reference count
    long        m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certdb\dbw.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        dbw.h
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------


#if !defined(__DBW_H__)
#define __DBW_H__

#ifdef __cplusplus
extern "C" {
#endif

#if DBG

JET_ERR JET_API _dbgJetInit(JET_INSTANCE *pinstance);

JET_ERR JET_API _dbgJetTerm(JET_INSTANCE instance);

JET_ERR JET_API _dbgJetTerm2(JET_INSTANCE instance, JET_GRBIT grbit);

JET_ERR JET_API _dbgJetBackup(const char *szBackupPath, JET_GRBIT grbit, JET_PFNSTATUS pfnStatus);

JET_ERR JET_API _dbgJetRestore(const char *sz, JET_PFNSTATUS pfn);

JET_ERR JET_API _dbgJetRestore2(const char *sz, const char *szDest, JET_PFNSTATUS pfn);

JET_ERR JET_API _dbgJetSetSystemParameter(JET_INSTANCE *pinstance, JET_SESID sesid, unsigned long paramid, unsigned long lParam, const char *sz);

JET_ERR JET_API _dbgJetBeginSession(JET_INSTANCE instance, JET_SESID *psesid, const char *szUserName, const char *szPassword);

JET_ERR JET_API _dbgJetEndSession(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API _dbgJetCreateDatabase(JET_SESID sesid, const char *szFilename, const char *szConnect, JET_DBID *pdbid, JET_GRBIT grbit);

JET_ERR JET_API _dbgJetCreateTable(JET_SESID sesid, JET_DBID dbid, const char *szTableName, unsigned long lPages, unsigned long lDensity, JET_TABLEID *ptableid);

JET_ERR JET_API _dbgJetGetColumnInfo(JET_SESID sesid, JET_DBID dbid, const char *szTableName, const char *szColumnName, void *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API _dbgJetConvertDDL(JET_SESID sesid, JET_DBID ifmp, JET_OPDDLCONV convtyp, void *pvData, unsigned long cbData);

JET_ERR JET_API _dbgJetAddColumn(JET_SESID sesid, JET_TABLEID tableid, const char *szColumn, const JET_COLUMNDEF *pcolumndef, const void *pvDefault, unsigned long cbDefault, JET_COLUMNID *pcolumnid);

JET_ERR JET_API _dbgJetDeleteColumn(JET_SESID sesid, JET_TABLEID tableid, const char *szColumnName);

JET_ERR JET_API _dbgJetCreateIndex(JET_SESID sesid, JET_TABLEID tableid, const char *szIndexName, JET_GRBIT grbit, const char *szKey, unsigned long cbKey, unsigned long lDensity);

JET_ERR JET_API _dbgJetDeleteIndex(JET_SESID sesid, JET_TABLEID tableid, const char *szIndexName);

JET_ERR JET_API _dbgJetBeginTransaction(JET_SESID sesid);

JET_ERR JET_API _dbgJetCommitTransaction(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API _dbgJetRollback(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API _dbgJetOpenDatabase(JET_SESID sesid, const char *szFilename, const char *szConnect, JET_DBID *pdbid, JET_GRBIT grbit);

JET_ERR JET_API _dbgJetAttachDatabase(JET_SESID sesid, const char *szFilename, JET_GRBIT grbit);

JET_ERR JET_API _dbgJetCloseDatabase(JET_SESID sesid, JET_DBID dbid, JET_GRBIT grbit);

JET_ERR JET_API _dbgJetOpenTable(JET_SESID sesid, JET_DBID dbid, const char *szTableName, const void *pvParameters, unsigned long cbParameters, JET_GRBIT grbit, JET_TABLEID *ptableid);

JET_ERR JET_API _dbgJetCloseTable(JET_SESID sesid, JET_TABLEID tableid);

JET_ERR JET_API _dbgJetUpdate(JET_SESID sesid, JET_TABLEID tableid, void *pvBookmark, unsigned long cbBookmark, unsigned long *pcbActual);

JET_ERR JET_API _dbgJetDelete(JET_SESID sesid, JET_TABLEID tableid);

JET_ERR JET_API _dbgJetRetrieveColumn(JET_SESID sesid, JET_TABLEID tableid, JET_COLUMNID columnid, void *pvData, unsigned long cbData, unsigned long *pcbActual, JET_GRBIT grbit, JET_RETINFO *pretinfo);

JET_ERR JET_API _dbgJetSetColumn(JET_SESID sesid, JET_TABLEID tableid, JET_COLUMNID columnid, const void *pvData, unsigned long cbData, JET_GRBIT grbit, JET_SETINFO *psetinfo);

JET_ERR JET_API _dbgJetPrepareUpdate(JET_SESID sesid, JET_TABLEID tableid, unsigned long prep);

JET_ERR JET_API _dbgJetSetCurrentIndex2(JET_SESID sesid, JET_TABLEID tableid, const char *szIndexName, JET_GRBIT grbit);

JET_ERR JET_API _dbgJetMove(JET_SESID sesid, JET_TABLEID tableid, long cRow, JET_GRBIT grbit);

JET_ERR JET_API _dbgJetMakeKey(JET_SESID sesid, JET_TABLEID tableid, const void *pvData, unsigned long cbData, JET_GRBIT grbit);
JET_ERR JET_API _dbgJetSeek(JET_SESID sesid, JET_TABLEID tableid, JET_GRBIT grbit);

JET_ERR JET_API _dbgJetSetIndexRange(JET_SESID sesid, JET_TABLEID tableid, JET_GRBIT grbit);

JET_ERR JET_API _dbgJetRetrieveKey(JET_SESID sesid, JET_TABLEID tableid, void *pvData, unsigned long cbData, unsigned long *pcbActual, JET_GRBIT grbit);

JET_ERR JET_API _dbgJetBeginExternalBackup(JET_GRBIT grbit);

JET_ERR JET_API _dbgJetGetAttachInfo(void *pv,
	unsigned long cbMax,
	unsigned long *pcbActual);

JET_ERR JET_API _dbgJetOpenFile(const char *szFileName,
	JET_HANDLE	*phfFile,
	unsigned long *pulFileSizeLow,
	unsigned long *pulFileSizeHigh);

JET_ERR JET_API _dbgJetReadFile(JET_HANDLE hfFile,
	void *pv,
	unsigned long cb,
	unsigned long *pcb);

#if 0
JET_ERR JET_API _dbgJetAsyncReadFile(
	JET_HANDLE hfFile,
	void* pv,
	unsigned long cb,
	JET_OLP *pjolp);

JET_ERR JET_API _dbgJetCheckAsyncReadFile(void *pv, int cb, unsigned long pgnoFirst);
#endif

JET_ERR JET_API _dbgJetCloseFile(JET_HANDLE hfFile);

JET_ERR JET_API _dbgJetGetLogInfo(void *pv,
	unsigned long cbMax,
	unsigned long *pcbActual);

JET_ERR JET_API _dbgJetTruncateLog(void);

JET_ERR JET_API _dbgJetEndExternalBackup(void);

JET_ERR JET_API _dbgJetExternalRestore(char *szCheckpointFilePath, char *szLogPath, JET_RSTMAP *rgstmap, long crstfilemap, char *szBackupLogPath, long genLow, long genHigh, JET_PFNSTATUS pfn);

#else // DBG

#define _dbgJetInit			JetInit
#define _dbgJetTerm			JetTerm
#define _dbgJetTerm2			JetTerm2
#define _dbgJetBackup			JetBackup
#define _dbgJetRestore			JetRestore
#define _dbgJetRestore2			JetRestore2
#define _dbgJetSetSystemParameter	JetSetSystemParameter
#define _dbgJetBeginSession		JetBeginSession
#define _dbgJetEndSession		JetEndSession
#define _dbgJetCreateDatabase		JetCreateDatabase
#define _dbgJetCreateTable		JetCreateTable
#define _dbgJetGetColumnInfo		JetGetColumnInfo
#define _dbgJetConvertDDL		JetConvertDDL
#define _dbgJetAddColumn		JetAddColumn
#define _dbgJetDeleteColumn		JetDeleteColumn
#define _dbgJetCreateIndex		JetCreateIndex
#define _dbgJetDeleteIndex		JetDeleteIndex
#define _dbgJetBeginTransaction		JetBeginTransaction
#define _dbgJetCommitTransaction	JetCommitTransaction
#define _dbgJetRollback			JetRollback
#define _dbgJetAttachDatabase		JetAttachDatabase
#define _dbgJetOpenDatabase		JetOpenDatabase
#define _dbgJetCloseDatabase		JetCloseDatabase
#define _dbgJetOpenTable		JetOpenTable
#define _dbgJetCloseTable		JetCloseTable
#define _dbgJetUpdate			JetUpdate
#define _dbgJetDelete			JetDelete
#define _dbgJetRetrieveColumn		JetRetrieveColumn
#define _dbgJetSetColumn		JetSetColumn
#define _dbgJetPrepareUpdate		JetPrepareUpdate
#define _dbgJetSetCurrentIndex2		JetSetCurrentIndex2
#define _dbgJetMove			JetMove
#define _dbgJetMakeKey			JetMakeKey
#define _dbgJetSeek			JetSeek
#define _dbgJetSetIndexRange		JetSetIndexRange
#define _dbgJetRetrieveKey		JetRetrieveKey
#define _dbgJetBeginExternalBackup	JetBeginExternalBackup
#define _dbgJetGetAttachInfo		JetGetAttachInfo
#define _dbgJetOpenFile			JetOpenFile
#define _dbgJetReadFile			JetReadFile
#if 0
#define _dbgJetAsyncReadFile		JetAsyncReadFile
#define _dbgJetCheckAsyncReadFile	JetCheckAsyncReadFile
#endif
#define _dbgJetCloseFile		JetCloseFile
#define _dbgJetGetLogInfo		JetGetLogInfo
#define _dbgJetTruncateLog		JetTruncateLog
#define _dbgJetEndExternalBackup	JetEndExternalBackup
#define _dbgJetExternalRestore		JetExternalRestore

#endif // DBG

#ifdef __cplusplus
}
#endif

#endif /* __DBW_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certdb\enum.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        enum.cpp
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "csprop.h"
#include "row.h"
#include "enum.h"
#include "db.h"
#include "dbw.h"


#if DBG
LONG g_cCertDBName;
LONG g_cCertDBNameTotal;
#endif

CEnumCERTDBNAME::CEnumCERTDBNAME()
{
    DBGCODE(InterlockedIncrement(&g_cCertDBName));
    DBGCODE(InterlockedIncrement(&g_cCertDBNameTotal));
    m_prow = NULL;
    m_cRef = 1;
}


CEnumCERTDBNAME::~CEnumCERTDBNAME()
{
    DBGCODE(InterlockedDecrement(&g_cCertDBName));
    _Cleanup();
}


// CEnumCERTDBNAME implementation
VOID
CEnumCERTDBNAME::_Cleanup()
{
    if (NULL != m_prow)
    {
	((CCertDBRow *) m_prow)->EnumerateClose(m_tableid);
	m_prow->Release();
    }
}


HRESULT
CEnumCERTDBNAME::Open(
    IN ICertDBRow *prow,
    IN JET_TABLEID tableid,
    IN DWORD Flags)
{
    HRESULT hr;
    
    if (NULL == prow)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    prow->AddRef();

    m_fNoMoreData = FALSE;
    m_prow = prow;
    m_tableid = tableid;
    m_Flags = Flags;
    m_ielt = 0;
    m_cskip = 0;
    hr = S_OK;

error:
    return(hr);
}


// IEnumCERTDBNAME implementation
STDMETHODIMP
CEnumCERTDBNAME::Next(
    /* [in] */  ULONG       celt,
    /* [out] */ CERTDBNAME *rgelt,
    /* [out] */ ULONG      *pceltFetched)
{
    HRESULT hr;

    if (NULL == rgelt || NULL == pceltFetched)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *pceltFetched = 0;
    if (NULL == m_prow)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_prow");
    }
    if (m_fNoMoreData)
    {
	hr = S_FALSE;
	goto error;
    }

    CSASSERT(0 <= m_ielt);
    CSASSERT(0 <= m_ielt + m_cskip);
    DBGPRINT((
	DBG_SS_CERTDBI,
	"Enum::Next(celt=%d) ielt=%d, skip=%d\n",
	celt,
	m_ielt,
	m_cskip));

    hr = ((CCertDBRow *) m_prow)->EnumerateNext(
					&m_Flags,
					m_tableid,
					m_cskip,
					celt,
					rgelt,
					pceltFetched);
    if (S_FALSE == hr)
    {
	m_fNoMoreData = TRUE;
    }
    else
    {
	_JumpIfError(hr, error, "EnumerateNext");
    }
    m_ielt += m_cskip;
    m_ielt += *pceltFetched;
    m_cskip = 0;

error:
    return(hr);
}


STDMETHODIMP
CEnumCERTDBNAME::Skip(
    /* [in] */  LONG  celt,
    /* [out] */ LONG *pielt)
{
    HRESULT hr;
    LONG cskipnew;
    
    if (NULL == pielt)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (NULL == m_prow)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_prow");
    }
    cskipnew = m_cskip + celt;

    DBGPRINT((
	DBG_SS_CERTDBI,
	"Enum::Skip(%d) ielt=%d: %d --> %d, skip=%d --> %d\n",
	celt,
	m_ielt,
	m_ielt + m_cskip,
	m_ielt + cskipnew,
	m_cskip,
	cskipnew));

    CSASSERT(0 <= m_ielt);
    if (0 > cskipnew)
    {
	if (0 > m_ielt + cskipnew)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Skip back to before start");
	}
	m_fNoMoreData = FALSE;
    }

    *pielt = m_ielt + cskipnew;
    m_cskip = cskipnew;
    hr = S_OK;

error:
    return(hr);
}


STDMETHODIMP
CEnumCERTDBNAME::Reset(VOID)
{
    HRESULT hr;
    LONG iDummy;

    hr = Skip(-(m_ielt + m_cskip), &iDummy);
    _JumpIfError(hr, error, "Skip");

    CSASSERT(0 == iDummy);

error:
    return(hr);
}


STDMETHODIMP
CEnumCERTDBNAME::Clone(
    /* [out] */ IEnumCERTDBNAME **ppenum)
{
    HRESULT hr;
    LONG iDummy;

    if (NULL == ppenum)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppenum = NULL;
    if (NULL == m_prow)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_prow");
    }

    hr = ((CCertDBRow *) m_prow)->EnumCertDBName(
					    CIE_TABLE_MASK & m_Flags,
					    ppenum);
    _JumpIfError(hr, error, "EnumerateCertDBName");

    (*ppenum)->Skip(m_ielt + m_cskip, &iDummy);

error:
    return(hr);
}


// IUnknown implementation
STDMETHODIMP
CEnumCERTDBNAME::QueryInterface(
    const IID& iid,
    void **ppv)
{
    HRESULT hr;
    
    if (NULL == ppv)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (iid == IID_IUnknown)
    {
	*ppv = static_cast<IEnumCERTDBNAME *>(this);
    }
    else if (iid == IID_IEnumCERTDBNAME)
    {
	*ppv = static_cast<IEnumCERTDBNAME *>(this);
    }
    else
    {
	*ppv = NULL;
	hr = E_NOINTERFACE;
	_JumpError(hr, error, "IID");
    }
    reinterpret_cast<IUnknown *>(*ppv)->AddRef();
    hr = S_OK;

error:
    return(hr);
}


ULONG STDMETHODCALLTYPE
CEnumCERTDBNAME::AddRef()
{
    return(InterlockedIncrement(&m_cRef));
}


ULONG STDMETHODCALLTYPE
CEnumCERTDBNAME::Release()
{
    ULONG cRef = InterlockedDecrement(&m_cRef);

    if (0 == cRef)
    {
	delete this;
    }
    return(cRef);
}


#if 0
STDMETHODIMP
CEnumCERTDBNAME::InterfaceSupportsErrorInfo(
    IN REFIID riid)
{
    static const IID *arr[] =
    {
	&IID_IEnumCERTDBNAME,
    };

    for (int i = 0; i < sizeof(arr)/sizeof(arr[0]); i++)
    {
	if (InlineIsEqualGUID(*arr[i], riid))
	{
	    return(S_OK);
	}
    }
    return(S_FALSE);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certdb\resource.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        resource.h
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------


//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by certdb.rc
//
#define IDS_CERTDB_DESC		1
#define IDS_CERTDBRESTORE_DESC	2



// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certdb\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
//---------------------------------------------------------------------------

#define __DIR__		"certdb"

#include <windows.h>
#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>
#include "certdb.h"
#include <esent.h>
#include <certsrv.h>
#include "dbtable.h"
#include "certlib.h"
#include "csdisp.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certdb\restore.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        restore.cpp
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "db.h"
#include "dbw.h"
#include "restore.h"


#if DBG
LONG g_cCertDBRestore;
LONG g_cCertDBRestoreTotal;
#endif

CCertDBRestore::CCertDBRestore()
{
    DBGCODE(InterlockedIncrement(&g_cCertDBRestore));
    DBGCODE(InterlockedIncrement(&g_cCertDBRestoreTotal));
}


CCertDBRestore::~CCertDBRestore()
{
    DBGCODE(InterlockedDecrement(&g_cCertDBRestore));
    _Cleanup();
}


VOID
CCertDBRestore::_Cleanup()
{
}


HRESULT
CCertDBRestore::RecoverAfterRestore(
    IN DWORD cSession,
    IN WCHAR const *pwszEventSource,
    IN WCHAR const *pwszLogDir,
    IN WCHAR const *pwszSystemDir,
    IN WCHAR const *pwszTempDir,
    IN WCHAR const *pwszCheckPointFile,
    IN WCHAR const *pwszLogPath,
    IN CSEDB_RSTMAPW rgrstmap[],
    IN LONG crstmap,
    IN WCHAR const *pwszBackupLogPath,
    IN DWORD genLow,
    IN DWORD genHigh)
{
    HRESULT hr;
    LONG i;
    char *pszCheckPointFile = NULL;
    char *pszLogPath = NULL;
    char *pszBackupLogPath = NULL;
    JET_RSTMAP *arstmap = NULL;
    JET_INSTANCE Instance = 0;

    // Call into JET to let it munge the databases.  Note that the JET
    // interpretation of LogPath and BackupLogPath is totally wierd, and we
    // want to pass in LogPath to both parameters.

    hr = E_OUTOFMEMORY;

    if ((NULL != pwszCheckPointFile &&
	 !ConvertWszToSz(&pszCheckPointFile, pwszCheckPointFile, -1)) ||
	(NULL != pwszLogPath &&
	 !ConvertWszToSz(&pszLogPath, pwszLogPath, -1)) ||
	(NULL != pwszBackupLogPath &&
	 !ConvertWszToSz(&pszBackupLogPath, pwszBackupLogPath, -1)))
    {
	_JumpError(hr, error, "ConvertWszToSz");
    }
    arstmap = (JET_RSTMAP *) LocalAlloc(
				    LMEM_FIXED | LMEM_ZEROINIT,
				    crstmap * sizeof(*arstmap));
    if (NULL == arstmap)
    {
	_JumpError(hr, error, "ConvertWszToSz");
    }
    for (i = 0; i < crstmap; i++)
    {
	if (!ConvertWszToSz(
			&arstmap[i].szDatabaseName,
			rgrstmap[i].pwszDatabaseName,
			-1) ||
	    !ConvertWszToSz(
			&arstmap[i].szNewDatabaseName,
			rgrstmap[i].pwszNewDatabaseName,
			-1))
	{
	    _JumpError(hr, error, "ConvertWszToSz");
	}
    }

    hr = DBInitParms(
		cSession,
                FALSE, // no circular logging
		pwszEventSource,
		pwszLogDir,
		pwszSystemDir,
		pwszTempDir,
		&Instance);
    _JumpIfError(hr, error, "DBInitParms");

    hr = _dbgJetExternalRestore(
			pszCheckPointFile,
			pszLogPath, 	
			arstmap,
			crstmap,
			pszLogPath,
			genLow,
			genHigh,
			NULL);
    hr = myJetHResult(hr);
    _JumpIfError(hr, error, "JetExternalRestore");

error:
    DBFreeParms();
    if (NULL != arstmap)
    {
	for (i = 0; i < crstmap; i++)
	{
	    if (NULL != arstmap[i].szDatabaseName)
	    {
		LocalFree(arstmap[i].szDatabaseName);
	    }
	    if (NULL != arstmap[i].szNewDatabaseName)
	    {
		LocalFree(arstmap[i].szNewDatabaseName);
	    }
	}
	LocalFree(arstmap);
    }
    if (NULL != pszCheckPointFile)
    {
	LocalFree(pszCheckPointFile);
    }
    if (NULL != pszLogPath)
    {
	LocalFree(pszLogPath);
    }
    if (NULL != pszBackupLogPath)
    {
	LocalFree(pszBackupLogPath);
    }
    return(hr);
}


STDMETHODIMP
CCertDBRestore::InterfaceSupportsErrorInfo(
    IN REFIID riid)
{
    static const IID *arr[] =
    {
	&IID_ICertDBRestore,
    };

    for (int i = 0; i < sizeof(arr)/sizeof(arr[0]); i++)
    {
	if (InlineIsEqualGUID(*arr[i], riid))
	{
	    return(S_OK);
	}
    }
    return(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certdb\restore.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        restore.h
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------


#include "resource.h"       // main symbols

class CCertDBRestore:
    public ICertDBRestore,
    public ISupportErrorInfo,
    public CComObjectRoot,
    public CComCoClass<CCertDBRestore, &CLSID_CCertDBRestore>
{
public:
    CCertDBRestore();
    ~CCertDBRestore();

BEGIN_COM_MAP(CCertDBRestore)
    COM_INTERFACE_ENTRY(ICertDBRestore)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertDBRestore) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(
    CCertDBRestore,
    wszCLASS_CERTDBRESTORE TEXT(".1"),
    wszCLASS_CERTDBRESTORE,
    IDS_CERTDBRESTORE_DESC,
    THREADFLAGS_BOTH)

    // ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    // ICertDBRestore
public:
    STDMETHOD(RecoverAfterRestore)(
	/* [in] */ DWORD cSession,
	/* [in] */ WCHAR const *pwszEventSource,
	/* [in] */ WCHAR const *pwszLogDir,
	/* [in] */ WCHAR const *pwszSystemDir,
	/* [in] */ WCHAR const *pwszTempDir,
	/* [in] */ WCHAR const *pwszCheckPointFile,
	/* [in] */ WCHAR const *pwszLogPath,
	/* [in] */ CSEDB_RSTMAPW rgrstmap[],
	/* [in] */ LONG crstmap,
	/* [in] */ WCHAR const *pwszBackupLogPath,
	/* [in] */ DWORD genLow,
	/* [in] */ DWORD genHigh);

private:
    VOID _Cleanup();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certdb\view.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        view.h
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------


#include "resource.h"       // main symbols

// defines for multi-thread handling
typedef enum
{
    ENUMTHREAD_OPEN = 0,
    ENUMTHREAD_NEXT,
    ENUMTHREAD_CLEANUP,
    ENUMTHREAD_END
} ENUMTHREADCALLS;


class CEnumCERTDBRESULTROW: public IEnumCERTDBRESULTROW
{
public:
    CEnumCERTDBRESULTROW(BOOL fThreading = TRUE);
    ~CEnumCERTDBRESULTROW();

    // IUnknown
    STDMETHODIMP QueryInterface(const IID& iid, void **ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IEnumCERTDBRESULTROW
    STDMETHOD(Next)(
	/* [in] */  ULONG            celt,
	/* [out] */ CERTDBRESULTROW *rgelt,
	/* [out] */ ULONG           *pceltFetched);

    STDMETHOD(ReleaseResultRow)(
	/* [in] */      ULONG            celt,
	/* [in, out] */ CERTDBRESULTROW *rgelt);
    
    STDMETHOD(Skip)(
	/* [in] */  LONG  celt,
	/* [out] */ LONG *pielt);
    
    STDMETHOD(Reset)(VOID);
    
    STDMETHOD(Clone)(
	/* [out] */ IEnumCERTDBRESULTROW **ppenum);

    // CEnumCERTDBRESULTROW
    HRESULT Open(
	IN CERTSESSION *pcs,
	IN ICertDB *pdb,
	IN DWORD ccvr,
	IN CERTVIEWRESTRICTION const *acvr,
	IN DWORD ccolOut,
	IN DWORD const *acolOut);

private:
    VOID _Cleanup();

    HRESULT _SetTable(
	IN LONG ColumnIndex,
	OUT LONG *pColumnIndexDefault);

    HRESULT _SaveRestrictions(
	IN DWORD ccvrIn,
	IN CERTVIEWRESTRICTION const *acvrIn,
	IN LONG ColumnIndexDefault);

    // multi-thread handling
    static DWORD WINAPI _ViewWorkThreadFunctionHelper(LPVOID lp);
    HRESULT _HandleThreadError();
    HRESULT _ThreadOpen(DWORD dwCallerThreadID);
    HRESULT _ThreadNext(DWORD dwCallerThreadID);
    VOID    _ThreadCleanup(DWORD dwCallerThreadID);
    DWORD   _ViewWorkThreadFunction(VOID);

    ICertDB             *m_pdb;
    CERTSESSION         *m_pcs;
    CERTVIEWRESTRICTION *m_aRestriction;
    DWORD                m_cRestriction;
    DWORD                m_ccolOut;
    DWORD               *m_acolOut;
    BOOL                 m_fNoMoreData;
    LONG                 m_ieltMax;
    LONG                 m_ielt;
    LONG                 m_cskip;

    // thread stuff
    HANDLE               m_hWorkThread;
    HANDLE               m_hViewEvent;
    HANDLE               m_hReturnEvent;
    HRESULT              m_hrThread;
    ENUMTHREADCALLS      m_enumViewCall;
    VOID                *m_pThreadParam;
    BOOL                 m_fThreading;
//#if DBG_CERTSRV
    DWORD                m_dwCallerThreadId;
//#endif

    // Reference count
    long                 m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certdb\view.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        view.cpp
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "csprop.h"
#include "column.h"
#include "enum.h"
#include "db.h"
#include "row.h"
#include "view.h"

#if DBG_CERTSRV
#define  THREAD_TIMEOUT    INFINITE
#else
#define  THREAD_TIMEOUT    INFINITE    // used to be 10000ms=10 seconds
#endif

#if DBG
LONG g_cCertDBResultRow;
LONG g_cCertDBResultRowTotal;
#endif

#ifdef DBG_CERTSRV_DEBUG_PRINT
DWORD s_ssDB = DBG_SS_CERTDBI;
#endif

#if DBG_CERTSRV
VOID
dbDumpFileTime(
    IN DWORD dwSubSystemId,
    IN CHAR const *pszPrefix,
    IN FILETIME const *pft);
#endif

typedef struct
{
    CERTSESSION *pcs;
    ICertDB *pdb;
    DWORD ccvr;
    CERTVIEWRESTRICTION const *acvr;
    DWORD ccolOut;
    DWORD const *acolOut;
} THREAD_PARAM_OPEN;

typedef struct
{
    ULONG            celt;
    CERTDBRESULTROW *rgelt;
    ULONG           *pceltFetched;
} THREAD_PARAM_NEXT;



CEnumCERTDBRESULTROW::CEnumCERTDBRESULTROW(
    IN BOOL fThreading) :
    m_fThreading(fThreading)
{
    DBGCODE(InterlockedIncrement(&g_cCertDBResultRow));
    DBGCODE(InterlockedIncrement(&g_cCertDBResultRowTotal));
    m_pdb = NULL;
    m_pcs = NULL;
    m_aRestriction = NULL;
    m_acolOut = NULL;
    m_cRef = 1;
    m_ieltMax = 0;
    m_hWorkThread = NULL;
    m_hViewEvent = NULL;
    m_hrThread = S_OK;
    m_hReturnEvent = NULL;
    m_enumViewCall = ENUMTHREAD_END;
    m_pThreadParam = NULL;
//#if DBG_CERTSRV
    m_dwCallerThreadId = 0;
//#endif
}


CEnumCERTDBRESULTROW::~CEnumCERTDBRESULTROW()
{
    HRESULT hr;

    DBGCODE(InterlockedDecrement(&g_cCertDBResultRow));
    _Cleanup();

}


// The following is the worker thread procedure to handle calls.
// All view calls will be made in this thread.

DWORD WINAPI
CEnumCERTDBRESULTROW::_ViewWorkThreadFunctionHelper(
    LPVOID lpParam)
{
    HRESULT hr = S_OK;

    DBGPRINT((s_ssDB, "worker thread (tid=%d) is created.\n", GetCurrentThreadId()));

    if (NULL == lpParam)
    {
        hr = E_POINTER;
        _PrintError(hr, "null pointer, kill worker thread unexpectedly");
        ExitThread(hr);
    }

    // call real one

    return (((CEnumCERTDBRESULTROW*)lpParam)->_ViewWorkThreadFunction());
}


DWORD
CEnumCERTDBRESULTROW::_ViewWorkThreadFunction(VOID)
{
    HRESULT  hr = S_OK;

    while (TRUE)
    {
        if (WAIT_OBJECT_0 == WaitForSingleObject(m_hViewEvent, INFINITE))
        {
            switch (m_enumViewCall)
            {
                case ENUMTHREAD_OPEN:
                    // call open
                    m_hrThread = _ThreadOpen(m_dwCallerThreadId);
                    if (!SetEvent(m_hReturnEvent))
                    {
                        hr = myHLastError();
                        _PrintError(hr, "SetEvent");
                    }
                break;

                case ENUMTHREAD_NEXT:
                    // call next
                    m_hrThread = _ThreadNext(m_dwCallerThreadId);
                    if (!SetEvent(m_hReturnEvent))
                    {
                        hr = myHLastError();
                        _PrintError(hr, "SetEvent");
                    }
                break;

                case ENUMTHREAD_CLEANUP:
                    // call cleanup
                    _ThreadCleanup(m_dwCallerThreadId);
                    m_hrThread = S_OK;
                    if (!SetEvent(m_hReturnEvent))
                    {
                        hr = myHLastError();
                        _PrintError(hr, "SetEvent");
                    }
                break;

                case ENUMTHREAD_END:
                    DBGPRINT((s_ssDB, "End worker thread (tid=%d)\n", GetCurrentThreadId()));
                    ExitThread(hr);
                break;

                default:
                    // unexpected
                    DBGPRINT((DBG_SS_CERTDB, "Unexpected event from (tid=%d)\n", m_dwCallerThreadId));
                    m_hrThread = E_UNEXPECTED;
                    if (!SetEvent(m_hReturnEvent))
                    {
                        hr = myHLastError();
                        _PrintError(hr, "SetEvent");
                    }
                    CSASSERT(FALSE);
                break;
            }
        }
    }
    return(hr);
}


VOID
CEnumCERTDBRESULTROW::_Cleanup()
{
    HRESULT hr;

    if (!m_fThreading)
    {
        CSASSERT(NULL == m_hWorkThread);
        _ThreadCleanup(0);	// no work thread, call directly
    }
    else
    {
        if (NULL != m_hWorkThread &&
            NULL != m_hViewEvent &&
            NULL != m_hReturnEvent)
        {
	    // ask work thread to do clean up
	    m_enumViewCall = ENUMTHREAD_CLEANUP;
//#if DBG_CERTSRV
	    m_dwCallerThreadId = GetCurrentThreadId();
	    DBGPRINT((
		s_ssDB,
		"CEnumCERTDBRESULTROW::_Cleanup(tid=%d) (this=0x%x)\n",
		m_dwCallerThreadId,
		this));
//#endif
	    //set cleanup event
	    if (!SetEvent(m_hViewEvent))
	    {
		hr = myHLastError();
		_PrintError(hr, "SetEvent");
	    }
	    else
	    {
		hr = _HandleThreadError();
		_PrintIfError(hr, "_HandleThreadError");
	    }

	    // ask the thread end
	    m_enumViewCall = ENUMTHREAD_END;
	    if (!SetEvent(m_hViewEvent))
	    {
		hr = myHLastError();
		_PrintError(hr, "SetEvent(thread still alive");
	    }
	    else
	    {
		if (WAIT_OBJECT_0 != WaitForSingleObject(m_hWorkThread, THREAD_TIMEOUT))
		{
		    hr = myHLastError();
		    _PrintError(hr, "Thread is not killed");
		}
	    }
	    if (GetExitCodeThread(m_hWorkThread, (DWORD *) &hr))
	    {
		_PrintIfError(hr, "Work thread error");
	    }

            m_pThreadParam = NULL; //may not be necessary, but safe
	}
	if (NULL != m_hWorkThread)
	{
	    CloseHandle(m_hWorkThread);
	    m_hWorkThread = NULL;
	}
	if (NULL != m_hViewEvent)
	{
	    CloseHandle(m_hViewEvent);
	    m_hViewEvent = NULL;
	}
	if (NULL != m_hReturnEvent)
	{
	    CloseHandle(m_hReturnEvent);
	    m_hReturnEvent = NULL;
	}
    }
    if (NULL != m_pdb)
    {
	m_pdb->Release();
	m_pdb = NULL;
    }
}


VOID
CEnumCERTDBRESULTROW::_ThreadCleanup(DWORD dwCallerThreadID)
{
    HRESULT hr;
    DWORD i;

    if (NULL != m_pdb)
    {
	if (NULL != m_pcs)
	{
	    hr = ((CCertDB *) m_pdb)->CloseTables(m_pcs);
	    _PrintIfError(hr, "CloseTables");

	    hr = ((CCertDB *) m_pdb)->ReleaseSession(m_pcs);
	    _PrintIfError(hr, "ReleaseSession");
	    m_pcs = NULL;
	}
	if (NULL != m_aRestriction)
	{
	    for (i = 0; i < m_cRestriction; i++)
	    {
		if (NULL != m_aRestriction[i].pbValue)
		{
		    LocalFree(m_aRestriction[i].pbValue);
		}
	    }
	    LocalFree(m_aRestriction);
	    m_aRestriction = NULL;
	}
	if (NULL != m_acolOut)
	{
	    LocalFree(m_acolOut);
	    m_acolOut = NULL;
	}
    }
}


HRESULT
CEnumCERTDBRESULTROW::_HandleThreadError()
{
    HRESULT hr = S_OK;
    HANDLE ahEvents[] = { m_hReturnEvent, m_hWorkThread };

    // need to handle error
    DWORD dwWaitState = WaitForMultipleObjects(
                            ARRAYSIZE(ahEvents),
                            ahEvents,
                            FALSE,
                            THREAD_TIMEOUT);

    // reset
    m_pThreadParam = NULL;
//#if DBG_CERTSRV
    //m_dwCallerThreadId = 0;
//#endif

    if (WAIT_OBJECT_0 == dwWaitState)
    {
        // signaled from work thread
        hr = m_hrThread;
    }
    else if (WAIT_OBJECT_0 + 1 == dwWaitState)
    {
        // work thread ended unexpectedly
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "work thread is ended unexpectedly");
    }
    else if (WAIT_TIMEOUT == dwWaitState)
    {
        hr = HRESULT_FROM_WIN32(ERROR_TIMEOUT);
        _JumpError(hr, error, "WaitForSingleObject(timeout)");
    }
    else if (WAIT_FAILED == dwWaitState)
    {
        hr = myHLastError();
        _JumpError(hr, error, "WaitForSingleObject");
    }

error:
    return(hr);
}


// Truncate FILETIME to next lower minute and add lMinuteCount minutes (if !0)

HRESULT
myMakeExprDateMinuteRound(
    IN OUT FILETIME *pft,
    IN LONG lMinuteCount)
{
    HRESULT hr;
    SYSTEMTIME st;

#if DBG_CERTSRV
    dbDumpFileTime(DBG_SS_CERTDBI, "MinuteRound(IN):  ", pft);
#endif
    FileTimeToSystemTime(pft, &st);
    st.wSecond = 0;
    st.wMilliseconds = 0;

    if (!SystemTimeToFileTime(&st, pft))
    {
	hr = myHLastError();
	_JumpError(hr, error, "SystemTimeToFileTime");
    }
    if (0 != lMinuteCount)
    {
	myMakeExprDateTime(pft, lMinuteCount, ENUM_PERIOD_MINUTES);
    }
#if DBG_CERTSRV
    dbDumpFileTime(DBG_SS_CERTDBI, "MinuteRound(OUT): ", pft);
#endif
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CEnumCERTDBRESULTROW::_SetTable(
    IN LONG ColumnIndex,
    OUT LONG *pColumnIndexDefault)
{
    HRESULT hr;
    DWORD dwTable;
    LONG ColumnIndexDefault;
    
    if (0 > ColumnIndex)
    {
	switch (ColumnIndex)
	{
	    case CV_COLUMN_LOG_DEFAULT:
	    case CV_COLUMN_LOG_FAILED_DEFAULT:
	    case CV_COLUMN_LOG_REVOKED_DEFAULT:
	    case CV_COLUMN_QUEUE_DEFAULT:
		ColumnIndex = DTI_REQUESTTABLE;
		break;

	    case CV_COLUMN_EXTENSION_DEFAULT:
		ColumnIndex = DTI_EXTENSIONTABLE;
		break;

	    case CV_COLUMN_ATTRIBUTE_DEFAULT:
		ColumnIndex = DTI_ATTRIBUTETABLE;
		break;

	    case CV_COLUMN_CRL_DEFAULT:
		ColumnIndex = DTI_CRLTABLE;
		break;

	    default:
		hr = E_INVALIDARG;
		_JumpError(hr, error, "bad negative ColumnIndex");
	}
    }
    if (~(DTI_COLUMNMASK | DTI_TABLEMASK) & ColumnIndex)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "invalid bits");
    }
    switch (DTI_TABLEMASK & ColumnIndex)
    {
	case DTI_REQUESTTABLE:
	case DTI_CERTIFICATETABLE:
	    dwTable = TABLE_REQCERTS;
	    ColumnIndexDefault = DTI_REQUESTTABLE | DTR_REQUESTID;
	    break;

	case DTI_EXTENSIONTABLE:
	    dwTable = TABLE_EXTENSIONS;
	    ColumnIndexDefault = DTI_EXTENSIONTABLE | DTE_REQUESTID;
	    break;

	case DTI_ATTRIBUTETABLE:
	    dwTable = TABLE_ATTRIBUTES;
	    ColumnIndexDefault = DTI_ATTRIBUTETABLE | DTA_REQUESTID;
	    break;

	case DTI_CRLTABLE:
	    dwTable = TABLE_CRLS;
	    ColumnIndexDefault = DTI_CRLTABLE | DTL_ROWID;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "bad table");
    }
    if (CSF_TABLESET & m_pcs->SesFlags)
    {
	if ((CSF_TABLEMASK & m_pcs->SesFlags) != dwTable)
	{
	    DBGPRINT((
		DBG_SS_CERTVIEW,
		"_SetTable: Table=%x <- %x\n",
		CSF_TABLEMASK & m_pcs->SesFlags,
		dwTable));
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "mixed tables");
	}
    }
    else
    {
	CSASSERT(0 == (CSF_TABLEMASK & m_pcs->SesFlags));
	m_pcs->SesFlags |= CSF_TABLESET | dwTable;
    }
    *pColumnIndexDefault = ColumnIndexDefault;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CEnumCERTDBRESULTROW::_SaveRestrictions(
    IN DWORD ccvrIn,
    IN CERTVIEWRESTRICTION const *acvrIn,
    IN LONG ColumnIndexDefault)
{
    HRESULT hr;
    DWORD ccvrAlloc;
    CERTVIEWRESTRICTION const *pcvr;
    CERTVIEWRESTRICTION const *pcvrEnd;
    CERTVIEWRESTRICTION const *pcvrIndexed;
    CERTVIEWRESTRICTION *pcvrDst;
    BOOL fFoundSortOrder;
    BOOL fDefault;
    DWORD dwDefaultValue;
    DWORD Type;
    FILETIME ft;
    
    ccvrAlloc = ccvrIn;
    pcvrIndexed = NULL;
    fFoundSortOrder = FALSE;
    pcvrEnd = &acvrIn[ccvrIn];
    for (pcvr = acvrIn; pcvr < pcvrEnd; pcvr++)     // for each restriction
    {
        fDefault = 0 > (LONG) pcvr->ColumnIndex;
        if (!fDefault)
        {
            hr = ((CCertDB *) m_pdb)->GetColumnType(pcvr->ColumnIndex, &Type);
            _JumpIfError(hr, error, "GetColumnType");
        }
	if (fDefault || (PROPFLAGS_INDEXED & Type))
	{
	    if (!fFoundSortOrder && CVR_SORT_NONE != pcvr->SortOrder)
	    {
		// if the first indexed column with sort order, save this one.

		fFoundSortOrder = TRUE;
		pcvrIndexed = pcvr;
	    }
	    else
	    if (NULL == pcvrIndexed)
	    {
		// if the first indexed column, save this one.

		pcvrIndexed = pcvr;
	    }
	}
	if (CVR_SORT_NONE != pcvr->SortOrder && pcvrIndexed != pcvr)
	{
	    hr = E_INVALIDARG;
	    DBGPRINT((DBG_SS_CERTDB, "_SaveRestrictions(%x)\n", pcvr->ColumnIndex));
	    _JumpError(hr, error, "multiple SortOrders or non-indexed column");
	}
        if (!fDefault &&
            PROPTYPE_DATE == (PROPTYPE_MASK & Type) &&
            CVR_SEEK_EQ == pcvr->SeekOperator)
        {
            ccvrAlloc++;	// Turn Date == value into a range restriction
        }
    }
    if (NULL == pcvrIndexed)
    {
        ccvrAlloc++;	// No indexed column: add RequestId >= 0
    }

    m_aRestriction = (CERTVIEWRESTRICTION *) LocalAlloc(
					LMEM_FIXED | LMEM_ZEROINIT,
					ccvrAlloc * sizeof(m_aRestriction[0]));
    if (NULL == m_aRestriction)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    m_cRestriction = ccvrAlloc;
    
    pcvrDst = m_aRestriction;
    
    // If no indexed restriction, add one.
    if (NULL == pcvrIndexed)
    {
        pcvrDst->ColumnIndex = ColumnIndexDefault;
        pcvrDst->SeekOperator = CVR_SEEK_NONE;
        pcvrDst->SortOrder = CVR_SORT_ASCEND;
        pcvrDst->cbValue = 0;
        pcvrDst->pbValue = NULL;

        pcvrDst++;
    }

    for (pcvr = acvrIn; pcvr < pcvrEnd; pcvr++)
    {
        CERTVIEWRESTRICTION const *pcvrSrc = pcvr;
        BYTE *pbValue;
        
        // Swap the first restriction with the first indexed restriction
        
        if (NULL != pcvrIndexed)
        {
            if (pcvrSrc == acvrIn)
            {
                pcvrSrc = pcvrIndexed;
            }
            else if (pcvrSrc == pcvrIndexed)
            {
                pcvrSrc = acvrIn;
            }
        }
        *pcvrDst = *pcvrSrc;

        if (pcvrSrc == pcvrIndexed && CVR_SORT_NONE == pcvrSrc->SortOrder)
	{
	    pcvrDst->SortOrder = CVR_SORT_ASCEND;
	}
        pcvrDst->pbValue = NULL;
        
        fDefault = 0 > (LONG) pcvr->ColumnIndex;
        if (fDefault)
        {
            pcvrDst->SeekOperator = CVR_SEEK_GE; // default seek operator
	    dwDefaultValue = 1;			 // default RequestId/Rowid
	    switch (pcvr->ColumnIndex)
	    {
		case CV_COLUMN_QUEUE_DEFAULT:
		case CV_COLUMN_LOG_DEFAULT:
		case CV_COLUMN_LOG_FAILED_DEFAULT:
		case CV_COLUMN_LOG_REVOKED_DEFAULT:
		    pcvrDst->ColumnIndex = DTI_REQUESTTABLE | DTR_REQUESTDISPOSITION;
		    if (CV_COLUMN_QUEUE_DEFAULT == pcvrDst->ColumnIndex)
		    {
			dwDefaultValue = DB_DISP_QUEUE_MAX;
			pcvrDst->SeekOperator = CVR_SEEK_LE;
		    }
		    else if (CV_COLUMN_LOG_DEFAULT == pcvrDst->ColumnIndex)
		    {
			dwDefaultValue = DB_DISP_LOG_MIN;
		    }
		    else if (CV_COLUMN_LOG_REVOKED_DEFAULT == pcvrDst->ColumnIndex)
		    {
			dwDefaultValue = DB_DISP_REVOKED;
			pcvrDst->SeekOperator = CVR_SEEK_EQ;
		    }
		    else
		    {
			dwDefaultValue = DB_DISP_LOG_FAILED_MIN;
		    }
		    break;

		case CV_COLUMN_EXTENSION_DEFAULT:
		    pcvrDst->ColumnIndex = DTI_EXTENSIONTABLE | DTE_REQUESTID;
		    break;

		case CV_COLUMN_ATTRIBUTE_DEFAULT:
		    pcvrDst->ColumnIndex = DTI_ATTRIBUTETABLE | DTA_REQUESTID;
		    break;

		case CV_COLUMN_CRL_DEFAULT:
		    pcvrDst->ColumnIndex = DTI_CRLTABLE | DTL_ROWID;
		    break;

		default:
		    hr = E_INVALIDARG;
		    _JumpError(hr, error, "bad default restriction column");
		    break;
	    }
            pcvrDst->cbValue = sizeof(dwDefaultValue);
            pbValue = (BYTE *) &dwDefaultValue;
        }
        else
        {
            // To handle rounding errors, modify date restrictions as follows:
            //
            // DateColumn == Constant ==> two restrictions:
            //     DateColumn < Ceiling(Constant) &&
            //     DateColumn >= Floor(Constant)
            //
            // DateColumn > Constant ==> DateColumn >= Ceiling(Constant)
            // DateColumn >= Constant ==> DateColumn >= Floor(Constant)
            //
            // DateColumn < Constant ==> DateColumn < Floor(Constant) 
            // DateColumn <= Constant ==> DateColumn < Ceiling(Constant)
            
            hr = ((CCertDB *) m_pdb)->GetColumnType(
						pcvrDst->ColumnIndex,
						&Type);
            _JumpIfError(hr, error, "GetColumnType");
            
            pbValue = pcvrSrc->pbValue;

            if (PROPTYPE_DATE == (PROPTYPE_MASK & Type) &&
                0 == (CVR_SEEK_NODELTA & pcvrDst->SeekOperator) &&
                CVR_SEEK_NONE != (CVR_SEEK_MASK & pcvrDst->SeekOperator))
            {
                LONG lMinuteCount = 0;	// assume truncate to lower minute

                if(NULL == pcvrSrc->pbValue)
                {
                    hr = E_INVALIDARG;
                    _JumpError(hr, error, "restriction value is null");
                }
		ft = *(FILETIME *) pcvrSrc->pbValue;
                pbValue = (BYTE *) &ft;
                
                switch (CVR_SEEK_MASK & pcvrDst->SeekOperator)
                {
		    FILETIME ftCeiling;

		    case CVR_SEEK_EQ:
			ftCeiling = ft;
			hr = myMakeExprDateMinuteRound(&ftCeiling, 1);
			_JumpIfError(hr, error, "myMakeExprDateMinuteRound");

			pcvrDst->pbValue = (BYTE *) LocalAlloc(
							    LMEM_FIXED,
							    sizeof(ft));
			if (NULL == pcvrDst->pbValue)
			{
			    hr = E_OUTOFMEMORY;
			    _JumpError(hr, error, "LocalAlloc");
			}
			CopyMemory(pcvrDst->pbValue, &ftCeiling, pcvrDst->cbValue);
			pcvrDst->SeekOperator = CVR_SEEK_LT | CVR_SEEK_NODELTA;
			pcvrDst++;
			
			*pcvrDst = *pcvrSrc;
			pcvrDst->pbValue = NULL;
			pcvrDst->SeekOperator = CVR_SEEK_GE | CVR_SEEK_NODELTA;
			hr = myMakeExprDateMinuteRound(&ft, 0);
			_JumpIfError(hr, error, "myMakeExprDateMinuteRound");

			break;
			
		    case CVR_SEEK_GT:
			lMinuteCount = 1;	// round to next higher minute
			// FALL THROUGH

		    case CVR_SEEK_GE:
			pcvrDst->SeekOperator = CVR_SEEK_GE | CVR_SEEK_NODELTA;
			hr = myMakeExprDateMinuteRound(&ft, lMinuteCount);
			_JumpIfError(hr, error, "myMakeExprDateMinuteRound");

			break;

		    case CVR_SEEK_LE:
			lMinuteCount = 1;	// round to next higher minute
			// FALL THROUGH

		    case CVR_SEEK_LT:
			pcvrDst->SeekOperator = CVR_SEEK_LT | CVR_SEEK_NODELTA;
			hr = myMakeExprDateMinuteRound(&ft, lMinuteCount);
			_JumpIfError(hr, error, "myMakeExprDateMinuteRound");

			break;

		    default:
		    hr = E_INVALIDARG;
		    _JumpError(hr, error, "invalid seek operator");
			
                }
            }
        }
        
        // either nonzero or SEEK_NONE
        CSASSERT((0 != pcvrDst->cbValue) || ((CVR_SEEK_MASK & pcvrDst->SeekOperator) == CVR_SEEK_NONE));

        if (0 != pcvrDst->cbValue)
        {
            pcvrDst->pbValue = (BYTE *) LocalAlloc(LMEM_FIXED, pcvrDst->cbValue);
            if (NULL == pcvrDst->pbValue)
            {
                hr = E_OUTOFMEMORY;
                _JumpError(hr, error, "alloc value");
            }
            CopyMemory(pcvrDst->pbValue, pbValue, pcvrDst->cbValue);
        }
        pcvrDst++;
    }
    CSASSERT(pcvrDst == &m_aRestriction[m_cRestriction]);

#if DBG_CERTSRV
    pcvrEnd = &m_aRestriction[m_cRestriction];
    for (pcvr = m_aRestriction; pcvr < pcvrEnd; pcvr++)
    {
	((CCertDB *) m_pdb)->DumpRestriction(
				DBG_SS_CERTDBI,
				SAFE_SUBTRACT_POINTERS(pcvr, m_aRestriction),
				pcvr);
    }
#endif // DBG_CERTSRV

    hr = S_OK;

error:
    return(hr);
}



HRESULT
CEnumCERTDBRESULTROW::Open(
    IN CERTSESSION *pcs,
    IN ICertDB *pdb,
    IN DWORD ccvr,
    IN CERTVIEWRESTRICTION const *acvr,
    IN DWORD ccolOut,
    IN DWORD const *acolOut)
{
    HRESULT hr;
    THREAD_PARAM_OPEN  tpOpen;

    CSASSERT(NULL == m_hViewEvent);
    CSASSERT(NULL == m_hReturnEvent);
    CSASSERT(NULL == m_hWorkThread);

    if (NULL != m_hViewEvent ||
        NULL != m_hReturnEvent ||
        NULL != m_hWorkThread)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "unexpected thread sync. state");
    }

    hr = ((CCertDB *) pdb)->TestShutDownState();
    _JumpIfError(hr, error, "TestShutDownState");

    // call cleanup before worker thread is created

    _Cleanup();

    tpOpen.pcs = pcs;
    tpOpen.pdb = pdb;
    tpOpen.ccvr = ccvr;
    tpOpen.acvr = acvr;
    tpOpen.ccolOut = ccolOut;
    tpOpen.acolOut = acolOut;
    m_pThreadParam = (void*)&tpOpen;
//#if DBG_CERTSRV
    m_dwCallerThreadId = GetCurrentThreadId();
    DBGPRINT((s_ssDB, "CEnumCERTDBRESULTROW::Open(tid=%d) (this=0x%x)\n", m_dwCallerThreadId, this));
//#endif

    if (m_fThreading)
    {
        m_hViewEvent = CreateEvent(
                            NULL,  //child inheritance
                            FALSE,  //manual reset
                            FALSE, //initial signaled
                            NULL); //name
        if (NULL == m_hViewEvent)
        {
            hr = myHLastError();
            _JumpError(hr, error, "CreateEvent");
        }

        m_hReturnEvent = CreateEvent(
                            NULL,  //child inheritance
                            FALSE,  //manual reset
                            FALSE, //initial signaled
                            NULL); //name
        if (NULL == m_hReturnEvent)
        {
            hr = myHLastError();
            _JumpError(hr, error, "CreateEvent");
        }

        m_hWorkThread = CreateThread(
			NULL,  //no child inheritance
			0,     //use default stack size
			_ViewWorkThreadFunctionHelper, // thread function
			this,  //pass this pointer
			0,     //run immediately
			&pcs->dwThreadId); //session thread id is overwritten
        if (NULL == m_hWorkThread)
        {
            hr = myHLastError();
            _JumpError(hr, error, "CreateThread");
        }

        m_enumViewCall = ENUMTHREAD_OPEN;
        //set open event
        if (!SetEvent(m_hViewEvent))
        {
            hr = myHLastError();
            _JumpError(hr, error, "SetEvent");
        }
        else
        {
            hr = _HandleThreadError();
        }
    }
    else
    {
        // don't go through worker thread

        hr = _ThreadOpen(0);
    }
    //hr = S_OK;

error:
    return(hr);
}

HRESULT
CEnumCERTDBRESULTROW::_ThreadOpen(DWORD dwCallerThreadID)
{
    HRESULT hr;
    THREAD_PARAM_OPEN *ptpOpen = (THREAD_PARAM_OPEN *)m_pThreadParam;
    LONG ColumnIndexDefault = DTI_REQUESTTABLE | DTR_REQUESTID;
    DWORD i;

    DBGPRINT((s_ssDB, "CEnumCERTDBRESULTROW::ThreadOpen(tid=%d) from (tid=%d)\n", GetCurrentThreadId(), m_dwCallerThreadId));

    CSASSERT(NULL != ptpOpen);
    CSASSERTTHREAD(ptpOpen->pcs);

    if (NULL == ptpOpen->pcs ||
	NULL == ptpOpen->pdb ||
	(NULL == ptpOpen->acvr && 0 != ptpOpen->ccvr) ||
	NULL == ptpOpen->acolOut)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    m_fNoMoreData = FALSE;
    m_pcs = ptpOpen->pcs;
    m_pdb = ptpOpen->pdb;
    m_pdb->AddRef();
    m_ielt = 0;
    m_cskip = 0;

    CSASSERT(0 == m_pcs->cTransact);
    if (NULL != ptpOpen->acolOut)
    {
	for (i = 0; i < ptpOpen->ccolOut; i++)
	{
	    hr = _SetTable(ptpOpen->acolOut[i], &ColumnIndexDefault);
	    _JumpIfError(hr, error, "_SetTable");
	}
    }
    for (i = 0; i < ptpOpen->ccvr; i++)
    {
	hr = _SetTable(ptpOpen->acvr[i].ColumnIndex, &ColumnIndexDefault);
	_JumpIfError(hr, error, "_SetTable");
    }

    hr = _SaveRestrictions(ptpOpen->ccvr, ptpOpen->acvr, ColumnIndexDefault);
    _JumpIfError(hr, error, "_SaveRestrictions");

    m_ccolOut = ptpOpen->ccolOut;
    if (NULL != ptpOpen->acolOut)
    {
	m_acolOut = (DWORD *) LocalAlloc(
				    LMEM_FIXED,
				    sizeof(m_acolOut[0]) * m_ccolOut);
	if (NULL == m_acolOut)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "alloc output columns");
	}
	CopyMemory(m_acolOut, ptpOpen->acolOut, sizeof(m_acolOut[0]) * m_ccolOut);
    }

    if (!(CSF_READONLY & ptpOpen->pcs->SesFlags))
    {
	hr = ((CCertDB *) m_pdb)->BeginTransaction(m_pcs, FALSE);
	_JumpIfError(hr, error, "BeginTransaction");
    }
    hr = ((CCertDB *) m_pdb)->OpenTables(m_pcs, &m_aRestriction[0]);
    _PrintIfError2(hr, "OpenTables", CERTSRV_E_PROPERTY_EMPTY);

    if (CERTSRV_E_PROPERTY_EMPTY == hr)
    {
	m_fNoMoreData = TRUE;
	m_ieltMax = 0;
	hr = S_OK;
    }
    _JumpIfError(hr, error, "OpenTables");

error:
    return(hr);
}


STDMETHODIMP
CEnumCERTDBRESULTROW::Next(
    /* [in] */  ULONG            celt,
    /* [out] */ CERTDBRESULTROW *rgelt,
    /* [out] */ ULONG           *pceltFetched)
{
    HRESULT hr;
    THREAD_PARAM_NEXT  tpNext;

    tpNext.celt = celt;
    tpNext.rgelt = rgelt;
    tpNext.pceltFetched = pceltFetched;
    m_pThreadParam = (void*)&tpNext;
//#if DBG_CERTSRV
    m_dwCallerThreadId = GetCurrentThreadId();
    DBGPRINT((s_ssDB, "CEnumCERTDBRESULTROW::Next(tid=%d) (this=0x%x)\n", m_dwCallerThreadId, this));
//#endif

    CSASSERT(NULL != m_pdb);
    if (NULL == m_pdb)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_pdb");
    }
    hr = ((CCertDB *) m_pdb)->TestShutDownState();
    _JumpIfError(hr, error, "TestShutDownState");

    if (m_fThreading)
    {
        CSASSERT(NULL != m_hViewEvent);
        CSASSERT(NULL != m_hReturnEvent);
        CSASSERT(NULL != m_hWorkThread);

        if (NULL == m_hViewEvent ||
            NULL == m_hReturnEvent ||
            NULL == m_hWorkThread)
        {
            hr = E_UNEXPECTED;
            _JumpError(hr, error, "unexpected thread sync. state");
        }

        m_enumViewCall = ENUMTHREAD_NEXT;

        // set next event

        if (!SetEvent(m_hViewEvent))
        {
            hr = myHLastError();
            _JumpError(hr, error, "SetEvent");
        }
        else
        {
            hr = _HandleThreadError();
        }
    }
    else
    {
        // don't go through worker thread

        hr = _ThreadNext(0);
    }
    //hr = S_OK;

error:
    return(hr);
}


HRESULT
CEnumCERTDBRESULTROW::_ThreadNext(DWORD dwCallerThreadID)
{
    HRESULT hr;
    LONG cskip;
    LONG cskipped;
    THREAD_PARAM_NEXT  *ptpNext = (THREAD_PARAM_NEXT *)m_pThreadParam;

    DBGPRINT((s_ssDB, "CEnumCERTDBRESULTROW::ThreadNext(tid=%d) from (tid=%d)\n", GetCurrentThreadId(), m_dwCallerThreadId));
    CSASSERT(NULL != ptpNext);

    DBGPRINT((
	DBG_SS_CERTDBI,
	"Trace: hr = penum->Next(%d, arow, &crow);\t_PrintIfError(hr, \"Next\");\n",
	ptpNext->celt));
    if (NULL == ptpNext->rgelt || NULL == ptpNext->pceltFetched)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ptpNext->pceltFetched = 0;
    if (NULL == m_pdb)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_pdb");
    }
    ZeroMemory(ptpNext->rgelt, ptpNext->celt * sizeof(ptpNext->rgelt[0]));

    CSASSERT(0 <= m_ielt);
    CSASSERT(0 <= m_ielt + m_cskip);
    DBGPRINT((
	DBG_SS_CERTDBI,
	"Next(celt=%d) ielt=%d, skip=%d\n",
	ptpNext->celt,
	m_ielt,
	m_cskip));

    hr = S_FALSE;
    if (m_fNoMoreData)
    {
	// We know no additional data can be returned until Reset is called or
	// until Skip is called with a negative skip count.  Don't bother...

	_JumpError2(hr, error, "NoMoreData", S_FALSE);
    }

    // If we have previously computed the end of the data set, ...

    cskip = m_cskip;
    if (0 != m_ieltMax)
    {
	if (m_ielt + cskip >= m_ieltMax)
	{
	    // The requested data lies past the computed end of the data set.

	    CSASSERT(S_FALSE == hr);
	    m_fNoMoreData = TRUE;
	    _JumpError2(hr, error, "past end", S_FALSE);
	}

	DBGPRINT((
	    DBG_SS_CERTDBI,
	    "cskip = %d  m_ielt = %d  m_ieltMax = %d\n",
	    cskip,
	    m_ielt,
	    m_ieltMax));
	if (0 > cskip && m_ielt > m_ieltMax)
	{
	    // We're skiping backwards.  If we started out past the end of the
	    // data set, we must reduce the negative skip count passed to the
	    // DB layer to position the index cursor correctly.

	    cskip += m_ielt - m_ieltMax;
	    DBGPRINT((
		DBG_SS_CERTDBI,
		"MODIFIED: cskip = %d  m_ielt = %d  m_ieltMax = %d\n",
		cskip,
		m_ielt,
		m_ieltMax));
	}
    }

    hr = ((CCertDB *) m_pdb)->EnumCertDBResultRowNext(
						m_pcs,
						m_cRestriction,
						m_aRestriction,
						m_ccolOut,
						m_acolOut,
						cskip,
						ptpNext->celt,
						ptpNext->rgelt,
						ptpNext->pceltFetched,
						&cskipped);
    if (S_FALSE == hr)
    {
	// Only set m_ieltMax the first time we run off the end, when we will
	// be guaranteed that we are moving forward through the DB index.
	// Otherwise the math is too complicated and would be redundant anyway.
	
	if (0 == m_ieltMax)
	{
	    CSASSERT(0 <= cskip);
	    CSASSERT(0 <= cskipped);
	    m_ieltMax = m_ielt + cskipped;
	}
	DBGPRINT((
	    DBG_SS_CERTDBI,
	    "Next: ieltMax=%d  ielt=%d, cskipped=%d\n",
	    m_ieltMax,
	    m_ielt,
	    cskipped));
	m_fNoMoreData = TRUE;
    }
    else
    {
	_JumpIfError(hr, error, "EnumCertDBResultRowNext");
    }

    DBGPRINT((
	DBG_SS_CERTDBI,
	"Next: ielt=%d -> %d  cskip=%d, *pceltFetched=%d\n",
	m_ielt,
	m_ielt + m_cskip + *ptpNext->pceltFetched,
	m_cskip,
	*ptpNext->pceltFetched));

    m_ielt += m_cskip;
    m_ielt += *ptpNext->pceltFetched;
    m_cskip = 0;

error:
    if (S_FALSE == hr)
    {
	CSASSERT(NULL != ptpNext->rgelt);
	CSASSERT(NULL != ptpNext->pceltFetched);
	CSASSERT(*ptpNext->pceltFetched < ptpNext->celt);
	CERTDBRESULTROW *peltMaxIndex = &ptpNext->rgelt[*ptpNext->pceltFetched];

	peltMaxIndex->rowid = m_ieltMax;
	peltMaxIndex->ccol = ~m_ieltMax;
    }
    return(hr);
}


STDMETHODIMP
CEnumCERTDBRESULTROW::ReleaseResultRow(
    /* [in] */      ULONG            celt,
    /* [in, out] */ CERTDBRESULTROW *rgelt)
{
    HRESULT hr;

    if (NULL == rgelt)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (NULL == m_pdb)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_pdb");
    }
    hr = ((CCertDB *) m_pdb)->ReleaseResultRow(celt, rgelt);
    _JumpIfError(hr, error, "ReleaseResultRow");

error:
    return(hr);
}


STDMETHODIMP
CEnumCERTDBRESULTROW::Skip(
    /* [in] */  LONG  celt,
    /* [out] */ LONG *pielt)
{
    HRESULT hr;
    LONG cskipnew;
    
    DBGPRINT((
	DBG_SS_CERTDBI,
	"Trace: hr = penum->Skip(%d, &irow);\t_PrintIfError(hr, \"Skip\");\n",
	celt));
    if (NULL == pielt)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    cskipnew = m_cskip + celt;

    DBGPRINT((
	DBG_SS_CERTDBI,
	"Skip(%d) ielt=%d: %d --> %d, skip=%d --> %d\n",
	celt,
	m_ielt,
	m_ielt + m_cskip,
	m_ielt + cskipnew,
	m_cskip,
	cskipnew));

    CSASSERT(0 <= m_ielt);
    if (0 > celt)
    {
	if (0 > m_ielt + cskipnew)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Skip back to before start");
	}
	m_fNoMoreData = FALSE;
    }

    *pielt = m_ielt + cskipnew;
    m_cskip = cskipnew;
    hr = S_OK;

error:
    return(hr);
}


STDMETHODIMP
CEnumCERTDBRESULTROW::Reset(VOID)
{
    HRESULT hr;
    LONG iDummy;

    DBGPRINT((
	DBG_SS_CERTDBI,
	"Trace: hr = penum->Reset();\t_PrintIfError(hr, \"Reset\");\n// "));
    hr = Skip(-(m_ielt + m_cskip), &iDummy);
    _JumpIfError(hr, error, "Skip");

    CSASSERT(0 == iDummy);

error:
    return(hr);
}


STDMETHODIMP
CEnumCERTDBRESULTROW::Clone(
    /* [out] */ IEnumCERTDBRESULTROW **ppenum)
{
    HRESULT hr;
    LONG iDummy;

    if (NULL == ppenum)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppenum = NULL;
    if (NULL == m_pdb)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_pdb");
    }
    hr = ((CCertDB *) m_pdb)->TestShutDownState();
    _JumpIfError(hr, error, "TestShutDownState");

    hr = ((CCertDB *) m_pdb)->OpenView(
				    m_cRestriction,
				    m_aRestriction,
				    m_ccolOut,
				    m_acolOut,
				    m_fThreading,
				    ppenum);
    _JumpIfError(hr, error, "OpenView");

    (*ppenum)->Skip(m_ielt + m_cskip, &iDummy);

error:
    return(hr);
}


// IUnknown implementation
STDMETHODIMP
CEnumCERTDBRESULTROW::QueryInterface(
    const IID& iid,
    void **ppv)
{
    HRESULT hr;
    
    if (NULL == ppv)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (iid == IID_IUnknown)
    {
	*ppv = static_cast<IEnumCERTDBRESULTROW *>(this);
    }
    else if (iid == IID_IEnumCERTDBRESULTROW)
    {
	*ppv = static_cast<IEnumCERTDBRESULTROW *>(this);
    }
    else
    {
	*ppv = NULL;
	hr = E_NOINTERFACE;
	_JumpError(hr, error, "IID");
    }
    reinterpret_cast<IUnknown *>(*ppv)->AddRef();
    hr = S_OK;

error:
    return(hr);
}


ULONG STDMETHODCALLTYPE
CEnumCERTDBRESULTROW::AddRef()
{
    return(InterlockedIncrement(&m_cRef));
}


ULONG STDMETHODCALLTYPE
CEnumCERTDBRESULTROW::Release()
{
    ULONG cRef = InterlockedDecrement(&m_cRef);

    if (0 == cRef)
    {
	delete this;
    }
    return(cRef);
}


#if 0
STDMETHODIMP
CEnumCERTDBRESULTROW::InterfaceSupportsErrorInfo(
    IN REFIID riid)
{
    static const IID *arr[] =
    {
	&IID_IEnumCERTDBRESULTROW,
    };

    for (int i = 0; i < sizeof(arr)/sizeof(arr[0]); i++)
    {
	if (InlineIsEqualGUID(*arr[i], riid))
	{
	    return(S_OK);
	}
    }
    return(S_FALSE);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certdb\row.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        row.cpp
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "csdisp.h"
#include "csprop.h"
#include "row.h"
#include "enum.h"
#include "db.h"
#include "dbw.h"


#if DBG
LONG g_cCertDBRow;
LONG g_cCertDBRowTotal;
#endif

CCertDBRow::CCertDBRow()
{
    DBGCODE(InterlockedIncrement(&g_cCertDBRow));
    DBGCODE(InterlockedIncrement(&g_cCertDBRowTotal));
    m_pdb = NULL;
    m_pcs = NULL;
    m_cRef = 1;
}


CCertDBRow::~CCertDBRow()
{
    DBGCODE(InterlockedDecrement(&g_cCertDBRow));
    _Cleanup();
}


VOID
CCertDBRow::_Cleanup()
{
    HRESULT hr;

    if (NULL != m_pdb)
    {
	if (NULL != m_pcs)
	{
	    hr = ((CCertDB *) m_pdb)->CloseTables(m_pcs);
	    _PrintIfError(hr, "CloseTables");

	    hr = ((CCertDB *) m_pdb)->ReleaseSession(m_pcs);
	    _PrintIfError(hr, "ReleaseSession");
	    m_pcs = NULL;
	}
	m_pdb->Release();
	m_pdb = NULL;
    }
}


HRESULT
CCertDBRow::Open(
    IN CERTSESSION *pcs,
    IN ICertDB *pdb,
    OPTIONAL IN CERTVIEWRESTRICTION const *pcvr)
{
    HRESULT hr;
    DWORD dwTemp;
    DWORD cbActual;
    bool fBeginTransaction = false;

    _Cleanup();

    if (NULL == pcs || NULL == pdb)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    m_pdb = pdb;
    m_pdb->AddRef();

    CSASSERT(0 == pcs->cTransact);
    if (!(CSF_READONLY & pcs->SesFlags))
    {
	hr = ((CCertDB *) m_pdb)->BeginTransaction(pcs, FALSE);
	_JumpIfError(hr, error, "BeginTransaction");
    }
    fBeginTransaction = true;

    hr = ((CCertDB *) m_pdb)->OpenTables(pcs, pcvr);
    _JumpIfError2(hr, error, "OpenTables", CERTSRV_E_PROPERTY_EMPTY);

    m_pcs = pcs;

error:

    if (S_OK != hr)
    {
        if(fBeginTransaction && !(CSF_READONLY & pcs->SesFlags))
        {
	    HRESULT hr2;
	    
	    hr2 = ((CCertDB *) m_pdb)->CommitTransaction(pcs, FALSE);
	    _PrintIfError(hr2, "CommitTransaction");
        }

	_Cleanup();
    }
    return(hr);
}


STDMETHODIMP
CCertDBRow::BeginTransaction(VOID)
{
    HRESULT hr;

    if (NULL == m_pdb)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_pdb");
    }
    if (CSF_READONLY & m_pcs->SesFlags)
    {
	hr = E_ACCESSDENIED;
	_JumpError(hr, error, "read-only row");
    }
    hr = ((CCertDB *) m_pdb)->BeginTransaction(m_pcs, TRUE);
    _JumpIfError(hr, error, "BeginTransaction");

error:
    return(hr);
}


STDMETHODIMP
CCertDBRow::CommitTransaction(
    /* [in] */ BOOL fCommit)
{
    HRESULT hr;

    if (NULL == m_pdb)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_pdb");
    }
    if (CSF_READONLY & m_pcs->SesFlags)
    {
	hr = E_ACCESSDENIED;
	_JumpError(hr, error, "read-only row");
    }
    hr = ((CCertDB *) m_pdb)->CommitTransaction(m_pcs, fCommit);
    _JumpIfError(hr, error, "CommitTransaction");

error:
    return(hr);
}


STDMETHODIMP
CCertDBRow::GetRowId(
    /* [out] */ DWORD *pRowId)
{
    HRESULT hr;
    
    if (NULL == pRowId)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (NULL == m_pcs)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "m_pcs");
    }
    *pRowId = m_pcs->RowId;
    hr = S_OK;

error:
    return(hr);
}


STDMETHODIMP
CCertDBRow::Delete()
{
    HRESULT hr;
    
    if (!(CSF_DELETE & m_pcs->SesFlags))
    {
	hr = E_ACCESSDENIED;
	_JumpError(hr, error, "not open for delete");
    }
    hr = ((CCertDB *) m_pdb)->Delete(m_pcs);
    _JumpIfError(hr, error, "Delete");

error:
    return(hr);
}


STDMETHODIMP
CCertDBRow::GetProperty(
    /* [in] */      WCHAR const *pwszPropName,
    /* [in] */      DWORD dwFlags,
    /* [in, out] */ DWORD *pcbProp,
    /* [out] */     BYTE *pbProp)		// OPTIONAL
{
    HRESULT hr;
    DWORD cchProp;
    char szProp[4 * MAX_PATH];
    DWORD *pcbPropT = pcbProp;
    BYTE *pbPropT = pbProp;
    DWORD FlagsT = dwFlags;
    
    if (NULL == pwszPropName || NULL == pcbProp)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL parm");
    }
    if (NULL == pbProp)
    {
        *pcbProp = 0;
    }

    hr = _GetPropertyA(pwszPropName, FlagsT, pcbPropT, pbPropT);
    if (CERTSRV_E_PROPERTY_EMPTY == hr)
    {
        goto error;
    }

    _JumpIfErrorStr2(
        hr,
        error,
        "_GetPropertyA",
        pwszPropName,
        HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW));
    
    if (0 == *pcbPropT)
    {
        hr = CERTSRV_E_PROPERTY_EMPTY;
	DBGPRINT((
		DBG_SS_CERTDB,
		"DB: Empty \"%hs\" property: %ws\n",
		PROPTABLE_REQUEST == (PROPTABLE_MASK & dwFlags)?
		    "Request" :
		    PROPTABLE_CERTIFICATE == (PROPTABLE_MASK & dwFlags)?
		    "Certificate" : "CRL",
		pwszPropName));
        _JumpErrorStr(hr, error, "Empty property", pwszPropName);
    }
    CSASSERT(_VerifyPropertyLength(FlagsT, *pcbPropT, pbPropT));
    CSASSERT(_VerifyPropertyLength(dwFlags, *pcbProp, pbProp));

error:
    return(hr);
}


// get a field value

HRESULT
CCertDBRow::_GetPropertyA(
    IN WCHAR const *pwszPropName,
    IN DWORD dwFlags,
    IN OUT DWORD *pcbProp,
    OPTIONAL OUT BYTE *pbProp)
{
    HRESULT hr;
    DWORD dwTable;
    DBTABLE dt;

    if (PROPTABLE_ATTRIBUTE == (PROPTABLE_MASK & dwFlags))
    {
	hr = _VerifyPropertyValue(
			    dwFlags,
			    0,
			    JET_coltypLongText,
			    CB_DBMAXTEXT_ATTRVALUE);
	_JumpIfError(hr, error, "Property value type mismatch");

	hr = ((CCertDB *) m_pdb)->GetAttribute(
					    m_pcs,
					    pwszPropName,
					    pcbProp,
					    pbProp);
	_JumpIfErrorStr2(
		    hr,
		    error,
		    "GetAttribute",
		    pwszPropName,
		    CERTSRV_E_PROPERTY_EMPTY);
    }
    else
    {
	hr = ((CCertDB *) m_pdb)->MapPropId(pwszPropName, dwFlags, &dt);
	_JumpIfError(hr, error, "MapPropId");

	hr = _VerifyPropertyValue(dwFlags, 0, dt.dbcoltyp, dt.dwcbMax);
	_JumpIfError(hr, error, "Property value type mismatch");

	hr = ((CCertDB *) m_pdb)->GetProperty(m_pcs, &dt, pcbProp, pbProp);
	if (hr == HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW))
	{
	    goto error;
	}
	_JumpIfError2(hr, error, "GetProperty", CERTSRV_E_PROPERTY_EMPTY);
    }

error:
    return(hr);
}


BOOL
CCertDBRow::_VerifyPropertyLength(
    IN DWORD dwFlags,
    IN DWORD cbProp,
    IN BYTE const *pbProp)
{
    BOOL fOk = FALSE;

    switch (dwFlags & PROPTYPE_MASK)
    {
	case PROPTYPE_LONG:
	    fOk = sizeof(LONG) == cbProp;
	    break;

	case PROPTYPE_DATE:
	    fOk = sizeof(FILETIME) == cbProp;
	    break;

	case PROPTYPE_BINARY:
	    fOk = TRUE;		// nothing to check
	    break;

	case PROPTYPE_STRING:
	    if (MAXDWORD == cbProp)
	    {
		cbProp = wcslen((WCHAR const *) pbProp) * sizeof(WCHAR);
	    }
	    fOk =
		0 == cbProp ||
		NULL == pbProp ||
		wcslen((WCHAR const *) pbProp) * sizeof(WCHAR) == cbProp;
	    break;

	default:
	    CSASSERT(!"_VerifyPropertyLength: Unexpected type");
	    break;
    }
    return(fOk);
}


HRESULT
CCertDBRow::_VerifyPropertyValue(
    IN DWORD dwFlags,
    IN DWORD cbProp,
    IN JET_COLTYP coltyp,
    IN DWORD cbMax)
{
    JET_COLTYP wType;
    HRESULT hr = E_INVALIDARG;

    switch (dwFlags & PROPTYPE_MASK)
    {
	case PROPTYPE_LONG:
	    wType = JET_coltypLong;
	    break;

	case PROPTYPE_DATE:
	    wType = JET_coltypDateTime;
	    break;

	case PROPTYPE_BINARY:
	    wType = JET_coltypLongBinary;
	    break;

	case PROPTYPE_STRING:
	    // LONG or static-sized version?

	    if (JET_coltypLongText == coltyp)
	    {
		CSASSERT(CB_DBMAXTEXT_MAXINTERNAL < cbMax);
		wType = JET_coltypLongText;
	    }
	    else
	    {
		CSASSERT(JET_coltypText == coltyp);
		CSASSERT(CB_DBMAXTEXT_MAXINTERNAL >= cbMax);
		wType = JET_coltypText;
	    }
	    break;

	default:
	    _JumpError(hr, error, "Property value type unknown");
    }
    if (coltyp != wType)
    {
	_JumpError(hr, error, "Property value type mismatch");
    }

    // Note: cbProp and cbMax do not include the trailing '\0'.

    if (ISTEXTCOLTYP(wType) && cbMax < cbProp)
    {
        hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	DBGCODE(wprintf(
		    L"_VerifyPropertyValue: len = %u, max = %u\n",
		    cbProp,
		    cbMax));
	_JumpError(hr, error, "Property value string too long");
    }
    hr = S_OK;

error:
    return(hr);
}


STDMETHODIMP
CCertDBRow::SetProperty(
    /* [in] */ WCHAR const *pwszPropName,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD cbProp,
    /* [in] */ BYTE const *pbProp)	// OPTIONAL
{
    HRESULT hr;
    char *pszProp = NULL;

    if (NULL == pwszPropName)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (NULL == pbProp &&
	(0 != cbProp || PROPTYPE_STRING != (dwFlags & PROPTYPE_MASK)))
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL pbProp");
    }
    if ((CSF_DELETE | CSF_READONLY) & m_pcs->SesFlags)
    {
	hr = E_ACCESSDENIED;
	_JumpError(hr, error, "SetProperty: delete/read-only row");
    }
    CSASSERT(_VerifyPropertyLength(dwFlags, cbProp, pbProp));

    if (NULL != pbProp && PROPTYPE_STRING == (dwFlags & PROPTYPE_MASK))
    {
	cbProp = wcslen((WCHAR const *) pbProp) * sizeof(WCHAR);
    }

    hr = _SetPropertyA(pwszPropName, dwFlags, cbProp, pbProp);
    _JumpIfErrorStr(hr, error, "_SetPropertyA", pwszPropName);

error:
    if (NULL != pszProp)
    {
	LocalFree(pszProp);
    }
    return(hr);
}


HRESULT
CCertDBRow::_SetPropertyA(
    IN WCHAR const *pwszPropName,
    IN DWORD dwFlags,
    IN DWORD cbProp,
    IN BYTE const *pbProp)		// OPTIONAL
{
    HRESULT hr;
    DBTABLE dt;

    if ((CSF_DELETE | CSF_READONLY) & m_pcs->SesFlags)
    {
	hr = E_ACCESSDENIED;
	_JumpError(hr, error, "_SetPropertyA: delete/read-only row");
    }
    CSASSERT(NULL != pwszPropName);
    if (!_VerifyPropertyLength(dwFlags, cbProp, pbProp))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "Property value length invalid");
    }

    if (PROPTABLE_ATTRIBUTE == (PROPTABLE_MASK & dwFlags))
    {
	if (PROPCALLER_POLICY == (PROPCALLER_MASK & dwFlags))
	{
	    hr = E_ACCESSDENIED;
	    _JumpError(hr, error, "Property write disallowed");
	}
	hr = _VerifyPropertyValue(
			    PROPTYPE_STRING,		// lie
			    wcslen(pwszPropName) * sizeof(WCHAR),
			    JET_coltypText,
			    CB_DBMAXTEXT_ATTRNAME);
	_JumpIfErrorStr(
		    hr,
		    error,
		    "_VerifyPropertyValue(attribute name)",
		    pwszPropName);

	hr = _VerifyPropertyValue(
			    dwFlags,
			    cbProp,
			    JET_coltypLongText,
			    CB_DBMAXTEXT_ATTRVALUE);
	_JumpIfErrorStr(
		    hr,
		    error,
		    "_VerifyPropertyValue(attribute value)",
		    pwszPropName);

	hr = ((CCertDB *) m_pdb)->SetAttribute(
					    m_pcs,
					    pwszPropName,
					    cbProp,
					    pbProp);
	_JumpIfError(hr, error, "SetProperty");
    }
    else
    {
	hr = ((CCertDB *) m_pdb)->MapPropId(pwszPropName, dwFlags, &dt);
	_JumpIfErrorStr(hr, error, "MapPropId", pwszPropName);

	if (PROPCALLER_POLICY == (PROPCALLER_MASK & dwFlags) &&
	    0 == (DBTF_POLICYWRITEABLE & dt.dwFlags))
	{
	    hr = E_ACCESSDENIED;
	    _JumpError(hr, error, "Property write disallowed");
	}
	hr = _VerifyPropertyValue(dwFlags, cbProp, dt.dbcoltyp, dt.dwcbMax);
	_JumpIfErrorStr(hr, error, "_VerifyPropertyValue", pwszPropName);

	hr = ((CCertDB *) m_pdb)->SetProperty(m_pcs, &dt, cbProp, pbProp);
	_JumpIfError(hr, error, "SetProperty");
    }

error:
    return(hr);
}


STDMETHODIMP
CCertDBRow::SetExtension(
    /* [in] */ WCHAR const *pwszExtensionName,
    /* [in] */ DWORD dwExtFlags,
    /* [in] */ DWORD cbValue,
    /* [in] */ BYTE const *pbValue)	// OPTIONAL
{
    HRESULT hr;

    if (NULL == pwszExtensionName)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (NULL == m_pdb)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_pdb");
    }
    if (TABLE_REQCERTS != (CSF_TABLEMASK & m_pcs->SesFlags))
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad Table");
    }
    if ((CSF_DELETE | CSF_READONLY) & m_pcs->SesFlags)
    {
	hr = E_ACCESSDENIED;
	_JumpError(hr, error, "SetExtension: delete/read-only row");
    }
    hr = ((CCertDB *) m_pdb)->SetExtension(
			m_pcs,
			pwszExtensionName,
			dwExtFlags,
			cbValue,
			pbValue);
    _JumpIfErrorStr(hr, error, "SetExtension", pwszExtensionName);

error:
    return(hr);
}


STDMETHODIMP
CCertDBRow::GetExtension(
    /* [in] */ WCHAR const *pwszExtensionName,
    /* [out] */ DWORD *pdwExtFlags,
    /* [in, out] */ DWORD *pcbValue,
    /* [out] */ BYTE *pbValue)		// OPTIONAL
{
    HRESULT hr;

    if (NULL == pwszExtensionName || NULL == pcbValue)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (NULL == m_pdb)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_pdb");
    }
    if (TABLE_REQCERTS != (CSF_TABLEMASK & m_pcs->SesFlags))
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad Table");
    }
    hr = ((CCertDB *) m_pdb)->GetExtension(
			m_pcs,
			pwszExtensionName,
			pdwExtFlags,
			pcbValue,
			pbValue);
    _JumpIfErrorStr2(
		hr,
		error,
		"GetExtension",
		pwszExtensionName,
		CERTSRV_E_PROPERTY_EMPTY);

error:
    return(hr);
}


STDMETHODIMP
CCertDBRow::CopyRequestNames()
{
    HRESULT hr;

    if (NULL == m_pdb)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_pdb");
    }
    if (TABLE_REQCERTS != (CSF_TABLEMASK & m_pcs->SesFlags))
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad Table");
    }
    if ((CSF_DELETE | CSF_READONLY) & m_pcs->SesFlags)
    {
	hr = E_ACCESSDENIED;
	_JumpError(hr, error, "CopyRequestNames: delete/read-only row");
    }
    hr = ((CCertDB *) m_pdb)->CopyRequestNames(m_pcs);
    _JumpIfError(hr, error, "CopyRequestNames");

error:
    return(hr);
}


STDMETHODIMP
CCertDBRow::EnumCertDBName(
    /* [in] */  DWORD dwFlags,
    /* [out] */ IEnumCERTDBNAME **ppenum)
{
    HRESULT hr;
    IEnumCERTDBNAME *penum = NULL;
    JET_TABLEID tableid = 0;

    if (NULL == ppenum)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppenum = NULL;
    if (NULL == m_pdb)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_pdb");
    }
    if (TABLE_REQCERTS != (CSF_TABLEMASK & m_pcs->SesFlags))
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad Table");
    }
    hr = ((CCertDB *) m_pdb)->EnumerateSetup(m_pcs, &dwFlags, &tableid);
    _JumpIfError(hr, error, "EnumerateSetup");

    penum = new CEnumCERTDBNAME;
    if (NULL == penum)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "new CEnumCERTDBNAME");
    }
    hr = ((CEnumCERTDBNAME *) penum)->Open(this, tableid, dwFlags);
    _JumpIfError(hr, error, "Open");

    *ppenum = penum;

error:
    if (S_OK != hr)
    {
	HRESULT hr2;
	
	if (0 != tableid)
	{
	    hr2 = ((CCertDB *) m_pdb)->CloseTable(m_pcs, tableid);
	    _PrintIfError(hr2, "CloseTable");
	}
	delete penum;
    }
    return(hr);
}


HRESULT
CCertDBRow::EnumerateNext(
    IN OUT DWORD      *pFlags,
    IN     JET_TABLEID tableid,
    IN     LONG        cskip,
    IN     ULONG       celt,
    OUT    CERTDBNAME *rgelt,
    OUT    ULONG      *pceltFetched)
{
    HRESULT hr;
    
    if (NULL == rgelt || NULL == pceltFetched)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (NULL == m_pdb)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_pdb");
    }
    if (TABLE_REQCERTS != (CSF_TABLEMASK & m_pcs->SesFlags))
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad Table");
    }
    hr = ((CCertDB *) m_pdb)->EnumerateNext(
					m_pcs,
					pFlags,
					tableid,
					cskip,
					celt,
					rgelt,
					pceltFetched);
    _JumpIfError2(hr, error, "EnumerateNext", S_FALSE);

error:
    return(hr);
}


HRESULT
CCertDBRow::EnumerateClose(
    IN JET_TABLEID tableid)
{
    return(((CCertDB *) m_pdb)->EnumerateClose(m_pcs, tableid));
}


// IUnknown implementation
STDMETHODIMP
CCertDBRow::QueryInterface(
    const IID& iid,
    void **ppv)
{
    HRESULT hr;
    
    if (NULL == ppv)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (iid == IID_IUnknown)
    {
	*ppv = static_cast<ICertDBRow *>(this);
    }
    else if (iid == IID_ICertDBRow)
    {
	*ppv = static_cast<ICertDBRow *>(this);
    }
    else
    {
	*ppv = NULL;
	hr = E_NOINTERFACE;
	_JumpError(hr, error, "IID");
    }
    reinterpret_cast<IUnknown *>(*ppv)->AddRef();
    hr = S_OK;

error:
    return(hr);
}


ULONG STDMETHODCALLTYPE
CCertDBRow::AddRef()
{
    return(InterlockedIncrement(&m_cRef));
}


ULONG STDMETHODCALLTYPE
CCertDBRow::Release()
{
    ULONG cRef = InterlockedDecrement(&m_cRef);

    if (0 == cRef)
    {
	delete this;
    }
    return(cRef);
}


#if 0
STDMETHODIMP
CCertDBRow::InterfaceSupportsErrorInfo(
    IN REFIID riid)
{
    static const IID *arr[] =
    {
	&IID_ICertDBRow,
    };

    for (int i = 0; i < sizeof(arr)/sizeof(arr[0]); i++)
    {
	if (InlineIsEqualGUID(*arr[i], riid))
	{
	    return(S_OK);
	}
    }
    return(S_FALSE);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certdb\row.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        row.h
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------


#include "resource.h"       // main symbols

class CCertDBRow: public ICertDBRow
{
public:
    CCertDBRow();
    ~CCertDBRow();

public:

    // IUnknown
    STDMETHODIMP QueryInterface(const IID& iid, void **ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // ICertDBRow
    STDMETHOD(BeginTransaction)();

    STDMETHOD(CommitTransaction)(
	/* [in] */ BOOL fCommit);

    STDMETHOD(GetRowId)(
	/* [out] */ DWORD *pRowId);

    STDMETHOD(Delete)();

    STDMETHOD(SetProperty)(
	/* [in] */ WCHAR const *pwszPropName,
	/* [in] */ DWORD dwFlags,
	/* [in] */ DWORD cbProp,
	/* [in] */ BYTE const *pbProp);		// OPTIONAL

    STDMETHOD(GetProperty)(
	/* [in] */ WCHAR const *pwszPropName,
	/* [in] */ DWORD dwFlags,
	/* [in, out] */ DWORD *pcbProp,
	/* [out] */ BYTE *pbProp);		// OPTIONAL

    STDMETHOD(SetExtension)(
	/* [in] */ WCHAR const *pwszExtensionName,
	/* [in] */ DWORD dwExtFlags,
	/* [in] */ DWORD cbValue,
	/* [in] */ BYTE const *pbValue);	// OPTIONAL

    STDMETHOD(GetExtension)(
	/* [in] */ WCHAR const *pwszExtensionName,
	/* [out] */ DWORD *pdwExtFlags,
	/* [in, out] */ DWORD *pcbValue,
	/* [out] */ BYTE *pbValue);		// OPTIONAL

    STDMETHOD(CopyRequestNames)();

    STDMETHOD(EnumCertDBName)(
	/* [in] */  DWORD dwFlags,
	/* [out] */ IEnumCERTDBNAME **ppenum);

    // CCertDBRow
    HRESULT Open(
	IN CERTSESSION *pcs,
	IN ICertDB *pdb,
	OPTIONAL IN CERTVIEWRESTRICTION const *pcvr);

    HRESULT EnumerateNext(
	IN OUT DWORD      *pFlags,
	IN     JET_TABLEID tableid,
	IN     LONG        cskip,
	IN     ULONG       celt,
	OUT    CERTDBNAME *rgelt,
	OUT    ULONG      *pceltFetched);

    HRESULT EnumerateClose(
	IN JET_TABLEID tableid);

private:
    VOID _Cleanup();

    HRESULT _SetPropertyA(
	IN WCHAR const *pwszPropName,
	IN DWORD dwFlags,
	IN DWORD cbProp,
	IN BYTE const *pbProp);

    HRESULT _GetPropertyA(
	IN WCHAR const *pwszPropName,
	IN DWORD dwFlags,
	IN OUT DWORD *pcbProp,
	OPTIONAL OUT BYTE *pbProp);

    BOOL _VerifyPropertyLength(
	IN DWORD dwFlags,
	IN DWORD cbProp,
	IN BYTE const *pbProp);

    HRESULT _VerifyPropertyValue(
	IN DWORD dwFlags,
	IN DWORD cbProp,
	IN JET_COLTYP coltyp,
	IN DWORD cbMax);

    ICertDB *m_pdb;
    CERTSESSION *m_pcs;

    // Reference count
    long m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certenc\adate.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       adate.h
//
//--------------------------------------------------------------------------

// adate.h: Declaration of the CCertEncodeDateArray


#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// certenc

#define wszCLASS_CERTENCODEDATEARRAY wszCLASS_CERTENCODE TEXT("DateArray")

class CCertEncodeDateArray: 
    public IDispatchImpl<ICertEncodeDateArray, &IID_ICertEncodeDateArray, &LIBID_CERTENCODELib>, 
    public ISupportErrorInfoImpl<&IID_ICertEncodeDateArray>,
    public CComObjectRoot,
    public CComCoClass<CCertEncodeDateArray, &CLSID_CCertEncodeDateArray>
{
public:
    CCertEncodeDateArray()
    {
	m_aValue = NULL;
	m_fConstructing = FALSE;
    }
    ~CCertEncodeDateArray();

BEGIN_COM_MAP(CCertEncodeDateArray)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(ICertEncodeDateArray)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertEncodeDateArray) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(
    CCertEncodeDateArray,
    wszCLASS_CERTENCODEDATEARRAY TEXT(".1"),
    wszCLASS_CERTENCODEDATEARRAY,
    IDS_CERTENCODEDATEARRAY_DESC,
    THREADFLAGS_BOTH)

// ICertEncodeDateArray
public:
    STDMETHOD(Decode)(
		/* [in] */ BSTR const strBinary);

    STDMETHOD(GetCount)(
		/* [out, retval] */ LONG __RPC_FAR *pCount);

    STDMETHOD(GetValue)(
		/* [in] */ LONG Index,
		/* [out, retval] */ DATE __RPC_FAR *pValue);

    STDMETHOD(Reset)(
		/* [in] */ LONG Count);

    STDMETHOD(SetValue)(
		/* [in] */ LONG Index,
		/* [in] */ DATE Value);

    STDMETHOD(Encode)(
		/* [out, retval] */ BSTR __RPC_FAR *pstrBinary);
private:
    VOID _Cleanup(VOID);

    HRESULT _SetErrorInfo(
		IN HRESULT hrError,
		IN WCHAR const *pwszDescription);

    DATE  *m_aValue;
    LONG   m_cValue;
    LONG   m_cValuesSet;
    BOOL   m_fConstructing;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certenc\along.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       along.h
//
//--------------------------------------------------------------------------

// along.h: Declaration of the CCertEncodeLongArray


#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// certenc

#define wszCLASS_CERTENCODELONGARRAY wszCLASS_CERTENCODE TEXT("LongArray")

class CCertEncodeLongArray: 
    public IDispatchImpl<ICertEncodeLongArray, &IID_ICertEncodeLongArray, &LIBID_CERTENCODELib>, 
    public ISupportErrorInfoImpl<&IID_ICertEncodeLongArray>,
    public CComObjectRoot,
    public CComCoClass<CCertEncodeLongArray, &CLSID_CCertEncodeLongArray>
{
public:
    CCertEncodeLongArray()
    {
	m_aValue = NULL;
	m_fConstructing = FALSE;
    }
    ~CCertEncodeLongArray();

BEGIN_COM_MAP(CCertEncodeLongArray)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(ICertEncodeLongArray)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertEncodeLongArray) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(
    CCertEncodeLongArray,
    wszCLASS_CERTENCODELONGARRAY TEXT(".1"),
    wszCLASS_CERTENCODELONGARRAY,
    IDS_CERTENCODELONGARRAY_DESC,
    THREADFLAGS_BOTH)

// ICertEncodeLongArray
public:
    STDMETHOD(Decode)(
		/* [in] */ BSTR const strBinary);

    STDMETHOD(GetCount)(
		/* [out, retval] */ LONG __RPC_FAR *pCount);

    STDMETHOD(GetValue)(
		/* [in] */ LONG Index,
		/* [out, retval] */ LONG __RPC_FAR *pValue);

    STDMETHOD(Reset)(
		/* [in] */ LONG Count);

    STDMETHOD(SetValue)(
		/* [in] */ LONG Index,
		/* [in] */ LONG Value);

    STDMETHOD(Encode)(
		/* [out, retval] */ BSTR __RPC_FAR *pstrBinary);
private:
    VOID _Cleanup(VOID);

    HRESULT _SetErrorInfo(
		IN HRESULT hrError,
		IN WCHAR const *pwszDescription);

    LONG  *m_aValue;
    LONG   m_cValue;
    LONG   m_cValuesSet;
    BOOL   m_fConstructing;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certenc\along.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        along.cpp
//
// Contents:    Cert Server Extension Encoding/Decoding implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include <assert.h>
#include "resource.h"
#include "along.h"
#include "celib.h"


//+--------------------------------------------------------------------------
// CCertEncodeLongArray::~CCertEncodeLongArray -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertEncodeLongArray::~CCertEncodeLongArray()
{
    _Cleanup();
}


//+--------------------------------------------------------------------------
// CCertEncodeLongArray::_Cleanup -- release all resources
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

VOID
CCertEncodeLongArray::_Cleanup()
{
    if (NULL != m_aValue)
    {
	LocalFree(m_aValue);
	m_aValue = NULL;
    }
    m_cValue = 0;
    m_cValuesSet = 0;
    m_fConstructing = FALSE;
}


//+--------------------------------------------------------------------------
// CCertEncodeLongArray::Decode -- Decode LongArray
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeLongArray::Decode(
    /* [in] */ BSTR const strBinary)
{
    HRESULT hr = S_OK;
    CRYPT_SEQUENCE_OF_ANY *pSequence = NULL;
    DWORD cbSequence;
    LONG i;

    _Cleanup();

    if (NULL == strBinary)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }

    // Decode to an array of ASN blobs:

    if (!ceDecodeObject(
		    X509_ASN_ENCODING,
		    X509_SEQUENCE_OF_ANY,
		    (BYTE *) strBinary,
		    SysStringByteLen(strBinary),
		    FALSE,
		    (VOID **) &pSequence,
		    &cbSequence))
    {
	hr = ceHLastError();
	ceERRORPRINTLINE("ceDecodeObject", hr);
	goto error;
    }

    m_cValue = pSequence->cValue;
    m_aValue = (LONG *) LocalAlloc(LMEM_FIXED, m_cValue * sizeof(m_aValue[0]));
    if (NULL == m_aValue)
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("LocalAlloc", hr);
	goto error;
    }
    for (i = 0; i < m_cValue; i++)
    {
	DWORD cb;

	// Decode each ASN blob to an integer:

	cb = sizeof(m_aValue[i]);
	if (!CryptDecodeObject(
			X509_ASN_ENCODING,
			X509_INTEGER,
			pSequence->rgValue[i].pbData,
			pSequence->rgValue[i].cbData,
			0,                  // dwFlags
			(VOID *) &m_aValue[i],
			&cb))
	{
	    hr = ceHLastError();
	    ceERRORPRINTLINE("CryptDecodeObject", hr);
	    goto error;
	}
	assert(sizeof(m_aValue[i]) == cb);
    }

error:
    if (NULL != pSequence)
    {
	LocalFree(pSequence);
    }
    if (S_OK != hr)
    {
	_Cleanup();
    }
    return(_SetErrorInfo(hr, L"CCertEncodeLongArray::Decode"));
}


//+--------------------------------------------------------------------------
// CCertEncodeLongArray::GetCount -- Get Array count
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeLongArray::GetCount(
    /* [out, retval] */ LONG __RPC_FAR *pCount)
{
    HRESULT hr = S_OK;

    if (NULL == pCount)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    if (NULL == m_aValue)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }
    *pCount = m_cValue;
error:
    return(_SetErrorInfo(hr, L"CCertEncodeLongArray::GetCount"));
}


//+--------------------------------------------------------------------------
// CCertEncodeLongArray::GetValue -- Fetch the indexed long
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeLongArray::GetValue(
    /* [in] */ LONG Index,
    /* [out, retval] */ LONG __RPC_FAR *pValue)
{
    HRESULT hr = S_OK;
    BYTE *pb;

    if (NULL == pValue)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    if (NULL == m_aValue || Index >= m_cValue)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }

    // Bitmap only exists when constrcuting!

    if (m_fConstructing)
    {
	pb = (BYTE *) &m_aValue[m_cValue];
	if (!GETBIT(pb, Index))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	    ceERRORPRINTLINE("uninitialized", hr);
	    goto error;
	}
    }
    *pValue = m_aValue[Index];

error:
    return(_SetErrorInfo(hr, L"CCertEncodeLongArray::GetValue"));
}


//+--------------------------------------------------------------------------
// CCertEncodeLongArray::Reset -- clear out data, and set up to encode new data
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeLongArray::Reset(
    /* [in] */ LONG Count)
{
    HRESULT hr = S_OK;
    DWORD cbAlloc;

    _Cleanup();
    m_fConstructing = TRUE;
    if (CENCODEMAX < Count || 0 > Count)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad count parameter", hr);
	goto error;
    }
    cbAlloc = Count * sizeof(m_aValue[0]) + BITSTOBYTES(Count);
    m_aValue = (LONG *) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cbAlloc);
    if (NULL == m_aValue)
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("LocalAlloc", hr);
	goto error;
    }
    m_cValue = Count;

error:
    return(_SetErrorInfo(hr, L"CCertEncodeLongArray::Reset"));
}


//+--------------------------------------------------------------------------
// CCertEncodeLongArray::SetValue -- Set an array long
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeLongArray::SetValue(
    /* [in] */ LONG Index,
    /* [in] */ LONG Value)
{
    HRESULT hr = S_OK;
    BYTE *pb;

    if (!m_fConstructing ||
	NULL == m_aValue ||
	Index >= m_cValue ||
	m_cValuesSet >= m_cValue)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }
    pb = (BYTE *) &m_aValue[m_cValue];
    if (GETBIT(pb, Index))
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("already set", hr);
	goto error;
    }
    SETBIT(pb, Index);
    m_aValue[Index] = Value;
    m_cValuesSet++;

error:
    return(_SetErrorInfo(hr, L"CCertEncodeLongArray::SetValue"));
}


//+--------------------------------------------------------------------------
// CCertEncodeLongArray::Encode -- Encode LongArray
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeLongArray::Encode(
    /* [out, retval] */ BSTR __RPC_FAR *pstrBinary)
{
    HRESULT hr = S_OK;
    LONG i;
    CRYPT_SEQUENCE_OF_ANY Sequence;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    Sequence.cValue = 0;
    Sequence.rgValue = NULL;

    if (NULL == pstrBinary)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    ceFreeBstr(pstrBinary);
    if (!m_fConstructing || NULL == m_aValue)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }
    if (m_cValuesSet != m_cValue)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	ceERRORPRINTLINE("m_cValuesSet", hr);
	goto error;
    }

    Sequence.rgValue = (CRYPT_DER_BLOB *) LocalAlloc(
				    LMEM_FIXED,
				    m_cValue * sizeof(Sequence.rgValue[0]));
    if (NULL == Sequence.rgValue)
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("LocalAlloc", hr);
	goto error;
    }

    for (i = 0; i < m_cValue; i++)
    {
	// Encode each integer into an ASN blob:

	if (!ceEncodeObject(
			X509_ASN_ENCODING,
			X509_INTEGER,
			&m_aValue[i],
			0,
			FALSE,
			&Sequence.rgValue[i].pbData,
			&Sequence.rgValue[i].cbData))
	{
	    hr = ceHLastError();
	    ceERRORPRINTLINE("ceEncodeObject", hr);
	    goto error;
	}
	Sequence.cValue++;
    }
    assert((LONG) Sequence.cValue == m_cValue);

    // Encode each integer into an ASN blob:

    if (!ceEncodeObject(
		    X509_ASN_ENCODING,
		    X509_SEQUENCE_OF_ANY,
		    &Sequence,
		    0,
		    FALSE,
		    &pbEncoded,
		    &cbEncoded))
    {
	hr = ceHLastError();
	ceERRORPRINTLINE("ceEncodeObject", hr);
	goto error;
    }
    if (!ceConvertWszToBstr(
			pstrBinary,
			(WCHAR const *) pbEncoded,
			cbEncoded))
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("ceConvertWszToBstr", hr);
	goto error;
    }

error:
    if (NULL != pbEncoded)
    {
	LocalFree(pbEncoded);
    }
    if (NULL != Sequence.rgValue)
    {
	assert((LONG) Sequence.cValue <= m_cValue);
	for (i = 0; i < (LONG) Sequence.cValue; i++)
	{
	    assert(NULL != Sequence.rgValue[i].pbData);
	    LocalFree(Sequence.rgValue[i].pbData);
	}
	LocalFree(Sequence.rgValue);
    }
    return(_SetErrorInfo(hr, L"CCertEncodeLongArray::Encode"));
}


//+--------------------------------------------------------------------------
// CCertEncodeLongArray::_SetErrorInfo -- set error object information
//
// Returns passed HRESULT
//+--------------------------------------------------------------------------

HRESULT
CCertEncodeLongArray::_SetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription)
{
    assert(FAILED(hrError) || S_OK == hrError || S_FALSE == hrError);
    if (FAILED(hrError))
    {
	HRESULT hr;

	hr = ceDispatchSetErrorInfo(
			    hrError,
			    pwszDescription,
			    wszCLASS_CERTENCODELONGARRAY,
			    &IID_ICertEncodeLongArray);
	assert(hr == hrError);
    }
    return(hrError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certenc\altname.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       altname.h
//
//--------------------------------------------------------------------------

// altname.h: Declaration of the CCertEncodeAltName


#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// certenc

#define wszCLASS_CERTENCODEALTNAME wszCLASS_CERTENCODE TEXT("AltName")

class CCertEncodeAltName: 
    public IDispatchImpl<ICertEncodeAltName, &IID_ICertEncodeAltName, &LIBID_CERTENCODELib>, 
    public ISupportErrorInfoImpl<&IID_ICertEncodeAltName>,
    public CComObjectRoot,
    public CComCoClass<CCertEncodeAltName, &CLSID_CCertEncodeAltName>
{
public:
    CCertEncodeAltName();
    ~CCertEncodeAltName();

BEGIN_COM_MAP(CCertEncodeAltName)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(ICertEncodeAltName)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertEncodeAltName) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(
    CCertEncodeAltName,
    wszCLASS_CERTENCODEALTNAME TEXT(".1"),
    wszCLASS_CERTENCODEALTNAME,
    IDS_CERTENCODEALTNAME_DESC,
    THREADFLAGS_BOTH)

// ICertEncodeAltName
public:
    STDMETHOD(Decode)(
		/* [in] */ BSTR const strBinary);

    STDMETHOD(GetNameCount)(
		/* [out, retval] */ LONG __RPC_FAR *pNameCount);

    STDMETHOD(GetNameChoice)(
		/* [in] */ LONG NameIndex,
		/* [out, retval] */ LONG __RPC_FAR *pNameChoice);

    STDMETHOD(GetName)(
		/* [in] */ LONG NameIndex,		// NameIndex | EAN_*
		/* [out, retval] */ BSTR __RPC_FAR *pstrName);

    STDMETHOD(Reset)(
		/* [in] */ LONG NameCount);

    STDMETHOD(SetNameEntry)(
		/* [in] */ LONG NameIndex,		// NameIndex | EAN_*
		/* [in] */ LONG NameChoice,
		/* [in] */ BSTR const strName);

    STDMETHOD(Encode)(
		/* [out, retval] */ BSTR *pstrBinary);
private:
    VOID _Cleanup(VOID);

    BOOL _VerifyName(
		IN LONG NameIndex);

    HRESULT _MapName(
		IN BOOL fEncode,
		IN LONG NameIndex,
		OUT CERT_ALT_NAME_ENTRY **ppName);

    HRESULT _SetErrorInfo(
		IN HRESULT hrError,
		IN WCHAR const *pwszDescription);

    typedef enum _enumNameType {
	enumUnknown = 0,
	enumUnicode,
	enumAnsi,
	enumBlob,
	enumOther,
    } enumNameType;

    enumNameType _NameType(
		IN DWORD NameChoice);

    CERT_ALT_NAME_ENTRY	*m_aValue;
    LONG		 m_cValue;
    CERT_ALT_NAME_INFO	*m_DecodeInfo;
    DWORD		 m_DecodeLength;
    BOOL		 m_fConstructing;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certenc\adate.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        adate.cpp
//
// Contents:    Cert Server Extension Encoding/Decoding implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include <assert.h>
#include "resource.h"
#include "adate.h"
#include "celib.h"


//+--------------------------------------------------------------------------
// CCertEncodeDateArray::~CCertEncodeDateArray -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertEncodeDateArray::~CCertEncodeDateArray()
{
    _Cleanup();
}


//+--------------------------------------------------------------------------
// CCertEncodeDateArray::_Cleanup -- release all resources
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

VOID
CCertEncodeDateArray::_Cleanup()
{
    if (NULL != m_aValue)
    {
	LocalFree(m_aValue);
	m_aValue = NULL;
    }
    m_cValue = 0;
    m_cValuesSet = 0;
    m_fConstructing = FALSE;
}


//+--------------------------------------------------------------------------
// CCertEncodeDateArray::Decode -- Decode DateArray
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeDateArray::Decode(
    /* [in] */ BSTR const strBinary)
{
    HRESULT hr = S_OK;
    CRYPT_SEQUENCE_OF_ANY *pSequence = NULL;
    DWORD cbSequence;
    LONG i;

    _Cleanup();

    if (NULL == strBinary)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }

    // Decode to an array of ASN blobs:

    if (!ceDecodeObject(
		    X509_ASN_ENCODING,
		    X509_SEQUENCE_OF_ANY,
		    (BYTE *) strBinary,
		    SysStringByteLen(strBinary),
		    FALSE,
		    (VOID **) &pSequence,
		    &cbSequence))
    {
	hr = ceHLastError();
	ceERRORPRINTLINE("ceDecodeObject", hr);
	goto error;
    }

    m_cValue = pSequence->cValue;
    m_aValue = (DATE *) LocalAlloc(LMEM_FIXED, m_cValue * sizeof(m_aValue[0]));
    if (NULL == m_aValue)
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("LocalAlloc", hr);
	goto error;
    }
    for (i = 0; i < m_cValue; i++)
    {
	DWORD cb;
	FILETIME ft;

	// Decode each ASN blob to a FILETIME:

	cb = sizeof(ft);
	if (!CryptDecodeObject(
			X509_ASN_ENCODING,
			X509_CHOICE_OF_TIME,
			pSequence->rgValue[i].pbData,
			pSequence->rgValue[i].cbData,
			0,                  // dwFlags
			&ft,
			&cb))
	{
	    hr = ceHLastError();
	    ceERRORPRINTLINE("CryptDecodeObject", hr);
	    goto error;
	}
	assert(sizeof(ft) == cb);

	// Convert each FILETIME into a DATE:

	hr = ceFileTimeToDate(&ft, &m_aValue[i]);
	if (S_OK != hr)
	{
	    ceERRORPRINTLINE("ceFileTimeToDate", hr);
	    _Cleanup();
	    goto error;
	}
    }

error:
    if (NULL != pSequence)
    {
	LocalFree(pSequence);
    }
    if (S_OK != hr)
    {
	_Cleanup();
    }
    return(_SetErrorInfo(hr, L"CCertEncodeDateArray::Decode"));
}


//+--------------------------------------------------------------------------
// CCertEncodeDateArray::GetCount -- Get Array count
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeDateArray::GetCount(
    /* [out, retval] */ LONG __RPC_FAR *pCount)
{
    HRESULT hr = S_OK;

    if (NULL == pCount)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    if (NULL == m_aValue)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }
    *pCount = m_cValue;
error:
    return(_SetErrorInfo(hr, L"CCertEncodeDateArray::GetCount"));
}


//+--------------------------------------------------------------------------
// CCertEncodeDateArray::GetValue -- Fetch the indexed date
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeDateArray::GetValue(
    /* [in] */ LONG Index,
    /* [out, retval] */ DATE __RPC_FAR *pValue)
{
    HRESULT hr = S_OK;

    if (NULL == pValue)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    if (NULL == m_aValue || Index >= m_cValue)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }
    if (0 == m_aValue[Index])
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	ceERRORPRINTLINE("uninitialized", hr);
	goto error;
    }
    *pValue = m_aValue[Index];

error:
    return(_SetErrorInfo(hr, L"CCertEncodeDateArray::GetValue"));
}


//+--------------------------------------------------------------------------
// CCertEncodeDateArray::Reset -- clear out data, and set up to encode new data
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeDateArray::Reset(
    /* [in] */ LONG Count)
{
    HRESULT hr = S_OK;

    _Cleanup();
    m_fConstructing = TRUE;
    if (CENCODEMAX < Count || 0 > Count)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad count parameter", hr);
	goto error;
    }
    m_aValue = (DATE *) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				Count * sizeof(m_aValue[0]));
    if (NULL == m_aValue)
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("LocalAlloc", hr);
	goto error;
    }
    m_cValue = Count;

error:
    return(_SetErrorInfo(hr, L"CCertEncodeDateArray::Reset"));
}


//+--------------------------------------------------------------------------
// CCertEncodeDateArray::SetValue -- Set an array date
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeDateArray::SetValue(
    /* [in] */ LONG Index,
    /* [in] */ DATE Value)
{
    HRESULT hr = S_OK;

    if (!m_fConstructing ||
	NULL == m_aValue ||
	Index >= m_cValue ||
	m_cValuesSet >= m_cValue ||
	0 != m_aValue[Index] ||
	0 == Value)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }
    m_aValue[Index] = Value;
    m_cValuesSet++;

error:
    return(_SetErrorInfo(hr, L"CCertEncodeDateArray::SetValue"));
}


//+--------------------------------------------------------------------------
// CCertEncodeDateArray::Encode -- Encode DateArray
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeDateArray::Encode(
    /* [out, retval] */ BSTR __RPC_FAR *pstrBinary)
{
    HRESULT hr = S_OK;
    LONG i;
    CRYPT_SEQUENCE_OF_ANY Sequence;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    Sequence.cValue = 0;
    Sequence.rgValue = NULL;

    if (NULL == pstrBinary)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    ceFreeBstr(pstrBinary);
    if (!m_fConstructing || NULL == m_aValue)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }
    if (m_cValuesSet != m_cValue)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	ceERRORPRINTLINE("m_cValuesSet", hr);
	goto error;
    }

    Sequence.rgValue = (CRYPT_DER_BLOB *) LocalAlloc(
				    LMEM_FIXED,
				    m_cValue * sizeof(Sequence.rgValue[0]));
    if (NULL == Sequence.rgValue)
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("LocalAlloc", hr);
	goto error;
    }

    for (i = 0; i < m_cValue; i++)
    {
	FILETIME ft;

	// Convert each DATE into a FILETIME:

	assert(0 != m_aValue[i]);
	hr = ceDateToFileTime(&m_aValue[i], &ft);
	if (S_OK != hr)
	{
	    ceERRORPRINTLINE("ceDateToFileTime", hr);
	    goto error;
	}

	// Encode each FILETIME into an ASN blob:

	if (!ceEncodeObject(
			X509_ASN_ENCODING,
			X509_CHOICE_OF_TIME,
			&ft,
			0,
			FALSE,
			&Sequence.rgValue[i].pbData,
			&Sequence.rgValue[i].cbData))
	{
	    hr = ceHLastError();
	    ceERRORPRINTLINE("ceEncodeObject", hr);
	    goto error;
	}
	Sequence.cValue++;
    }
    assert((LONG) Sequence.cValue == m_cValue);

    // Encode the array of ASN blob:

    if (!ceEncodeObject(
		    X509_ASN_ENCODING,
		    X509_SEQUENCE_OF_ANY,
		    &Sequence,
		    0,
		    FALSE,
		    &pbEncoded,
		    &cbEncoded))
    {
	hr = ceHLastError();
	ceERRORPRINTLINE("ceEncodeObject", hr);
	goto error;
    }
    if (!ceConvertWszToBstr(
			pstrBinary,
			(WCHAR const *) pbEncoded,
			cbEncoded))
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("ceConvertWszToBstr", hr);
	goto error;
    }

error:
    if (NULL != pbEncoded)
    {
	LocalFree(pbEncoded);
    }
    if (NULL != Sequence.rgValue)
    {
	assert((LONG) Sequence.cValue <= m_cValue);
	for (i = 0; i < (LONG) Sequence.cValue; i++)
	{
	    assert(NULL != Sequence.rgValue[i].pbData);
	    LocalFree(Sequence.rgValue[i].pbData);
	}
	LocalFree(Sequence.rgValue);
    }
    return(_SetErrorInfo(hr, L"CCertEncodeDateArray::Encode"));
}


//+--------------------------------------------------------------------------
// CCertEncodeDateArray::_SetErrorInfo -- set error object information
//
// Returns passed HRESULT
//+--------------------------------------------------------------------------

HRESULT
CCertEncodeDateArray::_SetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription)
{
    assert(FAILED(hrError) || S_OK == hrError || S_FALSE == hrError);
    if (FAILED(hrError))
    {
	HRESULT hr;

	hr = ceDispatchSetErrorInfo(
			    hrError,
			    pwszDescription,
			    wszCLASS_CERTENCODEDATEARRAY,
			    &IID_ICertEncodeDateArray);
	assert(hr == hrError);
    }
    return(hrError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certenc\astring.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        astring.cpp
//
// Contents:    Cert Server Extension Encoding/Decoding implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include <assert.h>
#include "resource.h"
#include "astring.h"
#include "celib.h"


//+--------------------------------------------------------------------------
// CCertEncodeStringArray::~CCertEncodeStringArray -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertEncodeStringArray::~CCertEncodeStringArray()
{
    _Cleanup();
}


//+--------------------------------------------------------------------------
// CCertEncodeStringArray::_Cleanup -- release all resources
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

VOID
CCertEncodeStringArray::_Cleanup()
{
    LONG i;

    if (NULL != m_aValue)
    {
	for (i = 0; i < m_cValue; i++)
	{
	    CERT_NAME_VALUE *pNameValue;

	    pNameValue = m_aValue[i];
	    assert(NULL != pNameValue);
	    if (m_fConstructing)
	    {
		if (NULL != pNameValue->Value.pbData)
		{
		    LocalFree(pNameValue->Value.pbData);
		}
	    }
	    else
	    {
		LocalFree(pNameValue);
	    }
	}
	if (m_fConstructing && NULL != m_aValue[0])
	{
	    LocalFree(m_aValue[0]);
	}
	LocalFree(m_aValue);
	m_aValue = NULL;
    }
    m_cValue = 0;
    m_cValuesSet = 0;
    m_fConstructing = FALSE;
    m_StringType = CERT_RDN_IA5_STRING;
}


//+--------------------------------------------------------------------------
// CCertEncodeStringArray::Decode -- Decode StringArray
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeStringArray::Decode(
    /* [in] */ BSTR const strBinary)
{
    HRESULT hr = S_OK;
    CRYPT_SEQUENCE_OF_ANY *pSequence = NULL;
    DWORD cbSequence;
    LONG i;

    _Cleanup();

    if (NULL == strBinary)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }

    // Decode to an array of ASN blobs:

    if (!ceDecodeObject(
		    X509_ASN_ENCODING,
		    X509_SEQUENCE_OF_ANY,
		    (BYTE *) strBinary,
		    SysStringByteLen(strBinary),
		    FALSE,
		    (VOID **) &pSequence,
		    &cbSequence))
    {
	hr = ceHLastError();
	ceERRORPRINTLINE("ceDecodeObject", hr);
	goto error;
    }

    m_aValue = (CERT_NAME_VALUE **) LocalAlloc(
				LMEM_FIXED,
				pSequence->cValue * sizeof(m_aValue[0]));
    if (NULL == m_aValue)
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("LocalAlloc", hr);
	goto error;
    }
    for (i = 0; i < (LONG) pSequence->cValue; i++)
    {
	DWORD cb;

	// Decode each ASN blob to a name value (string blob + encoding type):

	if (!ceDecodeObject(
			X509_ASN_ENCODING,
			X509_UNICODE_ANY_STRING,
			pSequence->rgValue[i].pbData,
			pSequence->rgValue[i].cbData,
			FALSE,
			(VOID **) &m_aValue[i],
			&cb))
	{
	    hr = ceHLastError();
	    ceERRORPRINTLINE("ceDecodeObject", hr);
	    goto error;
	}
	if (0 == i)
	{
	    m_StringType = m_aValue[i]->dwValueType;
	}
	else
	{
	    if (m_StringType != (LONG) m_aValue[i]->dwValueType)
	    {
		ceERRORPRINTLINE("dwValueType mismatch", hr);
	    }
	}
	m_cValue++;
    }
    assert((LONG) pSequence->cValue == m_cValue);

error:
    if (NULL != pSequence)
    {
	LocalFree(pSequence);
    }
    if (S_OK != hr)
    {
	_Cleanup();
    }
    return(_SetErrorInfo(hr, L"CCertEncodeStringArray::Decode"));
}


//+--------------------------------------------------------------------------
// CCertEncodeStringArray::GetStringType -- Get string type
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeStringArray::GetStringType(
    /* [out, retval] */ LONG __RPC_FAR *pStringType)
{
    HRESULT hr = S_OK;

    if (NULL == pStringType)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    if (NULL == m_aValue)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }
    *pStringType = m_StringType;
error:
    return(_SetErrorInfo(hr, L"CCertEncodeStringArray::GetStringType"));
}


//+--------------------------------------------------------------------------
// CCertEncodeStringArray::GetCount -- Get Array count
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeStringArray::GetCount(
    /* [out, retval] */ LONG __RPC_FAR *pCount)
{
    HRESULT hr = S_OK;

    if (NULL == pCount)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    if (NULL == m_aValue)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }
    *pCount = m_cValue;
error:
    return(_SetErrorInfo(hr, L"CCertEncodeStringArray::GetCount"));
}


//+--------------------------------------------------------------------------
// CCertEncodeStringArray::GetValue -- Fetch the indexed string
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeStringArray::GetValue(
    /* [in] */ LONG Index,
    /* [out, retval] */ BSTR __RPC_FAR *pstr)
{
    HRESULT hr = S_OK;

    if (NULL == pstr)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    ceFreeBstr(pstr);
    if (NULL == m_aValue || Index >= m_cValue)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }
    if (NULL == m_aValue[Index]->Value.pbData)
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	ceERRORPRINTLINE("uninitialized", hr);
	goto error;
    }
    if (!ceConvertWszToBstr(
			pstr,
			(WCHAR const *) m_aValue[Index]->Value.pbData,
			-1))
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("ceConvertWszToBstr", hr);
	goto error;
    }
error:
    return(_SetErrorInfo(hr, L"CCertEncodeStringArray::GetValue"));
}


//+--------------------------------------------------------------------------
// CCertEncodeStringArray::Reset -- clear out data
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeStringArray::Reset(
    /* [in] */ LONG Count,
    /* [in] */ LONG StringType)
{
    HRESULT hr = S_OK;
    CERT_NAME_VALUE *aNameValue = NULL;
    LONG i;

    _Cleanup();
    m_fConstructing = TRUE;
    if (CENCODEMAX < Count || 0 > Count)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad count parameter", hr);
	goto error;
    }

    switch (StringType)
    {
	case CERT_RDN_ANY_TYPE:
	//case CERT_RDN_ENCODED_BLOB:
	//case CERT_RDN_OCTET_STRING:
	case CERT_RDN_NUMERIC_STRING:
	case CERT_RDN_PRINTABLE_STRING:
	//case CERT_RDN_TELETEX_STRING: same as CERT_RDN_T61_STRING:
	case CERT_RDN_T61_STRING:
	case CERT_RDN_VIDEOTEX_STRING:
	case CERT_RDN_IA5_STRING:
	case CERT_RDN_GRAPHIC_STRING:
	//case CERT_RDN_VISIBLE_STRING: same as CERT_RDN_ISO646_STRING:
	case CERT_RDN_ISO646_STRING:
	case CERT_RDN_GENERAL_STRING:
	//case CERT_RDN_UNIVERSAL_STRING: same as CERT_RDN_INT4_STRING:
	case CERT_RDN_INT4_STRING:
	//case CERT_RDN_BMP_STRING: same as case CERT_RDN_UNICODE_STRING:
	case CERT_RDN_UNICODE_STRING:
	    break;

	default:
	    hr = E_INVALIDARG;
	    ceERRORPRINTLINE("bad parameter", hr);
	    goto error;
    }
    m_StringType = StringType;

    aNameValue = (CERT_NAME_VALUE *) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				Count * sizeof(*m_aValue[0]));
    if (NULL == aNameValue)
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("LocalAlloc", hr);
	goto error;
    }

    m_aValue = (CERT_NAME_VALUE **) LocalAlloc(
				LMEM_FIXED,
				Count * sizeof(m_aValue[0]));
    if (NULL == m_aValue)
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("LocalAlloc", hr);
	goto error;
    }

    m_cValue = Count;
    for (i = 0; i < Count; i++)
    {
	m_aValue[i] = &aNameValue[i];
    }
    aNameValue = NULL;

error:
    if (NULL != aNameValue)
    {
	LocalFree(aNameValue);
    }
    if (S_OK != hr)
    {
	_Cleanup();
    }
    return(_SetErrorInfo(hr, L"CCertEncodeStringArray::Reset"));
}


//+--------------------------------------------------------------------------
// CCertEncodeStringArray::SetValue -- Set an array string
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeStringArray::SetValue(
    /* [in] */ LONG Index,
    /* [in] */ BSTR const str)
{
    HRESULT hr = S_OK;
    WCHAR *pwsz;

    if (NULL == str)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    if (!m_fConstructing ||
	NULL == m_aValue ||
	Index >= m_cValue ||
	m_cValuesSet >= m_cValue ||
	NULL != m_aValue[Index]->Value.pbData)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }
    pwsz = ceDuplicateString(str);
    if (NULL == pwsz)
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("ceDuplicateString", hr);
	goto error;
    }
    m_aValue[Index]->dwValueType = m_StringType;
    m_aValue[Index]->Value.pbData = (BYTE *) pwsz;
    m_aValue[Index]->Value.cbData = 0;
    m_cValuesSet++;

error:
    return(_SetErrorInfo(hr, L"CCertEncodeStringArray::SetValue"));
}


//+--------------------------------------------------------------------------
// CCertEncodeStringArray::Encode -- Encode StringArray
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeStringArray::Encode(
    /* [out, retval] */ BSTR __RPC_FAR *pstrBinary)
{
    HRESULT hr = S_OK;
    LONG i;
    CRYPT_SEQUENCE_OF_ANY Sequence;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    Sequence.cValue = 0;
    Sequence.rgValue = NULL;

    if (NULL == pstrBinary)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    ceFreeBstr(pstrBinary);
    if (!m_fConstructing || NULL == m_aValue)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }
    if (m_cValuesSet != m_cValue)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	ceERRORPRINTLINE("uninitialized values", hr);
	goto error;
    }

    Sequence.rgValue = (CRYPT_DER_BLOB *) LocalAlloc(
				    LMEM_FIXED,
				    m_cValue * sizeof(Sequence.rgValue[0]));
    if (NULL == Sequence.rgValue)
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("LocalAlloc", hr);
	goto error;
    }

    for (i = 0; i < m_cValue; i++)
    {
	// Encode each name blob into an ASN blob:

	if (!ceEncodeObject(
			X509_ASN_ENCODING,
			X509_UNICODE_ANY_STRING,
			m_aValue[i],
			0,
			FALSE,
			&Sequence.rgValue[i].pbData,
			&Sequence.rgValue[i].cbData))
	{
	    hr = ceHLastError();
	    ceERRORPRINTLINE("ceEncodeObject", hr);
	    goto error;
	}
	Sequence.cValue++;
    }
    assert((LONG) Sequence.cValue == m_cValue);

    // Encode the array of ASN blob:

    if (!ceEncodeObject(
		    X509_ASN_ENCODING,
		    X509_SEQUENCE_OF_ANY,
		    &Sequence,
		    0,
		    FALSE,
		    &pbEncoded,
		    &cbEncoded))
    {
	hr = ceHLastError();
	ceERRORPRINTLINE("ceEncodeObject", hr);
	goto error;
    }
    if (!ceConvertWszToBstr(
			pstrBinary,
			(WCHAR const *) pbEncoded,
			cbEncoded))
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("ceConvertWszToBstr", hr);
	goto error;
    }

error:
    if (NULL != pbEncoded)
    {
	LocalFree(pbEncoded);
    }
    if (NULL != Sequence.rgValue)
    {
	assert((LONG) Sequence.cValue <= m_cValue);
	for (i = 0; i < (LONG) Sequence.cValue; i++)
	{
	    assert(NULL != Sequence.rgValue[i].pbData);
	    LocalFree(Sequence.rgValue[i].pbData);
	}
	LocalFree(Sequence.rgValue);
    }
    return(_SetErrorInfo(hr, L"CCertEncodeStringArray::Encode"));
}


//+--------------------------------------------------------------------------
// CCertEncodeStringArray::_SetErrorInfo -- set error object information
//
// Returns passed HRESULT
//+--------------------------------------------------------------------------

HRESULT
CCertEncodeStringArray::_SetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription)
{
    assert(FAILED(hrError) || S_OK == hrError || S_FALSE == hrError);
    if (FAILED(hrError))
    {
	HRESULT hr;

	hr = ceDispatchSetErrorInfo(
			    hrError,
			    pwszDescription,
			    wszCLASS_CERTENCODESTRINGARRAY,
			    &IID_ICertEncodeStringArray);
	assert(hr == hrError);
    }
    return(hrError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certenc\astring.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       astring.h
//
//--------------------------------------------------------------------------

// astring.h: Declaration of the CCertEncodeStringArray


#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// certenc

#define wszCLASS_CERTENCODESTRINGARRAY wszCLASS_CERTENCODE TEXT("StringArray")

class CCertEncodeStringArray: 
    public IDispatchImpl<ICertEncodeStringArray, &IID_ICertEncodeStringArray, &LIBID_CERTENCODELib>, 
    public ISupportErrorInfoImpl<&IID_ICertEncodeStringArray>,
    public CComObjectRoot,
    public CComCoClass<CCertEncodeStringArray, &CLSID_CCertEncodeStringArray>
{
public:
    CCertEncodeStringArray()
    {
	m_aValue = NULL;
	m_fConstructing = FALSE;
    }
    ~CCertEncodeStringArray();

BEGIN_COM_MAP(CCertEncodeStringArray)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(ICertEncodeStringArray)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertEncodeStringArray) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(
    CCertEncodeStringArray,
    wszCLASS_CERTENCODESTRINGARRAY TEXT(".1"),
    wszCLASS_CERTENCODESTRINGARRAY,
    IDS_CERTENCODESTRINGARRAY_DESC,
    THREADFLAGS_BOTH)

// ICertEncodeStringArray
public:
    STDMETHOD(Decode)(
		/* [in] */ BSTR const strBinary);

    STDMETHOD(GetStringType)(
		/* [out, retval] */ LONG __RPC_FAR *pStringType);

    STDMETHOD(GetCount)(
		/* [out, retval] */ LONG __RPC_FAR *pCount);

    STDMETHOD(GetValue)(
		/* [in] */ LONG Index,
		/* [out, retval] */ BSTR __RPC_FAR *pstr);

    STDMETHOD(Reset)(
		/* [in] */ LONG Count,
		/* [in] */ LONG StringType);

    STDMETHOD(SetValue)(
		/* [in] */ LONG Index,
		/* [in] */ BSTR const str);

    STDMETHOD(Encode)(
		/* [out, retval] */ BSTR *pstrBinary);
private:
    VOID _Cleanup(VOID);

    HRESULT _SetErrorInfo(
		IN HRESULT hrError,
		IN WCHAR const *pwszDescription);

    CERT_NAME_VALUE **m_aValue;
    LONG	      m_cValue;
    LONG	      m_cValuesSet;
    BOOL	      m_fConstructing;
    LONG	      m_StringType;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certenc\altname.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        crldist.cpp
//
// Contents:    Cert Server Extension Encoding/Decoding implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include <assert.h>
#include "resource.h"
#include "altname.h"
#include "celib.h"

#ifndef EAN_NAMEOBJECTID
#define EAN_NAMEOBJECTID        ( 0x80000000 )
#endif EAN_NAMEOBJECTID


//+--------------------------------------------------------------------------
// CCertEncodeAltName::CCertEncodeAltName -- constructor
//
// initialize class
//+--------------------------------------------------------------------------

CCertEncodeAltName::CCertEncodeAltName()
{
    m_aValue = NULL;
    m_DecodeInfo = NULL;
    m_fConstructing = FALSE;
}


//+--------------------------------------------------------------------------
// CCertEncodeAltName::~CCertEncodeAltName -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertEncodeAltName::~CCertEncodeAltName()
{
    _Cleanup();
}


//+--------------------------------------------------------------------------
// CCertEncodeAltName::_NameType -- determine name type tag
//
//+--------------------------------------------------------------------------

CCertEncodeAltName::enumNameType
CCertEncodeAltName::_NameType(
    IN DWORD NameChoice)
{
    enumNameType Type = enumUnknown;

    switch (NameChoice)
    {
	case CERT_ALT_NAME_RFC822_NAME:
	case CERT_ALT_NAME_DNS_NAME:
	case CERT_ALT_NAME_URL:
	    Type = enumUnicode;
	    break;

	case CERT_ALT_NAME_REGISTERED_ID:
	    Type = enumAnsi;
	    break;

	case CERT_ALT_NAME_DIRECTORY_NAME:
	case CERT_ALT_NAME_IP_ADDRESS:
	    Type = enumBlob;
	    break;

	case CERT_ALT_NAME_OTHER_NAME:
	    Type = enumOther;
	    break;

	//case CERT_ALT_NAME_X400_ADDRESS:
	//case CERT_ALT_NAME_EDI_PARTY_NAME:
    }
    return(Type);
}


//+--------------------------------------------------------------------------
// CCertEncodeAltName::_Cleanup -- release all resources
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

VOID
CCertEncodeAltName::_Cleanup()
{
    if (NULL != m_aValue)
    {
	if (!m_fConstructing)
	{
	    if (NULL != m_DecodeInfo)
	    {
		LocalFree(m_DecodeInfo);
		m_DecodeInfo = NULL;
	    }
	}
	else
	{
	    CERT_ALT_NAME_ENTRY *pName;
	    CERT_ALT_NAME_ENTRY *pNameEnd;

	    for (pName = m_aValue, pNameEnd = &m_aValue[m_cValue];
		 pName < pNameEnd;
		 pName++)
	    {
		BYTE **ppb;

		ppb = NULL;

		switch (_NameType(pName->dwAltNameChoice))
		{
		    case enumUnicode:
		    case enumAnsi:
			ppb = (BYTE **) &pName->pwszURL;
			break;

		    case enumBlob:
			ppb = (BYTE **) &pName->DirectoryName.pbData;
			break;

		    case enumOther:
		    {
			CERT_OTHER_NAME *pOther = pName->pOtherName;
			if (NULL != pOther)
			{
			    if (NULL != pOther->pszObjId)
			    {
				LocalFree(pOther->pszObjId);
			    }
			    if (NULL != pOther->Value.pbData)
			    {
				LocalFree(pOther->Value.pbData);
			    }
			}
			ppb = (BYTE **) &pName->pOtherName;
			break;
		    }
		}
		if (NULL != ppb && NULL != *ppb)
		{
		    LocalFree(*ppb);
		}
	    }
	    LocalFree(m_aValue);
	}
	m_aValue = NULL;
    }
    assert(NULL == m_DecodeInfo);
    m_fConstructing = FALSE;
}


//+--------------------------------------------------------------------------
// CCertEncodeAltName::_MapName -- map a distribution point
//
//+--------------------------------------------------------------------------

HRESULT
CCertEncodeAltName::_MapName(
    IN BOOL fEncode,
    IN LONG NameIndex,			// NameIndex | EAN_*
    OUT CERT_ALT_NAME_ENTRY **ppName)
{
    HRESULT hr = S_OK;
    CERT_ALT_NAME_ENTRY *pName;

    if (fEncode)
    {
	pName = m_fConstructing? m_aValue : NULL;
    }
    else
    {
	pName = m_aValue;
    }

    if (NULL == pName)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }

    NameIndex &= ~EAN_NAMEOBJECTID;
    if (m_cValue <= NameIndex)
    {
	ceERRORPRINTLINE("bad NameIndex parameter", hr);
	hr = E_INVALIDARG;
	goto error;
    }
    *ppName = &pName[NameIndex];

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertEncodeAltName::Decode -- Decode AltName
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeAltName::Decode(
    /* [in] */ BSTR const strBinary)
{
    HRESULT hr = S_OK;

    _Cleanup();

    if (NULL == strBinary)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }

    // Decode CERT_ALT_NAME_INFO:

    if (!ceDecodeObject(
		    X509_ASN_ENCODING,
		    X509_ALTERNATE_NAME,
		    (BYTE *) strBinary,
		    SysStringByteLen(strBinary),
		    FALSE,
		    (VOID **) &m_DecodeInfo,
		    &m_DecodeLength))
    {
	hr = ceHLastError();
	ceERRORPRINTLINE("ceDecodeObject", hr);
	goto error;
    }

    m_aValue = m_DecodeInfo->rgAltEntry;
    m_cValue = m_DecodeInfo->cAltEntry;

error:
    if (S_OK != hr)
    {
	_Cleanup();
    }
    return(_SetErrorInfo(hr, L"CCertEncodeAltName::Decode"));
}


//+--------------------------------------------------------------------------
// CCertEncodeAltName::GetNameCount -- Get the Distribution Name Count
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeAltName::GetNameCount(
    /* [out, retval] */ LONG __RPC_FAR *pNameCount)
{
    HRESULT hr = E_INVALIDARG;

    if (NULL == pNameCount)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    if (NULL == m_aValue)
    {
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }
    *pNameCount = m_cValue;
    hr = S_OK;

error:
    return(_SetErrorInfo(hr, L"CCertEncodeAltName::GetNameCount"));
}


//+--------------------------------------------------------------------------
// CCertEncodeAltName::GetNameChoice -- Get a Name Choice
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeAltName::GetNameChoice(
    /* [in] */ LONG NameIndex,
    /* [out, retval] */ LONG __RPC_FAR *pNameChoice)
{
    HRESULT hr;
    CERT_ALT_NAME_ENTRY *pName;

    if (NULL == pNameChoice)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    hr = _MapName(FALSE, NameIndex, &pName);
    if (S_OK != hr)
    {
	ceERRORPRINTLINE("_MapName", hr);
	goto error;
    }
    if (enumUnknown == _NameType(pName->dwAltNameChoice))
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	ceERRORPRINTLINE("uninitialized", hr);
	goto error;
    }
    *pNameChoice = pName->dwAltNameChoice;

error:
    return(_SetErrorInfo(hr, L"CCertEncodeAltName::GetNameChoice"));
}


//+--------------------------------------------------------------------------
// CCertEncodeAltName::GetName -- Get a Name
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeAltName::GetName(
    /* [in] */ LONG NameIndex,			// NameIndex | EAN_*
    /* [out, retval] */ BSTR __RPC_FAR *pstrName)
{
    HRESULT hr;
    CERT_ALT_NAME_ENTRY *pName;

    if (NULL == pstrName)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    ceFreeBstr(pstrName);
    hr = _MapName(FALSE, NameIndex, &pName);
    if (S_OK != hr)
    {
	ceERRORPRINTLINE("_MapName", hr);
	goto error;
    }

    hr = E_OUTOFMEMORY;
    switch (_NameType(pName->dwAltNameChoice))
    {
	case enumUnicode:
	    if (!ceConvertWszToBstr(pstrName, pName->pwszURL, -1))
	    {
		ceERRORPRINTLINE("no memory", hr);
		goto error;
	    }
	    break;

	case enumAnsi:
	    if (!ceConvertSzToBstr(pstrName, pName->pszRegisteredID, -1))
	    {
		ceERRORPRINTLINE("no memory", hr);
		goto error;
	    }
	    break;

	case enumBlob:
	    if (!ceConvertWszToBstr(
				pstrName,
				(WCHAR const *) pName->DirectoryName.pbData,
				pName->DirectoryName.cbData))
	    {
		ceERRORPRINTLINE("no memory", hr);
		goto error;
	    }
	    break;

	case enumOther:
	    if (EAN_NAMEOBJECTID & NameIndex)
	    {
		if (!ceConvertSzToBstr(
				pstrName,
				pName->pOtherName->pszObjId,
				-1))
		{
		    ceERRORPRINTLINE("no memory", hr);
		    goto error;
		}
	    }
	    else
	    {
		if (!ceConvertWszToBstr(
				pstrName,
				(WCHAR const *) pName->pOtherName->Value.pbData,
				pName->pOtherName->Value.cbData))
		{
		    ceERRORPRINTLINE("no memory", hr);
		    goto error;
		}
	    }
	    break;

	default:
	    assert(enumUnknown == _NameType(pName->dwAltNameChoice));
	    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	    ceERRORPRINTLINE("uninitialized", hr);
	    goto error;
    }
    hr = S_OK;

error:
    return(_SetErrorInfo(hr, L"CCertEncodeAltName::GetName"));
}


//+--------------------------------------------------------------------------
// CCertEncodeAltName::Reset -- clear out data
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeAltName::Reset(
    /* [in] */ LONG NameCount)
{
    HRESULT hr = S_OK;
    CERT_NAME_VALUE *aNameValue = NULL;

    _Cleanup();
    m_fConstructing = TRUE;
    if (CENCODEMAX < NameCount || 0 > NameCount)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad count parameter", hr);
	goto error;
    }

    m_aValue = (CERT_ALT_NAME_ENTRY *) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				NameCount * sizeof(m_aValue[0]));
    if (NULL == m_aValue)
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("LocalAlloc", hr);
	goto error;
    }
    m_cValue = NameCount;

error:
    if (S_OK != hr)
    {
	_Cleanup();
    }
    return(_SetErrorInfo(hr, L"CCertEncodeAltName::Reset"));
}


//+--------------------------------------------------------------------------
// CCertEncodeAltName::SetNameEntry -- Set a Name Netry
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeAltName::SetNameEntry(
    /* [in] */ LONG NameIndex,			// NameIndex | EAN_*
    /* [in] */ LONG NameChoice,
    /* [in] */ BSTR const strName)
{
    HRESULT hr;
    CERT_ALT_NAME_ENTRY *pName;
    DATA_BLOB *pBlob = NULL;

    if (NULL == strName)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    if (!m_fConstructing)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }

    hr = _MapName(TRUE, NameIndex, &pName);
    if (S_OK != hr)
    {
	ceERRORPRINTLINE("_MapName", hr);
	goto error;
    }

    if (enumUnknown != _NameType(pName->dwAltNameChoice))
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }

    hr = ceVerifyAltNameString(NameChoice, strName);
    if (S_OK != hr)
    {
	ceERRORPRINTLINE("ceVerifyAltNameString", hr);
	goto error;
    }

    switch (_NameType(NameChoice))
    {
	case enumUnicode:
	    pName->pwszURL = ceDuplicateString(strName);
	    if (NULL == pName->pwszURL)
	    {
		hr = E_OUTOFMEMORY;
		ceERRORPRINTLINE("ceDuplicateString", hr);
		goto error;
	    }
	    break;

	case enumAnsi:
	    if (CERT_ALT_NAME_REGISTERED_ID == NameChoice)
	    {
		hr = ceVerifyObjId(strName);
		if (S_OK != hr)
		{
		    ceERRORPRINTLINE("ceVerifyObjId", hr);
		    goto error;
		}
	    }
	    if (!ceConvertWszToSz(&pName->pszRegisteredID, strName, -1))
	    {
		hr = E_OUTOFMEMORY;
		ceERRORPRINTLINE("ceConvertWszToSz", hr);
		goto error;
	    }
	    break;

	case enumBlob:
	    pBlob = &pName->DirectoryName;
	    break;

	case enumOther:
	    if (NULL == pName->pOtherName)
	    {
		pName->pOtherName = (CERT_OTHER_NAME *) LocalAlloc(
					LMEM_FIXED | LMEM_ZEROINIT,
					sizeof(*pName->pOtherName));
		if (NULL == pName->pOtherName)
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "LocalAlloc");
		}
	    }
	    else if (CERT_ALT_NAME_OTHER_NAME != pName->dwAltNameChoice)
	    {
		hr = E_INVALIDARG;
		_JumpError(hr, error, "NameChoice conflict");
	    }
	    if (EAN_NAMEOBJECTID & NameIndex)
	    {
		if (NULL != pName->pOtherName->pszObjId)
		{
		    hr = E_INVALIDARG;
		    _JumpError(hr, error, "pszObjId already set");
		}
		if (!ceConvertWszToSz(&pName->pOtherName->pszObjId, strName, -1))
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "ceConvertWszToSz");
		}
	    }
	    else
	    {
		pBlob = &pName->pOtherName->Value;
	    }
	    break;

	default:
	    hr = E_INVALIDARG;
	    ceERRORPRINTLINE("bad NameChoice parameter", hr);
	    goto error;
	    break;
    }

    if (NULL != pBlob)
    {
	if (NULL != pBlob->pbData)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "pbData already set");
	}
	pBlob->cbData = SysStringByteLen(strName);
	pBlob->pbData = (BYTE *) LocalAlloc(LMEM_FIXED, pBlob->cbData);
	if (NULL == pBlob->pbData)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	CopyMemory(pBlob->pbData, strName, pBlob->cbData);
    }
    pName->dwAltNameChoice = NameChoice;

error:
    return(_SetErrorInfo(hr, L"CCertEncodeAltName::SetNameEntry"));
}


//+--------------------------------------------------------------------------
// CCertEncodeAltName::_VerifyName -- Verify name
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

BOOL
CCertEncodeAltName::_VerifyName(
    IN LONG NameIndex)
{
    HRESULT hr;
    BOOL fOk = FALSE;
    CERT_ALT_NAME_ENTRY *pName;

    assert(m_fConstructing);

    hr = _MapName(TRUE, NameIndex, &pName);
    if (S_OK != hr)
    {
	ceERRORPRINTLINE("_MapName", hr);
	goto error;
    }
    assert(NULL != pName);
    switch (_NameType(pName->dwAltNameChoice))
    {
	case enumOther:
	    if (NULL != pName->pOtherName &&
		NULL != pName->pOtherName->pszObjId &&
		NULL != pName->pOtherName->Value.pbData)
	    {
		break;
	    }
	    // FALLTHROUGH

	case enumUnknown:
	    hr = E_INVALIDARG;
	    ceERRORPRINTLINE("uninitialized name", hr);
	    goto error;
    }
    fOk = TRUE;

error:
    return(fOk);
}


//+--------------------------------------------------------------------------
// CCertEncodeAltName::Encode -- Encode AltName
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeAltName::Encode(
    /* [out, retval] */ BSTR __RPC_FAR *pstrBinary)
{
    HRESULT hr = S_OK;
    CERT_ALT_NAME_INFO AltName;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    LONG i;

    if (NULL == pstrBinary)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }

    AltName.cAltEntry = m_cValue;
    AltName.rgAltEntry = m_aValue;

    ceFreeBstr(pstrBinary);
    if (!m_fConstructing || NULL == m_aValue)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }

    for (i = 0; i < m_cValue; i++)
    {
	// Verify all entries are initialized:

	if (!_VerifyName(i))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    ceERRORPRINTLINE("uninitialized name", hr);
	    goto error;
	}
    }

    // Encode CERT_ALT_NAME_INFO:

    if (!ceEncodeObject(
		    X509_ASN_ENCODING,
		    X509_ALTERNATE_NAME,
		    &AltName,
		    0,
		    FALSE,
		    &pbEncoded,
		    &cbEncoded))
    {
	hr = ceHLastError();
	ceERRORPRINTLINE("ceEncodeObject", hr);
	goto error;
    }
    if (!ceConvertWszToBstr(pstrBinary, (WCHAR const *) pbEncoded, cbEncoded))
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("ceConvertWszToBstr", hr);
	goto error;
    }

error:
    if (NULL != pbEncoded)
    {
	LocalFree(pbEncoded);
    }
    return(_SetErrorInfo(hr, L"CCertEncodeAltName::Encode"));
}


//+--------------------------------------------------------------------------
// CCertEncodeAltName::_SetErrorInfo -- set error object information
//
// Returns passed HRESULT
//+--------------------------------------------------------------------------

HRESULT
CCertEncodeAltName::_SetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription)
{
    assert(FAILED(hrError) || S_OK == hrError || S_FALSE == hrError);
    if (FAILED(hrError))
    {
	HRESULT hr;

	hr = ceDispatchSetErrorInfo(
			    hrError,
			    pwszDescription,
			    wszCLASS_CERTENCODEALTNAME,
			    &IID_ICertEncodeAltName);
	assert(hr == hrError);
    }
    return(hrError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certenc\bitstr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       bitstr.h
//
//--------------------------------------------------------------------------

// bitstr.h: Declaration of the CCertEncodeBitString


#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// certenc

#define wszCLASS_CERTENCODEBITSTRING wszCLASS_CERTENCODE TEXT("BitString")

class CCertEncodeBitString: 
    public IDispatchImpl<ICertEncodeBitString, &IID_ICertEncodeBitString, &LIBID_CERTENCODELib>, 
    public ISupportErrorInfoImpl<&IID_ICertEncodeBitString>,
    public CComObjectRoot,
    public CComCoClass<CCertEncodeBitString, &CLSID_CCertEncodeBitString>
{
public:
    CCertEncodeBitString()
    {
	m_DecodeInfo = NULL;
    }
    ~CCertEncodeBitString();

BEGIN_COM_MAP(CCertEncodeBitString)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(ICertEncodeBitString)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertEncodeBitString) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(
    CCertEncodeBitString,
    wszCLASS_CERTENCODEBITSTRING TEXT(".1"),
    wszCLASS_CERTENCODEBITSTRING,
    IDS_CERTENCODEBITSTRING_DESC,
    THREADFLAGS_BOTH)

// ICertEncodeBitString
public:
    STDMETHOD(Decode)(
		/* [in] */ BSTR const strBinary);

    STDMETHOD(GetBitCount)(
		/* [out, retval] */ LONG __RPC_FAR *pBitCount);

    STDMETHOD(GetBitString)(
		/* [out, retval] */ BSTR __RPC_FAR *pstrBitString);

    STDMETHOD(Encode)(
		/* [in] */ LONG BitCount,
		/* [in] */ BSTR strBitString,
		/* [out, retval] */ BSTR *pstrBinary);
private:
    VOID _Cleanup(VOID);

    HRESULT _SetErrorInfo(
		IN HRESULT hrError,
		IN WCHAR const *pwszDescription);

    LONG		 m_cBits;
    CRYPT_BIT_BLOB	*m_DecodeInfo;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certenc\atl.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        atl.cpp
//
// Contents:    ActiveX Template Library COM support
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certenc\bitstr.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        crldist.cpp
//
// Contents:    Cert Server Extension Encoding/Decoding implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include <assert.h>
#include "resource.h"
#include "bitstr.h"
#include "celib.h"


//+--------------------------------------------------------------------------
// CCertEncodeBitString::~CCertEncodeBitString -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertEncodeBitString::~CCertEncodeBitString()
{
    _Cleanup();
}


//+--------------------------------------------------------------------------
// CCertEncodeBitString::_Cleanup -- release all resources
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

VOID
CCertEncodeBitString::_Cleanup()
{
    if (NULL != m_DecodeInfo)
    {
	LocalFree(m_DecodeInfo);
	m_DecodeInfo = NULL;
    }
}


//+--------------------------------------------------------------------------
// CCertEncodeBitString::Decode -- Decode BitString
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeBitString::Decode(
    /* [in] */ BSTR const strBinary)
{
    HRESULT hr = S_OK;
    DWORD cbBitString;

    _Cleanup();

    if (NULL == strBinary)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }

    // Decode CRYPT_BIT_BLOB:

    if (!ceDecodeObject(
		    X509_ASN_ENCODING,
		    X509_BITS,
		    (BYTE *) strBinary,
		    SysStringByteLen(strBinary),
		    FALSE,
		    (VOID **) &m_DecodeInfo,
		    &cbBitString))
    {
	hr = ceHLastError();
	ceERRORPRINTLINE("ceDecodeObject", hr);
	goto error;
    }

error:
    if (S_OK != hr)
    {
	_Cleanup();
    }
    return(_SetErrorInfo(hr, L"CCertEncodeBitString::Decode"));
}


//+--------------------------------------------------------------------------
// CCertEncodeBitString::GetBitCount -- Get the Distribution Name Count
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeBitString::GetBitCount(
    /* [out, retval] */ LONG __RPC_FAR *pBitCount)
{
    HRESULT hr = E_INVALIDARG;

    if (NULL == pBitCount)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    if (NULL == m_DecodeInfo)
    {
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }
    *pBitCount = m_DecodeInfo->cbData * 8 - m_DecodeInfo->cUnusedBits;
    hr = S_OK;

error:
    return(_SetErrorInfo(hr, L"CCertEncodeBitString::GetBitCount"));
}


//+--------------------------------------------------------------------------
// CCertEncodeBitString::GetBitString -- Get the bits
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeBitString::GetBitString(
    /* [out, retval] */ BSTR __RPC_FAR *pstrBitString)
{
    HRESULT hr = E_INVALIDARG;

    if (NULL == pstrBitString)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    ceFreeBstr(pstrBitString);

    if (NULL == m_DecodeInfo)
    {
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }

    hr = E_OUTOFMEMORY;
    if (!ceConvertWszToBstr(
			pstrBitString,
			(WCHAR const *) m_DecodeInfo->pbData,
			m_DecodeInfo->cbData))
    {
	ceERRORPRINTLINE("no memory", hr);
	goto error;
    }
    hr = S_OK;

error:
    return(_SetErrorInfo(hr, L"CCertEncodeBitString::GetBitString"));
}


//+--------------------------------------------------------------------------
// CCertEncodeBitString::Encode -- Encode BitString
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeBitString::Encode(
    /* [in] */ LONG BitCount,
    /* [in] */ BSTR strBitString,
    /* [out, retval] */ BSTR __RPC_FAR *pstrBinary)
{
    HRESULT hr = S_OK;
    CRYPT_BIT_BLOB BitString;
    LONG cbData;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    if (NULL != pstrBinary)
    {
	ceFreeBstr(pstrBinary);
    }
    if (NULL == strBitString || NULL == pstrBinary)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    if (CENCODEMAX < BitCount || 0 > BitCount)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad count parameter", hr);
	goto error;
    }

    cbData = SysStringByteLen(strBitString);
    if (BitCount > cbData * 8 || BitCount <= (cbData - 1) * 8)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad BitCount parameter", hr);
	goto error;
    }
    BitString.cbData = cbData;
    BitString.pbData = (BYTE *) strBitString;
    BitString.cUnusedBits = cbData * 8 - BitCount;

    // Encode CRYPT_BIT_BLOB:
    // If cUnusedBits is 0, encode as X509_KEY_USAGE to ensure that trailing
    // zero bytes are stripped, and trailing zero bits in the last byte are
    // counted and that count is encoded into the CRYPT_BIT_BLOB.

    if (!ceEncodeObject(
		    X509_ASN_ENCODING,
		    0 == BitString.cUnusedBits? X509_KEY_USAGE : X509_BITS,
		    &BitString,
		    0,
		    FALSE,
		    &pbEncoded,
		    &cbEncoded))
    {
	hr = ceHLastError();
	ceERRORPRINTLINE("ceEncodeObject", hr);
	goto error;
    }
    if (!ceConvertWszToBstr(pstrBinary, (WCHAR const *) pbEncoded, cbEncoded))
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("ceConvertWszToBstr", hr);
	goto error;
    }

error:
    if (NULL != pbEncoded)
    {
	LocalFree(pbEncoded);
    }
    return(_SetErrorInfo(hr, L"CCertEncodeBitString::Encode"));
}


//+--------------------------------------------------------------------------
// CCertEncodeStringArray::_SetErrorInfo -- set error object information
//
// Returns passed HRESULT
//+--------------------------------------------------------------------------

HRESULT
CCertEncodeBitString::_SetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription)
{
    assert(FAILED(hrError) || S_OK == hrError || S_FALSE == hrError);
    if (FAILED(hrError))
    {
	HRESULT hr;

	hr = ceDispatchSetErrorInfo(
			    hrError,
			    pwszDescription,
			    wszCLASS_CERTENCODEBITSTRING,
			    &IID_ICertEncodeBitString);
	assert(hr == hrError);
    }
    return(hrError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certenc\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    makefile.inc.

!ENDIF

$(O)\$(TARGETNAME).res:    ..\idl\com\$(O)\$(TARGETNAME).tlb

SOURCE_DIR=..\celib

$(NTTARGETFILE0):	$(SOURCE_DIR)\$(@F)
    copy $(SOURCE_DIR)\$(@F) $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certenc\certenc.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certenc.cpp
//
// Contents:    Cert Server encode/decode support
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include "celib.h"
#include "resource.h"
#include "certenc.h"
#include "adate.h"
#include "along.h"
#include "astring.h"
#include "crldist.h"
#include "altname.h"
#include "bitstr.h"

CComModule _Module;
HMODULE g_hModule;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CCertEncodeDateArray, CCertEncodeDateArray)
    OBJECT_ENTRY(CLSID_CCertEncodeLongArray, CCertEncodeLongArray)
    OBJECT_ENTRY(CLSID_CCertEncodeStringArray, CCertEncodeStringArray)
    OBJECT_ENTRY(CLSID_CCertEncodeCRLDistInfo, CCertEncodeCRLDistInfo)
    OBJECT_ENTRY(CLSID_CCertEncodeAltName, CCertEncodeAltName)
    OBJECT_ENTRY(CLSID_CCertEncodeBitString, CCertEncodeBitString)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI
DllMain(HINSTANCE hInstance, DWORD dwReason, VOID *lpReserved)
{
    g_hModule = hInstance;
    if (DLL_PROCESS_ATTACH == dwReason)
    {
	ceInitErrorMessageText(
			hInstance,
			IDS_E_UNEXPECTED,
			IDS_UNKNOWN_ERROR_CODE);
	_Module.Init(ObjectMap, hInstance);
	DisableThreadLibraryCalls(hInstance);
    }
    if (DLL_PROCESS_DETACH == dwReason)
    {
	_Module.Term();
    }
    return(TRUE);
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI
DllCanUnloadNow(VOID)
{
    HRESULT hr;

    hr = 0 == _Module.GetLockCount()? S_OK : S_FALSE;
    return(hr);
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI
DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;

    hr = _Module.GetClassObject(rclsid, riid, ppv);
    return(hr);
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI
DllRegisterServer(VOID)
{
    HRESULT hr;

    // registers object, typelib and all interfaces in typelib

    hr = _Module.RegisterServer(TRUE);
    return(hr);
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI
DllUnregisterServer(VOID)
{
    _Module.UnregisterServer();
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certenc\crldist.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        crldist.cpp
//
// Contents:    Cert Server Extension Encoding/Decoding implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include <assert.h>
#include "resource.h"
#include "crldist.h"
#include "celib.h"


//+--------------------------------------------------------------------------
// CCertEncodeCRLDistInfo::~CCertEncodeCRLDistInfo -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertEncodeCRLDistInfo::~CCertEncodeCRLDistInfo()
{
    _Cleanup();
}


//+--------------------------------------------------------------------------
// CCertEncodeCRLDistInfo::_Cleanup -- release all resources
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

VOID
CCertEncodeCRLDistInfo::_Cleanup()
{
    if (NULL != m_aValue)
    {
	if (!m_fConstructing)
	{
	    if (NULL != m_DecodeInfo)
	    {
		LocalFree(m_DecodeInfo);
		m_DecodeInfo = NULL;
	    }
	}
	else
	{
	    CRL_DIST_POINT *pDistPoint;
	    CRL_DIST_POINT *pDistPointEnd;

	    for (pDistPoint = m_aValue, pDistPointEnd = &m_aValue[m_cValue];
		 pDistPoint < pDistPointEnd;
		 pDistPoint++)
	    {
		CERT_ALT_NAME_ENTRY *pName;
		CERT_ALT_NAME_ENTRY *pNameEnd;

		pName = pDistPoint->DistPointName.FullName.rgAltEntry;
		if (NULL != pName)
		{
		    for (pNameEnd = &pName[pDistPoint->DistPointName.FullName.cAltEntry];
			 pName < pNameEnd;
			 pName++)
		    {
			if (NULL != pName->pwszURL) // test arbitrary union arm
			{
			    LocalFree(pName->pwszURL);
			}
		    }
		    LocalFree(pDistPoint->DistPointName.FullName.rgAltEntry);
		}
	    }
	    LocalFree(m_aValue);
	}
	m_aValue = NULL;
    }
    assert(NULL == m_DecodeInfo);
    m_fConstructing = FALSE;
}


//+--------------------------------------------------------------------------
// CCertEncodeCRLDistInfo::_MapDistPoint -- map a distribution point
//
//+--------------------------------------------------------------------------

HRESULT
CCertEncodeCRLDistInfo::_MapDistPoint(
    IN BOOL fEncode,
    IN LONG DistPointIndex,
    OUT LONG **ppNameCount,
    OUT CERT_ALT_NAME_ENTRY ***ppaName)
{
    HRESULT hr = S_OK;
    CRL_DIST_POINT *pDistPoint;

    if (fEncode)
    {
	pDistPoint = m_fConstructing? m_aValue : NULL;
    }
    else
    {
	pDistPoint = m_aValue;
    }

    if (NULL == pDistPoint)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }

    if (m_cValue <= DistPointIndex)
    {
	ceERRORPRINTLINE("bad DistPointIndex parameter", hr);
	hr = E_INVALIDARG;
	goto error;
    }
    *ppNameCount =
	(LONG *) &pDistPoint[DistPointIndex].DistPointName.FullName.cAltEntry;
    *ppaName = &pDistPoint[DistPointIndex].DistPointName.FullName.rgAltEntry;

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertEncodeCRLDistInfo::_MapName -- map a name
//
//+--------------------------