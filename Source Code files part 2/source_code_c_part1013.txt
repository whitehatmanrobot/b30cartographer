_EXTENSION AgpContext,
    IN OUT AGP_RANGE *Range
    )
/*++

Routine Description:

    Reserves a range of memory in the GART.

Arguments:

    AgpContext - Supplies the AGP Context

    Range - Supplies the AGP_RANGE structure. AGPLIB
        will have filled in NumberOfPages and Type. This
        routine will fill in MemoryBase and Context.

Return Value:

    NTSTATUS

--*/

{
    ULONG Index;
    ULONG NewState;
    NTSTATUS Status;
    PGART_PTE FoundRange;
    BOOLEAN Backwards;

    PAGED_CODE();

    ASSERT((Range->Type == MmNonCached) || (Range->Type == MmWriteCombined));

    if (Range->NumberOfPages > (AgpContext->ApertureLength / PAGE_SIZE)) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // If we have not allocated our GART yet, now is the time to do so
    //
    if (AgpContext->Gart == NULL) {
        ASSERT(AgpContext->GartLength == 0);
        Status = Agp440CreateGart(AgpContext,Range->NumberOfPages);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("Agp440CreateGart failed %08lx to create GART of size %lx\n",
                    Status,
                    AgpContext->ApertureLength));
            return(Status);
        }
    }
    ASSERT(AgpContext->GartLength != 0);

    //
    // Now that we have a GART, try and find enough contiguous entries to satisfy
    // the request. Requests for uncached memory will scan from high addresses to
    // low addresses. Requests for write-combined memory will scan from low addresses
    // to high addresses. We will use a first-fit algorithm to try and keep the allocations
    // packed and contiguous.
    //
    Backwards = (Range->Type == MmNonCached) ? TRUE : FALSE;
    FoundRange = Agp440FindRangeInGart(&AgpContext->Gart[0],
                                       &AgpContext->Gart[(AgpContext->GartLength / sizeof(GART_PTE)) - 1],
                                       Range->NumberOfPages,
                                       Backwards,
                                       GART_ENTRY_FREE);

    if (FoundRange == NULL) {
        //
        // A big enough chunk was not found.
        //
        AGPLOG(AGP_CRITICAL,
               ("AgpReserveMemory - Could not find %d contiguous free pages of type %d in GART at %08lx\n",
                Range->NumberOfPages,
                Range->Type,
                AgpContext->Gart));

        //
        //  This is where we could try and grow the GART
        //

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    AGPLOG(AGP_NOISE,
           ("AgpReserveMemory - reserved %d pages at GART PTE %08lx\n",
            Range->NumberOfPages,
            FoundRange));

    //
    // Set these pages to reserved
    //
    if (Range->Type == MmNonCached) {
        NewState = GART_ENTRY_RESERVED_UC;
    } else {
        NewState = GART_ENTRY_RESERVED_WC;
    }

    for (Index = 0;Index < Range->NumberOfPages; Index++) {
        ASSERT(FoundRange[Index].Soft.State == GART_ENTRY_FREE);
        FoundRange[Index].AsUlong = 0;
        FoundRange[Index].Soft.State = NewState;
    }

    Range->MemoryBase.QuadPart = AgpContext->ApertureStart.QuadPart + (FoundRange - &AgpContext->Gart[0]) * PAGE_SIZE;
    Range->Context = FoundRange;

    ASSERT(Range->MemoryBase.HighPart == 0);
    AGPLOG(AGP_NOISE,
           ("AgpReserveMemory - reserved memory handle %lx at PA %08lx\n",
            FoundRange,
            Range->MemoryBase.LowPart));

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpReleaseMemory(
    IN PAGP440_EXTENSION AgpContext,
    IN PAGP_RANGE Range
    )
/*++

Routine Description:

    Releases memory previously reserved with AgpReserveMemory

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the range to be released.

Return Value:

    NTSTATUS

--*/

{
    PGART_PTE Pte;
    ULONG Start;

    PAGED_CODE();

    //
    // Go through and free all the PTEs. None of these should still
    // be valid at this point.
    //
    for (Pte = Range->Context;
         Pte < (PGART_PTE)Range->Context + Range->NumberOfPages;
         Pte++) {
        if (Range->Type == MmNonCached) {
            ASSERT(Pte->Soft.State == GART_ENTRY_RESERVED_UC);
        } else {
            ASSERT(Pte->Soft.State == GART_ENTRY_RESERVED_WC);
        }
        Pte->Soft.State = GART_ENTRY_FREE;
    }

    Range->MemoryBase.QuadPart = 0;
    return(STATUS_SUCCESS);
}


NTSTATUS
Agp440CreateGart(
    IN PAGP440_EXTENSION AgpContext,
    IN ULONG MinimumPages
    )
/*++

Routine Description:

    Allocates and initializes an empty GART. The current implementation
    attempts to allocate the entire GART on the first reserve.

Arguments:

    AgpContext - Supplies the AGP context

    MinimumPages - Supplies the minimum size (in pages) of the GART to be
        created.

Return Value:

    NTSTATUS

--*/

{
    PGART_PTE Gart;
    ULONG GartLength;
    PHYSICAL_ADDRESS HighestAcceptable;
    PHYSICAL_ADDRESS LowestAcceptable;
    PHYSICAL_ADDRESS BoundaryMultiple;
    PHYSICAL_ADDRESS GartPhysical;
    ULONG i;

    PAGED_CODE();

    //
    // Try and get a chunk of contiguous memory big enough to map the
    // entire aperture.
    //
    LowestAcceptable.QuadPart = 0;
    BoundaryMultiple.QuadPart = 0;
    HighestAcceptable.QuadPart = 0xFFFFFFFF;
    GartLength = BYTES_TO_PAGES(AgpContext->ApertureLength) * sizeof(GART_PTE);

    Gart = MmAllocateContiguousMemorySpecifyCache(GartLength,
                                                  LowestAcceptable,
                                                  HighestAcceptable,
                                                  BoundaryMultiple,
                                                  MmNonCached);

    if (Gart == NULL) {
        AGPLOG(AGP_CRITICAL,
               ("Agp440CreateGart - MmAllocateContiguousMemorySpecifyCache %lx failed\n",
                GartLength));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // We successfully allocated a contiguous chunk of memory.
    // It should be page aligned already.
    //
    ASSERT(((ULONG_PTR)Gart & (PAGE_SIZE-1)) == 0);

    //
    // Get the physical address.
    //
    GartPhysical = MmGetPhysicalAddress(Gart);
    AGPLOG(AGP_NOISE,
           ("Agp440CreateGart - GART of length %lx created at VA %08lx, PA %08lx\n",
            GartLength,
            Gart,
            GartPhysical.LowPart));
    ASSERT(GartPhysical.HighPart == 0);
    ASSERT((GartPhysical.LowPart & (PAGE_SIZE-1)) == 0);

    //
    // Initialize all the PTEs to free
    //
    for (i=0; i<GartLength/sizeof(GART_PTE); i++) {
        Gart[i].Soft.State = GART_ENTRY_FREE;
    }


    Write440Config(&GartPhysical.LowPart, ATTBASE_OFFSET, sizeof(GartPhysical.LowPart));

    //
    // Update our extension to reflect the current state.
    //
    AgpContext->Gart = Gart;
    AgpContext->GartLength = GartLength;
    AgpContext->GartPhysical = GartPhysical;

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpMapMemory(
    IN PAGP440_EXTENSION AgpContext,
    IN PAGP_RANGE Range,
    IN PMDL Mdl,
    IN ULONG OffsetInPages,
    OUT PHYSICAL_ADDRESS *MemoryBase
    )
/*++

Routine Description:

    Maps physical memory into the GART somewhere in the specified range.

Arguments:

    AgpContext - Supplies the AGP context

    Range - Supplies the AGP range that the memory should be mapped into

    Mdl - Supplies the MDL describing the physical pages to be mapped

    OffsetInPages - Supplies the offset into the reserved range where the 
        mapping should begin.

    MemoryBase - Returns the physical memory in the aperture where the pages
        were mapped.

Return Value:

    NTSTATUS

--*/

{
    ULONG PageCount;
    PGART_PTE Pte;
    PGART_PTE StartPte;
    ULONG Index;
    ULONG TargetState;
    PPFN_NUMBER Page;
    BOOLEAN Backwards;
    GART_PTE NewPte;
    PACCFG PACConfig;

    PAGED_CODE();

    ASSERT(Mdl->Next == NULL);

    StartPte = Range->Context;
    PageCount = BYTES_TO_PAGES(Mdl->ByteCount);
    ASSERT(PageCount <= Range->NumberOfPages);
    ASSERT(OffsetInPages <= Range->NumberOfPages);
    ASSERT(PageCount + OffsetInPages <= Range->NumberOfPages);
    ASSERT(PageCount > 0);

    TargetState = (Range->Type == MmNonCached) ? GART_ENTRY_RESERVED_UC : GART_ENTRY_RESERVED_WC;

    Pte = StartPte + OffsetInPages;

    //
    // We have a suitable range, now fill it in with the supplied MDL.
    //
    ASSERT(Pte >= StartPte);
    ASSERT(Pte + PageCount <= StartPte + Range->NumberOfPages);
    NewPte.AsUlong = 0;
    NewPte.Soft.State = (Range->Type == MmNonCached) ? GART_ENTRY_VALID_UC :
                                                       GART_ENTRY_VALID_WC;
    Page = (PPFN_NUMBER)(Mdl + 1);

    //
    // Disable the TB as per the 440 spec. This is probably unnecessary
    // as there should be no valid entries in this range, and there should
    // be no invalid entries still in the TB. So flushing the TB seems
    // a little gratuitous but that's what the 440 spec says to do.
    //
    Agp440DisableTB(AgpContext);

    for (Index = 0; Index < PageCount; Index++) {
        ASSERT(Pte[Index].Soft.State == TargetState);

        NewPte.Hard.Page = (ULONG)(*Page++);
        Pte[Index].AsUlong = NewPte.AsUlong;
        ASSERT(Pte[Index].Hard.Valid == 1);
    }

    //
    // We have filled in all the PTEs. Read back the last one we wrote
    // in order to flush the write buffers.
    //
    NewPte.AsUlong = *(volatile ULONG *)&Pte[PageCount-1].AsUlong;

    //
    // Re-enable the TB
    //
    Agp440EnableTB(AgpContext);

    //
    // If we have not yet gotten around to enabling the GART aperture, do it now.
    //
    if (!AgpContext->GlobalEnable) {
        AGPLOG(AGP_NOISE,
               ("AgpMapMemory - Enabling global aperture access\n"));

        Read440Config(&PACConfig, PACCFG_OFFSET, sizeof(PACConfig));
        PACConfig.GlobalEnable = 1;
        Write440Config(&PACConfig, PACCFG_OFFSET, sizeof(PACConfig));

        AgpContext->GlobalEnable = TRUE;
    }

    MemoryBase->QuadPart = Range->MemoryBase.QuadPart + (Pte - StartPte) * PAGE_SIZE;

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpUnMapMemory(
    IN PAGP440_EXTENSION AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages
    )
/*++

Routine Description:

    Unmaps previously mapped memory in the GART.

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the AGP range that the memory should be freed from

    NumberOfPages - Supplies the number of pages in the range to be freed.

    OffsetInPages - Supplies the offset into the range where the freeing should begin.

Return Value:

    NTSTATUS

--*/

{
    ULONG i;
    PGART_PTE Pte;
    PGART_PTE LastChanged=NULL;
    PGART_PTE StartPte;
    ULONG NewState;

    PAGED_CODE();

    ASSERT(OffsetInPages + NumberOfPages <= AgpRange->NumberOfPages);

    StartPte = AgpRange->Context;
    Pte = &StartPte[OffsetInPages];

    if (AgpRange->Type == MmNonCached) {
        NewState = GART_ENTRY_RESERVED_UC;
    } else {
        NewState = GART_ENTRY_RESERVED_WC;
    }

    //
    // Disable the TB to flush it
    //
    Agp440DisableTB(AgpContext);
    for (i=0; i<NumberOfPages; i++) {
        if (Pte[i].Hard.Valid) {
            Pte[i].Soft.State = NewState;
            LastChanged = Pte;
        } else {
            //
            // This page is not mapped, just skip it.
            //
            AGPLOG(AGP_NOISE,
                   ("AgpUnMapMemory - PTE %08lx (%08lx) at offset %d not mapped\n",
                    &Pte[i],
                    Pte[i].AsUlong,
                    i));
            ASSERT(Pte[i].Soft.State == NewState);
        }
    }

    //
    // We have invalidated all the PTEs. Read back the last one we wrote
    // in order to flush the write buffers.
    //
    if (LastChanged != NULL) {
        ULONG Temp;
        Temp = *(volatile ULONG *)(&LastChanged->AsUlong);
    }

    //
    // Reenable the TB
    //
    Agp440EnableTB(AgpContext);

    return(STATUS_SUCCESS);
}


PGART_PTE
Agp440FindRangeInGart(
    IN PGART_PTE StartPte,
    IN PGART_PTE EndPte,
    IN ULONG Length,
    IN BOOLEAN SearchBackward,
    IN ULONG SearchState
    )
/*++

Routine Description:

    Finds a contiguous range in the GART. This routine can
    search either from the beginning of the GART forwards or
    the end of the GART backwards.

Arguments:

    StartIndex - Supplies the first GART pte to search

    EndPte - Supplies the last GART to search (inclusive)

    Length - Supplies the number of contiguous free entries
        to search for.

    SearchBackward - TRUE indicates that the search should begin
        at EndPte and search backwards. FALSE indicates that the
        search should begin at StartPte and search forwards

    SearchState - Supplies the PTE state to look for.

Return Value:

    Pointer to the first PTE in the GART if a suitable range
    is found.

    NULL if no suitable range exists.

--*/

{
    PGART_PTE Current;
    PGART_PTE Last;
    LONG Delta;
    ULONG Found;
    PGART_PTE Candidate;

    PAGED_CODE();

    ASSERT(EndPte >= StartPte);
    ASSERT(Length <= (ULONG)(EndPte - StartPte + 1));
    ASSERT(Length != 0);

    if (SearchBackward) {
        Current = EndPte;
        Last = StartPte-1;
        Delta = -1;
    } else {
        Current = StartPte;
        Last = EndPte+1;
        Delta = 1;
    }

    Found = 0;
    while (Current != Last) {
        if (Current->Soft.State == SearchState) {
            if (++Found == Length) {
                //
                // A suitable range was found, return it
                //
                if (SearchBackward) {
                    return(Current);
                } else {
                    return(Current - Length + 1);
                }
            }
        } else {
            Found = 0;
        }
        Current += Delta;
    }

    //
    // A suitable range was not found.
    //
    return(NULL);
}


VOID
Agp440SetGTLB_Enable(
    IN PAGP440_EXTENSION AgpContext,
    IN BOOLEAN Enable
    )
/*++

Routine Description:

    Enables or disables the GTLB by setting or clearing the GTLB_Enable bit
    in the AGPCTRL register

Arguments:

    AgpContext - Supplies the AGP context

    Enable - TRUE, GTLB_Enable is set to 1
             FALSE, GTLB_Enable is set to 0

Return Value:

    None

--*/

{
    AGPCTRL AgpCtrl;

    Read440Config(&AgpCtrl, AGPCTRL_OFFSET, sizeof(AgpCtrl));

    if (Enable) {
        AgpCtrl.GTLB_Enable = 1;
    } else {
        AgpCtrl.GTLB_Enable = 0;
    }
    Write440Config(&AgpCtrl, AGPCTRL_OFFSET, sizeof(AgpCtrl));
}


VOID
AgpFindFreeRun(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT ULONG *FreePages,
    OUT ULONG *FreeOffset
    )
/*++

Routine Description:

    Finds the first contiguous run of free pages in the specified
    part of the reserved range.

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the AGP range

    NumberOfPages - Supplies the size of the region to be searched for free pages

    OffsetInPages - Supplies the start of the region to be searched for free pages

    FreePages - Returns the length of the first contiguous run of free pages

    FreeOffset - Returns the start of the first contiguous run of free pages

Return Value:

    None. FreePages == 0 if there are no free pages in the specified range.

--*/

{
    PGART_PTE Pte;
    ULONG i;
    
    Pte = (PGART_PTE)(AgpRange->Context) + OffsetInPages;

    //
    // Find the first free PTE
    //
    for (i=0; i<NumberOfPages; i++) {
        if (Pte[i].Hard.Valid == 0) {
            //
            // Found a free PTE, count the contiguous ones.
            //
            *FreeOffset = i + OffsetInPages;
            *FreePages = 0;
            while ((i<NumberOfPages) && (Pte[i].Hard.Valid == 0)) {
                *FreePages += 1;
                ++i;
            }
            return;
        }
    }

    //
    // No free PTEs in the specified range
    //
    *FreePages = 0;
    return;

}


VOID
AgpGetMappedPages(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT PMDL Mdl
    )
/*++

Routine Description:

    Returns the list of physical pages mapped into the specified 
    range in the GART.

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the AGP range

    NumberOfPages - Supplies the number of pages to be returned

    OffsetInPages - Supplies the start of the region 

    Mdl - Returns the list of physical pages mapped in the specified range.

Return Value:

    None

--*/

{
    PGART_PTE Pte;
    ULONG i;
    PULONG Pages;
    
    ASSERT(NumberOfPages * PAGE_SIZE == Mdl->ByteCount);

    Pages = (PULONG)(Mdl + 1);
    Pte = (PGART_PTE)(AgpRange->Context) + OffsetInPages;

    for (i=0; i<NumberOfPages; i++) {
        ASSERT(Pte[i].Hard.Valid == 1);
        Pages[i] = Pte[i].Hard.Page;
    }
    return;
}


NTSTATUS
AgpSpecialTarget(
    IN PAGP440_EXTENSION AgpContext,
    IN ULONGLONG DeviceFlags
    )
/*++

Routine Description:

    This routine makes "special" tweaks to the AGP chipset

Arguments:

    AgpContext - Supplies the AGP context
 
    DeviceFlags - Flags indicating what tweaks to perform

Return Value:

    STATUS_SUCCESS, or error

--*/
{
    NTSTATUS Status;

    //
    // Should we change the AGP rate?
    //
    if (DeviceFlags & AGP_FLAG_SPECIAL_RESERVE) {

        Status = Agp440SetRate(AgpContext,
                               (ULONG)((DeviceFlags & AGP_FLAG_SPECIAL_RESERVE)
                                       >> AGP_FLAG_SET_RATE_SHIFT));
        
        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    }

    //
    // Add more tweaks here...
    //

    AgpContext->SpecialTarget |= DeviceFlags;

    return STATUS_SUCCESS;
}


NTSTATUS
Agp440SetRate(
    IN PAGP440_EXTENSION AgpContext,
    IN ULONG AgpRate
    )
/*++

Routine Description:

    This routine sets the AGP rate

Arguments:

    AgpContext - Supplies the AGP context
 
    AgpRate - Rate to set

Return Value:

    STATUS_SUCCESS, or error status

--*/
{
    NTSTATUS Status;
    ULONG TargetEnable;
    ULONG MasterEnable;
    PCI_AGP_CAPABILITY TargetCap;
    PCI_AGP_CAPABILITY MasterCap;
    BOOLEAN ReverseInit;

    //
    // Read capabilities
    //
    Status = AgpLibGetPciDeviceCapability(0, 0, &TargetCap);

    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING, ("AGP440SetRate: AgpLibGetPciDeviceCapability "
                             "failed %08lx\n", Status));
        return Status;
    }

    Status = AgpLibGetMasterCapability(AgpContext, &MasterCap);

    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING, ("AGP440SetRate: AgpLibGetMasterCapability "
                             "failed %08lx\n", Status));
        return Status;
    }

    //
    // Verify the requested rate is supported by both master and target
    //
    if (!(AgpRate & TargetCap.AGPStatus.Rate & MasterCap.AGPStatus.Rate)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Disable AGP while the pull the rug out from underneath
    //
    TargetEnable = TargetCap.AGPCommand.AGPEnable;
    TargetCap.AGPCommand.AGPEnable = 0;

    Status = AgpLibSetPciDeviceCapability(0, 0, &TargetCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("AGP440SetRate: AgpLibSetPciDeviceCapability %08lx for "
                "Target failed %08lx\n",
                &TargetCap,
                Status));
        return Status;
    }
    
    MasterEnable = MasterCap.AGPCommand.AGPEnable;
    MasterCap.AGPCommand.AGPEnable = 0;

    Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("AGP440SetRate: AgpLibSetMasterCapability %08lx failed "
                "%08lx\n",
                &MasterCap,
                Status));
        return Status;
    }

    //
    // Fire up AGP with new rate
    //
    ReverseInit =
        (AgpContext->SpecialTarget & AGP_FLAG_REVERSE_INITIALIZATION) ==
        AGP_FLAG_REVERSE_INITIALIZATION;
    if (ReverseInit) {
        MasterCap.AGPCommand.Rate = AgpRate;
        MasterCap.AGPCommand.AGPEnable = MasterEnable;
        
        Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
        
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_WARNING,
                   ("AGP440SetRate: AgpLibSetMasterCapability %08lx failed "
                    "%08lx\n",
                    &MasterCap,
                    Status));
        }
    }

    TargetCap.AGPCommand.Rate = AgpRate;
    TargetCap.AGPCommand.AGPEnable = TargetEnable;
        
    Status = AgpLibSetPciDeviceCapability(0, 0, &TargetCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("AGP440SetRate: AgpLibSetPciDeviceCapability %08lx for "
                "Target failed %08lx\n",
                &TargetCap,
                Status));
        return Status;
    }

    if (!ReverseInit) {
        MasterCap.AGPCommand.Rate = AgpRate;
        MasterCap.AGPCommand.AGPEnable = MasterEnable;
        
        Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
        
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_WARNING,
                   ("AGP440SetRate: AgpLibSetMasterCapability %08lx failed "
                    "%08lx\n",
                    &MasterCap,
                    Status));
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\agp\agp460\init.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    init.c

Abstract:

    This module contains the initialization code for AGP460.SYS.

Author:

    Naga Gurumoorthy  6/11/1999

Revision History:

--*/

#include "agp460.h"

ULONG AgpExtensionSize = sizeof(AGP460_EXTENSION);
PAGP_FLUSH_PAGES AgpFlushPages;  


NTSTATUS
AgpInitializeTarget(
    IN PVOID AgpExtension
    )
/*++

Routine Description:

    Entrypoint for target initialization. This is called first.

Arguments:

    AgpExtension - Supplies the AGP extension

Return Value:

    NTSTATUS

--*/

{
    ULONG               DeviceVendorID  = 0;
    PAGP460_EXTENSION	Extension		= AgpExtension;

	AGPLOG(AGP_NOISE, ("AGP460: AgpInitializeTarget entered.\n"));

	//
    // Initialize our Extension
    //
    RtlZeroMemory(Extension, sizeof(AGP460_EXTENSION));


	//
	// TO DO:  Check the Device & Vendor ID for 82460GX. - Naga G
	//

    //
    // Initialize our chipset-specific extension
    //
    Extension->ApertureStart.QuadPart	  = 0;
    Extension->ApertureLength			  = 0;
    Extension->Gart						  = NULL;
    Extension->GartLength				  = 0;
    Extension->GlobalEnable				  = FALSE;
	Extension->ChipsetPageSize            = PAGESIZE_460GX_CHIPSET;
    Extension->GartPhysical.QuadPart	  = 0;
	Extension->bSupportMultipleAGPDevices = FALSE;
	Extension->bSupportsCacheCoherency    = TRUE;
        Extension->SpecialTarget = 0;

	AgpFlushPages = Agp460FlushPages;
	
	AGPLOG(AGP_NOISE, ("AGP460: Leaving AgpInitializeTarget.\n"));

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpInitializeMaster(
    IN  PVOID AgpExtension,
    OUT ULONG *AgpCapabilities
    )
/*++

Routine Description:

    Entrypoint for master initialization. This is called after target initialization
    and should be used to initialize the AGP capabilities of both master and target.

    This is also called when the master transitions into the D0 state.

Arguments:

    AgpExtension - Supplies the AGP extension

    AgpCapabilities - Returns the capabilities of this AGP device.

Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS Status;
    PCI_AGP_CAPABILITY MasterCap;
    PCI_AGP_CAPABILITY TargetCap;
    PAGP460_EXTENSION Extension = AgpExtension;
    ULONG SBAEnable;
    ULONG DataRate;
    ULONG FastWrite;
    ULONG CBN;
    BOOLEAN ReverseInit;

#if DBG
    PCI_AGP_CAPABILITY CurrentCap;
#endif

	AGPLOG(AGP_NOISE, ("AGP460: AgpInitializeMaster entered.\n"));

    //
    // VERY IMPORTANT:  In 82460GX, the GART is not part of the main memory (though it
	// occupies a range in the address space) and is instead hanging off the GXB. This 
	// will make accesses from the Graphics Card to the GART pretty fast. But, the price
	// we pay - processor can't access the GART.  Therefore, we tell the rest of the
	// world that is NOT OK to map the physical addresses given by GART. Instead processor
	// accesses should use the MDL. This is done by setting the capabilities to 0.
	// - Naga G
    //
    *AgpCapabilities = 0;

    //
    // Get the master and target AGP capabilities
    //
    Status = AgpLibGetMasterCapability(AgpExtension, &MasterCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGP460InitializeDevice - AgpLibGetMasterCapability failed %08lx\n"));
        return(Status);
    }

    //
    // Some broken cards (Matrox Millenium II "AGP") report no valid
    // supported transfer rates. These are not really AGP cards. They
    // have an AGP Capabilities structure that reports no capabilities.
    //
    if (MasterCap.AGPStatus.Rate == 0) {
        AGPLOG(AGP_CRITICAL,
               ("AGP460InitializeDevice - AgpLibGetMasterCapability returned no valid transfer rate\n"));
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

	// We can't get the capability for bus 0, dev 0 in 460GX. it is the SAC & we want the
	// GXB (Target).
    //Status = AgpLibGetPciDeviceCapability(0,0,&TargetCap);

	Read460CBN((PVOID)&CBN);
    // CBN is of one byte width, so zero out the other bits from 32-bits - Sunil
    EXTRACT_LSBYTE(CBN); 

	Status = AgpLibGetPciDeviceCapability(CBN,AGP460_GXB_SLOT_ID,&TargetCap);

    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGP460InitializeDevice - AgpLibGetPciDeviceCapability failed %08lx\n"));
        return(Status);
    }

    //
    // Determine the greatest common denominator for data rate.
    //
    DataRate = TargetCap.AGPStatus.Rate & MasterCap.AGPStatus.Rate;

    ASSERT(DataRate != 0);

    //
    // Select the highest common rate.
    //
    if (DataRate & PCI_AGP_RATE_4X) {
        DataRate = PCI_AGP_RATE_4X;
    } else if (DataRate & PCI_AGP_RATE_2X) {
        DataRate = PCI_AGP_RATE_2X;
    } else if (DataRate & PCI_AGP_RATE_1X) {
        DataRate = PCI_AGP_RATE_1X;
    }

    //
    // Previously a call was made to change the rate (successfully),
    // use this rate again now
    //
    if (Extension->SpecialTarget & AGP_FLAG_SPECIAL_RESERVE) {
        DataRate = (ULONG)((Extension->SpecialTarget & 
                            AGP_FLAG_SPECIAL_RESERVE) >>
                           AGP_FLAG_SET_RATE_SHIFT);
    }

    //
    // Enable SBA if both master and target support it.
    //
    SBAEnable = (TargetCap.AGPStatus.SideBandAddressing & MasterCap.AGPStatus.SideBandAddressing);

    //
    // Enable FastWrite if both master and target support it.
    //
    FastWrite = (TargetCap.AGPStatus.FastWrite & MasterCap.AGPStatus.FastWrite);

    //
    // Enable the Master first.
    //
    ReverseInit = 
        (Extension->SpecialTarget & AGP_FLAG_REVERSE_INITIALIZATION) ==
        AGP_FLAG_REVERSE_INITIALIZATION;
    if (ReverseInit) {
        MasterCap.AGPCommand.Rate              = DataRate;
        MasterCap.AGPCommand.AGPEnable         = TRUE;
        MasterCap.AGPCommand.SBAEnable         = SBAEnable;
        MasterCap.AGPCommand.FastWriteEnable   = FastWrite;
        MasterCap.AGPCommand.FourGBEnable      = FALSE;  
        MasterCap.AGPCommand.RequestQueueDepth = TargetCap.AGPStatus.RequestQueueDepthMaximum;
        
        Status = AgpLibSetMasterCapability(AgpExtension, &MasterCap);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AGP460InitializeDevice - AgpLibSetMasterCapability %08lx failed %08lx\n",
                    &MasterCap,
                    Status));
        }
    }

    //
    // Now enable the Target.
    //
    TargetCap.AGPCommand.Rate            = DataRate;
    TargetCap.AGPCommand.AGPEnable       = TRUE;
    TargetCap.AGPCommand.SBAEnable       = SBAEnable;
    TargetCap.AGPCommand.FastWriteEnable = FastWrite;
    TargetCap.AGPCommand.FourGBEnable    = FALSE;  

    Status = AgpLibSetPciDeviceCapability(CBN, AGP460_GXB_SLOT_ID, &TargetCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGP460InitializeDevice - AgpLibSetPciDeviceCapability %08lx for target failed %08lx\n",
                &TargetCap,
                Status));
        return(Status);
    }

    if (!ReverseInit) {
        MasterCap.AGPCommand.Rate              = DataRate;
        MasterCap.AGPCommand.AGPEnable         = TRUE;
        MasterCap.AGPCommand.SBAEnable         = SBAEnable;
        MasterCap.AGPCommand.FastWriteEnable   = FastWrite;
        MasterCap.AGPCommand.FourGBEnable      = FALSE;  
        MasterCap.AGPCommand.RequestQueueDepth = TargetCap.AGPStatus.RequestQueueDepthMaximum;
        
        Status = AgpLibSetMasterCapability(AgpExtension, &MasterCap);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AGP460InitializeDevice - AgpLibSetMasterCapability %08lx failed %08lx\n",
                    &MasterCap,
                    Status));
        }
    }

#if DBG
    //
    // Read them back, see if it worked
    //
    Status = AgpLibGetMasterCapability(AgpExtension, &CurrentCap);
    ASSERT(NT_SUCCESS(Status));

    //
    // If the target request queue depth is greater than the master will
    // allow, it will be trimmed.   Loosen the assert to not require an
    // exact match.
    //
    ASSERT(CurrentCap.AGPCommand.RequestQueueDepth <= MasterCap.AGPCommand.RequestQueueDepth);
    CurrentCap.AGPCommand.RequestQueueDepth = MasterCap.AGPCommand.RequestQueueDepth;
    ASSERT(RtlEqualMemory(&CurrentCap.AGPCommand, &MasterCap.AGPCommand, sizeof(CurrentCap.AGPCommand)));

//    Status = AgpLibGetPciDeviceCapability(0,0,&CurrentCap);
	Status = AgpLibGetPciDeviceCapability(CBN,AGP460_GXB_SLOT_ID,&CurrentCap);	

    ASSERT(NT_SUCCESS(Status));
    ASSERT(RtlEqualMemory(&CurrentCap.AGPCommand, &TargetCap.AGPCommand, sizeof(CurrentCap.AGPCommand)));

#endif

	AGPLOG(AGP_NOISE, ("AGP460: Leaving AgpInitializeMaster.\n"));

    return(Status);
}


NTSTATUS
Agp460FlushPages(
    IN PAGP460_EXTENSION AgpContext,
    IN PMDL Mdl
    )

/*++

Routine Description:

    Flush entries in the GART. Currently a stub for 
	Win64 version of 460GX filter driver. This flushing  is done previously to 
	avoid any caching issues due to the same memory aliased with different caching
	attributes. Now that is taken care by the memory manager calls themselves (Win64 only).
	Therefore we just have a stub so that nothing gets executed in the AGPLIB code. (see
	AGPLIB code for details)

Arguments:

    AgpContext - Supplies the AGP context

    Mdl - Supplies the MDL describing the physical pages to be flushed

Return Value:

    STATUS_SUCCESS

--*/

{
    	AGPLOG(AGP_NOISE, ("AGP460: Entering AGPFlushPages.\n"));
		AGPLOG(AGP_NOISE, ("AGP460: Leaving AGPFlushPages.\n"));

                return STATUS_SUCCESS;   
}

void Read460CBN(PVOID _CBN_)					                
{                                                           
    ULONG _len_;                                            
    _len_ = HalGetBusDataByOffset(PCIConfiguration,         
                                  AGP460_SAC_BUS_ID,			
                                  AGP460_SAC_CBN_SLOT_ID,	
                                  _CBN_,                  
                                  0x40,		                
                                  1);		                
    ASSERT(_len_ ==	1);	
	return;
}


void Read460Config(ULONG _CBN_,PVOID  _buf_,ULONG _offset_,ULONG _size_)          
{                                                           
    ULONG _len_;                                            
    _len_ = HalGetBusDataByOffset(PCIConfiguration,         
                                  _CBN_,			        
                                  AGP460_GXB_SLOT_ID,		
                                  _buf_,                  
                                  _offset_,               
                                  _size_);                
    ASSERT(_len_ == (_size_));                             

	return;
}


void Write460Config(ULONG _CBN_,PVOID _buf_,ULONG _offset_,ULONG _size_)         
{                                                           
    ULONG _len_;                                            
    _len_ = HalSetBusDataByOffset(PCIConfiguration,         
                                  (_CBN_),					
                                  AGP460_GXB_SLOT_ID,		
                                  (_buf_),                  
                                  (_offset_),               
                                  (_size_));                
    ASSERT(_len_ == (_size_));                              
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\agp\agpcpq\agpcpq.h ===
/******************************************************************************\
*
*  FileName:    AGPCPQ.H       
*
*  Group:       AGP (Accelerated Graphics Port)
*                    
*  Level:       Driver
*
*  Date:        December 15, 1997
*
*  Author:      John Theisen
*
********************************************************************************
*
*  Module Functional Description:
*
*      This is the header file for Compaq's Accelerated Graphics Port (AGP) 
*      GART MiniPort driver.
*
********************************************************************************
*
*  History:
*
*    DATE   REV. DESCRIPTION                          DELEVOPER
*  -------- ---- ------------------------------------ -------------------------
*
*  12/15/97 1.00 Initial Revision.                    John Theisen
*
\******************************************************************************/
#define _NTDRIVER_

#include "stdarg.h"
#include "stdio.h"
#include "ntos.h"
#include "pci.h"
#include "wdmguid.h"
#include "zwapi.h"
#include "ntpoapi.h"

#include "agp.h"

//
// Device/Function/Bus numbers for the primary and secondary north bridges.
//
// "Primary" values are the same for RCC and Draco.
// "Secondary" values are only relevant on RCC HPSA machines.  
//      (By definition, if a northbridge exists at this location, then it is an HPSA machine.)
// 
#define PRIMARY_LE_BUS_ID              0
#define SECONDARY_LE_BUS_ID            0

//
// PCI_SLOT_NUMBER type = ULONG == [XXXXXXXX XXXXXXXX XXXXXXXX YYYZZZZZ]
//
// Where X = reserved
//       Y = function number 0 - 7
//       Z = device number 0 - 255
//
#define MAKE_PCI_SLOT_NUMBER(dev, func) ((func << 5) + (dev))

#define PRIMARY_LE_HOST_DEVICE          0
#define PRIMARY_LE_HOST_FUNCTION        0
#define PRIMARY_LE_PCI_DEVICE           PRIMARY_LE_HOST_DEVICE
#define PRIMARY_LE_PCI_FUNCION          1
#define SECONDARY_LE_HOST_DEVICE        17
#define SECONDARY_LE_HOST_FUNCTION      0
#define SECONDARY_LE_PCI_DEVICE         SECONDARY_LE_HOST_DEVICE      
#define SECONDARY_LE_PCI_FUNCION        1


#define PRIMARY_LE_HOSTPCI_SLOT_ID      MAKE_PCI_SLOT_NUMBER(PRIMARY_LE_HOST_DEVICE, PRIMARY_LE_HOST_FUNCTION)
#define PRIMARY_LE_PCIPCI_SLOT_ID       MAKE_PCI_SLOT_NUMBER(PRIMARY_LE_PCI_DEVICE, PRIMARY_LE_PCI_FUNCION)
#define SECONDARY_LE_HOSTPCI_SLOT_ID    MAKE_PCI_SLOT_NUMBER(SECONDARY_LE_HOST_DEVICE, SECONDARY_LE_HOST_FUNCTION)
#define SECONDARY_LE_PCIPCI_SLOT_ID     MAKE_PCI_SLOT_NUMBER(SECONDARY_LE_PCI_DEVICE, SECONDARY_LE_PCI_FUNCION)


//
//
//
#define AGP_CPQ_BUS_ID          PRIMARY_LE_BUS_ID
#define AGP_CPQ_HOSTPCI_SLOT_ID PRIMARY_LE_HOSTPCI_SLOT_ID  
#define AGP_CPQ_PCIPCI_SLOT_ID  PRIMARY_LE_PCIPCI_SLOT_ID   

#define OFFSET_DEVICE_VENDOR_ID 0x00 
#define OFFSET_BAR0             0x10    // Base of AGP Device Address Space
#define OFFSET_BAR1             0x14    // Memory Mapped Control Registers Pointer
#define OFFSET_AP_SIZE          0x8C    // For the RCC chipsets.  Draco doesn't implement this.
#define OFFSET_REV_ID           0x08    // Silicon Revision ID (on RCC chipsets).
#define MAX_REV_ID_TO_LIMIT_1X  4       // Maximum Silicon Rev ID that has the 2X bug.
#define MAX_REV_ID_TO_FIX_RQ    5       // Macimum Silicon Rev ID that has the RQ bug.
#define OFFSET_SHADOW_BYTE      0x93    // Byte that contains the shaddow enable bit (bit 3).
#define FLAG_DISABLE_SHADOW     0x08
#define MASK_ENABLE_SHADOW      (~FLAG_DISABLE_SHADOW)

//
// RCC Vendor-Device IDs (as of August 1998):
//
// CNB_20_LE (function 0) -- 0x00071166
// CNB_20_LE (function 1) -- 0x00051166
// CNB_20_HE (function 0) -- 0x00081166 
// CNB_20_HE (function 1) -- 0x00091166
//
#define AGP_CNB20_LE_IDENTIFIER   0x00071166 // * function 0 ID.
#define AGP_CNB20_HE_IDENTIFIER   0x00081166 
#define AGP_CNB20_HE4X_IDENTIFIER 0x00131166
#define AGP_CMIC_GC_IDENTIFIER    0x00151166
#define AGP_DRACO_IDENTIFIER      0xAE6C0E11 // * Note, support for this chipset is no longer required.


#define AP_SIZE_DEFAULT         0x10000000 // all chipsets default to 256MB

#define AP_MAX_SIZE_CNB20_LE    0x80000000 // 2GB    
#define AP_MAX_SIZE_CNB20_HE    0x80000000 // 2GB  
 
#define AP_MAX_SIZE_DRACO       0x10000000 // 256MB

#define AP_SIZE_COUNT_CNB20_LE  7
#define AP_SIZE_COUNT_CNB20_HE  7
#define AP_SIZE_COUNT_DRACO     1

#define LOWEST_REVISION_ID_SUPPORTED        1

#define MAX_CACHED_ENTRIES_TO_INVALIDATE    3   

#define MASK_LOW_TWENTYFIVE             (~0x01FFFFFF)
#define ALL_ONES                        (~0x0)

//
// Conversions from BAR0 read/write-attribute-encoding to aperture sizes.
//
// 0x00000000 (b 0000 0000 ...) =    0MB
// 0xFE000000 (b 1111 1110 ...) =   32MB
// 0xFC000000 (b 1111 1100 ...) =   64MB
// 0xF8000000 (b 1111 1000 ...) =  128MB
// 0xF0000000 (b 1111 0000 ...) =  256MB
// 0xE0000000 (b 1110 0000 ...) =  512MB
// 0xC0000000 (b 1100 0000 ...) =    1GB
// 0x80000000 (b 1000 0000 ...) =    2GB

#define BAR0_CODED_AP_SIZE_0MB     0x00000000
#define BAR0_CODED_AP_SIZE_32MB    0xFE000000
#define BAR0_CODED_AP_SIZE_64MB    0xFC000000
#define BAR0_CODED_AP_SIZE_128MB   0xF8000000
#define BAR0_CODED_AP_SIZE_256MB   0xF0000000
#define BAR0_CODED_AP_SIZE_512MB   0xE0000000
#define BAR0_CODED_AP_SIZE_1GB     0xC0000000
#define BAR0_CODED_AP_SIZE_2GB     0x80000000

//
// Conversions from the values in bits 3:1 of the AGP Device 
// Address Space Size Register to aperture sizes.
//
// 0    (b 000)    =    32MB
// 1    (b 001)    =    64MB
// 2    (b 010)    =   128MB
// 3    (b 011)    =   256MB
// 4    (b 100)    =   512MB
// 5    (b 101)    =     1GB
// 6    (b 110)    =     2GB
// 7    (b 111)    ->   "Reserved"
//
#define SET_AP_SIZE_32MB     0
#define SET_AP_SIZE_64MB     1
#define SET_AP_SIZE_128MB    2
#define SET_AP_SIZE_256MB    3
#define SET_AP_SIZE_512MB    4
#define SET_AP_SIZE_1GB      5
#define SET_AP_SIZE_2GB      6

#define BYTES_2G    0x80000000UL  // 2G Value, to avoid integral const. overflow 

// 
// Taken from config.c
//
typedef struct _BUS_SLOT_ID {
    ULONG BusId;
    ULONG SlotId;
} BUS_SLOT_ID, *PBUS_SLOT_ID;

//
// Macros for reading and writing to the Host-PCI Bridge registers
//
#define ReadCPQConfig(_buf_,_offset_,_size_)                \
{                                                           \
    ULONG _len_;                                            \
    _len_ = HalGetBusDataByOffset(PCIConfiguration,         \
                                  AGP_CPQ_BUS_ID,           \
                                  AGP_CPQ_HOSTPCI_SLOT_ID,  \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  (_size_));                \
    ASSERT(_len_ == (_size_));                              \
}

#define WriteCPQConfig(_buf_,_offset_,_size_)               \
{                                                           \
    ULONG _len_;                                            \
    _len_ = HalSetBusDataByOffset(PCIConfiguration,         \
                                  AGP_CPQ_BUS_ID,           \
                                  AGP_CPQ_HOSTPCI_SLOT_ID,  \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  (_size_));                \
    ASSERT(_len_ == (_size_));                              \
}

//
// Macro to translate the APSIZE encoding into MB.
//
#define TranslateCodedValueIntoApSize(_apsize_, _value_)                         \
{                                                                              \
    _apsize_ = (((_value_ & MASK_LOW_TWENTYFIVE) ^ ALL_ONES) + 1);             \
}


//
// GART table entry.
//
typedef struct _GART_ENTRY_HW {
    ULONG Valid     :  1;
    ULONG Linked    :  1;
    ULONG Dirty     :  1;
    ULONG Rsrvd1    :  9;
    ULONG Page      : 20;
} GART_ENTRY_HW, *PGART_ENTRY_HW;

typedef struct _GART_ENTRY_SW {
    ULONG State     : 5;
    ULONG Rsrvd1    : 27;
} GART_ENTRY_SW, *PGART_ENTRY_SW;

typedef struct _GART_PTE {
    union {
        GART_ENTRY_HW Hard;
        ULONG      AsUlong;
        GART_ENTRY_SW Soft;
    };
} GART_PTE, *PGART_PTE;

//
// GART Entry bits
//
#define GART_ENTRY_INVALID      0x00          // 00000
#define GART_ENTRY_VALID        0x01          // 00001
#define GART_ENTRY_LINKED       0x02          // 00010
#define GART_ENTRY_DIRTY        0x04          // 00100
#define GART_ENTRY_WC           0x08          // 01000
#define GART_ENTRY_UC           0x10          // 10000

//
// Defined GART Entry states. 
//
#define GART_ENTRY_FREE             GART_ENTRY_INVALID

#define GART_ENTRY_RESERVED_WC      GART_ENTRY_WC 
#define GART_ENTRY_RESERVED_UC      GART_ENTRY_UC 

#define GART_ENTRY_VALID_WC         (GART_ENTRY_VALID)
#define GART_ENTRY_VALID_UC         (GART_ENTRY_VALID)

#define GART_ENTRY_VALID_WC_LINKED  (GART_ENTRY_VALID_WC | GART_ENTRY_LINKED)
#define GART_ENTRY_VALID_UC_LINKED  (GART_ENTRY_VALID_UC | GART_ENTRY_LINKED)

//
// Memory Mapped Control Registers.
//
typedef struct _GART_CACHE_ENTRY_CONTROL_REGISTER {
    ULONG   volatile GartEntryInvalidate:1;
    ULONG   volatile GartEntryUpdate:1;
    ULONG   Rsrvd1:10;
    ULONG   volatile GartEntryOffset:20;
} GART_CACHE_ENTRY_CONTROL_REGISTER, *PGART_CACHE_ENTRY_CONTROL_REGISTER;

typedef struct _GART_CACHE_ENTRY_CONTROL {
    union {
        GART_CACHE_ENTRY_CONTROL_REGISTER AsBits;
        ULONG   volatile AsDword;
    };
} GART_CACHE_ENTRY_CONTROL, *PGART_CACHE_ENTRY_CONTROL;

typedef struct _MM_CONTROL_REGS {
    UCHAR   RevisionID;
    struct  _GART_CAPABILITES {
        UCHAR   ValidBitErrorReportingSupported:1;
        UCHAR   LinkingSupported:1;
        UCHAR   TwoLevelAddrTransSupported:1;
        UCHAR   BusCountersSupported:1;
        UCHAR   Rsrvd1:4;
    } Capabilities;
    struct _GART_FEATURE_CONTROL {
        UCHAR   ValidBitErrorReportingEnable:1;
        UCHAR   LinkingEnable:1;
        UCHAR   Rsrvd1:1;
        UCHAR   GARTCacheEnable:1;
        UCHAR   Rsrvd2:4;
    } FeatureControl;
    struct _GART_FEATURE_STATUS {
        UCHAR   volatile ValidBitErrorDetected:1;
        UCHAR   Rsrvd1:7;
    } FeatureStatus;
    struct _GART_BASE_ADDRESS {
        ULONG   Rsrvd1:12;
        ULONG   Page:20;
    } GartBase;
    struct _GART_AND_DIR_CACHE_SIZES {
        ULONG   MaxTableEntries:16;
        ULONG   MaxDirEntries:16;
    } CacheSize;
    struct _GART_CACHE_CONTROL {
        ULONG   volatile GartAndDirCacheInvalidate:1;
        ULONG   Rsrvd1:31;
    } CacheControl;
    GART_CACHE_ENTRY_CONTROL CacheEntryControl;
    struct _POSTED_WRITE_BUFFER_CONTROL {
        UCHAR   volatile Flush:1;
        UCHAR   Rsrvd1:7;
    } PostedWriteBufferControl;
    struct _AGP_BUS_COUNTERS_COMMAND {
        UCHAR   volatile ClearCounters:1;
        UCHAR   EnableUtilization:1;
        UCHAR   EnableBandwidth:1;
        UCHAR   EnableLatency:1;
        UCHAR   Rsrvd1:4;
    } BusCounters;
    USHORT  Rsrvd1;
    ULONG   BusUtilizationCounter;
    ULONG   BusBandwidthCounter;
    ULONG   BusLatencyCounter;
} MM_CONTROL_REGS, *PMM_CONTROL_REGS;

typedef struct _AGP_DEVICE_ADDRESS_SPACE_SIZE_REG {
    UCHAR   Rsrvd1:4;
    UCHAR   ApSize:3;
    UCHAR   AgpValid:1;
} AGP_DAS_SIZE_REG, *PAGP_DAS_SIZE_REG;

typedef struct _AGP_AP_SIZE_REG {
    union {
        AGP_DAS_SIZE_REG    AsBits;
        UCHAR               AsByte;
    };
} AGP_AP_SIZE_REG, *PAGP_AP_SIZE_REG;

//
// Compaq-specific extension
//
typedef struct _AGPCPQ_EXTENSION {
    PMM_CONTROL_REGS    MMIO;
    PHYSICAL_ADDRESS    ApertureStart;
    ULONG               ApertureLength;
    PGART_PTE           Gart;
    PVOID               Dir;
    ULONG               GartLength;
    ULONG               MaxGartLength;
    ULONG               DeviceVendorID;
    ULONG               GartPointer;              
    BOOLEAN             IsHPSA;
    ULONGLONG           SpecialTarget;
} AGPCPQ_EXTENSION, *PAGPCPQ_EXTENSION;

//
// Taken from Config.c
//
extern
NTSTATUS
ApGetSetBusData(
    IN PBUS_SLOT_ID BusSlotId,
    IN BOOLEAN Read,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

extern
NTSTATUS 
DnbSetShadowBit(
    ULONG SetToOne
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\agp\agp440\init.c ===
/*++

Copyright (c) 1996, 1997 Microsoft Corporation

Module Name:

    init.c

Abstract:

    This module contains the initialization code for AGP440.SYS.

Author:

    John Vert (jvert) 10/21/1997

Revision History:

--*/

#include "agp440.h"

ULONG AgpExtensionSize = sizeof(AGP440_EXTENSION);
PAGP_FLUSH_PAGES AgpFlushPages = NULL;  // not implemented


NTSTATUS
AgpInitializeTarget(
    IN PVOID AgpExtension
    )
/*++

Routine Description:

    Entrypoint for target initialization. This is called first.

Arguments:

    AgpExtension - Supplies the AGP extension

Return Value:

    NTSTATUS

--*/

{
    PAGP440_EXTENSION Extension = AgpExtension;

    //
    // Initialize our chipset-specific extension
    //
    Extension->ApertureStart.QuadPart = 0;
    Extension->ApertureLength = 0;
    Extension->Gart = NULL;
    Extension->GartLength = 0;
    Extension->GlobalEnable = FALSE;
    Extension->PCIEnable = FALSE;
    Extension->GartPhysical.QuadPart = 0;
    Extension->SpecialTarget = 0;

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpInitializeMaster(
    IN  PVOID AgpExtension,
    OUT ULONG *AgpCapabilities
    )
/*++

Routine Description:

    Entrypoint for master initialization. This is called after target initialization
    and should be used to initialize the AGP capabilities of both master and target.

    This is also called when the master transitions into the D0 state.

Arguments:

    AgpExtension - Supplies the AGP extension

    AgpCapabilities - Returns the capabilities of this AGP device.

Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS Status;
    PCI_AGP_CAPABILITY MasterCap;
    PCI_AGP_CAPABILITY TargetCap;
    PAGP440_EXTENSION Extension = AgpExtension;
    ULONG SBAEnable;
    ULONG DataRate;
    ULONG FastWrite;
    BOOLEAN ReverseInit;
    ULONG VendorId = 0;
    ULONG AgpCtrl = 0;
    
#if DBG
    PCI_AGP_CAPABILITY CurrentCap;
#endif

    //
    // Intel says if all BIOS manufacturers perform RMW ops on this
    // register, then it will always be set, however two video OEMs
    // have complained of systems where this was not set, and was
    // causing the system to freeze, so we'll hard code it just in
    // case (only affects 440LX)
    //
    Read440Config(&VendorId, 0, sizeof(VendorId));
    if ((VendorId == AGP_440LX_IDENTIFIER) ||
        (VendorId == AGP_440LX2_IDENTIFIER)) {
        Read440Config(&AgpCtrl, AGPCTRL_OFFSET, sizeof(AgpCtrl));
        AgpCtrl |= READ_SYNC_ENABLE;
        Write440Config(&AgpCtrl, AGPCTRL_OFFSET, sizeof(AgpCtrl)); 
    }

    //
    // Indicate that we can map memory through the GART aperture
    //
    *AgpCapabilities = AGP_CAPABILITIES_MAP_PHYSICAL;

    //
    // Get the master and target AGP capabilities
    //
    Status = AgpLibGetMasterCapability(AgpExtension, &MasterCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGP440InitializeDevice - AgpLibGetMasterCapability failed %08lx\n"));
        return(Status);
    }

    //
    // Some broken cards (Matrox Millenium II "AGP") report no valid
    // supported transfer rates. These are not really AGP cards. They
    // have an AGP Capabilities structure that reports no capabilities.
    //
    if (MasterCap.AGPStatus.Rate == 0) {
        AGPLOG(AGP_CRITICAL,
               ("AGP440InitializeDevice - AgpLibGetMasterCapability returned no valid transfer rate\n"));
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

    Status = AgpLibGetPciDeviceCapability(0,0,&TargetCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGP440InitializeDevice - AgpLibGetPciDeviceCapability failed %08lx\n"));
        return(Status);
    }

    //
    // Determine the greatest common denominator for data rate.
    //
    DataRate = TargetCap.AGPStatus.Rate & MasterCap.AGPStatus.Rate;

    ASSERT(DataRate != 0);

    //
    // Select the highest common rate.
    //
    if (DataRate & PCI_AGP_RATE_4X) {
        DataRate = PCI_AGP_RATE_4X;
    } else if (DataRate & PCI_AGP_RATE_2X) {
        DataRate = PCI_AGP_RATE_2X;
    } else if (DataRate & PCI_AGP_RATE_1X) {
        DataRate = PCI_AGP_RATE_1X;
    }

    //
    // Previously a call was made to change the rate (successfully),
    // use this rate again now
    //
    if (Extension->SpecialTarget & AGP_FLAG_SPECIAL_RESERVE) {
        DataRate = (ULONG)((Extension->SpecialTarget & 
                            AGP_FLAG_SPECIAL_RESERVE) >>
                           AGP_FLAG_SET_RATE_SHIFT);
    }

    //
    // Enable SBA if both master and target support it.
    //
    SBAEnable = (TargetCap.AGPStatus.SideBandAddressing & MasterCap.AGPStatus.SideBandAddressing);

    //
    // Enable FastWrite if both master and target support it.
    //
    FastWrite = (TargetCap.AGPStatus.FastWrite & MasterCap.AGPStatus.FastWrite);

    //
    // Enable the Master first.
    //
    ReverseInit = 
        (Extension->SpecialTarget & AGP_FLAG_REVERSE_INITIALIZATION) ==
        AGP_FLAG_REVERSE_INITIALIZATION;
    if (ReverseInit) {
        MasterCap.AGPCommand.Rate = DataRate;
        MasterCap.AGPCommand.AGPEnable = 1;
        MasterCap.AGPCommand.SBAEnable = SBAEnable;
        MasterCap.AGPCommand.FastWriteEnable = FastWrite;
        MasterCap.AGPCommand.FourGBEnable = 0;  
        MasterCap.AGPCommand.RequestQueueDepth = TargetCap.AGPStatus.RequestQueueDepthMaximum;
        Status = AgpLibSetMasterCapability(AgpExtension, &MasterCap);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AGP440InitializeDevice - AgpLibSetMasterCapability %08lx failed %08lx\n",
                    &MasterCap,
                    Status));
        }
    }

    //
    // Now enable the Target.
    //
    TargetCap.AGPCommand.Rate = DataRate;
    TargetCap.AGPCommand.AGPEnable = 1;
    TargetCap.AGPCommand.SBAEnable = SBAEnable;
    TargetCap.AGPCommand.FastWriteEnable = FastWrite;
    TargetCap.AGPCommand.FourGBEnable = 0;  
    Status = AgpLibSetPciDeviceCapability(0, 0, &TargetCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGP440InitializeDevice - AgpLibSetPciDeviceCapability %08lx for target failed %08lx\n",
                &TargetCap,
                Status));
        return(Status);
    }

    if (!ReverseInit) {
        MasterCap.AGPCommand.Rate = DataRate;
        MasterCap.AGPCommand.AGPEnable = 1;
        MasterCap.AGPCommand.SBAEnable = SBAEnable;
        MasterCap.AGPCommand.FastWriteEnable = FastWrite;
        MasterCap.AGPCommand.FourGBEnable = 0;  
        MasterCap.AGPCommand.RequestQueueDepth = TargetCap.AGPStatus.RequestQueueDepthMaximum;
        Status = AgpLibSetMasterCapability(AgpExtension, &MasterCap);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AGP440InitializeDevice - AgpLibSetMasterCapability %08lx failed %08lx\n",
                    &MasterCap,
                    Status));
        }
    }

#if DBG
    //
    // Read them back, see if it worked
    //
    Status = AgpLibGetMasterCapability(AgpExtension, &CurrentCap);
    ASSERT(NT_SUCCESS(Status));

    //
    // If the target request queue depth is greater than the master will
    // allow, it will be trimmed.   Loosen the assert to not require an
    // exact match.
    //
    ASSERT(CurrentCap.AGPCommand.RequestQueueDepth <= MasterCap.AGPCommand.RequestQueueDepth);
    CurrentCap.AGPCommand.RequestQueueDepth = MasterCap.AGPCommand.RequestQueueDepth;
    ASSERT(RtlEqualMemory(&CurrentCap.AGPCommand, &MasterCap.AGPCommand, sizeof(CurrentCap.AGPCommand)));

    Status = AgpLibGetPciDeviceCapability(0,0,&CurrentCap);
    ASSERT(NT_SUCCESS(Status));
    ASSERT(RtlEqualMemory(&CurrentCap.AGPCommand, &TargetCap.AGPCommand, sizeof(CurrentCap.AGPCommand)));

#endif

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\agp\agpcpq\gart.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    gart.c

Abstract:


      This module contains the routines for setting and querying the AGP
      aperture, and for Reserving, Releasing, Mapping, and Unmapping.

   TODO:  
       1. Optimize for dual memory controllers (Done on 3/24/99 by elliots)
       2. Claim MMIO resources for the chipset
       3. Make sure the driver is generic for all RCC based systems (not just SP700).


Author:

    John Vert (jvert) 10/30/1997

Revision History:

    12/15/97    John Theisen    Modified to support Compaq Chipsets
    10/09/98    John Theisen    Modified to enable Shadowing in the SP700
                                prior to MMIO writes.
    01/15/99    John Theisen    Modified to disable the aperture, by
                                shrinking it to size = 0.
    3/24/99     Elliot Shmukler Added support for "favored" memory
                                ranges for AGP physical memory allocation,
                                fixed some bugs. These changes optimizine
                                the driver for dual memory controllers.
    3/16/00     Peter Johnston  Add support for ServerWorks HE chipset.
                                          
--*/
#include "AGPCPQ.H"

//
// Local routine prototypes
//
NTSTATUS
AgpCPQCreateGart(
    IN PAGPCPQ_EXTENSION AgpContext,
    IN ULONG MinimumPages
    );

NTSTATUS
AgpCPQSetRate(
    IN PVOID AgpContext,
    IN ULONG AgpRate
    );

PGART_PTE
AgpCPQFindRangeInGart(
    IN PGART_PTE StartPte,
    IN PGART_PTE EndPte,
    IN ULONG Length,
    IN BOOLEAN SearchBackward,
    IN ULONG SearchState
    );

VOID
AgpCPQMaintainGARTCacheCoherency (
    IN PAGPCPQ_EXTENSION AgpContext,
    IN PHYSICAL_ADDRESS MemoryBase,
    IN ULONG NumberOfEntries,
    IN BOOLEAN InvalidateAll
    );

PIO_RESOURCE_LIST 
AgpCPQGetApSizeRequirements(
    ULONG   MaxSize,
    ULONG   Count
    );

NTSTATUS
AgpCPQSetApSizeInChipset
    (
    IN UCHAR               NewSetApSize,
    IN UCHAR               NewSetAgpValid
    );

NTSTATUS
AgpCPQSetApBaseInChipset
    (
    IN  PHYSICAL_ADDRESS    NewBase
    );


//
// IMPLEMENTATION
//

NTSTATUS
AgpQueryAperture(
    IN PAGPCPQ_EXTENSION AgpContext,
    OUT PHYSICAL_ADDRESS *CurrentBase,
    OUT ULONG *CurrentSizeInPages,
    OUT OPTIONAL PIO_RESOURCE_LIST *pApertureRequirements
    )
/*******************************************************************************
*                                                                          
* Routine Functional Description:                                            
*                                                                            
*   Returns the current base and size of the GART aperture. Optionally returns
*   the possible GART settings.
*               
* Arguments:
*   
*   AgpContext -- Supplies the AGP Context, i.e. the AGP Extension. 
*
*   CurrentBase -- Returns the current physical address of the aperture.
*
*   CurrentSizeInPages -- Returns the current size of the aperture, in pages.
*
*   pApertureRequirements -- If present, returns the possible aperture 
*       settings.
*
* Return Value:
*
*   NTSTATUS
*                                                                       
*******************************************************************************/

{
    ULONG BAR0, CodedApSize;

    AGPLOG(AGP_NOISE, ("AgpCpq: AgpQueryAperture entered.\n"));

    //
    // Get the current base physical address of the AGP Aperture.
    //
    ReadCPQConfig(&BAR0, OFFSET_BAR0, sizeof(BAR0));
    CurrentBase->QuadPart = BAR0 & PCI_ADDRESS_MEMORY_ADDRESS_MASK;

    //
    // Get the (current) size of the aperture.  This is done by writing all ones
    // to BAR0, and then reading back the value.  The Read/Write attributes
    // of bits 31:25 in BAR0 will indicate the size.  
    //
    CodedApSize = ALL_ONES;
    WriteCPQConfig(&CodedApSize, OFFSET_BAR0, sizeof(ULONG));
    ReadCPQConfig(&CodedApSize, OFFSET_BAR0, sizeof(CodedApSize));
    WriteCPQConfig(&BAR0, OFFSET_BAR0, sizeof(ULONG));

    CodedApSize &= MASK_LOW_TWENTYFIVE;
    switch(CodedApSize) {
        case BAR0_CODED_AP_SIZE_0MB:
            *CurrentSizeInPages = 0;
            break;
        case BAR0_CODED_AP_SIZE_32MB:
            *CurrentSizeInPages = (32 * 1024*1024) / PAGE_SIZE;
            break;
        case BAR0_CODED_AP_SIZE_64MB:
            *CurrentSizeInPages = (64 * 1024*1024) / PAGE_SIZE;
            break;
        case BAR0_CODED_AP_SIZE_128MB:
            *CurrentSizeInPages = (128* 1024*1024) / PAGE_SIZE;
            break;
        case BAR0_CODED_AP_SIZE_256MB:
            *CurrentSizeInPages = (256* 1024*1024) / PAGE_SIZE;
            break;
        case BAR0_CODED_AP_SIZE_512MB:
            *CurrentSizeInPages = (512* 1024*1024) / PAGE_SIZE;
            break;
        case BAR0_CODED_AP_SIZE_1GB:
            *CurrentSizeInPages = (1024*1024*1024) / PAGE_SIZE;
            break;
        case BAR0_CODED_AP_SIZE_2GB:
            *CurrentSizeInPages = (BYTES_2G) / PAGE_SIZE;
            break;
        default:
            AGPLOG(AGP_CRITICAL,
                ("AGPCPQ - AgpQueryAperture - Unexpected HW aperture size: %x.\n",
                *CurrentSizeInPages * PAGE_SIZE));
            ASSERT(FALSE);
            AgpContext->ApertureStart.QuadPart = 0;
            AgpContext->ApertureLength = 0;
            return(STATUS_UNSUCCESSFUL);
    }

    //
    // Remember the current aperture settings
    //
    AgpContext->ApertureStart.QuadPart = CurrentBase->QuadPart;
    AgpContext->ApertureLength = *CurrentSizeInPages * PAGE_SIZE;

    // 
    // The pApertureRequirements will be returned in an 
    // IO_RESOURCE_REQUIREMENTS_LIST structure
    // that describes the possible aperture sizes and bases that we support.
    // This will depend on which chipset we are running on, i.e. the 
    // Device-VendorID in the PCI config header.
    //
    if (pApertureRequirements != NULL) {
        switch (AgpContext->DeviceVendorID) {
            case AGP_CNB20_LE_IDENTIFIER:
                *pApertureRequirements = AgpCPQGetApSizeRequirements(
                    AP_MAX_SIZE_CNB20_LE, AP_SIZE_COUNT_CNB20_LE);
                break;
            case AGP_CNB20_HE_IDENTIFIER:
                *pApertureRequirements = AgpCPQGetApSizeRequirements(
                    AP_MAX_SIZE_CNB20_HE, AP_SIZE_COUNT_CNB20_HE);
                break;
            case AGP_DRACO_IDENTIFIER:
                *pApertureRequirements = AgpCPQGetApSizeRequirements(
                    AP_MAX_SIZE_DRACO, AP_SIZE_COUNT_DRACO);
                break;
            default:
                *pApertureRequirements = NULL;
                break;
        }
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpSetAperture(
    IN PAGPCPQ_EXTENSION AgpContext,
    IN PHYSICAL_ADDRESS NewBase,
    IN ULONG NewSizeInPages
    )
/*******************************************************************************
*                                                                          
* Routine Functional Description:                                            
*                                                                            
*   Sets the AGP aperture to the requested settings.
*               
* Arguments:
*   
*   AgpContext -- Supplies the AGP Context, i.e. the AGP Extension. 
*
*   NewBase -- Supplies the new physical memroy base for the AGP aperture.
*
*   NewSizeInPages -- Supplies the new size for the AGP aperture.
*
* Return Value:
*
*   NTSTATUS
*                                                                       
*******************************************************************************/

{
    NTSTATUS        Status = STATUS_SUCCESS; // Assume successful completion.
    UCHAR           SetApSize;
    ULONG           ApBase;
    AGP_AP_SIZE_REG AgpApSizeRegister;
    BOOLEAN         ChangingBase = TRUE;
    BOOLEAN         ChangingSize = TRUE;

    AGPLOG(AGP_NOISE, ("AgpCpq: AgpSetAperture entered.\n"));

    //
    // If we are resuming from s3, or s4, we need to reprogram
    // the gart cache enable and base
    //
    if (AgpContext->Gart) {

        if (AgpContext->IsHPSA) DnbSetShadowBit(0);
        
        AgpContext->MMIO->GartBase.Page =
            (AgpContext->GartPointer >> PAGE_SHIFT);
        AgpContext->MMIO->FeatureControl.GARTCacheEnable = 1;
        
        //
        // If the chipset supports linking then enable linking.
        //
        if (AgpContext->MMIO->Capabilities.LinkingSupported==1) {
            AgpContext->MMIO->FeatureControl.LinkingEnable=1;
        }

        if (AgpContext->IsHPSA) DnbSetShadowBit(1);
    }

    //
    // Reprogram Special Target settings when the chip
    // is powered off, but ignore rate changes as those were already
    // applied during MasterInit
    //
    if (AgpContext->SpecialTarget & ~AGP_FLAG_SPECIAL_RESERVE) {
        AgpSpecialTarget(AgpContext,
                         AgpContext->SpecialTarget &
                         ~AGP_FLAG_SPECIAL_RESERVE);
    }

    //
    // Determine which parameter(s) we are being asked to change.
    //
    if  (NewBase.QuadPart == AgpContext->ApertureStart.QuadPart) 
        {
        ChangingBase = FALSE;
        }

    if (NewSizeInPages == AgpContext->ApertureLength / PAGE_SIZE) 
        {
        ChangingSize = FALSE;
        }

    //
    // If the new settings match the current settings, leave everything alone.
    //
    if ( !ChangingBase && !ChangingSize )
        {
        return(STATUS_SUCCESS);
        }
    
    //
    // Make sure the supplied Base is aligned on the appropriate boundary for the size.
    //
    ASSERT(NewBase.HighPart == 0);
    ASSERT((NewBase.LowPart + (NewSizeInPages * PAGE_SIZE) - 1) <= ALL_ONES);
    ASSERT((NewBase.QuadPart & ((NewSizeInPages * PAGE_SIZE) - 1)) == 0);

    if ((NewBase.QuadPart & ((NewSizeInPages * PAGE_SIZE) - 1)) != 0 ) 
        {
        AGPLOG(AGP_CRITICAL,
            ("AgpSetAperture - invalid base: %I64X for aperture of %lx pages\n",
            NewBase.QuadPart,
            NewSizeInPages));
        return(STATUS_INVALID_PARAMETER);
        }

    //
    // Change the size first, since doing so will modify the Read/Write attributes 
    // of the appropriate bits in the Aperture Base register.
    //
    if (ChangingSize) {

        // 
        // Draco only supports the default 256MB h/w Aperture Size, and can't change it, so fail.
        //
        if (AgpContext->DeviceVendorID == AGP_DRACO_IDENTIFIER) 
            {
            ASSERT(NewSizeInPages != (256 * 1024*1024));
            AGPLOG(AGP_CRITICAL,
                ("AgpSetAperture - Chipset incapable of changing Aperture Size.\n"));
            return(STATUS_INVALID_PARAMETER);
            }

        // 
        // RCC HE and LE chipset both support from 32M to 2G h/w Aperture Size.
        // 
        ASSERT( (AgpContext->DeviceVendorID == AGP_CNB20_LE_IDENTIFIER) ||
                (AgpContext->DeviceVendorID == AGP_CNB20_HE_IDENTIFIER) );

        //
        // Determine the value to use to set the aperture size in the chipset's
        // Device Address Space Size register.
        //
        switch(NewSizeInPages) {
            case (32 * 1024*1024) / PAGE_SIZE:
                SetApSize = SET_AP_SIZE_32MB;
                break;
            case (64 * 1024*1024) / PAGE_SIZE:
                SetApSize = SET_AP_SIZE_64MB;
                break;
            case (128 * 1024*1024) / PAGE_SIZE:
                SetApSize = SET_AP_SIZE_128MB;
                break;
            case (256 * 1024*1024) / PAGE_SIZE:
                SetApSize = SET_AP_SIZE_256MB;
                break;
            case (512 * 1024*1024) / PAGE_SIZE:
                SetApSize = SET_AP_SIZE_512MB;
                break;
            case (1024 * 1024*1024) / PAGE_SIZE:
                SetApSize = SET_AP_SIZE_1GB;
                break;
            case (BYTES_2G) / PAGE_SIZE:
                SetApSize = SET_AP_SIZE_2GB;
                break;
           default:
                AGPLOG(AGP_CRITICAL,
                    ("AgpSetAperture - Invalid size: %lx pages.  Base: %I64X.\n",
                    NewSizeInPages,
                    NewBase.QuadPart));
                ASSERT(FALSE);
                return(STATUS_INVALID_PARAMETER);
        }

        //
        // Set the aperture size and set AgpValid bit.  This must be done before setting the Aperture Base.
        //
        Status = AgpCPQSetApSizeInChipset(SetApSize, 1);

        if (!NT_SUCCESS(Status)) 
            {
            return(Status);
            }

    } // End if ChangingSize

    if (ChangingBase) {
        
        //
        // Set the aperture base.
        //
        Status = AgpCPQSetApBaseInChipset(NewBase);

        if (!NT_SUCCESS(Status)) 
            {
            return(Status);
            }

    } // End if ChangingBase

    //
    // Update our extension to reflect the new GART setting
    //
    AgpContext->ApertureStart   = NewBase;
    AgpContext->ApertureLength  = NewSizeInPages * PAGE_SIZE;

    return(STATUS_SUCCESS);
}


VOID
AgpDisableAperture(
    IN PAGPCPQ_EXTENSION AgpContext
    )
/*++

Routine Description:

    Disables the GART aperture so that this resource is available
    for other devices

Arguments:

    AgpContext - Supplies the AGP context

Return Value:

    None - this routine must always succeed.

--*/

{
    AGPLOG(AGP_NOISE, ("AgpCpq: AgpDisableAperture entered.\n"));

    //
    // Set the ApSize and AgpValid to 0, which causes BAR0 to be set back 
    // to zero and to be read only.
    //
    AgpCPQSetApSizeInChipset(0, 0);

    //
    // Nuke the Gart!  (It's meaningless now...)
    //
    if (AgpContext->Gart != NULL) {
        MmFreeContiguousMemory(AgpContext->Gart);
        AgpContext->Gart = NULL;
        AgpContext->GartLength = 0;
    }
}

NTSTATUS
AgpReserveMemory(
    IN PAGPCPQ_EXTENSION AgpContext,
    IN OUT AGP_RANGE *Range
    )
/*******************************************************************************
*                                                                          
* Routine Functional Description:                                            
*                                                                            
*   Reserves a range of memory in the GART.
*               
* Arguments:
*   
*   AgpContext -- Supplies the AGP Context, i.e. the AGP Extension. 
*
*   Range -- Supplies the AGP_RANGE structure.  AGPLIB will have filled in 
*       NumberOfPages and Type.  This routine will fill in MemoryBase
*       and Context.
*
* Return Value:
*
*   NTSTATUS
*                                                                       
*******************************************************************************/

{
    ULONG       Index;
    ULONG       NewState;
    NTSTATUS    Status;
    PGART_PTE   FoundRange;
    BOOLEAN     Backwards;

    ASSERT((Range->Type == MmNonCached) || (Range->Type == MmWriteCombined));
    ASSERT(Range->NumberOfPages <= (AgpContext->ApertureLength / PAGE_SIZE));

    AGPLOG(AGP_NOISE, ("AgpCpq: AgpReserveMemory entered.\n"));

    //
    // If we have not allocated our GART yet, now is the time to do so
    //
    if (AgpContext->Gart == NULL) {
        ASSERT(AgpContext->GartLength == 0);
        Status = AgpCPQCreateGart(AgpContext, Range->NumberOfPages);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                ("AgpCPQCreateGart failed %08lx to create GART of size %lx\n",
                Status,
                AgpContext->ApertureLength/PAGE_SIZE));
            return(Status);
        }
    }
    ASSERT(AgpContext->GartLength != 0);

    //
    // Now that we have a GART, try and find enough contiguous entries 
    // to satisfy the request. Requests for uncached memory will scan 
    // from high addresses to low addresses. Requests for write-combined 
    // memory will scan from low addresses to high addresses. We will 
    // use a first-fit algorithm to try and keep the allocations
    // packed and contiguous.
    //
    Backwards = (Range->Type == MmNonCached) ? TRUE : FALSE;
    FoundRange = AgpCPQFindRangeInGart(&AgpContext->Gart[0],
        &AgpContext->Gart[(AgpContext->GartLength / sizeof(GART_PTE)) - 1],
        Range->NumberOfPages, Backwards, GART_ENTRY_FREE);

    if (FoundRange == NULL) {
        //
        // A big enough chunk was not found.
        //
        AGPLOG(AGP_CRITICAL,
            ("AgpReserveMemory - Could not find %d contiguous free pages of type %d in GART at %08lx\n",
            Range->NumberOfPages,
            Range->Type,
            AgpContext->Gart));

        //
        //  This is where we could try and grow the GART
        //

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    AGPLOG(AGP_NOISE,
           ("AgpReserveMemory - reserved %d pages at GART PTE %08lx\n",
            Range->NumberOfPages,
            FoundRange));

    //
    // Set these pages to reserved
    //
    if (Range->Type == MmNonCached) {
        NewState = GART_ENTRY_RESERVED_UC;
    } else {
        NewState = GART_ENTRY_RESERVED_WC;
    }

    for (Index = 0; Index < Range->NumberOfPages; Index++) {
        ASSERT(FoundRange[Index].Soft.State == GART_ENTRY_FREE);
        FoundRange[Index].AsUlong = 0;
        FoundRange[Index].Soft.State = NewState;
    }

    //
    // Return the values.
    //
    Range->MemoryBase.QuadPart = AgpContext->ApertureStart.QuadPart + 
        (FoundRange - &AgpContext->Gart[0]) * PAGE_SIZE;
    Range->Context = FoundRange;

    ASSERT(Range->MemoryBase.HighPart == 0);
    AGPLOG(AGP_NOISE,
        ("AgpReserveMemory - reserved memory handle %lx at PA %08lx\n",
        FoundRange,
        Range->MemoryBase.LowPart));

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpReleaseMemory(
    IN PAGPCPQ_EXTENSION AgpContext,
    IN PAGP_RANGE Range
    )
/*******************************************************************************
*                                                                          
* Routine Functional Description:                                            
*                                                                            
*   Releases memory previously reserved with AgpReserveMemory.
*               
* Arguments:
*   
*   AgpContext -- Supplies the AGP Context, i.e. the AGP Extension. 
*
*   Range -- Supplies the range to be released.
*
* Return Value:
*
*   NTSTATUS
*                                                                       
*******************************************************************************/

{
    PGART_PTE Pte, LastPteWritten;
    ULONG Start, ReadBack, PolledValue, Retry;

    AGPLOG(AGP_NOISE, ("AgpCpq: AgpReleaseMemory entered.\n"));

    //
    // Go through and free all the PTEs. None of these should still
    // be valid at this point, nor should they be mapped.
    //
    for (Pte = Range->Context; 
        Pte < (PGART_PTE)Range->Context + Range->NumberOfPages;
        Pte++) 
        {
        ASSERT(Pte->Hard.Page == 0);
        if (Range->Type == MmNonCached) {
            ASSERT(Pte->Soft.State == GART_ENTRY_RESERVED_UC);
        } else {
            ASSERT(Pte->Soft.State == GART_ENTRY_RESERVED_WC);
        }

        Pte->Soft.State = GART_ENTRY_FREE;
        LastPteWritten = Pte;
        }

    //
    // Invalidate the GART Cache appropriately.
    // 
    AgpCPQMaintainGARTCacheCoherency(AgpContext, 
                                     Range->MemoryBase,
                                     Range->NumberOfPages, 
                                     FALSE );

    //
    // Flush the posted write buffers
    //
    if (AgpContext->IsHPSA) DnbSetShadowBit(0);
    AgpContext->MMIO->PostedWriteBufferControl.Flush = 1;
    if (AgpContext->IsHPSA) DnbSetShadowBit(1);

    ReadBack = *(volatile ULONG *)&LastPteWritten->AsUlong;

    for (Retry = 1000; Retry; Retry--) {
        PolledValue =
            AgpContext->MMIO->PostedWriteBufferControl.Flush;
        if (PolledValue == 0) {
            break;
        }
    }
    ASSERT(PolledValue == 0); // This bit should get reset by the chipset.

    Range->MemoryBase.QuadPart = 0;
    return(STATUS_SUCCESS);
}


NTSTATUS
AgpMapMemory(
    IN PAGPCPQ_EXTENSION AgpContext,
    IN PAGP_RANGE Range,
    IN PMDL Mdl,
    IN ULONG OffsetInPages,
    OUT PHYSICAL_ADDRESS *MemoryBase
    )
/*******************************************************************************
*                                                                          
* Routine Functional Description:                                            
*                                                                            
*   Maps physical memory into the AGP aperture, somewhere in the specified
*   range.
*               
* Arguments:
*   
*   AgpContext -- Supplies the AGP Context, i.e. the AGP Extension. 
*
*   Range -- Supplies the AGP range into which the memory should be mapped.
*
*   Mdl -- Supplies the MDL describing the physical pages to be mapped.
*
*   OffsetInPages - Supplies the offset into the reserved range where the 
*       mapping should begin.
*
*   MemoryBase -- Returns the 'physical' address in the aperture where the
*       pages were mapped.
*
* Return Value:
*
*   NTSTATUS
*                                                                       
*******************************************************************************/

{
    ULONG       PageCount;
    PGART_PTE   Pte;
    PGART_PTE   StartPte;
    ULONG       Index;
    ULONG       TargetState;
    PULONG      Page;
    BOOLEAN     Backwards;
    GART_PTE    NewPte;
    ULONG       PolledValue, Retry;

    AGPLOG(AGP_NOISE, ("AgpCpq: AgpMapMemory entered.\n"));

    ASSERT(Mdl->Next == NULL);

    StartPte = Range->Context;
    PageCount = BYTES_TO_PAGES(Mdl->ByteCount);
    ASSERT(PageCount <= Range->NumberOfPages);
    ASSERT(OffsetInPages <= Range->NumberOfPages);
    ASSERT(PageCount + OffsetInPages <= Range->NumberOfPages);
    ASSERT(PageCount > 0);

    TargetState = (Range->Type == MmNonCached) ? GART_ENTRY_RESERVED_UC : 
                                                 GART_ENTRY_RESERVED_WC;

    Pte = StartPte + OffsetInPages;

    //
    // We have found a suitable spot to map the pages.  Now map them. 
    //
    ASSERT(Pte >= StartPte);
    ASSERT(Pte + PageCount <= StartPte + Range->NumberOfPages);
    NewPte.AsUlong = 0;
    NewPte.Soft.State = (Range->Type == MmNonCached) ? GART_ENTRY_VALID_UC :
                                                       GART_ENTRY_VALID_WC;
    Page = (PULONG)(Mdl + 1);

    for (Index = 0; Index < PageCount; Index++) 
        {
        ASSERT(Pte[Index].Soft.State == TargetState);
        NewPte.Hard.Page = *Page++;
        Pte[Index].AsUlong = NewPte.AsUlong;
        ASSERT(Pte[Index].Hard.Valid == 1);
        ASSERT(Pte[Index].Hard.Linked == 0);
        }

    // 
    // If Linking is supported, then link the entries by setting the link bit
    // in all entries, except the last entry, in the mapped set.
    //
    if (AgpContext->MMIO->Capabilities.LinkingSupported) {
        ASSERT(AgpContext->MMIO->FeatureControl.LinkingEnable);
        for (Index = 0; Index < PageCount-1; Index++) {
            ASSERT(Pte[Index].Hard.Page != 0);
            Pte[Index].Hard.Linked = 1;
        }
    }

    //
    // We have filled in all the PTEs. Now flush the write buffers.
    //
    if (AgpContext->IsHPSA) DnbSetShadowBit(0);
    AgpContext->MMIO->PostedWriteBufferControl.Flush = 1;
    if (AgpContext->IsHPSA) DnbSetShadowBit(1);
    NewPte.AsUlong = *(volatile ULONG *)&Pte[PageCount-1].AsUlong;

    for (Retry = 1000; Retry; Retry--) {
        PolledValue =
            AgpContext->MMIO->PostedWriteBufferControl.Flush;
        if (PolledValue == 0) {
            break;
        }
    }
    ASSERT(PolledValue == 0); // This bit should get reset by the chipset.

    //
    // Return where they are mapped
    //
    MemoryBase->QuadPart = Range->MemoryBase.QuadPart + (Pte - StartPte) * PAGE_SIZE;

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpUnMapMemory(
    IN PAGPCPQ_EXTENSION AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages
    )
/*******************************************************************************
*                                                                          
* Routine Functional Description:                                            
*                                                                            
*   UnMaps all or part of the memory that was previously mapped by AgpMapMemory.
*               
* Arguments:
*   
*   AgpContext -- Supplies the AGP Context, i.e. the AGP Extension. 
*
*   AgpRange -- Supplies the AGP range out of which memory should be un-mapped.
*
*   NumberOfPages -- Supplies the number of pages in the range to be un-mapped.
*
*   OffsetInPages -- Supplies the offset into the Reserved Range where the un-mapping
*       should begin.
*
* Return Value:
*
*   NTSTATUS
*                                                                       
*******************************************************************************/

{
    ULONG       Index, TargetState, ReadBack, PolledValue, Retry;
    PGART_PTE   ReservedBasePte;
    PGART_PTE   Pte;
    PGART_PTE   LastChangedPte=NULL;
    PHYSICAL_ADDRESS pa;

    AGPLOG(AGP_NOISE, ("AgpCpq: AgpUnMapMemory entered.\n"));

    ASSERT(OffsetInPages + NumberOfPages <= AgpRange->NumberOfPages);

    ReservedBasePte = AgpRange->Context;
    Pte = &ReservedBasePte[OffsetInPages];

    TargetState = (AgpRange->Type == MmNonCached) ? GART_ENTRY_RESERVED_UC : GART_ENTRY_RESERVED_WC;
                                                 
    //
    // UnMap each entry by putting each Mapped Entry back into the 'Reserved State'
    //
    for (Index=0; Index < NumberOfPages; Index++) {

        if (Pte[Index].Hard.Valid) {
            ASSERT(Pte[Index].Hard.Page != 0);

            Pte[Index].Hard.Page = 0;
            Pte[Index].Soft.State = TargetState;
            LastChangedPte = &Pte[Index];

        } else {
            //
            // We are being asked to un-map a page that is not mapped.
            //
            ASSERT(Pte[Index].Hard.Page == 0);
            ASSERT(Pte[Index].Soft.State == TargetState);
            AGPLOG(AGP_NOISE,
                   ("AgpUnMapMemory - PTE %08lx (%08lx) at offset %d not mapped\n",
                    &Pte[Index],
                    Pte[Index].AsUlong,
                    Index));
        }
    }

    // 
    // Maintain link bit coherency within this reserved range.
    //
    if (OffsetInPages != 0) {
        ASSERT(OffsetInPages >= 1);
        if (ReservedBasePte[OffsetInPages-1].Hard.Linked == 1) {
            ASSERT(ReservedBasePte[OffsetInPages-1].Hard.Valid == 1);
            ReservedBasePte[OffsetInPages-1].Hard.Linked = 0;
        }
    }

    //
    // Invalidate the Cache appropriately.
    // 
    pa.HighPart = 0;
    pa.LowPart = AgpRange->MemoryBase.LowPart + OffsetInPages*PAGE_SIZE;
    AgpCPQMaintainGARTCacheCoherency(AgpContext, pa, NumberOfPages, FALSE);

    //
    // Flush the posted write buffers
    //
    if (LastChangedPte != NULL) 
        {
        if (AgpContext->IsHPSA) DnbSetShadowBit(0);
        AgpContext->MMIO->PostedWriteBufferControl.Flush = 1;
        if (AgpContext->IsHPSA) DnbSetShadowBit(1);
        
        ReadBack = *((volatile ULONG *)&(LastChangedPte[0].AsUlong));
        
        for (Retry = 2000; Retry; Retry--) {
            PolledValue =
                AgpContext->MMIO->PostedWriteBufferControl.Flush;
            if (PolledValue == 0) {
                break;
            }
        }
        ASSERT(PolledValue == 0); // This bit should get reset by the chipset.
        }

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpCPQCreateGart(
    IN PAGPCPQ_EXTENSION AgpContext,
    IN ULONG MinimumPages
    )
/*******************************************************************************
*                                                                          
* Routine Functional Description:                                            
*                                                                            
*   Allocates and initializes an empty GART. The current implementation
*   attempts to allocate the entire GART on the first reserve.
*               
* Arguments:
*   
*   AgpContext -- Supplies the AGP Context, i.e. the AGP Extension. 
*
*   MinimumPages -- Supplies the minimum size (in pages) of the GART to be
*       created.
*
* Return Value:
*
*   NTSTATUS
*                                                                       
*******************************************************************************/

{
    PGART_PTE Gart;
    ULONG* Dir;
    PHYSICAL_ADDRESS LowestAcceptable;
    PHYSICAL_ADDRESS BoundaryMultiple;
    PHYSICAL_ADDRESS HighestAcceptable;
    PHYSICAL_ADDRESS GartPhysical, DirPhysical, GartPointer, GartPagePhysical;
    ULONG Index;
    ULONG GartLength = BYTES_TO_PAGES(AgpContext->ApertureLength) * sizeof(GART_PTE);;

    AGPLOG(AGP_NOISE, ("AgpCpq: AgpCPQCreateGart entered.\n"));

    // 
    // If the chipset requires two-level address translation, then allocate a not-necessarily-
    // contiguous GART, and create a Directory.  Otherwise, allocate a contiguous GART.
    //

    if (AgpContext->MMIO->Capabilities.TwoLevelAddrTransSupported == 1){

        // 
        // The chipset uses 2-level GART address translation.
        // Allocate the (not-necessarily-contiguous) GART.
        //

        Gart = AgpLibAllocateMappedPhysicalMemory(AgpContext, GartLength);

        if (Gart == NULL) 
            {
            AGPLOG(AGP_CRITICAL,
                ("AgpCPQCreateGart - MmAllocateNonCachedMemory, for %lx bytes, failed\n",
                PAGE_SIZE));
            return(STATUS_INSUFFICIENT_RESOURCES);
            }
        ASSERT(((ULONG_PTR)Gart & (PAGE_SIZE-1)) == 0);

        // 
        // Now allocate a GART Directory.  The directory needs to be
        // below the 4GB boundary.
        //

        HighestAcceptable.QuadPart = 0xffffffff;
        LowestAcceptable.QuadPart = 0;
        BoundaryMultiple.QuadPart = 0;

        Dir = MmAllocateContiguousMemorySpecifyCache(PAGE_SIZE,
                                                     LowestAcceptable,
                                                     HighestAcceptable,
                                                     BoundaryMultiple,
                                                     MmNonCached);
        if (Dir == NULL) 
            {
            AGPLOG(AGP_CRITICAL,
                ("AgpCPQCreateGart - MmAllocateContiguousMemory %lx failed\n",
                PAGE_SIZE));
            return(STATUS_INSUFFICIENT_RESOURCES);
            }
        ASSERT(((ULONG_PTR)Dir & (PAGE_SIZE-1)) == 0);
        DirPhysical = MmGetPhysicalAddress(Dir);

        //
        // Walk the Directory, and assign to each Directory entry the value
        // of the physical address of the corresponding GART page.
        //
        ASSERT(GartLength/PAGE_SIZE <= PAGE_SIZE/sizeof(ULONG));
        for (Index=0; Index<(GartLength/PAGE_SIZE); Index++) 
            {
            ULONG HighPart;
            ULONG Temp;

            GartPagePhysical = MmGetPhysicalAddress( &(Gart[Index*PAGE_SIZE/sizeof(GART_PTE)]));

            //
            // Format of a directory entry is
            // 31      12   11     10     9     8     7    2  1   0   <- bits
            // ------------------------------------------------------
            // | [31:12] | [32] | [33] | [34] | [35] |      | L | V | <- Data
            // ------------------------------------------------------
            //
            // Where:-
            // 31-12 are bits 31 thru 12 of the physical address, ie
            //       the page number if the page is below 4GB.
            // 32, 33, 34 and 35 are the respective bits of the physical
            //       address if the address is above 4GB.
            // L     Link.
            // V     Valid.
            //

            ASSERT((GartPagePhysical.HighPart & ~0xf) == 0);

            HighPart = GartPagePhysical.HighPart & 0xf;
            Temp      = (HighPart & 1) << 11;// bit 32 -> bit 11
            Temp     |= (HighPart & 2) << 9 ;// bit 33 -> bit 10
            Temp     |= (HighPart & 4) << 7 ;// bit 34 -> bit  9
            Temp     |= (HighPart & 8) << 5 ;// bit 35 -> bit  8
            Dir[Index] = GartPagePhysical.LowPart | Temp;

            }

    } else { 

        // 
        // The chipset uses single level address translation.
        // Allocate the contiguous GART.
        // 

        //
        // Try and get a chunk of contiguous memory big enough to map the
        // entire aperture. 
        //
        HighestAcceptable.QuadPart = 0xFFFFFFFF;
        LowestAcceptable.QuadPart = 0;
        BoundaryMultiple.QuadPart = 0;

        Gart = MmAllocateContiguousMemorySpecifyCache(GartLength,
                                                      LowestAcceptable,
                                                      HighestAcceptable,
                                                      BoundaryMultiple,
                                                      MmNonCached);
        if (Gart == NULL) 
            {
            AGPLOG(AGP_CRITICAL,
                ("AgpCPQCreateGart - MmAllocateContiguousMemory %lx failed\n",
                GartLength));
            return(STATUS_INSUFFICIENT_RESOURCES);
            }

        //
        // We successfully allocated a contiguous chunk of memory.
        // It should be page aligned already.
        //
        ASSERT(((ULONG_PTR)Gart & (PAGE_SIZE-1)) == 0);

        //
        // Get the physical address.
        //
        GartPhysical = MmGetPhysicalAddress(Gart);
        AGPLOG(AGP_NOISE,
            ("AgpCPQCreateGart - GART of length %lx created at VA %08lx, PA %08lx\n",
            GartLength,
            Gart,
            GartPhysical.LowPart));
        ASSERT(GartPhysical.HighPart == 0);
        ASSERT((GartPhysical.LowPart & (PAGE_SIZE-1)) == 0);

    }

    //
    // Initialize all the GART PTEs to free
    //
    for (Index=0; Index<GartLength/sizeof(GART_PTE); Index++) 
        {
        Gart[Index].Soft.State = GART_ENTRY_FREE;
        }

    //
    // Update our extension to reflect the current state.
    //
    AgpContext->Gart = Gart;
    AgpContext->GartLength = GartLength;
    if (AgpContext->MMIO->Capabilities.TwoLevelAddrTransSupported == 1) {
        AgpContext->Dir = Dir;
        GartPointer=DirPhysical;
    } else {
        AgpContext->Dir = NULL;
        GartPointer=GartPhysical;
    }

    //
    // Stash GartPointer for resuming from s3 or s4
    //
    AgpContext->GartPointer = GartPointer.LowPart;

    //
    // Tell the chipset where the GART base is.
    //
    if (AgpContext->IsHPSA) DnbSetShadowBit(0);
    AgpContext->MMIO->GartBase.Page = (GartPointer.LowPart >> PAGE_SHIFT);
    if (AgpContext->IsHPSA) DnbSetShadowBit(1);

    return(STATUS_SUCCESS);
}


PGART_PTE
AgpCPQFindRangeInGart(
    IN PGART_PTE StartPte,
    IN PGART_PTE EndPte,
    IN ULONG Length,
    IN BOOLEAN SearchBackward,
    IN ULONG SearchState
    )
/*++

Routine Description:

    Finds a contiguous range in the GART. This routine can
    search either from the beginning of the GART forwards or
    the end of the GART backwards.

Arguments:

    StartIndex - Supplies the first GART pte to search

    EndPte - Supplies the last GART to search (inclusive)

    Length - Supplies the number of contiguous free entries
        to search for.

    SearchBackward - TRUE indicates that the search should begin
        at EndPte and search backwards. FALSE indicates that the
        search should begin at StartPte and search forwards

    SearchState - Supplies the PTE state to look for.

Return Value:

    Pointer to the first PTE in the GART if a suitable range
    is found.

    NULL if no suitable range exists.

--*/

{
    PGART_PTE Current;
    PGART_PTE Last;
    LONG Delta;
    ULONG Found;
    PGART_PTE Candidate;

    AGPLOG(AGP_NOISE, ("AgpCpq: AgpCPQFindRangeInGart entered.\n"));

    ASSERT(EndPte >= StartPte);
    ASSERT(Length <= (ULONG)(EndPte - StartPte + 1));
    ASSERT(Length != 0);

    if (SearchBackward) {
        Current = EndPte;
        Last = StartPte-1;
        Delta = -1;
    } else {
        Current = StartPte;
        Last = EndPte+1;
        Delta = 1;
    }

    Found = 0;
    while (Current != Last) {
        if (Current->Soft.State == SearchState) {
            if (++Found == Length) {
                //
                // A suitable range was found, return it
                //
                if (SearchBackward) {
                    return(Current);
                } else {
                    return(Current - Length + 1);
                }
            }
        } else {
            Found = 0;
        }
        Current += Delta;
    }

    //
    // A suitable range was not found.
    //
    return(NULL);
}


VOID
AgpCPQMaintainGARTCacheCoherency(
    IN PAGPCPQ_EXTENSION AgpContext,
    IN PHYSICAL_ADDRESS MemoryBase,
    IN ULONG NumberOfEntries,
    IN BOOLEAN InvalidateAll
    )
/*******************************************************************************
*                                                                          
* Routine Functional Description:                                            
*                                                                            
*   Invalidates the entire GART [&DIR] Cache, or  individual Entries in the GART
*   cache, depending on which would provide better overall performance.
*               
* Arguments:
*   
*   AgpContext -- Supplies the AGP Context, i.e. the AGP Extension. 
*
*   MemoryBase -- Supplies the 'physical' address, in the AGP aperture,
*       corresponding to the first GART Entry to flush
*       from the GART Entry Cache. 
*
*   NumberOfEntries -- Supplies the number of Cached Entries which need to be 
*       invalidated.
*
*   InvalidateAll -- Supplies a flag that, if TRUE, indicates that this routine
*       should invalidate the entire GART [&DIR] cache, rather than the individual
*       Cached Entries.  If FALSE, then this routine decides how best to do it.
*
* Return Value:
*
*   None
*                                                                       
*******************************************************************************/

{
    ULONG PolledValue, AperturePage, Index, Retry;
    GART_CACHE_ENTRY_CONTROL CacheEntryControlValue;

    AGPLOG(AGP_NOISE, ("AgpCpq: AgpCPQMaintainGARTCacheCoherency entered.\n"));

    if (InvalidateAll || (NumberOfEntries > MAX_CACHED_ENTRIES_TO_INVALIDATE)) {
        // 
        // Invalidate the entire GART [&DIR] Cache
        //
        if (AgpContext->IsHPSA) DnbSetShadowBit(0);
        AgpContext->MMIO->CacheControl.GartAndDirCacheInvalidate = 1;
        if (AgpContext->IsHPSA) DnbSetShadowBit(1);
        for (Retry = 2000; Retry; Retry--) {
            PolledValue =
                    AgpContext->MMIO->CacheControl.GartAndDirCacheInvalidate;
            if (PolledValue == 0) {
                break;
            }
        }
        ASSERT(PolledValue == 0); // This bit should get reset by the chipset.
    } else {
        //
        // Invalidate the individual cached GART enties
        //
        AperturePage = MemoryBase.LowPart >> PAGE_SHIFT;
        for (Index=0; Index<NumberOfEntries; Index++, AperturePage++) {
            CacheEntryControlValue.AsBits.GartEntryInvalidate = 1;
            CacheEntryControlValue.AsBits.GartEntryOffset = AperturePage;
            if (AgpContext->IsHPSA) DnbSetShadowBit(0);
            AgpContext->MMIO->CacheEntryControl.AsDword = 
                CacheEntryControlValue.AsDword;
            if (AgpContext->IsHPSA) DnbSetShadowBit(1);
            for (Retry = 1000; Retry; Retry--) {
                PolledValue = 
                AgpContext->MMIO->CacheEntryControl.AsBits.GartEntryInvalidate;
                if (PolledValue == 0) {
                    break;
                }
            }
            ASSERT(PolledValue == 0);
        }
    }

    return;
}


PIO_RESOURCE_LIST 
AgpCPQGetApSizeRequirements(
    ULONG   MaxSize,
    ULONG   Count
    )
/*******************************************************************************
*                                                                          
* Routine Functional Description:                                            
*                                                                            
*   Creates and fills in an IO_RESOURCE_LIST structure, which describes
*   the possible aperture sizes supported by the chipset.
*               
* Arguments:
*   
*   MaxSize -- The Maximum possible size, in Bytes, for the aperture
*
*   Count -- The number of different aperture sizes.  This routine assumes
*       that the aperture size is a multiple of two
*       times the smallest aperture size.  For example, 256MB, 128MB, 64MB
*       32MB.  MaxSize would be 256M, and count would be 4.
*
* Return Value:
*
*   Pointer to the newly created IO_RESOURCE_LIST.
*                                                                       
*******************************************************************************/

{
    PVOID RequirementsPointer;
    PIO_RESOURCE_LIST   Requirements;
    ULONG Length, Index;

    AGPLOG(AGP_NOISE, ("AgpCpq: AgpCPQGetApSizeRequirements entered.\n"));

    RequirementsPointer = ExAllocatePoolWithTag(PagedPool, sizeof(IO_RESOURCE_LIST) + 
        (Count-1)*sizeof(IO_RESOURCE_DESCRIPTOR), 'RpgA');

    if (RequirementsPointer == NULL) {
        AGPLOG(AGP_NOISE,
       ("AgpAgpCPQGetApSizeRequirements - Failed to Allocate memory for a Resource Descriptor.\n"));
        return(NULL);
    } else {
        Requirements = (PIO_RESOURCE_LIST)RequirementsPointer;
    }

    //
    // Compaq supports several different aperture sizes, all must be 
    // naturally aligned. Start with the largest aperture and 
    // work downwards so that we get the biggest possible aperture.
    //

    Requirements->Version = Requirements->Revision = 1;
    Requirements->Count = Count;
    Length = MaxSize;
    for (Index=0; Index < Count; Index++) 
        {
        Requirements->Descriptors[Index].Option = IO_RESOURCE_ALTERNATIVE;
        Requirements->Descriptors[Index].Type = CmResourceTypeMemory;
        Requirements->Descriptors[Index].ShareDisposition = CmResourceShareDeviceExclusive;
        Requirements->Descriptors[Index].Flags = CM_RESOURCE_MEMORY_READ_WRITE | CM_RESOURCE_MEMORY_PREFETCHABLE;

        Requirements->Descriptors[Index].u.Memory.Length = Length;
        Requirements->Descriptors[Index].u.Memory.Alignment = Length;
        Requirements->Descriptors[Index].u.Memory.MinimumAddress.QuadPart = 0;
        Requirements->Descriptors[Index].u.Memory.MaximumAddress.QuadPart = (ULONG)-1;

        Length = Length/2;
        }

    return(Requirements);
}


NTSTATUS
AgpCPQSetApSizeInChipset
    (
    IN UCHAR               NewSetApSize,
    IN UCHAR               NewSetAgpValid
    )
/*******************************************************************************
*                                                                          
* Routine Functional Description:                                            
*                                                                            
*   Modifes the Device Address Space (Aperture) Size register in the chipset's
*   PCI-PCI bridge.
*               
* Arguments:
*   
*   NewSetApSize -- The value to set in bits 3:1 of the DAS_SIZE register.
*   NewSetAgpValid -- Value to set in bit 0 of the DAS_SIZE register.   
*
* Return Value:
*
*   NT Status value.
*                                                                       
*******************************************************************************/

{
    NTSTATUS                    Status = STATUS_SUCCESS;
    UCHAR                       ApSizeRegisterOffset;
    BUS_SLOT_ID                 CpqP2PBusSlotID;
    AGP_AP_SIZE_REG             ApSizeRegister;

    AGPLOG(AGP_NOISE, ("AgpCpq: AgpCPQSetApSizeInChipset entered.\n"));

    ApSizeRegisterOffset    =   OFFSET_AP_SIZE;
    CpqP2PBusSlotID.BusId   =   AGP_CPQ_BUS_ID;
    CpqP2PBusSlotID.SlotId  =   AGP_CPQ_PCIPCI_SLOT_ID;

    ApSizeRegister.AsBits.ApSize = NewSetApSize;
    ApSizeRegister.AsBits.AgpValid = NewSetAgpValid;

    Status = ApGetSetBusData(&CpqP2PBusSlotID, FALSE, &ApSizeRegister.AsByte, 
        ApSizeRegisterOffset, sizeof(UCHAR));

    return(Status);
}


NTSTATUS
AgpCPQSetApBaseInChipset
    (
    IN  PHYSICAL_ADDRESS    NewBase
    )
{
    ULONG   ApBase;

    AGPLOG(AGP_NOISE, ("AgpCpq: AgpCPQSetApBaseInChipset entered.\n"));

    //
    // Write the value of the aperture base in BAR0.
    //
    ApBase = NewBase.LowPart & PCI_ADDRESS_MEMORY_ADDRESS_MASK;
    WriteCPQConfig(&ApBase, OFFSET_BAR0, sizeof(ApBase));

#if DBG
    //
    // Read back what we wrote, make sure it worked
    //
    {
        ULONG DbgBase;

        ReadCPQConfig(&DbgBase, OFFSET_BAR0, sizeof(ApBase));
        ASSERT((DbgBase & PCI_ADDRESS_MEMORY_ADDRESS_MASK) == ApBase);
    }
#endif

    return(STATUS_SUCCESS);
}



VOID
AgpFindFreeRun(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT ULONG *FreePages,
    OUT ULONG *FreeOffset
    )
/*++

Routine Description:

    Finds the first contiguous run of free pages in the specified
    part of the reserved range.

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the AGP range

    NumberOfPages - Supplies the size of the region to be searched for free pages

    OffsetInPages - Supplies the start of the region to be searched for free pages

    FreePages - Returns the length of the first contiguous run of free pages

    FreeOffset - Returns the start of the first contiguous run of free pages

Return Value:

    None. FreePages == 0 if there are no free pages in the specified range.

--*/

{
    PGART_PTE Pte;
    ULONG i;
    
    AGPLOG(AGP_NOISE, ("AgpCpq: AgpFindFreeRun entered.\n"));

    Pte = (PGART_PTE)(AgpRange->Context) + OffsetInPages;

    //
    // Find the first free PTE
    //
    for (i=0; i<NumberOfPages; i++) {
        if (Pte[i].Hard.Valid == 0) {
            //
            // Found a free PTE, count the contiguous ones.
            //
            *FreeOffset = i + OffsetInPages;
            *FreePages = 0;
            while ((i<NumberOfPages) && (Pte[i].Hard.Valid == 0)) {
                *FreePages += 1;
                ++i;
            }
            return;
        }
    }

    //
    // No free PTEs in the specified range
    //
    *FreePages = 0;
    return;
}


VOID
AgpGetMappedPages(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT PMDL Mdl
    )
/*++

Routine Description:

    Returns the list of physical pages mapped into the specified 
    range in the GART.

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the AGP range

    NumberOfPages - Supplies the number of pages to be returned

    OffsetInPages - Supplies the start of the region 

    Mdl - Returns the list of physical pages mapped in the specified range.

Return Value:

    None

--*/

{
    PGART_PTE Pte;
    ULONG i;
    PULONG Pages;
    
    AGPLOG(AGP_NOISE, ("AgpCpq: AgpGetMappedPages entered.\n"));

    ASSERT(NumberOfPages * PAGE_SIZE == Mdl->ByteCount);

    Pages = (PULONG)(Mdl + 1);
    Pte = (PGART_PTE)(AgpRange->Context) + OffsetInPages;

    for (i=0; i<NumberOfPages; i++) {
        ASSERT(Pte[i].Hard.Valid == 1);
        Pages[i] = Pte[i].Hard.Page;
    }
    return;
    

}


NTSTATUS
AgpSpecialTarget(
    IN PAGPCPQ_EXTENSION AgpContext,
    IN ULONGLONG DeviceFlags
    )
/*++

Routine Description:

    This routine makes "special" tweaks to the AGP chipset

Arguments:

    AgpContext - Supplies the AGP context

    DeviceFlags - Flags indicating what tweaks to perform

Return Value:

    STATUS_SUCCESS, or error

--*/
{
    NTSTATUS Status;

    //
    // Should we change the AGP rate?
    //
    if (DeviceFlags & AGP_FLAG_SPECIAL_RESERVE) {

        Status = AgpCPQSetRate(AgpContext,
                               (ULONG)((DeviceFlags & AGP_FLAG_SPECIAL_RESERVE)
                                       >> AGP_FLAG_SET_RATE_SHIFT));
        
        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    }

    //
    // Add more tweaks here...
    //

    AgpContext->SpecialTarget |=DeviceFlags;

    return STATUS_SUCCESS;
}


NTSTATUS
AgpCPQSetRate(
    IN PAGPCPQ_EXTENSION AgpContext,
    IN ULONG AgpRate
    )
/*++

Routine Description:

    This routine sets the AGP rate

Arguments:

    AgpContext - Supplies the AGP context

    AgpRate - Rate to set

    note: this routine assumes that AGP has already been enabled, and that
          whatever rate we've been asked to set is supported by master

Return Value:

    STATUS_SUCCESS, or error status

--*/
{
    NTSTATUS Status;
    ULONG TargetEnable;
    ULONG MasterEnable;
    PCI_AGP_CAPABILITY TargetCap;
    PCI_AGP_CAPABILITY MasterCap;
    BOOLEAN ReverseInit;

    //
    // Read capabilities
    //
    Status = AgpLibGetPciDeviceCapability(0, 0, &TargetCap);

    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING, ("AgpCpqSetRate: AgpLibGetPciDeviceCapability "
                             "failed %08lx\n", Status));
        return Status;
    }

    Status = AgpLibGetMasterCapability(AgpContext, &MasterCap);

    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING, ("AgpCpqSetRate: AgpLibGetMasterCapability "
                             "failed %08lx\n", Status));
        return Status;
    }

    //
    // Verify the requested rate is supported by both master and target
    //
    if (!(AgpRate & TargetCap.AGPStatus.Rate & MasterCap.AGPStatus.Rate)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Disable AGP while the pull the rug out from underneath
    //
    TargetEnable = TargetCap.AGPCommand.AGPEnable;
    TargetCap.AGPCommand.AGPEnable = 0;

    Status = AgpLibSetPciDeviceCapability(0, 0, &TargetCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("AgpCpqSetRate: AgpLibSetPciDeviceCapability %08lx for "
                "Target failed %08lx\n",
                &TargetCap,
                Status));
        return Status;
    }
    
    MasterEnable = MasterCap.AGPCommand.AGPEnable;
    MasterCap.AGPCommand.AGPEnable = 0;

    Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("AgpCpqSetRate: AgpLibSetMasterCapability %08lx failed "
                "%08lx\n",
                &MasterCap,
                Status));
        return Status;
    }

    //
    // Fire up AGP with new rate
    //
    ReverseInit =
        (AgpContext->SpecialTarget & AGP_FLAG_REVERSE_INITIALIZATION) ==
        AGP_FLAG_REVERSE_INITIALIZATION;
    if (ReverseInit) {
        MasterCap.AGPCommand.Rate = AgpRate;
        MasterCap.AGPCommand.AGPEnable = MasterEnable;
        
        Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
        
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_WARNING,
                   ("AgpCpqSetRate: AgpLibSetMasterCapability %08lx failed "
                    "%08lx\n",
                    &MasterCap,
                    Status));
        }
    }

    TargetCap.AGPCommand.Rate = AgpRate;
    TargetCap.AGPCommand.AGPEnable = TargetEnable;
        
    Status = AgpLibSetPciDeviceCapability(0, 0, &TargetCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("AgpCpqSetRate: AgpLibSetPciDeviceCapability %08lx for "
                "Target failed %08lx\n",
                &TargetCap,
                Status));
        return Status;
    }

    if (!ReverseInit) {
        MasterCap.AGPCommand.Rate = AgpRate;
        MasterCap.AGPCommand.AGPEnable = MasterEnable;
        
        Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
        
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_WARNING,
                   ("AgpCpqSetRate: AgpLibSetMasterCapability %08lx failed "
                    "%08lx\n",
                    &MasterCap,
                    Status));
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\agp\agpcpq\init.c ===
/*++

Copyright (c) 1996, 1997 Microsoft Corporation

Module Name:

    init.c

Abstract:

    This module contains the initialization code for the Compaq driver.

Author:

    John Vert (jvert) 10/21/1997

Revision History:

    12/15/97    John Theisen    Modified to support Compaq Chipsets
    10/09/98    John Theisen    Modified to workaround an RCC silicon bug.  
                                If RCC Silicon Rev <= 4, then limit DATA_RATE to 1X.
    10/09/98    John Theisen    Modified to enable Shadowing in the SP700 prior to MMIO writes.
    01/15/98    John Theisen    Modified to set RQ depth to be 0x0F for all REV_IDs
    03/14/00    Peter Johnston  Add support for HE chipset.

--*/

#include "AGPCPQ.H"

ULONG AgpExtensionSize = sizeof(AGPCPQ_EXTENSION);
PAGP_FLUSH_PAGES AgpFlushPages = NULL;  // not implemented


NTSTATUS
AgpInitializeTarget(
    IN PVOID AgpExtension
    )
/*******************************************************************************
*                                                                          
* Routine Functional Description:                                            
*                                                                            
*   This function is the entrypoint for initialization of the AGP Target.  It 
*   is called first, and performs initialization of the chipset and extension.
*               
* Assumptions:  Regardless of whether we are running on a dual north bridge platform, 
*               this driver will only be installed and invoked once (for the AGP bridge at B0D0F1).
*
* Arguments:
*   
*   AgpExtension -- Supplies the AGP Extension
*
* Return Value:
*
*   STATUS_SUCCESS if successfull
*                                                                       
*******************************************************************************/

{
    ULONG               DeviceVendorID  = 0;
    ULONG               BAR1            = 0;
    PAGPCPQ_EXTENSION   Extension       = AgpExtension;
    PHYSICAL_ADDRESS    pa;
    ULONG               BytesReturned   = 0;

    AGPLOG(AGP_NOISE, ("AgpCpq: AgpInitializeTarget entered.\n"));
    //
    // Initialize our Extension
    //
    RtlZeroMemory(Extension, sizeof(AGPCPQ_EXTENSION));

    //
    // Verify that the chipset is a supported RCC Chipset.
    //
    ReadCPQConfig(&DeviceVendorID,OFFSET_DEVICE_VENDOR_ID,sizeof(DeviceVendorID));

    if ((DeviceVendorID != AGP_CNB20_LE_IDENTIFIER)   &&
        (DeviceVendorID != AGP_CNB20_HE_IDENTIFIER)   &&
        (DeviceVendorID != AGP_CNB20_HE4X_IDENTIFIER) &&
        (DeviceVendorID != AGP_CMIC_GC_IDENTIFIER)) {
        AGPLOG(AGP_CRITICAL,
            ("AGPCPQ - AgpInitializeTarget was called for platform %08x, which is not a known RCC AGP chipset!\n",
            DeviceVendorID));
        return(STATUS_UNSUCCESSFUL);
    }

    Extension->DeviceVendorID = DeviceVendorID;

    //
    // Read the chipset's BAR1 Register, and then map the chipset's 
    // Memory Mapped Control Registers into kernel mode address space.
    //
    ReadCPQConfig(&BAR1,OFFSET_BAR1,sizeof(BAR1));
    pa.HighPart = 0;
    pa.LowPart = BAR1;
    Extension->MMIO = (PMM_CONTROL_REGS)MmMapIoSpace(pa, sizeof(MM_CONTROL_REGS), FALSE);

    if (Extension->MMIO == NULL)
        {
        AGPLOG(AGP_CRITICAL,
            ("AgpInitializeTarget - Couldn't allocate %08x bytes for MMIO\n",
            sizeof(MM_CONTROL_REGS)));
        return(STATUS_UNSUCCESSFUL);
        }

    // 
    // Verify that the chipset's Revision ID is correct, but only complain, if it isn't.
    //
    if (Extension->MMIO->RevisionID < LOWEST_REVISION_ID_SUPPORTED)
        {
        AGPLOG(AGP_CRITICAL,
            ("AgpInitializeTarget - Revision ID = %08x, it should = 1.\n",
            Extension->MMIO->RevisionID));
        }

    //
    // Determine if there are two RCC North Bridges in this system.
    //
    DeviceVendorID = 0;
    BytesReturned = HalGetBusDataByOffset(PCIConfiguration, SECONDARY_LE_BUS_ID, SECONDARY_LE_HOSTPCI_SLOT_ID, 
        &DeviceVendorID, OFFSET_DEVICE_VENDOR_ID, sizeof(DeviceVendorID));

    if((DeviceVendorID != Extension->DeviceVendorID) || (BytesReturned != sizeof(DeviceVendorID)) ) {
        Extension->IsHPSA = FALSE;        
    } else {
        Extension->IsHPSA = TRUE;
    }  

    //
    // Enable the GART cache
    //
    if (Extension->IsHPSA) DnbSetShadowBit(0);

    Extension->MMIO->FeatureControl.GARTCacheEnable = 1;

    Extension->GartPointer = 0;
    Extension->SpecialTarget = 0;
    
    //
    // If the chipset supports linking then enable linking.
    //
    if (Extension->MMIO->Capabilities.LinkingSupported==1) {
        Extension->MMIO->FeatureControl.LinkingEnable=1;
    }

    if (Extension->IsHPSA) DnbSetShadowBit(1);
    
    return(STATUS_SUCCESS);
}


NTSTATUS
AgpInitializeMaster(
    IN  PVOID AgpExtension,
    OUT ULONG *AgpCapabilities
    )
/*******************************************************************************
*                                                                          
* Routine Functional Description:                                            
*                                                                            
*   This function is the entrypoint for initialization of the AGP Master. It
*   is called after Target initialization, and is intended to be used to 
*   initialize the AGP capabilities of both master and target.
*
* Arguments:
*   
*   AgpExtension -- Supplies the AGP Extension
*   
*   AgpCapabilities -- Returns the "software-visible" capabilities of the device
*
* Return Value:
*
*   NTSTATUS       
*                                                                
*******************************************************************************/

{
    NTSTATUS Status;
    PCI_AGP_CAPABILITY MasterCap;
    PCI_AGP_CAPABILITY TargetCap;
    PAGPCPQ_EXTENSION Extension = AgpExtension;
    ULONG SBAEnable;
    ULONG FastWrite;
    ULONG DataRate;
    UCHAR RevID = 0;
    BOOLEAN ReverseInit;

    AGPLOG(AGP_NOISE, ("AgpCpq: AgpInitializeMaster entered.\n"));

    //
    // Get the master and target AGP capabilities
    //
    Status = AgpLibGetMasterCapability(AgpExtension, &MasterCap);
    if (!NT_SUCCESS(Status)) 
        {
        AGPLOG(AGP_CRITICAL,
            ("AGPCPQInitializeDevice - AgpLibGetMasterCapability failed %08lx\n",
            Status));
        return(Status);
        }

    Status = AgpLibGetPciDeviceCapability(AGP_CPQ_BUS_ID, 
                                          AGP_CPQ_PCIPCI_SLOT_ID,
                                          &TargetCap);
    if (!NT_SUCCESS(Status)) 
        {
        AGPLOG(AGP_CRITICAL,
               ("AGPCPQInitializeDevice - AgpLibGetPciDeviceCapability failed %08lx\n",
               Status));
        return(Status);
        }

    //
    // Determine the greatest common denominator for data rate.
    //
    DataRate = TargetCap.AGPStatus.Rate & MasterCap.AGPStatus.Rate;
    ASSERT(DataRate != 0);

    //
    // Select the highest common rate.
    //
    if (DataRate & PCI_AGP_RATE_4X) {
        DataRate = PCI_AGP_RATE_4X;
    } else if (DataRate & PCI_AGP_RATE_2X) {
        DataRate = PCI_AGP_RATE_2X;
    } else if (DataRate & PCI_AGP_RATE_1X) {
        DataRate = PCI_AGP_RATE_1X;
    }

    //
    // Previously a call was made to change the rate (successfully),
    // use this rate again now
    //
    if (Extension->SpecialTarget & AGP_FLAG_SPECIAL_RESERVE) {
        DataRate = (ULONG)((Extension->SpecialTarget & 
                            AGP_FLAG_SPECIAL_RESERVE) >>
                           AGP_FLAG_SET_RATE_SHIFT);
    }

    //
    // FIX RCC silicon bugs:  
    // If RevID <= 4, then the reported Data Rate is 2X but the chip only supports 1X.
    // Regardless of RevID the reported RQDepth should be 0x0F.
    //
    if (Extension->DeviceVendorID == AGP_CNB20_LE_IDENTIFIER) {
        ReadCPQConfig(&RevID, OFFSET_REV_ID, sizeof(RevID));

        ASSERT(TargetCap.AGPStatus.RequestQueueDepthMaximum == 0x10); 
        TargetCap.AGPStatus.RequestQueueDepthMaximum = 0x0F;

        if (RevID <= MAX_REV_ID_TO_LIMIT_1X) {
            DataRate = PCI_AGP_RATE_1X;
        }
    }

    //
    // Enable SBA if both master and target support it.
    //
    SBAEnable = (TargetCap.AGPStatus.SideBandAddressing & 
                 MasterCap.AGPStatus.SideBandAddressing);

    //
    // Enable FastWrite if both master and target support it.
    //
    
    FastWrite = (TargetCap.AGPStatus.FastWrite &
                 MasterCap.AGPStatus.FastWrite);

    //
    // Enable the Master first.
    //
    ReverseInit = 
        (Extension->SpecialTarget & AGP_FLAG_REVERSE_INITIALIZATION) ==
        AGP_FLAG_REVERSE_INITIALIZATION;
    if (ReverseInit) {
        MasterCap.AGPCommand.Rate = DataRate;
        MasterCap.AGPCommand.AGPEnable = 1;
        MasterCap.AGPCommand.SBAEnable = SBAEnable;
        MasterCap.AGPCommand.FastWriteEnable = FastWrite;
        MasterCap.AGPCommand.RequestQueueDepth = TargetCap.AGPStatus.RequestQueueDepthMaximum;
        Status = AgpLibSetMasterCapability(AgpExtension, &MasterCap);
        if (!NT_SUCCESS(Status)) 
        {
            AGPLOG(AGP_CRITICAL,
                   ("AGPCPQInitializeDevice - AgpLibSetMasterCapability %08lx failed %08lx\n",
                    &MasterCap,
                    Status));
        }
    }

    //
    // Now enable the Target.
    //
    TargetCap.AGPCommand.Rate = DataRate;
    TargetCap.AGPCommand.AGPEnable = 1;
    TargetCap.AGPCommand.SBAEnable = SBAEnable;
    TargetCap.AGPCommand.FastWriteEnable = FastWrite;
    Status = AgpLibSetPciDeviceCapability(AGP_CPQ_BUS_ID, 
                                          AGP_CPQ_PCIPCI_SLOT_ID, 
                                          &TargetCap);
    if (!NT_SUCCESS(Status)) 
        {
        AGPLOG(AGP_CRITICAL,
               ("AGPCPQInitializeDevice - AgpLibSetPciDeviceCapability %08lx for target failed %08lx\n",
                &TargetCap,
                Status));
        return(Status);
        }

    if (!ReverseInit) {
        MasterCap.AGPCommand.Rate = DataRate;
        MasterCap.AGPCommand.AGPEnable = 1;
        MasterCap.AGPCommand.SBAEnable = SBAEnable;
        MasterCap.AGPCommand.FastWriteEnable = FastWrite;
        MasterCap.AGPCommand.RequestQueueDepth = TargetCap.AGPStatus.RequestQueueDepthMaximum;
        Status = AgpLibSetMasterCapability(AgpExtension, &MasterCap);
        if (!NT_SUCCESS(Status)) 
        {
            AGPLOG(AGP_CRITICAL,
                   ("AGPCPQInitializeDevice - AgpLibSetMasterCapability %08lx failed %08lx\n",
                    &MasterCap,
                    Status));
        }
    }

#if DBG
    {
        PCI_AGP_CAPABILITY CurrentCap;

        //
        // Read them back, see if it worked
        //
        Status = AgpLibGetMasterCapability(AgpExtension, &CurrentCap);
        ASSERT(NT_SUCCESS(Status));
        //
        // If the target request queue depth is greater than the master will
        // allow, it will be trimmed.   Loosen the assert to not require an
        // exact match.
        //
        ASSERT(CurrentCap.AGPCommand.RequestQueueDepth <= MasterCap.AGPCommand.RequestQueueDepth);
        CurrentCap.AGPCommand.RequestQueueDepth = MasterCap.AGPCommand.RequestQueueDepth;
        ASSERT(RtlEqualMemory(&CurrentCap.AGPCommand, &MasterCap.AGPCommand, sizeof(CurrentCap.AGPCommand)));


        Status = AgpLibGetPciDeviceCapability(AGP_CPQ_BUS_ID, 
                                              AGP_CPQ_PCIPCI_SLOT_ID,
                                              &CurrentCap);
        ASSERT(NT_SUCCESS(Status));
        ASSERT(RtlEqualMemory(&CurrentCap.AGPCommand, &TargetCap.AGPCommand, 
            sizeof(CurrentCap.AGPCommand)));
    }
#endif

    //
    // Indicate that we can map memory through the GART aperture
    //
    *AgpCapabilities = AGP_CAPABILITIES_MAP_PHYSICAL;

    return(Status);
}


NTSTATUS 
DnbSetShadowBit(
    ULONG SetToOne
    )
//
// This routine is required, (because of a new requirement in the RCC chipset.).
// When there are two NorthBridge's, the shadow bit must be set to 0 prior
// to any MMIO writes, and then set back to 1 when done.
//
{
    NTSTATUS    Status = STATUS_SUCCESS;    // Assume Success
    UCHAR       ShadowByte = 0;
    ULONG       BytesReturned = 0;
    ULONG       length = 1;

    if (SetToOne == 1) {

        //
        // Set the shadow bit to a one. (This disables shadowing.)
        //
        BytesReturned = HalGetBusDataByOffset(PCIConfiguration, SECONDARY_LE_BUS_ID,
            SECONDARY_LE_HOSTPCI_SLOT_ID, &ShadowByte, OFFSET_SHADOW_BYTE, length);

        if(BytesReturned != length) {
            AGPLOG(AGP_CRITICAL,("ERROR: Failed to read shadow register!\n"));
            Status = STATUS_UNSUCCESSFUL;
            goto exit_routine;
        }

        ShadowByte |= FLAG_DISABLE_SHADOW;

        HalSetBusDataByOffset(PCIConfiguration, SECONDARY_LE_BUS_ID,
            SECONDARY_LE_HOSTPCI_SLOT_ID, &ShadowByte, OFFSET_SHADOW_BYTE, length);

        if(BytesReturned != length) {
            AGPLOG(AGP_CRITICAL,("ERROR: Failed to write shadow register!\n"));
            Status = STATUS_UNSUCCESSFUL;
            goto exit_routine;
        }

    } else {

        //
        // Set the shadow bit to a zero. (This enables shadowing.)
        //
        BytesReturned = HalGetBusDataByOffset(PCIConfiguration, SECONDARY_LE_BUS_ID,
            SECONDARY_LE_HOSTPCI_SLOT_ID, &ShadowByte, OFFSET_SHADOW_BYTE, length);

        if(BytesReturned != length) {
            AGPLOG(AGP_CRITICAL,("ERROR: Failed to read shadow register!"));
            Status = STATUS_UNSUCCESSFUL;
            goto exit_routine;
        }

        ShadowByte &= MASK_ENABLE_SHADOW;

        HalSetBusDataByOffset(PCIConfiguration, SECONDARY_LE_BUS_ID,
            SECONDARY_LE_HOSTPCI_SLOT_ID, &ShadowByte, OFFSET_SHADOW_BYTE, length);

        if(BytesReturned != length) {
            AGPLOG(AGP_CRITICAL,("ERROR: Failed to write shadow register!"));
            Status = STATUS_UNSUCCESSFUL;
            goto exit_routine;
        }
    }

exit_routine:

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\agp\agplib\init.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    init.c

Abstract:

    Common initialization routine for the AGP filter driver

Author:

    John Vert (jvert) 10/22/1997

Revision History:

   Elliot Shmukler (elliots) 3/24/1999 - Added support for "favored" memory
                                          ranges for AGP physical memory allocation,
                                          fixed some bugs.

--*/
#include "agplib.h"

//
// Local function prototypes
//
NTSTATUS
AgpAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
AgpBuildHackTable(
    IN OUT PAGP_HACK_TABLE_ENTRY *AgpHackTable,
    IN HANDLE HackTableKey
    );

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
AgpDriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );

VOID
AgpInitFavoredMemoryRanges(
   IN PTARGET_EXTENSION Extension);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AgpAddDevice)
#pragma alloc_text(PAGE, DriverEntry)
#pragma alloc_text(PAGE, AgpDriverUnload)
#pragma alloc_text(PAGE, AgpAttachDeviceRelations)
#pragma alloc_text(INIT, AgpBuildHackTable)
#pragma alloc_text(PAGE, AgpInitFavoredMemoryRanges)
#endif

ULONG AgpLogLevel = 0;
ULONG AgpStopLevel = 0;
PDRIVER_OBJECT AgpDriver;

//
// Table of hacks for broken hardware read from the registry at init
//
PAGP_HACK_TABLE_ENTRY AgpDeviceHackTable = NULL;
PAGP_HACK_TABLE_ENTRY AgpGlobalHackTable = NULL;

#define HACKFMT_VENDORDEV         (sizeof(L"VVVVDDDD") - sizeof(UNICODE_NULL))
#define HACKFMT_VENDORDEVREVISION (sizeof(L"VVVVDDDDRR") - sizeof(UNICODE_NULL))
#define HACKFMT_SUBSYSTEM         (sizeof(L"VVVVDDDDSSSSssss") - sizeof(UNICODE_NULL))
#define HACKFMT_SUBSYSTEMREVISION (sizeof(L"VVVVDDDDSSSSssssRR") - sizeof(UNICODE_NULL))
#define HACKFMT_MAX_LENGTH        HACKFMT_SUBSYSTEMREVISION

#define HACKFMT_DEVICE_OFFSET     4
#define HACKFMT_SUBVENDOR_OFFSET  8
#define HACKFMT_SUBSYSTEM_OFFSET 12

NTSTATUS
AgpAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
{
    NTSTATUS Status;
    PDEVICE_OBJECT Device;
    PTARGET_EXTENSION Extension;

    PAGED_CODE();

    //
    // Create our device
    //
    Status = IoCreateDevice(DriverObject,
                            sizeof(TARGET_EXTENSION)  + AgpExtensionSize - sizeof(ULONGLONG),
                            NULL,
                            FILE_DEVICE_BUS_EXTENDER,
                            0,
                            FALSE,
                            &Device);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,("AgpAddDevice: IoCreateDevice failed %08lx\n",Status));
        return(Status);
    }

    //
    // Initialize the device extension
    //
    Extension = Device->DeviceExtension;
    Extension->CommonExtension.Type = AgpTargetFilter;
    Extension->CommonExtension.Deleted = FALSE;
    Extension->CommonExtension.Signature = TARGET_SIG;
    Status = ApQueryBusInterface(PhysicalDeviceObject, &Extension->CommonExtension.BusInterface);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpAddDevice: query for bus interface failed %08lx\n", Status));
        IoDeleteDevice(Device);
        return(STATUS_NO_SUCH_DEVICE);
    }
    Extension->ChildDevice = NULL;
    Extension->FavoredMemory.NumRanges = 0;
    Extension->FavoredMemory.Ranges = NULL;
    Extension->GartBase.QuadPart = 0;
    Extension->GartLengthInPages = 0;
    Extension->Lock = ExAllocatePoolWithTag(NonPagedPool, sizeof(FAST_MUTEX), 'MFgA');
    if (Extension->Lock == NULL) {
        AGPLOG(AGP_CRITICAL,
               ("AgpAddDevice: allocation of fast mutext failed\n"));
        RELEASE_BUS_INTERFACE(Extension);
        IoDeleteDevice(Device);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    ExInitializeFastMutex(Extension->Lock);

    //
    // Attach to the supplied PDO
    //
    Extension->CommonExtension.AttachedDevice = IoAttachDeviceToDeviceStack(Device, PhysicalDeviceObject);
    if (Extension->CommonExtension.AttachedDevice == NULL) {
        //
        // The attach failed.
        //
        AGPLOG(AGP_CRITICAL,
               ("AgpAddDevice: IoAttachDeviceToDeviceStack from %08lx to %08lx failed\n",
               Device,
               PhysicalDeviceObject));
        RELEASE_BUS_INTERFACE(Extension);
        IoDeleteDevice(Device);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Figure out our favored memory ranges
    //

    AgpInitFavoredMemoryRanges(Extension);

    //
    // Finally call the chipset-specific code for target initialization
    //
    Status = AgpInitializeTarget(GET_AGP_CONTEXT(Extension));
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpAttachDeviceRelations: AgpInitializeTarget on device %08lx failed %08lx\n",
                Device,
                Status));
        IoDetachDevice(Extension->CommonExtension.AttachedDevice);
        RELEASE_BUS_INTERFACE(Extension);
        IoDeleteDevice(Device);
        return(Status);
    }

    Device->Flags &= ~DO_DEVICE_INITIALIZING;

    return(STATUS_SUCCESS);

}

NTSTATUS
AgpBuildHackTable(
    IN OUT PAGP_HACK_TABLE_ENTRY *AgpHackTable,
    IN HANDLE HackTableKey
    )
{

    NTSTATUS status;
    PKEY_FULL_INFORMATION keyInfo = NULL;
    ULONG hackCount, size, index;
    USHORT temp;
    PAGP_HACK_TABLE_ENTRY entry;
    ULONGLONG data;
    PKEY_VALUE_FULL_INFORMATION valueInfo = NULL;
    ULONG valueInfoSize = sizeof(KEY_VALUE_FULL_INFORMATION)
                          + HACKFMT_MAX_LENGTH +
                          + sizeof(ULONGLONG);

    //
    // Get the key info so we know how many hack values there are.
    // This does not change during system initialization.
    //

    status = ZwQueryKey(HackTableKey,
                        KeyFullInformation,
                        NULL,
                        0,
                        &size
                        );

    if (status != STATUS_BUFFER_TOO_SMALL) {
        ASSERT(!NT_SUCCESS(status));
        goto cleanup;
    }

    ASSERT(size > 0);

    keyInfo = ExAllocatePool(PagedPool, size);

    if (!keyInfo) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    status = ZwQueryKey(HackTableKey,
                        KeyFullInformation,
                        keyInfo,
                        size,
                        &size
                        );

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    hackCount = keyInfo->Values;

    ExFreePool(keyInfo);
    keyInfo = NULL;

    //
    // Allocate and initialize the hack table
    //

    *AgpHackTable = ExAllocatePool(NonPagedPool,
                                  (hackCount + 1) * sizeof(AGP_HACK_TABLE_ENTRY)
                                  );

    if (!*AgpHackTable) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }


    //
    // Allocate a valueInfo buffer big enough for the biggest valid
    // format and a ULONGLONG worth of data.
    //

    valueInfo = ExAllocatePool(PagedPool, valueInfoSize);

    if (!valueInfo) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    entry = *AgpHackTable;

    for (index = 0; index < hackCount; index++) {

        status = ZwEnumerateValueKey(HackTableKey,
                                     index,
                                     KeyValueFullInformation,
                                     valueInfo,
                                     valueInfoSize,
                                     &size
                                     );

        if (!NT_SUCCESS(status)) {
            if (status == STATUS_BUFFER_OVERFLOW || status == STATUS_BUFFER_TOO_SMALL) {
                //
                // All out data is of fixed length and the buffer is big enough
                // so this can't be for us.
                //

                continue;
            } else {
                goto cleanup;
            }
        }

        //
        // Get pointer to the data if its of the right type
        //

        if ((valueInfo->Type == REG_BINARY) &&
            (valueInfo->DataLength == sizeof(ULONGLONG))) {
            data = *(ULONGLONG UNALIGNED *)(((PUCHAR)valueInfo) + valueInfo->DataOffset);
        } else {
            //
            // We only deal in ULONGLONGs
            //

            continue;
        }

        //
        // Now see if the name is formatted like we expect it to be:
        // VVVVDDDD
        // VVVVDDDDRR
        // VVVVDDDDSSSSssss
        // VVVVDDDDSSSSssssRR

        if ((valueInfo->NameLength != HACKFMT_VENDORDEV) &&
            (valueInfo->NameLength != HACKFMT_VENDORDEVREVISION) &&
            (valueInfo->NameLength != HACKFMT_SUBSYSTEM) &&
            (valueInfo->NameLength != HACKFMT_SUBSYSTEMREVISION)) {

            //
            // This isn't ours
            //

            AGPLOG(
                AGP_CRITICAL,
                ("Skipping hack entry with invalid length name\n"
                 ));

            continue;
        }


        //
        // This looks plausable - try to parse it and fill in a hack table
        // entry
        //

        RtlZeroMemory(entry, sizeof(AGP_HACK_TABLE_ENTRY));

        //
        // Look for DeviceID and VendorID (VVVVDDDD)
        //

        if (!AgpStringToUSHORT(valueInfo->Name, &entry->VendorID)) {
            continue;
        }

        if (!AgpStringToUSHORT(valueInfo->Name + HACKFMT_DEVICE_OFFSET,
                               &entry->DeviceID)) {
            continue;
        }


        //
        // Look for SubsystemVendorID/SubSystemID (SSSSssss)
        //

        if ((valueInfo->NameLength == HACKFMT_SUBSYSTEM) ||
            (valueInfo->NameLength == HACKFMT_SUBSYSTEMREVISION)) {

            if (!AgpStringToUSHORT(valueInfo->Name + HACKFMT_SUBVENDOR_OFFSET,
                                   &entry->SubVendorID)) {
                continue;
            }

            if (!AgpStringToUSHORT(valueInfo->Name + HACKFMT_SUBSYSTEM_OFFSET,
                                   &entry->SubSystemID)) {
                continue;
            }

            entry->Flags |= AGP_HACK_FLAG_SUBSYSTEM;
        }

        //
        // Look for RevisionID (RR)
        //

        if ((valueInfo->NameLength == HACKFMT_VENDORDEVREVISION) ||
            (valueInfo->NameLength == HACKFMT_SUBSYSTEMREVISION)) {
            if (AgpStringToUSHORT(valueInfo->Name +
                                  (valueInfo->NameLength/sizeof(WCHAR) - 4), &temp)) {
                entry->RevisionID = temp & 0xFF;
                entry->Flags |= AGP_HACK_FLAG_REVISION;
            } else {
                continue;
            }
        }

        ASSERT(entry->VendorID != 0xFFFF);

        //
        // Fill in the entry
        //

        entry->DeviceFlags = data;

        AGPLOG(
            AGP_CRITICAL,
            ("Adding Hack entry for Vendor:0x%04x Device:0x%04x ",
            entry->VendorID, entry->DeviceID
            ));

        if (entry->Flags & AGP_HACK_FLAG_SUBSYSTEM) {
            AGPLOG(
                AGP_CRITICAL,
                ("SybSys:0x%04x SubVendor:0x%04x ",
                 entry->SubSystemID, entry->SubVendorID
                 ));
        }

        if (entry->Flags & AGP_HACK_FLAG_REVISION) {
            AGPLOG(
                AGP_CRITICAL,
                ("Revision:0x%02x",
                 (ULONG) entry->RevisionID
                 ));
        }

        AGPLOG(
            AGP_CRITICAL,
            (" = 0x%I64x\n",
             entry->DeviceFlags
             ));

        entry++;
    }

    ASSERT(entry < (*AgpHackTable + hackCount + 1));

    //
    // Terminate the table with an invalid VendorID
    //

    entry->VendorID = 0xFFFF;

    ExFreePool(valueInfo);

    return STATUS_SUCCESS;

cleanup:

    ASSERT(!NT_SUCCESS(status));

    if (keyInfo) {
        ExFreePool(keyInfo);
    }

    if (valueInfo) {
        ExFreePool(valueInfo);
    }

    if (*AgpHackTable) {
        ExFreePool(*AgpHackTable);
        *AgpHackTable = NULL;
    }

    return status;

}


VOID
AgpInitFavoredMemoryRanges(
   IN PTARGET_EXTENSION Extension)
/*++

Routine Description:

    Determines the optimum memory ranges for AGP physical memory
    allocation by calling the ACPI BANK method provided by the
    AGP northbridge in order to determine which physical memory
    ranges are decoded by that northbridge.

    Initializes the FavoredMemory sturcture in the target extension
    with the proper ranges.

    If this routine fails, then the FavoredMemory structure
    is left untouched in its initialized state (i.e. no favored memory
    ranges found).

Arguments:

    Extension - The target extension.


Return Value:

    NONE. Upon failure,

--*/

{
   PDEVICE_OBJECT LowerPdo;
   IO_STATUS_BLOCK IoStatus;
   PIRP Irp;
   KEVENT event;
   NTSTATUS Status;
   ACPI_EVAL_INPUT_BUFFER inputBuffer;
   UCHAR ResultBuffer[sizeof(ACPI_EVAL_OUTPUT_BUFFER) + MAX_MBAT_SIZE];
   PACPI_EVAL_OUTPUT_BUFFER outputBuffer;
   PACPI_METHOD_ARGUMENT MethodArg;
   PMBAT Mbat;
   UCHAR i;
   USHORT j;
   PHYSICAL_ADDRESS MaxMemory;

   //
   // Maximum memory address for limiting AGP memory to below 4GB
   //

   MAX_MEM(MaxMemory.QuadPart);

   //
   // Get an event to wait on
   //

   KeInitializeEvent(&event, NotificationEvent, FALSE);

   // Get a PDO where we will send the request IRP.

   LowerPdo = Extension->CommonExtension.AttachedDevice;

   //
   // Initialize the input parameters and the output buffer.
   //
   RtlZeroMemory( &inputBuffer, sizeof(ACPI_EVAL_INPUT_BUFFER) );
   inputBuffer.MethodNameAsUlong = CM_BANK_METHOD;
   inputBuffer.Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;
   outputBuffer = (PACPI_EVAL_OUTPUT_BUFFER)ResultBuffer;

   //
   // Build the request to call the BANK method.
   //
   Irp = IoBuildDeviceIoControlRequest(
        IOCTL_ACPI_EVAL_METHOD,
        LowerPdo,
        &inputBuffer,
        sizeof(ACPI_EVAL_INPUT_BUFFER),
        outputBuffer,
        sizeof(ResultBuffer),
        FALSE,
        &event,
        &IoStatus
        );

   if (!Irp)
   {
      return;
   }

   //
   // Send to the ACPI driver
   //
   Status = IoCallDriver ( LowerPdo, Irp);
   if (Status == STATUS_PENDING)
   {
         KeWaitForSingleObject( &event, Executive, KernelMode, FALSE, NULL);
         Status = IoStatus.Status;
   }

   if (NT_SUCCESS(Status))
   {
      AGPLOG(AGP_NOISE, ("AGPLIB: ACPI BANK Method Executed.\n"));

      //
      // Sanity check method results
      //

      MethodArg = outputBuffer->Argument;
      if ((outputBuffer->Signature == ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE) &&
          (MethodArg->DataLength >= sizeof(MBAT)) &&
          (MethodArg->Type == ACPI_METHOD_ARGUMENT_BUFFER))
      {

         AGPLOG(AGP_NOISE, ("AGPLIB: MBAT appears valid.\n"));

         //
         // Grab the MBAT and see if we can parse it
         //

         Mbat = (PMBAT)MethodArg->Data;

         if (Mbat->TableVersion == MBAT_VERSION) {
            AGPLOG(AGP_NOISE, ("AGPLIB: Parsing MBAT.\n"));

             //
             // Calculate the number of favored ranges mentioned
             // in the MBAT
             //

             i=Mbat->ValidEntryBitmap;
             while(i)
             {
                Extension->FavoredMemory.NumRanges++;
                i = i & (i-1);
             }

             AGPLOG(AGP_NOISE, ("AGPLIB: %u favored ranges found.\n",
                      Extension->FavoredMemory.NumRanges));

             if(Extension->FavoredMemory.NumRanges == 0) return;

             //
             // Allocate the favored memory range structure in our device
             // extension
             //

             Extension->FavoredMemory.Ranges =
                ExAllocatePool(NonPagedPool, sizeof(AGP_MEMORY_RANGE) *
                               Extension->FavoredMemory.NumRanges);

             if (Extension->FavoredMemory.Ranges == NULL) {
                Extension->FavoredMemory.NumRanges = 0;
                return;
             }


             //
             // Initialize the favored memory ranges in our extension
             // based upon the MBAT
             //

             i=0;
             j=0;
             while(Mbat->ValidEntryBitmap)
             {
                if (Mbat->ValidEntryBitmap & 1)
                {
                   if (Mbat->DecodeRange[i].Lower.QuadPart > MaxMemory.QuadPart) {
                      // This range is invalid since its lower address is above
                      // the highest allowable address

                      AGPLOG(AGP_NOISE, ("AGPLIB: Invalid MBAT Range ==> %I64x - %I64x\n",
                               Mbat->DecodeRange[i].Lower.QuadPart,
                               Mbat->DecodeRange[i].Upper.QuadPart));

                      // Pretend like this range never existed ...
                      //

                      Extension->FavoredMemory.NumRanges--;

                   }
                   else
                   {

                     // This is a valid range.

                     Extension->FavoredMemory.Ranges[j].Lower.QuadPart =
                         Mbat->DecodeRange[i].Lower.QuadPart;
                     Extension->FavoredMemory.Ranges[j].Upper.QuadPart =
                         Mbat->DecodeRange[i].Upper.QuadPart;


                     AGPLOG(AGP_NOISE, ("AGPLIB: MBAT Range ==> %I64x - %I64x\n",
                              Mbat->DecodeRange[i].Lower.QuadPart,
                              Mbat->DecodeRange[i].Upper.QuadPart));

                     if(Extension->FavoredMemory.Ranges[j].Upper.QuadPart >
                        MaxMemory.QuadPart)
                     {
                        AGPLOG(AGP_NOISE, ("AGPLIB: Adjusting range to fit within maximum allowable address.\n"));
                        Extension->FavoredMemory.Ranges[j].Upper.QuadPart =
                           MaxMemory.QuadPart;
                     }

                     j++;
                   }
                }
                Mbat->ValidEntryBitmap >>= 1;
                i++;
             }

         } else {

            AGPLOG(AGP_WARNING, ("AGPLIB: Unknown MBAT version.\n"));

         }

}


    }
}


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Entrypoint needed to initialize the AGP filter.

Arguments:

    DriverObject - Pointer to the driver object created by the system.

    RegistryPath - Pointer to the unicode registry service path.

Return Value:

    NT status.

--*/

{
    NTSTATUS Status;
    HANDLE serviceKey, paramsKey;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES attributes;

    PAGED_CODE();

    AgpDriver = DriverObject;

    DriverObject->DriverExtension->AddDevice = AgpAddDevice;
    DriverObject->DriverUnload               = AgpDriverUnload;

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = AgpDispatchDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_PNP] = AgpDispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER] = AgpDispatchPower;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = AgpDispatchWmi;

    RtlInitUnicodeString(&UnicodeString,
                         L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\"
                         L"Control");

    //
    // Open the global hack key and retrieve the gloabl hack table
    //
    InitializeObjectAttributes(&attributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                               );

    Status = ZwOpenKey(&serviceKey,
                       KEY_READ,
                       &attributes
                       );

    //
    // We must succeed here, there are devices that can freeze a system,
    // and something is really wrong if we can't access these values
    //
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    AgpOpenKey(L"AGP", serviceKey, &paramsKey, &Status);

    ZwClose(serviceKey);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Status = AgpBuildHackTable(&AgpGlobalHackTable, paramsKey);

    ZwClose(paramsKey);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Open our service key and retrieve any platform hack(s)
    //
    InitializeObjectAttributes(&attributes,
                               RegistryPath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                               );

    Status = ZwOpenKey(&serviceKey,
                       KEY_READ,
                       &attributes
                       );

    //
    // Maybe their chipset is so burly, it doesn't require any hacks!
    //
    if (!NT_SUCCESS(Status)) {
        return STATUS_SUCCESS;
    }

    AgpOpenKey(L"Parameters", serviceKey, &paramsKey, &Status);

    ZwClose(serviceKey);

    //
    // Don't care
    //
    if (!NT_SUCCESS(Status)) {
        return STATUS_SUCCESS;
    }

    //
    // Again, disregard status
    //
    AgpBuildHackTable(&AgpDeviceHackTable, paramsKey);

    ZwClose(paramsKey);

    return STATUS_SUCCESS;
}



VOID
AgpDriverUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Entrypoint used to unload the AGP driver

Arguments:

    DriverObject - Pointer to the driver object created by the system

Return Value:

    None

--*/
{
    if (AgpDeviceHackTable != NULL) {
        ExFreePool(AgpDeviceHackTable);
        AgpDeviceHackTable = NULL;
    }

    if (AgpGlobalHackTable != NULL) {
        ExFreePool(AgpGlobalHackTable);
        AgpGlobalHackTable = NULL;
    }
}



NTSTATUS
AgpAttachDeviceRelations(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    )
/*++

Routine Description:

    Completion routine for BusRelations IRP_MN_QUERY_DEVICE_RELATIONS irps sent
    to the PCI-PCI bridge PDO.  In order to handle QUERY_INTERFACE irps sent
    from the AGP device, we must attach to its PDO.  That means we attach to
    all the child PDOs of the PCI-PCI bridge.

Arguments:

    DeviceObject - Supplies the device object

    Irp - Supplies the IRP_MN_QUERY_DEVICE_RELATIONS irp

    Extension - Supplies the AGP device extension.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;
    PDEVICE_RELATIONS Relations;
    ULONG i;
    PDEVICE_OBJECT NewDevice;
    PMASTER_EXTENSION NewExtension;
#if DBG
    ULONG MasterCount=0;
#endif

    PAGED_CODE();

    //
    // If we have already attached, don't do it again.
    //
    if (Extension->ChildDevice != NULL) {
        return(STATUS_SUCCESS);
    }

    Relations = (PDEVICE_RELATIONS)Irp->IoStatus.Information;
    //
    // If somebody completed the IRP with success, but never
    // filled in the Relations field, then assume there are
    // no children and we don't have to do anything.
    //
    if (Relations == NULL) {
        return(STATUS_SUCCESS);
    }

    for (i=0; i<Relations->Count; i++) {

        //
        // Create a device object to attach to this PDO.
        //
        Status = IoCreateDevice(AgpDriver,
                                sizeof(MASTER_EXTENSION),
                                NULL,
                                FILE_DEVICE_BUS_EXTENDER,
                                0,
                                FALSE,
                                &NewDevice);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,("AgpAttachDeviceRelations: IoCreateDevice failed %08lx\n",Status));
            continue;
        }

        //
        // Initialize the device extension
        //

        NewExtension = NewDevice->DeviceExtension;
        NewExtension->CommonExtension.Deleted = FALSE;
        NewExtension->CommonExtension.Type = AgpMasterFilter;
        NewExtension->CommonExtension.Signature = MASTER_SIG;
        Status = ApQueryBusInterface(Relations->Objects[i], &NewExtension->CommonExtension.BusInterface);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AgpAttachDeviceRelations: query for bus interface failed %08lx\n", Status));
            IoDeleteDevice(NewDevice);
            continue;
        }
        NewExtension->Target = Extension;
        NewExtension->InterfaceCount = 0;
        NewExtension->ReservedPages = 0;
        NewExtension->StopPending = FALSE;
        NewExtension->RemovePending = FALSE;
        NewExtension->DisableCount = 1;         // biased so that we don't give anything out
                                                // until we see the IRP_MN_START
        Extension->ChildDevice = NewExtension;

        //
        // Attach to the specified device
        //
        NewExtension->CommonExtension.AttachedDevice = IoAttachDeviceToDeviceStack(NewDevice, Relations->Objects[i]);
        if (NewExtension->CommonExtension.AttachedDevice == NULL) {
            //
            // The attach failed. Not really fatal, AGP just won't work for that device.
            //
            AGPLOG(AGP_CRITICAL,
                   ("AgpAttachDeviceRelations: IoAttachDeviceToDeviceStack from %08lx to %08lx failed\n",
                   NewDevice,
                   Relations->Objects[i]));
            RELEASE_BUS_INTERFACE(NewExtension);
            IoDeleteDevice(NewDevice);
            continue;
        }

        //
        // Propagate the PDO's requirements
        //
        NewDevice->StackSize = NewExtension->CommonExtension.AttachedDevice->StackSize + 1;
        NewDevice->AlignmentRequirement = NewExtension->CommonExtension.AttachedDevice->AlignmentRequirement;
        if (NewExtension->CommonExtension.AttachedDevice->Flags & DO_POWER_PAGABLE) {
            NewDevice->Flags |= DO_POWER_PAGABLE;
        }

        //
        // Finally call the chipset-specific code for master initialization
        //
        Status = AgpInitializeMaster(GET_AGP_CONTEXT(Extension),
                                     &NewExtension->Capabilities);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AgpAttachDeviceRelations: AgpInitializeMaster on device %08lx failed %08lx\n",
                    NewDevice,
                    Status));
            IoDetachDevice(NewExtension->CommonExtension.AttachedDevice);
            RELEASE_BUS_INTERFACE(NewExtension);
            IoDeleteDevice(NewDevice);
            continue;
        }
        NewDevice->Flags &= ~DO_DEVICE_INITIALIZING;


#if DBG
        //
        // Check to make sure there is only one AGP master on the bus. There can be more
        // than one device (multifunction device) but only one must have AGP capabilities
        //
        MasterCount++;
        ASSERT(MasterCount == 1);
#else
        break;
#endif

    }

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\agp\alim1541\alim1541.h ===
//
// agpALi.sys is a driver, make sure we get the appropriate linkage.
//

#define _NTDRIVER_

#include "stdarg.h"
#include "stdio.h"
#include "ntddk.h"
#include "agp.h"

//
// Define the location of the GART aperture control registers
//

//
// The GART registers on the ALi M1541 live in the host-PCI bridge.
// This is unfortunate, since the AGP driver attaches to the PCI-PCI (AGP)
// bridge. So we have to get to the host-PCI bridge config space
// and this is only possible because we KNOW this is bus 0, slot 0.
//
#define AGP_ALi_GART_BUS_ID     0
#define AGP_ALi_GART_SLOT_ID    0
#define AGP_ALi_P2P_SLOT_ID     1
#define AGP_VGA_BUS_ID          1
#define AGP_VGA_SLOT_ID         0

#define AGP_ALi_1541_IDENTIFIER      0x154110b9
#define AGP_ALi_1621_IDENTIFIER      0x162110b9
#define AGP_ALi_1631_IDENTIFIER      0x163110b9
#define AGP_ALi_1632_IDENTIFIER      0x163210b9
#define AGP_ALi_1641_IDENTIFIER      0x164110b9
#define AGP_ALi_1644_IDENTIFIER      0x164410b9
#define AGP_ALi_1646_IDENTIFIER      0x164610b9
#define AGP_ALi_1647_IDENTIFIER      0x164710b9
#define AGP_ALi_1651_IDENTIFIER      0x165110b9
#define AGP_ALi_1661_IDENTIFIER      0x166110b9
#define AGP_ALi_1667_IDENTIFIER      0x166710b9

#define APBASE_OFFSET  0x10             // Aperture Base Address
#define AGP_STATUS_OFFSET 0xB4          // AGP Status Register
#define APCTRL_OFFSET 0xBC              // Aperture Translation Table Base
#define GTLBCTRL_OFFSET 0xC0            // GTLB Control Register
#define GTLBTAGCLR_OFFSET 0xC4          // GTLB TAG Clear Register
#define L1_2_CACHE_FLUSH_CTRL 0xD0      // L1/L2 Cache Flush Control
#define M1541_Lock_WR 0x90              // M1541 AGP Status Lock Read/Write Control
#define M1621_Lock_WR 0xC8              // M1621 AGP Status Lock Read/Write Control
#define PCI_STATUS_REG 0x4              // PCI Status Register
#define CAP_PTR 0x34                    // PCI Capability Pointer
#define AGP_ID 0x2                      // AGP Capability ID
#define M1621_HIDDEN_REV_ID 0xFB        // M1621 series Hidden Revision ID 

#define ReadConfigUlong(_bus_,_slot_,_buf_,_offset_)        \
{                                                           \
    ULONG _len_;                                            \
    _len_ = HalGetBusDataByOffset(PCIConfiguration,         \
                                  (_bus_),                  \
                                  (_slot_),                 \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  4);                \
    ASSERT(_len_ == 4);                              \
}

#define ReadConfigUlongSafe(_bus_,_slot_,_buf_,_offset_)    \
{                                                           \
    HalGetBusDataByOffset(PCIConfiguration,         \
                                  (_bus_),                  \
                                  (_slot_),                 \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  4);                \
}

#define ReadConfigUchar(_bus_,_slot_,_buf_,_offset_)        \
{                                                           \
    ULONG _len_;                                            \
    _len_ = HalGetBusDataByOffset(PCIConfiguration,         \
                                  (_bus_),                  \
                                  (_slot_),                 \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  1);                \
    ASSERT(_len_ == 1);                              \
}

#define WriteConfigUlong(_bus_,_slot_,_buf_,_offset_)       \
{                                                           \
    ULONG _len_;                                            \
    _len_ = HalSetBusDataByOffset(PCIConfiguration,         \
                                  (_bus_),                  \
                                  (_slot_),                 \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  4);                \
    ASSERT(_len_ == 4);                              \
}

#define WriteConfigUchar(_bus_,_slot_,_buf_,_offset_)       \
{                                                           \
    ULONG _len_;                                            \
    _len_ = HalSetBusDataByOffset(PCIConfiguration,         \
                                  (_bus_),                  \
                                  (_slot_),                 \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  1);                \
    ASSERT(_len_ == 1);                              \
}

#define AP_SIZE_4MB     0x03
#define AP_SIZE_8MB     0x04
#define AP_SIZE_16MB    0x06
#define AP_SIZE_32MB    0x07
#define AP_SIZE_64MB    0x08
#define AP_SIZE_128MB   0x09
#define AP_SIZE_256MB   0x0A

#define AP_SIZE_COUNT 7
#define AP_MIN_SIZE (4 * 1024 * 1024)
#define AP_MAX_SIZE (256 * 1024 * 1024)

//
// Define the GART table entry.
//
typedef struct _GART_ENTRY_HW {
    ULONG Valid     :  1;
    ULONG Reserved  : 11;
    ULONG Page      : 20;
} GART_ENTRY_HW, *PGART_ENTRY_HW;


//
// GART Entry states are defined so that all software-only states
// have the Valid bit clear.
//
#define GART_ENTRY_VALID        1           //  001
#define GART_ENTRY_FREE         0           //  000

#define GART_ENTRY_WC           2           //  010
#define GART_ENTRY_UC           4           //  100

#define GART_ENTRY_RESERVED_WC  GART_ENTRY_WC
#define GART_ENTRY_RESERVED_UC  GART_ENTRY_UC

#define GART_ENTRY_VALID_WC     (GART_ENTRY_VALID)
#define GART_ENTRY_VALID_UC     (GART_ENTRY_VALID)


typedef struct _GART_ENTRY_SW {
    ULONG State     : 3;
    ULONG Reserved  : 29;
} GART_ENTRY_SW, *PGART_ENTRY_SW;

typedef struct _GART_PTE {
    union {
        GART_ENTRY_HW Hard;
        ULONG      AsUlong;
        GART_ENTRY_SW Soft;
    };
} GART_PTE, *PGART_PTE;

//
// Define the layout of the hardware registers
//
typedef struct _APCTRL {
    ULONG ApSize        : 4;
    ULONG Reserved1     : 8;
    ULONG ATTBase       : 20;
} APCTRL, *PAPCTRL;

typedef struct _GTLBCTRL {
    ULONG GartLevelSelect   : 1;
    ULONG Reserved1         : 3;
    ULONG GTLBSize          : 2;
    ULONG Reserved2         : 1;
    ULONG GTLB_ENJ          : 1;  // 0:Enable  1:Desable
    ULONG NLVM_Base         : 12;
    ULONG NLVM_Top          : 12;
} GTLBCTRL, *PGTLBCTRL;

typedef struct _GTLBTAGCLR {
    ULONG GTLBTagClear      : 1;
    ULONG ClearAllTag       : 1;
    ULONG ClearGDir         : 1;
    ULONG Reserved2         : 12;
    ULONG Page              : 17;
} GTLBTAGCLR, *PGTLBTAGCLR;

typedef struct _CACHECTRL {
    ULONG Reserved1         : 8;
    ULONG Flush_Enable      : 1;
    ULONG Reserved2         : 3;
    ULONG Address           : 20;
} CACHECTRL, *PCACHECTRL;

//
// Define the different chipsets supported by this driver.
//
typedef enum _ALI_CHIPSET_TYPE {
    ALi1541,
    ALi1621,
    ALi1631,
    ALi1632,
    ALi1641,
    ALi1644,
    ALi1646,
    ALi1647,
    ALi1651,
    ALi1661,
    ALi1667
} ALI_CHIPSET_TYPE;

//
// Define the ALi-specific extension
//
typedef struct _AGPALi_EXTENSION {
    PHYSICAL_ADDRESS    ApertureStart;
    ULONG               ApertureLength;
    PGART_PTE           Gart;
    ULONG               GartLength;
    PHYSICAL_ADDRESS    GartPhysical;
    ALI_CHIPSET_TYPE    ChipsetType;
    ULONGLONG           SpecialTarget;
} AGPALi_EXTENSION, *PAGPALi_EXTENSION;


NTSTATUS
Agp1541FlushPages(
    IN PAGPALi_EXTENSION AgpContext,
    IN PMDL Mdl
    );

VOID
AgpWorkaround(
    IN PVOID AgpExtension
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\agp\agplib\agplib.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    agplib.h

Abstract:

    Private header file for the common AGP library

Author:

    John Vert (jvert) 10/22/1997

Revision History:

   Elliot Shmukler (elliots) 3/24/1999 - Added support for "favored" memory
                                          ranges for AGP physical memory allocation,
                                          fixed some bugs.

--*/
#include "agp.h"
#include "wdmguid.h"
#include <devioctl.h>
#include <acpiioct.h>

//
// regstr.h uses things of type WORD, which isn't around in kernel mode.
//

#define _IN_KERNEL_

#include "regstr.h"

#define AGP_HACK_FLAG_SUBSYSTEM 0x01
#define AGP_HACK_FLAG_REVISION  0x02

typedef struct _AGP_HACK_TABLE_ENTRY {
    USHORT VendorID;
    USHORT DeviceID;
    USHORT SubVendorID;
    USHORT SubSystemID;
    ULONGLONG DeviceFlags;
    UCHAR   RevisionID;
    UCHAR   Flags;
} AGP_HACK_TABLE_ENTRY, *PAGP_HACK_TABLE_ENTRY;

extern PAGP_HACK_TABLE_ENTRY AgpDeviceHackTable;
extern PAGP_HACK_TABLE_ENTRY AgpGlobalHackTable;

//
// Define common device extension
//
typedef enum _AGP_EXTENSION_TYPE {
    AgpTargetFilter,
    AgpMasterFilter
} AGP_EXTENSION_TYPE;

#define TARGET_SIG 'TpgA'
#define MASTER_SIG 'MpgA'

typedef struct _COMMON_EXTENSION {
    ULONG               Signature;
    BOOLEAN             Deleted;
    AGP_EXTENSION_TYPE  Type;
    PDEVICE_OBJECT      AttachedDevice;
    BUS_INTERFACE_STANDARD BusInterface;
} COMMON_EXTENSION, *PCOMMON_EXTENSION;

// Structures to maintain a list of "favored" memory ranges
// for AGP allocation.

typedef struct _AGP_MEMORY_RANGE
{
   PHYSICAL_ADDRESS Lower;
   PHYSICAL_ADDRESS Upper;
} AGP_MEMORY_RANGE, *PAGP_MEMORY_RANGE;

typedef struct _AGP_FAVORED_MEMORY
{
   ULONG NumRanges;
   PAGP_MEMORY_RANGE Ranges;
} AGP_FAVORED_MEMORY;

typedef struct _TARGET_EXTENSION {
    COMMON_EXTENSION            CommonExtension;
    PFAST_MUTEX                 Lock;
    struct _MASTER_EXTENSION    *ChildDevice;
    PCM_RESOURCE_LIST           Resources;
    PCM_RESOURCE_LIST           ResourcesTranslated;
    AGP_FAVORED_MEMORY          FavoredMemory;
    PHYSICAL_ADDRESS            GartBase;
    ULONG                       GartLengthInPages;
    ULONGLONG                   AgpContext;
} TARGET_EXTENSION, *PTARGET_EXTENSION;

typedef struct _MASTER_EXTENSION {
    COMMON_EXTENSION    CommonExtension;
    PTARGET_EXTENSION   Target;
    ULONG               Capabilities;
    ULONG               InterfaceCount;         // tracks the number of interfaces handed out
    ULONG               ReservedPages;          // tracks the number of pages reserved in the aperture
    BOOLEAN             StopPending;            // TRUE if we have seen a QUERY_STOP
    BOOLEAN             RemovePending;          // TRUE if we have seen a QUERY_REMOVE
    ULONG               DisableCount;           // non-zero if we are in a state where we cannot service requests
} MASTER_EXTENSION, *PMASTER_EXTENSION;

//
// The MBAT - used to retrieve "favored" memory ranges from
// the AGP northbridge via an ACPI BANK method
//

#include <pshpack1.h>

typedef struct _MBAT
{
   UCHAR TableVersion;
   UCHAR AgpBusNumber;
   UCHAR ValidEntryBitmap;
   AGP_MEMORY_RANGE DecodeRange[ANYSIZE_ARRAY];
} MBAT, *PMBAT;

#include <poppack.h>

#define MBAT_VERSION 1

#define MAX_MBAT_SIZE sizeof(MBAT) + ((sizeof(UCHAR) * 8) - ANYSIZE_ARRAY) \
                        * sizeof(AGP_MEMORY_RANGE)

#define CM_BANK_METHOD (ULONG)('KNAB')

//
// The highest memory address supported by AGP
//

#define MAX_MEM(_num_) _num_ = 1; \
                       _num_ = _num_*1024*1024*1024*4 - 1

#define RELEASE_BUS_INTERFACE(_ext_) (_ext_)->CommonExtension.BusInterface.InterfaceDereference((_ext_)->CommonExtension.BusInterface.Context)

//
// Macros for getting from the chipset-specific context to our structures
//
#define GET_TARGET_EXTENSION(_target_,_agp_context_)  (_target_) = (CONTAINING_RECORD((_agp_context_),    \
                                                                                      TARGET_EXTENSION,   \
                                                                                      AgpContext));       \
                                                      ASSERT_TARGET(_target_)
#define GET_MASTER_EXTENSION(_master_,_agp_context_)    {                                                       \
                                                            PTARGET_EXTENSION _targetext_;                      \
                                                            GET_TARGET_EXTENSION(_targetext_, (_agp_context_)); \
                                                            (_master_) = _targetext_->ChildDevice;              \
                                                            ASSERT_MASTER(_master_);                            \
                                                        }
#define GET_TARGET_PDO(_pdo_,_agp_context_) {                                                           \
                                                PTARGET_EXTENSION _targetext_;                          \
                                                GET_TARGET_EXTENSION(_targetext_,(_agp_context_));      \
                                                (_pdo_) = _targetext_->CommonExtension.AttachedDevice;  \
                                            }

#define GET_MASTER_PDO(_pdo_,_agp_context_) {                                                           \
                                                PMASTER_EXTENSION _masterext_;                          \
                                                GET_MASTER_EXTENSION(_masterext_, (_agp_context_));     \
                                                (_pdo_) = _masterext_->CommonExtension.AttachedDevice;  \
                                            }

#define GET_AGP_CONTEXT(_targetext_) ((PVOID)(&(_targetext_)->AgpContext))
#define GET_AGP_CONTEXT_FROM_MASTER(_masterext_) GET_AGP_CONTEXT((_masterext_)->Target)

//
// Some debugging macros
//
#define ASSERT_TARGET(_target_) ASSERT((_target_)->CommonExtension.Signature == TARGET_SIG); \
                                ASSERT((_target_)->ChildDevice->CommonExtension.Signature == MASTER_SIG)
#define ASSERT_MASTER(_master_) ASSERT((_master_)->CommonExtension.Signature == MASTER_SIG); \
                                ASSERT((_master_)->Target->CommonExtension.Signature == TARGET_SIG)

//
// Locking macros
//
#define LOCK_MUTEX(_fm_) ExAcquireFastMutex(_fm_); \
                         ASSERT((_fm_)->Count == 0)

#define UNLOCK_MUTEX(_fm_) ASSERT((_fm_)->Count == 0);  \
                           ExReleaseFastMutex(_fm_)

#define LOCK_TARGET(_targetext_) ASSERT_TARGET(_targetext_); \
                                 LOCK_MUTEX((_targetext_)->Lock)

#define LOCK_MASTER(_masterext_) ASSERT_MASTER(_masterext_); \
                                 LOCK_MUTEX((_masterext_)->Target->Lock)

#define UNLOCK_TARGET(_targetext_) ASSERT_TARGET(_targetext_); \
                                   UNLOCK_MUTEX((_targetext_)->Lock)

#define UNLOCK_MASTER(_masterext_) ASSERT_MASTER(_masterext_); \
                                   UNLOCK_MUTEX((_masterext_)->Target->Lock)

//
// Private resource type definition
//
typedef enum {
    AgpPrivateResource = '0PGA'
} AGP_PRIVATE_RESOURCE_TYPES;

//
// Define function prototypes
//

//
// Driver and device initialization - init.c
//
NTSTATUS
AgpAttachDeviceRelations(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    );


//
// IRP Dispatch routines - dispatch.c
//
NTSTATUS
AgpDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
AgpDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
AgpDispatchDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
AgpDispatchWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
AgpSetEventCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    );

//
// Config space handling routines - config.c
//
NTSTATUS
ApQueryBusInterface(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PBUS_INTERFACE_STANDARD BusInterface
    );

//
// Resource handing routines - resource.c
//
NTSTATUS
AgpFilterResourceRequirements(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    );

NTSTATUS
AgpQueryResources(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    );

NTSTATUS
AgpStartTarget(
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    );

VOID
AgpStopTarget(
    IN PTARGET_EXTENSION Extension
    );

//
// AGP Interface functions
//
NTSTATUS
AgpInterfaceSetRate(
    IN PMASTER_EXTENSION Extension,
    IN ULONG AgpRate
    );

VOID
AgpInterfaceReference(
    IN PMASTER_EXTENSION Extension
    );

VOID
AgpInterfaceDereference(
    IN PMASTER_EXTENSION Extension
    );


NTSTATUS
AgpInterfaceReserveMemory(
    IN PMASTER_EXTENSION Extension,
    IN ULONG NumberOfPages,
    IN MEMORY_CACHING_TYPE MemoryType,
    OUT PVOID *MapHandle,
    OUT OPTIONAL PHYSICAL_ADDRESS *PhysicalAddress
    );

NTSTATUS
AgpInterfaceReleaseMemory(
    IN PMASTER_EXTENSION Extension,
    IN PVOID MapHandle
    );

NTSTATUS
AgpInterfaceCommitMemory(
    IN PMASTER_EXTENSION Extension,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    IN OUT PMDL Mdl OPTIONAL,
    OUT PHYSICAL_ADDRESS *MemoryBase
    );

NTSTATUS
AgpInterfaceFreeMemory(
    IN PMASTER_EXTENSION Extension,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages
    );

NTSTATUS
AgpInterfaceGetMappedPages(
    IN PMASTER_EXTENSION Extension,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT PMDL Mdl
    );

//
// Misc utils.c
//
BOOLEAN
AgpOpenKey(
    IN  PWSTR   KeyName,
    IN  HANDLE  ParentHandle,
    OUT PHANDLE Handle,
    OUT PNTSTATUS Status
    );

BOOLEAN
AgpStringToUSHORT(
    IN PWCHAR String,
    OUT PUSHORT Result
    );

ULONGLONG
AgpGetDeviceFlags(
    IN PAGP_HACK_TABLE_ENTRY AgpHackTable,
    IN USHORT VendorID,
    IN USHORT DeviceID,
    IN USHORT SubVendorID,
    IN USHORT SubSystemID,
    IN UCHAR  RevisionID
    );

//
// AGP Physical Memory allocator
//
PMDL
AgpLibAllocatePhysicalMemory(
    IN PVOID AgpContext,
    IN ULONG TotalBytes);

//
// Handy structures for mucking about in PCI config space
//

//
// The PCI_COMMON_CONFIG includes the 192 bytes of device specific
// data.  The following structure is used to get only the first 64
// bytes which is all we care about most of the time anyway.  We cast
// to PCI_COMMON_CONFIG to get at the actual fields.
//

typedef struct {
    ULONG Reserved[PCI_COMMON_HDR_LENGTH/sizeof(ULONG)];
} PCI_COMMON_HEADER, *PPCI_COMMON_HEADER;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\agp\agplib\utils.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    utils.c

Abstract:

    This module contains assorted utility functions for PCI.SYS.

Author:

    Peter Johnston (peterj)  20-Nov-1996

Revision History:

    Eric Nelson (enelson)  20-Mar-2000 - kidnap registry function

--*/

#include "agplib.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AgpOpenKey)
#pragma alloc_text(PAGE, AgpStringToUSHORT)
#endif


ULONGLONG
AgpGetDeviceFlags(
    IN PAGP_HACK_TABLE_ENTRY AgpHackTable,
    IN USHORT VendorID,
    IN USHORT DeviceID,
    IN USHORT SubVendorID,
    IN USHORT SubSystemID,
    IN UCHAR  RevisionID
    )
/*++

Description:

    Look in the registry for any flags for this VendorId/DeviceId.

Arguments:

    VendorId      PCI Vendor ID (16 bits) of the manufacturer of the
                  device.

    DeviceId      PCI Device ID (16 bits) of the device.

    SubVendorID   PCI SubVendorID representing the manufacturer of the
                  subsystem

    SubSystemID   PCI SubSystemID representing subsystem

    RevisionID    PCI Revision denoting the revision of the device

Return Value:

    64 bit flags value or 0 if not found.

--*/
{
    PAGP_HACK_TABLE_ENTRY current;
    ULONGLONG hackFlags = 0;
    ULONG match, bestMatch = 0;

    if (AgpHackTable == NULL) {
        return hackFlags;
    }

    // 
    // We want to do a best-case match:
    // VVVVDDDDSSSSssssRR
    // VVVVDDDDSSSSssss
    // VVVVDDDDRR
    // VVVVDDDD
    //
    // List is currently unsorted, so keep updating current best match.
    //

    for (current = AgpHackTable; current->VendorID != 0xFFFF; current++) {
        match = 0;

        //
        // Must at least match vendor/dev
        //

        if ((current->DeviceID != DeviceID) ||
            (current->VendorID != VendorID)) {
            continue;
        }

        match = 1;

        //
        // If this entry specifies a revision, check that it is consistent.
        // 

        if (current->Flags & AGP_HACK_FLAG_REVISION) {
            if (current->RevisionID == RevisionID) {
                match += 2;
            } else {
                continue;
            }
        }

        //
        // If this entry specifies subsystems, check that they are consistent
        //

        if (current->Flags & AGP_HACK_FLAG_SUBSYSTEM) {
            if (current->SubVendorID == SubVendorID &&
                current->SubSystemID == SubSystemID) {
                match += 4;
            } else {
                continue;
            }
        }

        if (match > bestMatch) {
            bestMatch = match;
            hackFlags = current->DeviceFlags;
        }
    }

    return hackFlags;
}



BOOLEAN
AgpOpenKey(
    IN  PWSTR   KeyName,
    IN  HANDLE  ParentHandle,
    OUT PHANDLE Handle,
    OUT PNTSTATUS Status
    )
/*++

Description:

    Open a registry key.

Arguments:

    KeyName      Name of the key to be opened.
    ParentHandle Pointer to the parent handle (OPTIONAL)
    Handle       Pointer to a handle to recieve the opened key.

Return Value:

    TRUE is key successfully opened, FALSE otherwise.

--*/
{
    UNICODE_STRING    nameString;
    OBJECT_ATTRIBUTES nameAttributes;
    NTSTATUS localStatus;

    PAGED_CODE();

    RtlInitUnicodeString(&nameString, KeyName);

    InitializeObjectAttributes(&nameAttributes,
                               &nameString,
                               OBJ_CASE_INSENSITIVE,
                               ParentHandle,
                               (PSECURITY_DESCRIPTOR)NULL
                               );
    localStatus = ZwOpenKey(Handle,
                            KEY_READ,
                            &nameAttributes
                            );

    if (Status != NULL) {

        //
        // Caller wants underlying status.
        //

        *Status = localStatus;
    }

    //
    // Return status converted to a boolean, TRUE if
    // successful.
    //

    return NT_SUCCESS(localStatus);
}



BOOLEAN
AgpStringToUSHORT(
    IN PWCHAR String,
    OUT PUSHORT Result
    )
/*++

Description:

    Takes a 4 character hexidecimal sting and converts it into a USHORT.

Arguments:

    String - the string

    Result - the USHORT

Return Value:

    TRUE is success, FASLE otherwise

--*/
{
    ULONG count;
    USHORT number = 0;
    PWCHAR current;

    current = String;

    for (count = 0; count < 4; count++) {

        number <<= 4;

        if (*current >= L'0' && *current <= L'9') {
            number |= *current - L'0';
        } else if (*current >= L'A' && *current <= L'F') {
            number |= *current + 10 - L'A';
        } else if (*current >= L'a' && *current <= L'f') {
            number |= *current + 10 - L'a';
        } else {
            return FALSE;
        }

        current++;
    }

    *Result = number;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\agp\agplib\intrface.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    intrface.c

Abstract:

    Routines for implementing the AGP_BUS_INTERFACE_STANDARD interface

Author:

    John Vert (jvert) 10/26/1997

Revision History:

   Elliot Shmukler (elliots) 3/24/1999 - Added support for "favored" memory
                                          ranges for AGP physical memory allocation,
                                          fixed some bugs.

--*/
#define INITGUID 1
#include "agplib.h"


VOID
AgpLibFlushDcacheMdl(
    PMDL Mdl
    );

VOID
ApFlushDcache(
    IN PKDPC Dpc,
    IN PKEVENT Event,
    IN PMDL Mdl,
    IN PVOID SystemArgument2
    );

PMDL
AgpCombineMdlList(IN PMDL MdlList);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AgpInterfaceReference)
#pragma alloc_text(PAGE, AgpInterfaceDereference)
#pragma alloc_text(PAGE, AgpInterfaceReserveMemory)
#pragma alloc_text(PAGE, AgpInterfaceReleaseMemory)
#pragma alloc_text(PAGE, AgpInterfaceSetRate)
#pragma alloc_text(PAGE, AgpInterfaceCommitMemory)
#pragma alloc_text(PAGE, AgpInterfaceFreeMemory)
#pragma alloc_text(PAGE, AgpLibFlushDcacheMdl)
#pragma alloc_text(PAGE, AgpLibAllocatePhysicalMemory)
#pragma alloc_text(PAGE, AgpLibAllocateMappedPhysicalMemory)
#pragma alloc_text(PAGE, AgpCombineMdlList)
#endif


VOID
AgpInterfaceReference(
    IN PMASTER_EXTENSION Extension
    )
/*++

Routine Description:

    References an interface. Currently a NOP.

Arguments:

    Extension - Supplies the device extension

Return Value:

    None

--*/

{

    PAGED_CODE();

    InterlockedIncrement(&Extension->InterfaceCount);

}


VOID
AgpInterfaceDereference(
    IN PMASTER_EXTENSION Extension
    )
/*++

Routine Description:

    Dereferences an interface. Currently a NOP.

Arguments:

    Extension - Supplies the device extension

Return Value:

    None

--*/

{

    PAGED_CODE();

    InterlockedDecrement(&Extension->InterfaceCount);

}


NTSTATUS
AgpInterfaceReserveMemory(
    IN PMASTER_EXTENSION Extension,
    IN ULONG NumberOfPages,
    IN MEMORY_CACHING_TYPE MemoryType,
    OUT PVOID *MapHandle,
    OUT OPTIONAL PHYSICAL_ADDRESS *PhysicalAddress
    )
/*++

Routine Description:

    Reserves memory in the specified aperture

Arguments:

    Extension - Supplies the device extension where physical address space should be reserved.

    NumberOfPages - Supplies the number of pages to reserve.

    MemoryType - Supplies the memory caching type.

    MapHandle - Returns the mapping handle to be used on subsequent calls.

    PhysicalAddress - If present, returns the physical address in the aperture of the reserved 
            space

Return Value:

    NTSTATUS

--*/

{
    PVOID AgpContext;
    NTSTATUS Status;
    PHYSICAL_ADDRESS MemoryBase;
    PAGP_RANGE Range;

    PAGED_CODE();                              

    AgpContext = GET_AGP_CONTEXT_FROM_MASTER(Extension);

    Range = ExAllocatePoolWithTag(PagedPool,
                                  sizeof(AGP_RANGE),
                                  'RpgA');
    if (Range == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    Range->CommittedPages = 0;
    Range->NumberOfPages = NumberOfPages;
    Range->Type = MemoryType;

    LOCK_MASTER(Extension);
    Status = AgpReserveMemory(AgpContext,
                              Range);
    UNLOCK_MASTER(Extension);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpInterfaceReserveMemory - reservation of %x pages of type %d failed %08lx\n",
                NumberOfPages,
                MemoryType,
                Status));
    } else {
        AGPLOG(AGP_NOISE,
               ("AgpInterfaceReserveMemory - reserved %x pages of type %d at %I64X\n",
                NumberOfPages,
                MemoryType,
                Range->MemoryBase.QuadPart));
    }

    *MapHandle = Range;
    if (ARGUMENT_PRESENT(PhysicalAddress)) {
        *PhysicalAddress = Range->MemoryBase;
    }
    return(Status);
}


NTSTATUS
AgpInterfaceReleaseMemory(
    IN PMASTER_EXTENSION Extension,
    IN PVOID MapHandle
    )
/*++

Routine Description:

    Releases memory in the specified aperture that was previously reserved by
    AgpInterfaceReserveMemory

Arguments:

    Extension - Supplies the device extension where physical address space should be reserved.

    MapHandle - Supplies the mapping handle returned from AgpInterfaceReserveMemory

Return Value:

    NTSTATUS

--*/

{
    PAGP_RANGE Range;
    PVOID AgpContext;
    NTSTATUS Status;
    PHYSICAL_ADDRESS MemoryBase;

    PAGED_CODE();

    AgpContext = GET_AGP_CONTEXT_FROM_MASTER(Extension);
    Range = (PAGP_RANGE)MapHandle;

    LOCK_MASTER(Extension);
    //
    // Make sure the range is empty
    //
    ASSERT(Range->CommittedPages == 0);
    if (Range->CommittedPages != 0) {
        AGPLOG(AGP_CRITICAL,
               ("AgpInterfaceReleaseMemory - Invalid attempt to release non-empty range %08lx\n",
                Range));
        UNLOCK_MASTER(Extension);
        return(STATUS_INVALID_PARAMETER);
    }

    AGPLOG(AGP_NOISE,
           ("AgpInterfaceReleaseMemory - releasing range %08lx, %lx pages at %08lx\n",
            Range,
            Range->NumberOfPages,
            Range->MemoryBase.QuadPart));
    Status = AgpReleaseMemory(AgpContext,
                              Range);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpInterfaceReleaseMemory - release failed %08lx\n",
                Status));
    }
    UNLOCK_MASTER(Extension);
    ExFreePool(Range);
    return(Status);
}


NTSTATUS
AgpInterfaceCommitMemory(
    IN PMASTER_EXTENSION Extension,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    IN OUT PMDL Mdl OPTIONAL,
    OUT PHYSICAL_ADDRESS *MemoryBase
    )
/*++

Routine Description:

    Commits memory into the specified aperture that was previously reserved by
    AgpInterfaceReserveMemory

Arguments:

    Extension - Supplies the device extension where physical address space should
        be committed.

    MapHandle - Supplies the mapping handle returned from AgpInterfaceReserveMemory

    NumberOfPages - Supplies the number of pages to be committed.

    OffsetInPages - Supplies the offset, in pages, into the aperture reserved by
        AgpInterfaceReserveMemory

    Mdl - Returns the MDL describing the pages of memory committed.

    MemoryBase - Returns the physical memory address of the committed memory.

Return Value:

    NTSTATUS

--*/

{
    PAGP_RANGE Range = (PAGP_RANGE)MapHandle;
    PMDL NewMdl;
    PVOID AgpContext;
    NTSTATUS Status=STATUS_SUCCESS;
    ULONG RunLength, RunOffset;
    ULONG CurrentLength, CurrentOffset;
    PMDL FirstMdl=NULL;

    PAGED_CODE();

    AgpContext = GET_AGP_CONTEXT_FROM_MASTER(Extension);

    ASSERT(NumberOfPages <= Range->NumberOfPages);
    ASSERT(NumberOfPages > 0);
    ASSERT((Mdl == NULL) || (Mdl->ByteCount == PAGE_SIZE * NumberOfPages));

    CurrentLength = NumberOfPages;
    CurrentOffset = OffsetInPages;

    LOCK_MASTER(Extension);
    do {

        //
        // Save ourselves the trouble...
        //
        if (!(CurrentLength > 0)) {
            break;
        }

        //
        // Find the first free run in the supplied range.
        //
        AgpFindFreeRun(AgpContext,
                       Range,
                       CurrentLength,
                       CurrentOffset,
                       &RunLength,
                       &RunOffset);

        if (RunLength > 0) {
            ASSERT(RunLength <= CurrentLength);
            ASSERT(RunOffset >= CurrentOffset);
            ASSERT(RunOffset < CurrentOffset + CurrentLength);
            ASSERT(RunOffset + RunLength <= CurrentOffset + CurrentLength);

            //
            // Compute the next offset and length
            //
            CurrentLength -= (RunOffset - CurrentOffset) + RunLength;
            CurrentOffset = RunOffset + RunLength;

            //
            // Get an MDL from memory management big enough to map the 
            // requested range.
            //

            NewMdl = AgpLibAllocatePhysicalMemory(AgpContext, RunLength * PAGE_SIZE);
            
            //
            // This can fail in two ways, either no memory is available at all (NewMdl == NULL)
            // or some pages were available, but not enough. (NewMdl->ByteCount < Length)
            //
            if (NewMdl == NULL) {
                AGPLOG(AGP_CRITICAL,
                       ("AgpInterfaceReserveMemory - Couldn't allocate pages for %lx bytes\n",
                        RunLength));
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            } else if (BYTES_TO_PAGES(NewMdl->ByteCount) < RunLength) {
                AGPLOG(AGP_CRITICAL,
                       ("AgpInterfaceCommitMemory - Only allocated enough pages for %lx of %lx bytes\n",
                        NewMdl->ByteCount,
                        RunLength));
                Status = STATUS_INSUFFICIENT_RESOURCES;
                MmFreePagesFromMdl(NewMdl);
                break;
            }

            //
            // Now that we have our MDL, we can map this into the specified
            // range.
            //
            if (AgpFlushPages != NULL) {
                if (!NT_SUCCESS((AgpFlushPages)(AgpContext, NewMdl))) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    MmFreePagesFromMdl(NewMdl);
                    break;
                }
            } else {
                AgpLibFlushDcacheMdl(NewMdl);
            }
            Status = AgpMapMemory(AgpContext,
                                  Range,
                                  NewMdl,
                                  RunOffset,
                                  MemoryBase);
            if (!NT_SUCCESS(Status)) {
                AGPLOG(AGP_CRITICAL,
                       ("AgpInterfaceCommitMemory - AgpMapMemory for Mdl %08lx in range %08lx failed %08lx\n",
                        NewMdl,
                        Range,
                        Status));
                MmFreePagesFromMdl(NewMdl);
                break;
            }
            Range->CommittedPages += RunLength;

            //
            // Add this MDL to our list of allocated MDLs for cleanup
            // If we need to cleanup, we will also need to know the page offset
            // so that we can unmap the memory. Stash that value in the ByteOffset
            // field of the MDL (ByteOffset is always 0 for our MDLs)
            //
            NewMdl->ByteOffset = RunOffset;
            NewMdl->Next = FirstMdl;
            FirstMdl = NewMdl;
        }

    } while (RunLength > 0);

    //
    // Cleanup the MDLs. If the allocation failed, we need to
    // unmap them and free the pages and the MDL itself. If the
    // operation completed successfully, we just need to free the
    // MDL.
    //
    while (FirstMdl) {
        NewMdl = FirstMdl;
        FirstMdl = NewMdl->Next;
        if (!NT_SUCCESS(Status)) {

            //
            // Unmap the memory that was mapped. The ByteOffset field
            // of the MDL is overloaded here to store the offset in pages
            // into the range.
            //
            AgpUnMapMemory(AgpContext,
                           Range,
                           NewMdl->ByteCount / PAGE_SIZE,
                           NewMdl->ByteOffset);
            NewMdl->ByteOffset = 0;
            Range->CommittedPages -= NewMdl->ByteCount / PAGE_SIZE;
            MmFreePagesFromMdl(NewMdl);
        }
        ExFreePool(NewMdl);
    }

    if (NT_SUCCESS(Status)) {

        if (Mdl) {
            //
            // Get the MDL that describes the entire mapped range.
            //
            AgpGetMappedPages(AgpContext,
                              Range,
                              NumberOfPages,
                              OffsetInPages,
                              Mdl);
        }

        MemoryBase->QuadPart = Range->MemoryBase.QuadPart + OffsetInPages * PAGE_SIZE;
    }

    UNLOCK_MASTER(Extension);
    return(Status);
}


NTSTATUS
AgpInterfaceFreeMemory(
    IN PMASTER_EXTENSION Extension,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages
    )
/*++

Routine Description:

    Frees memory previously committed by AgpInterfaceCommitMemory

Arguments:

    Extension - Supplies the device extension where physical address space should
        be freed.

    MapHandle - Supplies the mapping handle returned from AgpInterfaceReserveMemory

    NumberOfPages - Supplies the number of pages to be freed.

    OffsetInPages - Supplies the start of the range to be freed.

Return Value:

    NTSTATUS

--*/

{
    PAGP_RANGE Range = (PAGP_RANGE)MapHandle;
    PVOID AgpContext;
    NTSTATUS Status;
    PMDL FreeMdl;

    PAGED_CODE();

    AgpContext = GET_AGP_CONTEXT_FROM_MASTER(Extension);

    ASSERT(OffsetInPages < Range->NumberOfPages);
    ASSERT(OffsetInPages + NumberOfPages <= Range->NumberOfPages);
    //
    // Make sure the supplied address is within the reserved range
    //
    if ((OffsetInPages >= Range->NumberOfPages) ||
        (OffsetInPages + NumberOfPages > Range->NumberOfPages)) {
        AGPLOG(AGP_WARNING,
               ("AgpInterfaceFreeMemory - Invalid free of %x pages at offset %x from range %I64X (%x pages)\n",
                NumberOfPages,
                OffsetInPages,
                Range->MemoryBase.QuadPart,
                Range->NumberOfPages));
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Allocate an MDL big enough to contain the pages to be unmapped.
    //
    FreeMdl = MmCreateMdl(NULL, 0, NumberOfPages * PAGE_SIZE);
    if (FreeMdl == NULL) {

        //
        // This is kind of a sticky situation. We can't allocate the memory
        // that we need to free up some memory! I guess we could have a small
        // MDL on our stack and free things that way.
        //
        // John Vert (jvert) 11/11/1997
        // implement this
        //
        // ISSUE-2000/09/06-enelson I've tried several AGP video cards, and 
        // not one of them uses AgpInterfaceCommit/FreeMemory, hence I'm
        // loathe to change this at this point...
        //

        ASSERT(FreeMdl != NULL);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    LOCK_MASTER(Extension);

    //
    // Get the MDL that describes the entire mapped range
    //
    AgpGetMappedPages(AgpContext, 
                      Range,
                      NumberOfPages,
                      OffsetInPages,
                      FreeMdl);
    //
    // Unmap the memory
    //
    Status = AgpUnMapMemory(AgpContext,
                            Range,
                            NumberOfPages,
                            OffsetInPages);
    UNLOCK_MASTER(Extension);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpInterfaceFreeMemory - UnMapMemory for %x pages at %I64X failed %08lx\n",
                NumberOfPages,
                Range->MemoryBase.QuadPart + OffsetInPages * PAGE_SIZE,
                Status));
    } else {
        //
        // Free the pages
        //
        MmFreePagesFromMdl(FreeMdl);
        ASSERT(Range->CommittedPages >= NumberOfPages);
        Range->CommittedPages -= NumberOfPages;
    }

    //
    // Free the MDL we allocated.
    //
    ExFreePool(FreeMdl);
    return(Status);
}

NTSTATUS
AgpInterfaceGetMappedPages(
    IN PMASTER_EXTENSION Extension,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT PMDL Mdl
    )
/*++

Routine Description:

    Returns the list of physical pages mapped backing the specified range.

Arguments:

    Extension - Supplies the device extension where physical address space should
        be freed.

    MapHandle - Supplies the mapping handle returned from AgpInterfaceReserveMemory

    NumberOfPages - Supplies the number of pages to be returned

    OffsetInPages - Supplies the start of the rangion

Return Value:

    NTSTATUS

--*/

{
    PAGP_RANGE Range = (PAGP_RANGE)MapHandle;
    PVOID AgpContext;
    NTSTATUS Status;

    PAGED_CODE();

    AgpContext = GET_AGP_CONTEXT_FROM_MASTER(Extension);

    ASSERT(NumberOfPages <= Range->NumberOfPages);
    ASSERT(NumberOfPages > 0);
    ASSERT(OffsetInPages < Range->NumberOfPages);
    ASSERT(OffsetInPages + NumberOfPages <= Range->NumberOfPages);
    ASSERT(Mdl->ByteCount == PAGE_SIZE * NumberOfPages);

    //
    // Make sure the supplied address is within the reserved range
    //
    if ((OffsetInPages >= Range->NumberOfPages) ||
        (OffsetInPages + NumberOfPages > Range->NumberOfPages)) {
        AGPLOG(AGP_WARNING,
               ("AgpInterfaceGetMappedPages - Invalid 'get' of %x pages at offset %x from range %I64X (%x pages)\n",
                NumberOfPages,
                OffsetInPages,
                Range->MemoryBase.QuadPart,
                Range->NumberOfPages));
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Get the MDL that describes the entire mapped range
    //
    LOCK_MASTER(Extension);

    AgpGetMappedPages(AgpContext, 
                      Range,
                      NumberOfPages,
                      OffsetInPages,
                      Mdl);

    UNLOCK_MASTER(Extension);
    return(STATUS_SUCCESS);
}


PMDL
AgpLibAllocatePhysicalMemory(IN PVOID AgpContext, IN ULONG TotalBytes)
/*++

Routine Description:

    Allocates a set of physical memory pages for use by the AGP driver.
    
    This routine uses MmAllocatePagesForMdl to attempt to allocate
    as many of the pages as possible within favored AGP memory
    ranges (if any).

Arguments:

    AgpContext   - The AgpContext

    TotalBytes   - The total amount of bytes to allocate.

Return Value:

    An MDL that describes the allocated physical pages or NULL
    if this function is unsuccessful. 
    
    NOTE: Just like MmAllocatePagesForMdl, this function can return
    an MDL that describes an allocation smaller than TotalBytes in size.

--*/
{
   PHYSICAL_ADDRESS ZeroAddress, MaxAddress;
   PMDL MdlList = NULL, NewMdl = NULL;
   PTARGET_EXTENSION Extension;
   ULONG i, PagesNeeded;

   PAGED_CODE();

   AGPLOG(AGP_NOISE, ("AGPLIB: Attempting to allocate memory = %u pages.\n", 
            BYTES_TO_PAGES(TotalBytes)));

   // Initialize some stuff

   ZeroAddress.QuadPart = 0;
   MAX_MEM(MaxAddress.QuadPart);
   
   AGPLOG(AGP_NOISE, ("AGPLIB: Max memory set to %I64x.\n", MaxAddress.QuadPart));

   GET_TARGET_EXTENSION(Extension, AgpContext);

   // How many pages do we need?

   PagesNeeded = BYTES_TO_PAGES(TotalBytes);

   //
   // Loop through each favored range, attempting to allocate
   // as much as possible from that range within the bounds
   // of what we actually need.
   //

   for (i = 0; i < Extension->FavoredMemory.NumRanges; i++) {
      AGPLOG(AGP_NOISE, 
             ("AGPLIB: Trying to allocate %u pages from range %I64x - %I64x.\n",
               PagesNeeded, 
               Extension->FavoredMemory.Ranges[i].Lower,               
               Extension->FavoredMemory.Ranges[i].Upper));      

      NewMdl = MmAllocatePagesForMdl(Extension->FavoredMemory.Ranges[i].Lower,
                                     Extension->FavoredMemory.Ranges[i].Upper,
                                     ZeroAddress,                                     
                                     PagesNeeded << PAGE_SHIFT);
      if (NewMdl) {
         AGPLOG(AGP_NOISE, ("AGPLIB: %u pages allocated in range.\n",
                  NewMdl->ByteCount >> PAGE_SHIFT));
         
         PagesNeeded -= (NewMdl->ByteCount >> PAGE_SHIFT);
         
         //
         // Build a list of the MDls used
         // for each range-based allocation
         //

         NewMdl->Next = MdlList;
         MdlList = NewMdl;

         // Stop allocating if we are finished.

         if (PagesNeeded == 0) break;
         

      } else {
         AGPLOG(AGP_NOISE, ("AGPLIB: NO pages allocated in range.\n"));
      }
      
   }

   //
   // Attempt to allocate from ALL of physical memory
   // if we could not complete our allocation with only
   // the favored memory ranges.
   //

   if (PagesNeeded > 0) {

      AGPLOG(AGP_NOISE, ("AGPLIB: Global Memory allocation for %u pages.\n", 
               PagesNeeded));

      NewMdl = MmAllocatePagesForMdl(ZeroAddress,
                                     MaxAddress,
                                     ZeroAddress,
                                     PagesNeeded << PAGE_SHIFT);
      if (NewMdl) {

         AGPLOG(AGP_NOISE, ("AGPLIB: Good Global Memory Alloc for %u pages.\n",
                  NewMdl->ByteCount >> PAGE_SHIFT));

         //
         // Add this MDL to the list as well
         //

         NewMdl->Next = MdlList;
         MdlList = NewMdl;
      } else {

         AGPLOG(AGP_NOISE, ("AGPLIB: Failed Global Memory Alloc.\n"));

      }

   }

   // We now have a list of Mdls in MdlList that give us the best
   // possible memory allocation taking favored ranges into account.

   // What we now need to do is combine this Mdl list into one mdl.

   NewMdl = AgpCombineMdlList(MdlList);

   if (!NewMdl && MdlList) {
      AGPLOG(AGP_WARNING, ("AGPLIB: Could not combine MDL List!\n"));

      // This is bad. The mdl list could not be combined probably 
      // because a large enough mdl could not be allocated for 
      // the combination.

      // This is not the end of the world however, since the mdl list
      // is not modified until its combination has succeeded so we 
      // still have a valid list. But we need it in one Mdl, so 
      // we just fall back to the simplest allocation strategy
      // we have available:

      // 1. Destroy the list and all of its allocations.
      
      while(MdlList)
      {
         MmFreePagesFromMdl(MdlList);
         NewMdl = MdlList->Next;
         ExFreePool(MdlList);
         MdlList = NewMdl;
      }

      // 2. Allocate a single Mdl with our pages without regard
      // for favored memory ranges. 

      NewMdl = MmAllocatePagesForMdl(ZeroAddress, 
                                     MaxAddress,
                                     ZeroAddress,
                                     TotalBytes);

   }

   return NewMdl;

   
}

PMDL
AgpCombineMdlList(IN PMDL MdlList)
/*++

Routine Description:

    Combines a list of MDLs that describe some set of physical memory
    pages into a single MDL that describes the same set of pages.
    
    The MDLs in the list should be of the type produced by
    MmAllocatePagesForMdl (i.e. MDLs that are useful for nothing more
    than as an array of PFNs)

    This function is used by AgpLibAllocatePhysicalMemory in order
    to combine its multiple range-based allocations into 1 MDL.
    
Arguments:

    MdlList - A list of MDLs to be combines

Return Value:

    A single MDL that describes the same set of physical pages as
    the MDLs in MdlList or NULL if this function is unsuccessful.
    
    NOTE: This function will deallocate the Mdls in MdlList if it
    is successful. If it is unsuccessful, however, it will leave
    the MdlList intact.

--*/
{
   PMDL NewMdl = NULL, Mdl, MdlTemp;
   ULONG Pages = 0;
   PPFN_NUMBER NewPageArray, PageArray;

   ULONG i; // for debugging only

   PAGED_CODE();

   if ((MdlList == NULL) || (MdlList->Next == NULL)) {

      // List of 0 or 1 elements, no need for this 
      // function to do anything.

      return MdlList;
   }

   // Calculate the number of pages spanned by this MdlList.

   for(Mdl = MdlList; Mdl; Mdl = Mdl->Next)
      Pages += BYTES_TO_PAGES(Mdl->ByteCount);

   // Allocate a new Mdl of the proper size.

   NewMdl = MmCreateMdl(NULL, NULL, Pages << PAGE_SHIFT);

   if (!NewMdl) {

      // Chances are that the system will bugcheck before
      // this actually happens ... but whatever.

      return NULL;
   }

   // Run through the mdl list, combining the mdls found
   // into a new mdl.

   //
   // First, get a pointer to the PFN array of the new Mdl
   //

   NewPageArray = MmGetMdlPfnArray(NewMdl);

   for(Mdl = MdlList; Mdl; Mdl = Mdl->Next)
   {
      // Get a pointer to the physical page number array in this Mdl.

      PageArray = MmGetMdlPfnArray(Mdl);
      Pages = Mdl->ByteCount >> PAGE_SHIFT;

      // Copy this array into a proper slot in the array area of the new Mdl.

      RtlCopyMemory((PVOID)NewPageArray, 
                    (PVOID)PageArray,
                    sizeof(PFN_NUMBER) * Pages);

      // Adjust new array slot pointer appropriately for the next copy

      NewPageArray += Pages;
         
   }

   // The list has been combined, now we need to destroy the Mdls
   // in the list.

   Mdl = MdlList;
   while(Mdl)
   {
      MdlTemp = Mdl->Next;
      ExFreePool(Mdl);
      Mdl = MdlTemp;
   }

   // All done. Return the new combined Mdl.

   return NewMdl;
}


PVOID
AgpLibAllocateMappedPhysicalMemory(IN PVOID AgpContext, IN ULONG TotalBytes)
/*++

Routine Description:

    Same as AgpLibAllocatePhysicalMemory, except this function will
    also map the allocated memory to a virtual address.

Arguments:

    Same as AgpLibAllocatePhysicalMemory.

Return Value:

    A virtual address of the allocated memory or NULL if unsuccessful.

--*/
{
   PMDL Mdl;
   PVOID Ret;

   PAGED_CODE();
   
   AGPLOG(AGP_NOISE, 
          ("AGPLIB: Attempting to allocate mapped memory = %u.\n", TotalBytes));

   //
   // Call the real memory allocator.
   //
   
   Mdl = AgpLibAllocatePhysicalMemory(AgpContext, TotalBytes);

   // Two possible failures 

   // 1. MDL is NULL. No memory could be allocated.

   if (Mdl == NULL) {

      AGPLOG(AGP_WARNING, ("AGPMAP: Could not allocate anything.\n"));

      return NULL;
   }

   // 2. MDL has some pages allocated but not enough.

   if (Mdl->ByteCount < TotalBytes) {

      AGPLOG(AGP_WARNING, ("AGPMAP: Could not allocate enough.\n"));

      MmFreePagesFromMdl(Mdl);
      ExFreePool(Mdl);
      return NULL;
   }

   // Ok. Our allocation succeeded. Map it to a virtual address.
   
   // Step 1: Map the locked Pages. (will return NULL if failed)

   Mdl->MdlFlags |= MDL_PAGES_LOCKED;
   Ret = MmMapLockedPagesSpecifyCache (Mdl,
                                         KernelMode,
                                         MmNonCached,
                                         NULL,
                                         FALSE,
                                         HighPagePriority);

   // Don't need the Mdl anymore, whether we succeeded or failed. 

   ExFreePool(Mdl);

   if (Ret == NULL) {
      AGPLOG(AGP_WARNING, ("AGPMAP: Could not map.\n"));
   } 

   return Ret;
}

#if defined (_X86_)
#define FLUSH_DCACHE(Mdl) __asm{ wbinvd }
#else
#define FLUSH_DCACHE(Mdl)   \
            AGPLOG(AGP_CRITICAL,    \
                   ("AgpLibFlushDcacheMdl - NEED TO IMPLEMENT DCACHE FLUSH FOR THIS ARCHITECTURE!!\n"))
#endif


VOID
AgpLibFlushDcacheMdl(
    PMDL Mdl
    )
/*++

Routine Description:

    Flushes the specified MDL from the D-caches of all processors
    in the system.

    Current algorithm is to set the current thread's affinity to each 
    processor in turn and flush the dcache. This could be made a lot
    more efficient if this turns out to be a hot codepath
    
Arguments:

    Mdl - Supplies the MDL to be flushed.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    KAFFINITY Processors;
    UCHAR Number;
    KEVENT Event;
    KDPC Dpc;

    PAGED_CODE();
    Processors = KeQueryActiveProcessors();
    //
    // Quick out for the UP case.
    //
    if (Processors == 1) {
        FLUSH_DCACHE(Mdl);
        return;
    }

    //
    // We will invoke a DPC on each processor. That DPC will flush the cache,
    // set the event and return. 
    //
    KeInitializeEvent(&Event, NotificationEvent, FALSE);

    Number = 0;
    while (Processors) {
        if (Processors & 1) {
            //
            // Initialize the DPC and set it to run on the specified
            // processor.
            //
            KeInitializeDpc(&Dpc,ApFlushDcache, &Event);
            KeSetTargetProcessorDpc(&Dpc, Number);

            //
            // Queue the DPC and wait for it to finish its work.
            //
            KeClearEvent(&Event);
            KeInsertQueueDpc(&Dpc, Mdl, NULL);
            KeWaitForSingleObject(&Event, 
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
        }
        Processors = Processors >> 1;
        ++Number;
    }
}



VOID
ApFlushDcache(
    IN PKDPC Dpc,
    IN PKEVENT Event,
    IN PMDL Mdl,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    DPC which executes on each processor in turn to flush the
    specified MDL out of the dcache on each.

Arguments:

    Dpc - supplies the DPC object

    Event - Supplies the event to signal when the DPC is complete

    Mdl - Supplies the MDL to be flushed from the dcache

Return Value:

    None

--*/

{
    FLUSH_DCACHE(Mdl);
    KeSetEvent(Event, 0, FALSE);
}


NTSTATUS
AgpInterfaceSetRate(
    IN PMASTER_EXTENSION Extension,
    IN ULONG AgpRate
    )
/*++

Routine Description:

    This routine sets the AGP rate

Arguments:

    Extension - Supplies the device extension

    AgpRate - Rate to set

Return Value:

    STATUS_SUCCESS, or error status

--*/
{
    ULONGLONG DeviceFlags = 0;

    PAGED_CODE();

    switch (AgpRate) {
        case PCI_AGP_RATE_1X:
            DeviceFlags = AGP_FLAG_SET_RATE_1X;
            break;
        case PCI_AGP_RATE_2X:
            DeviceFlags = AGP_FLAG_SET_RATE_2X;
            break;
        case PCI_AGP_RATE_4X:
            DeviceFlags = AGP_FLAG_SET_RATE_4X;
            break;
        case 8:
            DeviceFlags = AGP_FLAG_SET_RATE_8X;
            break;
    }

    if (DeviceFlags != 0) {
        return AgpSpecialTarget(GET_AGP_CONTEXT_FROM_MASTER(Extension),
                                DeviceFlags);
    }

    return STATUS_INVALID_PARAMETER;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\agp\agplib\dispatch.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

    IRP dispatching routines for the common AGPLIB library

Author:

    John Vert (jvert) 10/25/1997

Revision History:

   Elliot Shmukler (elliots) 3/24/1999 - Added support for "favored" memory
                                          ranges for AGP physical memory allocation,
                                          fixed some bugs.

--*/
#include "agplib.h"

//
// Two flavors of each dispatch routine, one for the target (AGP bridge) filter and
// one for the master (video card) filter.
//

NTSTATUS
AgpTargetDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    IN PTARGET_EXTENSION Extension
    );

NTSTATUS
AgpMasterDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    IN PMASTER_EXTENSION Extension
    );

NTSTATUS
AgpTargetDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    IN PTARGET_EXTENSION Extension
    );

NTSTATUS
AgpMasterDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    IN PMASTER_EXTENSION Extension
    );

NTSTATUS
AgpCancelMasterRemove(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PMASTER_EXTENSION Extension
    );

NTSTATUS
AgpMasterPowerUpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PMASTER_EXTENSION Extension
    );

NTSTATUS
AgpTargetPowerUpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AgpDispatchPnp)
#pragma alloc_text(PAGE, AgpDispatchDeviceControl)
#pragma alloc_text(PAGE, AgpDispatchWmi)
#pragma alloc_text(PAGE, AgpTargetDispatchPnp)
#pragma alloc_text(PAGE, AgpMasterDispatchPnp)
#pragma alloc_text(PAGE, AgpCancelMasterRemove)
#endif



NTSTATUS
AgpDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    Main dispatch routine for PNP irps sent to the AGP bus filter driver

Arguments:

    DeviceObject - Supplies the AGP device object

    Irp - Supplies the PNP Irp.

Return Value:

    NTSTATUS

--*/
{
    PCOMMON_EXTENSION Extension = DeviceObject->DeviceExtension;

    PAGED_CODE();

    //
    // We're deleted, fail the irp
    //
    if (Extension->Deleted == TRUE) {
        Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DELETE_PENDING;
    }

    ASSERT(Extension->AttachedDevice != NULL);

    if (Extension->Type == AgpTargetFilter) {
        return(AgpTargetDispatchPnp(DeviceObject,
                                    Irp,
                                    DeviceObject->DeviceExtension));
    } else {
        ASSERT(Extension->Type == AgpMasterFilter);
        return(AgpMasterDispatchPnp(DeviceObject,
                                    Irp,
                                    DeviceObject->DeviceExtension));
    }
}


NTSTATUS
AgpDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    Main dispatch routine for power irps sent to the AGP bus filter driver

Arguments:

    DeviceObject - Supplies the AGP device object

    Irp - Supplies the power Irp.

Return Value:

    NTSTATUS

--*/
{
    PCOMMON_EXTENSION Extension = DeviceObject->DeviceExtension;

    //
    // We're deleted, fail the irp
    //
    if (Extension->Deleted == TRUE) {
        Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        PoStartNextPowerIrp(Irp);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DELETE_PENDING;
    }

    ASSERT(Extension->AttachedDevice != NULL);

   if (Extension->Type == AgpTargetFilter) {
        return(AgpTargetDispatchPower(DeviceObject,
                                      Irp,
                                      DeviceObject->DeviceExtension));
    } else {
        ASSERT(Extension->Type == AgpMasterFilter);
        return(AgpMasterDispatchPower(DeviceObject,
                                      Irp,
                                      DeviceObject->DeviceExtension));
    }
}


NTSTATUS
AgpTargetDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    IN PTARGET_EXTENSION Extension
    )
/*++

Routine Description:

    Dispatch routine for PNP irps sent to the AGP bus filter driver
    attached to the target (AGP bridge) PDO.

Arguments:

    DeviceObject - Supplies the AGP target device object

    Irp - Supplies the PNP Irp.

    Extension - Supplies the AGP target device extension

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status = STATUS_NOT_SUPPORTED;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );

    PAGED_CODE();

    // AGPLOG(AGP_IRPTRACE,
           // ("AgpTargetDispatchPnp: IRP 0x%x\n", irpStack->MinorFunction));

    switch (irpStack->MinorFunction) {
        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
            AGPLOG(AGP_NOISE,
                   ("AgpTargetDispatchPnp: IRP_MN_FILTER_RESOURCE_REQUIREMENTS to %08lx\n",
                    DeviceObject));

            Status = AgpFilterResourceRequirements(DeviceObject, Irp, Extension);
            break;

        case IRP_MN_QUERY_RESOURCES:
            AGPLOG(AGP_NOISE,
                   ("AgpTargetDispatchPnp: IRP_MN_QUERY_RESOURCES to %08lx\n",
                    DeviceObject));

            //
            // We must handle this IRP on the way back so we can add the AGP
            // resources on to it. Set a completion routine.
            //
            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine(Irp,
                                   AgpQueryResources,
                                   Extension,
                                   TRUE,
                                   FALSE,
                                   FALSE);
            Status = IoCallDriver(Extension->CommonExtension.AttachedDevice, Irp);
            return Status ;

        case IRP_MN_QUERY_DEVICE_RELATIONS:
            if (irpStack->Parameters.QueryDeviceRelations.Type == BusRelations) {
                KEVENT event;

                KeInitializeEvent(&event, NotificationEvent, FALSE);

                //
                // We must handle this IRP on the way back so that we can attach
                // a filter to any child PDOs of our PCI-PCI bridge.
                //
                IoCopyCurrentIrpStackLocationToNext(Irp);
                IoSetCompletionRoutine(Irp,
                                       AgpSetEventCompletion,
                                       &event,
                                       TRUE,
                                       TRUE,
                                       TRUE);

                Status = IoCallDriver(Extension->CommonExtension.AttachedDevice, Irp);

                //
                // If we did things asynchronously then wait on our event
                //
                if (Status == STATUS_PENDING) {

                    //
                    // We do a KernelMode wait so that our stack where the
                    // event is doesn't get paged out!
                    //
                    KeWaitForSingleObject(&event,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          NULL);
                    Status = Irp->IoStatus.Status;
                }

                if (NT_SUCCESS(Status)) {
                    Status = AgpAttachDeviceRelations(DeviceObject,
                                                      Irp,
                                                      Extension);
                    Irp->IoStatus.Status = Status;
                }

                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                return Status;

            } else {
                break;
            }

        case IRP_MN_START_DEVICE:
            //
            // We need to hook this in order to filter out any AGP
            // resources that have been added.
            //
            return(AgpStartTarget(Irp, Extension));

        case IRP_MN_QUERY_REMOVE_DEVICE:
        case IRP_MN_QUERY_STOP_DEVICE:
        case IRP_MN_CANCEL_REMOVE_DEVICE:

            //
            // We can always succeed this.
            //
            Status = STATUS_SUCCESS;
            break;

        case IRP_MN_REMOVE_DEVICE:
            AgpDisableAperture(GET_AGP_CONTEXT(Extension));

            //
            // Pass the irp down
            //
            IoSkipCurrentIrpStackLocation(Irp);
            Status = IoCallDriver(Extension->CommonExtension.AttachedDevice, Irp);

            //
            // Clean up and delete ourselves
            //
            Extension->CommonExtension.Deleted = TRUE;
            IoDetachDevice(Extension->CommonExtension.AttachedDevice);
            Extension->CommonExtension.AttachedDevice = NULL;
            RELEASE_BUS_INTERFACE(Extension);
            if (Extension->FavoredMemory.Ranges) {
               ExFreePool(Extension->FavoredMemory.Ranges);
            }
            if (Extension->Resources) {
                ExFreePool(Extension->Resources);
            }
            if (Extension->ResourcesTranslated) {
                ExFreePool(Extension->ResourcesTranslated);
            }
            ExFreePool(Extension->Lock);;
            IoDeleteDevice(DeviceObject);
            return(Status);

        case IRP_MN_STOP_DEVICE:
            AgpDisableAperture(GET_AGP_CONTEXT(Extension));
            Status = STATUS_SUCCESS;
            break;  // forward irp down the stack

    }

    ASSERT(Status != STATUS_PENDING);

    if (Status != STATUS_NOT_SUPPORTED) {

        Irp->IoStatus.Status = Status;
    }

    if (NT_SUCCESS(Status) || (Status == STATUS_NOT_SUPPORTED)) {

        //
        // Forward IRP to PCI driver
        //
        IoSkipCurrentIrpStackLocation(Irp);
        return(IoCallDriver(Extension->CommonExtension.AttachedDevice, Irp));

    } else {

        Status = Irp->IoStatus.Status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT) ;
        return Status ;
    }
}


NTSTATUS
AgpDispatchDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    Main dispatch routine for device control irps sent to the AGP bus filter driver

    AGP currently does not support any device controls. So we just pass everything
    down and hope the PDO knows what to do with it.

Arguments:

    DeviceObject - Supplies the AGP device object

    Irp - Supplies the power Irp.

Return Value:

    NTSTATUS

--*/
{
    PCOMMON_EXTENSION Extension = DeviceObject->DeviceExtension;
    PAGED_CODE();

    //
    // We're deleted, fail the irp
    //
    if (Extension->Deleted == TRUE) {
        Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DELETE_PENDING;
    }

    ASSERT(Extension->AttachedDevice != NULL);

    IoSkipCurrentIrpStackLocation(Irp);
    return(IoCallDriver(Extension->AttachedDevice, Irp));
}


NTSTATUS
AgpDispatchWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    Main dispatch routine for system control irps sent to the AGP bus filter
    driver.

    AGP currently does not support any WMI IRPs, so we just pass everything
    down and hope the PDO knows what to do with it.

Arguments:

    DeviceObject - Supplies the AGP device object

    Irp - Supplies the power Irp.

Return Value:

    NTSTATUS

--*/
{
    PCOMMON_EXTENSION Extension = DeviceObject->DeviceExtension;
    PAGED_CODE();

    //
    // We're deleted, fail the irp
    //
    if (Extension->Deleted == TRUE) {
        Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DELETE_PENDING;
    }

    ASSERT(Extension->AttachedDevice != NULL);

    IoSkipCurrentIrpStackLocation(Irp);
    return(IoCallDriver(Extension->AttachedDevice, Irp));
}


NTSTATUS
AgpTargetDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    IN PTARGET_EXTENSION Extension
    )
{
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );

    AGPLOG(AGP_IRPTRACE,
           ("AgpTargetDispatchPower: IRP 0x%x\n", irpStack->MinorFunction));

    //
    // All we keep track of are Dx states. PCI is responsible for mapping
    // S-states into D states.
    //


    if ((irpStack->MinorFunction == IRP_MN_SET_POWER) &&
        (irpStack->Parameters.Power.Type == DevicePowerState) &&
        (irpStack->Parameters.Power.State.DeviceState == PowerDeviceD0)) {

        NTSTATUS Status;

        //
        // We need to reinitialize the target when this IRP has been completed
        // by the lower drivers. Set up our completion handler to finish this.
        //
        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp,
                               AgpTargetPowerUpCompletion,
                               Extension,
                               TRUE,
                               FALSE,
                               FALSE);

        IoMarkIrpPending(Irp);
        PoStartNextPowerIrp(Irp);
        Status = PoCallDriver(Extension->CommonExtension.AttachedDevice, Irp);
        return STATUS_PENDING;
    }
    //
    // Just forward to target device
    //
    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);
    return(PoCallDriver(Extension->CommonExtension.AttachedDevice, Irp));
}


NTSTATUS
AgpMasterDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    IN PMASTER_EXTENSION Extension
    )
/*++

Routine Description:

    Dispatch routine for PNP irps sent to the AGP bus filter driver
    attached to the device PDOs.

Arguments:

    DeviceObject - Supplies the AGP device object

    Irp - Supplies the PNP Irp.

    Extension - Supplies the AGP bridge device extension

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );
    PAGP_BUS_INTERFACE_STANDARD Interface;
    NTSTATUS Status;

    PAGED_CODE();

    AGPLOG(AGP_IRPTRACE,
           ("AgpMasterDispatchPnp: IRP 0x%x\n", irpStack->MinorFunction));

    switch (irpStack->MinorFunction) {
        case IRP_MN_QUERY_INTERFACE:

#if 0
            AGPLOG(AGP_IRPTRACE,
                   ("\tSize=0x%x, Version=%d\n"
                    "\tGUID=0x%08x-0x%04x-0x%04x-0x%02x-"
                    "0x%02x-0x%02x-0x%02x-0x%02x-0x%02x-0x%02x-0x%02x\n",
                    irpStack->Parameters.QueryInterface.Size,
                    irpStack->Parameters.QueryInterface.Version,
                    *(PULONG)irpStack->Parameters.QueryInterface.InterfaceType,
                    *((PUSHORT)irpStack->Parameters.QueryInterface.InterfaceType + 2),
                    *((PUSHORT)irpStack->Parameters.QueryInterface.InterfaceType + 3),
                    *((PUCHAR)irpStack->Parameters.QueryInterface.InterfaceType + 8),
                    *((PUCHAR)irpStack->Parameters.QueryInterface.InterfaceType + 9),
                    *((PUCHAR)irpStack->Parameters.QueryInterface.InterfaceType + 10),

                    *((PUCHAR)irpStack->Parameters.QueryInterface.InterfaceType + 11),
                    *((PUCHAR)irpStack->Parameters.QueryInterface.InterfaceType + 12),
                    *((PUCHAR)irpStack->Parameters.QueryInterface.InterfaceType + 13),
                    *((PUCHAR)irpStack->Parameters.QueryInterface.InterfaceType + 14),
                    *((PUCHAR)irpStack->Parameters.QueryInterface.InterfaceType + 15)));

#endif

            //
            // The only IRP we look for here is IRP_MN_QUERY_INTERFACE for
            // GUID_AGP_BUS_INTERFACE_STANDARD.
            //
            if ((RtlEqualMemory(
                irpStack->Parameters.QueryInterface.InterfaceType,
                &GUID_AGP_BUS_INTERFACE_STANDARD,
                sizeof(GUID))) &&
                (((irpStack->Parameters.QueryInterface.Size >=
                   sizeof(AGP_BUS_INTERFACE_STANDARD)) &&
                  (irpStack->Parameters.QueryInterface.Version ==
                   AGP_BUS_INTERFACE_V2)) ||
                 ((irpStack->Parameters.QueryInterface.Size >=
                   AGP_BUS_INTERFACE_V1_SIZE) &&
                  (irpStack->Parameters.QueryInterface.Version ==
                   AGP_BUS_INTERFACE_V1)))) {

                Interface = (PAGP_BUS_INTERFACE_STANDARD)irpStack->Parameters.QueryInterface.Interface;

                Interface->Version =
                    irpStack->Parameters.QueryInterface.Version;
                Interface->AgpContext = Extension;
                Interface->InterfaceReference = AgpInterfaceReference;
                Interface->InterfaceDereference = AgpInterfaceDereference;
                Interface->ReserveMemory = AgpInterfaceReserveMemory;
                Interface->ReleaseMemory = AgpInterfaceReleaseMemory;
                Interface->CommitMemory = AgpInterfaceCommitMemory;
                Interface->FreeMemory = AgpInterfaceFreeMemory;
                Interface->GetMappedPages = AgpInterfaceGetMappedPages;

                if (Interface->Version < AGP_BUS_INTERFACE_V2) {
                    Interface->Size = AGP_BUS_INTERFACE_V1_SIZE;
                } else {
                    Interface->Size = sizeof(AGP_BUS_INTERFACE_STANDARD);
                    Interface->SetRate = AgpInterfaceSetRate;
                }

                Interface->Capabilities = Extension->Capabilities;

                //
                // Complete the IRP successfully
                //
                Irp->IoStatus.Status = STATUS_SUCCESS;

                // AGPLOG(AGP_IRPTRACE, ("\tOK.\n"));
            } // else { AGPLOG(AGP_IRPTRACE, ("\tNO!\n")); }
            break;

        case IRP_MN_QUERY_REMOVE_DEVICE:
        case IRP_MN_QUERY_STOP_DEVICE:
            if (irpStack->MinorFunction == IRP_MN_QUERY_REMOVE_DEVICE) {
                Extension->RemovePending = TRUE;
            } else {
                Extension->StopPending = TRUE;
            }
            //
            // If we have given out any interfaces or there are some reserved
            // pages, we cannot stop.
            //
            if ((Extension->InterfaceCount > 0) ||
                (Extension->ReservedPages > 0)) {
                AGPLOG(AGP_NOISE,
                       ("AgpMasterDispatchPnp: failing %s due to outstanding interfaces\n",
                        (irpStack->MinorFunction == IRP_MN_QUERY_REMOVE_DEVICE)
                            ? "IRP_MN_QUERY_REMOVE_DEVICE"
                            : "IRP_MN_QUERY_STOP_DEVICE"
                       ));

                Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                return(STATUS_UNSUCCESSFUL);
            } else {
                //
                // We can succeed this, mark our extension as being in limbo so we do
                // not give out any interfaces or anything until we get removed or
                // get a cancel.
                //
                InterlockedIncrement(&Extension->DisableCount);
                break;  // forward irp down the stack
            }

        case IRP_MN_CANCEL_REMOVE_DEVICE:
            //
            // This IRP must be handled on the way back up the stack.
            // Set a completion routine to reenable the device.
            //
            if (Extension->RemovePending) {
                Extension->RemovePending = FALSE;
                IoCopyCurrentIrpStackLocationToNext(Irp);
                IoSetCompletionRoutine(Irp,
                                       AgpCancelMasterRemove,
                                       Extension,
                                       TRUE,
                                       FALSE,
                                       FALSE);
                return(IoCallDriver(Extension->CommonExtension.AttachedDevice, Irp));
            } else {
                //
                // This is a cancel-remove for a query-remove IRP we never saw.
                // Ignore it.
                //
                break;
            }

        case IRP_MN_CANCEL_STOP_DEVICE:
            //
            // This IRP must be handled on the way back up the stack.
            // Set a completion routine to reenable the device.
            //
            if (Extension->StopPending) {
                Extension->StopPending = FALSE;
                IoCopyCurrentIrpStackLocationToNext(Irp);
                IoSetCompletionRoutine(Irp,
                                       AgpCancelMasterRemove,
                                       Extension,
                                       TRUE,
                                       FALSE,
                                       FALSE);
                return(IoCallDriver(Extension->CommonExtension.AttachedDevice, Irp));
            } else {
                //
                // This is a cancel-stop for a query-stop IRP we never saw.
                // Ignore it.
                //
                break;
            }

        case IRP_MN_REMOVE_DEVICE:
            AGPLOG(AGP_NOISE,
                   ("AgpMasterDispatchPnp: removing device due to IRP_MN_REMOVE_DEVICE\n"));

            //
            // PNP is supposed to send us a QUERY_REMOVE before any REMOVE. That is
            // when we check that we are actually in a state where we can be removed.
            // Like all PNP rules, there is an exception - if the START is failed
            // after we have succeeded it, then we get a REMOVE without a QUERY_REMOVE.
            // Obviously this is totally fatal if we have given out interfaces or
            // have pages mapped in the GART. Not much we can do about it then.
            //
            ASSERT(Extension->InterfaceCount == 0);
            ASSERT(Extension->ReservedPages == 0);

            //
            // Pass the IRP down.
            //
            IoSkipCurrentIrpStackLocation(Irp);
            Status = IoCallDriver(Extension->CommonExtension.AttachedDevice, Irp);

            //
            // Clean up and delete ourselves
            //
            Extension->Target->ChildDevice = NULL;
            Extension->CommonExtension.Deleted = TRUE;
            IoDetachDevice(Extension->CommonExtension.AttachedDevice);
            Extension->CommonExtension.AttachedDevice = NULL;
            RELEASE_BUS_INTERFACE(Extension);
            IoDeleteDevice(DeviceObject);
            return(Status);

        case IRP_MN_STOP_DEVICE:
            AGPLOG(AGP_NOISE,
                   ("AgpMasterDispatchPnp: stopping device due to IRP_MN_STOP_DEVICE\n"));
            ASSERT(Extension->DisableCount);

            //
            // Just pass the IRP on down
            //
            break;

        case IRP_MN_START_DEVICE:
            AGPLOG(AGP_NOISE,
                   ("AgpMasterDispatchPnp: starting device due to IRP_MN_START_DEVICE\n"));
            ASSERT(Extension->DisableCount);
            InterlockedDecrement(&Extension->DisableCount);
            break;  // forward IRP down the stack
    }

    //
    // Just forward to target device
    //
    IoSkipCurrentIrpStackLocation(Irp);
    return(IoCallDriver(Extension->CommonExtension.AttachedDevice, Irp));
}

NTSTATUS
AgpMasterDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    IN PMASTER_EXTENSION Extension
    )
{
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation( Irp );

    AGPLOG(AGP_IRPTRACE,
           ("AgpMasterDispatchPower: IRP 0x%x\n", irpStack->MinorFunction));

    //
    // All we keep track of are Dx states. Videoport is responsible for mapping
    // S-states into D states.
    //
    if ((irpStack->MinorFunction == IRP_MN_SET_POWER) &&
        (irpStack->Parameters.Power.Type == DevicePowerState) &&
        (irpStack->Parameters.Power.State.DeviceState == PowerDeviceD0)) {

        NTSTATUS Status;

        //
        // We need to reinitialize the master when this IRP has been completed
        // by the lower drivers. Set up a completion routine.
        //
        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp,
                               AgpMasterPowerUpCompletion,
                               Extension,
                               TRUE,
                               FALSE,
                               FALSE);

        IoMarkIrpPending(Irp);
        PoStartNextPowerIrp(Irp);
        Status = PoCallDriver(Extension->CommonExtension.AttachedDevice, Irp);
        return STATUS_PENDING;
    }

    //
    // Just forward to target device
    //
    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);
    return(PoCallDriver(Extension->CommonExtension.AttachedDevice, Irp));
}


NTSTATUS
AgpMasterPowerUpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PMASTER_EXTENSION Extension
    )
/*++

Routine Description:

    Powerup completion routine for the master device. It reinitializes the
    master registers.

Arguments:

    DeviceObject - supplies the master device object.

    Irp - Supplies the IRP_MN_SET_POWER irp.

    Extension - Supplies the master extension

Return Value:

    Status

--*/

{
    NTSTATUS Status;
    ULONG CurrentCapabilities;

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    Status = AgpInitializeMaster(GET_AGP_CONTEXT_FROM_MASTER(Extension),
                                 &CurrentCapabilities);
    ASSERT(CurrentCapabilities == Extension->Capabilities);
    if (!NT_SUCCESS(Status)) {
        Irp->IoStatus.Status = Status;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
AgpTargetPowerUpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    )
/*++

Routine Description:

    Powerup completion routine for the target device. It reinitializes the
    GART aperture

Arguments:

    DeviceObject - supplies the master device object.

    Irp - Supplies the IRP_MN_SET_POWER irp.

    Extension - Supplies the target extension

Return Value:

    Status

--*/

{
    NTSTATUS Status;

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    //
    // Now it is safe to reinitialize the target. All we do here
    // is reset the aperture
    //
    if (Extension->GartLengthInPages != 0) {
        Status = AgpSetAperture(GET_AGP_CONTEXT(Extension),
                                Extension->GartBase,
                                Extension->GartLengthInPages);
        if (!NT_SUCCESS(Status)) {
            Irp->IoStatus.Status = Status;
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
AgpCancelMasterRemove(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PMASTER_EXTENSION Extension
    )
/*++

Routine Description:

    Completion routine for IRP_MN_CANCEL_REMOVE_DEVICE. This is required
    since we cannot reenable AGP until the lower levels have completed their
    CANCEL_REMOVE processing.

Arguments:

    DeviceObject - Supplies the device object

    Irp - Supplies the IRP

    Extension - Supplies the master extension

Return Value:

    NTSTATUS

--*/

{
    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    ASSERT(Extension->DisableCount > 0);
    InterlockedDecrement(&Extension->DisableCount);
    return(STATUS_SUCCESS);
}


NTSTATUS
AgpSetEventCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )
/*++

Routine Description:

    This routine is used as a completion routine when an IRP is passed
    down the stack but more processing must be done on the way back up.
    The effect of using this as a completion routine is that the IRP
    will not be destroyed in IoCompleteRequest as called by the lower
    level object.  The event which is a KEVENT is signaled to allow
    processing to continue

Arguments:

    DeviceObject - Supplies the device object

    Irp - The IRP we are processing

    Event - Supplies the event to be signaled

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/

{
    ASSERT(Event);

    //
    // This can be called at DISPATCH_LEVEL so must not be paged
    //
    KeSetEvent(Event, IO_NO_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\agp\agplib\config.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    config.c

Abstract:

    Routines for accessing config space in the PCI-PCI bridge

Author:

    John Vert (jvert) 10/27/1997

Revision History:

--*/
#include "agplib.h"

typedef struct _BUS_SLOT_ID {
    ULONG BusId;
    ULONG SlotId;
} BUS_SLOT_ID, *PBUS_SLOT_ID;

//
// Local function prototypes
//
NTSTATUS
ApGetSetDeviceBusData(
    IN PCOMMON_EXTENSION Extension,
    IN BOOLEAN Read,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

NTSTATUS
ApGetSetBusData(
    IN PBUS_SLOT_ID BusSlotId,
    IN BOOLEAN Read,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

NTSTATUS
ApFindAgpCapability(
    IN PAGP_GETSET_CONFIG_SPACE pConfigFn,
    IN PVOID Context,
    OUT PPCI_AGP_CAPABILITY Capability,
    OUT UCHAR *pOffset,
    OUT PPCI_COMMON_CONFIG PciCommonConfig OPTIONAL
    );


NTSTATUS
ApQueryBusInterface(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PBUS_INTERFACE_STANDARD BusInterface
    )
/*++

Routine Description:

    Sends a query-interface IRP to the specified device object
    to obtain the BUS_INTERFACE_STANDARD interface.

Arguments:

    DeviceObject - Supplies the device object to send the BUS_INTERFACE_STANDARD to

    BusInterface - Returns the bus interface

Return Value:

    STATUS_SUCCESS if successful
    NTSTATUS if unsuccessful

--*/

{
    PIRP Irp;
    KEVENT Event;
    PIO_STACK_LOCATION IrpSp;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    ULONG ReturnLength;

    KeInitializeEvent( &Event, NotificationEvent, FALSE );
    Irp = IoBuildSynchronousFsdRequest( IRP_MJ_PNP,
                                        DeviceObject,
                                        NULL,
                                        0,
                                        NULL,
                                        &Event,
                                        &IoStatusBlock );
    if (Irp == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    IrpSp = IoGetNextIrpStackLocation( Irp );
    ASSERT(IrpSp != NULL);
    Irp->IoStatus.Status = STATUS_NOT_SUPPORTED ;
    IrpSp->MajorFunction = IRP_MJ_PNP;
    IrpSp->MinorFunction = IRP_MN_QUERY_INTERFACE;
    IrpSp->Parameters.QueryInterface.InterfaceType = (LPGUID)&GUID_BUS_INTERFACE_STANDARD;
    IrpSp->Parameters.QueryInterface.Size = sizeof(BUS_INTERFACE_STANDARD);
    IrpSp->Parameters.QueryInterface.Version = 1;
    IrpSp->Parameters.QueryInterface.Interface = (PINTERFACE) BusInterface;
    IrpSp->Parameters.QueryInterface.InterfaceSpecificData = NULL;

    Status = IoCallDriver(DeviceObject, Irp);
    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject( &Event, Executive, KernelMode, FALSE, NULL );
        Status = Irp->IoStatus.Status;
    }

    return(Status);
}


NTSTATUS
ApGetSetDeviceBusData(
    IN PCOMMON_EXTENSION Extension,
    IN BOOLEAN Read,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Reads or writes PCI config space for the specified device.

Arguments:

    Extension - Supplies the common AGP extension

    Read - if TRUE, this is a READ IRP
           if FALSE, this is a WRITE IRP

    Buffer - Returns the PCI config data

    Offset - Supplies the offset into the PCI config data where the read should begin

    Length - Supplies the number of bytes to be read

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;
    ULONG ReturnLength;
    ULONG Transferred;

    //
    // First check our device extension. This must be either a master
    // or target extension, we don't care too much which.
    //
    ASSERT((Extension->Signature == TARGET_SIG) ||
           (Extension->Signature == MASTER_SIG));

    //
    // Now we simply use our bus interface to call directly to PCI.
    //

    if (Read) {
        Transferred = Extension->BusInterface.GetBusData(Extension->BusInterface.Context,
                                                         PCI_WHICHSPACE_CONFIG,
                                                         Buffer,
                                                         Offset,
                                                         Length);
    } else {
        Transferred = Extension->BusInterface.SetBusData(Extension->BusInterface.Context,
                                                         PCI_WHICHSPACE_CONFIG,
                                                         Buffer,
                                                         Offset,
                                                         Length);
    }
    if (Transferred == Length) {
        return(STATUS_SUCCESS);
    } else {
        return(STATUS_UNSUCCESSFUL);
    }
}


NTSTATUS
ApGetSetBusData(
    IN PBUS_SLOT_ID BusSlotId,
    IN BOOLEAN Read,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Calls HalGet/SetBusData for the specified PCI bus/slot ID.

Arguments:

    BusSlotId - Supplies the bus and slot ID.

    Read - if TRUE, this is a GetBusData
           if FALSE, this is a SetBusData

    Buffer - Returns the PCI config data

    Offset - Supplies the offset into the PCI config data where the read should begin

    Length - Supplies the number of bytes to be read

Return Value:

    NTSTATUS

--*/

{
    ULONG Transferred;

    if (Read) {
        Transferred = HalGetBusDataByOffset(PCIConfiguration,
                                            BusSlotId->BusId,
                                            BusSlotId->SlotId,
                                            Buffer,
                                            Offset,
                                            Length);
    } else {
        Transferred = HalSetBusDataByOffset(PCIConfiguration,
                                            BusSlotId->BusId,
                                            BusSlotId->SlotId,
                                            Buffer,
                                            Offset,
                                            Length);

    }
    if (Transferred == Length) {
        return(STATUS_SUCCESS);
    } else {
        return(STATUS_UNSUCCESSFUL);
    }
}


NTSTATUS
ApFindAgpCapability(
    IN PAGP_GETSET_CONFIG_SPACE pConfigFn,
    IN PVOID Context,
    OUT PPCI_AGP_CAPABILITY Capability,
    OUT UCHAR *pOffset,
    OUT PPCI_COMMON_CONFIG PciCommonConfig OPTIONAL
    )
/*++

Routine Description:

    Finds the capability offset for the specified device and
    reads in the header.

Arguments:

    pConfigFn - Supplies the function to call for accessing config space
        on the appropriate device.

    Context - Supplies the context to pass to pConfigFn

    Capabilities - Returns the AGP Capabilities common header

    pOffset - Returns the offset into config space.

    PciCommonConfig - NULL, or points to the PCI common configuration header

Return Value:

    NTSTATUS

--*/

{
    PCI_COMMON_HEADER Header;
    PPCI_COMMON_CONFIG PciConfig = (PPCI_COMMON_CONFIG)&Header;
    NTSTATUS Status;
    UCHAR CapabilityOffset;

    //
    // Read the PCI common header to get the capabilities pointer
    //
    Status = (pConfigFn)(Context,
                         TRUE,
                         PciConfig,
                         0,
                         sizeof(PCI_COMMON_HEADER));
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpLibGetAgpCapability - read PCI Config space for Context %08lx failed %08lx\n",
                Context,
                Status));
        return(Status);
    }

    //
    // Check the Status register to see if this device supports capability lists.
    // If not, it is not an AGP-compliant device.
    //
    if ((PciConfig->Status & PCI_STATUS_CAPABILITIES_LIST) == 0) {
        AGPLOG(AGP_CRITICAL,
               ("AgpLibGetAgpCapability - Context %08lx does not support Capabilities list, not an AGP device\n",
                Context));
        return(STATUS_NOT_IMPLEMENTED);
    }

    //
    // The device supports capability lists, find the AGP capabilities
    //
    if ((PciConfig->HeaderType & (~PCI_MULTIFUNCTION)) == PCI_BRIDGE_TYPE) {
        CapabilityOffset = PciConfig->u.type1.CapabilitiesPtr;
    } else {
        ASSERT((PciConfig->HeaderType & (~PCI_MULTIFUNCTION)) == PCI_DEVICE_TYPE);
        CapabilityOffset = PciConfig->u.type0.CapabilitiesPtr;
    }
    while (CapabilityOffset != 0) {

        //
        // Read the Capability at this offset
        //
        Status = (pConfigFn)(Context,
                             TRUE,
                             Capability,
                             CapabilityOffset,
                             sizeof(PCI_CAPABILITIES_HEADER));
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AgpLibGetAgpCapability - read PCI Capability at offset %x for Context %08lx failed %08lx\n",
                    CapabilityOffset,
                    Context,
                    Status));
            return(Status);
        }
        if (Capability->Header.CapabilityID == PCI_CAPABILITY_ID_AGP) {
            //
            // Found the AGP Capability
            //
            break;
        } else {
            //
            // This is some other Capability, keep looking for the AGP Capability
            //
            CapabilityOffset = Capability->Header.Next;
        }
    }
    if (CapabilityOffset == 0) {
        //
        // No AGP capability was found
        //
        AGPLOG(AGP_CRITICAL,
               ("AgpLibGetAgpCapability - Context %08lx does have an AGP Capability entry, not an AGP device\n",
                Context));
        return(STATUS_NOT_IMPLEMENTED);
    }

    AGPLOG(AGP_NOISE,
           ("AgpLibGetAgpCapability - Context %08lx has AGP Capability at offset %x\n",
            Context,
            CapabilityOffset));

    *pOffset = CapabilityOffset;

    if (PciCommonConfig) {
        RtlCopyMemory(PciCommonConfig, PciConfig, sizeof(PCI_COMMON_HEADER));
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpLibGetAgpCapability(
    IN PAGP_GETSET_CONFIG_SPACE pConfigFn,
    IN PVOID Context,
    IN BOOLEAN DoSpecial,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    This routine finds and retrieves the AGP capabilities in the
    PCI config space of the AGP master (graphics card).

Arguments:

    pConfigFn - Supplies the function to call for accessing config space
        on the appropriate device.

    Context - Supplies the context to pass to pConfigFn

    DoSpecial - Indicates whether we should apply any "pecial" tweaks

    Capabilities - Returns the current AGP Capabilities

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;
    ULONGLONG DeviceFlags;
    UCHAR CapabilityOffset;
    PCI_COMMON_HEADER Header;
    USHORT SubVendorID, SubSystemID;
    PPCI_COMMON_CONFIG PciConfig = (PPCI_COMMON_CONFIG)&Header;
 
    Status = ApFindAgpCapability(pConfigFn,
                                 Context,
                                 Capability,
                                 &CapabilityOffset,
                                 PciConfig);
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // Read the rest of the AGP capability
    //
    Status = (pConfigFn)(Context,
                         TRUE,
                         &Capability->Header + 1,
                         CapabilityOffset + sizeof(PCI_CAPABILITIES_HEADER),
                         sizeof(PCI_AGP_CAPABILITY) - sizeof(PCI_CAPABILITIES_HEADER));
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpLibGetAgpCapability - read AGP Capability at offset %x for Context %08lx failed %08lx\n",
                CapabilityOffset,
                Context,
                Status));
        return(Status);
    }

    //
    // Check device flags for broken HW, we may need to tweak caps
    //
    if ((PCI_CONFIGURATION_TYPE(PciConfig) == PCI_DEVICE_TYPE) &&
        (PciConfig->BaseClass != PCI_CLASS_BRIDGE_DEV)) {
        SubVendorID = PciConfig->u.type0.SubVendorID;
        SubSystemID = PciConfig->u.type0.SubSystemID;
    } else {
        SubVendorID = 0;
        SubSystemID = 0;
    }
    
    DeviceFlags = AgpGetDeviceFlags(AgpGlobalHackTable,
                                    PciConfig->VendorID,
                                    PciConfig->DeviceID,
                                    SubVendorID,
                                    SubSystemID,
                                    PciConfig->RevisionID);

    DeviceFlags |= AgpGetDeviceFlags(AgpDeviceHackTable,
                                     PciConfig->VendorID,
                                     PciConfig->DeviceID,
                                     SubVendorID,
                                     SubSystemID,
                                     PciConfig->RevisionID);
    
    if (DeviceFlags & AGP_FLAG_NO_1X_RATE) {
        Capability->AGPStatus.Rate &= ~PCI_AGP_RATE_1X;
        
        AGPLOG(AGP_WARNING,
               ("AGP HAMMER CAPS: NO_1X_RATE Vendor %x, Device %x.\n",
                PciConfig->VendorID,
                PciConfig->DeviceID));
    }
    
    if (DeviceFlags & AGP_FLAG_NO_2X_RATE) {
        Capability->AGPStatus.Rate &= ~PCI_AGP_RATE_2X;
        
        AGPLOG(AGP_WARNING,
               ("AGP HAMMER CAPS: NO_2X_RATE Vendor %x, Device %x.\n",
                PciConfig->VendorID,
                PciConfig->DeviceID));
    }
    
    if (DeviceFlags & AGP_FLAG_NO_4X_RATE) {
        Capability->AGPStatus.Rate &= ~PCI_AGP_RATE_4X;
        
        AGPLOG(AGP_WARNING,
               ("AGP HAMMER CAPS: NO_4X_RATE Vendor %x, Device %x.\n",
                PciConfig->VendorID,
                PciConfig->DeviceID));
    }
    
    if (DeviceFlags & AGP_FLAG_NO_8X_RATE) {
        Capability->AGPStatus.Rate &= ~8;
        
        AGPLOG(AGP_WARNING,
               ("AGP HAMMER CAPS: NO_8X_RATE Vendor %x, Device %x.\n",
                PciConfig->VendorID,
                PciConfig->DeviceID));
    }
    
    if (DeviceFlags & AGP_FLAG_NO_SBA_ENABLE) {
        Capability->AGPStatus.SideBandAddressing = 0;
        
        AGPLOG(AGP_WARNING,
               ("AGP HAMMER CAPS: NO_SBA_ENABLE Vendor %x, Device %x.\n",
                PciConfig->VendorID,
                PciConfig->DeviceID));
    }
    
    if (DeviceFlags & AGP_FLAG_REVERSE_INITIALIZATION) {
        
        AGPLOG(AGP_WARNING,
               ("AGP GLOBAL HACK: REVERSE_INITIALIZATION Vendor %x, "
                "Device %x.\n",
                PciConfig->VendorID,
                PciConfig->DeviceID));
    }

    //
    // Test if this device requires any platform specific AGP tweaks
    //
    if (DoSpecial && (DeviceFlags > AGP_FLAG_SPECIAL_TARGET) ||
        (DeviceFlags & AGP_FLAG_REVERSE_INITIALIZATION)) {
        AgpSpecialTarget(GET_AGP_CONTEXT_FROM_MASTER((PMASTER_EXTENSION)Context), ((DeviceFlags & ~AGP_FLAG_SPECIAL_TARGET) | (DeviceFlags & AGP_FLAG_REVERSE_INITIALIZATION)));
    }
    
    AGPLOG(AGP_NOISE,
           ("AGP CAPABILITY: version %d.%d\n",Capability->Major, Capability->Minor));
    AGPLOG(AGP_NOISE,
           ("\tSTATUS  - Rate: %x  SBA: %x  RQ: %02x\n",
           Capability->AGPStatus.Rate,
           Capability->AGPStatus.SideBandAddressing,
           Capability->AGPStatus.RequestQueueDepthMaximum));
    AGPLOG(AGP_NOISE,
           ("\tCOMMAND - Rate: %x  SBA: %x  RQ: %02x  AGPEnable: %x\n",
           Capability->AGPCommand.Rate,
           Capability->AGPCommand.SBAEnable,
           Capability->AGPCommand.RequestQueueDepth,
           Capability->AGPCommand.AGPEnable));

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpLibGetTargetCapability(
    IN PVOID AgpExtension,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    Retrieves the AGP capability for the AGP target (AGP bridge)

Arguments:

    AgpExtension - Supplies the AGP extension

    Capability - Returns the AGP capability

Return Value:

    NTSTATUS

--*/

{
    PTARGET_EXTENSION Extension;

    GET_TARGET_EXTENSION(Extension, AgpExtension);

    return(AgpLibGetAgpCapability(ApGetSetDeviceBusData,
                                  Extension,
                                  FALSE,
                                  Capability));
}


NTSTATUS
AgpLibGetMasterCapability(
    IN PVOID AgpExtension,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    Retrieves the AGP capability for the AGP master (graphics card)

Arguments:

    AgpExtension - Supplies the AGP extension

    Capability - Returns the AGP capability

Return Value:

    NTSTATUS

--*/

{
    PMASTER_EXTENSION Extension;

    GET_MASTER_EXTENSION(Extension, AgpExtension);

    return(AgpLibGetAgpCapability(ApGetSetDeviceBusData,
                                  Extension,
                                  TRUE,
                                  Capability));
}


NTSTATUS
AgpLibGetPciDeviceCapability(
    IN ULONG BusId,
    IN ULONG SlotId,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    Retrieves the AGP capability for the specified PCI slot.

    Caller is responsible for figuring out what the correct
    Bus/Slot ID is. These are just passed right to HalGetBusData.

Arguments:

    BusId - supplies the bus id

    SlotId - Supplies the slot id

    Capability - Returns the AGP capability

Return Value:

    NTSTATUS

--*/

{
    BUS_SLOT_ID BusSlotId;

    BusSlotId.BusId = BusId;
    BusSlotId.SlotId = SlotId;

    return(AgpLibGetAgpCapability(ApGetSetBusData,
                                  &BusSlotId,
                                  FALSE,
                                  Capability));
}


NTSTATUS
AgpLibSetAgpCapability(
    IN PAGP_GETSET_CONFIG_SPACE pConfigFn,
    IN PVOID Context,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    This routine finds and retrieves the AGP capabilities in the
    PCI config space of the AGP master (graphics card).

Arguments:

    pConfigFn - Supplies the function to call for accessing config space
        on the appropriate device.

    Context - Supplies the context to pass to pConfigFn

    Capabilities - Returns the current AGP Capabilities

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;
    UCHAR CapabilityOffset;

    Status = ApFindAgpCapability(pConfigFn,
                                 Context,
                                 Capability,
                                 &CapabilityOffset,
                                 NULL);
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // Now that we know the offset, write the supplied command register
    //
    Status = (pConfigFn)(Context,
                         FALSE,
                         &Capability->AGPCommand,
                         CapabilityOffset + FIELD_OFFSET(PCI_AGP_CAPABILITY, AGPCommand),
                         sizeof(Capability->AGPCommand));
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpLibSetAgpCapability - Set AGP command at offset %x for Context %08lx failed %08lx\n",
                CapabilityOffset,
                Context,
                Status));
        return(Status);
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpLibSetTargetCapability(
    IN PVOID AgpExtension,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    Sets the AGP capability for the AGP target (AGP bridge)

Arguments:

    AgpExtension - Supplies the AGP extension

    Capability - Returns the AGP capability

Return Value:

    NTSTATUS

--*/

{
    PTARGET_EXTENSION Extension;

    GET_TARGET_EXTENSION(Extension, AgpExtension);

    return(AgpLibSetAgpCapability(ApGetSetDeviceBusData,
                                  Extension,
                                  Capability));
}


NTSTATUS
AgpLibSetMasterCapability(
    IN PVOID AgpExtension,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    Sets the AGP capability for the AGP master (graphics card)

Arguments:

    AgpExtension - Supplies the AGP extension

    Capability - Returns the AGP capability

Return Value:

    NTSTATUS

--*/

{
    PMASTER_EXTENSION Extension;

    GET_MASTER_EXTENSION(Extension, AgpExtension);

    return(AgpLibSetAgpCapability(ApGetSetDeviceBusData,
                                  Extension,
                                  Capability));
}


NTSTATUS
AgpLibSetPciDeviceCapability(
    IN ULONG BusId,
    IN ULONG SlotId,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    Sets the AGP capability for the specified PCI slot.

    Caller is responsible for figuring out what the correct
    Bus/Slot ID is. These are just passed right to HalSetBusData.

Arguments:

    BusId - supplies the bus id

    SlotId - Supplies the slot id

    Capability - Returns the AGP capability

Return Value:

    NTSTATUS

--*/

{
    BUS_SLOT_ID BusSlotId;

    BusSlotId.BusId = BusId;
    BusSlotId.SlotId = SlotId;

    return(AgpLibSetAgpCapability(ApGetSetBusData,
                                  &BusSlotId,
                                  Capability));
}



NTSTATUS
AgpLibGetMasterDeviceId(
    IN PVOID AgpExtension,
    OUT PULONG DeviceId
    )
/*++

Routine Description:

    This function returns the PCI DeviceId/Vendo58rId of the master AGP
    device

Arguments:

    DeviceId - Identifies PCI manufaturer and device of master

Return Value:

    STATUS_SUCCESS or an appropriate error status

--*/
{
    PCI_COMMON_HEADER Header;
    PPCI_COMMON_CONFIG PciConfig = (PPCI_COMMON_CONFIG)&Header;
    NTSTATUS Status;
    PMASTER_EXTENSION Master = NULL;
    PTARGET_EXTENSION Target = NULL;

    //
    // Try to make this as idiot proof as possible for the case
    // where this is called from SetAperture on a system without
    // an AGP adapter, so we don't AV if some context hasn't been
    // initialized, or is missing...
    //

    Target = CONTAINING_RECORD(AgpExtension,
                               TARGET_EXTENSION,
                               AgpContext);
    
    if (Target) {
        if (Target->CommonExtension.Signature == TARGET_SIG) {
            if (Target->ChildDevice) {        
                if (Target->ChildDevice->CommonExtension.Signature ==
                    MASTER_SIG) {
                    Master = Target->ChildDevice;
                }
            }
        }
    }

    if (Master) {

        //
        // Read the PCI common header to get the capabilities pointer
        //
        Status = (ApGetSetDeviceBusData)((PCOMMON_EXTENSION)Master,
                                         TRUE,
                                         PciConfig,
                                         0,
                                         sizeof(PCI_COMMON_HEADER));
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AgpLibGetMasterDeviceId - read PCI Config space for Context %08lx failed %08lx\n",
                    Master,
                    Status));
            return Status;
        }
        
        *DeviceId = *(PULONG)PciConfig;
        
    } else {
        *DeviceId = (ULONG)-1;
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\agp\agplib\resource.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    resource.c

Abstract:

    Common routines for handling resource requirements

Author:

    John Vert (jvert) 10/25/1997

Revision History:

--*/
#include "agplib.h"


PCM_RESOURCE_LIST
ApSplitResourceList(
    IN PCM_RESOURCE_LIST ResourceList,
    OUT PCM_RESOURCE_LIST *NewResourceList
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AgpFilterResourceRequirements)
#pragma alloc_text(PAGE, AgpStartTarget)
#pragma alloc_text(PAGE, ApSplitResourceList)
#endif

static BOOLEAN ResourceConflict = FALSE;


NTSTATUS
AgpFilterResourceRequirements(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    )
/*++

Routine Description:

    Completion routine for IRP_MN_QUERY_RESOURCE_REQUIREMENTS. This adds on the
    AGP resource requirements.

Arguments:

    DeviceObject - Supplies the device object

    Irp - Supplies the IRP_MN_QUERY_RESOURCE_REQUIREMENTS Irp

    Extension - Supplies the device extension

Return Value:

    NTSTATUS

--*/

{
    BOOLEAN SwapDescriptor;
    ULONG SwapLength;
    ULONG ApertureSize;
    NTSTATUS Status;
    ULONG AddCount;
    PHYSICAL_ADDRESS CurrentBase;
    PHYSICAL_ADDRESS MaxAddr;
    ULONG CurrentSizeInPages;
    PIO_RESOURCE_REQUIREMENTS_LIST OldRequirements;
    PIO_RESOURCE_REQUIREMENTS_LIST NewRequirements;
    ULONG NewSize;
    ULONG Alternative;
    PIO_RESOURCE_LIST OldResourceList;
    PIO_RESOURCE_LIST NewResourceList;
    PIO_RESOURCE_DESCRIPTOR Descriptor;
    PIO_STACK_LOCATION IrpSp;
    PIO_RESOURCE_LIST ApertureRequirements = NULL;
    ULONG i;

    PAGED_CODE();

    AGPLOG(AGP_NOISE,
           ("AgpQueryResourceRequirements - IRP %08lx, resource %08lx\n",
            Irp,
            Irp->IoStatus.Information));

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Create a new resource requirements list with our current aperture
    // settings tacked on the end.
    //
    OldRequirements = IrpSp->Parameters.FilterResourceRequirements.IoResourceRequirementList;
    if (OldRequirements == NULL) {
        //STATUS_INVALID_DEVICE_REQUEST
        // PNP helpfully passes us a NULL pointer instead of an empty resource list
        // when the bridge is disabled. In this case we will ignore this irp and not
        // add on our requirements since they are not going to be used anyway.
        //
        return(STATUS_SUCCESS);
    }

    //
    // Get the current GART aperture.
    //
    Status = AgpQueryAperture(GET_AGP_CONTEXT(Extension),
                              &CurrentBase,
                              &CurrentSizeInPages,
                              &ApertureRequirements);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpQueryResourceRequirements - AgpQueryAperture %08lx failed %08lx\n",
                Extension,
                Status));
        return(Status);
    }

#if !defined(_IA64_)
    ASSERT(ApertureRequirements != NULL);
#endif

    ApertureSize = (CurrentSizeInPages * PAGE_SIZE);
    MaxAddr.QuadPart = CurrentBase.QuadPart + ApertureSize - 1;

    AGPLOG(AGP_NOISE,
           ("AgpQueryResourceRequirements - aperture at %I64x, length %08lx pages, Requirements %08lx\n",
            CurrentBase.QuadPart,
            CurrentSizeInPages,
            ApertureRequirements));

    //
    // We will add IO_RESOURCE_DESCRIPTORs to each alternative.
    //
    // The first one is a private data type marked with our signature. This is
    // a marker so that we know which descriptors are ours so we can remove
    // them later.
    //
    // The second is the actual descriptor for the current aperture settings.
    // This is marked as preferred.
    //
    // Following this is the requirements returned from AgpQueryAperture. These
    // get marked as alternatives.
    //
    AddCount = 2;

    //
    // Enumerate the old list looking for any preferred descriptor that
    // conflicts with our preferred settings; if we find one, then the BIOS
    // is whack, and we will throw out our preferred descriptor, and let PnP
    // choose from our alternates
    //
    ResourceConflict = FALSE;
    OldResourceList = &OldRequirements->List[0];

    for (Alternative = 0; Alternative < OldRequirements->AlternativeLists;
         Alternative++) {

        for (i = 0; i < OldResourceList->Count; i++) {
            Descriptor = &OldResourceList->Descriptors[i];

            if ((Descriptor->Option == IO_RESOURCE_PREFERRED) &&
                (Descriptor->Type == CmResourceTypeMemory)) {
                
                if (((Descriptor->u.Memory.MinimumAddress.QuadPart >=
                      CurrentBase.QuadPart) &&
                     (Descriptor->u.Memory.MinimumAddress.QuadPart <=
                      MaxAddr.QuadPart)) ||
                     ((Descriptor->u.Memory.MaximumAddress.QuadPart >=
                       CurrentBase.QuadPart) &&
                      (Descriptor->u.Memory.MaximumAddress.QuadPart <=
                       MaxAddr.QuadPart)) ||
                    ((Descriptor->u.Memory.MinimumAddress.QuadPart <
                      CurrentBase.QuadPart) &&
                     (Descriptor->u.Memory.MaximumAddress.QuadPart >
                      MaxAddr.QuadPart))) {

                    AGPLOG(AGP_CRITICAL,
                           ("AgpQueryResourceRequirements - Conflicted "
                            "resource detected: %I64X - %I64X\n",
                            Descriptor->u.Memory.MinimumAddress.QuadPart,
                            Descriptor->u.Memory.MaximumAddress.QuadPart));

                    //
                    // This preferred descriptor is in conflic with our AGP
                    // preferred setting
                    //
#if defined(_IA64_)
                    AGPLOG(AGP_CRITICAL, ("Please contact system manufacturer "
                                          "for a BIOS upgrade.\n"));
#else // _IA64_
                    AddCount = 1;
                    ResourceConflict = TRUE;
#endif // _IA64_
                    break;
                }
            }
        }
        OldResourceList = (PIO_RESOURCE_LIST)(OldResourceList->Descriptors +
                                              OldResourceList->Count);
    }

    //
    //
    // For IA64, PnP cannot reassign the aperture base, so we can only use
    // the "preferred" descriptor
    //
#if !defined(_IA64_)
    AddCount += ApertureRequirements->Count;
#endif // _IA64_

    NewSize = OldRequirements->ListSize;
    NewSize += sizeof(IO_RESOURCE_DESCRIPTOR) *
        (AddCount * OldRequirements->AlternativeLists);
    
    NewRequirements = ExAllocatePool(PagedPool, NewSize);
    if (NewRequirements == NULL) {
        ExFreePool(ApertureRequirements);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    NewRequirements->ListSize = NewSize;
    NewRequirements->InterfaceType = OldRequirements->InterfaceType;
    NewRequirements->BusNumber = OldRequirements->BusNumber;
    NewRequirements->SlotNumber = OldRequirements->SlotNumber;
    NewRequirements->AlternativeLists = OldRequirements->AlternativeLists;

    //
    // Append our requirement to each alternative resource list.
    //
    NewResourceList = &NewRequirements->List[0];
    OldResourceList = &OldRequirements->List[0];
    for (Alternative = 0; Alternative < OldRequirements->AlternativeLists; Alternative++) {

        //
        // Copy the old resource list into the new one.
        //
        NewResourceList->Version = OldResourceList->Version;
        NewResourceList->Revision = OldResourceList->Revision;
        NewResourceList->Count = OldResourceList->Count + AddCount;
        RtlCopyMemory(&NewResourceList->Descriptors[0],
                      &OldResourceList->Descriptors[0],
                      OldResourceList->Count * sizeof(IO_RESOURCE_DESCRIPTOR));

        Descriptor = &NewResourceList->Descriptors[OldResourceList->Count];

        //
        // Append the marker descriptor
        //
        Descriptor->Option = 0;
        Descriptor->Flags = 0;
        Descriptor->Type = CmResourceTypeDevicePrivate;
        Descriptor->ShareDisposition = CmResourceShareDeviceExclusive;
        Descriptor->u.DevicePrivate.Data[0] = AgpPrivateResource;
        Descriptor->u.DevicePrivate.Data[1] = 1;
        ++Descriptor;

        //
        // Append the new descriptor
        //
        if (!ResourceConflict) {
            Descriptor->Option = IO_RESOURCE_PREFERRED;
            Descriptor->Flags = CM_RESOURCE_MEMORY_READ_WRITE |
                CM_RESOURCE_MEMORY_PREFETCHABLE;
            Descriptor->Type = CmResourceTypeMemory;
            Descriptor->ShareDisposition = CmResourceShareDeviceExclusive;
            Descriptor->u.Memory.Length = CurrentSizeInPages * PAGE_SIZE;
            Descriptor->u.Memory.Alignment = CurrentSizeInPages * PAGE_SIZE;
            Descriptor->u.Memory.MinimumAddress = CurrentBase;
            Descriptor->u.Memory.MaximumAddress = MaxAddr;
            ++Descriptor;
        }

        //
        // Append the alternatives
        //
#if !defined(_IA64_)
        SwapDescriptor = FALSE;
        for (i = 0; i < ApertureRequirements->Count; i++) {
            
            //
            // Make sure this descriptor makes sense
            //
            ASSERT(ApertureRequirements->Descriptors[i].Flags ==
                   (CM_RESOURCE_MEMORY_READ_WRITE |
                    CM_RESOURCE_MEMORY_PREFETCHABLE));
            ASSERT(ApertureRequirements->Descriptors[i].Type ==
                   CmResourceTypeMemory);
            ASSERT(ApertureRequirements->Descriptors[i].ShareDisposition ==
                   CmResourceShareDeviceExclusive);

            *Descriptor = ApertureRequirements->Descriptors[i];
           
            //
            // In this case we nuked our preferred descriptor so mark the
            // first alternate as preferred
            //
            if ((i == 0) && ResourceConflict) {

                Descriptor->Option = IO_RESOURCE_PREFERRED;

                if (Descriptor->u.Memory.Length != ApertureSize) {
                    SwapLength = Descriptor->u.Memory.Length;
                    Descriptor->u.Memory.Length = ApertureSize;
                    Descriptor->u.Memory.Alignment = ApertureSize;
                    SwapDescriptor = TRUE;
                }

            } else {
                Descriptor->Option = IO_RESOURCE_ALTERNATIVE;
                
                if (SwapDescriptor) {
                    if (Descriptor->u.Memory.Length == ApertureSize) {
                        Descriptor->u.Memory.Length = SwapLength;
                        Descriptor->u.Memory.Alignment = SwapLength;
                        SwapDescriptor = FALSE;
                    }
                }
            }

            ++Descriptor;
        }
#endif // _IA64_

        //
        // Advance to next resource list
        //
        NewResourceList = (PIO_RESOURCE_LIST)(NewResourceList->Descriptors + NewResourceList->Count);
        OldResourceList = (PIO_RESOURCE_LIST)(OldResourceList->Descriptors + OldResourceList->Count);
    }

    AGPLOG(AGP_NOISE,
           ("AgpQueryResourceRequirements - IRP %p, old resources %p, new resources %p\n",
            Irp,
            OldRequirements,
            NewRequirements));
    IrpSp->Parameters.FilterResourceRequirements.IoResourceRequirementList = NewRequirements;
    Irp->IoStatus.Information = (ULONG_PTR)NewRequirements;
    ExFreePool(OldRequirements);
#if !defined(_IA64_)
    ExFreePool(ApertureRequirements);
#endif // _IA64_
    return(STATUS_SUCCESS);

}


NTSTATUS
AgpQueryResources(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    )
/*++

Routine Description:

    Completion routine for IRP_MN_QUERY_RESOURCES. This adds on the
    AGP resources

Arguments:

    DeviceObject - Supplies the device object

    Irp - Supplies the IRP_MN_QUERY_RESOURCES Irp

    Extension - Supplies the device extension

Return Value:

    NTSTATUS

--*/

{
    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    AGPLOG(AGP_NOISE,
           ("AgpQueryResources - IRP %08lx, resource %08lx\n",
            Irp,
            Irp->IoStatus.Information));
    return(STATUS_SUCCESS);
}


NTSTATUS
AgpStartTarget(
    IN PIRP Irp,
    IN PTARGET_EXTENSION Extension
    )
/*++

Routine Description:

    Filters out the AGP-specific resource requirements on a
    IRP_MN_START_DEVICE Irp.

Arguments:

    Irp - supplies the IRP_MN_START_DEVICE Irp.

    Extension - Supplies the device extension.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION irpSp;
    PCM_RESOURCE_LIST NewResources;
    PCM_RESOURCE_LIST NewResourcesTranslated;
    PCM_RESOURCE_LIST AgpAllocatedResources;
    PCM_RESOURCE_LIST AgpAllocatedResourcesTranslated;
    NTSTATUS Status;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    AGPLOG(AGP_NOISE,
           ("AgpStartTarget - IRP %08lx, resource %08lx\n",
            Irp,
            Irp->IoStatus.Information));

    if (irpSp->Parameters.StartDevice.AllocatedResources != NULL) {
        KEVENT event;

        //
        // Find our private descriptors and split them out into
        // our own resource list
        //
        Extension->Resources = ApSplitResourceList(irpSp->Parameters.StartDevice.AllocatedResources,
                                                   &NewResources);
        Extension->ResourcesTranslated = ApSplitResourceList(irpSp->Parameters.StartDevice.AllocatedResourcesTranslated,
                                                             &NewResourcesTranslated);


        ASSERT(Extension->Resources->Count == 1);
        ASSERT(Extension->Resources->List[0].PartialResourceList.Count == 1);
        Descriptor = &Extension->Resources->List[0].PartialResourceList.PartialDescriptors[0];
        ASSERT(Descriptor->Type == CmResourceTypeMemory);
        Extension->GartBase = Descriptor->u.Memory.Start;
        Extension->GartLengthInPages = Descriptor->u.Memory.Length / PAGE_SIZE;

        //
        // Set the new GART aperture
        //
        Status = AgpSetAperture(GET_AGP_CONTEXT(Extension),
                                Extension->GartBase,
                                Extension->GartLengthInPages);
        ASSERT(NT_SUCCESS(Status));

        Irp->IoStatus.Status = Status ;
        if (!NT_SUCCESS(Status) ) {
            AGPLOG(AGP_CRITICAL,
                   ("AgpStartTarget - AgpSetAperture to %I64X, %08lx failed %08lx\n",
                    Extension->GartBase.QuadPart,
                    Extension->GartLengthInPages * PAGE_SIZE,
                    Status));
            Irp->IoStatus.Status = Status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(Status);
        }

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        //
        // Set up the new parameters for the PCI driver.
        //

        irpSp->Parameters.StartDevice.AllocatedResources = NewResources;
        irpSp->Parameters.StartDevice.AllocatedResourcesTranslated = NewResourcesTranslated;
        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp,
                               AgpSetEventCompletion,
                               &event,
                               TRUE,
                               TRUE,
                               TRUE);

        //
        // Pass down the driver stack
        //
        Status = IoCallDriver(Extension->CommonExtension.AttachedDevice, Irp);

        //
        // If we did things asynchronously then wait on our event
        //
        if (Status == STATUS_PENDING) {
            
            //
            // We do a KernelMode wait so that our stack where the event is
            // doesn't get paged out!
            //
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            Status = Irp->IoStatus.Status;
        }

        ExFreePool(irpSp->Parameters.StartDevice.AllocatedResources);
        ExFreePool(irpSp->Parameters.StartDevice.AllocatedResourcesTranslated);

        IoCompleteRequest(Irp, IO_NO_INCREMENT) ;
        return Status;        
    }
    
    //
    // The bridge is disabled, we have been passed a NULL pointer
    // instead of an empty resource list.  There is nothing to do other
    // than pass down the irp
    //
    IoSkipCurrentIrpStackLocation(Irp);

    return(IoCallDriver(Extension->CommonExtension.AttachedDevice, Irp));
}


PCM_RESOURCE_LIST
ApSplitResourceList(
    IN PCM_RESOURCE_LIST ResourceList,
    OUT PCM_RESOURCE_LIST *NewResourceList
    )
/*++

Routine Description:

    Splits out the AGP-specific resources from a resource list.

Arguments:

    ResourceList - Supplies the resource list.

    NewResourceList - Returns the new resource list with the AGP-specific
        resources stripped out.

Return Value:

    Pointer to the AGP-specific resource list

--*/

{
    ULONG Size;
    ULONG FullCount;
    ULONG PartialCount;
    PCM_FULL_RESOURCE_DESCRIPTOR Full, NewFull, AgpFull;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Partial, NewPartial, AgpPartial;
    PCM_RESOURCE_LIST NewList;
    PCM_RESOURCE_LIST AgpList;
    ULONG NextAgp=0;

    PAGED_CODE();

    //
    // First walk through the source resource list and figure out how big it
    // is. The two resulting resource lists must be smaller than this, so we
    // will just allocate them to be that size and not worry about it.
    //
    Size = sizeof(CM_RESOURCE_LIST) - sizeof(CM_FULL_RESOURCE_DESCRIPTOR);
    Full = &ResourceList->List[0];
    for (FullCount=0; FullCount<ResourceList->Count; FullCount++) {
        Size += sizeof(CM_FULL_RESOURCE_DESCRIPTOR);
        PartialCount = Full->PartialResourceList.Count;
        Size += (PartialCount-1) * sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);

        Full = (PCM_FULL_RESOURCE_DESCRIPTOR)(&Full->PartialResourceList.PartialDescriptors[PartialCount]);
    }

    //
    // Allocate two additional lists
    //
    NewList = ExAllocatePool(PagedPool, Size);
    if (NewList == NULL) {
        *NewResourceList = NULL;
        return(NULL);
    }

    AgpList = ExAllocatePool(PagedPool, Size);
    if (AgpList == NULL) {
        ExFreePool(NewList);
        *NewResourceList = NULL;
        return(NULL);
    }

    //
    // Initialize both new resource lists to have the same number
    // of CM_FULL_RESOURCE_DESCRIPTORs. If any turn out to be empty,
    // we will adjust the count.
    //
    NewList->Count = AgpList->Count = ResourceList->Count;

    //
    // Walk through each CM_FULL_RESOURCE_DESCRIPTOR, copying as we go.
    //
    Full = &ResourceList->List[0];
    NewFull = &NewList->List[0];
    AgpFull = &AgpList->List[0];
    for (FullCount = 0;FullCount < ResourceList->Count; FullCount++) {
        NewFull->InterfaceType = AgpFull->InterfaceType = Full->InterfaceType;
        NewFull->BusNumber = AgpFull->BusNumber = Full->BusNumber;

        //
        // Initialize the partial resource list header
        //
        NewFull->PartialResourceList.Version = Full->PartialResourceList.Version;
        AgpFull->PartialResourceList.Version = Full->PartialResourceList.Version;
        NewFull->PartialResourceList.Revision = Full->PartialResourceList.Revision;
        AgpFull->PartialResourceList.Revision = Full->PartialResourceList.Revision;
        NewFull->PartialResourceList.Count = AgpFull->PartialResourceList.Count = 0;

        NewPartial = &NewFull->PartialResourceList.PartialDescriptors[0];
        AgpPartial = &AgpFull->PartialResourceList.PartialDescriptors[0];
        for (PartialCount = 0; PartialCount < Full->PartialResourceList.Count; PartialCount++) {
            Partial = &Full->PartialResourceList.PartialDescriptors[PartialCount];
            if ((Partial->Type == CmResourceTypeDevicePrivate) &&
                (Partial->u.DevicePrivate.Data[0] == AgpPrivateResource)) {
                //
                // Found one of our private marker descriptors
                //
                // For now, the only kind we should see indicates we skip one descriptor
                //
                ASSERT(NextAgp == 0);
                ASSERT(Partial->u.DevicePrivate.Data[1] == 1);
                NextAgp = Partial->u.DevicePrivate.Data[1];
                ASSERT(PartialCount+NextAgp < Full->PartialResourceList.Count);
            } else {
                //
                // if NextAgp is set, this descriptor goes in the AGP-specific list.
                // Otherwise, it goes in the new list.
                //
                if (NextAgp > 0) {
                    --NextAgp;
                    *AgpPartial++ = *Partial;
                    ++AgpFull->PartialResourceList.Count;
                } else {
                    *NewPartial++ = *Partial;
                    ++NewFull->PartialResourceList.Count;
                }
            }
        }

        //
        // Finished this CM_PARTIAL_RESOURCE_LIST, advance to the next CM_FULL_RESOURCE_DESCRIPTOR
        //
        if (NewFull->PartialResourceList.Count == 0) {
            //
            // we can just reuse this partial resource descriptor as it is empty
            //
            --NewList->Count;
        } else {
            NewFull = (PCM_FULL_RESOURCE_DESCRIPTOR)NewPartial;
        }
        if (AgpFull->PartialResourceList.Count == 0) {
            //
            // we can just reuse this partial resource descriptor as it is empty
            //
            --AgpList->Count;
        } else {
            AgpFull = (PCM_FULL_RESOURCE_DESCRIPTOR)NewPartial;
        }
    }

    *NewResourceList = NewList;

    return(AgpList);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\agp\inc\agp.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    agp.h

Abstract:

    Header file for common AGP library

Author:

    John Vert (jvert) 10/22/1997

Revision History:

--*/
//
// AGP is a driver, make sure we get the appropriate linkage.
//

#define _NTDRIVER_

#include "ntddk.h"
#include "ntagp.h"

//
// regstr.h uses things of type WORD, which isn't around in kernel mode.
//
#define _IN_KERNEL_
#include "regstr.h"

//
// Handy debugging and logging macros
//

//
// Always turned on for now
//
#if DEVL

#define AGP_ALWAYS   0
#define AGP_CRITICAL 1
#define AGP_WARNING  2
#define AGP_IRPTRACE 3
#define AGP_NOISE    4

extern ULONG AgpLogLevel;
extern ULONG AgpStopLevel;
#define AGPLOG(_level_,_x_) if ((_level_) <= AgpLogLevel) DbgPrint _x_; \
                            if ((_level_) <= AgpStopLevel) { DbgBreakPoint();}

#else

#define AGPLOG(_level_,_x_)

#endif

//
// Functions provided by AGPLIB for use by chipset-specific code
//

//
// Helper routines for manipulating AGP Capabilities registers
//
typedef
NTSTATUS
(*PAGP_GETSET_CONFIG_SPACE)(
    IN PVOID Context,
    IN BOOLEAN Read,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

NTSTATUS
AgpLibGetAgpCapability(
    IN PAGP_GETSET_CONFIG_SPACE pConfigFn,
    IN PVOID Context,
    IN BOOLEAN DoSpecial,
    OUT PPCI_AGP_CAPABILITY Capability
    );

NTSTATUS
AgpLibGetTargetCapability(
    IN PVOID AgpExtension,
    OUT PPCI_AGP_CAPABILITY Capability
    );

NTSTATUS
AgpLibGetMasterDeviceId(
    IN PVOID AgpExtension,
    OUT PULONG DeviceId
    );

NTSTATUS
AgpLibGetMasterCapability(
    IN PVOID AgpExtension,
    OUT PPCI_AGP_CAPABILITY Capability
    );

NTSTATUS
AgpLibGetPciDeviceCapability(
    IN ULONG BusId,
    IN ULONG SlotId,
    OUT PPCI_AGP_CAPABILITY Capability
    );

NTSTATUS
AgpLibSetAgpCapability(
    IN PAGP_GETSET_CONFIG_SPACE pConfigFn,
    IN PVOID Context,
    IN PPCI_AGP_CAPABILITY Capability
    );

NTSTATUS
AgpLibSetTargetCapability(
    IN PVOID AgpExtension,
    IN PPCI_AGP_CAPABILITY Capability
    );

NTSTATUS
AgpLibSetMasterCapability(
    IN PVOID AgpExtension,
    IN PPCI_AGP_CAPABILITY Capability
    );

NTSTATUS
AgpLibSetPciDeviceCapability(
    IN ULONG BusId,
    IN ULONG SlotId,
    IN PPCI_AGP_CAPABILITY Capability
    );

PVOID
AgpLibAllocateMappedPhysicalMemory(
   IN PVOID AgpContext, 
   IN ULONG TotalBytes);

//
// Functions implemented by the chipset-specific code
//
typedef struct _AGP_RANGE {
    PHYSICAL_ADDRESS MemoryBase;
    ULONG NumberOfPages;
    MEMORY_CACHING_TYPE Type;
    PVOID Context;
    ULONG CommittedPages;
} AGP_RANGE, *PAGP_RANGE;

//
// These flags have been reserved under AGP_FLAG_SPECIAL_RESERVE
// defined in regstr.h
//
//      AGP_FLAG_SPECIAL_RESERVE 0x000F0000
//
#define AGP_FLAG_SET_RATE_1X     0x00010000
#define AGP_FLAG_SET_RATE_2X     0x00020000
#define AGP_FLAG_SET_RATE_4X     0x00040000
#define AGP_FLAG_SET_RATE_8X     0x00080000

#define AGP_FLAG_SET_RATE_SHIFT  0x00000010

NTSTATUS
AgpSpecialTarget(
    IN PVOID AgpContext,
    IN ULONGLONG DeviceFlags
    );

NTSTATUS
AgpInitializeTarget(
    IN PVOID AgpExtension
    );

NTSTATUS
AgpInitializeMaster(
    IN  PVOID AgpExtension,
    OUT ULONG *AgpCapabilities
    );

NTSTATUS
AgpQueryAperture(
    IN PVOID AgpContext,
    OUT PHYSICAL_ADDRESS *CurrentBase,
    OUT ULONG *CurrentSizeInPages,
    OUT OPTIONAL PIO_RESOURCE_LIST *ApertureRequirements
    );

NTSTATUS
AgpSetAperture(
    IN PVOID AgpContext,
    IN PHYSICAL_ADDRESS NewBase,
    OUT ULONG NewSizeInPages
    );

VOID
AgpDisableAperture(
    IN PVOID AgpContext
    );

NTSTATUS
AgpReserveMemory(
    IN PVOID AgpContext,
    IN OUT AGP_RANGE *AgpRange
    );

NTSTATUS
AgpReleaseMemory(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange
    );

VOID
AgpFindFreeRun(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT ULONG *FreePages,
    OUT ULONG *FreeOffset
    );

VOID
AgpGetMappedPages(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT PMDL Mdl
    );

NTSTATUS
AgpMapMemory(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN PMDL Mdl,
    IN ULONG OffsetInPages,
    OUT PHYSICAL_ADDRESS *MemoryBase
    );

NTSTATUS
AgpUnMapMemory(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages
    );

typedef
NTSTATUS
(*PAGP_FLUSH_PAGES)(
    IN PVOID AgpContext,
    IN PMDL Mdl
    );

//
// Globals defined by the chipset-specific code
//
extern ULONG AgpExtensionSize;
extern PAGP_FLUSH_PAGES AgpFlushPages;

//
// AGP Pool tag definitions
//
#ifdef POOL_TAGGING
#undef ExAllocatePool
#undef ExAllocatePoolWithQuota
#define ExAllocatePool(_type_,_size_) ExAllocatePoolWithTag(_type_,_size_,' PGA')
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\agp\viaagp\init.c ===
/*++

Copyright (c) 1998 VIA Technologies, Inc. and Microsoft Corporation.

Module Name:

    init.c

Abstract:

    This module contains the initialization code for VIAAGP.SYS.

Revision History:

--*/

#include "viaagp.h"

ULONG AgpExtensionSize = sizeof(AGPVIA_EXTENSION);
PAGP_FLUSH_PAGES AgpFlushPages = NULL;  // not implemented

VOID
AgpTweak(
    VOID
    )
/*++

Routine Description:

    Check VIA rev and video device, then tweak config accordingly

Parameters:

    None

Return Value:

    None

--*/
{
    ULONG   ulNB_ID, ulVGA_ID, ulNB_Rev=0xFFFFFFFF, ulNB_Version=0xFFFFFFFF;
    ULONG   ulTmpPhysAddr;
    UCHAR   bVMask, bVOrg;
    UCHAR   i, bMaxItem=20;
    
    //----------------------------------------------------------------
    //Patch Mapping Table
    //----------------------------------------------------------------
    ULONG NBtable[11] =
    {
        //VT3054      VT3055      VT3062      VT3064      VT3056
        0x059700FF, 0x0598000F, 0x0598101F, 0x0501000F, 0x0691000F,
        
        //VT3063      VT3073      VT3075      VT3085      VT3067
        0x0691202F, 0x0691404F, 0x0691808F, 0x0691C0CF, 0x0601000F, 0xFFFFFFFF
    };
    
    ULONG NBVersion[11] =
    {
        0x3054,     0x3055,     0x3062,     0x3064,     0x3056,
        0x3063,     0x3073,     0x3075,     0x3085,     0x3067,     0xFFFFFFFF
    };
    
#ifdef AGP_440
    DbgPrint("FineTune\n");
#endif
    
    //----------------------------------------------------------------
    //Find the type of North Bridge (device id, revision #)
    //----------------------------------------------------------------
    
    //
    //Save back door value and close back door
    //
    ReadVIAConfig(&bVOrg, 0xFC, sizeof(bVOrg));
    bVMask=bVOrg & 0xFE;
    WriteVIAConfig(&bVMask, 0xFC, sizeof(bVMask));
    ReadVIAConfig(&ulNB_ID, 0x00, sizeof(ulNB_ID))
        ulNB_ID=ulNB_ID&0xFFFF0000;
    ReadVIAConfig(&ulNB_Rev, 0x08, sizeof(ulNB_Rev));
    ulNB_Rev=ulNB_Rev&0x000000FF;
    ulNB_ID=ulNB_ID | (ulNB_Rev<<8) | ulNB_Rev;
    WriteVIAConfig(&bVOrg, 0xFC, sizeof(bVOrg));

    //
    //Find the type of North Bridge from the predefined NBtable
    //
    for ( i=0; i<bMaxItem; i++ )
    {
        if ( (NBtable[i]&0xFFFF0000) == (ulNB_ID&0xFFFF0000) )
        {
            if ( ((NBtable[i]&0x0000FF00)<=(ulNB_ID&0x0000FF00)) && ((NBtable[i]&0x000000FF)>=(ulNB_ID&0x000000FF)) )
            {
                ulNB_Version=NBVersion[i];
                break;
            }
        }
        
        if ( NBtable[i]==0xFFFFFFFF )
        {
            break;
        }
    }

    //----------------------------------------------------------------
    // General Case for NB
    //----------------------------------------------------------------
    
    //
    //Stephen Add Start, If Socket 7's chipset, write 1 to Rx51 bit 6;
    //
    if ( (ulNB_ID & 0xFF000000) == 0x05000000) {
        ReadVIAConfig(&bVMask, 0x51, sizeof(bVMask));
        bVMask=bVMask|0x40;
        WriteVIAConfig(&bVMask, 0x51, sizeof(bVMask));
    }
    
    //
    //  For the specific NB
    //
    switch(ulNB_Version)
    {
        case 0x3054:
            break;
            
        case 0x3055:
            // 51[7]=1, 51[6]=1, AC[2]=1
            if ( ulNB_Rev > 3 )
            {
                ReadVIAConfig(&bVMask, 0x51, sizeof(bVMask));
                bVMask=bVMask|0xC0;
                WriteVIAConfig(&bVMask, 0x51, sizeof(bVMask));
                ReadVIAConfig(&bVMask, 0xAC, sizeof(bVMask));
                bVMask=bVMask|0x04;
                WriteVIAConfig(&bVMask, 0xAC, sizeof(bVMask));
            }
            break;
            
        case 0x3056:
            // 69[1]=1, 69[0]=1, AC[2]=1, AC[5]=1
            ReadVIAConfig(&bVMask, 0x69, sizeof(bVMask));
            bVMask=bVMask|0x03;
            WriteVIAConfig(&bVMask, 0x69, sizeof(bVMask));
            ReadVIAConfig(&bVMask, 0xAC, sizeof(bVMask));
            bVMask=bVMask|0x24;
            WriteVIAConfig(&bVMask, 0xAC, sizeof(bVMask));
            break;
            
        case 0x3062:
        case 0x3063:
        case 0x3064:
        case 0x3073:
        case 0x3075:
        case 0x3085:
        case 0x3067:
            // AC[6]=1, AC[5]=1
            ReadVIAConfig(&bVMask, 0xAC, sizeof(bVMask));
            bVMask=bVMask|0x60;
            WriteVIAConfig(&bVMask, 0xAC, sizeof(bVMask));
            break;
            
        default:
            break;
    }
    
    //----------------------------------------------------------------
    //Find the type of AGP VGA Card (vender id, device id, revision #)
    //Bus 1, Device 0, Function 0
    //----------------------------------------------------------------
    
    ReadVGAConfig(&ulVGA_ID, 0x00, sizeof(ulVGA_ID));
    
#ifdef AGP_440
    DbgPrint("\nPatch for ulNB_Version=%x (ulNB_ID=%x), ulVGA_ID=%x",ulNB_Version,ulNB_ID,ulVGA_ID);
#endif
    
    //----------------------------------------------------------------
    //Patch the Compatibility between VGA Card and North Bridge
    //----------------------------------------------------------------
    
    //
    // Switch 1. For all cards of the same vender
    //
    switch(ulVGA_ID&0x0000FFFF)
    {
        //ATI
        case 0x00001002:
            switch(ulNB_Version)
            {
                case 0x3055:
                case 0x3054:
                case 0x3056:
                    // P2P, 40[7]=0
                    ReadP2PConfig(&bVMask, 0x40, sizeof(bVMask));
                    bVMask=bVMask&0x7F;
                    WriteP2PConfig(&bVMask, 0x40, sizeof(bVMask));
                    break;
            }
            break;
            
            //3DLAB
        case 0x0000104C:
            if (ulNB_Version==0x3063)
            {
                // AC[1]=0
                ReadVIAConfig(&bVMask, 0xAC, sizeof(bVMask));
                bVMask=bVMask&0xFD;
                WriteVIAConfig(&bVMask, 0xAC, sizeof(bVMask));
            }
            break;
    }
    
    //
    // Switch 2. For the specific card
    //
    switch(ulVGA_ID)
    {
        //ATIRage128
        case 0x52461002:
            switch(ulNB_Version)
            {
                case 0x3056:
                    // P2P, 40[7]=0
                    ReadP2PConfig(&bVMask, 0x40, sizeof(bVMask));
                    bVMask=bVMask&0x7F;
                    WriteP2PConfig(&bVMask, 0x40, sizeof(bVMask));
                    break;
                    
                case 0x3063:
                    if (ulNB_Rev == 6)
                    {
                        // P2P, 40[7]=1
                        ReadP2PConfig(&bVMask, 0x40, sizeof(bVMask));
                        bVMask=bVMask|0x80;
                        WriteP2PConfig(&bVMask, 0x40, sizeof(bVMask));
                    }
                    else
                    {
                        // P2P, 40[7]=0
                        ReadP2PConfig(&bVMask, 0x40, sizeof(bVMask));
                        bVMask=bVMask&0x7F;
                        WriteP2PConfig(&bVMask, 0x40, sizeof(bVMask));
                    }
                    break;
            }
            break;
            
            //TNT
        case 0x002010DE:
            switch(ulNB_Version)
            {
                case 0x3056:
                case 0x3063:
                case 0x3073:
                    // P2P, 40[1]=0
                    ReadP2PConfig(&bVMask, 0x40, sizeof(bVMask));
                    bVMask=bVMask&0xFD;
                    WriteP2PConfig(&bVMask, 0x40, sizeof(bVMask));
                    // 70[2]=0
                    ReadVIAConfig(&bVMask, 0x70, sizeof(bVMask));
                    bVMask=bVMask&0xFB;
                    WriteVIAConfig(&bVMask, 0x70, sizeof(bVMask));
                    break;
            }
            break;
            
            //S33D    
        case 0x8A225333:
            if (ulNB_Version==0x3063)
                if (ulNB_Rev==6)
                {
                    // P2P, 40[7]=0
                    ReadP2PConfig(&bVMask, 0x40, sizeof(bVMask));
                    bVMask=bVMask&0x7F;
                    WriteP2PConfig(&bVMask, 0x40, sizeof(bVMask));
                }
            break;
    }
}


NTSTATUS
AgpInitializeTarget(
    IN PVOID AgpExtension
    )
/*++

Routine Description:

    Entrypoint for target initialization. This is called first.

Arguments:

    AgpExtension - Supplies the AGP extension

Return Value:

    NTSTATUS

--*/

{
    ULONG VendorId = 0;
    PAGPVIA_EXTENSION Extension = AgpExtension;
    VIA_GATT_BASE GARTBASE_Config;

    //
    // Make sure we are really loaded only on a VIA chipset
    //
    ReadVIAConfig(&VendorId,0,sizeof(VendorId));

    VendorId &= 0x0000FFFF;
    ASSERT(VendorId == AGP_VIA_IDENTIFIER);

    if (VendorId != AGP_VIA_IDENTIFIER) {
        AGPLOG(AGP_CRITICAL,
               ("VIAAGP - AgpInitializeTarget called for platform %08lx which is not a VIA chipset!\n",
                VendorId));
        return(STATUS_UNSUCCESSFUL);
    }

    //
    // Initialize our chipset-specific extension
    //
    Extension->ApertureStart.QuadPart = 0;
    Extension->ApertureLength = 0;
    Extension->Gart = NULL;
    Extension->GartLength = 0;
    Extension->GlobalEnable = FALSE;
    Extension->PCIEnable = FALSE;
    Extension->GartPhysical.QuadPart = 0;
    Extension->SpecialTarget = 0;

    //
    // Check whether the chipset support Flush TLB or not
    // 88[2]=0, support FLUSH TLB
    //
    ReadVIAConfig(&GARTBASE_Config, GATTBASE_OFFSET, sizeof(GARTBASE_Config));
    if ( GARTBASE_Config.TLB_Timing == 0) {
        Extension->Cap_FlushTLB = TRUE;
    } else {
        Extension->Cap_FlushTLB = FALSE;
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpInitializeMaster(
    IN  PVOID AgpExtension,
    OUT ULONG *AgpCapabilities
    )
/*++

Routine Description:

    Entrypoint for master initialization. This is called after target initialization
    and should be used to initialize the AGP capabilities of both master and target.

Arguments:

    AgpExtension - Supplies the AGP extension

    AgpCapabilities - Returns the capabilities of this AGP device.

Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS Status;
    PCI_AGP_CAPABILITY MasterCap;
    PCI_AGP_CAPABILITY TargetCap;
    PAGPVIA_EXTENSION Extension = AgpExtension;
    ULONG SBAEnable;
    ULONG DataRate;
    ULONG FastWrite;
    ULONG FourGB;
    VIA_GART_TLB_CTRL AGPCTRL_Config;
    VIA_GATT_BASE GARTBASE_Config;
    VREF_REG VREF_Config;
    BOOLEAN ReverseInit;
    AGPMISC_REG AGPMISC_Config;

#if DBG
    PCI_AGP_CAPABILITY CurrentCap;
#endif

    //
    // Indicate that we can map memory through the GART aperture
    //
    *AgpCapabilities = AGP_CAPABILITIES_MAP_PHYSICAL;

    //
    // Get the master and target AGP capabilities
    //
    Status = AgpLibGetMasterCapability(AgpExtension, &MasterCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGPVIAInitializeDevice - AgpLibGetMasterCapability failed %08lx\n"));
        return(Status);
    }

    //
    // Some broken cards (Matrox Millenium II "AGP") report no valid
    // supported transfer rates. These are not really AGP cards. They
    // have an AGP Capabilities structure that reports no capabilities.
    //
    if (MasterCap.AGPStatus.Rate == 0) {
        AGPLOG(AGP_CRITICAL,
               ("AGP440InitializeDevice - AgpLibGetMasterCapability returned no valid transfer rate\n"));
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

    Status = AgpLibGetPciDeviceCapability(0,0,&TargetCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGPVIAInitializeDevice - AgpLibGetPciDeviceCapability failed %08lx\n"));
        return(Status);
    }

    //
    // Determine the greatest common denominator for data rate.
    //
    DataRate = TargetCap.AGPStatus.Rate & MasterCap.AGPStatus.Rate;
    ASSERT(DataRate != 0);

    //
    // Select the highest common rate.
    //
    if (DataRate & PCI_AGP_RATE_4X) {
        DataRate = PCI_AGP_RATE_4X;
    } else if (DataRate & PCI_AGP_RATE_2X) {
        DataRate = PCI_AGP_RATE_2X;
    } else if (DataRate & PCI_AGP_RATE_1X) {
        DataRate = PCI_AGP_RATE_1X;

        //
        //Disable FW capability
        //
        TargetCap.AGPStatus.FastWrite = 0;
        ReadVIAConfig(&AGPMISC_Config, AGPMISC_OFFSET, sizeof(AGPMISC_Config));
        AGPMISC_Config.FW_Support = 0;
        WriteVIAConfig(&AGPMISC_Config, AGPMISC_OFFSET, sizeof(AGPMISC_Config));
   }

    //
    // Previously a call was made to change the rate (successfully),
    // use this rate again now
    //
    if (Extension->SpecialTarget & AGP_FLAG_SPECIAL_RESERVE) {
        DataRate = (ULONG)((Extension->SpecialTarget & 
                            AGP_FLAG_SPECIAL_RESERVE) >>
                           AGP_FLAG_SET_RATE_SHIFT);
    }

    //
    // Set the VREF, RxB0[7].
    // 4x -> STB#
    // 1x, 2x -> AGPREF
    //
    ReadVIAConfig(&VREF_Config, VREF_OFFSET, sizeof(VREF_Config));
    if (DataRate == PCI_AGP_RATE_4X) {
        VREF_Config.VREF_Control = 0;
    } else {
        VREF_Config.VREF_Control = 1;
    }
    WriteVIAConfig(&VREF_Config, VREF_OFFSET, sizeof(VREF_Config));

    //
    // Enable SBA if both master and target support it.
    //
    SBAEnable = (TargetCap.AGPStatus.SideBandAddressing &
                 MasterCap.AGPStatus.SideBandAddressing);

    //
    // Enable FastWrite if both master and target support it.
    //
    FastWrite = (TargetCap.AGPStatus.FastWrite & MasterCap.AGPStatus.FastWrite);

    //
    // Enable FourGB if both master and target support it.
    //
    FourGB = (TargetCap.AGPStatus.FourGB & MasterCap.AGPStatus.FourGB);

    //
    // Fine tune the Compatibility between VGA Card and North Bridge
    //
    AgpTweak();

    //
    // Enable the Master
    //
    ReverseInit = 
        (Extension->SpecialTarget & AGP_FLAG_REVERSE_INITIALIZATION) ==
        AGP_FLAG_REVERSE_INITIALIZATION;
    if (ReverseInit) {
        MasterCap.AGPCommand.Rate = DataRate;
        MasterCap.AGPCommand.AGPEnable = 1;
        MasterCap.AGPCommand.SBAEnable = SBAEnable;
        MasterCap.AGPCommand.RequestQueueDepth = TargetCap.AGPStatus.RequestQueueDepthMaximum;
        MasterCap.AGPCommand.FastWriteEnable = FastWrite;
        MasterCap.AGPCommand.FourGBEnable = FourGB;  
        Status = AgpLibSetMasterCapability(AgpExtension, &MasterCap);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AGPVIAInitializeDevice - AgpLibSetMasterCapability %08lx failed %08lx\n",
                    &MasterCap,
                    Status));
        }
    }

    //
    // Now enable the Target
    //
    TargetCap.AGPCommand.Rate = DataRate;
    TargetCap.AGPCommand.AGPEnable = 1;
    TargetCap.AGPCommand.SBAEnable = SBAEnable;
    TargetCap.AGPCommand.FastWriteEnable = FastWrite;
    TargetCap.AGPCommand.FourGBEnable = FourGB;  
    Status = AgpLibSetPciDeviceCapability(0, 0, &TargetCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGPVIAInitializeDevice - AgpLibSetPciDeviceCapability %08lx for target failed %08lx\n",
                &TargetCap,
                Status));
        return(Status);
    }

    if (!ReverseInit) {
        MasterCap.AGPCommand.Rate = DataRate;
        MasterCap.AGPCommand.AGPEnable = 1;
        MasterCap.AGPCommand.SBAEnable = SBAEnable;
        MasterCap.AGPCommand.RequestQueueDepth = TargetCap.AGPStatus.RequestQueueDepthMaximum;
        MasterCap.AGPCommand.FastWriteEnable = FastWrite;
        MasterCap.AGPCommand.FourGBEnable = FourGB;  
        Status = AgpLibSetMasterCapability(AgpExtension, &MasterCap);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AGPVIAInitializeDevice - AgpLibSetMasterCapability %08lx failed %08lx\n",
                    &MasterCap,
                    Status));
        }
    }

#if DBG
    //
    // Read them back, see if it worked
    //
    Status = AgpLibGetMasterCapability(AgpExtension, &CurrentCap);
    ASSERT(NT_SUCCESS(Status));

    //
    // If the target request queue depth is greater than the master will
    // allow, it will be trimmed.   Loosen the assert to not require an
    // exact match.
    //
    ASSERT(CurrentCap.AGPCommand.RequestQueueDepth <= MasterCap.AGPCommand.RequestQueueDepth);
    CurrentCap.AGPCommand.RequestQueueDepth = MasterCap.AGPCommand.RequestQueueDepth;
    ASSERT(RtlEqualMemory(&CurrentCap.AGPCommand, &MasterCap.AGPCommand, sizeof(CurrentCap.AGPCommand)));

    Status = AgpLibGetPciDeviceCapability(0,0,&CurrentCap);
    ASSERT(NT_SUCCESS(Status));
    ASSERT(RtlEqualMemory(&CurrentCap.AGPCommand, &TargetCap.AGPCommand, sizeof(CurrentCap.AGPCommand)));

#endif

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\isapnp\bus.c ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    bus.c

Abstract:


Author:

    Shie-Lin Tzong (shielint) July-26-1995

Environment:

    Kernel mode only.

Revision History:

--*/

#include "busp.h"
#include "pnpisa.h"

#if ISOLATE_CARDS

BOOLEAN
PipIsDeviceInstanceInstalled(
    IN HANDLE Handle,
    IN PUNICODE_STRING DeviceInstanceName
    );

VOID
PipInitializeDeviceInfo (
                 IN OUT PDEVICE_INFORMATION deviceInfo,
                 IN PCARD_INFORMATION cardinfo,
                 IN USHORT index
                 );

NTSTATUS
PipGetInstalledLogConf(
    IN HANDLE EnumHandle,
    IN PDEVICE_INFORMATION DeviceInfo,
    OUT PHANDLE LogConfHandle
);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,PipCreateReadDataPort)
#pragma alloc_text(PAGE,PipStartReadDataPort)
#pragma alloc_text(PAGE,PipStartAndSelectRdp)
#pragma alloc_text(PAGE,PipCheckBus)
#pragma alloc_text(PAGE,PipIsDeviceInstanceInstalled)
#pragma alloc_text(PAGE,PipGetInstalledLogConf)
#pragma alloc_text(PAGE,PipInitializeDeviceInfo)
#endif

VOID
PipVerifyCards(
    IN OUT ULONG *CardsExpected
    )
/*++

Routine Description:

    This routine checks to see how many cards can be found using the
    current RDP resources.

Arguments:

    CardsExpected - Pointer to ULONG in which to store the number of
    cards found and minimally verified.

Return Value:

    None

--*/
{
    ULONG j, cardsDetected = 0;
    NTSTATUS status;

    ASSERT(PipState == PiSSleep);
    if (*CardsExpected == 0) {
        return;
    }

    for (j = 1; j <= *CardsExpected; j++) {
        ULONG noDevices, dataLength;
        PUCHAR cardData;

        PipConfig((UCHAR)j);
        status = PipReadCardResourceData (
                                          &noDevices,
                                          &cardData,
                                          &dataLength);
        if (!NT_SUCCESS(status)) {
            continue;
        } else {
            ExFreePool(cardData);
            cardsDetected++;
        }
    }
    *CardsExpected = cardsDetected;
}

NTSTATUS
PipStartAndSelectRdp(
    PDEVICE_INFORMATION DeviceInfo,
    PPI_BUS_EXTENSION BusExtension,
    PDEVICE_OBJECT  DeviceObject,
    PCM_RESOURCE_LIST StartResources
    )
/*++

Routine Description:

    This routine selects an RDP and trims down the resources to just the RDP.

Arguments:

    DeviceInfo - device extension for RDP
    BusExtension - device extension for BUS object
    DeviceObject - device object for RDP
    StartResources - the start resources we received in the RDP start irp

Return Value:

   STATUS_SUCCESS = Current resources are fine but need trimming

   anything else - current resources failed in some way

--*/
{
    ULONG i, j, CardsFound, LastMapped = -1;
    NTSTATUS status;
    
    // Already tested for null start resources, and start resource list too small

    status = PipMapAddressAndCmdPort(BusExtension);
    if (!NT_SUCCESS(status)) {
        DebugPrint((DEBUG_ERROR, "failed to map the address and command ports\n"));
        return status;
    }

    for (i = 2, j = 0; i < StartResources->List->PartialResourceList.Count; i++, j++) {

        PipReadDataPortRanges[j].CardsFound = 0;
        // RDP possibilities that we didn't get.
        if (StartResources->List->PartialResourceList.PartialDescriptors[i].u.Port.Length == 0) {
            continue;
        }

        status = PipMapReadDataPort(
                                    BusExtension,
                                    StartResources->List->PartialResourceList.PartialDescriptors[i].u.Port.Start,
                                    StartResources->List->PartialResourceList.PartialDescriptors[i].u.Port.Length
                                    );
        if (!NT_SUCCESS(status))
        {
            DebugPrint((DEBUG_ERROR, "failed to map RDP range\n"));
            continue;
        }
    
        LastMapped = i;

        PipIsolateCards(&CardsFound);
        DebugPrint((DEBUG_STATE, "Found %d cards at RDP %x\n", CardsFound, BusExtension->ReadDataPort));

#if 0
        PipVerifyCards(&CardsFound);
        DebugPrint((DEBUG_STATE, "Found %d cards at RDP %x, verified OK\n", CardsFound, BusExtension->ReadDataPort));
#endif

        PipReadDataPortRanges[j].CardsFound = CardsFound;

        PipWaitForKey();
    }

    if (LastMapped == -1) {     // never mapped a RDP successfully
        PipCleanupAcquiredResources(BusExtension);
        return STATUS_CONFLICTING_ADDRESSES;
    }

    //
    // Establish that we want trimmed resource requirements and that
    // we're still processing the RDP.
    // 
    ASSERT((DeviceInfo->Flags & DF_PROCESSING_RDP) == 0);
    DeviceInfo->Flags |= DF_PROCESSING_RDP|DF_REQ_TRIMMED;

    //
    // Release unwanted resources.
    //
    PipCleanupAcquiredResources(BusExtension);

    IoInvalidateDeviceState(DeviceObject);
    return STATUS_SUCCESS;
}


NTSTATUS
PipStartReadDataPort(
    PDEVICE_INFORMATION DeviceInfo,
    PPI_BUS_EXTENSION BusExtension,
    PDEVICE_OBJECT  DeviceObject,
    PCM_RESOURCE_LIST StartResources
    )
{
    NTSTATUS status;
    ULONG i, CardsFound;

    if (StartResources == NULL) {
        DebugPrint((DEBUG_ERROR, "Start RDP with no resources?\n"));
        ASSERT(0);
        return STATUS_UNSUCCESSFUL;
    }

    if (StartResources->List->PartialResourceList.Count < 2) {
        DebugPrint((DEBUG_ERROR, "Start RDP with insufficient resources?\n"));
        ASSERT(0);
        return STATUS_UNSUCCESSFUL;
    }

    if (StartResources->List->PartialResourceList.Count > 3) {
        return PipStartAndSelectRdp(
                                    DeviceInfo,
                                    BusExtension,
                                    DeviceObject,
                                    StartResources
                                    );
    }

    DebugPrint((DEBUG_STATE|DEBUG_PNP,
                "Starting RDP as port %x\n",
                StartResources->List->PartialResourceList.PartialDescriptors[2].u.Port.Start.LowPart + 3));

    status = PipMapAddressAndCmdPort(BusExtension);
    if (!NT_SUCCESS(status)) {
        DebugPrint((DEBUG_ERROR, "failed to map the address and command ports\n"));
        return status;
    }

    status = PipMapReadDataPort(
        BusExtension,
        StartResources->List->PartialResourceList.PartialDescriptors[2].u.Port.Start,
        StartResources->List->PartialResourceList.PartialDescriptors[2].u.Port.Length
        );

    if (!NT_SUCCESS(status)) {
        // BUGBUG probably have to free something
        DebugPrint((DEBUG_ERROR, "failed to map RDP range\n"));
        return status;
    }
    
    PipIsolateCards(&CardsFound);
    DebugPrint((DEBUG_STATE, "Found %d cards at RDP %x, WaitForKey\n", CardsFound, BusExtension->ReadDataPort));

#if 0
    PipVerifyCards(&CardsFound);
    DebugPrint((DEBUG_STATE, "Found %d cards are OK at RDP %x, WaitForKey\n", CardsFound, BusExtension->ReadDataPort));
#endif

    DeviceInfo->Flags &= ~DF_PROCESSING_RDP;
    DeviceInfo->Flags |= DF_ACTIVATED;

    PipWaitForKey();

    return status;
}

NTSTATUS
PipCreateReadDataPortBootResources(
    IN PDEVICE_INFORMATION DeviceInfo
    )
/*++

Routine Description:

    This routine creates the CM_RESOURCE_LIST reported as a partial
    boot config for the RDP.  This ensures that the RDP start isn't
    deferred excessively.

Arguments:

    DeviceInfo - device extension for PDO

Return Value:

    STATUS_SUCCESS

    STATUS_INSUFFICIENT_RESOURCES

--*/
{
    PCM_RESOURCE_LIST bootResources;
    PCM_PARTIAL_RESOURCE_LIST partialResList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDesc;
    ULONG bootResourcesSize, i;

    bootResourcesSize = sizeof(CM_RESOURCE_LIST) +
        sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);
                
    bootResources = ExAllocatePool(PagedPool,
                                   bootResourcesSize);
    if (bootResources == NULL) {
         return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(bootResources, bootResourcesSize);

    bootResources->Count = 1;
    partialResList = (PCM_PARTIAL_RESOURCE_LIST)&bootResources->List[0].PartialResourceList;
    partialResList->Version = 0;
    partialResList->Revision = 0x3000;
    partialResList->Count = 2;
    partialDesc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)&partialResList->PartialDescriptors[0];

    for (i = 0; i < 2; i++) {
        partialDesc->Type = CmResourceTypePort;
        partialDesc->ShareDisposition = CmResourceShareDeviceExclusive;
        partialDesc->Flags = CM_RESOURCE_PORT_IO;
        if (i == 0) {
            partialDesc->u.Port.Start.LowPart = COMMAND_PORT;
        }
        else {
            partialDesc->u.Port.Start.LowPart = ADDRESS_PORT;
        }
        partialDesc->Flags = CM_RESOURCE_PORT_16_BIT_DECODE;
        partialDesc->u.Port.Length = 1;
        partialDesc++;
    }
    DeviceInfo->BootResources = bootResources;
    DeviceInfo->BootResourcesLength = bootResourcesSize;

    return STATUS_SUCCESS;
}


NTSTATUS
PipCreateReadDataPort(
    PPI_BUS_EXTENSION BusExtension
    )
/*++

Routine Description:

    This routine isolates all the PNP ISA cards.

Arguments:

    None.

Return Value:

    Always return STATUS_UNSUCCESSFUL.

--*/
{
    NTSTATUS status;
    PUCHAR readDataPort = NULL;
    PDEVICE_INFORMATION deviceInfo;
    PDEVICE_OBJECT pdo;

    status = IoCreateDevice(PipDriverObject,
                            sizeof(PDEVICE_INFORMATION),
                            NULL,    
                            FILE_DEVICE_BUS_EXTENDER,
                            FILE_AUTOGENERATED_DEVICE_NAME,
                            FALSE,
                            &pdo);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    // Create a physical device object to represent this logical function
    //
    deviceInfo = ExAllocatePoolWithTag(NonPagedPool,
                                       sizeof(DEVICE_INFORMATION),
                                       'iPnP');
    if (!deviceInfo) {
        DebugPrint((DEBUG_ERROR, "PnpIsa:failed to allocate DEVICEINFO structure\n"));
        IoDeleteDevice(pdo);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    PipInitializeDeviceInfo (deviceInfo,NULL,0);

    status = PipCreateReadDataPortBootResources(deviceInfo);

    if (NT_SUCCESS(status)) {
        deviceInfo->PhysicalDeviceObject = pdo;

        //
        // Mark this node as the special read data port node
        //
        deviceInfo->Flags |= DF_ENUMERATED|DF_READ_DATA_PORT;
        deviceInfo->Flags &= ~DF_NOT_FUNCTIONING;
        deviceInfo->PhysicalDeviceObject->DeviceExtension = (PVOID)deviceInfo;
        deviceInfo->ParentDeviceExtension = BusExtension;

        PipRDPNode = deviceInfo;

        PipLockDeviceDatabase();
        PushEntryList (&BusExtension->DeviceList,
                       &deviceInfo->DeviceList
                       );
        PipUnlockDeviceDatabase();

        deviceInfo->PhysicalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    } else {
        IoDeleteDevice(pdo);
        ExFreePool(deviceInfo);
    }

    return status;
}

//
// PipCheckBus and PipMinimalCheckBus enumerate the ISAPNP cards present.
// 
// PipMinimalCheckBus is used on return from hibernation to avoid
// having to make everything referenced by PipCheckBus non-pageable.
//
// Conventions:
//  * Cards are marked dead by setting their CSN to 0.
//  * Cards are marked potentially missing by setting their CSN to -1.
//    Cards that are found later in the routines have their CSNs
//    properly set, any remaining cards get their CSN set to 0.
//  * Logical devices of dead cards have the DF_NOT_FUNCTIONING flag set.
//

BOOLEAN
PipMinimalCheckBus (
    IN PPI_BUS_EXTENSION BusExtension
    )
/*++

Routine Description:

    This routine enumerates the ISAPNP cards on return from hibernate.
    It is a subset of PipCheckBus and assumes that PipCheckBus will be
    run shortly thereafter.  It deals with cards that disappear after
    hibernate or new cards that have appeared.  It's primary task is
    to put cards where they used to be before the hibernate.

Arguments:

    BusExtension - FDO extension

Return Value:

    None

--*/
{
    PDEVICE_INFORMATION deviceInfo;
    PCARD_INFORMATION cardInfo;
    PSINGLE_LIST_ENTRY cardLink, deviceLink;
    ULONG dataLength, noDevices, logicalDevice, FoundCSNs, i;
    NTSTATUS status;
    USHORT  csn;
    PUCHAR cardData;
    BOOLEAN needsFullRescan = FALSE;

    DebugPrint((DEBUG_POWER | DEBUG_ISOLATE,
                "Minimal check bus for restore: %d CSNs expected\n",
                BusExtension->NumberCSNs
                ));

    DebugPrint((DEBUG_POWER, "reset csns in extensions\n"));

    // forget any previously issued CSNs
    cardLink = BusExtension->CardList.Next;
    while (cardLink) {
        cardInfo = CONTAINING_RECORD (cardLink, CARD_INFORMATION, CardList);
        if (cardInfo->CardSelectNumber != 0) {
            cardInfo->CardSelectNumber = (USHORT) -1;
        }
        cardLink = cardInfo->CardList.Next;
    }

    //
    // Perform Pnp isolation process.  This will assign card select number for each
    // Pnp Isa card isolated by the system.  All the isolated cards will be left in
    // isolation state.
    //

    if (PipReadDataPort && PipCommandPort && PipAddressPort) {

        PipIsolateCards(&FoundCSNs);

        DebugPrint((DEBUG_POWER | DEBUG_ISOLATE,
                    "Minimal check bus for restore: %d cards found\n",
                    FoundCSNs));
    } else {
        //
        // If we can't enumerate (no resources) stop now
        //
        DebugPrint((DEBUG_POWER | DEBUG_ISOLATE,
                    "Minimal check bus failed, no resources\n"));
        PipWaitForKey();
        return FALSE;
    }

    //
    // For each card selected build CardInformation and DeviceInformation structures.
    //
    // PipLFSRInitiation(); BUG?

    for (csn = 1; csn <= FoundCSNs; csn++) {
        
        PipConfig((UCHAR)csn);
        status = PipReadCardResourceData (
                            &noDevices,
                            &cardData,
                            &dataLength);
        if (!NT_SUCCESS(status)) {

            DebugPrint((DEBUG_ERROR | DEBUG_POWER, "CSN %d gives bad resource data\n", csn));
            continue;
        }

        cardInfo = PipIsCardEnumeratedAlready(BusExtension, cardData, dataLength);
        if (!cardInfo) {
            DebugPrint((DEBUG_ERROR | DEBUG_POWER,
                        "No match for card CSN %d, turning off\n", csn));
            for (i = 0; i < noDevices; i++) {
                PipSelectDevice((UCHAR) i);
                PipDeactivateDevice();
            }
            needsFullRescan = TRUE;
            continue;
        }

        cardInfo->CardSelectNumber = csn;

        for (deviceLink = cardInfo->LogicalDeviceList.Next; deviceLink;
             deviceLink = deviceInfo->LogicalDeviceList.Next) {             

            deviceInfo = CONTAINING_RECORD (deviceLink, DEVICE_INFORMATION, LogicalDeviceList);
            if (deviceInfo->Flags & DF_NOT_FUNCTIONING) {
                continue;
            }

            PipSelectDevice((UCHAR)deviceInfo->LogicalDeviceNumber);
            if ((deviceInfo->DevicePowerState == PowerDeviceD0) &&
                (deviceInfo->Flags & DF_ACTIVATED))
            {
                DebugPrint((DEBUG_POWER, "CSN %d/LDN %d was never powered off\n",
                            (ULONG) deviceInfo->LogicalDeviceNumber,
                            (ULONG) csn));
                PipDeactivateDevice();
                (VOID) PipSetDeviceResources(deviceInfo,
                                             deviceInfo->AllocatedResources);
                PipActivateDevice();
            } else {
                PipDeactivateDevice();
            }
        }
    }
    
    cardLink = BusExtension->CardList.Next;
    while (cardLink) {
        cardInfo = CONTAINING_RECORD (cardLink, CARD_INFORMATION, CardList);
        if (cardInfo->CardSelectNumber == (USHORT)-1) {
            DebugPrint((DEBUG_ERROR, "Marked a card as DEAD, logical devices\n"));
            cardInfo->CardSelectNumber = (USHORT)0;  // Mark it is no longer present
            deviceLink = cardInfo->LogicalDeviceList.Next;
            while (deviceLink) {
                deviceInfo = CONTAINING_RECORD (deviceLink, DEVICE_INFORMATION, LogicalDeviceList);
                deviceInfo->Flags |= DF_NOT_FUNCTIONING;
                deviceLink = deviceInfo->LogicalDeviceList.Next;
            }
            needsFullRescan = TRUE;
        }
        cardLink = cardInfo->CardList.Next;
    }

    PipWaitForKey();

    return needsFullRescan;
}



VOID
PipCheckBus (
    IN PPI_BUS_EXTENSION BusExtension
    )
/*++

Routine Description:

    The function enumerates the bus specified by BusExtension

Arguments:

    BusExtension - supplies a pointer to the BusExtension structure of the bus
                   to be enumerated.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    ULONG objectSize, noDevices;
    OBJECT_ATTRIBUTES objectAttributes;
    PUCHAR cardData;
    ULONG dataLength;
    USHORT csn, i, detectedCsn = 0, irqReqFlags, irqBootFlags;
    PDEVICE_INFORMATION deviceInfo;
    PCARD_INFORMATION cardInfo;
    UCHAR tmp;
    PSINGLE_LIST_ENTRY link;
    ULONG dumpData;
    UNICODE_STRING unicodeString;
    HANDLE logConfHandle, enumHandle = NULL;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    PCM_RESOURCE_LIST cmResource;
    BOOLEAN conflictDetected,requireEdge;
    ULONG dummy, bootFlags = 0;

    PSINGLE_LIST_ENTRY deviceLink;
    PSINGLE_LIST_ENTRY cardLink;

    // mark all cards as 'maybe missing'

    cardLink = BusExtension->CardList.Next;
    while (cardLink) {
        cardInfo = CONTAINING_RECORD (cardLink, CARD_INFORMATION, CardList);
        if (cardInfo->CardSelectNumber != (USHORT)0) {
            cardInfo->CardSelectNumber = (USHORT)-1;
        }
        cardLink = cardInfo->CardList.Next;
    }

    //
    // Clear DF_ENUMERTED flag for all the devices.
    //

    deviceLink = BusExtension->DeviceList.Next;
    while (deviceLink) {
        deviceInfo = CONTAINING_RECORD (deviceLink, DEVICE_INFORMATION, DeviceList);
        if (!(deviceInfo->Flags & DF_READ_DATA_PORT)) {
            deviceInfo ->Flags &= ~DF_ENUMERATED;
        }
        deviceLink = deviceInfo->DeviceList.Next;
    }

    //
    // Perform Pnp isolation process.  This will assign card select number for each
    // Pnp Isa card isolated by the system.  All the isolated cards will be left in
    // isolation state.
    //

    if (PipReadDataPort && PipCommandPort && PipAddressPort) {
        DebugPrint((DEBUG_PNP, "QueryDeviceRelations checking the BUS\n"));
        PipIsolateCards(&BusExtension->NumberCSNs);
    } else {
        //
        // If we can't enumerate (no resources) stop now
        //
        DebugPrint((DEBUG_PNP, "QueryDeviceRelations: No RDP\n"));
        return;
    }

    DebugPrint((DEBUG_PNP, "CheckBus found %d cards\n",
                BusExtension->NumberCSNs));
#if NT4_DRIVER_COMPAT

    //
    // If there is no PnpISA card, we are done.
    // Oterwise, open HKLM\System\CCS\ENUM\PNPISA.
    //

    if (BusExtension->NumberCSNs != 0) {

        RtlInitUnicodeString(
                 &unicodeString,
                 L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\ENUM");
        status = PipOpenRegistryKey(&enumHandle,
                                    NULL,
                                    &unicodeString,
                                    KEY_ALL_ACCESS,
                                    FALSE
                                    );
        if (!NT_SUCCESS(status)) {
            dumpData = status;
            PipLogError(PNPISA_OPEN_CURRENTCONTROLSET_ENUM_FAILED,
                        PNPISA_CHECKDEVICE_1,
                        status,
                        &dumpData,
                        1,
                        0,
                        NULL
                        );

            DebugPrint((DEBUG_ERROR, "PnPIsa: Unable to open HKLM\\SYSTEM\\CCS\\ENUM"));
            return;
        }
    }

#endif // NT4_DRIVER_COMPAT

    //
    // For each card selected build CardInformation and DeviceInformation structures.
    //

    for (csn = 1; csn <= BusExtension->NumberCSNs; csn++) {

        PipConfig((UCHAR)csn);
        status = PipReadCardResourceData (
                            &noDevices,
                            &cardData,
                            &dataLength);
        if (!NT_SUCCESS(status)) {
            //
            // card will marked 'not functioning' later
            //
            DebugPrint((DEBUG_ERROR, "PnpIsaCheckBus: Found a card which gives bad resource data\n"));
            continue;
        }

        detectedCsn++;

        cardInfo = PipIsCardEnumeratedAlready(BusExtension, cardData, dataLength);

        if (!cardInfo) {

            //
            // Allocate and initialize card information and its associate device
            // information structures.
            //

            cardInfo = (PCARD_INFORMATION)ExAllocatePoolWithTag(
                                                  NonPagedPool,
                                                  sizeof(CARD_INFORMATION),
                                                  'iPnP');
            if (!cardInfo) {
                dumpData = sizeof(CARD_INFORMATION);
                PipLogError(PNPISA_INSUFFICIENT_POOL,
                            PNPISA_CHECKBUS_1,
                            STATUS_INSUFFICIENT_RESOURCES,
                            &dumpData,
                            1,
                            0,
                            NULL
                            );

                ExFreePool(cardData);
                DebugPrint((DEBUG_ERROR, "PnpIsaCheckBus: failed to allocate CARD_INFO structure\n"));
                continue;
            }

            //
            // Initialize card information structure
            //

            RtlZeroMemory(cardInfo, sizeof(CARD_INFORMATION));
            cardInfo->CardSelectNumber = csn;
            cardInfo->NumberLogicalDevices = noDevices;
            cardInfo->CardData = cardData;
            cardInfo->CardDataLength = dataLength;
            cardInfo->CardFlags = PipGetCardFlags(cardInfo);

            PushEntryList (&BusExtension->CardList,
                           &cardInfo->CardList
                           );
            DebugPrint ((DEBUG_ISOLATE, "adding one pnp card %x\n",
                         cardInfo));

            //
            // For each logical device supported by the card build its DEVICE_INFORMATION
            // structures.
            //

            cardData += sizeof(SERIAL_IDENTIFIER);
            dataLength -= sizeof(SERIAL_IDENTIFIER);
            PipFindNextLogicalDeviceTag(&cardData, &dataLength);

            //
            // Select card
            //

            for (i = 0; i < noDevices; i++) {       // logical device number starts from 0

                //
                // Create and initialize device tracking structure (Device_Information.)
                //

                deviceInfo = (PDEVICE_INFORMATION) ExAllocatePoolWithTag(
                                                     NonPagedPool,
                                                     sizeof(DEVICE_INFORMATION),
                                                     'iPnP');
                if (!deviceInfo) {
                    dumpData = sizeof(DEVICE_INFORMATION);
                    PipLogError(PNPISA_INSUFFICIENT_POOL,
                                PNPISA_CHECKBUS_2,
                                STATUS_INSUFFICIENT_RESOURCES,
                                &dumpData,
                                1,
                                0,
                                NULL
                                );

                    DebugPrint((DEBUG_ERROR, "PnpIsa:failed to allocate DEVICEINFO structure\n"));
                    continue;
                }

                //
                // This sets card data to point to the next device.
                //
                PipInitializeDeviceInfo (deviceInfo,cardInfo,i);

                deviceInfo->ParentDeviceExtension = BusExtension;

                //
                // cardData is UPDATED by this routine to the next logical device.
                //
                deviceInfo->DeviceData = cardData;
                if (cardData) {
                    deviceInfo->DeviceDataLength = PipFindNextLogicalDeviceTag(&cardData, &dataLength);
                } else {
                    deviceInfo->DeviceDataLength = 0;
                    ASSERT(deviceInfo->DeviceDataLength != 0);
                    continue;
                }

                ASSERT(deviceInfo->DeviceDataLength != 0);

                // 
                // The PNP ISA spec lets the device specify IRQ
                // settings that don't actually work, and some that
                // work rarely.  And some devices just get it wrong.
                //
                // IRQ edge/level interpretation strategy:
                //
                // * Extract the irq requirements from the tags on a
                // per device basis.
                // * Extract the boot config, note edge/level settings
                // * Trust the boot config over requirements.  When in
                // doubt, assume edge.
                // * Fix boot config and requirements to reflect the
                // edge/level settings we've decided upon.
                // * Ignore the high/low settings in the requirements
                // and in the boot config.  Only support high- // edge
                // and low-level.
                //
                
                // Determine whether requirements specify edge or
                // level triggered interrupts.  Unfortunately, we
                // don't build the IO_REQUIREMENTS_LIST until later,
                // so just examine the tags.

                irqReqFlags = PipIrqLevelRequirementsFromDeviceData(
                    deviceInfo->DeviceData,
                    deviceInfo->DeviceDataLength
                    );

                DebugPrint((DEBUG_IRQ, "Irqs for CSN %d/LDN %d are %s\n",
                            deviceInfo->CardInformation->CardSelectNumber,
                            deviceInfo->LogicalDeviceNumber,
                            (irqReqFlags == CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE) ? "level" : "edge"));

                //
                // Select the logical device, disable its io range check
                // and read its boot config before disabling it.
                //

                PipSelectDevice((UCHAR)i);
                if (!(deviceInfo->CardInformation->CardFlags & CF_IGNORE_BOOTCONFIG)) {
                    status = PipReadDeviceResources (
                        0,
                        deviceInfo->DeviceData,
                        deviceInfo->CardInformation->CardFlags,
                        &deviceInfo->BootResources,
                        &deviceInfo->BootResourcesLength,
                        &irqBootFlags
                        );
                    if (!NT_SUCCESS(status)) {
                        deviceInfo->BootResources = NULL;
                        deviceInfo->BootResourcesLength = 0;

                        // If we had a boot config on this boot,
                        // extract saved irqBootFlags that we saved earlier.
                        status = PipGetBootIrqFlags(deviceInfo, &irqBootFlags);
                        if (!NT_SUCCESS(status)) {
                            // if we have no boot config, and no saved
                            // boot config from earlier this boot then
                            // we are going to take a shot in the dark
                            // and declare it edge.  Experience has
                            // shown that if you actually believe
                            // resource requirements of level w/o
                            // confirmation from the BIOS, then you
                            // die horribly.  Very very few cards
                            // actually do level and do it right.

                            irqBootFlags = CM_RESOURCE_INTERRUPT_LATCHED;
                            (VOID) PipSaveBootIrqFlags(deviceInfo, irqBootFlags);
                        }
                    } else {
                        // save irqBootFlags in case the RDP gets
                        // removed and our boot config is lost.
                        (VOID) PipSaveBootIrqFlags(deviceInfo, irqBootFlags);
                    }
                    
                    DebugPrint((DEBUG_IRQ, "Irqs (boot config) for CSN %d/LDN %d are %s\n",
                            deviceInfo->CardInformation->CardSelectNumber,
                            deviceInfo->LogicalDeviceNumber,
                            (irqBootFlags == CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE) ? "level" : "edge"));
                } else {
                    // when in doubt....
                    irqBootFlags = CM_RESOURCE_INTERRUPT_LATCHED;
                }
                
                if (irqBootFlags != irqReqFlags) {
                    DebugPrint((DEBUG_IRQ, "Req and Boot config disagree on irq type, favoring boot config"));
                    irqReqFlags = irqBootFlags;
                }

                // override flags in case a card *MUST* be configured
                // one way and the above code fails to do this.
                if (deviceInfo->CardInformation->CardFlags == CF_FORCE_LEVEL) {
                    irqReqFlags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
                } else if (deviceInfo->CardInformation->CardFlags == CF_FORCE_EDGE) {
                    irqReqFlags = CM_RESOURCE_INTERRUPT_LATCHED;
                }

                if (deviceInfo->BootResources) {
                    // apply irq level/edge decision to boot config
                    PipFixBootConfigIrqs(deviceInfo->BootResources,
                                     irqReqFlags);
                    (VOID) PipSaveBootResources(deviceInfo);
                    cmResource = deviceInfo->BootResources;
                } else {
                   status = PipGetSavedBootResources(deviceInfo, &cmResource);
                   if (!NT_SUCCESS(status)) {
                       cmResource = NULL;
                   }
                }

#if 0
                PipWriteAddress(IO_RANGE_CHECK_PORT);
                tmp = PipReadData();
                tmp &= ~2;
                PipWriteAddress(IO_RANGE_CHECK_PORT);
                PipWriteData(tmp);
#endif
                PipDeactivateDevice();

                PipQueryDeviceResourceRequirements (
                    deviceInfo,
                    0,             // Bus Number
                    0,             // Slot number??
                    cmResource,
                    irqReqFlags,
                    &deviceInfo->ResourceRequirements,
                    &dumpData
                    );

                if (cmResource && !deviceInfo->BootResources) {
                    ExFreePool(cmResource);
                    cmResource = NULL;
                }

                //
                // Create a physical device object to represent this logical function
                //
                status = IoCreateDevice( PipDriverObject,
                                         sizeof(PDEVICE_INFORMATION),
                                         NULL,
                                         FILE_DEVICE_BUS_EXTENDER,
                                         FILE_AUTOGENERATED_DEVICE_NAME,
                                         FALSE,
                                         &deviceInfo->PhysicalDeviceObject);
                if (NT_SUCCESS(status)) {
                    deviceInfo->Flags |= DF_ENUMERATED;
                    deviceInfo->Flags &= ~DF_NOT_FUNCTIONING;
                    deviceInfo->PhysicalDeviceObject->DeviceExtension = (PVOID)deviceInfo;
                    //
                    // Add it to the logical device list of the pnp isa card.
                    //

                    PushEntryList (&cardInfo->LogicalDeviceList,
                                   &deviceInfo->LogicalDeviceList
                                   );

                    //
                    // Add it to the list of devices for this bus
                    //

                    PushEntryList (&BusExtension->DeviceList,
                                   &deviceInfo->DeviceList
                                   );

#if NT4_DRIVER_COMPAT

                    //
                    // Check should we enable this device.  If the device has
                    // Service setup and ForcedConfig then enable the device.
                    //

                    logConfHandle = NULL;
                    status = PipGetInstalledLogConf(enumHandle,
                                               deviceInfo,
                                               &logConfHandle);
                    if (NT_SUCCESS(status)) {
                                //
                                // Read the boot config selected by user and activate the device.
                                // First check if ForcedConfig is set.  If not, check BootConfig.
                                //

                        status = PipGetRegistryValue(logConfHandle,
                                                     L"ForcedConfig",
                                                     &keyValueInformation);
                        if (NT_SUCCESS(status)) {
                            if ((keyValueInformation->Type == REG_RESOURCE_LIST) &&
                                (keyValueInformation->DataLength != 0)) {
                                cmResource = (PCM_RESOURCE_LIST)
                                    KEY_VALUE_DATA(keyValueInformation);
                                //
                                // Act as if force config
                                // reflected the level/edge
                                // decision we made based on
                                // the boot config and
                                // resource requirements.
                                //
                                        
                                PipFixBootConfigIrqs(cmResource,
                                                     irqReqFlags);
                                        
                                conflictDetected = FALSE;

                                //
                                // Before activating the device, make sure no one is using
                                // the resources.
                                //

                                status = IoReportResourceForDetection(
                                    PipDriverObject,
                                    NULL,
                                    0,
                                    deviceInfo->PhysicalDeviceObject,
                                    cmResource,
                                    keyValueInformation->DataLength,
                                    &conflictDetected
                                    );
                                if (NT_SUCCESS(status) && (conflictDetected == FALSE)) {

                                    //
                                    // Set resources and activate the device.
                                    //

                                    status = PipSetDeviceResources (deviceInfo, cmResource);
                                    if (NT_SUCCESS(status)) {
                                        PipActivateDevice();
                                        deviceInfo->Flags |= DF_ACTIVATED;
                                        deviceInfo->Flags &= ~DF_REMOVED;

                                        //
                                        // Write ForcedConfig to AllocConfig
                                        //

                                        RtlInitUnicodeString(&unicodeString, L"AllocConfig");
                                        ZwSetValueKey(logConfHandle,
                                                      &unicodeString,
                                                      0,
                                                      REG_RESOURCE_LIST,
                                                      cmResource,
                                                      keyValueInformation->DataLength
                                                      );

                                        //
                                        // Make ForcedConfig our new BootConfig.
                                        //

                                        if (deviceInfo->BootResources) {
                                            ExFreePool(deviceInfo->BootResources);
                                            deviceInfo->BootResourcesLength = 0;
                                            deviceInfo->BootResources = NULL;
                                        }
                                        deviceInfo->BootResources = (PCM_RESOURCE_LIST) ExAllocatePool (
                                            PagedPool, keyValueInformation->DataLength);
                                        if (deviceInfo->BootResources) {
                                            deviceInfo->BootResourcesLength = keyValueInformation->DataLength;
                                            RtlMoveMemory(deviceInfo->BootResources,
                                                          cmResource,
                                                          deviceInfo->BootResourcesLength
                                                          );
                                        }
                                        deviceInfo->DevicePowerState = PowerDeviceD0;
                                        deviceInfo->LogConfHandle = logConfHandle;
                                    }

                                    //
                                    // Release the resources.  If someone else gets the resources
                                    // before us, then ....
                                    //

                                    dummy = 0;
                                    IoReportResourceForDetection(
                                        PipDriverObject,
                                        NULL,
                                        0,
                                        deviceInfo->PhysicalDeviceObject,
                                        (PCM_RESOURCE_LIST) &dummy,
                                        sizeof(dummy),
                                        &conflictDetected
                                        );
                                }
                            }
                            ExFreePool(keyValueInformation);
                        }
                        if (deviceInfo->LogConfHandle == NULL) {
                            ZwClose(logConfHandle);
                        }
                    }
#endif
                    deviceInfo->PhysicalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
                } else {
                    // NTRAID#20181
                    // Still leaking the DeviceInfo structure
                    // and it's contents if IoCreateDevice failed.
                }
            }
        } else {

            //
            // The card has been enumerated and setup.  We only need to change the CSN.
            //

            cardInfo->CardSelectNumber = csn;
            ExFreePool(cardData);

            //
            // Set DF_ENUMERATED flag on all the logical devices on the isapnp card.
            //

            deviceLink = cardInfo->LogicalDeviceList.Next;
            while (deviceLink) {
                deviceInfo = CONTAINING_RECORD (deviceLink, DEVICE_INFORMATION, LogicalDeviceList);
                if (!(deviceInfo->Flags & DF_NOT_FUNCTIONING)) {
                    deviceInfo->Flags |= DF_ENUMERATED;
                }
                // what did this accomplish?
                if ((deviceInfo->DevicePowerState == PowerDeviceD0) &&
                    (deviceInfo->Flags & DF_ACTIVATED)) {                
                    PipSelectDevice((UCHAR)deviceInfo->LogicalDeviceNumber);
                    PipActivateDevice();
                }
                deviceLink = deviceInfo->LogicalDeviceList.Next;
            }
        }
    }

    //
    // Go through the card link list for cards that we didn't find this time.
    //

    cardLink = BusExtension->CardList.Next;
    while (cardLink) {
        cardInfo = CONTAINING_RECORD (cardLink, CARD_INFORMATION, CardList);
        if (cardInfo->CardSelectNumber == (USHORT)-1) {
            DebugPrint((DEBUG_ERROR, "Marked a card as DEAD, logical devices\n"));
            cardInfo->CardSelectNumber = (USHORT)0;  // Mark it is no longer present
            deviceLink = cardInfo->LogicalDeviceList.Next;
            while (deviceLink) {
                deviceInfo = CONTAINING_RECORD (deviceLink, DEVICE_INFORMATION, LogicalDeviceList);
                deviceInfo->Flags |= DF_NOT_FUNCTIONING;
                deviceInfo->Flags &= ~DF_ENUMERATED;
                deviceLink = deviceInfo->LogicalDeviceList.Next;
            }
        }
        cardLink = cardInfo->CardList.Next;
    }

#if NT4_DRIVER_COMPAT
    if (enumHandle) {
        ZwClose(enumHandle);
    }
#endif
    //
    // Finaly put all cards into wait for key state.
    //

    DebugPrint((DEBUG_STATE, "All cards ready\n"));
    PipWaitForKey();

    BusExtension->NumberCSNs = detectedCsn;
}

BOOLEAN
PipIsDeviceInstanceInstalled(
    IN HANDLE Handle,
    IN PUNICODE_STRING DeviceInstanceName
    )

/*++

Routine Description:

    This routine checks if the device instance is installed.

Arguments:

    Handle - Supplies a handle to the device instanace key to be checked.

    DeviceInstanceName - supplies a pointer to a UNICODE_STRING which specifies
             the path of the device instance to be checked.

Returns:

    A BOOLEAN value.

--*/

{
    NTSTATUS status;
    ULONG deviceFlags;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    BOOLEAN installed;
    UNICODE_STRING serviceName, unicodeString;
    HANDLE handle, handlex;
    ULONG dumpData;

    //
    // Check if the "Service=" value entry initialized.  If no, its driver
    // is not installed yet.
    //
    status = PipGetRegistryValue(Handle,
                                 L"Service",
                                 &keyValueInformation);
    if (NT_SUCCESS(status)) {
        if ((keyValueInformation->Type == REG_SZ) &&
            (keyValueInformation->DataLength != 0)) {
            serviceName.Buffer = (PWSTR)((PCHAR)keyValueInformation +
                                         keyValueInformation->DataOffset);
            serviceName.MaximumLength = serviceName.Length = (USHORT)keyValueInformation->DataLength;
            if (serviceName.Buffer[(keyValueInformation->DataLength / sizeof(WCHAR)) - 1] == UNICODE_NULL) {
                serviceName.Length -= sizeof(WCHAR);
            }

            //
            // try open the service key to make sure it is a valid key
            //

            RtlInitUnicodeString(
                     &unicodeString,
                     L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\SERVICES");
            status = PipOpenRegistryKey(&handle,
                                        NULL,
                                        &unicodeString,
                                        KEY_READ,
                                        FALSE
                                        );
            if (!NT_SUCCESS(status)) {
                dumpData = status;
                PipLogError(PNPISA_OPEN_CURRENTCONTROLSET_SERVICE_FAILED,
                            PNPISA_CHECKINSTALLED_1,
                            status,
                            &dumpData,
                            1,
                            0,
                            NULL
                            );

                DebugPrint((DEBUG_ERROR, "PnPIsaCheckDeviceInstalled: Can not open CCS\\SERVICES key"));
                ExFreePool(keyValueInformation);
                return FALSE;
            }

            status = PipOpenRegistryKey(&handlex,
                                        handle,
                                        &serviceName,
                                        KEY_READ,
                                        FALSE
                                        );
            ZwClose (handle);
            if (!NT_SUCCESS(status)) {
                dumpData = status;
                PipLogError(PNPISA_OPEN_CURRENTCONTROLSET_SERVICE_DRIVER_FAILED,
                            PNPISA_CHECKINSTALLED_2,
                            status,
                            &dumpData,
                            1,
                            serviceName.Length,
                            serviceName.Buffer
                            );

                DebugPrint((DEBUG_ERROR, "PnPIsaCheckDeviceInstalled: Can not open CCS\\SERVICES key"));
                ExFreePool(keyValueInformation);
                return FALSE;
            }
            ZwClose(handlex);
        }
        ExFreePool(keyValueInformation);
    } else {
        return FALSE;
    }

    //
    // Check if the device instance has been disabled.
    // First check global flag: CONFIGFLAG and then CSCONFIGFLAG.
    //

    deviceFlags = 0;
    status = PipGetRegistryValue(Handle,
                                 L"ConfigFlags",
                                 &keyValueInformation);
    if (NT_SUCCESS(status)) {
        if ((keyValueInformation->Type == REG_DWORD) &&
            (keyValueInformation->DataLength >= sizeof(ULONG))) {
            deviceFlags = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
        }
        ExFreePool(keyValueInformation);
    }

    if (!(deviceFlags & CONFIGFLAG_DISABLED)) {
        deviceFlags = 0;
        status = PipGetDeviceInstanceCsConfigFlags(
                     DeviceInstanceName,
                     &deviceFlags
                     );
        if (NT_SUCCESS(status)) {
            if ((deviceFlags & CSCONFIGFLAG_DISABLED) ||
                (deviceFlags & CSCONFIGFLAG_DO_NOT_CREATE)) {
                deviceFlags = CONFIGFLAG_DISABLED;
            } else {
                deviceFlags = 0;
            }
        }
    }

    installed = TRUE;
    if (deviceFlags & CONFIGFLAG_DISABLED) {
        installed = FALSE;
    }

    return installed;
}

VOID
PipInitializeDeviceInfo (PDEVICE_INFORMATION deviceInfo,
                                 PCARD_INFORMATION cardInfo,
                                 USHORT index
                                )
{
    ULONG dataLength;

    RtlZeroMemory (deviceInfo,sizeof (DEVICE_INFORMATION));
    deviceInfo->Flags = DF_NOT_FUNCTIONING;
    deviceInfo->CardInformation = cardInfo;
    deviceInfo->LogicalDeviceNumber = index;
    deviceInfo->DevicePowerState = PowerDeviceD0;
}


#if NT4_DRIVER_COMPAT

NTSTATUS
PipGetInstalledLogConf(
    IN HANDLE EnumHandle,
    IN PDEVICE_INFORMATION DeviceInfo,
    OUT PHANDLE LogConfHandle
)
{
    HANDLE deviceIdHandle = NULL, uniqueIdHandle = NULL, confHandle = NULL;
    PWCHAR deviceId = NULL, uniqueId = NULL, buffer;
    UNICODE_STRING unicodeString;
    NTSTATUS status;
    USHORT length;
    
    status = PipQueryDeviceId(DeviceInfo, &deviceId, 0);
    if (!NT_SUCCESS(status)) {
        goto Cleanup;
    }

    RtlInitUnicodeString(&unicodeString, deviceId);
    status = PipOpenRegistryKey(&deviceIdHandle,
                                EnumHandle,
                                &unicodeString,
                                KEY_READ,
                                FALSE
                                );
    if (!NT_SUCCESS(status)) {
        goto Cleanup;
    }

    status = PipQueryDeviceUniqueId(DeviceInfo, &uniqueId);
    if (!NT_SUCCESS(status)) {
        goto Cleanup;
    }


    //
    // Open this registry path under HKLM\CCS\System\Enum
    //

    RtlInitUnicodeString(&unicodeString, uniqueId);
    status = PipOpenRegistryKey(&uniqueIdHandle,
                                deviceIdHandle,
                                &unicodeString,
                                KEY_READ,
                                FALSE
                                );
    if (!NT_SUCCESS(status)) {
        goto Cleanup;
    }

    RtlInitUnicodeString(&unicodeString, L"LogConf");
    status = PipOpenRegistryKey(&confHandle,
                                uniqueIdHandle,
                                &unicodeString,
                                KEY_READ,
                                FALSE
                                );
    if (!NT_SUCCESS(status)) {
        goto Cleanup;
    }

    // allocate enough space for "deviceid\uniqueid<unicode null>"
    length = (wcslen(uniqueId) + wcslen(deviceId)) * sizeof(WCHAR) +
        sizeof(WCHAR) + sizeof(WCHAR);
    buffer = ExAllocatePool(PagedPool, length);
    if (buffer == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    swprintf(buffer, L"%s\\%s", deviceId, uniqueId);
    RtlInitUnicodeString(&unicodeString, buffer);

    if (PipIsDeviceInstanceInstalled(uniqueIdHandle, &unicodeString)) {
        status = STATUS_SUCCESS;
        *LogConfHandle = confHandle;
    } else {
        status = STATUS_UNSUCCESSFUL;
    }

    ExFreePool(buffer);

 Cleanup:
    if (uniqueIdHandle) {
        ZwClose(uniqueIdHandle);
    }

    if (uniqueId) {
        ExFreePool(uniqueId);
    }

    if (deviceIdHandle) {
        ZwClose(deviceIdHandle);
    }

    if (deviceId) {
        ExFreePool(deviceId);
    }

    if (!NT_SUCCESS(status)) {
        *LogConfHandle = NULL;
        if (confHandle) {
            ZwClose(confHandle);
        }
    }

    return status;
}

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\agp\alim1541\init.c ===
/*++

Copyright (c) 1996, 1997 Microsoft Corporation

Module Name:

    init.c

Abstract:

    This module contains the initialization code for AGPALi.SYS.

Author:

    John Vert (jvert) 10/21/1997

Modified by:
   
        Chi-Ming Cheng 06/24/1998 Acer Labs, Inc.
        Wang-Kai Tsai  08/29/2000 Acer Labs, Inc.

Revision History:

--*/

#include "ALiM1541.h"

ULONG AgpExtensionSize = sizeof(AGPALi_EXTENSION);
PAGP_FLUSH_PAGES AgpFlushPages;

NTSTATUS
AgpInitializeTarget(
    IN PVOID AgpExtension
    )
/*++

Routine Description:

    Entrypoint for target initialization. This is called first.

Arguments:

    AgpExtension - Supplies the AGP extension

Return Value:

    NTSTATUS

--*/

{
    ULONG VendorId = 0;
    PAGPALi_EXTENSION Extension = AgpExtension;
    UCHAR  HidId;

    //
    // Make sure we are really loaded only on a ALi chipset
    //
    ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &VendorId, 0);
    ASSERT((VendorId == AGP_ALi_1541_IDENTIFIER) ||
           (VendorId == AGP_ALi_1621_IDENTIFIER) ||
           (VendorId == AGP_ALi_1631_IDENTIFIER) ||
           (VendorId == AGP_ALi_1632_IDENTIFIER) ||
           (VendorId == AGP_ALi_1641_IDENTIFIER) ||
           (VendorId == AGP_ALi_1644_IDENTIFIER) ||
           (VendorId == AGP_ALi_1646_IDENTIFIER) ||
           (VendorId == AGP_ALi_1647_IDENTIFIER) ||
           (VendorId == AGP_ALi_1651_IDENTIFIER) ||
           (VendorId == AGP_ALi_1661_IDENTIFIER) ||
           (VendorId == AGP_ALi_1667_IDENTIFIER));

    //
    // Determine which particular chipset we are running on.
    //
    if (VendorId == AGP_ALi_1541_IDENTIFIER) {
        Extension->ChipsetType = ALi1541;
        AgpFlushPages = Agp1541FlushPages;
    } else if (VendorId == AGP_ALi_1621_IDENTIFIER) {
        Extension->ChipsetType = ALi1621;
        ReadConfigUchar(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &HidId, M1621_HIDDEN_REV_ID);
        switch (HidId)
        {
            case 0x31:
                    Extension->ChipsetType = ALi1631;
                    break;
            case 0x32:
                    Extension->ChipsetType = ALi1632;
                    break;
            case 0x41:
                    Extension->ChipsetType = ALi1641;
                    break;
            case 0x43:
                    Extension->ChipsetType = ALi1621;
                    break;        
            default:
                    Extension->ChipsetType = ALi1621;
                    break;
        }
        AgpFlushPages = NULL;
    } else if (VendorId == AGP_ALi_1631_IDENTIFIER) {
        Extension->ChipsetType = ALi1631;
        AgpFlushPages = NULL;
    } else if (VendorId == AGP_ALi_1632_IDENTIFIER) {
        Extension->ChipsetType = ALi1632;
        AgpFlushPages = NULL;
    } else if (VendorId == AGP_ALi_1641_IDENTIFIER) {
        Extension->ChipsetType = ALi1641;
        AgpFlushPages = NULL;
    } else if (VendorId == AGP_ALi_1644_IDENTIFIER) {
        Extension->ChipsetType = ALi1644;
        AgpFlushPages = NULL;
    } else if (VendorId == AGP_ALi_1646_IDENTIFIER) {
        Extension->ChipsetType = ALi1646;
        AgpFlushPages = NULL;
    } else if (VendorId == AGP_ALi_1647_IDENTIFIER) {
        Extension->ChipsetType = ALi1647;
        AgpFlushPages = NULL;
    } else if (VendorId == AGP_ALi_1651_IDENTIFIER) {
        Extension->ChipsetType = ALi1651;
        AgpFlushPages = NULL;    
    } else if (VendorId == AGP_ALi_1661_IDENTIFIER) {
        Extension->ChipsetType = ALi1661;
        AgpFlushPages = NULL;
    } else if (VendorId == AGP_ALi_1667_IDENTIFIER) {
        Extension->ChipsetType = ALi1667;
        AgpFlushPages = NULL;
    } else {
        AGPLOG(AGP_CRITICAL,
               ("AGPALi - AgpInitializeTarget called for platform %08lx which is not a ALi chipset!\n",
                VendorId));
        return(STATUS_UNSUCCESSFUL);
    }

    //
    // Initialize our chipset-specific extension
    //
    Extension->ApertureStart.QuadPart = 0;
    Extension->ApertureLength = 0;
    Extension->Gart = NULL;
    Extension->GartLength = 0;
    Extension->GartPhysical.QuadPart = 0;
    Extension->SpecialTarget = 0;

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpInitializeMaster(
    IN  PVOID AgpExtension,
    OUT ULONG *AgpCapabilities
    )
/*++

Routine Description:

    Entrypoint for master initialization. This is called after target initialization
    and should be used to initialize the AGP capabilities of both master and target.

Arguments:

    AgpExtension - Supplies the AGP extension

    AgpCapabilities - Returns the capabilities of this AGP device.

Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS Status;
    PCI_AGP_CAPABILITY MasterCap;
    PCI_AGP_CAPABILITY TargetCap;
    PAGPALi_EXTENSION Extension = AgpExtension;
    ULONG SBAEnable;
    ULONG DataRate;
    BOOLEAN ReverseInit;

#if DBG
    PCI_AGP_CAPABILITY CurrentCap;
#endif

    //
    // Indicate that we can map memory through the GART aperture
    //
    *AgpCapabilities = AGP_CAPABILITIES_MAP_PHYSICAL;

    //
    // Get the master and target AGP capabilities
    //
    Status = AgpLibGetMasterCapability(AgpExtension, &MasterCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGPALiInitializeDevice - AgpLibGetMasterCapability failed %08lx\n"));
        return(Status);
    }

    //
    // Some broken cards (Matrox Millenium II "AGP") report no valid
    // supported transfer rates. These are not really AGP cards. They
    // have an AGP Capabilities structure that reports no capabilities.
    //
    if (MasterCap.AGPStatus.Rate == 0) {
        AGPLOG(AGP_CRITICAL,
               ("AGP440InitializeDevice - AgpLibGetMasterCapability returned no valid transfer rate\n"));
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

    Status = AgpLibGetPciDeviceCapability(0,0,&TargetCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGPALiInitializeDevice - AgpLibGetPciDeviceCapability failed %08lx\n"));
        return(Status);
    }

    //
    // Determine the greatest common denominator for data rate.
    //
    DataRate = TargetCap.AGPStatus.Rate & MasterCap.AGPStatus.Rate;
    ASSERT(DataRate != 0);

    //
    // Select the highest common rate.
    //
    if (DataRate & PCI_AGP_RATE_4X) {
        DataRate = PCI_AGP_RATE_4X;
    } else if (DataRate & PCI_AGP_RATE_2X) {
        DataRate = PCI_AGP_RATE_2X;
    } else if (DataRate & PCI_AGP_RATE_1X) {
        DataRate = PCI_AGP_RATE_1X;
    }

    //
    // Previously a call was made to change the rate (successfully),
    // use this rate again now
    //
    if (Extension->SpecialTarget & AGP_FLAG_SPECIAL_RESERVE) {
        DataRate = (ULONG)((Extension->SpecialTarget & 
                            AGP_FLAG_SPECIAL_RESERVE) >>
                           AGP_FLAG_SET_RATE_SHIFT);
    }

    //
    // Enable SBA if both master and target support it.
    //
    SBAEnable = (TargetCap.AGPStatus.SideBandAddressing & MasterCap.AGPStatus.SideBandAddressing);

    //
    // Before we enable AGP, apply any workarounds
    //
    AgpWorkaround(Extension);

    //
    // Enable the Master first.
    //
    ReverseInit = 
        (Extension->SpecialTarget & AGP_FLAG_REVERSE_INITIALIZATION) ==
        AGP_FLAG_REVERSE_INITIALIZATION;
    if (ReverseInit) {
        MasterCap.AGPCommand.Rate = DataRate;
        MasterCap.AGPCommand.AGPEnable = 1;
        MasterCap.AGPCommand.SBAEnable = SBAEnable;
        MasterCap.AGPCommand.RequestQueueDepth = TargetCap.AGPStatus.RequestQueueDepthMaximum;
        Status = AgpLibSetMasterCapability(AgpExtension, &MasterCap);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AGPALiInitializeDevice - AgpLibSetMasterCapability %08lx failed %08lx\n",
                    &MasterCap,
                    Status));
        }
    }

    //
    // Now enable the Target.
    //
    TargetCap.AGPCommand.Rate = DataRate;
    TargetCap.AGPCommand.AGPEnable = 1;
    TargetCap.AGPCommand.SBAEnable = SBAEnable;
    Status = AgpLibSetPciDeviceCapability(0, 0, &TargetCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGPALiInitializeDevice - AgpLibSetPciDeviceCapability %08lx for target failed %08lx\n",
                &TargetCap,
                Status));
        return(Status);
    }

    if (!ReverseInit) {
        MasterCap.AGPCommand.Rate = DataRate;
        MasterCap.AGPCommand.AGPEnable = 1;
        MasterCap.AGPCommand.SBAEnable = SBAEnable;
        MasterCap.AGPCommand.RequestQueueDepth = TargetCap.AGPStatus.RequestQueueDepthMaximum;
        Status = AgpLibSetMasterCapability(AgpExtension, &MasterCap);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AGPALiInitializeDevice - AgpLibSetMasterCapability %08lx failed %08lx\n",
                    &MasterCap,
                    Status));
        }
    }

#if DBG
    //
    // Read them back, see if it worked
    //
    Status = AgpLibGetMasterCapability(AgpExtension, &CurrentCap);
    ASSERT(NT_SUCCESS(Status));

    //
    // If the target request queue depth is greater than the master will
    // allow, it will be trimmed.   Loosen the assert to not require an
    // exact match.
    //
    ASSERT(CurrentCap.AGPCommand.RequestQueueDepth <= MasterCap.AGPCommand.RequestQueueDepth);
    CurrentCap.AGPCommand.RequestQueueDepth = MasterCap.AGPCommand.RequestQueueDepth;
    ASSERT(RtlEqualMemory(&CurrentCap.AGPCommand, &MasterCap.AGPCommand, sizeof(CurrentCap.AGPCommand)));

    Status = AgpLibGetPciDeviceCapability(0,0,&CurrentCap);
    ASSERT(NT_SUCCESS(Status));
    ASSERT(RtlEqualMemory(&CurrentCap.AGPCommand, &TargetCap.AGPCommand, sizeof(CurrentCap.AGPCommand)));

#endif

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\agp\viaagp\viaagp.h ===
//
// VIAAGP.sys is a driver, make sure we get the appropriate linkage.
//

#define _NTDRIVER_

#include "stdarg.h"
#include "stdio.h"
#include "ntddk.h"
#include "agp.h"

//
// Define the location of the GART aperture control registers
//

//
// The GART registers on the VIA live in the host-PCI bridge.
// This is unfortunate, since the AGP driver attaches to the PCI-PCI (AGP)
// bridge. So we have to get to the host-PCI bridge config space
// and this is only possible because we KNOW this is bus 0, slot 0.
//
#define AGP_VIA_GART_BUS_ID     0
#define AGP_VIA_GART_SLOT_ID    0
#define AGP_P2P_SLOT_ID         1
#define AGP_VGA_BUS_ID          1
#define AGP_VGA_SLOT_ID         0


#define AGP_VIA_IDENTIFIER    0x00001106
// 0x05971106 -> VT82C597 / VT82C597 AT

// chu
#define GABASE_OFFSET   0x10            // Graphics Aperture Base
#define GARTCTRL_OFFSET 0x80            // GART/TLB Control
#define GASIZE_OFFSET   0x84            // Graphics Aperture Size
#define GATTBASE_OFFSET 0x88            // GA Translation Table Base
#define VREF_OFFSET     0xB0            // AGP VREF control
#define AGPMISC_OFFSET  0xAC             // AGP MISC control

#define ReadVIAConfig(_buf_,_offset_,_size_)                \
{                                                           \
    ULONG _len_;                                            \
    _len_ = HalGetBusDataByOffset(PCIConfiguration,         \
                                  AGP_VIA_GART_BUS_ID,      \
                                  AGP_VIA_GART_SLOT_ID,     \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  (_size_));                \
    ASSERT(_len_ == (_size_));                              \
}

#define WriteVIAConfig(_buf_,_offset_,_size_)               \
{                                                           \
    ULONG _len_;                                            \
    _len_ = HalSetBusDataByOffset(PCIConfiguration,         \
                                  AGP_VIA_GART_BUS_ID,      \
                                  AGP_VIA_GART_SLOT_ID,     \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  (_size_));                \
    ASSERT(_len_ == (_size_));                              \
}

#define ReadP2PConfig(_buf_,_offset_,_size_)                \
{                                                           \
    ULONG _len_;                                            \
    _len_ = HalGetBusDataByOffset(PCIConfiguration,         \
                                  AGP_VIA_GART_BUS_ID,      \
                                  AGP_P2P_SLOT_ID,          \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  (_size_));                \
    ASSERT(_len_ == (_size_));                              \
}

#define WriteP2PConfig(_buf_,_offset_,_size_)               \
{                                                           \
    ULONG _len_;                                            \
    _len_ = HalSetBusDataByOffset(PCIConfiguration,         \
                                  AGP_VIA_GART_BUS_ID,      \
                                  AGP_P2P_SLOT_ID,          \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  (_size_));                \
    ASSERT(_len_ == (_size_));                              \
}

#define ReadVGAConfig(_buf_,_offset_,_size_)                \
{                                                           \
    ULONG _len_;                                            \
    _len_ = HalGetBusDataByOffset(PCIConfiguration,         \
                                  AGP_VGA_BUS_ID,           \
                                  AGP_VGA_SLOT_ID,          \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  (_size_));                \
    ASSERT(_len_ == (_size_));                              \
}

#define WriteVGAConfig(_buf_,_offset_,_size_)                \
{                                                           \
    ULONG _len_;                                            \
    _len_ = HalSetBusDataByOffset(PCIConfiguration,         \
                                  AGP_VGA_BUS_ID,           \
                                  AGP_VGA_SLOT_ID,          \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  (_size_));                \
    ASSERT(_len_ == (_size_));                              \
}

#define ON  1
#define OFF 0

#define ViaApertureEnable(Enable) \
{ \
    VIA_GART_TLB_CTRL AGPCTRL_Config; \
 \
    ReadVIAConfig(&AGPCTRL_Config, GARTCTRL_OFFSET, sizeof(AGPCTRL_Config)); \
    AGPCTRL_Config.AGP_ATFGA = (Enable); \
    AGPCTRL_Config.CPU_ATFGA = (Enable); \
    AGPCTRL_Config.PCI2_ATFGA = (Enable); \
    AGPCTRL_Config.PCI1_ATFGA = (Enable); \
    WriteVIAConfig(&AGPCTRL_Config, GARTCTRL_OFFSET, sizeof(AGPCTRL_Config)); \
}

#define ViaGartEnable(Enable) \
{ \
    VIA_GATT_BASE GARTBASE_Config; \
 \
    ReadVIAConfig(&GARTBASE_Config, GATTBASE_OFFSET, sizeof(GARTBASE_Config));\
    GARTBASE_Config.GA_Enable = (Enable); \
    WriteVIAConfig(&GARTBASE_Config, GATTBASE_OFFSET, sizeof(GARTBASE_Config));}

//
// Conversions from Graphics Aperture Size encoding to MB
//
// 0xFF (b 1111 1111) =   1MB
// 0xFE (b 1111 1110) =   2MB
// 0xFC (b 1111 1100) =   4MB
// 0xF8 (b 1111 1000) =   8MB
// 0xF0 (b 1111 0000) =  16MB
// 0xE0 (b 1110 0000) =  32MB
// 0xC0 (b 1100 0000) =  64MB
// 0x80 (b 1000 0000) = 128MB
// 0x00 (b 0000 0000) = 256MB

#define GA_SIZE_1MB     0xFF
#define GA_SIZE_2MB     0xFE
#define GA_SIZE_4MB     0xFC
#define GA_SIZE_8MB     0xF8
#define GA_SIZE_16MB    0xF0
#define GA_SIZE_32MB    0xE0
#define GA_SIZE_64MB    0xC0
#define GA_SIZE_128MB   0x80
#define GA_SIZE_256MB   0x00

#define GA_SIZE_COUNT 7
#define GA_MIN_SIZE (1 * 1024 * 1024)
#define GA_MAX_SIZE (256 * 1024 * 1024)


//
// Define the GART table entry.
//
typedef struct _GART_ENTRY_HW {
    ULONG Valid     :  1;
    ULONG Reserved  : 11;
    ULONG Page      : 20;
} GART_ENTRY_HW, *PGART_ENTRY_HW;

//
// Aperture size in MB is equivalent to gart table allocation
// alignment requirement in KB
//
#define VIA_GART_ALIGN(Aperture) ((Aperture) >> 0xA)
#define VIA_VERIFY_GART_ALIGN(Gart, Aperture) \
    (((Gart) & (VIA_GART_ALIGN((Aperture)) - 1)) == 0)

//
// GART Entry states are defined so that all software-only states
// have the Valid bit clear.
//
#define GART_ENTRY_VALID        1           //  001
#define GART_ENTRY_FREE         0           //  000

#define GART_ENTRY_WC           2           //  010
#define GART_ENTRY_UC           4           //  100

#define GART_ENTRY_RESERVED_WC  GART_ENTRY_WC
#define GART_ENTRY_RESERVED_UC  GART_ENTRY_UC

#define GART_ENTRY_VALID_WC     (GART_ENTRY_VALID)
#define GART_ENTRY_VALID_UC     (GART_ENTRY_VALID)


typedef struct _GART_ENTRY_SW {
    ULONG State     : 3;
    ULONG Reserved  : 29;
} GART_ENTRY_SW, *PGART_ENTRY_SW;

typedef struct _GART_PTE {
    union {
        GART_ENTRY_HW Hard;
        ULONG      AsUlong;
        GART_ENTRY_SW Soft;
    };
} GART_PTE, *PGART_PTE;

//
// Define the layout of the hardware registers
//

typedef struct _VIA_GART_TLB_CTRL {
    ULONG AGP_ATFGA     : 1;    // ATFGA = Address Translation for GA Access
    ULONG CPU_ATFGA     : 1;
    ULONG PCI2_ATFGA    : 1;
    ULONG PCI1_ATFGA    : 1;
    ULONG Reserved1     : 3;
    ULONG FlushPageTLB  : 1;
    ULONG Reserved2     : 8;    // test mode status
    ULONG Reserved3     : 16;
} VIA_GART_TLB_CTRL, *PVIA_GART_TLB_CTRL;

typedef struct _VIA_GATT_BASE {
    ULONG TT_NonCache   : 1;    // Translation Table Noncachable
    ULONG GA_Enable     : 1;    // Graphics Aperture Enable
    ULONG TLB_Timing    : 1;
    ULONG Reserved      : 9;
    ULONG GATT_Base     : 20;
} VIA_GATT_BASE, *PVIA_GATT_BASE;

typedef struct _VREF_REG {
    ULONG Reserved1       : 7;
    ULONG VREF_Control    : 1;
    ULONG Reserved2       : 24;
} VREF_REG, *PVREF_REG;

typedef struct _AGPMISC_REG {
    ULONG Reserved1       : 18;
    ULONG AGP4X_Support   : 1;
    ULONG Reserved2       : 1;
    ULONG FW_Support      : 1;
    ULONG AGP4G_Support   : 1;
    ULONG Reserved3       : 10;
} AGPMISC_REG, *PAGPMISC_REG;

//
// Define the VIA-specific extension
//
typedef struct _AGPVIA_EXTENSION {
    BOOLEAN             GlobalEnable;
    BOOLEAN             PCIEnable;
    PHYSICAL_ADDRESS    ApertureStart;         //Aperture Phys Base Address
    ULONG               ApertureLength;
    PGART_PTE           GartCached;
    PGART_PTE           Gart;
    ULONG               GartLength;
    PHYSICAL_ADDRESS    GartPhysical;
    BOOLEAN             Cap_FlushTLB;          //TRUE: support Flush TLB
    ULONGLONG           SpecialTarget;
} AGPVIA_EXTENSION, *PAGPVIA_EXTENSION;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\agp\viaagp\gart.c ===
/*++

Copyright (c) 1998 VIA Technologies, Inc. and  Microsoft Corporation

Module Name:

    gart.c

Abstract:

    Routines for querying and setting the VIA VT82C597 ... GART aperture


Revision History:

--*/
#include "viaagp.h"

//
// Local function prototypes
//
NTSTATUS
AgpVIACreateGart(
    IN PAGPVIA_EXTENSION AgpContext,
    IN ULONG MinimumPages
    );

NTSTATUS
AgpVIASetRate(
    IN PVOID AgpContext,
    IN ULONG AgpRate
    );

PGART_PTE
AgpVIAFindRangeInGart(
    IN PGART_PTE StartPte,
    IN PGART_PTE EndPte,
    IN ULONG Length,
    IN BOOLEAN SearchBackward,
    IN ULONG SearchState
    );

VOID
AgpVIAFlushPageTLB(
    IN PAGPVIA_EXTENSION AgpContext
    );

VOID
AgpVIAFlushData(
    IN PAGPVIA_EXTENSION AgpContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AgpDisableAperture)
#pragma alloc_text(PAGE, AgpQueryAperture)
#pragma alloc_text(PAGE, AgpVIAFlushData)
#pragma alloc_text(PAGE, AgpVIAFlushPageTLB)
#pragma alloc_text(PAGE, AgpMapMemory)
#pragma alloc_text(PAGE, AgpUnMapMemory)
#pragma alloc_text(PAGE, AgpReserveMemory)
#pragma alloc_text(PAGE, AgpReleaseMemory)
#pragma alloc_text(PAGE, AgpVIACreateGart)
#pragma alloc_text(PAGE, AgpVIAFindRangeInGart)
#pragma alloc_text(PAGE, AgpFindFreeRun)
#pragma alloc_text(PAGE, AgpGetMappedPages)
#endif

#define VIA_FIRST_AVAILABLE_PTE 0


NTSTATUS
AgpQueryAperture(
    IN PAGPVIA_EXTENSION AgpContext,
    OUT PHYSICAL_ADDRESS *CurrentBase,
    OUT ULONG *CurrentSizeInPages,
    OUT OPTIONAL PIO_RESOURCE_LIST *ApertureRequirements
    )
/*++

Routine Description:

    Queries the current size of the GART aperture. Optionally returns
    the possible GART settings.

Arguments:

    AgpContext - Supplies the AGP context.

    CurrentBase - Returns the current physical address of the GART.

    CurrentSizeInPages - Returns the current GART size.

    ApertureRequirements - if present, returns the possible GART settings

Return Value:

    NTSTATUS

--*/

{
    ULONG GaBase;
    UCHAR GaSize;
    PIO_RESOURCE_LIST Requirements;
    ULONG i;
    ULONG Length;

    PAGED_CODE();

    //
    // Get the current GABASE and GASIZE settings
    //
    ReadVIAConfig(&GaBase, GABASE_OFFSET, sizeof(GaBase));
    ReadVIAConfig(&GaSize, GASIZE_OFFSET, sizeof(GaSize));

    ASSERT(GaBase != 0);
    CurrentBase->QuadPart = GaBase & PCI_ADDRESS_MEMORY_ADDRESS_MASK;

    //
    // Convert APSIZE into the actual size of the aperture
    //
    switch (GaSize) {
        case GA_SIZE_1MB:
            *CurrentSizeInPages = (1 * 1024*1024) / PAGE_SIZE;
            break;
        case GA_SIZE_2MB:
            *CurrentSizeInPages = (2 * 1024*1024) / PAGE_SIZE;
            break;
        case GA_SIZE_4MB:
            *CurrentSizeInPages = (4 * 1024*1024) / PAGE_SIZE;
            break;
        case GA_SIZE_8MB:
            *CurrentSizeInPages = 8 * (1024*1024 / PAGE_SIZE);
            break;
        case GA_SIZE_16MB:
            *CurrentSizeInPages = 16 * (1024*1024 / PAGE_SIZE);
            break;
        case GA_SIZE_32MB:
            *CurrentSizeInPages = 32 * (1024*1024 / PAGE_SIZE);
            break;
        case GA_SIZE_64MB:
            *CurrentSizeInPages = 64 * (1024*1024 / PAGE_SIZE);
            break;
        case GA_SIZE_128MB:
            *CurrentSizeInPages = 128 * (1024*1024 / PAGE_SIZE);
            break;
        case GA_SIZE_256MB:
            *CurrentSizeInPages = 256 * (1024*1024 / PAGE_SIZE);
            break;

        default:
            AGPLOG(AGP_CRITICAL,
                   ("VIAAGP - AgpQueryAperture - Unexpected value %x for GaSize!\n",
                    GaSize));
            ASSERT(FALSE);
            AgpContext->ApertureStart.QuadPart = 0;
            AgpContext->ApertureLength = 0;
            return(STATUS_UNSUCCESSFUL);
    }

    //
    // Remember the current aperture settings
    //
    AgpContext->ApertureStart.QuadPart = CurrentBase->QuadPart;
    AgpContext->ApertureLength = *CurrentSizeInPages * PAGE_SIZE;

    if (ApertureRequirements != NULL) {

        //
        // VIA supports 9 different aperture sizes, all must be
        // naturally aligned. Start with the largest aperture and
        // work downwards so that we get the biggest possible aperture.
        //
        Requirements = ExAllocatePoolWithTag(PagedPool,
                                             sizeof(IO_RESOURCE_LIST) + (GA_SIZE_COUNT-1)*sizeof(IO_RESOURCE_DESCRIPTOR),
                                             'RpgA');

        if (Requirements == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
        Requirements->Version = Requirements->Revision = 1;
        Requirements->Count = GA_SIZE_COUNT;
        Length = GA_MAX_SIZE;
        for (i=0; i<GA_SIZE_COUNT; i++) {
            Requirements->Descriptors[i].Option = IO_RESOURCE_ALTERNATIVE;
            Requirements->Descriptors[i].Type = CmResourceTypeMemory;
            Requirements->Descriptors[i].ShareDisposition = CmResourceShareDeviceExclusive;
            Requirements->Descriptors[i].Flags = CM_RESOURCE_MEMORY_READ_WRITE | CM_RESOURCE_MEMORY_PREFETCHABLE;

            Requirements->Descriptors[i].u.Memory.Length = Length;
            Requirements->Descriptors[i].u.Memory.Alignment = Length;
            Requirements->Descriptors[i].u.Memory.MinimumAddress.QuadPart = 0;
            Requirements->Descriptors[i].u.Memory.MaximumAddress.QuadPart = (ULONG)-1;

            Length = Length/2;
        }
        *ApertureRequirements = Requirements;
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpSetAperture(
    IN PAGPVIA_EXTENSION AgpContext,
    IN PHYSICAL_ADDRESS NewBase,
    IN ULONG NewSizeInPages
    )
/*++

Routine Description:

    Sets the GART aperture to the supplied settings

Arguments:

    AgpContext - Supplies the AGP context

    NewBase - Supplies the new physical memory base for the GART.

    NewSizeInPages - Supplies the new size for the GART

Return Value:

    NTSTATUS

--*/

{
    VIA_GATT_BASE       GATTBase;
    UCHAR GaSize;
    ULONG GaBase;

    //
    // Figure out the new APSIZE setting, make sure it is valid.
    //
    switch (NewSizeInPages) {
        case 1 * 1024 * 1024 / PAGE_SIZE:
            GaSize = GA_SIZE_1MB;
            break;
        case 2 * 1024 * 1024 / PAGE_SIZE:
            GaSize = GA_SIZE_2MB;
            break;
        case 4 * 1024 * 1024 / PAGE_SIZE:
            GaSize = GA_SIZE_4MB;
            break;
        case 8 * 1024 * 1024 / PAGE_SIZE:
            GaSize = GA_SIZE_8MB;
            break;
        case 16 * 1024 * 1024 / PAGE_SIZE:
            GaSize = GA_SIZE_16MB;
            break;
        case 32 * 1024 * 1024 / PAGE_SIZE:
            GaSize = GA_SIZE_32MB;
            break;
        case 64 * 1024 * 1024 / PAGE_SIZE:
            GaSize = GA_SIZE_64MB;
            break;
        case 128 * 1024 * 1024 / PAGE_SIZE:
            GaSize = GA_SIZE_128MB;
            break;
        case 256 * 1024 * 1024 / PAGE_SIZE:
            GaSize = GA_SIZE_256MB;
            break;
        default:
            AGPLOG(AGP_CRITICAL,
                   ("AgpSetAperture - invalid GART size of %lx pages specified, aperture at %I64X.\n",
                    NewSizeInPages,
                    NewBase.QuadPart));
            ASSERT(FALSE);
            return(STATUS_INVALID_PARAMETER);
    }

    //
    // Make sure the supplied size is aligned on the appropriate boundary.
    //
    ASSERT(NewBase.HighPart == 0);
    ASSERT((NewBase.QuadPart & ((NewSizeInPages * PAGE_SIZE) - 1)) == 0);
    if ((NewBase.QuadPart & ((NewSizeInPages * PAGE_SIZE) - 1)) != 0 ) {
        AGPLOG(AGP_CRITICAL,
               ("AgpSetAperture - invalid base %I64X specified for GART aperture of %lx pages\n",
               NewBase.QuadPart,
               NewSizeInPages));
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Reprogram Special Target settings when the chip
    // is powered off, but ignore rate changes as those were already
    // applied during MasterInit
    //
    if (AgpContext->SpecialTarget & ~AGP_FLAG_SPECIAL_RESERVE) {
        AgpSpecialTarget(AgpContext,
                         AgpContext->SpecialTarget &
                         ~AGP_FLAG_SPECIAL_RESERVE);
    }

    //
    // Need to reset the hardware to match the supplied settings
    //
    // If the aperture is enabled, disable it, write the new settings, then
    // reenable the aperture
    //
    ViaApertureEnable(OFF);

    //
    // Write GASIZE first, as this will enable the correct bits in GABASE that
    // need to be written next.
    //
    WriteVIAConfig(&GaSize, GASIZE_OFFSET, sizeof(GaSize));

    //
    // While the aperture base address is changed, 88[1] must be set as 1,
    // otherwise the high aperture address will not change.
    //
    ViaGartEnable(ON);

    //
    // Now we can update GABASE
    //
    GaBase = NewBase.LowPart & PCI_ADDRESS_MEMORY_ADDRESS_MASK;
    WriteVIAConfig(&GaBase, GABASE_OFFSET, sizeof(GaBase));

#if DBG
    //
    // Read back what we wrote, make sure it worked
    //
    {
        ULONG DbgBase;
        UCHAR DbgSize;

        ReadVIAConfig(&DbgSize, GASIZE_OFFSET, sizeof(GaSize));
        ReadVIAConfig(&DbgBase, GABASE_OFFSET, sizeof(GaBase));
        ASSERT(DbgSize == GaSize);
        ASSERT((DbgBase & PCI_ADDRESS_MEMORY_ADDRESS_MASK) == GaBase);  
    }
#endif

    //
    // Now enable the aperture if it was enabled before
    //
    // EFNfix:  Apparently code was added (above) which indiscriminantly
    //          enables aperture, so we must turn it off if !GlobalEnable
    //
    if (AgpContext->GlobalEnable == FALSE) {
        ViaApertureEnable(OFF);
    } else {
        ViaApertureEnable(ON);
    }

    //
    // Update our extension to reflect the new GART setting
    //
    AgpContext->ApertureStart = NewBase;
    AgpContext->ApertureLength = NewSizeInPages * PAGE_SIZE;

    //
    // Enable the TB in case we are resuming from S3 or S4
    //

    //
    // If the GART has been allocated, rewrite the GARTBASE
    //
    if (AgpContext->Gart != NULL) {
        ULONG uTmpPhysAddr;

        ReadVIAConfig(&uTmpPhysAddr, GATTBASE_OFFSET, sizeof(uTmpPhysAddr));
        uTmpPhysAddr = (AgpContext->GartPhysical.LowPart & 0xFFFFF000) |
            (uTmpPhysAddr & 0x00000FFF);
        WriteVIAConfig(&uTmpPhysAddr, GATTBASE_OFFSET, sizeof(uTmpPhysAddr));
    }

    return(STATUS_SUCCESS);
}


VOID
AgpDisableAperture(
    IN PAGPVIA_EXTENSION AgpContext
    )
/*++

Routine Description:

    Disables the GART aperture so that this resource is available
    for other devices

Arguments:

    AgpContext - Supplies the AGP context

Return Value:

    None - this routine must always succeed.

--*/

{
    //
    // Disable the aperture
    //
    ViaApertureEnable(OFF);
    
    AgpContext->GlobalEnable = FALSE;

    //
    // Nuke the Gart!  (It's meaningless now...)
    //
    if (AgpContext->Gart != NULL) {
        MmFreeContiguousMemory(AgpContext->Gart);
        AgpContext->Gart = NULL;
        AgpContext->GartLength = 0;
    }
}



NTSTATUS
AgpReserveMemory(
    IN PAGPVIA_EXTENSION AgpContext,
    IN OUT AGP_RANGE *Range
    )
/*++

Routine Description:

    Reserves a range of memory in the GART.

Arguments:

    AgpContext - Supplies the AGP Context

    Range - Supplies the AGP_RANGE structure. AGPLIB
        will have filled in NumberOfPages and Type. This
        routine will fill in MemoryBase and Context.

Return Value:

    NTSTATUS

--*/

{
    ULONG       Index;
    ULONG       NewState;
    NTSTATUS    Status;
    PGART_PTE   FoundRange;
    BOOLEAN     Backwards;

    PAGED_CODE();

    ASSERT((Range->Type == MmNonCached) || (Range->Type == MmWriteCombined));
    ASSERT(Range->NumberOfPages <= (AgpContext->ApertureLength / PAGE_SIZE));

    //
    // If we have not allocated our GART yet, now is the time to do so
    //
    if (AgpContext->Gart == NULL) {
        ASSERT(AgpContext->GartLength == 0);
        Status = AgpVIACreateGart(AgpContext,Range->NumberOfPages);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AgpVIACreateGart failed %08lx to create GART of size %lx\n",
                    Status,
                    AgpContext->ApertureLength));
            return(Status);
        }
    }
    ASSERT(AgpContext->GartLength != 0);

    //
    // Now that we have a GART, try and find enough contiguous entries to satisfy
    // the request. Requests for uncached memory will scan from high addresses to
    // low addresses. Requests for write-combined memory will scan from low addresses
    // to high addresses. We will use a first-fit algorithm to try and keep the allocations
    // packed and contiguous.
    //
    Backwards = (Range->Type == MmNonCached) ? TRUE : FALSE;
    FoundRange = AgpVIAFindRangeInGart(&AgpContext->Gart[VIA_FIRST_AVAILABLE_PTE],
                                       &AgpContext->Gart[(AgpContext->GartLength / sizeof(GART_PTE)) - 1],
                                       Range->NumberOfPages,
                                       Backwards,
                                       GART_ENTRY_FREE);

    if (FoundRange == NULL) {
        //
        // A big enough chunk was not found.
        //
        AGPLOG(AGP_CRITICAL,
               ("AgpReserveMemory - Could not find %d contiguous free pages of type %d in GART at %08lx\n",
                Range->NumberOfPages,
                Range->Type,
                AgpContext->Gart));

        //
        //  This is where we could try and grow the GART
        //

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    AGPLOG(AGP_NOISE,
           ("AgpReserveMemory - reserved %d pages at GART PTE %08lx\n",
            Range->NumberOfPages,
            FoundRange));

    //
    // Set these pages to reserved
    //
    if (Range->Type == MmNonCached) {
        NewState = GART_ENTRY_RESERVED_UC;
    } else {
        NewState = GART_ENTRY_RESERVED_WC;
    }

    for (Index = 0;Index < Range->NumberOfPages; Index++) {
        ASSERT(FoundRange[Index].Soft.State == GART_ENTRY_FREE);
        FoundRange[Index].AsUlong = 0;
        FoundRange[Index].Soft.State = NewState;
    }

    Range->MemoryBase.QuadPart = AgpContext->ApertureStart.QuadPart + (FoundRange - &AgpContext->Gart[0]) * PAGE_SIZE;
    Range->Context = FoundRange;

    ASSERT(Range->MemoryBase.HighPart == 0);
    AGPLOG(AGP_NOISE,
           ("AgpReserveMemory - reserved memory handle %lx at PA %08lx\n",
            FoundRange,
            Range->MemoryBase.LowPart));

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpReleaseMemory(
    IN PAGPVIA_EXTENSION AgpContext,
    IN PAGP_RANGE Range
    )
/*++

Routine Description:

    Releases memory previously reserved with AgpReserveMemory

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the range to be released.

Return Value:

    NTSTATUS

--*/

{
    PGART_PTE Pte;
    ULONG Start;

    PAGED_CODE()

    //
    // Go through and free all the PTEs. None of these should still
    // be valid at this point.
    //
    for (Pte = Range->Context;
         Pte < (PGART_PTE)Range->Context + Range->NumberOfPages;
         Pte++) {
        if (Range->Type == MmNonCached) {
            ASSERT(Pte->Soft.State == GART_ENTRY_RESERVED_UC);
        } else {
            ASSERT(Pte->Soft.State == GART_ENTRY_RESERVED_WC);
        }
        Pte->Soft.State = GART_ENTRY_FREE;
    }

    Range->MemoryBase.QuadPart = 0;
    return(STATUS_SUCCESS);
}

#define AGP_TEST_SIGNATURE 0xAA55AA55


NTSTATUS
AgpVIACreateGart(
    IN PAGPVIA_EXTENSION AgpContext,
    IN ULONG MinimumPages
    )
/*++

Routine Description:

    Allocates and initializes an empty GART. The current implementation
    attempts to allocate the entire GART on the first reserve.

Arguments:

    AgpContext - Supplies the AGP context

    MinimumPages - Supplies the minimum size (in pages) of the GART to be
        created.

Return Value:

    NTSTATUS

--*/

{
    PHYSICAL_ADDRESS LowestAcceptable;
    PHYSICAL_ADDRESS BoundaryMultiple;
    PGART_PTE           Gart;
    ULONG               GartLength;
    ULONG               TempPhysAddr;
    PHYSICAL_ADDRESS    HighestAcceptable;
    PHYSICAL_ADDRESS    GartPhysical;
    PULONG              TestPage;
    ULONG i;

    PAGED_CODE();
    //
    // Try and get a chunk of contiguous memory big enough to map the
    // entire aperture.
    //
    LowestAcceptable.QuadPart = 0;
    BoundaryMultiple.QuadPart =
        (ULONGLONG)VIA_GART_ALIGN(AgpContext->ApertureLength);
    HighestAcceptable.QuadPart = 0xFFFFFFFF;
    GartLength = BYTES_TO_PAGES(AgpContext->ApertureLength) * sizeof(GART_PTE);

    Gart = MmAllocateContiguousMemorySpecifyCache(GartLength,
                                                  LowestAcceptable,
                                                  HighestAcceptable,
                                                  BoundaryMultiple,
                                                  MmNonCached);
    if (Gart == NULL) {
        AGPLOG(AGP_CRITICAL,
               ("AgpVIACreateGart - MmAllocateContiguousMemory %lx failed\n",
                GartLength));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // We successfully allocated a contiguous chunk of memory.
    // It should be page aligned already.
    //
    ASSERT(((ULONG_PTR)Gart & (PAGE_SIZE-1)) == 0);

    //
    // Get the physical address.
    //
    GartPhysical = MmGetPhysicalAddress(Gart);
    AGPLOG(AGP_NOISE,
           ("AgpVIACreateGart - GART of length %lx created at VA %08lx, PA %08lx\n",
            GartLength,
            Gart,
            GartPhysical.LowPart));
    ASSERT(GartPhysical.HighPart == 0);
    ASSERT(VIA_VERIFY_GART_ALIGN(GartPhysical.LowPart,
                                 AgpContext->ApertureLength));

    //
    // Initialize all the PTEs to free
    //
    for (i=0; i<GartLength/sizeof(GART_PTE); i++) {
        Gart[i].AsUlong = 0;
        Gart[i].Soft.State = GART_ENTRY_FREE;
    }

    ReadVIAConfig(&TempPhysAddr, GATTBASE_OFFSET, sizeof(TempPhysAddr));
    TempPhysAddr = (GartPhysical.LowPart & 0xFFFFF000) |
        (TempPhysAddr & 0x00000FFF);
    WriteVIAConfig(&TempPhysAddr, GATTBASE_OFFSET, sizeof(TempPhysAddr));

    //
    // Update our extension to reflect the current state.
    //
    AgpContext->Gart = Gart;
    AgpContext->GartLength = GartLength;
    AgpContext->GartPhysical = GartPhysical;

#if 0
    //
    // Test if AGP is working
    //
    LowestAcceptable.QuadPart = 0;
    BoundaryMultiple.QuadPart = 0;
    HighestAcceptable.QuadPart = 0xFFFFFFFF;
    
    TestPage =
        (PULONG)MmAllocateContiguousMemorySpecifyCache(PAGE_SIZE,
                                                       LowestAcceptable,
                                                       HighestAcceptable,
                                                       BoundaryMultiple,
                                                       MmNonCached);
    if (TestPage) {
        PVOID  ApertureVa;
        ULONG  TestPte;

        TestPage[0] = AGP_TEST_SIGNATURE;
        TestPte = MmGetPhysicalAddress(TestPage).LowPart;
        
        //
        // Setup a translation so the first page at aperture base points
        // to our test page
        //
        Gart[0].AsUlong =
            (((UINT_PTR)TestPte >> PAGE_SHIFT) * PAGE_SIZE) | GART_ENTRY_VALID;
        
        //
        // Flush the write buffer
        //
        i = Gart[0].AsUlong;

        //
        // Flush the TLB
        //
        AgpVIAFlushPageTLB(AgpContext);

        //
        // Try to read our signature through the aperture/gart translation
        //
        ApertureVa = MmMapIoSpace(AgpContext->ApertureStart,
                                  PAGE_SIZE,
                                  MmNonCached);
        
        ASSERT(ApertureVa != NULL);

        i = *(PULONG)ApertureVa;

        AGPLOG(AGP_NOISE,
               ("AgpVIACreateGart AGP test: wrote (%08x) PA %08x=badceede, "
                "mapped gart[0] %08x=%08x, read AP_BASE (%08x) VA %08x=%08x\n",
                TestPage,
                TestPte,
                Gart,
                Gart[0].AsUlong,
                AgpContext->ApertureStart.LowPart,
                ApertureVa,
                i));

        MmUnmapIoSpace(ApertureVa, PAGE_SIZE);

        //
        // Cleanup
        //
        Gart[0].AsUlong = 0;
        Gart[0].Soft.State = GART_ENTRY_FREE;
        TestPage[0] = Gart[0].AsUlong;
        AgpVIAFlushPageTLB(AgpContext);
        MmFreeContiguousMemory(TestPage);

        //
        // Turn off everything, and bail, AGP is broken
        //
        if (i != AGP_TEST_SIGNATURE) {

            AGPLOG(AGP_CRITICAL,
                   ("AgpVIACreateGart - AGP failed: Read=%08x\n", i));

            AgpDisableAperture(AgpContext);
            
            //
            // Need to let the user know what happened here
            //
            //AgpLogGenericHwFailure();

            return STATUS_DEVICE_CONFIGURATION_ERROR;
        }
    }
#endif

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpMapMemory(
    IN PAGPVIA_EXTENSION AgpContext,
    IN PAGP_RANGE Range,
    IN PMDL Mdl,
    IN ULONG OffsetInPages,
    OUT PHYSICAL_ADDRESS *MemoryBase
    )
/*++

Routine Description:

    Maps physical memory into the GART somewhere in the specified range.

Arguments:

    AgpContext - Supplies the AGP context

    Range - Supplies the AGP range that the memory should be mapped into

    Mdl - Supplies the MDL describing the physical pages to be mapped

    MemoryBase - Returns the physical memory in the aperture where the pages
        were mapped.

Return Value:

    NTSTATUS

--*/

{
    ULONG               PageCount;
    PGART_PTE           Pte;
    PGART_PTE           StartPte;
    ULONG               Index;
    ULONG               TargetState;
    PULONG              Page;
    BOOLEAN             Backwards;
    GART_PTE            NewPte;
    VIA_GATT_BASE       GATTBase;
    NTSTATUS            Status;

    PAGED_CODE();

    ASSERT(Mdl->Next == NULL);

    StartPte = Range->Context;
    PageCount = BYTES_TO_PAGES(Mdl->ByteCount);
    ASSERT(PageCount <= Range->NumberOfPages);
    ASSERT(PageCount > 0);

    TargetState = (Range->Type == MmNonCached) ? GART_ENTRY_RESERVED_UC : GART_ENTRY_RESERVED_WC;

    Pte = StartPte + OffsetInPages;

    //
    // We have a suitable range, now fill it in with the supplied MDL.
    //
    ASSERT(Pte >= StartPte);
    ASSERT(Pte + PageCount <= StartPte + Range->NumberOfPages);
    NewPte.AsUlong = 0;
    NewPte.Soft.State = (Range->Type == MmNonCached) ? GART_ENTRY_VALID_UC :
                                                       GART_ENTRY_VALID_WC;
    Page = (PULONG)(Mdl + 1);


    for (Index = 0; Index < PageCount; Index++) {
        ASSERT(Pte[Index].Soft.State == TargetState);

        NewPte.Hard.Page = *Page++;
        Pte[Index].AsUlong = NewPte.AsUlong;
        ASSERT(Pte[Index].Hard.Valid == 1);
    }

    //
    // We have filled in all the PTEs. Read back the last one we wrote
    // in order to flush the write buffers.
    //
    NewPte.AsUlong = *(volatile ULONG *)&Pte[PageCount-1].AsUlong;

    //
    // If we have not yet gotten around to enabling the GART aperture, do it now.
    //
    if (!AgpContext->GlobalEnable) {
        VIA_GATT_BASE GARTBASE_Config;

        AGPLOG(AGP_NOISE,
               ("AgpMapMemory - Enabling global aperture access\n"));

        ViaApertureEnable(ON);

        ReadVIAConfig(&GARTBASE_Config,
                      GATTBASE_OFFSET,
                      sizeof(GARTBASE_Config));

        GARTBASE_Config.TT_NonCache = 1;

        WriteVIAConfig(&GARTBASE_Config,
                       GATTBASE_OFFSET,
                       sizeof(GARTBASE_Config));

        ViaGartEnable(ON);

        AgpContext->GlobalEnable = TRUE;
    }

    MemoryBase->QuadPart = Range->MemoryBase.QuadPart + (Pte - StartPte) * PAGE_SIZE;

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpUnMapMemory(
    IN PAGPVIA_EXTENSION AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG PageOffset
    )
/*++

Routine Description:

    Unmaps previously mapped memory in the GART.

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the AGP range that the memory should be mapped into

    NumberOfPages - Supplies the number of pages in the range to be freed.

    PageOffset - Supplies the offset into the range where the freeing should begin.

Return Value:

    NTSTATUS

--*/

{
    ULONG i;
    PGART_PTE Pte;
    PGART_PTE LastChanged=NULL;
    PGART_PTE StartPte;
    ULONG NewState;

    PAGED_CODE();

    ASSERT(PageOffset + NumberOfPages <= AgpRange->NumberOfPages);

    StartPte = AgpRange->Context;
    Pte = &StartPte[PageOffset];

    if (AgpRange->Type == MmNonCached) {
        NewState = GART_ENTRY_RESERVED_UC;
    } else {
        NewState = GART_ENTRY_RESERVED_WC;
    }

    //
    // Flush TLB
    //
    AgpVIAFlushPageTLB(AgpContext);

    for (i=0; i<NumberOfPages; i++) {
        if (Pte[i].Hard.Valid) {
            Pte[i].Soft.State = NewState;
            LastChanged = Pte;
        } else {
            //
            // This page is not mapped, just skip it.
            //
            AGPLOG(AGP_NOISE,
                   ("AgpUnMapMemory - PTE %08lx (%08lx) at offset %d not mapped\n",
                    &Pte[i],
                    Pte[i].AsUlong,
                    i));
        }
    }

    //
    // We have invalidated all the PTEs. Read back the last one we wrote
    // in order to flush the write buffers.
    //
    if (LastChanged != NULL) {
        ULONG Temp;
        Temp = *(volatile ULONG *)(&LastChanged->AsUlong);
    }

    return(STATUS_SUCCESS);
}


PGART_PTE
AgpVIAFindRangeInGart(
    IN PGART_PTE StartPte,
    IN PGART_PTE EndPte,
    IN ULONG Length,
    IN BOOLEAN SearchBackward,
    IN ULONG SearchState
    )
/*++

Routine Description:

    Finds a contiguous range in the GART. This routine can
    search either from the beginning of the GART forwards or
    the end of the GART backwards.

Arguments:

    StartIndex - Supplies the first GART pte to search

    EndPte - Supplies the last GART to search (inclusive)

    Length - Supplies the number of contiguous free entries
        to search for.

    SearchBackward - TRUE indicates that the search should begin
        at EndPte and search backwards. FALSE indicates that the
        search should begin at StartPte and search forwards

    SearchState - Supplies the PTE state to look for.

Return Value:

    Pointer to the first PTE in the GART if a suitable range
    is found.

    NULL if no suitable range exists.

--*/

{
    PGART_PTE Current;
    PGART_PTE Last;
    LONG Delta;
    ULONG Found;
    PGART_PTE Candidate;

    PAGED_CODE();

    ASSERT(EndPte >= StartPte);
    ASSERT(Length <= (ULONG)(EndPte - StartPte + 1));
    ASSERT(Length != 0);

    if (SearchBackward) {
        Current = EndPte;
        Last = StartPte-1;
        Delta = -1;
    } else {
        Current = StartPte;
        Last = EndPte+1;
        Delta = 1;
    }

    Found = 0;
    while (Current != Last) {
        if (Current->Soft.State == SearchState) {
            if (++Found == Length) {
                //
                // A suitable range was found, return it
                //
                if (SearchBackward) {
                    return(Current);
                } else {
                    return(Current - Length + 1);
                }
            }
        } else {
            Found = 0;
        }
        Current += Delta;
    }

    //
    // A suitable range was not found.
    //
    return(NULL);
}


VOID
AgpVIAFlushPageTLB(
    IN PAGPVIA_EXTENSION AgpContext
    )
/*++

Routine Description:

    Flush the AGP TLB (16 entries)
    if hardware does not support FLUSH TLB, then read Aperture 32 times

Arguments:

    AgpContext - Supplies the AGP context

Return Value:

    None

--*/

{
    VIA_GART_TLB_CTRL GARTCTRL_Config;

    PAGED_CODE();

    if (AgpContext->Cap_FlushTLB) {

        ReadVIAConfig(&GARTCTRL_Config,
                      GARTCTRL_OFFSET,
                      sizeof(GARTCTRL_Config));

        //Flush TLB
        GARTCTRL_Config.FlushPageTLB = 1;
        WriteVIAConfig(&GARTCTRL_Config,
                       GARTCTRL_OFFSET,
                       sizeof(GARTCTRL_Config));

        //Stop Flush TLB
        GARTCTRL_Config.FlushPageTLB = 0;
        WriteVIAConfig(&GARTCTRL_Config,
                       GARTCTRL_OFFSET,
                       sizeof(GARTCTRL_Config));

    } else {
        AgpVIAFlushData(AgpContext);
    }
}


VOID
AgpFindFreeRun(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT ULONG *FreePages,
    OUT ULONG *FreeOffset
    )
/*++

Routine Description:

    Finds the first contiguous run of free pages in the specified
    part of the reserved range.

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the AGP range

    NumberOfPages - Supplies the size of the region to be searched for free pages

    OffsetInPages - Supplies the start of the region to be searched for free pages

    FreePages - Returns the length of the first contiguous run of free pages

    FreeOffset - Returns the start of the first contiguous run of free pages

Return Value:

    None. FreePages == 0 if there are no free pages in the specified range.

--*/

{
    PGART_PTE Pte;
    ULONG i;

    PAGED_CODE();
    Pte = (PGART_PTE)(AgpRange->Context) + OffsetInPages;

    //
    // Find the first free PTE
    //
    for (i=0; i<NumberOfPages; i++) {
        if (Pte[i].Hard.Valid == 0) {
            //
            // Found a free PTE, count the contiguous ones.
            //
            *FreeOffset = i + OffsetInPages;
            *FreePages = 0;
            while ((i<NumberOfPages) && (Pte[i].Hard.Valid == 0)) {
                *FreePages += 1;
                ++i;
            }
            return;
        }
    }

    //
    // No free PTEs in the specified range
    //
    *FreePages = 0;
    return;

}


VOID
AgpGetMappedPages(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT PMDL Mdl
    )
/*++

Routine Description:

    Returns the list of physical pages mapped into the specified
    range in the GART.

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the AGP range

    NumberOfPages - Supplies the number of pages to be returned

    OffsetInPages - Supplies the start of the region

    Mdl - Returns the list of physical pages mapped in the specified range.

Return Value:

    None

--*/

{
    PGART_PTE Pte;
    ULONG i;
    PULONG Pages;

    PAGED_CODE();

    ASSERT(NumberOfPages * PAGE_SIZE == Mdl->ByteCount);

    Pages = (PULONG)(Mdl + 1);
    Pte = (PGART_PTE)(AgpRange->Context) + OffsetInPages;

    for (i=0; i<NumberOfPages; i++) {
        ASSERT(Pte[i].Hard.Valid == 1);
        Pages[i] = Pte[i].Hard.Page;
    }
}


VOID
AgpVIAFlushData(
    IN PAGPVIA_EXTENSION AgpContext
    )
/*++

Routine Description:

    Flushes the chipset TB by reading 32 pages of aperture memory space.

Arguments:

    AgpContext - Supplies the AGP context

Return Value:

    NTSTATUS

--*/

{
    PVOID   ApertureVirtAddr, TempVirtualAddr;
    ULONG   ReadData;        
    ULONG   Index;

    PAGED_CODE();

    ApertureVirtAddr = MmMapIoSpace(AgpContext->ApertureStart,
                                    32 * PAGE_SIZE,
                                    MmNonCached);

    ASSERT(ApertureVirtAddr != NULL);

    if (ApertureVirtAddr != NULL) {

        TempVirtualAddr = ApertureVirtAddr;
        for (Index = 0; Index < 32; Index++) {
            ReadData = *(PULONG)TempVirtualAddr;
            TempVirtualAddr = (PVOID)((PCCHAR)TempVirtualAddr + PAGE_SIZE);
        }
        MmUnmapIoSpace(ApertureVirtAddr, 32 * PAGE_SIZE);
    
    } else {
         AGPLOG(AGP_CRITICAL,("Agp440FlushPageTLB: Invalid address\n"));
    }
}


NTSTATUS
AgpSpecialTarget(
    IN PAGPVIA_EXTENSION AgpContext,
    IN ULONGLONG DeviceFlags
    )
/*++

Routine Description:

    This routine makes "special" tweaks to the AGP chipset

Arguments:

    AgpContext - Supplies the AGP context

    DeviceFlags - Flags indicating what tweaks to perform

Return Value:

    STATUS_SUCCESS, or error

--*/
{
    NTSTATUS Status;

    //
    // Should we change the AGP rate?
    //
    if (DeviceFlags & AGP_FLAG_SPECIAL_RESERVE) {

        Status = AgpVIASetRate(AgpContext,
                               (ULONG)((DeviceFlags & AGP_FLAG_SPECIAL_RESERVE)
                                       >> AGP_FLAG_SET_RATE_SHIFT));
        
        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    }

    //
    // Add more tweaks here...
    //

    AgpContext->SpecialTarget |= DeviceFlags;

    return STATUS_SUCCESS;
}


NTSTATUS
AgpVIASetRate(
    IN PAGPVIA_EXTENSION AgpContext,
    IN ULONG AgpRate
    )
/*++

Routine Description:

    This routine sets the AGP rate

Arguments:

    AgpContext - Supplies the AGP context

    AgpRate - Rate to set

    note: this routine assumes that AGP has already been enabled, and that
          whatever rate we've been asked to set is supported by master

Return Value:

    STATUS_SUCCESS, or error status

--*/
{
    NTSTATUS Status;
    ULONG TargetEnable;
    ULONG MasterEnable;
    PCI_AGP_CAPABILITY TargetCap;
    PCI_AGP_CAPABILITY MasterCap;
    BOOLEAN ReverseInit;

    //
    // Read capabilities
    //
    Status = AgpLibGetPciDeviceCapability(0, 0, &TargetCap);

    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING, ("AGPVIASetRate: AgpLibGetPciDeviceCapability "
                             "failed %08lx\n", Status));
        return Status;
    }

    Status = AgpLibGetMasterCapability(AgpContext, &MasterCap);

    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING, ("AGPVIASetRate: AgpLibGetMasterCapability "
                             "failed %08lx\n", Status));
        return Status;
    }

    //
    // Verify the requested rate is supported by both master and target
    //
    if (!(AgpRate & TargetCap.AGPStatus.Rate & MasterCap.AGPStatus.Rate)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Disable AGP while the pull the rug out from underneath
    //
    TargetEnable = TargetCap.AGPCommand.AGPEnable;
    TargetCap.AGPCommand.AGPEnable = 0;

    Status = AgpLibSetPciDeviceCapability(0, 0, &TargetCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("AGPVIASetRate: AgpLibSetPciDeviceCapability %08lx for "
                "Target failed %08lx\n",
                &TargetCap,
                Status));
        return Status;
    }
    
    MasterEnable = MasterCap.AGPCommand.AGPEnable;
    MasterCap.AGPCommand.AGPEnable = 0;

    Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("AGPVIASetRate: AgpLibSetMasterCapability %08lx failed "
                "%08lx\n",
                &MasterCap,
                Status));
        return Status;
    }

    //
    // Fire up AGP with new rate
    //
    ReverseInit =
        (AgpContext->SpecialTarget & AGP_FLAG_REVERSE_INITIALIZATION) ==
        AGP_FLAG_REVERSE_INITIALIZATION;
    if (ReverseInit) {
        MasterCap.AGPCommand.Rate = AgpRate;
        MasterCap.AGPCommand.AGPEnable = MasterEnable;
        
        Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
        
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_WARNING,
                   ("AGPVIASetRate: AgpLibSetMasterCapability %08lx failed "
                    "%08lx\n",
                    &MasterCap,
                    Status));
        }
    }

    TargetCap.AGPCommand.Rate = AgpRate;
    TargetCap.AGPCommand.AGPEnable = TargetEnable;
        
    Status = AgpLibSetPciDeviceCapability(0, 0, &TargetCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("AGPVIASetRate: AgpLibSetPciDeviceCapability %08lx for "
                "Target failed %08lx\n",
                &TargetCap,
                Status));
        return Status;
    }

    if (!ReverseInit) {
        MasterCap.AGPCommand.Rate = AgpRate;
        MasterCap.AGPCommand.AGPEnable = MasterEnable;
        
        Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
        
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_WARNING,
                   ("AGPVIASetRate: AgpLibSetMasterCapability %08lx failed "
                    "%08lx\n",
                    &MasterCap,
                    Status));
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\agp\alim1541\gart.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    gart.c

Abstract:

    Routines for querying and setting the Intel 440xx GART aperture

Author:

    John Vert (jvert) 10/30/1997

Modified by:

        Chi-Ming Cheng 06/24/1998 Acer Labs, Inc.
        Wang-Kai Tsai  08/28/2000 Acer Labs, Inc. - ACPI power up GART reinitialization

Revision History:

--*/
#include "ALiM1541.h"

//
// Local function prototypes
//
NTSTATUS
AgpALiSetRate(
    IN PVOID AgpContext,
    IN ULONG AgpRate
    );

NTSTATUS
AgpALiCreateGart(
    IN PAGPALi_EXTENSION AgpContext,
    IN ULONG MinimumPages
    );

PGART_PTE
AgpALiFindRangeInGart(
    IN PGART_PTE StartPte,
    IN PGART_PTE EndPte,
    IN ULONG Length,
    IN BOOLEAN SearchBackward,
    IN ULONG SearchState
    );

NTSTATUS
AgpQueryAperture(
    IN PAGPALi_EXTENSION AgpContext,
    OUT PHYSICAL_ADDRESS *CurrentBase,
    OUT ULONG *CurrentSizeInPages,
    OUT OPTIONAL PIO_RESOURCE_LIST *ApertureRequirements
    )
/*++

Routine Description:

    Queries the current size of the GART aperture. Optionally returns
    the possible GART settings.

Arguments:

    AgpContext - Supplies the AGP context.

    CurrentBase - Returns the current physical address of the GART.

    CurrentSizeInPages - Returns the current GART size.

    ApertureRequirements - if present, returns the possible GART settings

Return Value:

    NTSTATUS

--*/

{
    ULONG ApBase;
    APCTRL ApCtrl;
    PIO_RESOURCE_LIST Requirements;
    ULONG i;
    ULONG Length;

    //
    // Get the current APBASE and APSIZE settings
    //
    ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ApBase, APBASE_OFFSET);
    ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ApCtrl, APCTRL_OFFSET);

    ASSERT(ApBase != 0);
    CurrentBase->QuadPart = ApBase & 0xFFFFFFF0; //PCI_ADDRESS_MEMORY_ADDRESS_MASK;

    //
    // Convert APSIZE into the actual size of the aperture
    //
    switch (ApCtrl.ApSize) {
        case AP_SIZE_4MB:
            *CurrentSizeInPages = (4 * 1024*1024) / PAGE_SIZE;
            break;
        case AP_SIZE_8MB:
            *CurrentSizeInPages = 8 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_16MB:
            *CurrentSizeInPages = 16 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_32MB:
            *CurrentSizeInPages = 32 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_64MB:
            *CurrentSizeInPages = 64 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_128MB:
            *CurrentSizeInPages = 128 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_256MB:
            *CurrentSizeInPages = 256 * (1024*1024 / PAGE_SIZE);
            break;

        default:
            AGPLOG(AGP_CRITICAL,
                   ("AGPALi - AgpQueryAperture - Unexpected value %x for ApSize!\n",
                    ApCtrl.ApSize));
            ASSERT(FALSE);
            AgpContext->ApertureStart.QuadPart = 0;
            AgpContext->ApertureLength = 0;
            return(STATUS_UNSUCCESSFUL);
    }

    //
    // Remember the current aperture settings
    //
    AgpContext->ApertureStart.QuadPart = CurrentBase->QuadPart;
    AgpContext->ApertureLength = *CurrentSizeInPages * PAGE_SIZE;

    if (ApertureRequirements != NULL) {
        //
        // 1541 supports 7 different aperture sizes, all must be
        // naturally aligned. Start with the largest aperture and
        // work downwards so that we get the biggest possible aperture.
        //
        Requirements = ExAllocatePoolWithTag(PagedPool,
                                             sizeof(IO_RESOURCE_LIST) + (AP_SIZE_COUNT-1)*sizeof(IO_RESOURCE_DESCRIPTOR),
                                             'RpgA');
        if (Requirements == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
        Requirements->Version = Requirements->Revision = 1;
        Requirements->Count = AP_SIZE_COUNT;
        Length = AP_MAX_SIZE;
        for (i=0; i<AP_SIZE_COUNT; i++) {
            Requirements->Descriptors[i].Option = IO_RESOURCE_ALTERNATIVE;
            Requirements->Descriptors[i].Type = CmResourceTypeMemory;
            Requirements->Descriptors[i].ShareDisposition = CmResourceShareDeviceExclusive;
            Requirements->Descriptors[i].Flags = CM_RESOURCE_MEMORY_READ_WRITE | CM_RESOURCE_MEMORY_PREFETCHABLE;

            Requirements->Descriptors[i].u.Memory.Length = Length;
            Requirements->Descriptors[i].u.Memory.Alignment = Length;
            Requirements->Descriptors[i].u.Memory.MinimumAddress.QuadPart = 0;
            Requirements->Descriptors[i].u.Memory.MaximumAddress.QuadPart = (ULONG)-1;

            Length = Length/2;
        }
        *ApertureRequirements = Requirements;
    }
    return(STATUS_SUCCESS);
}


NTSTATUS
AgpSetAperture(
    IN PAGPALi_EXTENSION AgpContext,
    IN PHYSICAL_ADDRESS NewBase,
    IN ULONG NewSizeInPages
    )
/*++

Routine Description:

    Sets the GART aperture to the supplied settings

Arguments:

    AgpContext - Supplies the AGP context

    NewBase - Supplies the new physical memory base for the GART.

    NewSizeInPages - Supplies the new size for the GART

Return Value:

    NTSTATUS

--*/

{
    ULONG ApBase;
    ULONG ApSize;
    APCTRL ApCtrl;
    GTLBCTRL GTLBCtrl;
    ULONG GTLBDisable;
    PHYSICAL_ADDRESS GartPhysical;

    GartPhysical = AgpContext->GartPhysical;

    //
    // Reprogram Special Target settings when the chip
    // is powered off, but ignore rate changes as those were already
    // applied during MasterInit
    //
    if (AgpContext->SpecialTarget & ~AGP_FLAG_SPECIAL_RESERVE) {
        AgpSpecialTarget(AgpContext,
                         AgpContext->SpecialTarget &
                         ~AGP_FLAG_SPECIAL_RESERVE);
    }
    
    //
    // Set GART base
    //
    ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ApCtrl, APCTRL_OFFSET);
    ApCtrl.ATTBase = GartPhysical.LowPart / PAGE_SIZE;
    WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ApCtrl, APCTRL_OFFSET);

    //
    // If the new settings match the current settings, leave everything
    // alone.
    //
    if ((NewBase.QuadPart == AgpContext->ApertureStart.QuadPart) &&
        (NewSizeInPages == AgpContext->ApertureLength / PAGE_SIZE)) {
        //
        // Enable GART table
        //
        if ((AgpContext->ChipsetType != ALi1647) && (AgpContext->ChipsetType != ALi1651) &&
            (AgpContext->ChipsetType != ALi1644) && (AgpContext->ChipsetType != ALi1646) &&
            (AgpContext->ChipsetType != ALi1661) && (AgpContext->ChipsetType != ALi1667))
        {
            if (AgpContext->Gart) {
                ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &GTLBCtrl, GTLBCTRL_OFFSET);
                GTLBCtrl.GTLB_ENJ = 0;
                WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &GTLBCtrl, GTLBCTRL_OFFSET);
            }
        }       

        AgpWorkaround(AgpContext);

        return(STATUS_SUCCESS);
    }

    //
    // Figure out the new APSIZE setting, make sure it is valid.
    //
    switch (NewSizeInPages) {
        case 4 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_4MB;
            break;
        case 8 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_8MB;
            break;
        case 16 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_16MB;
            break;
        case 32 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_32MB;
            break;
        case 64 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_64MB;
            break;
        case 128 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_128MB;
            break;
        case 256 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_256MB;
            break;
        default:
            AGPLOG(AGP_CRITICAL,
                   ("AgpSetAperture - invalid GART size of %lx pages specified, aperture at %I64X.\n",
                    NewSizeInPages,
                    NewBase.QuadPart));
            ASSERT(FALSE);
            return(STATUS_INVALID_PARAMETER);
    }

    //
    // Make sure the supplied size is aligned on the appropriate boundary.
    //
    ASSERT(NewBase.HighPart == 0);
    ASSERT((NewBase.QuadPart & ((NewSizeInPages * PAGE_SIZE) - 1)) == 0);
    if ((NewBase.QuadPart & ((NewSizeInPages * PAGE_SIZE) - 1)) != 0 ) {
        AGPLOG(AGP_CRITICAL,
               ("AgpSetAperture - invalid base %I64X specified for GART aperture of %lx pages\n",
               NewBase.QuadPart,
               NewSizeInPages));
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Need to reset the hardware to match the supplied settings
    //
    // If the GTLB is enabled, disable it, write the new settings, then reenable the GTLB
    //
    if ((AgpContext->ChipsetType != ALi1647) && (AgpContext->ChipsetType != ALi1651) &&
        (AgpContext->ChipsetType != ALi1644) && (AgpContext->ChipsetType != ALi1646) &&
        (AgpContext->ChipsetType != ALi1661) && (AgpContext->ChipsetType != ALi1667))
    {
        ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &GTLBCtrl, GTLBCTRL_OFFSET);
        GTLBDisable = GTLBCtrl.GTLB_ENJ;
        if (!GTLBDisable)
        {
                GTLBCtrl.GTLB_ENJ = 1;
                WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &GTLBCtrl, GTLBCTRL_OFFSET);
        }
    }

    //
    // update APBASE
    //
    ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ApBase, APBASE_OFFSET);
    ApBase = (ApBase & 0x0000000F) | NewBase.LowPart;
    WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ApBase, APBASE_OFFSET);

    //
    // update APSIZE
    //
    ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ApCtrl, APCTRL_OFFSET);
    ApCtrl.ApSize = ApSize;
    WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ApCtrl, APCTRL_OFFSET);

    //
    // Only 1541 chipset supports NLVM_BASE and NLVM_TOP
    //
    if (AgpContext->ChipsetType == ALi1541) {
        //
        // update NLVM_BASE and NLVM_TOP
        //
        ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &GTLBCtrl, GTLBCTRL_OFFSET);
        GTLBCtrl.NLVM_Base = NewBase.LowPart >> 20;
        GTLBCtrl.NLVM_Top = (NewBase.LowPart + NewSizeInPages * PAGE_SIZE - 0x100000) >> 20;
        WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &GTLBCtrl, GTLBCTRL_OFFSET);
    }

#if DBG
    //
    // Read back what we wrote, make sure it worked
    //
    {
        APCTRL DbgSize;
        ULONG DbgBase;

        ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &DbgSize, APCTRL_OFFSET);
        ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &DbgBase, APBASE_OFFSET);
        ASSERT(DbgSize.ApSize == ApSize);
        ASSERT(DbgBase == ApBase);
    }
#endif

    //
    // Now enable the GTLB if it was enabled before
    //
    if ((AgpContext->ChipsetType != ALi1647) && (AgpContext->ChipsetType != ALi1651) &&
        (AgpContext->ChipsetType != ALi1644) && (AgpContext->ChipsetType != ALi1646) &&
        (AgpContext->ChipsetType != ALi1661) && (AgpContext->ChipsetType != ALi1667))
    {
        if (!GTLBDisable)
        {
                ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &GTLBCtrl, GTLBCTRL_OFFSET);
                GTLBCtrl.GTLB_ENJ = 0;
                WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &GTLBCtrl, GTLBCTRL_OFFSET);
        }
    }

    //
    // Update our extension to reflect the new GART setting
    //
    AgpContext->ApertureStart = NewBase;
    AgpContext->ApertureLength = NewSizeInPages * PAGE_SIZE;

    return(STATUS_SUCCESS);
}



VOID
AgpDisableAperture(
    IN PAGPALi_EXTENSION AgpContext
    )
/*++

Routine Description:

    Disables the GART aperture so that this resource is available
    for other devices

Arguments:

    AgpContext - Supplies the AGP context

Return Value:

    None - this routine must always succeed.

--*/

{
    GTLBCTRL GTLBCtrl;
    ULONG GTLBDisable;

    //
    // Disable the aperture
    //
    if ((AgpContext->ChipsetType != ALi1647) && (AgpContext->ChipsetType != ALi1651) &&
        (AgpContext->ChipsetType != ALi1644) && (AgpContext->ChipsetType != ALi1646) &&
        (AgpContext->ChipsetType != ALi1661) && (AgpContext->ChipsetType != ALi1667))
    {
        ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &GTLBCtrl, GTLBCTRL_OFFSET);
        GTLBDisable = GTLBCtrl.GTLB_ENJ;
        if (!GTLBDisable)
        {
                GTLBCtrl.GTLB_ENJ = 1;
                WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &GTLBCtrl, GTLBCTRL_OFFSET);
        }
    }

    //
    // Nuke the Gart!  (It's meaningless now...)
    //
    if (AgpContext->Gart != NULL) {
        MmFreeContiguousMemory(AgpContext->Gart);
        AgpContext->Gart = NULL;
        AgpContext->GartLength = 0;
    }
}

NTSTATUS
AgpReserveMemory(
    IN PAGPALi_EXTENSION AgpContext,
    IN OUT AGP_RANGE *Range
    )
/*++

Routine Description:

    Reserves a range of memory in the GART.

Arguments:

    AgpContext - Supplies the AGP Context

    Range - Supplies the AGP_RANGE structure. AGPLIB
        will have filled in NumberOfPages and Type. This
        routine will fill in MemoryBase and Context.

Return Value:

    NTSTATUS

--*/

{
    ULONG Index;
    ULONG NewState;
    NTSTATUS Status;
    PGART_PTE FoundRange;
    BOOLEAN Backwards;

    ASSERT((Range->Type == MmNonCached) || (Range->Type == MmWriteCombined));
    ASSERT(Range->NumberOfPages <= (AgpContext->ApertureLength / PAGE_SIZE));

    //
    // If we have not allocated our GART yet, now is the time to do so
    //
    if (AgpContext->Gart == NULL) {
        ASSERT(AgpContext->GartLength == 0);
        Status = AgpALiCreateGart(AgpContext,Range->NumberOfPages);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AgpALiCreateGart failed %08lx to create GART of size %lx\n",
                    Status,
                    AgpContext->ApertureLength));
            return(Status);
        }
    }
    ASSERT(AgpContext->GartLength != 0);

    //
    // Now that we have a GART, try and find enough contiguous entries to satisfy
    // the request. Requests for uncached memory will scan from high addresses to
    // low addresses. Requests for write-combined memory will scan from low addresses
    // to high addresses. We will use a first-fit algorithm to try and keep the allocations
    // packed and contiguous.
    //
    Backwards = (Range->Type == MmNonCached) ? TRUE : FALSE;
    FoundRange = AgpALiFindRangeInGart(&AgpContext->Gart[0],
                                       &AgpContext->Gart[(AgpContext->GartLength / sizeof(GART_PTE)) - 1],
                                       Range->NumberOfPages,
                                       Backwards,
                                       GART_ENTRY_FREE);

    if (FoundRange == NULL) {
        //
        // A big enough chunk was not found.
        //
        AGPLOG(AGP_CRITICAL,
               ("AgpReserveMemory - Could not find %d contiguous free pages of type %d in GART at %08lx\n",
                Range->NumberOfPages,
                Range->Type,
                AgpContext->Gart));

        //
        //  This is where we could try and grow the GART
        //

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    AGPLOG(AGP_NOISE,
           ("AgpReserveMemory - reserved %d pages at GART PTE %08lx\n",
            Range->NumberOfPages,
            FoundRange));

    //
    // Set these pages to reserved
    //
    if (Range->Type == MmNonCached) {
        NewState = GART_ENTRY_RESERVED_UC;
    } else {
        NewState = GART_ENTRY_RESERVED_WC;
    }

    for (Index = 0;Index < Range->NumberOfPages; Index++) {
        ASSERT(FoundRange[Index].Soft.State == GART_ENTRY_FREE);
        FoundRange[Index].AsUlong = 0;
        FoundRange[Index].Soft.State = NewState;
    }

    Range->MemoryBase.QuadPart = AgpContext->ApertureStart.QuadPart + (FoundRange - &AgpContext->Gart[0]) * PAGE_SIZE;
    Range->Context = FoundRange;

    ASSERT(Range->MemoryBase.HighPart == 0);
    AGPLOG(AGP_NOISE,
           ("AgpReserveMemory - reserved memory handle %lx at PA %08lx\n",
            FoundRange,
            Range->MemoryBase.LowPart));

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpReleaseMemory(
    IN PAGPALi_EXTENSION AgpContext,
    IN PAGP_RANGE Range
    )
/*++

Routine Description:

    Releases memory previously reserved with AgpReserveMemory

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the range to be released.

Return Value:

    NTSTATUS

--*/

{
    PGART_PTE Pte;
    ULONG Start;
    GTLBTAGCLR ClearTag;

    //
    // Go through and free all the PTEs. None of these should still
    // be valid at this point.
    //
    for (Pte = Range->Context;
         Pte < (PGART_PTE)Range->Context + Range->NumberOfPages;
         Pte++) {
        if (Range->Type == MmNonCached) {
            ASSERT(Pte->Soft.State == GART_ENTRY_RESERVED_UC);
        } else {
            ASSERT(Pte->Soft.State == GART_ENTRY_RESERVED_WC);
        }
        Pte->Soft.State = GART_ENTRY_FREE;
    }

    //
    // Clear All Tag
    //
    ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ClearTag, GTLBTAGCLR_OFFSET);
    ClearTag.GTLBTagClear = 1;
    ClearTag.ClearAllTag = 1;
    WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ClearTag, GTLBTAGCLR_OFFSET);

    Range->MemoryBase.QuadPart = 0;
    return(STATUS_SUCCESS);
}


NTSTATUS
AgpALiCreateGart(
    IN PAGPALi_EXTENSION AgpContext,
    IN ULONG MinimumPages
    )
/*++

Routine Description:

    Allocates and initializes an empty GART. The current implementation
    attempts to allocate the entire GART on the first reserve.

Arguments:

    AgpContext - Supplies the AGP context

    MinimumPages - Supplies the minimum size (in pages) of the GART to be
        created.

Return Value:

    NTSTATUS

--*/

{
    PGART_PTE Gart;
    ULONG GartLength;
    PHYSICAL_ADDRESS LowestAcceptable;
    PHYSICAL_ADDRESS BoundaryMultiple;
    PHYSICAL_ADDRESS HighestAcceptable;
    PHYSICAL_ADDRESS GartPhysical;
    ULONG i;
    CACHECTRL FlushCache;
    APCTRL ApCtrl;
    GTLBCTRL    GTLBCtrl;

    //
    // Try and get a chunk of contiguous memory big enough to map the
    // entire aperture.
    //
    HighestAcceptable.QuadPart = 0xFFFFFFFF;
    LowestAcceptable.QuadPart = 0;
    BoundaryMultiple.QuadPart = 0;
    GartLength = BYTES_TO_PAGES(AgpContext->ApertureLength) * sizeof(GART_PTE);

    Gart = MmAllocateContiguousMemorySpecifyCache(GartLength,
                                                  LowestAcceptable,
                                                  HighestAcceptable,
                                                  BoundaryMultiple,
                                                  MmNonCached);
    if (Gart == NULL) {
        AGPLOG(AGP_CRITICAL,
               ("AgpALiCreateGart - MmAllocateContiguousMemory %lx failed\n",
                GartLength));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    //
    // We successfully allocated a contiguous chunk of memory.
    // It should be page aligned already.
    //
    ASSERT(((ULONG_PTR)Gart & (PAGE_SIZE-1)) == 0);

    //
    // Get the physical address.
    //
    GartPhysical = MmGetPhysicalAddress(Gart);
    AGPLOG(AGP_NOISE,
           ("AgpALiCreateGart - GART of length %lx created at VA %08lx, PA %08lx\n",
            GartLength,
            Gart,
            GartPhysical.LowPart));
    ASSERT(GartPhysical.HighPart == 0);
    ASSERT((GartPhysical.LowPart & (PAGE_SIZE-1)) == 0);

    //
    // Initialize all the PTEs to free
    //
    for (i=0; i<GartLength/sizeof(GART_PTE); i++) {
        Gart[i].AsUlong = 0;
    }

    //
    // Only 1541 chipset has L1_2_CACHE_FLUSH_CTRL
    //
    if (AgpContext->ChipsetType == ALi1541) {
        
        //
        // Flush GART table region
        //
        FlushCache.Flush_Enable = 1;
        for (i=0; i < GartLength/PAGE_SIZE; i++)
        {
            FlushCache.Address = (GartPhysical.LowPart / PAGE_SIZE) + i;
            WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &FlushCache, L1_2_CACHE_FLUSH_CTRL);
        }
    }

    //
    // Set GART base
    //
    ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ApCtrl, APCTRL_OFFSET);
    ApCtrl.ATTBase = GartPhysical.LowPart / PAGE_SIZE;
    WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ApCtrl, APCTRL_OFFSET);

    //
    // Enable GART table
    //
    if ((AgpContext->ChipsetType != ALi1647) && (AgpContext->ChipsetType != ALi1651) &&
        (AgpContext->ChipsetType != ALi1644) && (AgpContext->ChipsetType != ALi1646) &&
        (AgpContext->ChipsetType != ALi1661) && (AgpContext->ChipsetType != ALi1667))
    {
        ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &GTLBCtrl, GTLBCTRL_OFFSET);
        GTLBCtrl.GTLB_ENJ = 0;
        WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &GTLBCtrl, GTLBCTRL_OFFSET);
    }   

    //
    // Update our extension to reflect the current state.
    //
    AgpContext->Gart = Gart;
    AgpContext->GartLength = GartLength;
    AgpContext->GartPhysical = GartPhysical;

    return(STATUS_SUCCESS);
}

NTSTATUS
Agp1541FlushPages(
    IN PAGPALi_EXTENSION AgpContext,
    IN PMDL Mdl
    )

/*++

Routine Description:

    Flush entries in the GART.

Arguments:

    AgpContext - Supplies the AGP context

    Mdl - Supplies the MDL describing the physical pages to be flushed

Return Value:

    VOID

--*/

{
    ULONG PageCount;
    CACHECTRL FlushCache;
    ULONG Index;
    PULONG Page;

    ASSERT(Mdl->Next == NULL);
    PageCount = BYTES_TO_PAGES(Mdl->ByteCount);

    Page = (PULONG)(Mdl + 1);

    //
    // Flush GART table entry
    //
    FlushCache.Flush_Enable = 1;
    for (Index = 0; Index < PageCount; Index++) {
        FlushCache.Address = Page[Index];
        WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &FlushCache, L1_2_CACHE_FLUSH_CTRL);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
AgpMapMemory(
    IN PAGPALi_EXTENSION AgpContext,
    IN PAGP_RANGE Range,
    IN PMDL Mdl,
    IN ULONG OffsetInPages,
    OUT PHYSICAL_ADDRESS *MemoryBase
    )
/*++

Routine Description:

    Maps physical memory into the GART somewhere in the specified range.

Arguments:

    AgpContext - Supplies the AGP context

    Range - Supplies the AGP range that the memory should be mapped into

    Mdl - Supplies the MDL describing the physical pages to be mapped

    OffsetInPages - Supplies the offset into the reserved range where the
        mapping should begin.

    MemoryBase - Returns the physical memory in the aperture where the pages
        were mapped.

Return Value:

    NTSTATUS

--*/

{
    ULONG PageCount;
    PGART_PTE Pte;
    PGART_PTE StartPte;
    ULONG Index;
    ULONG TargetState;
    PULONG Page;
    BOOLEAN Backwards;
    GART_PTE NewPte;
    GTLBTAGCLR ClearTag;

    ASSERT(Mdl->Next == NULL);

    StartPte = Range->Context;
    PageCount = BYTES_TO_PAGES(Mdl->ByteCount);
    ASSERT(PageCount <= Range->NumberOfPages);
    ASSERT(OffsetInPages <= Range->NumberOfPages);
    ASSERT(PageCount + OffsetInPages <= Range->NumberOfPages);
    ASSERT(PageCount > 0);

    TargetState = (Range->Type == MmNonCached) ? GART_ENTRY_RESERVED_UC : GART_ENTRY_RESERVED_WC;

    Pte = StartPte + OffsetInPages;

    //
    // We have a suitable range, now fill it in with the supplied MDL.
    //
    ASSERT(Pte >= StartPte);
    ASSERT(Pte + PageCount <= StartPte + Range->NumberOfPages);
    NewPte.AsUlong = 0;
    NewPte.Soft.State = (Range->Type == MmNonCached) ? GART_ENTRY_VALID_UC :
                                                       GART_ENTRY_VALID_WC;
    Page = (PULONG)(Mdl + 1);

    // Fill the physical memory address into GART
    for (Index = 0; Index < PageCount; Index++) {
        AGPLOG(AGP_NOISE,
               ("AgpMapMemory: Pte=%p, Page=%x\n", &Pte[Index], *Page));
        NewPte.Hard.Page = *Page++;
        Pte[Index].AsUlong = NewPte.AsUlong;
    }

    //
    // Clear All Tag
    //
    ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ClearTag, GTLBTAGCLR_OFFSET);
    ClearTag.GTLBTagClear = 1;
    ClearTag.ClearAllTag = 1;
    WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ClearTag, GTLBTAGCLR_OFFSET);

    MemoryBase->QuadPart = Range->MemoryBase.QuadPart + (Pte - StartPte) * PAGE_SIZE;

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpUnMapMemory(
    IN PAGPALi_EXTENSION AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG PageOffset
    )
/*++

Routine Description:

    Unmaps previously mapped memory in the GART.

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the AGP range that the memory should be mapped into

    NumberOfPages - Supplies the number of pages in the range to be freed.

    PageOffset - Supplies the offset into the range where the freeing should begin.

Return Value:

    NTSTATUS

--*/

{
    ULONG i;
    PGART_PTE Pte;
    PGART_PTE StartPte;
    GTLBTAGCLR ClearTag;
    ULONG NewState;

    ASSERT(PageOffset + NumberOfPages <= AgpRange->NumberOfPages);

    StartPte = AgpRange->Context;
    Pte = &StartPte[PageOffset];
    if (AgpRange->Type == MmNonCached) {
        NewState = GART_ENTRY_RESERVED_UC;
    } else {
        NewState = GART_ENTRY_RESERVED_WC;
    }

    //
    // Clear the GART entry.
    //
    for (i=0; i<NumberOfPages; i++) {
        if (Pte[i].Hard.Valid) {
            Pte[i].Soft.State = NewState;
        } else {
            //
            // This page is not mapped, just skip it.
            //
            AGPLOG(AGP_NOISE,
                   ("AgpUnMapMemory - PTE %08lx (%08lx) at offset %d not mapped\n",
                    &Pte[i],
                    Pte[i].AsUlong,
                    i));
        }
    }

    //
    // Clear All Tag
    //
    ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ClearTag, GTLBTAGCLR_OFFSET);
    ClearTag.GTLBTagClear = 1;
    ClearTag.ClearAllTag = 1;
    WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ClearTag, GTLBTAGCLR_OFFSET);

    return(STATUS_SUCCESS);
}


PGART_PTE
AgpALiFindRangeInGart(
    IN PGART_PTE StartPte,
    IN PGART_PTE EndPte,
    IN ULONG Length,
    IN BOOLEAN SearchBackward,
    IN ULONG SearchState
    )
/*++

Routine Description:

    Finds a contiguous range in the GART. This routine can
    search either from the beginning of the GART forwards or
    the end of the GART backwards.

Arguments:

    StartIndex - Supplies the first GART pte to search

    EndPte - Supplies the last GART to search (inclusive)

    Length - Supplies the number of contiguous free entries
        to search for.

    SearchBackward - TRUE indicates that the search should begin
        at EndPte and search backwards. FALSE indicates that the
        search should begin at StartPte and search forwards

    SearchState - Supplies the PTE state to look for.

Return Value:

    Pointer to the first PTE in the GART if a suitable range
    is found.

    NULL if no suitable range exists.

--*/

{
    PGART_PTE Current;
    PGART_PTE Last;
    LONG Delta;
    ULONG Found;
    PGART_PTE Candidate;

    ASSERT(EndPte >= StartPte);
    ASSERT(Length <= (ULONG)(EndPte - StartPte + 1));
    ASSERT(Length != 0);

    if (SearchBackward) {
        Current = EndPte;
        Last = StartPte-1;
        Delta = -1;
    } else {
        Current = StartPte;
        Last = EndPte+1;
        Delta = 1;
    }

    Found = 0;
    while (Current != Last) {
        if (Current->Soft.State == SearchState) {
            if (++Found == Length) {
                //
                // A suitable range was found, return it
                //
                if (SearchBackward) {
                    return(Current);
                } else {
                    return(Current - Length + 1);
                }
            }
        } else {
            Found = 0;
        }
        Current += Delta;
    }

    //
    // A suitable range was not found.
    //
    return(NULL);
}


VOID
AgpFindFreeRun(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT ULONG *FreePages,
    OUT ULONG *FreeOffset
    )
/*++

Routine Description:

    Finds the first contiguous run of free pages in the specified
    part of the reserved range.

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the AGP range

    NumberOfPages - Supplies the size of the region to be searched for free pages

    OffsetInPages - Supplies the start of the region to be searched for free pages

    FreePages - Returns the length of the first contiguous run of free pages

    FreeOffset - Returns the start of the first contiguous run of free pages

Return Value:

    None. FreePages == 0 if there are no free pages in the specified range.

--*/

{
    PGART_PTE Pte;
    ULONG i;

    Pte = (PGART_PTE)(AgpRange->Context) + OffsetInPages;

    //
    // Find the first free PTE
    //
    for (i=0; i<NumberOfPages; i++) {
        if (Pte[i].Hard.Valid == 0) {
            //
            // Found a free PTE, count the contiguous ones.
            //
            *FreeOffset = i + OffsetInPages;
            *FreePages = 0;
            while ((i<NumberOfPages) && (Pte[i].Hard.Valid == 0)) {
                *FreePages += 1;
                ++i;
            }
            return;
        }
    }

    //
    // No free PTEs in the specified range
    //
    *FreePages = 0;
    return;

}


VOID
AgpGetMappedPages(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT PMDL Mdl
    )
/*++

Routine Description:

    Returns the list of physical pages mapped into the specified
    range in the GART.

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the AGP range

    NumberOfPages - Supplies the number of pages to be returned

    OffsetInPages - Supplies the start of the region

    Mdl - Returns the list of physical pages mapped in the specified range.

Return Value:

    None

--*/

{
    PGART_PTE Pte;
    ULONG i;
    PULONG Pages;

    ASSERT(NumberOfPages * PAGE_SIZE == Mdl->ByteCount);

    Pages = (PULONG)(Mdl + 1);
    Pte = (PGART_PTE)(AgpRange->Context) + OffsetInPages;

    for (i=0; i<NumberOfPages; i++) {
        ASSERT(Pte[i].Hard.Valid == 1);
        Pages[i] = Pte[i].Hard.Page;
    }
    return;
}

VOID
AgpWorkaround(
    IN PVOID AgpExtension
    )
{
    PAGPALi_EXTENSION Extension = AgpExtension;
    ULONG ulTemp, ulTemp1, ulLockRW, i, j, ulQD;
    ULONG ulType, ulSize;
    BOOLEAN blPrefetchFound, blSupportAGP, blnVidia=FALSE, blMatrox=FALSE;
    UCHAR ID, Address, Data;
    NTSTATUS                 Status;

    ulTemp = (ULONG)-1;
    ReadConfigUlongSafe(AGP_VGA_BUS_ID, AGP_VGA_SLOT_ID, &ulTemp, 0);

    //
    // Come back after you splurge for an AGP card!!!
    //
    if (ulTemp == (ULONG)-1) {
        return;
    }

    if ((ulTemp & 0xFFFF) == 0x10DE)                            // nVidia chip detected
        blnVidia=TRUE;
    else if ((ulTemp & 0xFFFF) == 0x102B)
        blMatrox=TRUE;

    switch (Extension->ChipsetType)
    {
        case ALi1541:
            ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, AGP_STATUS_OFFSET);     // adjust queue depth to avoid ambiguous
            if (((ulTemp & 0xFF000000) >= 0x1C000000) && ((ulTemp & 0xFF000000) <= 0x20000000))
            {
                ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulLockRW, M1541_Lock_WR);
                ulTemp1 = ulLockRW | 0x40;
                WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp1, M1541_Lock_WR);
                ulTemp = (ulTemp & 0x00FFFFFF) | 0x1B000000;
                WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, AGP_STATUS_OFFSET);
                ulLockRW = ulLockRW & 0xFFFFFFBF;
                WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulLockRW, M1541_Lock_WR);
            }

            ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, 0x40);      // 0x43 bit 7 -> 1
            ulTemp = ulTemp | 0x80000000;
            WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, 0x40);

            ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_P2P_SLOT_ID, &ulTemp, 0x88);       // P2P 0x88 bit 7,5,3 -> 1
            ulTemp = ulTemp | 0x000000A8;
            WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_P2P_SLOT_ID, &ulTemp, 0x88);

            // fix frame buffer here
            i=0;
            blPrefetchFound=FALSE;
            while ((i<6) && (!blPrefetchFound))      // Jump out loop when first prefetch found
            {                                       // Two or more prefetch case should be considered in the future
                ReadConfigUlong(AGP_VGA_BUS_ID, AGP_VGA_SLOT_ID, &ulTemp1, 0x10+i*0x4);     // read VGA base address
                if ((ulTemp1 & 0x0000000F) == 0x8) blPrefetchFound=TRUE;
                i++;
            }

            if (blPrefetchFound)             // AGP VGA prefetchable address is found. Modify M1541 write buffer
            {
                ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_P2P_SLOT_ID, &ulTemp, 0x84);
                if ((ulTemp & 0x00010000) == 0x00010000)       // Write buffer is enabled
                {
                    ulTemp = (ulTemp & 0xFFFF0000) | ((ulTemp1 & 0xFFF00000) >> 16) | 0x4;
                    WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_P2P_SLOT_ID, &ulTemp, 0x84);
                }
            }
            else                            // AGP VGA prefetchable address is not found. Disable M1541 write buffer
            {
                ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_P2P_SLOT_ID, &ulTemp, 0x84);
                ulTemp = ulTemp & 0xFFFE0000;
                WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_P2P_SLOT_ID, &ulTemp, 0x84);
            }

            if (blnVidia)    // Set aperture size to 4M as a temporatory solution
            {
                ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, APCTRL_OFFSET);
                ulTemp = (ulTemp & 0xFFFFFFF0) | AP_SIZE_4MB;
                WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, APCTRL_OFFSET);

            }

            break;

        case ALi1621:
            // Check AGP VGA is a pipeline(SBA disabled) device. If yes, adjust queue depth to 0x2(3 queues)
            ReadConfigUlong(AGP_VGA_BUS_ID, AGP_VGA_SLOT_ID, &ulTemp1, PCI_STATUS_REG);
            ulQD = 0;
            blSupportAGP = FALSE;
            if ((ulTemp1 & 0x00100000) != 0)
            {
                ReadConfigUlong(AGP_VGA_BUS_ID, AGP_VGA_SLOT_ID, &ulTemp1, CAP_PTR);
                ulTemp = ulTemp1 & 0xFF;

                while (!blSupportAGP)
                {
                    if ((ulTemp < 0x40) || (ulTemp > 0xF4)) break;
                    ReadConfigUlong(AGP_VGA_BUS_ID, AGP_VGA_SLOT_ID, &ulTemp1, ulTemp);
                    if ((ulTemp1 & 0xFF) == AGP_ID)
                        blSupportAGP = TRUE;
                    else
                        ulTemp = (ulTemp1 & 0xFF00) >> 8;
                }

                if (blSupportAGP)
                {
                    ReadConfigUlong(AGP_VGA_BUS_ID, AGP_VGA_SLOT_ID, &ulTemp1, ulTemp+4);   // Read AGP status register
                    if ((ulTemp1 & 0x00000200) == 0x0) ulQD = 0x2;                      // AGP VGA supports pipeline only
                }
            }

            ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, AGP_STATUS_OFFSET);     // adjust queue depth to avoid ambiguous
            if ((((ulTemp & 0xFF000000) >= 0x1C000000) && ((ulTemp & 0xFF000000) <= 0x20000000)) || (ulQD != 0))
            {
                ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulLockRW, M1621_Lock_WR);
                ulTemp1 = ulLockRW | 0x1000;
                WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp1, M1621_Lock_WR);

                if (ulQD != 0)
                    ulTemp = (ulTemp & 0x00FFFFFF) | (ulQD << 24);
                else
                    ulTemp = (ulTemp & 0x00FFFFFF) | 0x1B000000;
                WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, AGP_STATUS_OFFSET);
                ulLockRW = ulLockRW & 0xFFFFEFFF;
                WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulLockRW, M1621_Lock_WR);
            }

            ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, 0x80);
            ulTemp = ulTemp & 0xFFFFF3FF;                               // set offset 0x81 bit 2~3 to 0
            WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, 0x80);

            if (blnVidia)
            {
                ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, 0x50);
                ulTemp = ulTemp | 0x40;                                 // set M1621 index 0x50 bit 6 to 1
                WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, 0x50);

                ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, 0x60);
                ulTemp = ulTemp | 0x40;                                 // set M1621 index 0x60 bit 6 to 1
                WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, 0x60);

                ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, 0x7C);
                ulTemp = ulTemp & 0xCFFFFFFF;                           // set M1621 index 0x7F bit 4~5 to 0
                WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, 0x7C);
            }

            if (blMatrox)
            {
                ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, 0x50);
                ulTemp = ulTemp | 0xFF000000;                           // set M1621 index 0x53 to 0xFF
                WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, 0x50);
            }

            break;
        case ALi1631:
        case ALi1632:
            break;
        case ALi1641:
            if (blMatrox)
            {
                ReadConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, 0x50);
                ulTemp = ulTemp | 0xFF000000;                           // set M1621 index 0x53 to 0xFF
                WriteConfigUlong(AGP_ALi_GART_BUS_ID, AGP_ALi_GART_SLOT_ID, &ulTemp, 0x50);
            }

            break;
        case ALi1644:
        case ALi1646:
        case ALi1647:
        case ALi1651:
        case ALi1661:
        case ALi1667:
            break;
        default:
            break;
    }
}


NTSTATUS
AgpSpecialTarget(
    IN PAGPALi_EXTENSION AgpContext,
    IN ULONGLONG DeviceFlags
    )
/*++

Routine Description:

    This routine makes "special" tweaks to the AGP chipset

Arguments:

    AgpContext - Supplies the AGP context

    DeviceFlags - Flags indicating what tweaks to perform

Return Value:

    STATUS_SUCCESS, or error

--*/
{
    NTSTATUS Status;

    //
    // Should we change the AGP rate?
    //
    if (DeviceFlags & AGP_FLAG_SPECIAL_RESERVE) {

        Status = AgpALiSetRate(AgpContext,
                               (ULONG)((DeviceFlags & AGP_FLAG_SPECIAL_RESERVE)
                                       >> AGP_FLAG_SET_RATE_SHIFT));
        
        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    }

    //
    // Add more tweaks here...
    //

    AgpContext->SpecialTarget |= DeviceFlags;

    return STATUS_SUCCESS;
}


NTSTATUS
AgpALiSetRate(
    IN PAGPALi_EXTENSION AgpContext,
    IN ULONG AgpRate
    )
/*++

Routine Description:

    This routine sets the AGP rate

Arguments:

    AgpContext - Supplies the AGP context

    AgpRate - Rate to set

    note: this routine assumes that AGP has already been enabled, and that
          whatever rate we've been asked to set is supported by master

Return Value:

    STATUS_SUCCESS, or error status

--*/
{
    NTSTATUS Status;
    ULONG TargetEnable;
    ULONG MasterEnable;
    PCI_AGP_CAPABILITY TargetCap;
    PCI_AGP_CAPABILITY MasterCap;
    BOOLEAN ReverseInit;

    //
    // Read capabilities
    //
    Status = AgpLibGetPciDeviceCapability(0, 0, &TargetCap);

    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING, ("AGPALiSetRate: AgpLibGetPciDeviceCapability "
                             "failed %08lx\n", Status));
        return Status;
    }

    Status = AgpLibGetMasterCapability(AgpContext, &MasterCap);

    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING, ("AGPALiSetRate: AgpLibGetMasterCapability "
                             "failed %08lx\n", Status));
        return Status;
    }

    //
    // Verify the requested rate is supported by both master and target
    //
    if (!(AgpRate & TargetCap.AGPStatus.Rate & MasterCap.AGPStatus.Rate)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Disable AGP while the pull the rug out from underneath
    //
    TargetEnable = TargetCap.AGPCommand.AGPEnable;
    TargetCap.AGPCommand.AGPEnable = 0;

    Status = AgpLibSetPciDeviceCapability(0, 0, &TargetCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("AGPALiSetRate: AgpLibSetPciDeviceCapability %08lx for "
                "Target failed %08lx\n",
                &TargetCap,
                Status));
        return Status;
    }
    
    MasterEnable = MasterCap.AGPCommand.AGPEnable;
    MasterCap.AGPCommand.AGPEnable = 0;

    Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("AGPALiSetRate: AgpLibSetMasterCapability %08lx failed "
                "%08lx\n",
                &MasterCap,
                Status));
        return Status;
    }

    //
    // Fire up AGP with new rate
    //
    ReverseInit =
        (AgpContext->SpecialTarget & AGP_FLAG_REVERSE_INITIALIZATION) ==
        AGP_FLAG_REVERSE_INITIALIZATION;
    if (ReverseInit) {
        MasterCap.AGPCommand.Rate = AgpRate;
        MasterCap.AGPCommand.AGPEnable = MasterEnable;
        
        Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
        
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_WARNING,
                   ("AGPALiSetRate: AgpLibSetMasterCapability %08lx failed "
                    "%08lx\n",
                    &MasterCap,
                    Status));
        }
    }

    TargetCap.AGPCommand.Rate = AgpRate;
    TargetCap.AGPCommand.AGPEnable = TargetEnable;
        
    Status = AgpLibSetPciDeviceCapability(0, 0, &TargetCap);
    
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_WARNING,
               ("AGPALiSetRate: AgpLibSetPciDeviceCapability %08lx for "
                "Target failed %08lx\n",
                &TargetCap,
                Status));
        return Status;
    }

    if (!ReverseInit) {
        MasterCap.AGPCommand.Rate = AgpRate;
        MasterCap.AGPCommand.AGPEnable = MasterEnable;
        
        Status = AgpLibSetMasterCapability(AgpContext, &MasterCap);
        
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_WARNING,
                   ("AGPALiSetRate: AgpLibSetMasterCapability %08lx failed "
                    "%08lx\n",
                    &MasterCap,
                    Status));
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\isapnp\busp.h ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    busp.h

Abstract:

    Hardware independent header file for Pnp Isa bus extender.

Author:

    Shie-Lin Tzong (shielint) July-26-1995

Environment:

    Kernel mode only.

Revision History:

--*/
#ifndef _IN_KERNEL_
#define _IN_KERNEL_
#endif

#include <stdio.h>
#include <ntddk.h>
#include <stdarg.h>
#include <regstr.h>
#include "message.h"

#ifdef POOL_TAGGING
#undef ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'pasI')
#endif

//
// Turn this on to track resource start/stop printfs
//
#define VERBOSE_DEBUG 1

//
// ISOLATE_CARDS enables the code that actually isolates ISAPNP
// devices.  WIth this turned off, all aspects of ISAPNP are disabled except
// ejecting an ISA Interrupt translator.  This is intended for
// circumstances in which we aren't sure if we can get ISAPNP not to
// load at all but for which we want ISAPNP not to isolate ISAPNP
// cards i.e Win64
//

#if defined(_WIN64)
#define ISOLATE_CARDS 0
#else
#define ISOLATE_CARDS 1
#endif

//
// NT4_DRIVER_COMPAT enables the code which checks if a force config
// is installed for an ISA pnp device.  If yes, isapnp.sys will
// activate the device.  Else, the device is deactivated until isapnp
// receives a start irp.  This supports NT4 PNPISA drivers that expect
// to find the device activated at the 'force config' that was created
// when the driver was installed.
//

#define NT4_DRIVER_COMPAT 1
#define BOOT_CONFIG_PRIORITY   0x2000
#define KEY_VALUE_DATA(k) ((PCHAR)(k) + (k)->DataOffset)

//
// Define PnpISA driver unique error code to specify where the error was reported.
//

#define PNPISA_INIT_ACQUIRE_PORT_RESOURCE  0x01
#define PNPISA_INIT_MAP_PORT               0x02
#define PNPISA_ACQUIREPORTRESOURCE_1       0x10
#define PNPISA_ACQUIREPORTRESOURCE_2       0x11
#define PNPISA_ACQUIREPORTRESOURCE_3       0x12
#define PNPISA_CHECKBUS_1                  0x20
#define PNPISA_CHECKBUS_2                  0x21
#define PNPISA_CHECKDEVICE_1               0x30
#define PNPISA_CHECKDEVICE_2               0x31
#define PNPISA_CHECKDEVICE_3               0x32
#define PNPISA_CHECKDEVICE_4               0x33
#define PNPISA_CHECKDEVICE_5               0x34
#define PNPISA_CHECKINSTALLED_1            0x40
#define PNPISA_CHECKINSTALLED_2            0x41
#define PNPISA_CHECKINSTALLED_3            0x42
#define PNPISA_BIOSTONTRESOURCES_1         0x50
#define PNPISA_BIOSTONTRESOURCES_2         0x51
#define PNPISA_BIOSTONTRESOURCES_3         0x52
#define PNPISA_BIOSTONTRESOURCES_4         0x53
#define PNPISA_READBOOTRESOURCES_1         0x60
#define PNPISA_READBOOTRESOURCES_2         0x61
#define PNPISA_CLEANUP_1                   0x70


#define ISAPNP_IO_VERSION 1
#define ISAPNP_IO_REVISION 1
//
// Structures
//

//
// Extension data for Bus extender
//

typedef struct _PI_BUS_EXTENSION {

    //
    // Flags
    //

    ULONG Flags;

    //
    // Number of cards selected
    //

    ULONG NumberCSNs;

    //
    // ReadDataPort addr
    //

    PUCHAR ReadDataPort;
    BOOLEAN DataPortMapped;

    //
    // Address Port
    //

    PUCHAR AddressPort;
    BOOLEAN AddrPortMapped;

    //
    // Command port
    //

    PUCHAR CommandPort;
    BOOLEAN CmdPortMapped;

    //
    // Next Slot Number to assign
    //

    ULONG NextSlotNumber;

    //
    // DeviceList is the DEVICE_INFORMATION link list.
    //

    SINGLE_LIST_ENTRY DeviceList;

    //
    // CardList is the list of CARD_INFORMATION
    //

    SINGLE_LIST_ENTRY CardList;

    //
    // Physical device object
    //

    PDEVICE_OBJECT PhysicalBusDevice;

    //
    // Functional device object
    //

    PDEVICE_OBJECT FunctionalBusDevice;

    //
    // Attached Device object
    //

    PDEVICE_OBJECT AttachedDevice;

    //
    // Bus Number
    //

    ULONG BusNumber;

    //
    // Power management data
    //

    //
    // System Power state of the device
    //

    SYSTEM_POWER_STATE SystemPowerState;

    //
    // Device power state of the device
    //

    DEVICE_POWER_STATE DevicePowerState;

} PI_BUS_EXTENSION, *PPI_BUS_EXTENSION;

//
// CARD_INFORMATION Flags masks
//

typedef struct _CARD_INFORMATION_ {

    //
    // Next points to next CARD_INFORMATION structure
    //

    SINGLE_LIST_ENTRY CardList;

    //
    // Card select number for this Pnp Isa card.
    //

    USHORT CardSelectNumber;

    //
    // Number logical devices in the card.
    //

    ULONG NumberLogicalDevices;

    //
    // Logical device link list
    //

    SINGLE_LIST_ENTRY LogicalDeviceList;

    //
    // Pointer to card data which includes:
    //     9 byte serial identifier for the pnp isa card
    //     PlugPlay Version number type for the pnp isa card
    //     Identifier string resource type for the pnp isa card
    //     Logical device Id resource type (repeat for each logical device)
    //

    PVOID CardData;
    ULONG CardDataLength;

    // Flags for card-specific workarounds

    ULONG CardFlags;

} CARD_INFORMATION, *PCARD_INFORMATION;

//
// DEVICE_INFORMATION Flags masks
//

typedef struct _DEVICE_INFORMATION_ {

    //
    // Flags
    //

    ULONG Flags;

    //
    // Device power state of the device
    //

    DEVICE_POWER_STATE DevicePowerState;

    //
    // The device object of the device extension. I.e. the PDO
    //

    PDEVICE_OBJECT PhysicalDeviceObject;

    //
    // The isapnp bus extension which owns this device.
    //

    PPI_BUS_EXTENSION ParentDeviceExtension;

    //
    // Link list for ALL the Pnp Isa logical devices.
    // NextDevice points to next DEVICE_INFORMATION structure
    //

    SINGLE_LIST_ENTRY DeviceList;

    //
    // ResourceRequirements list
    //

    PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirements;

    //
    // Pointer to the CARD_INFORMATION for this device
    //

    PCARD_INFORMATION CardInformation;

    //
    // Link list for all the logical devices in a Pnp Isa card.
    //

    SINGLE_LIST_ENTRY LogicalDeviceList;

    //
    // LogicalDeviceNumber selects the corresponding logical device in the
    // pnp isa card specified by CSN.
    //

    USHORT LogicalDeviceNumber;

    //
    // Pointer to device specific data
    //

    PUCHAR DeviceData;

    //
    // Length of the device data
    //

    ULONG DeviceDataLength;

    //
    // Boot resources
    //

    PCM_RESOURCE_LIST BootResources;
    ULONG BootResourcesLength;

    //
    // AllocatedResources
    //

    PCM_RESOURCE_LIST AllocatedResources;

    //
    // LogConfHandle - the LogConfHandle whose AllocatedResources needs to be deleted on removal irp.
    //

    HANDLE LogConfHandle;

    // Counts of how many paging and crash dump paths
    // this device is on.
    LONG Paging, CrashDump;

} DEVICE_INFORMATION, *PDEVICE_INFORMATION;

//
// IRP dispatch routines
//
typedef
NTSTATUS
(*PPI_DISPATCH)(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );



//
// These must be updated if any new PNP or PO IRPs are added
//



#define IRP_MN_PNP_MAXIMUM_FUNCTION IRP_MN_QUERY_LEGACY_BUS_INFORMATION
#define IRP_MN_PO_MAXIMUM_FUNCTION  IRP_MN_QUERY_POWER

//
// Flags definitions of DEVICE_INFORMATION and BUS_EXTENSION
//

#define DF_DELETED          0x00000001
#define DF_REMOVED          0X00000002
#define DF_NOT_FUNCTIONING  0x00000004
#define DF_ENUMERATED       0x00000008
#define DF_ACTIVATED        0x00000010
#define DF_QUERY_STOPPED    0x00000020
#define DF_SURPRISE_REMOVED 0x00000040
#define DF_PROCESSING_RDP   0x00000080
#define DF_STOPPED          0x00000100
#define DF_RESTARTED_MOVED  0x00000200
#define DF_RESTARTED_NOMOVE 0x00000400
#define DF_REQ_TRIMMED      0x00000800
#define DF_NEEDS_RESCAN     0x00001000
#define DF_READ_DATA_PORT   0x40000000
#define DF_BUS              0x80000000

//
// Flags definitions for card-related hacks
//
//

#define CF_ISOLATION_BROKEN  0x00000001 /* once started, isolation is broken */
#define CF_IGNORE_BOOTCONFIG 0x00000002 /* unusually sensitive to bad bioses */
#define CF_FORCE_LEVEL       0x00000004 /* force level triggered interrupt */
#define CF_FORCE_EDGE        0x00000008 /* force edge triggered interrupt */
#define CF_IBM_MEMBOOTCONFIG 0x00000010 /* bad register on ibm isapnp token ring */

// Possible bus states

typedef enum  {
    PiSUnknown,                    // not sure of exact state
    PiSWaitForKey,                 //
    PiSSleep,                      //
    PiSIsolation,                  // performing isolation sequence
    PiSConfig,                     // one card in config
} PNPISA_STATE;


//
// The read data port range is from 0x200 - 0x3ff.
// We will try the following optimal ranges first
// if they all fail, we then pick any port from 0x200 - 0x3ff
//
// BEST:
//   One 4-byte range in 274-2FF
//   One 4-byte range in 374-3FF
//   One 4-byte range in 338-37F
//   One 4-byte range in 238-27F
//
// NORMAL:
//   One 4-byte range in 200-3FF
//

#define READ_DATA_PORT_RANGE_CHOICES 6

typedef struct _READ_DATA_PORT_RANGE {
    ULONG MinimumAddress;
    ULONG MaximumAddress;
    ULONG Alignment;
    ULONG CardsFound;
} READ_DATA_PORT_RANGE, *PREAD_DATA_PORT_RANGE;

//
// List node for Bus Extensions.
//
typedef struct _BUS_EXTENSION_LIST {
    PVOID Next;
    PPI_BUS_EXTENSION BusExtension;
} BUS_EXTENSION_LIST, *PBUS_EXTENSION_LIST;
//
// Constanct to control PipSelectLogicalDevice
//

#define SELECT_AND_ACTIVATE     0x1
#define SELECT_AND_DEACTIVATE   0x2
#define SELECT_ONLY             0x3

//
// Global Data references
//

extern PDRIVER_OBJECT           PipDriverObject;
extern UNICODE_STRING           PipRegistryPath;
extern PUCHAR                   PipReadDataPort;
extern PUCHAR                   PipAddressPort;
extern PUCHAR                   PipCommandPort;
extern READ_DATA_PORT_RANGE     PipReadDataPortRanges[];
extern KEVENT                   PipDeviceTreeLock;
extern KEVENT                   IsaBusNumberLock;
extern ULONG                    BusNumber;
extern ULONG                    ActiveIsaCount;
extern PBUS_EXTENSION_LIST      PipBusExtension;
extern ULONG                    BusNumberBuffer[];
extern RTL_BITMAP               BusNumBMHeader;
extern PRTL_BITMAP              BusNumBM;
extern PDEVICE_INFORMATION      PipRDPNode;
extern USHORT                   PipFirstInit;
extern PPI_DISPATCH             PiPnpDispatchTableFdo[];
extern PPI_DISPATCH             PiPnpDispatchTablePdo[];
extern ULONG                    PipDebugMask;
extern PNPISA_STATE             PipState;
extern BOOLEAN                  PipIsolationDisabled;

//
// Devnode / compat ID for the RDP
//
#define wReadDataPort (L"ReadDataPort")
#define IDReadDataPort (L"PNPRDP")
//
// Global strings
//

#define DEVSTR_PNPISA_DEVICE_NAME  (L"\\Device\\PnpIsa_Fdo_0")
#define BRIDGE_CHECK_KEY (L"DeferBridge")

extern WCHAR rgzPNPISADeviceName[sizeof(DEVSTR_PNPISA_DEVICE_NAME)/sizeof(WCHAR)];



//
// Prototypes
//

NTSTATUS
PipPassIrp(
    PDEVICE_OBJECT pDeviceObject,
    PIRP pIrp
    );

VOID
PipCompleteRequest(
    IN OUT PIRP Irp,
    IN NTSTATUS Status,
    IN PVOID Information
    );


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
PiUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
PipGetReadDataPort(
    PPI_BUS_EXTENSION BusExtension
    );

NTSTATUS
PiAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
PiDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiDispatchPnpFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiDispatchPnpPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiDispatchDevCtl(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiDispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiDispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PipGetCardIdentifier (
    PUCHAR CardData,
    PWCHAR *Buffer,
    PULONG BufferLength
    );

NTSTATUS
PipGetFunctionIdentifier (
    PUCHAR DeviceData,
    PWCHAR *Buffer,
    PULONG BufferLength
    );

NTSTATUS
PipQueryDeviceUniqueId (
    PDEVICE_INFORMATION DeviceInfo,
    PWCHAR *DeviceId
    );

NTSTATUS
PipQueryDeviceId (
    PDEVICE_INFORMATION DeviceInfo,
    PWCHAR *DeviceId,
    ULONG IdIndex
    );

NTSTATUS
PipQueryDeviceResources (
    PDEVICE_INFORMATION DeviceInfo,
    ULONG BusNumber,
    PCM_RESOURCE_LIST *CmResources,
    PULONG Length
    );

NTSTATUS
PipQueryDeviceResourceRequirements (
    PDEVICE_INFORMATION DeviceInfo,
    ULONG BusNumber,
    ULONG Slot,
    PCM_RESOURCE_LIST BootResources,
    USHORT IrqFlags,
    PIO_RESOURCE_REQUIREMENTS_LIST *IoResources,
    ULONG *Size
    );

NTSTATUS
PipSetDeviceResources (
    PDEVICE_INFORMATION DeviceInfo,
    PCM_RESOURCE_LIST CmResources
    );

PVOID
PipGetMappedAddress(
    IN  INTERFACE_TYPE BusType,
    IN  ULONG BusNumber,
    IN  PHYSICAL_ADDRESS IoAddress,
    IN  ULONG NumberOfBytes,
    IN  ULONG AddressSpace,
    OUT PBOOLEAN MappedAddress
    );

NTSTATUS
PipMapReadDataPort (
    IN PPI_BUS_EXTENSION BusExtension,
    IN PHYSICAL_ADDRESS BaseAddressLow,
    IN ULONG PortLength
    );

NTSTATUS
PipMapAddressAndCmdPort (
    IN PPI_BUS_EXTENSION BusExtension
    );

VOID
PipDecompressEisaId(
    IN ULONG CompressedId,
    IN PUCHAR EisaId
    );

VOID
PipCheckBus (
    IN PPI_BUS_EXTENSION BusExtension
    );

NTSTATUS
PipReadCardResourceData (
    OUT PULONG NumberLogicalDevices,
    IN PVOID *ResourceData,
    OUT PULONG ResourceDataLength
    );

NTSTATUS
PipReadDeviceResources (
    IN ULONG BusNumber,
    IN PUCHAR BiosRequirements,
    IN ULONG CardFlags,
    OUT PCM_RESOURCE_LIST *ResourceData,
    OUT PULONG Length,
    OUT PUSHORT irqFlags
    );

USHORT
PipIrqLevelRequirementsFromDeviceData(
    IN PUCHAR BiosRequirements, ULONG Length);

NTSTATUS
PipWriteDeviceResources (
    IN PUCHAR BiosRequirements,
    IN PCM_RESOURCE_LIST CmResources
    );

VOID
PipFixBootConfigIrqs(
    IN PCM_RESOURCE_LIST BootResources,
    IN USHORT irqFlags
    );

VOID
PipActivateDevice (
    );
VOID
PipDeactivateDevice (
    );

VOID
PipSelectLogicalDevice (
    IN USHORT Csn,
    IN USHORT LogicalDeviceNumber,
    IN ULONG  Control
    );

VOID
PipLFSRInitiation (
    VOID
    );

VOID
PipIsolateCards (
    OUT PULONG NumberCSNs
    );

VOID
PipWakeAndSelectDevice(
    IN UCHAR Csn,
    IN UCHAR Device
    );

ULONG
PipFindNextLogicalDeviceTag (
    IN OUT PUCHAR *CardData,
    IN OUT LONG *Limit
    );

NTSTATUS
PipGetCompatibleDeviceId (
    PUCHAR DeviceData,
    ULONG IdIndex,
    PWCHAR *Buffer
    );
VOID
PipLogError(
    IN NTSTATUS ErrorCode,
    IN ULONG UniqueErrorValue,
    IN NTSTATUS FinalStatus,
    IN PULONG DumpData,
    IN ULONG DumpCount,
    IN USHORT StringLength,
    IN PWCHAR String
    );

VOID
PipCleanupAcquiredResources (
    IN PPI_BUS_EXTENSION BusExtension
    );

PCARD_INFORMATION
PipIsCardEnumeratedAlready(
    IN PPI_BUS_EXTENSION BusExtension,
    IN PUCHAR CardData,
    IN ULONG DataLength
    );

NTSTATUS
PipQueryDeviceRelations (
    IN PPI_BUS_EXTENSION BusExtension,
    PDEVICE_RELATIONS *DeviceRelations,
    BOOLEAN Removal
    );

PDEVICE_INFORMATION
PipReferenceDeviceInformation (
    PDEVICE_OBJECT DeviceObject, BOOLEAN ConfigHardware
    );

VOID
PipDereferenceDeviceInformation (
    PDEVICE_INFORMATION DeviceInformation, BOOLEAN ConfigHardware
    );

VOID
PipLockDeviceDatabase (
    VOID
    );

VOID
PipUnlockDeviceDatabase (
    VOID
    );

NTSTATUS
PipOpenRegistryKey(
    OUT PHANDLE Handle,
    IN HANDLE BaseHandle OPTIONAL,
    IN PUNICODE_STRING KeyName,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN Create
    );

NTSTATUS
PipGetRegistryValue(
    IN HANDLE KeyHandle,
    IN PWSTR  ValueName,
    OUT PKEY_VALUE_FULL_INFORMATION *Information
    );

NTSTATUS
PipOpenCurrentHwProfileDeviceInstanceKey(
    OUT PHANDLE Handle,
    IN  PUNICODE_STRING DeviceInstanceName,
    IN  ACCESS_MASK DesiredAccess
    );

NTSTATUS
PipGetDeviceInstanceCsConfigFlags(
    IN PUNICODE_STRING DeviceInstance,
    OUT PULONG CsConfigFlags
    );

NTSTATUS
PiQueryInterface (
    IN PPI_BUS_EXTENSION BusExtension,
    IN OUT PIRP Irp
    );

ULONG
PipDetermineResourceListSize(
    IN PCM_RESOURCE_LIST ResourceList
    );

VOID
PipDeleteDevice (
    PDEVICE_OBJECT DeviceObject
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName
    );

NTSTATUS
PipReleaseInterfaces(
                    IN PPI_BUS_EXTENSION PipBusExtension
                    );

NTSTATUS
PipRebuildInterfaces(
                    IN PPI_BUS_EXTENSION PipBusExtension
                    );

VOID
PipResetGlobals (
                 VOID
                 );

BOOLEAN
PipMinimalCheckBus (
    IN PPI_BUS_EXTENSION BusExtension
    );

NTSTATUS
PipStartAndSelectRdp(
    PDEVICE_INFORMATION DeviceInfo,
    PPI_BUS_EXTENSION BusExtension,
    PDEVICE_OBJECT  DeviceObject,
    PCM_RESOURCE_LIST StartResources
    );

NTSTATUS
PipStartReadDataPort(
    PDEVICE_INFORMATION DeviceInfo,
    PPI_BUS_EXTENSION BusExtension,
    PDEVICE_OBJECT  DeviceObject,
    PCM_RESOURCE_LIST StartResources
    );

NTSTATUS
PipCreateReadDataPort(
    PPI_BUS_EXTENSION BusExtension
    );

BOOLEAN
PiNeedDeferISABridge(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject
    );

void
PipReleaseDeviceResources (
    PDEVICE_INFORMATION deviceInfo
    );

VOID
PipReportStateChange(
    PNPISA_STATE State
    );

//
// System defined levels
//
#define DEBUG_ERROR    DPFLTR_ERROR_LEVEL
#define DEBUG_WARN     DPFLTR_WARNING_LEVEL
#define DEBUG_TRACE    DPFLTR_TRACE_LEVEL
#define DEBUG_INFO     DPFLTR_INFO_LEVEL

//
// Driver defined levels.
// Or in DPFLTR_MASK so that these are interpreted
// as mask values rather than levels.
//
#define DEBUG_PNP      (0x00000010 | DPFLTR_MASK)
#define DEBUG_POWER    (0x00000020 | DPFLTR_MASK)
#define DEBUG_STATE    (0x00000040 | DPFLTR_MASK)
#define DEBUG_ISOLATE  (0x00000080 | DPFLTR_MASK)
#define DEBUG_RDP      (0x00000100 | DPFLTR_MASK)
#define DEBUG_CARDRES  (0x00000200 | DPFLTR_MASK)
#define DEBUG_UNUSED   (0x00000400 | DPFLTR_MASK)
#define DEBUG_UNUSED2  (0x00000800 | DPFLTR_MASK)
#define DEBUG_IRQ      (0x00001000 | DPFLTR_MASK)
#define DEBUG_RESOURCE (0x00002000 | DPFLTR_MASK)

//
// Set this bit to break in after printing a
// debug message
//
#define DEBUG_BREAK    0x08000000

VOID
PipDebugPrint (
    ULONG       Level,
    PCCHAR      DebugMessage,
    ...
    );

VOID
PipDebugPrintContinue (
    ULONG       Level,
    PCCHAR      DebugMessage,
    ...
    );

VOID
PipDumpIoResourceDescriptor (
    IN PUCHAR Indent,
    IN PIO_RESOURCE_DESCRIPTOR Desc
    );

VOID
PipDumpIoResourceList (
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoList
    );

VOID
PipDumpCmResourceDescriptor (
    IN PUCHAR Indent,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Desc
    );

VOID
PipDumpCmResourceList (
    IN PCM_RESOURCE_LIST CmList
    );

#if DBG
#define DebugPrint(arg) PipDebugPrint arg
#define DebugPrintContinue(arg) PipDebugPrintContinue arg
#else
#define DebugPrint(arg)
#define DebugPrintContinue(arg)
#endif

VOID
PipUnlockDeviceDatabase (
    VOID
    );
VOID
PipLockDeviceDatabase (
    VOID
    );

ULONG
PipGetCardFlags(
    IN PCARD_INFORMATION CardInfo
    );

NTSTATUS
PipSaveBootIrqFlags(
    IN PDEVICE_INFORMATION DeviceInfo,
    IN USHORT IrqFlags
    );

NTSTATUS
PipGetBootIrqFlags(
    IN PDEVICE_INFORMATION DeviceInfo,
    OUT PUSHORT IrqFlags
    );

NTSTATUS
PipSaveBootResources(
    IN PDEVICE_INFORMATION DeviceInfo
    );

NTSTATUS
PipGetSavedBootResources(
    IN PDEVICE_INFORMATION DeviceInfo,
    OUT PCM_RESOURCE_LIST *BootResources
    );

NTSTATUS
PipTrimResourceRequirements (
    IN PIO_RESOURCE_REQUIREMENTS_LIST *IoList,
    IN USHORT IrqFlags,
    IN PCM_RESOURCE_LIST BootResources
    );

//
// Name of the volative key under the DeviceParameters key where data that needs
// to be persistent accross removes, but NOT reboots is stored
//
#define BIOS_CONFIG_KEY_NAME L"BiosConfig"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\isapnp\convert.c ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    xlate.c

Abstract:

    This file contains routines to translate resources between PnP ISA/BIOS
    format and Windows NT formats.

Author:

    Shie-Lin Tzong (shielint) 12-Apr-1995

Environment:

    Kernel mode only.

Revision History:

--*/

#include "busp.h"
#include "pnpisa.h"
#include "cfg.h"

#if ISOLATE_CARDS
#include "..\..\ntos\io\pnpmgr\convert.c"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\isapnp\data.c ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    pbdata.c

Abstract:

    Declares various data which is specific to PNP ISA bus extender architecture and
    is independent of BIOS.

Author:

    Shie-Lin Tzong (shielint) July-26-95

Environment:

    Kernel mode only.

Revision History:

--*/


#include "busp.h"

// global variable for configuring level of debug spew.

ULONG PipDebugMask = DEBUG_WARN | DEBUG_ERROR;

//
// global varialbe to remember the driver object created
// by IO mgr.
//

PDRIVER_OBJECT PipDriverObject;

//
// regPNPISADeviceName
//

WCHAR rgzPNPISADeviceName[] = DEVSTR_PNPISA_DEVICE_NAME;

//
// Pointers to bus extension data.
//

PBUS_EXTENSION_LIST PipBusExtension;

//
// PipRegistryPath stores the registry path that we got upon driver entry.
// This is used later when we're attempting to allocate resources.
//

UNICODE_STRING PipRegistryPath;

//
// Variables to protect critical region.
//

KEVENT PipDeviceTreeLock;
KEVENT IsaBusNumberLock;

//
// Bus Number and DMA control counters
//
ULONG BusNumberBuffer [256/sizeof (ULONG)];
RTL_BITMAP BusNumBMHeader;
PRTL_BITMAP BusNumBM;
ULONG ActiveIsaCount;
USHORT PipFirstInit;

#if ISOLATE_CARDS

// current bus "state"

PNPISA_STATE PipState = PiSWaitForKey;

//
// Read_data_port address
// (This is mainly for convinience.  It duplicates the
//  ReadDataPort field in BUS extension structure.)
//

ULONG  ADDRESS_PORT=0x0279;
ULONG  COMMAND_PORT=0x0a79;

PUCHAR PipReadDataPort;
PUCHAR PipCommandPort;
PUCHAR PipAddressPort;

//
// The global pointer to the Read Data Port DevNode
//
PDEVICE_INFORMATION PipRDPNode;


//
// ActiveIsaCount data port range selection array
//
//this conflicts with Compaq 2ndary IDE     {0x374, 0x377, 4},
READ_DATA_PORT_RANGE
PipReadDataPortRanges[READ_DATA_PORT_RANGE_CHOICES] =
    {{0x274, 0x277, 4},
     {0x3E4, 0x3E7, 4},
     {0x204, 0x207, 4},
     {0x2E4, 0x2E7, 4},
     {0x354, 0x357, 4},
     {0x2F4, 0x2F7, 4}};

BOOLEAN PipIsolationDisabled;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\isapnp\misc.c ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    misc.c

Abstract:

    This file contains pnp isa bus extender support routines.

Author:

    Shie-Lin Tzong (shielint) 27-July-1995

Environment:

    Kernel mode only.

Revision History:

--*/


#include "busp.h"
#include "pnpisa.h"

#ifdef ALLOC_PRAGMA
//#pragma alloc_text(PAGE, PipLockDeviceDatabase)
//#pragma alloc_text(PAGE, PipUnlockDeviceDatabase)
#pragma alloc_text(PAGE, PipQueryDeviceRelations)
//#pragma alloc_text(PAGE, PipIsCardEnumeratedAlready)
#pragma alloc_text(PAGE, PipCleanupAcquiredResources)
#pragma alloc_text(PAGE, PipMapReadDataPort)
#pragma alloc_text(PAGE, PipGetMappedAddress)
#pragma alloc_text(PAGE, PipDecompressEisaId)
#pragma alloc_text(PAGE, PipLogError)
#pragma alloc_text(PAGE, PipOpenRegistryKey)
#pragma alloc_text(PAGE, PipGetRegistryValue)
#pragma alloc_text(PAGE, PipOpenCurrentHwProfileDeviceInstanceKey)
#pragma alloc_text(PAGE, PipGetDeviceInstanceCsConfigFlags)
#pragma alloc_text(PAGE, PipDetermineResourceListSize)
#pragma alloc_text(PAGE, PipResetGlobals)
#pragma alloc_text(PAGE, PipMapAddressAndCmdPort)
#pragma alloc_text(PAGE, PiNeedDeferISABridge)
#pragma alloc_text(PAGE, PipReleaseDeviceResources)
#if DBG
//#pragma alloc_text(PAGE, PipDebugPrint)
#pragma alloc_text(PAGE, PipDumpIoResourceDescriptor)
#pragma alloc_text(PAGE, PipDumpIoResourceList)
#pragma alloc_text(PAGE, PipDumpCmResourceDescriptor)
#pragma alloc_text(PAGE, PipDumpCmResourceList)
#endif
#endif

#define IRQFLAGS_VALUE_NAME L"IrqFlags"
#define BOOTRESOURCES_VALUE_NAME L"BootRes"

#if ISOLATE_CARDS

UCHAR CurrentCsn = 0;
UCHAR CurrentDev = 255;

VOID
PipWaitForKey(VOID)
{
    ASSERT((PipState == PiSConfig) || (PipState == PiSIsolation) || (PipState == PiSSleep));
    PipWriteAddress(CONFIG_CONTROL_PORT);
    PipWriteData(CONTROL_WAIT_FOR_KEY);
    PipReportStateChange(PiSWaitForKey);
    CurrentCsn = 0;
    CurrentDev = 255;
}

VOID
PipConfig(
    IN UCHAR Csn
)
{
    ASSERT(Csn);
    ASSERT((PipState == PiSConfig) || (PipState == PiSIsolation) || (PipState == PiSSleep));
    PipWriteAddress(WAKE_CSN_PORT);
    PipWriteData(Csn);
    DebugPrint((DEBUG_STATE, "Wake CSN %u\n", (ULONG) Csn));
    CurrentCsn = Csn;
    CurrentDev = 255;
    PipReportStateChange(PiSConfig);
}

VOID
PipIsolation(
    VOID
)
{
    ASSERT((PipState == PiSConfig) || (PipState == PiSIsolation) || (PipState == PiSSleep));
    PipWriteAddress(WAKE_CSN_PORT);
    PipWriteData(0);
    CurrentCsn = 0;
    CurrentDev = 255;
    DebugPrint((DEBUG_STATE, "Isolate cards w/o CSN\n"));
    PipReportStateChange(PiSIsolation);
}
VOID
PipSleep(
    VOID
)
{
    ASSERT((PipState == PiSConfig) || PipState == PiSIsolation);
    PipWriteAddress(WAKE_CSN_PORT);
    PipWriteData(0);
    CurrentCsn = 0;
    CurrentDev = 255;
    DebugPrint((DEBUG_STATE, "Putting all cards to sleep (we think)\n"));
    PipReportStateChange(PiSSleep);
}

VOID
PipActivateDevice (
    )
{
    UCHAR tmp;

    PipWriteAddress(IO_RANGE_CHECK_PORT);
    tmp = PipReadData();
    tmp &= ~2;
    PipWriteAddress(IO_RANGE_CHECK_PORT);
    PipWriteData(tmp);
    PipWriteAddress(ACTIVATE_PORT);
    PipWriteData(1);

    DebugPrint((DEBUG_STATE, "Activated card CSN %d/LDN %d\n",
                (ULONG) CurrentCsn,
                (ULONG) CurrentDev));
}
VOID
PipDeactivateDevice (
    )
{
    PipWriteAddress(ACTIVATE_PORT);
    PipWriteData(0);

    DebugPrint((DEBUG_STATE, "Deactivated card CSN %d/LDN %d\n",
                (ULONG) CurrentCsn,
                (ULONG) CurrentDev));
}

VOID
PipSelectDevice(
    IN UCHAR Device
    )
{
    ASSERT(PipState == PiSConfig);
    PipWriteAddress(LOGICAL_DEVICE_PORT);
    PipWriteData(Device);

    CurrentDev = Device;
    DebugPrint((DEBUG_STATE, "Selected CSN %d/LDN %d\n",
                (ULONG) CurrentCsn,
                (ULONG) Device));
}

VOID
PipWakeAndSelectDevice(
    IN UCHAR Csn,
    IN UCHAR Device
    )
{
    PipLFSRInitiation();
    PipConfig(Csn);
    PipSelectDevice(Device);
}

PDEVICE_INFORMATION
PipReferenceDeviceInformation (
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN ConfigHardware
    )

/*++

Routine Description:

    This function locks a device node so it won't go away.

    Note, this function does not lock the whole device node tree.

Arguments:

    DeviceNode - Supplies a pointer to the device information node

Return Value:

    None.

--*/

{
    PDEVICE_INFORMATION deviceInfo;

    deviceInfo = (PDEVICE_INFORMATION)DeviceObject->DeviceExtension;
    if (deviceInfo && !(deviceInfo->Flags & DF_DELETED)) {

        if ((deviceInfo->Flags & DF_NOT_FUNCTIONING) && ConfigHardware) {
            PipDereferenceDeviceInformation(NULL, FALSE);
            return NULL;
        }

        if (!(deviceInfo->Flags & DF_READ_DATA_PORT) && ConfigHardware) {
            PipWakeAndSelectDevice(
                (UCHAR)deviceInfo->CardInformation->CardSelectNumber,
                (UCHAR)deviceInfo->LogicalDeviceNumber);
        }

        return deviceInfo;
    } else {
        PipDereferenceDeviceInformation(NULL, FALSE);
        return NULL;
    }
}

VOID
PipDereferenceDeviceInformation(
    IN PDEVICE_INFORMATION DeviceInformation, BOOLEAN ConfigedHardware
    )

/*++

Routine Description:

    This function releases the enumeration lock of the specified device node.

Arguments:

    DeviceNode - Supplies a pointer to the device node whose lock is to be released.

Return Value:

    None.

--*/

{
    //
    // Synchronize the dec and set event operations with IopAcquireEnumerationLock.
    //

    if (DeviceInformation) {


        if (!(DeviceInformation->Flags & DF_READ_DATA_PORT) && ConfigedHardware) {
            if (PipState != PiSWaitForKey) {
                PipWaitForKey();
            }
        }
    }
}

VOID
PipLockDeviceDatabase(
    VOID
    )

/*++

Routine Description:

    This function locks the whole device node tree.  Currently, eject operation
    needs to lock the whole device node tree.

Arguments:

    None.

Return Value:

    None.

--*/

{
    KeWaitForSingleObject( &PipDeviceTreeLock,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL );

}

VOID
PipUnlockDeviceDatabase (
    VOID
    )

/*++

Routine Description:

    This function releases the lock of the whole device node tree.

Arguments:

    None.

Return Value:

    None.

--*/

{
    KeSetEvent( &PipDeviceTreeLock,
                0,
                FALSE );
}

VOID
PipDeleteDevice (
    PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine

Parameters:

    P1 -

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    PDEVICE_INFORMATION deviceInfo, devicex, devicep;
    PCARD_INFORMATION cardInfo, cardx, cardp;
    PSINGLE_LIST_ENTRY deviceLink, cardLink;
    NTSTATUS status = STATUS_SUCCESS;
    PPI_BUS_EXTENSION busExtension;

    deviceInfo = (PDEVICE_INFORMATION)DeviceObject->DeviceExtension;

    deviceInfo->Flags |= DF_DELETED;

    //
    // Free the pool
    //

    if (deviceInfo->ResourceRequirements) {
        ExFreePool(deviceInfo->ResourceRequirements);
    }

    if (deviceInfo->BootResources) {
        ExFreePool(deviceInfo->BootResources);
    }

    if (deviceInfo->AllocatedResources) {
        ExFreePool(deviceInfo->AllocatedResources);
    }

    if (deviceInfo->LogConfHandle) {
        ZwClose(deviceInfo->LogConfHandle);
        deviceInfo->LogConfHandle = NULL;
    }

    busExtension = deviceInfo->ParentDeviceExtension;
    cardInfo = deviceInfo->CardInformation;

    PipLockDeviceDatabase();

    //
    // Remove the device from device list.
    //

    deviceLink = busExtension->DeviceList.Next;
    devicep = NULL;
    while (deviceLink) {
        devicex = CONTAINING_RECORD (deviceLink, DEVICE_INFORMATION, DeviceList);
        if (devicex == deviceInfo) {
             break;
        }
        devicep = devicex;
        deviceLink = devicex->DeviceList.Next;
    }
    ASSERT(devicex == deviceInfo);
    if (devicep == NULL) {
        busExtension->DeviceList.Next = deviceInfo->DeviceList.Next;
    } else {
        devicep->DeviceList.Next = deviceInfo->DeviceList.Next;
    }

    //
    // Remove the device from logical device list of the card
    //

    deviceLink = cardInfo->LogicalDeviceList.Next;
    devicep = NULL;
    while (deviceLink) {
        devicex = CONTAINING_RECORD (deviceLink, DEVICE_INFORMATION, LogicalDeviceList);
        if (devicex == deviceInfo) {
             break;
        }
        devicep = devicex;
        deviceLink = devicex->LogicalDeviceList.Next;
    }
    ASSERT(devicex == deviceInfo);
    if (devicep == NULL) {
        cardInfo->LogicalDeviceList.Next = deviceInfo->LogicalDeviceList.Next;
    } else {
        devicep->LogicalDeviceList.Next = deviceInfo->LogicalDeviceList.Next;
    }

    cardInfo->NumberLogicalDevices--;

    //
    // All the devices are gone.  That means the card is removed.
    // Next remove the isapnp card structure.
    //

    if (cardInfo->NumberLogicalDevices == 0) {
        ASSERT(cardInfo->LogicalDeviceList.Next == NULL);
        cardLink = busExtension->CardList.Next;
        cardp = NULL;
        while (cardLink) {
            cardx = CONTAINING_RECORD (cardLink, CARD_INFORMATION, CardList);
            if (cardx == cardInfo) {
                 break;
            }
            cardp = cardx;
            cardLink = cardx->CardList.Next;
        }
        ASSERT(cardx == cardInfo);
        if (cardp == NULL) {
            busExtension->CardList.Next = cardInfo->CardList.Next;
        } else {
            cardp->CardList.Next = cardInfo->CardList.Next;
        }
    }

    PipUnlockDeviceDatabase();

    //
    // Remove the card information structure after releasing spin lock.
    //

    if (cardInfo->NumberLogicalDevices == 0) {
        if (cardInfo->CardData) {
            ExFreePool(cardInfo->CardData);
        }
        ExFreePool(cardInfo);
    }

    IoDeleteDevice(DeviceObject);
}

NTSTATUS
PipQueryDeviceRelations (
    PPI_BUS_EXTENSION BusExtension,
    PDEVICE_RELATIONS *DeviceRelations,
    BOOLEAN Removal
    )

/*++

Routine Description:

    This routine

Parameters:

    P1 -

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    PDEVICE_INFORMATION deviceInfo;
    PSINGLE_LIST_ENTRY deviceLink;
    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_OBJECT *devicePtr;
    ULONG count = 0;
    PDEVICE_RELATIONS deviceRelations;

    PAGED_CODE();

    *DeviceRelations = NULL;

    //
    // Go through the card link list to match the card data
    //

    deviceLink = BusExtension->DeviceList.Next;
    while (deviceLink) {
        deviceInfo = CONTAINING_RECORD (deviceLink, DEVICE_INFORMATION, DeviceList);
        //
        // if it's the RDP ignore it for removal relations
        //
        if ((deviceInfo->Flags & DF_ENUMERATED) &&
            (!(deviceInfo->Flags & DF_READ_DATA_PORT) || !Removal)) {
             count++;
        } else {

            DebugPrint((DEBUG_PNP, "PipQueryDeviceRelations skipping a node, Flags: %x\n",deviceInfo->Flags));
        }
        deviceLink = deviceInfo->DeviceList.Next;
    }
    if (count != 0) {
        deviceRelations = (PDEVICE_RELATIONS) ExAllocatePool(
                             PagedPool,
                             sizeof(DEVICE_RELATIONS) + (count - 1) * sizeof(PDEVICE_OBJECT));
        if (deviceRelations) {
            deviceRelations->Count = count;
            deviceLink = BusExtension->DeviceList.Next;
            devicePtr = deviceRelations->Objects;
            while (deviceLink) {
                deviceInfo = CONTAINING_RECORD (deviceLink, DEVICE_INFORMATION, DeviceList);

                if ((deviceInfo->Flags & DF_ENUMERATED) &&
                    (!(deviceInfo->Flags & DF_READ_DATA_PORT) || !(Removal))) {
                     ObReferenceObject(deviceInfo->PhysicalDeviceObject);
                     *devicePtr = deviceInfo->PhysicalDeviceObject;
                     devicePtr++;
                }
                deviceLink = deviceInfo->DeviceList.Next;
            }
            *DeviceRelations = deviceRelations;
        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    return status;
}

PCARD_INFORMATION
PipIsCardEnumeratedAlready(
    IN PPI_BUS_EXTENSION BusExtension,
    IN PUCHAR CardData,
    IN ULONG DataLength
    )

/*++

Routine Description:

    This routine finds the card information structure which contains the same CardData.

Parameters:

    CardData - Supplies a pointer to the CardData

    DataLength - The length of the CardData

Return Value:

    A pointer to the CARD_INFORMATION structure if found.

--*/

{
    PCARD_INFORMATION cardInfo;
    PSINGLE_LIST_ENTRY cardLink;
    PSERIAL_IDENTIFIER serialId1, serialId2 = (PSERIAL_IDENTIFIER)CardData;

    //
    // Go through the card link list to match the card data
    //

    cardLink = BusExtension->CardList.Next;
    while (cardLink) {
        cardInfo = CONTAINING_RECORD (cardLink, CARD_INFORMATION, CardList);
        if (cardInfo->CardSelectNumber != 0) {   // if == 0, card is no longer present
            serialId1 = (PSERIAL_IDENTIFIER)cardInfo->CardData;
            ASSERT(serialId1 && serialId2);
            if (serialId1->VenderId == serialId2->VenderId &&
                serialId1->SerialNumber == serialId2->SerialNumber) {
                return cardInfo;
            }
        }
        cardLink = cardInfo->CardList.Next;         // Get the next addr before releasing pool
    }
    return NULL;
}

VOID
PipCleanupAcquiredResources (
    PPI_BUS_EXTENSION BusExtension
    )

/*++

Routine Description:

    This routine cleans up the resources assigned to the readdata, command and address
    ports.

Parameters:

    BusExtension - specifies the isapnp bus to be cleaned up.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    // Release address, command and read data port resources.
    //

    if (BusExtension->CommandPort && BusExtension->CmdPortMapped) {
        MmUnmapIoSpace(BusExtension->CommandPort, 1);
        BusExtension->CmdPortMapped = FALSE;
    }
    BusExtension->CommandPort = NULL;

    if (BusExtension->AddressPort && BusExtension->AddrPortMapped) {
        MmUnmapIoSpace(BusExtension->AddressPort, 1);
        BusExtension->AddrPortMapped = FALSE;
    }
    BusExtension->AddressPort = NULL;

    if (BusExtension->ReadDataPort) {
        PipReadDataPort = PipCommandPort = PipAddressPort = NULL;
    }
    if (BusExtension->ReadDataPort && BusExtension->DataPortMapped) {
        MmUnmapIoSpace(BusExtension->ReadDataPort - 3, 4);
        BusExtension->DataPortMapped = FALSE;
    }
    BusExtension->ReadDataPort = NULL;
}

NTSTATUS
PipMapReadDataPort (
    IN PPI_BUS_EXTENSION BusExtension,
    IN PHYSICAL_ADDRESS Start,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine maps specified port resources.

Arguments:

    BusExtension - Supplies a pointer to the pnp bus extension.

    BaseAddressLow,
    BaseAddressHi - Supplies the read data port base address range to be mapped.
Return Value:

    NTSTATUS code.

--*/

{
    NTSTATUS status;
    ULONG size;
    PHYSICAL_ADDRESS physicalAddress;
    ULONG dumpData[3];
    BOOLEAN conflictDetected;

    PAGED_CODE();

    if (BusExtension->ReadDataPort && BusExtension->DataPortMapped) {
        MmUnmapIoSpace(PipReadDataPort - 3, 4);
        PipReadDataPort = BusExtension->ReadDataPort = NULL;
        BusExtension->DataPortMapped = FALSE;
    }

    PipReadDataPort = PipGetMappedAddress(
                             Isa,             // InterfaceType
                             0,               // BusNumber,
                             Start,
                             Length,
                             CM_RESOURCE_PORT_IO,
                             &BusExtension->DataPortMapped
                             );

    DebugPrint((DEBUG_RDP, "PnpIsa:ReadDataPort is at %x\n",PipReadDataPort+3));
    if (PipReadDataPort) {
        PipReadDataPort += 3;
        BusExtension->ReadDataPort = PipReadDataPort;
        status = STATUS_SUCCESS;
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }
    return status;
}

PVOID
PipGetMappedAddress(
    IN  INTERFACE_TYPE BusType,
    IN  ULONG BusNumber,
    IN  PHYSICAL_ADDRESS IoAddress,
    IN  ULONG NumberOfBytes,
    IN  ULONG AddressSpace,
    OUT PBOOLEAN MappedAddress
    )

/*++

Routine Description:

    This routine maps an IO address to system address space.

Arguments:

    BusType - Supplies the type of bus - eisa, mca, isa...

    IoBusNumber - Supplies the bus number.

    IoAddress - Supplies the base device address to be mapped.

    NumberOfBytes - Supplies the number of bytes for which the address is
                    valid.

    AddressSpace - Supplies whether the address is in io space or memory.

    MappedAddress - Supplies whether the address was mapped. This only has
                      meaning if the address returned is non-null.

Return Value:

    The mapped address.

--*/

{
    PHYSICAL_ADDRESS cardAddress;
    PVOID address;

    PAGED_CODE();

    HalTranslateBusAddress(BusType, BusNumber, IoAddress, &AddressSpace,
                           &cardAddress);

    //
    // Map the device base address into the virtual address space
    // if the address is in memory space.
    //

    if (!AddressSpace) {

        address = MmMapIoSpace(cardAddress, NumberOfBytes, FALSE);
        *MappedAddress = (address ? TRUE : FALSE);

    } else {

        address = (PVOID) cardAddress.LowPart;
        *MappedAddress = FALSE;
    }

    return address;
}

VOID
PipDecompressEisaId(
    IN ULONG CompressedId,
    IN PUCHAR EisaId
    )

/*++

Routine Description:

    This routine decompressed compressed Eisa Id and returns the Id to caller
    specified character buffer.

Arguments:

    CompressedId - supplies the compressed Eisa Id.

    EisaId - supplies a 8-char buffer to receive the decompressed Eisa Id.

Return Value:

    None.

--*/

{
    USHORT c1, c2;
    LONG i;

    PAGED_CODE();

    CompressedId &= 0xffffff7f;           // remove the reserved bit (bit 7 of byte 0)
    c1 = c2 = (USHORT)CompressedId;
    c1 = (c1 & 0xff) << 8;
    c2 = (c2 & 0xff00) >> 8;
    c1 |= c2;
    for (i = 2; i >= 0; i--) {
        *(EisaId + i) = (UCHAR)(c1 & 0x1f) + 0x40;
        c1 >>= 5;
    }
    EisaId += 3;
    c1 = c2 = (USHORT)(CompressedId >> 16);
    c1 = (c1 & 0xff) << 8;
    c2 = (c2 & 0xff00) >> 8;
    c1 |= c2;
    sprintf (EisaId, "%04x", c1);
}

VOID
PipLogError(
    IN NTSTATUS ErrorCode,
    IN ULONG UniqueErrorValue,
    IN NTSTATUS FinalStatus,
    IN PULONG DumpData,
    IN ULONG DumpCount,
    IN USHORT StringLength,
    IN PWCHAR String
    )

/*++

Routine Description:

    This routine contains common code to write an error log entry.  It is
    called from other routines to avoid duplication of code.  This routine
    only allows caller to supply one insertion string to the error log.

Arguments:

    ErrorCode - The error code for the error log packet.

    UniqueErrorValue - The unique error value for the error log packet.

    FinalStatus - The final status of the operation for the error log packet.

    DumpData - Pointer to an array of dump data for the error log packet.

    DumpCount - The number of entries in the dump data array.

    StringLength - The length of insertion string *NOT* including the NULL terminater.

    String - The pointer to the insertion string

Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;
    ULONG i, size;
    PUCHAR p;

    size = sizeof(IO_ERROR_LOG_PACKET) + DumpCount * sizeof(ULONG) +
           StringLength + sizeof(UNICODE_NULL) - sizeof(ULONG);
    errorLogEntry = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry(
                                               PipDriverObject,
                                               (UCHAR) size
                                               );
    if (errorLogEntry != NULL) {

        RtlZeroMemory(errorLogEntry, size);

        errorLogEntry->ErrorCode = ErrorCode;
        errorLogEntry->DumpDataSize = (USHORT) (DumpCount * sizeof(ULONG));
        errorLogEntry->UniqueErrorValue = UniqueErrorValue;
        errorLogEntry->FinalStatus = FinalStatus;
        for (i = 0; i < DumpCount; i++)
            errorLogEntry->DumpData[i] = DumpData[i];
        if (String) {
            errorLogEntry->NumberOfStrings = 1;
            errorLogEntry->StringOffset = (USHORT)(sizeof(IO_ERROR_LOG_PACKET) +
                                          DumpCount * sizeof(ULONG) - sizeof(ULONG));
            p= (PUCHAR)errorLogEntry + errorLogEntry->StringOffset;
            RtlMoveMemory(p, String, StringLength);
        }
        IoWriteErrorLogEntry(errorLogEntry);
    }
}

NTSTATUS
PipOpenCurrentHwProfileDeviceInstanceKey(
    OUT PHANDLE Handle,
    IN  PUNICODE_STRING DeviceInstanceName,
    IN  ACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    This routine sets the csconfig flags for the specified device
    which is specified by the instance number under ServiceKeyName\Enum.

Arguments:

    ServiceKeyName - Supplies a pointer to the name of the subkey in the
        system service list (HKEY_LOCAL_MACHINE\CurrentControlSet\Services)
        that caused the driver to load. This is the RegistryPath parameter
        to the DriverEntry routine.

    Instance - Supplies the instance value under ServiceKeyName\Enum key

    DesiredAccess - Specifies the desired access that the caller needs to
        the key.

    Create - Determines if the key is to be created if it does not exist.

Return Value:

    status

--*/

{
    NTSTATUS status;
    UNICODE_STRING unicodeString;
    HANDLE profileEnumHandle;

    //
    // See if we can open the device instance key of current hardware profile
    //
    RtlInitUnicodeString (
        &unicodeString,
        L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\HARDWARE PROFILES\\CURRENT\\SYSTEM\\CURRENTCONTROLSET\\ENUM"
        );
    status = PipOpenRegistryKey(&profileEnumHandle,
                                NULL,
                                &unicodeString,
                                KEY_READ,
                                FALSE
                                );
    if (NT_SUCCESS(status)) {
        status = PipOpenRegistryKey(Handle,
                                    profileEnumHandle,
                                    DeviceInstanceName,
                                    DesiredAccess,
                                    FALSE
                                    );
        ZwClose(profileEnumHandle);
    }
    return status;
}

NTSTATUS
PipGetDeviceInstanceCsConfigFlags(
    IN PUNICODE_STRING DeviceInstance,
    OUT PULONG CsConfigFlags
    )

/*++

Routine Description:

    This routine retrieves the csconfig flags for the specified device
    which is specified by the instance number under ServiceKeyName\Enum.

Arguments:

    ServiceKeyName - Supplies a pointer to the name of the subkey in the
        system service list (HKEY_LOCAL_MACHINE\CurrentControlSet\Services)
        that caused the driver to load.

//    Instance - Supplies the instance value under ServiceKeyName\Enum key
//
    CsConfigFlags - Supplies a variable to receive the device's CsConfigFlags

Return Value:

    status

--*/

{
    NTSTATUS status;
    HANDLE handle;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;

    *CsConfigFlags = 0;

    status = PipOpenCurrentHwProfileDeviceInstanceKey(&handle,
                                                      DeviceInstance,
                                                      KEY_READ
                                                      );
    if(NT_SUCCESS(status)) {
        status = PipGetRegistryValue(handle,
                                     L"CsConfigFlags",
                                     &keyValueInformation
                                    );
        if(NT_SUCCESS(status)) {
            if((keyValueInformation->Type == REG_DWORD) &&
               (keyValueInformation->DataLength >= sizeof(ULONG))) {
                *CsConfigFlags = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
            }
            ExFreePool(keyValueInformation);
        }
        ZwClose(handle);
    }
    return status;
}

ULONG
PipDetermineResourceListSize(
    IN PCM_RESOURCE_LIST ResourceList
    )

/*++

Routine Description:

    This routine determines size of the passed in ResourceList
    structure.

Arguments:

    Configuration1 - Supplies a pointer to the resource list.

Return Value:

    size of the resource list structure.

--*/

{
    ULONG totalSize, listSize, descriptorSize, i, j;
    PCM_FULL_RESOURCE_DESCRIPTOR fullResourceDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptor;

    if (!ResourceList) {
        totalSize = 0;
    } else {
        totalSize = FIELD_OFFSET(CM_RESOURCE_LIST, List);
        fullResourceDesc = &ResourceList->List[0];
        for (i = 0; i < ResourceList->Count; i++) {
            listSize = FIELD_OFFSET(CM_FULL_RESOURCE_DESCRIPTOR,
                                    PartialResourceList) +
                       FIELD_OFFSET(CM_PARTIAL_RESOURCE_LIST,
                                    PartialDescriptors);
            partialDescriptor = &fullResourceDesc->PartialResourceList.PartialDescriptors[0];
            for (j = 0; j < fullResourceDesc->PartialResourceList.Count; j++) {
                descriptorSize = sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);
                if (partialDescriptor->Type == CmResourceTypeDeviceSpecific) {
                    descriptorSize += partialDescriptor->u.DeviceSpecificData.DataSize;
                }
                listSize += descriptorSize;
                partialDescriptor = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)
                                        ((PUCHAR)partialDescriptor + descriptorSize);
            }
            totalSize += listSize;
            fullResourceDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)
                                      ((PUCHAR)fullResourceDesc + listSize);
        }
    }
    return totalSize;
}
NTSTATUS
PipMapAddressAndCmdPort (
    IN PPI_BUS_EXTENSION BusExtension
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG dumpData[3];
    PHYSICAL_ADDRESS physicalAddress;
    //
    // Map port addr to memory addr if necessary.
    //

    if (PipAddressPort == NULL) {
        physicalAddress.LowPart = ADDRESS_PORT;
        physicalAddress.HighPart = 0;
        BusExtension->AddressPort =
        PipAddressPort = PipGetMappedAddress(
                             Isa,             // InterfaceType
                             0,               // BusNumber,
                             physicalAddress,
                             1,
                             CM_RESOURCE_PORT_IO,
                             &BusExtension->AddrPortMapped
                             );
        if (PipAddressPort == NULL) {
            dumpData[0] = ADDRESS_PORT;
            dumpData[1] = 1;
            dumpData[2] = CM_RESOURCE_PORT_IO;
            PipLogError(PNPISA_REGISTER_NOT_MAPPED,
                        PNPISA_ACQUIREPORTRESOURCE_1,
                        STATUS_INSUFFICIENT_RESOURCES,
                        dumpData,
                        3,
                        0,
                        NULL
                        );
            status = STATUS_UNSUCCESSFUL;
        }
    }
    if (PipCommandPort == NULL) {
        physicalAddress.LowPart = COMMAND_PORT;
        physicalAddress.HighPart = 0;
        BusExtension->CommandPort =
        PipCommandPort = PipGetMappedAddress(
                             Isa,             // InterfaceType
                             0,               // BusNumber,
                             physicalAddress,
                             1,
                             CM_RESOURCE_PORT_IO,
                             &BusExtension->CmdPortMapped
                             );
        if (PipCommandPort == NULL) {
            dumpData[0] = COMMAND_PORT;
            dumpData[1] = 1;
            dumpData[2] = CM_RESOURCE_PORT_IO;
            PipLogError(PNPISA_REGISTER_NOT_MAPPED,
                        PNPISA_ACQUIREPORTRESOURCE_2,
                        STATUS_INSUFFICIENT_RESOURCES,
                        dumpData,
                        3,
                        0,
                        NULL
                        );
            status = STATUS_UNSUCCESSFUL;
        }
    }


    return status;



}

VOID
PipReleaseDeviceResources (
    PDEVICE_INFORMATION DeviceInfo
    )
{
    UNICODE_STRING unicodeString;

    // This code is here rather than in the following conditional as
    // this best reflects how the code used to work before this code
    // was moved here from PDO stop/remove/surprise remove.
    if (DeviceInfo->LogConfHandle) {
        RtlInitUnicodeString(&unicodeString, L"AllocConfig");
        ZwDeleteValueKey (DeviceInfo->LogConfHandle, &unicodeString);
    }

    if (DeviceInfo->AllocatedResources)  {
       ExFreePool (DeviceInfo->AllocatedResources);
       DeviceInfo->AllocatedResources=NULL;

       if (DeviceInfo->LogConfHandle) {
           // As it stands now it we will close the logconf handle if
           // the device gets removed, surprise removed, or stopped.
           // When we get started, we'll try to re-create the
           // AllocConfig value but fail because of the lack of the
           // logconf handle.  This is not a change in behavior.
           //
           // The ZwDeleteKey() was definitely bogus though.

           ZwClose(DeviceInfo->LogConfHandle);
           DeviceInfo->LogConfHandle=NULL;
       }
    }

}

VOID
PipReportStateChange(
    PNPISA_STATE State
    )
{
    DebugPrint((DEBUG_STATE, "State transition: %d to %d\n",
               PipState, State));
    PipState = State;
}

ULONG
PipGetCardFlags(
    PCARD_INFORMATION CardInfo
    )

/*++

Description:

    Look in the registry for any flags for this CardId

Arguments:

    CardId    First 4 bytes of ISAPNP config space

Return Value:

    32 bit flags value from registry or 0 if not found.

--*/

{
    HANDLE         serviceHandle, paramHandle;
    NTSTATUS       status;
    ULONG          flags, returnedLength;
    UNICODE_STRING nameString;
    ANSI_STRING    ansiString;
    WCHAR          nameBuffer[9];
    UCHAR          eisaId[8];
    const PWCHAR   paramKey = L"Parameters";
    struct {
        KEY_VALUE_PARTIAL_INFORMATION   Header;

        //
        // The header contains enough space for one UCHAR, pad
        // it out by a ULONG, this will ensure the structure
        // is large enough for at lease the ULONG we need.
        //
        // N.B. Natural alignment will get it out far enough that
        // this ULONG is 4 bytes to many.
        //

        ULONG Pad;
    } returnedData;


    status = PipOpenRegistryKey(&serviceHandle,
                                NULL,
                                &PipRegistryPath,
                                KEY_READ,
                                FALSE);
    if (!NT_SUCCESS(status)) {
        return 0;
    }

    RtlInitUnicodeString(&nameString, paramKey);
    status = PipOpenRegistryKey(&paramHandle,
                                serviceHandle,
                                &nameString,
                                KEY_READ,
                                FALSE);
    if (!NT_SUCCESS(status)) {
        ZwClose(serviceHandle);
        return 0;
    }

    PipDecompressEisaId(
          ((PSERIAL_IDENTIFIER) (CardInfo->CardData))->VenderId,
          eisaId
          );
    RtlInitAnsiString(&ansiString, eisaId);
    status = RtlAnsiStringToUnicodeString(&nameString, &ansiString, TRUE);
    if (!NT_SUCCESS(status)) {
        ZwClose(paramHandle);
        ZwClose(serviceHandle);
        return 0;
    }

    //
    // Get the "value" of this value.
    //

    status = ZwQueryValueKey(
                 paramHandle,
                 &nameString,
                 KeyValuePartialInformation,
                 &returnedData,
                 sizeof(returnedData),
                 &returnedLength
                 );
    ZwClose(paramHandle);
    ZwClose(serviceHandle);

    if (NT_SUCCESS(status) && (returnedData.Header.Type == REG_DWORD) &&
        (returnedData.Header.DataLength == sizeof(ULONG))) {
        flags =  *(PULONG)(returnedData.Header.Data);
        DebugPrint((DEBUG_WARN, "Retrieving card flags for %ws: %x\n",
                    nameString.Buffer, flags));
    } else {
        flags = 0;
    }
    RtlFreeUnicodeString(&nameString);
    return flags;
}

NTSTATUS
PipBuildValueName(
    IN PDEVICE_INFORMATION DeviceInfo,
    IN PWSTR Suffix,
    OUT PWSTR *ValuePath)
/*++

Description:

    Builds a name describing the device via the device id and unique
    id.  Used to store per-device info in our parent's BiosConfig key

Arguments:

    DeviceInfo    Pointer to the PDO Extension for this device.

    Suffix        Suffix for value name

    IrqFlags      The edge or level setting of the boot config

Return Value:

    Status

--*/
{
    NTSTATUS status;
    PWSTR DeviceId = NULL, Instance = NULL;
    PWSTR Buffer, Current;
    ULONG length;

    status = PipQueryDeviceId(DeviceInfo, &DeviceId, 0);
    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    status = PipQueryDeviceUniqueId(DeviceInfo, &Instance);
    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    length = (wcslen(DeviceId) + wcslen(Instance) + wcslen(Suffix) + 1) * sizeof(WCHAR);

    Buffer = ExAllocatePool(PagedPool, length);
    if (Buffer == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    wcscpy(Buffer, DeviceId);
    wcscat(Buffer, Instance);
    wcscat(Buffer, Suffix);

    Current = Buffer;
    while (*Current != UNICODE_NULL) {
        if (*Current == L'\\') {
            *Current = L'_';
        }
        Current++;
    }

 cleanup:
    if (Instance) {
        ExFreePool(Instance);
    }

    if (DeviceId) {
        ExFreePool(DeviceId);
    }

    if (NT_SUCCESS(status)) {
        *ValuePath = Buffer;
    } else {
        *ValuePath = NULL;
    }
    return status;
}

NTSTATUS
PipSaveBootResources(
    IN PDEVICE_INFORMATION DeviceInfo
    )
/*++

Description:

    This saves the per-boot configuration of a device in the registry

Arguments:

    DeviceInfo    Pointer to the PDO Extension for this device.

Return Value:

    Status

--*/
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES attributes;
    UNICODE_STRING unicodeString;
    HANDLE deviceHandle, configHandle;
    PWSTR Buffer = NULL;
    ULONG Flags;

    PAGED_CODE();

    status = IoOpenDeviceRegistryKey(DeviceInfo->ParentDeviceExtension->PhysicalBusDevice,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     KEY_ALL_ACCESS,
                                     &deviceHandle
                                     );

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    RtlInitUnicodeString(&unicodeString, BIOS_CONFIG_KEY_NAME);

    InitializeObjectAttributes(&attributes,
                               &unicodeString,
                               OBJ_KERNEL_HANDLE,
                               deviceHandle,
                               NULL
                               );

    status = ZwCreateKey(&configHandle,
                         KEY_ALL_ACCESS,
                         &attributes,
                         0,
                         NULL,
                         REG_OPTION_VOLATILE,
                         NULL
                         );

    ZwClose(deviceHandle);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    status = PipBuildValueName(DeviceInfo, BOOTRESOURCES_VALUE_NAME,
                                  &Buffer);
    if (!NT_SUCCESS(status)) {
        Buffer = NULL;
        goto cleanup;
    }

    unicodeString.Buffer = Buffer;
    unicodeString.Length = (wcslen(unicodeString.Buffer) + 1) * sizeof(WCHAR);
    unicodeString.MaximumLength = unicodeString.Length;

    status = ZwSetValueKey(configHandle,
                           &unicodeString,
                           0,
                           REG_BINARY,
                           DeviceInfo->BootResources,
                           DeviceInfo->BootResourcesLength
                           );

    ZwClose(configHandle);

cleanup:
    if (Buffer != NULL) {
        ExFreePool(Buffer);
    }
    return status;
}

NTSTATUS
PipSaveBootIrqFlags(
    IN PDEVICE_INFORMATION DeviceInfo,
    IN USHORT IrqFlags
    )
/*++

Description:

    This saves the per-boot irq configuration of a device in the registry

Arguments:

    DeviceInfo    Pointer to the PDO Extension for this device.

    IrqFlags      The edge or level setting of the boot config

Return Value:

    Status

--*/
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES attributes;
    UNICODE_STRING unicodeString;
    HANDLE deviceHandle, configHandle;
    PWSTR Buffer = NULL;
    ULONG Flags;

    PAGED_CODE();

    Flags = (ULONG) IrqFlags;

    status = IoOpenDeviceRegistryKey(DeviceInfo->ParentDeviceExtension->PhysicalBusDevice,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     KEY_ALL_ACCESS,
                                     &deviceHandle
                                     );

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    RtlInitUnicodeString(&unicodeString, BIOS_CONFIG_KEY_NAME);

    InitializeObjectAttributes(&attributes,
                               &unicodeString,
                               OBJ_KERNEL_HANDLE,
                               deviceHandle,
                               NULL
                               );

    status = ZwCreateKey(&configHandle,
                         KEY_ALL_ACCESS,
                         &attributes,
                         0,
                         NULL,
                         REG_OPTION_VOLATILE,
                         NULL
                         );

    ZwClose(deviceHandle);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    status = PipBuildValueName(DeviceInfo, IRQFLAGS_VALUE_NAME, &Buffer);
    if (!NT_SUCCESS(status)) {
        Buffer = NULL;
        goto cleanup;
    }

    unicodeString.Buffer = Buffer;
    unicodeString.Length = (wcslen(unicodeString.Buffer) + 1) * sizeof(WCHAR);
    unicodeString.MaximumLength = unicodeString.Length;

    status = ZwSetValueKey(configHandle,
                           &unicodeString,
                           0,
                           REG_DWORD,
                           &Flags,
                           sizeof(ULONG)
                           );

    ZwClose(configHandle);

cleanup:
    if (Buffer != NULL) {
        ExFreePool(Buffer);
    }
    return status;
}

NTSTATUS
PipGetSavedBootResources(
    IN PDEVICE_INFORMATION DeviceInfo,
    OUT PCM_RESOURCE_LIST *BootResources
    )
/*

Description:

    This retrieves the saved boot resources

Arguments:

    DeviceInfo    Pointer to the PDO Extension for this device.

Return Value:

    Status

--*/
{
    UNICODE_STRING unicodeString;
    NTSTATUS status;
    OBJECT_ATTRIBUTES attributes;
    HANDLE deviceHandle, configHandle;
    PWSTR Buffer = NULL;
    PKEY_VALUE_PARTIAL_INFORMATION info = NULL;
    ULONG resultLength;

    PAGED_CODE();

    *BootResources = NULL;
    status = IoOpenDeviceRegistryKey(DeviceInfo->ParentDeviceExtension->PhysicalBusDevice,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     KEY_READ | KEY_WRITE,
                                     &deviceHandle
                                     );

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    RtlInitUnicodeString(&unicodeString, BIOS_CONFIG_KEY_NAME);

    InitializeObjectAttributes(&attributes,
                               &unicodeString,
                               OBJ_KERNEL_HANDLE,
                               deviceHandle,
                               NULL
                               );

    status = ZwOpenKey(&configHandle,
                         KEY_READ,
                         &attributes
                         );

    ZwClose(deviceHandle);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    status = PipBuildValueName(DeviceInfo, BOOTRESOURCES_VALUE_NAME, &Buffer);
    if (!NT_SUCCESS(status)) {
        ZwClose(configHandle);
        Buffer = NULL;
        goto cleanup;
    }

    unicodeString.Buffer = Buffer;
    unicodeString.Length = (wcslen(unicodeString.Buffer) + 1) * sizeof(WCHAR);
    unicodeString.MaximumLength = unicodeString.Length;

    status = ZwQueryValueKey(configHandle,
                             &unicodeString,
                             KeyValuePartialInformation,
                             NULL,
                             0,
                             &resultLength
                             );
    if (status != STATUS_BUFFER_OVERFLOW &&
        status != STATUS_BUFFER_TOO_SMALL) {
        ZwClose(configHandle);
        goto cleanup;
    }

    info = ExAllocatePool(PagedPool, resultLength);
    if (info == NULL) {
        ZwClose(configHandle);
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    status = ZwQueryValueKey(configHandle,
                             &unicodeString,
                             KeyValuePartialInformation,
                             info,
                             resultLength,
                             &resultLength
                             );
    ZwClose(configHandle);
    if (!NT_SUCCESS(status)) {
        DebugPrint((DEBUG_PNP, "Failed to get boot resources from registry for %ws\n", Buffer));
        goto cleanup;
    }

    *BootResources = ExAllocatePool(PagedPool, info->DataLength);
    if (BootResources) {
        RtlCopyMemory(*BootResources, info->Data, info->DataLength);
        DebugPrint((DEBUG_PNP, "Got boot resources from registry for %ws\n", Buffer));
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

 cleanup:

    if (info != NULL) {
        ExFreePool(info);
    }

    if (Buffer != NULL) {
        ExFreePool(Buffer);
    }

    return status;
}

NTSTATUS
PipGetBootIrqFlags(
    IN PDEVICE_INFORMATION DeviceInfo,
    OUT PUSHORT IrqFlags
    )
/*

Description:

    This retrieves the per-boot irq configuration of a device from the registry

Arguments:

    DeviceInfo    Pointer to the PDO Extension for this device.

    IrqFlags - flags we originally derived from the device's boot
               config on this boot

Return Value:

    Status

--*/
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES attributes;
    UNICODE_STRING unicodeString;
    HANDLE deviceHandle, configHandle;
    PWSTR Buffer = NULL;
    CHAR returnBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG) - 1];
    PKEY_VALUE_PARTIAL_INFORMATION info;
    ULONG resultLength;

    PAGED_CODE();

    status = IoOpenDeviceRegistryKey(DeviceInfo->ParentDeviceExtension->PhysicalBusDevice,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     KEY_READ | KEY_WRITE,
                                     &deviceHandle
                                     );

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    RtlInitUnicodeString(&unicodeString, BIOS_CONFIG_KEY_NAME);

    InitializeObjectAttributes(&attributes,
                               &unicodeString,
                               OBJ_KERNEL_HANDLE,
                               deviceHandle,
                               NULL
                               );

    status = ZwOpenKey(&configHandle,
                         KEY_READ,
                         &attributes
                         );

    ZwClose(deviceHandle);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    status = PipBuildValueName(DeviceInfo, IRQFLAGS_VALUE_NAME, &Buffer);
    if (!NT_SUCCESS(status)) {
        ZwClose(configHandle);
        Buffer = NULL;
        goto cleanup;
    }

    unicodeString.Buffer = Buffer;
    unicodeString.Length = (wcslen(unicodeString.Buffer) + 1) * sizeof(WCHAR);
    unicodeString.MaximumLength = unicodeString.Length;

    status = ZwQueryValueKey(configHandle,
                             &unicodeString,
                             KeyValuePartialInformation,
                             &returnBuffer,
                             sizeof(returnBuffer),
                             &resultLength
                             );

    ZwClose(configHandle);

    if (NT_SUCCESS(status)) {
        ULONG Temp;

        info = (PKEY_VALUE_PARTIAL_INFORMATION) returnBuffer;

        ASSERT(info->DataLength == sizeof(ULONG));

        Temp = *((PULONG) info->Data);
        ASSERT(!(Temp & 0xFFFF0000));
        *IrqFlags = (USHORT) Temp;

        DebugPrint((DEBUG_IRQ, "Got Irq Flags of %d for %ws\n",
                    (ULONG) *IrqFlags,
                    unicodeString.Buffer));
    } else {
        DebugPrint((DEBUG_IRQ, "Failed to get irq flags for %ws\n",
                    unicodeString.Buffer));
    }

 cleanup:

    if (Buffer != NULL) {
        ExFreePool(Buffer);
    }

    return status;
}

VOID
PipResetGlobals (
                   VOID
                   )
{
    PipReadDataPort = PipCommandPort = PipAddressPort = NULL;
    PipRDPNode = NULL;
}
#endif



NTSTATUS
PipOpenRegistryKey(
    OUT PHANDLE Handle,
    IN HANDLE BaseHandle OPTIONAL,
    IN PUNICODE_STRING KeyName,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN Create
    )

/*++

Routine Description:

    Opens or creates a VOLATILE registry key using the name passed in based
    at the BaseHandle node.

Arguments:

    Handle - Pointer to the handle which will contain the registry key that
        was opened.

    BaseHandle - Handle to the base path from which the key must be opened.

    KeyName - Name of the Key that must be opened/created.

    DesiredAccess - Specifies the desired access that the caller needs to
        the key.

    Create - Determines if the key is to be created if it does not exist.

Return Value:

   The function value is the final status of the operation.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    ULONG disposition;

    PAGED_CODE();

    //
    // Initialize the object for the key.
    //

    InitializeObjectAttributes( &objectAttributes,
                                KeyName,
                                OBJ_CASE_INSENSITIVE,
                                BaseHandle,
                                (PSECURITY_DESCRIPTOR) NULL );

    //
    // Create the key or open it, as appropriate based on the caller's
    // wishes.
    //

    if (Create) {
        return ZwCreateKey( Handle,
                            DesiredAccess,
                            &objectAttributes,
                            0,
                            (PUNICODE_STRING) NULL,
                            REG_OPTION_VOLATILE,
                            &disposition );
    } else {
        return ZwOpenKey( Handle,
                          DesiredAccess,
                          &objectAttributes );
    }
}

NTSTATUS
PipGetRegistryValue(
    IN HANDLE KeyHandle,
    IN PWSTR  ValueName,
    OUT PKEY_VALUE_FULL_INFORMATION *Information
    )

/*++

Routine Description:

    This routine is invoked to retrieve the data for a registry key's value.
    This is done by querying the value of the key with a zero-length buffer
    to determine the size of the value, and then allocating a buffer and
    actually querying the value into the buffer.

    It is the responsibility of the caller to free the buffer.

Arguments:

    KeyHandle - Supplies the key handle whose value is to be queried

    ValueName - Supplies the null-terminated Unicode name of the value.

    Information - Returns a pointer to the allocated data buffer.

Return Value:

    The function value is the final status of the query operation.

--*/

{
    UNICODE_STRING unicodeString;
    NTSTATUS status;
    PKEY_VALUE_FULL_INFORMATION infoBuffer;
    ULONG keyValueLength;

    PAGED_CODE();

    *Information = NULL;
    RtlInitUnicodeString( &unicodeString, ValueName );

    //
    // Figure out how big the data value is so that a buffer of the
    // appropriate size can be allocated.
    //

    status = ZwQueryValueKey( KeyHandle,
                              &unicodeString,
                              KeyValueFullInformation,
                              (PVOID) NULL,
                              0,
                              &keyValueLength );
    if (status != STATUS_BUFFER_OVERFLOW &&
        status != STATUS_BUFFER_TOO_SMALL) {
        return status;
    }

    //
    // Allocate a buffer large enough to contain the entire key data value.
    //

    infoBuffer = ExAllocatePool( NonPagedPool, keyValueLength );
    if (!infoBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Query the data for the key value.
    //

    status = ZwQueryValueKey( KeyHandle,
                              &unicodeString,
                              KeyValueFullInformation,
                              infoBuffer,
                              keyValueLength,
                              &keyValueLength );
    if (!NT_SUCCESS( status )) {
        ExFreePool( infoBuffer );
        return status;
    }

    //
    // Everything worked, so simply return the address of the allocated
    // buffer to the caller, who is now responsible for freeing it.
    //

    *Information = infoBuffer;
    return STATUS_SUCCESS;
}

BOOLEAN
PiNeedDeferISABridge(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject
    )
{
    BOOLEAN defer=FALSE;
    NTSTATUS status;
    HANDLE  hKey;
    ULONG value;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;



    status = IoOpenDeviceRegistryKey (DeviceObject,PLUGPLAY_REGKEY_DEVICE,KEY_READ,&hKey);

    if (NT_SUCCESS (status)) {
        status = PipGetRegistryValue (hKey,&BRIDGE_CHECK_KEY,&keyValueInformation);

        if (NT_SUCCESS (status)) {
            if((keyValueInformation->Type == REG_DWORD) &&
               (keyValueInformation->DataLength >= sizeof(ULONG))) {
                value = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
                //
                // Assume that if the value !0 then the bridge is 'broken'
                //
                defer = (value == 0)?FALSE:TRUE;
            }
        }
        ZwClose(hKey);

    }

    return defer;
}

#if DBG

VOID
PipDebugPrintContinue (
    ULONG       Level,
    PCCHAR      DebugMessage,
    ...
    )
/*++

Routine Description:

    This routine displays debugging message or causes a break.

Arguments:

    Level - supplies debugging levelcode.  DEBUG_MESSAGE - displays message only.
        DEBUG_BREAK - displays message and break.

    DebugMessage - supplies a pointer to the debugging message.

Return Value:

    None.

--*/

{
    va_list     ap;

    va_start(ap, DebugMessage);

    vDbgPrintEx(DPFLTR_ISAPNP_ID,
                Level,
                DebugMessage,
                ap
                );

    if (Level & DEBUG_BREAK) {
        DbgBreakPoint();
    }

    va_end(ap);
}


VOID
PipDebugPrint (
    ULONG       Level,
    PCCHAR      DebugMessage,
    ...
    )
/*++

Routine Description:

    This routine displays debugging message or causes a break.

Arguments:

    Level - supplies debugging levelcode.  DEBUG_MESSAGE - displays message only.
        DEBUG_BREAK - displays message and break.

    DebugMessage - supplies a pointer to the debugging message.

Return Value:

    None.

--*/

{
    va_list     ap;

    va_start(ap, DebugMessage);

    vDbgPrintExWithPrefix("ISAPNP: ",
                          DPFLTR_ISAPNP_ID,
                          Level,
                          DebugMessage,
                          ap
                          );

    if (Level & DEBUG_BREAK) {
        DbgBreakPoint();
    }

    va_end(ap);
}

#endif


VOID
PipDumpIoResourceDescriptor (
    IN PUCHAR Indent,
    IN PIO_RESOURCE_DESCRIPTOR Desc
    )
/*++

Routine Description:

    This routine processes a IO_RESOURCE_DESCRIPTOR and displays it.

Arguments:

    Indent - # char of indentation.

    Desc - supplies a pointer to the IO_RESOURCE_DESCRIPTOR to be displayed.

Return Value:

    None.

--*/
{
    UCHAR c = ' ';

    if (Desc->Option == IO_RESOURCE_ALTERNATIVE) {
        c = 'A';
    } else if (Desc->Option == IO_RESOURCE_PREFERRED) {
        c = 'P';
    }
    switch (Desc->Type) {
        case CmResourceTypePort:
            DebugPrint ((
                DEBUG_RESOURCE,
                "%sIO  %c Min: %x:%08x, Max: %x:%08x, Algn: %x, Len %x\n",
                Indent, c,
                Desc->u.Port.MinimumAddress.HighPart, Desc->u.Port.MinimumAddress.LowPart,
                Desc->u.Port.MaximumAddress.HighPart, Desc->u.Port.MaximumAddress.LowPart,
                Desc->u.Port.Alignment,
                Desc->u.Port.Length
                ));
            break;

        case CmResourceTypeMemory:
            DebugPrint ((
                DEBUG_RESOURCE,
                "%sMEM %c Min: %x:%08x, Max: %x:%08x, Algn: %x, Len %x\n",
                Indent, c,
                Desc->u.Memory.MinimumAddress.HighPart, Desc->u.Memory.MinimumAddress.LowPart,
                Desc->u.Memory.MaximumAddress.HighPart, Desc->u.Memory.MaximumAddress.LowPart,
                Desc->u.Memory.Alignment,
                Desc->u.Memory.Length
                ));
            break;

        case CmResourceTypeInterrupt:
            DebugPrint ((
                DEBUG_RESOURCE,
                "%sINT %c Min: %x, Max: %x\n",
                Indent, c,
                Desc->u.Interrupt.MinimumVector,
                Desc->u.Interrupt.MaximumVector
                ));
            break;

        case CmResourceTypeDma:
            DebugPrint ((
                DEBUG_RESOURCE,
                "%sDMA %c Min: %x, Max: %x\n",
                Indent, c,
                Desc->u.Dma.MinimumChannel,
                Desc->u.Dma.MaximumChannel
                ));
            break;
    }
}

VOID
PipDumpIoResourceList (
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoList
    )
/*++

Routine Description:

    This routine displays Io resource requirements list.

Arguments:

    IoList - supplies a pointer to the Io resource requirements list to be displayed.

Return Value:

    None.

--*/
{


    PIO_RESOURCE_LIST resList;
    PIO_RESOURCE_DESCRIPTOR resDesc;
    ULONG listCount, count, i, j;

    if (IoList == NULL) {
        return;
    }
    DebugPrint((DEBUG_RESOURCE,
                  "Pnp Bios IO Resource Requirements List for Slot %x -\n",
                  IoList->SlotNumber
                  ));
    DebugPrint((DEBUG_RESOURCE,
                  "  List Count = %x, Bus Number = %x\n",
                  IoList->AlternativeLists,
                  IoList->BusNumber
                  ));
    listCount = IoList->AlternativeLists;
    resList = &IoList->List[0];
    for (i = 0; i < listCount; i++) {
        DebugPrint((DEBUG_RESOURCE,
                      "  Version = %x, Revision = %x, Desc count = %x\n",
                      resList->Version, resList->Revision, resList->Count
                      ));
        resDesc = &resList->Descriptors[0];
        count = resList->Count;
        for (j = 0; j < count; j++) {
            PipDumpIoResourceDescriptor("    ", resDesc);
            resDesc++;
        }
        resList = (PIO_RESOURCE_LIST) resDesc;
    }
}

VOID
PipDumpCmResourceDescriptor (
    IN PUCHAR Indent,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Desc
    )
/*++

Routine Description:

    This routine processes a IO_RESOURCE_DESCRIPTOR and displays it.

Arguments:

    Indent - # char of indentation.

    Desc - supplies a pointer to the IO_RESOURCE_DESCRIPTOR to be displayed.

Return Value:

    None.

--*/
{
    switch (Desc->Type) {
        case CmResourceTypePort:
            DebugPrint ((
                DEBUG_RESOURCE,
                "%sIO  Start: %x:%08x, Length:  %x\n",
                Indent,
                Desc->u.Port.Start.HighPart, Desc->u.Port.Start.LowPart,
                Desc->u.Port.Length
                ));
            break;

        case CmResourceTypeMemory:
            DebugPrint ((
                DEBUG_RESOURCE,
                "%sMEM Start: %x:%08x, Length:  %x\n",
                Indent,
                Desc->u.Memory.Start.HighPart, Desc->u.Memory.Start.LowPart,
                Desc->u.Memory.Length
                ));
            break;

        case CmResourceTypeInterrupt:
            DebugPrint ((
                DEBUG_RESOURCE,
                "%sINT Level: %x, Vector: %x, Affinity: %x\n",
                Indent,
                Desc->u.Interrupt.Level,
                Desc->u.Interrupt.Vector,
                Desc->u.Interrupt.Affinity
                ));
            break;

        case CmResourceTypeDma:
            DebugPrint ((
                DEBUG_RESOURCE,
                "%sDMA Channel: %x, Port: %x\n",
                Indent,
                Desc->u.Dma.Channel,
                Desc->u.Dma.Port
                ));
            break;
    }
}

VOID
PipDumpCmResourceList (
    IN PCM_RESOURCE_LIST CmList
    )
/*++

Routine Description:

    This routine displays CM resource list.

Arguments:

    CmList - supplies a pointer to CM resource list

Return Value:

    None.

--*/
{
    PCM_FULL_RESOURCE_DESCRIPTOR fullDesc;
    PCM_PARTIAL_RESOURCE_LIST partialDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR desc;
    ULONG count, i;

    if (CmList) {
        fullDesc = &CmList->List[0];
        DebugPrint((DEBUG_RESOURCE,
                      "Pnp Bios Cm Resource List -\n"
                      ));
        DebugPrint((DEBUG_RESOURCE,
                      "  List Count = %x, Bus Number = %x\n",
                      CmList->Count, fullDesc->BusNumber
                      ));
        partialDesc = &fullDesc->PartialResourceList;
        DebugPrint((DEBUG_RESOURCE,
                      "  Version = %x, Revision = %x, Desc count = %x\n",
                      partialDesc->Version, partialDesc->Revision, partialDesc->Count
                      ));
        count = partialDesc->Count;
        desc = &partialDesc->PartialDescriptors[0];
        for (i = 0; i < count; i++) {
            PipDumpCmResourceDescriptor("    ", desc);
            desc++;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\isapnp\dispatch.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

    This file contains the dispatch logic for ISAPNP

Author:

    Shie-Lin Tzong (shielint)

Environment:

    Kernel Mode Driver.

--*/

#include "busp.h"
#include "pnpisa.h"
#include <initguid.h>
#include <wdmguid.h>
#include "halpnpp.h"

//
// Prototype
//

VOID
PipCompleteRequest(
    IN OUT PIRP Irp,
    IN NTSTATUS Status,
    IN PVOID Information
    );

NTSTATUS
PipPassIrp(
    PDEVICE_OBJECT pDeviceObject,
    PIRP pIrp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PiUnload)
#pragma alloc_text(PAGE, PiDispatchPnp)
#pragma alloc_text(PAGE, PiDispatchDevCtl)
#pragma alloc_text(PAGE, PiDispatchCreate)
#pragma alloc_text(PAGE, PiDispatchClose)
#pragma alloc_text(PAGE, PiAddDevice)
#pragma alloc_text(PAGE, PipPassIrp)
#endif

VOID
PiUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine checks if there is any pnpisa card in the machine.  If non, it returns
    STATUS_NO_SUCH_DEVICE.

Arguments:

    DriverObject - Pointer to our pseudo driver object.

    DeviceObject - Pointer to the device object for which this requestapplies.

Return Value:

    NT status.

--*/
{

    PAGED_CODE();
    // We can not be unload.
    // ASSERT(0);
}

NTSTATUS
PiAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine checks if there is any pnpisa card in the machine.  If non, it returns
    STATUS_NO_SUCH_DEVICE.

    (Not any more, fix this)

Arguments:

    DriverObject - Pointer to our pseudo driver object.

    DeviceObject - Pointer to the device object for which this requestapplies.

Return Value:

    NT status.

--*/
{
    NTSTATUS status;
    PDEVICE_OBJECT busFdo;
    PPI_BUS_EXTENSION busExtension;
    UNICODE_STRING interfaceName;
    ULONG busNumber;

    PAGED_CODE();




    KeWaitForSingleObject( &IsaBusNumberLock,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL );
    ActiveIsaCount++;


    //
    // We are creating the first instance of the ISA bus.
    //
    RtlInitUnicodeString(&interfaceName, NULL);

    //
    // Create an FDO to attatch to the PDO
    //
    status = IoCreateDevice( DriverObject,
                             sizeof(PI_BUS_EXTENSION),  // Extension Size
                             NULL,                      // DeviceName
                             FILE_DEVICE_BUS_EXTENDER,
                             0,
                             FALSE,
                             &busFdo);


    if (NT_SUCCESS(status)) {
        busExtension = (PPI_BUS_EXTENSION) busFdo->DeviceExtension;
        busExtension->Flags = DF_BUS;
        busExtension->FunctionalBusDevice = busFdo;
        busExtension->AttachedDevice = IoAttachDeviceToDeviceStack(busFdo, DeviceObject);
        busExtension->PhysicalBusDevice = DeviceObject;
        busFdo->Flags &= ~DO_DEVICE_INITIALIZING;

        if (PiNeedDeferISABridge(DriverObject,DeviceObject)) {
          busNumber = RtlFindClearBitsAndSet (BusNumBM,1,1);
          ASSERT (busNumber != 0);
        } else {
          busNumber = RtlFindClearBitsAndSet (BusNumBM,1,0);
        }

        ASSERT (busNumber != 0xFFFFFFFF);

        if (ActiveIsaCount ==  1) {
            if (PipFirstInit) {
#if ISOLATE_CARDS
                PipResetGlobals();
#endif
            }
            PipDriverObject = DriverObject;
            busExtension->ReadDataPort = NULL;

            ASSERT (PipBusExtension == NULL);
            //
            //bus extension can get touched in pipdeletedevice
            //
            PipBusExtension = (PBUS_EXTENSION_LIST)ExAllocatePool (NonPagedPool,sizeof (BUS_EXTENSION_LIST));
            if (!PipBusExtension) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            PipBusExtension->BusExtension = busExtension;
            PipBusExtension->Next=NULL;

            PipFirstInit = TRUE;
        } else {
            PBUS_EXTENSION_LIST busList;

            ASSERT (PipDriverObject);
            busExtension->ReadDataPort = NULL;

            ASSERT (PipBusExtension);
            busList = PipBusExtension;
            while (busList->Next) {
                busList = (PBUS_EXTENSION_LIST)busList->Next;
            }
            busList->Next = (PBUS_EXTENSION_LIST)ExAllocatePool (NonPagedPool,sizeof (BUS_EXTENSION_LIST));

            if (!busList->Next) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            busList=busList->Next;
            busList->BusExtension = busExtension;
            busList->Next=NULL;
        }
        busExtension->BusNumber = busNumber;
    }

    KeSetEvent( &IsaBusNumberLock,
                0,
                FALSE );


    return status;
}

NTSTATUS
PiDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles all IRP_MJ_PNP_POWER IRPs.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP_POWER IRP to dispatch.

Return Value:

    NT status.

--*/
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    ULONG length;
    PVOID information = NULL;
    PWCHAR requestId, ids;
    PIO_RESOURCE_REQUIREMENTS_LIST ioResources;
    PCM_RESOURCE_LIST cmResources;
    PDEVICE_INFORMATION deviceInfo;
    PDEVICE_CAPABILITIES deviceCapabilities;
    PPNP_BUS_INFORMATION busInfo;
    PPI_BUS_EXTENSION busExtension;
    PDEVICE_INFORMATION deviceExtension = NULL;
    UNICODE_STRING unicodeString;

    PAGED_CODE();

    //
    // Get a pointer to our stack location and take appropriate action based
    // on the minor function.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    busExtension = DeviceObject->DeviceExtension;
    if (busExtension->Flags & DF_BUS) {
        if (busExtension->AttachedDevice == NULL) {
            status = STATUS_NO_SUCH_DEVICE;
            PipCompleteRequest(Irp, status, information);
            goto exit;
        }
    } else {
        busExtension = NULL;
        deviceExtension = DeviceObject->DeviceExtension;
        if (deviceExtension->Flags & DF_DELETED) {
            if (irpSp->MinorFunction == IRP_MN_REMOVE_DEVICE) {
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_NO_SUCH_DEVICE;
            }
            PipCompleteRequest(Irp, status, information);
            goto exit;
        }
    }


    //
    // Dispatch IRPs bound for the FDO
    //
    if (busExtension) {
        status = PiDispatchPnpFdo(
                                DeviceObject,
                                Irp
                                );

        //return status;
    } else {
#if ISOLATE_CARDS
    //
    // Dispatch IRPs bound for the PDO
    //
        status = PiDispatchPnpPdo(
                                DeviceObject,
                                Irp
                                );
        //return status;
#endif
    }



exit:
    //
    // Complete the Irp and return.
    //

   // PipCompleteRequest(Irp, status, information);
    return status;
} // PiDispatchPnp


VOID
PipCompleteRequest(
    IN OUT PIRP Irp,
    IN NTSTATUS Status,
    IN PVOID Information
    )

/*++

Routine Description:

    This routine completes PnP irps for our pseudo driver.

Arguments:

    Irp - Supplies a pointer to the irp to be completed.

    Status - completion status.

    Information - completion information to be passed back.

Return Value:

    None.

--*/

{
    //
    // Complete the IRP.  First update the status...
    //

    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = (ULONG_PTR)Information;

    //
    // ... and complete it.
    //

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
}

NTSTATUS
PipPassIrp(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Description:

    This function pass the Irp to lower level driver.

Arguments:

    DeviceObject - the Fdo or Pdo
    Irp - the request

Return:

    STATUS_PENDING

--*/
{

    PIO_STACK_LOCATION ioStackLocation;                 // our stack location
    PIO_STACK_LOCATION nextIoStackLocation;             // next guy's
    PPI_BUS_EXTENSION busExtension = (PPI_BUS_EXTENSION) DeviceObject->DeviceExtension;


    IoSkipCurrentIrpStackLocation(Irp);

    //
    // Io call next driver, we pass it to root hub's parent no matter which tier we are at.
    //

    return IoCallDriver( busExtension->AttachedDevice, Irp );
}


NTSTATUS
PiDispatchDevCtl(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Description:

    This function passes the Device Control Irp to lower level driver.

Arguments:

    DeviceObject - the Fdo or Pdo
    Irp - the request

Return:

    STATUS_PENDING

--*/
{
    PPI_BUS_EXTENSION busExtension = (PPI_BUS_EXTENSION) DeviceObject->DeviceExtension;
    NTSTATUS status;

    PAGED_CODE();
    if (busExtension->Flags & DF_BUS) {
        IoSkipCurrentIrpStackLocation (Irp);
        return IoCallDriver( busExtension->AttachedDevice, Irp );
    } else {
        //
        //We're at the bottom
        //
        status = Irp->IoStatus.Status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return status;
    }



}

NTSTATUS
PiDispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Description:

    This function handles the IRP_MJ_CREATE Irp

Arguments:

    DeviceObject - the Fdo or Pdo
    Irp - the request

Return:

    STATUS_PENDING

--*/
{
    PAGED_CODE();
    PipCompleteRequest(Irp,STATUS_SUCCESS,NULL);
    return STATUS_SUCCESS;

}
NTSTATUS
PiDispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Description:

    This function handles the IRP_MJ_CLOSE request

Arguments:

    DeviceObject - the Fdo or Pdo
    Irp - the request

Return:

    STATUS_PENDING

--*/
{
    PAGED_CODE();
    PipCompleteRequest(Irp,STATUS_SUCCESS,NULL);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\isapnp\isolate.c ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    isolate.c

Abstract:


Author:

    Shie-Lin Tzong (shielint) July-10-1995

Environment:

    Kernel mode only.

Revision History:

--*/

#include "busp.h"
#include "pbios.h"
#include "pnpisa.h"

#if ISOLATE_CARDS

#define RANGE_MASK 0xFF000000

BOOLEAN
PipFindIrqInformation (
    IN ULONG IrqLevel,
    IN PUCHAR BiosRequirements,
    OUT PUCHAR Information
    );

BOOLEAN
PipFindMemoryInformation (
    IN ULONG Index,
    IN ULONG Base,
    IN ULONG Limit,
    IN PUCHAR BiosRequirements,
    OUT PUCHAR NameTag,
    OUT PUCHAR Information,
    OUT PULONG NewLengh OPTIONAL
    );

BOOLEAN
PipFindIoPortInformation (
    IN ULONG BaseAddress,
    IN PUCHAR BiosRequirements,
    OUT PUCHAR Information,
    OUT PUCHAR Alignment,
    OUT PUCHAR RangeLength
    );

BOOLEAN
PipFindDmaInformation (
    IN UCHAR ChannelMask,
    IN PUCHAR BiosRequirements,
    OUT PUCHAR Information
    );

NTSTATUS
PipReadCardResourceDataBytes (
    IN USHORT BytesToRead,
    IN PUCHAR Buffer
    );

USHORT
PipIrqLevelRequirementsFromDeviceData(
    IN PUCHAR BiosRequirements,
    ULONG Length
    );

//
// Internal type definitions
//

typedef struct _MEMORY_DESC_{
    ULONG Base;
    ULONG Length;
    BOOLEAN Memory32;
} MEMORY_DESC, *PMEMORY_DESC;

typedef struct _IRQ_DESC_{
    UCHAR Level;
    ULONG Type;
}IRQ_DESC, *PIRQ_DESC;

#ifdef ALLOC_PRAGMA
//#pragma alloc_text(PAGE, PipFindIrqInformation)
//#pragma alloc_text(PAGE, PipFindMemoryInformation)
//#pragma alloc_text(PAGE, PipFindIoPortInformation)
//#pragma alloc_text(PAGE, PipReadCardResourceData)
#pragma alloc_text(PAGE, PipReadDeviceResources)
//#pragma alloc_text(PAGE, PipWriteDeviceResources)
//#pragma alloc_text(PAGE, PipLFSRInitiation)
//#pragma alloc_text(PAGE, PipIsolateCards)
#pragma alloc_text(PAGE, PipFindNextLogicalDeviceTag)
//#pragma alloc_text(PAGE, PipSelectLogicalDevice)
//#pragma alloc_text(PAGE, PipReadCardResourceDataBytes)

#endif

BOOLEAN
PipFindIrqInformation (
    IN ULONG IrqLevel,
    IN PUCHAR BiosRequirements,
    OUT PUCHAR Information
    )

/*++

Routine Description:

    This routine searches the Bios resource requirement lists for the corresponding
    Irq descriptor information.  The search stops when we encounter another logical
    device id tag or the END tag.  On input, the BiosRequirements points to current
    logical id tag.

Arguments:

    IrqLevel - Supplies the irq level.

    BiosRequirements - Supplies a pointer to the bios resource requirement lists.  This
        parameter must point to the logical device Id tag.

    Information - supplies a pointer to a UCHAR to receive the port information/flags.

Return Value:

    TRUE - if memory information found.  Else False.

--*/
{
    UCHAR tag;
    ULONG increment;
    USHORT irqMask;
    PPNP_IRQ_DESCRIPTOR biosDesc;

    //
    // Skip current logical id tag
    //

    tag = *BiosRequirements;
    ASSERT((tag & SMALL_TAG_MASK) == TAG_LOGICAL_ID);
    BiosRequirements += (tag & SMALL_TAG_SIZE_MASK) + 1;

    //
    // Search the possible resource list to get the information
    // for the Irq.
    //

    irqMask = 1 << IrqLevel;
    tag = *BiosRequirements;
    while ((tag != TAG_COMPLETE_END) && ((tag & SMALL_TAG_MASK) != TAG_LOGICAL_ID)) {
        if ((tag & SMALL_TAG_MASK) == TAG_IRQ) {
            biosDesc = (PPNP_IRQ_DESCRIPTOR)BiosRequirements;
            if (biosDesc->IrqMask & irqMask) {
                if ((tag & SMALL_TAG_SIZE_MASK) == 2) {

                    //
                    // if no irq info is available, a value of zero is returned.
                    // (o is not a valid irq information.)
                    //

                    *Information = 0;
                } else {
                    *Information = biosDesc->Information;
                }
                return TRUE;
            }
        }
        if (tag & LARGE_RESOURCE_TAG) {
            increment = *((USHORT UNALIGNED *)(BiosRequirements + 1));
            increment += 3;     // length of large tag
        } else {
            increment = tag & SMALL_TAG_SIZE_MASK;
            increment += 1;     // length of small tag
        }
        BiosRequirements += increment;
        tag = *BiosRequirements;
    }
    return FALSE;
}

BOOLEAN
PipFindMemoryInformation (
    IN ULONG Index,
    IN ULONG BaseAddress,
    IN ULONG Limit,
    IN PUCHAR BiosRequirements,
    OUT PUCHAR NameTag,
    OUT PUCHAR Information,
    OUT PULONG NewLength OPTIONAL
    )

/*++

Routine Description:

    This routine searches the Bios resource requirement lists for the corresponding
    memory descriptor information.  The search stops when we encounter another logical
    device id tag or the END tag.  Note, the memory range specified by Base
    and Limit must be within a single Pnp ISA memory descriptor.

Arguments:

    Index - Which memory descriptor we're interested in.

    BaseAddress - Supplies the base address of the memory range.

    Limit - Supplies the upper limit of the memory range.

    BiosRequirements - Supplies a pointer to the bios resource requirement lists.  This
        parameter must point to the logical device Id tag.

    NameTag - Supplies a variable to receive the Tag of the memory descriptor which
        describes the memory information.

    Information - supplies a pointer to a UCHAR to receive the memory information
        for the specified memory range.

Return Value:

    TRUE - if memory information found.  Else False.

--*/
{
    UCHAR tag;
    BOOLEAN found = FALSE,foundMem24, foundMem;
    ULONG minAddr, length, maxAddr, alignment, noMem = 0;
    USHORT increment;

    //
    // Skip current logical id tag.
    //

    tag = *BiosRequirements;
    ASSERT((tag & SMALL_TAG_MASK) == TAG_LOGICAL_ID);
    BiosRequirements += (tag & SMALL_TAG_SIZE_MASK) + 1;
    //
    // Search the possible resource list to get the information
    // for the memory range described by Base and Limit.
    //
    if (NewLength) {
        *NewLength=0;
    }

    tag = *BiosRequirements;
    while ((tag != TAG_COMPLETE_END) && ((tag & SMALL_TAG_MASK) != TAG_LOGICAL_ID)) {
        foundMem = foundMem24 = FALSE;
        switch (tag) {
        case TAG_MEMORY:
            minAddr = ((ULONG)(((PPNP_MEMORY_DESCRIPTOR)BiosRequirements)->MinimumAddress)) << 8;
            length = ((ULONG)(((PPNP_MEMORY_DESCRIPTOR)BiosRequirements)->MemorySize)) << 8;
            maxAddr = (((ULONG)(((PPNP_MEMORY_DESCRIPTOR)BiosRequirements)->MaximumAddress)) << 8)
                + length - 1;

            foundMem24 = TRUE;
            foundMem = TRUE;
            break;
        case TAG_MEMORY32:
            length = ((PPNP_MEMORY32_DESCRIPTOR)BiosRequirements)->MemorySize;
            minAddr = ((PPNP_MEMORY32_DESCRIPTOR)BiosRequirements)->MinimumAddress;
            maxAddr = ((PPNP_MEMORY32_DESCRIPTOR)BiosRequirements)->MaximumAddress
                + length - 1;
            foundMem = TRUE;
            break;
        case TAG_MEMORY32_FIXED:
            length = ((PPNP_FIXED_MEMORY32_DESCRIPTOR)BiosRequirements)->MemorySize;
            minAddr = ((PPNP_FIXED_MEMORY32_DESCRIPTOR)BiosRequirements)->BaseAddress;
            maxAddr = minAddr + length - 1;
            foundMem = TRUE;
            break;
        }

        if (foundMem) {
            //
            // Work around cards that don't set register 43 correctly.
            // if the boot config has a value that equals the rom data, but
            // has the range type flipped, allow it, and reset
            // the length
            //
            if ((minAddr <= BaseAddress &&
                ((maxAddr >= Limit) || ((foundMem24 && (maxAddr >= (BaseAddress+(~Limit & ~RANGE_MASK))))))) && (noMem == Index)) {

                *Information = ((PPNP_MEMORY32_DESCRIPTOR)BiosRequirements)->Information;
                *NameTag = tag;
                found = TRUE;
                //
                // did we find a 16-bit tag
                //
                if (NewLength && foundMem24) {
                    if  (maxAddr >= (BaseAddress+(~Limit & ~RANGE_MASK))) {
                        *NewLength = length;
                    }
                }
                break;
            } else {
                noMem++;
            }
        }

        //
        // Advance to next tag
        //

        if (tag & LARGE_RESOURCE_TAG) {
            increment = *(USHORT UNALIGNED *)(BiosRequirements + 1);
            increment += 3;     // length of large tag
        } else {
            increment = tag & SMALL_TAG_SIZE_MASK;
            increment += 1;     // length of small tag
        }
        BiosRequirements += increment;
        tag = *BiosRequirements;
    }
    return found;
}

BOOLEAN
PipFindIoPortInformation (
    IN ULONG BaseAddress,
    IN PUCHAR BiosRequirements,
    OUT PUCHAR Information,
    OUT PUCHAR Alignment,
    OUT PUCHAR RangeLength
    )

/*++

Routine Description:

    This routine searches the Bios resource requirement lists for the corresponding
    Io port descriptor information.  The search stops when we encounter another logical
    device id tag or the END tag.

Arguments:

    BaseAddress - Supplies the base address of the Io port range.

    BiosRequirements - Supplies a pointer to the bios resource requirement lists.  This
        parameter must point to the logical device Id tag.

    Information - supplies a pointer to a UCHAR to receive the port information/flags.

    Alignment - supplies a pointer to a UCHAR to receive the port alignment
        information.

    RangeLength - supplies a pointer to a UCHAR to receive the port range length
        information.

Return Value:

    TRUE - if memory information found.  Else False.

--*/
{
    UCHAR tag;
    BOOLEAN found = FALSE;
    ULONG minAddr, length, maxAddr, alignment;
    USHORT increment;
    PPNP_PORT_DESCRIPTOR portDesc;
    PPNP_FIXED_PORT_DESCRIPTOR fixedPortDesc;

    tag = *BiosRequirements;
    ASSERT((tag & SMALL_TAG_MASK) == TAG_LOGICAL_ID);
    BiosRequirements += (tag & SMALL_TAG_SIZE_MASK) + 1;

    //
    // Search the possible resource list to get the information
    // for the io port range described by Base.
    //

    tag = *BiosRequirements;
    while ((tag != TAG_COMPLETE_END) && ((tag & SMALL_TAG_MASK) != TAG_LOGICAL_ID)) {
        switch (tag & SMALL_TAG_MASK) {
        case TAG_IO:
             portDesc = (PPNP_PORT_DESCRIPTOR)BiosRequirements;
             minAddr = portDesc->MinimumAddress;
             maxAddr = portDesc->MaximumAddress;
             if (minAddr <= BaseAddress && maxAddr >= BaseAddress) {
                 *Information = portDesc->Information;
                 *Alignment = portDesc->Alignment;
                 *RangeLength = portDesc->Length;
                 found = TRUE;
             }
             break;
        case TAG_IO_FIXED:
             fixedPortDesc = (PPNP_FIXED_PORT_DESCRIPTOR)BiosRequirements;
             minAddr = fixedPortDesc->MinimumAddress;
             if (BaseAddress == minAddr) {
                 *Information = 0;     // 10 bit decode
                 *Alignment = 1;
                 *RangeLength = fixedPortDesc->Length;
                 found = TRUE;
             }
             break;
        }

        if (found) {
            break;
        }

        //
        // Advance to next tag
        //

        if (tag & LARGE_RESOURCE_TAG) {
            increment = *(USHORT UNALIGNED *)(BiosRequirements + 1);
            increment += 3;     // length of large tag
        } else {
            increment = tag & SMALL_TAG_SIZE_MASK;
            increment += 1;     // length of small tag
        }
        BiosRequirements += increment;
        tag = *BiosRequirements;
    }
    return found;
}

BOOLEAN
PipFindDmaInformation (
    IN UCHAR ChannelMask,
    IN PUCHAR BiosRequirements,
    OUT PUCHAR Information
    )

/*++

Routine Description:

    This routine searches the Bios resource requirement lists for the corresponding
    Io port descriptor information.  The search stops when we encounter another logical
    device id tag or the END tag.

Arguments:

    BaseAddress - Supplies the channel mask.

    BiosRequirements - Supplies a pointer to the bios resource requirement lists.  This
        parameter must point to the logical device Id tag.

    Information - supplies a pointer to a UCHAR to receive the port information/flags.

Return Value:

    TRUE - if memory information found.  Else False.

--*/
{
    UCHAR tag;
    BOOLEAN found = FALSE;
    USHORT increment;
    PPNP_DMA_DESCRIPTOR dmaDesc;
    UCHAR biosMask;

    tag = *BiosRequirements;
    ASSERT((tag & SMALL_TAG_MASK) == TAG_LOGICAL_ID);
    BiosRequirements += (tag & SMALL_TAG_SIZE_MASK) + 1;

    //
    // Search the possible resource list to get the information
    // for the io port range described by Base.
    //

    tag = *BiosRequirements;
    while ((tag != TAG_COMPLETE_END) && ((tag & SMALL_TAG_MASK) != TAG_LOGICAL_ID)) {
        if ((tag & SMALL_TAG_MASK) == TAG_DMA) {
             dmaDesc = (PPNP_DMA_DESCRIPTOR)BiosRequirements;
             biosMask = dmaDesc->ChannelMask;
             if (ChannelMask & biosMask) {
                 *Information = dmaDesc->Flags;
                 found = TRUE;
             }
        }

        if (found) {
            break;
        }

        //
        // Advance to next tag
        //

        if (tag & LARGE_RESOURCE_TAG) {
            increment = *(USHORT UNALIGNED *)(BiosRequirements + 1);
            increment += 3;     // length of large tag
        } else {
            increment = tag & SMALL_TAG_SIZE_MASK;
            increment += 1;     // length of small tag
        }
        BiosRequirements += increment;
        tag = *BiosRequirements;
    }
    return found;
}

NTSTATUS
PipReadCardResourceData (
    OUT PULONG NumberLogicalDevices,
    IN PUCHAR *ResourceData,
    OUT PULONG ResourceDataLength
    )
/*++

Routine Description:

    This routine reads resources data from a specified PnP ISA card.  It is
    caller's responsibility to release the memory.  Before calling this routine,
    the Pnp ISA card should be in sleep state (i.e. Initiation Key was sent.)
    After exiting this routine, the card will be left in Config state.

Arguments:

    NumberLogicalDevices - supplies a variable to receive the number of logical devices
        associated with the Pnp Isa card.

    ResourceData - Supplies a variable to receive the pointer to the resource data.

    ResourceDataLength - Supplies a variable to receive the length of the ResourceData.

Return Value:

    NT STATUS code.

--*/
{

    PUCHAR buffer, p;
    LONG sizeToRead, limit, i;
    USHORT size;
    UCHAR tag;
    ULONG noDevices;

    BOOLEAN failed;
    NTSTATUS status;

    //
    // Allocate memory to store the resource data.
    // N.B. The buffer size should cover 99.999% of the machines.
    //

    sizeToRead = 4096;

tryAgain:

    noDevices = 0;
    buffer = (PUCHAR)ExAllocatePoolWithTag(NonPagedPool, sizeToRead, 'iPnP');
    if (!buffer) {
        DebugPrint((DEBUG_ERROR, "PipReadCardResourceData returning STATUS_INSUFFICIENT_RESOURCES\n"));

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Send card from sleep state to configuration state
    // Note, by doing this the resource data includes 9 bytes Id.
    //

    DebugPrint((DEBUG_STATE, "Read resources\n"));

    //
    // Read card id bytes
    //

    p = buffer;
    status = PipReadCardResourceDataBytes(NUMBER_CARD_ID_BYTES, p);
    if (!NT_SUCCESS(status)) {
        ExFreePool(buffer);
        DebugPrint((DEBUG_STATE | DEBUG_ERROR,
                    "Read resources failed\n"));

        DebugPrint((DEBUG_ERROR, "PipReadCardResourceDataBytes Failed %x\n",status));
        return status;
    }
    i = NUMBER_CARD_ID_BYTES;
    p += NUMBER_CARD_ID_BYTES;

    //
    // read all the tag descriptors of the card resource data
    //

    failed = FALSE;
    limit = sizeToRead - 4 - NUMBER_CARD_ID_BYTES;;

    while (TRUE) {

        //
        // Read tag byte. Make sure it's a valid tag and determine
        // the size of the descriptor.
        //

        PipReadCardResourceDataBytes(1, p);
        tag = *p;
        i++;
        p++;
        if (tag == TAG_COMPLETE_END) {
            PipReadCardResourceDataBytes(1, p);
            p++;
            i++;
            break;
        } else if (tag == TAG_END) {  // With NO checksum
            *p = 0;
            i++;
            p++;
            break;
        }
        if (tag & LARGE_RESOURCE_TAG) {
            if (tag & 0x70) {
                failed = TRUE;
#if VERBOSE_DEBUG
    DbgPrint ("Failing Resource read on large tag: %x\n",tag);
#endif
                break;
            } else {
                PipReadCardResourceDataBytes(2, p);
                size = *((USHORT UNALIGNED *)p);
                p += 2;
                i += 2;
            }
        } else {
            if ((tag & 0x70) == 0x50 || (tag & 0x70) == 0x60 || (((tag & 0x70) == 0) && (tag != 0xa))) {
                failed = TRUE;
#if VERBOSE_DEBUG
    DbgPrint ("Failing Resource read on small tag: %x\n",tag);
#endif
                break;
            } else {
                if ((tag & SMALL_TAG_MASK) == TAG_LOGICAL_ID) {
                    noDevices++;
                }
                size = (USHORT)(tag & SMALL_TAG_SIZE_MASK);
            }
        }

        //
        // read 'size' number of bytes for the current descriptor
        //

        i += size;
        if (i < limit) {
            PipReadCardResourceDataBytes(size, p);
            p += size;
        } else {
            ExFreePool(buffer);
            sizeToRead <<= 1;           // double the buffer

            //
            // If we can find the END tag with 32K byte, assume the resource
            // requirement list is bad.
            //

            if (sizeToRead > 0x80000) {

                DebugPrint ((DEBUG_STATE | DEBUG_ERROR, "PipReadCardResourceData returning STATUS_INVALID_PARAMETER, Sleep\n"));

                return STATUS_INVALID_PARAMETER;
            } else {
                goto tryAgain;
            }
        }
    }

    if (failed) {
        ExFreePool(buffer);
#if VERBOSE_DEBUG
        DbgPrint ("PipReadCardResourceData returning FAILED\n");
#endif

        return STATUS_UNSUCCESSFUL;
    }

    //
    // Determine the real size of the buffer required and
    // resize the buffer.
    //

    size = (USHORT)(p - buffer); // i
    p = (PUCHAR)ExAllocatePoolWithTag(NonPagedPool, size, 'iPnP');
    if (p) {
        RtlMoveMemory(p, buffer, size);
        ExFreePool(buffer);
    } else {

        //
        // Fail to resize the buffer.  Simply leave it alone.
        //

        p = buffer;
    }

    *ResourceData = p;
    *NumberLogicalDevices = noDevices;
    *ResourceDataLength = size;
    return STATUS_SUCCESS;
}

NTSTATUS
PipReadDeviceResources (
    IN ULONG BusNumber,
    IN PUCHAR BiosRequirements,
    IN ULONG CardFlags,
    OUT PCM_RESOURCE_LIST *ResourceData,
    OUT PULONG Length,
    OUT PUSHORT irqFlags
    )

/*++

Routine Description:

    This routine reads boot resource data from an enabled logical device of a PNP ISA
    card.  Caller must put the card into configuration state and select the logical
    device before calling this function.  It is caller's responsibility to release
    the memory. ( The boot resource data is the resources that a card assigned during
    boot.)

Arguments:

    BusNumber - specifies the bus number of the device whose resource data to be read.

    BiosRequirements - Supplies a pointer to the resource requirement list for the logical
        device.  This parameter must point to the logical device Id tag.

    CardFlags - Flags that may indicate the need to apply a workaround.

    ResourceData - Supplies a variable to receive the pointer to the resource data.

    Length - Supplies a variable to recieve the length of the resource data.

Return Value:

    NT STATUS code.

--*/
{
    UCHAR c, junk1, junk2, info;
    PUCHAR base;
    ULONG l, resourceCount;
    BOOLEAN limit;
    LONG i, j, noMemoryDesc = 0, noIoDesc = 0, noDmaDesc =0, noIrqDesc = 0;
    MEMORY_DESC memoryDesc[NUMBER_MEMORY_DESCRIPTORS + NUMBER_32_MEMORY_DESCRIPTORS];
    IRQ_DESC irqDesc[NUMBER_IRQ_DESCRIPTORS];
    UCHAR dmaDesc[NUMBER_DMA_DESCRIPTORS];
    USHORT ioDesc[NUMBER_IO_DESCRIPTORS];
    PCM_RESOURCE_LIST cmResource;
    PCM_PARTIAL_RESOURCE_LIST partialResList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDesc;
    ULONG dumpData[2];

    //
    // First make sure the specified BiosRequirements is valid and at the right tag.
    //

    if ((*BiosRequirements & SMALL_TAG_MASK) != TAG_LOGICAL_ID) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // If card is not activated, don't read boot resource.
    // Because boot resource of non activated NEC98's ISAPNP card is not 0.
    //

    *irqFlags = CM_RESOURCE_INTERRUPT_LATCHED;
    PipWriteAddress(ACTIVATE_PORT);
    if (!(PipReadData() & 1)) {
        *ResourceData = NULL;
        *Length = 0;
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Read memory configuration
    //

    base = (PUCHAR)ADDRESS_MEMORY_BASE;
    for (i = 0; i < NUMBER_MEMORY_DESCRIPTORS; i++) {

        //
        // Read memory base address
        //

        PipWriteAddress(base + ADDRESS_MEMORY_HI);
        c = PipReadData();
        l = c;
        l <<= 8;
        PipWriteAddress(base + ADDRESS_MEMORY_LO);
        c = PipReadData();
        l |= c;
        l <<= 8;        // l = memory base address
        if (l == 0) {
            break;
        }

        memoryDesc[noMemoryDesc].Base = l;

        //
        // Read memory control byte
        //

        PipWriteAddress(base + ADDRESS_MEMORY_CTL);
        c= PipReadData();

        limit = c & 1;

        //
        // Read memory upper limit address or range length
        //

        PipWriteAddress(base + ADDRESS_MEMORY_UPPER_HI);
        c = PipReadData();

        l = c;
        l <<= 8;

        PipWriteAddress(base + ADDRESS_MEMORY_UPPER_LO);
        c = PipReadData();
        l |= c;
        l <<= 8;

        //
        //If bit[0] of memory control is 0, this is the range length.
        //If bit[0] of memory control is 1, this is upper limit for memory
        //address (equal to memory base address plus the range length allocated).
        //
        if (limit == ADDRESS_MEMORY_CTL_LIMIT) {
            l = l - memoryDesc[noMemoryDesc].Base;
        }else {
            l = (~l+1) & ~(RANGE_MASK);
        }

        // IBM0001 Token Ring card has write-only registers 0x4B-0x4C.
        // The boot configed length comes back 0 instead of 0x2000
        if ((CardFlags & CF_IBM_MEMBOOTCONFIG) && (l == 0) &&
            (noMemoryDesc == 1)) {
            l = 0x2000;
        }

        memoryDesc[noMemoryDesc].Length = l;
        memoryDesc[noMemoryDesc].Memory32 = FALSE;
        noMemoryDesc++;
        base += ADDRESS_MEMORY_INCR;
    }

    //
    // Read memory 32 configuration
    //
    // Spec says you can't mix 24 bit and 32bit memory.  Helps on
    // cards with flakey 32 bit memory registers until we examine only
    // the boot configed resources specified in the requirements.
    if (noMemoryDesc == 0) {

        for (i = 0; i < NUMBER_32_MEMORY_DESCRIPTORS; i++) {

            base = ADDRESS_32_MEMORY_BASE(i);

            //
            // Read memory base address
            //
            l = 0;
            for (j = ADDRESS_32_MEMORY_B3; j <= ADDRESS_32_MEMORY_B0; j++) {
                PipWriteAddress(base + j);
                c = PipReadData();

                l <<= 8;
                l |= c;
            }
            if (l == 0) {
                break;
            }

            memoryDesc[noMemoryDesc].Base = l;

            //
            // Read memory control byte
            //

            PipWriteAddress(base + ADDRESS_32_MEMORY_CTL);
            c= PipReadData();

            limit = c & 1;

            //
            // Read memory upper limit address or range length
            //

            l = 0;
            for (j = ADDRESS_32_MEMORY_E3; j <= ADDRESS_32_MEMORY_E0; j++) {
                PipWriteAddress(base + j);
                c = PipReadData();
                l <<= 8;
                l |= c;
            }

            if (limit == ADDRESS_MEMORY_CTL_LIMIT) {
                l = l - memoryDesc[noMemoryDesc].Base;
            }else {
                l = ((~l)+1) & ~(RANGE_MASK);
            }

            memoryDesc[noMemoryDesc].Length = l;
            memoryDesc[noMemoryDesc].Memory32 = TRUE;
            noMemoryDesc++;
        }
    }

    //
    // Read Io Port Configuration
    //

    base =  (PUCHAR)ADDRESS_IO_BASE;
    for (i = 0; i < NUMBER_IO_DESCRIPTORS; i++) {
        PipWriteAddress(base + ADDRESS_IO_BASE_HI);
        c = PipReadData();
        l = c;
        PipWriteAddress(base + ADDRESS_IO_BASE_LO);
        c = PipReadData();
        l <<= 8;
        l |= c;
        if (l == 0) {
            break;
        }
        ioDesc[noIoDesc++] = (USHORT)l;
        base += ADDRESS_IO_INCR;
    }

    //
    // Read Interrupt configuration
    //

    base = (PUCHAR)ADDRESS_IRQ_BASE;
    for (i = 0; i < NUMBER_IRQ_DESCRIPTORS; i++) {
        PipWriteAddress(base + ADDRESS_IRQ_VALUE);
        c = PipReadData() & 0xf;
        if (c == 0) {
            break;
        }
        irqDesc[noIrqDesc].Level = c;
        PipWriteAddress(base + ADDRESS_IRQ_TYPE);
        c = PipReadData();
        irqDesc[noIrqDesc++].Type = c;
        base += ADDRESS_IRQ_INCR;

        DebugPrint((DEBUG_IRQ, "card boot config byte %x\n", (ULONG) c));
        // only if card is configured to low level do we respect level.
        // register is probably busted
        if ((c & 3) == 1) {
            *irqFlags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
        }
    }

    //
    // Read DMA configuration
    //

    base = (PUCHAR)ADDRESS_DMA_BASE;
    for (i = 0; i < NUMBER_DMA_DESCRIPTORS; i++) {
        PipWriteAddress(base + ADDRESS_DMA_VALUE);
        c = PipReadData() & 0x7;
        if (c == 4) {
            break;
        }
        if (!PipFindDmaInformation ( (UCHAR)(1 << c), BiosRequirements, &info)) {
            break;
        }
        dmaDesc[noDmaDesc++] = c;
        base += ADDRESS_DMA_INCR;
    }

    //
    // Construct CM_RESOURCE_LIST structure based on the resource data
    // we collect so far.
    //

    resourceCount = noMemoryDesc + noIoDesc + noDmaDesc + noIrqDesc;

    //
    // if empty bios resources, simply return.
    //

    if (resourceCount == 0) {
        *ResourceData = NULL;
        *Length = 0;
        return STATUS_SUCCESS;
    }

    l = sizeof(CM_RESOURCE_LIST) + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) *
               ( resourceCount - 1);
    cmResource = ExAllocatePoolWithTag(PagedPool, l, 'iPnP');
    if (!cmResource) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(cmResource, l);
    *Length = l;                                   // Set returned resource data length
    cmResource->Count = 1;
    cmResource->List[0].InterfaceType = Isa;
    cmResource->List[0].BusNumber = BusNumber;
    partialResList = (PCM_PARTIAL_RESOURCE_LIST)&cmResource->List[0].PartialResourceList;
    partialResList->Version = 0;
    partialResList->Revision = 0x3000;
    partialResList->Count = resourceCount;
    partialDesc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)&partialResList->PartialDescriptors[0];

    //
    // Set up all the CM memory descriptors
    //
    for (i = 0; i < noMemoryDesc; i++) {

        ULONG NewLength;

        partialDesc->Type = CmResourceTypeMemory;
        partialDesc->ShareDisposition = CmResourceShareDeviceExclusive;
        partialDesc->u.Memory.Length = memoryDesc[i].Length;
        partialDesc->u.Memory.Start.HighPart = 0;
        partialDesc->u.Memory.Start.LowPart = memoryDesc[i].Base;

        //
        // Need to consult configuration data for the Flags
        //

        l = memoryDesc[i].Base + memoryDesc[i].Length - 1;
        if (PipFindMemoryInformation (i, memoryDesc[i].Base, l, BiosRequirements, &junk1, &c,&NewLength)) {

            if (NewLength != 0 ) {
                partialDesc->u.Memory.Length = NewLength;
            }

            // Mark the memory descriptor as read-only if the tags describe as
            // expansion ROM or generic non-writable memory
            if ((c & PNP_MEMORY_ROM_MASK) ||
                !(c & PNP_MEMORY_WRITE_STATUS_MASK)) {
                partialDesc->Flags =  CM_RESOURCE_MEMORY_READ_ONLY;
            }
        } else {
            DebugPrint((DEBUG_CARDRES|DEBUG_WARN,
                        "ReadDeviceResources: No matched memory req for %x to %x\n",
                        memoryDesc[i].Base, l));
            ExFreePool(cmResource);
            return STATUS_UNSUCCESSFUL;
        }
        partialDesc->Flags |= CM_RESOURCE_MEMORY_24;
        partialDesc++;
    }

    //
    // Set up all the CM io/port descriptors
    //

    for (i = 0; i < noIoDesc; i++) {
        partialDesc->Type = CmResourceTypePort;
        partialDesc->ShareDisposition = CmResourceShareDeviceExclusive;
        partialDesc->Flags = CM_RESOURCE_PORT_IO;
        partialDesc->u.Port.Start.LowPart = ioDesc[i];

        //
        // Need to consult configuration data for the Port length
        //

        if (PipFindIoPortInformation (ioDesc[i], BiosRequirements, &info, &junk2, &c)) {
            if (info & 1) {
                partialDesc->Flags |= CM_RESOURCE_PORT_16_BIT_DECODE;
            } else {
                partialDesc->Flags |= CM_RESOURCE_PORT_10_BIT_DECODE;
            }
            partialDesc->u.Port.Length = c;
            partialDesc++;
        } else {
            DebugPrint((DEBUG_CARDRES|DEBUG_WARN,
                        "ReadDeviceResources: No matched port req for %x\n",
                        ioDesc[i]));
            ExFreePool(cmResource);
            return STATUS_UNSUCCESSFUL;
        }
    }

    //
    // Set up all the CM DMA descriptors
    //

    for (i = 0; i < noDmaDesc; i++) {
        partialDesc->Type = CmResourceTypeDma;
        partialDesc->ShareDisposition = CmResourceShareDeviceExclusive;
        partialDesc->Flags = 0;   // no flags for DMA descriptor
        partialDesc->u.Dma.Channel = (ULONG) dmaDesc[i];
        partialDesc->u.Dma.Port = 0;
        partialDesc->u.Dma.Reserved1 = 0;
        partialDesc++;
    }

    //
    // Set up all the CM interrupt descriptors
    //

    for (i = 0; i < noIrqDesc; i++) {
        partialDesc->Type = CmResourceTypeInterrupt;
        partialDesc->ShareDisposition = CmResourceShareDeviceExclusive;


        partialDesc->Flags = *irqFlags;
        partialDesc->u.Interrupt.Vector =
        partialDesc->u.Interrupt.Level = irqDesc[i].Level;
        partialDesc->u.Interrupt.Affinity = (ULONG)-1;
        partialDesc++;
    }

    *ResourceData = cmResource;
    return STATUS_SUCCESS;
}

NTSTATUS
PipWriteDeviceResources (
    IN PUCHAR BiosRequirements,
    IN PCM_RESOURCE_LIST CmResources
    )

/*++

Routine Description:

    This routine writes boot resource data to an enabled logical device of
    a Pnp ISA card.  Caller must put the card into configuration state and select
    the logical device before calling this function.

Arguments:

    BiosRequirements - Supplies a pointer to the possible resources for the logical
        device.  This parameter must point to the logical device Id tag.

    ResourceData - Supplies a pointer to the cm resource data.

Return Value:

    NT STATUS code.

--*/
{
    UCHAR c, information, tag;
    ULONG count, i, j, pass, base, limit;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmDesc;
    ULONG noIrq =0, noIo = 0, noDma = 0, noMemory24 = 0, noMemory32 = 0, noMemory;
    PUCHAR memoryBase, irqBase, dmaBase, ioBase, tmp;
    ULONG memory32Base;

#if 0
    PipWriteAddress(ACTIVATE_PORT);
    if (!(PipReadData() & 1)) {
        DbgPrint("PnpIsa-WriteDeviceBootResourceData:The logical device has not been activated\n");
    }
#endif // DBG

    //
    // First make sure the specified BiosRequirements is valid and at the right tag.
    //

    if ((*BiosRequirements & SMALL_TAG_MASK) != TAG_LOGICAL_ID) {
        return STATUS_INVALID_PARAMETER;
    }

    count = CmResources->List[0].PartialResourceList.Count;
    memoryBase = (PUCHAR)ADDRESS_MEMORY_BASE;
    memory32Base = 0;
    ioBase = (PUCHAR)ADDRESS_IO_BASE;
    irqBase = (PUCHAR)ADDRESS_IRQ_BASE;
    dmaBase = (PUCHAR)ADDRESS_DMA_BASE;
    for (pass = 1; pass <= 2; pass++) {

        //
        // First pass we make sure the resources to be set is acceptable.
        // Second pass we actually write the resources to the logical device's
        // configuration space.
        //
        noMemory = 0;
        cmDesc = CmResources->List[0].PartialResourceList.PartialDescriptors;
        for (i = 0; i < count; i++) {
            switch (cmDesc->Type) {
            case CmResourceTypePort:
                 if (pass == 1) {
                     noIo++;
                     if (noIo > NUMBER_IO_DESCRIPTORS ||
                         cmDesc->u.Port.Start.HighPart != 0 ||
                         cmDesc->u.Port.Start.LowPart & 0xffff0000 ||
                         cmDesc->u.Port.Length & 0xffffff00) {
                         return STATUS_INVALID_PARAMETER;
                     }
                 } else {

                     //
                     // Set the Io port base address to logical device configuration space
                     //

                     c = (UCHAR)cmDesc->u.Port.Start.LowPart;
                     PipWriteAddress(ioBase + ADDRESS_IO_BASE_LO);
                     PipWriteData(c);
                     c = (UCHAR)(cmDesc->u.Port.Start.LowPart >> 8);
                     PipWriteAddress(ioBase + ADDRESS_IO_BASE_HI);
                     PipWriteData(c);
                     ioBase += ADDRESS_IO_INCR;
                 }
                 break;
            case CmResourceTypeInterrupt:
                 if (pass == 1) {
                     noIrq++;
                     if (noIrq > NUMBER_IRQ_DESCRIPTORS ||
                         (cmDesc->u.Interrupt.Level & 0xfffffff0)) {
                         return STATUS_INVALID_PARAMETER;
                     }

                     //
                     // See if we can get the interrupt information from possible resource
                     // data.  We need it to set the configuration register.
                     //

                     if (!PipFindIrqInformation(cmDesc->u.Interrupt.Level, BiosRequirements, &information)) {
                         return STATUS_INVALID_PARAMETER;
                     }
                 } else {

                     //
                     // Set the Irq to logical device configuration space
                     //

                     c = (UCHAR)cmDesc->u.Interrupt.Level;
                     PipWriteAddress(irqBase + ADDRESS_IRQ_VALUE);
                     PipWriteData(c);

                     // Set IRQ to high edge or low level.  Explicitly
                     // ignore what was in the requirements as it may
                     // specify low edge or high level which don't
                     // actually work.

                     if (cmDesc->Flags & CM_RESOURCE_INTERRUPT_LATCHED) {
                         c = 2;
                     } else {
                         c = 1;
                     }

                     PipWriteAddress(irqBase + ADDRESS_IRQ_TYPE);
                     PipWriteData(c);

                     DebugPrint((DEBUG_IRQ, "Wrote 0x%x to port %x\n",
                                 (ULONG) c, irqBase));
                     PipWriteAddress(irqBase + ADDRESS_IRQ_TYPE);
                     c = PipReadData();
                     DebugPrint((DEBUG_IRQ, "Read back 0x%x at port %x\n",
                                 (ULONG) c, irqBase));

                     irqBase += ADDRESS_IRQ_INCR;
                 }
                 break;
            case CmResourceTypeDma:
                 if (pass == 1) {
                     noDma++;
                     if (noDma > NUMBER_IRQ_DESCRIPTORS ||
                         (cmDesc->u.Dma.Channel & 0xfffffff8)) {
                         return STATUS_INVALID_PARAMETER;
                     }
                 } else {

                     //
                     // Set the Dma channel to logical device configuration space
                     //

                     c = (UCHAR)cmDesc->u.Dma.Channel;
                     PipWriteAddress(dmaBase + ADDRESS_DMA_VALUE);
                     PipWriteData(c);
                     dmaBase += ADDRESS_DMA_INCR;
                 }
                 break;
            case CmResourceTypeMemory:
                 if (pass == 1) {
                     base = cmDesc->u.Memory.Start.LowPart;
                     limit = base + cmDesc->u.Memory.Length - 1;
                     if (!PipFindMemoryInformation(noMemory, base, limit, BiosRequirements, &tag, &information,NULL)) {
                         return STATUS_INVALID_PARAMETER;
                     } else {
                         if (tag == TAG_MEMORY) {
                              noMemory24++;

                              //
                              // Make sure the lower 8 bits of the base address are zero.
                              //

                              if (noMemory24 > NUMBER_MEMORY_DESCRIPTORS ||
                                  base & 0xff) {
                                  return STATUS_INVALID_PARAMETER;
                              }
                         } else {
                              noMemory32++;
                              if (noMemory32 > NUMBER_32_MEMORY_DESCRIPTORS) {
                                  return STATUS_INVALID_PARAMETER;
                              }
                         }
                     }
                 } else {

                     //
                     // Find information in BiosRequirements to help determine how to  write
                     // the memory configuration space.
                     //

                     base = cmDesc->u.Memory.Start.LowPart;
                     limit = base + cmDesc->u.Memory.Length - 1;
                     PipFindMemoryInformation(noMemory, base, limit, BiosRequirements, &tag, &information,NULL);
                     if (tag == TAG_MEMORY) {
                          PipWriteAddress(memoryBase + ADDRESS_MEMORY_LO);
                          PipWriteData(base >> 0x8);

                          PipWriteAddress(memoryBase + ADDRESS_MEMORY_HI);
                          PipWriteData(base >> 0x10);

                          if ((information & 0x18) == 0) {     // 8 bit memory only
                              c = 0;
                          } else {
                              c = 2;
                          }

                          //
                          // Check range or limit
                          //

                          PipWriteAddress(memoryBase + ADDRESS_MEMORY_CTL);
                          if (PipReadData() & ADDRESS_MEMORY_CTL_LIMIT) {
                              c += ADDRESS_MEMORY_CTL_LIMIT;
                              limit = base + cmDesc->u.Memory.Length;
                          } else {
                              limit = cmDesc->u.Memory.Length; // Range
                              limit = (~limit)+1;
                          }

                          PipWriteAddress(memoryBase + ADDRESS_MEMORY_CTL);
                          PipWriteData(c);

                          PipWriteAddress(memoryBase + ADDRESS_MEMORY_UPPER_LO);
                          PipWriteData((UCHAR)(limit >> 0x8));

                          PipWriteAddress(memoryBase + ADDRESS_MEMORY_UPPER_HI);
                          PipWriteData((UCHAR)(limit >> 0x10));
                          memoryBase += ADDRESS_MEMORY_INCR;
                     } else {
                          tmp = ADDRESS_32_MEMORY_BASE(memory32Base);
                          PipWriteAddress(tmp + ADDRESS_32_MEMORY_B0);
                          PipWriteData(base);

                          PipWriteAddress(tmp + ADDRESS_32_MEMORY_B1);
                          PipWriteData(base >> 0x8);

                          PipWriteAddress(tmp + ADDRESS_32_MEMORY_B2);
                          PipWriteData(base >> 0x10);

                          PipWriteAddress(tmp + ADDRESS_32_MEMORY_B3);
                          PipWriteData(base >> 0x18);

                          switch (information & 0x18) {
                          case 0:      // 8 bit only
                              c = 0;
                          case 8:      // 16 bit only
                          case 0x10:   // 8 and 16 bit supported
                              c = 2;
                              break;
                          case 0x18:   // 32 bit only
                              c = 4;
                              break;
                          }
                          PipWriteAddress(ADDRESS_32_MEMORY_CTL);
                          if (PipReadData() & ADDRESS_MEMORY_CTL_LIMIT) {
                              c += ADDRESS_MEMORY_CTL_LIMIT;
                              limit = base + cmDesc->u.Memory.Length;
                          } else {
                              limit = cmDesc->u.Memory.Length; // Range
                              limit = (~limit) + 1;
                          }
                          PipWriteAddress(ADDRESS_32_MEMORY_CTL);
                          PipWriteData(c);

                          PipWriteAddress(tmp + ADDRESS_32_MEMORY_E0);
                          PipWriteData(limit);

                          PipWriteAddress(tmp + ADDRESS_32_MEMORY_E1);
                          PipWriteData(limit >> 0x8);

                          PipWriteAddress(tmp + ADDRESS_32_MEMORY_E2);
                          PipWriteData(limit >> 0x10);

                          PipWriteAddress(tmp + ADDRESS_32_MEMORY_E3);
                          PipWriteData(limit >> 0x18);
                          memory32Base++;
                     }
                 }
                 noMemory++;
            }
            cmDesc++;
        }
    }

    //
    // Finally, mark all the unused descriptors as disabled.
    //

    for (i = noMemory24; i < NUMBER_MEMORY_DESCRIPTORS; i++) {
        for (j = 0; j < 5; j++) {
            PipWriteAddress(memoryBase + j);
            PipWriteData(0);
        }
        memoryBase += ADDRESS_MEMORY_INCR;
    }
    for (i = noMemory32; i < NUMBER_32_MEMORY_DESCRIPTORS; i++) {
        tmp = ADDRESS_32_MEMORY_BASE(memory32Base);
        for (j = 0; j < 9; j++) {
            PipWriteAddress(tmp + j);
            PipWriteData(0);
        }
        memory32Base++;
    }
    for (i = noIo; i < NUMBER_IO_DESCRIPTORS; i++) {
        for (j = 0; j < 2; j++) {
            PipWriteAddress(ioBase + j);
            PipWriteData(0);
        }
        ioBase += ADDRESS_IO_INCR;
    }
    for (i = noIrq; i < NUMBER_IRQ_DESCRIPTORS; i++) {
        for (j = 0; j < 2; j++) {
            PipWriteAddress(irqBase + j);
            PipWriteData(0);
        }
        irqBase += ADDRESS_IRQ_INCR;
    }
    for (i = noDma; i < NUMBER_DMA_DESCRIPTORS; i++) {
        PipWriteAddress(dmaBase);
        PipWriteData(4);
        dmaBase += ADDRESS_DMA_INCR;
    }


    return STATUS_SUCCESS;
}

VOID
PipLFSRInitiation(
    VOID
    )

/*++

Routine Description:

    This routine insures the LFSR (linear feedback shift register) is in its
    initial state and then performs 32 writes to the ADDRESS port to initiation
    LFSR function.

    Pnp software sends the initiation key to all the Pnp ISA cards to place them
    into configuration mode.  The software then ready to perform isolation
    protocol.

Arguments:

    None.

Return Value:

    None.

--*/
{
    UCHAR seed, bit7;
    ULONG i;

    ASSERT(PipState == PiSWaitForKey);
    //
    // First perform two writes of value zero to insure the LFSR is in the
    // initial state.
    //

    PipWriteAddress (0);
    PipWriteAddress (0);

    //
    // Perform the initiation key.
    //

    seed = LFSR_SEED;               // initial value of 0x6a
    for (i = 0; i < 32; i++) {
        PipWriteAddress (seed);
        bit7=(((seed & 2) >> 1) ^ (seed & 1)) << 7;
        seed =(seed >> 1) | bit7;
    }

    DebugPrint((DEBUG_ISOLATE, "Sent initiation key\n"));
    PipReportStateChange(PiSSleep);
}

VOID
PipIsolateCards (
    OUT PULONG NumberCSNs
    )

/*++

Routine Description:

    This routine performs PnP ISA cards isolation sequence.

Arguments:

    NumberCSNs - supplies the addr of a variable to receive the number of
        Pnp Isa cards isolated.

    ReadDataPort - Supplies the address of a variable to supply ReadData port
        address.

Return Value:

    None.

--*/
{
    USHORT j, i;
    UCHAR  cardId[NUMBER_CARD_ID_BYTES];
    UCHAR  bit, bit7, checksum, byte1, byte2;
    ULONG  csn;


    //
    // First send Initiation Key to all the PNP ISA cards to enable PnP auto-config
    // ports and put all cards into sleep state
    //

    PipLFSRInitiation();

    //
    // Reset all Pnp ISA cards' CSN to 0 and return to wait-for-key state
    //

    PipWriteAddress (CONFIG_CONTROL_PORT);
    PipWriteData (CONTROL_RESET_CSN + CONTROL_WAIT_FOR_KEY);

    DebugPrint((DEBUG_STATE, "Reset CSNs, going to WaitForKey\n"));
    PipReportStateChange(PiSWaitForKey);

    csn=*NumberCSNs = 0;

    //
    // Delay 2 msec for cards to load initial configuration state.
    //

    KeStallExecutionProcessor(2000);     // delay 2 msec

    //
    // Put cards into configuration mode to ready isolation process.
    // The hardware on each PnP Isa card expects 72 pairs of I/O read
    // access to the read data port.
    //

    PipLFSRInitiation();

    //
    // Starting Pnp Isa card isolation process.
    //

    //
    // Send WAKE[CSN=0] to force all cards without CSN into isolation
    // state to set READ DATA PORT.
    //

    PipIsolation();

    KeStallExecutionProcessor(1000);     // delay 1 msec

    DebugPrint((DEBUG_STATE, "Wake all cards without CSN, Isolation\n"));

    //
    // Set read data port to current testing value.
    //

    PipWriteAddress(SET_READ_DATA_PORT);
    PipWriteData((UCHAR)((ULONG_PTR)PipReadDataPort >> 2));

    DebugPrint((DEBUG_STATE, "Set RDP to %x\n", PipReadDataPort));
    //
    // Isolate one PnP ISA card until fail
    //

    PipIsolation();

    while (TRUE) {



        //
        // Read serial isolation port to cause PnP cards in the isolation
        // state to compare one bit of the boards ID.
        //

        PipWriteAddress(SERIAL_ISOLATION_PORT);

        //
        // We need to delay 1 msec prior to starting the first pair of isolation
        // reads and must wait 250usec between each subsequent pair of isolation
        // reads.  This delay gives the ISA cards time to access information from
        // possible very slow storage device.
        //

        KeStallExecutionProcessor(1000); // delay 1 msec

        RtlZeroMemory(cardId, NUMBER_CARD_ID_BYTES);
        checksum = LFSR_SEED;
        for (j = 0; j < NUMBER_CARD_ID_BITS; j++) {

            //
            // Read card id bit by bit
            //

            byte1 = PipReadData();
            byte2 = PipReadData();
            bit = (byte1 == ISOLATION_TEST_BYTE_1) && (byte2 == ISOLATION_TEST_BYTE_2);
            cardId[j / 8] |= bit << (j % 8);
            if (j < CHECKSUMED_BITS) {

                //
                // Calculate checksum and only do it for the first 64 bits
                //

                bit7 = (((checksum & 2) >> 1) ^ (checksum & 1) ^ (bit)) << 7;
                checksum = (checksum >> 1) | bit7;
            }
            KeStallExecutionProcessor(250); // delay 250 usec
        }

        //
        // Verify the card id we read is legitimate
        // First make sure checksum is valid.  Note zero checksum is considered valid.
        //
        DebugPrint((DEBUG_ISOLATE, "Card Bytes: %X %X %X %X %X %X %X %X %X\n",cardId[0],cardId[1],cardId[2],cardId[3],cardId[4],cardId[5],cardId[6],cardId[7],cardId[8]));
        if (cardId[8] == 0 || checksum == cardId[8]) {
            //
            // Next make sure cardId is not zero
            //

            byte1 = 0;
            for (j = 0; j < NUMBER_CARD_ID_BYTES; j++) {
                byte1 |= cardId[j];
            }
            if (byte1 != 0) {

                //
                // Make sure the vender EISA ID bytes are nonzero
                //

                if ((cardId[0] & 0x7f) != 0 && cardId[1] != 0) {

                    //
                    // We found a valid Pnp Isa card, assign it a CSN number
                    //
                    DebugPrint((DEBUG_ISOLATE, "Assigning csn %d\n",csn+1));

                    PipWriteAddress(SET_CSN_PORT);
                    PipWriteData(++csn);
                    if (PipReadData() != csn) {
                        csn--;

                        DebugPrint((DEBUG_ISOLATE, "Assigning csn %d FAILED, bailing!\n",csn+1));

                        PipIsolation();
                        PipSleep();
                        *NumberCSNs = csn;
                        return;
                    }

                    //
                    // Do Wake[CSN] command to put the newly isolated card to
                    // sleep state and other un-isolated cards to isolation
                    // state.
                    //

                    PipIsolation();

                    DebugPrint((DEBUG_STATE, "Put card in Sleep, other in Isolation\n"));

                    continue;     // ... to isolate more cards ...
                }
            }
        }else {

            DebugPrint ((DEBUG_ISOLATE, "invalid read during isolation\n"));
        }
        break;                // could not isolate more cards ...
    }

    //
    // Finaly put all cards into sleep state
    //

    PipSleep();
    *NumberCSNs = csn;
}

ULONG
PipFindNextLogicalDeviceTag (
    IN OUT PUCHAR *CardData,
    IN OUT LONG *Limit
    )

/*++

Routine Description:

    This function searches the Pnp Isa card data for the Next logical
    device tag encountered.  The input *CardData should point to an logical device id tag,
    which is the current logical device tag.  If the *CardData does not point to a logical
    device id tag (but, it must point to some kind of tag), it will be moved to next
    logical device id tag.

Arguments:

    CardData - a variable to supply a pointer to the pnp Isa resource descriptors and to
        receive next logical device tag pointer.

    Limit - a variable to supply the maximum length of the search and to receive the new
        lemit after the search.

Return Value:

    Length of the data between current and next logical device tags, ie the data length
    of the current logical device.
    In case there is no 'next' logical device tag, the returned *CardData = NULL,
    *Limit = zero and the data length of current logical tag is returned as function
    returned value.

--*/
{
    UCHAR tag;
    USHORT size;
    LONG l;
    ULONG retLength;
    PUCHAR p;
    BOOLEAN atIdTag = FALSE;;

    p = *CardData;
    l = *Limit;
    tag = *p;
    retLength = 0;
    while (tag != TAG_COMPLETE_END && l > 0) {

        //
        // Determine the size of the BIOS resource descriptor
        //

        if (!(tag & LARGE_RESOURCE_TAG)) {
            size = (USHORT)(tag & SMALL_TAG_SIZE_MASK);
            size += 1;                          // length of small tag
        } else {
            size = *((USHORT UNALIGNED *)(p + 1));
            size += 3;                          // length of large tag
        }

        p += size;
        retLength += size;
        l -= size;
        tag = *p;
        if ((tag & SMALL_TAG_MASK) == TAG_LOGICAL_ID) {
            *CardData = p;
            *Limit = l;
            return retLength;
        }
    }
    *CardData = NULL;
    *Limit = 0;
    if (tag == TAG_COMPLETE_END) {
        return (retLength + 2);             // add 2 for the length of end tag descriptor
    } else {
        return 0;
    }
}


VOID
PipSelectLogicalDevice (
    IN USHORT Csn,
    IN USHORT LogicalDeviceNumber,
    IN ULONG  Control
    )

/*++

Routine Description:

    This function selects the logical logical device in the specified device.

Arguments:

    Csn - Supplies a CardSelectNumber to select the card.

    LogicalDeviceNumber - supplies a logical device number to select the logical device.

    Control - supplies a variable to specify if the logical device should be enabled.

Return Value:

    None
--*/
{
    UCHAR tmp;

    //
    // Put cards into sleep state
    //

    ASSERT(PipState == PiSWaitForKey);

    PipLFSRInitiation();

    //
    // Send WAKE[CSN] to force the card into config state.
    //

    DebugPrint((DEBUG_STATE, "Select Logical Device\n"));
    PipConfig((UCHAR)Csn);

    //
    // Select the logical device.
    //

    PipWriteAddress(LOGICAL_DEVICE_PORT);
    PipWriteData(LogicalDeviceNumber);
    if (Control == SELECT_AND_ACTIVATE) {

        //
        // If we need to activate the logical device, disable its io range check and
        // then enable the device.
        //

        PipActivateDevice();
    } else if (Control == SELECT_AND_DEACTIVATE) {
        PipDeactivateDevice();
    }

}

NTSTATUS
PipReadCardResourceDataBytes (
    IN USHORT BytesToRead,
    IN PUCHAR Buffer
    )

/*++

Routine Description:

    This function reads specified number of bytes of card resource data .

Arguments:

    BytesToRead - supplies number of bytes to read.

    Buffer - supplies a pointer to a buffer to receive the read bytes.

Return Value:

    None
--*/
{
    USHORT i, j;
    PUCHAR p;
    for (i = 0, p = Buffer; i < BytesToRead; i++, p++) {

        PipWriteAddress(CONFIG_DATA_STATUS_PORT);

        //
        // Waiting for data ready status bit
        //

        j = 0;
        while ((PipReadData() & 1) != 1) {
            if (j == 10000) {
                return STATUS_NO_SUCH_DEVICE;
            }
            KeStallExecutionProcessor(1000); // delay 1 msec
            j++;
        }

        //
        // Read the data ...
        //

        PipWriteAddress(CONFIG_DATA_PORT);
        *p = PipReadData();
    }
    return STATUS_SUCCESS;

}

USHORT
PipIrqLevelRequirementsFromDeviceData(
    IN PUCHAR BiosRequirements,
    IN ULONG Length
    )
/*++

Routine Description:

    This routine searches the resource data for IRQ tags and extracts
    information on whether edge/level is specified.  This is on a per
    logical device basis.

  Arguments:

    BiosRequirements - the per-device tags.

    Length - Length of per-device tag area.

Return Value:

    edge/level as specified by the device requirements.

--*/
{
    UCHAR tag, level;
    ULONG increment;
    USHORT irqFlags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
    PPNP_IRQ_DESCRIPTOR biosDesc;
    BOOLEAN sawIrq = FALSE;

    //
    // Skip current logical id tag
    //

    tag = *BiosRequirements;
    ASSERT((tag & SMALL_TAG_MASK) == TAG_LOGICAL_ID);
    BiosRequirements += (tag & SMALL_TAG_SIZE_MASK) + 1;

    //
    // Search the possible resource list to get the information
    // for the Irq.
    //

    tag = *BiosRequirements;
    while ((tag != TAG_COMPLETE_END) && ((tag & SMALL_TAG_MASK) != TAG_LOGICAL_ID)) {
        if ((tag & SMALL_TAG_MASK) == TAG_IRQ) {
            sawIrq = TRUE;
            biosDesc = (PPNP_IRQ_DESCRIPTOR)BiosRequirements;
            if ((tag & SMALL_TAG_SIZE_MASK) == 2) {
                irqFlags = CM_RESOURCE_INTERRUPT_LATCHED;
            } else {
                level = biosDesc->Information;
                DebugPrint((DEBUG_IRQ, "Irq req info is %x\n", (ULONG) level));
                if (level == 0xF) {
                    // register is broken, assume edge
                    irqFlags = CM_RESOURCE_INTERRUPT_LATCHED;
                } else if (level & 0x3) {
                    irqFlags = CM_RESOURCE_INTERRUPT_LATCHED;
                } else if (level & 0xC) {
                    irqFlags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
                }
            }
        }
        if (tag & LARGE_RESOURCE_TAG) {
            increment = *((USHORT UNALIGNED *)(BiosRequirements + 1));
            increment += 3;     // length of large tag
        } else {
            increment = tag & SMALL_TAG_SIZE_MASK;
            increment += 1;     // length of small tag
        }
        BiosRequirements += increment;
        tag = *BiosRequirements;
    }

    if (!sawIrq) {
        return CM_RESOURCE_INTERRUPT_LATCHED;
    }

    return irqFlags;
}

VOID
PipFixBootConfigIrqs(
    IN PCM_RESOURCE_LIST BootResources,
    IN USHORT irqFlags
    )
/*++

Routine Description:

    This routine modifies the boot config resources list to reflect
    whether the devices's irqs should be considered edge or level.
    This is on a per logical device basis.

  Arguments:

    BootResources - Boot config as determined by PipReadDeviceResources()

    irqFlags - level/edge setting to apply to boot config resources

--*/
{
    PCM_FULL_RESOURCE_DESCRIPTOR cmFullDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmPartDesc;
    ULONG count = 0, size, i, j;

    if (BootResources == NULL) {
        return;
    }

    cmFullDesc = &BootResources->List[0];
    for (i = 0; i < BootResources->Count; i++) {
        cmPartDesc = &cmFullDesc->PartialResourceList.PartialDescriptors[0];
        for (j = 0; j < cmFullDesc->PartialResourceList.Count; j++) {
            size = 0;
            if (cmPartDesc->Type == CmResourceTypeInterrupt) {

                cmPartDesc->Flags = irqFlags;

                if (cmPartDesc->Flags & CM_RESOURCE_INTERRUPT_LATCHED) {
                    cmPartDesc->ShareDisposition = CmResourceShareDeviceExclusive;
                }
            } else if (cmPartDesc->Type == CmResourceTypeDeviceSpecific) {
                    size = cmPartDesc->u.DeviceSpecificData.DataSize;
            }
            cmPartDesc++;
            cmPartDesc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)cmPartDesc + size);
        }
        cmFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)cmPartDesc;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\isapnp\fdopnp.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    fdopnp.c

Abstract:

    This file contains the PNP IRP dispatch code for FDOs

Environment:

    Kernel Mode Driver.

Revision History:

--*/

#include "busp.h"
#include "pnpisa.h"
#include <wdmguid.h>
#include "halpnpp.h"


//
// Function Prototypes
//

NTSTATUS
PiDeferProcessingFdo(
    IN PPI_BUS_EXTENSION BusExtension,
    IN OUT PIRP Irp
    );

NTSTATUS
PiStartFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiQueryRemoveStopFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiCancelRemoveStopFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiStopFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiQueryDeviceRelationsFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiRemoveFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiQueryLegacyBusInformationFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiQueryInterfaceFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiQueryPnpDeviceState(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiSurpriseRemoveFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,PiDispatchPnpFdo)
#pragma alloc_text(PAGE,PiDeferProcessingFdo)
#pragma alloc_text(PAGE,PiStartFdo)
#pragma alloc_text(PAGE,PiQueryRemoveStopFdo)
#pragma alloc_text(PAGE,PiRemoveFdo)
#pragma alloc_text(PAGE,PiCancelRemoveStopFdo)
#pragma alloc_text(PAGE,PiStopFdo)
#pragma alloc_text(PAGE,PiQueryRemoveStopFdo)
#pragma alloc_text(PAGE,PiCancelRemoveStopFdo)
#pragma alloc_text(PAGE,PiQueryDeviceRelationsFdo)
#pragma alloc_text(PAGE,PiQueryInterfaceFdo)
#pragma alloc_text(PAGE,PipPassIrp)
#pragma alloc_text(PAGE,PiQueryLegacyBusInformationFdo)
#pragma alloc_text(PAGE,PiQueryPnpDeviceState)
#pragma alloc_text(PAGE,PiSurpriseRemoveFdo)
#endif


//
// PNP IRP Dispatch table for FDOs
//

PPI_DISPATCH PiPnpDispatchTableFdo[] = {
    PiStartFdo,                             // IRP_MN_START_DEVICE
    PiQueryRemoveStopFdo,                   // IRP_MN_QUERY_REMOVE_DEVICE
    PiRemoveFdo,                            // IRP_MN_REMOVE_DEVICE
    PiCancelRemoveStopFdo,                  // IRP_MN_CANCEL_REMOVE_DEVICE
    PiStopFdo,                              // IRP_MN_STOP_DEVICE
    PiQueryRemoveStopFdo,                   // IRP_MN_QUERY_STOP_DEVICE
    PiCancelRemoveStopFdo,                  // IRP_MN_CANCEL_STOP_DEVICE
    PiQueryDeviceRelationsFdo,              // IRP_MN_QUERY_DEVICE_RELATIONS
    PiQueryInterfaceFdo,                    // IRP_MN_QUERY_INTERFACE
    PipPassIrp,                             // IRP_MN_QUERY_CAPABILITIES
    PipPassIrp,                             // IRP_MN_QUERY_RESOURCES
    PipPassIrp,                             // IRP_MN_QUERY_RESOURCE_REQUIREMENTS
    PipPassIrp,                             // IRP_MN_QUERY_DEVICE_TEXT
    PipPassIrp,                             // IRP_MN_FILTER_RESOURCE_REQUIREMENTS
    PipPassIrp,                             // Unused
    PipPassIrp,                             // IRP_MN_READ_CONFIG
    PipPassIrp,                             // IRP_MN_WRITE_CONFIG
    PipPassIrp,                             // IRP_MN_EJECT
    PipPassIrp,                             // IRP_MN_SET_LOCK
    PipPassIrp,                             // IRP_MN_QUERY_ID
    PiQueryPnpDeviceState,                  // IRP_MN_QUERY_PNP_DEVICE_STATE
    PipPassIrp,                             // IRP_MN_QUERY_BUS_INFORMATION
    PipPassIrp,                             // IRP_MN_DEVICE_USAGE_NOTIFICATION
    PiSurpriseRemoveFdo,                    // IRP_MN_SURPRISE_REMOVAL
    PiQueryLegacyBusInformationFdo          // IRP_MN_QUERY_LEGACY_BUS_INFORMATION
};

//
// Function declarations
//

NTSTATUS
PiDispatchPnpFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles IRP_MJ_PNP IRPs for FDOs.

Arguments:

    DeviceObject - Pointer to the FDO for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    PPI_BUS_EXTENSION busExtension;

    PAGED_CODE();

    //
    // Get a pointer to our stack location and take appropriate action based
    // on the minor function.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    busExtension = DeviceObject->DeviceExtension;

    if (irpSp->MinorFunction > IRP_MN_PNP_MAXIMUM_FUNCTION) {

        return PipPassIrp(DeviceObject, Irp);

    } else {

        status = PiPnpDispatchTableFdo[irpSp->MinorFunction](DeviceObject, Irp);

    }



    return status;
} //PipDispatchPnpFdo

NTSTATUS
PiPnPFdoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is used to defer processing of an IRP until drivers
    lower in the stack including the bus driver have done their
    processing.

    This routine triggers the event to indicate that processing of the
    irp can now continue.

Arguments:

    DeviceObject - Pointer to the FDO for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/

{
    KeSetEvent((PKEVENT) Context, EVENT_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
PiDeferProcessingFdo(
    IN PPI_BUS_EXTENSION BusExtension,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    This routine is used to defer processing of an IRP until drivers
    lower in the stack including the bus driver have done their
    processing.

    This routine uses an IoCompletion routine along with an event to
    wait until the lower level drivers have completed processing of
    the irp.

Arguments:

    BusExtension - FDO extension for the FDO devobj in question

    Irp - Pointer to the IRP_MJ_PNP IRP to defer

Return Value:

    NT status.

--*/
{
    KEVENT event;
    NTSTATUS status;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // Set our completion routine
    //

    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp,
                           PiPnPFdoCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE
                           );
    status =  IoCallDriver(BusExtension->AttachedDevice, Irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = Irp->IoStatus.Status;
    }

    return status;
}

NTSTATUS
PiStartFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PPI_BUS_EXTENSION busExtension;
    NTSTATUS status;

    DebugPrint((DEBUG_PNP,
       "*** StartDevice irp received FDO: %x\n",DeviceObject));

    busExtension = DeviceObject->DeviceExtension;

    //
    // Postpones start operations until all lower drivers have
    // finished with the IRP.
    //

    status = PiDeferProcessingFdo(busExtension, Irp);
    if (NT_SUCCESS(status)) {
        busExtension->SystemPowerState = PowerSystemWorking;
        busExtension->DevicePowerState = PowerDeviceD0;
    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
} // PiStartFdo


NTSTATUS
PiQueryRemoveStopFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PPI_BUS_EXTENSION busExtension;

    DebugPrint((DEBUG_PNP,
       "*** QR/R/StopDevice irp received FDO: %x\n",DeviceObject));

    busExtension = DeviceObject->DeviceExtension;

    KeWaitForSingleObject( &IsaBusNumberLock,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL );

    if (busExtension->BusNumber != 0) {

        status = PipReleaseInterfaces(busExtension);
        ActiveIsaCount--;
        busExtension->Flags |= DF_QUERY_STOPPED;

    } else {

        Irp->IoStatus.Status = status = STATUS_UNSUCCESSFUL;
        IoCompleteRequest (Irp,IO_NO_INCREMENT);
    }

    KeSetEvent( &IsaBusNumberLock,
                0,
                FALSE );

    if (NT_SUCCESS(status)) {

        Irp->IoStatus.Status =  STATUS_SUCCESS;
        status = PipPassIrp(DeviceObject, Irp);
    }

    DebugPrint((DEBUG_PNP, "QR/R/Stop Device returning: %x\n",status));

    return status;

} // PiQueryRemoveStopFdo



NTSTATUS
PiCancelRemoveStopFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PPI_BUS_EXTENSION busExtension;

    DebugPrint((DEBUG_PNP,
                "*** Cancel R/Stop Device irp received FDO: %x\n",DeviceObject));

    busExtension = DeviceObject->DeviceExtension;

    status = PiDeferProcessingFdo(busExtension, Irp);
    // NTRAID#53498
    // ASSERT(status == STATUS_SUCCESS);
    // Uncomment after PCI state machine is fixed to not fail bogus stops

    //
    // Add back to active count
    //
    KeWaitForSingleObject( &IsaBusNumberLock,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL );

    if (busExtension->Flags & DF_QUERY_STOPPED) {
        ActiveIsaCount++;
    }

    busExtension->Flags &= ~DF_QUERY_STOPPED;


    KeSetEvent( &IsaBusNumberLock,
                0,
                FALSE );

    status = PipRebuildInterfaces (busExtension);
    ASSERT(status == STATUS_SUCCESS);
    
    PipCompleteRequest(Irp, STATUS_SUCCESS, NULL);

    DebugPrint((DEBUG_PNP, "Cancel R/Stop Device returning: %x\n",status));
    return STATUS_SUCCESS;
} // PiCancelRemoveStopFdo



NTSTATUS
PiStopFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PPI_BUS_EXTENSION busExtension;
    NTSTATUS status;

    DebugPrint((DEBUG_PNP,
       "*** Stop Device irp received FDO: %x\n",DeviceObject));

    busExtension = DeviceObject->DeviceExtension;



    KeWaitForSingleObject( &IsaBusNumberLock,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL );

    //
    //Actually clear the bitmap
    //
    ASSERT (RtlAreBitsSet (BusNumBM,busExtension->BusNumber,1));
    RtlClearBits (BusNumBM,busExtension->BusNumber,1);

    KeSetEvent( &IsaBusNumberLock,
                0,
                FALSE );


    busExtension->DevicePowerState = PowerDeviceD3;
    //
    // Handled in QueryStop, pass it down.
    //
    Irp->IoStatus.Status =  STATUS_SUCCESS;

    status = PipPassIrp (DeviceObject,Irp);

    DebugPrint((DEBUG_PNP, "Stop Device returning: %x\n",status));

    return status;
} // PiStopFdo



NTSTATUS
PiQueryDeviceRelationsFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PPI_BUS_EXTENSION busExtension;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_RELATIONS deviceRelations;
    PDEVICE_INFORMATION deviceInfo;
    PSINGLE_LIST_ENTRY deviceLink;
    BOOLEAN creatingRDP=FALSE,accessHW;
    NTSTATUS status;

    DebugPrint((DEBUG_PNP, "QueryDeviceRelations FDO %x\n",
                DeviceObject));

    busExtension = DeviceObject->DeviceExtension;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

#if ISOLATE_CARDS

    //
    // Only support BusRelations on PnpIsa bus PDO.
    //
    switch (irpSp->Parameters.QueryDeviceRelations.Type) {
        case  BusRelations: {

            //
            // Isolation may have been disabled via registry key.  In
            // that case, never enumerate an RDP.
            //
            // Note: Must return success and empty relations list
            // *RATHER* than just passing the irp down to accomplish
            // the same task due because of assumptions in the pnpres
            // code.
            //
            if (PipIsolationDisabled) {
                deviceRelations = ExAllocatePool(PagedPool,
                                                 sizeof(DEVICE_RELATIONS));
                if (deviceRelations) {
                    deviceRelations->Count = 0;
                    Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;
                    Irp->IoStatus.Status = STATUS_SUCCESS;
                } else {
                    PipCompleteRequest(Irp,STATUS_INSUFFICIENT_RESOURCES,NULL);
                    return STATUS_INSUFFICIENT_RESOURCES;
                }
                break;
            }

            //
            // All relations exist on the 'root' isa bus. (don't ask)
            //
            if (busExtension->BusNumber != 0) {
                break;
            }

            if (PipRDPNode) {
                //
                // overload the notion of "creating" for multi-bridge systems
                //
                if (PipRDPNode->Flags & (DF_PROCESSING_RDP|DF_ACTIVATED)) {
                    creatingRDP=TRUE;
                }
            }



            if (PipReadDataPort == NULL && !creatingRDP && !PipRDPNode ) {

                status = PipCreateReadDataPort(busExtension);
                if (!NT_SUCCESS(status)) {
                    PipCompleteRequest(Irp, status, NULL);
                    return status;
                }

                creatingRDP=TRUE;
            }

            if ((PipRDPNode && (creatingRDP) &&
               !(PipRDPNode->Flags & DF_ACTIVATED)) ||

                (PipRDPNode && (PipRDPNode->Flags & DF_REMOVED))) {

                PSINGLE_LIST_ENTRY deviceLink;

                deviceRelations = (PDEVICE_RELATIONS) ExAllocatePool(
                                     PagedPool,
                                     sizeof(DEVICE_RELATIONS) );

                if (deviceRelations) {

                    //
                    // If a device exists, mark it as disappeared so
                    // it's not reported again
                    //
                    PipLockDeviceDatabase();
                    deviceLink = busExtension->DeviceList.Next;
                    while (deviceLink) {
                        deviceInfo = CONTAINING_RECORD (deviceLink, DEVICE_INFORMATION, DeviceList);
                        if (!(deviceInfo->Flags & DF_READ_DATA_PORT)) {
                            deviceInfo->Flags &= ~DF_ENUMERATED;
                        }
                        deviceLink = deviceInfo->DeviceList.Next;
                    }
                    PipUnlockDeviceDatabase();

                    deviceRelations->Count = 1;

                    DebugPrint((DEBUG_PNP,
                               "QueryDeviceRelations handing back the FDO\n"));
                    ObReferenceObject(PipRDPNode->PhysicalDeviceObject);
                    deviceRelations->Objects[0] = PipRDPNode->PhysicalDeviceObject;
                    (PDEVICE_RELATIONS)Irp->IoStatus.Information = deviceRelations;
                    Irp->IoStatus.Status = STATUS_SUCCESS;
                    break;
                } else {
                    PipCompleteRequest(Irp, STATUS_INSUFFICIENT_RESOURCES,NULL);
                    return STATUS_INSUFFICIENT_RESOURCES;
                }
            }


            //
            // Perform bus check to enumerate all the device under pnpisa bus.
            //


            PipLockDeviceDatabase();

            if ((PipRDPNode->Flags & (DF_ACTIVATED|DF_QUERY_STOPPED)) == DF_ACTIVATED) {
                accessHW = TRUE;
                deviceLink = busExtension->DeviceList.Next;
                while (deviceLink) {
                    deviceInfo = CONTAINING_RECORD (deviceLink,
                                                    DEVICE_INFORMATION,
                                                    DeviceList);
                    if (!(deviceInfo->Flags & DF_READ_DATA_PORT)) {
                        accessHW = FALSE;
                        DebugPrint((DEBUG_PNP,
                                    "QueryDeviceRelations: Found 1 card, no more isolation\n"));
                        break;
                    }
                    deviceLink = deviceInfo->DeviceList.Next;
                }
            } else {
                accessHW = FALSE;
            }

            if (PipRDPNode->Flags & DF_NEEDS_RESCAN) {
                DebugPrint((DEBUG_PNP,
                            "QueryDeviceRelations: Force rescan\n"));
                PipRDPNode->Flags &= ~DF_NEEDS_RESCAN;
                accessHW = TRUE;
            }

            if (accessHW) {
                PipCheckBus(busExtension);
            } else {
                DebugPrint((DEBUG_PNP, "QueryDeviceRelations: Using cached data\n"));
            }

            status = PipQueryDeviceRelations(
                         busExtension,
                         (PDEVICE_RELATIONS *)&Irp->IoStatus.Information,
                         FALSE );
            PipUnlockDeviceDatabase();
            Irp->IoStatus.Status = status;
            if (!NT_SUCCESS(status)) {
                PipCompleteRequest(Irp, status, NULL);
                return status;
            }
        }
        break;
        case EjectionRelations: {

            if (PipRDPNode) {
                deviceRelations = (PDEVICE_RELATIONS) ExAllocatePool(
                                     PagedPool,
                                     sizeof(DEVICE_RELATIONS) );
                if (deviceRelations) {
                    deviceRelations->Count = 1;

                    ObReferenceObject(PipRDPNode->PhysicalDeviceObject);
                    deviceRelations->Objects[0] = PipRDPNode->PhysicalDeviceObject;
                    (PDEVICE_RELATIONS)Irp->IoStatus.Information = deviceRelations;
                    Irp->IoStatus.Status = STATUS_SUCCESS;
                } else {
                    PipCompleteRequest(Irp,STATUS_INSUFFICIENT_RESOURCES,NULL);
                    return STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        }
        break;
    }
#else
    if (irpSp->Parameters.QueryDeviceRelations.Type == BusRelations &&
        busExtension->BusNumber == 0) {

        deviceRelations = (PDEVICE_RELATIONS) ExAllocatePool(
            PagedPool,
            sizeof(DEVICE_RELATIONS) );
        if (deviceRelations) {
            deviceRelations->Count = 0;
            (PDEVICE_RELATIONS)Irp->IoStatus.Information = deviceRelations;
            Irp->IoStatus.Status = STATUS_SUCCESS;
        } else {
            PipCompleteRequest(Irp,STATUS_INSUFFICIENT_RESOURCES,NULL);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }
#endif

    return PipPassIrp(DeviceObject, Irp);
} // PiQueryDeviceRelationsFdo



NTSTATUS
PiRemoveFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PPI_BUS_EXTENSION busExtension;
    PSINGLE_LIST_ENTRY child;
    PBUS_EXTENSION_LIST busList,prevBus;
    USHORT count=0;


    DebugPrint((DEBUG_PNP,
       "*** Remove Device irp received FDO: %x\n",DeviceObject));

    busExtension = DeviceObject->DeviceExtension;


     //
     // Clear the entry in the BM. Count dropped in
     // Query Remove.
     //
    KeWaitForSingleObject( &IsaBusNumberLock,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL );

    if (!(busExtension->Flags & DF_SURPRISE_REMOVED)) {

#ifdef DBG
         ASSERT (RtlAreBitsSet (BusNumBM,busExtension->BusNumber,1));
#endif

         RtlClearBits (BusNumBM,busExtension->BusNumber,1);
    }

#if ISOLATE_CARDS

     PipLockDeviceDatabase();

     //
     // Walk the list of children and delete them
     //
     child=PopEntryList (&busExtension->DeviceList);
     while (child) {
         ASSERT (CONTAINING_RECORD (child, DEVICE_INFORMATION,DeviceList)->PhysicalDeviceObject);
         //
         // This pulls them from the list!
         //
         count ++;
         if (CONTAINING_RECORD (child, DEVICE_INFORMATION,DeviceList)->Flags & DF_READ_DATA_PORT) {
             //
             // Force the recreate of the RDP
             //
             PipCleanupAcquiredResources (busExtension);
             PipReadDataPort = NULL;
             PipRDPNode = NULL;
         } else {
             PipReleaseDeviceResources ((PDEVICE_INFORMATION)child);

         }
         IoDeleteDevice (CONTAINING_RECORD (child, DEVICE_INFORMATION,DeviceList)->PhysicalDeviceObject);
         child=PopEntryList (&busExtension->DeviceList);
     }

     PipUnlockDeviceDatabase();
     
#endif
     //
     // Delete this extension.
     //
     prevBus= busList = PipBusExtension;

     ASSERT (busList != NULL);

     while (busList->BusExtension != busExtension) {
         prevBus= busList;
         busList = busList->Next;
         ASSERT (busList != NULL);
     }
     //
     // Remove the node
     //
     if (prevBus == busList) {
         //
         // First Node.
         //
         PipBusExtension=busList->Next;
     }else  {
         prevBus->Next = busList->Next;
     }

     ExFreePool (busList);
     KeSetEvent( &IsaBusNumberLock,
                 0,
                 FALSE );


     if (count  > 0 ) {
         //
         // If we STILL have an ISA bus. Do this.
         //
         if (ActiveIsaCount > 0 ) {
             ASSERT (PipBusExtension->BusExtension);
             IoInvalidateDeviceRelations (PipBusExtension->BusExtension->PhysicalBusDevice,BusRelations);
         }
     }

#if ISOLATE_CARDS
     //
     // Cleanup all the resources on the last remove.
     //
     if (!(busExtension->Flags & DF_SURPRISE_REMOVED)) {
         PipCleanupAcquiredResources (busExtension);
     }
#endif

     //
     // The PnpISa bus PDO is being removed...
     //
     IoDetachDevice(busExtension->AttachedDevice);
     Irp->IoStatus.Status=STATUS_SUCCESS;
     status = PipPassIrp(DeviceObject, Irp);
     busExtension->AttachedDevice = NULL;
     busExtension->Flags  |= DF_DELETED;
     busExtension->DevicePowerState = PowerDeviceD3;
     IoDeleteDevice(busExtension->FunctionalBusDevice);
     return status;

} // PiRemoveFdo


NTSTATUS
PiQueryLegacyBusInformationFdo(
                               IN PDEVICE_OBJECT DeviceObject,
                               IN OUT PIRP Irp
                               )
{
    PLEGACY_BUS_INFORMATION legacyBusInfo;
    PVOID information = NULL;
    PPI_BUS_EXTENSION busExtension;
    NTSTATUS status;

    busExtension = DeviceObject->DeviceExtension;

    legacyBusInfo = (PLEGACY_BUS_INFORMATION) ExAllocatePool(PagedPool, sizeof(LEGACY_BUS_INFORMATION));
    if (legacyBusInfo) {
        legacyBusInfo->BusTypeGuid = GUID_BUS_TYPE_ISAPNP;
        legacyBusInfo->LegacyBusType = Isa;
        legacyBusInfo->BusNumber = busExtension->BusNumber;
        information = legacyBusInfo;
        status = STATUS_SUCCESS;
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (NT_SUCCESS(status)) {

        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = (ULONG_PTR) information;
        return PipPassIrp(DeviceObject, Irp);

    } else {

        PipCompleteRequest (Irp,status,NULL);
        return status;
    }
}


NTSTATUS
PiQueryInterfaceFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PPI_BUS_EXTENSION busExtension;

    busExtension = DeviceObject->DeviceExtension;

    //
    // We are a FDO - check if we are being asked for an interface we
    // support
    //

    status = PiQueryInterface(busExtension, Irp);

    if (NT_SUCCESS(status)) {

        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        return PipPassIrp(DeviceObject, Irp);

    } else if (status == STATUS_NOT_SUPPORTED) {

        return PipPassIrp(DeviceObject, Irp);

    } else {

        PipCompleteRequest (Irp,status,NULL);
        return status;
    }

} // PiQueryInterfaceFdo




NTSTATUS
PiQueryPnpDeviceState(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{

    PPI_BUS_EXTENSION busExtension;

    busExtension = DeviceObject->DeviceExtension;

    //
    // We are a FDO
    //

    (PNP_DEVICE_STATE) Irp->IoStatus.Information |= PNP_DEVICE_NOT_DISABLEABLE;
    Irp->IoStatus.Status = STATUS_SUCCESS;
    return PipPassIrp(DeviceObject, Irp);

} // PiQueryPnpDeviceState








NTSTATUS
PiSurpriseRemoveFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{

    NTSTATUS status;
    PPI_BUS_EXTENSION busExtension;

    DebugPrint((DEBUG_PNP,
       "*** Surprise Remove Device irp received FDO: %x\n",DeviceObject));

    busExtension = DeviceObject->DeviceExtension;


     //
     // Clear the entry in the BM. Count dropped in
     // Query Remove.
     //
    KeWaitForSingleObject( &IsaBusNumberLock,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL );

#ifdef DBG
     ASSERT (RtlAreBitsSet (BusNumBM,busExtension->BusNumber,1));
#endif
     RtlClearBits (BusNumBM,busExtension->BusNumber,1);




     KeSetEvent( &IsaBusNumberLock,
                 0,
                 FALSE );

#if ISOLATE_CARDS
     PipCleanupAcquiredResources (busExtension);
#endif

     //
     // The PnpISa bus PDO is being removed...
     //
     Irp->IoStatus.Status=STATUS_SUCCESS;
     status = PipPassIrp(DeviceObject, Irp);

     busExtension->AttachedDevice = NULL;
     busExtension->Flags  |= DF_SURPRISE_REMOVED;
     busExtension->DevicePowerState = PowerDeviceD3;
     return status;

} // PiSurpriseRemoveFdo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\isapnp\pbios.h ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    pbiosp.h

Abstract:

    PnP BIOS/ISA configuration data definitions

Author:

    Shie-Lin Tzong (shielint) April 12, 1995

Revision History:

--*/

//#include "nthal.h"
//#include "hal.h"

//
// Constants
//

#define SMALL_RESOURCE_TAG          (UCHAR)(0x00)
#define LARGE_RESOURCE_TAG          (UCHAR)(0x80)
#define SMALL_TAG_MASK              0xf8
#define SMALL_TAG_SIZE_MASK         7

//
// Small Resouce Tags with length bits stripped off
//

#define TAG_VERSION                 0x08
#define TAG_LOGICAL_ID              0x10
#define TAG_COMPATIBLE_ID           0x18
#define TAG_IRQ                     0x20
#define TAG_DMA                     0x28
#define TAG_START_DEPEND            0x30
#define TAG_END_DEPEND              0x38
#define TAG_IO                      0x40
#define TAG_IO_FIXED                0x48
#define TAG_VENDOR                  0x70
#define TAG_END                     0x78

//
// Large Resouce Tags
//

#define TAG_MEMORY                  0x81
#define TAG_ANSI_ID                 0x82
#define TAG_UNICODE_ID              0x83
#define TAG_LVENDOR                 0x84
#define TAG_MEMORY32                0x85
#define TAG_MEMORY32_FIXED          0x86

//
// Complete TAG if applicable.
//

#define TAG_COMPLETE_COMPATIBLE_ID  0x1C
#define TAG_COMPLETE_END            0x79

#include "pshpack1.h"

//
// PNP ISA Port descriptor definition
//

typedef struct _PNP_PORT_DESCRIPTOR_ {
    UCHAR   Tag;                    // 01000111B, small item name = 08, length = 7
    UCHAR   Information;            // bit [0] = 1 device decodes full 16 bit addr
                                    //         = 0 device decodes ISA addr bits[9-0]
    USHORT  MinimumAddress;
    USHORT  MaximumAddress;
    UCHAR   Alignment;              // Increment in 1 byte blocks
    UCHAR   Length;                 // # contiguous Port requested
} PNP_PORT_DESCRIPTOR, *PPNP_PORT_DESCRIPTOR;

//
// PNP ISA fixed Port descriptor definition
//

typedef struct _PNP_FIXED_PORT_DESCRIPTOR_ {
    UCHAR   Tag;                    // 01001011B, small item name = 09, length = 3
    USHORT  MinimumAddress;
    UCHAR   Length;                 // # contiguous Port requested
} PNP_FIXED_PORT_DESCRIPTOR, *PPNP_FIXED_PORT_DESCRIPTOR;

//
// PNP ISA IRQ descriptor definition
//

typedef struct _PNP_IRQ_DESCRIPTOR_ {
    UCHAR   Tag;                    // 0010001XB small item name = 4 length = 2/3
    USHORT  IrqMask;                // bit 0 is irq 0
    UCHAR   Information;            // Optional
} PNP_IRQ_DESCRIPTOR, *PPNP_IRQ_DESCRIPTOR;

//
// Masks for PNP_IRQ_DESCRIPTOR Information byte
//

#define PNP_IRQ_LEVEL_MASK          0xC
#define PNP_IRQ_EDGE_MASK           0x3

//
// PNP ISA DMA descriptor definition
//

typedef struct _PNP_DMA_DESCRIPTOR_ {
    UCHAR   Tag;                    // 00101010B, small item name = 05, length = 2
    UCHAR   ChannelMask;            // bit 0 is channel 0
    UCHAR   Flags;                  // see spec
} PNP_DMA_DESCRIPTOR, *PPNP_DMA_DESCRIPTOR;

//
// PNP ISA MEMORY descriptor
//

typedef struct _PNP_MEMORY_DESCRIPTOR_ {
    UCHAR   Tag;                    // 10000001B, Large item name = 1
    USHORT  Length;                 // Length of the descriptor = 9
    UCHAR   Information;            // See def below
    USHORT  MinimumAddress;         // address bit [8-23]
    USHORT  MaximumAddress;         // address bit [8-23]
    USHORT  Alignment;              // 0x0000 = 64KB
    USHORT  MemorySize;             // In 256 byte blocks
} PNP_MEMORY_DESCRIPTOR, *PPNP_MEMORY_DESCRIPTOR;

//
// PNP ISA MEMORY32 descriptor
//

typedef struct _PNP_MEMORY32_DESCRIPTOR_ {
    UCHAR   Tag;                    // 10000101B, Large item name = 5
    USHORT  Length;                 // Length of the descriptor = 17
    UCHAR   Information;            // See def below
    ULONG   MinimumAddress;         // 32 bit addr
    ULONG   MaximumAddress;         // 32 bit addr
    ULONG   Alignment;              // 32 bit alignment
    ULONG   MemorySize;             // 32 bit length
} PNP_MEMORY32_DESCRIPTOR, *PPNP_MEMORY32_DESCRIPTOR;

//
// PNP ISA FIXED MEMORY32 descriptor
//

typedef struct _PNP_FIXED_MEMORY32_DESCRIPTOR_ {
    UCHAR   Tag;                    // 10000110B, Large item name = 6
    USHORT  Length;                 // Length of the descriptor = 9
    UCHAR   Information;            // See def below
    ULONG   BaseAddress;            // 32 bit addr
    ULONG   MemorySize;             // 32 bit length
} PNP_FIXED_MEMORY32_DESCRIPTOR, *PPNP_FIXED_MEMORY32_DESCRIPTOR;

#define PNP_MEMORY_ROM_MASK            0x40
#define PNP_MEMORY_SHADOWABLE_MASK     0x20
#define PNP_MEMORY_CONTROL_MASK        0x18
    #define PNP_MEMORY_CONTROL_8BIT       00
    #define PNP_MEMORY_CONTROL_16BIT      01
    #define PNP_MEMORY_CONTROL_8AND16BIT  02
    #define PNP_MEMORY_CONTROL_32BIT      03
#define PNP_MEMORY_SUPPORT_TYPE_MASK   04
#define PNP_MEMORY_CACHE_SUPPORT_MASK  02
#define PNP_MEMORY_WRITE_STATUS_MASK   01

#define UNKNOWN_DOCKING_IDENTIFIER     0xffffffff
#define UNABLE_TO_DETERMINE_DOCK_CAPABILITIES 0x89
#define FUNCTION_NOT_SUPPORTED         0x82
#define SYSTEM_NOT_DOCKED              0x87

//
// Pnp BIOS device node structure
//

typedef struct _PNP_BIOS_DEVICE_NODE {
    USHORT  Size;
    UCHAR   Node;
    ULONG   ProductId;
    UCHAR   DeviceType[3];
    USHORT  DeviceAttributes;
    // followed by AllocatedResourceBlock, PossibleResourceBlock
    // and CompatibleDeviceId
} PNP_BIOS_DEVICE_NODE, *PPNP_BIOS_DEVICE_NODE;

//
// DeviceType definition
//

#define BASE_TYPE_DOCKING_STATION      0xA

//
// Device attributes definitions
//

#define DEVICE_DOCKING                 0x20
#define DEVICE_REMOVABLE               0x40

//
// Pnp BIOS Installation check
//

typedef struct _PNP_BIOS_INSTALLATION_CHECK {
    UCHAR   Signature[4];              // $PnP (ascii)
    UCHAR   Revision;
    UCHAR   Length;
    USHORT  ControlField;
    UCHAR   Checksum;
    ULONG   EventFlagAddress;          // Physical address
    USHORT  RealModeEntryOffset;
    USHORT  RealModeEntrySegment;
    USHORT  ProtectedModeEntryOffset;
    ULONG   ProtectedModeCodeBaseAddress;
    ULONG   OemDeviceId;
    USHORT  RealModeDataBaseAddress;
    ULONG  ProtectedModeDataBaseAddress;
} PNP_BIOS_INSTALLATION_CHECK, *PPNP_BIOS_INSTALLATION_CHECK;

#include "poppack.h"

//
// Pnp BIOS ControlField masks
//

#define PNP_BIOS_CONTROL_MASK          0x3
#define PNP_BIOS_EVENT_NOT_SUPPORTED   0
#define PNP_BIOS_EVENT_POLLING         1
#define PNP_BIOS_EVENT_ASYNC           2

//
// Pnp Bios event
//

#define ABOUT_TO_CHANGE_CONFIG         1
#define DOCK_CHANGED                   2
#define SYSTEM_DEVICE_CHANGED          3
#define CONFIG_CHANGE_FAILED           4
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\isapnp\init.c ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    init.c

Abstract:

    DriverEntry initialization code for pnp isa bus driver

Author:

    Shie-Lin Tzong (shielint) 3-Jan-1997

Environment:

    Kernel mode only.

Revision History:

--*/


#include "busp.h"
#include "pnpisa.h"

BOOLEAN
PipIsIsolationDisabled(
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(INIT,PipIsIsolationDisabled)
#endif

#if ISOLATE_CARDS

BOOLEAN
PipIsIsolationDisabled(
    )

/*++

Description:

    Look in the registry for flag indicating that isolation has been
    disabled.  This is a last resort hook for platforms that can't
    deal with the RDP and it's boot config.

Return Value:

   BOOLEAN indicating whether isolation is disabled or not.

--*/

{
    HANDLE         serviceHandle, paramHandle;
    UNICODE_STRING paramString;
    PKEY_VALUE_FULL_INFORMATION keyInfo;
    NTSTATUS       status;
    BOOLEAN        result = FALSE;

    status = PipOpenRegistryKey(&serviceHandle,
                                NULL,
                                &PipRegistryPath,
                                KEY_READ,
                                FALSE);
    if (!NT_SUCCESS(status)) {
        return result;
    }

    RtlInitUnicodeString(&paramString, L"Parameters");
    status = PipOpenRegistryKey(&paramHandle,
                                serviceHandle,
                                &paramString,
                                KEY_READ,
                                FALSE);
    ZwClose(serviceHandle);
    if (!NT_SUCCESS(status)) {
        return result;
    }

    status = PipGetRegistryValue(paramHandle,
                                 L"IsolationDisabled",
                                 &keyInfo);
    ZwClose(paramHandle);
    if (NT_SUCCESS(status)) {
        if((keyInfo->Type == REG_DWORD) &&
           (keyInfo->DataLength >= sizeof(ULONG))) {
            result = *(PULONG)KEY_VALUE_DATA(keyInfo) != 0;
        }
        ExFreePool(keyInfo);
    }

    return result;
}
#endif

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine initializes driver object major function table to handle Pnp IRPs
    and AddDevice entry point.  If detection is allowed, it reports a detected device
    for the pseudo isapnp bus and performs enumeration.

Arguments:

    DriverObject - specifies the driver object for the bus extender.

    RegistryPath - supplies a pointer to a unicode string of the service key name in
        the CurrentControlSet\Services key for the bus extender.

Return Value:

    Always return STATUS_UNSUCCESSFUL.

--*/

{

    PDRIVER_EXTENSION driverExtension;
    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_OBJECT detectedDeviceObject = NULL;

#if defined(_X86_) && ISOLATE_CARDS
    if (IsNEC_98) {
        ADDRESS_PORT=ADDRESS_PORT_NEC;
        COMMAND_PORT=COMMAND_PORT_NEC;
    }
#endif

    PipDriverObject = DriverObject;
    //
    // Fill in the driver object
    //

    DriverObject->DriverUnload = PiUnload;
    DriverObject->MajorFunction[IRP_MJ_PNP] = PiDispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER] = PiDispatchPower;
    //
    // Device and system control IRPs can be handled in the same way
    // we basically don't touch them
    //
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = PiDispatchDevCtl;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = PiDispatchDevCtl;
    DriverObject->MajorFunction[IRP_MJ_CREATE] = PiDispatchCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = PiDispatchClose;

    driverExtension = DriverObject->DriverExtension;
    driverExtension->AddDevice = PiAddDevice;

    //
    // Store our registry path globally so we can use it later
    //

    PipRegistryPath.Length = RegistryPath->Length;
    PipRegistryPath.MaximumLength = RegistryPath->MaximumLength;
    PipRegistryPath.Buffer = ExAllocatePool(PagedPool,
                                               RegistryPath->MaximumLength );
    if( PipRegistryPath.Buffer == NULL ){
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory( PipRegistryPath.Buffer,
                   RegistryPath->Buffer,
                   RegistryPath->MaximumLength );

    //
    // Initialize global varaibles
    //

    KeInitializeEvent (&PipDeviceTreeLock, SynchronizationEvent, TRUE);
    KeInitializeEvent (&IsaBusNumberLock, SynchronizationEvent, TRUE);

    BusNumBM=&BusNumBMHeader;
    RtlInitializeBitMap (BusNumBM,BusNumberBuffer,256/sizeof (ULONG));
    RtlClearAllBits (BusNumBM);

#if ISOLATE_CARDS
    PipIsolationDisabled = PipIsIsolationDisabled();
#endif

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\isapnp\pdopnp.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    pdopnp.c

Abstract:

    This file contains the PNP IRP dispatch code for PDOs

Environment:

    Kernel Mode Driver.

Revision History:

--*/

#include "busp.h"
#include "pnpisa.h"
#include <wdmguid.h>
#include "halpnpp.h"

#if ISOLATE_CARDS

//
// Function Prototypes
//

BOOLEAN PipFailStartPdo = FALSE;
BOOLEAN PipFailStartRdp = FALSE;

NTSTATUS
PiStartPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiQueryRemoveStopPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp    );

NTSTATUS
PiCancelRemoveStopPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp    );

NTSTATUS
PiStopPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiQueryDeviceRelationsPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiQueryCapabilitiesPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiQueryDeviceTextPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiFilterResourceRequirementsPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiQueryIdPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiQueryResourcesPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiQueryResourceRequirementsPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiRemovePdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiQueryBusInformationPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiQueryInterfacePdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiDeviceUsageNotificationPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiSurpriseRemovePdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiIrpNotSupported(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PipBuildRDPResources(
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST *IoResources,
    IN ULONG Flags
    );

NTSTATUS
PiQueryDeviceState(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,PiDispatchPnpPdo)
#pragma alloc_text(PAGE,PiStartPdo)
#pragma alloc_text(PAGE,PiQueryRemoveStopPdo)
#pragma alloc_text(PAGE,PiRemovePdo)
#pragma alloc_text(PAGE,PiCancelRemoveStopPdo)
#pragma alloc_text(PAGE,PiStopPdo)
#pragma alloc_text(PAGE,PiQueryDeviceRelationsPdo)
#pragma alloc_text(PAGE,PiQueryInterfacePdo)
#pragma alloc_text(PAGE,PiQueryCapabilitiesPdo)
#pragma alloc_text(PAGE,PiQueryResourcesPdo)
#pragma alloc_text(PAGE,PiQueryResourceRequirementsPdo)
#pragma alloc_text(PAGE,PiQueryDeviceTextPdo)
#pragma alloc_text(PAGE,PiFilterResourceRequirementsPdo)
#pragma alloc_text(PAGE,PiSurpriseRemovePdo)
#pragma alloc_text(PAGE,PiIrpNotSupported)
#pragma alloc_text(PAGE,PiQueryIdPdo)
#pragma alloc_text(PAGE,PiQueryBusInformationPdo)
#pragma alloc_text(PAGE,PiDeviceUsageNotificationPdo)
#pragma alloc_text(PAGE,PipBuildRDPResources)
#pragma alloc_text(PAGE,PiQueryDeviceState)
#endif


//
// PNP IRP Dispatch table for PDOs - This should be updated if new IRPs are added
//

PPI_DISPATCH PiPnpDispatchTablePdo[] = {
    PiStartPdo,                             // IRP_MN_START_DEVICE
    PiQueryRemoveStopPdo,                   // IRP_MN_QUERY_REMOVE_DEVICE
    PiRemovePdo,                            // IRP_MN_REMOVE_DEVICE
    PiCancelRemoveStopPdo,                  // IRP_MN_CANCEL_REMOVE_DEVICE
    PiStopPdo,                              // IRP_MN_STOP_DEVICE
    PiQueryRemoveStopPdo,                   // IRP_MN_QUERY_STOP_DEVICE
    PiCancelRemoveStopPdo,                  // IRP_MN_CANCEL_STOP_DEVICE
    PiQueryDeviceRelationsPdo,              // IRP_MN_QUERY_DEVICE_RELATIONS
    PiQueryInterfacePdo,                    // IRP_MN_QUERY_INTERFACE
    PiQueryCapabilitiesPdo,                 // IRP_MN_QUERY_CAPABILITIES
    PiQueryResourcesPdo,                    // IRP_MN_QUERY_RESOURCES
    PiQueryResourceRequirementsPdo,         // IRP_MN_QUERY_RESOURCE_REQUIREMENTS
    PiQueryDeviceTextPdo,                   // IRP_MN_QUERY_DEVICE_TEXT
    PiFilterResourceRequirementsPdo,        // IRP_MN_FILTER_RESOURCE_REQUIREMENTS
    PiIrpNotSupported,                      // Unused
    PiIrpNotSupported,                      // IRP_MN_READ_CONFIG
    PiIrpNotSupported,                      // IRP_MN_WRITE_CONFIG
    PiIrpNotSupported,                      // IRP_MN_EJECT
    PiIrpNotSupported,                      // IRP_MN_SET_LOCK
    PiQueryIdPdo,                           // IRP_MN_QUERY_ID
    PiQueryDeviceState,                     // IRP_MN_QUERY_PNP_DEVICE_STATE
    PiQueryBusInformationPdo,               // IRP_MN_QUERY_BUS_INFORMATION
    PiDeviceUsageNotificationPdo,           // IRP_MN_DEVICE_USAGE_NOTIFICATION
    PiSurpriseRemovePdo,                    // IRP_MN_SURPRISE_REMOVAL
    PiIrpNotSupported                       // IRP_MN_QUERY_LEGACY_BUS_INFORMATION
};


NTSTATUS
PiDispatchPnpPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles IRP_MJ_PNP IRPs for PDOs.

Arguments:

    DeviceObject - Pointer to the PDO for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/

{

    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    PVOID information = NULL;

    PAGED_CODE();

    //
    // Get a pointer to our stack location and take appropriate action based
    // on the minor function.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    if (irpSp->MinorFunction > IRP_MN_PNP_MAXIMUM_FUNCTION) {

        status = Irp->IoStatus.Status;

    } else {

        status = PiPnpDispatchTablePdo[irpSp->MinorFunction](DeviceObject, Irp);

        if ( status != STATUS_NOT_SUPPORTED ) {

            //
            // We understood this IRP and handled it so we need to set status before completing
            //

            Irp->IoStatus.Status = status;

        } else {

            status = Irp->IoStatus.Status;
        }

    }

    information = (PVOID)Irp->IoStatus.Information;

    ASSERT(status == Irp->IoStatus.Status);

    PipCompleteRequest(Irp, status, information);
    return status;


} //PipDispatchPnpPdo


NTSTATUS
PiStartPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{

    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    PCM_RESOURCE_LIST cmResources;
    PDEVICE_INFORMATION deviceInfo;
    UNICODE_STRING unicodeString;
    ULONG length;
    POWER_STATE newPowerState;

    irpSp = IoGetCurrentIrpStackLocation(Irp);


    cmResources = irpSp->Parameters.StartDevice.AllocatedResources;

    if (PipDebugMask & DEBUG_PNP) {
        PipDumpCmResourceList(cmResources);
    } else if (!cmResources) {
        DbgPrint("StartDevice irp with empty CmResourceList\n");
    }

    DebugPrint((DEBUG_PNP,
       "*** StartDevice irp received PDO: %x\n",DeviceObject));
    if (deviceInfo = PipReferenceDeviceInformation(DeviceObject, TRUE)) {

        if (deviceInfo->Flags & DF_READ_DATA_PORT) {
            ULONG curSize,newSize;
            //
            if (PipFailStartRdp) {
                PipDereferenceDeviceInformation(deviceInfo, TRUE);
                return STATUS_UNSUCCESSFUL;
            }
            // Read data port is special
            //
            newSize=PipDetermineResourceListSize(cmResources);
            curSize=PipDetermineResourceListSize(deviceInfo->AllocatedResources);

            //
            // Check if we've been removed, or moved (the +3 is the bit mask for the RDP , we claim 4-7, need xxxi7)
            //
            if ( (deviceInfo->Flags & DF_REMOVED) ||
                 !(deviceInfo->Flags & DF_STOPPED) ||
                 (curSize != newSize) ||
                 (newSize != RtlCompareMemory (deviceInfo->AllocatedResources,cmResources,newSize))) {


                //
                // This will release the unused resources
                //
                status = PipStartReadDataPort (deviceInfo,deviceInfo->ParentDeviceExtension,DeviceObject,cmResources);
                if (NT_SUCCESS(status) || status == STATUS_NO_SUCH_DEVICE) {
                    status = STATUS_SUCCESS;
                }

                //
                // Invalidate the device relations
                //

                if (NT_SUCCESS (status)) {
                    IoInvalidateDeviceRelations (
                        deviceInfo->ParentDeviceExtension->PhysicalBusDevice,BusRelations);
                }
                deviceInfo->Flags &= ~(DF_STOPPED|DF_REMOVED|DF_SURPRISE_REMOVED);
            } else {
                deviceInfo->Flags &= ~DF_STOPPED;
                IoInvalidateDeviceRelations (
                    deviceInfo->ParentDeviceExtension->PhysicalBusDevice,BusRelations);
                status=STATUS_SUCCESS;
            }
            deviceInfo->Flags |= DF_ACTIVATED;
            PipDereferenceDeviceInformation(deviceInfo, TRUE);

            DebugPrint((DEBUG_PNP, "StartDevice(RDP) returning: %x\n",status));

            return status;
        }


        //
        if (PipFailStartPdo) {
            PipDereferenceDeviceInformation(deviceInfo, TRUE);
            return STATUS_UNSUCCESSFUL;
        }

        // Do this first, so that we allow for no-resource devices in the ref count.
        // (when we activate the RDP it won't have resources, yet)
        //

        // ASSERT (!(PipRDPNode->Flags & (DF_STOPPED|DF_REMOVED)));
        if (PipRDPNode->Flags & (DF_STOPPED|DF_REMOVED)) {
            //
            // If the RDP isn't running, fail the start.
            //
            PipDereferenceDeviceInformation(deviceInfo, TRUE);

            return STATUS_UNSUCCESSFUL;
        }

        if (cmResources) {
            deviceInfo->AllocatedResources = ExAllocatePool(
                    NonPagedPool,
                    PipDetermineResourceListSize(cmResources));
            if (deviceInfo->AllocatedResources) {
                RtlMoveMemory(deviceInfo->AllocatedResources,
                             cmResources,
                             length = PipDetermineResourceListSize(cmResources));
                deviceInfo->Flags &= ~(DF_REMOVED|DF_STOPPED);
                status = PipSetDeviceResources (deviceInfo, cmResources);
                if (NT_SUCCESS(status)) {

                    PipActivateDevice();

                    DebugPrint((DEBUG_STATE,
                                "Starting CSN %d/LDN %d\n",
                                deviceInfo->CardInformation->CardSelectNumber,
                                deviceInfo->LogicalDeviceNumber));

                    deviceInfo->Flags |= DF_ACTIVATED;
                    newPowerState.DeviceState =
                        deviceInfo->DevicePowerState = PowerDeviceD0;
                    PoSetPowerState(DeviceObject,
                                    DevicePowerState,
                                    newPowerState);
                    deviceInfo->DevicePowerState = PowerDeviceD0;

                    if (deviceInfo->LogConfHandle) {
                        RtlInitUnicodeString(&unicodeString, L"AllocConfig");
                        ZwSetValueKey(deviceInfo->LogConfHandle,
                                      &unicodeString,
                                      0,
                                      REG_RESOURCE_LIST,
                                      cmResources,
                                      length
                                      );
                    }
                }

            } else {
                status = STATUS_NO_MEMORY;
            }
        } else if (deviceInfo->ResourceRequirements) {
            status = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            status = STATUS_SUCCESS;
        }
        PipDereferenceDeviceInformation(deviceInfo, TRUE);
    } else {
        status = STATUS_NO_SUCH_DEVICE;
    }

    DebugPrint((DEBUG_PNP, "StartDevice returning: %x\n",status));
    return status;

} // PiStartPdo


NTSTATUS
PiQueryRemoveStopPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PDEVICE_INFORMATION deviceInfo;
    PIO_STACK_LOCATION irpSp;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    DebugPrint((DEBUG_PNP,
       "*** Query%s irp received PDO: %x\n",
                (irpSp->MinorFunction == IRP_MN_QUERY_STOP_DEVICE) ? "Stop" : "Remove",
                DeviceObject));
    if (deviceInfo = PipReferenceDeviceInformation(DeviceObject, FALSE)) {

        if (deviceInfo->Paging || deviceInfo->CrashDump) {
            status = STATUS_DEVICE_BUSY;
        } else if ( deviceInfo->Flags & DF_READ_DATA_PORT ) {
            if (irpSp->MinorFunction != IRP_MN_QUERY_STOP_DEVICE) {
                status = STATUS_SUCCESS;
            } else if (deviceInfo->Flags & DF_PROCESSING_RDP) {
                //
                // If we're in the middle of the two part RDP start process,
                // flag this as a device that needs to be requeried for
                // resource requirements.
                //
                status = STATUS_RESOURCE_REQUIREMENTS_CHANGED;
            } else {

                PSINGLE_LIST_ENTRY deviceLink;
                PDEVICE_INFORMATION childDeviceInfo;
                PPI_BUS_EXTENSION busExtension = deviceInfo->ParentDeviceExtension;
                //
                // If trying to stop the RDP, then if any children fail it.
                //
                PipLockDeviceDatabase();

                status = STATUS_SUCCESS;
                deviceLink = busExtension->DeviceList.Next;
                while (deviceLink) {
                    childDeviceInfo = CONTAINING_RECORD (deviceLink, DEVICE_INFORMATION, DeviceList);

                    if (!(childDeviceInfo->Flags & DF_READ_DATA_PORT) &&
                        ((childDeviceInfo->Flags & DF_ENUMERATED) ||
                         !(childDeviceInfo->Flags & DF_REMOVED)))  {

                        status = STATUS_UNSUCCESSFUL;
                        break;
                    }
                    deviceLink = childDeviceInfo->DeviceList.Next;
                }

                PipUnlockDeviceDatabase();
            }

        } else {

            if ((irpSp->MinorFunction == IRP_MN_QUERY_STOP_DEVICE) &&
                !(deviceInfo->Flags & DF_ENUMERATED)) {

                status = STATUS_UNSUCCESSFUL;
            } else {

                ASSERT(!(PipRDPNode->Flags & (DF_STOPPED|DF_REMOVED)));
                if ((irpSp->MinorFunction == IRP_MN_QUERY_REMOVE_DEVICE) &&
                    (deviceInfo->CardInformation->CardFlags & CF_ISOLATION_BROKEN)) {
                    DebugPrint((DEBUG_ERROR, "Failed query remove due to broken isolatee\n"));
                    status = STATUS_UNSUCCESSFUL;
                } else {
                    deviceInfo->Flags |= DF_QUERY_STOPPED;
                    status = STATUS_SUCCESS;
                }
            }
        }

        PipDereferenceDeviceInformation(deviceInfo, FALSE);
    } else {
        status = STATUS_NO_SUCH_DEVICE;
    }

    DebugPrint((DEBUG_PNP, "Query%s Device returning: %x\n",
                (irpSp->MinorFunction == IRP_MN_QUERY_STOP_DEVICE) ? "Stop" : "Remove",
                status));

    return status;

} // PiQueryRemoveStopPdo


NTSTATUS
PiCancelRemoveStopPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PDEVICE_INFORMATION deviceInfo;
    PIO_STACK_LOCATION irpSp;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    DebugPrint((DEBUG_PNP,
       "*** Cancel%s irp received PDO: %x\n",
                (irpSp->MinorFunction == IRP_MN_CANCEL_STOP_DEVICE) ? "Stop" : "Remove",
                DeviceObject));
    if (deviceInfo = PipReferenceDeviceInformation(DeviceObject, FALSE)) {

        deviceInfo->Flags &= ~DF_QUERY_STOPPED;

        PipDereferenceDeviceInformation(deviceInfo, FALSE);
        status = STATUS_SUCCESS;

    } else {

        status = STATUS_NO_SUCH_DEVICE;
    }

    DebugPrint((DEBUG_PNP, "Cancel%s Device returning: %x\n",
                (irpSp->MinorFunction == IRP_MN_CANCEL_STOP_DEVICE) ? "Stop" : "Remove",
                status));

    return status;

} // PiCancelRemoteStopPdo


NTSTATUS
PiStopPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PDEVICE_INFORMATION deviceInfo;
    POWER_STATE newPowerState;

    DebugPrint((DEBUG_PNP, "PiStopPdo %x\n",DeviceObject));

    if (deviceInfo = PipReferenceDeviceInformation(DeviceObject, TRUE)) {

        //
        // Deselect the cards, but not the RDP node.
        //
        if (DeviceObject != PipRDPNode->PhysicalDeviceObject) {

            PipDeactivateDevice();
            DebugPrint((DEBUG_STATE,
                        "Stopping CSN %d/LDN %d\n",
                        deviceInfo->CardInformation->CardSelectNumber,
                        deviceInfo->LogicalDeviceNumber));

            PipReleaseDeviceResources (deviceInfo);
        }

        if ((deviceInfo->Flags & DF_ACTIVATED)) {
            deviceInfo->Flags &= ~DF_ACTIVATED;
            newPowerState.DeviceState = deviceInfo->DevicePowerState = PowerDeviceD3;
            PoSetPowerState(DeviceObject, DevicePowerState, newPowerState);
        }
        deviceInfo->Flags &= ~DF_QUERY_STOPPED;
        deviceInfo->Flags |= DF_STOPPED;

        PipDereferenceDeviceInformation(deviceInfo, TRUE);
        status = STATUS_SUCCESS;
    } else {
        status = STATUS_NO_SUCH_DEVICE;
    }

    DebugPrint((DEBUG_PNP, "StopDevice returning: %x\n",status));
    return status;

} // PiStopPdo


NTSTATUS
PiQueryDeviceRelationsPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PDEVICE_INFORMATION deviceInfo;
    PIO_STACK_LOCATION irpSp;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // The QueryDeviceRelation Irp is for devices under enumerated PnpIsa device.
    //


    switch (irpSp->Parameters.QueryDeviceRelations.Type) {
        case  TargetDeviceRelation: {
            PDEVICE_RELATIONS deviceRelations;

            deviceRelations = ExAllocatePool(PagedPool, sizeof(DEVICE_RELATIONS));
            if (deviceRelations == NULL) {
                status = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                deviceRelations->Count = 1;
                deviceRelations->Objects[0] = DeviceObject;
                ObReferenceObject(DeviceObject);
                Irp->IoStatus.Information = (ULONG_PTR)deviceRelations;
                status = STATUS_SUCCESS;
            }
        }
        break;

        case RemovalRelations: {

            PDEVICE_RELATIONS deviceRelations;

            if (PipRDPNode && (DeviceObject == PipRDPNode->PhysicalDeviceObject)) {

                deviceRelations = ExAllocatePool(PagedPool, sizeof(DEVICE_RELATIONS));
                if (deviceRelations == NULL) {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                } else {
                    //
                    //Don't include ourselves in the list of Removal Relations, hence the -1
                    //

                    PipLockDeviceDatabase();
                    status = PipQueryDeviceRelations(
                        PipRDPNode->ParentDeviceExtension,
                        (PDEVICE_RELATIONS *)&Irp->IoStatus.Information,
                        TRUE
                        );

                    PipUnlockDeviceDatabase();
               }

            } else {
                status = STATUS_NOT_SUPPORTED;

            }
        }
        break;

        default : {

            status = STATUS_NOT_SUPPORTED;

            break;
        }
    }


    return status;

} // PiQueryDeviceRelationsPdo


NTSTATUS
PiQueryCapabilitiesPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_CAPABILITIES deviceCapabilities;
    ULONG i;
    PDEVICE_POWER_STATE state;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    deviceCapabilities = irpSp->Parameters.DeviceCapabilities.Capabilities;
    deviceCapabilities->SystemWake = PowerSystemUnspecified;
    deviceCapabilities->DeviceWake = PowerDeviceUnspecified;
    deviceCapabilities->LockSupported = FALSE;
    deviceCapabilities->EjectSupported = FALSE;
    deviceCapabilities->Removable = FALSE;
    deviceCapabilities->DockDevice = FALSE;
    deviceCapabilities->UniqueID = TRUE;
    state = deviceCapabilities->DeviceState;
    //
    // Init the entire DeviceState array to D3 then replace the entry
    // for system state S0.
    //
    for (i = 0;
         i <  sizeof(deviceCapabilities->DeviceState);
         i += sizeof(deviceCapabilities->DeviceState[0])) {

        //
        // Only supported state, currently, is off.
        //

        *state++ = PowerDeviceD3;
    }
    deviceCapabilities->DeviceState[PowerSystemWorking] = PowerDeviceD0;

    //deviceCapabilities->SilentInstall = TRUE;
    //deviceCapabilities->RawDeviceOK = FALSE;
    if (PipRDPNode && (PipRDPNode->PhysicalDeviceObject == DeviceObject)) {
        deviceCapabilities->SilentInstall = TRUE;
        deviceCapabilities->RawDeviceOK = TRUE;
    }

    return STATUS_SUCCESS;

} // PiQueryCapabilitiesPdo

NTSTATUS
PiQueryDeviceTextPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_INFORMATION deviceInfo;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    if (deviceInfo = PipReferenceDeviceInformation(DeviceObject, FALSE)) {
        PWSTR functionId;

        ULONG functionIdLength;

        if (irpSp->Parameters.QueryDeviceText.DeviceTextType == DeviceTextDescription) {

            //
            // Once we know we're going to touch the IRP
            //
            status = STATUS_SUCCESS;

            PipGetFunctionIdentifier((PUCHAR)deviceInfo->DeviceData,
                                     &functionId,
                                     &functionIdLength);

            if (!functionId) {
                if (deviceInfo->CardInformation) {
                    PipGetCardIdentifier((PUCHAR)deviceInfo->CardInformation->CardData + NUMBER_CARD_ID_BYTES,
                                         &functionId,
                                         &functionIdLength);
                }else {
                    functionId=NULL;
                }
            }
            Irp->IoStatus.Information = (ULONG_PTR)functionId;
        } else {

            status = STATUS_NOT_SUPPORTED;
        }
        PipDereferenceDeviceInformation(deviceInfo, FALSE);
    } else {
        status = STATUS_NO_SUCH_DEVICE;
    }

    return status;

} // PiQueryDeviceTextPdo

NTSTATUS
PiFilterResourceRequirementsPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    This routine ensures that the RDP doesn't get its requirements filtered.

    Design Note:
    This code may now be extraneous now that we ensure that the
    DF_PROCESSING_RDP and DF_REQ_TRIMMED flags are cleared on RDP
    removal.

Arguments:

    DeviceObject - Pointer to the PDO for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/

{
    NTSTATUS status;
    PDEVICE_INFORMATION deviceInfo;
    PIO_RESOURCE_REQUIREMENTS_LIST IoResources;
    USHORT irqBootFlags;

    if ((deviceInfo = PipReferenceDeviceInformation(DeviceObject, FALSE)) == NULL) {
        return STATUS_NO_SUCH_DEVICE;
    }

    if (deviceInfo->Flags & DF_READ_DATA_PORT) {
        DebugPrint((DEBUG_PNP, "Filtering resource requirements for RDP\n"));

        status = PipBuildRDPResources(&IoResources, deviceInfo->Flags);

        if (NT_SUCCESS(status)) {
            //
            // if someone above us filtered the RDP resource requirements,
            // free them.
            if (Irp->IoStatus.Information) {
                ExFreePool((PVOID) Irp->IoStatus.Information);
            }
            Irp->IoStatus.Information = (ULONG_PTR) IoResources;
        }
    } else {
        //
        // If the device's resource requirements are being filtered
        // and the new requirements have only one alternative vs the n
        // alternatives of the original, then we're going to assume we
        // are receiving a force config.  Apply our earlier derived
        // IRQ level/edge settings to this force config in order to
        // deal with broken force configs from NT4
        //
        // Design Note:
        // Probably should've left out the force config test
        // and done it on everything, but this is what we private
        // tested.

        IoResources =
            (PIO_RESOURCE_REQUIREMENTS_LIST) Irp->IoStatus.Information;

        if (IoResources &&
            (IoResources->AlternativeLists == 1) &&
            (deviceInfo->ResourceRequirements->AlternativeLists > 1)) {
            status = PipGetBootIrqFlags(deviceInfo, &irqBootFlags);
            if (NT_SUCCESS(status)) {
                status = PipTrimResourceRequirements(
                    &IoResources,
                    irqBootFlags,
                    NULL);
                Irp->IoStatus.Information = (ULONG_PTR) IoResources;
            } else {
                status = STATUS_NOT_SUPPORTED;
            }
        } else {
            status = STATUS_NOT_SUPPORTED;
        }
    }

    PipDereferenceDeviceInformation(deviceInfo, FALSE);

    return status;
}



NTSTATUS
PiQueryIdPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_INFORMATION deviceInfo;
    ULONG length;
    PWCHAR requestId = NULL, ids;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    if ((deviceInfo = PipReferenceDeviceInformation(DeviceObject, FALSE)) == NULL) {

        status = STATUS_NO_SUCH_DEVICE;
        return status;
    }

    switch (irpSp->Parameters.QueryId.IdType) {
    case BusQueryCompatibleIDs:

        ids = (PWCHAR)ExAllocatePool(PagedPool, 1024);
        if (ids) {
            PWCHAR p1;
            ULONG i;

            p1 = ids;
            length = 0;
            for (i = 1; TRUE; i++) {
                //
                // Use the -1 as a sentinel so that we get the magic RDP compat. ID and also leave the loop
                //
                ASSERT (i < 256);
                if (deviceInfo->Flags & DF_READ_DATA_PORT) {
                    i =-1;
                }

                status = PipGetCompatibleDeviceId(
                              deviceInfo->DeviceData,
                              i,
                              &requestId);
                if (NT_SUCCESS(status) && requestId) {
                    if ((length + wcslen(requestId) * sizeof(WCHAR) + 2 * sizeof(WCHAR))
                         <= 1024) {
                        RtlMoveMemory(p1, requestId, wcslen(requestId) * sizeof(WCHAR));
                        p1 += wcslen(requestId);
                        *p1 = UNICODE_NULL;
                        p1++;
                        length += wcslen(requestId) * sizeof(WCHAR) + sizeof(WCHAR);
                        ExFreePool(requestId);
                    } else {
                        ExFreePool(requestId);
                        break;
                    }
                    if ( i == -1 ) {
                        break;
                    }
                } else {
                   break;
                }
            }
            if (length == 0) {
                ExFreePool(ids);
                ids = NULL;
            } else {
                *p1 = UNICODE_NULL;
            }
        }
        Irp->IoStatus.Information = (ULONG_PTR)ids;
        status = STATUS_SUCCESS;
        break;

    case BusQueryHardwareIDs:

        if (deviceInfo->Flags & DF_READ_DATA_PORT) {
            status = PipGetCompatibleDeviceId(deviceInfo->DeviceData, -1, &requestId);
        }else {
            status = PipGetCompatibleDeviceId(deviceInfo->DeviceData, 0, &requestId);
        }

        if (NT_SUCCESS(status) && requestId) {

            ULONG idLength, deviceIdLength;
            PWCHAR deviceId = NULL, p;

            //
            // create HardwareId value name.  Even though it is a MULTI_SZ,
            // we know there is only one HardwareId for PnpIsa.
            //
            // HACK - The modem inf files use the form of isapnp\xyz0001
            //        instead of *xyz0001 as the hardware id.  To solve this
            //        problem we will generate two hardware Ids: *xyz0001 and
            //        isapnp\xyz0001 (device instance name).
            //

            status = PipQueryDeviceId(deviceInfo, &deviceId, 0);

            if (NT_SUCCESS (status)) {
                idLength = wcslen(requestId) * sizeof(WCHAR);
                deviceIdLength = wcslen(deviceId) * sizeof(WCHAR);
                length = idLength +                       // returned ID
                         sizeof(WCHAR) +                  // UNICODE_NULL
                         deviceIdLength +                 // isapnp\id
                         2 * sizeof(WCHAR);               // two UNICODE_NULLs
                ids = p = (PWCHAR)ExAllocatePool(PagedPool, length);
                if (ids) {
                    RtlMoveMemory(ids, deviceId, deviceIdLength);
                    p += deviceIdLength / sizeof(WCHAR);
                    *p = UNICODE_NULL;
                    p++;
                    RtlMoveMemory(p, requestId, idLength);
                    p += idLength / sizeof(WCHAR);
                    *p = UNICODE_NULL;
                    p++;
                    *p = UNICODE_NULL;
                    ExFreePool(requestId);
                    Irp->IoStatus.Information = (ULONG_PTR)ids;
                } else {
                    Irp->IoStatus.Information = (ULONG_PTR)requestId;
                }
                if (deviceId) {
                    ExFreePool(deviceId);
                }
            }
        }
        break;

    case BusQueryDeviceID:

        status = PipQueryDeviceId(deviceInfo, &requestId, 0);
        Irp->IoStatus.Information = (ULONG_PTR)requestId;
        break;

    case BusQueryInstanceID:

        status = PipQueryDeviceUniqueId (deviceInfo, &requestId);
        Irp->IoStatus.Information = (ULONG_PTR)requestId;
        break;

    default:

        status = STATUS_NOT_SUPPORTED;
    }
    PipDereferenceDeviceInformation(deviceInfo, FALSE);

    return status;

} // PiQueryIdPdo


NTSTATUS
PiQueryResourcesPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status=STATUS_SUCCESS;
    PDEVICE_INFORMATION deviceInfo;
    PCM_RESOURCE_LIST cmResources=NULL;
    ULONG length;

    if (deviceInfo = PipReferenceDeviceInformation(DeviceObject, FALSE)) {
        if ((deviceInfo->Flags & DF_READ_DATA_PORT) ||
            ((deviceInfo->Flags & (DF_ENUMERATED|DF_REMOVED)) == DF_ENUMERATED)) {
            status = PipQueryDeviceResources (
                          deviceInfo,
                          0,             // BusNumber
                          &cmResources,
                          &length
                          );
        }
        PipDereferenceDeviceInformation(deviceInfo, FALSE);
        Irp->IoStatus.Information = (ULONG_PTR)cmResources;
    } else {
        status = STATUS_NO_SUCH_DEVICE;
    }

    DebugPrint((DEBUG_PNP, "PiQueryResourcesPdo returning: %x\n",status));
    return status;

} // PiQueryResourcesPdo

NTSTATUS
PiQueryResourceRequirementsPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PDEVICE_INFORMATION deviceInfo;
    PIO_RESOURCE_REQUIREMENTS_LIST ioResources;

    if (deviceInfo = PipReferenceDeviceInformation(DeviceObject, FALSE)) {
        status = STATUS_SUCCESS;

        if (deviceInfo->Flags & DF_READ_DATA_PORT) {
            status = PipBuildRDPResources (&ioResources,
                                           deviceInfo->Flags);
        } else {
            if (deviceInfo->ResourceRequirements &&
              !(deviceInfo->Flags & (DF_SURPRISE_REMOVED))) {

                ioResources = (PIO_RESOURCE_REQUIREMENTS_LIST) ExAllocatePool (
                               PagedPool, deviceInfo->ResourceRequirements->ListSize);
                if (ioResources == NULL) {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                } else {
                    RtlMoveMemory(ioResources,
                                  deviceInfo->ResourceRequirements,
                                  deviceInfo->ResourceRequirements->ListSize
                                  );
                }
            } else {
                ioResources = NULL;
            }
        }
        Irp->IoStatus.Information = (ULONG_PTR)ioResources;
        PipDereferenceDeviceInformation(deviceInfo, FALSE);
    } else {
        status = STATUS_NO_SUCH_DEVICE;
    }

    DebugPrint((DEBUG_PNP, "PiQueryResourceRequirementsPdo returning: %x\n",status));
    return status;

} // PiQueryResourceRequirementsPdo


NTSTATUS
PiRemovePdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PDEVICE_INFORMATION deviceInfo;
    POWER_STATE newPowerState;

    //
    // One of our enumerated device is being removed.  Mark it and deactivate the
    // device.  Note, we do NOT delete its device object.
    //
    DebugPrint((DEBUG_PNP, "PiRemovePdo %x\n",DeviceObject));

    if (deviceInfo = PipReferenceDeviceInformation(DeviceObject, FALSE)) {
        if (!(deviceInfo->Flags & (DF_REMOVED|DF_SURPRISE_REMOVED))) {
            deviceInfo->Flags |= DF_REMOVED;
            deviceInfo->Flags &= ~DF_QUERY_STOPPED;

            if (deviceInfo->Flags & DF_READ_DATA_PORT) {

                PSINGLE_LIST_ENTRY deviceLink;
                PPI_BUS_EXTENSION busExtension = deviceInfo->ParentDeviceExtension;

                //
                // If the RDP is removed, mark everyone as missing, and then return only the
                // RDP
                //
                PipLockDeviceDatabase();

                deviceLink = busExtension->DeviceList.Next;
                while (deviceLink) {
                    deviceInfo = CONTAINING_RECORD (deviceLink, DEVICE_INFORMATION, DeviceList);
                    if (!(deviceInfo->Flags & DF_READ_DATA_PORT)) {
                        deviceInfo->Flags &= ~DF_ENUMERATED;
                    }
                    deviceLink = deviceInfo->DeviceList.Next;
                }

                PipUnlockDeviceDatabase();

                IoInvalidateDeviceRelations (
                    deviceInfo->ParentDeviceExtension->PhysicalBusDevice,BusRelations);
                deviceInfo->Flags &= ~(DF_REQ_TRIMMED|DF_PROCESSING_RDP);
            }

            //
            // Deactivate the device
            //
            if (deviceInfo->Flags & DF_ACTIVATED) {
                deviceInfo->Flags &= ~DF_ACTIVATED;

                if (!(deviceInfo->Flags & (DF_READ_DATA_PORT|DF_NOT_FUNCTIONING))) {
                    PipWakeAndSelectDevice(
                        (UCHAR) deviceInfo->CardInformation->CardSelectNumber,
                        (UCHAR)deviceInfo->LogicalDeviceNumber);
                    PipDeactivateDevice();
                    PipWaitForKey();
                    DebugPrint((DEBUG_STATE,
                                "Removing CSN %d/LDN %d\n",
                                deviceInfo->CardInformation->CardSelectNumber,
                                deviceInfo->LogicalDeviceNumber));
                }
                newPowerState.DeviceState = deviceInfo->DevicePowerState = PowerDeviceD3;
                PoSetPowerState(DeviceObject, DevicePowerState, newPowerState);
            }

            PipReleaseDeviceResources (deviceInfo);
        }

        if (!(deviceInfo->Flags & DF_ENUMERATED)) {
            PipDeleteDevice(DeviceObject);
        }

        PipDereferenceDeviceInformation(deviceInfo, TRUE);
        status = STATUS_SUCCESS;
    } else {
        status = STATUS_NO_SUCH_DEVICE;
    }

    DebugPrint((DEBUG_PNP, "RemoveDevice returning: %x\n",status));

    return status;

} // PiRemovePdo


NTSTATUS
PiQueryBusInformationPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PPNP_BUS_INFORMATION pnpBusInfo;
    PVOID information = NULL;
    PPI_BUS_EXTENSION busExtension;
    NTSTATUS status;

    busExtension = DeviceObject->DeviceExtension;

    pnpBusInfo = (PPNP_BUS_INFORMATION) ExAllocatePool(PagedPool, sizeof(PNP_BUS_INFORMATION));
    if (pnpBusInfo) {
        pnpBusInfo->BusTypeGuid = GUID_BUS_TYPE_ISAPNP;
        pnpBusInfo->LegacyBusType = Isa;
        pnpBusInfo->BusNumber = busExtension->BusNumber;
        information = pnpBusInfo;
        status = STATUS_SUCCESS;
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
        information = NULL;
    }
    Irp->IoStatus.Information = (ULONG_PTR) information;

    return status;
} // PiQueryBusInformationPdo

NTSTATUS
PiDeviceUsageNotificationPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    This routine notes whether an ISAPNP device is on the crashdump or
    paging file path.  It fails attempts to put us on the hibernation path.

Arguments:

    DeviceObject - Pointer to the PDO for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/
{
    PDEVICE_INFORMATION deviceInfo;
    PIO_STACK_LOCATION irpSp;
    PLONG addend;
    NTSTATUS status = STATUS_SUCCESS;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    if ((deviceInfo = PipReferenceDeviceInformation(DeviceObject, FALSE)) == NULL) {

        status = STATUS_NO_SUCH_DEVICE;
        return status;
    }

    DebugPrint((DEBUG_PNP, "DeviceUsage CSN %d/LSN %d: InPath %s Type %d\n",
                deviceInfo->CardInformation->CardSelectNumber,
                deviceInfo->LogicalDeviceNumber,
                irpSp->Parameters.UsageNotification.InPath ? "TRUE" : "FALSE",
                irpSp->Parameters.UsageNotification.Type));

    switch (irpSp->Parameters.UsageNotification.Type) {
    case DeviceUsageTypePaging:
        addend = &deviceInfo->Paging;
        break;
    case DeviceUsageTypeHibernation:
        status = STATUS_DEVICE_BUSY;
        break;
    case DeviceUsageTypeDumpFile:
        addend = &deviceInfo->CrashDump;
        break;
    default:
        status = STATUS_NOT_SUPPORTED;
    }

    if (status == STATUS_SUCCESS) {
        if (irpSp->Parameters.UsageNotification.InPath) {
            //
            // Turn on broken isolation flag which causes QDR
            // to use the cache instead of beating on the hardware if
            // we're on the paging or crashdump paths.  Some
            // hardware appears unhappy during QDR and causes problems when
            // we take a page fault in this routine.
            //

            deviceInfo->CardInformation->CardFlags |= CF_ISOLATION_BROKEN;
            (*addend)++;
            IoInvalidateDeviceState(DeviceObject);
        }
        else {
            (*addend)--;
        }
    }
    PipDereferenceDeviceInformation(deviceInfo, FALSE);
    return status;
}

NTSTATUS
PiQueryInterfacePdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{

    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(Irp);

    return STATUS_NOT_SUPPORTED;

} // PiQueryInterfacePdo


NTSTATUS
PiSurpriseRemovePdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PDEVICE_INFORMATION deviceInfo;
    PSINGLE_LIST_ENTRY deviceLink;

    DebugPrint((DEBUG_PNP, "SurpriseRemove PDO %x\n", DeviceObject));
    //
    // One of our enumerated device is being removed.  Mark it and deactivate the
    // device.  Note, we do NOT delete its device object.
    //

    if (deviceInfo = PipReferenceDeviceInformation(DeviceObject, FALSE)) {
        if (deviceInfo->Flags & DF_READ_DATA_PORT) {
            //
            // If the RDP is removed, mark everyone as missing, and then return only the
            // RDP
            //
            PipLockDeviceDatabase();

            deviceLink = deviceInfo->ParentDeviceExtension->DeviceList.Next;
            while (deviceLink) {
                deviceInfo = CONTAINING_RECORD (deviceLink, DEVICE_INFORMATION, DeviceList);
                if (!(deviceInfo->Flags & DF_READ_DATA_PORT)) {
                    deviceInfo->Flags &= ~DF_ENUMERATED;
                }
                deviceLink = deviceInfo->DeviceList.Next;
            }

            PipUnlockDeviceDatabase();

            IoInvalidateDeviceRelations (
                deviceInfo->ParentDeviceExtension->PhysicalBusDevice,BusRelations);
        } else {
            DebugPrint((DEBUG_STATE,
                        "Surprise removing CSN %d/LDN %d\n",
                        deviceInfo->CardInformation->CardSelectNumber,
                        deviceInfo->LogicalDeviceNumber));
            if ((deviceInfo->Flags & (DF_ACTIVATED|DF_NOT_FUNCTIONING)) == DF_ACTIVATED) {
                PipWakeAndSelectDevice(
                    (UCHAR) deviceInfo->CardInformation->CardSelectNumber,
                    (UCHAR)deviceInfo->LogicalDeviceNumber);
                PipDeactivateDevice();
                PipWaitForKey();
            }

            PipReleaseDeviceResources (deviceInfo);
            deviceInfo->Flags |= DF_SURPRISE_REMOVED;
            deviceInfo->Flags &= ~(DF_QUERY_STOPPED|DF_REMOVED|DF_ACTIVATED);
        }
        PipDereferenceDeviceInformation(deviceInfo, FALSE);
        status = STATUS_SUCCESS;
    } else {
        status = STATUS_NO_SUCH_DEVICE;
    }

    return status;
} // PiSurpriseRemovePdo



NTSTATUS
PiIrpNotSupported(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{

    return STATUS_NOT_SUPPORTED;

} // PiIrpNotSupported

NTSTATUS
PipBuildRDPResources(
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST *IoResources,
    IN ULONG    Flags
    )
{
        ULONG MaxCards = 0, CardsFound;
        int i, j, numcases;
        int resSize;

        ASSERT(Flags & DF_READ_DATA_PORT);

        //
        // We need to assemble all possible cases for the RDP
        //
        numcases = 2*READ_DATA_PORT_RANGE_CHOICES;

        if (Flags & DF_REQ_TRIMMED) {
            numcases = 0;
            for (i = 0; i < READ_DATA_PORT_RANGE_CHOICES; i++) {
                CardsFound = PipReadDataPortRanges[i].CardsFound;
                if (MaxCards < CardsFound) {
                    MaxCards = CardsFound;
                    numcases = 1;
                } else if (MaxCards == CardsFound) {
                    numcases++;
                }
            }
        }
        //
        // need to allow for the RDP range, the address port, the cmd port and the 0
        //
        resSize = sizeof (IO_RESOURCE_LIST)+((numcases+3)*sizeof (IO_RESOURCE_REQUIREMENTS_LIST));

        *IoResources = (PIO_RESOURCE_REQUIREMENTS_LIST) ExAllocatePool (PagedPool,resSize);
        if (*IoResources == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory (*IoResources,resSize);

        (*IoResources)->BusNumber=0;
        (*IoResources)->AlternativeLists = 1;
        (*IoResources)->List->Count = numcases+4;
        (*IoResources)->List->Version = ISAPNP_IO_VERSION;
        (*IoResources)->List->Revision =ISAPNP_IO_REVISION;

        //
        // Requirements specify 16-bit decode even though the spec
        // says 12.  No ill effects have ever been observed from 16
        // and 12-bit decode broke some machines when tried.

        //
        // cmd port
        //
        (*IoResources)->List->Descriptors[0].Type=CM_RESOURCE_PORT_IO;
        (*IoResources)->List->Descriptors[0].u.Port.MinimumAddress.LowPart = COMMAND_PORT;
        (*IoResources)->List->Descriptors[0].u.Port.MaximumAddress.LowPart = COMMAND_PORT;

        (*IoResources)->List->Descriptors[0].u.Port.Length = 1;
        (*IoResources)->List->Descriptors[0].u.Port.Alignment = 1;
        (*IoResources)->List->Descriptors[0].Flags = CM_RESOURCE_PORT_16_BIT_DECODE;
        (*IoResources)->List->Descriptors[0].ShareDisposition = CmResourceShareDeviceExclusive;

        //
        // alternative of 0 for bioses that include COMMAND_PORT in
        // a PNP0C02 node.
        //
        (*IoResources)->List->Descriptors[1].Type=CM_RESOURCE_PORT_IO;
        (*IoResources)->List->Descriptors[1].u.Port.MinimumAddress.QuadPart = 0;
        (*IoResources)->List->Descriptors[1].u.Port.MaximumAddress.QuadPart = 0;

        (*IoResources)->List->Descriptors[1].u.Port.Length = 0;
        (*IoResources)->List->Descriptors[1].u.Port.Alignment  = 1;
        (*IoResources)->List->Descriptors[1].Flags = CM_RESOURCE_PORT_16_BIT_DECODE;
        (*IoResources)->List->Descriptors[1].ShareDisposition = CmResourceShareDeviceExclusive;
        (*IoResources)->List->Descriptors[1].Option = IO_RESOURCE_ALTERNATIVE;

        //
        // Address port
        //
        (*IoResources)->List->Descriptors[2].Type=CM_RESOURCE_PORT_IO;
        (*IoResources)->List->Descriptors[2].u.Port.MinimumAddress.LowPart = ADDRESS_PORT;
        (*IoResources)->List->Descriptors[2].u.Port.MaximumAddress.LowPart = ADDRESS_PORT;

        (*IoResources)->List->Descriptors[2].u.Port.Length = 1;
        (*IoResources)->List->Descriptors[2].u.Port.Alignment = 1;
        (*IoResources)->List->Descriptors[2].Flags = CM_RESOURCE_PORT_16_BIT_DECODE;
        (*IoResources)->List->Descriptors[2].ShareDisposition = CmResourceShareDeviceExclusive;
        //
        // alternative of 0
        //
        (*IoResources)->List->Descriptors[3].Type=CM_RESOURCE_PORT_IO;
        (*IoResources)->List->Descriptors[3].u.Port.MinimumAddress.QuadPart = 0;
        (*IoResources)->List->Descriptors[3].u.Port.MaximumAddress.QuadPart = 0;

        (*IoResources)->List->Descriptors[3].u.Port.Length = 0;
        (*IoResources)->List->Descriptors[3].u.Port.Alignment  = 1;
        (*IoResources)->List->Descriptors[3].Flags = CM_RESOURCE_PORT_16_BIT_DECODE;
        (*IoResources)->List->Descriptors[3].ShareDisposition = CmResourceShareDeviceExclusive;
        (*IoResources)->List->Descriptors[3].Option = IO_RESOURCE_ALTERNATIVE;

        if (Flags & DF_REQ_TRIMMED) {
            j = 0;
            for (i = 0; i < READ_DATA_PORT_RANGE_CHOICES; i++) {
                if (PipReadDataPortRanges[i].CardsFound != MaxCards) {
                    continue;
                }
                //
                // An RDP alternative
                //
                (*IoResources)->List->Descriptors[4+j].Type=CM_RESOURCE_PORT_IO;

                (*IoResources)->List->Descriptors[4+j].u.Port.MinimumAddress.LowPart =
                    PipReadDataPortRanges[i].MinimumAddress;
                (*IoResources)->List->Descriptors[4+j].u.Port.MaximumAddress.LowPart =
                    PipReadDataPortRanges[i].MaximumAddress;

                (*IoResources)->List->Descriptors[4+j].u.Port.Length =
                    PipReadDataPortRanges[i].MaximumAddress  -
                    PipReadDataPortRanges[i].MinimumAddress+1;
                (*IoResources)->List->Descriptors[4+j].u.Port.Alignment  = 1;
                (*IoResources)->List->Descriptors[4+j].Flags = CM_RESOURCE_PORT_16_BIT_DECODE;
                (*IoResources)->List->Descriptors[4+j].ShareDisposition = CmResourceShareDeviceExclusive;
                (*IoResources)->List->Descriptors[4+j].Option = IO_RESOURCE_ALTERNATIVE;
                j++;
            }
            (*IoResources)->List->Descriptors[4].Option = 0;
        } else {
            for (i = 0;i< (numcases >> 1);i++) {
                //
                // The RDP
                //
                (*IoResources)->List->Descriptors[4+i*2].Type=CM_RESOURCE_PORT_IO;

                (*IoResources)->List->Descriptors[4+i*2].u.Port.MinimumAddress.LowPart =
                    PipReadDataPortRanges[i].MinimumAddress;
                (*IoResources)->List->Descriptors[4+i*2].u.Port.MaximumAddress.LowPart =
                    PipReadDataPortRanges[i].MaximumAddress;

                (*IoResources)->List->Descriptors[4+i*2].u.Port.Length =
                    PipReadDataPortRanges[i].MaximumAddress  -
                    PipReadDataPortRanges[i].MinimumAddress+1;

                (*IoResources)->List->Descriptors[4+i*2].u.Port.Alignment  = 1;
                (*IoResources)->List->Descriptors[4+i*2].Flags = CM_RESOURCE_PORT_16_BIT_DECODE;
                (*IoResources)->List->Descriptors[4+i*2].ShareDisposition = CmResourceShareDeviceExclusive;

                //
                // alternative of 0
                //
                (*IoResources)->List->Descriptors[4+i*2+1].Type=CM_RESOURCE_PORT_IO;
                (*IoResources)->List->Descriptors[4+i*2+1].u.Port.MinimumAddress.QuadPart = 0;
                (*IoResources)->List->Descriptors[4+i*2+1].u.Port.MaximumAddress.QuadPart = 0;

                (*IoResources)->List->Descriptors[4+i*2+1].u.Port.Length = 0;
                (*IoResources)->List->Descriptors[4+i*2+1].u.Port.Alignment  = 1;
                (*IoResources)->List->Descriptors[4+i*2+1].Flags = CM_RESOURCE_PORT_16_BIT_DECODE;
                (*IoResources)->List->Descriptors[4+i*2+1].ShareDisposition = CmResourceShareDeviceExclusive;
                (*IoResources)->List->Descriptors[4+i*2+1].Option = IO_RESOURCE_ALTERNATIVE;

            }

        }
        (*IoResources)->ListSize = resSize;

        return STATUS_SUCCESS;
}

NTSTATUS
PiQueryDeviceState(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status=STATUS_NOT_SUPPORTED;
    PDEVICE_INFORMATION deviceInfo;

    //
    // One of our enumerated device is being removed.  Mark it and deactivate the
    // device.  Note, we do NOT delete its device object.
    //

    if (deviceInfo = PipReferenceDeviceInformation(DeviceObject, FALSE)) {

        if ((deviceInfo->Flags & DF_READ_DATA_PORT) && (deviceInfo->Flags & DF_PROCESSING_RDP)) {
            Irp->IoStatus.Information |= PNP_DEVICE_RESOURCE_REQUIREMENTS_CHANGED |
                                         PNP_DEVICE_FAILED |
                                         PNP_DEVICE_NOT_DISABLEABLE ;
            status = STATUS_SUCCESS;
        }

        if (deviceInfo->Paging || deviceInfo->CrashDump) {
            Irp->IoStatus.Information |= PNP_DEVICE_NOT_DISABLEABLE;
            status = STATUS_SUCCESS;
        }
        PipDereferenceDeviceInformation(deviceInfo, FALSE);
   }
   return status;

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\isapnp\translate.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    translate.c

Abstract:

    This is the ISA pnp IRQ translator.

Author:

    Andy Thornton (andrewth) 7-June-97

Environment:

    Kernel Mode Driver.

Notes:

    This should only be temporary and will be replaced by a call into the HAL
    to retrieve its translators.

Revision History:

--*/


#include "busp.h"
#include "wdmguid.h"
#include "halpnpp.h"

//
//Prototypes
//
NTSTATUS FindInterruptTranslator (PPI_BUS_EXTENSION BusExtension,PIRP Irp);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,PiQueryInterface)
#pragma alloc_text (PAGE,FindInterruptTranslator)
#pragma alloc_text (PAGE,PipReleaseInterfaces)
#pragma alloc_text (PAGE,PipRebuildInterfaces)
#endif


NTSTATUS
PiQueryInterface (
    IN PPI_BUS_EXTENSION BusExtension,
    IN OUT PIRP Irp
    )
{

    NTSTATUS              status;
    PIO_STACK_LOCATION    thisIrpSp;

    PAGED_CODE();

    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );
    status = STATUS_NOT_SUPPORTED;

    //
    // Check if we are requesting a translator interface
    //

    if (RtlEqualMemory(&GUID_TRANSLATOR_INTERFACE_STANDARD,
                       thisIrpSp->Parameters.QueryInterface.InterfaceType,
                       sizeof(GUID))) {

        status = FindInterruptTranslator (BusExtension,Irp);
        if (NT_SUCCESS (status)) {
            //
            // Save away the hal interface, so we can unload it...
            //
        }
    }

    return status;
}

NTSTATUS
FindInterruptTranslator (PPI_BUS_EXTENSION BusExtension,PIRP Irp)
{
    NTSTATUS              status;
    PIO_STACK_LOCATION    thisIrpSp;
    PTRANSLATOR_INTERFACE translator;
    ULONG busNumber, length;
    INTERFACE_TYPE interfaceType;

    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );
    status = STATUS_NOT_SUPPORTED;

    if ((UINT_PTR)(thisIrpSp->Parameters.QueryInterface.InterfaceSpecificData) ==
    CmResourceTypeInterrupt) {

    //
    // Retrieve the bus number and interface type for the bridge
    //

    status = IoGetDeviceProperty(BusExtension->PhysicalBusDevice,
                                 DevicePropertyLegacyBusType,
                                 sizeof(INTERFACE_TYPE),
                                 &interfaceType,
                                 &length
                                 );

    //ASSERT(NT_SUCCESS(status));

    status = IoGetDeviceProperty(BusExtension->PhysicalBusDevice,
                                 DevicePropertyBusNumber,
                                 sizeof(ULONG),
                                 &busNumber,
                                 &length
                                 );

    //ASSERT(NT_SUCCESS(status));

    status = HalGetInterruptTranslator(
                interfaceType,
                busNumber,
                Isa,
                thisIrpSp->Parameters.QueryInterface.Size,
                thisIrpSp->Parameters.QueryInterface.Version,
                (PTRANSLATOR_INTERFACE) thisIrpSp->Parameters.QueryInterface.Interface,
                &busNumber
                );

    }
    return status;

}

NTSTATUS
PipReleaseInterfaces(PPI_BUS_EXTENSION PipBusExtension)
{


    return STATUS_SUCCESS;
}

NTSTATUS
PipRebuildInterfaces(PPI_BUS_EXTENSION PipBusExtension)
{

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\isapnp\power.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    power.c

Abstract:

    This file contains the support for power management

Environment:

    Kernel Mode Driver.

Notes:

    Nothing in here or in routines referenced from here should be pageable.

Revision History:

--*/

#include "busp.h"
#include "pnpisa.h"
#include <initguid.h>
#include <wdmguid.h>
#include "halpnpp.h"

NTSTATUS
PiDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiDispatchPowerFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PiDispatchPowerPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PipPassPowerIrpFdo(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
PipPowerIrpNotSupportedPdo(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
PipQueryPowerStatePdo (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PipSetPowerStatePdo (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PipSetQueryPowerStateFdo (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PipRequestPowerUpCompletionRoutinePdo (
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    );

NTSTATUS
FdoContingentPowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

const PUCHAR SystemPowerStateStrings[] = {
    "Unspecified",
    "Working",
    "Sleeping1",
    "Sleeping2",
    "Sleeping3",
    "Hibernate",
    "Shutdown"
};

const PUCHAR DevicePowerStateStrings[] = {
    "Unspecified",
    "D0",
    "D1",
    "D2",
    "D3"
};

const PPI_DISPATCH PiPowerDispatchTableFdo[] =
{
    PipPassPowerIrpFdo,
    PipPassPowerIrpFdo,
    PipSetQueryPowerStateFdo,
    PipSetQueryPowerStateFdo,
};

#if ISOLATE_CARDS
const PPI_DISPATCH PiPowerDispatchTablePdo[] =
{
    PipPowerIrpNotSupportedPdo,
    PipPowerIrpNotSupportedPdo,
    PipSetPowerStatePdo,
    PipQueryPowerStatePdo,
};
#endif


VOID
PipDumpPowerIrpLocation(
    PIO_STACK_LOCATION IrpSp
    )
{
    DebugPrintContinue((
        DEBUG_POWER,
        "%s %d\n",
        (IrpSp->Parameters.Power.Type == DevicePowerState) ?
        DevicePowerStateStrings[IrpSp->Parameters.Power.State.DeviceState] : SystemPowerStateStrings[IrpSp->Parameters.Power.State.SystemState],
        IrpSp->Parameters.Power.ShutdownType));
}

NTSTATUS
PiDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles all the IRP_MJ_POWER IRPs.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP_POWER IRP to dispatch.

Return Value:

    NT status.

--*/
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status = STATUS_SUCCESS;
    PPI_BUS_EXTENSION busExtension;

    //
    // Make sure this is a valid device object.
    //

    busExtension = DeviceObject->DeviceExtension;

#if !ISOLATE_CARDS
    return PiDispatchPowerFdo(DeviceObject, Irp);
#else
    if (busExtension->Flags & DF_BUS) {
        return PiDispatchPowerFdo(DeviceObject, Irp);
    } else {
        return PiDispatchPowerPdo(DeviceObject, Irp);
    }
#endif
}

#if ISOLATE_CARDS

NTSTATUS
PipPowerIrpNotSupportedPdo(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{
    PIO_STACK_LOCATION irpSp;

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    PoStartNextPowerIrp(Irp);

    DebugPrint((DEBUG_POWER,
                "Completing unsupported power irp %x for PDO %x\n",
                irpSp->MinorFunction,
                DeviceObject
                ));

    PipCompleteRequest(Irp, STATUS_NOT_SUPPORTED, NULL);
    return STATUS_NOT_SUPPORTED;
}

NTSTATUS
PiDispatchPowerPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles all the IRP_MJ_POWER IRPs.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP_POWER IRP to dispatch.

Return Value:

    NT status.

--*/
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_INFORMATION deviceExtension;

    //
    // Make sure this is a valid device object.
    //

    deviceExtension = DeviceObject->DeviceExtension;
    if (deviceExtension->Flags & DF_DELETED) {
        status = STATUS_NO_SUCH_DEVICE;
        PoStartNextPowerIrp(Irp);
        PipCompleteRequest(Irp, status, NULL);
        return status;
    }

    //
    // Get a pointer to our stack location and take appropriate action based
    // on the minor function.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    if (irpSp->MinorFunction > IRP_MN_PO_MAXIMUM_FUNCTION) {
        status =  PipPowerIrpNotSupportedPdo(DeviceObject, Irp);
    } else {
        status = PiPowerDispatchTablePdo[irpSp->MinorFunction](DeviceObject, Irp);
    }
    return status;
}

NTSTATUS
PipQueryPowerStatePdo (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    This routine handles the Query_Power irp for the PDO .

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP_POWER IRP to dispatch.

Return Value:

    NT status.

--*/
{

    DEVICE_POWER_STATE targetState;
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);

    DebugPrint((DEBUG_POWER, "QueryPower on PDO %x: ", DeviceObject));
    PipDumpPowerIrpLocation(irpSp);

    if (irpSp->Parameters.Power.Type == DevicePowerState) {
        targetState=irpSp->Parameters.Power.State.DeviceState;
        ASSERT ((targetState == PowerDeviceD0) ||
                (targetState == PowerDeviceD3));

        if ((targetState == PowerDeviceD0) ||
            (targetState == PowerDeviceD3) ) {

            status=Irp->IoStatus.Status = STATUS_SUCCESS;
        } else {
            status=Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        }
    } else {
        //
        // Just succeed S irps
        //
        status=Irp->IoStatus.Status = STATUS_SUCCESS;
    }

    PoStartNextPowerIrp (Irp);
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DebugPrint((DEBUG_POWER, "QueryPower on PDO %x: returned %x\n", DeviceObject, status));
    return status;

}

NTSTATUS
PipSetPowerStatePdo (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles SET_POWER_IRP for the IsaPnp device (i.e. PDO)
    It sets the devices power state to the power state type as indicated.  In
    the case of a device state change which is transitioning a device out of
    the PowerDevice0 state, we need call PoSetPowerState prior to leaving the
    PowerDeviceD0.  In the case if a device state change which is transitioning
    a device into the PowerDeviceD0 state, we call PoSetPowerState after the
    device is successfully put into the PowerDeviceD0 state.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP_POWER IRP to dispatch.

Return Value:

    NT status.

--*/
{
    PDEVICE_INFORMATION pdoExtension;
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);
    DEVICE_POWER_STATE targetState=irpSp->Parameters.Power.State.DeviceState;
    POWER_STATE newState;

    DebugPrint((DEBUG_POWER, "SetPower on PDO %x: ", DeviceObject));
    PipDumpPowerIrpLocation(irpSp);

    pdoExtension = PipReferenceDeviceInformation(DeviceObject, FALSE);
    if (pdoExtension == NULL) {
        status = STATUS_NO_SUCH_DEVICE;
    } else if (pdoExtension->Flags & DF_NOT_FUNCTIONING) {
        status = STATUS_NO_SUCH_DEVICE;
        PipDereferenceDeviceInformation(pdoExtension, FALSE);
    } else {
        if (irpSp->Parameters.Power.Type == DevicePowerState) {

            // * On transition from D0 to D0, we do nothing.
            //
            // * On transition to D3, we'll deactivate the card.
            //
            // * On transition from D3->D0 we'll refresh the resources
            // and activate the card.
            //
            if ((targetState == PowerDeviceD0) &&
                (pdoExtension->DevicePowerState == PowerDeviceD0)) {
                // Do not try to power device back up if this is a D0->D0
                // transition.  The device is already powered.
                DebugPrint((DEBUG_POWER,
                            "PDO %x D0 -> D0 Transition ignored\n", DeviceObject));
            } else if ((pdoExtension->DevicePowerState == PowerDeviceD0) &&
                       pdoExtension->CrashDump) {
                DebugPrint((DEBUG_POWER,
                            "PDO %x D0 -> ?? Transition ignored, crash file\n",
                            DeviceObject));
            } else if (targetState >  PowerDeviceD0) {
                targetState = PowerDeviceD3;
                DebugPrint((DEBUG_POWER,
                            "Powering down PDO %x CSN %d/LDN %d\n",
                            DeviceObject,
                            pdoExtension->CardInformation->CardSelectNumber,
                            pdoExtension->LogicalDeviceNumber
                            ));
                if ((pdoExtension->Flags & (DF_ACTIVATED | DF_READ_DATA_PORT)) == DF_ACTIVATED) {
                    if (!(PipRDPNode->Flags & (DF_STOPPED|DF_REMOVED|DF_SURPRISE_REMOVED))) {
                        PipWakeAndSelectDevice(
                            (UCHAR) pdoExtension->CardInformation->CardSelectNumber,
                            (UCHAR) pdoExtension->LogicalDeviceNumber);
                        PipDeactivateDevice();
                        PipWaitForKey();
                    } else {
                        targetState = PowerDeviceD0;
                    }
                }
            } else {
                if ((pdoExtension->Flags & (DF_ACTIVATED | DF_READ_DATA_PORT)) == DF_ACTIVATED) {
                    DebugPrint((DEBUG_POWER,
                                "Powering up PDO %x CSN %d/LDN %d\n",
                                DeviceObject,
                                pdoExtension->CardInformation->CardSelectNumber,
                                pdoExtension->LogicalDeviceNumber
                                ));
                    if (!(PipRDPNode->Flags & (DF_STOPPED|DF_REMOVED|DF_SURPRISE_REMOVED))) {
                        PipWakeAndSelectDevice(
                            (UCHAR) pdoExtension->CardInformation->CardSelectNumber,
                            (UCHAR) pdoExtension->LogicalDeviceNumber);
                        status = PipSetDeviceResources(
                            pdoExtension,
                            pdoExtension->AllocatedResources);
                        if (NT_SUCCESS(status)) {
                            PipActivateDevice();
                        }
                        PipWaitForKey();
                    } else {
                        targetState = PowerDeviceD3;
                    }

                }
            }
            newState.DeviceState = targetState;
            PoSetPowerState(DeviceObject, DevicePowerState, newState);
            pdoExtension->DevicePowerState = targetState;
        }
        status = STATUS_SUCCESS;
        PipDereferenceDeviceInformation(pdoExtension, FALSE);
    }

    Irp->IoStatus.Status = status;

    PoStartNextPowerIrp (Irp);
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DebugPrint((DEBUG_POWER, "SetPower on PDO %x: returned %x\n", DeviceObject, status));
    return status;
}
#endif

NTSTATUS
PipPassPowerIrpFdo(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Description:

    This function pass the power Irp to lower level driver.

Arguments:

    DeviceObject - the Fdo
    Irp - the request

Return:

    STATUS_PENDING

--*/
{
    NTSTATUS status;
    PPI_BUS_EXTENSION busExtension;
    PIO_STACK_LOCATION irpSp;

    PoStartNextPowerIrp(Irp);

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    busExtension = (PPI_BUS_EXTENSION) DeviceObject->DeviceExtension;

    DebugPrint((DEBUG_POWER,
                "Passing down power irp %x for FDO %x to %x\n",
                irpSp->MinorFunction,
                DeviceObject,
                busExtension->AttachedDevice
                ));

    IoSkipCurrentIrpStackLocation(Irp);
    status = PoCallDriver(busExtension->AttachedDevice, Irp);
    DebugPrint((DEBUG_POWER,
                "Passed down power irp for FDO: returned %x\n",
                status));
    return status;
}

NTSTATUS
PiDispatchPowerFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles all the IRP_MJ_POWER IRPs.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP_POWER IRP to dispatch.

Return Value:

    NT status.

--*/
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status = STATUS_SUCCESS;
    PPI_BUS_EXTENSION busExtension;

    //
    // Make sure this is a valid device object.
    //

    busExtension = DeviceObject->DeviceExtension;
    if (busExtension->AttachedDevice == NULL) {
        status = STATUS_NO_SUCH_DEVICE;
        PoStartNextPowerIrp(Irp);
        PipCompleteRequest(Irp, status, NULL);
        return status;
    }

    //
    // Get a pointer to our stack location and take appropriate action based
    // on the minor function.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    if (irpSp->MinorFunction > IRP_MN_PO_MAXIMUM_FUNCTION) {
            return PipPassPowerIrpFdo(DeviceObject, Irp);
    } else {
        status = PiPowerDispatchTableFdo[irpSp->MinorFunction](DeviceObject, Irp);
    }
    return status;
}

NTSTATUS
PipSetQueryPowerStateFdo (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles QUERY_POWER or SET_POWER IRPs for the IsaPnp bus device
    (i.e. FDO). It sets the devices power state for the power state type as indicated.
    In the case of a device state change which is transitioning a device out of
    the PowerDevice0 state, we need call PoSetPowerState prior to leaving the
    PowerDeviceD0.  In the case if a device state change which is transitioning
    a device into the PowerDeviceD0 state, we call PoSetPowerState after the
    device is successfully put into the PowerDeviceD0 state.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP_POWER IRP to dispatch.

Return Value:

    NT status.

--*/
{
    PPI_BUS_EXTENSION  fdoExtension;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    fdoExtension = DeviceObject->DeviceExtension;

    irpSp = IoGetCurrentIrpStackLocation (Irp);

    DebugPrint((DEBUG_POWER, "%s on FDO %x: ",
                (irpSp->MinorFunction == IRP_MN_SET_POWER) ? "SetPower" :
                "QueryPower", DeviceObject));
    PipDumpPowerIrpLocation(irpSp);

    if (irpSp->Parameters.Power.Type == SystemPowerState) {
        POWER_STATE powerState;

        switch (irpSp->Parameters.Power.State.SystemState) {
            case PowerSystemWorking:

                //
                // Make sure the bus is on for these system states
                //

                powerState.DeviceState = PowerDeviceD0;
                break;

            case PowerSystemSleeping1:
            case PowerSystemHibernate:
            case PowerSystemShutdown:
            case PowerSystemSleeping2:
            case PowerSystemSleeping3:

                //
                // Going to sleep  ... Power down
                //

                powerState.DeviceState = PowerDeviceD3;
                break;

            default:

                //
                // Unknown request - be safe power up
                //

                ASSERT (TRUE == FALSE);
                powerState.DeviceState = PowerDeviceD0;
                break;
        }

        DebugPrint((DEBUG_POWER, "request power irp to busdev %x, pending\n",
                    fdoExtension->FunctionalBusDevice));
        IoMarkIrpPending(Irp);
        PoRequestPowerIrp (
            fdoExtension->FunctionalBusDevice,
            irpSp->MinorFunction,
            powerState,
            FdoContingentPowerCompletionRoutine,
            Irp,
            NULL
            );

        return STATUS_PENDING;

    }

    status = PipPassPowerIrpFdo(DeviceObject, Irp);
    DebugPrint((DEBUG_POWER, "SetPower(device) on FDO %x: returned %x\n", DeviceObject, status));
    return status;
}


NTSTATUS
FdoContingentPowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PIRP irp = Context;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (irp);

    DebugPrint((DEBUG_POWER, "requested power irp completed to %x\n", DeviceObject));

    //
    // Propagate the status of the transient power IRP
    //
    irp->IoStatus.Status = IoStatus->Status;

    if (NT_SUCCESS(IoStatus->Status)) {

        PPI_BUS_EXTENSION fdoExtension;

        fdoExtension = DeviceObject->DeviceExtension;

        PoStartNextPowerIrp (irp);
        //
        // changing device power state call PoSetPowerState now.
        //

        if (MinorFunction == IRP_MN_SET_POWER) {
            SYSTEM_POWER_STATE OldSystemPowerState = fdoExtension->SystemPowerState;

            fdoExtension->SystemPowerState = irpSp->Parameters.Power.State.SystemState;
            fdoExtension->DevicePowerState = PowerState.DeviceState;
            PoSetPowerState (
                DeviceObject,
                DevicePowerState,
                PowerState
                );
            DebugPrint((DEBUG_POWER, "New FDO %x powerstate system %s/%s\n",
                        DeviceObject,
                        SystemPowerStateStrings[fdoExtension->SystemPowerState],
                        DevicePowerStateStrings[fdoExtension->DevicePowerState]));
#if ISOLATE_CARDS

            if ((OldSystemPowerState == PowerSystemHibernate) ||
                (OldSystemPowerState == PowerSystemSleeping3) ) {
                BOOLEAN needsRescan;

                PipReportStateChange(PiSWaitForKey);
                if ((fdoExtension->BusNumber == 0) && PipRDPNode &&
                    (PipRDPNode->Flags & (DF_ACTIVATED|DF_PROCESSING_RDP|DF_QUERY_STOPPED)) == DF_ACTIVATED) {
                    needsRescan = PipMinimalCheckBus(fdoExtension);
                    if (needsRescan) {
                        PipRDPNode->Flags |= DF_NEEDS_RESCAN;
                        IoInvalidateDeviceRelations(
                            fdoExtension->PhysicalBusDevice,
                            BusRelations);
                    }
                }
            }
#endif
        }

        IoSkipCurrentIrpStackLocation (irp);
        PoCallDriver (fdoExtension->AttachedDevice, irp);

    } else {

        PoStartNextPowerIrp (irp);
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }

    return STATUS_SUCCESS;
} // FdoContingentPowerCompletionRoutine
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\isapnp\resource.c ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    devres.c

Abstract:

    This module contains the high level device resources support routines.

Author:

    Shie-Lin Tzong (shielint) July-27-1995

Environment:

    Kernel mode only.

Revision History:

--*/

#include "busp.h"
#include "pnpisa.h"
#include "pbios.h"
#include "pnpcvrt.h"

#if ISOLATE_CARDS

#define IDBG 0

#if 0
NTSTATUS
PipFilterResourceRequirementsList(
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST *IoResources
    );
#endif

PIO_RESOURCE_REQUIREMENTS_LIST
PipCmResourcesToIoResources (
    IN PCM_RESOURCE_LIST CmResourceList
    );

NTSTATUS
PipMergeResourceRequirementsLists (
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoList1,
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoList2,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST *MergedList
    );

NTSTATUS
PipBuildBootResourceRequirementsList (
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoList,
    IN PCM_RESOURCE_LIST CmList,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST *FilteredList,
    OUT PBOOLEAN ExactMatch
    );

VOID
PipMergeBootResourcesToRequirementsList(
    PDEVICE_INFORMATION DeviceInfo,
    PCM_RESOURCE_LIST BootResources,
    PIO_RESOURCE_REQUIREMENTS_LIST *IoResources
    );

#pragma alloc_text(PAGE, PipGetCardIdentifier)
#pragma alloc_text(PAGE, PipGetFunctionIdentifier)
#pragma alloc_text(PAGE, PipGetCompatibleDeviceId)
#pragma alloc_text(PAGE, PipQueryDeviceId)
#pragma alloc_text(PAGE, PipQueryDeviceUniqueId)
//#pragma alloc_text(PAGE, PipQueryDeviceResources)
#pragma alloc_text(PAGE, PipQueryDeviceResourceRequirements)
//#pragma alloc_text(PAGE, PipFilterResourceRequirementsList)
#pragma alloc_text(PAGE, PipCmResourcesToIoResources)
#pragma alloc_text(PAGE, PipMergeResourceRequirementsLists)
#pragma alloc_text(PAGE, PipBuildBootResourceRequirementsList)
#pragma alloc_text(PAGE, PipMergeBootResourcesToRequirementsList)
//#pragma alloc_text(PAGE, PipSetDeviceResources)


NTSTATUS
PipGetCardIdentifier (
    PUCHAR CardData,
    PWCHAR *Buffer,
    PULONG BufferLength
    )
/*++

Routine Description:

    This function returns the identifier for a pnpisa card.

Arguments:

    CardData - supplies a pointer to the pnp isa device data.

    Buffer - supplies a pointer to variable to receive a pointer to the Id.

    BufferLength - supplies a pointer to a variable to receive the size of the id buffer.

Return Value:

    NTSTATUS code

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    UCHAR tag;
    LONG size, length;
    UNICODE_STRING unicodeString;
    ANSI_STRING ansiString;
    PCHAR ansiBuffer;

    *Buffer = NULL;
    *BufferLength = 0;

    if (CardData == NULL) {
        return status;
    }
    tag = *CardData;

    //
    // Make sure CardData does *NOT* point to a Logical Device Id tag
    //

    if ((tag & SMALL_TAG_MASK) == TAG_LOGICAL_ID) {
        DbgPrint("PipGetCardIdentifier: CardData is at a Logical Id tag\n");
        return status;
    }

    //
    // Find the resource descriptor which describle identifier string
    //

    do {

        //
        // Do we find the identifer resource tag?
        //

        if (tag == TAG_ANSI_ID) {
            CardData++;
            length = *(USHORT UNALIGNED *)CardData;
            CardData += 2;
            ansiBuffer = (PCHAR)ExAllocatePool(PagedPool, length+1);
            if (ansiBuffer == NULL) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            RtlMoveMemory(ansiBuffer, CardData, length);
            ansiBuffer[length] = 0;
            RtlInitAnsiString(&ansiString, ansiBuffer);
            status = RtlAnsiStringToUnicodeString(&unicodeString, &ansiString, TRUE);
            ExFreePool(ansiBuffer);
            if (!NT_SUCCESS(status)) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            *Buffer = unicodeString.Buffer;
            *BufferLength = unicodeString.Length + sizeof(WCHAR);
            break;
        }

        //
        // Determine the size of the BIOS resource descriptor and
        // advance to next resource descriptor.
        //

        if (!(tag & LARGE_RESOURCE_TAG)) {
            size = (USHORT)(tag & SMALL_TAG_SIZE_MASK);
            size += 1;     // length of small tag
        } else {
            size = *(USHORT UNALIGNED *)(CardData + 1);
            size += 3;     // length of large tag
        }

        CardData += size;
        tag = *CardData;

    } while ((tag != TAG_COMPLETE_END) && ((tag & SMALL_TAG_MASK) != TAG_LOGICAL_ID));

    return status;
}

NTSTATUS
PipGetFunctionIdentifier (
    PUCHAR DeviceData,
    PWCHAR *Buffer,
    PULONG BufferLength
    )
/*++

Routine Description:

    This function returns the desired pnp isa identifier for the specified
    DeviceData/LogicalFunction.  The Identifier for a logical function is
    optional.  If no Identifier available , Buffer is set to NULL.

Arguments:

    DeviceData - supplies a pointer to the pnp isa device data.

    Buffer - supplies a pointer to variable to receive a pointer to the Id.

    BufferLength - supplies a pointer to a variable to receive the size of the id buffer.

Return Value:

    NTSTATUS code

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    UCHAR tag;
    LONG size, length;
    UNICODE_STRING unicodeString;
    ANSI_STRING ansiString;
    PCHAR ansiBuffer;

    *Buffer = NULL;
    *BufferLength = 0;

    if (DeviceData==NULL) {
        return status;
    }
    tag = *DeviceData;

#if DBG

    //
    // Make sure device data points to Logical Device Id tag
    //

    if ((tag & SMALL_TAG_MASK) != TAG_LOGICAL_ID) {
        DbgPrint("PipGetFunctionIdentifier: DeviceData is not at a Logical Id tag\n");
    }
#endif

    //
    // Skip all the resource descriptors to find compatible Id descriptor
    //

    do {

        //
        // Determine the size of the BIOS resource descriptor and
        // advance to next resource descriptor.
        //

        if (!(tag & LARGE_RESOURCE_TAG)) {
            size = (USHORT)(tag & SMALL_TAG_SIZE_MASK);
            size += 1;     // length of small tag
        } else {
            size = *(USHORT UNALIGNED *)(DeviceData + 1);
            size += 3;     // length of large tag
        }

        DeviceData += size;
        tag = *DeviceData;

        //
        // Do we find the identifer resource tag?
        //

        if (tag == TAG_ANSI_ID) {
            DeviceData++;
            length = *(USHORT UNALIGNED *)DeviceData;
            DeviceData += 2;
            ansiBuffer = (PCHAR)ExAllocatePool(PagedPool, length+1);
            if (ansiBuffer == NULL) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            RtlMoveMemory(ansiBuffer, DeviceData, length);
            ansiBuffer[length] = 0;
            RtlInitAnsiString(&ansiString, ansiBuffer);
            status = RtlAnsiStringToUnicodeString(&unicodeString,
                                                  &ansiString,
                                                  TRUE);
            ExFreePool(ansiBuffer);
            if (!NT_SUCCESS(status)) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            *Buffer = unicodeString.Buffer;
            *BufferLength = unicodeString.Length + sizeof(WCHAR);
            break;
        }

    } while ((tag != TAG_COMPLETE_END) && ((tag & SMALL_TAG_MASK) != TAG_LOGICAL_ID));

    return status;
}

NTSTATUS
PipGetCompatibleDeviceId (
    PUCHAR DeviceData,
    ULONG IdIndex,
    PWCHAR *Buffer
    )
/*++

Routine Description:

    This function returns the desired pnp isa id for the specified DeviceData
    and Id index.  If Id index = 0, the Hardware ID will be return; if id
    index = n, the Nth compatible id will be returned.

Arguments:

    DeviceData - supplies a pointer to the pnp isa device data.

    IdIndex - supplies the index of the compatible id desired.

    Buffer - supplies a pointer to variable to receive a pointer to the compatible Id.

Return Value:

    NTSTATUS code

--*/
{
    NTSTATUS status = STATUS_NO_MORE_ENTRIES;
    UCHAR tag;
    ULONG count = 0,length;
    LONG size;
    UNICODE_STRING unicodeString;
    ANSI_STRING ansiString;
    UCHAR eisaId[8];
    ULONG id;


    //
    // Bail out BEFORE we touch the device data for the RDP
    //

    if (IdIndex == -1) {
        length = 2* sizeof(WCHAR);

        *Buffer = (PWCHAR) ExAllocatePool(PagedPool, length);
        if (*Buffer) {
            RtlZeroMemory (*Buffer,length);
        }else {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        return STATUS_SUCCESS;
    }



    tag = *DeviceData;

#if DBG

    //
    // Make sure device data points to Logical Device Id tag
    //

    if ((tag & SMALL_TAG_MASK) != TAG_LOGICAL_ID) {
        DbgPrint("PipGetCompatibleDeviceId: DeviceData is not at Logical Id tag\n");
    }
#endif

    if (IdIndex == 0) {

        //
        // Caller is asking for hardware id
        //

        DeviceData++;                                      // Skip tag
        id = *(ULONG UNALIGNED *)DeviceData;
        status = STATUS_SUCCESS;
    } else {

        //
        // caller is asking for compatible id
        //

        IdIndex--;

        //
        // Skip all the resource descriptors to find compatible Id descriptor
        //

        do {

            //
            // Determine the size of the BIOS resource descriptor and
            // advance to next resource descriptor.
            //

            if (!(tag & LARGE_RESOURCE_TAG)) {
                size = (USHORT)(tag & SMALL_TAG_SIZE_MASK);
                size += 1;     // length of small tag
            } else {
                size = *(USHORT UNALIGNED *)(DeviceData + 1);
                size += 3;     // length of large tag
            }

            DeviceData += size;
            tag = *DeviceData;

            //
            // Do we reach the compatible ID descriptor?
            //

            if ((tag & SMALL_TAG_MASK) == TAG_COMPATIBLE_ID) {
                if (count == IdIndex) {
                    id = *(ULONG UNALIGNED *)(DeviceData + 1);
                    status = STATUS_SUCCESS;
                    break;
                } else {
                    count++;
                }
            }

        } while ((tag != TAG_COMPLETE_END) && ((tag & SMALL_TAG_MASK) != TAG_LOGICAL_ID));
    }

    if (NT_SUCCESS(status)) {
        PipDecompressEisaId(id, eisaId);
        RtlInitAnsiString(&ansiString, eisaId);
        status = RtlAnsiStringToUnicodeString(&unicodeString, &ansiString, TRUE);
        if (!NT_SUCCESS(status)) {
            return status;
        }
        *Buffer = (PWCHAR)ExAllocatePool (
                        PagedPool,
                        sizeof(L"*") + sizeof(WCHAR) + unicodeString.Length
                        );
        if (*Buffer) {
            swprintf(*Buffer, L"*%s", unicodeString.Buffer);
        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
        RtlFreeUnicodeString(&unicodeString);
    }
    return status;
}

NTSTATUS
PipQueryDeviceUniqueId (
    PDEVICE_INFORMATION DeviceInfo,
    PWCHAR *DeviceId
    )
/*++

Routine Description:

    This function returns the unique id for the particular device.

Arguments:

    DeviceData - Device data information for the specificied device.

    DeviceId - supplies a pointer to a variable to receive device id.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    //
    // Set up device's unique id.
    // device unique id = SerialNumber of the card
    //

    *DeviceId = (PWCHAR)ExAllocatePool (
                        PagedPool,
                        (8 + 1) * sizeof(WCHAR)  // serial number + null
                        );
    if (*DeviceId) {
        if (DeviceInfo->Flags & DF_READ_DATA_PORT) {
            //
            // Override the unique ID for the RDP
            //
            swprintf (*DeviceId,
                      L"0"
                      );
        } else {
            swprintf (*DeviceId,
                      L"%01X",
                      ((PSERIAL_IDENTIFIER) (DeviceInfo->CardInformation->CardData))->SerialNumber
                      );
        }

#if IDBG
        {
            ANSI_STRING ansiString;
            UNICODE_STRING unicodeString;

            RtlInitUnicodeString(&unicodeString, *DeviceId);
            RtlUnicodeStringToAnsiString(&ansiString, &unicodeString, TRUE);
            DbgPrint("PnpIsa: return Unique Id = %s\n", ansiString.Buffer);
            RtlFreeAnsiString(&ansiString);
        }
#endif
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;

    }

    return status;
}

NTSTATUS
PipQueryDeviceId (
    PDEVICE_INFORMATION DeviceInfo,
    PWCHAR *DeviceId,
    ULONG IdIndex
    )
/*++

Routine Description:

    This function returns the device id for the particular device.

Arguments:

    DeviceInfo - Device information for the specificied device.

    DeviceId - supplies a pointer to a variable to receive the device id.

    IdIndex - specifies device id or compatible id (0 - device id)

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PWSTR format;
    ULONG size,length;
    UCHAR eisaId[8];
    UNICODE_STRING unicodeString;
    ANSI_STRING ansiString;


    //
    // Bail out BEFORE we touch the device data for the RDP
    //

    if (DeviceInfo->Flags & DF_READ_DATA_PORT) {
        length = (sizeof (wReadDataPort)+
             + sizeof(WCHAR) +sizeof (L"ISAPNP\\"));
        *DeviceId = (PWCHAR) ExAllocatePool(PagedPool, length);
        if (*DeviceId) {
           _snwprintf(*DeviceId, length, L"ISAPNP\\%s",wReadDataPort);
        } else {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        return STATUS_SUCCESS;
    }


    //
    // Set up device's id.
    // device id = VenderId + Logical device number
    //


    if (DeviceInfo->CardInformation->NumberLogicalDevices == 1) {
        format = L"ISAPNP\\%s";
        size = sizeof(L"ISAPNP\\*") + sizeof(WCHAR);
    } else {
        format = L"ISAPNP\\%s_DEV%04X";
        size = sizeof(L"ISAPNP\\_DEV") + 4 * sizeof(WCHAR) + sizeof(WCHAR);
    }
    PipDecompressEisaId(
          ((PSERIAL_IDENTIFIER) (DeviceInfo->CardInformation->CardData))->VenderId,
          eisaId
          );
    RtlInitAnsiString(&ansiString, eisaId);
    status = RtlAnsiStringToUnicodeString(&unicodeString, &ansiString, TRUE);
    if (!NT_SUCCESS(status)) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    size += unicodeString.Length;
    *DeviceId = (PWCHAR)ExAllocatePool (PagedPool, size);
    if (*DeviceId) {
        swprintf (*DeviceId,
                  format,
                  unicodeString.Buffer,
                  DeviceInfo->LogicalDeviceNumber
                  );
#if IDBG
        {
            ANSI_STRING dbgAnsiString;
            UNICODE_STRING dbgUnicodeString;

            RtlInitUnicodeString(&dbgUnicodeString, *DeviceId);
            RtlUnicodeStringToAnsiString(&dbgAnsiString, &dbgUnicodeString, TRUE);
            DbgPrint("PnpIsa: return device Id = %s\n", dbgAnsiString.Buffer);
            RtlFreeAnsiString(&dbgAnsiString);
        }
#endif
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlFreeUnicodeString(&unicodeString);

    return status;
}

NTSTATUS
PipQueryDeviceResources (
    PDEVICE_INFORMATION DeviceInfo,
    ULONG BusNumber,
    PCM_RESOURCE_LIST *CmResources,
    ULONG *Size
    )
/*++

Routine Description:

    This function returns the bus resources being used by the specified device

Arguments:

    DeviceInfo - Device information for the specificied slot

    BusNumber - should always be 0

    CmResources - supplies a pointer to a variable to receive the device resource
                  data.

    Size - Supplies a pointer to avariable to receive the size of device resource
           data.

Return Value:

    NTSTATUS code.

--*/
{
    ULONG length;
    NTSTATUS status = STATUS_SUCCESS;
    PCM_RESOURCE_LIST cmResources;

    *CmResources = NULL;
    *Size = 0;

    if (DeviceInfo->BootResources){ // && DeviceInfo->LogConfHandle) {

        *CmResources = ExAllocatePool(PagedPool, DeviceInfo->BootResourcesLength);
        if (*CmResources) {
            RtlMoveMemory(*CmResources, DeviceInfo->BootResources, DeviceInfo->BootResourcesLength);
            *Size = DeviceInfo->BootResourcesLength;
        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    return status;
}

NTSTATUS
PipQueryDeviceResourceRequirements (
    PDEVICE_INFORMATION DeviceInfo,
    ULONG BusNumber,
    ULONG Slot,
    PCM_RESOURCE_LIST BootResources,
    USHORT IrqFlags,
    PIO_RESOURCE_REQUIREMENTS_LIST *IoResources,
    ULONG *Size
    )

/*++

Routine Description:

    This function returns the possible bus resources that this device may be
    satisfied with.

Arguments:

    DeviceData - Device data information for the specificied slot

    BusNumber - Supplies the bus number

    Slot - supplies the slot number of the BusNumber

    IoResources - supplies a pointer to a variable to receive the IO resource
                  requirements list

Return Value:

    The device control is completed

--*/
{
    ULONG length = 0;
    NTSTATUS status;
    PUCHAR deviceData;
    PIO_RESOURCE_REQUIREMENTS_LIST ioResources;

    deviceData = DeviceInfo->DeviceData;
    status = PpBiosResourcesToNtResources (
                   BusNumber,
                   Slot,
                   &deviceData,
                   0,
                   &ioResources,
                   &length
                   );

    //
    // Return results
    //

    if (NT_SUCCESS(status)) {
        if (length == 0) {
            ioResources = NULL;     // Just to make sure
        } else {
            
            // * Set the irq level/edge requirements to be consistent
            //   with the our determination earlier as to what is
            //   likely to work for this card
            //
            // * Make requirements reflect boot configed ROM if any.
            //   
            // Make these changes across all alternatives.
            PipTrimResourceRequirements(&ioResources,
                                        IrqFlags,
                                        BootResources);

            //PipFilterResourceRequirementsList(&ioResources);
            PipMergeBootResourcesToRequirementsList(DeviceInfo,
                                                    BootResources,
                                                    &ioResources
                                                    );
            ASSERT(ioResources);
            length = ioResources->ListSize;
        }
        *IoResources = ioResources;
        *Size = length;
#if IDBG
        PipDumpIoResourceList(ioResources);
#endif
    }
    return status;
}

NTSTATUS
PipSetDeviceResources (
    PDEVICE_INFORMATION DeviceInfo,
    PCM_RESOURCE_LIST CmResources
    )
/*++

Routine Description:

    This function configures the device to the specified device setttings

Arguments:

    DeviceInfo - Device information for the specificied slot

    CmResources - pointer to the desired resource list

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    if (CmResources && (CmResources->Count != 0)) {
        //
        // Set resource settings for the device
        //

        status = PipWriteDeviceResources (
                        DeviceInfo->DeviceData,
                        (PCM_RESOURCE_LIST) CmResources
                        );
        //
        // Put all cards into wait for key state.
        //

        DebugPrint((DEBUG_STATE,
                    "SetDeviceResources CSN %d/LDN %d\n",
                    DeviceInfo->CardInformation->CardSelectNumber,
                    DeviceInfo->LogicalDeviceNumber));

        //
        // Delay some time for the newly set resources to be avaiable.
        // This is required on some slow machines.
        //

        KeStallExecutionProcessor(10000);     // delay 10 ms

    }

    return status;
}
#if 0

NTSTATUS
PipFilterResourceRequirementsList(
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST *IoResources
    )

/*++

Routine Description:

    This routine removes the length zero entries from the input Io resource
    requirements list.

Parameters:

    IoResources - supplies a pointer to an address to Io resource requirements List.

Return Value:

    NTSTATUS code.

--*/

{
    NTSTATUS status;
    PIO_RESOURCE_REQUIREMENTS_LIST oldIoResources = *IoResources, newIoResources;
    PIO_RESOURCE_LIST oldIoResourceList = oldIoResources->List;
    PIO_RESOURCE_LIST newIoResourceList;
    PIO_RESOURCE_DESCRIPTOR oldIoResourceDescriptor, newIoResourceDescriptor;
    PIO_RESOURCE_DESCRIPTOR oldIoResourceDescriptorEnd;
#if DBG
    PIO_RESOURCE_DESCRIPTOR newIoResourceDescriptorEnd;
#endif
    LONG IoResourceListCount = (LONG) oldIoResources->AlternativeLists;
    ULONG size;

    PAGED_CODE();

    //
    // Make sure there is some resource requirements to be fulfilled.
    //

    if (IoResourceListCount == 0) {
        return STATUS_SUCCESS;
    }

    size = oldIoResources->ListSize;

    //
    // Check if there is any length zero descriptor
    //

    while (--IoResourceListCount >= 0) {

        oldIoResourceDescriptor = oldIoResourceList->Descriptors;
        oldIoResourceDescriptorEnd = oldIoResourceDescriptor + oldIoResourceList->Count;

        while (oldIoResourceDescriptor < oldIoResourceDescriptorEnd) {
            switch (oldIoResourceDescriptor->Type) {
            case CmResourceTypePort:
            case CmResourceTypeMemory:
                 if (oldIoResourceDescriptor->u.Generic.Length == 0) {
                     size -= sizeof(IO_RESOURCE_DESCRIPTOR);
                 }

                 break;

            default:

                 break;
            }
            oldIoResourceDescriptor++;
        }
        ASSERT(oldIoResourceDescriptor == oldIoResourceDescriptorEnd);
        oldIoResourceList = (PIO_RESOURCE_LIST) oldIoResourceDescriptorEnd;
    }
    if (size == oldIoResources->ListSize) {
        return STATUS_SUCCESS;
    }

    //
    // We have length zero descriptor. Rebuild the resources requirements list
    //


    newIoResources = (PIO_RESOURCE_REQUIREMENTS_LIST) ExAllocatePool (
                     PagedPool, size);
    if (newIoResources == NULL) {
        return STATUS_NO_MEMORY;
    } else {
        RtlMoveMemory(newIoResources,
                      oldIoResources,
                      FIELD_OFFSET(IO_RESOURCE_REQUIREMENTS_LIST, List)
                      );
        newIoResources->ListSize = size;
        newIoResourceList = newIoResources->List;
#if DBG
        newIoResourceDescriptorEnd = (PIO_RESOURCE_DESCRIPTOR)
                                        ((PUCHAR)newIoResourceList + size);
#endif
    }

    //
    // filter the IO ResReq list
    //

    oldIoResourceList = oldIoResources->List;
    IoResourceListCount = (LONG) oldIoResources->AlternativeLists;

    while (--IoResourceListCount >= 0) {

        newIoResourceList->Version = oldIoResourceList->Version;
        newIoResourceList->Revision = oldIoResourceList->Revision;
        newIoResourceList->Count = oldIoResourceList->Count;

        oldIoResourceDescriptor = oldIoResourceList->Descriptors;
        newIoResourceDescriptor = newIoResourceList->Descriptors;
        oldIoResourceDescriptorEnd = oldIoResourceDescriptor + oldIoResourceList->Count;

        while (oldIoResourceDescriptor < oldIoResourceDescriptorEnd) {
            switch (oldIoResourceDescriptor->Type) {
            case CmResourceTypePort:
            case CmResourceTypeMemory:
                 if (oldIoResourceDescriptor->u.Generic.Length == 0) {
                     newIoResourceList->Count--;
                     break;
                 }

            default:

                *newIoResourceDescriptor = *oldIoResourceDescriptor;
                newIoResourceDescriptor++;
                break;
            }
            oldIoResourceDescriptor++;
        }
        ASSERT(oldIoResourceDescriptor == oldIoResourceDescriptorEnd);
        oldIoResourceList = (PIO_RESOURCE_LIST) oldIoResourceDescriptor;
        newIoResourceList = (PIO_RESOURCE_LIST) newIoResourceDescriptor;
    }
    ASSERT(newIoResourceDescriptor <= newIoResourceDescriptorEnd);

    ExFreePool(oldIoResources);
    *IoResources = newIoResources;
    return STATUS_SUCCESS;
}
#endif

PIO_RESOURCE_REQUIREMENTS_LIST
PipCmResourcesToIoResources (
    IN PCM_RESOURCE_LIST CmResourceList
    )

/*++

Routine Description:

    This routines converts the input CmResourceList to IO_RESOURCE_REQUIREMENTS_LIST.

Arguments:

    CmResourceList - the cm resource list to convert.

Return Value:

    returns a IO_RESOURCE_REQUIREMENTS_LISTST if succeeds.  Otherwise a NULL value is
    returned.

--*/
{
    PIO_RESOURCE_REQUIREMENTS_LIST ioResReqList;
    ULONG count = 0, size, i, j;
    PCM_FULL_RESOURCE_DESCRIPTOR cmFullDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmPartDesc;
    PIO_RESOURCE_DESCRIPTOR ioDesc;

    //
    // First determine number of descriptors required.
    //

    cmFullDesc = &CmResourceList->List[0];
    for (i = 0; i < CmResourceList->Count; i++) {
        count += cmFullDesc->PartialResourceList.Count;
        cmPartDesc = &cmFullDesc->PartialResourceList.PartialDescriptors[0];
        for (j = 0; j < cmFullDesc->PartialResourceList.Count; j++) {
            size = 0;
            switch (cmPartDesc->Type) {
            case CmResourceTypeDeviceSpecific:
                 size = cmPartDesc->u.DeviceSpecificData.DataSize;
                 count--;
                 break;
            }
            cmPartDesc++;
            cmPartDesc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)cmPartDesc + size);
        }
        cmFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)cmPartDesc;
    }

    if (count == 0) {
        return NULL;
    }

    //
    // Count the extra descriptors for InterfaceType and BusNumber information.
    //

    count += CmResourceList->Count - 1;

    //
    // Allocate heap space for IO RESOURCE REQUIREMENTS LIST
    //

    count++;           // add one for CmResourceTypeConfigData
    ioResReqList = (PIO_RESOURCE_REQUIREMENTS_LIST)ExAllocatePool(
                       PagedPool,
                       sizeof(IO_RESOURCE_REQUIREMENTS_LIST) +
                           count * sizeof(IO_RESOURCE_DESCRIPTOR)
                       );
    if (!ioResReqList) {
        return NULL;
    }

    //
    // Parse the cm resource descriptor and build its corresponding IO resource descriptor
    //

    ioResReqList->InterfaceType = CmResourceList->List[0].InterfaceType;
    ioResReqList->BusNumber = CmResourceList->List[0].BusNumber;
    ioResReqList->SlotNumber = 0;
    ioResReqList->Reserved[0] = 0;
    ioResReqList->Reserved[1] = 0;
    ioResReqList->Reserved[2] = 0;
    ioResReqList->AlternativeLists = 1;
    ioResReqList->List[0].Version = 1;
    ioResReqList->List[0].Revision = 1;
    ioResReqList->List[0].Count = count;

    //
    // Generate a CmResourceTypeConfigData descriptor
    //

    ioDesc = &ioResReqList->List[0].Descriptors[0];
    ioDesc->Option = IO_RESOURCE_PREFERRED;
    ioDesc->Type = CmResourceTypeConfigData;
    ioDesc->ShareDisposition = CmResourceShareShared;
    ioDesc->Flags = 0;
    ioDesc->Spare1 = 0;
    ioDesc->Spare2 = 0;
    ioDesc->u.ConfigData.Priority = BOOT_CONFIG_PRIORITY;
    ioDesc++;

    cmFullDesc = &CmResourceList->List[0];
    for (i = 0; i < CmResourceList->Count; i++) {
        cmPartDesc = &cmFullDesc->PartialResourceList.PartialDescriptors[0];
        for (j = 0; j < cmFullDesc->PartialResourceList.Count; j++) {
            ioDesc->Option = IO_RESOURCE_PREFERRED;
            ioDesc->Type = cmPartDesc->Type;
            ioDesc->ShareDisposition = cmPartDesc->ShareDisposition;
            ioDesc->Flags = cmPartDesc->Flags;
            ioDesc->Spare1 = 0;
            ioDesc->Spare2 = 0;

            size = 0;
            switch (cmPartDesc->Type) {
            case CmResourceTypePort:
                 ioDesc->u.Port.MinimumAddress = cmPartDesc->u.Port.Start;
                 ioDesc->u.Port.MaximumAddress.QuadPart = cmPartDesc->u.Port.Start.QuadPart +
                                                             cmPartDesc->u.Port.Length - 1;
                 ioDesc->u.Port.Alignment = 1;
                 ioDesc->u.Port.Length = cmPartDesc->u.Port.Length;
                 ioDesc++;
                 break;
            case CmResourceTypeInterrupt:
#if defined(_X86_)
                ioDesc->u.Interrupt.MinimumVector = ioDesc->u.Interrupt.MaximumVector =
                   cmPartDesc->u.Interrupt.Level;
#else
                 ioDesc->u.Interrupt.MinimumVector = ioDesc->u.Interrupt.MaximumVector =
                    cmPartDesc->u.Interrupt.Vector;
#endif
                 ioDesc++;
                 break;
            case CmResourceTypeMemory:
                 ioDesc->u.Memory.MinimumAddress = cmPartDesc->u.Memory.Start;
                 ioDesc->u.Memory.MaximumAddress.QuadPart = cmPartDesc->u.Memory.Start.QuadPart +
                                                               cmPartDesc->u.Memory.Length - 1;
                 ioDesc->u.Memory.Alignment = 1;
                 ioDesc->u.Memory.Length = cmPartDesc->u.Memory.Length;
                 ioDesc++;
                 break;
            case CmResourceTypeDma:
                 ioDesc->u.Dma.MinimumChannel = cmPartDesc->u.Dma.Channel;
                 ioDesc->u.Dma.MaximumChannel = cmPartDesc->u.Dma.Channel;
                 ioDesc++;
                 break;
            case CmResourceTypeDeviceSpecific:
                 size = cmPartDesc->u.DeviceSpecificData.DataSize;
                 break;
            case CmResourceTypeBusNumber:
                 ioDesc->u.BusNumber.MinBusNumber = cmPartDesc->u.BusNumber.Start;
                 ioDesc->u.BusNumber.MaxBusNumber = cmPartDesc->u.BusNumber.Start +
                                                    cmPartDesc->u.BusNumber.Length - 1;
                 ioDesc->u.BusNumber.Length = cmPartDesc->u.BusNumber.Length;
                 ioDesc++;
                 break;
            default:
                 ioDesc->u.DevicePrivate.Data[0] = cmPartDesc->u.DevicePrivate.Data[0];
                 ioDesc->u.DevicePrivate.Data[1] = cmPartDesc->u.DevicePrivate.Data[1];
                 ioDesc->u.DevicePrivate.Data[2] = cmPartDesc->u.DevicePrivate.Data[2];
                 ioDesc++;
                 break;
            }
            cmPartDesc++;
            cmPartDesc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)cmPartDesc + size);
        }
        cmFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)cmPartDesc;
    }
    ioResReqList->ListSize = (ULONG)((ULONG_PTR)ioDesc - (ULONG_PTR)ioResReqList);
    return ioResReqList;
}

NTSTATUS
PipMergeResourceRequirementsLists (
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoList1,
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoList2,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST *MergedList
    )

/*++

Routine Description:

    This routines merges two IoLists into one.


Arguments:

    IoList1 - supplies the pointer to the first IoResourceRequirementsList

    IoList2 - supplies the pointer to the second IoResourceRequirementsList

    MergedList - Supplies a variable to receive the merged resource
             requirements list.

Return Value:

    A NTSTATUS code to indicate the result of the function.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_RESOURCE_REQUIREMENTS_LIST ioList, newList;
    ULONG size;
    PUCHAR p;

    PAGED_CODE();

    *MergedList = NULL;

    //
    // First handle the easy cases that both IO Lists are empty or any one of
    // them is empty.
    //

    if ((IoList1 == NULL || IoList1->AlternativeLists == 0) &&
        (IoList2 == NULL || IoList2->AlternativeLists == 0)) {
        return status;
    }
    ioList = NULL;
    if (IoList1 == NULL || IoList1->AlternativeLists == 0) {
        ioList = IoList2;
    } else if (IoList2 == NULL || IoList2->AlternativeLists == 0) {
        ioList = IoList1;
    }
    if (ioList) {
        newList = (PIO_RESOURCE_REQUIREMENTS_LIST) ExAllocatePool(PagedPool, ioList->ListSize);
        if (newList == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        RtlMoveMemory(newList, ioList, ioList->ListSize);
        *MergedList = newList;
        return status;
    }

    //
    // Do real work...
    //

    size = IoList1->ListSize + IoList2->ListSize - FIELD_OFFSET(IO_RESOURCE_REQUIREMENTS_LIST, List);
    newList = (PIO_RESOURCE_REQUIREMENTS_LIST) ExAllocatePool(
                          PagedPool,
                          size
                          );
    if (newList == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    p = (PUCHAR)newList;
    RtlMoveMemory(p, IoList1, IoList1->ListSize);
    p += IoList1->ListSize;
    RtlMoveMemory(p,
                  &IoList2->List[0],
                  size - IoList1->ListSize
                  );
    newList->ListSize = size;
    newList->AlternativeLists += IoList2->AlternativeLists;
    *MergedList = newList;
    return status;
}

VOID
PipMergeBootResourcesToRequirementsList(
    PDEVICE_INFORMATION DeviceInfo,
    PCM_RESOURCE_LIST BootResources,
    PIO_RESOURCE_REQUIREMENTS_LIST *IoResources
    )

/*++

Routine Description:

    This routines merges two IoLists into one.


Arguments:

    IoList1 - supplies the pointer to the first IoResourceRequirementsList

    IoList2 - supplies the pointer to the second IoResourceRequirementsList

    MergedList - Supplies a variable to receive the merged resource
             requirements list.

Return Value:

    A NTSTATUS code to indicate the result of the function.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_RESOURCE_REQUIREMENTS_LIST ioResources = *IoResources, bootResReq = NULL, newList = NULL;
    BOOLEAN exactMatch;

    PAGED_CODE();

    if (DeviceInfo->BootResources) {
        PipBuildBootResourceRequirementsList (ioResources, BootResources, &bootResReq, &exactMatch);
        if (bootResReq) {
            if (exactMatch && ioResources->AlternativeLists == 1) {
                ExFreePool(ioResources);
                *IoResources = bootResReq;
            } else {
                PipMergeResourceRequirementsLists (bootResReq, ioResources, &newList);
                if (newList) {
                    ExFreePool(ioResources);
                    *IoResources = newList;
                }
                ExFreePool(bootResReq);
            }
        }
    }
}

NTSTATUS
PipBuildBootResourceRequirementsList (
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoList,
    IN PCM_RESOURCE_LIST CmList,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST *FilteredList,
    OUT PBOOLEAN ExactMatch
    )

/*++

Routine Description:

    This routines adjusts the input IoList based on input BootConfig.


Arguments:

    IoList - supplies the pointer to an IoResourceRequirementsList

    CmList - supplies the pointer to a BootConfig.

    FilteredList - Supplies a variable to receive the filtered resource
             requirements list.

Return Value:

    A NTSTATUS code to indicate the result of the function.

--*/
{
    NTSTATUS status;
    PIO_RESOURCE_REQUIREMENTS_LIST ioList, newList;
    PIO_RESOURCE_LIST ioResourceList, newIoResourceList;
    PIO_RESOURCE_DESCRIPTOR ioResourceDescriptor, ioResourceDescriptorEnd;
    PIO_RESOURCE_DESCRIPTOR newIoResourceDescriptor, configDataDescriptor;
    LONG ioResourceDescriptorCount = 0;
    USHORT version;
    PCM_FULL_RESOURCE_DESCRIPTOR cmFullDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmDescriptor;
    ULONG cmDescriptorCount = 0;
    ULONG size, i, j, oldCount, phase;
    LONG k, alternativeLists;
    BOOLEAN exactMatch;

    PAGED_CODE();

    *FilteredList = NULL;
    *ExactMatch = FALSE;

    //
    // Make sure there is some resource requirements to be filtered.
    // If no, we will convert CmList/BootConfig to an IoResourceRequirementsList
    //

    if (IoList == NULL || IoList->AlternativeLists == 0) {
        if (CmList && CmList->Count != 0) {
            *FilteredList = PipCmResourcesToIoResources (CmList);
        }
        return STATUS_SUCCESS;
    }

    //
    // Make a copy of the Io Resource Requirements List
    //

    ioList = (PIO_RESOURCE_REQUIREMENTS_LIST) ExAllocatePool(PagedPool, IoList->ListSize);
    if (ioList == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlMoveMemory(ioList, IoList, IoList->ListSize);

    //
    // If there is no BootConfig, simply return the copy of the input Io list.
    //

    if (CmList == NULL || CmList->Count == 0) {
        *FilteredList = ioList;
        return STATUS_SUCCESS;
    }

    //
    // First determine minimum number of descriptors required.
    //

    cmFullDesc = &CmList->List[0];
    for (i = 0; i < CmList->Count; i++) {
        cmDescriptorCount += cmFullDesc->PartialResourceList.Count;
        cmDescriptor = &cmFullDesc->PartialResourceList.PartialDescriptors[0];
        for (j = 0; j < cmFullDesc->PartialResourceList.Count; j++) {
            size = 0;
            switch (cmDescriptor->Type) {
            case CmResourceTypeConfigData:
            case CmResourceTypeDevicePrivate:
                 cmDescriptorCount--;
                 break;
            case CmResourceTypeDeviceSpecific:
                 size = cmDescriptor->u.DeviceSpecificData.DataSize;
                 cmDescriptorCount--;
                 break;
            default:

                 //
                 // Invalid cmresource list.  Ignore it and use io resources
                 //

                 if (cmDescriptor->Type == CmResourceTypeNull ||
                     cmDescriptor->Type >= CmResourceTypeMaximum) {
                     cmDescriptorCount--;
                 }
            }
            cmDescriptor++;
            cmDescriptor = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)cmDescriptor + size);
        }
        cmFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)cmDescriptor;
    }

    if (cmDescriptorCount == 0) {
        *FilteredList = ioList;
        return STATUS_SUCCESS;
    }

    //
    // cmDescriptorCount is the number of BootConfig Descriptors needs.
    //
    // For each IO list Alternative ...
    //

    ioResourceList = ioList->List;
    k = ioList->AlternativeLists;
    while (--k >= 0) {
        ioResourceDescriptor = ioResourceList->Descriptors;
        ioResourceDescriptorEnd = ioResourceDescriptor + ioResourceList->Count;
        while (ioResourceDescriptor < ioResourceDescriptorEnd) {
            ioResourceDescriptor->Spare1 = 0;
            ioResourceDescriptor++;
        }
        ioResourceList = (PIO_RESOURCE_LIST) ioResourceDescriptorEnd;
    }

    ioResourceList = ioList->List;
    k = alternativeLists = ioList->AlternativeLists;
    while (--k >= 0) {
        version = ioResourceList->Version;
        if (version == 0xffff) {  // Convert bogus version to valid number
            version = 1;
        }

        //
        // We use Version field to store number of BootConfig found.
        // Count field to store new number of descriptor in the alternative list.
        //

        ioResourceList->Version = 0;
        oldCount = ioResourceList->Count;

        ioResourceDescriptor = ioResourceList->Descriptors;
        ioResourceDescriptorEnd = ioResourceDescriptor + ioResourceList->Count;

        if (ioResourceDescriptor == ioResourceDescriptorEnd) {

            //
            // An alternative list with zero descriptor count
            //

            ioResourceList->Version = 0xffff;  // Mark it as invalid
            ioList->AlternativeLists--;
            continue;
        }

        exactMatch = TRUE;

        //
        // For each Cm Resource descriptor ... except DevicePrivate and
        // DeviceSpecific...
        //

        cmFullDesc = &CmList->List[0];
        for (i = 0; i < CmList->Count; i++) {
            cmDescriptor = &cmFullDesc->PartialResourceList.PartialDescriptors[0];
            for (j = 0; j < cmFullDesc->PartialResourceList.Count; j++) {
                size = 0;
                switch (cmDescriptor->Type) {
                case CmResourceTypeDevicePrivate:
                     break;
                case CmResourceTypeDeviceSpecific:
                     size = cmDescriptor->u.DeviceSpecificData.DataSize;
                     break;
                default:
                    if (cmDescriptor->Type == CmResourceTypeNull ||
                        cmDescriptor->Type >= CmResourceTypeMaximum) {
                        break;
                    }

                    //
                    // Check CmDescriptor against current Io Alternative list
                    //

                    for (phase = 0; phase < 2; phase++) {
                        ioResourceDescriptor = ioResourceList->Descriptors;
                        while (ioResourceDescriptor < ioResourceDescriptorEnd) {
                            if ((ioResourceDescriptor->Type == cmDescriptor->Type) &&
                                (ioResourceDescriptor->Spare1 == 0)) {
                                ULONGLONG min1, max1, min2, max2;
                                ULONG len1 = 1, len2 = 1, align1, align2;
                                UCHAR share1, share2;

                                share2 = ioResourceDescriptor->ShareDisposition;
                                share1 = cmDescriptor->ShareDisposition;
                                if ((share1 == CmResourceShareUndetermined) ||
                                    (share1 > CmResourceShareShared)) {
                                    share1 = share2;
                                }
                                if ((share2 == CmResourceShareUndetermined) ||
                                    (share2 > CmResourceShareShared)) {
                                    share2 = share1;
                                }
                                align1 = align2 = 1;

                                switch (cmDescriptor->Type) {
                                case CmResourceTypePort:
                                case CmResourceTypeMemory:
                                    min1 = cmDescriptor->u.Port.Start.QuadPart;
                                    max1 = cmDescriptor->u.Port.Start.QuadPart + cmDescriptor->u.Port.Length - 1;
                                    len1 = cmDescriptor->u.Port.Length;
                                    min2 = ioResourceDescriptor->u.Port.MinimumAddress.QuadPart;
                                    max2 = ioResourceDescriptor->u.Port.MaximumAddress.QuadPart;
                                    len2 = ioResourceDescriptor->u.Port.Length;
                                    align2 = ioResourceDescriptor->u.Port.Alignment;
                                    break;
                                case CmResourceTypeInterrupt:
                                    max1 = min1 = cmDescriptor->u.Interrupt.Vector;
                                    min2 = ioResourceDescriptor->u.Interrupt.MinimumVector;
                                    max2 = ioResourceDescriptor->u.Interrupt.MaximumVector;
                                    break;
                                case CmResourceTypeDma:
                                    min1 = max1 =cmDescriptor->u.Dma.Channel;
                                    min2 = ioResourceDescriptor->u.Dma.MinimumChannel;
                                    max2 = ioResourceDescriptor->u.Dma.MaximumChannel;
                                    break;
                                case CmResourceTypeBusNumber:
                                    min1 = cmDescriptor->u.BusNumber.Start;
                                    max1 = cmDescriptor->u.BusNumber.Start + cmDescriptor->u.BusNumber.Length - 1;
                                    len1 = cmDescriptor->u.BusNumber.Length;
                                    min2 = ioResourceDescriptor->u.BusNumber.MinBusNumber;
                                    max2 = ioResourceDescriptor->u.BusNumber.MaxBusNumber;
                                    len2 = ioResourceDescriptor->u.BusNumber.Length;
                                    break;
                                default:
                                    ASSERT(0);
                                    break;
                                }
                                if (phase == 0) {
                                    if (share1 == share2 && min2 == min1 && max2 >= max1 && len2 >= len1) {

                                        //
                                        // For phase 0 match, we want near exact match...
                                        //

                                        if (max2 != max1) {
                                            exactMatch = FALSE;
                                        }

                                        ioResourceList->Version++;
                                        ioResourceDescriptor->Spare1 = 0x80;
                                        if (ioResourceDescriptor->Option & IO_RESOURCE_ALTERNATIVE) {
                                            PIO_RESOURCE_DESCRIPTOR ioDesc;

                                            ioDesc = ioResourceDescriptor;
                                            ioDesc--;
                                            while (ioDesc >= ioResourceList->Descriptors) {
                                                ioDesc->Type = CmResourceTypeNull;
                                                ioResourceList->Count--;
                                                if (ioDesc->Option == IO_RESOURCE_ALTERNATIVE) {
                                                    ioDesc--;
                                                } else {
                                                    break;
                                                }
                                            }
                                        }
                                        ioResourceDescriptor->Option = IO_RESOURCE_PREFERRED;
                                        if (ioResourceDescriptor->Type == CmResourceTypePort ||
                                            ioResourceDescriptor->Type == CmResourceTypeMemory) {
                                            ioResourceDescriptor->u.Port.MinimumAddress.QuadPart = min1;
                                            ioResourceDescriptor->u.Port.MaximumAddress.QuadPart = min1 + len2 - 1;
                                            ioResourceDescriptor->u.Port.Alignment = 1;
                                        } else if (ioResourceDescriptor->Type == CmResourceTypeBusNumber) {
                                            ioResourceDescriptor->u.BusNumber.MinBusNumber = (ULONG)min1;
                                            ioResourceDescriptor->u.BusNumber.MaxBusNumber = (ULONG)(min1 + len2 - 1);
                                        }
                                        ioResourceDescriptor++;
                                        while (ioResourceDescriptor < ioResourceDescriptorEnd) {
                                            if (ioResourceDescriptor->Option & IO_RESOURCE_ALTERNATIVE) {
                                                ioResourceDescriptor->Type = CmResourceTypeNull;
                                                ioResourceDescriptor++;
                                                ioResourceList->Count--;
                                            } else {
                                                break;
                                            }
                                        }
                                        phase = 1;   // skip phase 1
                                        break;
                                    } else {
                                        ioResourceDescriptor++;
                                    }
                                } else {
                                    exactMatch = FALSE;
                                    if (share1 == share2 && min2 <= min1 && max2 >= max1 && len2 >= len1 &&
                                        (min1 & (align2 - 1)) == 0) {

                                        //
                                        // Io range covers Cm range ... Change the Io range to what is specified
                                        // in BootConfig.
                                        //
                                        //

                                        switch (cmDescriptor->Type) {
                                        case CmResourceTypePort:
                                        case CmResourceTypeMemory:
                                            ioResourceDescriptor->u.Port.MinimumAddress.QuadPart = min1;
                                            ioResourceDescriptor->u.Port.MaximumAddress.QuadPart = min1 + len2 - 1;
                                            break;
                                        case CmResourceTypeInterrupt:
                                        case CmResourceTypeDma:
                                            ioResourceDescriptor->u.Interrupt.MinimumVector = (ULONG)min1;
                                            ioResourceDescriptor->u.Interrupt.MaximumVector = (ULONG)max1;
                                            break;
                                        case CmResourceTypeBusNumber:
                                            ioResourceDescriptor->u.BusNumber.MinBusNumber = (ULONG)min1;
                                            ioResourceDescriptor->u.BusNumber.MaxBusNumber = (ULONG)(min1 + len2 - 1);
                                            break;
                                        }
                                        ioResourceList->Version++;
                                        ioResourceDescriptor->Spare1 = 0x80;
                                        if (ioResourceDescriptor->Option & IO_RESOURCE_ALTERNATIVE) {
                                            PIO_RESOURCE_DESCRIPTOR ioDesc;

                                            ioDesc = ioResourceDescriptor;
                                            ioDesc--;
                                            while (ioDesc >= ioResourceList->Descriptors) {
                                                ioDesc->Type = CmResourceTypeNull;
                                                ioResourceList->Count--;
                                                if (ioDesc->Option == IO_RESOURCE_ALTERNATIVE) {
                                                    ioDesc--;
                                                } else {
                                                    break;
                                                }
                                            }
                                        }
                                        ioResourceDescriptor->Option = IO_RESOURCE_PREFERRED;
                                        ioResourceDescriptor++;
                                        while (ioResourceDescriptor < ioResourceDescriptorEnd) {
                                            if (ioResourceDescriptor->Option & IO_RESOURCE_ALTERNATIVE) {
                                                ioResourceDescriptor->Type = CmResourceTypeNull;
                                                ioResourceList->Count--;
                                                ioResourceDescriptor++;
                                            } else {
                                                break;
                                            }
                                        }
                                        break;
                                    } else {
                                        ioResourceDescriptor++;
                                    }
                                }
                            } else {
                                ioResourceDescriptor++;
                            }
                        } // Don't add any instruction after this ...
                    } // phase
                } // switch

                //
                // Move to next Cm Descriptor
                //

                cmDescriptor++;
                cmDescriptor = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)cmDescriptor + size);
            }

            //
            // Move to next Cm List
            //

            cmFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)cmDescriptor;
        }

        if (ioResourceList->Version != (USHORT)cmDescriptorCount) {

            //
            // If the current alternative list does not cover all the boot config
            // descriptors, make it as invalid.
            //

            ioResourceList->Version = 0xffff;
            ioList->AlternativeLists--;
        } else {
            ioResourceDescriptorCount += ioResourceList->Count;
            ioResourceList->Version = version;
            ioResourceList->Count = oldCount; // ++ single alternative list
            break;   // ++  single alternative list
        }
        ioResourceList->Count = oldCount;

        //
        // Move to next Io alternative list.
        //

        ioResourceList = (PIO_RESOURCE_LIST) ioResourceDescriptorEnd;
    }

    //
    // If there is not any valid alternative, convert CmList to Io list.
    //

    if (ioList->AlternativeLists == 0) {
         *FilteredList = PipCmResourcesToIoResources (CmList);
        ExFreePool(ioList);
        return STATUS_SUCCESS;
    }

    //
    // we have finished filtering the resource requirements list.  Now allocate memory
    // and rebuild a new list.
    //

    size = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) +
               //sizeof(IO_RESOURCE_LIST) * (ioList->AlternativeLists - 1) +    // ++ Single Alternative list
               sizeof(IO_RESOURCE_DESCRIPTOR) * (ioResourceDescriptorCount);
    newList = (PIO_RESOURCE_REQUIREMENTS_LIST) ExAllocatePool(PagedPool, size);
    if (newList == NULL) {
        ExFreePool(ioList);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Walk through the io resource requirements list and pick up any valid descriptor.
    //

    newList->ListSize = size;
    newList->InterfaceType = CmList->List->InterfaceType;
    newList->BusNumber = CmList->List->BusNumber;
    newList->SlotNumber = ioList->SlotNumber;
#if 0 // ++ Single Alternative list
    newList->AlternativeLists = ioList->AlternativeLists;
#else
    newList->AlternativeLists = 1;
#endif
    ioResourceList = ioList->List;
    newIoResourceList = newList->List;
    while (--alternativeLists >= 0) {
        ioResourceDescriptor = ioResourceList->Descriptors;
        ioResourceDescriptorEnd = ioResourceDescriptor + ioResourceList->Count;
        if (ioResourceList->Version == 0xffff) {
            ioResourceList = (PIO_RESOURCE_LIST)ioResourceDescriptorEnd;
            continue;
        }
        newIoResourceList->Version = ioResourceList->Version;
        newIoResourceList->Revision = ioResourceList->Revision;

        newIoResourceDescriptor = newIoResourceList->Descriptors;
        if (ioResourceDescriptor->Type != CmResourceTypeConfigData) {
            newIoResourceDescriptor->Option = IO_RESOURCE_PREFERRED;
            newIoResourceDescriptor->Type = CmResourceTypeConfigData;
            newIoResourceDescriptor->ShareDisposition = CmResourceShareShared;
            newIoResourceDescriptor->Flags = 0;
            newIoResourceDescriptor->Spare1 = 0;
            newIoResourceDescriptor->Spare2 = 0;
            newIoResourceDescriptor->u.ConfigData.Priority = BOOT_CONFIG_PRIORITY;
            configDataDescriptor = newIoResourceDescriptor;
            newIoResourceDescriptor++;
        } else {
            newList->ListSize -= sizeof(IO_RESOURCE_DESCRIPTOR);
            configDataDescriptor = newIoResourceDescriptor;
        }

        while (ioResourceDescriptor < ioResourceDescriptorEnd) {
            if (ioResourceDescriptor->Type != CmResourceTypeNull) {
                *newIoResourceDescriptor = *ioResourceDescriptor;
                newIoResourceDescriptor++;
            }
            ioResourceDescriptor++;
        }
        newIoResourceList->Count = (ULONG)(newIoResourceDescriptor - newIoResourceList->Descriptors);
        configDataDescriptor->u.ConfigData.Priority =  BOOT_CONFIG_PRIORITY;

        break;
    }
    ASSERT((PUCHAR)newIoResourceDescriptor == ((PUCHAR)newList + newList->ListSize));

    *FilteredList = newList;
    *ExactMatch = exactMatch;
    ExFreePool(ioList);
    return STATUS_SUCCESS;
}


PCM_PARTIAL_RESOURCE_DESCRIPTOR
PipFindMatchingBootMemResource(
    IN ULONG Index,
    IN PIO_RESOURCE_DESCRIPTOR IoDesc,
    IN PCM_RESOURCE_LIST BootResources
    )
/*++

Routine Description:

    This routine finds boot resources that match the i/o descriptor


Arguments:

    Index - Index of memory boot config resource the caller is interested in.

    IoDesc - I/O descriptor

    BootResources - boot config

Return Value:

    A pointer to a matching descriptor in the boot config

--*/
{
    PCM_FULL_RESOURCE_DESCRIPTOR cmFullDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmPartDesc;
    ULONG count = 0, size, i, j, noMem;
    
    if (BootResources == NULL) {
        return NULL;
    }

    cmFullDesc = &BootResources->List[0];
    for (i = 0; i < BootResources->Count; i++) {
        cmPartDesc = &cmFullDesc->PartialResourceList.PartialDescriptors[0];
        noMem = 0;
        for (j = 0; j < cmFullDesc->PartialResourceList.Count; j++) {
            size = 0;
            if (cmPartDesc->Type == CmResourceTypeMemory) {
                if (((cmPartDesc->u.Memory.Start.QuadPart >=
                     IoDesc->u.Memory.MinimumAddress.QuadPart) &&
                    ((cmPartDesc->u.Memory.Start.QuadPart +
                      cmPartDesc->u.Memory.Length - 1) <=
                     IoDesc->u.Memory.MaximumAddress.QuadPart)) &&
                    noMem == Index) {
                    return cmPartDesc;
                }
                noMem++;
            } else if (cmPartDesc->Type == CmResourceTypeDeviceSpecific) {
                    size = cmPartDesc->u.DeviceSpecificData.DataSize;
            }
            cmPartDesc++;
            cmPartDesc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)cmPartDesc + size);
        }
        cmFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)cmPartDesc;
    }
    return NULL;
}

NTSTATUS
PipTrimResourceRequirements (
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST *IoList,
    IN USHORT IrqFlags,
    IN PCM_RESOURCE_LIST BootResources
    )
/*++

Routine Description:

    This routine:
       * adjusts the irq requirements level/edge to the value
       decided on in PipCheckBus()

       * adjusts the memory requirements to reflect the memory boot
         config.

Arguments:

    IoList - supplies the pointer to an IoResourceRequirementsList

    IrqFlags - level/edge irq reuirements to be applied to all interrupt requirements in all alternatives.

    BootResources - Used as a reference.

--*/
{
    PIO_RESOURCE_REQUIREMENTS_LIST newReqList;
    PIO_RESOURCE_LIST resList, newList;
    PIO_RESOURCE_DESCRIPTOR resDesc, newDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR bootDesc;
    ULONG listCount, i, j, pass, size, noMem;
    BOOLEAN goodAlt;

    if (IoList == NULL) {
        return STATUS_SUCCESS;
    }

    // The only way to create a new req list only if absolutely
    // necessary and make it the perfect size is perform this
    // operation in two passes.
    // 1. figure out how many alternatives will be eliminated and
    //    compute size of new req list.  if all of the alternatives
    //    survived, return the original list (now modified)
    //
    // 2. construct new reqlist minus the bad alternatives.

    listCount = 0;
    size = 0;
    for (pass = 0; pass < 2; pass++) {
        if (pass == 0) {
            size = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) -
                sizeof(IO_RESOURCE_LIST);
        } else {
            newReqList = (PIO_RESOURCE_REQUIREMENTS_LIST) ExAllocatePool(PagedPool, size);
            if (newReqList == NULL) {
                return STATUS_INSUFFICIENT_RESOURCES;
             }
            *newReqList = **IoList;
            newReqList->ListSize = size;
            newReqList->AlternativeLists = listCount;
            newList = &newReqList->List[0];
        }

        resList = &(*IoList)->List[0];

        for (i = 0; i < (*IoList)->AlternativeLists; i++) {
            if (pass == 1) {

                *newList = *resList;
                newDesc = &newList->Descriptors[0];
            }
            resDesc = &resList->Descriptors[0];
            goodAlt = TRUE;
            noMem = 0;
            for (j = 0; j < resList->Count; j++) {
                if (resDesc->Type == CmResourceTypeInterrupt) {
                    resDesc->Flags = IrqFlags;

                    if (resDesc->Flags & CM_RESOURCE_INTERRUPT_LATCHED) {
                        resDesc->ShareDisposition = CmResourceShareDeviceExclusive;
                    }
                } else if (resDesc->Type == CmResourceTypeMemory) {
                    resDesc->Flags |= CM_RESOURCE_MEMORY_24;

                    if (BootResources) {
                        bootDesc = PipFindMatchingBootMemResource(noMem, resDesc, BootResources);
                        // have matching boot config resource, can trim requirements
                        if (bootDesc) {
                            if (bootDesc->Flags & CM_RESOURCE_MEMORY_READ_ONLY) {
                                // exact or inclusive ROM match is
                                // converted into a fixed requirement.
                                resDesc->u.Memory.MinimumAddress.QuadPart =
                                    bootDesc->u.Memory.Start.QuadPart;
                                if (bootDesc->u.Memory.Length) {
                                    resDesc->u.Memory.MaximumAddress.QuadPart =
                                        bootDesc->u.Memory.Start.QuadPart +
                                        bootDesc->u.Memory.Length - 1;
                                } else {
                                    resDesc->u.Memory.MaximumAddress.QuadPart =
                                        bootDesc->u.Memory.Start.QuadPart;
                                }
                                resDesc->u.Memory.Length = bootDesc->u.Memory.Length;
                                resDesc->u.Memory.Alignment = 1;
                                resDesc->Flags |= CM_RESOURCE_MEMORY_READ_ONLY;
                            }
                        } else {
                            goodAlt = FALSE;
                        }
                    } else {
                        resDesc->Flags &= ~CM_RESOURCE_MEMORY_READ_ONLY;
                    }
                    noMem++;
                }
                if (pass == 1) {
                    *newDesc = *resDesc;
                    PipDumpIoResourceDescriptor("  ", newDesc);
                    newDesc++;
                }

                resDesc++;
            }

            if (pass == 0) {
                if (goodAlt) {
                    size += sizeof(IO_RESOURCE_LIST) + 
                        sizeof(IO_RESOURCE_DESCRIPTOR) * (resList->Count - 1);
                    listCount++;
                }
            } else {
                if (goodAlt) {
                    newList = (PIO_RESOURCE_LIST) newDesc;
                } else {
                    DebugPrint((DEBUG_RESOURCE, "An alternative trimmed off of reqlist\n"));
                }
            }

            resList = (PIO_RESOURCE_LIST) resDesc;
        }

        // If we have the same number of alternatives as before use
        // the use existing (modified in-place) requirements list
        if (!pass && (listCount == (*IoList)->AlternativeLists)) {
            return STATUS_SUCCESS;
        }
 
        // if all alternatives have been eliminated, then it is better
        // to use the existing requirements list than to hope to build
        // one out of the boot config alone.
        if (!pass && (listCount == 0)) {
            DebugPrint((DEBUG_RESOURCE, "All alternatives trimmed off of reqlist, going with original\n"));
            return STATUS_SUCCESS;
        }
    }

    ExFreePool(*IoList);
    *IoList = newReqList;

    return STATUS_SUCCESS;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\isapnp\pnpisa.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    pnpisa.h

Abstract:

    This module contins definitions/declarations for PNP ISA related
    definitions.

Author:

    Shie-Lin Tzong (shielint) July-12-1995

Revision History:

--*/

//
// External references
//

extern ULONG  ADDRESS_PORT;
extern ULONG  COMMAND_PORT;

extern PUCHAR PipReadDataPort;
extern PUCHAR PipAddressPort;
extern PUCHAR PipCommandPort;

//
// Definitions
//

#if defined(_X86_)
#define ADDRESS_PORT_NEC            0x0259
#define COMMAND_PORT_NEC            0x0a59
#endif

//
// Plug and Play Card Control Registers
//

#define SET_READ_DATA_PORT          0x00
#define SERIAL_ISOLATION_PORT       0x01
#define CONFIG_CONTROL_PORT         0x02
#define WAKE_CSN_PORT               0x03
#define CONFIG_DATA_PORT            0x04
#define CONFIG_DATA_STATUS_PORT     0x05
#define SET_CSN_PORT                0x06
#define LOGICAL_DEVICE_PORT         0x07

//
// Plug and Play Logical Device Control Registers
//

#define ACTIVATE_PORT               0x30
#define IO_RANGE_CHECK_PORT         0x31

//
// Config Control command
//

#define CONTROL_RESET               0x01
#define CONTROL_WAIT_FOR_KEY        0x02
#define CONTROL_RESET_CSN           0x04

//
// Memory Space Configuration
//

#define NUMBER_MEMORY_DESCRIPTORS   4
#define ADDRESS_MEMORY_BASE         0x40
#define ADDRESS_MEMORY_INCR         0x08
#define ADDRESS_MEMORY_HI           0x00
#define ADDRESS_MEMORY_LO           0x01
#define ADDRESS_MEMORY_CTL          0x02
#define ADDRESS_MEMORY_CTL_LIMIT    0x01
#define ADDRESS_MEMORY_UPPER_HI     0x03
#define ADDRESS_MEMORY_UPPER_LO     0x04

//
// 32 Bit Memory Space Configuration
//

#define NUMBER_32_MEMORY_DESCRIPTORS 4
#define ADDRESS_32_MEMORY_BASE(x)   ((PUCHAR)(0x70+((x)*0x10)+((x==0) ? 6 : 0)))
#define ADDRESS_32_MEMORY_B3        0x0
#define ADDRESS_32_MEMORY_B2        0x1
#define ADDRESS_32_MEMORY_B1        0x2
#define ADDRESS_32_MEMORY_B0        0x3
#define ADDRESS_32_MEMORY_CTL       0x4
#define ADDRESS_32_MEMORY_E3        0x5
#define ADDRESS_32_MEMORY_E2        0x6
#define ADDRESS_32_MEMORY_E1        0x7
#define ADDRESS_32_MEMORY_E0        0x8

//
// Io Space Configuration
//

#define NUMBER_IO_DESCRIPTORS       8
#define ADDRESS_IO_BASE             0x60
#define ADDRESS_IO_INCR             0x02
#define ADDRESS_IO_BASE_HI          0x00
#define ADDRESS_IO_BASE_LO          0x01

//
// Interrupt Configuration
//

#define NUMBER_IRQ_DESCRIPTORS      2
#define ADDRESS_IRQ_BASE            0x70
#define ADDRESS_IRQ_INCR            0x02
#define ADDRESS_IRQ_VALUE           0x00
#define ADDRESS_IRQ_TYPE            0x01

//
// DMA Configuration
//

#define NUMBER_DMA_DESCRIPTORS     2
#define ADDRESS_DMA_BASE           0x74
#define ADDRESS_DMA_INCR           0x01
#define ADDRESS_DMA_VALUE          0x00
#define NO_DMA                     0x04

//
// 9 byte serial identifier of a PNP ISA Card
//

#include "pshpack1.h"
typedef struct _SERIAL_IDENTIFIER_ {
    ULONG VenderId;
    ULONG SerialNumber;
    UCHAR Checksum;
} SERIAL_IDENTIFIER, *PSERIAL_IDENTIFIER;
#include "poppack.h"

//
// Misc. definitions
//

#define MIN_READ_DATA_PORT         0x200
#define MAX_READ_DATA_PORT         0x3ff
#define MAX_CHARACTER_LENGTH       255
#define NUMBER_CARD_ID_BYTES       9
#define NUMBER_CARD_ID_BITS        (NUMBER_CARD_ID_BYTES * 8)
#define CHECKSUMED_BITS            64
#define LFSR_SEED                  0x6A
#define ISOLATION_TEST_BYTE_1      0x55
#define ISOLATION_TEST_BYTE_2      0xAA

#define PipWriteAddress(data)      WRITE_PORT_UCHAR (PipAddressPort, (UCHAR)(ULONG_PTR)(data))
#define PipWriteData(data)         WRITE_PORT_UCHAR (PipCommandPort, (UCHAR)(ULONG_PTR)(data))
#define PipReadData()              READ_PORT_UCHAR (PipReadDataPort)

VOID
PipWaitForKey(
    VOID
    );

VOID
PipConfig(
    IN UCHAR Csn
    );

VOID
PipIsolation(
    VOID
    );

VOID
PipSleep(
    VOID
    );

VOID
PipSelectDevice(
    IN UCHAR Device
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\mf\common.c ===
/*++                 

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    common.c

Abstract:

    This module provides the functions which are common to both the PDO and FDO.
    
Author:

    Andy Thornton (andrewth) 20-Oct-97

Revision History:

--*/

#include "mfp.h"

/*++
        
The majority of functions in this file are called based on their presence
in Pnp and Po dispatch tables.  In the interests of brevity the arguments
to all those functions will be described below:

NTSTATUS
MfXxxCommon(
    IN PIRP Irp,
    IN PMF_COMMON_EXTENSION Common,
	IN PIO_STACK_LOCATION IrpStack
    )

Routine Description:
    
    This function handles the Xxx requests for all multifunction devices

Arguments:

    Irp - Points to the IRP associated with this request.
    
    Parent - Points to the common device extension.
    
    IrpStack - Points to the current stack location for this request.
    
Return Value:

    Status code that indicates whether or not the function was successful.
    
    STATUS_NOT_SUPPORTED indicates that the IRP should be passed down without
    changing the Irp->IoStatus.Status field otherwise it is updated with this
    status.
    
--*/

NTSTATUS
MfDeviceUsageNotificationCommon(
    IN PIRP Irp,
    IN PMF_COMMON_EXTENSION Common,
	IN PIO_STACK_LOCATION IrpStack
    )
{
    PULONG counter;
    
    //
    // Select the appropriate counter
    //
    
    switch (IrpStack->Parameters.UsageNotification.Type) {
    
    case DeviceUsageTypePaging:
        counter = &Common->PagingCount;
        break;
    
    case DeviceUsageTypeHibernation:
        counter = &Common->HibernationCount;
        break;

    case DeviceUsageTypeDumpFile:
        counter = &Common->DumpCount;
        break;

    default:
        return STATUS_NOT_SUPPORTED;
    }

    //
    // Update it...
    //
    
    IoAdjustPagingPathCount(counter, 
                            IrpStack->Parameters.UsageNotification.InPath
                            );
    
    return STATUS_SUCCESS;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\mf\debug.c ===
/*++      

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module provides debugging support.

Author:

    Andy Thornton (andrewth) 20-Oct-97

Revision History:

--*/


#include "mfp.h"

//
// Get mappings from status codes to strings
//

#include <ntstatus.dbg>

#undef MAP
#define MAP(_Value) { (_Value), #_Value }
#define END_STRING_MAP  { 0xFFFFFFFF, NULL }
#if DBG

LONG MfDebug = -1;

PMF_STRING_MAP MfDbgStatusStringMap = (PMF_STRING_MAP) ntstatusSymbolicNames;

MF_STRING_MAP MfDbgPnpIrpStringMap[] = {

    MAP(IRP_MN_START_DEVICE),
    MAP(IRP_MN_QUERY_REMOVE_DEVICE),
    MAP(IRP_MN_REMOVE_DEVICE),
    MAP(IRP_MN_CANCEL_REMOVE_DEVICE),
    MAP(IRP_MN_STOP_DEVICE),
    MAP(IRP_MN_QUERY_STOP_DEVICE),
    MAP(IRP_MN_CANCEL_STOP_DEVICE),
    MAP(IRP_MN_QUERY_DEVICE_RELATIONS),
    MAP(IRP_MN_QUERY_INTERFACE),
    MAP(IRP_MN_QUERY_CAPABILITIES),
    MAP(IRP_MN_QUERY_RESOURCES),
    MAP(IRP_MN_QUERY_RESOURCE_REQUIREMENTS),
    MAP(IRP_MN_QUERY_DEVICE_TEXT),
    MAP(IRP_MN_FILTER_RESOURCE_REQUIREMENTS),
    MAP(IRP_MN_READ_CONFIG),
    MAP(IRP_MN_WRITE_CONFIG),
    MAP(IRP_MN_EJECT),
    MAP(IRP_MN_SET_LOCK),
    MAP(IRP_MN_QUERY_ID),
    MAP(IRP_MN_QUERY_PNP_DEVICE_STATE),
    MAP(IRP_MN_QUERY_BUS_INFORMATION),
    MAP(IRP_MN_DEVICE_USAGE_NOTIFICATION),
    MAP(IRP_MN_SURPRISE_REMOVAL),
    MAP(IRP_MN_QUERY_LEGACY_BUS_INFORMATION),
    END_STRING_MAP
};


MF_STRING_MAP MfDbgPoIrpStringMap[] = {

    MAP(IRP_MN_WAIT_WAKE),
    MAP(IRP_MN_POWER_SEQUENCE),
    MAP(IRP_MN_SET_POWER),
    MAP(IRP_MN_QUERY_POWER),
    END_STRING_MAP
};



MF_STRING_MAP MfDbgDeviceRelationStringMap[] = {
    
    MAP(BusRelations),
    MAP(EjectionRelations),
    MAP(PowerRelations),
    MAP(RemovalRelations),
    MAP(TargetDeviceRelation),
    END_STRING_MAP
    
};

MF_STRING_MAP MfDbgSystemPowerStringMap[] = {
    
    MAP(PowerSystemUnspecified),
    MAP(PowerSystemWorking),
    MAP(PowerSystemSleeping1),
    MAP(PowerSystemSleeping2),
    MAP(PowerSystemSleeping3),
    MAP(PowerSystemHibernate),
    MAP(PowerSystemShutdown),
    MAP(PowerSystemMaximum),
    END_STRING_MAP

};

MF_STRING_MAP MfDbgDevicePowerStringMap[] = {
    
    MAP(PowerDeviceUnspecified),
    MAP(PowerDeviceD0),
    MAP(PowerDeviceD1),
    MAP(PowerDeviceD2),
    MAP(PowerDeviceD3),
    MAP(PowerDeviceMaximum),
    END_STRING_MAP

};

PCHAR
MfDbgLookupString(
    IN PMF_STRING_MAP Map,
    IN ULONG Id
    )

/*++

Routine Description:

    Looks up the string associated with Id in string map Map
    
Arguments:

    Map - The string map
    
    Id - The id to lookup

Return Value:

    The string
        
--*/

{
    PMF_STRING_MAP current = Map;
    
    while(current->Id != 0xFFFFFFFF) {

        if (current->Id == Id) {
            return current->String;
        }
        
        current++;
    }
    
    return "** UNKNOWN **";
}

VOID
MfDbgPrintMultiSz(
    LONG DebugLevel,
    PWSTR MultiSz
    )

/*++

Routine Description:

    Prints a registry style REG_MULTI_SZ
    
Arguments:

    DebugLevel - The debug level at which or above the data should be displayed.
    
    MultiSz - The string to print

Return Value:

    None
            
--*/

{
    PWSTR current = MultiSz;

    if (DebugLevel <= MfDebug) {

        if (MultiSz) {
        
            while(*current) {
        
                DbgPrint("%S", current);
                
                current += wcslen(current) + 1; // include the NULL
        
                DbgPrint(*current ? ", " : "\n");
        
            }
        } else {
            DbgPrint("*** None ***\n");
        }
    }
}

VOID
MfDbgPrintResourceMap(
    LONG DebugLevel,
    PMF_RESOURCE_MAP Map
    )

/*++

Routine Description:

    Prints a resource map
        
Arguments:

    DebugLevel - The debug level at which or above the data should be displayed.
    
    Map - The map to be displayed

Return Value:

    None
            
--*/

{
    PCHAR current;
    
    if (DebugLevel <= MfDebug) {
    
        if (Map) {
            
            FOR_ALL_IN_ARRAY(Map->Resources, Map->Count, current) {
                DbgPrint("%i ", *current);
            }
            
            DbgPrint("\n");
        
        } else {
            
            DbgPrint("*** None ***\n");
        
        }
    }
}

VOID
MfDbgPrintVaryingResourceMap(
    LONG DebugLevel,
    PMF_VARYING_RESOURCE_MAP Map
    )

/*++

Routine Description:

    Prints a varying resource map
        
Arguments:

    DebugLevel - The debug level at which or above the data should be displayed.
    
    Map - The map to be displayed

Return Value:

    None
            
--*/

{
    PMF_VARYING_RESOURCE_ENTRY current;
    
    if (DebugLevel <= MfDebug) {
    
        if (Map) {
            
            DbgPrint("\n");
            FOR_ALL_IN_ARRAY(Map->Resources, Map->Count, current) {
                DbgPrint("\t\tIndex %i for %x bytes at offset %x\n",
                         current->ResourceIndex,
                         current->Size,
                         current->Offset
                         );
            }
            
        } else {
            
            DbgPrint("*** None ***\n");
        
        }
    }
}

//
// Printing resource descriptors and resource lists (stolen from PCI)
//

PUCHAR
MfDbgCmResourceTypeToText(
    UCHAR Type
    )
{
    switch (Type) {
    case CmResourceTypePort:
        return "CmResourceTypePort";
    case CmResourceTypeInterrupt:
        return "CmResourceTypeInterrupt";
    case CmResourceTypeMemory:
        return "CmResourceTypeMemory";
    case CmResourceTypeDma:
        return "CmResourceTypeDma";
    case CmResourceTypeDeviceSpecific:
        return "CmResourceTypeDeviceSpecific";
    case CmResourceTypeBusNumber:
        return "CmResourceTypeBusNumber";
    case CmResourceTypeConfigData:
        return "CmResourceTypeConfigData";
    case CmResourceTypeDevicePrivate:
        return "CmResourceTypeDevicePrivate";
    case CmResourceTypePcCardConfig:
        return "CmResourceTypePcCardConfig";
    default:
        return "*** INVALID RESOURCE TYPE ***";
    }
}

VOID
MfDbgPrintIoResource(
    IN LONG Level,
    IN PIO_RESOURCE_DESCRIPTOR D
    )
{
    ULONG  i;
    PUCHAR t;

    if (Level <= MfDebug) {
    
        t = MfDbgCmResourceTypeToText(D->Type);
        DbgPrint("     IoResource Descriptor dump:  Descriptor @0x%x\n", D);
        DbgPrint("        Option           = 0x%x\n", D->Option);
        DbgPrint("        Type             = %d (%s)\n", D->Type, t);
        DbgPrint("        ShareDisposition = %d\n", D->ShareDisposition);
        DbgPrint("        Flags            = 0x%04X\n", D->Flags);
    
        for ( i = 0; i < 6 ; i+=3 ) {
            DbgPrint("        Data[%d] = %08x  %08x  %08x\n",
                     i,
                     D->u.DevicePrivate.Data[i],
                     D->u.DevicePrivate.Data[i+1],
                     D->u.DevicePrivate.Data[i+2]);
        }
    }
}


VOID
MfDbgPrintIoResReqList(
    IN LONG Level,
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoResReqList
    )
{
    ULONG                   numlists;
    PIO_RESOURCE_LIST       list;


    if (Level <= MfDebug) {
    
        if (IoResReqList) {
            
            numlists = IoResReqList->AlternativeLists;
            list     = IoResReqList->List;
        
            DbgPrint("  IO_RESOURCE_REQUIREMENTS_LIST\n");
            DbgPrint("     InterfaceType        %d\n", IoResReqList->InterfaceType);
            DbgPrint("     BusNumber            %d\n", IoResReqList->BusNumber    );
            DbgPrint("     SlotNumber           %d\n",  IoResReqList->SlotNumber  );
            DbgPrint("     AlternativeLists     %d\n", numlists                   );
        
            while (numlists--) {
        
                PIO_RESOURCE_DESCRIPTOR resource = list->Descriptors;
                ULONG                   count    = list->Count;
        
                DbgPrint("\n     List[%d].Count = %d\n", numlists, count);
                while (count--) {
                    MfDbgPrintIoResource(Level, resource++);
                }
        
                list = (PIO_RESOURCE_LIST)resource;
            }
            DbgPrint("\n");
        } else {
            
            DbgPrint("  IO_RESOURCE_REQUIREMENTS_LIST\n");
            DbgPrint("     *** EMPTY ***\n");
        }
    }
}


VOID
MfDbgPrintPartialResource(
    IN LONG Level,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR D
    )
{
    ULONG  i;
    PUCHAR t;

    if (Level <= MfDebug) {

        if (D) {
        
            t = MfDbgCmResourceTypeToText(D->Type);
            DbgPrint("     Partial Resource Descriptor @0x%x\n", D);
            DbgPrint("        Type             = %d (%s)\n", D->Type, t);
            DbgPrint("        ShareDisposition = %d\n", D->ShareDisposition);
            DbgPrint("        Flags            = 0x%04X\n", D->Flags);
            
            for ( i = 0; i < 3 ; i+=3 ) {
                DbgPrint("        Data[%d] = %08x  %08x  %08x\n",
                         i,
                         D->u.DevicePrivate.Data[i],
                         D->u.DevicePrivate.Data[i+1],
                         D->u.DevicePrivate.Data[i+2]);
            }

        } else {
        
            DbgPrint("     Partial Resource Descriptor EMPTY!!\n");
        }
    }
}

PCM_PARTIAL_RESOURCE_DESCRIPTOR
MfNextPartialDescriptor(
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    )

/*++

Routine Description:

    Given a pointer to a CmPartialResourceDescriptor, return a pointer
    to the next descriptor in the same list.

    This is only done in a routine (rather than a simple descriptor++)
    because if the variable length resource CmResourceTypeDeviceSpecific.

Arguments:

    Descriptor   - Pointer to the descriptor being advanced over.

Return Value:

    Pointer to the next descriptor in the same list (or byte beyond
    end of list).

--*/

{
    PCM_PARTIAL_RESOURCE_DESCRIPTOR nextDescriptor;

    nextDescriptor = Descriptor + 1;

    if (Descriptor->Type == CmResourceTypeDeviceSpecific) {

        //
        // This (old) descriptor is followed by DataSize bytes
        // of device specific data, ie, not immediatelly by the
        // next descriptor.   Adjust nextDescriptor by this amount.
        //

        nextDescriptor = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)
            ((PCHAR)nextDescriptor + Descriptor->u.DeviceSpecificData.DataSize);
    }
    return nextDescriptor;
}


VOID
MfDbgPrintCmResList(
    IN LONG Level,
    IN PCM_RESOURCE_LIST ResourceList
    )
{
    ULONG                           numlists;
    PCM_FULL_RESOURCE_DESCRIPTOR    full;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR descriptor;

    if (Level <= MfDebug) {
    

        if (ResourceList) {
        
            numlists = ResourceList->Count;
            full     = ResourceList->List;
        
            DbgPrint("  CM_RESOURCE_LIST (List Count = %d)\n",
                     numlists);
        
            while (numlists--) {
                PCM_PARTIAL_RESOURCE_LIST partial = &full->PartialResourceList;
                ULONG                     count   = partial->Count;
        
                DbgPrint("     InterfaceType        %d\n", full->InterfaceType);
                DbgPrint("     BusNumber            %d\n", full->BusNumber    );
        
                descriptor = partial->PartialDescriptors;
                while (count--) {
                    MfDbgPrintPartialResource(Level, descriptor);
                    descriptor = MfNextPartialDescriptor(descriptor);
                }
        
                full = (PCM_FULL_RESOURCE_DESCRIPTOR)descriptor;
            }
            DbgPrint("\n");
        
        } else {
        
            DbgPrint("  CM_RESOURCE_LIST EMPTY!!!\n");
        }
    }
}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\mf\arbiter.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    arbiter.c

Abstract:

    This module provides arbiters for the resources consumed by PDOs.

Author:

    Andy Thornton (andrewth) 20-Oct-97

Revision History:

--*/


#include "mfp.h"
#include "arbiter.h"


NTSTATUS
MfInitializeArbiters(
    IN PMF_PARENT_EXTENSION Parent
    );

NTSTATUS
MfInitializeArbiter(
    OUT PMF_ARBITER Arbiter,
    IN PDEVICE_OBJECT BusDeviceObject,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    );

LONG
MfNopScore(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    );

NTSTATUS
MfStartArbiter(
    IN PARBITER_INSTANCE Arbiter,
    IN PCM_RESOURCE_LIST StartResources
    );

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, MfInitializeArbiters)
#pragma alloc_text(PAGE, MfInitializeArbiter)
#pragma alloc_text(PAGE, MfNopScore)
#pragma alloc_text(PAGE, MfStartArbiter)

#endif


NTSTATUS
MfInitializeArbiters(
    IN PMF_PARENT_EXTENSION Parent
    )

/*++

Routine Description:

    This initializes the arbiters required to arbitrated resources for the
    parent device.

Arguments:

    Parent - The MF device we are initializing arbiters for.

Return Value:

    Status of operation.

--*/
{

    NTSTATUS status;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR descriptor;
    PMF_ARBITER arbiter, newArbiter = NULL;
    BOOLEAN existingArbiter;

    PAGED_CODE();

    //
    // REBALANCE - if restart then free the old arbiters
    // until we do that, assume we're not restarting
    //

    ASSERT(IsListEmpty(&Parent->Arbiters));

    //
    // If we don't have any resources we don't need any arbiters
    //

    if (!Parent->ResourceList) {

        return STATUS_SUCCESS;
    }

    FOR_ALL_CM_DESCRIPTORS(Parent->ResourceList, descriptor) {

        //
        // Check if this is an nonarbitrated resource - if it is then we won't
        // be needing an arbiter for it!
        //

        if (!IS_ARBITRATED_RESOURCE(descriptor->Type)) {
            continue;
        }

        //
        // See if we already have an arbiter for this resource
        //

        existingArbiter = FALSE;

        FOR_ALL_IN_LIST(MF_ARBITER, &Parent->Arbiters, arbiter) {

            if (arbiter->Type == descriptor->Type) {

                //
                // We already have an arbiter so we don't need
                // to create a new one
                //

                existingArbiter = TRUE;

                break;
            }
        }

        if (!existingArbiter) {

            //
            // We don't have an arbiter for this resource type so make one!
            //

            DEBUG_MSG(1,
                      ("Creating arbiter for %s\n",
                       MfDbgCmResourceTypeToText(descriptor->Type)
                      ));

            newArbiter = ExAllocatePoolWithTag(PagedPool,
                                               sizeof(MF_ARBITER),
                                               MF_ARBITER_TAG
                                               );

            if (!newArbiter) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            status = MfInitializeArbiter(newArbiter, Parent->Self, descriptor);

            if (!NT_SUCCESS(status)) {
                goto cleanup;
            }

            InsertHeadList(&Parent->Arbiters, &newArbiter->ListEntry);

        }

    }

    FOR_ALL_IN_LIST(MF_ARBITER, &Parent->Arbiters, arbiter) {

        MfStartArbiter(&(arbiter->Instance), Parent->ResourceList);
    }

    return STATUS_SUCCESS;

cleanup:

    if (newArbiter) {

        ExFreePool(newArbiter);
    }

    return status;
}


LONG
MfNopScore(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    )
{
    PAGED_CODE();

    return 0;
}

NTSTATUS
MfInitializeArbiter(
    OUT PMF_ARBITER Arbiter,
    IN PDEVICE_OBJECT BusDeviceObject,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    )
/*

Routine Description:

    This initializes an arbiter to arbitrated the resources described in
    Descriptor

Arguments:

    Arbiter - Pointer to a buffer where the arbiter should reside.

    Descriptor - Describes the resources available to the arbiter.

Return Value:

    Status of operation.

*/

{

    NTSTATUS status;
    PMF_RESOURCE_TYPE resType;

    PAGED_CODE();

    //
    // Do we understand these resources
    //

    resType = MfFindResourceType(Descriptor->Type);

    if (!resType) {
        return STATUS_INVALID_PARAMETER;
    }

    Arbiter->Type = Descriptor->Type;

    RtlZeroMemory(&Arbiter->Instance, sizeof(ARBITER_INSTANCE));

    Arbiter->Instance.PackResource = resType->PackResource;
    Arbiter->Instance.UnpackResource = resType->UnpackResource;
    Arbiter->Instance.UnpackRequirement = resType->UnpackRequirement;

    //
    // Initialize the arbiter
    //

    status = ArbInitializeArbiterInstance(&Arbiter->Instance,
                                          BusDeviceObject,
                                          Arbiter->Type,
                                          L"Mf Arbiter",
                                          L"Root",  // should be NULL
                                          NULL
                                          );



    return status;

}

//
// Arbiter support functions
//

NTSTATUS
MfStartArbiter(
    IN PARBITER_INSTANCE Arbiter,
    IN PCM_RESOURCE_LIST StartResources
    )
/*++

Routine Description:

    This initializes an arbiter's range list to arbitrate the
    resources described in StartResources

Arguments:

    Arbiter - Pointer to the arbiter.

    StartResources - Describes the resources available to the arbiter.

Return Value:

    Status of operation.

--*/

{
    RTL_RANGE_LIST invertedAllocation;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR descriptor;
    ULONGLONG start;
    ULONG length;
    NTSTATUS status;


    PAGED_CODE();

    RtlInitializeRangeList(&invertedAllocation);

    //
    // Iterate through resource descriptors, adding the resources
    // this arbiter arbitrates to the ReverseAllocation
    //

    FOR_ALL_CM_DESCRIPTORS(StartResources,descriptor) {

        if (descriptor->Type == Arbiter->ResourceType) {

            status = Arbiter->UnpackResource(descriptor,
                                             &start,
                                             &length);

            if (!NT_SUCCESS(status)) {
                goto cleanup;
            }

            if (length > 0) {

                //
                // we don't care about Attributes, UserData or Owner since this
                // list is going to get trashed in a minute anyway
                //

                status = RtlAddRange(&invertedAllocation,
                                     start,
                                     END_OF_RANGE(start,length),
                                     0,                             // Attributes
                                     RTL_RANGE_LIST_ADD_SHARED|RTL_RANGE_LIST_ADD_IF_CONFLICT,
                                     0,                             // UserData
                                     NULL);                         // Owner
            }

            if (!NT_SUCCESS(status)) {
                goto cleanup;
            }

        }
    }

    status = RtlInvertRangeList(Arbiter->Allocation,&invertedAllocation);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    status = STATUS_SUCCESS;

cleanup:

    RtlFreeRangeList(&invertedAllocation);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\mf\debug.h ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This header provides debugging support prototypes and macros

Author:

    Andy Thornton (andrewth) 20-Oct-97

Revision History:

--*/


#if !defined(_DEBUG_)
#define DEBUG

#if DBG

typedef struct _MF_STRING_MAP {
    ULONG Id;
    PCHAR String;
} MF_STRING_MAP, *PMF_STRING_MAP;

//
// Debug globals
//

extern LONG MfDebug;
extern MF_STRING_MAP MfDbgPnpIrpStringMap[];
extern MF_STRING_MAP MfDbgPoIrpStringMap[];
extern MF_STRING_MAP MfDbgDeviceRelationStringMap[];
extern MF_STRING_MAP MfDbgSystemPowerStringMap[];
extern MF_STRING_MAP MfDbgDevicePowerStringMap[];
extern PMF_STRING_MAP MfDbgStatusStringMap;

//
// Debug prototypes
//

VOID
MfDbgInitialize(
    VOID
    );

VOID
MfDbgPrintMultiSz(
    LONG DebugLevel,
    PWSTR MultiSz
    );

PCHAR
MfDbgLookupString(
    IN PMF_STRING_MAP Map,
    IN ULONG Id
    );

VOID
MfDbgPrintResourceMap(
    LONG DebugLevel,
    PMF_RESOURCE_MAP Map
    );

VOID
MfDbgPrintVaryingResourceMap(
    LONG DebugLevel,
    PMF_VARYING_RESOURCE_MAP Map
    );

VOID
MfDbgPrintCmResList(
    IN LONG Level,
    IN PCM_RESOURCE_LIST ResourceList
    );

VOID
MfDbgPrintIoResReqList(
    IN LONG Level,
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoResReqList
    );

PUCHAR
MfDbgCmResourceTypeToText(
    UCHAR Type
    );


//
// Debug macros
//

#define DEBUG_PRINT(Level, Msg)                                             \
    if (Level <= MfDebug) DbgPrint Msg

#define DEBUG_MSG(Level, Msg)                                               \
    if (Level <= MfDebug) { DbgPrint("Mf: "); DbgPrint Msg; }

#define ASSERT_MF_DEVICE(DeviceObject)                                      \
    ASSERT(((PMF_COMMON_EXTENSION)DeviceObject->DeviceExtension)->Type      \
                == MfFunctionalDeviceObject                                 \
          ||                                                                \
           ((PMF_COMMON_EXTENSION)DeviceObject->DeviceExtension)->Type      \
                == MfPhysicalDeviceObject)


#define STATUS_STRING(_Status)                                              \
    (_Status) == STATUS_SUCCESS ?                                           \
        "STATUS_SUCCESS" : MfDbgLookupString(MfDbgStatusStringMap, (_Status))

#define PNP_IRP_STRING(_Irp)                                                \
    MfDbgLookupString(MfDbgPnpIrpStringMap, (_Irp))

#define PO_IRP_STRING(_Irp)                                                 \
    MfDbgLookupString(MfDbgPoIrpStringMap, (_Irp))

#define RELATION_STRING(_Relation)                                          \
    MfDbgLookupString(MfDbgDeviceRelationStringMap, (_Relation))

#define SYSTEM_POWER_STRING(_State)                                         \
    MfDbgLookupString(MfDbgSystemPowerStringMap, (_State))

#define DEVICE_POWER_STRING(_State)                                         \
    MfDbgLookupString(MfDbgDevicePowerStringMap, (_State))



#else

#define DEBUG_PRINT(Level, Msg) 
#define DEBUG_MSG(Level, Msg)
#define ASSERT_MF_DEVICE(DeviceObject)
#define STATUS_STRING(_Status)      ""
#define PNP_IRP_STRING(_Irp)        ""
#define PO_IRP_STRING(_Irp)         ""
#define RELATION_STRING(_Relation)  ""
#define SYSTEM_POWER_STRING(_State) ""
#define DEVICE_POWER_STRING(_State) ""

#endif // DBG

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\mf\dispatch.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

    This module provides the functions which dispatch IRPs to FDOs and PDOs.

Author:

    Andy Thornton (andrewth) 20-Oct-97

Revision History:

--*/


#include "mfp.h"

NTSTATUS
MfAddDevice(
    IN PDRIVER_OBJECT  DriverObject,
    IN PDEVICE_OBJECT  PhysicalDeviceObject
    );

NTSTATUS
MfDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MfDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MfDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, MfAddDevice)
#pragma alloc_text(PAGE, MfDispatchPnp)
#pragma alloc_text(PAGE, MfForwardIrpToParent)
#pragma alloc_text(PAGE, MfDispatchNop)

#endif

NTSTATUS
MfAddDevice(
    IN PDRIVER_OBJECT  DriverObject,
    IN PDEVICE_OBJECT  PhysicalDeviceObject
    )

/*++

Routine Description:

    Given a physical device object, this routine creates a functional
    device object for it and attaches it to the top of the stack.

Arguments:

    DriverObject - Pointer to our driver's DRIVER_OBJECT structure.

    PhysicalDeviceObject - Pointer to the physical device object for which
                           we must create a functional device object.

Return Value:

    NT status.

--*/
{
    NTSTATUS status;
    PDEVICE_OBJECT fdo = NULL;
    PMF_PARENT_EXTENSION extension;

    ASSERT(DriverObject == MfDriverObject);

    PAGED_CODE();

    //
    // Create our FDO
    //

    status = MfCreateFdo(&fdo);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    extension = fdo->DeviceExtension;

    extension->PhysicalDeviceObject = PhysicalDeviceObject;

    //
    // Attach to the stack
    //

    extension->AttachedDevice = IoAttachDeviceToDeviceStack(
                                    fdo,
                                    PhysicalDeviceObject
                                    );

    if (!extension->AttachedDevice) {

        //
        // Could not attach
        //

        status = STATUS_NO_SUCH_DEVICE;
        goto cleanup;
    }

    fdo->Flags |= DO_POWER_PAGABLE;
    fdo->Flags &= ~DO_DEVICE_INITIALIZING;

    DEBUG_MSG(1, ("Completed AddDevice for PDO 0x%08x\n", PhysicalDeviceObject));

    return STATUS_SUCCESS;

cleanup:

    if (fdo) {
        IoDeleteDevice(fdo);
    }

    return status;
}

NTSTATUS
MfDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles all IRP_MJ_PNP IRPs for this driver.  It dispatches to
    the appropriate fdo/pdo routine.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/

{
    NTSTATUS status;
    PMF_COMMON_EXTENSION common;
    PIO_STACK_LOCATION irpStack;

    PAGED_CODE();

    ASSERT_MF_DEVICE(DeviceObject);

    common = (PMF_COMMON_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    ASSERT(irpStack->MajorFunction == IRP_MJ_PNP);

    if (IS_FDO(common)) {
        return MfDispatchPnpFdo(DeviceObject,
                                (PMF_PARENT_EXTENSION) common,
                                irpStack,
                                Irp
                                );
    } else {
        return MfDispatchPnpPdo(DeviceObject,
                                (PMF_CHILD_EXTENSION) common,
                                irpStack,
                                Irp
                                );
    }
}

NTSTATUS
MfDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles all IRP_MJ_POWER IRPs for this driver.  It dispatches
    to the routines described in the PoDispatchTable entry in the device object
    extension.

    This routine is NOT pageable as it can be called at DISPATCH_LEVEL

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/


{
    NTSTATUS status;
    PMF_COMMON_EXTENSION common;
    PIO_STACK_LOCATION irpStack;

    ASSERT_MF_DEVICE(DeviceObject);

    //
    // Find out who we are and what we need to do
    //

    common = (PMF_COMMON_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    ASSERT(irpStack->MajorFunction == IRP_MJ_POWER);

    if (IS_FDO(common)) {
        return MfDispatchPowerFdo(DeviceObject,
                                  (PMF_PARENT_EXTENSION) common,
                                  irpStack,
                                  Irp);
    } else {
        return MfDispatchPowerPdo(DeviceObject,
                                  (PMF_CHILD_EXTENSION) common,
                                  irpStack,
                                  Irp);
    }
}

NTSTATUS
MfIrpNotSupported(
    IN PIRP Irp,
    IN PVOID Extension,
    IN PIO_STACK_LOCATION IrpStack
    )
/*++

Routine Description:

    This function handles the unsupported IRPs for both mf PDOs and FDOs

    This is NOT paged because is can be called from MfDispatchPower which can
    be called at DISPATCH_LEVEL

Arguments:

    Irp - Points to the IRP associated with this request.

    Extension - Points to the device extension.

    IrpStack - Points to the current stack location for this request.

Return Value:

    STATUS_NOT_SUPPORTED

--*/

{
    UNREFERENCED_PARAMETER(Irp);
    UNREFERENCED_PARAMETER(Extension);
    UNREFERENCED_PARAMETER(IrpStack);

    DEBUG_MSG(1, ("Skipping upsupported IRP\n"));

    return STATUS_NOT_SUPPORTED;
}

NTSTATUS
MfForwardIrpToParent(
    IN PIRP Irp,
    IN PMF_CHILD_EXTENSION Child,
    IN PIO_STACK_LOCATION IrpStack
    )

/*++

Routine Description:

    This function builds a new Pnp irp and sends it to the parent device,
    returning the status and information to the child stack

Arguments:

    Irp - Points to the IRP associated with this request.

    Parent - Points to the parent FDO's device extension.

    IrpStack - Points to the current stack location for this request.

Return Value:

    The status of the IRP from the parent stack.

--*/

{
    PAGED_CODE();

    DEBUG_MSG(1, ("\tForwarding IRP to parent stack\n"));

    ASSERT(Child->Common.Type == MfPhysicalDeviceObject);
    ASSERT(IrpStack->MajorFunction == IRP_MJ_PNP);

    return MfSendPnpIrp(Child->Parent->Self,
                        IrpStack,
                        &Irp->IoStatus.Information
                        );
}


NTSTATUS
MfDispatchNop(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles irps like IRP_MJ_DEVICE_CONTROL, which we don't support.
    This handler will complete the irp (if PDO) or pass it (if FDO).

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP to dispatch.

Return Value:

    NT status.

--*/

{
    NTSTATUS status;
    PMF_COMMON_EXTENSION common;
    PDEVICE_OBJECT attachedDevice;

    PAGED_CODE();

    ASSERT_MF_DEVICE(DeviceObject);

    common = (PMF_COMMON_EXTENSION) DeviceObject->DeviceExtension;

    if (IS_FDO(common)) {

        attachedDevice = ((PMF_PARENT_EXTENSION) common)->AttachedDevice;

        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(attachedDevice, Irp);

    } else {

        status = STATUS_NOT_SUPPORTED;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\mf\mfp.h ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    local.h

Abstract:

    This header declares the stuctures and function prototypes shared between
    the various modules.

Author:

    Andy Thornton (andrewth) 20-Oct-97

Revision History:

--*/


#if !defined(_LOCAL_)
#define _LOCAL_

#include <ntddk.h>
#include <arbiter.h>
#include <wdmguid.h>
//#include <initguid.h>
#include <mf.h>

#include "msg.h"
#include "debug.h"

//
// --- Constants ---
//

#define MF_CM_RESOURCE_VERSION          1
#define MF_CM_RESOURCE_REVISION         1
#define MF_ARBITER_INTERFACE_VERSION    1
#define MF_TRANSLATOR_INTERFACE_VERSION 1

//
// These must be updated if any new PNP or PO irps are added
//

#define IRP_MN_PNP_MAXIMUM_FUNCTION IRP_MN_QUERY_LEGACY_BUS_INFORMATION
#define IRP_MN_PO_MAXIMUM_FUNCTION  IRP_MN_QUERY_POWER

//
// Pool Tags
//

#define MF_POOL_TAG                     '  fM'
#define MF_RESOURCE_MAP_TAG             'MRfM'
#define MF_VARYING_MAP_TAG              'MVfM'
#define MF_CHILD_LIST_TAG               'LCfM'
#define MF_DEVICE_ID_TAG                'IDfM'
#define MF_INSTANCE_ID_TAG              'IIfM'
#define MF_CHILD_REQUIREMENTS_TAG       'QCfM'
#define MF_CHILD_RESOURCE_TAG           'RCfM'
#define MF_HARDWARE_COMPATIBLE_ID_TAG   'IHfM'
#define MF_PARENTS_RESOURCE_TAG         'RPfM'
#define MF_PARENTS_REQUIREMENTS_TAG     'QPfM'
#define MF_BUS_RELATIONS_TAG            'RBfM'
#define MF_TARGET_RELATIONS_TAG         'RTfM'
#define MF_REQUIREMENTS_INDEX_TAG       'IRfM'
#define MF_ARBITER_TAG                  'rAfM'

//
// Device state flags
//

#define MF_DEVICE_STARTED               0x00000001
#define MF_DEVICE_REMOVED               0x00000002
#define MF_DEVICE_ENUMERATED            0x00000004
#define MF_DEVICE_REMOVE_PENDING        0x00000008 /* DEPRECATED */
#define MF_DEVICE_STOP_PENDING          0x00000010 /* DEPRECATED */
#define MF_DEVICE_CAPABILITIES_CAPTURED 0x00000020 /* DEPRECATED */
#define MF_DEVICE_REQUIREMENTS_CAPTURED 0x00000040 /* DEPRECATED */
#define MF_DEVICE_DELETED               0x00000080
#define MF_DEVICE_SURPRISE_REMOVED      0x00000100

//
// Flags to MfGetRegistryValue
//

#define MF_GETREG_SZ_TO_MULTI_SZ    0x00000001

//
// --- Type definitions ---
//

typedef enum _MF_OBJECT_TYPE {
    MfPhysicalDeviceObject   = 'dPfM',
    MfFunctionalDeviceObject = 'dFfM'
} MF_OBJECT_TYPE;

typedef
NTSTATUS
(*PMF_DISPATCH)(
    IN PIRP Irp,
    IN PVOID Extension,
    IN PIO_STACK_LOCATION IrpStack
    );

typedef ULONG Mf_MSG_ID;

//
// Structures for storing the resource distributions
//

typedef struct _MF_ARBITER {

    //
    // List of arbiters
    //
    LIST_ENTRY ListEntry;

    //
    // The resource this arbiter arbitrates
    //
    CM_RESOURCE_TYPE Type;

    //
    // The arbiter instance
    //
    ARBITER_INSTANCE Instance;

} MF_ARBITER, *PMF_ARBITER;



typedef struct _MF_COMMON_EXTENSION {

    //
    // Type of device this is
    //
    MF_OBJECT_TYPE Type;

    //
    // Dispatch tables for Pnp and Power Irps.
    //
    PMF_DISPATCH *PnpDispatchTable;
    PMF_DISPATCH *PoDispatchTable;

    //
    // Flags to indicate the device's current state (use MF_DEVICE_*)
    //
    ULONG DeviceState;

    ULONG PagingCount;
    ULONG HibernationCount;
    ULONG DumpCount;

    //
    // The power state of the device
    //
    DEVICE_POWER_STATE PowerState;

} MF_COMMON_EXTENSION, *PMF_COMMON_EXTENSION;

typedef struct _MF_CHILD_EXTENSION *PMF_CHILD_EXTENSION;
typedef struct _MF_PARENT_EXTENSION *PMF_PARENT_EXTENSION;

typedef struct _MF_CHILD_EXTENSION {

    //
    // The common extension
    //
    MF_COMMON_EXTENSION Common;

    //
    // Various Flags
    //
    ULONG Flags;

    //
    // Backpointer to the device object we are are the extension of
    //
    PDEVICE_OBJECT Self;

    //
    // The FDO who enumerated us
    //
    PMF_PARENT_EXTENSION Parent;

    //
    // Other children enumerated by the same FDO
    //
    LIST_ENTRY ListEntry;

    //
    // The pnp device state of the device
    //
    PNP_DEVICE_STATE PnpDeviceState;

    //
    // The information about this device
    //
    MF_DEVICE_INFO Info;

} MF_CHILD_EXTENSION, *PMF_CHILD_EXTENSION;


typedef struct _MF_PARENT_EXTENSION {

    //
    // The common extension
    //
    MF_COMMON_EXTENSION Common;

    //
    // Backpointer to the device object of whom we are the extension
    //
    PDEVICE_OBJECT Self;

    //
    // The PDO for the multi-function device
    //
    PDEVICE_OBJECT PhysicalDeviceObject;

    //
    // Lock for the children database
    //
    KEVENT ChildrenLock;

    //
    // List of children enumerated by this device
    //
    LIST_ENTRY Children;

    //
    // The next device in the stack who we should send our IRPs down to
    //
    PDEVICE_OBJECT AttachedDevice;

    //
    // The resources with which the parent was stated
    //
    PCM_RESOURCE_LIST ResourceList;
    PCM_RESOURCE_LIST TranslatedResourceList;

    //
    // The device and instance ID's of our parent
    //
    UNICODE_STRING DeviceID;
    UNICODE_STRING InstanceID;

    //
    // The already instantiated arbiters for this device
    //
    LIST_ENTRY Arbiters;

    //
    // If we had to traverse the children in order to determine what
    // the lowest power state the parent can go to, then the
    // synchronization of the children list would become extremely
    // complicated.
    //
    // Instead, have a spinlock protected data structure consisting of
    // an array of device power states.  Each element of the array is
    // a count of how many children are in that power state.  
    //

    KSPIN_LOCK PowerLock;
    LONG ChildrenPowerReferences[PowerDeviceMaximum];

    //
    // Remove lock.  Used to prevent the FDO from being removed while
    // other operations are digging around in the extension.
    //

    IO_REMOVE_LOCK RemoveLock;

} MF_PARENT_EXTENSION, *PMF_PARENT_EXTENSION;

//
// A list of MF_CHILD_LIST_ENTRYs is returned by MfEnumerate
//

typedef struct _MF_CHILD_LIST_ENTRY {
    LIST_ENTRY ListEntry;
    MF_DEVICE_INFO Info;
} MF_CHILD_LIST_ENTRY, *PMF_CHILD_LIST_ENTRY;

//
// Registry structure - from our friends in Win9x so it must be byte aligned
//

#include <pshpack1.h>

typedef struct _MF_REGISTRY_VARYING_RESOURCE_MAP {

    UCHAR ResourceIndex; // Win9x BYTE
    ULONG Offset;
    ULONG Size;

} MF_REGISTRY_VARYING_RESOURCE_MAP, *PMF_REGISTRY_VARYING_RESOURCE_MAP;

#include <poppack.h>

typedef
NTSTATUS
(*PMF_REQUIREMENT_FROM_RESOURCE)(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Resource,
    OUT PIO_RESOURCE_DESCRIPTOR Requirement
    );

typedef
NTSTATUS
(*PMF_UPDATE_RESOURCE)(
    IN OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Resource,
    IN ULONGLONG Start,
    IN ULONG Length
    );

typedef struct _MF_RESOURCE_TYPE {

    CM_RESOURCE_TYPE Type;
    PARBITER_UNPACK_REQUIREMENT UnpackRequirement;
    PARBITER_PACK_RESOURCE PackResource;
    PARBITER_UNPACK_RESOURCE UnpackResource;
    PMF_REQUIREMENT_FROM_RESOURCE RequirementFromResource;
    PMF_UPDATE_RESOURCE UpdateResource;

} MF_RESOURCE_TYPE, *PMF_RESOURCE_TYPE;

typedef struct _MF_POWER_COMPLETION_CONTEXT {

    //
    // Event that will be set when the operation is complete
    //
    KEVENT Event;

    //
    // The status of the completed operation
    //
    NTSTATUS Status;

} MF_POWER_COMPLETION_CONTEXT, *PMF_POWER_COMPLETION_CONTEXT;


//
// --- Globals ---
//

extern PDRIVER_OBJECT MfDriverObject;

//
// --- Function prototypes ---
//

//
// arbiter.c
//

NTSTATUS
MfInitializeArbiters(
    IN PMF_PARENT_EXTENSION Parent
    );

//
// common.c
//

NTSTATUS
MfDeviceUsageNotificationCommon(
    IN PIRP Irp,
    IN PMF_COMMON_EXTENSION Common,
    IN PIO_STACK_LOCATION IrpStack
    );

//
// dispatch.c
//

NTSTATUS
MfAddDevice(
    IN PDRIVER_OBJECT  DriverObject,
    IN PDEVICE_OBJECT  PhysicalDeviceObject
    );

NTSTATUS
MfDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MfDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MfIrpNotSupported(
    IN PIRP Irp,
    IN PVOID Extension,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
MfForwardIrpToParent(
    IN PIRP Irp,
    IN PMF_CHILD_EXTENSION Extension,
    IN PIO_STACK_LOCATION IrpStack
    );
    
NTSTATUS
MfDispatchNop(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//
// enum.c
//

NTSTATUS
MfEnumerate(
    IN PMF_PARENT_EXTENSION Parent
    );

NTSTATUS
MfBuildDeviceID(
    IN PMF_PARENT_EXTENSION Parent,
    OUT PWSTR *DeviceID
    );

NTSTATUS
MfBuildInstanceID(
    IN PMF_CHILD_EXTENSION Child,
    OUT PWSTR *InstanceID
    );

NTSTATUS
MfBuildChildRequirements(
    IN PMF_CHILD_EXTENSION Child,
    OUT PIO_RESOURCE_REQUIREMENTS_LIST *RequirementsList
    );

//
// fdo.c
//

NTSTATUS
MfDispatchPnpFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack,
    IN OUT PIRP Irp
    );

NTSTATUS
MfDispatchPowerFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack,
    IN OUT PIRP Irp
    );

NTSTATUS
MfCreateFdo(
    PDEVICE_OBJECT *Fdo
    );

VOID
MfAcquireChildrenLock(
    IN PMF_PARENT_EXTENSION Parent
    );

VOID
MfReleaseChildrenLock(
    IN PMF_PARENT_EXTENSION Parent
    );

//
// init.c
//

//
// pdo.c
//

NTSTATUS
MfDispatchPnpPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PMF_CHILD_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack,
    IN OUT PIRP Irp
    );

NTSTATUS
MfDispatchPowerPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PMF_CHILD_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack,
    IN OUT PIRP Irp
    );

NTSTATUS
MfCreatePdo(
    IN PMF_PARENT_EXTENSION Parent,
    OUT PDEVICE_OBJECT *PhysicalDeviceObject
    );

VOID
MfDeletePdo(
    IN PMF_CHILD_EXTENSION Child
    );

//
// resource.c
//

PMF_RESOURCE_TYPE
MfFindResourceType(
    IN CM_RESOURCE_TYPE Type
    );

//
// utils.c
//

NTSTATUS
MfGetSubkeyByIndex(
    IN HANDLE ParentHandle,
    IN ULONG Index,
    IN ACCESS_MASK Access,
    OUT PHANDLE ChildHandle,
    OUT PUNICODE_STRING Name
    );

VOID
MfInitCommonExtension(
    IN OUT PMF_COMMON_EXTENSION Common,
    IN MF_OBJECT_TYPE Type
    );

VOID
MfFreeDeviceInfo(
    PMF_DEVICE_INFO Info
    );

NTSTATUS
MfGetRegistryValue(
    IN HANDLE Handle,
    IN PWSTR Name,
    IN ULONG Type,
    IN ULONG Flags,
    IN OUT PULONG DataLength,
    IN OUT PVOID *Data OPTIONAL
    );

NTSTATUS
MfSendPnpIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_STACK_LOCATION Location,
    OUT PULONG_PTR Information OPTIONAL
    );

NTSTATUS
MfSendSetPowerIrp(
    IN PDEVICE_OBJECT Target,
    IN POWER_STATE State
    );

DEVICE_POWER_STATE
MfUpdateChildrenPowerReferences(
    IN PMF_PARENT_EXTENSION Parent,
    IN DEVICE_POWER_STATE PreviousPowerState,
    IN DEVICE_POWER_STATE NewPowerState
    );

NTSTATUS
MfUpdateParentPowerState(
    IN PMF_PARENT_EXTENSION Parent,
    IN DEVICE_POWER_STATE TargetPowerState
    );

//
// --- Macros ---
//

#define IS_FDO(Extension) \
    (((PMF_COMMON_EXTENSION)Extension)->Type == MfFunctionalDeviceObject)

#define MfCompareGuid(a,b)                                         \
    (RtlEqualMemory((PVOID)(a), (PVOID)(b), sizeof(GUID)))

//
// Control macro (used like a for loop) which iterates over all entries in
// a standard doubly linked list.  Head is the list head and the entries are of
// type Type.  A member called ListEntry is assumed to be the LIST_ENTRY
// structure linking the entries together.  Current contains a pointer to each
// entry in turn.
//
#define FOR_ALL_IN_LIST(Type, Head, Current)                            \
    for((Current) = CONTAINING_RECORD((Head)->Flink, Type, ListEntry);  \
       (Head) != &(Current)->ListEntry;                                 \
       (Current) = CONTAINING_RECORD((Current)->ListEntry.Flink,        \
                                     Type,                              \
                                     ListEntry)                         \
       )

#define FOR_ALL_IN_LIST_SAFE(Type, Head, Current, Next)                 \
    for((Current) = CONTAINING_RECORD((Head)->Flink, Type, ListEntry),  \
            (Next) = CONTAINING_RECORD((Current)->ListEntry.Flink,      \
                                       Type, ListEntry);                \
       (Head) != &(Current)->ListEntry;                                 \
       (Current) = (Next),                                              \
            (Next) = CONTAINING_RECORD((Current)->ListEntry.Flink,      \
                                     Type, ListEntry)                   \
       )

//
// Similar to the above only iteration is over an array of length _Size.
//
#define FOR_ALL_IN_ARRAY(_Array, _Size, _Current)                       \
    for ( (_Current) = (_Array);                                        \
          (_Current) < (_Array) + (_Size);                              \
          (_Current)++ )

//
// FOR_ALL_CM_DESCRIPTORS(
//      IN PCM_RESOURCE_LIST _ResList,
//      OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR _Descriptor
//      )
//
//  Iterates over the resource descriptors in a CM_RESOURCE_LIST of Count 1
//
#define FOR_ALL_CM_DESCRIPTORS(_ResList, _Descriptor)               \
    ASSERT((_ResList)->Count == 1);                                 \
    FOR_ALL_IN_ARRAY(                                               \
        (_ResList)->List[0].PartialResourceList.PartialDescriptors, \
        (_ResList)->List[0].PartialResourceList.Count,              \
        (_Descriptor)                                               \
        )

//
// BOOLEAN
// IS_ARBITRATED_RESOURCE(
//      IN CM_RESOURCE_TYPE _Resource
//      )
//
// If the top bit of the resource type (when viewed as a UCHAR) is set
// then the resource is nonarbitrated.
//
#define IS_ARBITRATED_RESOURCE(_Resource)                           \
    (!(((UCHAR)(_Resource)) & 0x80) &&                              \
     !(((UCHAR)(_Resource)) == 0x00))

#define END_OF_RANGE(_Start, _Length)                               \
    ((_Start)+(_Length)-1)

#endif // !defined(_LOCAL_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\mf\pdo.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    pdo.c

Abstract:

    This module provides the functions that pertain to MF.SYS PDOs

Author:

    Andy Thornton (andrewth) 20-Oct-97

Revision History:

--*/

#include "mfp.h"

/*++

The majority of functions in this file are called based on their presence
in Pnp and Po dispatch tables.  In the interests of brevity the arguments
to all those functions will be described below:

NTSTATUS
MfXxxPdo(
    IN PIRP Irp,
    IN PMF_CHILD_EXTENSION Child,
   IN PIO_STACK_LOCATION IrpStack
    )

Routine Description:

    This function handles the Xxx requests for multifunction PDO's

Arguments:

    Irp - Points to the IRP associated with this request.

    Child - Points to the child PDO's device extension.

    IrpStack - Points to the current stack location for this request.

Return Value:

    Status code that indicates whether or not the function was successful.

    STATUS_NOT_SUPPORTED indicates that the IRP should be completed without
    changing the Irp->IoStatus.Status field otherwise it is updated with this
    status.

--*/

NTSTATUS
MfCreatePdo(
           IN PMF_PARENT_EXTENSION Parent,
           OUT PDEVICE_OBJECT *PhysicalDeviceObject
           );

NTSTATUS
MfStartPdo(
          IN PIRP Irp,
          IN PMF_CHILD_EXTENSION Child,
          IN PIO_STACK_LOCATION IrpStack
          );

NTSTATUS
MfQueryRemovePdo(
                IN PIRP Irp,
                IN PMF_CHILD_EXTENSION Child,
                IN PIO_STACK_LOCATION IrpStack
                );

NTSTATUS
MfRemovePdo(
           IN PIRP Irp,
           IN PMF_CHILD_EXTENSION Child,
           IN PIO_STACK_LOCATION IrpStack
           );

NTSTATUS
MfSurpriseRemovePdo(
           IN PIRP Irp,
           IN PMF_CHILD_EXTENSION Child,
           IN PIO_STACK_LOCATION IrpStack
           );

NTSTATUS
MfCancelRemovePdo(
                 IN PIRP Irp,
                 IN PMF_CHILD_EXTENSION Child,
                 IN PIO_STACK_LOCATION IrpStack
                 );

NTSTATUS
MfStopPdo(
         IN PIRP Irp,
         IN PMF_CHILD_EXTENSION Child,
         IN PIO_STACK_LOCATION IrpStack
         );

NTSTATUS
MfQueryStopPdo(
              IN PIRP Irp,
              IN PMF_CHILD_EXTENSION Child,
              IN PIO_STACK_LOCATION IrpStack
              );

NTSTATUS
MfCancelStopPdo(
               IN PIRP Irp,
               IN PMF_CHILD_EXTENSION Child,
               IN PIO_STACK_LOCATION IrpStack
               );
NTSTATUS
MfQueryDeviceRelationsPdo(
                      IN PIRP Irp,
                      IN PMF_CHILD_EXTENSION Child,
                      IN PIO_STACK_LOCATION IrpStack
                      );

NTSTATUS
MfQueryInterfacePdo(
                   IN PIRP Irp,
                   IN PMF_CHILD_EXTENSION Child,
                   IN PIO_STACK_LOCATION IrpStack
                   );
NTSTATUS
MfQueryCapabilitiesPdo(
                   IN PIRP Irp,
                   IN PMF_CHILD_EXTENSION Child,
                   IN PIO_STACK_LOCATION IrpStack
                   );

NTSTATUS
MfQueryResourcesPdo(
                   IN PIRP Irp,
                   IN PMF_CHILD_EXTENSION Child,
                   IN PIO_STACK_LOCATION IrpStack
                   );

NTSTATUS
MfQueryResourceRequirementsPdo(
                              IN PIRP Irp,
                              IN PMF_CHILD_EXTENSION Child,
                              IN PIO_STACK_LOCATION IrpStack
                              );

NTSTATUS
MfQueryDeviceTextPdo(
                    IN PIRP Irp,
                    IN PMF_CHILD_EXTENSION Child,
                    IN PIO_STACK_LOCATION IrpStack
                    );

NTSTATUS
MfQueryIdPdo(
            IN PIRP Irp,
            IN PMF_CHILD_EXTENSION Child,
            IN PIO_STACK_LOCATION IrpStack
            );


NTSTATUS
MfQueryPnpDeviceStatePdo(
                        IN PIRP Irp,
                        IN PMF_CHILD_EXTENSION Child,
                        IN PIO_STACK_LOCATION IrpStack
                        );

NTSTATUS
MfPagingNotificationPdo(
                       IN PIRP Irp,
                       IN PMF_CHILD_EXTENSION Child,
                       IN PIO_STACK_LOCATION IrpStack
                       );

NTSTATUS
MfSetPowerPdo(
             IN PIRP Irp,
             IN PMF_CHILD_EXTENSION Child,
             IN PIO_STACK_LOCATION IrpStack
             );

NTSTATUS
MfQueryPowerPdo(
               IN PIRP Irp,
               IN PMF_CHILD_EXTENSION Child,
               IN PIO_STACK_LOCATION IrpStack
               );

VOID
MfTranslatorReference(
    IN PVOID Context
    );

VOID
MfTranslatorDereference(
    IN PVOID Context
    );

BOOLEAN
MfIsSubResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Super,
    IN ULONGLONG SubStart,
    IN ULONG SubLength,
    OUT PULONGLONG Offset
    );

NTSTATUS
MfPerformTranslation(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Translated,
    IN ULONGLONG Offset,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );

NTSTATUS
MfTransFromRawRequirements(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    );

NTSTATUS
MfTransFromRawResources(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
);

#ifdef ALLOC_PRAGMA
   #pragma alloc_text(PAGE, MfCancelRemovePdo)
   #pragma alloc_text(PAGE, MfCancelStopPdo)
   #pragma alloc_text(PAGE, MfCreatePdo)
   #pragma alloc_text(PAGE, MfDispatchPnpPdo)
   #pragma alloc_text(PAGE, MfIsSubResource)
   #pragma alloc_text(PAGE, MfPerformTranslation)
   #pragma alloc_text(PAGE, MfQueryCapabilitiesPdo)
   #pragma alloc_text(PAGE, MfQueryDeviceRelationsPdo)
   #pragma alloc_text(PAGE, MfQueryDeviceTextPdo)
   #pragma alloc_text(PAGE, MfQueryIdPdo)
   #pragma alloc_text(PAGE, MfQueryInterfacePdo)
   #pragma alloc_text(PAGE, MfQueryRemovePdo)
   #pragma alloc_text(PAGE, MfQueryResourceRequirementsPdo)
   #pragma alloc_text(PAGE, MfQueryResourcesPdo)
   #pragma alloc_text(PAGE, MfQueryStopPdo)
   #pragma alloc_text(PAGE, MfRemovePdo)
   #pragma alloc_text(PAGE, MfStartPdo)
   #pragma alloc_text(PAGE, MfStopPdo)
   #pragma alloc_text(PAGE, MfTransFromRawRequirements)
   #pragma alloc_text(PAGE, MfTransFromRawResources)
#endif

PMF_DISPATCH MfPnpDispatchTablePdo[] = {

   MfStartPdo,                     // IRP_MN_START_DEVICE
   MfQueryRemovePdo,               // IRP_MN_QUERY_REMOVE_DEVICE
   MfRemovePdo,                    // IRP_MN_REMOVE_DEVICE
   MfCancelRemovePdo,              // IRP_MN_CANCEL_REMOVE_DEVICE
   MfIrpNotSupported,              // IRP_MN_STOP_DEVICE
   MfQueryStopPdo,                 // IRP_MN_QUERY_STOP_DEVICE
   MfCancelStopPdo,                // IRP_MN_CANCEL_STOP_DEVICE
   MfQueryDeviceRelationsPdo,      // IRP_MN_QUERY_DEVICE_RELATIONS
   MfQueryInterfacePdo,            // IRP_MN_QUERY_INTERFACE
   MfQueryCapabilitiesPdo,         // IRP_MN_QUERY_CAPABILITIES
   MfQueryResourcesPdo,            // IRP_MN_QUERY_RESOURCES
   MfQueryResourceRequirementsPdo, // IRP_MN_QUERY_RESOURCE_REQUIREMENTS
   MfQueryDeviceTextPdo,           // IRP_MN_QUERY_DEVICE_TEXT
   MfIrpNotSupported,              // IRP_MN_FILTER_RESOURCE_REQUIREMENTS
   MfIrpNotSupported,              // Unused
   MfForwardIrpToParent,           // IRP_MN_READ_CONFIG
   MfForwardIrpToParent,           // IRP_MN_WRITE_CONFIG
   MfForwardIrpToParent,           // IRP_MN_EJECT
   MfForwardIrpToParent,           // IRP_MN_SET_LOCK
   MfQueryIdPdo,                   // IRP_MN_QUERY_ID
   MfQueryPnpDeviceStatePdo,       // IRP_MN_QUERY_PNP_DEVICE_STATE
   MfForwardIrpToParent,           // IRP_MN_QUERY_BUS_INFORMATION
   MfDeviceUsageNotificationCommon,// IRP_MN_DEVICE_USAGE_NOTIFICATION
   MfSurpriseRemovePdo,            // IRP_MN_SURPRISE_REMOVAL
   MfIrpNotSupported               // IRP_MN_QUERY_LEGACY_BUS_INFORMATION
};

PMF_DISPATCH MfPoDispatchTablePdo[] = {
    NULL,                          // IRP_MN_WAIT_WAKE
    NULL,                          // IRP_MN_POWER_SEQUENCE
    MfSetPowerPdo,                 // IRP_MN_SET_POWER
    MfQueryPowerPdo                // IRP_MN_QUERY_POWER
};

NTSTATUS
MfCreatePdo(
           IN PMF_PARENT_EXTENSION Parent,
           OUT PDEVICE_OBJECT *PhysicalDeviceObject
           )

/*++

Routine Description:

    Creates and initializes a new pdo inserting it into the list of PDOs owned
    by Parent

Arguments:

    Parent - The parent device that owns this pdo.

    PhysicalDeviceObject - On success pointer to the physical device object created

Return Value:

    NT status.

--*/

{
   NTSTATUS status;
   PDEVICE_OBJECT pdo;
   PMF_CHILD_EXTENSION extension;

   PAGED_CODE();

   ASSERT((sizeof(MfPnpDispatchTablePdo) / sizeof(PMF_DISPATCH)) - 1
          == IRP_MN_PNP_MAXIMUM_FUNCTION);

   ASSERT((sizeof(MfPoDispatchTablePdo) / sizeof(PMF_DISPATCH)) - 1
          == IRP_MN_PO_MAXIMUM_FUNCTION);

   status = IoCreateDevice(Parent->Self->DriverObject,
                           sizeof(MF_CHILD_EXTENSION),
                           NULL, // Name
                           FILE_DEVICE_UNKNOWN,
                           FILE_AUTOGENERATED_DEVICE_NAME,
                           FALSE, // Exclusive
                           &pdo
                          );

   if (!NT_SUCCESS(status)) {
       return status;
   }


   //
   // Fill in our extension
   //

   extension = pdo->DeviceExtension;

   MfInitCommonExtension(&extension->Common, MfPhysicalDeviceObject);

   extension->Self = pdo;
   extension->Parent = Parent;

   extension->Common.PowerState = PowerDeviceUnspecified;

   //
   // Insert the child into the parents child list.  Access already
   // protected by the children lock taken in the QDR code.
   //

   InsertHeadList(&Parent->Children, &extension->ListEntry);

   //
   // Our FDO stack is pagable, so we need to
   // assume pagable as well.
   //

   pdo->Flags |= DO_POWER_PAGABLE;

   //
   // We have finished initializing
   //

   pdo->Flags &= ~DO_DEVICE_INITIALIZING;

   *PhysicalDeviceObject = pdo;

   //
   // Dump the info about the PDO just created
   //

   DEBUG_MSG(1, ("Created PDO @ 0x%08x\n", pdo));

   return STATUS_SUCCESS;
}


VOID
MfDeletePdo(
           IN PMF_CHILD_EXTENSION Child
           )

/*++

Routine Description:

    Cleans a PDO extension and any associated allocations.  Then
    deletes the PDO itself.

Arguments:

    Child - PDO extension

Return Value:

    None

--*/

{
    if (Child->Common.DeviceState & MF_DEVICE_DELETED) {
        //
        // Trying to delete twice
        //
        ASSERT(!(Child->Common.DeviceState & MF_DEVICE_DELETED));
        return;
    }

    MfFreeDeviceInfo(&Child->Info);

    Child->Common.DeviceState |= MF_DEVICE_DELETED;
    DEBUG_MSG(1, ("Deleted PDO @ 0x%08x\n", Child->Self));
    IoDeleteDevice(Child->Self);
}

NTSTATUS
MfDispatchPnpPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PMF_CHILD_EXTENSION Child,
    IN PIO_STACK_LOCATION IrpStack,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles IRP_MJ_PNP IRPs for PDOs.

Arguments:

    DeviceObject - Pointer to the PDO for which this IRP applies.

    Child - PDO extension

    IrpStack - Current stack location
    
    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/
{
    NTSTATUS status;
    BOOLEAN isRemove;
    
    PAGED_CODE();

    if (Child->Common.DeviceState & MF_DEVICE_DELETED) {
        status = Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
    } else if (IrpStack->MinorFunction > IRP_MN_PNP_MAXIMUM_FUNCTION) {
        status = Irp->IoStatus.Status;
    } else {
        //
        // If IRP_MN_REMOVE_DEVICE is received by a pdo that was not
        // enumerated in the last BusRelations query, then it needs to
        // delete the pdo *AFTER* completing the remove irp.  As this
        // is in conflict with the standard dispatch functionality
        // provided by this function, explicitly delegate completion
        // of this irp to the dispatched routine.

        isRemove = IrpStack->MinorFunction == IRP_MN_REMOVE_DEVICE;
        status =
            MfPnpDispatchTablePdo[IrpStack->MinorFunction](Irp,
                                                           Child,
                                                           IrpStack
                                                           );
        if (isRemove) {
            return status;
        }
        if (status != STATUS_NOT_SUPPORTED) {
            Irp->IoStatus.Status = status;
        } else {
            status = Irp->IoStatus.Status;
        }
    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

POWER_STATE
MfUpdatePowerPdo(
    IN PMF_CHILD_EXTENSION Child,
    IN DEVICE_POWER_STATE NewDevicePowerState
    )
{
    POWER_STATE previousState, newState;
    DEVICE_POWER_STATE newParentState;

    newState.DeviceState = NewDevicePowerState;
    previousState = PoSetPowerState(Child->Self,
                                    DevicePowerState,
                                    newState);

    ASSERT(previousState.DeviceState == Child->Common.PowerState);
    DEBUG_MSG(1,
              ("Updating child power state from %s (believed %s) to %s\n",
               DEVICE_POWER_STRING(previousState.DeviceState),
               DEVICE_POWER_STRING(Child->Common.PowerState),
               DEVICE_POWER_STRING(NewDevicePowerState)
               ));

    Child->Common.PowerState = NewDevicePowerState;

    //
    // We may be receiving an operation after our parent has been
    // surprise removed/removed in which case we should keep our
    // hands out of the cookie jar.
    //
    if (Child->Parent) {
        //
        // * We've already claimed that we can go to this power
        // state via the capabilities
        // * Said yes to QUERY_POWER
        // * Children's power state is defined to be as resource consuming
        // or less than the parent

        //
        // Update the children power state references stored in the
        // parent extension.  Compute a new target power state for the
        // parent

        newParentState =
            MfUpdateChildrenPowerReferences(Child->Parent,
                                            previousState.DeviceState,
                                            NewDevicePowerState
                                            );

        //
        // Modify the parent's power state to reflect that of it's
        // children.
        //

        MfUpdateParentPowerState(Child->Parent, newParentState);
    }

    return previousState;
}

NTSTATUS
MfStartPdo(
          IN PIRP Irp,
          IN PMF_CHILD_EXTENSION Child,
          IN PIO_STACK_LOCATION IrpStack
          )
{
   PDEVICE_OBJECT pDO;
   POWER_STATE previousState, newState;

   PAGED_CODE();

   if (Child->Common.DeviceState & MF_DEVICE_SURPRISE_REMOVED) {
       return STATUS_NO_SUCH_DEVICE;
   }
   //
   // Trivially succeed the start
   //

   MfUpdatePowerPdo(Child, PowerDeviceD0);

   return STATUS_SUCCESS;
}
NTSTATUS
MfQueryRemovePdo(
                IN PIRP Irp,
                IN PMF_CHILD_EXTENSION Child,
                IN PIO_STACK_LOCATION IrpStack
                )
{
   PAGED_CODE();

   if (Child->Common.PagingCount > 0
       ||  Child->Common.HibernationCount > 0
       ||  Child->Common.DumpCount > 0) {

       return STATUS_DEVICE_BUSY;

   } else {

       return STATUS_SUCCESS;
   }
}

NTSTATUS
MfCancelRemovePdo(
                 IN PIRP Irp,
                 IN PMF_CHILD_EXTENSION Child,
                 IN PIO_STACK_LOCATION IrpStack
                 )
{
   PAGED_CODE();

   return STATUS_SUCCESS;
}

NTSTATUS
MfRemovePdo(
           IN PIRP Irp,
           IN PMF_CHILD_EXTENSION Child,
           IN PIO_STACK_LOCATION IrpStack
           )
{
    PAGED_CODE();

    if ((Child->Common.DeviceState & MF_DEVICE_SURPRISE_REMOVED) == 0) {
       
        MfUpdatePowerPdo(Child, PowerDeviceD3);
    }

    //
    // If child appeared in the last BusRelations then just mark it
    // removed, otherwise completely delete it.
    // 

    Irp->IoStatus.Status = STATUS_SUCCESS;
    if (Child->Common.DeviceState & MF_DEVICE_ENUMERATED) {
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    } else {
        if (Child->Parent) {
            MfAcquireChildrenLock(Child->Parent);
            RemoveEntryList(&Child->ListEntry);
            MfReleaseChildrenLock(Child->Parent);
        }
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        MfDeletePdo(Child);
    }
    return STATUS_SUCCESS;
}

NTSTATUS
MfSurpriseRemovePdo(
           IN PIRP Irp,
           IN PMF_CHILD_EXTENSION Child,
           IN PIO_STACK_LOCATION IrpStack
           )
{
    PAGED_CODE();

    //
    // Mark device as surprise removed.
    //
    Child->Common.DeviceState |= MF_DEVICE_SURPRISE_REMOVED;

    //
    // Update my pdo's power state *AND* my parent's power state *IFF*
    // the parent is still connected.
    //
    MfUpdatePowerPdo(Child, PowerDeviceD3);

    //
    // The surprise remove could have one of many causes.  One
    // possibility that can be excluded is MF reporting its children
    // missing directly since MF children can't disappear.
    //

    return STATUS_SUCCESS;
}

//
// Stopping is disabled at the moment because MF is dependent on
// changes in the arbiters to support resource rebalance.
//

NTSTATUS
MfStopPdo(
         IN PIRP Irp,
         IN PMF_CHILD_EXTENSION Child,
         IN PIO_STACK_LOCATION IrpStack
         )
{
   PAGED_CODE();

   return STATUS_SUCCESS;
}

NTSTATUS
MfQueryStopPdo(
              IN PIRP Irp,
              IN PMF_CHILD_EXTENSION Child,
              IN PIO_STACK_LOCATION IrpStack
              )
{
   PAGED_CODE();

   if (Child->Common.PagingCount > 0
       ||  Child->Common.HibernationCount > 0
       ||  Child->Common.DumpCount > 0) {

       return STATUS_UNSUCCESSFUL;

   } else {

       // REBALANCE
       // If rebalance was supported by parent, then this would have
       // to succeed.

       return STATUS_UNSUCCESSFUL;
   }
}


NTSTATUS
MfCancelStopPdo(
               IN PIRP Irp,
               IN PMF_CHILD_EXTENSION Child,
               IN PIO_STACK_LOCATION IrpStack
               )
{
   PAGED_CODE();

   return STATUS_SUCCESS;
}

NTSTATUS
MfQueryDeviceRelationsPdo(
                      IN PIRP Irp,
                      IN PMF_CHILD_EXTENSION Child,
                      IN PIO_STACK_LOCATION IrpStack
                      )
{
   PDEVICE_RELATIONS deviceRelations;
   PMF_CHILD_EXTENSION nextChild;
   NTSTATUS          status;
   ULONG             index;

   PAGED_CODE();

   if ((Child->Common.DeviceState & MF_DEVICE_SURPRISE_REMOVED) ||
       (Child->Parent == NULL)) {
       return STATUS_NO_SUCH_DEVICE;
   }

   status = Irp->IoStatus.Status;

   switch (IrpStack->Parameters.QueryDeviceRelations.Type) {

   case TargetDeviceRelation:

      deviceRelations = ExAllocatePool(PagedPool, sizeof(DEVICE_RELATIONS));
      if (!deviceRelations) {
         return STATUS_INSUFFICIENT_RESOURCES;
      }

      status = ObReferenceObjectByPointer(Child->Self,
                                          0,
                                          NULL,
                                          KernelMode);
      if (!NT_SUCCESS(status)) {
         ExFreePool(deviceRelations);
         return status;
      }
      deviceRelations->Count = 1;
      deviceRelations->Objects[0] = Child->Self;
      Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;
      break;

   default:
      //
      // Don't touch the status
      //
      break;
   }
   return status;
}


//
// Seeing as the MF translator don't allocate any memory for their context the
// reference and dereference are nops.
//

VOID
MfTranslatorReference(
    IN PVOID Context
    )
{
}

VOID
MfTranslatorDereference(
    IN PVOID Context
    )
{
}

BOOLEAN
MfIsSubResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Super,
    IN ULONGLONG SubStart,
    IN ULONG SubLength,
    OUT PULONGLONG Offset
    )
{
/*++

Routine Description:

    Reports whether one resource descriptor is encapsulated
    in another

Arguments:

    Super - the resource descriptor that we want to encapsulate
    SubStart - The start of the subrange
    SubLength - The length of the subrange
    Offset - On success the offset from the beginning of Super and
        SubStart.

Return Value:

    TRUE on succeess FALSE otherwise
--*/

    NTSTATUS status;
    ULONGLONG superStart;
    ULONG superLength;
    PMF_RESOURCE_TYPE restype;

    PAGED_CODE();

    ASSERT(Offset);

    restype = MfFindResourceType(Super->Type);

    if (restype == NULL) {
        ASSERT(restype != NULL);
        return FALSE;
    }

    status = restype->UnpackResource(Super,&superStart,&superLength);

    if (!NT_SUCCESS(status)) {
        ASSERT(NT_SUCCESS(status));
        return FALSE;
    }

    //
    // special case 0 length resources
    //

    if (superLength == 0) {

        if (SubLength == 0 &&
            SubStart == superStart) {

            *Offset = 0;
            return TRUE;
        }
        else return FALSE;
    }

    if (SubLength == 0) {

        if (SubStart >= superStart &&
            SubStart <= superStart + superLength - 1) {

            *Offset = SubStart-superStart;
            return TRUE;
        }

        else return FALSE;
    }

    //
    // if SubStart falls in between the ends of Super, we have
    // potential encapsulation
    //
    if ((SubStart >= superStart) && (SubStart <= superStart+superLength-1)) {

        //
        // It is an error if the two ranges overlap.  Either
        // Sub should be encapsulated in Super or they should
        // not intersect.
        //
        ASSERT(SubStart+SubLength-1 <= superStart+superLength-1);
        if (SubStart+SubLength-1 > superStart+superLength-1) {
            return FALSE;
        }
        *Offset = SubStart-superStart;
        return TRUE;

    } else {
        //
        // Checking again to make sure ranges don't overlap
        //
        ASSERT((SubStart > superStart+superLength-1) ||
               (SubStart+SubLength-1 < superStart));
        return FALSE;
    }

}

NTSTATUS
MfPerformTranslation(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Translated,
    IN ULONGLONG Offset,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    )
{
/*++

Routine Description:

    stores the translated version of the Source resource in Target.

Arguments:

    Source - the raw resource
    Translated - the translated resource that matches the raw resource
        that encapsulates Source.
    offset - the offset of the beginning of Source from the raw parent
        resource.
    Target - the resource descriptor in which the translated version of
        source is stored.

Return Value:

    status of operation

--*/

    NTSTATUS status;
    PMF_RESOURCE_TYPE restype;
    ULONGLONG translatedStart, dummy;
    ULONG sourceLength, dummy2;

    PAGED_CODE();

    RtlCopyMemory(Target, Translated, sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));

    //
    // Get the length from the source
    //

    restype = MfFindResourceType(Source->Type);
    if (restype == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    status = restype->UnpackResource(Source, &dummy, &sourceLength);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Get the start of the translated
    //

    restype = MfFindResourceType(Translated->Type);
    if (restype == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    status = restype->UnpackResource(Translated, &translatedStart, &dummy2);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Apply the offset and any length changes and update the descriptor
    //

    status = restype->UpdateResource(Target, translatedStart + Offset, sourceLength);

    return status;
}


NTSTATUS
MfTransFromRawResources(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
)
/*++

Routine Description:

    Translates a raw resource into a global translated resource.

Arguments:

    Context - the parent extension that stores the raw and translated resources
    Source - the raw resource
    Direction - ChildToParent or ParentToChild
    PhysicalDeviceObject - the PDO associated with this
    Target - the translated resource

Return Value:

    status of operation

--*/
{
    PMF_PARENT_EXTENSION parent = (PMF_PARENT_EXTENSION) Context;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR raw, translated;
    NTSTATUS status;
    ULONGLONG offset;
    ULONGLONG sourceStart;
    ULONG sourceLength;
    PMF_RESOURCE_TYPE restype;
    ULONG index;

    PAGED_CODE();

    if (Direction == TranslateParentToChild) {
        //
        // Perform an identity translation
        //
        RtlCopyMemory(Target, Source, sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));
        return STATUS_SUCCESS;

    }

    //
    // Do some real translation
    //

    ASSERT(Direction == TranslateChildToParent);

    restype = MfFindResourceType(Source->Type);
    if (restype == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    status = restype->UnpackResource(Source,&sourceStart,&sourceLength);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // runs through raw and translated resource lists, looking for the
    // element of the raw list that corresponds to the source we are
    // given as a parameter, then does the translation using the parallel
    // element of the translated list
    //
    index = 0;
    status = STATUS_INVALID_PARAMETER;
    FOR_ALL_CM_DESCRIPTORS(parent->ResourceList, raw) {

        if (raw->Type == Source->Type
        && MfIsSubResource(raw, sourceStart, sourceLength, &offset)) {

            //
            // This is a match, look up the translated entry in the parallel array
            //
            translated = &parent->TranslatedResourceList->List[0].PartialResourceList.PartialDescriptors[index];

            status = MfPerformTranslation(Source, translated, offset, Target);

            if (NT_SUCCESS(status)) {
                //
                // We did our translation from the translated resources our parent got
                // and these are already
                //
                status = STATUS_TRANSLATION_COMPLETE;
            }
            break;

        } else {
            index++;
        }
    }

    return status;
}

NTSTATUS
MfTransFromRawRequirements(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    )
{

    PAGED_CODE();

    *Target = ExAllocatePool(PagedPool, sizeof(IO_RESOURCE_DESCRIPTOR));
    if (!*Target) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(*Target, Source, sizeof(IO_RESOURCE_DESCRIPTOR));
    *TargetCount = 1;

    return STATUS_TRANSLATION_COMPLETE;
}

NTSTATUS
MfQueryInterfacePdo(
                   IN PIRP Irp,
                   IN PMF_CHILD_EXTENSION Child,
                   IN PIO_STACK_LOCATION IrpStack
                   )
{
    PTRANSLATOR_INTERFACE interface = (PTRANSLATOR_INTERFACE) IrpStack->Parameters.QueryInterface.Interface;
    PAGED_CODE();

   if ((Child->Common.DeviceState & MF_DEVICE_SURPRISE_REMOVED) ||
       (Child->Parent == NULL)) {
       return STATUS_NO_SUCH_DEVICE;
   }

   if (MfCompareGuid(&GUID_TRANSLATOR_INTERFACE_STANDARD,
                     IrpStack->Parameters.QueryInterface.InterfaceType)) {

       interface->Size = sizeof(TRANSLATOR_INTERFACE);
       interface->Version = MF_TRANSLATOR_INTERFACE_VERSION;
       interface->Context = Child->Parent;
       interface->InterfaceReference = MfTranslatorReference;
       interface->InterfaceDereference = MfTranslatorDereference;
       interface->TranslateResources = MfTransFromRawResources;
       interface->TranslateResourceRequirements = MfTransFromRawRequirements;

       Irp->IoStatus.Information = 0;

       // NTRAID#54667
       // Aren't we supposed to reference this before returning it?


       return STATUS_SUCCESS;

   } else if (MfCompareGuid(&GUID_ARBITER_INTERFACE_STANDARD,
                          IrpStack->Parameters.QueryInterface.InterfaceType)) {
       return STATUS_INVALID_PARAMETER_1;
   } else if (MfCompareGuid(&GUID_MF_ENUMERATION_INTERFACE,
                          IrpStack->Parameters.QueryInterface.InterfaceType)) {
       //
       // Otherwise you wouldn't be able to instantiate MF on top of a
       // MF child.
       //
       return Irp->IoStatus.Status;
   } else {

       //
       // Fire these off to the parent
       //
       
       // NOTE: There is the potential that some future interface(s)
       // shouldn't be forwarded to the parent.
       
       return MfForwardIrpToParent(Irp, Child, IrpStack);
   }

}

NTSTATUS
MfQueryCapabilitiesPdo(
    IN PIRP Irp,
    IN PMF_CHILD_EXTENSION Child,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    PDEVICE_CAPABILITIES capabilities;
    IO_STACK_LOCATION location;
    NTSTATUS status;

    PAGED_CODE();

    if ((Child->Common.DeviceState & MF_DEVICE_SURPRISE_REMOVED) || 
        (Child->Parent == NULL)) {
       return STATUS_NO_SUCH_DEVICE;
    }

    ASSERT (Child->Parent);

    if (IrpStack->Parameters.DeviceCapabilities.Capabilities->Version != 1) {
        return STATUS_INVALID_PARAMETER;
    }
    
    capabilities = ExAllocatePool(PagedPool, sizeof(DEVICE_CAPABILITIES));
    if (capabilities == NULL) {
         return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(capabilities, sizeof(DEVICE_CAPABILITIES));
    capabilities->Size = sizeof(DEVICE_CAPABILITIES);
    capabilities->Version = 1;
    capabilities->Address = capabilities->UINumber = -1;

    RtlZeroMemory(&location, sizeof(IO_STACK_LOCATION));
    location.MajorFunction = IRP_MJ_PNP;
    location.MinorFunction = IRP_MN_QUERY_CAPABILITIES;
    location.Parameters.DeviceCapabilities.Capabilities = capabilities;

    status = MfSendPnpIrp(Child->Parent->Self,
                          &location,
                          NULL);
    if (NT_SUCCESS(status)) {
        RtlCopyMemory(IrpStack->Parameters.DeviceCapabilities.Capabilities,
                      location.Parameters.DeviceCapabilities.Capabilities,
                      sizeof(DEVICE_CAPABILITIES)
                      );

        //
        // The child has now inherited the capabilities of the MF
        // parent.  Some of these capabilities must now be filtered
        // out in order to avoid implying functionality that is really
        // limited to the parent's bus driver.
        //

        //
        // Child is not removable, lockable, ejectable or
        // SurpriseRemovalOK. Ensure this
        //
        IrpStack->Parameters.DeviceCapabilities.Capabilities->LockSupported = 
            IrpStack->Parameters.DeviceCapabilities.Capabilities->EjectSupported =
            IrpStack->Parameters.DeviceCapabilities.Capabilities->Removable = 
            IrpStack->Parameters.DeviceCapabilities.Capabilities->SurpriseRemovalOK = FALSE;
    }

    ExFreePool(capabilities);
    return status;
}

NTSTATUS
MfQueryResourcesPdo(
                   IN PIRP Irp,
                   IN PMF_CHILD_EXTENSION Child,
                   IN PIO_STACK_LOCATION IrpStack
                   )
{
   PAGED_CODE();
   //
   // If the parent device had a boot config then it will have
   // reported it (and they will have been preallocated).  Don't
   // bother to report boot configs for the children as they don't
   // gain us anything other than extra arbitration.
   //

   return STATUS_NOT_SUPPORTED;
}


NTSTATUS
MfQueryResourceRequirementsPdo(
                              IN PIRP Irp,
                              IN PMF_CHILD_EXTENSION Child,
                              IN PIO_STACK_LOCATION IrpStack
                              )
{
   NTSTATUS status;
   PIO_RESOURCE_REQUIREMENTS_LIST requirements;

   PAGED_CODE();

   if ((Child->Common.DeviceState & MF_DEVICE_SURPRISE_REMOVED) ||
       (Child->Parent == NULL)) {
       return STATUS_NO_SUCH_DEVICE;
   }

   status = MfBuildChildRequirements(Child, &requirements);

   if (NT_SUCCESS(status)) {
#if DBG
      DEBUG_MSG(1, ("Reporting resource requirements for child 0x%08x\n", Child));
      MfDbgPrintIoResReqList(1, requirements);
#endif
      Irp->IoStatus.Information = (ULONG_PTR) requirements;
   }

   return status;

}


NTSTATUS
MfQueryDeviceTextPdo(
                    IN PIRP Irp,
                    IN PMF_CHILD_EXTENSION Child,
                    IN PIO_STACK_LOCATION IrpStack
                    )
{
   NTSTATUS status;

   PAGED_CODE();

   if (IrpStack->Parameters.QueryDeviceText.DeviceTextType == DeviceTextDescription) {
#define MF_DEFAULT_DEVICE_TEXT L"Multifunction Device"
       ULONG len = sizeof(MF_DEFAULT_DEVICE_TEXT);
       PWSTR pStr;

       pStr = ExAllocatePool(PagedPool, len);
      
       if (!pStr) {
           status = STATUS_INSUFFICIENT_RESOURCES;
       } else {
           RtlCopyMemory(pStr, MF_DEFAULT_DEVICE_TEXT, len);
           Irp->IoStatus.Information = (ULONG_PTR) pStr;
           status = STATUS_SUCCESS;
       }
   } else {
       status = Irp->IoStatus.Status;
   }

   return status;
}

NTSTATUS
MfQueryIdPdo(
            IN PIRP Irp,
            IN PMF_CHILD_EXTENSION Child,
            IN PIO_STACK_LOCATION IrpStack
            )
{

   NTSTATUS status = STATUS_SUCCESS;
   PUNICODE_STRING copy;
   PVOID buffer = NULL;

   PAGED_CODE();

   if ((Child->Common.DeviceState & MF_DEVICE_SURPRISE_REMOVED) ||
       (Child->Parent == NULL)) {
       return STATUS_NO_SUCH_DEVICE;
   }

   switch (IrpStack->Parameters.QueryId.IdType) {
   case BusQueryDeviceID:       // <Enumerator>\<Enumerator-specific device id>

       return MfBuildDeviceID(Child->Parent,
                              (PWSTR*)&Irp->IoStatus.Information
                              );
       break;


   case BusQueryInstanceID:     // persistent id for this instance of the device

       return MfBuildInstanceID(Child,
                                (PWSTR*)&Irp->IoStatus.Information
                                );

       break;

   case BusQueryHardwareIDs:    // Hardware ids

       copy = &Child->Info.HardwareID;

       break;

   case BusQueryCompatibleIDs:  // compatible device ids

       copy = &Child->Info.CompatibleID;

       break;

   default:

       return Irp->IoStatus.Status;
   }

   ASSERT(copy);

   //
   // If we have an ID to copy
   //

   if (copy->Length > 0) {

      //
      // Allocate the buffer for the ID and copy it
      //

      buffer = ExAllocatePoolWithTag(PagedPool,
                                     copy->Length,
                                     MF_HARDWARE_COMPATIBLE_ID_TAG
                                    );

      if (!buffer) {
          return STATUS_INSUFFICIENT_RESOURCES;
      }

      RtlCopyMemory(buffer, copy->Buffer, copy->Length);
   }

   Irp->IoStatus.Information = (ULONG_PTR) buffer;

   return STATUS_SUCCESS;
}



NTSTATUS
MfQueryPnpDeviceStatePdo(
                        IN PIRP Irp,
                        IN PMF_CHILD_EXTENSION Child,
                        IN PIO_STACK_LOCATION IrpStack
                        )
{
    PAGED_CODE();

    if (Child->Common.PagingCount > 0
        ||  Child->Common.HibernationCount > 0
        ||  Child->Common.DumpCount > 0) {
        Irp->IoStatus.Information |= PNP_DEVICE_NOT_DISABLEABLE;
    }

    return STATUS_SUCCESS;
}

//
// --- Power operations ---
//

NTSTATUS
MfDispatchPowerPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PMF_CHILD_EXTENSION Child,
    IN PIO_STACK_LOCATION IrpStack,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles all IRP_MJ_POWER IRPs for PDO.  It dispatches
    to the routines described in the PoDispatchTable entry in the
    device object extension.

    This routine is NOT pageable as it can be called at DISPATCH_LEVEL

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Child - PDO extension
    
    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

    IrpStack

Return Value:

    NT status.

--*/
{
    NTSTATUS status;
    PMF_COMMON_EXTENSION common = (PMF_COMMON_EXTENSION) Child;


    if ((Child->Common.DeviceState & (MF_DEVICE_SURPRISE_REMOVED|MF_DEVICE_DELETED)) ||
        (Child->Parent == NULL)) {
        PoStartNextPowerIrp(Irp);
        status = STATUS_NO_SUCH_DEVICE;
    } else if ((IrpStack->MinorFunction <= IRP_MN_PO_MAXIMUM_FUNCTION) &&
               (MfPoDispatchTablePdo[IrpStack->MinorFunction])) {

        //
        // We are interested in this irp...
        //

        DEBUG_MSG(1,
                    ("--> Dispatching %s IRP for PDO 0x%08x\n",
                     PO_IRP_STRING(IrpStack->MinorFunction),
                     DeviceObject
                    ));

        status =
            MfPoDispatchTablePdo[IrpStack->MinorFunction](Irp,
                                                          (PVOID) common,
                                                          IrpStack
                                                          );
    } else {

        //
        // We don't know about this irp
        //

        DEBUG_MSG(0,
                    ("Unknown POWER IRP 0x%x for PDO 0x%08x\n",
                     IrpStack->MinorFunction,
                     DeviceObject
                    ));

        PoStartNextPowerIrp(Irp);
        status = STATUS_NOT_SUPPORTED;
    }

    if (status != STATUS_NOT_SUPPORTED) {

        //
        // We understood the irp so we can set status - otherwise leave
        // the status alone as we don't know what we are doing and a filter
        // might have done the job for us!
        //

        Irp->IoStatus.Status = status;

        DEBUG_MSG(1,
                  ("<-- Completing irp with status %s (0x%08x)\n",
                   STATUS_STRING(status),
                   status
                   ));

    } else {

        DEBUG_MSG(1,
                  ("<-- Completing unhandled irp, status is %s (0x%08x)\n",
                   STATUS_STRING(Irp->IoStatus.Status),
                   Irp->IoStatus.Status
                   ));

        status = Irp->IoStatus.Status;

    }

    ASSERT(status == Irp->IoStatus.Status);
    
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
MfSetPowerPdo(
             IN PIRP Irp,
             IN PMF_CHILD_EXTENSION Child,
             IN PIO_STACK_LOCATION IrpStack
             )
{

   NTSTATUS status;
   POWER_STATE previousState;

   UNREFERENCED_PARAMETER(Irp);

   //
   // If this is a system power state then someone else in the stack will have
   // set the policy and we just leave well alone as we don't know anything
   // about the hardware.
   //

   if (IrpStack->Parameters.Power.Type == DevicePowerState) {
       MfUpdatePowerPdo(Child,
                        IrpStack->Parameters.Power.State.DeviceState);
   }

   PoStartNextPowerIrp(Irp);
   return STATUS_SUCCESS;
}

NTSTATUS
MfQueryPowerPdo(
               IN PIRP Irp,
               IN PMF_CHILD_EXTENSION Child,
               IN PIO_STACK_LOCATION IrpStack
               )
{

   UNREFERENCED_PARAMETER(Irp);
   UNREFERENCED_PARAMETER(Child);
   UNREFERENCED_PARAMETER(IrpStack);

   //
   // We can go to any power state...
   //

   PoStartNextPowerIrp(Irp);
   return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\mf\fdo.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    fdo.c

Abstract:

    This module provides the functions which answer IRPs to functional devices.

Author:

    Andy Thornton (andrewth) 20-Oct-97

Revision History:

--*/

#include "mfp.h"

/*++

The majority of functions in this file are called based on their presence
in Pnp and Po dispatch tables.  In the interests of brevity the arguments
to all those functions will be described below:

NTSTATUS
MfXxxFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    )

Routine Description:

    This function handles the Xxx requests for multifunction FDO's

Arguments:

    Irp - Points to the IRP associated with this request.

    Parent - Points to the parent FDO's device extension.

    IrpStack - Points to the current stack location for this request.

Return Value:

    Status code that indicates whether or not the function was successful.

    STATUS_NOT_SUPPORTED indicates that the IRP should be passed down without
    changing the Irp->IoStatus.Status field otherwise it is updated with this
    status.

--*/


NTSTATUS
MfDeferProcessingFdo(
    IN PMF_PARENT_EXTENSION Parent,
    IN OUT PIRP Irp
    );

NTSTATUS
MfStartFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
MfStartFdoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
MfStartFdoInitializeArbiters(
    IN PMF_PARENT_EXTENSION Parent,
    IN PCM_RESOURCE_LIST ResList,
    IN PCM_RESOURCE_LIST TranslatedResList
    );

NTSTATUS
MfQueryStopFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
MfCancelStopFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
MfQueryRemoveFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
MfRemoveFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
MfSurpriseRemoveFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
MfCancelRemoveFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
MfQueryDeviceRelationsFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
MfQueryInterfaceFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
MfQueryCapabilitiesFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
MfQueryPowerFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
MfSetPowerFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
MfPassIrp(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    );

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, MfCancelRemoveFdo)
#pragma alloc_text(PAGE, MfCancelStopFdo)
#pragma alloc_text(PAGE, MfCreateFdo)
#pragma alloc_text(PAGE, MfDeferProcessingFdo)
#pragma alloc_text(PAGE, MfDispatchPnpFdo)
#pragma alloc_text(PAGE, MfPassIrp)
#pragma alloc_text(PAGE, MfQueryCapabilitiesFdo)
#pragma alloc_text(PAGE, MfQueryDeviceRelationsFdo)
#pragma alloc_text(PAGE, MfQueryInterfaceFdo)
#pragma alloc_text(PAGE, MfQueryRemoveFdo)
#pragma alloc_text(PAGE, MfQueryStopFdo)
#pragma alloc_text(PAGE, MfRemoveFdo)
#pragma alloc_text(PAGE, MfStartFdo)
#pragma alloc_text(PAGE, MfStartFdoInitializeArbiters)
#pragma alloc_text(PAGE, MfSurpriseRemoveFdo)
#endif


PMF_DISPATCH MfPnpDispatchTableFdo[] = {

    MfStartFdo,                     // IRP_MN_START_DEVICE
    MfQueryRemoveFdo,               // IRP_MN_QUERY_REMOVE_DEVICE
    MfRemoveFdo,                    // IRP_MN_REMOVE_DEVICE
    MfCancelRemoveFdo,              // IRP_MN_CANCEL_REMOVE_DEVICE
    MfPassIrp,                      // IRP_MN_STOP_DEVICE
    MfQueryStopFdo,                 // IRP_MN_QUERY_STOP_DEVICE
    MfCancelStopFdo,                // IRP_MN_CANCEL_STOP_DEVICE
    MfQueryDeviceRelationsFdo,      // IRP_MN_QUERY_DEVICE_RELATIONS
    MfQueryInterfaceFdo,            // IRP_MN_QUERY_INTERFACE
    MfQueryCapabilitiesFdo,         // IRP_MN_QUERY_CAPABILITIES
    MfPassIrp,                      // IRP_MN_QUERY_RESOURCES
    MfPassIrp,                      // IRP_MN_QUERY_RESOURCE_REQUIREMENTS
    MfPassIrp,                      // IRP_MN_QUERY_DEVICE_TEXT
    MfPassIrp,                      // IRP_MN_FILTER_RESOURCE_REQUIREMENTS
    MfPassIrp,                      // Unused
    MfPassIrp,                      // IRP_MN_READ_CONFIG
    MfPassIrp,                      // IRP_MN_WRITE_CONFIG
    MfPassIrp,                      // IRP_MN_EJECT
    MfPassIrp,                      // IRP_MN_SET_LOCK
    MfPassIrp,                      // IRP_MN_QUERY_ID
    MfPassIrp,                      // IRP_MN_QUERY_PNP_DEVICE_STATE
    MfPassIrp,                      // IRP_MN_QUERY_BUS_INFORMATION
    MfDeviceUsageNotificationCommon,// IRP_MN_DEVICE_USAGE_NOTIFICATION
    MfSurpriseRemoveFdo,            // IRP_MN_SURPRISE_REMOVAL
    MfPassIrp                       // IRP_MN_QUERY_LEGACY_BUS_INFORMATION
};

PMF_DISPATCH MfPoDispatchTableFdo[] = {

    NULL,                           // IRP_MN_WAIT_WAKE
    NULL,                           // IRP_MN_POWER_SEQUENCE
    MfSetPowerFdo,                  // IRP_MN_SET_POWER
    MfQueryPowerFdo                 // IRP_MN_QUERY_POWER

};


NTSTATUS
MfCreateFdo(
    OUT PDEVICE_OBJECT *Fdo
    )
/*++

Routine Description:

    This function creates a new FDO and initializes it.

Arguments:

    Fdo - Pointer to where the FDO should be returned

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{

    NTSTATUS status;
    PMF_PARENT_EXTENSION extension;

    PAGED_CODE();

    ASSERT((sizeof(MfPnpDispatchTableFdo) / sizeof(PMF_DISPATCH)) - 1
           == IRP_MN_PNP_MAXIMUM_FUNCTION);

    ASSERT((sizeof(MfPoDispatchTableFdo) / sizeof(PMF_DISPATCH)) -1
       == IRP_MN_PO_MAXIMUM_FUNCTION);

    *Fdo = NULL;

    status = IoCreateDevice(MfDriverObject,
                            sizeof(MF_PARENT_EXTENSION),
                            NULL,
                            FILE_DEVICE_BUS_EXTENDER,
                            0,
                            FALSE,
                            Fdo
                           );

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    //
    // Initialize the extension
    //

    extension = (PMF_PARENT_EXTENSION) (*Fdo)->DeviceExtension;

    MfInitCommonExtension(&extension->Common, MfFunctionalDeviceObject);
    extension->Self = *Fdo;

    InitializeListHead(&extension->Arbiters);

    InitializeListHead(&extension->Children);
    KeInitializeEvent(&extension->ChildrenLock, SynchronizationEvent, TRUE);

    KeInitializeSpinLock(&extension->PowerLock);

    IoInitializeRemoveLock(&extension->RemoveLock, MF_POOL_TAG, 1, 20);

    extension->Common.PowerState = PowerDeviceD3;

    DEBUG_MSG(1, ("Created FDO @ 0x%08x\n", *Fdo));

    return status;

cleanup:

    if (*Fdo) {
        IoDeleteDevice(*Fdo);
    }

    return status;

}

VOID
MfAcquireChildrenLock(
    IN PMF_PARENT_EXTENSION Parent
    )
{
    KeWaitForSingleObject(&Parent->ChildrenLock,
                         Executive,
                         KernelMode,
                         FALSE,
                         NULL);
}

VOID
MfReleaseChildrenLock(
    IN PMF_PARENT_EXTENSION Parent
    )
{
    KeSetEvent(&Parent->ChildrenLock, 0, FALSE);
}

VOID
MfDeleteFdo(
    IN PDEVICE_OBJECT Fdo
    )
{
    PMF_PARENT_EXTENSION parent = Fdo->DeviceExtension;
    PMF_ARBITER current, next;

    if (parent->Common.DeviceState & MF_DEVICE_DELETED) {
        //
        // Trying to delete twice
        //
        ASSERT(!(parent->Common.DeviceState & MF_DEVICE_DELETED));
        return;
    }

    parent->Common.DeviceState = MF_DEVICE_DELETED;

    //
    // Free up any memory we have allocated
    //

    if (parent->ResourceList) {
        ExFreePool(parent->ResourceList);
    }

    if (parent->TranslatedResourceList) {
        ExFreePool(parent->TranslatedResourceList);
    }

    if (parent->DeviceID.Buffer) {
        ExFreePool(parent->DeviceID.Buffer);
    }

    if (parent->InstanceID.Buffer) {
        ExFreePool(parent->InstanceID.Buffer);
    }

    FOR_ALL_IN_LIST_SAFE(MF_ARBITER, &parent->Arbiters, current, next) {
        ArbDeleteArbiterInstance(&current->Instance);
        ExFreePool(current);
    }

    ASSERT(IsListEmpty(&parent->Children));

    IoDeleteDevice(Fdo);

    DEBUG_MSG(1, ("Deleted FDO @ 0x%08x\n", Fdo));

}

NTSTATUS
MfPassIrp(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    PAGED_CODE();

    IoSkipCurrentIrpStackLocation(Irp);

    return IoCallDriver(Parent->AttachedDevice, Irp);
}

NTSTATUS
MfDispatchPnpFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles IRP_MJ_PNP IRPs for FDOs.

Arguments:

    DeviceObject - Pointer to the FDO for which this IRP applies.

    Parent - FDO extension

    IrpStack - Current stack location

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/

{
    NTSTATUS status;
    BOOLEAN isRemoveDevice;

    PAGED_CODE();

    //
    // Get a pointer to our stack location and take appropriate action based
    // on the minor function.
    //

    IoAcquireRemoveLock(&Parent->RemoveLock, (PVOID) Irp);

    isRemoveDevice = IrpStack->MinorFunction == IRP_MN_REMOVE_DEVICE;

    if (IrpStack->MinorFunction > IRP_MN_PNP_MAXIMUM_FUNCTION) {

        status = MfPassIrp(Irp, Parent, IrpStack);

    } else {

        status =
            MfPnpDispatchTableFdo[IrpStack->MinorFunction](Irp,
                                                          Parent,
                                                          IrpStack
                                                          );
    }

    if (!isRemoveDevice) {
        IoReleaseRemoveLock(&Parent->RemoveLock, (PVOID) Irp);
    }

    return status;
}

NTSTATUS
MfPnPFdoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is used to defer processing of an IRP until drivers
    lower in the stack including the bus driver have done their
    processing.

    This routine triggers the event to indicate that processing of the
    irp can now continue.

Arguments:

    DeviceObject - Pointer to the FDO for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/

{
    KeSetEvent((PKEVENT) Context, EVENT_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
MfDeferProcessingFdo(
    IN PMF_PARENT_EXTENSION Parent,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    This routine is used to defer processing of an IRP until drivers
    lower in the stack including the bus driver have done their
    processing.

    This routine uses an IoCompletion routine along with an event to
    wait until the lower level drivers have completed processing of
    the irp.

Arguments:

    Parent - FDO extension for the FDO devobj in question

    Irp - Pointer to the IRP_MJ_PNP IRP to defer

Return Value:

    NT status.

--*/
{
    KEVENT event;
    NTSTATUS status;

    PAGED_CODE();

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // Set our completion routine
    //

    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp,
                           MfPnPFdoCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE
                           );
    status =  IoCallDriver(Parent->AttachedDevice, Irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = Irp->IoStatus.Status;
    }

    return status;
}

NTSTATUS
MfStartFdoInitializeArbiters(
    IN PMF_PARENT_EXTENSION Parent,
    IN PCM_RESOURCE_LIST ResList,
    IN PCM_RESOURCE_LIST TranslatedResList
    )
{

    NTSTATUS status;
    ULONG size;
    ULONG count;

    PAGED_CODE();

    DEBUG_MSG(1, ("Start Fdo arbiters intiialization\n"));

    //
    // If we were started with any resources then remember them
    //

    if (ResList && TranslatedResList) {

#if DBG
        MfDbgPrintCmResList(1, ResList);
#endif

        //
        // We only deal with resources on a single bus - which is all we
        // should see in a start irp.
        //

        ASSERT(ResList->Count == 1);
        ASSERT(TranslatedResList->Count == 1);

        //
        // Both lists should have the same number of descriptors
        //

        ASSERT(ResList->List[0].PartialResourceList.Count == TranslatedResList->List[0].PartialResourceList.Count);

        //
        // Calculate the size of the resouceList
        //

        size = sizeof(CM_RESOURCE_LIST) +
               ((ResList->List[0].PartialResourceList.Count - 1) *
                sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));

        //
        // Allocate a buffer and copy the data
        //

        Parent->ResourceList = ExAllocatePoolWithTag(NonPagedPool,
                                                     size,
                                                     MF_PARENTS_RESOURCE_TAG
                                                     );

        if (!Parent->ResourceList) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }

        RtlCopyMemory(Parent->ResourceList, ResList, size);

        //
        // do the same for the TranslatedResList.
        //

        Parent->TranslatedResourceList = ExAllocatePoolWithTag(NonPagedPool,
                                                               size,
                                                               MF_PARENTS_RESOURCE_TAG
                                                               );

        if (!Parent->TranslatedResourceList) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }

        RtlCopyMemory(Parent->TranslatedResourceList, TranslatedResList, size);

        //
        // As we have resources we are going to need some arbiters
        //

        status = MfInitializeArbiters(Parent);
        if (!NT_SUCCESS(status)) {
            goto cleanup;
        }

    } else {

        DEBUG_MSG(1, ("Parent started with no resources\n"));
    }

    return STATUS_SUCCESS;

cleanup:

    if (Parent->ResourceList) {
        ExFreePool(Parent->ResourceList);
        Parent->ResourceList = NULL;
    }

    if (Parent->TranslatedResourceList) {
        ExFreePool(Parent->TranslatedResourceList);
        Parent->TranslatedResourceList = NULL;
    }

    return status;
}

// REBALANCE
//
// FUTURE DESIGN NOTE:
// If rebalance was actually supported by this component i.e arbiters
// become stoppable, then there are various issues raised by the start
// code.  It performs a number of operations assuming that the device
// has never been started before including the query ids, resource
// list storage, etc.  There are also issues in redistributing these
// new resources to the children.  The current requirements given to
// the children are absolute.  Relative requirements have some other
// issues.
//

NTSTATUS
MfStartFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    NTSTATUS status;
    IO_STACK_LOCATION location;
    PWSTR string;

    PAGED_CODE();

    status = MfDeferProcessingFdo(Parent, Irp);
    if (!NT_SUCCESS(status)) {
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    Parent->Common.PowerState = PowerDeviceD0;

    //
    // We need to find out some information about our parent
    //

    Parent->DeviceID.Buffer = NULL;
    Parent->InstanceID.Buffer = NULL;

    RtlZeroMemory(&location, sizeof(IO_STACK_LOCATION));
    location.MajorFunction = IRP_MJ_PNP;
    location.MinorFunction = IRP_MN_QUERY_ID;

    //
    // ...DeviceID...
    //

    location.Parameters.QueryId.IdType = BusQueryDeviceID;

    status = MfSendPnpIrp(Parent->PhysicalDeviceObject,
                          &location,
                          (PULONG_PTR)&string
                          );

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    RtlInitUnicodeString(&Parent->DeviceID, string);

    DEBUG_MSG(1, ("Parent DeviceID: %wZ\n", &Parent->DeviceID));

    //
    // ...InstanceID
    //

    location.Parameters.QueryId.IdType = BusQueryInstanceID;

    status = MfSendPnpIrp(Parent->PhysicalDeviceObject,
                          &location,
                          (PULONG_PTR)&string
                          );

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    RtlInitUnicodeString(&Parent->InstanceID, string);

    DEBUG_MSG(1, ("Parent InstanceID: %wZ\n", &Parent->InstanceID));

    status = MfStartFdoInitializeArbiters(
                 Parent,
                 IrpStack->Parameters.StartDevice.AllocatedResources,
                 IrpStack->Parameters.StartDevice.AllocatedResourcesTranslated
                 );

cleanup:

    Irp->IoStatus.Status = status;
    if (!NT_SUCCESS(status)) {
        if (Parent->DeviceID.Buffer) {
            ExFreePool(Parent->DeviceID.Buffer);
            Parent->DeviceID.Buffer = NULL;
        }

        if (Parent->InstanceID.Buffer) {
            ExFreePool(Parent->InstanceID.Buffer);
            Parent->InstanceID.Buffer = NULL;
        }
    } else {
        //
        // We are now started!
        //
    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

NTSTATUS
MfQueryStopFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    )
{

    PAGED_CODE();

    Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
MfCancelStopFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    NTSTATUS status;

    PAGED_CODE();

    status = MfDeferProcessingFdo(Parent, Irp);
    // NTRAID#53498
    // ASSERT(status == STATUS_SUCCESS);
    // Uncomment after PCI state machine is fixed to not fail bogus stops

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

NTSTATUS
MfQueryRemoveFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    PAGED_CODE();

    Irp->IoStatus.Status = STATUS_SUCCESS;
    return MfPassIrp(Irp, Parent, IrpStack);
}

NTSTATUS
MfRemoveFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    PMF_CHILD_EXTENSION current;
    PLIST_ENTRY currentEntry;
    NTSTATUS status;

    //
    // If we have any children then make sure they are removed and
    // delete them.
    //

    MfAcquireChildrenLock(Parent);

    while (!IsListEmpty(&Parent->Children)) {

        currentEntry = RemoveHeadList(&Parent->Children);
        ASSERT(currentEntry);

        current = CONTAINING_RECORD(currentEntry, MF_CHILD_EXTENSION,
                                    ListEntry);

        //
        // * If this child has been surprise removed, and hasn't
        // received the subsequent remove, then leave
        // the PDO intact but mark it 'missing'.
        //
        // * If this child has handled a previous remove (this is
        // fundamentally the case if we've gotten to the point of
        // removing the parent) and hasn't subsequently received a
        // surprise remove, then delete the pdo.
        //

        if (current->Common.DeviceState & MF_DEVICE_SURPRISE_REMOVED) {
            //
            // Mark as 'missing' and unlink dangerous reference to parent
            //

            current->Parent = NULL;
            current->Common.DeviceState &= ~MF_DEVICE_ENUMERATED;
        } else {
            MfDeletePdo(current);
        }
    }

    MfReleaseChildrenLock(Parent);

    Parent->Common.PowerState = PowerDeviceD3;

    Irp->IoStatus.Status = STATUS_SUCCESS;
    status = MfPassIrp(Irp, Parent, IrpStack);
    ASSERT(NT_SUCCESS(status));

    IoReleaseRemoveLockAndWait(&Parent->RemoveLock, (PVOID) Irp);

    //
    // Detach and delete myself
    //

    IoDetachDevice(Parent->AttachedDevice);
    Parent->AttachedDevice = NULL;

    MfDeleteFdo(Parent->Self);

    return status;
}

NTSTATUS
MfSurpriseRemoveFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    PLIST_ENTRY currentEntry;
    PMF_CHILD_EXTENSION current;

    PAGED_CODE();

    Parent->Common.DeviceState |= MF_DEVICE_SURPRISE_REMOVED;

    MfAcquireChildrenLock(Parent);

    for (currentEntry = Parent->Children.Flink;
         currentEntry != &Parent->Children;
         currentEntry = currentEntry->Flink) {

        current = CONTAINING_RECORD(currentEntry,
                                    MF_CHILD_EXTENSION,
                                    ListEntry);
        current->Common.DeviceState &= ~MF_DEVICE_ENUMERATED;
    }

    MfReleaseChildrenLock(Parent);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    return MfPassIrp(Irp, Parent, IrpStack);
}

NTSTATUS
MfCancelRemoveFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    NTSTATUS status;

    PAGED_CODE();

    status = MfDeferProcessingFdo(Parent, Irp);
    // NTRAID#53498
    // ASSERT(status == STATUS_SUCCESS);
    // Uncomment after PCI state machine is fixed to not fail bogus stops
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}


NTSTATUS
MfQueryDeviceRelationsFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    )
{

    NTSTATUS status;
    PDEVICE_RELATIONS relations = NULL;
    ULONG relationsSize, childrenCount, i;
    PDEVICE_OBJECT *currentRelation;
    PMF_CHILD_EXTENSION currentChild;
    PLIST_ENTRY currentEntry;

    PAGED_CODE();

    DEBUG_MSG(1,
              ("%s\n",
               RELATION_STRING(IrpStack->Parameters.QueryDeviceRelations.Type)
              ));

    switch (IrpStack->Parameters.QueryDeviceRelations.Type) {

    case BusRelations:

        MfAcquireChildrenLock(Parent);

        status = MfEnumerate(Parent);

        if (!NT_SUCCESS(status)) {
            MfReleaseChildrenLock(Parent);
            Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return STATUS_UNSUCCESSFUL;
        }

        childrenCount = 0;
        for (currentEntry = Parent->Children.Flink;
             currentEntry != &Parent->Children;
             currentEntry = currentEntry->Flink) {

            childrenCount++;
        }

        if (childrenCount == 0) {
            relationsSize = sizeof(DEVICE_RELATIONS);
        } else {
            relationsSize = sizeof(DEVICE_RELATIONS) +
                (childrenCount-1) * sizeof(PDEVICE_OBJECT);
        }

        relations = ExAllocatePoolWithTag(PagedPool,
                                          relationsSize,
                                          MF_BUS_RELATIONS_TAG
                                          );

        if (!relations) {
            MfReleaseChildrenLock(Parent);
            Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(relations, relationsSize);

        //
        // Iterate through the list of children in the parent and build the
        // relations structure
        //

        currentRelation = relations->Objects;
        relations->Count = childrenCount;

        for (currentEntry = Parent->Children.Flink;
             currentEntry != &Parent->Children;
             currentEntry = currentEntry->Flink) {

            currentChild = CONTAINING_RECORD(currentEntry,
                                             MF_CHILD_EXTENSION,
                                             ListEntry);

            currentChild->Common.DeviceState |= MF_DEVICE_ENUMERATED;
            ObReferenceObject(currentChild->Self);
            *currentRelation = currentChild->Self;
#if DBG
            DEBUG_MSG(1, ("\tPDO Enumerated @ 0x%08x\n", currentChild));
            DEBUG_MSG(1, ("\tName: %wZ\n", &currentChild->Info.Name));
            DEBUG_MSG(1, ("\tHardwareID: "));
            MfDbgPrintMultiSz(1, currentChild->Info.HardwareID.Buffer);

            DEBUG_MSG(1, ("\tCompatibleID: "));
            MfDbgPrintMultiSz(1, currentChild->Info.CompatibleID.Buffer);

            DEBUG_MSG(1, ("\tResourceMap: "));
            MfDbgPrintResourceMap(1, currentChild->Info.ResourceMap);

            DEBUG_MSG(1, ("\tVaryingMap: "));
            MfDbgPrintVaryingResourceMap(1, currentChild->Info.VaryingResourceMap);
            DEBUG_MSG(1, ("\tFlags: 0x%08x\n", currentChild->Info.MfFlags));

#endif
            currentRelation++;
        }

        MfReleaseChildrenLock(Parent);

        //
        // Hand back the relations
        //

        Irp->IoStatus.Information = (ULONG_PTR) relations;
        Irp->IoStatus.Status = STATUS_SUCCESS;
        break;

    //
    // For the rest of the relations just pass down the irp untouched.
    //

    default:
        break;
    }

    return MfPassIrp(Irp, Parent, IrpStack);
}

VOID
MfArbiterReference(
    PVOID Context
    )
{
}

VOID
MfArbiterDereference(
    PVOID Context
    )
{
}


NTSTATUS
MfQueryInterfaceFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    PMF_ARBITER current;
    PARBITER_INTERFACE interface = (PARBITER_INTERFACE) IrpStack->Parameters.QueryInterface.Interface;

    PAGED_CODE();

    //
    // We only provide arbiters
    //

    if (MfCompareGuid(&GUID_ARBITER_INTERFACE_STANDARD,
                      IrpStack->Parameters.QueryInterface.InterfaceType)) {

        //
        // We only support version 1 of the ARBITER_INTERFACE so we
        // don't need to bother checking version numbers, just that the
        // return buffer is big enough
        //

        if (IrpStack->Parameters.QueryInterface.Size < sizeof(ARBITER_INTERFACE)) {
            Irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return STATUS_BUFFER_TOO_SMALL;
        }

        FOR_ALL_IN_LIST(MF_ARBITER, &Parent->Arbiters, current) {

            if (current->Type == (CM_RESOURCE_TYPE)((ULONG_PTR)
                    IrpStack->Parameters.QueryInterface.InterfaceSpecificData)) {

                DEBUG_MSG(1,("    Returning Arbiter interface\n"));

                //
                // Fill in the interface
                //

                interface->Size = sizeof(ARBITER_INTERFACE);
                interface->Version = MF_ARBITER_INTERFACE_VERSION;
                interface->Context = &current->Instance;
                interface->InterfaceReference = MfArbiterReference;
                interface->InterfaceDereference = MfArbiterDereference;
                interface->ArbiterHandler = ArbArbiterHandler;
                interface->Flags = 0;

                Irp->IoStatus.Status = STATUS_SUCCESS;
                break;

            }
        }
    }

    return MfPassIrp(Irp, Parent, IrpStack);
}

NTSTATUS
MfQueryCapabilitiesFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    NTSTATUS status;

    PAGED_CODE();

    status = MfDeferProcessingFdo(Parent, Irp);
    if (!NT_SUCCESS(status)) {
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    if (IrpStack->Parameters.DeviceCapabilities.Capabilities->Version != 1) {
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_INVALID_PARAMETER;
    }

    IrpStack->Parameters.DeviceCapabilities.Capabilities->WakeFromD0 =
        IrpStack->Parameters.DeviceCapabilities.Capabilities->WakeFromD1 =
        IrpStack->Parameters.DeviceCapabilities.Capabilities->WakeFromD2 =
        IrpStack->Parameters.DeviceCapabilities.Capabilities->WakeFromD3 = 0;

    IrpStack->Parameters.DeviceCapabilities.Capabilities->DeviceWake =
        PowerSystemUnspecified;
    IrpStack->Parameters.DeviceCapabilities.Capabilities->SystemWake =
        PowerSystemUnspecified;
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

NTSTATUS
MfDispatchPowerFdo(
    IN PDEVICE_OBJECT DeviceObject,
    PMF_PARENT_EXTENSION Parent,
    PIO_STACK_LOCATION IrpStack,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles all IRP_MJ_POWER IRPs for the FDO.  It dispatches
    to the routines described in the PoDispatchTable entry in the device object
    extension.

    This routine is NOT pageable as it can be called at DISPATCH_LEVEL

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Parent - FDO Extension

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/


{
    NTSTATUS status;
    PMF_COMMON_EXTENSION common = (PMF_COMMON_EXTENSION) Parent;

    IoAcquireRemoveLock(&Parent->RemoveLock, (PVOID) Irp);

    //
    // Call the appropriate function
    //

    if ((IrpStack->MinorFunction <= IRP_MN_PO_MAXIMUM_FUNCTION) &&
        (MfPoDispatchTableFdo[IrpStack->MinorFunction])) {

        status =
            MfPoDispatchTableFdo[IrpStack->MinorFunction](Irp,
                                                          (PVOID) common,
                                                          IrpStack
                                                          );

    } else {
        //
        // We don't know about this irp
        //

        DEBUG_MSG(0,
                  ("Unknown POWER IRP 0x%x for FDO 0x%08x\n",
                   IrpStack->MinorFunction,
                   DeviceObject
                   ));

        PoStartNextPowerIrp(Irp);
        IoSkipCurrentIrpStackLocation(Irp);
        status = PoCallDriver(Parent->AttachedDevice, Irp);
    }

    IoReleaseRemoveLock(&Parent->RemoveLock, (PVOID) Irp);

    return status;
}

NTSTATUS
MfQueryPowerFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);

    Irp->IoStatus.Status = STATUS_SUCCESS;

    return PoCallDriver(Parent->AttachedDevice, Irp);
}

NTSTATUS
MfSetPowerFdoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PMF_PARENT_EXTENSION parent = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Remember the parent's power state
    //

    if (irpStack->Parameters.Power.Type == DevicePowerState) {
        parent->Common.PowerState =
            irpStack->Parameters.Power.State.DeviceState;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
MfSetPowerFdo(
    IN PIRP Irp,
    IN PMF_PARENT_EXTENSION Parent,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    PoStartNextPowerIrp(Irp);
    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp,
                           MfSetPowerFdoCompletion,
                           NULL,   //Context
                           TRUE,   //InvokeOnSuccess
                           FALSE,  //InvokeOnError
                           FALSE   //InvokeOnCancel
                           );
    Irp->IoStatus.Status = STATUS_SUCCESS;
    return PoCallDriver(Parent->AttachedDevice, Irp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\mf\init.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    init.c

Abstract:

    This module provides the initialization and unload functions.

Author:

    Andy Thornton (andrewth) 20-Oct-97

Revision History:

--*/

#include "mfp.h"

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
MfUnload(
    IN PDRIVER_OBJECT DriverObject
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, MfUnload)
#endif

PDRIVER_OBJECT MfDriverObject;

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:
    
    This is the entry point to MF.SYS and performs initialization.
    
Arguments:

    DriverObject - The system owned driver object for MF
    
    RegistryPath - The path to MF's service entry
    
Return Value:

    STATUS_SUCCESS

--*/
{

    DriverObject->DriverExtension->AddDevice = MfAddDevice;
    DriverObject->MajorFunction[IRP_MJ_PNP] = MfDispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER] = MfDispatchPower;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = MfDispatchNop;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = MfDispatchNop;
    DriverObject->DriverUnload = MfUnload;

    //
    // Remember the driver object
    //

    MfDriverObject = DriverObject;

    DEBUG_MSG(1, ("Completed DriverEntry for Driver 0x%08x\n", DriverObject));
    
    return STATUS_SUCCESS;
}

VOID
MfUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:
    
    This is called to reverse any operations performed in DriverEntry before a
    driver is unloaded.
        
Arguments:

    DriverObject - The system owned driver object for MF
    
Return Value:

    STATUS_SUCCESS

--*/
{
    PAGED_CODE();
    
    DEBUG_MSG(1, ("Completed Unload for Driver 0x%08x\n", DriverObject));
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\mf\resource.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    arbiter.c

Abstract:

    This module provides arbiters for the resources consumed by PDOs.

Author:

    Andy Thornton (andrewth) 20-Oct-97

Revision History:

--*/


#include "mfp.h"

NTSTATUS
MfUnpackRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Minimum,
    OUT PULONGLONG Maximum,
    OUT PULONG Length,
    OUT PULONG Alignment
    );

NTSTATUS
MfPackResource(
    IN PIO_RESOURCE_DESCRIPTOR Requirement,
    IN ULONGLONG Start,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    );

NTSTATUS
MfUnpackResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Start,
    OUT PULONG Length
    );

NTSTATUS
MfRequirementFromResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Resource,
    OUT PIO_RESOURCE_DESCRIPTOR Requirement
    );

NTSTATUS
MfUpdateResource(
    IN OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Resource,
    IN ULONGLONG Start,
    IN ULONG Length
    );

//
// Make everything pageable
//

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, MfFindResourceType)
#pragma alloc_text(PAGE, MfUnpackRequirement)
#pragma alloc_text(PAGE, MfPackResource)
#pragma alloc_text(PAGE, MfUnpackResource)
#pragma alloc_text(PAGE, MfUpdateResource)

#endif // ALLOC_PRAGMA

//
// This table describes the resource types that are understood by the MF driver.
// It is implemented thus to that in the future MF could be educated about new
// resource types dynamically.
//

MF_RESOURCE_TYPE MfResourceTypes[] = {

    {
        CmResourceTypePort,
        MfUnpackRequirement,
        MfPackResource,
        MfUnpackResource,
        MfRequirementFromResource,
        MfUpdateResource

    },

    {
        CmResourceTypeInterrupt,
        MfUnpackRequirement,
        MfPackResource,
        MfUnpackResource,
        MfRequirementFromResource,
        MfUpdateResource
    },

    {
        CmResourceTypeMemory,
        MfUnpackRequirement,
        MfPackResource,
        MfUnpackResource,
        MfRequirementFromResource,
        MfUpdateResource
    },

    {
        CmResourceTypeDma,
        MfUnpackRequirement,
        MfPackResource,
        MfUnpackResource,
        MfRequirementFromResource,
        MfUpdateResource
    },

    {
        CmResourceTypeBusNumber,
        MfUnpackRequirement,
        MfPackResource,
        MfUnpackResource,
        MfRequirementFromResource,
        MfUpdateResource
    }
};

NTSTATUS
MfRequirementFromResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Resource,
    OUT PIO_RESOURCE_DESCRIPTOR Requirement
    )
/*++

Routine Description:

    This function build an requirements descriptor for a resource the parent is
    started with.

Arguments:

    Resource - Pointer to the resource to make a requirement from

    Requirement - Pointer to a descriptor that should be filled in

Return Value:

    Success or otherwise of the operation

--*/
{

    //
    // Copy the common fields
    //

    Requirement->Type = Resource->Type;
    Requirement->ShareDisposition =  Resource->ShareDisposition;
    Requirement->Flags = Resource->Flags;

    //
    // Fill in the requirement
    //

    switch (Resource->Type) {
    case CmResourceTypeMemory:
    case CmResourceTypePort:

        //
        // We *DO NOT* support zero length requirements
        //

        if (Resource->u.Generic.Length == 0) {
            return STATUS_INVALID_PARAMETER;
        }

        Requirement->u.Generic.MinimumAddress = Resource->u.Generic.Start;
        Requirement->u.Generic.MaximumAddress.QuadPart =
            Resource->u.Generic.Start.QuadPart + Resource->u.Generic.Length - 1;
        Requirement->u.Generic.Length = Resource->u.Generic.Length;
        Requirement->u.Generic.Alignment = 1;
        break;

    case CmResourceTypeInterrupt:
        Requirement->u.Interrupt.MinimumVector = Resource->u.Interrupt.Vector;
        Requirement->u.Interrupt.MaximumVector = Resource->u.Interrupt.Vector;
        break;

    case CmResourceTypeDma:
        Requirement->u.Dma.MinimumChannel = Resource->u.Dma.Channel;
        Requirement->u.Dma.MinimumChannel = Resource->u.Dma.Channel;
        break;

    case CmResourceTypeBusNumber:

        //
        // We *DO NOT* support zero length requirements
        //

        if (Resource->u.BusNumber.Length == 0) {
            return STATUS_INVALID_PARAMETER;
        }

        Requirement->u.BusNumber.Length = Resource->u.BusNumber.Length;
        Requirement->u.BusNumber.MinBusNumber = Resource->u.BusNumber.Start;
        Requirement->u.BusNumber.MaxBusNumber = Resource->u.BusNumber.Start +
                                                Resource->u.BusNumber.Length - 1;
        break;

    case CmResourceTypeDevicePrivate:
        Requirement->u.DevicePrivate.Data[0] = Resource->u.DevicePrivate.Data[0];
        Requirement->u.DevicePrivate.Data[1] = Resource->u.DevicePrivate.Data[1];
        Requirement->u.DevicePrivate.Data[2] = Resource->u.DevicePrivate.Data[2];
        break;

    default:
        return STATUS_INVALID_PARAMETER;

    }

    return STATUS_SUCCESS;

}

PMF_RESOURCE_TYPE
MfFindResourceType(
    IN CM_RESOURCE_TYPE Type
    )
/*++

Routine Description:

    This routine searches the database of know resource types to find the
    resource descriptor manipulation routines for resources of type Type.

Arguments:

    Type - The resource type we are interested in.

Return Value:

    Returns a pointer to the appropriate MF_RESOURCE_TYPE or NULL if one could
    not be found.

--*/


{
    PMF_RESOURCE_TYPE current;

    PAGED_CODE();

    FOR_ALL_IN_ARRAY(MfResourceTypes,
                     sizeof(MfResourceTypes) / sizeof(MF_RESOURCE_TYPE),
                     current
                     ) {

        if (current->Type == Type) {
            return current;
        }
    }

    return NULL;
}


NTSTATUS
MfUnpackRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Minimum,
    OUT PULONGLONG Maximum,
    OUT PULONG Length,
    OUT PULONG Alignment
    )

/*++

Routine Description:

    This routine unpacks an resource requirement descriptor.

Arguments:

    Descriptor - The descriptor describing the requirement to unpack.

    Minimum - Pointer to where the minimum acceptable start value should be
        unpacked to.

    Maximum - Pointer to where the maximum acceptable end value should be
        unpacked to.

    Length - Pointer to where the required length should be unpacked to.

    Minimum - Pointer to where the required alignment should be unpacked to.

Return Value:

    Returns the status of this operation.

--*/

{

    PAGED_CODE();

    switch (Descriptor->Type) {
    case CmResourceTypePort:
    case CmResourceTypeMemory:

        *Maximum = Descriptor->u.Generic.MaximumAddress.QuadPart;
        *Minimum = Descriptor->u.Generic.MinimumAddress.QuadPart;
        *Length = Descriptor->u.Generic.Length;
        *Alignment = Descriptor->u.Generic.Alignment;
        break;

    case CmResourceTypeInterrupt:

        *Maximum = Descriptor->u.Interrupt.MaximumVector;
        *Minimum = Descriptor->u.Interrupt.MinimumVector;
        *Length = 1;
        *Alignment = 1;
        break;

    case CmResourceTypeDma:
        *Maximum = Descriptor->u.Dma.MaximumChannel;
        *Minimum = Descriptor->u.Dma.MinimumChannel;
        *Length = 1;
        *Alignment = 1;
        break;

    case CmResourceTypeBusNumber:
        *Maximum = Descriptor->u.BusNumber.MaxBusNumber;
        *Minimum = Descriptor->u.BusNumber.MinBusNumber;
        *Length = Descriptor->u.BusNumber.Length;
        *Alignment = 1;
        break;

    default:
        return STATUS_INVALID_PARAMETER;

    }

    return STATUS_SUCCESS;
}

NTSTATUS
MfPackResource(
    IN PIO_RESOURCE_DESCRIPTOR Requirement,
    IN ULONGLONG Start,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    )

/*++

Routine Description:

    This routine packs an resource descriptor.

Arguments:

    Requirement - The requirement from which this resource was chosen.

    Start - The start value of the resource.

    Descriptor - Pointer to the descriptor to pack into.

Return Value:

    Returns the status of this operation.

--*/

{
    PAGED_CODE();

    switch (Requirement->Type) {
    case CmResourceTypePort:
    case CmResourceTypeMemory:
        Descriptor->u.Generic.Start.QuadPart = Start;
        Descriptor->u.Generic.Length = Requirement->u.Generic.Length;
        break;

    case CmResourceTypeInterrupt:
        ASSERT(Start <= MAXULONG);
        Descriptor->u.Interrupt.Level = (ULONG)Start;
        Descriptor->u.Interrupt.Vector = (ULONG)Start;
        Descriptor->u.Interrupt.Affinity = 0xFFFFFFFF;
        break;

    case CmResourceTypeDma:
        ASSERT(Start <= MAXULONG);
        Descriptor->u.Dma.Channel = (ULONG)Start;
        Descriptor->u.Dma.Port = 0;
        break;

    case CmResourceTypeBusNumber:
        ASSERT(Start <= MAXULONG);
        Descriptor->u.BusNumber.Start = (ULONG)Start;
        Descriptor->u.BusNumber.Length = Requirement->u.BusNumber.Length;
        break;

    default:
        return STATUS_INVALID_PARAMETER;
    }

    Descriptor->ShareDisposition = Requirement->ShareDisposition;
    Descriptor->Flags = Requirement->Flags;
    Descriptor->Type = Requirement->Type;

    return STATUS_SUCCESS;

}

NTSTATUS
MfUnpackResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Start,
    OUT PULONG Length
    )

/*++

Routine Description:

    This routine unpacks a resource descriptor.

Arguments:

    Descriptor - The descriptor describing the resource to unpack.

    Start - Pointer to where the start value should be unpacked to.

    End - Pointer to where the end value should be unpacked to.

Return Value:

    Returns the status of this operation.

--*/

{
    PAGED_CODE();

    switch (Descriptor->Type) {
    case CmResourceTypePort:
    case CmResourceTypeMemory:
        *Start = Descriptor->u.Generic.Start.QuadPart;
        *Length = Descriptor->u.Generic.Length;
        break;

    case CmResourceTypeInterrupt:
        *Start = Descriptor->u.Interrupt.Vector;
        *Length = 1;
        break;

    case CmResourceTypeDma:
        *Start = Descriptor->u.Dma.Channel;
        *Length = 1;
        break;

    case CmResourceTypeBusNumber:
        *Start = Descriptor->u.BusNumber.Start;
        *Length = Descriptor->u.BusNumber.Length;
        break;

    default:
        return STATUS_INVALID_PARAMETER;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
MfUpdateResource(
    IN OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Resource,
    IN ULONGLONG Start,
    IN ULONG Length
    )
{
    PAGED_CODE();

    ASSERT(Resource);

    switch (Resource->Type) {

    case CmResourceTypePort:
    case CmResourceTypeMemory:
        Resource->u.Generic.Start.QuadPart = Start;
        Resource->u.Generic.Length = Length;
        break;

    case CmResourceTypeInterrupt:
        ASSERT(Start < MAXULONG);
        Resource->u.Interrupt.Vector = (ULONG)Start;
        break;

    case CmResourceTypeDma:
        ASSERT(Start < MAXULONG);
        Resource->u.Dma.Channel = (ULONG)Start;
        break;

    case CmResourceTypeBusNumber:
        ASSERT(Start < MAXULONG);
        Resource->u.BusNumber.Start = (ULONG)Start;
        Resource->u.BusNumber.Length = Length;
        break;

    default:
        return STATUS_INVALID_PARAMETER;
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\mf\enum.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    enum.c

Abstract:

    This module provides the functions related to device enumeration.

Author:

    Andy Thornton (andrewth) 20-Oct-97

Revision History:

--*/

#include "mfp.h"
#pragma hdrstop
#include <initguid.h>
#include <mf.h>
#include <wdmguid.h>

NTSTATUS
MfBuildChildRequirements(
    IN PMF_CHILD_EXTENSION Child,
    OUT PIO_RESOURCE_REQUIREMENTS_LIST *RequirementsList
    );

NTSTATUS
MfBuildDeviceID(
    IN PMF_PARENT_EXTENSION Parent,
    OUT PWSTR *DeviceID
    );

NTSTATUS
MfBuildInstanceID(
    IN PMF_CHILD_EXTENSION Child,
    OUT PWSTR *InstanceID
    );

NTSTATUS
MfBuildResourceMap(
    IN PUCHAR Data,
    IN ULONG Length,
    OUT PMF_RESOURCE_MAP *ResourceMap
    );

NTSTATUS
MfBuildVaryingResourceMap(
    IN PMF_REGISTRY_VARYING_RESOURCE_MAP RegistryMap,
    IN ULONG Length,
    OUT PMF_VARYING_RESOURCE_MAP *ResourceMap
    );

NTSTATUS
MfEnumRegistryChild(
    IN HANDLE ParentHandle,
    IN ULONG Index,
    IN OUT PMF_DEVICE_INFO Info
    );

NTSTATUS
MfEnumerate(
    IN PMF_PARENT_EXTENSION Parent
    );

NTSTATUS
MfEnumerateFromInterface(
    IN PMF_PARENT_EXTENSION Parent
    );

NTSTATUS
MfEnumerateFromRegistry(
    IN PMF_PARENT_EXTENSION Parent
    );

BOOLEAN
MfIsChildEnumeratedAlready(
    PMF_PARENT_EXTENSION Parent,
    PUNICODE_STRING childName
    );

BOOLEAN
MfIsResourceShared(
    IN PMF_PARENT_EXTENSION Parent,
    IN UCHAR Index,
    IN ULONG Offset,
    IN ULONG Size
    );

NTSTATUS
MfParentResourceToChildRequirement(
    IN PMF_PARENT_EXTENSION Parent,
    IN PMF_CHILD_EXTENSION Child,
    IN UCHAR Index,
    IN ULONG Offset OPTIONAL,
    IN ULONG Size OPTIONAL,
    OUT PIO_RESOURCE_DESCRIPTOR Requirement
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, MfBuildChildRequirements)
#pragma alloc_text(PAGE, MfBuildDeviceID)
#pragma alloc_text(PAGE, MfBuildInstanceID)
#pragma alloc_text(PAGE, MfBuildResourceMap)
#pragma alloc_text(PAGE, MfBuildVaryingResourceMap)
#pragma alloc_text(PAGE, MfEnumRegistryChild)
#pragma alloc_text(PAGE, MfEnumerate)
#pragma alloc_text(PAGE, MfEnumerateFromInterface)
#pragma alloc_text(PAGE, MfEnumerateFromRegistry)
#pragma alloc_text(PAGE, MfIsResourceShared)
#pragma alloc_text(PAGE, MfParentResourceToChildRequirement)
#endif

NTSTATUS
MfBuildResourceMap(
    IN PUCHAR Data,
    IN ULONG Length,
    OUT PMF_RESOURCE_MAP *ResourceMap
    )

/*++

Routine Description:

    Constructs an MF_RESOURCE_MAP from information returned from the registry

Arguments:

    Data - The raw REG_BINARY data from the registry

    Length - Length in bytes of Data

    ResourceMap - On success a pointer to the resource map.  Memory should be
        freed using ExFreePool when no longer required

Return Value:

    Status code indicating the success or otherwise of the operation.

--*/

{
    PMF_RESOURCE_MAP resourceMap;

    //
    // Allocate the resource map structure, add space for a count
    //

    resourceMap = ExAllocatePoolWithTag(PagedPool,
                                        sizeof(MF_RESOURCE_MAP) +
                                            (Length - 1) * sizeof(UCHAR),
                                        MF_RESOURCE_MAP_TAG
                                        );

    if (!resourceMap) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Fill it in
    //

    resourceMap->Count = Length;

    RtlCopyMemory(&resourceMap->Resources, Data, Length);

    //
    // Hand it back to the caller
    //

    *ResourceMap = resourceMap;

    return STATUS_SUCCESS;
}

NTSTATUS
MfBuildVaryingResourceMap(
    IN PMF_REGISTRY_VARYING_RESOURCE_MAP RegistryMap,
    IN ULONG Length,
    OUT PMF_VARYING_RESOURCE_MAP *ResourceMap
    )

/*++

Routine Description:

    Constructs an MF_VARYING_RESOURCE_MAP from information returned from the registry

Arguments:

    RegistryMap - The raw REG_BINARY data from the registry

    Length - Length in bytes of RegistryMap

    ResourceMap - On success a pointer to the resource map.  Memory should be
        freed using ExFreePool when no longer required

Return Value:

    Status code indicating the success or otherwise of the operation.

--*/

{

    PMF_VARYING_RESOURCE_MAP resourceMap;
    PMF_VARYING_RESOURCE_ENTRY current;
    PMF_REGISTRY_VARYING_RESOURCE_MAP currentRegistry;
    ULONG count;

    if (Length % sizeof(MF_REGISTRY_VARYING_RESOURCE_MAP) != 0) {
        return STATUS_INVALID_PARAMETER;
    }

    count = Length / sizeof(MF_REGISTRY_VARYING_RESOURCE_MAP);

    //
    // Allocate the resource map structure
    //

    resourceMap = ExAllocatePoolWithTag(PagedPool,
                                        sizeof(MF_VARYING_RESOURCE_MAP) +
                                            (count-1) * sizeof(MF_VARYING_RESOURCE_ENTRY),
                                        MF_VARYING_MAP_TAG
                                        );

    if (!resourceMap) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Fill it in
    //

    resourceMap->Count = count;

    //
    // Translate the registry data into an aligned internal format
    //

    current = resourceMap->Resources;
    currentRegistry = RegistryMap;

    while (count--) {

        current->ResourceIndex = currentRegistry->ResourceIndex;
        current->Offset = currentRegistry->Offset;
        current->Size = currentRegistry->Size;

        currentRegistry++;
        current++;
    }

    //
    // Hand it back to the caller
    //

    *ResourceMap = resourceMap;

    return STATUS_SUCCESS;
}

NTSTATUS
MfEnumRegistryChild(
    IN HANDLE ParentHandle,
    IN ULONG Index,
    IN OUT PMF_DEVICE_INFO Info
    )

/*++

Routine Description:

    Initialized an MF_DEVICE_INFO from information stored in the registry.

Arguments:

    ParentHandle - Handle to the registry key under which the data is stored

    Index - Index of the subkey to use

    Info - Pointer to the device info that should be filled in


Return Value:

    Status code indicating the success or otherwise of the operation.

--*/

{
    NTSTATUS status;
    PMF_REGISTRY_VARYING_RESOURCE_MAP varyingMap = NULL;
    PUCHAR resourceMap = NULL;
    ULONG varyingMapSize = 0, resourceMapSize = 0, stringSize = 0;
    BOOLEAN gotId = FALSE;

    ASSERT(ParentHandle && Info);

    //
    // Retrieve the data - we must have a HardwareID and/or CompatibleID
    //

    status = MfGetRegistryValue(ParentHandle,
                                L"HardwareID",
                                REG_MULTI_SZ,
                                MF_GETREG_SZ_TO_MULTI_SZ,
                                &stringSize,
                                &Info->HardwareID.Buffer
                                );

    if (NT_SUCCESS(status)) {
        gotId = TRUE;
    } else if (status != STATUS_OBJECT_NAME_NOT_FOUND) {
        goto cleanup;
    }

    ASSERT(stringSize <= MAXUSHORT);

    Info->HardwareID.Length = (USHORT)stringSize;
    Info->HardwareID.MaximumLength = Info->HardwareID.Length;

    //
    // ... CompatibleID ...
    //

    stringSize = 0;

    status = MfGetRegistryValue(ParentHandle,
                                L"CompatibleID",
                                REG_MULTI_SZ,
                                MF_GETREG_SZ_TO_MULTI_SZ,
                                &stringSize,
                                &Info->CompatibleID.Buffer
                                );

    if (NT_SUCCESS(status)) {
        gotId = TRUE;
    } else if (status != STATUS_OBJECT_NAME_NOT_FOUND) {
        goto cleanup;
    }

    ASSERT(stringSize <= MAXUSHORT);

    Info->CompatibleID.Length = (USHORT)stringSize;
    Info->CompatibleID.MaximumLength = Info->CompatibleID.Length;

    //
    // Now check that we have got an ID - if we don't then fail
    //

    if (!gotId) {
        status = STATUS_UNSUCCESSFUL;
        goto cleanup;
    }

    //
    // ...ResourceMap...
    //

    status = MfGetRegistryValue(ParentHandle,
                                L"ResourceMap",
                                REG_BINARY,
                                0,  // flags
                                &resourceMapSize,
                                &resourceMap
                                );

    if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
        goto cleanup;
    }

    //
    // If we have a resource map the store it in our device info
    //

    if (resourceMap) {

        status = MfBuildResourceMap(resourceMap,
                                    resourceMapSize,
                                    &Info->ResourceMap
                                    );
        ExFreePool(resourceMap);
        resourceMap = NULL;
        if (!NT_SUCCESS(status)) {
            goto cleanup;
        }
    }

    //
    // ...VaryingResourceMap...
    //

    status = MfGetRegistryValue(ParentHandle,
                                L"VaryingResourceMap",
                                REG_BINARY,
                                0, // flags
                                &varyingMapSize,
                                &varyingMap
                                );

    if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
        goto cleanup;
    }

    if (varyingMap) {

        status = MfBuildVaryingResourceMap(varyingMap,
                                           varyingMapSize,
                                           &Info->VaryingResourceMap
                                           );
        ExFreePool(varyingMap);
        varyingMap = NULL;
        if (!NT_SUCCESS(status)) {
            goto cleanup;
        }

    }


    //
    // ...MfFlags
    //

    status = MfGetRegistryValue(ParentHandle,
                                L"MFFlags",
                                REG_DWORD,
                                0, // flags
                                NULL,
                                (PVOID) &Info->MfFlags
                                );

    if (!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND) {
        goto cleanup;
    }

    return STATUS_SUCCESS;

cleanup:

    MfFreeDeviceInfo(Info);
    //
    // If any of the values were of the wrong type then this is an invalid
    // MF entry.
    //

    if (status == STATUS_OBJECT_TYPE_MISMATCH) {
        status = STATUS_INVALID_PARAMETER;
    }

    return status;
}

NTSTATUS
MfEnumerate(
    IN PMF_PARENT_EXTENSION Parent
    )
/*++

Routine Description:

    Allocates and initialies the Children list of PDOs for this MF device.
    First from the registry and then by querying an MF_ENUMERATION_INTERFACE from
    its PDO.

Arguments:

    Parent - The MF device that should be enumerated

Return Value:

    Status code indicating the success or otherwise of the operation.

--*/

{
    NTSTATUS status;
    PMF_CHILD_EXTENSION current, next;

    //
    // Try to get our children from the registry
    //

    status = MfEnumerateFromRegistry(Parent);

    if (!NT_SUCCESS(status)) {

        //
        // STATUS_UNSUCCESSFUL indicates that there wasn't any MF information
        // in the registry
        //

        if (status == STATUS_UNSUCCESSFUL) {

            //
            // See if our parent has an MF_ENUMERATION_INTERFACE for us...
            //

            status = MfEnumerateFromInterface(Parent);
        }
    }

    return status;
}


NTSTATUS
MfEnumerateFromRegistry(
    IN PMF_PARENT_EXTENSION Parent
    )

/*++

Routine Description:

    Allocates and initialies the Children list of PDOs for this MF device by
    looking in the registry

Arguments:

    Parent - The MF device that should be enumerated

Return Value:

    Status code indicating the success or otherwise of the operation.
    STATUS_UNSUCCESSFUL indicates that no MF information was found in the
    registry.

--*/

{
    NTSTATUS status;
    HANDLE parentHandle = NULL, childHandle = NULL;
    ULONG index = 0;
    UNICODE_STRING childName;
    PDEVICE_OBJECT pdo;
    PMF_CHILD_EXTENSION child;
    MF_DEVICE_INFO info;

    ASSERT(!(Parent->Common.DeviceState & MF_DEVICE_ENUMERATED));

    //
    // Open the "Device Parameters" key for our PDO and see what the INF file
    // put there.
    //

    status = IoOpenDeviceRegistryKey(Parent->PhysicalDeviceObject,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     KEY_READ,
                                     &parentHandle
                                     );

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    ASSERT(parentHandle);

    //
    // Iterate over keys
    //

    for (;;) {

        //
        // Open the child key for this info
        //

        status = MfGetSubkeyByIndex(parentHandle,
                                    index,
                                    KEY_READ,
                                    &childHandle,
                                    &childName
                                    );

        if (status == STATUS_NO_MORE_ENTRIES) {

            if (IsListEmpty(&Parent->Children)) {

                //
                // There wern't any children - fail
                //
                status = STATUS_UNSUCCESSFUL;
                goto cleanup;
            }

            //
            // We've found all the children
            //
            break;
        }

        if (!NT_SUCCESS(status)) {
            goto cleanup;
        }

        RtlZeroMemory(&info, sizeof(info));
        if (!MfIsChildEnumeratedAlready(Parent, &childName)) {
            
            info.Name = childName;

            //
            // Query the registry for the info
            //

            status = MfEnumRegistryChild(childHandle, index, &info);
            if (NT_SUCCESS(status)) {
                status = MfCreatePdo(Parent, &pdo);
                if (NT_SUCCESS(status)) {
                    child = (PMF_CHILD_EXTENSION) pdo->DeviceExtension;
                    child->Info = info;
                } else {
                    MfFreeDeviceInfo(&info);
                }
            }
        } else {
            ExFreePool(childName.Buffer);
        }

        ZwClose(childHandle);
        index++;
    }

    ZwClose(parentHandle);

    return STATUS_SUCCESS;

cleanup:

    if (parentHandle) {
        ZwClose(parentHandle);
    }

    if (childHandle) {
        ZwClose(childHandle);
    }

    return status;

}

NTSTATUS
MfEnumerateFromInterface(
    IN PMF_PARENT_EXTENSION Parent
    )

/*++

Routine Description:

    Allocates and initialies the Children list of PDOs for this MF device by
    querying its pdo for an interface

Arguments:

    Parent - The MF device that should be enumerated

Return Value:

    Status code indicating the success or otherwise of the operation.

--*/

{

    NTSTATUS status;
    IO_STACK_LOCATION request;
    MF_ENUMERATION_INTERFACE interface;
    PDEVICE_OBJECT pdo;
    PMF_CHILD_EXTENSION child;
    MF_DEVICE_INFO info;
    ULONG index = 0;

    //
    // Send a query interface IRP to our parent's PDO
    //

    RtlZeroMemory(&request, sizeof(IO_STACK_LOCATION));
    RtlZeroMemory(&interface, sizeof(MF_ENUMERATION_INTERFACE));

    request.MajorFunction = IRP_MJ_PNP;
    request.MinorFunction = IRP_MN_QUERY_INTERFACE;
    request.Parameters.QueryInterface.InterfaceType = &GUID_MF_ENUMERATION_INTERFACE;
    request.Parameters.QueryInterface.Size = sizeof(MF_ENUMERATION_INTERFACE);
    request.Parameters.QueryInterface.Version = 1;
    request.Parameters.QueryInterface.Interface = (PINTERFACE) &interface;

    status = MfSendPnpIrp(Parent->PhysicalDeviceObject, &request, NULL);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    for (;;) {

        RtlZeroMemory(&info, sizeof(info));
        //
        // Query the interface for the info
        //

        status = interface.EnumerateChild(interface.Context,
                                          index,
                                          &info
                                          );

        if (!NT_SUCCESS(status)) {

            if (status == STATUS_NO_MORE_ENTRIES) {

                if (IsListEmpty(&Parent->Children)) {

                    //
                    // There wern't any children - fail
                    //
                    status = STATUS_UNSUCCESSFUL;
                    goto cleanup;
                }

                status = STATUS_SUCCESS;
                break;

            } else {
                goto cleanup;
            }
        }

        if (!MfIsChildEnumeratedAlready(Parent, &info.Name)) {

            //
            // Create a device object
            //

            status = MfCreatePdo(Parent, &pdo);
            if (NT_SUCCESS(status)) {
                child = (PMF_CHILD_EXTENSION) pdo->DeviceExtension;
                child->Info = info;
            } else {
                MfFreeDeviceInfo(&info);
            }
        } else {
            MfFreeDeviceInfo(&info);
        }
        index++;
    }

    interface.InterfaceDereference(interface.Context);

    return STATUS_SUCCESS;

cleanup:

    return status;
}

NTSTATUS
MfBuildDeviceID(
    IN PMF_PARENT_EXTENSION Parent,
    OUT PWSTR *DeviceID
    )

/*++

Routine Description:

    Constructs a device ID for the parent device

Arguments:

    Parent - Parent the device ID should be constructed for

    DeviceID - On success the device id

Return Value:

    Status code indicating the success or otherwise of the operation.

--*/

{

#define MF_ENUMERATOR_STRING    L"MF\\"

    NTSTATUS status;
    PWSTR source, destination, id = NULL;

    id = ExAllocatePoolWithTag(PagedPool,
                               sizeof(MF_ENUMERATOR_STRING) // This includes the termination NULL
                                    + Parent->DeviceID.Length,
                               MF_DEVICE_ID_TAG
                               );

    if (!id) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    RtlCopyMemory(id,
                  MF_ENUMERATOR_STRING,
                  sizeof(MF_ENUMERATOR_STRING) - sizeof(UNICODE_NULL)
                  );

    //
    // Copy the device ID of the parent to the buffer replacing each
    // occurence of '\' with '#'
    //

    destination = id +
        (sizeof(MF_ENUMERATOR_STRING) - sizeof(UNICODE_NULL)) / sizeof(WCHAR);

    FOR_ALL_IN_ARRAY(Parent->DeviceID.Buffer,
                     Parent->DeviceID.Length / sizeof(WCHAR),
                     source) {

        ASSERT(*source != L' ');

        if (*source == L'\\') {
            *destination = L'#';
        } else {
            *destination = *source;
        }

        destination++;
    }

    //
    // Finally null terminate it
    //

    *destination = UNICODE_NULL;
    *DeviceID = id;

    return STATUS_SUCCESS;

cleanup:

    if (id) {
        ExFreePool(id);
    }

    return status;
}


NTSTATUS
MfBuildInstanceID(
    IN PMF_CHILD_EXTENSION Child,
    OUT PWSTR *InstanceID
    )

/*++

Routine Description:

    Constructs a instance ID for this child

Arguments:

    Child - Child the ID should be constructed for

    DeviceID - On success the device id

Return Value:

    Status code indicating the success or otherwise of the operation.

--*/

{
    NTSTATUS status;
    PWSTR current, id = NULL;

    id = ExAllocatePoolWithTag(PagedPool,
                               Child->Parent->InstanceID.Length + sizeof(L'#')
                                   + Child->Info.Name.Length + sizeof(UNICODE_NULL),
                               MF_INSTANCE_ID_TAG
                               );

    if (!id) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }


    //
    // Copy the parents instance ID...
    //

    RtlCopyMemory(id,
                  Child->Parent->InstanceID.Buffer,
                  Child->Parent->InstanceID.Length
                  );

    current = id + Child->Parent->InstanceID.Length / sizeof(WCHAR);

    //
    // ...then the '#'...
    //

    *current++ = L'#';

    //
    // ...the child name...
    //

    RtlCopyMemory(current,
                  Child->Info.Name.Buffer,
                  Child->Info.Name.Length
                  );

    //
    // ...and last but not least the NULL termination
    //

    current += Child->Info.Name.Length / sizeof(WCHAR);

    *current = UNICODE_NULL;

    *InstanceID = id;

    return STATUS_SUCCESS;

cleanup:

    if (id) {
        ExFreePool(id);
    }

    return status;

}

BOOLEAN
MfIsResourceShared(
    IN PMF_PARENT_EXTENSION Parent,
    IN UCHAR Index,
    IN ULONG Offset,
    IN ULONG Size
    )

/*++

Routine Description:

    Determines if the Parent resource of Index has been requested by more than
    one child, in which case the children wanting that resource should claim it
    shared.

Arguments:

    Parent - The parent device of the MF subtree.

    Index - The index of the parent resources we are interested in.

Return Value:

    TRUE if the resource is shared, FALSE otherwise

--*/

{

    PMF_CHILD_EXTENSION current;
    PUCHAR resource;
    PMF_VARYING_RESOURCE_ENTRY varyingResource;
    PLIST_ENTRY currentEntry;
    BOOLEAN result = FALSE;
    ULONG refCount = 0;


    //
    // Iterate through the list of children in the parent
    //

    MfAcquireChildrenLock(Parent);

    for (currentEntry = Parent->Children.Flink;
         currentEntry != &Parent->Children;
         currentEntry = currentEntry->Flink) {

        current = CONTAINING_RECORD(currentEntry,
                                    MF_CHILD_EXTENSION,
                                    ListEntry);

        //
        // Iterate through the array of descriptors
        //

        if (current->Info.ResourceMap) {

            FOR_ALL_IN_ARRAY(current->Info.ResourceMap->Resources,
                             current->Info.ResourceMap->Count,
                             resource) {

                if (*resource == Index) {

                    refCount++;

                    if (refCount > 1) {
                        result = TRUE;
                        goto out;
                    }
                }
            }
        }

        if (current->Info.VaryingResourceMap) {

            FOR_ALL_IN_ARRAY(current->Info.VaryingResourceMap->Resources,
                             current->Info.VaryingResourceMap->Count,
                             varyingResource) {

                //
                // If indexes are the same and ranges overlap, we have a reference
                //
                if ((varyingResource->ResourceIndex == Index) &&
                    ( ( Size == 0) ||
                      ( varyingResource->Offset >= Offset &&
                        varyingResource->Offset < Offset + Size) ||
                      ( Offset >= varyingResource->Offset &&
                        Offset < varyingResource->Offset + varyingResource->Size))) {

                    refCount++;

                    if (refCount > 1) {
                        result = TRUE;
                        goto out;
                    }
                }
            }
        }
    }

 out:
    MfReleaseChildrenLock(Parent);
    return result;
}

NTSTATUS
MfBuildChildRequirements(
    IN PMF_CHILD_EXTENSION Child,
    OUT PIO_RESOURCE_REQUIREMENTS_LIST *RequirementsList
    )

/*++

Routine Description:

    Constructs a requirements list for Child based on the resources allocated
    to the childs parent

Arguments:

    Child - Child the requirements list is to be built for

    RequirementsList - On success a pointer to the list

Return Value:

    Status code indicating the success or otherwise of the operation.

--*/

{
    NTSTATUS status;
    ULONG size, count = 0;
    PIO_RESOURCE_REQUIREMENTS_LIST requirements = NULL;
    PIO_RESOURCE_DESCRIPTOR descriptor;
    PCHAR resource;
    PMF_VARYING_RESOURCE_ENTRY varyingResource;

    //
    // Check if we have a resource list.  If not, then MF has been
    // loaded on device that doesn't consume resources.  As a result,
    // the children can't consume resources either.
    //

    if (Child->Parent->ResourceList == NULL) {
        *RequirementsList = NULL;
        return STATUS_SUCCESS;
    }

    //
    // Calculate the size of the resource list
    //

    if (Child->Info.VaryingResourceMap) {

        count += Child->Info.VaryingResourceMap->Count;
    }

    if (Child->Info.ResourceMap) {

        count += Child->Info.ResourceMap->Count;
    }

    //
    // Allocate the buffer
    //

    size = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) +
                (count-1) * sizeof(IO_RESOURCE_DESCRIPTOR);

    requirements = ExAllocatePoolWithTag(PagedPool,
                                         size,
                                         MF_CHILD_REQUIREMENTS_TAG
                                         );
    if (!requirements) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    //
    // Build the list
    //
    RtlZeroMemory(requirements, size);

    requirements->ListSize = size;
    requirements->InterfaceType = Child->Parent->ResourceList->List[0].InterfaceType;
    requirements->BusNumber = Child->Parent->ResourceList->List[0].BusNumber;
    requirements->AlternativeLists = 1;
    requirements->List[0].Version = MF_CM_RESOURCE_VERSION;
    requirements->List[0].Revision = MF_CM_RESOURCE_REVISION;
    requirements->List[0].Count = count;

    descriptor = requirements->List[0].Descriptors;

    if (Child->Info.ResourceMap) {

        FOR_ALL_IN_ARRAY(Child->Info.ResourceMap->Resources,
                         Child->Info.ResourceMap->Count,
                         resource) {

            status = MfParentResourceToChildRequirement(Child->Parent,
                                                        Child,
                                                        *resource,
                                                        0,
                                                        0,
                                                        descriptor
                                                        );

            if (!NT_SUCCESS(status)) {
                goto cleanup;
            }

            descriptor++;

        }
    }

    if (Child->Info.VaryingResourceMap) {

         FOR_ALL_IN_ARRAY(Child->Info.VaryingResourceMap->Resources,
                          Child->Info.VaryingResourceMap->Count,
                          varyingResource) {

             status = MfParentResourceToChildRequirement(Child->Parent,
                                                         Child,
                                                         varyingResource->ResourceIndex,
                                                         varyingResource->Offset,
                                                         varyingResource->Size,
                                                         descriptor
                                                         );

             if (!NT_SUCCESS(status)) {
                 goto cleanup;
             }

             descriptor++;

         }
     }


    *RequirementsList = requirements;

    return STATUS_SUCCESS;

cleanup:

    *RequirementsList = NULL;

    if (requirements) {
        ExFreePool(requirements);
    }

    return status;

}

NTSTATUS
MfParentResourceToChildRequirement(
    IN PMF_PARENT_EXTENSION Parent,
    IN PMF_CHILD_EXTENSION Child,
    IN UCHAR Index,
    IN ULONG Offset OPTIONAL,
    IN ULONG Size OPTIONAL,
    OUT PIO_RESOURCE_DESCRIPTOR Requirement
    )
/*++

Routine Description:

    This function build an requirements descriptor for a resource the parent is
    started with.

Arguments:

    Parent - The parent device of the MF subtree.

    Index - The index of the parent resources we are interested in.

    Offset - The offset within the parent resource of the requirement.
        This is actually used as an index into a table stored in the parent
        resource list describing the mapping from this given offset to the
        real offset to be used.  This allows for varying resource maps to
        access the same offset within the same resource and get a different
        requirement.  If Size == 0, this is ignored.

    Size - The length of the requirement.  If set to 0, it is assumed to be
        the length of the parent resource.

    Requirement - Pointer to a descriptor that should be filled in

Return Value:

    Success or otherwise of the operation

--*/
{
    NTSTATUS status;
    CM_PARTIAL_RESOURCE_DESCRIPTOR resource;
    PMF_RESOURCE_TYPE resType;
    ULONG effectiveOffset;
    ULONGLONG resourceStart;
    ULONG dummyLength;

    ASSERT(Parent->ResourceList->Count == 1);

    //
    // Bounds check the index
    //

    if (Index > Parent->ResourceList->List[0].PartialResourceList.Count) {

        if (Child->Info.MfFlags & MF_FLAGS_FILL_IN_UNKNOWN_RESOURCE) {
            //
            // Fill in a null resource list
            //

            RtlZeroMemory(Requirement, sizeof(IO_RESOURCE_DESCRIPTOR));
            Requirement->Type = CmResourceTypeNull;
            return STATUS_SUCCESS;
        }

        return STATUS_INVALID_PARAMETER;
    }

    RtlCopyMemory(&resource,
                  &Parent->ResourceList->List[0].PartialResourceList.PartialDescriptors[Index],
                  sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));

    //
    // Find the appropriate resource type for the resource -> requirement
    // function if this is an arbitrated resource
    //

    if (!(resource.Type & CmResourceTypeNonArbitrated)) {

        resType = MfFindResourceType(resource.Type);

        if (!resType) {

            DEBUG_MSG(1,
                      ("Unknown resource type %i at parent index 0x%x\n",
                       resource.Type,
                       Index
                      ));


            return STATUS_INVALID_PARAMETER;
        }

        //
        // update the resource with the correct offset and length
        // if size == 0 we assume it is optional and don't do the update
        //

        if (Size) {

            status = resType->UnpackResource(&resource,
                                        &resourceStart,
                                        &dummyLength);

            if (!NT_SUCCESS(status)) {
                return status;
            }

            status = resType->UpdateResource(&resource,
                                        resourceStart+Offset,
                                        Size
                                        );

            if (!NT_SUCCESS(status)) {
                return status;
            }

        }
        //
        // Convert the resource to a requirement
        //

        status = resType->RequirementFromResource(&resource, Requirement);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        //
        // Update the share disposition if necessary
        //

        if (MfIsResourceShared(Parent, Index, Offset, Size)) {
            Requirement->ShareDisposition =  CmResourceShareShared;
        }

    } else {

        //
        // This is a non-arbitrated resource so it is modled after a device
        // private, just copy the data
        //

        Requirement->Type = resource.Type;
        Requirement->ShareDisposition =  resource.ShareDisposition;
        Requirement->Flags = resource.Flags;
        Requirement->u.DevicePrivate.Data[0] = resource.u.DevicePrivate.Data[0];
        Requirement->u.DevicePrivate.Data[1] = resource.u.DevicePrivate.Data[1];
        Requirement->u.DevicePrivate.Data[2] = resource.u.DevicePrivate.Data[2];

    }

    return STATUS_SUCCESS;
}

BOOLEAN
MfIsChildEnumeratedAlready(
    PMF_PARENT_EXTENSION Parent,
    PUNICODE_STRING ChildName
    )
/*++

Routine Description:

    This function checks whether a child with this name has already
    been enumerated.

Arguments:

    Parent - The parent device of the MF subtree.

    ChildName - unicode string to compare to existing child names

Return Value:

    TRUE or FALSE

--*/
{
    PMF_CHILD_EXTENSION currentChild;
    PLIST_ENTRY currentEntry;
    BOOLEAN result = FALSE;

    for (currentEntry = Parent->Children.Flink;
         currentEntry != &Parent->Children;
         currentEntry = currentEntry->Flink) {

        currentChild = CONTAINING_RECORD(currentEntry,
                                         MF_CHILD_EXTENSION,
                                         ListEntry);

        //
        // Comparison is case-sensitive because there is no reason it
        // shouldn't be.
        //

        if (RtlEqualUnicodeString(&currentChild->Info.Name,
                                  ChildName,
                                  FALSE)) {
            result = TRUE;
            break;
        }
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\mf\utils.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    utils.c

Abstract:

    This module provides general utility functions.

Author:

    Andy Thornton (andrewth) 20-Oct-97

Revision History:

--*/

#include "mfp.h"

VOID
MfInitCommonExtension(
    PMF_COMMON_EXTENSION Common,
    MF_OBJECT_TYPE Type
    );

NTSTATUS
MfGetSubkeyByIndex(
    IN HANDLE ParentHandle,
    IN ULONG Index,
    IN ACCESS_MASK Access,
    OUT PHANDLE ChildHandle,
    OUT PUNICODE_STRING Name
    );

NTSTATUS
MfGetRegistryValue(
    IN HANDLE Handle,
    IN PWSTR Name,
    IN ULONG Type,
    IN ULONG Flags,
    IN OUT PULONG DataLength,
    IN OUT PVOID *Data
    );

NTSTATUS
MfSendPnpIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_STACK_LOCATION Location,
    OUT PULONG_PTR Information OPTIONAL
    );

DEVICE_POWER_STATE
MfFindLowestChildPowerState(
    IN PMF_PARENT_EXTENSION Parent
    );

NTSTATUS
MfPowerRequestCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
MfSendSetPowerIrp(
    IN PDEVICE_OBJECT Target,
    IN POWER_STATE State
    );


#ifdef ALLOC_PRAGMA

// NOTE: Should see if the rest of the funcs can be moved out of this
// file.

#pragma alloc_text(PAGE, MfInitCommonExtension)
#pragma alloc_text(PAGE, MfGetSubkeyByIndex)
#pragma alloc_text(PAGE, MfGetRegistryValue)
#pragma alloc_text(PAGE, MfSendPnpIrp)

#endif


VOID
MfInitCommonExtension(
    PMF_COMMON_EXTENSION Common,
    MF_OBJECT_TYPE Type
    )
/*++

Routine Description:

    This initializes the fields in the common header of the device extension

Arguments:

    Common - The common header to initialize

    Type - The type of the object being initialized (ie PDO or FDO)

Return Value:

    None

--*/

{
    Common->Type = Type;
}

VOID
MfFreeDeviceInfo(
    PMF_DEVICE_INFO Info
    )
{
    if (Info->Name.Buffer) {
        ExFreePool(Info->Name.Buffer);
        Info->Name.Buffer = NULL;
    }

    if (Info->HardwareID.Buffer) {
        ExFreePool(Info->HardwareID.Buffer);
        Info->HardwareID.Buffer = NULL;
    }

    if (Info->CompatibleID.Buffer) {
        ExFreePool(Info->CompatibleID.Buffer);
        Info->CompatibleID.Buffer = NULL;
    }

    if (Info->ResourceMap) {
        ExFreePool(Info->ResourceMap);
        Info->ResourceMap = NULL;
    }

    if (Info->VaryingResourceMap) {
        ExFreePool(Info->VaryingResourceMap);
        Info->VaryingResourceMap = NULL;
    }
}

NTSTATUS
MfGetSubkeyByIndex(
    IN HANDLE ParentHandle,
    IN ULONG Index,
    IN ACCESS_MASK Access,
    OUT PHANDLE ChildHandle,
    OUT PUNICODE_STRING Name
    )

/*++

Routine Description:

    This returns the name and a handle to a subkey given that keys index

Arguments:

    ParentHandle - The handle of the key the subkeys are located under

    Index - The index of the subkey required

    Access - The type of access required to the subkey

    ChildHandle - On success contains a handle to the subkey

    Name - On success contains the name of the subkey

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{

#define INFO_BUFFER_SIZE sizeof(KEY_BASIC_INFORMATION) + 255*sizeof(WCHAR)

    NTSTATUS status;
    UCHAR buffer[INFO_BUFFER_SIZE];
    PKEY_BASIC_INFORMATION info = (PKEY_BASIC_INFORMATION) buffer;
    ULONG resultSize;
    HANDLE childHandle;
    UNICODE_STRING string = {0};
    OBJECT_ATTRIBUTES attributes;

    status = ZwEnumerateKey(ParentHandle,
                            Index,
                            KeyBasicInformation,
                            info,
                            INFO_BUFFER_SIZE,
                            &resultSize
                            );

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    //
    // Copy the name
    //

    string.Length = (USHORT) info->NameLength;
    string.MaximumLength = (USHORT) info->NameLength;
    string.Buffer = ExAllocatePoolWithTag(PagedPool,
                                          info->NameLength,
                                          MF_POOL_TAG
                                          );

    if (!string.Buffer) {
        goto cleanup;
    }

    RtlCopyMemory(string.Buffer, info->Name, info->NameLength);

    //
    // Open the name to get a handle
    //

    InitializeObjectAttributes(&attributes,
                               &string,
                               0,   //Attributes
                               ParentHandle,
                               NULL //SecurityDescriptoy
                               );

    status = ZwOpenKey(&childHandle,
                       Access,
                       &attributes
                       );

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }


    DEBUG_MSG(1, ("\tSubkey %wZ\n", &string));

    //
    // Hand the name back to the caller
    //

    Name->Buffer = string.Buffer;
    Name->Length = string.Length;
    Name->MaximumLength = string.MaximumLength;

    *ChildHandle = childHandle;

    return STATUS_SUCCESS;

cleanup:

    if (string.Buffer) {
        ExFreePool(string.Buffer);
    }
    //
    // We should never be able to overflow as our buffer is the max size of
    // a registry key name
    //
    ASSERT(status != STATUS_BUFFER_OVERFLOW);

    return status;

}



NTSTATUS
MfGetRegistryValue(
    IN HANDLE Handle,
    IN PWSTR Name,
    IN ULONG Type,
    IN ULONG Flags,
    IN OUT PULONG DataLength,
    IN OUT PVOID *Data
    )

/*++

Routine Description:

    This retrieves a value key from the registry performing type and sanity
    checking

Arguments:

    Handle - The key the values are located under

    Name - The name of the value

    Type - The type (REG_*) of the value

    DataLength - Points to the length of the data buffer, on success contains
        the size of the data

    Data - Pointer to pointer to the buffer to return the data in, if points to
        NULL a buffer of the right size should be allocated (in this case
        DataLength should be 0)

Return Value:

    Status code that indicates whether or not the function was successful.  If
    the type of the object is not Type then we fail with STATUS_OBJECT_TYPE_MISMATCH

--*/

{

#define VALUE_BUFFER_SIZE PAGE_SIZE

    NTSTATUS status;
    PKEY_VALUE_PARTIAL_INFORMATION info = NULL;
    ULONG size = VALUE_BUFFER_SIZE, length;
    UNICODE_STRING string;
    BOOLEAN convertSzToMultiSz;

    //
    // Check parameters
    //

    if (*Data && !(*DataLength)) {
        status = STATUS_INVALID_PARAMETER;
        goto cleanup;
    }

    RtlInitUnicodeString(&string, Name);

    info = ExAllocatePoolWithTag(PagedPool,
                                 VALUE_BUFFER_SIZE,
                                 MF_POOL_TAG
                                 );
    if (!info) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }


    while ((status = ZwQueryValueKey(Handle,
                                     &string,
                                     KeyValuePartialInformation,
                                     info,
                                     size,
                                     &size
                                     )) == STATUS_BUFFER_OVERFLOW) {
        ExFreePool(info);

        info = ExAllocatePoolWithTag(PagedPool,
                                     size,
                                     MF_POOL_TAG
                                     );

        if (!info) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }

    }

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }


    convertSzToMultiSz = (Type == REG_MULTI_SZ
                          && info->Type == REG_SZ
                          && Flags & MF_GETREG_SZ_TO_MULTI_SZ);


    if (convertSzToMultiSz) {
        length = info->DataLength + sizeof(UNICODE_NULL);
    } else {
        length = info->DataLength;
    }

    //
    // Make sure the type we got back is what we expected
    //

    if (info->Type != Type && !convertSzToMultiSz) {

        status = STATUS_OBJECT_TYPE_MISMATCH;
        goto cleanup;
    }

    //
    // Apply various common sense checks based on the type.
    //

    if (Type == REG_DWORD) {

        //
        // If the data is a REG_DWORD then Data is a pointer to a ULONG to store
        // the data
        //

        *Data = *((PULONG *)info->Data);

    } else if (*Data) {

        //
        // If the user supplied a buffer then make sure its big enough and use it
        // otherwise allocate one.
        //

        if (*DataLength < length) {
            status = STATUS_BUFFER_OVERFLOW;
            goto cleanup;
        }
    } else {
        *Data = ExAllocatePoolWithTag(PagedPool,
                                      length,
                                      MF_POOL_TAG
                                      );
        if (!*Data) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }
    }

    RtlCopyMemory(*Data, info->Data, info->DataLength);

    if (convertSzToMultiSz) {

        PWSTR term = (PWSTR)*Data + (info->DataLength / sizeof(WCHAR));

        //
        // Add the final null termination
        //

        *term = UNICODE_NULL;

    }

    *DataLength = length;


    status = STATUS_SUCCESS;

cleanup:

    if (info) {
        ExFreePool(info);
    }

    return status;
}

NTSTATUS
MfSendPnpIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_STACK_LOCATION Location,
    OUT PULONG_PTR Information OPTIONAL
    )

/*++

Routine Description:

    This builds and send a pnp irp to a device.

Arguments:

    DeviceObject - The a device in the device stack the irp is to be sent to -
        the top of the device stack is always found and the irp sent there first.

    Location - The initial stack location to use - contains the IRP minor code
        and any parameters

    Information - If provided contains the final value of the irps information
        field.

Return Value:

    The final status of the completed irp or an error if the irp couldn't be sent

--*/

{

    NTSTATUS status;
    PIRP irp = NULL;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_OBJECT targetDevice = NULL;
    KEVENT irpCompleted;
    IO_STATUS_BLOCK statusBlock;

    ASSERT(Location->MajorFunction == IRP_MJ_PNP);

    //
    // Find out where we are sending the irp
    //

    targetDevice = IoGetAttachedDeviceReference(DeviceObject);

    //
    // Get an IRP
    //

    KeInitializeEvent(&irpCompleted, SynchronizationEvent, FALSE);

    irp = IoBuildSynchronousFsdRequest(IRP_MJ_PNP,
                                       targetDevice,
                                       NULL,    // Buffer
                                       0,       // Length
                                       0,       // StartingOffset
                                       &irpCompleted,
                                       &statusBlock
                                       );


    if (!irp) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    irp->IoStatus.Information = 0;

    //
    // Initialize the stack location
    //

    irpStack = IoGetNextIrpStackLocation(irp);

    ASSERT(irpStack->MajorFunction == IRP_MJ_PNP);

    irpStack->MinorFunction = Location->MinorFunction;
    irpStack->Parameters = Location->Parameters;

    //
    // Call the driver and wait for completion
    //

    status = IoCallDriver(targetDevice, irp);

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(&irpCompleted, Executive, KernelMode, FALSE, NULL);
        status = statusBlock.Status;
    }

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    //
    // Return the information
    //

    if (ARGUMENT_PRESENT(Information)) {
        *Information = statusBlock.Information;
    }

    ObDereferenceObject(targetDevice);

    ASSERT(status == STATUS_PENDING || status == statusBlock.Status);

    return statusBlock.Status;

cleanup:

    if (targetDevice) {
        ObDereferenceObject(targetDevice);
    }

    return status;
}

DEVICE_POWER_STATE
MfUpdateChildrenPowerReferences(
    IN PMF_PARENT_EXTENSION Parent,
    IN DEVICE_POWER_STATE PreviousPowerState,
    IN DEVICE_POWER_STATE NewPowerState
    )
/*++

Routine Description:

    Calculates the lowest power state the mf parent can be put into
    based on the power states of its children.

Arguments:

    Parent - The MF parent device

Return Value:

    The lowest power state

--*/

{
    PMF_CHILD_EXTENSION currentChild;
    PLIST_ENTRY currentEntry;
    DEVICE_POWER_STATE lowest;
    KIRQL oldIrql;

    DEBUG_MSG(1,
              ("Scanning 0x%08x's childrens power states:\n",
               Parent->Self
               ));

 
    KeAcquireSpinLock(&Parent->PowerLock, &oldIrql);

    //
    // ChildrenPowerStates[PowerDeviceUnspecified] will go negative as
    // children leave this state.  It will never go positive as
    // children never re-enter this state.
    //

    Parent->ChildrenPowerReferences[PreviousPowerState]--;
    Parent->ChildrenPowerReferences[NewPowerState]++;

    //
    // Find the lowest power state
    //

    for (lowest = PowerDeviceUnspecified; lowest < PowerDeviceMaximum;
         lowest++) {
        if (Parent->ChildrenPowerReferences[lowest] > 0) {
            break;
        }
    }

    KeReleaseSpinLock(&Parent->PowerLock, oldIrql);

    if (lowest == PowerDeviceMaximum) {
        lowest = PowerDeviceD3;
    }

    DEBUG_MSG(1, ("Lowest = %s\n", DEVICE_POWER_STRING(lowest)));
    return lowest;
}

NTSTATUS
MfPowerRequestCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )

/*++

Routine Description:

    This is the power completion routine for all mf power operations.  It copies
    the status of the power operation into the context and then sets the completed
    event.

Arguments:

    As documented for power completion routines.

Return Value:

    STATUS_SUCCESS

--*/

{
    PMF_POWER_COMPLETION_CONTEXT completion = Context;

    completion->Status = IoStatus->Status;

    KeSetEvent(&completion->Event, 0, FALSE);

    return STATUS_SUCCESS;
}


NTSTATUS
MfSendSetPowerIrp(
    IN PDEVICE_OBJECT Target,
    IN POWER_STATE State
    )

/*++

Routine Description:

    This builds and send a IRP_MN_SET_POWER_IRP to a device.

Arguments:

    Target - The a device in the device stack the irp is to be sent to -
        the top of the device stack is always found and the irp sent there first.

    State - The device power state that should be requested.

Return Value:

    The final status of the completed irp or an error if the irp couldn't be sent

--*/


{
    NTSTATUS status;
    MF_POWER_COMPLETION_CONTEXT completion;

    KeInitializeEvent(&completion.Event, SynchronizationEvent, FALSE);

    DEBUG_MSG(1,
          ("Sending SET_POWER to 0x%08x for %s\n",
           Target,
           DEVICE_POWER_STRING(State.DeviceState)
          ));

    status = PoRequestPowerIrp(Target,
                               IRP_MN_SET_POWER,
                               State,
                               MfPowerRequestCompletion,
                               &completion,
                               NULL
                               );

    if (NT_SUCCESS(status)) {

        ASSERT(status == STATUS_PENDING);

        KeWaitForSingleObject( &completion.Event, Executive, KernelMode, FALSE, NULL );

        status = completion.Status;
    }

    return status;
}

NTSTATUS
MfUpdateParentPowerState(
    IN PMF_PARENT_EXTENSION Parent,
    IN DEVICE_POWER_STATE TargetPowerState
    )
/*++

Routine Description:

    Request Po to send the mf parent device a power irp if we need to
    change its power state because of changes to its children power
    states.

Arguments:

    Parent - The MF parent device

    TargetPowerState - The device power state that the parent should
    be updated to.

Return Value:

    The status of this operation.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    POWER_STATE newState;

    //
    // If the parent's power state need changing because of a power down or
    // power up request that it do so
    //

    if (Parent->Common.PowerState != TargetPowerState) {

        //
        // Create and send the power irp and wait for its completion
        //

        DEBUG_MSG(1,
                  ("Updating parent power state from %s to %s\n",
                   DEVICE_POWER_STRING(Parent->Common.PowerState),
                   DEVICE_POWER_STRING(TargetPowerState)
                   ));

        newState.DeviceState = TargetPowerState;

        status = MfSendSetPowerIrp(Parent->Self,
                                   newState);
        
        DEBUG_MSG(1,
                  ("Power update completed with %s (0x%08x)\n",
                   STATUS_STRING(status), status
                   ));

    } else {
        DEBUG_MSG(1,
                  ("Parent power already in %s\n",
                   DEVICE_POWER_STRING(TargetPowerState)
                   ));
    }

    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\inc\data.h ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    data.h

Abstract:

    This module provides the definitions for controller types

Author(s):

    Neil Sandlin (neilsa)

Revisions:

--*/

#ifndef _PCMCIA_DATA_H_
#define _PCMCIA_DATA_H_

#define PCMCTL_ID( Type, Part, Revision) (      \
    ((Revision) << 26) | ((Part) << 8) | (Type) \
)

#define PcmciaCLPD6729     PCMCTL_ID(PcmciaIntelCompatible, 6729, 0)
#define PcmciaCLPD6832     PCMCTL_ID(PcmciaCirrusLogic, 6832, 0) 
#define PcmciaCLPD6834     PCMCTL_ID(PcmciaCirrusLogic, 6834, 0)

#define PcmciaDB87144      PCMCTL_ID(PcmciaDatabookCB, 87144, 0)

#define PcmciaNEC66369     PCMCTL_ID(PcmciaNEC, 66369, 0)
#define PcmciaNEC98        PCMCTL_ID(PcmciaNEC_98, 0, 0)
#define PcmciaNEC98102     PCMCTL_ID(PcmciaNEC_98, 102, 0)

#define PcmciaOpti82C814   PCMCTL_ID(PcmciaOpti, 814, 0)
#define PcmciaOpti82C824   PCMCTL_ID(PcmciaOpti, 824, 0)

#define PcmciaRL5C465      PCMCTL_ID(PcmciaRicoh, 465, 0)
#define PcmciaRL5C466      PCMCTL_ID(PcmciaRicoh, 466, 0)
#define PcmciaRL5C475      PCMCTL_ID(PcmciaRicoh, 475, 0)
#define PcmciaRL5C476      PCMCTL_ID(PcmciaRicoh, 476, 0)
#define PcmciaRL5C478      PCMCTL_ID(PcmciaRicoh, 478, 0)

#define PcmciaTI1031       PCMCTL_ID(PcmciaTI, 1031, 0)
#define PcmciaTI1130       PCMCTL_ID(PcmciaTI, 1130, 0)
#define PcmciaTI1131       PCMCTL_ID(PcmciaTI, 1131, 0)
#define PcmciaTI1220       PCMCTL_ID(PcmciaTI, 1220, 0)
#define PcmciaTI1250       PCMCTL_ID(PcmciaTI, 1250, 0)
#define PcmciaTI1251B      PCMCTL_ID(PcmciaTI, 1251, 1)
#define PcmciaTI1450       PCMCTL_ID(PcmciaTI, 1450, 0)

#define PcmciaTopic95      PCMCTL_ID(PcmciaTopic, 95, 0)

#define PcmciaTrid82C194   PCMCTL_ID(PcmciaTrid, 194, 0)


//
// Vendor/Device Ids for pcmcia controllers we're interested in
//
#define PCI_CIRRUSLOGIC_VENDORID 0x1013
#define PCI_TI_VENDORID          0x104C
#define PCI_TOSHIBA_VENDORID     0x1179
#define PCI_RICOH_VENDORID       0x1180
#define PCI_DATABOOK_VENDORID    0x10B3
#define PCI_OPTI_VENDORID        0x1045
#define PCI_TRIDENT_VENDORID     0x1023
#define PCI_O2MICRO_VENDORID     0x1217
#define PCI_NEC_VENDORID         0x1033


#define PCI_CLPD6729_DEVICEID    0x1100
#define PCI_CLPD6832_DEVICEID    0x1110
#define PCI_CLPD6834_DEVICEID    0x1112

#define PCI_TI1130_DEVICEID      0xAC12
#define PCI_TI1031_DEVICEID      0xAC13
#define PCI_TI1131_DEVICEID      0xAC15
#define PCI_TI1250_DEVICEID      0xAC16
#define PCI_TI1220_DEVICEID      0xAC17
#define PCI_TI1450_DEVICEID      0xAC1B
#define PCI_TI1251B_DEVICEID     0xAC1F

#define PCI_TOPIC95_DEVICEID     0x060A

#define PCI_RL5C465_DEVICEID     0x0465
#define PCI_RL5C466_DEVICEID     0x0466
#define PCI_RL5C475_DEVICEID     0x0475
#define PCI_RL5C476_DEVICEID     0x0476
#define PCI_RL5C478_DEVICEID     0x0478

#define PCI_DB87144_DEVICEID     0x3106

#define PCI_OPTI82C814_DEVICEID  0xC814
#define PCI_OPTI82C824_DEVICEID  0xC824

#define PCI_TRID82C194_DEVICEID  0x0194

#define PCI_NEC66369_DEVICEID    0x003E



#endif  // _PCMCIA_DATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\inc\cb.h ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    cb.h

Abstract:

    This header contains generic cardbus definitions.

Author(s):

    Neil Sandlin (neilsa)

Revisions:

--*/

#ifndef _PCMCIA_CB_H_
#define _PCMCIA_CB_H_

//
// Cardbus register definitions
//

#define CARDBUS_EXCA_REGISTER_BASE  0x800

#define CARDBUS_SOCKET_EVENT_REG             0x0
#define CARDBUS_SOCKET_MASK_REG              0x4
#define CARDBUS_SOCKET_PRESENT_STATE_REG     0x8
#define CARDBUS_SOCKET_FORCE_EVENT_REG       0xc
#define CARDBUS_SOCKET_CONTROL_REG           0x10


//
// Masks for testing SOCKET_PRESENT_STATE Register
//

#define CARDBUS_CARDSTS                     0x1
#define CARDBUS_CD1                         0x2
#define CARDBUS_CD2                         0x4
#define CARDBUS_PWRCYCLE                    0x8
#define CARDBUS_16BIT_CARD                  0x10
#define CARDBUS_CB_CARD                     0x20
#define CARDBUS_READY                       0x40
#define CARDBUS_NOT_A_CARD                  0x80
#define CARDBUS_DATALOST                    0x100
#define CARDBUS_BAD_VCC_REQ                 0x200
#define CARDBUS_CARD_SUPPORTS_5V            0x400
#define CARDBUS_CARD_SUPPORTS_3V            0x800
#define CARDBUS_CARD_SUPPORTS_XV            0x1000
#define CARDBUS_CARD_SUPPORTS_YV            0x2000
#define CARDBUS_SOCKET_SUPPORTS_5V          0x10000000
#define CARDBUS_SOCKET_SUPPORTS_3V          0x20000000
#define CARDBUS_SOCKET_SUPPORTS_XV          0x40000000
#define CARDBUS_SOCKET_SUPPORTS_YV          0x80000000


//CardBus Registers
#define CBREG_SKTEVENT                  0x00
#define CBREG_SKTMASK                   0x04
#define CBREG_SKTSTATE                  0x08
#define CBREG_SKTFORCE                  0x0c
#define CBREG_SKTPOWER                  0x10

//TI CardBus Registers
#define CBREG_TI_SKT_POWER_MANAGEMENT   0x20
#define CBREG_TI_CLKCTRLLEN             0x00010000L
#define CBREG_TI_CLKCTRL                0x00000001L

//O2Micro CardBus Registers
#define CBREG_O2MICRO_ZVCTRL     0x20
#define ZVCTRL_ZV_ENABLE      0x01

//Socket Event Register bits
#define SKTEVENT_CSTSCHG                0x00000001L
#define SKTEVENT_CCD1                   0x00000002L
#define SKTEVENT_CCD2                   0x00000004L
#define SKTEVENT_CCD_MASK               (SKTEVENT_CCD1 | SKTEVENT_CCD2)
#define SKTEVENT_POWERCYCLE             0x00000008L
#define SKTEVENT_MASK                   0x0000000fL

//Socket Mask Register bits
#define SKTMSK_CSTSCHG                  0x00000001L
#define SKTMSK_CCD                      0x00000006L
#define SKTMSK_CCD1                     0x00000002L
#define SKTMSK_CCD2                     0x00000004L
#define SKTMSK_POWERCYCLE               0x00000008L

//Socket Present State Register bits
#define SKTSTATE_CSTSCHG                0x00000001L
#define SKTSTATE_CCD1                   0x00000002L
#define SKTSTATE_CCD2                   0x00000004L
#define SKTSTATE_CCD_MASK               (SKTSTATE_CCD1 | SKTSTATE_CCD2)
#define SKTSTATE_POWERCYCLE             0x00000008L
#define SKTSTATE_CARDTYPE_MASK          0x00000030L
#define SKTSTATE_R2CARD                 0x00000010L
#define SKTSTATE_CBCARD                 0x00000020L
#define SKTSTATE_OPTI_DOCK              0x00000030L
#define CARDTYPE(dw)       ((dw) & SKTSTATE_CARDTYPE_MASK)
#define SKTSTATE_CARDINT                0x00000040L
#define SKTSTATE_NOTACARD               0x00000080L
#define SKTSTATE_DATALOST               0x00000100L
#define SKTSTATE_BADVCCREQ              0x00000200L
#define SKTSTATE_5VCARD                 0x00000400L
#define SKTSTATE_3VCARD                 0x00000800L
#define SKTSTATE_XVCARD                 0x00001000L
#define SKTSTATE_YVCARD                 0x00002000L
#define SKTSTATE_CARDVCC_MASK    (SKTSTATE_5VCARD | SKTSTATE_3VCARD | \
                SKTSTATE_XVCARD | SKTSTATE_YVCARD)
#define SKTSTATE_5VSOCKET               0x10000000L
#define SKTSTATE_3VSOCKET               0x20000000L
#define SKTSTATE_XVSOCKET               0x40000000L
#define SKTSTATE_YVSOCKET               0x80000000L
#define SKTSTATE_SKTVCC_MASK     (SKTSTATE_5VSOCKET | \
                SKTSTATE_3VSOCKET | \
                SKTSTATE_XVSOCKET | \
                SKTSTATE_YVSOCKET)

//Socket Froce Register bits
#define SKTFORCE_CSTSCHG                0x00000001L
#define SKTFORCE_CCD1                   0x00000002L
#define SKTFORCE_CCD2                   0x00000004L
#define SKTFORCE_POWERCYCLE             0x00000008L
#define SKTFORCE_R2CARD                 0x00000010L
#define SKTFORCE_CBCARD                 0x00000020L
#define SKTFORCE_NOTACARD               0x00000080L
#define SKTFORCE_DATALOST               0x00000100L
#define SKTFORCE_BADVCCREQ              0x00000200L
#define SKTFORCE_5VCARD                 0x00000400L
#define SKTFORCE_3VCARD                 0x00000800L
#define SKTFORCE_XVCARD                 0x00001000L
#define SKTFORCE_YVCARD                 0x00002000L
#define SKTFORCE_CVSTEST                0x00004000L
#define SKTFORCE_5VSOCKET     0x10000000L
#define SKTFORCE_3VSOCKET     0x20000000L
#define SKTFORCE_XVSOCKET     0x40000000L
#define SKTFORCE_YVSOCKET     0x80000000L

//Power Control Register bits
#define SKTPOWER_VPP_CONTROL            0x00000007L
#define SKTPOWER_VPP_OFF                0x00000000L
#define SKTPOWER_VPP_120V               0x00000001L
#define SKTPOWER_VPP_050V               0x00000002L
#define SKTPOWER_VPP_033V               0x00000003L
#define SKTPOWER_VPP_0XXV               0x00000004L
#define SKTPOWER_VPP_0YYV               0x00000005L
#define SKTPOWER_VCC_CONTROL            0x00000070L
#define SKTPOWER_VCC_OFF                0x00000000L
#define SKTPOWER_VCC_050V               0x00000020L
#define SKTPOWER_VCC_033V               0x00000030L
#define SKTPOWER_VCC_0XXV               0x00000040L
#define SKTPOWER_VCC_0YYV               0x00000050L
#define SKTPOWER_STOPCLOCK              0x00000080L

//Misc. CardBus Constants
#define NUMWIN_BRIDGE                   4       //2 Mem + 2 IO
#define EXCAREG_OFFSET                  0x0800


//
// Number of times we attempt to look at a cardbus device which has
// invalid config space.
//
// This is so that for cards like the Adaptec SlimScsi
// on TI 1250, 1260 etc. power managed controllers,
// the config space needs to be read at least twice
// to ensure reliability
//

#define CARDBUS_CONFIG_RETRY_COUNT     5

//
// The pcmcia spec only specifies 20 msec for the reset setup delay, but
// I'm seeing machine/card combination that need a lot more.
// For example:
//    Gateway Solo 9100 with 3Com/Mhz 10/100 LAN CardBus card
//    Gateway 2000 Solo with a 3c575-TX
//    Toshiba Tecra 540CDT with (unknown)
//
#define PCMCIA_DEFAULT_CB_MODEM_READY_DELAY      1000000 // 1 sec

#define PCMCIA_DEFAULT_CB_RESET_WIDTH_DELAY      100     // 100 usec

//
// The pcmcia spec says this should be 50msec, but some hardware seems
// to need more (for example, a Thinkpad 600 with a Xircom realport modem)
//
#define PCMCIA_DEFAULT_CB_RESET_SETUP_DELAY      100000  // 100 msec

#endif  // _PCMCIA_CB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

ALT_PROJECT_TARGET=drivers2
BINPLACE_PLACEFILE=$(BASEDIR)\private\ntos\dd\pccard\placefil.txt
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\inc\card.h ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    card.h

Abstract:

    These are the structures used for various card related requests.

Author:

    Bob Rinne (BobRi) 3-Aug-1994
    Jeff McLeman (mcleman@zso.dec.com)
    Neil Sandlin (neilsa) June 1 1999

Revision History:

--*/
#ifndef _PCMCIA_CARD_H_
#define _PCMCIA_CARD_H_
//
// Define request types
//

#define IO_REQUEST          0x1
#define IRQ_REQUEST         0x2
#define CONFIGURE_REQUEST   0x3
#define MEM_REQUEST         0x4
#define DECONFIGURE_REQUEST 0x6

//
// Define an I/O range request structure
//

typedef struct _CARD_REQUEST_IO {

    struct _CARD_IO_ENTRY {
       ULONG  BasePort;
       ULONG  NumPorts;
       UCHAR  Attributes;
    } IoEntry[MAX_NUMBER_OF_IO_RANGES];
           
    USHORT  NumberOfRanges;

}CARD_REQUEST_IO, *PCARD_REQUEST_IO;

//
// Define I/O attributes
//

#define IO_WAIT_STATE_16   0x1
#define IO_SOURCE_16       0x2
#define IO_ZERO_WAIT_8     0x4
#define IO_DATA_PATH_WIDTH 0x8


//
// Define an IRQ Request structure
//

typedef struct _CARD_REQUEST_IRQ {

    USHORT Attributes;
    UCHAR  AssignedIRQ;
    UCHAR  ReadyIRQ;
    UCHAR  IRQInfo1;
    UCHAR  IRQInfo2;

}CARD_REQUEST_IRQ, *PCARD_REQUEST_IRQ;

//
// define the IRQ request attributes
//

#define IRQ_EXCLUSIVE    0x00
#define IRQ_TIME_SHARED  0x01
#define IRQ_DYN_SHARED   0x02
#define IRQ_RESERVED     0x03

#define IRQ_FORCE_PULSED 0x04
#define IRQ_FIRST_SHARED 0x08
#define IRQ_PULSE_ALLOC  0x10

//
// define a configuration request
//

typedef struct _CARD_REQUEST_CONFIG {

    ULONG  ConfigBase;
    USHORT Attributes;
    UCHAR  RegisterWriteMask;
    UCHAR  InterfaceType;
    UCHAR  ConfigIndex;
    UCHAR  CardConfiguration;
    UCHAR  PinPlacement;
    UCHAR  SocketCopyRegister;
    UCHAR  ExtendedStatusRegister;
    ULONG  IoBaseRegister;
    UCHAR  IoLimitRegister;

} CARD_REQUEST_CONFIG, *PCARD_REQUEST_CONFIG;

//
// Define associated bits for above
//

//
// InterfaceType
//

#define CONFIG_INTERFACE_MEM    0x0
#define CONFIG_INTERFACE_IO_MEM 0x1

//
// RegisterWriteMask is a bit mask that controls what configuration registers are
// modified in the CONFIGURE_REQUEST call.
//

#define REGISTER_WRITE_CONFIGURATION_INDEX 0x01    /* Configuration Option Register          */
#define REGISTER_WRITE_CARD_CONFIGURATION  0x02    /* Card Configuration and Status Register */
#define REGISTER_WRITE_PIN_PLACEMENT       0x04    /* Pin Placement Register   */
#define REGISTER_WRITE_COPY_REGISTER       0x08    /* Socket and Copy Register */
#define REGISTER_WRITE_EXTENDED_STATUS     0x10    /* Extended Status Register */
#define REGISTER_WRITE_IO_BASE             0x20    /* I/O Base Register        */
#define REGISTER_WRITE_IO_LIMIT            0x40    /* I/O Limit Register       */

//
// define a request memory window structure
//

typedef struct _CARD_REQUEST_MEM {

    struct _CARD_MEMORY_ENTRY {
        ULONG   BaseAddress;
        ULONG   HostAddress;
        ULONG   WindowSize;
        UCHAR   AttributeMemory;
        BOOLEAN WindowDataSize16;
        UCHAR   WaitStates;
    } MemoryEntry[MAX_NUMBER_OF_MEMORY_RANGES];
    
    USHORT  NumberOfRanges;
    USHORT  Attributes;
    UCHAR   AccessSpeed;

}CARD_REQUEST_MEM, *PCARD_REQUEST_MEM;

//
// Defined attribute bits for request_mem
//

#define MEM_ATTRIBUTE          0x02
#define MEM_ENABLED            0x04
#define MEM_DATA_PATH_WIDTH_16 0x08
#define MEM_PAGED              0x10
#define MEM_SHARED             0x20
#define MEM_FIRST_SHARED       0x40
#define MEM_BIND_SPECIFIC      0x80
#define MEM_CRD_OFFSET_SIZED   0x100

#define MEM_SPEED_CODE         0x07
#define MEM_SPEED_EXP          0x07
#define MEM_SPEED_MANTISSA     0x78
#define MEM_WAIT               0x80

#define MEM_SPEED_250          0x02
#define MEM_SPEED_200          0x04
#define MEM_SPEED_150          0x08
#define MEM_SPEED_100          0x10

typedef struct _CARD_TUPLE_REQUEST {
    PVOID  SocketPointer;
    PUCHAR Buffer;
    USHORT BufferSize;
    USHORT Socket;
} CARD_TUPLE_REQUEST, *PCARD_TUPLE_REQUEST;

//
// Card configuration request packet.
//

typedef struct _CARD_REQUEST {
    USHORT  RequestType;
    union {
        CARD_REQUEST_IRQ    Irq;
        CARD_REQUEST_CONFIG Config;
        CARD_REQUEST_MEM    Memory;
        CARD_REQUEST_IO     Io;
    } u;
} CARD_REQUEST, *PCARD_REQUEST;

#endif //_PCMCIA_CARD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\inc\dbsocket.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    dbsocket.h

Abstract:

    Definitions and structures for Databook TCIC support.
    
Author(s):
        John Keys - Databook Inc. 7-Apr-1995

Revisions:
--*/


#ifndef _dbsocket_h_        // prevent multiple includes 
#define _dbsocket_h_

#include "pcmcia.h"

typedef struct _DBSOCKET {
    SOCKET  skt;                /* PCMCIA.H SOCKET structure        */
    UCHAR   busyLed;            /* Busy LED state                   */
    USHORT  timerStarted;       /* indicate if the BusyLED timer up */
    ULONG   physPortAddr;       /* unmapped port address            */
    USHORT  chipType;           /* TCIC silicon ID                  */
    USHORT  dflt_vcc5v;         /* default 5V Vcc bits              */
    USHORT  dflt_wctl;          /* default AR_WCTL bits             */
    USHORT  dflt_syscfg;        /* default AR_SYSCFG bits           */
    USHORT  dflt_ilock;         /* default AR_ILOCK bits            */
    USHORT  dflt_wrmctl;        /* default IR_WRMCTL bits           */
    USHORT  dflt_scfg1;         /* default IR_SCFG1 bits            */
    USHORT  clkdiv;             /* clock rate divisor (SHFT CNT.)   */
    UCHAR   IRQMapTbl[16];      /* IRQ map                          */
    UCHAR   niowins;            /* number of io windows             */
    UCHAR   nmemwins;           /* number of mem windows            */
    }DBSOCKET, *PDBSOCKET; 

    
/* Codes for various useful bits of information:
 */
#define TCIC_IS270      0x01    /* New TCIC at base+0x400 */
#define TCIC_ALIAS800   0x02    /* Aliased at base+0x800  */
#define TCIC_IS140      0x04    /* Aliased at base+0x10   */
#define TCIC_ALIAS400   0x08    /* Aliased at base+0x400  */

#define TCIC_ALIAS  1
#define TCIC_NOALIAS    2
#define TCIC_NONE   0

/* For tagging wonky-looking IRQ lines:
 */
#define TCIC_BADIRQ 0x80
#define ICODEMASK   0x7f

/* Memory offsets used in looking for TCICs at fixed distances from a base
 * address:
 */
#define TCIC_OFFSET_400     0x400
#define TCIC_OFFSET_800     0x800
#define TCIC_ALIAS_OFFSET   0x010


/* 
 * Constants for power tables 
 */
#define SPWR_VCC_SUPPLY 0x8000
#define SPWR_VPP_SUPPLY 0x6000
#define SPWR_ALL_SUPPLY (SPWR_VCC_SUPPLY | SPWR_VPP_SUPPLY)

#define SPWR_0p0V   0
#define SPWR_5p0V   50
#define SPWR_12p0V  120

#define PWRTBL_WORDS    9
#define PWRTBL_SIZE (PWRTBL_WORDS * sizeof(unsigned short))


/*
 * Fixed point integer type and handler macros
 */
typedef unsigned long FIXEDPT;
#define FIXEDPT_FRACBITS 8
#define INT2FXP(n)  (((FIXEDPT)(n)) << FIXEDPT_FRACBITS)

#define ISx84(x) (((x) == SILID_DB86084_1) || ((x) == SILID_DB86084A) || ((x) == SILID_DB86184_1))
#define ISPNP(x) (((x) == SILID_DB86084_1) || ((x) == SILID_DB86084A) || ((x) == SILID_DB86184_1))

/*
 *Chip Properties - matches capabilites to a Chip ID 
 */

typedef struct ChipProps_t {
    USHORT  chip_id;        /* The Silicon ID for this chip     */
    PUSHORT privpwrtbl;     /* the power table that applies     */
    UCHAR   reserved_1;     /* Alignment byte                   */
    PUCHAR  irqcaps;        /* table of possible IRQs           */
    USHORT  maxsockets;     /* max # of skts for this chip      */
    USHORT  niowins;        /* # I/O wins supported             */
    USHORT  nmemwins;       /* # mem wins supported             */
    USHORT  fprops;         /* Various properties flags         */ 
#   define fIS_PNP     1    /* chip is Plug-n-Play              */
#   define fEXTBUF_CHK 2    /* chip may need ext buffering check*/
#   define fSKTIRQPIN  4    /* chip has socket IRQ pin          */
#   define fINVALID    8    /* Can't get good flags             */
    }CHIPPROPS;


/* MODE_AR_SYSCFG must have, with j = ***read*** (***, R_AUX)
   and k = (j>>9)&7:
    if (k&4) k == 5
    And also:
    j&0x0f is none of 2, 8, 9, b, c, d, f
        if (j&8) must have (j&3 == 2)
        Can't have j==2
 */
#define INVALID_AR_SYSCFG(x) ((((x)&0x1000) && (((x)&0x0c00) != 0x0200)) \
                || (((((x)&0x08) == 0) || (((x)&0x03) == 2)) \
                && ((x) != 0x02)))
/* AR_ILOCK must have bits 6 and 7 the same:
 */
#define INVALID_AR_ILOCK(x) ((((x)&0xc0) != 0) && (((x)&0xc0) != 0xc0))

/* AR_TEST has some reserved bits:
 */
#define INVALID_AR_TEST(x)  (((x)&0154) != 0)

/* Wait state codes */
#define WCTL_300NS  8

/**** end of dbsocket.H ****/
#endif /* _dbsocket_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\inc\debug.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This header provides debugging support prototypes and macros

Author:

    Neil Sandlin (neilsa) 10-Aug-98
      - code merged from mf.sys and pcmcia.sys

Revision History:


--*/


#if !defined(_DEBUG_)
#define DEBUG

#if DBG

typedef struct _PCMCIA_STRING_MAP {
    ULONG Id;
    PCHAR String;
} PCMCIA_STRING_MAP, *PPCMCIA_STRING_MAP;

//
// Debug globals
//

extern ULONG PcmciaDebugMask;
extern PCMCIA_STRING_MAP PcmciaDbgPnpIrpStringMap[];
extern PCMCIA_STRING_MAP PcmciaDbgPoIrpStringMap[];
extern PCMCIA_STRING_MAP PcmciaDbgDeviceRelationStringMap[];
extern PCMCIA_STRING_MAP PcmciaDbgSystemPowerStringMap[];
extern PCMCIA_STRING_MAP PcmciaDbgDevicePowerStringMap[];
extern PPCMCIA_STRING_MAP PcmciaDbgStatusStringMap;
extern PCMCIA_STRING_MAP PcmciaDbgFdoPowerWorkerStringMap[];
extern PCMCIA_STRING_MAP PcmciaDbgPdoPowerWorkerStringMap[];
extern PCMCIA_STRING_MAP PcmciaDbgSocketPowerWorkerStringMap[];
extern PCMCIA_STRING_MAP PcmciaDbgConfigurationWorkerStringMap[];
extern PCMCIA_STRING_MAP PcmciaDbgTupleStringMap[];
extern PCMCIA_STRING_MAP PcmciaDbgWakeStateStringMap[];

//
// Debug prototypes
//

PCHAR
PcmciaDbgLookupString(
    IN PPCMCIA_STRING_MAP Map,
    IN ULONG Id
    );


VOID
PcmciaDebugPrint(
                ULONG  DebugMask,
                PCCHAR DebugMessage,
                ...
                );

VOID
PcmciaDumpSocket(
   IN PSOCKET Socket
   );

VOID
PcmciaWriteTraceEntry(
   IN PSOCKET Socket,
   IN ULONG Context
   );

//
// Debug macros
//
#define DebugPrint(X) PcmciaDebugPrint X

#define DUMP_SOCKET(Socket) PcmciaDumpSocket(Socket)

#define TRACE(Socket, Context) PcmciaWriteTraceEntry(Socket, Context)

#define STATUS_STRING(_Status)                                              \
    (_Status) == STATUS_SUCCESS ?                                           \
        "STATUS_SUCCESS" : PcmciaDbgLookupString(PcmciaDbgStatusStringMap, (_Status))

#define PNP_IRP_STRING(_Irp)                                                \
    PcmciaDbgLookupString(PcmciaDbgPnpIrpStringMap, (_Irp))

#define PO_IRP_STRING(_Irp)                                                 \
    PcmciaDbgLookupString(PcmciaDbgPoIrpStringMap, (_Irp))

#define RELATION_STRING(_Relation)                                          \
    PcmciaDbgLookupString(PcmciaDbgDeviceRelationStringMap, (_Relation))

#define SYSTEM_POWER_STRING(_State)                                         \
    PcmciaDbgLookupString(PcmciaDbgSystemPowerStringMap, (_State))

#define DEVICE_POWER_STRING(_State)                                         \
    PcmciaDbgLookupString(PcmciaDbgDevicePowerStringMap, (_State))

#define FDO_POWER_WORKER_STRING(_State)                                    \
    PcmciaDbgLookupString(PcmciaDbgFdoPowerWorkerStringMap, (_State))

#define PDO_POWER_WORKER_STRING(_State)                                    \
    PcmciaDbgLookupString(PcmciaDbgPdoPowerWorkerStringMap, (_State))

#define SOCKET_POWER_WORKER_STRING(_State)                                 \
    PcmciaDbgLookupString(PcmciaDbgSocketPowerWorkerStringMap, (_State))

#define CONFIGURATION_WORKER_STRING(_State)                                 \
    PcmciaDbgLookupString(PcmciaDbgConfigurationWorkerStringMap, (_State))

#define TUPLE_STRING(_Tuple)                                                \
    PcmciaDbgLookupString(PcmciaDbgTupleStringMap, (_Tuple))

#define WAKESTATE_STRING(_State)                                                \
    PcmciaDbgLookupString(PcmciaDbgWakeStateStringMap, (_State))

//
// Debug mask flags
//
#define PCMCIA_DEBUG_ALL       0xFFFFFFFF
#define PCMCIA_DEBUG_FAIL      0x00000001
#define PCMCIA_DEBUG_INFO      0x00000002
#define PCMCIA_DEBUG_PNP       0x00000004
#define PCMCIA_DEBUG_POWER     0x00000008
#define PCMCIA_DEBUG_SOCKET    0x00000010
#define PCMCIA_DEBUG_CONFIG    0x00000020
#define PCMCIA_DEBUG_TUPLES    0x00000040
#define PCMCIA_DEBUG_RESOURCES 0x00000080
#define PCMCIA_DEBUG_ENUM      0x00000100
#define PCMCIA_DEBUG_INTERFACE 0x00001000
#define PCMCIA_DEBUG_IOCTL     0x00002000
#define PCMCIA_DEBUG_DPC       0x00004000
#define PCMCIA_DEBUG_ISR       0x00008000
#define PCMCIA_PCCARD_READY    0x00010000
#define PCMCIA_DEBUG_DETECT    0x00020000
#define PCMCIA_COUNTERS        0x00040000
#define PCMCIA_DEBUG_IRQMASK   0x00080000
#define PCMCIA_DUMP_SOCKET     0x00100000

//
// Structures
//

typedef struct _TRACE_ENTRY {

   ULONG Context;
   ULONG CardBusReg[5];
   UCHAR ExcaReg[70];

} TRACE_ENTRY, *PTRACE_ENTRY;

#else

//
// !defined DBG
//

#define DebugPrint(X)
#define DUMP_SOCKET(Socket)
#define PDO_TRACE(PdoExt, Context)
#define STATUS_STRING(_Status)      ""
#define PNP_IRP_STRING(_Irp)        ""
#define PO_IRP_STRING(_Irp)         ""
#define RELATION_STRING(_Relation)  ""
#define SYSTEM_POWER_STRING(_State) ""
#define DEVICE_POWER_STRING(_State) ""

#endif // DBG

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\inc\exca.h ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    exca.h

Abstract:

    This module defines the 82365SL chip, and subsequent chips based on it.

Author(s):

    Jeff McLeman (mcleman@zso.dec.com)

Revisions:
    Added misc stuff
         Ravisankar Pudipeddi (ravisp) 1 Dec 1996

--*/

#ifndef _PCMCIA_EXCA_H_
#define _PCMCIA_EXCA_H_
//
// For initial debug
//

#define PCMCIA_PROTO 1

//
// Memory window sizes that will be allocated
// for this controller - to map card memory
//
#define PCIC_WINDOW_SIZE                 0x1000  //(4K)
#define PCIC_WINDOW_ALIGNMENT            0x1000  //(4K)

//
// Define on chip registers
//

#define PCIC_IDENT             0x00
#define PCIC_STATUS            0x01
#define PCIC_PWR_RST           0x02
#define PCIC_INTERRUPT         0x03
#define PCIC_CARD_CHANGE       0x04
#define PCIC_CARD_INT_CONFIG   0x05
#define PCIC_ADD_WIN_ENA       0x06

#define PCIC_IO_CONTROL        0x07
#define PCIC_IO_ADD0_STRT_L    0x08
#define PCIC_IO_ADD0_STRT_H    0x09
#define PCIC_IO_ADD0_STOP_L    0x0a
#define PCIC_IO_ADD0_STOP_H    0x0b
#define PCIC_IO_ADD1_STRT_L    0x0c
#define PCIC_IO_ADD1_STRT_H    0x0d
#define PCIC_IO_ADD1_STOP_L    0x0e
#define PCIC_IO_ADD1_STOP_H    0x0f

#define PCIC_MEM_ADD0_STRT_L   0x10
#define PCIC_MEM_ADD0_STRT_H   0x11
#define PCIC_MEM_ADD0_STOP_L   0x12
#define PCIC_MEM_ADD0_STOP_H   0x13
#define PCIC_CRDMEM_OFF_ADD0_L 0x14
#define PCIC_CRDMEM_OFF_ADD0_H 0x15

#define PCIC_MEM_ADD1_STRT_L   0x18
#define PCIC_MEM_ADD1_STRT_H   0x19
#define PCIC_MEM_ADD1_STOP_L   0x1a
#define PCIC_MEM_ADD1_STOP_H   0x1b
#define PCIC_CRDMEM_OFF_ADD1_L 0x1c
#define PCIC_CRDMEM_OFF_ADD1_H 0x1d


#define PCIC_MEM_ADD2_STRT_L   0x20
#define PCIC_MEM_ADD2_STRT_H   0x21
#define PCIC_MEM_ADD2_STOP_L   0x22
#define PCIC_MEM_ADD2_STOP_H   0x23
#define PCIC_CRDMEM_OFF_ADD2_L 0x24
#define PCIC_CRDMEM_OFF_ADD2_H 0x25

#define PCIC_MEM_ADD3_STRT_L   0x28
#define PCIC_MEM_ADD3_STRT_H   0x29
#define PCIC_MEM_ADD3_STOP_L   0x2a
#define PCIC_MEM_ADD3_STOP_H   0x2b
#define PCIC_CRDMEM_OFF_ADD3_L 0x2c
#define PCIC_CRDMEM_OFF_ADD3_H 0x2d

#define PCIC_MEM_ADD4_STRT_L   0x30
#define PCIC_MEM_ADD4_STRT_H   0x31
#define PCIC_MEM_ADD4_STOP_L   0x32
#define PCIC_MEM_ADD4_STOP_H   0x33
#define PCIC_CRDMEM_OFF_ADD4_L 0x34
#define PCIC_CRDMEM_OFF_ADD4_H 0x35


#define PCIC_IO_WIN0_OFFSET_L  0x36
#define PCIC_IO_WIN0_OFFSET_H  0x37
#define PCIC_IO_WIN1_OFFSET_L  0x38
#define PCIC_IO_WIN1_OFFSET_H  0x39

//
// TI registers
//

#define PCIC_TI_CARD_DETECT        0x16
#define PCIC_TI_GLOBAL_CONTROL     0x1e

//
// Topic registers
//
#define PCIC_TO_ADDITIONAL_GENCTRL 0x16
#define PCIC_TO_MMI_CTRL           0x3c
#define PCIC_TO_FUNC_CTRL          0x3e

//
// RICOH registers
//

#define PCIC_RICOH_MISC_CTRL1      0x2f
//
// Other Cirrus Logic registers
//
#define PCIC_CL_MISC_CTRL1      0x16
#define PCIC_CL_MISC_CTRL2      0x1e
#define PCIC_CL_CHIP_INFO      0x1f
#define PCIC_CL_MISC_CTRL3       0x125
#define PCIC_CL_MASK_REV       0x134
#define PCIC_CL_PRODUCT_ID     0x135
#define PCIC_CL_DEV_CAP_A      0x136
#define PCIC_CL_DEV_CAP_B      0x137
#define PCIC_CL_DEV_IMP_A      0x138
#define PCIC_CL_DEV_IMP_B      0x139
#define PCIC_CL_DEV_IMP_C      0x13a
#define PCIC_CL_DEV_IMP_D      0x13b

//Cirrus Logic Miscellaneous Control 1 Register bits
#define CL_MC1_5V_DETECT            0x01
#define CL_MC1_MM_ENABLE            0x01
#define CL_MC1_VCC_33V              0x02
#define CL_MC1_PULSE_MGMT_INT       0x04
#define CL_MC1_PULSE_SYSTEM_IRQ     0x08
#define CL_MC1_SPKR_ENABLE          0x10
#define CL_MC1_INPACK_ENABLE        0x80

//Cirrus Logic Miscellaneous Control 2 Register bits
#define CL_MC2_BFS                  0x01
#define CL_MC2_LPDYNAMIC_MODE       0x02
#define CL_MC2_SUSPEND              0x04
#define CL_MC2_5VCORE               0x08
#define CL_MC2_DRIVELED_ENABLE      0x10
#define CL_MC2_TIMERCLK_DIVIDE      0x10
#define CL_MC2_3STATE_BIT7          0x20
#define CL_MC2_DMA_SYSTEM           0x40
#define CL_MC2_IRQ15_RIOUT          0x80

//Cirrus Logic Miscellaneous Control 3 Register bits
#define CL_MC3_INTMODE_MASK             0x03
#define CL_MC3_INTMODE_SERIAL           0x00
#define CL_MC3_INTMODE_EXTHW            0x01
#define CL_MC3_INTMODE_PCIWAY           0x02
#define CL_MC3_INTMODE_PCI              0x03    //default
#define CL_MC3_PWRMODE_MASK             0x0c
#define CL_MC3_HWSUSPEND_ENABLE         0x10

//
// Cirrus Logic extension register 1
//
#define PCIC_CIRRUS_EXTENDED_INDEX   0x2E
#define PCIC_CIRRUS_INDEX_REG        0x2F
#define PCIC_CIRRUS_EXTENSION_CTRL_1 0x03



//                
// Databook registers
//
#define PCIC_DBK_ZV_ENABLE    0x3b

//
// Opti registers
//
#define PCIC_OPTI_GLOBAL_CTRL 0x1e


//
// This is only for cardbus controllers
//
#define PCIC_PAGE_REG         0x40

//
//
// Define offset to socket A and B
//

#define PCIC_SOCKETA_OFFSET    0x00
#define PCIC_SOCKETB_OFFSET    0x40


#define PCIC_REVISION         0x82
#define PCIC_REVISION2        0x83
#define PCIC_REVISION3        0x84
#define PCIC_SCM_REVISION     0xAB

#define SOCKET1               PCIC_SOCKETA_OFFSET
#define SOCKET2               PCIC_SOCKETB_OFFSET

#define CARD_DETECT_1         0x4
#define CARD_DETECT_2         0x8

#define CARD_IN_SOCKET_A      0x1
#define CARD_IN_SOCKET_B      0x2

#define CARD_TYPE_MODEM       0x1
#define CARD_TYPE_ENET        0x2
#define CARD_TYPE_DISK        0x3

//
// For Cirrus Logic PCI controllers
//
#define PCIC_CIRRUS_INTA      0x3
#define PCIC_CIRRUS_INTB      0x4
#define PCIC_CIRRUS_INTC      0x5
#define PCIC_CIRRUS_INTD      0x7

//
// Support IRQs:
// 15,14, , ,  11,10, 9, ,  7, ,5,4,  3, , ,
// 1  1  0  0   1  1  1 0   1 0 1 1   1 0 0 0
//
#define PCIC_SUPPORTED_INTERRUPTS 0xCEB8

//
// Support IRQs:
// 15,14, , ,  11,10, 9, ,  7, ,5,4,  3, , ,
// 0  1  0  0   0  1  0 0   1 0 1 1   1 0 0 0
//
#define CL_SUPPORTED_INTERRUPTS 0x44B8

//
// Support IRQs for NEC_98:
//   ,  ,  ,12,   ,10,  ,  ,    ,6 ,5 ,  ,  3 ,  ,  ,
// 0  0  0  1   0  1  0  0    0  1  1  0    1  0  0  0
//
#define PCIC_SUPPORTED_INTERRUPTS_NEC_98 0x1468



/*** 16-Bit Socket Constants
 */

//Device IDs for various controllers
#define DEVID_VALID_LO        0x82
#define DEVID_CL        0x82
#define DEVID_VADEM        0x83
#define DEVID_RICOH        0x83
#define DEVID_GEN_PCIC        0x84
#define DEVID_IBM_KING        0x8a
#define DEVID_OPTI_82C824     0x87
#define DEVID_OPTI_82C852     0x8f

//TI PCI-1130 specific registers
#define PCIC_TI_MEMWIN_PAGE      0x40

//ID and Revision Register bits
#define IDREV_REV_MASK                  0x0f
#define IDREV_IFID_MASK                 0xc0
#define IDREV_IFID_IO                   0x00
#define IDREV_IFID_MEM                  0x40
#define IDREV_IFID_IOMEM                0x80

//Interface Status Register bits
#define IFS_BVD_MASK                    0x03
#define IFS_BVD1                        0x01
#define IFS_BVD2                        0x02
#define IFS_CD_MASK                     0x0c
#define IFS_CD1                         0x04
#define IFS_CD2                         0x08
#define IFS_WP                          0x10
#define IFS_RDYBSY                      0x20
#define IFS_CARDPWR_ACTIVE              0x40
#define IFS_VPP_VALID                   0x80

//Power and RESETDRV Control Register bits

#define PC_VPP1_MASK                    0x03
#define PC_VPP2_MASK                    0x0c
#define PC_CARDPWR_ENABLE               0x10
#define PC_AUTOPWR_ENABLE               0x20
#define PC_RESETDRV_DISABLE             0x40
#define PC_OUTPUT_ENABLE                0x80

#define PC_PWRON_BITS                   (PC_OUTPUT_ENABLE | PC_AUTOPWR_ENABLE)

#define PC_VPP_NO_CONNECT     0x00
#define PC_VPP_SETTO_VCC      0x01
#define PC_VPP_SETTO_VPP      0x02
#define PC_VPP_RESERVED       0x03

#define PC_VPP_VLSI_MASK      0x03
#define PC_VPP_VLSI_NO_CONNECT      0x00
#define PC_VPP_VLSI_050V      0x01
#define PC_VPP_VLSI_120V      0x02
#define PC_VPP_VLSI_RESERVED     0x03

#define PC_VCC_TOPIC_033V     0x08

#define PC_VCC_VLSI_MASK      0x18
#define PC_VCC_VLSI_NO_CONNECT      0x00
#define PC_VCC_VLSI_RESERVED     0x08
#define PC_VCC_VLSI_050V      0x10
#define PC_VCC_VLSI_033V      0x18

#define PC_VPP_KING_MASK      0x03
#define PC_VPP_KING_NO_CONNECT      0x00
#define PC_VPP_KING_050V      0x01
#define PC_VPP_KING_120V      0x02
#define PC_VPP_KING_SETTO_VCC    0x03

#define PC_VCC_KING_MASK      0x0c
#define PC_VCC_KING_NO_CONNECT      0x00
#define PC_VCC_KING_050V      0x04
#define PC_VCC_KING_RESERVED     0x08
#define PC_VCC_KING_033V      0x0c

#define PC_VPP_OPTI_MASK      0x03
#define PC_VPP_OPTI_NO_CONNECT      0x00
#define PC_VPP_OPTI_SETTO_VCC    0x01
#define PC_VPP_OPTI_120V      0x02
#define PC_VPP_OPTI_0V        0x03

#define PC_VCC_OPTI_MASK      0x18
#define PC_VCC_OPTI_NO_CONNECT      0x00
#define PC_VCC_OPTI_033V      0x08
#define PC_VCC_OPTI_050V      0x10
#define PC_VCC_OPTI_0XXV      0x18

//Interrupt and General Control Register bits
#define IGC_IRQ_MASK                    0x0f
#define IGC_INTR_ENABLE                 0x10
#define IGC_PCCARD_IO                   0x20
#define IGC_PCCARD_RESETLO              0x40
#define IGC_RINGIND_ENABLE              0x80

//Card Status Change Register bits
#define CSC_CHANGE_MASK                 0x0f
#define CSC_BATT_DEAD                   0x01
#define CSC_BATT_WARNING                0x02
#define CSC_BATT_MASK         (CSC_BATT_DEAD | CSC_BATT_WARNING)
#define CSC_READY_CHANGE                0x04
#define CSC_CD_CHANGE                   0x08

//Card Status Change Interrupt Configuration Register bits
#define CSCFG_ENABLE_MASK               0x0f
#define CSCFG_BATT_DEAD                 0x01
#define CSCFG_BATT_WARNING              0x02
#define CSCFG_BATT_MASK       (CSCFG_BATT_DEAD | CSCFG_BATT_WARNING)
#define CSCFG_READY_ENABLE              0x04
#define CSCFG_CD_ENABLE                 0x08
#define CSCFG_IRQ_MASK                  0xf0

//Address Window Enable Register bits
#define WE_MEM0_ENABLE                  0x01
#define WE_MEM1_ENABLE                  0x02
#define WE_MEM2_ENABLE                  0x04
#define WE_MEM3_ENABLE                  0x08
#define WE_MEM4_ENABLE                  0x10
#define WE_MEMWIN_MASK        (WE_MEM0_ENABLE | WE_MEM1_ENABLE | \
                WE_MEM2_ENABLE | WE_MEM3_ENABLE | \
                WE_MEM4_ENABLE)
#define WE_MEMCS16_DECODE               0x20
#define WE_IO0_ENABLE                   0x40
#define WE_IO1_ENABLE                   0x80
#define WE_IOWIN_MASK         (WE_IO0_ENABLE | WE_IO1_ENABLE)

//I/O Control Register bits
#define IOC_IO0_MASK                    0x0f
#define IOC_IO0_DATASIZE                0x01
#define IOC_IO0_IOCS16                  0x02
#define IOC_IO0_ZEROWS                  0x04
#define IOC_IO0_WAITSTATE               0x08
#define IOC_IO1_MASK                    0xf0
#define IOC_IO1_DATASIZE                0x10
#define IOC_IO1_IOCS16                  0x20
#define IOC_IO1_ZEROWS                  0x40
#define IOC_IO1_WAITSTATE               0x80

//Card Detection and General Control Register
#define CDGC_SW_DET_INT       0x20

//Memory Window Start Register bits
#define MEMBASE_ADDR_MASK               0x0fff
#define MEMBASE_ZEROWS                  0x4000
#define MEMBASE_16BIT                   0x8000

//Memory Window Stop Register bits
#define MEMEND_ADDR_MASK                0x0fff
#define MEMEND_WS_MASK                  0xc000

//Memory Window Offset Register bits
#define MEMOFF_ADDR_MASK                0x3fff
#define MEMOFF_REG_ACTIVE               0x4000
#define MEMOFF_WP                       0x8000

//
//Masks used to calculate 2's-complement based offset
#define OFFSETCALC_BASE_MASK            0x00FFFFFF
#define OFFSETCALC_OFFSET_MASK          0x03FFFFFF

//Cirrus Logic Miscellaneous Control 1 Register bits
#define CL_MC1_5V_DETECT      0x01
#define CL_MC1_MM_ENABLE      0x01
#define CL_MC1_VCC_33V        0x02
#define CL_MC1_PULSE_MGMT_INT    0x04
#define CL_MC1_PULSE_SYSTEM_IRQ     0x08
#define CL_MC1_SPKR_ENABLE    0x10
#define CL_MC1_INPACK_ENABLE     0x80

//Cirrus Logic Miscellaneous Control 2 Register bits
#define CL_MC2_BFS         0x01
#define CL_MC2_LPDYNAMIC_MODE    0x02
#define CL_MC2_SUSPEND        0x04
#define CL_MC2_5VCORE         0x08
#define CL_MC2_DRIVELED_ENABLE      0x10
#define CL_MC2_TIMERCLK_DIVIDE      0x10
#define CL_MC2_3STATE_BIT7    0x20
#define CL_MC2_DMA_SYSTEM     0x40
#define CL_MC2_IRQ15_RIOUT    0x80

//Cirrus Logic Miscellaneous Control 3 Register bits
#define CL_MC3_INTMODE_MASK             0x03
#define CL_MC3_INTMODE_SERIAL           0x00
#define CL_MC3_INTMODE_EXTHW            0x01
#define CL_MC3_INTMODE_PCIWAY           0x02
#define CL_MC3_INTMODE_PCI              0x03    //default
#define CL_MC3_PWRMODE_MASK             0x0c
#define CL_MC3_HWSUSPEND_ENABLE         0x10
#define CL_MC3_MM_ARM         0x80

//Cirrus Logic Chip Info Register bits
#define CL_CI_REV_MASK        0x1e
#define CL_CI_DUAL_SOCKET     0x20
#define CL_CI_CHIP_ID         0xc0

//Cirrus Logic Mask Revision Register bits
#define CL_MSKREV_MASK        0x0f

//Cirrus Logic Product ID Register bits
#define CL_PID_PRODUCT_CODE_MASK 0x0f
#define CL_PID_FAMILY_CODE_MASK     0xf0

//Cirrus Logic Device Capability Register A bits
#define CL_CAPA_NUMSKT_MASK      0x03
#define CL_CAPA_IDE_INTERFACE    0x04
#define CL_CAPA_SLAVE_DMA     0x08
#define CL_CAPA_CPSTB_CAPABLE    0x20
#define CL_CAPA_PER_SKT_LED      0x80

//Cirrus Logic Device Capability Register B bits
#define CL_CAPB_CARDBUS_CAPABLE     0x01
#define CL_CAPB_LOCK_SUPPORT     0x02
#define CL_CAPB_CLKRUN_SUPPORT      0x04
#define CL_CAPB_EXT_DEF       0x80

//Cirrus Logic Device Implementation Register A bits
#define CL_IMPA_NUMSKT_MASK      0x03
#define CL_IMPA_SLAVE_DMA     0x04
#define CL_IMPA_VS1_VS2       0x08
#define CL_IMPA_GPSTB_A       0x10
#define CL_IMPA_GPSTB_B       0x20
#define CL_IMPA_HW_SUSPEND    0x40
#define CL_IMPA_RI_OUT        0x80

//Cirrus Logic Device Implementation Register B bits
#define CL_IMPB_033_VCC       0x01
#define CL_IMPB_050_VCC       0x02
#define CL_IMPB_0YY_VCC       0x04
#define CL_IMPB_0XX_VCC       0x08
#define CL_IMPB_120_VPP       0x10
#define CL_IMPB_VPP_VCC_1A    0x20
#define CL_IMPB_RFRATED_SKT      0x40

//Cirrus Logic Device Implementation Register C bits
#define CL_IMPC_LED        0x01
#define CL_IMPC_PER_SKT_LED      0x02
#define CL_IMPC_SPK        0x04
#define CL_IMPC_ZVP_A         0x08
#define CL_IMPC_ZVP_B         0x10

//Cirrus Logic Device Implementation Register D bits
#define CL_IMPD_CLKRUN        0x01
#define CL_IMPD_LOCK       0x02
#define CL_IMPD_EXT_CLK       0x40

//Cirrus Logic Extension Registers
#define CLEXTREG_EXTCTRL_1    0x03
#define CLEXTREG_MEMWIN0_HIADDR     0x05
#define CLEXTREG_MEMWIN1_HIADDR     0x06
#define CLEXTREG_MEMWIN2_HIADDR     0x07
#define CLEXTREG_MEMWIN3_HIADDR     0x08
#define CLEXTREG_MEMWIN4_HIADDR     0x09
#define CLEXTREG_EXT_DATA     0x0a
#define CLEXTREG_EXTCTRL_2    0x0b

//TI Global Control Register bits
#define TI_GCTRL_PWRDOWN_MODE_ENABLE    0x01
#define TI_GCTRL_CSC_LEVEL_MODE         0x02
#define TI_GCTRL_INTFLAG_CLEAR_MODE     0x04
#define TI_GCTRL_CARDA_LEVEL_MODE       0x08
#define TI_GCTRL_CARDB_LEVEL_MODE       0x10

//Cirrus Logic External Data Register bits (Index=0x6f,ExtIndex=0x0a)
#define CL_EDATA_A_VS1        0x01
#define CL_EDATA_A_VS2        0x02
#define CL_EDATA_A_5V         (CL_EDATA_A_VS1 | CL_EDATA_A_VS2)
#define CL_EDATA_B_VS1        0x04
#define CL_EDATA_B_VS2        0x08
#define CL_EDATA_B_5V         (CL_EDATA_B_VS1 | CL_EDATA_B_VS2)

//Toshiba TOPIC95 Function Control Register bits
#define TO_FCTRL_CARDPWR_ENABLE     0x01
#define TO_FCTRL_VSSTATUS_ENABLE 0x02
#define TO_FCTRL_PPEC_TIMING_ENABLE 0x04
#define TO_FCTRL_CARD_TIMING_ENABLE 0x08
#define TO_FCTRL_CARD_MEMPAGE_ENABLE   0x10
#define TO_FCTRL_DMA_ENABLE      0x20
#define TO_FCTRL_PWRCTRL_BUFFER_ENABLE 0x40

//Toshiba TOPIC95 Multimedia Interface Control Register bits
#define TO_MMI_VIDEO_CTRL     0x01
#define TO_MMI_AUDIO_CTRL     0x02
#define TO_MMI_REV_BIT        0x80

//Toshiba TOPIC95 Addition General Control Register bits
#define TO_GCTRL_CARDREMOVAL_RESET  0x02
#define TO_GCTRL_SWCD_INT     0x20

//Databook DB87144 Zoom Video Port Enable Register
#define DBK_ZVE_MODE_MASK     0x03
#define DBK_ZVE_STANDARD_MODE    0x00
#define DBK_ZVE_MM_MODE       0x03

//OPTi Global Control Register bits
#define OPTI_ZV_ENABLE                  0x20

//VLSI ELC Constants
#define VLSI_ELC_ALIAS        0x8000
#define VLSI_EA2_EA_ENABLE    0x10
#define VLSI_CC_VS1        0x04

//VADEM Constants
#define VADEM_UNLOCK_SEQ1     0x0e
#define VADEM_UNLOCK_SEQ2     0x37
#define VADEM_MISC_UNLOCK_VADEMREV  0xc0
#define VADEM_IDREV_VG469_REV    0x0c
#define VADEM_VSEL_VCC_MASK      0x03
#define VADEM_VSEL_VCC_050V      0x00
#define VADEM_VSEL_VCC_033V      0x01
#define VADEM_VSEL_VCC_XXXV      0x02
#define VADEM_VSEL_VCC_033VB     0x03
#define VADEM_VSEL_SKT_MIXEDVOLT 0x40
#define VADEM_VSENSE_A_VS1    0x01
#define VADEM_VSENSE_A_VS2    0x02
#define VADEM_VSENSE_B_VS1    0x04
#define VADEM_VSENSE_B_VS2    0x08
#define VADEM_VSENSE_050V_ONLY      0x03

//IBM King Constants
#define KING_CVS_VS1       0x01
#define KING_CVS_VS2       0x02
#define KING_CVS_VS_MASK      (KING_CVS_VS1 | KING_CVS_VS2)
#define KING_CVS_5V        (KING_CVS_VS1 | KING_CVS_VS2)
#define KING_CVS_GPI       0x80

//Ricoh RL5C466 Miscellaneous Control 1 Register bits
#define RICOH_MC1_VS                    0x01
#define RICOH_MC1_IREQ_SENSE_SEL        0x02
#define RICOH_MC1_INPACK_ENABLE         0x04
#define RICOH_MC1_ZV_ENABLE             0x08
#define RICOH_MC1_DMA_ENABLE_MASK       0x30
#define RICOH_MC1_DMA_DISABLE           0x00
#define RICOH_MC1_DMA_INPACK            0x10
#define RICOH_MC1_DMA_IOIS16            0x20
#define RICOH_MC1_DMA_SPKR              0x30

//Misc. Constants
#define EXCAREGBASE_SPACE     0x40
#define NUMWIN_PCCARD16                 7       //5 mem + 2 io per socket
#define NUMWIN_PC16_MEM                 5
#define NUMWIN_PC16_IO                  2
#define PCCARD_IOWIN_START              5

//These are default values for the slowest and fastest memory speeds supported.
//It may be necessary to change the actual values with arguments, if the bus
//speed is not the default 8MHz/8.33MHz, which gives 120ns-125ns per cycle.
//Note that the SLOW_MEM_SPEED should be the same as the default
//WaitToSpeed[3], and FAST_MEM_SPEED might as well be 1ns, since the socket
//will support arbitrarily fast memory.
#define SLOW_MEM_SPEED                  0x72    //700ns
#define FAST_MEM_SPEED                  0x08    //1ns

//
// Values for various delays for R2 cards
//
#define PWRON_DELAY                     400000  //400ms

#define  PCMCIA_DEFAULT_READY_DELAY_ITER       850
#define  PCMCIA_DEFAULT_READY_STALL            10000     // 10 millesec

#define PCMCIA_DEFAULT_PCIC_MEMORY_WINDOW_DELAY  3000    // 3 msec
#define PCMCIA_DEFAULT_PCIC_RESET_WIDTH_DELAY    100     // 100 usec
#define PCMCIA_DEFAULT_PCIC_RESET_SETUP_DELAY    70000   // 70 msec

#define PCMCIA_DEFAULT_ATTRIBUTE_MEMORY_LOW      0xD0000
#define PCMCIA_DEFAULT_ATTRIBUTE_MEMORY_HIGH     0xE0000
#define PCMCIA_DEFAULT_IO_LOW                    0x0
#define PCMCIA_DEFAULT_IO_HIGH                   0xFFFF

//I/O Control Register default nibble values
//The Xircom net PC cards fails with a 16-bit wait on the AcerNote which
//has a Cirrus Logic controller.  Why the addition of a wait state causes
//this to fail is a mystery.  The Socket EA PC card fails on the IBM ThinkPad
//755 if the 16-bit wait state is not set.
#define DEF_IOC_8BIT                     0x00
#define DEF_IOC_16BIT                   (IOC_IO0_DATASIZE | IOC_IO0_IOCS16 | \
                                         IOC_IO0_WAITSTATE)
#endif  // _PCMCIA_EXCA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\inc\extern.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    extern.h

Abstract:

    External definitions for intermodule functions.

Revision History:
    6-Apr-95
        Databook support added.
    2-Nov-96
        Overhaul for plug'n'play - Ravisankar Pudipeddi (ravisp)

--*/
#ifndef _PCMCIA_EXTERN_H_
#define _PCMCIA_EXTERN_H_

//
// Global data referenced by the driver
//
extern const DEVICE_DISPATCH_TABLE    DeviceDispatchTable[];
extern const PCMCIA_ID_ENTRY    PcmciaAdapterHardwareIds[];
extern const PCMCIA_CONTEXT_RANGE     DefaultPciContextSave[];
extern const PCMCIA_CONTEXT_RANGE     DefaultCardbusContextSave[];
extern const PCMCIA_CONTEXT_RANGE     ExcludeCardbusContextRange[];
extern const PCMCIA_REGISTER_INIT     PcicRegisterInitTable[];
extern const PCMCIA_DEVICE_CONFIG_PARAMS DeviceConfigParams[];
extern ULONG                          PcmciaGlobalFlags;
extern ULONG                          PcmciaDebugMask;
extern PDEVICE_OBJECT                 FdoList;
extern ULONG CBModemReadyDelay;
extern ULONG PcicMemoryWindowDelay;
extern ULONG PcicResetWidthDelay;
extern ULONG PcicResetSetupDelay;
extern ULONG PcicStallPower;
extern ULONG CBResetWidthDelay;
extern ULONG CBResetSetupDelay;
extern ULONG ControllerPowerUpDelay;

extern ULONG globalOverrideIrqMask;   
extern ULONG globalFilterIrqMask;   
extern ULONG globalIoLow;              
extern ULONG globalIoHigh;             
extern ULONG globalReadyDelayIter;     
extern ULONG globalReadyStall;         
extern ULONG globalAttributeMemoryLow; 
extern ULONG globalAttributeMemoryHigh;
extern ULONG globalAttributeMemorySize;
extern ULONG initSoundsEnabled;
extern ULONG initUsePolledCsc; 
extern ULONG initDisableAcpiNameSpaceCheck;
extern ULONG initDefaultRouteR2ToIsa;
extern ULONG pcmciaDisableIsaPciRouting; 
extern ULONG pcmciaIsaIrqRescanComplete; 
extern ULONG pcmciaIrqRouteToPciController;
extern ULONG pcmciaIrqRouteToIsaController;
extern ULONG pcmciaIrqRouteToPciLocation;
extern ULONG pcmciaIrqRouteToIsaLocation;
extern ULONG pcmciaReportMTD0002AsError;

extern GLOBAL_REGISTRY_INFORMATION GlobalRegistryInfo[];
extern ULONG GlobalInfoCount;

extern const PCI_CONTROLLER_INFORMATION   PciControllerInformation[];
extern const PCI_VENDOR_INFORMATION       PciVendorInformation[];
extern KEVENT                       PcmciaDelayTimerEvent;
extern PPCMCIA_SOUND_EVENT PcmciaToneList;
extern KTIMER PcmciaToneTimer;
extern KDPC PcmciaToneDpc;
extern KSPIN_LOCK PcmciaToneLock;
extern KSPIN_LOCK PcmciaGlobalLock;
extern PPCMCIA_NTDETECT_DATA pNtDetectDataList;
extern ULONG EventDpcDelay;
extern ULONG PcmciaPowerPolicy;
extern LONG PcmciaControllerDeviceWake;

//
// Irp dispatch routines
//

VOID
PcmciaInitDeviceDispatchTable(
   IN PDRIVER_OBJECT DriverObject
   );

NTSTATUS
PcmciaDispatch(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
PcmciaFdoPnpDispatch(
   IN PDEVICE_OBJECT Fdo,
   IN PIRP Irp
   );

NTSTATUS
PcmciaPdoPnpDispatch(
   IN PDEVICE_OBJECT Pdo,
   IN PIRP Irp
   );

NTSTATUS
PcmciaPdoCardBusPnPDispatch(
   IN PDEVICE_OBJECT Pdo,
   IN PIRP Irp
   );

NTSTATUS
PcmciaFdoPowerDispatch(
   IN PDEVICE_OBJECT Fdo,
   IN PIRP Irp
   );

NTSTATUS
PcmciaPdoPowerDispatch(
   IN PDEVICE_OBJECT Pdo,
   IN PIRP Irp
   );

NTSTATUS
PcmciaOpenCloseDispatch(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
PcmciaCleanupDispatch(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );
   
NTSTATUS
PcmciaDeviceControl(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
PcmciaPdoDeviceControl(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
PcmciaFdoSystemControl(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
PcmciaPdoSystemControl(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

//
// enumeration routines
//

NTSTATUS
PcmciaDeviceRelations(
   IN PDEVICE_OBJECT Fdo,
   IN PIRP Irp,
   IN DEVICE_RELATION_TYPE RelationType,
   OUT PDEVICE_RELATIONS *DeviceRelations
   );


//
// controller support routines
//

NTSTATUS
PcmciaAddDevice(
   IN PDRIVER_OBJECT DriverObject,
   IN PDEVICE_OBJECT pdo
   );

NTSTATUS
PcmciaStartPcmciaController(
   IN PDEVICE_OBJECT Fdo
   );
   
NTSTATUS
PcmciaGetLegacyDetectedControllerType(
   IN PDEVICE_OBJECT Pdo,
   IN OUT PPCMCIA_CONTROLLER_TYPE ControllerType
   );
   
NTSTATUS
PcmciaSetLegacyDetectedControllerType(
   IN PDEVICE_OBJECT Pdo,
   IN PCMCIA_CONTROLLER_TYPE ControllerType
   );
   
VOID
PcmciaSetControllerType(
   IN PFDO_EXTENSION FdoExtension,
   IN PCMCIA_CONTROLLER_TYPE ControllerType
   );
   
NTSTATUS
PcmciaInitializeController(
   IN PDEVICE_OBJECT Fdo
   );
   
VOID
PcmciaCleanupPdo(
   IN PDEVICE_OBJECT Pdo
   );

//
// Interface routines
//

NTSTATUS
PcmciaPdoQueryInterface(
   IN PDEVICE_OBJECT Pdo,
   IN OUT PIRP       Irp
   );

NTSTATUS
PcmciaGetInterface(
   IN PDEVICE_OBJECT Pdo,
   IN CONST GUID *pGuid,
   IN USHORT sizeofInterface,
   OUT PINTERFACE pInterface
   );

NTSTATUS
PcmciaGetSetPciConfigData(
   IN PDEVICE_OBJECT PciPdo,
   IN PVOID Buffer,
   IN ULONG Offset,
   IN ULONG Length,
   IN BOOLEAN Read
   );

NTSTATUS
PcmciaUpdateInterruptLine(
   IN PPDO_EXTENSION PdoExtension,
   IN PFDO_EXTENSION FdoExtension
   );

//
// Socket routines
//

VOID
PcmciaSocketPowerWorker(
   IN PKDPC Dpc,
   IN PVOID Context,
   IN PVOID SystemArgument1,
   IN PVOID SystemArgument2
   );

NTSTATUS
PcmciaRequestSocketPower(
   IN PPDO_EXTENSION PdoExtension,
   IN PPCMCIA_COMPLETION_ROUTINE PowerCompletionRoutine
   );

NTSTATUS
PcmciaReleaseSocketPower(
   IN PPDO_EXTENSION PdoExtension,
   IN PPCMCIA_COMPLETION_ROUTINE PowerCompletionRoutine
   );

NTSTATUS
PcmciaSetSocketPower(
   IN PSOCKET Socket,
   IN PPCMCIA_COMPLETION_ROUTINE PowerCompletionRoutine,
   IN PVOID Context,
   IN BOOLEAN PowerOn
   );

VOID
PcmciaGetSocketStatus(
   IN PSOCKET Socket
   );

UCHAR
PcmciaReadCISChar(
   IN PPDO_EXTENSION PdoExtension,
   IN MEMORY_SPACE MemorySpace,
   IN ULONG Offset
   );

NTSTATUS
PcmciaConfigureCardBusCard(
   IN PPDO_EXTENSION pdoExtension
   );

NTSTATUS
PcmciaConfigurePcCard(
   IN PPDO_EXTENSION pdoExtension,
   IN PPCMCIA_COMPLETION_ROUTINE ConfigCompletionRoutine
   );

VOID
PcmciaConfigurationWorker(
   IN PKDPC Dpc,
   IN PVOID DeferredContext,
   IN PVOID SystemArgument1,
   IN PVOID SystemArgument2
   );

VOID
PcmciaSocketDeconfigure(
   IN PSOCKET Socket
   );

NTSTATUS
PcmciaReadWriteCardMemory(
   IN PDEVICE_OBJECT Pdo,
   IN ULONG          WhichSpace,
   IN OUT PUCHAR     Buffer,
   IN ULONG          Offset,
   IN ULONG          Length,
   IN BOOLEAN        Read
   );

NTSTATUS
PcmciaGetConfigData(
   IN PPDO_EXTENSION PdoExtension
   );

VOID
PcmciaCleanupCisCache(
   IN PSOCKET Socket
   );

BOOLEAN
PcmciaVerifyCardInSocket(
   IN PSOCKET Socket
   );

//
// Pnp id routines
//

NTSTATUS
PcmciaGetDeviceId(
   IN  PDEVICE_OBJECT  Pdo,
   IN  ULONG           FunctionNumber,
   OUT PUNICODE_STRING DeviceId
   );

NTSTATUS
PcmciaGetHardwareIds(
   IN  PDEVICE_OBJECT  Pdo,
   IN  ULONG           FunctionNumber,
   OUT PUNICODE_STRING HardwareIds
   );

NTSTATUS
PcmciaGetCompatibleIds(
   IN  PDEVICE_OBJECT  Pdo,
   IN  ULONG           FunctionNumber,
   OUT PUNICODE_STRING CompatibleIds
   );

NTSTATUS
PcmciaGetInstanceId(
   IN PDEVICE_OBJECT   Pdo,
   OUT PUNICODE_STRING InstanceId
   );

NTSTATUS
PcmciaStringsToMultiString(
   IN PCSTR * Strings,
   IN ULONG Count,
   IN PUNICODE_STRING MultiString
   );

//
// Registry routines
//

NTSTATUS
PcmciaLoadGlobalRegistryValues(
   VOID
   );
   
NTSTATUS
PcmciaGetControllerRegistrySettings(
   IN OUT PFDO_EXTENSION FdoExtension
   );
   
VOID
PcmciaGetRegistryFdoIrqMask(
   IN OUT PFDO_EXTENSION FdoExtension
   );

//
// Intel PCIC (82365SL) and compatible routines.
//

NTSTATUS
PcicBuildSocketList(
   IN PFDO_EXTENSION FdoExtension
   );

UCHAR
PcicReadSocket(
   IN PSOCKET Socket,
   IN ULONG   Register
   );

VOID
PcicWriteSocket(
   IN PSOCKET Socket,
   IN ULONG   Register,
   IN UCHAR  DataByte
   );

NTSTATUS
PcicIsaDetect(
   IN PFDO_EXTENSION DeviceExtension
   );

NTSTATUS
PcicSetPower(
   IN PSOCKET Socket,
   IN BOOLEAN Enable,
   OUT PULONG pDelayTime
   );

//
// Utility routines for pcmcia work.
//

NTSTATUS
PcmciaIoCallDriverSynchronous(
   PDEVICE_OBJECT deviceObject,
   PIRP Irp
   );

VOID
PcmciaWait(
   IN ULONG MilliSeconds
   );

VOID
PcmciaLogError(
   IN PFDO_EXTENSION DeviceExtension,
   IN ULONG ErrorCode,
   IN ULONG UniqueId,
   IN ULONG Argument
   );

VOID
PcmciaPlaySound(
   IN PCMCIA_SOUND_TYPE SoundType
   );
   
VOID
PcmciaPlayToneCompletion(
   IN PKDPC Dpc,
   IN PVOID Context,
   IN PVOID SystemArgument1,
   IN PVOID SystemArgument2
   );

VOID
PcmciaLogErrorWithStrings(
   IN PFDO_EXTENSION DeviceExtension,
   IN ULONG             ErrorCode,
   IN ULONG             UniqueId,
   IN PUNICODE_STRING   String1,
   IN PUNICODE_STRING   String2
   );

BOOLEAN
PcmciaReportControllerError(
   IN PFDO_EXTENSION FdoExtension,
   NTSTATUS ErrorCode
   );

ULONG
PcmciaCountOnes(
   IN ULONG Data
   );


//
// Power management routines

NTSTATUS
PcmciaFdoArmForWake(
   IN PFDO_EXTENSION FdoExtension
   );

NTSTATUS
PcmciaFdoDisarmWake(
   IN PFDO_EXTENSION FdoExtension
   );

NTSTATUS
PcmciaPdoWaitWakeCompletion(
   IN PDEVICE_OBJECT Pdo,
   IN PIRP           Irp,
   IN PPDO_EXTENSION PdoExtension
   );

NTSTATUS
PcmciaSetPdoDevicePowerState(
   IN PDEVICE_OBJECT Pdo,
   IN OUT PIRP Irp
   );
   
VOID
PcmciaPdoPowerWorkerDpc(
   IN PKDPC Dpc,
   IN PVOID DeferredContext,
   IN PVOID SystemArgument1,
   IN PVOID SystemArgument2
   );

VOID
PcmciaFdoRetryPdoPowerRequest(
   IN PKDPC Dpc,
   IN PVOID DeferredContext,
   IN PVOID SystemArgument1,
   IN PVOID SystemArgument2
   );

VOID
PcmciaFdoPowerWorkerDpc(
   IN PKDPC Dpc,
   IN PVOID Context,
   IN PVOID SystemArgument1,
   IN PVOID SystemArgument2
   );

NTSTATUS
PcmciaFdoCheckForIdle(
   IN PFDO_EXTENSION FdoExtension
   );

//
//
// Tuple processing routines.
//

NTSTATUS
PcmciaParseFunctionData(
   IN PSOCKET       Socket,
   IN PSOCKET_DATA  SocketData
   );
   
NTSTATUS
PcmciaParseFunctionDataForID(
   IN PSOCKET_DATA  SocketData
   );
   
//
// General detection and support.
//

NTSTATUS
PcmciaDetectPcmciaControllers(
   IN PDRIVER_OBJECT DriverObject,
   IN PUNICODE_STRING RegistryPath
   );

BOOLEAN
PcmciaLegacyDetectionOk(
   VOID
   );

//
// Databook TCIC2 and compatible routines.
//

NTSTATUS
TcicBuildSocketList(
   IN PFDO_EXTENSION FdoExtension
   );

NTSTATUS
TcicDetect(
   IN PFDO_EXTENSION DeviceExtension
   );

VOID
TcicGetControllerProperties (
   IN PSOCKET socketPtr,
   IN PUSHORT pIoPortBase,
   IN PUSHORT pIoPortSize
   );
            
NTSTATUS
TcicSetPower(
   IN PSOCKET Socket,
   IN BOOLEAN Enable,
   OUT PULONG pDelayTime
   );
            

//
// Cardbus support routines
//

NTSTATUS
CBBuildSocketList(
   IN PFDO_EXTENSION FdoExtension
   );

ULONG
CBReadSocketRegister(
   IN PSOCKET Socket,
   IN UCHAR Register
   );
   
VOID
CBWriteSocketRegister(
   IN PSOCKET Socket,
   IN UCHAR Register,
   IN ULONG Data
   );

BOOLEAN
CBEnableDeviceInterruptRouting(
   IN PSOCKET Socket
   );
   
VOID
CBIssueCvsTest(
   IN PSOCKET Socket
   );
   
//
// Cardbus vendor specific exports
//

VOID
TIInitialize(
   IN PFDO_EXTENSION FdoExtension
   );

BOOLEAN
TISetZV(
   IN PSOCKET Socket,
   IN BOOLEAN Enable
   );

BOOLEAN
TISetWindowPage(
   IN PSOCKET Socket,
   USHORT Index,
   UCHAR Page
   );

VOID
CLInitialize(
   IN PFDO_EXTENSION FdoExtension
   );

NTSTATUS
CLSetPower(
   IN PSOCKET Socket,
   IN BOOLEAN Enable,
   OUT PULONG pDelayTime
   );

BOOLEAN
CLSetZV(
   IN PSOCKET Socket,
   IN BOOLEAN Enable
   );
   
VOID
RicohInitialize(
   IN PFDO_EXTENSION FdoExtension
   );

BOOLEAN
RicohSetZV(
   IN PSOCKET Socket,
   IN BOOLEAN Enable
   );

VOID
OptiInitialize(
   IN PFDO_EXTENSION FdoExtension
   );

NTSTATUS
OptiSetPower(
   IN PSOCKET Socket,
   IN BOOLEAN Enable,
   OUT PULONG pDelayTime
   );

BOOLEAN
OptiSetZV(
   IN PSOCKET Socket,
   IN BOOLEAN Enable
   );
   
VOID
TopicInitialize(
   IN PFDO_EXTENSION FdoExtension
   );

NTSTATUS
TopicSetPower(
   IN PSOCKET Socket,
   IN BOOLEAN Enable,
   OUT PULONG pDelayTime
   );

VOID
TopicSetAudio(
   IN PSOCKET Socket,
   IN BOOLEAN Enable
   );

BOOLEAN
TopicSetZV(
   IN PSOCKET Socket,
   IN BOOLEAN Enable
   );

VOID
O2MInitialize(
   IN PFDO_EXTENSION FdoExtension
   );

NTSTATUS
O2MSetPower(
   IN PSOCKET Socket,
   IN BOOLEAN Enable,
   OUT PULONG pDelayTime
   );

BOOLEAN
O2MSetZV(
   IN PSOCKET Socket,
   IN BOOLEAN Enable
   );
   
VOID
DBInitialize(
   IN PFDO_EXTENSION FdoExtension
   );

BOOLEAN
DBSetZV(
   IN PSOCKET Socket,
   IN BOOLEAN Enable
   );

BOOLEAN
TridSetZV(
   IN PSOCKET Socket,
   IN BOOLEAN Enable
   );

NTSTATUS
CBSetPower(
   IN PSOCKET Socket,
   IN BOOLEAN Enable,
   OUT PULONG pDelayTime
   );

BOOLEAN
CBSetWindowPage(
   IN PSOCKET Socket,
   USHORT Index,
   UCHAR Page
   );

#endif // _PCMCIA_EXTERN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\inc\pcicfg.h ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    pcicfg.h

Abstract:

    Contains defines for vendor specific PCI configuration
    information

Author(s):

    Ravisankar Pudipeddi   (1 Nov 1997)
    Largely derived from pcskhw.h for win 9x

Revision History:

--*/

#ifndef _PCMCIA_PCICFG_H_
#define _PCMCIA_PCICFG_H_

//
// Macros for read/writing to PCI config headers
//

//
// VOID
// GetPciConfigSpace (IN PVOID  Extension,
//                    IN UCHAR  Offset,
//                    IN PUCHAR Buffer,
//                    IN ULONG  Size)
//
#define GetPciConfigSpace(Extension, Offset, Buffer, Size)    \
           (Extension)->PciBusInterface.GetBusData(           \
               (Extension)->PciBusInterface.Context,          \
               PCI_WHICHSPACE_CONFIG, Buffer, Offset, Size);


//
// VOID
// SetPciConfigSpace (IN PVOID  Extension,
//                    IN UCHAR  Offset,
//                    IN PUCHAR Buffer,
//                    IN ULONG  Size)
//
#define SetPciConfigSpace(Extension, Offset, Buffer, Size)    \
           (Extension)->PciBusInterface.SetBusData(           \
               (Extension)->PciBusInterface.Context,          \
               PCI_WHICHSPACE_CONFIG, Buffer, Offset, Size);




//ConfigSpace Registers

#define CFGSPACE_VENDOR_ID              0x00
#define CFGSPACE_DEVICE_ID              0x02
#define CFGSPACE_COMMAND                0x04
#define CFGSPACE_STATUS                 0x06
#define CFGSPACE_REV_ID                 0x08
#define CFGSPACE_CLASS_CODE             0x09
#define CFGSPACE_CLASSCODE_PI           0x09
#define CFGSPACE_CLASSCODE_SUBCLASS     0x0a
#define CFGSPACE_CLASSCODE_BASECLASS    0x0b
#define CFGSPACE_CACHE_LINESIZE         0x0c
#define CFGSPACE_LATENCY_TIMER          0x0d
#define CFGSPACE_HEADER_TYPE            0x0e
#define CFGSPACE_BIST                   0x0f
#define CFGSPACE_REGBASE_ADDR           0x10
#define CFGSPACE_CAPPTR                 0x14
#define CFGSPACE_SECOND_STATUS          0x16
#define CFGSPACE_PCI_BUSNUM             0x18
#define CFGSPACE_CARDBUS_BUSNUM         0x19
#define CFGSPACE_SUB_BUSNUM             0x1a
#define CFGSPACE_CB_LATENCY_TIMER       0x1b
#define CFGSPACE_MEMBASE_0              0x1c
#define CFGSPACE_MEMLIMIT_0             0x20
#define CFGSPACE_MEMBASE_1              0x24
#define CFGSPACE_MEMLIMIT_1             0x28
#define CFGSPACE_IOBASE_0               0x2c
#define CFGSPACE_IOLIMIT_0              0x30
#define CFGSPACE_IOBASE_1               0x34
#define CFGSPACE_IOLIMIT_1              0x38
#define CFGSPACE_INT_LINE               0x3c
#define CFGSPACE_INT_PIN                0x3d
#define CFGSPACE_BRIDGE_CTRL            0x3e
#define CFGSPACE_SUBSYS_VENDOR_ID       0x40
#define CFGSPACE_SUBSYS_ID              0x42
#define CFGSPACE_LEGACY_MODE_BASE_ADDR 0x44

//ConfigSpace registers for cardbus cards

#define CBCFG_BAR0                      0x10
#define CBCFG_BAR1                      0x14
#define CBCFG_BAR2                      0x18
#define CBCFG_BAR3                      0x1c
#define CBCFG_BAR4                      0x20
#define CBCFG_BAR5                      0x24
#define CBCFG_CISPTR                    0x28
#define CBCFG_SUBSYS_VENDOR_ID          0x2c
#define CBCFG_SUBSYS_ID                 0x2e
#define CBCFG_ROMBAR                    0x30
#define CBCFG_CAPPTR                    0x34


//Command Register bits
#define CMD_IOSPACE_ENABLE              0x0001
#define CMD_MEMSPACE_ENABLE             0x0002
#define CMD_BUSMASTER_ENABLE            0x0004
#define CMD_SPECIALCYCLE_ENABLE         0x0008
#define CMD_MEMWR_INVALIDATE_ENABLE     0x0010
#define CMD_VGA_PALETTE_SNOOP           0x0020
#define CMD_PARITY_ERROR_ENABLE         0x0040
#define CMD_WAIT_CYCLE_CTRL             0x0080
#define CMD_SYSTEM_ERROR_ENABLE         0x0100
#define CMD_FAST_BACKTOBACK_ENABLE      0x0200

//Bridge Control Register bits
#define BCTRL_PERR_RESPONSE_ENABLE      0x0001
#define BCTRL_SERR_ENABLE               0x0002
#define BCTRL_ISA_ENABLE                0x0004
#define BCTRL_VGA_ENABLE                0x0008
#define BCTRL_MASTER_ABORT_MODE         0x0020
#define BCTRL_CRST                      0x0040
#define BCTRL_IRQROUTING_ENABLE         0x0080
#define BCTRL_MEMWIN0_PREFETCH_ENABLE   0x0100
#define BCTRL_MEMWIN1_PREFETCH_ENABLE   0x0200
#define BCTRL_WRITE_POSTING_ENABLE      0x0400
#define BCTRL_CL_CSCIRQROUTING_ENABLE   0x0800

//Power Management control bits
#define PME_EN                          0x0100
#define PME_STAT                        0x8000

//
// TI
//

//ConfigSpace Registers (TI PCI1130)
#define CFGSPACE_TI_SYSTEM_CTRL         0x80
#define CFGSPACE_TI_MM_CTRL             0x84
#define CFGSPACE_TI_RETRY_STATUS        0x90
#define CFGSPACE_TI_CARD_CTRL           0x91
#define CFGSPACE_TI_DEV_CTRL            0x92

//System Control Register bits (TI PCI1130)
#define SYSCTRL_PCICLKRUN_ENABLE        0x00000001
#define SYSCTRL_KEEPCLK_ENABLE          0x00000002
#define SYSCTRL_ASYNC_INTMODE           0x00000004
#define SYSCTRL_PCPCI_DMA_ENABLE        0x00000008
#define SYSCTRL_CBDATAPARITY_SERR       0x00000010
#define SYSCTRL_EXCAIDREV_READONLY      0x00000020
#define SYSCTRL_INTERROGATING           0x00000100
#define SYSCTRL_POWERING_UP             0x00000200
#define SYSCTRL_POWERING_DOWN           0x00000400
#define SYSCTRL_POWER_STREAMING         0x00000800
#define SYSCTRL_SOCKET_ACTIVITY         0x00002000
#define SYSCTRL_PCPCI_DMA_CHAN_MASK     0x00070000
#define SYSCTRL_PCPCI_DMA_CHAN_DISABLED 0x00040000
#define SYSCTRL_PCPCI_DMA_CARD_ENABLE   0x00080000
#define SYSCTRL_REDUCED_ZV_ENABLE       0x00100000
#define SYSCTRL_VCC_PROTECT_OVERRIDE    0x00200000
#define SYSCTRL_SMI_INT_ENABLE          0x01000000
#define SYSCTRL_SMI_INT_ROUTING_SELECT  0x02000000

//Multimedia Control Register bits (TI PCI1250/1260)
#define MMCTRL_ZVEN0                    0x01
#define MMCTRL_ZVEN1                    0x02
#define MMCTRL_PORTSEL                  0x40
#define MMCTRL_ZVOUTEN                  0x80

//Retry Status Register bits (TI PCI1130)
#define RETRY_PCIM_RETRY_EXPIRED        0x01
#define RETRY_PCI_RETRY_EXPIRED         0x02
#define RETRY_CBMA_RETRY_EXPIRED        0x04
#define RETRY_CBA_RETRY_EXPIRED         0x08
#define RETRY_CBMB_RETRY_EXPIRED        0x10
#define RETRY_CBB_RETRY_EXPIRED         0x20
#define RETRY_CBRETRY_TIMEOUT_ENABLE    0x40
#define RETRY_PCIRETRY_TIMEOUT_ENABLE   0x80

//Card Control Register bits (TI PCI1130)
#define CARDCTRL_PCCARD_INTFLAG         0x01
#define CARDCTRL_SPKR_ENABLE            0x02
#define CARDCTRL_CSCINT_ENABLE          0x08
#define CARDCTRL_FUNCINT_ENABLE         0x10
#define CARDCTRL_PCIINT_ENABLE          0x20
#define CARDCTRL_ZV_ENABLE              0x40
#define CARDCTRL_RIOUT_ENABLE           0x80

//Device Control Register bits (TI PCI1130)
#define DEVCTRL_INTMODE_MASK            0x06
#define DEVCTRL_INTMODE_DISABLED        0x00
#define DEVCTRL_INTMODE_ISA             0x02
#define DEVCTRL_INTMODE_COMPAQ          0x04
#define DEVCTRL_INTMODE_SERIAL          0x06
#define DEVCTRL_ALWAYS_ONE              0x10
#define DEVCTRL_3V_ENABLE               0x20
#define DEVCTRL_5V_ENABLE               0x40

//
// TOPIC
//

//ConfigSpace Registers (TOPIC95)
#define CFGSPACE_TO_PC16_SKTCTRL        0x90
#define CFGSPACE_TO_SLOT_CTRL           0xa0
#define CFGSPACE_TO_CARD_CTRL           0xa1
#define CFGSPACE_TO_CD_CTRL             0xa3
#define CFGSPACE_TO_CBREG_CTRL          0xa4

//PC Card-16 Socket Control Register bits (TOPIC95)
#define S16CTRL_CSC_ISAIRQ              0x00000001

//Card Control Register bits (TOPIC95)
#define CARDCTRL_INTPIN_ASSIGNMASK      0x30
#define CARDCTRL_INTPIN_NONE            0x00
#define CARDCTRL_INTPIN_INTA            0x01
#define CARDCTRL_INTPIN_INTB            0x02

//Card Detect Control Register bits (TOPIC95)
#define CDCTRL_SW_DETECT                0x01
#define CDCTRL_VS_MASK                  0x06
#define CDCTRL_PCCARD_16_32             0x80

//CardBus Socket Register Control Register (TOPIC)
#define CSRCR_TO_CAUDIO_OFF             0x00000002


//
// CL
//

//ConfigSpace Registers (CL PD6834)
#define CFGSPACE_CL_CFGMISC1     0x98

//Cirrus Logic Configuration Miscellaneous 1
#define CL_CFGMISC1_ISACSC    0x02

//
// Opti
//

//ConfigSpace Registers (OPTi 82C824)
#define CFGSPACE_OPTI_HF_CTRL           0x50
#define HFC_COMBINE_CINT_CSTSCHG        0x01
#define HFC_SPKROUT_ENABLE              0x02
#define HFC_CLKRUN_DISBALE              0x04
#define HFC_CD_DEBOUNCE_250MS           0x00
#define HFC_CD_DEBOUNCE_1000MS          0x08
#define HFC_IRQLAT_ON_CLKRUN            0x10
#define HFC_VENDOR_ID_STRAP             0x20
#define HFC_LEGACY_MODE_STRAP           0x40
#define HFC_ZV_SUPPORT                  0x80

//ConfigSpace Register (OPTi 82C824)
#define CFGSPACE_OPTI_SF_CTRL2      0x52
#define SFC2_SECOND_IDSEL_ADDR_MASK 0x0f
#define SFC2_SECOND_PCICLK_SKEW_MASK   0xf0

//
// Ricoh
//

//ConfigSpace Registers (RICOH RL5C466)
#define CFGSPACE_RICOH_MISC_CTRL        0x82
#define CFGSPACE_RICOH_IF16_CTRL        0x84
#define CFGSPACE_RICOH_IO16_TIMING0     0x88
#define CFGSPACE_RICOH_MEM16_TIMING0    0x8a
#define CFGSPACE_RICOH_DMA_SLAVE_CFG    0x90

//RICOH 16-bit Interface Control Register bits
#define IF16_INDEX_RANGE_SELECT         0x0008
#define IF16_LEGACY_LEVEL_1             0x0010
#define IF16_LEGACY_LEVEL_2             0x0020
#define IF16_IO16_ENHANCE_TIMING        0x0100
#define IF16_MEM16_ENHANCE_TIMING       0x0200

//
// O2Micro
//

//ConfigSpace Registers (O2Micro)
#define CFGSPACE_O2MICRO_ZVCFG      0x80
#define ZVCFG_SKTA_SUPPORT    0x01
#define ZVCFG_SKTB_SUPPORT    0x02

#endif  // _PCMCIA_PCICFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\inc\tcic2.h ===
/* tcic2.h	Mon Jul 25 1994 18:30:04 zema */

/*

Module:  tcic2.h

Function:
	Definitions for DB86082 (TCIC-2/N) PCMCIA
	V2 interface controller chip.

Version:
	V6.62f	Mon Jul 25 1994 18:30:04 zema	Edit level 34


Copyright Notice:
	This file is in the public domain.  It was created by:

		Databook Inc.
		Building E, Suite 6
		3495 Winton Place
		Rochester, NY  14623

		Telephone:	+1-716-292-5720
		Fax:		+1-716-292-5737
		BBS:		+1-716-292-5741
		Email:		support@databook.com
		Compuserve:	go databook

	This code is provided as-is.  Databook makes no warrantees of
	any kind as to its correctness or suitability for any purpose,
	and disclaims all liability for any loss or damage resulting from
	the use of this file, including without limitation contingent, 
	special, or other liability.

 
Author:
	Terry Moore, Databook Inc.	April 1991

Revision history:
   1.00a  Mon Apr 15 1991 19:16:41  tmm
	Module created.


   6.62f  Mon Jul 25 1994 18:30:04 zema
	Incorporated define of a Chip's Silicon ID into ILOCKTEST define. ex.-
	#define SILID_DBxxxx		(n)
 	#define ILOCKTEST_DBxxxx	((SILID_DBxxxx) << ILOCKTEST_ID_SHFT)

*/

/*****************************************************************************\

This file contains a set of common definitions for the Databook/Fujitsu
family of memory and I/O card controller chips, known by Databook as the 
TCIC family.

When this file is included it will define symbols for one or more chips,
depending on whether the following symbols are defined:

	MB86301		gets definitions for the Fujitsu 86301
	DB86081		gets definitions for the Databook TCIC-2/P
	DB86082		gets definitions for the Databook TCIC-2/N.
	DB86082A	gets definitions for 86082a, and for the 86082.

For backwards compatibility, the file "mcic.h" will define MB86301, then
call this file.

\*****************************************************************************/

#ifndef _TCIC2_H_		/* prevent multiple includes */
#define _TCIC2_H_


//
// Memory window sizes that will be allocated
// for this controller - to map card memory
//
#define TCIC_WINDOW_SIZE                 0x8000  //(32K)
#define TCIC_WINDOW_ALIGNMENT            0x8000  //(32K)

#define NUMSOCKETS	2
#define	CHIPBASE	0x240

/* register definitions */
#define	R_DATA	0		/* data register */
#define	R_ADDR	2		/* address register */
#define	R_ADDR2	(R_ADDR+2)	/*   high order word of address register */
#define	R_SCTRL	6		/* socket ctrl register */
#define	R_SSTAT	7		/* socket status register */
#define	R_MODE	8		/* controller mode register */
#define	R_PWR	9		/* controller power register */
#define	R_EDC	10		/* EDC register */
#define	R_ICSR	12		/* interrupt control/status register */
#define	R_IENA	13		/* interrupt enable register */
#define	R_AUX	14		/* auxiliary control registers */


/*

The TCIC-2 family defines architectural extensions for handling multiple
sockets with a single chip.  Much of this is handled via a "socket select"
field in the address register.

We define the fields first as bit fields within the high order word
of the address register, as this will be the most convenient way for
software to access them; for completeness, and for the benefit of C code, we
define the fields as part of the ULONG that represents the entire address
register.

*/

/**** first, some simple definitions ****/
#define	TCIC_SS_SHFT	12			/* default location for the
						socket select bits
						*/
#define	TCIC_SS_MASK	(7 << TCIC_SS_SHFT)	/* default mask for the
						socket select bits
						*/

/* bits in ADDR2 */
#define	ADR2_REG	(1 << 15)		/* select REG space */
#define	ADR2_SS_SHFT	TCIC_SS_SHFT		/* select sockets the usual
						way */
#define	ADR2_SS_MASK	TCIC_SS_MASK		/* ditto */
#define	ADR2_INDREG	(1 << 11)		/* access indirect registers
						||  (not card data)
						*/
#define	ADR2_IO		(1 << 10)		/* select I/O cycles, readback
						||  card /IORD, /IOWR in diag-
						||  nostic mode.
						*/

/* Bits in address register */
#define	ADDR_REG  ((unsigned long) ADR2_REG << 16)	/* OR with this for REG space */
#define	ADDR_SS_SHFT	((unsigned long) ADR2_SS_SHFT + 16)
						/* shift count, cast so that
						|| you'll get the right type
						|| if you use it but forget
						|| to cast the left arg.
						*/
#define	ADDR_SS_MASK	((unsigned long) ADR2_SS_MASK << 16)
#define	ADDR_INDREG	((unsigned long) ADR2_INDREG << 16)
#define	ADDR_IO		((unsigned long) ADR2_IO << 16)

#define	ADDR_SPACE_SIZE	((unsigned long) 1 << 26)
#define	ADDR_MASK	(ADDR_SPACE_SIZE - 1)

/* following bits are defined in diagnostic mode */
#define	ADDR_DIAG_NREG	 ((unsigned long) 1 << 31)	/* inverted! */
#define	ADDR_DIAG_NCEH	 ((unsigned long) 1 << 30)
#define	ADDR_DIAG_NCEL	 ((unsigned long) 1 << 29)
#define	ADDR_DIAG_NCWR	 ((unsigned long) 1 << 28)
#define	ADDR_DIAG_NCRD	 ((unsigned long) 1 << 27)
#define	ADDR_DIAG_CRESET ((unsigned long) 1 << 26)

/* Bits in socket control register */
#define	SCTRL_ENA	(1 << 0)	/* enable access to card */
#define	SCTRL_INCMODE	(3 << 3)	/* mask for increment mode:  */
#define  SCTRL_INCMODE_AUTO  (3 << 3)	/*   auto-increment mode */
#define  SCTRL_INCMODE_HOLD  (0 << 3)	/*   byte hold mode */
#define	 SCTRL_INCMODE_WORD  (1 << 3)	/*   word hold mode */
#define	 SCTRL_INCMODE_REG   (2 << 3)	/*   reg-space increment mode */
#define	SCTRL_EDCSUM	(1 << 5)	/* if set, use checksum (not CRC) */
#define	SCTRL_RESET	(1 << 7)	/* internal software reset */

/**** the status register (read-only):  R_SSTAT ****/
#define	SSTAT_6US	(1 << 0)	/* 6 microseconds have elapsed */
#define	SSTAT_10US	(1 << 1)	/* 10 microseconds have elapsed */
#define	SSTAT_PROGTIME	(1 << 2)	/* programming pulse timeout */
#define	SSTAT_LBAT1	(1 << 3)	/* low battery 1 */
#define	SSTAT_LBAT2	(1 << 4)	/* low battery 2 */
#define  SSTAT_BATOK	  (0 << 3)	/* battery is OK */
#define	 SSTAT_BATBAD1	  (1 << 3)	/* battery is low */
#define	 SSTAT_BATLO	  (2 << 3)	/* battery is getting low */
#define	 SSTAT_BATBAD2	  (3 << 3)	/* battery is low */
#define	SSTAT_RDY	(1 << 5)	/* card is ready (not busy) */
#define	SSTAT_WP	(1 << 6)	/* card is write-protected */
#define	SSTAT_CD	(1 << 7)	/* card present */

/**** mode register contents (R_MODE) ****/
#define	MODE_PGMMASK	(0x1F)		/* the programming mode bits */
#define	MODE_NORMAL	(0)		/*   normal mode */
#define	MODE_PGMWR	(1 << 0)	/*   assert /WR */
#define	MODE_PGMRD	(1 << 1)	/*   assert /RD */
#define	MODE_PGMCE	(1 << 2)	/*   assert /CEx */
#define	MODE_PGMDBW	(1 << 3)	/*   databus in write mode */
#define	MODE_PGMWORD	(1 << 4)	/*   word programming mode */

#define	MODE_AUXSEL_SHFT (5)		/* shift count for aux regs */
#define	MODE_AUXSEL_MASK (7 << 5)	/* the aux-reg select bits */
#define	MODE_AR_TCTL	(0 << MODE_AUXSEL_SHFT)	/* timing control */
#define	MODE_AR_PCTL	(1 << MODE_AUXSEL_SHFT)	/* pulse control */
#define	MODE_AR_WCTL	(2 << MODE_AUXSEL_SHFT)	/* wait-state control */
#define	MODE_AR_EXTERN	(3 << MODE_AUXSEL_SHFT)	/* external reg select */
#define	MODE_AR_PDATA	(4 << MODE_AUXSEL_SHFT)	/* programming data reg */
#define	MODE_AR_SYSCFG	(5 << MODE_AUXSEL_SHFT) /* system config reg */
#define	MODE_AR_ILOCK	(6 << MODE_AUXSEL_SHFT)	/* interlock control reg */
#define	MODE_AR_TEST	(7 << MODE_AUXSEL_SHFT)	/* test control reg */

#define	PWR_VCC_SHFT	(0)			/* the VCC ctl shift */
#define	PWR_VCC_MASK	(3 << PWR_VCC_SHFT)

#define	PWR_VPP_SHFT	(3)			/* the VPP ctl shift */
#define	PWR_VPP_MASK	(3 << PWR_VPP_SHFT)
#define	PWR_ENA		(1 << 5)		/* on 084, successors, this
						|| must be set to turn on
						|| power.
						*/
#define	PWR_VCC5V	(1 << 2)		/* enable +5 (not +3) */
#define	PWR_VOFF_POFF	(0)			/* turn off VCC, VPP */
#define	PWR_VON_PVCC	(1)			/* turn on VCC, VPP=VCC */
#define	PWR_VON_PVPP	(2)			/* turn on VCC, VPP=12V */
#define	PWR_VON_POFF	(3)			/* turn on VCC, VPP=0V */

#define	PWR_CLIMENA	(1 << 6)		/* the current-limit enable */
#define	PWR_CLIMSTAT	(1 << 7)		/* current limit sense (r/o) */

/**** int CSR ****/
#define	ICSR_IOCHK	(1 << 7)		/* I/O check */
#define	ICSR_CDCHG	(1 << 6)		/* card status change: top 5
						|| bits of SSTAT register.
						*/
#define	ICSR_ERR	(1 << 5)		/* error condition */
#define	ICSR_PROGTIME	(1 << 4)		/* program timer ding */
#define	ICSR_ILOCK	(1 << 3)		/* interlock change */
#define	ICSR_STOPCPU	(1 << 2)		/* Stop CPU was asserted */
#define	ICSR_SET	(1 << 1)		/* (w/o:  enable writes that set bits */
#define	ICSR_CLEAR	(1 << 0)		/* (w/o:  enable writes that clear */
#define	ICSR_JAM	(ICSR_SET|ICSR_CLEAR)	/* jam value into ICSR */

/**** interrupt enable bits ****/
#define	IENA_CDCHG	(1 << 6)	/* enable INT when ICSR_CDCHG is set */
#define	IENA_ERR	(1 << 5)	/* enable INT when ICSR_ERR is set */
#define	IENA_PROGTIME	(1 << 4)	/* enable INT when ICSR_PROGTIME " */
#define	IENA_ILOCK	(1 << 3)	/* enable INT when ICSR_ILOCK is set */
#define	IENA_CFG_MASK	(3 << 0)	/* select the bits for IRQ config: */
#define	IENA_CFG_OFF	(0 << 0)	/*  IRQ is high-impedance */
#define	IENA_CFG_OD	(1 << 0)	/*  IRQ is active low, open drain. */
#define	IENA_CFG_LOW	(2 << 0)	/*  IRQ is active low, totem pole */
#define	IENA_CFG_HIGH	(3 << 0)	/*  IRQ is active high, totem pole */

/**** aux registers ****/
#define	WAIT_COUNT_MASK	(0x1F)		/* the count of 1/2 wait states */
#define	WAIT_COUNT_SHFT (0)		/* the wait-count shift */
#define	WAIT_ASYNC	(1 << 5)	/* set for asynch, clear for synch cycles */

#define	WAIT_SENSE	(1 << 6)	/* select rising (1) or falling (0) 
					|| edge of wait clock as reference 
					|| edge.
					*/
#define	WAIT_SRC	(1 << 7)	/* select constant clock (0) or bus
					|| clock (1) as the timing source 
					*/

/**** some derived constants ****/
#define	WAIT_BCLK	(1 * WAIT_SRC)
#define	WAIT_CCLK	(0 * WAIT_SRC)
#define	WAIT_RISING	(1 * WAIT_SENSE)
#define	WAIT_FALLING	(0 * WAIT_SENSE)

/**** high byte ****/
#define	WCTL_WR		(1 << 8)	/* control:  pulse write */
#define	WCTL_RD		(1 << 9)	/* control:  pulse read */
#define	WCTL_CE		(1 << 10)	/* control:  pulse chip ena */
#define	WCTL_LLBAT1	(1 << 11)	/* status:  latched LBAT1 */
#define	WCTL_LLBAT2	(1 << 12)	/* status:  latched LBAT2 */
#define	WCTL_LRDY	(1 << 13)	/* status:  latched RDY */
#define	WCTL_LWP	(1 << 14)	/* status:  latched WP */
#define	WCTL_LCD	(1 << 15)	/* status:  latched CD */

/**** the same thing, from a byte perspective ****/
#define	AR_WCTL_WAIT	(R_AUX + 0)	/* the wait state control byte */
#define	AR_WCTL_XCSR	(R_AUX + 1)	/* extended control/status */

#define	XCSR_WR		(1 << 0)	/* control:  pulse write */
#define	XCSR_RD		(1 << 1)	/* control:  pulse read */
#define	XCSR_CE		(1 << 2)	/* control:  pulse chip ena */
#define	XCSR_LLBAT1	(1 << 3)	/* status:  latched LBAT1 */
#define	XCSR_LLBAT2	(1 << 4)	/* status:  latched LBAT2 */
#define	XCSR_LRDY	(1 << 5)	/* status:  latched RDY */
#define	XCSR_LWP	(1 << 6)	/* status:  latched WP */
#define	XCSR_LCD	(1 << 7)	/* status:  latched CD */

/**** prog timers ****/
#define	TCTL_6US_SHFT	(0)		/* the shift count for the 6 us ctr */
#define	TCTL_10US_SHFT	(8)		/* the shift count for the 10 us ctr */
#define	TCTL_6US_MASK	(0xFF << TCTL_6US_SHFT)
#define	TCTL_10US_MASK	(0xFF << TCTL_10US_SHFT)

#define	AR_TCTL_6US	(R_AUX + 0)	/* the byte access handle */
#define	AR_TCTL_10US	(R_AUX + 1)	/* the byte access handle */

/**** The programming pulse register ****/
#define	AR_PULSE_LO	(R_AUX + 0)
#define	AR_PULSE_HI	(R_AUX + 1)

/**** The programming data register ****/
#define	AR_PDATA_LO	(R_AUX + 0)
#define	AR_PDATA_HI	(R_AUX + 1)

/**** the system configuration register ****/
/*
|| The bottom four bits specify the steering of the socket IRQ.  On
|| the 2N, the socket IRQ is (by default) pointed at the dedicated
|| pin.
*/
#define	SYSCFG_IRQ_MASK		(0xF)		/* mask for this bit field. */
#define	  SYSCFG_SSIRQDFLT	(0)	/* default:  use SKTIRQ (2/N) 
					||	disable (2/P)
					*/
#define   SYSCFG_SSIRQ		(0x1)	/* use SKTIRQ (explicit) (2/N) 
					||	do not use (2/P)
					*/
#define   SYSCFG_SIRQ3		(0x3)	/* use IRQ3 */
#define   SYSCFG_SIRQ4		(0x4)	/* use IRQ4 */
#define   SYSCFG_SIRQ5		(0x5)	/* use IRQ5 (2/N) */
#define   SYSCFG_SIRQ6		(0x6)	/* use IRQ6 (2/N) */
#define   SYSCFG_SIRQ7		(0x7)	/* use IRQ7 (2/N) */
#define   SYSCFG_SIRQ10		(0xA)	/* use IRQ10 */
#define   SYSCFG_SIRQ14		(0xE)	/* use IRQ14 */

#define	SYSCFG_MCSFULL	(1 << 4)	/* 
	If set, use full address (a[12:23]) for MCS16 generation.
	If clear, run in ISA-compatible mode (only using a[17:23]).
	With many chip sets, the TCIC-2/N's timing will will allow full
	address decoding to be used rather than limiting us to LA[17:23];
	thus we can get around the ISA spec which limits the granularity
	of bus sizing to 128K blocks.
*/
#define	SYSCFG_IO1723	(1 << 5)	/*
	Flag indicating that LA[17:23] can be trusted to be zero during a true
	I/O cycle.  Setting this bit will allow us to reduce power consumption
	further by eliminating I/O address broadcasts for memory cycles.

	Unfortunately, you cannot trust LA[17:23] to be zero on all systems,
	because the ISA specs do not require that LA[17:23] be zero when an
	alternate bus master runs an I/O cycle.  However, on a palmtop or
	notebook, it is a good guess.
*/

#define	SYSCFG_MCSXB	(1 << 6)	/*
	If set, assume presence of an external buffer for MCS16:  operate
	the driver as a totem-pole output.
	
	If clear, run in psuedo-ISA mode; output is open drain.  But note 
	that on the 082 the output buffers cannot drive a 300-ohm
	load.
*/
#define	SYSCFG_ICSXB	(1 << 7)	/*
	If set, assume presence of an external buffer for IOCS16*; operate
	the buffer as a totem-pole output.

	If clear, run in psuedo-ISA mode; output is open drain.  But note 
	that on the 082 the output buffers cannot drive a 300-ohm
	load.
*/
#define	SYSCFG_NOPDN	(1 << 8)	/*
	If set, disable the auto power-down sequencing.  The chip will
	run card cycles somewhat more quickly (though perhaps not
	significantly so); but it will dissipate significantly more power.

	If clear, the low-power operating modes are enabled.  This
	causes the part to go into low-power mode automatically at
	system reset.

*/
#define	SYSCFG_MPSEL_SHFT (9)
#define	SYSCFG_MPSEL_MASK (7 << 9)		/*
	This field controls the operation of the multipurpose pin on the
	86082.  It has the following codes:
*/
#define	  SYSCFGMPSEL_OFF	(0 << SYSCFG_MPSEL_SHFT)	/*
		This is the reset state; it indicates that the Multi-purpose
		pin is not used.  The pin will be held in a high-impedance
		state.  It can be read by monitoring SYSCFG_MPSENSE.
*/
#define	  SYSCFGMPSEL_NEEDCLK	(1 << SYSCFG_MPSEL_SHFT)	/*
		NMULTI is an output.
		External indication that CCLK or BCLK are needed in order
		to complete an internal operation.  External logic can use
		this to control the clocks coming to the chip.
*/
#define	  SYSCFGMPSEL_MIO	(2 << SYSCFG_MPSEL_SHFT)	/*
		NMULTI is an input; it is an unambiguous M/IO signal, issued
		with timing similar to the LA[] lines.
*/
#define	  SYSCFGMPSEL_EXTSEL	(3 << SYSCFG_MPSEL_SHFT)	/*
		NMULTI is an output; it is the external register select
		pulse, generated whenever software attempts to access
		aux register AR_EXTRN. Of course, the 86082 will ignore
		writes to AR_EXTRN, and will float the data bus if
		the CPU reads from AR_EXTRN.
*/
/*				(4 << SCFG_MPSEL_SHFT)	 is reserved */

#define	  SYSCFGMPSEL_RI	(5 << SYSCFG_MPSEL_SHFT)	/*
		NMULTI is an output; it indicates a RI (active-going)
		transition has occurred lately on a an appropriately-
		configured socket.  The output is active low.
*/
/*
		Codes 4, 6 and 7 are reserved, and must NOT be output.  It is
		indeed possibly hazardous to your system to encode values in
		this field that do not match your hardware!
*/

/*			1 << 12		reserved */

#define	SYSCFG_MPSENSE	(1 << 13)	/* 
	This bit, when read, returns the sense of the multi-purpose
	pin.
*/


#define	SYSCFG_AUTOBUSY	(1 << 14)	/* 
	This bit, when set, causes the busy led to be gated with the
	SYSCFG_ACC bit.  When clear, the busy led reflects whether the
	socket is actually enabled.  If AUTOBUSY is set and ACC is clear,
	then the busy light will be off, even if a socket is enabled.
	If AUTOBUSY is clear, then the busy light will be on if either
	socket is enabled.

	Note, that when in a programming mode, you should either clear this
	bit (causing the busy light to be on whenever the socket is enabled)
	or set both this bit and the ACC bit (causing the light to be on
	all the time).	

	On the '084 and '184, this bit is per-socket.

*/

#define	SYSCFG_ACC	(1<<15)		/* 
	This bit will be set automatically by the hardware whenever the CPU
	accesses data on a card.  It can be cleared under software control.

	In AUTOBUSY mode, it has the additional effect of turning on the
	busy light.

	Since we'll tristate the command lines as the card is going out of
	the socket, and since the shared lines idle low, there's no real
	danger if the busy light is off even though the socket is enabled.

	On the '084 and '184, this bit is per-socket.

*/

/*
 C0: The interlock control register.
*/
#define	AR_ILOCK	(R_AUX+0)	/* symbolic handle for low byte */

#define	ILOCK_OUT	(1 << 0)	/* interlock output 
					|| per-socket on x84
					*/
#define	ILOCK_SENSE	(1 << 1)	/* (r/o) interlock sense
					||  0 -> /cilock not asserted;
					||  1 -> /cilock is asserted.
					|| per-socket on x84.
					*/
#define	ILOCK_CRESET	(1 << 2)	/* card reset output level (S) */
#define	ILOCK_CRESENA	(1 << 3)	/* enable card reset output (S) */
#define	ILOCK_CWAIT	(1 << 4)	/* enable card wait (S) */
#define	ILOCK_CWAITSNS	(1 << 5)	/* (r/o) sense current state of wait 
					||  0 -> /cwait not asserted; 
					||  1 -> /cwait is asserted
					|| (S)
					*/
/*  the shift count & mask for the hold-time control */
#define	ILOCK_HOLD_SHIFT	6	/* shift count for the hold-time ctl (G) */
#define	ILOCK_HOLD_MASK		(3 << ILOCK_HOLD_SHIFT)

/* 
|| quick hold mode waits until we observe that the strobe is high,
|| guaranteeing 10ns or so of hold time.
*/
#define	  ILOCK_HOLD_QUICK	(0 << ILOCK_HOLD_SHIFT)

/*
|| CCLK hold mode waits (asynchronously) for an edge on CCLK.  Minimum is 1 
|| CCLK + epsilon; maximum is 2 CCLKs + epsilon.
||
|| for the 86081 & '82, this mode enables the multi-step
|| sequencer that generates setup and hold times based on CCLK.  This
|| is the recommended mode of operation for the '81 and '82.
*/
#define	  ILOCK_HOLD_CCLK	(3 << ILOCK_HOLD_SHIFT)

/**** The following bits are only present on the x84 and later parts ****/
#define	ILOCK_INPACK	(1 << 11)	/* (r/o, S) this bit is a diagnostic
					|| read-back for card input
					|| acknowledge.
					|| The sense is inverted from the
					|| level at the pin.
					*/
#define	ILOCK_CP0	(1 << 12)	/* (r/o, S) this bit is a diagnostic
					|| monitor for card present pin 0.
					|| The sense is inverted from the
					|| level at the pin.
					*/
#define	ILOCK_CP1	(1 << 13)	/* (r/o, S) this bit is a diagnostic
					|| monitor for card present pin 1.
					|| The sense is inverted from the
					|| level at the pin.
					*/
#define	ILOCK_VS1	(1 << 14)	/* (r/o, S) this bit is the primary
					|| monitor for Card Voltage Sense
					|| pin 1.
					|| The sense is inverted from the
					|| level at the pin.
					*/
#define	ILOCK_VS2	(1 << 15)	/* (r/o, S) this bit is the primary
					|| monitor for Card Voltage Sense
					|| pin 2.
					|| The sense is inverted from the
					|| level at the pin.
					*/
/*

	Silicon Version Register

In diagnostic mode, the high byte of the interlock register is defined as the 
silicon identity byte.

In order to read this byte, the chip must be placed in diagnostic
mode by setting bit 15 of the TESTDIAG register.  (This may or may
not be enforced by the silicon.)

The layout is:

	15 14 13 12 11 10 9 8    7 6 5 4 3 2 1 0
	m  <-------ID------->	 <----ILOCK---->

The fields are:

m	Always reset.

ID	This field is one of the following:

	0x02	the db86082

	0x03	the db86082a

	0x04	the db86084

	0x05	the DB86072ES,	(Engineering Sample)

	0x07	the db86082bES,	(Engineering Sample)

	0x08	the db86084a

	0x14	the DB86184

	0x15	the DB86072,	(Production)

	0x17	the db86082b,	(Production)

*/

/*
|| Defines for Silicon IDs described above.
||
|| Use the following convention for defining SILID_DBxxxxxY:
||
||	SILID_DBxxxxx_1		The First step of chip.
||	SILID_DBxxxxxA		The Second step of chip.
||	SILID_DBxxxxxB		The Third step of chip.
||	SILID_DBxxxxx...	The ... step of chip.
||
||	SILID_DBxxxxx"step of chip"_ES	An Engineering Sample of chip.
||
*/
#define SILID_DB86082_1		(0x02)
#define SILID_DB86082A		(0x03)
#define SILID_DB86082B_ES	(0x07)
#define SILID_DB86082B		(0x17)

#define SILID_DB86084_1		(0x04)
#define SILID_DB86084A		(0x08)

#define SILID_DB86184_1		(0x14)

#define SILID_DB86072_1_ES	(0x05)
#define SILID_DB86072_1		(0x15)


/**** the high order bits (in diag mode) give the chip version ****/
#define	AR_ILOCK_ID	(R_AUX + 1)

#define	ILOCKTEST_ID_SHFT	8	/* the shift count */
#define	ILOCKTEST_ID_MASK	(0x7F << ILOCKTEST_ID_SHFT)
					/* the mask for the field */

/*
|| Use the following convention for defining ILOCKTEST_DBxxxxxY:
||
||	ILOCKTEST_DBxxxxx_1	The First step of chip.
||	ILOCKTEST_DBxxxxxA	The Second step of chip.
||	ILOCKTEST_DBxxxxxB	The Third step of chip.
||	ILOCKTEST_DBxxxxx...	The ... step of chip.
||
||	ILOCKTEST_DBxxxxx"step of chip"_ES	An Engineering Sample of chip.
||
*/
#define	ILOCKTEST_TCIC2N_1	((SILID_DB86082_1) << ILOCKTEST_ID_SHFT)
#define	ILOCKTEST_DB86082_1	ILOCKTEST_TCIC2N_1
#define	ILOCKTEST_TCIC2N_2	((SILID_DB86082A) << ILOCKTEST_ID_SHFT)
#define	ILOCKTEST_DB86082A	ILOCKTEST_TCIC2N_2
#define	ILOCKTEST_TCIC2N_3	((SILID_DB86082B_ES) << ILOCKTEST_ID_SHFT)
#define	ILOCKTEST_DB86082B_ES	ILOCKTEST_TCIC2N_3

#define	ILOCKTEST_DB86082B	((SILID_DB86082B) << ILOCKTEST_ID_SHFT)

#define	ILOCKTEST_DB86084_1	((SILID_DB86084_1) << ILOCKTEST_ID_SHFT)
#define	ILOCKTEST_DB86084A	((SILID_DB86084A) << ILOCKTEST_ID_SHFT)

#define	ILOCKTEST_DB86184_1	((SILID_DB86184_1) << ILOCKTEST_ID_SHFT)

#define	ILOCKTEST_DB86072_1	((SILID_DB86072_1) << ILOCKTEST_ID_SHFT)
#define	ILOCKTEST_DB86072_1_ES	((SILID_DB86072_1_ES) << ILOCKTEST_ID_SHFT)

/**** the test control register ****/
#define	AR_TEST	(R_AUX + 0)
#define	TEST_AEN	(1 << 0)	/* force card AEN */
#define	TEST_CEN	(1 << 1)	/* force card CEN */
#define	TEST_CTR	(1 << 2)	/* test programming pulse, address ctrs */
#define	TEST_ENA	(1 << 3)	/* force card-present (for test), and
					|| special VPP test mode
					*/
#define	TEST_IO		(1 << 4)	/* feed back some I/O signals
					|| internally.
					*/
#define	TEST_OUT1	(1 << 5)	/* force special address output mode */
#define	TEST_ZPB	(1 << 6)	/* enter ZPB test mode */
#define	TEST_WAIT	(1 << 7)	/* force-enable WAIT pin */
#define	TEST_PCTR	(1 << 8)	/* program counter in read-test mode */
#define	TEST_VCTL	(1 << 9)	/* force-enable power-supply controls */
#define	TEST_EXTA	(1 << 10)	/* external access doesn't override
					|| internal decoding.
					*/
#define	TEST_DRIVECDB	(1 << 11)	/* drive the card data bus all the time */
#define	TEST_ISTP	(1 << 12)	/* turn off CCLK to the interrupt CSR */
#define	TEST_BSTP	(1 << 13)	/* turn off BCLK internal to the chip */
#define	TEST_CSTP	(1 << 14)	/* turn off CCLK except to int CSR */
#define	TEST_DIAG	(1 << 15)	/* enable diagnostic read-back mode */

/*

	Indirectly Addressed Registers

Indirect address	Function
----------------	--------

[$000:$003]		Socket configuration registers for socket 0.
[$008:$00A]		Socket configuration registers for socket 1.
			(we allow for up to 8 sockets per adapter)

[$00B:$0FF]		reserved

[$100:$107]		Memory window 0 translation registers:
			$100: reserved;
			$102: base window address
			$104: map to card address
			$106: control register.
[$108:$10F]		Memory window 1 translation registers
[$110:$117]		Memory window 2 translation registers
			...
[$138:$13F]		Memory window 7 translation registers
[$140:$147]		Memory window 8 translation registers
[$148:$14F]		Memory window 9 translation registers

			(the architecture reserves room for up to
			32 windows.)

[$200:$203]		I/O window 0 translation registers
[$204:$207]		I/O window 1 translation registers
[$208:$20B]		I/O window 2 translation registers
[$20C:$20F]		I/O window 3 translation registers

[$210:$2FF]

[$300:$301]		Adapter configuration register 0 ('x84 and later)

[$320:$321]		Configuration ROM CSR.

[$380:$381]		Plug and Play ISA read port and address port reister
[$382:$383]		Plug and Play ISA configuration sequence number and
			logical device number register.
[$384:$385]		Plug and Play chip ID/test register.
[$386:$387]		Plug and Play config selection register.
[$386:$3FFFFFF]		Reserved  -- do not read or write.

*/

/*

Bit definitions:

1) The Indirect Socket Configuration Registers:

*/

#define	IR_SCFG_S(skt)	(0 + (skt) * 8)	/* base indices of socket config */
#define	IR_SCFG_S0	IR_SCFG_S(0)	/* base indices of socket config */
#define	IR_SCFG_S1	IR_SCFG_S(1)	/*   regs for socket 0, 1 */


#define	IR_MWIN_BASE		0x100	/* where they start */

#define	IR_MWIN_NUM_082		8	/* number of memory windows */
#define	IR_MWIN_NUM_082A	10	/* number of memory windows in 082a */
#define	IR_MWIN_NUM_082B	10	/* number of memory windows in 082b */
#define	IR_MWIN_NUM_084		10	/* number of memory windows in 084 */
#define	IR_MWIN_NUM_184		10	/* number of memory windows in 184 */
#define	IR_MWIN_NUM_072		10	/* number of memory windows in 072 */
#define	IR_MWIN_NUM_MAX		32	/* make arrays of windows this big */

#define	IR_MWIN_SIZE		8	/* 8 bytes per window descriptor */
#define	IR_MBASE_X		2	/* index to the memory base controlreg */
#define	IR_MMAP_X		4	/* index to the memory map control reg */
#define	IR_MCTL_X		6	/* index to the memory window control reg */

#define	IR_MBASE_W(w)	(IR_MWIN_BASE + (w) * IR_MWIN_SIZE + IR_MBASE_X)
#define	IR_MMAP_W(w)	(IR_MWIN_BASE + (w) * IR_MWIN_SIZE + IR_MMAP_X)
#define	IR_MCTL_W(w)	(IR_MWIN_BASE + (w) * IR_MWIN_SIZE + IR_MCTL_X)

#define	IR_IOWIN_BASE		0x200	/* where they start */
#define	IR_IOWIN_SIZE		4	/* bytes per window descriptor */
#define	IR_IOWIN_NUM		4	/* we have 4 of them on the 082 */
					/* should be defined as 0 on the
					86301 */
#define	IR_IOBASE_X		0	/* index to the I/O base register */
#define	IR_IOCTL_X		2	/* index to the I/O window control register */

#define	IR_IOBASE_W(w)	(IR_IOWIN_BASE + (w) * IR_IOWIN_SIZE + IR_IOBASE_X)
#define	IR_IOCTL_W(w)	(IR_IOWIN_BASE + (w) * IR_IOWIN_SIZE + IR_IOCTL_X)

/**** patterns in the indirect registers ****/
#define	IRSCFG_IRQ_MASK		(0xF)	/* mask for this bit field */
#define	  IRSCFG_IRQOFF		(0)	/* disable */
#define   IRSCFG_SIRQ		(0x1)	/* use SKTIRQ (2/N) */
#define   IRSCFG_IRQ3		(0x3)	/* use IRQ3 */
#define   IRSCFG_IRQ4		(0x4)	/* use IRQ4 */
#define   IRSCFG_IRQ5		(0x5)	/* use IRQ5 */
#define   IRSCFG_IRQ6		(0x6)	/* use IRQ6 */
#define   IRSCFG_IRQ7		(0x7)	/* use IRQ7 */
#define	  IRSCFG_IRQ9		(0x9)	/* use IRQ9 */
#define   IRSCFG_IRQ10		(0xA)	/* use IRQ10 */
#define	  IRSCFG_IRQ11		(0xB)	/* use IRQ11 */
#define	  IRSCFG_IRQ12		(0xC)	/* use IRQ12 */
#define   IRSCFG_IRQ14		(0xE)	/* use IRQ14 */
#define	  IRSCFG_IRQ15		(0xF)	/* use IRQ15 */


#define	IRSCFG_IRQOC		(1 << 4)	/* selected IRQ is
						|| open-collector, and active
						|| low; otherwise it's totem-
						|| pole and active hi.
						*/
#define	IRSCFG_PCVT		(1 << 5)	/* convert level-mode IRQ
						|| to pulse mode, or stretch
						|| pulses from card.
						*/
#define	IRSCFG_IRDY		(1 << 6)	/* interrupt from RDY (not
						|| from /IREQ).  Used with
						|| ATA drives.
						*/
#define	IRSCFG_ATA		(1 << 7)	/* Special ATA drive mode.
						|| CEL/H become CE1/2 in
						|| the IDE sense; CEL is
						|| activated for even window
						|| matches, and CEH for
						|| odd window matches.
						*/
#define	IRSCFG_DMA_SHIFT	8		/* offset to DMA selects; */
#define	IRSCFG_DMA_MASK		(0x7 << IRSCFG_DMA_SHIFT)

#define	  IRSCFG_DMAOFF		(0 << IRSCFG_DMA_SHIFT)	/* disable DMA */
#define	  IRSCFG_DREQ2		(2 << IRSCFG_DMA_SHIFT)	/* enable DMA on DRQ2 */

#define	IRSCFG_IOSTS		(1 << 11)	/* enable I/O status mode;
						||  allows CIORD/CIOWR to
						||  become low-Z.
						*/
#define	IRSCFG_SPKR		(1 << 12)	/* enable SPKR output from
						|| this card
						*/
#define	IRSCFG_FINPACK		(1 << 13)	/* force card input
						|| acknowledge during I/O
						|| cycles.  Has no effect
						|| if no windows map to card
						*/
#define	IRSCFG_DELWR		(1 << 14)	/* force -all- data to
						|| meet 60ns setup time
						|| ("DELay WRite")
						*/
#define	IRSCFG_HD7IDE		(1 << 15)	/* Enable special IDE
						|| data register mode:  odd
						|| byte addresses in odd
						|| I/O windows will not
						|| drive HD7.
						*/

/***** bits in the second config register *****/
#define	IR_SCF2_S(skt)	(IR_SCFG_S(skt) + 2)	/* index to second config reg */
#define	IR_SCF2_S0	IR_SCF2_S(0)		/* second config for socket 0 */
#define	IR_SCF2_S1	IR_SCF2_S(1)		/* second config for socket 0 */

#define	IRSCF2_RI	(1 << 0)		/* enable RI pin from STSCHG 
						|| (2/N)
						*/
#define	IRSCF2_IDBR	(1 << 1)		/* force I/O data bus routing
						|| for this socket, regardless
						|| of cycle type. (2/N)
						*/
#define	IRSCF2_MDBR	(1 << 2)		/* force memory window data
						|| bus routing for this
						|| socket, regardless of cycle
						|| type. (2/N)
						*/
#define	IRSCF2_MLBAT1	(1 << 3)		/* disable status change
						|| ints from LBAT1 (or
						|| "STSCHG"
						*/
#define	IRSCF2_MLBAT2	(1 << 4)		/* disable status change
						|| ints from LBAT2 (or
						|| "SPKR"
						*/
#define	IRSCF2_MRDY	(1 << 5)		/* disable status change ints
						|| from RDY/BSY (or /IREQ).
						|| note that you get ints on
						|| both high- and low-going
						|| edges if this is enabled.
						*/
#define	IRSCF2_MWP	(1 << 6)		/* disable status-change ints
						|| from WP (or /IOIS16).
						|| If you're using status
						|| change ints, you better set
						|| this once an I/O window is
						|| enabled, before accessing
						|| it.
						*/
#define	IRSCF2_MCD	(1 << 7)		/* disable status-change ints
						|| from Card Detect.
						*/

/* 
|| note that these bits match the top 5 bits of the socket status register
|| in order and sense.
*/

#define	IRSCF2_DMASRC_MASK	(0x3 << 8)	/* mask for this bit field */
						/*-- DMA Source --*/
#define	  IRSCF2_DRQ_BVD2	(0x0 << 8)	/*     BVD2       */
#define   IRSCF2_DRQ_IOIS16	(0x1 << 8)	/*     IOIS16     */
#define   IRSCF2_DRQ_INPACK	(0x2 << 8)	/*     INPACK     */
#define   IRSCF2_DRQ_FORCE	(0x3 << 8)	/*     Force it   */

/*	reserved	(0xFC00) */		/* top 6 bits are RFU */


/****************************************************************************\
|
| The memory window control registers.
|
\****************************************************************************/

/*
|| The BASE ADDRESS register establishes a correspondence between
|| a host bus address and a particular memory window.
||
|| The MAP ADDRESS register establishes a correspondence between a
|| window and a particular card address.  The contents of this register
|| are ADDED to the address from the host, and (therefore) are not
|| independent of the value in the BASE ADDRESS register.  That is,
|| the value to put into the MAP ADDRESS register to map to page
|| 0 of common space is NOT (in general) 0; it is, rather, (-window
|| base address), in twos complement.
||
|| Of course, you must use the twos complement of the actual window
|| base, NOT of the value that's actually in the BASE ADDRESS register;
|| that value also has the window size encoded in it.
||
|| The window enable bit for a given window is automatically cleared whenever 
|| you write to the BASE ADDRESS register.
*/
/**** the base register ****/
#define	MBASE_ILV	(1 << 15)		/* rfu */
#define	MBASE_4K	(1 << MBASE_4K_BIT)	/* if set, addresses are 4K */
#define	  MBASE_4K_BIT	14			/*  (bit shift count) */
#define	MBASE_HA_SHFT	(12)			/* shift host addresses 
						|| right this much 
						*/
#define	MBASE_HA_MASK	(0xFFF)			/* mask for host address
						|| bits in this register
						*/
#define	MBASE_HA2BASE(ha)	\
	( \
	 ((USHORT) ((ha) >> MBASE_HA_SHFT) & MBASE_HA_MASK) \
	| \
	 (((USHORT) (ha) & (1 << 11)) << (MBASE_4K_BIT - 11)) \
	)

#define	MBASE_BASE2HA(base) \
	( \
	((ULONG) ((base) & MBASE_HA_MASK) << MBASE_HA_SHFT) \
	| \
	(((base) & MBASE_4K) >> (MBASE_4K_BIT - 11)) \
	)

/**** the card mapping register ****/
#define	MMAP_CA_SHFT	12		/* shift card address right this much */
#define	MMAP_CA_MASK	(0x3FFF)	/* then mask with this */
#define	MMAP_REG	(1 << 15)	/* the REG bit */

/**** the mem window control register ****/
#define	MCTL_WSCNT_MASK	0x1F		/* the wait-state mask register */
#define	MCTL_WSCNT_SHFT	0		/* how to align it */

/* reserved		(1<<5)		-- this bit is reserved */

#define	MCTL_QUIET	(1<<6)		/* the window is quiet */
#define	MCTL_WP		(1<<7)		/* prohibit writes via this window */
#define	MCTL_ACC	(1<<8)		/* if set, we've used this window */
#define	MCTL_KE		(1<<9)		/* enable caching on this window */
#define	MCTL_EDC	(1<<10)		/* enable EDC on this window */
#define	MCTL_B8		(1<<11)		/* force window to be 8 bits */
#define	MCTL_SS_SHFT	(TCIC_SS_SHFT)	/* socket select in standard place (bits 12-14) */
#define	MCTL_SS_MASK	(TCIC_SS_MASK)	/* ditto for mask */
#define	MCTL_ENA	(1<<15)		/* enable the window */

/**** the I/O base register ****/
/*
||  the base and length are encoded here, pretty much as they are for the
||  memory base register; however, a 17th bit is needed, and can be found
||  in the I/O window control register (IOCTL_TINY).
*/

/**** the I/O control register ****/
#define	ICTL_WSCNT_MASK	MCTL_WSCNT_MASK	/* these are the same */
#define	ICTL_WSCNT_SFHT	MCTL_WSCNT_SHFT	/* and are shown this way to ensure
					|| that you can use the same code to
					||generate them, if you like
					*/
#define	ICTL_PASS16	(1 << 5)	/* If this bit is set, then all 16
					|| bits of an I/O address will be
					|| passed through to the card, even
					|| if the window is only a 10-bit
					|| window.  If reset, then only 10
					|| bits will be passed if this is a
					|| 1K window, even if HA[15:10] were
					|| non-zero.  Regardless of the
					|| value of this bit, the 082 always
					|| acts as if this bit were clear.
					*/
#define	ICTL_QUIET	MCTL_QUIET	/* more commonality */
#define	ICTL_1K		(1 << 7)	/* ignore ha[15:10] in comparisons;
					|| this makes us 100% PC compatible.
					*/
#define	ICTL_ACC	MCTL_ACC	/* more commonality */
#define	ICTL_TINY	(1 << 9)	/* window is exactly 1 byte long */
#define	ICTL_B16	(1 << 10)	/* I/O mode stuff; force 16 bit, but
					|| also encodes stuff; see below.
					*/
#define	ICTL_B8		(MCTL_B8)

/* B8 and B16, taken together, define the bus width for this window: */
#define	  ICTL_BW_MASK	(ICTL_B8 | ICTL_B16)	/* the field itself. */
#define	  ICTL_BW_DYN	(0)			/* use CIOIS16 */
#define	  ICTL_BW_8	(ICTL_B8)		/* force 8-bit (no /HIOCS16) */
#define	  ICTL_BW_16	(ICTL_B16)		/* force 16-bit (force HIOCS16) */
#define	  ICTL_BW_ATA	(ICTL_B8|ICTL_B16)	/* ATA mode IOCS16 */

/* 

"ATA mode IOCS16" means that this window is to be used with an ATA/IDE-like
drive.  /HIOCS16 is asserted for references to addresses 0, 8, ...  within
the window; it is deasserted for all other addresses.

*/

/* socket is selected in the usual way, using the usual fields */
#define	ICTL_SS_SHFT	(TCIC_SS_SHFT)	/* the shift count for the socket 
					|| for this window (12) 
					*/
#define	ICTL_SS_MASK	(TCIC_SS_MASK)	/* the mask for the field (0x7000) */

#define	ICTL_ENA	(MCTL_ENA)	/* enable the window (same fn/same bit) */

/****************************************************************************\
|
|	The TCIC architecture V2.0 registers
|
\****************************************************************************/

#define	IR_ADPTCFG0	0x300		/* The primary adapter config register */
#define IRADPCF0_PNPCS	(1 << 0)	/* if set, using PnP to set base addr */
#define	IRADPCF0_MULTI	(1 << 1)	/* if set, NMULTI# functions are available */
#define	IRADPCF0_EE1K	(1 << 2)	/* if set, if EEPROM is present, it's 1K (max) */
#define	IRADPCF0_EE	(1 << 3)	/* if set, EE control is present */
#define	IRADPCF0_DRQ2	(1 << 4)	/* if set, DMA is possible */
#define	IRADPCF0_IRQ6	(1 << 5)	/* if set, IRQ6 is available */
#define	IRADPCF0_IRQ9	(1 << 6)	/* if set, IRQ9 is available */
#define	IRADPCF0_IRQ12	(1 << 7)	/* if set, IRQ12 is available */
#define	IRADPCF0_IRQ15	(1 << 8)	/* if set, IRQ15 is available */
#define	IRADPCF0_3V	(1 << 9)	/* if set, CVS & 3V/5V are enabled */
#define	IRADPCF0_BUSYLED (1 << 10)	/* if set, we have busy light(s) */
#define	IRADPCF0_BUSYSKT (1 << 11)	/* if set, busy lights are per skt */
#define	IRADPCF0_ILOCK	(1 << 12)	/* if set, we have interlocks */
#define	IRADPCF0_ILOCKSKT (1 << 13)	/* if set, ilocks are per-skt */
#define	IRADPCF0_NONSTD	(1 << 14)	/* if set, a hardware-specific driver
					|| is required.
					*/
#define	IRADPCF0_READY	(1 << 15)	/* if set, TCIC has finished power-up
					|| self configuration.
					*/

#define	IR_ROMCSR	0x320		/* the config ROM csr */
					
#define	IR_ROMCSR_ADDR_MASK	0xFF	/* the WORD address bits */
#define	IR_ROMCSR_CMD_SHFT	12	/* the ROM command bit offset */
#define	IR_ROMCSR_CMD_MASK	(3 << 12) 

#define	IR_ROMCSR_GO	(1 << 14)	/* set this bit to process a command */
#define	IR_ROMCSR_BUSY	(1 << 15)	/* r/o:  set while working */

/**** the READ command -- data shows up in PDATA ****/
#define	IR_ROMCSR_READCMD(a)	\
	((2 << IR_ROMCSR_CMD_SHFT) | \
	((a) & IR_ROMCSR_ADDR_MASK))

/**** the WRITE command ****/
#define	IR_ROMCSR_WRITECMD(a)	\
	((1 << IR_ROMCSR_CMD_SHFT) | \
	((a) & IR_ROMCSR_ADDR_MASK))

/**** the ERASE WORD command ****/
#define	IR_ROMCSR_ERASEWDCMD(a)	\
	((3 << IR_ROMCSR_CMD_SHFT) | \
	((a) & IR_ROMCSR_ADDR_MASK))

/**** the WRITE-ENABLE command ****/
#define	IR_ROMCSR_WRITEENA \
	((0 << IR_ROMCSR_CMD_SHFT) | \
	((0x03) & IR_ROMCSR_ADDR_MASK))

/**** the WRITE-DISABLE command ****/
#define	IR_ROMCSR_WRITEDSA \
	((0 << IR_ROMCSR_CMD_SHFT) | \
	((0x00) & IR_ROMCSR_ADDR_MASK))

/****************************************************************************\
|
|	The plug and play test registers 
|
\****************************************************************************/

#define	IR_PNPADDRP	0x380		/* PnP ISA:  read port, address port */
#define	IRPNPADDR_ADDR_MASK	0x00FF	/* the last value written to the 
					|| PnP address register.
					*/
#define	IRPNPADDR_ADDR_SHFT	0
#define	IRPNPADDR_RDP_MASK	0xFF00	/* the last value written to the read-
					|| data port-address PnP register.
					*/
#define	IRPNPADDR_RDP_SHFT	8	

/**** handy place to figure out CSN, LDN ****/
#define	IR_PNPCSNLDN	0x382		/* PnP ISA:  card seq no, log dev no */
#define	IRPNPCSN_LDN_MASK	0xFF00	/* the last value written to this
					|| chip's PnP logical dev # reg.
					*/
#define	IRPNPCSN_LDN_SHFT	8
#define	IRPNPCSN_CSN_MASK	0x00FF	/* the last value written to this
					|| chip's PnP CSN register.
					*/
#define	IRPNPCSN_CSN_SHFT	0	

/**** handy place to figure out chip ID ****/
#define	IR_PNPTEST	0x384		/* PnP ISA:  chip id */
#define	IRPNPTEST_CHIPID_MASK	0x00FF	/* the Chip ID captured during the last
					|| PnP wake-up seqeunce.
					*/
#define	IRPNPTEST_CHIPID_SHFT	0	
#define	IRPNPTEST_LSTCFGCTL_SHFT 8	/* the last value written to cfgctl */
#define	IRPNPTEST_LSTCFGCTL_MASK (7 << IRPNPTEST_LSTCFGCTL_SHFT)
#define	IRPNPTEST_ISO2ND	(1 << 11)
#define	IRPNPTEST_MTCH1ST	(1 << 12)
#define	IRPNPTEST_STATE_SHFT	13
#define	IRPNPTEST_STATE_MASK	(3 << IRPNPTEST_STATE_SHFT)
#define	IRPNPTEST_STATE_WFK	(0 << IRPNPTEST_STATE_SHFT)
#define IRPNPTEST_STATE_SLP	(1 << IRPNPTEST_STATE_SHFT)
#define	IRPNPTEST_STATE_ISO	(2 << IRPNPTEST_STATE_SHFT)
#define	IRPNPTEST_STATE_CFG	(3 << IRPNPTEST_STATE_SHFT)

/**** the following register lets us see what PNP software has done ****/
#define	IR_PNPCFG	0x386		/* PnP ISA:  configuration info */
#define	IRPNPCFG_IRQ_SHFT	0
#define	IRPNPCFG_IRQ_MASK	(0xF << IRPNPCFG_IRQ_SHFT)

#define	IRPNPCFG_IRQLVL		(1 << 4)	/* Level IRQ selected */
#define	IRPNPCFG_IRQHIGH	(1 << 5)	/* active high IRQ select */

#define	IRPNPCFG_DMA_SHFT	8
#define	IRPNPCFG_DMA_MASK	(7 << IRPNPCFG_DMA_SHFT)

/**** end of tcic2.h ****/
#endif /* _TCIC2_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\inc\tcicext.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    tcicext.h

Abstract:

	Definitions for TCIC support helper functions.
	
Author(s):
		John Keys - Databook Inc. 7-Apr-1995

Revisions:
--*/

#ifndef _tcicext_h_				// prevent multiple includes 
#define _tcicext_h_

BOOLEAN 
TcicReservedBitsOK(
	IN PSOCKET pskt
	);

VOID
TcicFillInAdapter(
	IN PSOCKET plocskt,
	IN PSOCKET *psocketPtr, 
	IN PSOCKET *previousSocketPtr, 
	IN PFDO_EXTENSION DeviceExtension,
	IN ULONG   ioPortBase
	);

USHORT
TcicReadBaseReg(
    IN PSOCKET SocketPtr,
    IN ULONG   Register
    );
	
VOID
TcicWriteBaseReg(
    IN PSOCKET SocketPtr,
    IN ULONG   Register,
	IN USHORT  value
    );
	
ULONG
TcicReadAddrReg(
    IN PSOCKET SocketPtr
	);

VOID
TcicWriteAddrReg(
	IN PSOCKET SocketPtr,
	IN ULONG   addr
	);

USHORT
TcicReadAuxReg(
    IN PSOCKET SocketPtr,
    IN ULONG   Register
    );

VOID
TcicWriteAuxReg(
    IN PSOCKET SocketPtr,
    IN ULONG   Register,
	IN USHORT  value
    );

VOID
TcicReadIndirectRegs(
    IN PSOCKET SocketPtr,
    IN ULONG   StartRegister,
	IN USHORT  numWords,
	IN PUSHORT ReadBuffer
    );
	
VOID
TcicWriteIndirectRegs(
    IN PSOCKET SocketPtr,
    IN ULONG   StartRegister,
	IN USHORT  numWords,
	IN PUSHORT WriteBuffer
    );

USHORT 
TcicSocketSelect(
	IN PSOCKET SocketPtr,
	IN USHORT sktnum
	);

PUCHAR
TcicAllocateMemRange(
    IN PFDO_EXTENSION DeviceExtension,
    IN PULONG Mapped,
    IN PULONG Physical
    );

USHORT 
TcicChipID (
	IN PDBSOCKET pInst
	);

BOOLEAN 
TcicCheckSkt(
	IN PSOCKET pInst, 
	IN int iSocket
	);
	
USHORT 
TcicCheckAliasing(
	IN PDBSOCKET pdbskt, 
	IN USHORT offst
	);
	
USHORT 
TcicCheckAliasType (
	IN PDBSOCKET pInst
	);
	
BOOLEAN 
TcicCheckXBufNeeded(
	IN PSOCKET pInst
	);
	
VOID TcicSetMemWindow(
	IN PSOCKET pInst, 
	IN USHORT wnum, 
	IN ULONG_PTR base, 
	IN USHORT npages, 
	IN USHORT mctl
	);
	
VOID 
TcicGetPossibleIRQs(
	IN PDBSOCKET pInst, 
	IN UCHAR *ptbl
	);

CHIPPROPS *
TcicGetChipProperties(
	IN PDBSOCKET pInst
	);
	
BOOLEAN 
TcicChipIDKnown(
	IN PDBSOCKET pInst
	);
	
USHORT 
TcicGetnIOWins(
	IN PDBSOCKET pInst
	);

USHORT 
TcicGetnMemWins(
	IN PDBSOCKET pInst
	);

USHORT 
TcicGetFlags(
	IN PDBSOCKET pInst
	);

BOOLEAN 
TcicIsPnP(
	IN PDBSOCKET pInst
	);

BOOLEAN 
TcicHasSktIRQPin(
	IN PDBSOCKET pInst
	);

VOID 
TcicGetAdapterInfo(
	IN PDBSOCKET dbsocketPtr
	);
	
USHORT 
TcicGet5vVccVal(
	IN PDBSOCKET pInst
	);
	
VOID 
TcicGetIRQMap(
	IN PDBSOCKET pInst
	);
	

USHORT 
TcicClockRate(
	PSOCKET pInst
	);

VOID
TcicSetIoWin(
	IN PSOCKET socketPtr,
	IN USHORT  winIdx,
	IN ULONG   BasePort,
	IN ULONG   NumPorts,
	IN UCHAR   Attributes	
	);
	
VOID
TcicSetMemWin(
	IN PSOCKET socketPtr,
	IN USHORT  winIdx,
	IN ULONG   cardbase,
	IN ULONG   base,
	IN ULONG   size,
	IN UCHAR   AttrMem,
	IN UCHAR   AccessSpeed,		
	IN USHORT  Attributes	
	);


USHORT	
TcicMapSpeedCode(
	IN PDBSOCKET pdb, 
	IN UCHAR AccessSpeed
	);

VOID 
TcicAutoBusyOff(
	IN PDBSOCKET pdbs
	);
	
UCHAR 
TcicAutoBusyCheck(
	IN PDBSOCKET pdbs
	);
	
VOID
TcicCheckSktLED(	
	IN PDBSOCKET pdbs
	);
	
VOID
TcicBusyLedRoutine(
	IN PDEVICE_OBJECT DeviceObject,
	IN PVOID Context
	);
	
VOID 
TcicDecodeIoWin(
	USHORT	iobase,
	USHORT  ioctl,
	USHORT	*NumPorts,
	USHORT	*BasePort
	);
	
VOID 
TcicDecodeMemWin(
	USHORT	mbase,
	USHORT	mmap,
	USHORT  mctl,
	ULONG  *Host,
	ULONG  *Card,
	ULONG  *Size,
	UCHAR  *Attr
	);
	
	
#endif // _tcicext_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\inc\pcmcia.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    pcmcia.h

Abstract:

Revision History
    27-Apr-95
        Databook support added.
    1-Nov-96
        Complete overhaul to make this a bus enumerator +
        CardBus support
                  - Ravisankar Pudipeddi (ravisp)
--*/

#ifndef _PCMCIAPRT_
#define _PCMCIAPRT_

#define MAX_NUMBER_OF_IO_RANGES     2
#define MAX_NUMBER_OF_MEMORY_RANGES 4

#define MAX_MANFID_LENGTH   64
#define MAX_IDENT_LENGTH    64


//
// Function number for a multi-function pc-card
//
#define PCMCIA_MULTIFUNCTION_PARENT    0xFFFFFFFF

typedef enum _DEVICE_OBJECT_TYPE {
   FDO = 0,
   PDO
} DEVICE_OBJECT_TYPE;

//
// Type of the controller
//
typedef ULONG PCMCIA_CONTROLLER_TYPE, *PPCMCIA_CONTROLLER_TYPE;

struct _SOCKET;                         //forward references
struct _FDO_EXTENSION;
struct _PDO_EXTENSION;

//
// Define SynchronizeExecution routine.
//

typedef
BOOLEAN
(*PSYNCHRONIZATION_ROUTINE) (
   IN PKINTERRUPT           Interrupt,
   IN PKSYNCHRONIZE_ROUTINE Routine,
   IN PVOID                 SynchronizeContext
   );

//
// Define the Pcmcia controller detection routine
//

typedef
NTSTATUS
(*PPCMCIA_DETECT_ROUTINE) (
   struct _FDO_EXTENSION  *DeviceExtension
   );

//
// Completion routine called by various timed routines
//

typedef
VOID
(*PPCMCIA_COMPLETION_ROUTINE) (
   IN PVOID Context,
   IN NTSTATUS status
   );

//
// Register context structure used to save register contents
// when cardbus controllers are powered down..
//
typedef struct _PCMCIA_CONTEXT_RANGE {
    USHORT wOffset;
    USHORT wLen;
} PCMCIA_CONTEXT_RANGE, *PPCMCIA_CONTEXT_RANGE;

typedef struct _PCMCIA_CONTEXT {
   PPCMCIA_CONTEXT_RANGE Range;
   ULONG                 RangeCount;
   ULONG                 BufferLength;
   ULONG                 MaxLen;
} PCMCIA_CONTEXT, *PPCMCIA_CONTEXT;   

//
// Configuration entry parsed from CISTPL_CFTABLE_ENTRY
// on a pc-card. Indicates what kind of resource configurations
// the pc-card supports
//
typedef struct _CONFIG_ENTRY {
   struct _CONFIG_ENTRY *NextEntry;
   USHORT                NumberOfIoPortRanges;
   USHORT                NumberOfMemoryRanges;
   USHORT                IoPortBase[MAX_NUMBER_OF_IO_RANGES];
   USHORT                IoPortLength[MAX_NUMBER_OF_IO_RANGES];
   USHORT                IoPortAlignment[MAX_NUMBER_OF_IO_RANGES];
   ULONG                 MemoryHostBase[MAX_NUMBER_OF_MEMORY_RANGES];
   ULONG                 MemoryCardBase[MAX_NUMBER_OF_MEMORY_RANGES];
   ULONG                 MemoryLength[MAX_NUMBER_OF_MEMORY_RANGES];
   USHORT                IrqMask;

   //
   // Only one flag used now. Expect to have more in future..
   //
#define PCMCIA_INVALID_CONFIGURATION    0x00000001
   USHORT                Flags;

   //
   // Level or Edge triggered IRQ
   //
   UCHAR                 LevelIrq;
   //
   // Share disp.for the IRQ
   //
   UCHAR                 ShareDisposition;
   UCHAR                 IndexForThisConfiguration;
   //
   // Indicates if the i/o requirement supports 16-bit access
   //
   BOOLEAN               Io16BitAccess;
   //
   // Indicates if the i/o requirement supports 8-bit access
   // At least one of Io8BitAccess and Io16BitAccess must always
   // be true for a valid configuration
   //
   BOOLEAN               Io8BitAccess;
} CONFIG_ENTRY, *PCONFIG_ENTRY;

//
// Function configuration holds the data that goes in each functions's
// configuration registers
//

typedef struct _FUNCTION_CONFIGURATION {
   struct _FUNCTION_CONFIGURATION *Next;
   ULONG    ConfigRegisterBase;
   UCHAR    ConfigOptions;
   UCHAR    ConfigFlags;
   UCHAR    IoLimit;
   UCHAR    Reserved;
   ULONG    IoBase;
} FUNCTION_CONFIGURATION, *PFUNCTION_CONFIGURATION;

//
// Socket configuration is the holder of the actual controller setup
//

typedef struct _SOCKET_CONFIGURATION {
   //
   // Device irq assigned
   //
   ULONG   Irq;
   //
   // Optional Irq to indicate when card is ready
   //
   ULONG   ReadyIrq;
   ULONG   ConfigRegisterBase;
   
   ULONG   NumberOfIoPortRanges;

   struct _SOCKET_CONFIG_IO_ENTRY {
      ULONG Base;
      USHORT Length;
      BOOLEAN Width16;
      BOOLEAN WaitState16;
      BOOLEAN Source16;
      BOOLEAN ZeroWait8;
   } Io[MAX_NUMBER_OF_IO_RANGES];
   
   ULONG   NumberOfMemoryRanges;

   struct _SOCKET_CONFIG_MEM_ENTRY {
      ULONG HostBase;
      ULONG CardBase;
      ULONG Length;
      UCHAR IsAttribute;
      UCHAR WaitState;
      BOOLEAN Width16;
   } Memory[MAX_NUMBER_OF_MEMORY_RANGES];
   
   PFUNCTION_CONFIGURATION FunctionConfiguration;
   UCHAR   IndexForCurrentConfiguration;
} SOCKET_CONFIGURATION, *PSOCKET_CONFIGURATION;


//
// Each function on a PCCARD present gets socket data.  Socket data
// contains information concerning the function and its configuration.
//

typedef struct _SOCKET_DATA {
   //
   // Multi function pcards: links to
   // other socket-datas' off the same PC-Card
   //
   struct _SOCKET_DATA   *Next;
   struct _SOCKET_DATA   *Prev;

   struct _SOCKET        *Socket;
   //
   // Pointer to the pdo's extension corresponding
   // to this socket
   //
   struct _PDO_EXTENSION *PdoExtension;


   UCHAR          Mfg[MAX_MANFID_LENGTH];
   UCHAR          Ident[MAX_IDENT_LENGTH];
   USHORT         ManufacturerCode;
   USHORT         ManufacturerInfo;

   ULONG          ConfigRegisterBase; // Base address from config tuple.

   //
   // Number of configurations possible
   //
   ULONG          NumberOfConfigEntries;
   //
   // Pointer to head of list of configurations
   //
   PCONFIG_ENTRY  ConfigEntryChain;             // Offset 0x114
   //
   // CRC calculated from the relevant tuples, used in
   // constructing hardware ids
   //
   USHORT         CisCrc;
   //
   // Device Type: PCCARD_TYPE_xxxx
   //
   UCHAR          DeviceType;
   UCHAR          LastEntryInCardConfig;
   //
   // Voltage values requested
   //
   UCHAR          Vcc;
   UCHAR          Vpp1;
   UCHAR          Vpp2;
   UCHAR          Audio;

   UCHAR          RegistersPresentMask[16];
   //
   // Configuration entry number used when actually
   // starting the pc-card
   //
   UCHAR          ConfigIndexUsed;
   //
   // Number of function in a multifunction card - zero-based
   //
   UCHAR          Function;
   UCHAR          Flags;
   //
   // Pointer to the default configuration among the list of config entries
   // which will be used when the default bit is zero in a tuple (and
   // set when the default bit is one)
   //
   PCONFIG_ENTRY  DefaultConfiguration;

   ULONG          Instance;
   USHORT         JedecId;
   //
   // Resource map indices for the requested resources in the
   // merged multifunction resource requirements list
   //
   UCHAR          MfIrqResourceMapIndex;
   UCHAR          MfIoPortResourceMapIndex;
   UCHAR          MfMemoryResourceMapIndex;
   BOOLEAN        MfNeedsIrq;
   USHORT         MfIoPortCount;
   USHORT         MfMemoryCount;
} SOCKET_DATA, *PSOCKET_DATA;

//
// Bits defined in Flags field
//
#define SDF_ZV       1                          // Zoom video custom interface
#define SDF_JEDEC_ID 2

#define IsConfigRegisterPresent(xSocketData, reg) ((((xSocketData)->RegistersPresentMask[reg / 8] &          \
                                                                                  (1 << (reg % 8)) )) ?      \
                                                                                                TRUE:FALSE)

//
// Config list is an array used in translating CONFIG_ENTRY data to 
// IO_RESOURCE_LISTs
//

typedef struct _CONFIG_LIST {

   PSOCKET_DATA SocketData;
   PCONFIG_ENTRY ConfigEntry;

} CONFIG_LIST, * PCONFIG_LIST;

//
// PCMCIA configuration information structure contains information
// about the PCMCIA controller attached and its configuration.
//

typedef struct _PCMCIA_CONFIGURATION_INFORMATION {
   INTERFACE_TYPE                 InterfaceType;
   ULONG                          BusNumber;
   ULONG                          SlotNumber;
   PHYSICAL_ADDRESS               PortAddress;
   USHORT                         PortSize;
   USHORT                         UntranslatedPortAddress;
   //
   // Card status change interrupt: these fields are used only
   // for cardbus controllers.
   //
   CM_PARTIAL_RESOURCE_DESCRIPTOR Interrupt;
   CM_PARTIAL_RESOURCE_DESCRIPTOR TranslatedInterrupt;
   //
   // For PCI-based controllers, indicates the pin number which we need
   // for programming the controller interrupt.
   // NOTE: This is no longer needed (this was to handle CSC interrupts
   // for PCI-PCMCIA bridges (like CL PD6729). We no longer support interrupt
   // based card status change for these cntrollers. Get rid of it
   // whenever possible.
   //
   UCHAR                          InterruptPin;
   //
   // Another dead field. Legacy.
   //
   BOOLEAN                        FloatingSave;
   USHORT                         Reserved;    // Alignment
} PCMCIA_CONFIGURATION_INFORMATION, *PPCMCIA_CONFIGURATION_INFORMATION;

//
// PCMCIA_CTRL_BLOCK allows for a level of indirection, thereby allowing
// the top-level PCMCIA code to do it's work without worrying about who's
// particular brand of PCMCIA controller it's addressing.
//
// Note that this only implements TWO architectures, pcic and tcic. For
// more indirection, see DEVICE_DISPATCH_TABLE


typedef struct _PCMCIA_CTRL_BLOCK {

   //
   // Function to initialize the socket
   //

   BOOLEAN (*PCBInitializePcmciaSocket)(
      IN struct _SOCKET *Socket
      );

   //
   // Function to initialize the card in the socket.
   //

   NTSTATUS
   (*PCBResetCard)(
      IN struct _SOCKET *Socket,
      OUT PULONG pDelayTime
      );

   //
   // Function to determine if a card is in the socket
   //

   BOOLEAN (*PCBDetectCardInSocket)(
      IN struct _SOCKET *Socket
      );

   //
   // Function to determine if insertion status has changed.
   //

   BOOLEAN (*PCBDetectCardChanged)(
      IN struct _SOCKET *Socket
      );

   //
   // Function to determine if card status has been asserted.
   //

   BOOLEAN (*PCBDetectCardStatus)(
      IN struct _SOCKET *Socket
      );

   //
   // Function to determine if "card ready" status has changed
   //

   BOOLEAN (*PCBDetectReadyChanged)(
      IN struct _SOCKET *Socket
      );
      
   //
   // Function which requests that the controller be examined to
   // determine what power settings the current device in the socket
   // requires.
   //

   NTSTATUS
   (*PCBGetPowerRequirements)(
      IN struct _SOCKET *Socket
      );
      
   //
   // Function to configure cards.
   //

   BOOLEAN (*PCBProcessConfigureRequest)(
      IN struct _SOCKET *Socket,
      IN struct _CARD_REQUEST *ConfigRequest,
      IN PUCHAR          Base
      );

   //
   // Function to enable/disable status change interrupts
   //

   BOOLEAN (*PCBEnableDisableCardDetectEvent)(
      IN struct _SOCKET *Socket,
      IN BOOLEAN         Enable
      );

   //
   // Function to set/reset the ring enable bit  for the given
   // socket. Setting Ring Enable would cause the CSC to be used
   // as a wakeup event for pc-card modems/netcards etc.
   //

   VOID (*PCBEnableDisableWakeupEvent) (
      IN  struct _SOCKET *SocketPtr,
      IN struct _PDO_EXTENSION *PdoExtension,
      IN  BOOLEAN Enable
      );

   //
   // Function to return the set of IRQs supported
   // by the controller
   //
   ULONG (*PCBGetIrqMask) (
      IN struct _FDO_EXTENSION *DeviceExtension
      );

   //
   // Function to read the memory contents (attribute/common)
   // on the given PC-Card
   //
   ULONG (*PCBReadCardMemory) (
      IN struct _PDO_EXTENSION *PdoExtension,
      IN MEMORY_SPACE MemorySpace,
      IN ULONG  Offset,
      IN PUCHAR Buffer,
      IN ULONG  Length
      );

   //
   // Function to write to the attribute/common memory of
   // the given PC-Card
   //
   ULONG (*PCBWriteCardMemory) (
      IN struct _PDO_EXTENSION *PdoExtension,
      IN  MEMORY_SPACE MemorySpace,
      IN  ULONG  Offset,
      IN  PUCHAR Buffer,
      IN  ULONG  Length
      );

   //
   // Flash memory card interfaces:
   //
   //
   // Function to slide the host memory window on a pc-card
   //
   PPCMCIA_MODIFY_MEMORY_WINDOW PCBModifyMemoryWindow;
   //
   // Function to set the Vpp to the supplied value
   //
   PPCMCIA_SET_VPP              PCBSetVpp;
   //
   // Function to test if the given card is write protected
   //
   PPCMCIA_IS_WRITE_PROTECTED   PCBIsWriteProtected;

}PCMCIA_CTRL_BLOCK, *PPCMCIA_CTRL_BLOCK;

//
// Each socket on the PCMCIA controller has a socket structure
// to contain current information on the state of the socket and
// and PCCARD inserted.
//

#define IsSocketFlagSet(Socket, Flag)        (((Socket)->Flags & (Flag))?TRUE:FALSE)
#define SetSocketFlag(Socket, Flag)          ((Socket)->Flags |= (Flag))
#define ResetSocketFlag(Socket,Flag)         ((Socket)->Flags &= ~(Flag))

//
// Socket flags
//
#define SOCKET_CARD_INITIALIZED        0x00000002
#define SOCKET_CARD_POWERED_UP         0x00000004
#define SOCKET_CARD_CONFIGURED         0x00000008
#define SOCKET_CARD_MULTIFUNCTION      0x00000010
#define SOCKET_CARD_MEMORY             0x00000040
#define SOCKET_CHANGE_INTERRUPT        0x00000080
#define SOCKET_CUSTOM_INTERFACE        0x00000100
#define SOCKET_INSERTED_SOUND_PENDING  0x00000200
#define SOCKET_REMOVED_SOUND_PENDING   0x00000400
#define SOCKET_SUPPORT_MESSAGE_SENT    0x00000800
#define SOCKET_MEMORY_WINDOW_ENABLED   0x00001000
#define SOCKET_CARD_STATUS_CHANGE      0x00002000
#define SOCKET_ENUMERATE_PENDING       0x00008000
#define SOCKET_CLEANUP_PENDING         0x00010000
#define SOCKET_CB_ROUTE_R2_TO_PCI      0x00020000
#define SOCKET_POWER_PREFER_3V         0x00040000
#define SOCKET_ENABLED_FOR_CARD_DETECT 0x00080000

#define SOCKET_CLEANUP_MASK (SOCKET_CARD_CONFIGURED | SOCKET_CLEANUP_PENDING)

//
// Socket insertion states
//
#define SKT_Empty                   0
#define SKT_CardBusCard             1
#define SKT_R2Card                  2

//
// Worker states for socket power operations
//
typedef enum _SPW_STATE {
   SPW_Stopped = 0,
   SPW_Exit,            
   SPW_RequestPower,    
   SPW_ReleasePower,    
   SPW_SetPowerOn,      
   SPW_SetPowerOff,     
   SPW_ResetCard,       
   SPW_Deconfigure      
} SPW_STATE;   


//
// Socket structure
//

typedef struct _SOCKET {
   struct _SOCKET           *NextSocket;
   //
   // Pointer to the pdo for the pc-card in this socket. This is a linked
   // list running through "NextPdoInSocket" in the pdo extension. This list
   // represents the functions that are physically contained within a socket.
   //
   PDEVICE_OBJECT            PdoList;   
   //
   // Parent pcmcia controller's fdo extension of this socket
   //
   struct _FDO_EXTENSION    *DeviceExtension;
   //
   // Pointer to the miniport-like
   //
   PPCMCIA_CTRL_BLOCK        SocketFnPtr;
   //
   // Flags prefixed SOCKET_ defined above
   //
   ULONG                     Flags;
   //
   // For 16-bit cards we use the i/o address port to read/write
   // to the socket registers
   // For cardbus cards, we use the CardBus socket register base
   //
   PUCHAR                    AddressPort;

   KEVENT                    PCCardReadyEvent;
   BOOLEAN                   ReadyChanged;
   //
   // Voltage values requested
   //
   UCHAR                     Vcc;
   UCHAR                     Vpp1;
   UCHAR                     Vpp2;
   //
   // Socket states
   //
   UCHAR                     DeviceState;
   UCHAR                     Reserved0;
   //
   // For PCIC controllers: register offset of the socket
   //
   USHORT                    RegisterOffset;
   //
   // PCIC revision
   //
   UCHAR                     Revision;
   //
   // PCIC controllers: zero-based number of the socket
   //
   UCHAR                     SocketNumber;
   //
   // Indicates the number of functions this pc-card has
   // (this will be > 1 only for multifunction cards like modem/net combos)
   //
   UCHAR                     NumberOfFunctions;
   //
   // Current memory window used internally for reading attributes
   //
   UCHAR                     CurrentMemWindow;
   
   //
   // Timer and DPC objects to handle socket power and initialization
   //
   KTIMER                    PowerTimer;
   KDPC                      PowerDpc;
   //
   // Function and parameter to call at the end of power operation
   //
   PPCMCIA_COMPLETION_ROUTINE PowerCompletionRoutine;
   PVOID                     PowerCompletionContext;
   NTSTATUS                  CallerStatus;
   NTSTATUS                  DeferredStatus;
   LONG                      DeferredStatusLock;
   //
   // Phase variables control state machine for socket power
   //
   LONG                      WorkerBusy;
   SPW_STATE                 WorkerState;
   UCHAR                     PowerPhase;
   UCHAR                     CardResetPhase;
   
   UCHAR                     Reserved;
   //
   // PowerData is temporary storage for power "miniports"
   //
   ULONG                     PowerData;
   //
   // semaphore to count # of functions requesting power on this socket
   //
   LONG                      PowerRequests;
   //
   // Context buffers
   //
   PUCHAR                    CardbusContextBuffer;
   PUCHAR                    ExcaContextBuffer;
   //
   // Current IRQ routing settings on socket
   //
   ULONG                     IrqMask;
   ULONG                     FdoIrq;
} SOCKET, *PSOCKET;



//
// Lock used for synhing access to device(pcmcia controller registers etc.)
// If the definition for this changes, the following 3 defs for
// acquiring/releasing the locks also may need to change
//
typedef struct _PCMCIA_DEVICE_LOCK {

   KSPIN_LOCK  Lock;
   KIRQL       Irql;

} PCMCIA_DEVICE_LOCK, * PPCMCIA_DEVICE_LOCK;

#define PCMCIA_INITIALIZE_DEVICE_LOCK(X)              KeInitializeSpinLock(&(X)->DeviceLock.Lock)
#define PCMCIA_ACQUIRE_DEVICE_LOCK(X)                 KeAcquireSpinLock(&(X)->DeviceLock.Lock, &(X)->DeviceLock.Irql)
#define PCMCIA_ACQUIRE_DEVICE_LOCK_AT_DPC_LEVEL(X)    KeAcquireSpinLockAtDpcLevel(&(X)->DeviceLock.Lock)
#define PCMCIA_RELEASE_DEVICE_LOCK(X)                 KeReleaseSpinLock(&(X)->DeviceLock.Lock, (X)->DeviceLock.Irql)
#define PCMCIA_RELEASE_DEVICE_LOCK_FROM_DPC_LEVEL(X)  KeReleaseSpinLockFromDpcLevel(&(X)->DeviceLock.Lock)

#define PCMCIA_TEST_AND_SET(X)   (InterlockedCompareExchange(X, 1, 0) == 0)
#define PCMCIA_TEST_AND_RESET(X) (InterlockedCompareExchange(X, 0, 1) == 1)

//
// Wait-Wake states
//
typedef enum {
   WAKESTATE_DISARMED,
   WAKESTATE_WAITING,
   WAKESTATE_WAITING_CANCELLED,
   WAKESTATE_ARMED,   
   WAKESTATE_ARMING_CANCELLED,   
   WAKESTATE_COMPLETING
} WAKESTATE;   

//
// Power Policy Flags
//

#define PCMCIA_PP_WAKE_FROM_D0                 0x00000001
#define PCMCIA_PP_D3_ON_IDLE                   0x00000002
        
//
// Functional Device Object's device extension information
//
// There is one device object for each PCMCIA socket controller
// located in the system.  This contains the root pointers for
// each of the lists of information on this controller.
//

//
// Flags common to both fdoExtension and pdoExtension
//

#define PCMCIA_DEVICE_STARTED                  0x00000001
#define PCMCIA_DEVICE_LOGICALLY_REMOVED        0x00000002
#define PCMCIA_DEVICE_PHYSICALLY_REMOVED       0x00000004
#define PCMCIA_DEVICE_DELETED                  0x00000040
#define PCMCIA_DEVICE_CARDBUS                  0x00000080

//
// Flags indicating controller state (fdoExtension)
//

#define PCMCIA_DEVICE_LEGACY_DETECTED          0x00000020
#define PCMCIA_FILTER_ADDED_MEMORY             0x00000100
#define PCMCIA_MEMORY_24BIT                    0x00000200
#define PCMCIA_CARDBUS_NOT_SUPPORTED           0x00000400
#define PCMCIA_USE_POLLED_CSC                  0x00000800
#define PCMCIA_ATTRIBUTE_MEMORY_MAPPED         0x00001000
#define PCMCIA_SOCKET_REGISTER_BASE_MAPPED     0x00002000
#define PCMCIA_INTMODE_COMPAQ                  0x00004000
#define PCMCIA_INT_ROUTE_INTERFACE             0x00080000
#define PCMCIA_FDO_CONTEXT_SAVED               0x00100000
#define PCMCIA_FDO_OFFLINE                     0x00800000
#define PCMCIA_FDO_ON_DEBUG_PATH               0x01000000
#define PCMCIA_FDO_DISABLE_AUTO_POWEROFF       0x02000000
#define PCMCIA_FDO_PREFER_3V                   0x04000000

//
// FDO Flags
//

#define PCMCIA_FDO_IRQ_DETECT_DEVICE_FOUND     0x00000001
#define PCMCIA_FDO_IRQ_DETECT_COMPLETED        0x00000002
#define PCMCIA_FDO_IN_ACPI_NAMESPACE           0x00000004

#define PCMCIA_FDO_FORCE_PCI_ROUTING           0x00000010
#define PCMCIA_FDO_PREFER_PCI_ROUTING          0x00000020
#define PCMCIA_FDO_FORCE_ISA_ROUTING           0x00000040
#define PCMCIA_FDO_PREFER_ISA_ROUTING          0x00000080

#define PCMCIA_FDO_WAKE_BY_CD                  0x00000100

//
// states for FdoPowerWorker
//

typedef enum _FDO_POWER_WORKER_STATE {
   FPW_Stopped = 0,
   FPW_BeginPowerDown,
   FPW_PowerDown,
   FPW_PowerDownSocket,
   FPW_PowerDownComplete,
   FPW_BeginPowerUp,
   FPW_PowerUp,
   FPW_PowerUpSocket,
   FPW_PowerUpSocket2,
   FPW_PowerUpSocketVerify,
   FPW_PowerUpSocketComplete,
   FPW_PowerUpComplete,
   FPW_SendIrpDown,
   FPW_CompleteIrp
} FDO_POWER_WORKER_STATE;

#define FPW_END_SEQUENCE 128

//
// Device extension for the functional device object for pcmcia controllers
//
typedef struct _FDO_EXTENSION {
   //
   // Pointer to the next pcmcia controller's FDO in the central list
   // of all pcmcia controller managed by this driver.
   // The head of the list is pointed to by the global variable FdoList
   //
   PDEVICE_OBJECT                   NextFdo;
   //
   // The PDO ejected by the parent bus driver for this pcmcia controller
   //
   //
   PDEVICE_OBJECT                   Pdo;
   //
   // The immediately lower device attached beneath the pcmcia controller's FDO.
   // This would be the same as the Pdo above, excepting in cases when there are
   // lower filter drivers for the pcmcia controller - like the ACPI driver
   //
   PDEVICE_OBJECT                   LowerDevice;
   //
   // Pointer to the list of sockets which hang off this pcmcia controller
   //
   PSOCKET                          SocketList; 
   //
   // Various flags used to track the state of this
   // (flags prefixed by PCMCIA_ above)
   //
   ULONG                            Flags;
   //
   // FDO specific flags
   //
   ULONG                            FdoFlags;   
   //
   // Bus numbering for PCI devices
   //
   UCHAR                            PciBusNumber;
   UCHAR                            PciDeviceNumber;
   UCHAR                            PciFunctionNumber;
   UCHAR                            reserved;
   //
   // Type of the controller. We need to know this since this is
   // a monolithic driver. We can do controller specific stuff
   // based on the type if needed.
   //
   PCMCIA_CONTROLLER_TYPE           ControllerType; 
   //
   // Index into the device dispatch table for vendor-specific
   // controller functions
   //
   ULONG                            DeviceDispatchIndex;

   PDEVICE_OBJECT                   DeviceObject;
   PDRIVER_OBJECT                   DriverObject;
   PUNICODE_STRING                  RegistryPath;
   //
   // Symbolic link name exported for this pcmcia controller
   //
   UNICODE_STRING                   LinkName;
   //
   // Head of the list of child pc-card PDO's hanging off this controller.
   // This is a linked list running through "NextPdoInFdoChain" in the pdo
   // extension. This list represents the devices that were enumerated by
   // the fdo.
   //
   PDEVICE_OBJECT                   PdoList;
   //
   // Keeps track of the number of PDOs which are actually
   // valid (not removed).  This is primarily used in
   // enumeration of the pcmcia controller upon an IRP_MN_QUERY_DEVICE_RELATIONS
   //
   ULONG                            LivePdoCount;
   //
   // Lock for synching device access
   //
   PCMCIA_DEVICE_LOCK               DeviceLock;

   //
   // Card status change poll related structures
   //
   //
   // Dpc which periodically polls to see if card has been inserted or removed
   //
   KDPC                             TimerDpc;
   //
   // The PollTimer object which is initialized and triggered if a Card Status change
   // interrupt is not used & we resort to polling..
   //
   KTIMER                           PollTimer;
   //
   // Kernel objects to defer power up initialization of controller
   //   
   KTIMER                           PowerTimer;
   KDPC                             PowerDpc;
   //
   // Kernel objects to handle controller events
   //   
   KTIMER                           EventTimer;
   KDPC                             EventDpc;

   //
   // IRQ Mask used in determining which IRQs are allowed for this
   // controller & it's child pc-cards.
   // 1's in the mask correspond to valid IRQs.
   // IRQs are numbered 0 - 15, lsb to msb
   // LegacyIrqMask is a fixed masked used if detection fails and PCI routing is disabled
   //
   USHORT                           DetectedIrqMask;
   USHORT                           LegacyIrqMask;

   //
   // Physical address of the attribute memory window used
   // read tuples off a pc-card.
   //
   PHYSICAL_ADDRESS                 PhysicalBase;
   //
   // Attribute memory resource requirement limits
   //
   ULONG                            AttributeMemoryLow;
   ULONG                            AttributeMemoryHigh;

   //
   // Size of the attribute memory window requested
   //
   ULONG                            AttributeMemorySize;
   //
   // Alignment of the attribute memory window
   //
   ULONG                            AttributeMemoryAlignment;
   //
   // Virtual address mapped to the attribute memory window (PhysicalBase)
   //
   PUCHAR                           AttributeMemoryBase;
   //
   // Io window limits requested on behalf of pc-cards who
   // have flexible i/o resource requirements.
   // (default is to request anything from 0 to ffff
   // but we could use registry overrides to hack around
   // problems
   //
   ULONG                            IoLow;
   ULONG                            IoHigh;

   //
   // Sequence number for  event logging
   //
   ULONG                            SequenceNumber;

   //
   // Pointer to the interrupt object - if we use interrupt based
   // card status change detection
   //
   PKINTERRUPT                      PcmciaInterruptObject;

   //
   // Power management related stuff.
   //
   //
   // Incremented every time a socket is powered up & decremented
   // when it is powered down
   //
   ULONG                            NumberOfSocketsPoweredUp;
   //
   // Current system power state..
   //
   SYSTEM_POWER_STATE               SystemPowerState;
   //
   // Device power state the pcmcia controller is currently in
   //
   DEVICE_POWER_STATE               DevicePowerState;
   //
   // Indicates how many children (pc-cards) are pending on an
   // IRP_MN_WAIT_WAKE
   //
   ULONG                            ChildWaitWakeCount;
   //
   // Device capabilities as reported by our bus driver
   //
   DEVICE_CAPABILITIES              DeviceCapabilities;
   //
   // Pending wait wake Irp
   //
   PIRP                             WaitWakeIrp;
   LONG                             WaitWakeState;

   //
   // PC-Card Ready stall parameters
   //
   ULONG                            ReadyDelayIter;
   ULONG                            ReadyStall;
   //
   // Pci config register state
   //
   PCMCIA_CONTEXT                   PciContext;
   //
   // Interface obtained from PCI driver, for cardbus controllers.
   // This contains interfaces to enumerate CardBus cards
   // (not this interface is private to PCI & PCMCIA.
   // No other driver is expected to use these interfaces
   //
   PCI_CARDBUS_INTERFACE_PRIVATE    PciCardBusInterface;
   PVOID                            PciCardBusDeviceContext;
   //
   // PCI Bus interface standard
   // This contains interfaces to read/write from PCI config space
   // of the cardbus controller, among other stuff..
   //
   BUS_INTERFACE_STANDARD           PciBusInterface;   
   //
   // PCI Int Route interface standard
   // This contains the interface to update the raw interrupt line
   // of the cardbus card
   //
   INT_ROUTE_INTERFACE_STANDARD     PciIntRouteInterface;
   //
   // Configuration resources for the PCMCIA controller
   //
   PCMCIA_CONFIGURATION_INFORMATION Configuration;
   //
   // Pending power irp
   //
   PIRP                             PendingPowerIrp;
   PSOCKET                          PendingPowerSocket;
   //
   // Power worker state machine context
   //
   FDO_POWER_WORKER_STATE          *PowerWorkerSequence;
   FDO_POWER_WORKER_STATE           PowerWorkerState;
   UCHAR                            PowerWorkerPhase;
   UCHAR                            PowerWorkerMaxPhase;
   //
   // Type of bus we are on
   //
   INTERFACE_TYPE                   InterfaceType;
   //
   // CardBus socket base
   //
   PUCHAR                           CardBusSocketRegisterBase;
   //
   // Size of the socket register base that has been mapped
   //
   ULONG                            CardBusSocketRegisterSize;
   //
   // configuration context
   //
   PCMCIA_CONTEXT                   CardbusContext;
   PCMCIA_CONTEXT                   ExcaContext;
   PUCHAR                           PciContextBuffer;
   //
   // Deferred pdo power irp handling
   //
   LIST_ENTRY                       PdoPowerRetryList;
   KDPC                             PdoPowerRetryDpc;
   //
   // Count to track cardbus PCI interface calls
   //
   ULONG                            PciAddCardBusCount;
   
} FDO_EXTENSION, *PFDO_EXTENSION;



//
// Physical Device Object's device extension information
//
// There is one device object for each function of each
// PC-card in a socket per PCMCIA controller
// in the system.  This is referred to as the 'PDO' (physical device
// object)- handled by this bus driver.
//

//
// Flags indicating card state
//
#define PCMCIA_DEVICE_MULTIFUNCTION            0x00000008
#define PCMCIA_DEVICE_WAKE_PENDING             0x00000010
#define PCMCIA_POWER_WORKER_POWERUP            0x00008000
#define PCMCIA_CONFIG_STATUS_DEFERRED          0x00020000
#define PCMCIA_POWER_STATUS_DEFERRED           0x00040000
#define PCMCIA_PDO_ENABLE_AUDIO                0x00200000
#define PCMCIA_PDO_EXCLUSIVE_IRQ               0x00400000

#define PCMCIA_PDO_INDIRECT_CIS                0x00000001

//
// states for PdoPowerWorker
//
typedef enum _PDO_POWER_WORKER_STATE {
   PPW_Stopped = 0,
   PPW_Exit,              
   PPW_InitialState,      
   PPW_PowerUp,           
   PPW_PowerUpComplete,   
   PPW_PowerDown,         
   PPW_PowerDownComplete, 
   PPW_SendIrpDown,       
   PPW_16BitConfigure,    
   PPW_CardBusRefresh,    
   PPW_CardBusDelay       
} PDO_POWER_WORKER_STATE;

//
// phases for ConfigurationWorker
//
typedef enum _CW_STATE {
   CW_Stopped = 0,
   CW_InitialState,
   CW_ResetCard,
   CW_Phase1,
   CW_Phase2,
   CW_Phase3,
   CW_Exit
} CW_STATE;

//
// Flags for ConfigurationWorker
//

#define CONFIG_WORKER_APPLY_MODEM_HACK    0x01

//
// Device extension for the physical device object for pcmcia cards
//
typedef struct _PDO_EXTENSION {
   PDEVICE_OBJECT                   DeviceObject;

   //
   // Link to next pdo in the Fdo's pdo chain
   //
   PDEVICE_OBJECT                   NextPdoInFdoChain;

   //
   // Link to next pdo in the Socket's pdo chain
   //
   PDEVICE_OBJECT                   NextPdoInSocket;

   //
   // Following two declarations valid only for cardbus cards
   //
   // Device attached just below us
   //
   PDEVICE_OBJECT                   LowerDevice;
   //
   // Actual PDO (owned by PCI) that was enumerated for this
   // cardbus card
   //
   PDEVICE_OBJECT                   PciPdo;

   //
   // Cached copy of device id
   //
   PUCHAR                           DeviceId;

   //
   // Pointer to the appropriate socket struc in the parent FDO
   //
   PSOCKET                          Socket;
   //
   // Pointer to the structure assembled by gleaning off tuple data
   // from  a 16-bit pc-card
   //
   PSOCKET_DATA                     SocketData;
   
   //
   // Resource configuration assigned to this socket
   //
   PSOCKET_CONFIGURATION            SocketConfiguration;

   //
   // Flags prefixed PCMCIA_ above
   //
   ULONG                            Flags;

   //
   // PDO Flags
   //
   ULONG                            PdoFlags;

   //
   // Power declarations
   //
   DEVICE_POWER_STATE               DevicePowerState;
   SYSTEM_POWER_STATE               SystemPowerState;
   //
   // Device Capabilities
   //
   DEVICE_CAPABILITIES              DeviceCapabilities;
   //
   // Pending wait wake irp
   //
   PIRP                             WaitWakeIrp;
   //
   // Other pending power irps
   //
   PIRP                             PendingPowerIrp;
   //
   // power worker state machine variables
   //
   KTIMER                           PowerWorkerTimer;
   KDPC                             PowerWorkerDpc;
   NTSTATUS                         PowerWorkerDpcStatus;
   PUCHAR                           PowerWorkerSequence;
   UCHAR                            PowerWorkerPhase;
   PDO_POWER_WORKER_STATE           PowerWorkerState;
   
   //
   // Timer and DPC objects to handle card enables
   //
   CW_STATE                         ConfigurationPhase;
   UCHAR                            ConfigurationFlags;         
   KTIMER                           ConfigurationTimer;
   KDPC                             ConfigurationDpc;
   NTSTATUS                         ConfigurationStatus;
   NTSTATUS                         DeferredConfigurationStatus;
   USHORT                           ConfigureDelay1;   
   USHORT                           ConfigureDelay2;   
   USHORT                           ConfigureDelay3;   
   USHORT                           Reserved2;
   PPCMCIA_COMPLETION_ROUTINE       ConfigCompletionRoutine;
   //
   // PCI Bus interface standard
   // This contains interfaces to read/write from PCI config space
   // of the cardbus card, among other stuff..
   //
   BUS_INTERFACE_STANDARD           PciBusInterface;       // size 0x20  (32)
   //
   // ID used to check for card changes while powered off
   //
   ULONG                            CardBusId;
   //
   // CIS cache for reading tuple data
   //
   PUCHAR                           CisCache;
   MEMORY_SPACE                     CisCacheSpace;
   ULONG                            CisCacheBase;
   //
   // Lock for power requests
   //
   LONG                             SocketPowerRequested;
   //
   // Deletion Mutex 
   //
   ULONG                            DeletionLock;
} PDO_EXTENSION, *PPDO_EXTENSION;


//
// Struct for Database of card bus controller information
// which maps the vendor id/device id to a CONTROLLER_TYPE
//

typedef struct _PCI_CONTROLLER_INFORMATION {
   USHORT          VendorID;
   USHORT          DeviceID;
   PCMCIA_CONTROLLER_TYPE ControllerType;
} PCI_CONTROLLER_INFORMATION, *PPCI_CONTROLLER_INFORMATION;

//
// Struct for database of generic vendor class based on vendor ID
//

typedef struct _PCI_VENDOR_INFORMATION {
   USHORT          VendorID;
   PCMCIA_CONTROLLER_CLASS ControllerClass;
} PCI_VENDOR_INFORMATION, *PPCI_VENDOR_INFORMATION;


//
// Tuple packet used to access tuples
//
typedef struct _TUPLE_PACKET {
   PSOCKET      Socket;
   PSOCKET_DATA SocketData;
   UCHAR        TupleCode;
   UCHAR        TupleLink;
   UCHAR        TupleOffset;
   UCHAR        DesiredTuple;
   USHORT       Attributes;
   USHORT       TupleDataMaxLength;
   USHORT       TupleDataIndex;
   PUCHAR       TupleData;
   ULONG        LinkOffset;
   ULONG        CISOffset;
   USHORT       TupleDataLength;
   USHORT       Flags;
   UCHAR        Function;
} TUPLE_PACKET, * PTUPLE_PACKET;

//
// Memory space definitions for accessing CardBus CIS data
//

#define    PCCARD_CARDBUS_BAR0               0x6e627301
#define    PCCARD_CARDBUS_BAR1               0x6e627302
#define    PCCARD_CARDBUS_BAR2               0x6e627303
#define    PCCARD_CARDBUS_BAR3               0x6e627304
#define    PCCARD_CARDBUS_BAR4               0x6e627305
#define    PCCARD_CARDBUS_BAR5               0x6e627306
#define    PCCARD_CARDBUS_ROM                0x6e627307

//
// Chain of resource lists built by PcmciaConfigEntriesToResourceList
//
typedef struct _PCMCIA_RESOURCE_CHAIN {
   struct _PCMCIA_RESOURCE_CHAIN *NextList;
   PIO_RESOURCE_LIST IoResList;
} PCMCIA_RESOURCE_CHAIN, *PPCMCIA_RESOURCE_CHAIN;

//
// Linked list of CM_PCCARD_DEVICE_DATA's pulled from the registry
//

typedef struct _PCMCIA_NTDETECT_DATA {
   struct _PCMCIA_NTDETECT_DATA *Next;
   CM_PCCARD_DEVICE_DATA PcCardData;
} PCMCIA_NTDETECT_DATA, *PPCMCIA_NTDETECT_DATA;


//
// Poll interval for card status change (in case interrupt not available)
// Expressed in milliseconds
//
#define PCMCIA_CSC_POLL_INTERVAL 1000   // 1 Second

// Maximum no. of fucntions in a multi-function pc-card supported
#define PCMCIA_MAX_MFC    3

// The pccard device id prefix
#define  PCMCIA_ID_STRING        "PCMCIA"

// String to be substituted if manufacturer name is not known
#define PCMCIA_UNKNOWN_MANUFACTURER_STRING "UNKNOWN_MANUFACTURER"

// Max length of device id
#define PCMCIA_MAXIMUM_DEVICE_ID_LENGTH   128

// Pcmcia controller device name
#define  PCMCIA_DEVICE_NAME      "\\Device\\Pcmcia"

// Pcmcia controller device symbolic link name
#define  PCMCIA_LINK_NAME        "\\DosDevices\\Pcmcia"

// PcCard's device name (PDO name)
#define  PCMCIA_PCCARD_NAME      "\\Device\\PcCard"

// Jedec prefix for memory cards
#define  PCMCIA_MEMORY_ID_STRING "MTD"

//
// Max no. of pccard instances of a particular device id allowed
// at a time
#define  PCMCIA_MAX_INSTANCE     100            //arbitrary

#define  PCMCIA_ENABLE_DELAY                   10000

//
// Number of times we attempt to configure the card before
// we give up  (could be the card has been removed)
//
#define PCMCIA_MAX_CONFIG_TRIES        2

//
// problems observed on tecra 750 and satellite 300, with dec-chipset cb nic
//
#define PCMCIA_DEFAULT_CONTROLLER_POWERUP_DELAY  250000   // 250 msec

//
// Amount of time to wait after an event interrupt was asserted on the controller
//
#define PCMCIA_DEFAULT_EVENT_DPC_DELAY  400000   // 400 msec

//
// Global Flags
//
#define    PCMCIA_GLOBAL_SOUNDS_ENABLED      0x00000001     // beep on card insertion/removal
#define    PCMCIA_GLOBAL_FORCE_POLL_MODE     0x00000002     // use polled mode for detecting card insert/remove
#define PCMCIA_DISABLE_ACPI_NAMESPACE_CHECK  0x00000004     // irq routing test
#define PCMCIA_DEFAULT_ROUTE_R2_TO_ISA       0x00000008
//
// Flags for PcmciaSetSocketPower
//

#define PCMCIA_POWERON TRUE
#define PCMCIA_POWEROFF FALSE

//
// This accepts device extension as  paramter: need to keep adding to this macro
// as more PciPcmciaBridges are supported
//
  #define PciPcmciaBridgeExtension(DeviceExtension)  (((DeviceExtension)->ControllerType==PcmciaPciPcmciaBridge)  ||     \
                                                     ((DeviceExtension)->ControllerType==PcmciaCLPD6729))


// These accept the socket as parameter

//
// Cirrus Logic PD6729 PCI-PCMCIA Bridge
//
#define CLPD6729(s)    (((s)->DeviceExtension) && ((s)->DeviceExtension->ControllerType==PcmciaCLPD6729))

//
// Databook TCIC 16-bit pcmcia controller
//
#define Databook(s)    (((s)->DeviceExtension) && ((s)->DeviceExtension->ControllerType==PcmciaDatabook))

//
// Compaq Elite controller
//
#define Elc(s)         (((s)->DeviceExtension) && ((s)->DeviceExtension->ControllerType==PcmciaElcController))

//
// Generic cardbus controller
//
#define CardBus(s)     (((s)->DeviceExtension) && CardBusExtension((s)->DeviceExtension))

//
// Generic PCI-PCMCIA Bridge
//
#define PciPcmciaBridge(s) (((s)->DeviceExtension) && PciPcmciaBridgeExtension((s)->DeviceExtension))

//
// Macros for manipulating PDO's flags
//

#define IsDeviceFlagSet(deviceExtension, Flag)        (((deviceExtension)->Flags & (Flag))?TRUE:FALSE)
#define SetDeviceFlag(deviceExtension, Flag)          ((deviceExtension)->Flags |= (Flag))
#define ResetDeviceFlag(deviceExtension,Flag)         ((deviceExtension)->Flags &= ~(Flag))

#define IsFdoFlagSet(fdoExtension, Flag)       (((fdoExtension)->FdoFlags & (Flag))?TRUE:FALSE)
#define SetFdoFlag(fdoExtension, Flag)         ((fdoExtension)->FdoFlags |= (Flag))
#define ResetFdoFlag(fdoExtension,Flag)        ((fdoExtension)->FdoFlags &= ~(Flag))

#define IsPdoFlagSet(pdoExtension, Flag)       (((pdoExtension)->PdoFlags & (Flag))?TRUE:FALSE)
#define SetPdoFlag(pdoExtension, Flag)         ((pdoExtension)->PdoFlags |= (Flag))
#define ResetPdoFlag(pdoExtension,Flag)        ((pdoExtension)->PdoFlags &= ~(Flag))


#define MarkDeviceStarted(deviceExtension)     ((deviceExtension)->Flags |=  PCMCIA_DEVICE_STARTED)
#define MarkDeviceNotStarted(deviceExtension)  ((deviceExtension)->Flags &= ~PCMCIA_DEVICE_STARTED)
#define MarkDeviceDeleted(deviceExtension)     ((deviceExtension)->Flags |= PCMCIA_DEVICE_DELETED);
#define MarkDevicePhysicallyRemoved(deviceExtension)                                                              \
                                                  ((deviceExtension)->Flags |=  PCMCIA_DEVICE_PHYSICALLY_REMOVED)
#define MarkDevicePhysicallyInserted(deviceExtension)                                                           \
                                               ((deviceExtension)->Flags &= ~PCMCIA_DEVICE_PHYSICALLY_REMOVED)
#define MarkDeviceLogicallyRemoved(deviceExtension)                                                              \
                                                  ((deviceExtension)->Flags |=  PCMCIA_DEVICE_LOGICALLY_REMOVED)
#define MarkDeviceLogicallyInserted(deviceExtension)                                                           \
                                               ((deviceExtension)->Flags &= ~PCMCIA_DEVICE_LOGICALLY_REMOVED)
#define MarkDeviceCardBus(deviceExtension)     ((deviceExtension)->Flags |= PCMCIA_DEVICE_CARDBUS)
#define MarkDevice16Bit(deviceExtension)       ((deviceExtension)->Flags &= ~PCMCIA_DEVICE_CARDBUS)
#define MarkDeviceMultifunction(deviceExtension)                                                                  \
                                               ((deviceExtension)->Flags |= PCMCIA_DEVICE_MULTIFUNCTION)


#define IsDeviceStarted(deviceExtension)       (((deviceExtension)->Flags & PCMCIA_DEVICE_STARTED)?TRUE:FALSE)
#define IsDevicePhysicallyRemoved(deviceExtension) \
                                               (((deviceExtension)->Flags & PCMCIA_DEVICE_PHYSICALLY_REMOVED)?TRUE:FALSE)
#define IsDeviceLogicallyRemoved(deviceExtension) \
                                               (((deviceExtension)->Flags & PCMCIA_DEVICE_LOGICALLY_REMOVED)?TRUE:FALSE)
#define IsDeviceDeleted(deviceExtension)       (((deviceExtension)->Flags & PCMCIA_DEVICE_DELETED)?TRUE:FALSE)
#define IsDeviceMultifunction(deviceExtension) (((deviceExtension)->Flags & PCMCIA_DEVICE_MULTIFUNCTION)?TRUE:FALSE)

#define IsCardBusCard(deviceExtension)         (((deviceExtension)->Flags & PCMCIA_DEVICE_CARDBUS)?TRUE:FALSE)
#define Is16BitCard(deviceExtension)           (((deviceExtension)->Flags & PCMCIA_DEVICE_CARDBUS)?FALSE:TRUE)

#define CardBusExtension(deviceExtension)      (((deviceExtension)->Flags & PCMCIA_DEVICE_CARDBUS)?TRUE:FALSE)

//
// Macros for checking & setting type of PC-CARD in a socket
//
#define IsCardBusCardInSocket(SocketPtr)       (((SocketPtr)->DeviceState == SKT_CardBusCard)?TRUE:FALSE)
#define Is16BitCardInSocket(SocketPtr)         (((SocketPtr)->DeviceState == SKT_R2Card)?TRUE:FALSE)
#define IsCardInSocket(SocketPtr)              (((SocketPtr)->DeviceState == SKT_Empty)?FALSE:TRUE)

#define SetCardBusCardInSocket(SocketPtr)      ((SocketPtr)->DeviceState = SKT_CardBusCard)
#define Set16BitCardInSocket(SocketPtr)        ((SocketPtr)->DeviceState = SKT_R2Card)
#define SetSocketEmpty(SocketPtr)              ((SocketPtr)->DeviceState = SKT_Empty)

//
// NT definitions
//
#ifdef POOL_TAGGING
#undef ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'cmcP')
#endif

#define IO_RESOURCE_LIST_VERSION  0x1
#define IO_RESOURCE_LIST_REVISION 0x1

#define IRP_MN_PNP_MAXIMUM_FUNCTION IRP_MN_QUERY_LEGACY_BUS_INFORMATION

//
// Some useful macros
//
#define MIN(x,y) ((x) > (y) ? (y) : (x))        // return minimum among x & y
#define MAX(x,y) ((x) > (y) ? (x) : (y))        // return maximum among x & y

//
// BOOLEAN
// IS_PDO (IN PDEVICE_OBJECT DeviceObject);
//
#define IS_PDO(DeviceObject)      (((DeviceObject)->Flags & DO_BUS_ENUMERATED_DEVICE)?TRUE:FALSE)

//
// VOID
// MARK_AS_PDO (IN PDEVICE_OBJECT DeviceObject);
//
#define MARK_AS_PDO(DeviceObject) ((DeviceObject)->Flags |= DO_BUS_ENUMERATED_DEVICE)

//
// Checks if Ptr is aligned on a boundary of 2^Size
//
// BOOLEAN
// IS_ALIGNED (IN PVOID Ptr,
//             IN ULONG Size);
//
#define IS_ALIGNED(Ptr,Size)                                            \
     (((((ULONG)(Ptr)) & (((ULONG) (1<<(Size)) - 1)) ) == 0) ? TRUE : FALSE )

//
// BOOLEAN
// PcmciaSetWindowPage(IN FDO_EXTENSION fdoExtension,
//                     IN PSOCKET Socket,
//                     IN USHORT Index,
//                     IN UCHAR Page);
//
#define PcmciaSetWindowPage(fdoExtension, Socket, Index, Page)                                        \
   ((DeviceDispatchTable[fdoExtension->DeviceDispatchIndex].SetWindowPage) ?                          \
      (*DeviceDispatchTable[fdoExtension->DeviceDispatchIndex].SetWindowPage)(Socket, Index, Page) :  \
      FALSE)                                                                                          

#define HasWindowPageRegister(fdoExtension)  \
   ((BOOLEAN)(DeviceDispatchTable[fdoExtension->DeviceDispatchIndex].SetWindowPage))

//
// VOID
// PcmciaSetAudio(
//    IN PSOCKET Socket,
//    IN BOOLEAN enable
//    );
//
#define PcmciaSetAudio(fdoExtension, socket, enable)                                                  \
   if ((DeviceDispatchTable[fdoExtension->DeviceDispatchIndex].SetAudio)) {                           \
      (*DeviceDispatchTable[fdoExtension->DeviceDispatchIndex].SetAudio)(socket, enable);             \
      }

//
// BOOLEAN
// PcmciaSetZV(
//    IN PSOCKET Socket,
//    IN BOOLEAN enable
//    );
//
#define PcmciaSetZV(fdoExtension, socket, enable)                                                     \
   ((DeviceDispatchTable[fdoExtension->DeviceDispatchIndex].SetZV) ?                                  \
      (*DeviceDispatchTable[fdoExtension->DeviceDispatchIndex].SetZV)(socket, enable) :               \
      FALSE)                                                                                          

//
// Io extension macro to just pass on the Irp to a lower driver
//

//
// VOID
// PcmciaSkipCallLowerDriver(OUT NTSTATUS Status,
//                           IN  PDEVICE_OBJECT DeviceObject,
//                           IN  PIRP Irp);
//
#define PcmciaSkipCallLowerDriver(Status, DeviceObject, Irp) {          \
               IoSkipCurrentIrpStackLocation(Irp);                      \
               Status = IoCallDriver(DeviceObject,Irp);}

//
// VOID
// PcmciaCopyCallLowerDriver(OUT NTSTATUS Status,
//                           IN  PDEVICE_OBJECT DeviceObject,
//                           IN  PIRP Irp);
//
#define PcmciaCopyCallLowerDriver(Status, DeviceObject, Irp) {          \
               IoCopyCurrentIrpStackLocationToNext(Irp);                \
               Status = IoCallDriver(DeviceObject,Irp); }

//  BOOLEAN
//  CompareGuid(
//      IN LPGUID guid1,
//      IN LPGUID guid2
//      );

#define CompareGuid(g1, g2)  ((g1) == (g2) ?TRUE:                       \
                                 RtlCompareMemory((g1),                 \
                                                  (g2),                 \
                                                  sizeof(GUID))         \
                                 == sizeof(GUID)                        \
                             )

//
// VOID
// PcmciaDoStartSound(
//                   IN PSOCKET Socket,
//                   IN NTSTATUS Status);
//
#define PcmciaDoStartSound(Socket, Status) {                               \
         if (NT_SUCCESS(Status)) {                                         \
            if (IsSocketFlagSet(Socket, SOCKET_INSERTED_SOUND_PENDING)) {  \
               ResetSocketFlag(Socket, SOCKET_INSERTED_SOUND_PENDING);     \
               PcmciaPlaySound(CARD_INSERTED_SOUND);                       \
            }                                                              \
            SetSocketFlag(Socket, SOCKET_REMOVED_SOUND_PENDING);           \
         } else {                                                          \
            PcmciaPlaySound(ERROR_SOUND);                                  \
         }                                                                 \
         }

//
// BOOLEAN
// ValidateController(IN FDO_EXTENSION fdoExtension)
//
// Bit of paranoia code. Make sure that the cardbus controller's registers
// are still visible. 
//

#define ValidateController(fdoExtension) \
      (CardBusExtension(fdoExtension) ?  \
         ((CBReadSocketRegister(fdoExtension->SocketList, CBREG_SKTMASK) & 0xfffffff0) == 0)  \
         : TRUE)
         
//
// These are the types of tones used on card pnp events
//
typedef enum _PCMCIA_SOUND_TYPE {
   CARD_INSERTED_SOUND,
   CARD_REMOVED_SOUND,
   ERROR_SOUND
}  PCMCIA_SOUND_TYPE, *PPCMCIA_SOUND_TYPE;

typedef struct _PCMCIA_SOUND_EVENT {
   struct _PCMCIA_SOUND_EVENT *NextEvent;
   ULONG Frequency;
   ULONG Duration;
} PCMCIA_SOUND_EVENT, *PPCMCIA_SOUND_EVENT;

//
// CARDBUS Bridge specific header portion in PCI Config space
//

#define CARDBUS_SPECIFIC_HDR_OFFSET     0x40

typedef struct _CARDBUS_SPECIFIC_HDR {
   USHORT SubSystemVendorID;
   USHORT SubSystemID;
   ULONG  LegacyBaseAddress;
   UCHAR  Reserved1[56];
   ULONG  SystemCtrlReg;
   UCHAR  MultimediaControl;
   UCHAR  Reserved2[3];
   UCHAR  GPIO0;
   UCHAR  GPIO1;
   UCHAR  GPIO2;
   UCHAR  GPIO3;
   ULONG  IRQMux;
   UCHAR  RetryStatus;
   UCHAR  CardCtrl;
   UCHAR  DeviceCtrl;
   UCHAR  Diagnostic;
   ULONG  SocketDMAReg0;
   ULONG  SocketDMAReg1;
}  CARDBUS_SPECIFIC_HDR, *PCARDBUS_SPECIFIC_HDR;

//
// Registers for accessing indirect access space
//

#define IAR_CONTROL_LOW 2
#define IAR_ADDRESS     4
#define IAR_DATA        8

// Flags defined in "Control"
#define IARF_COMMON      1
#define IARF_AUTO_INC    2
#define IARF_BYTE_GRAN   4

//
// Vendor specific dispatches for various controllers
//
typedef struct _DEVICE_DISPATCH_TABLE {

   //
   // Type of controller for which the dispatches apply
   //
   PCMCIA_CONTROLLER_CLASS   ControllerClass;

   //
   // Function to vendor-specific initialize controller
   //
   VOID   (*InitController) (IN PFDO_EXTENSION FdoExtension);

   //
   // Vendor specific function to set power for a pc-card
   //
   NTSTATUS
   (*SetPower) (
      IN PSOCKET SocketPtr,
      IN BOOLEAN Enable,
      OUT PULONG pDelayTime
      );

   //
   // Vendor specific function to set/reset Audio
   //
   VOID
   (*SetAudio) (
      IN PSOCKET Socket,
      IN BOOLEAN Enable
      );

   //
   // Vendor specific function to set/reset Zoom Video mode
   //
   BOOLEAN
   (*SetZV) (
      IN PSOCKET Socket,
      IN BOOLEAN Enable
      );

   //
   // Vendor specific function to set page register for memory windows
   //
   BOOLEAN (*SetWindowPage) (IN PSOCKET SocketPtr,
                             IN USHORT Index,
                             IN UCHAR Page);

} DEVICE_DISPATCH_TABLE, *PDEVICE_DISPATCH_TABLE;

//
// Controller types to hardware/device/compatible id mapping
//
typedef struct _PCMCIA_ID_ENTRY {
   PCMCIA_CONTROLLER_TYPE ControllerType;
   PUCHAR              Id;
} PCMCIA_ID_ENTRY, *PPCMCIA_ID_ENTRY;

//
// Exca & cardbus register init structure used to
// initialize the registers on start up
//
typedef struct _PCMCIA_REGISTER_INIT {
   //
   // Register offset
   //
   ULONG Register;
   //
   // value: EXCA regs need only a byte,
   // so only the LSB of this field is used for
   // initializing them. Cardbus regs need the
   // entire DWORD
   //
   ULONG Value;
} PCMCIA_REGISTER_INIT, *PPCMCIA_REGISTER_INIT;

//
// Structure which defines special per-device configuration parameters
//

typedef struct _PCMCIA_DEVICE_CONFIG_PARAMS {
   UCHAR ValidEntry;
   UCHAR DeviceType;
   USHORT ManufacturerCode;
   USHORT ManufacturerInfo;
   USHORT CisCrc;
   USHORT ConfigDelay1;
   USHORT ConfigDelay2;
   USHORT ConfigDelay3;
   UCHAR ConfigFlags;
} PCMCIA_DEVICE_CONFIG_PARAMS, *PPCMCIA_DEVICE_CONFIG_PARAMS;

//
// Structure which defines what global parameters are read from the registry
//

typedef struct _GLOBAL_REGISTRY_INFORMATION {
   PWSTR Name;
   PULONG pValue;
   ULONG Default;
} GLOBAL_REGISTRY_INFORMATION, *PGLOBAL_REGISTRY_INFORMATION;

//
// Defines used both by data.c and registry.c
//

#define PCMCIA_REGISTRY_ISA_IRQ_RESCAN_COMPLETE     L"IsaIrqRescanComplete"

#endif  //_PCMCIAPRT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\inc\tcicregs.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    tcicregs.h

Abstract:

	Databook TCIC register structures for DEBUG support.
	
Author(s):
		John Keys - Databook Inc. 7-Apr-1995

Revisions:
--*/
#ifndef _tcicregs_h_			// prevent multiple includes 
#define _tcicregs_h_

typedef struct _BASEREGS {
	UCHAR	sctrl;
	UCHAR 	sstat;
	UCHAR	mode;
	UCHAR	pwr;
	USHORT  edc;
	UCHAR	icsr;
	UCHAR	iena;
	USHORT  wctl;
	USHORT	syscfg;
	USHORT	ilock;
	USHORT  test;
}BASEREGS, *PBASEREGS;


typedef struct _SKTREGS {
	USHORT  scfg1;
	USHORT	scfg2;
}SKTREGS, *PSKTREGS;

typedef struct _IOWIN {
	USHORT iobase;
	USHORT ioctl;
}IOWIN, *PIOWIN;

typedef struct _MEMWIN {
	USHORT mbase;
	USHORT mmap;
	USHORT mctl;
}MEMWIN, *PMEMWIN;


typedef struct _TCIC {
	BASEREGS baseregs[2];
	SKTREGS	 sktregs[2];
	IOWIN	 iowins[4];
	MEMWIN	 memwins[10];
}TCIC, *PTCIC;

#endif  //_tcicregs_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\memcard\debug.c ===
/*++      

Copyright (c) 1999 Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module provides debugging support.

Author:

    Neil Sandlin (neilsa) 26-Apr-99

Revision History:


--*/


#include "pch.h"

#if DBG

ULONG MemCardDebugLevel = 1;

VOID
MemCardDebugPrint(
                ULONG  DebugMask,
                PCCHAR DebugMessage,
                ...
                )

/*++

Routine Description:

    Debug print for the PCMCIA enabler.

Arguments:

    Check the mask value to see if the debug message is requested.

Return Value:

    None

--*/

{
    va_list ap;
    char    buffer[256];

    va_start(ap, DebugMessage);

    if (DebugMask & MemCardDebugLevel) {
       vsprintf(buffer, DebugMessage, ap);
       DbgPrint(buffer);
    }

    va_end(ap);
} // end MemcardDebugPrint()




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\memcard\debug.h ===
/*++

Copyright (c) 1991 - 1993 Microsoft Corporation

Module Name:

    debug.h

Abstract:


Author:

    Neil Sandlin (neilsa) 26-Apr-99

Environment:

    Kernel mode only.

Notes:


--*/


#if DBG
//
// For checked kernels, define a macro to print out informational
// messages.
//
// MemCardDebug is normally 0.  At compile-time or at run-time, it can be
// set to some bit patter for increasingly detailed messages.
//
// Big, nasty errors are noted with DBGP.  Errors that might be
// recoverable are handled by the WARN bit.  More information on
// unusual but possibly normal happenings are handled by the INFO bit.
// And finally, boring details such as routines entered and register
// dumps are handled by the SHOW bit.
//
#define MEMCARDDBGP              ((ULONG)0x00000001)
#define MEMCARDWARN              ((ULONG)0x00000002)
#define MEMCARDINFO              ((ULONG)0x00000004)
#define MEMCARDSHOW              ((ULONG)0x00000008)
#define MEMCARDIRPPATH           ((ULONG)0x00000010)
#define MEMCARDFORMAT            ((ULONG)0x00000020)
#define MEMCARDSTATUS            ((ULONG)0x00000040)
#define MEMCARDPNP               ((ULONG)0x00000080)
#define MEMCARDIOCTL             ((ULONG)0x00000100)
#define MEMCARDRW                ((ULONG)0x00000200)
extern ULONG MemCardDebugLevel;
#define MemCardDump(LEVEL,STRING) \
        do { \
            if (MemCardDebugLevel & (LEVEL)) { \
                DbgPrint STRING; \
            } \
        } while (0)
#else
#define MemCardDump(LEVEL,STRING) do {NOTHING;} while (0)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\memcard\ioctl.c ===
/*++

Copyright (c) 1991-1998  Microsoft Corporation

Module Name:

    ioctl.c

Abstract:

Author:

    Neil Sandlin (neilsa) 26-Apr-99

Environment:

    Kernel mode only.

--*/
#include "pch.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,MemCardDeviceControl)
#endif


NTSTATUS
MemCardDeviceControl(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   )

/*++

Routine Description:

   This routine is called by the I/O system to perform a device I/O
   control function.

Arguments:

   DeviceObject - a pointer to the object that represents the device
   that I/O is to be done on.

   Irp - a pointer to the I/O Request Packet for this request.

Return Value:

   STATUS_SUCCESS or STATUS_PENDING if recognized I/O control code,
   STATUS_INVALID_DEVICE_REQUEST otherwise.

--*/

{
   PIO_STACK_LOCATION irpSp;
   PMEMCARD_EXTENSION memcardExtension;
   PDISK_GEOMETRY outputBuffer;
   NTSTATUS status;
   ULONG outputBufferLength;
   UCHAR i;
   ULONG formatExParametersSize;
   PFORMAT_EX_PARAMETERS formatExParameters;

   MemCardDump( MEMCARDIOCTL, ("MemCard: IOCTL entered\n") );

   memcardExtension = DeviceObject->DeviceExtension;
   irpSp = IoGetCurrentIrpStackLocation( Irp );

   //
   //  If the device has been removed we will just fail this request outright.
   //
   if ( memcardExtension->IsRemoved ) {

       Irp->IoStatus.Information = 0;
       Irp->IoStatus.Status = STATUS_DELETE_PENDING;
       IoCompleteRequest( Irp, IO_NO_INCREMENT );
       return STATUS_DELETE_PENDING;
   }

   //
   // If the device hasn't been started we will let the IOCTL through. This
   // is another hack for ACPI.
   //
   if (!memcardExtension->IsStarted) {

       IoSkipCurrentIrpStackLocation( Irp );
       return IoCallDriver( memcardExtension->TargetObject, Irp );
   }

   switch( irpSp->Parameters.DeviceIoControl.IoControlCode ) {

      case IOCTL_MOUNTDEV_QUERY_DEVICE_NAME: {

         PMOUNTDEV_NAME mountName;

         MemCardDump( MEMCARDIOCTL, ("MemCard: DO %.8x Irp %.8x IOCTL_MOUNTDEV_QUERY_DEVICE_NAME\n",
                                        DeviceObject, Irp));
                                        
         ASSERT(memcardExtension->DeviceName.Buffer);

         if ( irpSp->Parameters.DeviceIoControl.OutputBufferLength <
             sizeof(MOUNTDEV_NAME) ) {

             status = STATUS_INVALID_PARAMETER;
             break;
         }

         mountName = Irp->AssociatedIrp.SystemBuffer;
         mountName->NameLength = memcardExtension->DeviceName.Length;

         if ( irpSp->Parameters.DeviceIoControl.OutputBufferLength <
             sizeof(USHORT) + mountName->NameLength) {

             status = STATUS_BUFFER_OVERFLOW;
             Irp->IoStatus.Information = sizeof(MOUNTDEV_NAME);
             break;
         }

         RtlCopyMemory( mountName->Name, memcardExtension->DeviceName.Buffer,
                        mountName->NameLength);

         status = STATUS_SUCCESS;
         Irp->IoStatus.Information = sizeof(USHORT) + mountName->NameLength;
         break;
         }

      case IOCTL_MOUNTDEV_QUERY_UNIQUE_ID: {

         PMOUNTDEV_UNIQUE_ID uniqueId;

         MemCardDump( MEMCARDIOCTL, ("MemCard: DO %.8x Irp %.8x IOCTL_MOUNTDEV_QUERY_UNIQUE_ID\n",
                                        DeviceObject, Irp));

         if ( !memcardExtension->InterfaceString.Buffer ||
              irpSp->Parameters.DeviceIoControl.OutputBufferLength <
               sizeof(MOUNTDEV_UNIQUE_ID)) {

             status = STATUS_INVALID_PARAMETER;
             break;
         }

         uniqueId = Irp->AssociatedIrp.SystemBuffer;
         uniqueId->UniqueIdLength =
                 memcardExtension->InterfaceString.Length;

         if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
             sizeof(USHORT) + uniqueId->UniqueIdLength) {

             status = STATUS_BUFFER_OVERFLOW;
             Irp->IoStatus.Information = sizeof(MOUNTDEV_UNIQUE_ID);
             break;
         }

         RtlCopyMemory( uniqueId->UniqueId,
                        memcardExtension->InterfaceString.Buffer,
                        uniqueId->UniqueIdLength );

         status = STATUS_SUCCESS;
         Irp->IoStatus.Information = sizeof(USHORT) +
                                     uniqueId->UniqueIdLength;
         break;
         }

      case IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME: {
      
         MemCardDump(MEMCARDIOCTL,("MemCard: DO %.8x Irp %.8x IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME\n",
                                    DeviceObject, Irp));

         status = STATUS_INVALID_DEVICE_REQUEST;
         break;
      }

      case IOCTL_DISK_GET_MEDIA_TYPES: {
         ULONG ByteCapacity;
      
         MemCardDump(MEMCARDIOCTL,("MemCard: DO %.8x Irp %.8x IOCTL_DISK_GET_MEDIA_TYPES\n",
                                   DeviceObject, Irp));
                                   
         outputBufferLength = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
         outputBuffer = (PDISK_GEOMETRY) Irp->AssociatedIrp.SystemBuffer;

         //
         // Make sure that the input buffer has enough room to return
         // at least one descriptions of a supported media type.
         //
         if (outputBufferLength < (sizeof(DISK_GEOMETRY))) {
             status = STATUS_BUFFER_TOO_SMALL;
             break;
         }

         //
         // Assume success, although we might modify it to a buffer
         // overflow warning below (if the buffer isn't big enough
         // to hold ALL of the media descriptions).
         //
         status = STATUS_SUCCESS;
         
         i = 0;
         Irp->IoStatus.Information = 0;

         //
         // Fill in capacities from 512K to 8M
         //
         for (ByteCapacity = 0x80000; ByteCapacity <= 0x800000; ByteCapacity*=2) {            
            if (outputBufferLength < (sizeof(DISK_GEOMETRY) + Irp->IoStatus.Information)) {
               status = STATUS_BUFFER_OVERFLOW;
               break;
            }        

            outputBuffer->MediaType          = FixedMedia;
            outputBuffer->Cylinders.LowPart  = ByteCapacity / (8 * 2 * 512);
            outputBuffer->Cylinders.HighPart = 0;
            outputBuffer->TracksPerCylinder  = 2;
            outputBuffer->SectorsPerTrack    = 8;
            outputBuffer->BytesPerSector     = 512;
            MemCardDump( MEMCARDIOCTL, ("MemCard: Cyls=%x\n", outputBuffer->Cylinders.LowPart));
            
            outputBuffer++;
            Irp->IoStatus.Information += sizeof( DISK_GEOMETRY );
         }        
         break;        
      }
              
      case IOCTL_DISK_CHECK_VERIFY:
         MemCardDump( MEMCARDIOCTL, ("MemCard: DO %.8x Irp %.8x IOCTL_DISK_CHECK_VERIFY\n",
                                     DeviceObject, Irp));
         status = STATUS_SUCCESS;
         break;

      case IOCTL_DISK_GET_DRIVE_GEOMETRY: {
         PDISK_GEOMETRY outputBuffer = (PDISK_GEOMETRY) Irp->AssociatedIrp.SystemBuffer;
         
         MemCardDump( MEMCARDIOCTL, ("MemCard: DO %.8x Irp %.8x IOCTL_DISK_GET_DRIVE_GEOMETRY\n",
                                     DeviceObject, Irp));
                                        
         if ( irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof( DISK_GEOMETRY ) ) {
            status = STATUS_INVALID_PARAMETER;        
            break;
         }

         status = STATUS_SUCCESS;

         if (!memcardExtension->ByteCapacity) {
            //
            // Just zero out everything.  The
            // caller shouldn't look at it.
            //
            outputBuffer->MediaType = Unknown;
            outputBuffer->Cylinders.LowPart = 0;
            outputBuffer->Cylinders.HighPart = 0;
            outputBuffer->TracksPerCylinder = 0;
            outputBuffer->SectorsPerTrack = 0;
            outputBuffer->BytesPerSector = 0;

         } else {
            //
            // Return the geometry of the current
            // media.
            //
            outputBuffer->MediaType = FixedMedia;
            outputBuffer->Cylinders.HighPart = 0;
            outputBuffer->Cylinders.LowPart  = memcardExtension->ByteCapacity / (8 * 2 * 512);
            outputBuffer->TracksPerCylinder  = 2;
            outputBuffer->SectorsPerTrack    = 8;
            outputBuffer->BytesPerSector     = 512;
         }

         MemCardDump( MEMCARDIOCTL, ("MemCard: Capacity=%.8x => Cyl=%x\n",
                                     memcardExtension->ByteCapacity, outputBuffer->Cylinders.LowPart));
         Irp->IoStatus.Information = sizeof( DISK_GEOMETRY );
         break;
      }

      case IOCTL_DISK_IS_WRITABLE: {
         MemCardDump( MEMCARDIOCTL, ("MemCard: DO %.8x Irp %.8x IOCTL_DISK_IS_WRITABLE\n",
                                     DeviceObject, Irp));
                                     
         if ((memcardExtension->PcmciaInterface.IsWriteProtected)(memcardExtension->UnderlyingPDO)) {
            status = STATUS_INVALID_PARAMETER;
         } else {
            status = STATUS_SUCCESS;
         }               
         break;                                        
      }        

      case IOCTL_DISK_VERIFY: {
         PVERIFY_INFORMATION verifyInformation = Irp->AssociatedIrp.SystemBuffer;
         
         if (irpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(VERIFY_INFORMATION)) {
            status = STATUS_INVALID_PARAMETER;        
            break;
         }         

         //NOTE: not implemented
         Irp->IoStatus.Information = verifyInformation->Length;        
         status = STATUS_SUCCESS;
         break;
      }            
      
      case IOCTL_DISK_GET_DRIVE_LAYOUT: {
         PDRIVE_LAYOUT_INFORMATION outputBuffer = (PDRIVE_LAYOUT_INFORMATION) Irp->AssociatedIrp.SystemBuffer;
         
         MemCardDump( MEMCARDIOCTL, ("MemCard: DO %.8x Irp %.8x IOCTL_DISK_GET_DRIVE_LAYOUT\n",
                                     DeviceObject, Irp));
                                        
         if ( irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(DRIVE_LAYOUT_INFORMATION) ) {
            status = STATUS_INVALID_PARAMETER;        
            break;
         }
         RtlZeroMemory(outputBuffer, sizeof(DRIVE_LAYOUT_INFORMATION));

         outputBuffer->PartitionCount = 1;
         outputBuffer->PartitionEntry[0].StartingOffset.LowPart = 512;
         outputBuffer->PartitionEntry[0].PartitionLength.LowPart = memcardExtension->ByteCapacity;
         outputBuffer->PartitionEntry[0].RecognizedPartition = TRUE;

         status = STATUS_SUCCESS;
         
         Irp->IoStatus.Information = sizeof(DRIVE_LAYOUT_INFORMATION);
         break;
      }        
      
      case IOCTL_DISK_GET_PARTITION_INFO: {
         PPARTITION_INFORMATION outputBuffer = (PPARTITION_INFORMATION)Irp->AssociatedIrp.SystemBuffer;
         
         MemCardDump( MEMCARDIOCTL, ("MemCard: DO %.8x Irp %.8x IOCTL_DISK_GET_PARTITION_INFO\n",
                                     DeviceObject, Irp));
                                     
         if ( irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof( PARTITION_INFORMATION ) ) {
            status = STATUS_INVALID_PARAMETER;
            break;
         } 

         RtlZeroMemory(outputBuffer, sizeof(PARTITION_INFORMATION));
         
         outputBuffer->RecognizedPartition = TRUE;
         outputBuffer->StartingOffset.LowPart = 512;
         outputBuffer->PartitionLength.LowPart = memcardExtension->ByteCapacity;

         status = STATUS_SUCCESS;
         Irp->IoStatus.Information = sizeof( PARTITION_INFORMATION );
         break;
      }
      
      
      case IOCTL_DISK_SET_DRIVE_LAYOUT:
         MemCardDump( MEMCARDIOCTL, ("MemCard: DO %.8x Irp %.8x IOCTL_DISK_SET_DRIVE_LAYOUT\n",
                                      DeviceObject, Irp));
      case IOCTL_MOUNTMGR_CHANGE_NOTIFY:
      case IOCTL_MOUNTDEV_LINK_CREATED:
      case IOCTL_MOUNTDEV_LINK_DELETED:
      default: {

         MemCardDump(MEMCARDIOCTL,
             ("MemCard: IOCTL - unsupported device request %.8x\n", irpSp->Parameters.DeviceIoControl.IoControlCode));

         status = STATUS_INVALID_DEVICE_REQUEST;
         break;
         
         //IoSkipCurrentIrpStackLocation( Irp );
         //status = IoCallDriver( memcardExtension->TargetObject, Irp );
         //return status;
      }
   }

   if ( status != STATUS_PENDING ) {

      Irp->IoStatus.Status = status;
      if (!NT_SUCCESS( status ) && IoIsErrorUserInduced( status )) {
         IoSetHardErrorOrVerifyDevice( Irp, DeviceObject );
      }
      MemCardDump( MEMCARDIOCTL, ("MemCard: DO %.8x Irp %.8x IOCTL comp %.8x\n", DeviceObject, Irp, status));
                                         
      IoCompleteRequest( Irp, IO_NO_INCREMENT );
   }

   MemCardDump( MEMCARDIOCTL, ("MemCard: DO %.8x Irp %.8x IOCTL <-- %.8x \n", DeviceObject, Irp, status));
   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\memcard\memcard.h ===
/*++

Copyright (c) 1991 - 1993 Microsoft Corporation

Module Name:

    memcard.h

Abstract:


Author:

    Neil Sandlin (neilsa) 26-Apr-99

Environment:

    Kernel mode only.

Notes:


--*/

#ifndef _MEMCARD_H_
#define _MEMCARD_H_


#ifdef POOL_TAGGING
#ifdef ExAllocatePool
#undef ExAllocatePool
#endif
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'cmeM')
#endif

//
// The byte in the boot sector that specifies the type of media, and
// the values that it can assume.  We can often tell what type of media
// is in the drive by seeing which controller parameters allow us to read
// the diskette, but some different densities are readable with the same
// parameters so we use this byte to decide the media type.
//
#pragma pack(1)

typedef struct _BOOT_SECTOR_INFO {
    UCHAR   JumpByte;
    UCHAR   Ignore1[2];
    UCHAR   OemData[8];
    USHORT  BytesPerSector;
    UCHAR   SectorsPerCluster;
    USHORT  ReservedSectors;
    UCHAR   NumberOfFATs;
    USHORT  RootEntries;
    USHORT  TotalSectors;
    UCHAR   MediaDescriptor;
    USHORT  SectorsPerFAT;
    USHORT  SectorsPerTrack;
    USHORT  Heads;
    ULONG   BigHiddenSectors;
    ULONG   BigTotalSectors;
} BOOT_SECTOR_INFO, *PBOOT_SECTOR_INFO;

#pragma pack()



//
// Runtime device structures
//
//
// There is one MEMCARD_EXTENSION attached to the device object of each
// MEMCARDpy drive.  Only data directly related to that drive (and the media
// in it) is stored here; common data is in CONTROLLER_DATA.  So the
// MEMCARD_EXTENSION has a pointer to the CONTROLLER_DATA.
//

typedef struct _MEMCARD_EXTENSION {
    PDEVICE_OBJECT          UnderlyingPDO;
    PDEVICE_OBJECT          TargetObject;
    PDEVICE_OBJECT          DeviceObject;
    UNICODE_STRING          DeviceName;
    UNICODE_STRING          LinkName;
    UNICODE_STRING          InterfaceString;

    ULONG                   MediaIndex;
    ULONG                   ByteCapacity;
    BOOLEAN                 IsStarted;
    BOOLEAN                 IsRemoved;
    BOOLEAN                 IsMemoryMapped;
    BOOLEAN                 NoDrive;
    
    ULONGLONG               HostBase;    
    PCHAR                   MemoryWindowBase;
    ULONG                   MemoryWindowSize;
    
    ULONG                   TechnologyIndex;
    
    PCMCIA_INTERFACE_STANDARD PcmciaInterface;
    PCMCIA_BUS_INTERFACE_STANDARD  PcmciaBusInterface;
} MEMCARD_EXTENSION, *PMEMCARD_EXTENSION;


//
// macros for ReadWriteMemory
//

#define MEMCARD_READ(Extension, Offset, Buffer, Size)       \
   MemCardReadWrite(Extension, Offset, Buffer, Size, FALSE)

#define MEMCARD_WRITE(Extension, Offset, Buffer, Size)      \
   MemCardReadWrite(Extension, Offset, Buffer, Size, TRUE)

#endif  // _MEMCARD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\memcard\io.c ===
/*++

Copyright (c) 1991-1998  Microsoft Corporation

Module Name:

    io.c

Abstract:

Author:

    Neil Sandlin (neilsa) 26-Apr-99

Environment:

    Kernel mode only.

--*/
#include "pch.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,MemCardIrpReadWrite)
#pragma alloc_text(PAGE,MemCardReadWrite)
#endif



NTSTATUS
MemCardIrpReadWrite(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   )

/*++

Routine Description:

   This routine handles read/write irps for the memory card. It validates
   parameters and calls MemCardReadWrite to do the real work.

Arguments:

   DeviceObject - a pointer to the object that represents the device
   that I/O is to be done on.

   Irp - a pointer to the I/O Request Packet for this request.

Return Value:

   STATUS_SUCCESS if the packet was successfully read or written; the
   appropriate error is propogated otherwise.

--*/

{
   NTSTATUS status = STATUS_SUCCESS;
   PMEMCARD_EXTENSION memcardExtension = DeviceObject->DeviceExtension;
   PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
   BOOLEAN            writeOperation;
   
   //
   //  If the device is not active (not started yet or removed) we will
   //  just fail this request outright.
   //
   if ( memcardExtension->IsRemoved || !memcardExtension->IsStarted) {

      if ( memcardExtension->IsRemoved) {
         status = STATUS_DELETE_PENDING;
      } else {
         status = STATUS_UNSUCCESSFUL;
      }
      goto ReadWriteComplete;
   } 

   if (((irpSp->Parameters.Read.ByteOffset.LowPart +
          irpSp->Parameters.Read.Length) > memcardExtension->ByteCapacity) ||
          (irpSp->Parameters.Read.ByteOffset.HighPart != 0)) {

      status = STATUS_INVALID_PARAMETER;
      goto ReadWriteComplete;
   } 

   //
   // verify that user is really expecting some I/O operation to
   // occur.
   //
   if (!irpSp->Parameters.Read.Length) {
      //
      // Complete this zero length request with no boost.
      //
      Irp->IoStatus.Status = STATUS_SUCCESS;
      goto ReadWriteComplete;
   }
   
   if ((DeviceObject->Flags & DO_VERIFY_VOLUME) && !(irpSp->Flags & SL_OVERRIDE_VERIFY_VOLUME)) {
      //
      // The disk changed, and we set this bit.  Fail
      // all current IRPs for this device; when all are
      // returned, the file system will clear
      // DO_VERIFY_VOLUME.
      //
      status = STATUS_VERIFY_REQUIRED;
      goto ReadWriteComplete;
   }

   writeOperation = (irpSp->MajorFunction == IRP_MJ_WRITE) ? TRUE : FALSE;
   
   //
   // Do the operation
   //
   status = MemCardReadWrite(memcardExtension,
                             irpSp->Parameters.Read.ByteOffset.LowPart,
                             MmGetSystemAddressForMdl(Irp->MdlAddress),
                             irpSp->Parameters.Read.Length,
                             writeOperation);
                               
ReadWriteComplete:

   if (NT_SUCCESS(status)) {
      Irp->IoStatus.Information = irpSp->Parameters.Read.Length;
   } else {
      Irp->IoStatus.Information = 0;
   }   

   Irp->IoStatus.Status = status;
   IoCompleteRequest(Irp, IO_NO_INCREMENT);
   return status;
}   

   

NTSTATUS
MemCardReadWrite(
   IN PMEMCARD_EXTENSION memcardExtension,
   IN ULONG              startOffset,
   IN PVOID              UserBuffer,
   IN ULONG              lengthToCopy,
   IN BOOLEAN            writeOperation
   )

/*++

Routine Description:

   This routine is called to read/write data to/from the memory card.
   It breaks the request into pieces based on the size of our memory
   window.

Arguments:

   DeviceObject - a pointer to the object that represents the device
   that I/O is to be done on.

   Irp - a pointer to the I/O Request Packet for this request.

Return Value:

   STATUS_SUCCESS if the packet was successfully read or written; the
   appropriate error is propogated otherwise.

--*/

{
   NTSTATUS status = STATUS_SUCCESS;
   PCHAR     userBuffer = UserBuffer;
   ULONG     windowOffset;
   ULONG     singleCopyLength;
   BOOLEAN   bSuccess;
   ULONGLONG CardBase;
   
   if (writeOperation && (memcardExtension->PcmciaInterface.IsWriteProtected)(memcardExtension->UnderlyingPDO)) {
      return STATUS_MEDIA_WRITE_PROTECTED;
   }      
   
   MemCardDump(MEMCARDRW,("MemCard: DO %.8x %s offset %.8x, buffer %.8x, len %x\n",
                           memcardExtension->DeviceObject,
                           writeOperation?"WRITE":"READ",
                           startOffset, UserBuffer, lengthToCopy));
                           
   // pcmcia controller is 4k page granular
   windowOffset = startOffset % 4096;
   CardBase = startOffset - windowOffset;
   
   while(lengthToCopy) {
   
      bSuccess = (memcardExtension->PcmciaInterface.ModifyMemoryWindow) (
                       memcardExtension->UnderlyingPDO,
                       memcardExtension->HostBase,
                       CardBase,
                       TRUE,
                       memcardExtension->MemoryWindowSize,
                       0, 0, FALSE);
     
      if (!bSuccess) {
         status = STATUS_DEVICE_NOT_READY;
         break;
      }
     
      singleCopyLength = (lengthToCopy <= (memcardExtension->MemoryWindowSize - windowOffset)) ?
                                    lengthToCopy :
                                    (memcardExtension->MemoryWindowSize - windowOffset);
      
     
      MemCardDump(MEMCARDRW,("MemCard: COPY %.8x (devbase %.8x) %s buffer %.8x, len %x\n",
                           memcardExtension->MemoryWindowBase+windowOffset,
                           (ULONG)(CardBase+windowOffset),
                           (writeOperation ? "<=" : "=>"),
                           userBuffer,
                           singleCopyLength));
                           
      if (writeOperation) {

         MemCardMtdWrite(memcardExtension, 
                         userBuffer,    
                         memcardExtension->MemoryWindowBase+windowOffset,
                         singleCopyLength);

      } else {

         MemCardMtdRead(memcardExtension, 
                        userBuffer,    
                        memcardExtension->MemoryWindowBase+windowOffset,
                        singleCopyLength);

      }
      
      lengthToCopy -= singleCopyLength;
      userBuffer += singleCopyLength;
      
      CardBase += memcardExtension->MemoryWindowSize;
      windowOffset = 0;
   }

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\memcard\pch.h ===
/*++

Copyright (c) 1991-1998  Microsoft Corporation

Module Name:

    pch.h

Abstract:

Author:

    Neil Sandlin (neilsa) 26-Apr-99

Environment:

    Kernel mode only.

--*/

//
// Include files.
//

#include "stdio.h"
#include <stdarg.h>

#include "ntosp.h"                       // various NT definitions
#include <zwapi.h>
#include "ntdddisk.h"                    // disk device driver I/O control codes
#include "initguid.h"
#include "wdmguid.h"
#include "ntddpcm.h"
#include "mountdev.h"
#include "acpiioct.h"

#include <memcard.h>                    // this driver's data declarations
#include <extern.h>
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\memcard\extern.h ===
/*++

Copyright (c) 1991 - 1993 Microsoft Corporation

Module Name:

    extern.h

Abstract:


Author:

    Neil Sandlin (neilsa) 26-Apr-99

Environment:

    Kernel mode only.

Notes:


--*/



//
// Prototypes of driver routines.
//

NTSTATUS
MemCardDeviceControl(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
MemCardIrpReadWrite(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
MemCardAddDevice(
   IN      PDRIVER_OBJECT DriverObject,
   IN OUT  PDEVICE_OBJECT PhysicalDeviceObject
   );

NTSTATUS
MemCardPnp(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
MemCardPower(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );
    
NTSTATUS
MemCardReadWrite(
   IN PMEMCARD_EXTENSION memcardExtension,
   IN ULONG              startOffset,
   IN PVOID              userBuffer,
   IN ULONG              lengthToCopy,
   IN BOOLEAN            writeOperation
   );
   
ULONG
MemCardGetCapacity(
   IN PMEMCARD_EXTENSION memcardExtension
   );
   
NTSTATUS
MemCardInitializeMtd(
   IN PMEMCARD_EXTENSION memcardExtension,
   IN PUNICODE_STRING TechnologyName
   );
   
VOID
MemCardMtdRead(
   IN PMEMCARD_EXTENSION memcardExtension,
   IN PVOID TargetBuffer,
   IN CONST PVOID DeviceBuffer,
   IN ULONG Length
   );
   
VOID
MemCardMtdWrite(
   IN PMEMCARD_EXTENSION memcardExtension,
   IN CONST PVOID SourceBuffer,
   IN PVOID DeviceBuffer,
   IN ULONG Length
   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\memcard\memcard.c ===
/*++

Copyright (c) 1991-1998  Microsoft Corporation

Module Name:

    memcard.c

Abstract:

Author:

    Neil Sandlin (neilsa) 26-Apr-99

Environment:

    Kernel mode only.

--*/
#include "pch.h"

//
// Internal References
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
MemCardUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
MemCardCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)

#pragma alloc_text(PAGE,MemCardCreateClose)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is the driver's entry point, called by the I/O system
    to load the driver.  The driver's entry points are initialized and
    a mutex to control paging is initialized.

    In DBG mode, this routine also examines the registry for special
    debug parameters.

Arguments:

    DriverObject - a pointer to the object that represents this device
                   driver.

    RegistryPath - a pointer to this driver's key in the Services tree.

Return Value:

    STATUS_SUCCESS unless we can't allocate a mutex.

--*/

{
    NTSTATUS ntStatus = STATUS_SUCCESS;


    MemCardDump(MEMCARDSHOW, ("MemCard: DriverEntry\n") );

    //
    // Initialize the driver object with this driver's entry points.
    //
    DriverObject->MajorFunction[IRP_MJ_CREATE]         = MemCardCreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = MemCardCreateClose;
    DriverObject->MajorFunction[IRP_MJ_READ]           = MemCardIrpReadWrite;
    DriverObject->MajorFunction[IRP_MJ_WRITE]          = MemCardIrpReadWrite;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = MemCardDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_PNP]            = MemCardPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER]          = MemCardPower;

    DriverObject->DriverUnload = MemCardUnload;

    DriverObject->DriverExtension->AddDevice = MemCardAddDevice;
    
    return ntStatus;
}


VOID
MemCardUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Unload the driver from the system.  The paging mutex is freed before
    final unload.

Arguments:

    DriverObject - a pointer to the object that represents this device
                   driver.

Return Value:
    
    none

--*/

{
    MemCardDump( MEMCARDSHOW, ("MemCardUnload:\n"));

    //
    //  The device object(s) should all be gone by now.
    //
    ASSERT( DriverObject->DeviceObject == NULL );

    return;
}



NTSTATUS
MemCardCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called only rarely by the I/O system; it's mainly
    for layered drivers to call.  All it does is complete the IRP
    successfully.

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

    Always returns STATUS_SUCCESS, since this is a null operation.

--*/

{
    UNREFERENCED_PARAMETER( DeviceObject );

    MemCardDump(
        MEMCARDSHOW,
        ("MemCardCreateClose...\n")
        );

    //
    // Null operation.  Do not give an I/O boost since
    // no I/O was actually done.  IoStatus.Information should be
    // FILE_OPENED for an open; it's undefined for a close.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = FILE_OPENED;

    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\memcard\mtd.c ===
/*++

Copyright (c) 1991-1998  Microsoft Corporation

Module Name:

    mtd.c

Abstract:

    This module supplies the structure for simple "mtd" functionality
    for memory card devices.

    Note that to keep the driver simple, and because of the limited
    number of memory technologies, the code supplied here does not
    implement true mtd capability where an independent device driver
    is loaded. Instead, the driver allows a device to name its technology,
    but the choices are limited to what is directly implemented here.
    
    Alternatively, this could be extended to add a p-code style interpreter
    to allow for greater flexibility, but that's not in here yet.    

Author:

    Neil Sandlin (neilsa) 26-Apr-99

Environment:

    Kernel mode only.

--*/
#include "pch.h"

//
// Internal References
//

VOID
MtdStandardRead(
   IN PVOID TargetBuffer,
   IN CONST PVOID DeviceBuffer,
   IN ULONG Length
   );
   
VOID
MtdSramWrite(
   IN CONST PVOID SourceBuffer,
   IN PVOID DeviceBuffer,
   IN ULONG Length
   );

VOID
MtdUndefinedRead(
   IN PVOID TargetBuffer,
   IN CONST PVOID DeviceBuffer,
   IN ULONG Length
   );
   
VOID
MtdUndefinedWrite(
   IN CONST PVOID SourceBuffer,
   IN PVOID DeviceBuffer,
   IN ULONG Length
   );



#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,MemCardInitializeMtd)
#pragma alloc_text(PAGE,MtdStandardRead)
#pragma alloc_text(PAGE,MtdSramWrite)
#endif


typedef struct _MTD_ENTRY {
   PCWSTR TechnologyName;
   
   VOID (*MtdReadProc)(
              IN PVOID TargetBuffer,
              IN CONST PVOID DeviceBuffer,
              IN ULONG Length
              );
   
   VOID (*MtdWriteProc)(
              IN PVOID TargetBuffer,
              IN CONST PVOID DeviceBuffer,
              IN ULONG Length
              );

} MTD_ENTRY, *PMTD_ENTRY;              
   

MTD_ENTRY MtdTable[] = {
   L"UNDEFINED", MtdUndefinedRead, MtdUndefinedWrite,
   L"SRAM", MtdStandardRead, MtdSramWrite,
   NULL, NULL, NULL
   };
   


NTSTATUS
MemCardInitializeMtd(
   IN PMEMCARD_EXTENSION memcardExtension,
   IN PUNICODE_STRING TechnologyName
   )
/*++

Routine Description:

Arguments:

   device extension for the card

Return Value:


--*/
{
   ULONG i = 0;
   
   memcardExtension->TechnologyIndex = 0;
   
   while(MtdTable[i].TechnologyName) {
      UNICODE_STRING tableName;
      
      RtlInitUnicodeString(&tableName, MtdTable[i].TechnologyName);
      
      if (!RtlCompareUnicodeString(TechnologyName, &tableName, TRUE)) {
         memcardExtension->TechnologyIndex = i;
         return STATUS_SUCCESS;  
      }
      
      i++;
   }
   return STATUS_INVALID_PARAMETER;
}


VOID
MemCardMtdRead(
   IN PMEMCARD_EXTENSION memcardExtension,
   IN PVOID TargetBuffer,
   IN CONST PVOID DeviceBuffer,
   IN ULONG Length
   )
{
   (*MtdTable[memcardExtension->TechnologyIndex].MtdReadProc)(TargetBuffer, DeviceBuffer, Length);
}
   
VOID
MemCardMtdWrite(
   IN PMEMCARD_EXTENSION memcardExtension,
   IN CONST PVOID SourceBuffer,
   IN PVOID DeviceBuffer,
   IN ULONG Length
   )
{
   (*MtdTable[memcardExtension->TechnologyIndex].MtdWriteProc)(SourceBuffer, DeviceBuffer, Length);
}   


VOID
MtdUndefinedRead(
   IN PVOID TargetBuffer,
   IN CONST PVOID DeviceBuffer,
   IN ULONG Length
   )
{
}
   
VOID
MtdUndefinedWrite(
   IN CONST PVOID SourceBuffer,
   IN PVOID DeviceBuffer,
   IN ULONG Length
   )
{
}

VOID
MtdStandardRead(
   IN PVOID TargetBuffer,
   IN CONST PVOID DeviceBuffer,
   IN ULONG Length
   )
{
   RtlCopyMemory(TargetBuffer, DeviceBuffer, Length);
}   
   
VOID
MtdSramWrite(
   IN CONST PVOID SourceBuffer,
   IN PVOID DeviceBuffer,
   IN ULONG Length
   )
{
   RtlCopyMemory(DeviceBuffer, SourceBuffer, Length);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\memcard\pnp.c ===
/*++

Copyright (c) 1991-1998  Microsoft Corporation

Module Name:

    pnp.c

Abstract:

Author:

    Neil Sandlin (neilsa) 26-Apr-99

Environment:

    Kernel mode only.

--*/
#include "pch.h"

//
// Internal References
//

NTSTATUS
MemCardStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MemCardGetResourceRequirements(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
  );

NTSTATUS
MemCardPnpComplete (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );

NTSTATUS
MemCardGetDeviceParameters(
    IN PMEMCARD_EXTENSION memcardExtension
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,MemCardAddDevice)
#pragma alloc_text(PAGE,MemCardPnp)
#pragma alloc_text(PAGE,MemCardStartDevice)
#endif


#define MEMCARD_DEVICE_NAME            L"\\Device\\Memcard"
#define MEMCARD_LINK_NAME              L"\\DosDevices\\Memcard"
#define MEMCARD_REGISTRY_NODRIVE_KEY   L"NoDrive"
#define MEMCARD_REGISTRY_MTD_KEY       L"Mtd"



NTSTATUS
MemCardAddDevice(
   IN      PDRIVER_OBJECT DriverObject,
   IN OUT  PDEVICE_OBJECT PhysicalDeviceObject
   )
/*++

Routine Description:

   This routine is the driver's pnp add device entry point.  It is
   called by the pnp manager to initialize the driver.

   Add device creates and initializes a device object for this FDO and
   attaches to the underlying PDO.

Arguments:

   DriverObject - a pointer to the object that represents this device driver.
   PhysicalDeviceObject - a pointer to the underlying PDO to which this new device will attach.

Return Value:

   If we successfully create a device object, STATUS_SUCCESS is
   returned.  Otherwise, return the appropriate error code.

--*/

{
   NTSTATUS             status = STATUS_SUCCESS;
   PDEVICE_OBJECT       deviceObject;
   PMEMCARD_EXTENSION   memcardExtension;
   WCHAR                NameBuffer[128];
   UNICODE_STRING       deviceName;
   UNICODE_STRING       linkName;
   LONG                 deviceNumber = -1;
   KEVENT               event;
   PIRP                 irp;
   IO_STATUS_BLOCK      statusBlock;
   PIO_STACK_LOCATION   irpSp;

   MemCardDump(MEMCARDSHOW, ("MemCard: AddDevice...\n"));

   //
   //  Create a device.  We will use the first available device name for
   //  this device.
   //
   do {

      swprintf(NameBuffer, L"%s%d", MEMCARD_DEVICE_NAME, ++deviceNumber);
      RtlInitUnicodeString(&deviceName, NameBuffer);
      status = IoCreateDevice(DriverObject,
                                 sizeof(MEMCARD_EXTENSION),
                                 &deviceName,
                                 FILE_DEVICE_DISK,
                                 FILE_REMOVABLE_MEDIA,
                                 FALSE,
                                 &deviceObject);

   } while (status == STATUS_OBJECT_NAME_COLLISION);

   if (!NT_SUCCESS(status)) {
      return status;
   }

   memcardExtension = (PMEMCARD_EXTENSION)deviceObject->DeviceExtension;
   RtlZeroMemory(memcardExtension, sizeof(MEMCARD_EXTENSION));

   memcardExtension->DeviceObject = deviceObject;

   //
   //  Save the device name.
   //
   MemCardDump(MEMCARDSHOW | MEMCARDPNP,
               ("MemCard: AddDevice - Device Object Name - %S\n", NameBuffer));

   memcardExtension->DeviceName.Buffer = ExAllocatePool(PagedPool, deviceName.Length);
   if (memcardExtension->DeviceName.Buffer == NULL) {
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto errorExit;
   }
   memcardExtension->DeviceName.Length = 0;
   memcardExtension->DeviceName.MaximumLength = deviceName.Length;
   RtlCopyUnicodeString(&memcardExtension->DeviceName, &deviceName);

   //
   // create the link name
   //

   swprintf(NameBuffer, L"%s%d", MEMCARD_LINK_NAME, deviceNumber);
   RtlInitUnicodeString(&linkName, NameBuffer);

   memcardExtension->LinkName.Buffer = ExAllocatePool(PagedPool, linkName.Length);
   if (memcardExtension->LinkName.Buffer == NULL) {
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto errorExit;
   }
   memcardExtension->LinkName.Length = 0;
   memcardExtension->LinkName.MaximumLength = linkName.Length;
   RtlCopyUnicodeString(&memcardExtension->LinkName, &linkName);

   status = IoCreateSymbolicLink(&memcardExtension->LinkName, &memcardExtension->DeviceName);

   if (!NT_SUCCESS(status)) {
      goto errorExit;
   }

   //
   // Set the PDO for use with PlugPlay functions
   //

   memcardExtension->UnderlyingPDO = PhysicalDeviceObject;

   MemCardDump(MEMCARDSHOW, ("MemCard: AddDevice attaching %p to %p\n", deviceObject, PhysicalDeviceObject));

   memcardExtension->TargetObject = IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);

   MemCardDump(MEMCARDSHOW,
               ("MemCard: AddDevice TargetObject = %p\n",
               memcardExtension->TargetObject));


   //
   // Get pcmcia interfaces
   //
   KeInitializeEvent(&event, NotificationEvent, FALSE);
   irp = IoBuildSynchronousFsdRequest(IRP_MJ_PNP, memcardExtension->UnderlyingPDO,
                                      NULL, 0, 0, &event, &statusBlock);

   if (!irp) {
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto errorExit;
   }

   irp->IoStatus.Status = STATUS_NOT_SUPPORTED ;
   irp->IoStatus.Information = 0;

   irpSp = IoGetNextIrpStackLocation(irp);

   irpSp->MinorFunction = IRP_MN_QUERY_INTERFACE;

   irpSp->Parameters.QueryInterface.InterfaceType= &GUID_PCMCIA_INTERFACE_STANDARD;
   irpSp->Parameters.QueryInterface.Size = sizeof(PCMCIA_INTERFACE_STANDARD);
   irpSp->Parameters.QueryInterface.Version = 1;
   irpSp->Parameters.QueryInterface.Interface = (PINTERFACE) &memcardExtension->PcmciaInterface;

   status = IoCallDriver(memcardExtension->UnderlyingPDO, irp);

   if (status == STATUS_PENDING) {
      KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
      status = statusBlock.Status;
   }

   if (!NT_SUCCESS(status)) {
      goto errorExit;
   }

   KeInitializeEvent(&event, NotificationEvent, FALSE);
   irp = IoBuildSynchronousFsdRequest(IRP_MJ_PNP, memcardExtension->UnderlyingPDO,
                                      NULL, 0, 0, &event, &statusBlock);

   if (!irp) {
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto errorExit;
   }

   irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
   irp->IoStatus.Information = 0;

   irpSp = IoGetNextIrpStackLocation(irp);

   irpSp->MinorFunction = IRP_MN_QUERY_INTERFACE;

   irpSp->Parameters.QueryInterface.InterfaceType= &GUID_PCMCIA_BUS_INTERFACE_STANDARD;
   irpSp->Parameters.QueryInterface.Size = sizeof(PCMCIA_BUS_INTERFACE_STANDARD);
   irpSp->Parameters.QueryInterface.Version = 1;
   irpSp->Parameters.QueryInterface.Interface = (PINTERFACE) &memcardExtension->PcmciaBusInterface;

   status = IoCallDriver(memcardExtension->UnderlyingPDO, irp);

   if (status == STATUS_PENDING) {
      KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
      status = statusBlock.Status;
   }

   if (!NT_SUCCESS(status)) {
      goto errorExit;
   }

   status = MemCardGetDeviceParameters(memcardExtension);
   if (!NT_SUCCESS(status)) {
      goto errorExit;
   }

   //
   // done
   //

   deviceObject->Flags |= DO_DIRECT_IO | DO_POWER_PAGABLE;
   deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

   memcardExtension->IsStarted = FALSE;
   memcardExtension->IsRemoved = FALSE;

   return STATUS_SUCCESS;

errorExit:

   if (memcardExtension->DeviceName.Buffer != NULL) {
      ExFreePool(memcardExtension->DeviceName.Buffer);
   }

   if (memcardExtension->LinkName.Buffer != NULL) {
      IoDeleteSymbolicLink(&memcardExtension->LinkName);
      ExFreePool(memcardExtension->LinkName.Buffer);
   }

   if (memcardExtension->TargetObject) {
      IoDetachDevice(memcardExtension->TargetObject);
   }

   IoDeleteDevice(deviceObject);
   return status;
}



NTSTATUS
MemCardPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
   )
/*++

Routine Description:

   Main PNP irp dispatch routine

Arguments:

   DeviceObject - a pointer to the object that represents the device
   that I/O is to be done on.

   Irp - a pointer to the I/O Request Packet for this request.

Return Value:

   status

--*/
{
   PIO_STACK_LOCATION irpSp;
   PMEMCARD_EXTENSION memcardExtension;
   NTSTATUS status = STATUS_SUCCESS;
   ULONG i;


   memcardExtension = DeviceObject->DeviceExtension;

   irpSp = IoGetCurrentIrpStackLocation(Irp);

   MemCardDump(MEMCARDPNP, ("MemCard: DO %.8x Irp %.8x PNP func %x\n",
                           DeviceObject, Irp, irpSp->MinorFunction));

   if (memcardExtension->IsRemoved) {

      //
      // Since the device is stopped, but we don't hold IRPs,
      // this is a surprise removal. Just fail it.
      //
      Irp->IoStatus.Information = 0;
      Irp->IoStatus.Status = STATUS_DELETE_PENDING;
      IoCompleteRequest (Irp, IO_NO_INCREMENT);
      return STATUS_DELETE_PENDING;
   }

   switch (irpSp->MinorFunction) {

   case IRP_MN_START_DEVICE:

      status = MemCardStartDevice(DeviceObject, Irp);
      break;

   case IRP_MN_QUERY_STOP_DEVICE:
   case IRP_MN_QUERY_REMOVE_DEVICE:

      if (irpSp->MinorFunction == IRP_MN_QUERY_STOP_DEVICE) {
         MemCardDump(MEMCARDPNP,("MemCard: IRP_MN_QUERY_STOP_DEVICE\n"));
      } else {
         MemCardDump(MEMCARDPNP,("MemCard: IRP_MN_QUERY_REMOVE_DEVICE\n"));
      }

      if (!memcardExtension->IsStarted) {
         //
         // If we aren't started, we'll just pass the irp down.
         //
         IoSkipCurrentIrpStackLocation (Irp);
         status = IoCallDriver(memcardExtension->TargetObject, Irp);

         return status;
      }


      Irp->IoStatus.Status = STATUS_SUCCESS;
      IoSkipCurrentIrpStackLocation(Irp);
      status = IoCallDriver(memcardExtension->TargetObject, Irp);

      break;

   case IRP_MN_CANCEL_STOP_DEVICE:
   case IRP_MN_CANCEL_REMOVE_DEVICE:

      if (irpSp->MinorFunction == IRP_MN_CANCEL_STOP_DEVICE) {
         MemCardDump(MEMCARDPNP,("MemCard: IRP_MN_CANCEL_STOP_DEVICE\n"));
      } else {
         MemCardDump(MEMCARDPNP,("MemCard: IRP_MN_CANCEL_REMOVE_DEVICE\n"));
      }

      if (!memcardExtension->IsStarted) {

         //
         // Nothing to do, just pass the irp down:
         // no need to start the device
         //
         IoSkipCurrentIrpStackLocation (Irp);
         status = IoCallDriver(memcardExtension->TargetObject, Irp);

      } else  {

         KEVENT doneEvent;

         //
         // Set the status to STATUS_SUCCESS
         //
         Irp->IoStatus.Status = STATUS_SUCCESS;

         //
         // We need to wait for the lower drivers to do their job.
         //
         IoCopyCurrentIrpStackLocationToNext (Irp);

         //
         // Clear the event: it will be set in the completion
         // routine.
         //
         KeInitializeEvent(&doneEvent,
                            SynchronizationEvent,
                            FALSE);

         IoSetCompletionRoutine(Irp,
                                 MemCardPnpComplete,
                                 &doneEvent,
                                 TRUE, TRUE, TRUE);

         status = IoCallDriver(memcardExtension->TargetObject, Irp);

         if (status == STATUS_PENDING) {

             KeWaitForSingleObject(&doneEvent,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    NULL);

             status = Irp->IoStatus.Status;
         }

         //
         // We must now complete the IRP, since we stopped it in the
         // completetion routine with MORE_PROCESSING_REQUIRED.
         //
         Irp->IoStatus.Status = status;
         Irp->IoStatus.Information = 0;
         IoCompleteRequest (Irp, IO_NO_INCREMENT);
      }
      break;

   case IRP_MN_STOP_DEVICE:

       MemCardDump(MEMCARDPNP,("MemCard: IRP_MN_STOP_DEVICE\n"));

       if (memcardExtension->IsMemoryMapped) {
           MmUnmapIoSpace(memcardExtension->MemoryWindowBase, memcardExtension->MemoryWindowSize);
           memcardExtension->MemoryWindowBase = 0;
           memcardExtension->MemoryWindowSize = 0;
           memcardExtension->IsMemoryMapped = FALSE;
       }

       memcardExtension->IsStarted = FALSE;

       Irp->IoStatus.Status = STATUS_SUCCESS;
       IoSkipCurrentIrpStackLocation(Irp);
       status = IoCallDriver(memcardExtension->TargetObject, Irp);

       break;

   case IRP_MN_REMOVE_DEVICE:

       MemCardDump(MEMCARDPNP,("MemCard: IRP_MN_REMOVE_DEVICE\n"));

       //
       // We need to mark the fact that we don't hold requests first, since
       // we asserted earlier that we are holding requests only if
       // we're not removed.
       //
       memcardExtension->IsStarted = FALSE;
       memcardExtension->IsRemoved = TRUE;

       //
       //  Forward this Irp to the underlying PDO
       //
       IoSkipCurrentIrpStackLocation(Irp);
       Irp->IoStatus.Status = STATUS_SUCCESS;
       status = IoCallDriver(memcardExtension->TargetObject, Irp);

       //
       //  Send notification that we are going away.
       //
       if (memcardExtension->InterfaceString.Buffer != NULL) {

           IoSetDeviceInterfaceState(&memcardExtension->InterfaceString,
                                      FALSE);

           RtlFreeUnicodeString(&memcardExtension->InterfaceString);
           RtlInitUnicodeString(&memcardExtension->InterfaceString, NULL);
       }

       //
       // Remove our link
       //
       IoDeleteSymbolicLink(&memcardExtension->LinkName);

       RtlFreeUnicodeString(&memcardExtension->LinkName);
       RtlInitUnicodeString(&memcardExtension->LinkName, NULL);

       RtlFreeUnicodeString(&memcardExtension->DeviceName);
       RtlInitUnicodeString(&memcardExtension->DeviceName, NULL);

       //
       //  Detatch from the undelying device.
       //
       IoDetachDevice(memcardExtension->TargetObject);

       //
       //  And delete the device.
       //
       IoDeleteDevice(DeviceObject);

       break;


   case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
      status = MemCardGetResourceRequirements(DeviceObject, Irp);
      break;


   default:
       MemCardDump(MEMCARDPNP, ("MemCardPnp: Unsupported PNP Request %x - Irp: %p\n",irpSp->MinorFunction, Irp));
       IoSkipCurrentIrpStackLocation(Irp);
       status = IoCallDriver(memcardExtension->TargetObject, Irp);
   }

   return status;
}



NTSTATUS
MemCardStartDevice(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   )
/*++

Routine Description:

   Start device routine

Arguments:

   DeviceObject - a pointer to the object that represents the device
   that I/O is to be done on.

   Irp - a pointer to the I/O Request Packet for this request.

Return Value:

   status

--*/
{
   NTSTATUS status;
   NTSTATUS pnpStatus;
   KEVENT doneEvent;
   PCM_RESOURCE_LIST ResourceList;
   PCM_RESOURCE_LIST TranslatedResourceList;
   PCM_PARTIAL_RESOURCE_LIST        partialResourceList, partialTranslatedList;
   PCM_PARTIAL_RESOURCE_DESCRIPTOR  partialResourceDesc, partialTranslatedDesc;
   PCM_FULL_RESOURCE_DESCRIPTOR     fullResourceDesc, fullTranslatedDesc;

   PMEMCARD_EXTENSION memcardExtension = (PMEMCARD_EXTENSION)DeviceObject->DeviceExtension;
   PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

   MemCardDump(MEMCARDPNP,("MemCard: StartDevice\n"));
   MemCardDump(MEMCARDSHOW, ("        AllocatedResources = %08x\n",irpSp->Parameters.StartDevice.AllocatedResources));
   MemCardDump(MEMCARDSHOW, ("        AllocatedResourcesTranslated = %08x\n",irpSp->Parameters.StartDevice.AllocatedResourcesTranslated));

   //
   // First we must pass this Irp on to the PDO.
   //
   KeInitializeEvent(&doneEvent, NotificationEvent, FALSE);

   IoCopyCurrentIrpStackLocationToNext(Irp);

   IoSetCompletionRoutine(Irp,
                           MemCardPnpComplete,
                           &doneEvent,
                           TRUE, TRUE, TRUE);

   status = IoCallDriver(memcardExtension->TargetObject, Irp);

   if (status == STATUS_PENDING) {

       status = KeWaitForSingleObject(&doneEvent,
                                         Executive,
                                         KernelMode,
                                         FALSE,
                                         NULL);

       ASSERT(status == STATUS_SUCCESS);

       status = Irp->IoStatus.Status;
   }

   if (!NT_SUCCESS(status)) {
      Irp->IoStatus.Status = status;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
      return status;
   }

   //
   // Parse the resources to map the memory window
   //
   ResourceList = irpSp->Parameters.StartDevice.AllocatedResources;
   TranslatedResourceList = irpSp->Parameters.StartDevice.AllocatedResourcesTranslated;

   fullResourceDesc = &ResourceList->List[0];
   fullTranslatedDesc = &TranslatedResourceList->List[0];

   partialResourceList   = &fullResourceDesc->PartialResourceList;
   partialTranslatedList = &fullTranslatedDesc->PartialResourceList;

   partialResourceDesc   = partialResourceList->PartialDescriptors;
   partialTranslatedDesc = partialTranslatedList->PartialDescriptors;

   if (partialResourceDesc->Type != CmResourceTypeMemory) {
      ASSERT(partialResourceDesc->Type == CmResourceTypeMemory);
      Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
      return STATUS_INVALID_PARAMETER;
   }

   memcardExtension->HostBase = partialTranslatedDesc->u.Memory.Start.QuadPart;
   memcardExtension->MemoryWindowSize = partialTranslatedDesc->u.Memory.Length;
   //
   //

   switch (partialTranslatedDesc->Type) {

   case CmResourceTypeMemory:
      memcardExtension->MemoryWindowBase = MmMapIoSpace(partialTranslatedDesc->u.Memory.Start,
                                                       partialTranslatedDesc->u.Memory.Length,
                                                       FALSE);
      memcardExtension->IsMemoryMapped = TRUE;
      break;

   case CmResourceTypePort:
      memcardExtension->MemoryWindowBase = (PUCHAR) partialResourceDesc->u.Port.Start.QuadPart;
      memcardExtension->IsMemoryMapped = FALSE;
      break;

   default:
      ASSERT(FALSE);
      Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
      return STATUS_INVALID_PARAMETER;
   }

   //
   // Try to get the capacity of the card
   //
   memcardExtension->ByteCapacity = MemCardGetCapacity(memcardExtension);

   //
   // If we can't get the capacity, the must be broken in some way
   //

   if (!memcardExtension->ByteCapacity) {
      Irp->IoStatus.Status = STATUS_UNRECOGNIZED_MEDIA;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
      return STATUS_UNRECOGNIZED_MEDIA;
   }


   if (!memcardExtension->NoDrive) {
      pnpStatus = IoRegisterDeviceInterface(memcardExtension->UnderlyingPDO,
                                            (LPGUID)&MOUNTDEV_MOUNTED_DEVICE_GUID,
                                            NULL,
                                            &memcardExtension->InterfaceString);

      if ( NT_SUCCESS(pnpStatus) ) {

          pnpStatus = IoSetDeviceInterfaceState(&memcardExtension->InterfaceString,
                                                TRUE);
      }
   }

   memcardExtension->IsStarted = TRUE;

   Irp->IoStatus.Status = status;
   IoCompleteRequest(Irp, IO_NO_INCREMENT);

   return status;
}


NTSTATUS
MemCardPnpComplete (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
  )
/*++
Routine Description:
    A completion routine for use when calling the lower device objects to
    which our bus (FDO) is attached.

--*/
{

    KeSetEvent ((PKEVENT) Context, 1, FALSE);
    // No special priority
    // No Wait

    return STATUS_MORE_PROCESSING_REQUIRED; // Keep this IRP
}

NTSTATUS
MemCardGetResourceRequirements(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   )
/*++

Routine Description:

   Provides a memory resource requirement in case the bus driver
   doesn't.

Arguments:

   DeviceObject - a pointer to the object that represents the device
   that I/O is to be done on.

   Irp - a pointer to the I/O Request Packet for this request.

Return Value:

   status

--*/
{
   NTSTATUS status;
   KEVENT doneEvent;
   PIO_RESOURCE_REQUIREMENTS_LIST ioResourceRequirementsList;
   PIO_RESOURCE_LIST ioResourceList;
   PIO_RESOURCE_DESCRIPTOR ioResourceDesc;
   PMEMCARD_EXTENSION memcardExtension = (PMEMCARD_EXTENSION)DeviceObject->DeviceExtension;
   PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
   ULONG listSize;

   //
   // First we must pass this Irp on to the PDO.
   //
   KeInitializeEvent(&doneEvent, NotificationEvent, FALSE);

   IoCopyCurrentIrpStackLocationToNext(Irp);

   IoSetCompletionRoutine(Irp,
                          MemCardPnpComplete,
                          &doneEvent,
                          TRUE, TRUE, TRUE);

   status = IoCallDriver(memcardExtension->TargetObject, Irp);

   if (status == STATUS_PENDING) {

      status = KeWaitForSingleObject(&doneEvent,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL);

      ASSERT(status == STATUS_SUCCESS);

      status = Irp->IoStatus.Status;
   }

   if (NT_SUCCESS(status) && (Irp->IoStatus.Information == 0)) {

      listSize = sizeof(IO_RESOURCE_REQUIREMENTS_LIST);

      ioResourceRequirementsList = (PIO_RESOURCE_REQUIREMENTS_LIST) ExAllocatePool(PagedPool, listSize);

      RtlZeroMemory(ioResourceRequirementsList, listSize);

      ioResourceRequirementsList->ListSize = listSize;
      ioResourceRequirementsList->AlternativeLists = 1;
      //
      // NOTE: not quite sure if the following values are the best choices
      //
      ioResourceRequirementsList->InterfaceType = Isa;
      ioResourceRequirementsList->BusNumber = 0;
      ioResourceRequirementsList->SlotNumber = 0;

      ioResourceList = &ioResourceRequirementsList->List[0];

      ioResourceList->Version  = 1;
      ioResourceList->Revision = 1;
      ioResourceList->Count    = 1;

      ioResourceDesc = &ioResourceList->Descriptors[0];
      ioResourceDesc->Option = 0;
      ioResourceDesc->Type  =  CmResourceTypeMemory;
      ioResourceDesc->Flags =  CM_RESOURCE_MEMORY_READ_WRITE;
      ioResourceDesc->ShareDisposition =  CmResourceShareDeviceExclusive;
      ioResourceDesc->u.Memory.MinimumAddress.QuadPart = 0;
      ioResourceDesc->u.Memory.MaximumAddress.QuadPart = (ULONGLONG)-1;
      ioResourceDesc->u.Memory.Length = 0x2000;
      ioResourceDesc->u.Memory.Alignment = 0x2000;

      Irp->IoStatus.Information = (ULONG_PTR)ioResourceRequirementsList;
   }
   Irp->IoStatus.Status = status;
   IoCompleteRequest(Irp, IO_NO_INCREMENT);

   return status;
}


NTSTATUS
MemCardGetDeviceParameters(
    IN PMEMCARD_EXTENSION memcardExtension
    )
/*++

Routine Description:

   Loads device specific parameters from the registry

Arguments:

   memcardExtension - device extension of the device

Return Value:

   status

--*/
{
   NTSTATUS status;
   HANDLE instanceHandle;
   UNICODE_STRING KeyName;
   UCHAR buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 32*sizeof(UCHAR)];
   PKEY_VALUE_PARTIAL_INFORMATION value = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
   ULONG length;

   if (!memcardExtension->UnderlyingPDO) {
      return STATUS_UNSUCCESSFUL;
   }

   status = IoOpenDeviceRegistryKey(memcardExtension->UnderlyingPDO,
                                    PLUGPLAY_REGKEY_DRIVER,
                                    KEY_READ,
                                    &instanceHandle
                                    );
   if (!NT_SUCCESS(status)) {
      return(status);
   }

   //
   // Read in the "NoDrive" parameter
   //

   RtlInitUnicodeString(&KeyName, MEMCARD_REGISTRY_NODRIVE_KEY);

   status =  ZwQueryValueKey(instanceHandle,
                             &KeyName,
                             KeyValuePartialInformation,
                             value,
                             sizeof(buffer),
                             &length);

   if (NT_SUCCESS(status)) {
      memcardExtension->NoDrive = (BOOLEAN) (*(PULONG)(value->Data) != 0);
   }

   //
   // Read in the MTD name
   //

   RtlInitUnicodeString(&KeyName, MEMCARD_REGISTRY_MTD_KEY);

   status =  ZwQueryValueKey(instanceHandle,
                             &KeyName,
                             KeyValuePartialInformation,
                             value,
                             sizeof(buffer),
                             &length);

   if (NT_SUCCESS(status)) {
      UNICODE_STRING TechnologyName;

      RtlInitUnicodeString(&TechnologyName, (PVOID)value->Data);

      status = MemCardInitializeMtd(memcardExtension, &TechnologyName);
   }

   ZwClose(instanceHandle);
   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\memcard\power.c ===
/*++

Copyright (c) 1991-1998  Microsoft Corporation

Module Name:

    power.c

Abstract:

    This module contains code to handle IRP_MJ_POWER dispatches for
    PCMCIA memory card devices

Author:

    Neil Sandlin (neilsa) 26-Apr-99

Environment:

    Kernel mode only.

--*/
#include "pch.h"

NTSTATUS
MemCardSetFdoPowerState(
   IN PDEVICE_OBJECT Fdo,
   IN OUT PIRP Irp
   );

NTSTATUS
MemCardSetFdoSystemPowerState(
   IN PDEVICE_OBJECT Fdo,
   IN OUT PIRP Irp
   );

VOID
MemCardFdoSystemPowerDeviceIrpComplete(
   IN PDEVICE_OBJECT Fdo,
   IN UCHAR MinorFunction,
   IN POWER_STATE PowerState,
   IN PVOID Context,
   IN PIO_STATUS_BLOCK IoStatus
   );
   
NTSTATUS
MemCardSetFdoDevicePowerState (
   IN PDEVICE_OBJECT Fdo,
   IN OUT PIRP Irp
   );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,MemCardPower)
#endif


NTSTATUS
MemCardPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );
   PMEMCARD_EXTENSION memcardExtension = DeviceObject->DeviceExtension;

    MemCardDump( MEMCARDSHOW, ("MemCardPower:\n"));

    switch (irpSp->MinorFunction) {
    
    case IRP_MN_SET_POWER:
         status = MemCardSetFdoPowerState(DeviceObject, Irp);
         break;

    case IRP_MN_QUERY_POWER:
         //
         // No need to send this irp down
         //
         status = STATUS_SUCCESS;
         PoStartNextPowerIrp(Irp);
         Irp->IoStatus.Status = status;
         IoCompleteRequest(Irp, IO_NO_INCREMENT);
         break;
          
    default: 

         PoStartNextPowerIrp( Irp );
         IoSkipCurrentIrpStackLocation(Irp);
         status = PoCallDriver(memcardExtension->TargetObject, Irp);
         break;
    }

    return status;
}



NTSTATUS
MemCardSetFdoPowerState(
   IN PDEVICE_OBJECT Fdo,
   IN OUT PIRP Irp
   )
/*++

Routine Description

   Dispatches the IRP based on whether a system power state
   or device power state transition is requested

Arguments

   DeviceObject      - Pointer to the functional device object for the pcmcia controller
   Irp               - Pointer to the Irp for the power dispatch

Return value

   status

--*/
{
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
   NTSTATUS           status;

   if (irpStack->Parameters.Power.Type == DevicePowerState) {
      status = MemCardSetFdoDevicePowerState(Fdo, Irp);

   } else if (irpStack->Parameters.Power.Type == SystemPowerState) {
      status = MemCardSetFdoSystemPowerState(Fdo, Irp);

   } else {
      status = STATUS_NOT_SUPPORTED;
      Irp->IoStatus.Status = status;
      PoStartNextPowerIrp (Irp);
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
   }

   return status;
}


NTSTATUS
MemCardSetFdoSystemPowerState(
   IN PDEVICE_OBJECT Fdo,
   IN OUT PIRP Irp
   )
/*++

Routine Description

   Handles system power state IRPs for the pccard controller.

Arguments

   DeviceObject      - Pointer to the functional device object for the pcmcia controller
   Irp               - Pointer to the Irp for the power dispatch

Return value

   status

--*/
{
   PMEMCARD_EXTENSION memcardExtension = Fdo->DeviceExtension;
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
   SYSTEM_POWER_STATE newSystemState = irpStack->Parameters.Power.State.SystemState;
   NTSTATUS           status = STATUS_SUCCESS;
   POWER_STATE        powerState;

   MemCardDump( MEMCARDSHOW, ("MemCard: Set System Power(%d)\n", newSystemState));
   ASSERT(irpStack->Parameters.Power.Type == SystemPowerState);

   //
   // Find the device power state corresponding to this system state
   //
   if (newSystemState == PowerSystemWorking) {
      powerState.DeviceState = PowerDeviceD0;
   } else {
      powerState.DeviceState = PowerDeviceD3;
   }      
   //
   // Send a D IRP to the stack if necessary
   //
   MemCardDump( MEMCARDSHOW, ("MemCard: generating D irp (%d)\n", powerState.DeviceState));
       
   status = PoRequestPowerIrp(memcardExtension->DeviceObject,
                              IRP_MN_SET_POWER,
                              powerState,
                              MemCardFdoSystemPowerDeviceIrpComplete,
                              Irp,
                              NULL
                              );
   return status;
}


VOID
MemCardFdoSystemPowerDeviceIrpComplete(
   IN PDEVICE_OBJECT Fdo,
   IN UCHAR MinorFunction,
   IN POWER_STATE PowerState,
   IN PVOID Context,
   IN PIO_STATUS_BLOCK IoStatus
   )
/*++

Routine Description

   This routine is called on completion of a D irp generated by an S irp.

Parameters

   DeviceObject   -  Pointer to the Fdo for the PCMCIA controller
   MinorFunction  -  Minor function of the IRP_MJ_POWER request
   PowerState     -  Power state requested 
   Context        -  Context passed in to the completion routine
   IoStatus       -  Pointer to the status block which will contain
                     the returned status
Return Value

   Status

--*/
{
   PMEMCARD_EXTENSION memcardExtension = Fdo->DeviceExtension;
   PIRP Irp = Context;
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
   
   ASSERT(NT_SUCCESS(IoStatus->Status));
   
   PoSetPowerState (Fdo, SystemPowerState, irpStack->Parameters.Power.State);
   
   //
   // Send the S IRP to the pdo
   //
   PoStartNextPowerIrp (Irp);
   IoSkipCurrentIrpStackLocation(Irp);
   PoCallDriver(memcardExtension->TargetObject, Irp);
}



NTSTATUS
MemCardSetFdoDevicePowerState (
   IN PDEVICE_OBJECT Fdo,
   IN OUT PIRP Irp
   )
/*++

Routine Description

   Handles device power state IRPs for the pccard controller.

Arguments

   DeviceObject      - Pointer to the functional device object for the pcmcia controller
   Irp               - Pointer to the Irp for the power dispatch

Return value

   status

--*/
{
   NTSTATUS           status;
   PMEMCARD_EXTENSION memcardExtension = Fdo->DeviceExtension;
   MemCardDump( MEMCARDSHOW, ("MemCard: Set Device Power\n"));

   PoStartNextPowerIrp (Irp);
   IoSkipCurrentIrpStackLocation(Irp);
   status = PoCallDriver(memcardExtension->TargetObject, Irp);
   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\pcmcibus\cb.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    cb.c

Abstract:

    This module contains the code that contains
    generic (Yenta compliant) cardbus controller
    specific initialization and other dispatches

Author:

    Ravisankar Pudipeddi (ravisp) 1-Nov-97
    Neil Sandlin (neilsa) June 1 1999    


Environment:

    Kernel mode

Revision History :

    Neil Sandlin (neilsa) 3-Mar-99
      new setpower routine interface

--*/

#include "pch.h"

//
// Function Prototypes
//

BOOLEAN
CBInitializePcmciaSocket(
   PSOCKET Socket
   );

NTSTATUS
CBResetCard(
   PSOCKET Socket,
   PULONG pDelayTime
   );
   
BOOLEAN
CBDetectCardInSocket(
   IN PSOCKET Socket
   );

BOOLEAN
CBDetectCardChanged(
   IN PSOCKET Socket
   );
   
BOOLEAN
CBDetectCardStatus(
   IN PSOCKET Socket
   );
   
BOOLEAN
CBDetectReadyChanged(
   IN PSOCKET Socket
   );

NTSTATUS
CBGetPowerRequirements(
   IN PSOCKET Socket
   );
   
BOOLEAN
CBProcessConfigureRequest(
   IN PSOCKET Socket, 
   IN PVOID  ConfigRequest,
   IN PUCHAR Base
   );
   
BOOLEAN
CBEnableDisableCardDetectEvent(
   IN PSOCKET Socket,
   IN BOOLEAN Enable
   );
   
ULONG
CBGetIrqMask(
   IN PFDO_EXTENSION DeviceExtension
   );
   
ULONG
CBReadCardMemory(
   IN PPDO_EXTENSION PdoExtension,
   IN MEMORY_SPACE MemorySpace,
   IN ULONG   Offset,
   IN PUCHAR Buffer,
   IN ULONG  Length
   );
   
ULONG
CBWriteCardMemory(
   IN PPDO_EXTENSION PdoExtension,
   IN  MEMORY_SPACE MemorySpace,
   IN  ULONG  Offset,
   IN  PUCHAR Buffer,
   IN  ULONG  Length
   );
   
VOID
CBEnableDisableWakeupEvent(
   IN PSOCKET Socket,
   IN PPDO_EXTENSION PdoExtension,
   IN BOOLEAN Enable
   );
   
BOOLEAN
CBModifyMemoryWindow(
   IN PDEVICE_OBJECT Pdo,
   IN ULONGLONG HostBase,
   IN ULONGLONG CardBase OPTIONAL,
   IN BOOLEAN   Enable,
   IN ULONG     WindowSize  OPTIONAL,
   IN UCHAR     AccessSpeed OPTIONAL,
   IN UCHAR     BusWidth    OPTIONAL,
   IN BOOLEAN   IsAttributeMemory OPTIONAL
   );                      
   
BOOLEAN
CBSetVpp(
   IN PDEVICE_OBJECT Pdo,
   IN UCHAR          Vpp
   );
   
BOOLEAN
CBIsWriteProtected(
   IN PDEVICE_OBJECT Pdo
   );

//
// Function dispatch data block
//

PCMCIA_CTRL_BLOCK CBSupportFns = {
   CBInitializePcmciaSocket,
   CBResetCard,
   CBDetectCardInSocket,
   CBDetectCardChanged,
   CBDetectCardStatus,
   CBDetectReadyChanged,
   CBGetPowerRequirements,
   CBProcessConfigureRequest,
   CBEnableDisableCardDetectEvent,
   CBEnableDisableWakeupEvent,
   CBGetIrqMask,
   CBReadCardMemory,
   CBWriteCardMemory,
   CBModifyMemoryWindow,
   CBSetVpp,
   CBIsWriteProtected
};

extern PCMCIA_CTRL_BLOCK PcicSupportFns;

//
// Support functions
//


NTSTATUS
CBBuildSocketList(
   IN PFDO_EXTENSION FdoExtension
   )
/*++

Routine Description:

    This routine builds the socket list for the given FDO. This is very
    simple for cardbus since there is always only 1 socket per controller.

Arguments:

    FdoExtension - device extension for the controller

Return Value:

    ntstatus

--*/
{
   PSOCKET        socket = NULL;
   
   socket = ExAllocatePool(NonPagedPool, sizeof(SOCKET));
   if (!socket) {
      return STATUS_INSUFFICIENT_RESOURCES;
   }
   RtlZeroMemory(socket, sizeof(SOCKET));

   FdoExtension->SocketList = socket;

   socket->DeviceExtension = FdoExtension;
   socket->SocketFnPtr = &CBSupportFns;
   
   return STATUS_SUCCESS;
}




BOOLEAN
CBInitializePcmciaSocket(
   PSOCKET Socket
   )
/*++

Routine Description:

    This routine will setup the controller into a state where the pcmcia support
    module will be able to issue commands to read device tuples from the
    cards in the sockets.

Arguments:

    Socket - socket specific information

Return Value:

    TRUE if successful
    FALSE if not successful

--*/
{
   UCHAR             index;
   UCHAR             reg;
   
   //
   // Initialize exca registers
   //
   if (!PcicSupportFns.PCBInitializePcmciaSocket(Socket)) {
      return FALSE;
   }

   //
   // Clear pending events
   //
   CBWriteSocketRegister(Socket, CARDBUS_SOCKET_EVENT_REG, 0x0000000F);
   
   //
   // Since we may have just powered up, do a cvstest to make sure the socket registers
   // are valid
   //      
       
   if (CBDetectCardInSocket(Socket) && 
       !IsDeviceFlagSet(Socket->DeviceExtension, PCMCIA_FDO_ON_DEBUG_PATH)) { 
      CBIssueCvsTest(Socket);
   }

   return TRUE;
}



VOID
CBIssueCvsTest(
   IN PSOCKET Socket
   )
/*++

Routine Description:

   This routine forces the controller to reinterrogate the card type and voltage
   requirements. This is to insure correct values read from the socket registers.

Arguments:

   Socket - socket specific information

Return Value:

   none

--*/
{
   ULONG dwSktMask;

   //
   // Issue CVSTEST to interrogate card
   // Disable interrupt temporarily because TI 12xx could cause spurious
   // interrupt when playing with SktForce register.
   //
   dwSktMask = CBReadSocketRegister(Socket, CARDBUS_SOCKET_MASK_REG);
   CBWriteSocketRegister(Socket, CARDBUS_SOCKET_MASK_REG, 0);
   CBWriteSocketRegister(Socket, CARDBUS_SOCKET_FORCE_EVENT_REG, SKTFORCE_CVSTEST);
   
   CBWriteSocketRegister(Socket, CARDBUS_SOCKET_MASK_REG, dwSktMask);

   // it would be nice to figure out a cleaner way to determine when interrogation is complete   
   PcmciaWait(300000);
}
   


BOOLEAN
CBEnableDeviceInterruptRouting(
   IN PSOCKET Socket
   )
/*++

Routine Description:

Arguments:

   Socket - socket specific information

Return Value:

   FALSE - irq to PCI
   TRUE - route to ISA

--*/
{
   USHORT word, orig_word;
   
   //
   // set up IRQ routing
   //

   GetPciConfigSpace(Socket->DeviceExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
   orig_word = word;

   if (IsCardBusCardInSocket(Socket) ||
      (Is16BitCardInSocket(Socket) && IsSocketFlagSet(Socket, SOCKET_CB_ROUTE_R2_TO_PCI))) {
      //
      // route to PCI 
      //
      word &= ~BCTRL_IRQROUTING_ENABLE;
   } else {         
      //
      // route to ISA
      //
      word |= BCTRL_IRQROUTING_ENABLE;
   }      

   if (orig_word != word) {
      SetPciConfigSpace(Socket->DeviceExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
   }      

   // return TRUE for routing to ISA   
   return ((word & BCTRL_IRQROUTING_ENABLE) == BCTRL_IRQROUTING_ENABLE);
}   
   


NTSTATUS
CBResetCard(
   PSOCKET Socket,
   OUT PULONG pDelayTime   
   )
/*++

Routine Description:

   Resets the pc-card in the given socket.

Arguments:

   Socket - Pointer to the socket in which the pc-card resides
   pDelayTime - specifies delay (msec) to occur after the current phase   

Return value:

   STATUS_MORE_PROCESSING_REQUIRED - increment phase, perform delay, recall
   other status values terminate sequence

--*/
{
   NTSTATUS status = STATUS_MORE_PROCESSING_REQUIRED;
   UCHAR             byte;
   USHORT            word;
   PFDO_EXTENSION    deviceExtension=Socket->DeviceExtension;
   
   
   if (Is16BitCardInSocket(Socket)) {
      if (Socket->CardResetPhase == 2) {
         GetPciConfigSpace(deviceExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
         //
         // R2 card. Turn off write posting
         //
         word &= ~BCTRL_WRITE_POSTING_ENABLE;
         SetPciConfigSpace(deviceExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
      }
   
      status = PcicSupportFns.PCBResetCard(Socket, pDelayTime);
      return status;   
   }
   

   switch(Socket->CardResetPhase) {
   case 1:
     
      //
      // Reset via bridge control
      //
      GetPciConfigSpace(deviceExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
      word |= BCTRL_CRST;
      SetPciConfigSpace(deviceExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);

      Socket->PowerData = (ULONG) word;                  
      *pDelayTime = CBResetWidthDelay;
      break;

   case 2:
         
      word = (USHORT)Socket->PowerData;
      word &= ~BCTRL_CRST;
      //
      // CardBus card. Turn on write posting
      //
      word |= BCTRL_WRITE_POSTING_ENABLE;
      word &= ~BCTRL_IRQROUTING_ENABLE;
      //
      // Hack: turn of write posting for topic95 to avoid hardware
      // bug with intel NICs
      //
      if (deviceExtension->ControllerType == PcmciaTopic95) {
         word &= ~BCTRL_WRITE_POSTING_ENABLE;
      }
      //
      // Stop bridge control reset
      //
      SetPciConfigSpace(deviceExtension, CFGSPACE_BRIDGE_CTRL,  &word, 2);

      *pDelayTime = CBResetSetupDelay;
      break;
     
   case 3:  
      status = STATUS_SUCCESS;
      break;

   default:
      ASSERT(FALSE);
      status = STATUS_UNSUCCESSFUL;
   }

   return status;      
}



BOOLEAN
CBDetectCardInSocket(
   IN PSOCKET Socket
   )
/*++

Routine Description:

    This routine will determine if a card is in the socket

Arguments:

    Socket -- Socket information

Return Value:

    TRUE if card is present.

--*/
{
   ULONG state;
   BOOLEAN cardPresent=FALSE;

   //
   // Read the CARDBUS status register to see if the card is in there.
   //
   state = CBReadSocketRegister(Socket, CARDBUS_SOCKET_PRESENT_STATE_REG);
   if ((state & SKTSTATE_CCD_MASK) == 0) {
      cardPresent = TRUE;
   }
   return(cardPresent);
}


BOOLEAN
CBDetectCardChanged(
   IN PSOCKET Socket
   )
/*++

Routine Description:

    This routine will determine if socket's card insertion status has changed.

Arguments:

    Socket -- Socket info.

Return Value:

    TRUE if card insertion status has changed.

--*/
{
   BOOLEAN retVal = FALSE;
   ULONG   tmp;
   //
   // Read SOCKET Event register to see if CD's changed
   //
   tmp = CBReadSocketRegister(Socket, CARDBUS_SOCKET_EVENT_REG);
   if ((tmp & SKTEVENT_CCD_MASK) != 0) {
      //
      // Yes they did..
      // first clear the interrupt
      CBWriteSocketRegister(Socket, CARDBUS_SOCKET_EVENT_REG, SKTEVENT_CCD_MASK);
      retVal = TRUE;
   }
   return retVal;
}                   



BOOLEAN
CBDetectCardStatus(
   IN PSOCKET Socket
   )
/*++

Routine Description:

    This routine will determine if socket's card insertion status has changed.

Arguments:

    Socket -- Socket info.

Return Value:

    TRUE if card insertion status has changed.

--*/
{
   BOOLEAN retVal = FALSE;
   ULONG   tmp;

   if (Is16BitCardInSocket(Socket)) {
      // NOTE: UNIMPLEMENTED: may need to do something for 16-bit cards
      return FALSE;
   }
   
   //
   // Read SOCKET Event register to see if CD's changed
   //
   tmp = CBReadSocketRegister(Socket, CARDBUS_SOCKET_EVENT_REG);
   if ((tmp & SKTEVENT_CSTSCHG) != 0) {
      //
      // Yes they did..
      // first clear the interrupt
      CBWriteSocketRegister(Socket, CARDBUS_SOCKET_EVENT_REG, SKTEVENT_CSTSCHG);
      retVal = TRUE;
   }
   return retVal;
}                   



BOOLEAN
CBDetectReadyChanged(
   IN PSOCKET Socket
   )                    
{
   return(PcicSupportFns.PCBDetectReadyChanged(Socket));
}                   


BOOLEAN
CBProcessConfigureRequest(
   IN PSOCKET Socket,
   IN PCARD_REQUEST Request,
   IN PUCHAR Base
   )                     
{
   BOOLEAN bStatus = TRUE;
   USHORT word;

   //
   // Shouldn't this check for 16-bit cards?
   //

   switch (Request->RequestType) {

   case IRQ_REQUEST:

      if (CBEnableDeviceInterruptRouting(Socket)) {
         bStatus = PcicSupportFns.PCBProcessConfigureRequest(Socket, Request, Base);
      }         
      break;

   case DECONFIGURE_REQUEST:

      bStatus = PcicSupportFns.PCBProcessConfigureRequest(Socket, Request, Base);
      GetPciConfigSpace(Socket->DeviceExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
      word |= BCTRL_IRQROUTING_ENABLE;
      SetPciConfigSpace(Socket->DeviceExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
      break;

   default:
      bStatus = PcicSupportFns.PCBProcessConfigureRequest(Socket, Request, Base);
   }         
  
   return bStatus; 
}                   


BOOLEAN
CBEnableDisableCardDetectEvent(
   IN PSOCKET Socket,
   IN BOOLEAN Enable
   )                           
/*++

Routine Description:

    Enable card detect/card ready interrupt.

Arguments:

    Socket - socket information
    Enable - if  TRUE, CSC interrupt is enabled,
             if FALSE, it is disabled
Return Value:

    TRUE if successful
    FALSE if not successful

--*/
{

   switch (Enable) {

   case TRUE: {
         UCHAR byte;
         //
         // Only if TI 1130/1250?
         // Route through PCI interrupts
         byte = PcicReadSocket(Socket, PCIC_INTERRUPT);
         byte |= IGC_INTR_ENABLE;
         PcicWriteSocket(Socket, PCIC_INTERRUPT, byte);

         //
         // Clear the bits in Socket Event Register
         //
         CBWriteSocketRegister(Socket, CARDBUS_SOCKET_EVENT_REG, 0xF);

         //
         // Enable card-detect interrupt in Socket Mask Register
         //
         CBWriteSocketRegister(Socket, CARDBUS_SOCKET_MASK_REG, SKTMSK_CCD);
         break;
      }         
      
   case FALSE: {
         ULONG oldValue;
         //
         // Clear the bits in Socket Event Register
         //
         CBWriteSocketRegister(Socket, CARDBUS_SOCKET_EVENT_REG, 0xF);

         //
         // Disable card-detect interrupt in Socket Mask Register
         //
         oldValue = CBReadSocketRegister(Socket, CARDBUS_SOCKET_MASK_REG);
         oldValue &= ~SKTMSK_CCD;
         CBWriteSocketRegister(Socket, CARDBUS_SOCKET_MASK_REG, oldValue);
         break;
      }
   }

   return TRUE;
}                   



VOID
CBEnableDisableWakeupEvent(
   IN PSOCKET Socket,
   IN PPDO_EXTENSION PdoExtension,
   IN BOOLEAN Enable
   )
/*++

Routine Description:

    

Arguments:

    Socket - socket information
    Enable - if  TRUE, interrupt is enabled,
             if FALSE, it is disabled

Return Value:

    none

--*/
{
   ULONG dwValue;

   switch (Enable) {

   case TRUE: {

         //
         // Enable card-status interrupt in Socket Mask Register
         //
         dwValue = CBReadSocketRegister(Socket, CARDBUS_SOCKET_MASK_REG);
         dwValue |= SKTMSK_CSTSCHG;
         CBWriteSocketRegister(Socket, CARDBUS_SOCKET_MASK_REG, dwValue);

         if (PdoExtension && IsCardBusCard(PdoExtension)) {
            UCHAR capptr;
            ULONG powercaps;
            //
            // HACK ALERT - should be handled by PCI.SYS
            // Have a look to see if PME_ENABLE has been turned on by PCI. If not then we do it.
            //
         
            GetPciConfigSpace(PdoExtension, CBCFG_CAPPTR, &capptr, sizeof(capptr));
            if (capptr) {
               GetPciConfigSpace(PdoExtension, capptr, &powercaps, sizeof(powercaps));
               if ((powercaps & 0xff) == 1) {
                  GetPciConfigSpace(PdoExtension, capptr+4, &powercaps, sizeof(powercaps));
                  if (!(powercaps & PME_EN)) {
                     powercaps |= PME_EN;
                     DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x setting PME_EN!\n", PdoExtension->DeviceObject));
                     SetPciConfigSpace(PdoExtension, capptr+4, &powercaps, sizeof(powercaps));
                  }               
               }
            }
         }      
         
         break;
      }         
      
   case FALSE: {

         PFDO_EXTENSION fdoExtension = Socket->DeviceExtension;         
         UCHAR capptr;
         ULONG powercaps, newPowercaps;
         
         //
         // Check to see if PMESTAT is on... It shouldn't be. If it is, it probably means
         // that the BIOS did not notify us that the device did the wake, and PCI didn't
         // get a chance to clear the condition. This is really a BIOS bug.
         //
         if (PdoExtension && IsCardBusCard(PdoExtension)) {

            GetPciConfigSpace(PdoExtension, CBCFG_CAPPTR, &capptr, sizeof(capptr));
            if (capptr) {
               GetPciConfigSpace(PdoExtension, capptr, &powercaps, sizeof(powercaps));
               if ((powercaps & 0xff) == 1) {
                  GetPciConfigSpace(PdoExtension, capptr+4, &powercaps, sizeof(powercaps));
                  if (powercaps & (PME_STAT | PME_EN)) {

                     DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x PME bits still set! stat=%x en=%x\n",
                                 PdoExtension->DeviceObject, ((powercaps&PME_STAT)!=0), ((powercaps&PME_EN)!=0)));

                     powercaps |= PME_STAT;
                     powercaps &= ~PME_EN;
                     SetPciConfigSpace(PdoExtension, capptr+4, &powercaps, sizeof(powercaps));
                  }                     
               }
            }
         }

         GetPciConfigSpace(fdoExtension, CFGSPACE_CAPPTR, &capptr, sizeof(capptr));
         if (capptr) {
            GetPciConfigSpace(fdoExtension, capptr, &powercaps, sizeof(powercaps));
            if ((powercaps & 0xff) == 1) {
         
               //
               // Clear PMESTAT, if on
               //
               GetPciConfigSpace(fdoExtension, capptr+4, &powercaps, sizeof(powercaps));
               if (powercaps & PME_STAT) {

                  DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x PME_STAT still set!\n", fdoExtension->DeviceObject));

                  SetPciConfigSpace(fdoExtension, capptr+4, &powercaps, sizeof(powercaps));
               }
            }
         }
         
         //
         // Disable card-status interrupt in Socket Mask Register
         //
         dwValue = CBReadSocketRegister(Socket, CARDBUS_SOCKET_MASK_REG);
         dwValue &= ~SKTMSK_CSTSCHG;
         CBWriteSocketRegister(Socket, CARDBUS_SOCKET_MASK_REG, dwValue);
         
         //
         // Clear the event in Socket Event Register
         //
         CBWriteSocketRegister(Socket, CARDBUS_SOCKET_EVENT_REG, SKTEVENT_CSTSCHG);
         
         break;
      }
   }
}



ULONG
CBGetIrqMask(
   IN PFDO_EXTENSION DeviceExtension
   )                
{
   return(PcicSupportFns.PCBGetIrqMask(DeviceExtension));
}                   


ULONG
CBReadCardMemory(
   IN PPDO_EXTENSION PdoExtension,
   IN MEMORY_SPACE MemorySpace,
   IN ULONG   Offset,
   IN PUCHAR Buffer,
   IN ULONG  Length
   )              
{
   ULONG bytesCopied = 0;

   if (!IsCardBusCard(PdoExtension)) {
      return(PcicSupportFns.PCBReadCardMemory(PdoExtension,
                                              MemorySpace,
                                              Offset,
                                              Buffer,
                                              Length));
   }

   switch(MemorySpace){

   case PCCARD_PCI_CONFIGURATION_SPACE:
      bytesCopied = GetPciConfigSpace(PdoExtension, Offset, Buffer, Length);
      break;
   
   case PCCARD_CARDBUS_BAR0:
   case PCCARD_CARDBUS_BAR1:
   case PCCARD_CARDBUS_BAR2:
   case PCCARD_CARDBUS_BAR3:
   case PCCARD_CARDBUS_BAR4:
   case PCCARD_CARDBUS_BAR5:
      break;
      
   case PCCARD_CARDBUS_ROM:
      bytesCopied =  PdoExtension->PciBusInterface.GetBusData(
                                      PdoExtension->PciBusInterface.Context,          
                                      PCI_WHICHSPACE_ROM, Buffer, Offset, Length);
      break;                                      

   }
   return bytesCopied;
}                   


ULONG
CBWriteCardMemory(
   IN PPDO_EXTENSION PdoExtension,
   IN  MEMORY_SPACE MemorySpace,
   IN  ULONG  Offset,
   IN  PUCHAR Buffer,
   IN  ULONG  Length
   )                  
{
   if (IsCardBusCard(PdoExtension)) {
      return 0;
   }
   return(PcicSupportFns.PCBWriteCardMemory(PdoExtension,
                                            MemorySpace,
                                            Offset,
                                            Buffer,
                                            Length));
}                   


BOOLEAN
CBModifyMemoryWindow(
   IN PDEVICE_OBJECT Pdo,
   IN ULONGLONG HostBase,
   IN ULONGLONG CardBase OPTIONAL,
   IN BOOLEAN   Enable,
   IN ULONG     WindowSize  OPTIONAL,
   IN UCHAR     AccessSpeed OPTIONAL,
   IN UCHAR     BusWidth    OPTIONAL,
   IN BOOLEAN   IsAttributeMemory OPTIONAL
   )                      
{
   return(PcicSupportFns.PCBModifyMemoryWindow(Pdo,
                                               HostBase,
                                               CardBase,
                                               Enable,
                                               WindowSize,
                                               AccessSpeed,
                                               BusWidth,
                                               IsAttributeMemory));
}                   


BOOLEAN
CBSetVpp(
   IN PDEVICE_OBJECT Pdo,
   IN UCHAR          Vpp
   )                      
{
   return(PcicSupportFns.PCBSetVpp(Pdo, Vpp));
}                   


BOOLEAN
CBIsWriteProtected(
   IN PDEVICE_OBJECT Pdo
   )
{
   return(PcicSupportFns.PCBIsWriteProtected(Pdo));
}                   



NTSTATUS
CBGetPowerRequirements(
   IN PSOCKET Socket
   )
/*++

Routine Description:

    Look at the hardware to see what it says the card needs, and update the
    socket structure accordingly.

Arguments:

    Socket - the socket to examine

Return Value:

    n/a

--*/
{
   ULONG state;
   UCHAR voltage;
   
   //
   // Check what voltages are supported by this card
   //
   state = CBReadSocketRegister(Socket, CARDBUS_SOCKET_PRESENT_STATE_REG);
   
   if (!(state & (SKTSTATE_5VCARD | SKTSTATE_3VCARD))) {
      ULONG dwSktMask;
      //
      // neither 5v or 3v is set... try cvstest
      // Disable interrupt temporarily because TI 12xx could cause spurious
      // interrupt when playing with SktForce register.
      //
      dwSktMask = CBReadSocketRegister(Socket, CARDBUS_SOCKET_MASK_REG);
      CBWriteSocketRegister(Socket, CARDBUS_SOCKET_MASK_REG, 0);
      
      CBWriteSocketRegister(Socket, CARDBUS_SOCKET_FORCE_EVENT_REG, SKTFORCE_CVSTEST);
      state = CBReadSocketRegister(Socket, CARDBUS_SOCKET_PRESENT_STATE_REG);
      
      CBWriteSocketRegister(Socket, CARDBUS_SOCKET_MASK_REG, dwSktMask);
   }

   state &= (SKTSTATE_5VCARD | SKTSTATE_3VCARD);

   if (state == 0) {
      return STATUS_UNSUCCESSFUL;
   }

   if (state == (SKTSTATE_5VCARD | SKTSTATE_3VCARD)) {
      //
      // both are specified. Check for preference
      //
      voltage = IsDeviceFlagSet(Socket->DeviceExtension, PCMCIA_FDO_PREFER_3V) ? 33 : 50;
   
   } else {

      voltage = (state & SKTSTATE_5VCARD) ? 50 : 33;
      
   } 
   
   Socket->Vcc = Socket->Vpp1 = Socket->Vpp2 = voltage;
   
   return STATUS_SUCCESS;
}
   
   

NTSTATUS
CBSetPower(
   IN PSOCKET Socket,
   IN BOOLEAN Enable,
   OUT PULONG pDelayTime   
   )
/*++

Routine Description:

    Set power to the specified socket.

Arguments:

    Socket - the socket to set
    Enable - TRUE means to set power - FALSE is to turn it off.
    pDelayTime - specifies delay (msec) to occur after the current phase    

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED - increment phase, perform delay, recall
    other status values terminate sequence

--*/

{
   NTSTATUS status;
   ULONG             oldPower, state, newPower;
   ULONG             vcc, vpp;
   UCHAR             tmp;
   USHORT            word;

   switch(Socket->PowerPhase) {
   case 1:
   
      if (Enable) {

         //
         // Turn on the power
         //
         
         switch(Socket->Vcc) {
         
         case 50: vcc = SKTPOWER_VCC_050V; break;
         case 33: vcc = SKTPOWER_VCC_033V; break;
         default: vcc = SKTPOWER_VCC_OFF;
         
         }

         switch(Socket->Vpp1) {
         
         case 120: vpp = SKTPOWER_VPP_120V; break;
         case 50: vpp = SKTPOWER_VPP_050V; break;
         case 33: vpp = SKTPOWER_VPP_033V; break;
         default: vpp = SKTPOWER_VPP_OFF;
         
         }

      } else {

         //
         // Power off
         //
         vcc = SKTPOWER_VCC_OFF;
         vpp = SKTPOWER_VPP_OFF;
     
         //
         // Disable output before powering down to avoid spurious signals
         // from reaching the card
         //      
         if (Is16BitCardInSocket(Socket)) {
            tmp = PcicReadSocket(Socket, PCIC_PWR_RST);
            if (tmp & PC_OUTPUT_ENABLE) {
               tmp &= ~PC_OUTPUT_ENABLE;
               PcicWriteSocket(Socket, PCIC_PWR_RST, tmp);
            }                               
         }         
      }
     
      oldPower = CBReadSocketRegister(Socket, CARDBUS_SOCKET_CONTROL_REG);
     
      newPower = vcc | vpp;
      newPower|= oldPower & ~(SKTPOWER_VPP_CONTROL |SKTPOWER_VCC_CONTROL);

      if (newPower != oldPower) {
         CBWriteSocketRegister(Socket, CARDBUS_SOCKET_CONTROL_REG, newPower);
         //
         // When power is enabled always stall to give the PCCARD
         // a chance to react.
         //
         *pDelayTime = PcicStallPower;         
         Socket->PowerData = newPower;
         status = STATUS_MORE_PROCESSING_REQUIRED;
      } else {
         //
         // Indicate that nothing was done
         //
         status = STATUS_INVALID_DEVICE_STATE;
      }
      break;

   case 2:      
   case 3:      
   case 4:      

      newPower = Socket->PowerData;         
      //
      // Try to apply the required power setting a few times.
      // We bail if it doesn't succeed after the given number of tries
      //
      state = CBReadSocketRegister(Socket, CARDBUS_SOCKET_PRESENT_STATE_REG);
      
      if (state & SKTSTATE_BADVCCREQ) {
         DebugPrint((PCMCIA_DEBUG_INFO, "skt %08 CBSetPower: Bad vcc request\n", Socket));
         //
         // Clear the status bits & try again
         //
         CBWriteSocketRegister(Socket, CARDBUS_SOCKET_FORCE_EVENT_REG, 0);
         CBWriteSocketRegister(Socket, CARDBUS_SOCKET_CONTROL_REG, newPower);
         *pDelayTime = PcicStallPower;         
         status = STATUS_MORE_PROCESSING_REQUIRED;
     
      } else {
         status = STATUS_SUCCESS;
         if (Is16BitCardInSocket(Socket)) {
            tmp = PcicReadSocket(Socket, PCIC_PWR_RST);
            if (newPower & SKTPOWER_VCC_CONTROL) {
               //
               // Vcc is on..
               //
               tmp |= PC_OUTPUT_ENABLE | PC_AUTOPWR_ENABLE;
               PcicWriteSocket(Socket, PCIC_PWR_RST, tmp);
               *pDelayTime = PcicStallPower;         
            } else {
               //
               // power off..
               //
               tmp &= ~(PC_OUTPUT_ENABLE | PC_AUTOPWR_ENABLE);
               PcicWriteSocket(Socket, PCIC_PWR_RST, tmp);
     
            }
         }
      }
      break;
      
   default:
      DebugPrint((PCMCIA_DEBUG_FAIL, "skt %08 CBSetPower: Final retry failed - bad vcc\n", Socket));
      ASSERT(FALSE);
      status = STATUS_UNSUCCESSFUL;
   }
   
   return status;      
}


BOOLEAN
CBSetWindowPage(
   IN PSOCKET Socket,
   USHORT Index,
   UCHAR Page
   )
{
   ASSERT(Index <= 4);

   PcicWriteSocket(Socket, (UCHAR) (PCIC_PAGE_REG + Index), Page);
   return TRUE;
}


ULONG
CBReadSocketRegister(
   IN PSOCKET Socket,
   IN UCHAR Register
   )
/*++

Routine Description

   Returns the contents of the specified Cardbus socket register for the
   given socket

Arguments

   Socket      - Pointer to the socket
   Register       - Cardbus socket register

Return Value

   Contents of the register

--*/
{
   ULONG data;
   
   ASSERT (CardBus(Socket));
   ASSERT (Socket->DeviceExtension->CardBusSocketRegisterBase != NULL);
   ASSERT ((Register&3) == 0);

   //
   // Sanity check in case controller wasn't started
   // or if the register is not dword aligned
   //
   if ((Socket->DeviceExtension->CardBusSocketRegisterBase) && ((Register&3) == 0)) {
      data = READ_REGISTER_ULONG((PULONG) (Socket->DeviceExtension->CardBusSocketRegisterBase+Register));
   } else {
      data = 0xFFFFFFFF;
   }
   return data;
}


VOID
CBWriteSocketRegister(
   IN PSOCKET Socket,
   IN UCHAR Register,
   IN ULONG Data
   )
/*++

Routine Description

   Writes the supplied value to the Cardbus socket register for the
   given socket

Arguments

   Socket      - Pointer to the socket
   Register       - Cardbus socket register
   Data           - Value to be written to the register

Return Value

--*/
{
   ASSERT (CardBus(Socket));
   ASSERT (Socket->DeviceExtension->CardBusSocketRegisterBase != NULL);
   ASSERT ((Register&3) == 0);
   
   //
   // Sanity check in case controller wasn't started
   // or if the register is not dword aligned
   //
   if ((Socket->DeviceExtension->CardBusSocketRegisterBase) && ((Register&3) == 0)) {
      WRITE_REGISTER_ULONG((PULONG) (Socket->DeviceExtension->CardBusSocketRegisterBase+Register), Data);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\pcmcibus\cl.c ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    cl.c

Abstract:

    This module contains the code that contains
    Cirrus Logic controller specific initialization and
    other dispatches

Author:

    Ravisankar Pudipeddi (ravisp) 1-Nov-97


Environment:

    Kernel mode

Revision History :

    Neil Sandlin (neilsa) 3-Mar-99
      new setpower routine interface

--*/

#include "pch.h"


VOID
CLInitialize(IN PFDO_EXTENSION FdoExtension)
/*++

Routine Description:

    Initialize Cirrus Logic cardbus controllers

Arguments:

    FdoExtension - Pointer to the device extension for the controller FDO

Return Value:

    None
--*/
{
    UCHAR                byte, revisionID;
    USHORT               word;


   byte = PcicReadSocket(FdoExtension->SocketList,
                         PCIC_CL_MISC_CTRL3);

   if ((FdoExtension->ControllerType == PcmciaCLPD6832) &&
      ((byte & CL_MC3_INTMODE_MASK) == CL_MC3_INTMODE_EXTHW)) {

      FdoExtension->LegacyIrqMask = 0xd8b8;    //3,4,5,7,11,12,14,15

   }        

    GetPciConfigSpace(FdoExtension, CFGSPACE_REV_ID, &revisionID, 1);
    if (FdoExtension->ControllerType == PcmciaCLPD6832) {
        //disable CSC IRQ routing (use PCI interrupt for CSC)
        GetPciConfigSpace(FdoExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
        word &= ~BCTRL_CL_CSCIRQROUTING_ENABLE;
        SetPciConfigSpace(FdoExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
    }
    else {
        //disable CSC IRQ routing (use PCI interrupt for CSC)
        GetPciConfigSpace(FdoExtension, CFGSPACE_CL_CFGMISC1, &byte, 1);
        byte &= ~CL_CFGMISC1_ISACSC;
        SetPciConfigSpace(FdoExtension, CFGSPACE_CL_CFGMISC1, &byte, 1);
    }

    //enable speaker
    byte = PcicReadSocket(FdoExtension->SocketList, PCIC_CL_MISC_CTRL1);
    byte |= CL_MC1_SPKR_ENABLE;
    PcicWriteSocket(FdoExtension->SocketList, PCIC_CL_MISC_CTRL1, byte);

    byte = PcicReadSocket(FdoExtension->SocketList, PCIC_CL_DEV_IMP_C);
    if (byte & (CL_IMPC_ZVP_A | CL_IMPC_ZVP_B)) {
        //enable multimedia support (i.e. ZV)
        byte = PcicReadSocket(FdoExtension->SocketList,PCIC_CL_MISC_CTRL3);
        byte |= CL_MC3_MM_ARM;
        PcicWriteSocket(FdoExtension->SocketList, PCIC_CL_MISC_CTRL3,byte);
    }
}

NTSTATUS
CLSetPower(
   IN PSOCKET SocketPtr,
   IN BOOLEAN Enable,
   OUT PULONG pDelayTime   
   )
/*++

Routine Description:

    Set power to the specified socket.

Arguments:

    SocketPtr - the socket to set
    Enable - TRUE means to set power - FALSE is to turn it off.
    pDelayTime - specifies delay (msec) to occur after the current phase    

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED - increment phase, perform delay, recall
    other status values terminate sequence

--*/

{
   NTSTATUS status;
   UCHAR             oldPower, newPower, oldMiscCtrl, newMiscCtrl;

   if (IsCardBusCardInSocket(SocketPtr)) {
      //
      // Hand over to generic power setting routine
      //
      return(CBSetPower(SocketPtr, Enable, pDelayTime));

   }

   switch(SocketPtr->PowerPhase) {
   case 1:
      //
      // R2 card - special handling
      //
      oldPower = PcicReadSocket(SocketPtr, PCIC_PWR_RST);
      oldMiscCtrl = PcicReadSocket(SocketPtr, PCIC_CL_MISC_CTRL1);
     
      //
      // Set new vcc
      //
      newPower = (Enable ? PC_CARDPWR_ENABLE: 0);
      //
      // Since we always set 5V for R2 cards, we let MISC control be 0
      // other wise it should be CL_MC1_VCC_3V if the vcc was 3.3V
      //
      newMiscCtrl = 0;
     
      //
      // Set vpp
      //
      if (Enable) {
          //
          // We - as always - set vpp to vcc..
          //
          newPower |= PC_VPP_SETTO_VCC;
      }
      //
      // Don't nuke the non-power related bits in the register..
      //
      newPower |= (oldPower & PC_PWRON_BITS);
      newMiscCtrl |= (oldMiscCtrl & ~CL_MC1_VCC_33V);
      //
      // If Vcc is turned off, reset OUTPUT_ENABLE & AUTOPWR_ENABLE
      //
      if (!(newPower & PC_CARDPWR_ENABLE)) {
         newPower &= ~PC_PWRON_BITS;
      }
      //
      // Only set power if nothing's changed..
      //
      status = STATUS_SUCCESS;
      if ((newPower != oldPower) || (newMiscCtrl != oldMiscCtrl)) {
         PcicWriteSocket(SocketPtr, PCIC_PWR_RST, newPower);
         PcicWriteSocket(SocketPtr, PCIC_CL_MISC_CTRL1, newMiscCtrl);
         //
         // Allow ramp up.. (actually we don't need to this if
         // Enable was FALSE).  Keep it for paranoia's sake
         //         
         *pDelayTime = PcicStallPower;
         SocketPtr->PowerData = (ULONG) newPower;
         status = STATUS_MORE_PROCESSING_REQUIRED;
      }
      break;

   case 2:

      newPower = (UCHAR) SocketPtr->PowerData;         

      if ((newPower & PC_CARDPWR_ENABLE) &&
          ((newPower & PC_PWRON_BITS) != PC_PWRON_BITS)) {
         //
         // More paranoia?
         //
         newPower |= PC_PWRON_BITS;
         PcicWriteSocket(SocketPtr, PCIC_PWR_RST, newPower);
      }
      status = STATUS_SUCCESS;
      break;

   default:
      ASSERT(FALSE);
      status = STATUS_UNSUCCESSFUL;
   }
   return status;      
}


BOOLEAN
CLSetZV(
   IN PSOCKET Socket,
   IN BOOLEAN Enable
   )
{
   UCHAR bData;
   
   if (Enable) {
   
      bData = PcicReadSocket(Socket, PCIC_CL_MISC_CTRL1);
      bData |= CL_MC1_MM_ENABLE;
      bData &= ~CL_MC1_SPKR_ENABLE;
      PcicWriteSocket(Socket, PCIC_CL_MISC_CTRL1, bData);
      
   } else {
   
      bData = PcicReadSocket(Socket, PCIC_CL_MISC_CTRL1);
      bData &= ~CL_MC1_MM_ENABLE;
      bData |= CL_MC1_SPKR_ENABLE;
      PcicWriteSocket(Socket, PCIC_CL_MISC_CTRL1, bData);
      
   }
   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\pcmcibus\ctlr.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    ctlr.c

Abstract:

    This module contains code to support starting and stopping the
    pcmcia controller.

Author:

    Neil Sandlin (neilsa) 1-Jun-1999

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"

//
// Internal References
//

NTSTATUS
PcmciaInitializeController(
   IN PDEVICE_OBJECT Fdo
   );


NTSTATUS
PcmciaGetPciControllerType(
   IN PDEVICE_OBJECT Pdo,
   IN PDEVICE_OBJECT Fdo
   );
   
NTSTATUS
PcmciaCreateFdo(
   IN PDRIVER_OBJECT DriverObject,
   OUT PDEVICE_OBJECT *NewDeviceObject
   );
   
BOOLEAN
PcmciaInterrupt(
   IN PKINTERRUPT InterruptObject,
   IN PVOID       Context
   );

VOID
PcmciaInterruptDpc(
   IN PKDPC          Dpc,
   IN PDEVICE_OBJECT DeviceObject,
   IN PVOID          SystemContext1,
   IN PVOID          SystemContext2
   );

VOID
PcmciaTimerDpc(
   IN PKDPC          Dpc,
   IN PDEVICE_OBJECT DeviceObject,
   IN PVOID          SystemContext1,
   IN PVOID          SystemContext2
   );

VOID
PcmciaDpc(
   IN PKDPC Dpc,
   IN PDEVICE_OBJECT DeviceObject,
   IN PVOID SystemContext1,
   IN PVOID SystemContext2
   );

   
PUNICODE_STRING  DriverRegistryPath;

#ifdef ALLOC_PRAGMA
   #pragma alloc_text(PAGE, PcmciaAddDevice)
   #pragma alloc_text(PAGE, PcmciaCreateFdo)
   #pragma alloc_text(PAGE, PcmciaStartPcmciaController)
   #pragma alloc_text(PAGE, PcmciaSetControllerType)
   #pragma alloc_text(PAGE, PcmciaGetPciControllerType)
#endif




NTSTATUS
PcmciaAddDevice(
   IN PDRIVER_OBJECT DriverObject,
   IN PDEVICE_OBJECT Pdo
   )

/*++

Routine Description:

    This routine creates functional device objects for each Pcmcia controller in the
    system and attaches them to the physical device objects for the controllers


Arguments:

    DriverObject - a pointer to the object for this driver
    PhysicalDeviceObject - a pointer to the physical object we need to attach to

Return Value:

    Status from device creation and initialization

--*/

{
   PDEVICE_OBJECT fdo = NULL;
   PDEVICE_OBJECT lowerDevice = NULL;

   PFDO_EXTENSION deviceExtension;
   ULONG          resultLength;

   NTSTATUS status;

   PAGED_CODE();

   DebugPrint((PCMCIA_DEBUG_PNP, "AddDevice Entered with pdo %x\n", Pdo));

   if (Pdo == NULL) {

      //
      // Have we been asked to do detection on our own?
      // if so just return no more devices
      //

      DebugPrint((PCMCIA_DEBUG_FAIL, "PcmciaAddDevice - asked to do detection\n"));
      return STATUS_NO_MORE_ENTRIES;
   }

   //
   // create and initialize the new functional device object
   //

   status = PcmciaCreateFdo(DriverObject, &fdo);

   if (!NT_SUCCESS(status)) {

      DebugPrint((PCMCIA_DEBUG_FAIL, "PcmciaAddDevice - error creating Fdo [%#08lx]\n",
                  status));
      return status;
   }

   deviceExtension = fdo->DeviceExtension;
   KeInitializeTimer(&deviceExtension->EventTimer);
   KeInitializeDpc(&deviceExtension->EventDpc, PcmciaDpc, fdo);   
   
   KeInitializeTimer(&deviceExtension->PowerTimer);
   KeInitializeDpc(&deviceExtension->PowerDpc, PcmciaFdoPowerWorkerDpc, deviceExtension);   
   
   InitializeListHead(&deviceExtension->PdoPowerRetryList);
   KeInitializeDpc(&deviceExtension->PdoPowerRetryDpc, PcmciaFdoRetryPdoPowerRequest, deviceExtension);   

   //
   // Layer our FDO on top of the PDO
   //
   //

   lowerDevice = IoAttachDeviceToDeviceStack(fdo,Pdo);

   //
   // No status. Do the best we can.
   //
   if (lowerDevice == NULL) {
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto cleanupExit;
   };

   deviceExtension->LowerDevice = lowerDevice;
   deviceExtension->Pdo = Pdo;

   status = IoGetDeviceProperty(Pdo,
                                DevicePropertyLegacyBusType,
                                sizeof(INTERFACE_TYPE),
                                (PVOID)&deviceExtension->InterfaceType,
                                &resultLength);

   if (!NT_SUCCESS(status)) {
      //
      // Probably a legacy pcic device
      //
      deviceExtension->InterfaceType = InterfaceTypeUndefined;
   }

   //
   // Get our controller type
   //

   deviceExtension->ControllerType = PcmciaInvalidControllerType;

   
   if (deviceExtension->InterfaceType == PCIBus) {
   
      status = PcmciaGetPciControllerType(Pdo, fdo);
      if (!NT_SUCCESS(status)) {
         goto cleanupExit;
      }
      
   } else {
      PCMCIA_CONTROLLER_TYPE controllerType;
      
      status = PcmciaGetLegacyDetectedControllerType(deviceExtension->Pdo,
                                                     &controllerType);
                                                     
      if (NT_SUCCESS(status)) {
         PcmciaSetControllerType(deviceExtension, controllerType);
      }
   }     
   
   //
   // Do some cardbus specific initialization
   //
   if (CardBusExtension(deviceExtension)) {
      BOOLEAN OnDebugPath;
      ACPI_INTERFACE_STANDARD AcpiInterface;
      USHORT word;
      //
      // Get the pci/cardbus private interface
      //
      status = PcmciaGetInterface(Pdo,
                                  &GUID_PCI_CARDBUS_INTERFACE_PRIVATE,
                                  sizeof(PCI_CARDBUS_INTERFACE_PRIVATE),
                                  (PINTERFACE) &deviceExtension->PciCardBusInterface
                                  );
                                  
      if (!NT_SUCCESS(status)) {
         goto cleanupExit;
      }                                  
      
      status = deviceExtension->PciCardBusInterface.GetLocation(Pdo,
                                                                &deviceExtension->PciBusNumber,
                                                                &deviceExtension->PciDeviceNumber,
                                                                &deviceExtension->PciFunctionNumber,
                                                                &OnDebugPath);
                                                                
      if (!NT_SUCCESS(status)) {
         goto cleanupExit;
      }                                  

      if (OnDebugPath) {
         SetDeviceFlag(deviceExtension, PCMCIA_FDO_ON_DEBUG_PATH);
      }         
      
      //
      // Get the pci interface for reading/writing to config header space
      //
      status = PcmciaGetInterface(Pdo,
                                  &GUID_BUS_INTERFACE_STANDARD,
                                  sizeof(BUS_INTERFACE_STANDARD),
                                  (PINTERFACE) &deviceExtension->PciBusInterface);
      if (!NT_SUCCESS(status)) {
         goto cleanupExit;
      }                                  

      //
      // Make sure IRQ routing is to isa. This has come up when installing from a pcmcia CD-rom.
      // What happens is that, after we start booting GUI mode, the controller is at first
      // in legacy PCIC mode (set by the bios to accomplish boot). At some point, the _INIT
      // method is run, and we switch to cardbus mode. So, under the following conditions:
      // 1) irq routing bit is still off
      // 2) cd-rom is asserting its interrupt
      // 3) host controller routes cd-rom interrupt to PCI
      // then we hang.
      //
      GetPciConfigSpace(deviceExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
      word |= BCTRL_IRQROUTING_ENABLE;
      SetPciConfigSpace(deviceExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
      
      if (!(PcmciaGlobalFlags & PCMCIA_DISABLE_ACPI_NAMESPACE_CHECK)) {
         status = PcmciaGetInterface(fdo,
                                     &GUID_ACPI_INTERFACE_STANDARD,
                                     sizeof(ACPI_INTERFACE_STANDARD),
                                     (PINTERFACE) &AcpiInterface
                                     );
                                     
         if (NT_SUCCESS(status)) {
            SetFdoFlag(deviceExtension, PCMCIA_FDO_IN_ACPI_NAMESPACE);
         }                                  
      }
   }

   //
   // Get settings from registry (potentially also compatible ControllerType)
   //
   
   PcmciaGetControllerRegistrySettings(deviceExtension);
   
   if ((deviceExtension->ControllerType == PcmciaInvalidControllerType)) {
      //
      // not really sure what this is... maybe it's a PNP0E00 on a boot. Just do
      // the least common denominator
      //
      PcmciaSetControllerType(deviceExtension, PcmciaIntelCompatible);
   }

   
   //
   // Link this fdo to the list of fdo's managed by the driver
   //
   
   DebugPrint((PCMCIA_DEBUG_PNP, "FDO %08X now linked to fdolist by AddDevice\n", fdo));
   deviceExtension->NextFdo = FdoList;
   FdoList = fdo;
   
   fdo->Flags &= ~DO_DEVICE_INITIALIZING;

   return STATUS_SUCCESS;

cleanupExit:
   MarkDeviceDeleted(deviceExtension);
   //
   // Cannot support a controller without knowing its type etc.
   //
   if (deviceExtension->LinkName.Buffer) {
      IoDeleteSymbolicLink(&deviceExtension->LinkName);
      ExFreePool(deviceExtension->LinkName.Buffer);
   }      

   if (deviceExtension->LowerDevice) {
      IoDetachDevice(deviceExtension->LowerDevice);
   }      

   IoDeleteDevice(fdo);
   return status;
}



NTSTATUS
PcmciaCreateFdo(
   IN PDRIVER_OBJECT DriverObject,
   OUT PDEVICE_OBJECT *NewDeviceObject
   )

/*++

Routine Description:

    This routine will create and initialize a functional device object to
    be attached to a Pcmcia controller PDO.

Arguments:

    DriverObject - a pointer to the driver object this is created under
    DeviceObject - a location to store the pointer to the new device object

Return Value:

    STATUS_SUCCESS if everything was successful
    reason for failure otherwise

--*/

{
   UCHAR deviceNameBuffer[64];
   LONG deviceNumber = -1;
   ANSI_STRING ansiDeviceName;
   UNICODE_STRING unicodeDeviceName;
   UNICODE_STRING unicodeLinkName;

   PDEVICE_OBJECT deviceObject = NULL;
   PFDO_EXTENSION deviceExtension = NULL;
   BOOLEAN LinkCreated = FALSE;

   ULONG count;

   NTSTATUS status=STATUS_SUCCESS;

   PAGED_CODE();

   //
   // Zero out allocated memory pointers so we know if they must be freed
   //

   RtlZeroMemory(&ansiDeviceName, sizeof(ANSI_STRING));
   RtlZeroMemory(&unicodeDeviceName, sizeof(UNICODE_STRING));
   RtlZeroMemory(&unicodeLinkName, sizeof(UNICODE_STRING));


   //
   // Run in a loop incrementing the device number count until we either
   // get an error or find a name that's not taken
   //

   try {
      do {
         //
         // free buffer from previous loop
         //
         if (unicodeDeviceName.Buffer != NULL) {
            RtlFreeUnicodeString(&unicodeDeviceName);
            unicodeDeviceName.Buffer = NULL;
         }
      
         //
         // create the device name
         //
         sprintf(deviceNameBuffer, "%s%d", PCMCIA_DEVICE_NAME, ++deviceNumber);

         RtlInitAnsiString(&ansiDeviceName, deviceNameBuffer);

         status = RtlAnsiStringToUnicodeString(
                                              &unicodeDeviceName,
                                              &ansiDeviceName,
                                              TRUE);

         if (!NT_SUCCESS(status)) {

            DebugPrint((PCMCIA_DEBUG_FAIL, "PcmciaCreateFdo: Error creating unicode "
                        "string [%#08lx]\n",
                        status));
            leave;
         }

         //
         // create the device object
         //

         status = IoCreateDevice(DriverObject,
                                 sizeof(FDO_EXTENSION),
                                 &unicodeDeviceName,
                                 FILE_DEVICE_CONTROLLER,
                                 0L,
                                 FALSE,
                                 &deviceObject);

      } while ((status == STATUS_OBJECT_NAME_EXISTS) ||
               (status == STATUS_OBJECT_NAME_COLLISION));

      if (!NT_SUCCESS(status)) {

         DebugPrint((PCMCIA_DEBUG_FAIL, "PcmciaCreateFdo: Error creating device object "
                     "[%#08lx]\n",
                     status));
         leave;
      }

      // Setup symbolic link for VDDs
      //
      //
      // create the link name (reuse the device name buffers for this)
      //

      sprintf(deviceNameBuffer,"%s%d", PCMCIA_LINK_NAME, deviceNumber);

      RtlInitAnsiString(&ansiDeviceName, deviceNameBuffer);

      status = RtlAnsiStringToUnicodeString(
                                           &unicodeLinkName,
                                           &ansiDeviceName,
                                           TRUE);

      if (!NT_SUCCESS(status)) {

         DebugPrint((PCMCIA_DEBUG_FAIL, "PcmciaCreateFdo: Error creating unicode "
                     "string [%#08lx]\n",
                     status));
         leave;
      }

      status = IoCreateSymbolicLink(&unicodeLinkName, &unicodeDeviceName);

      if (!NT_SUCCESS(status)) {
         DebugPrint((PCMCIA_DEBUG_FAIL, "PcmciaCreateFdo: Symbolic Link was not created\n"));
         leave;
      }

      LinkCreated = TRUE;

      //
      // Set up the device extension.
      //
      deviceExtension = deviceObject->DeviceExtension;
      deviceExtension->DeviceObject = deviceObject;
      deviceExtension->LinkName     = unicodeLinkName;
      deviceExtension->RegistryPath = DriverRegistryPath;
      deviceExtension->DriverObject = DriverObject;
      deviceExtension->DeviceObject = deviceObject;
      deviceExtension->PdoList      = NULL;
      deviceExtension->LivePdoCount = 0;
      deviceExtension->Flags        = PCMCIA_FDO_OFFLINE;
      deviceExtension->WaitWakeState= WAKESTATE_DISARMED;

      //
      // Lock for synching device access
      //
      PCMCIA_INITIALIZE_DEVICE_LOCK(deviceExtension);

      *NewDeviceObject = deviceObject;

   } finally {


      DebugPrint((PCMCIA_DEBUG_INFO, "PcmciaCreateFdo: Cleanup\n"));

      //
      //
      // deallocate temporary objects
      //

      if (unicodeDeviceName.Buffer != NULL) {
         RtlFreeUnicodeString(&unicodeDeviceName);
      }

      //
      // destroy objects if there was an error
      //
      if (!NT_SUCCESS(status)) {
         if (LinkCreated) {
            IoDeleteSymbolicLink(&unicodeLinkName);
         }

         if (unicodeLinkName.Buffer != NULL) {
            RtlFreeUnicodeString(&unicodeLinkName);
         }

         if (deviceObject != NULL) {
            MarkDeviceDeleted(deviceExtension);
            IoDeleteDevice(deviceObject);
         }
      }
   }
   return status;
}



NTSTATUS
PcmciaStartPcmciaController(
   IN PDEVICE_OBJECT Fdo
   )
/*++

Routine Description:

Arguments:

Return value:

--*/
{
   PFDO_EXTENSION    deviceExtension = Fdo->DeviceExtension;
   PSOCKET socket;
   BOOLEAN           sharedInterrupt;
   KINTERRUPT_MODE   interruptMode;
   NTSTATUS          status;
   INTERFACE_TYPE    interfaceType;

   //
   // Now the controller registers should be accessible
   //
   deviceExtension->Flags &= ~PCMCIA_FDO_OFFLINE;
   
   //   
   // Set up the socket list
   //

   if (!deviceExtension->SocketList) {
      if (CardBusExtension(deviceExtension)) {
     
         status = CBBuildSocketList(deviceExtension);
         
      } else {
     
         switch (deviceExtension->ControllerType) {
         case PcmciaIntelCompatible:
         case PcmciaElcController:
         case PcmciaCLPD6729:
         case PcmciaPciPcmciaBridge:
         case PcmciaNEC98:
         case PcmciaNEC98102: {
               status = PcicBuildSocketList(deviceExtension);
               break;
            }
     
         case PcmciaDatabook: {
               status = TcicBuildSocketList(deviceExtension);
               break;
            }
         default:
            status = STATUS_UNSUCCESSFUL;
         }
      }      
      
      if (!NT_SUCCESS(status)) {
         return status;
      }
      
   }      
   
   //
   // Get the IRQ mask for the controller. This is based on several
   // values in the registry.
   //
   PcmciaGetRegistryFdoIrqMask(deviceExtension);


   deviceExtension->SystemPowerState = PowerSystemWorking;
   deviceExtension->DevicePowerState = PowerDeviceD0;

   //
   // Initialize our DpcForIsr
   //
   IoInitializeDpcRequest(Fdo, PcmciaInterruptDpc);
   
   //
   // Initialize socket objects
   //
   for (socket = deviceExtension->SocketList; socket; socket = socket->NextSocket) {
      
      socket->PdoList = NULL;
      //
      // Initialize the ready enable event.
      //
      KeInitializeEvent(&socket->PCCardReadyEvent,
                        SynchronizationEvent,
                        FALSE
                       );
      //
      // Initialize power objects
      //
      KeInitializeTimer(&socket->PowerTimer);
      KeInitializeDpc(&socket->PowerDpc, PcmciaSocketPowerWorker, socket);
     
      socket->FdoIrq = deviceExtension->Configuration.Interrupt.u.Interrupt.Vector;
   }

   //
   // Assume we are going to poll
   //
   deviceExtension->Flags |= PCMCIA_USE_POLLED_CSC;
   deviceExtension->PcmciaInterruptObject = NULL;
   
   if ((deviceExtension->Configuration.Interrupt.u.Interrupt.Level != 0) &&
       CardBusExtension(deviceExtension) &&
       !(PcmciaGlobalFlags & PCMCIA_GLOBAL_FORCE_POLL_MODE)) {

      //
      // Hook up the controller interrupt for detecting pc-card plug ins/outs
      //
      interruptMode=((deviceExtension->Configuration.Interrupt.Flags & CM_RESOURCE_INTERRUPT_LATCHED) == CM_RESOURCE_INTERRUPT_LATCHED) ? Latched:LevelSensitive;

      sharedInterrupt=(deviceExtension->Configuration.Interrupt.ShareDisposition == CmResourceShareShared)?
                      TRUE:FALSE;


      status = IoConnectInterrupt(&(deviceExtension->PcmciaInterruptObject),
                                  (PKSERVICE_ROUTINE) PcmciaInterrupt,
                                  (PVOID) Fdo,
                                  NULL,
                                  deviceExtension->Configuration.TranslatedInterrupt.u.Interrupt.Vector,
                                  (KIRQL) deviceExtension->Configuration.TranslatedInterrupt.u.Interrupt.Level,
                                  (KIRQL) deviceExtension->Configuration.TranslatedInterrupt.u.Interrupt.Level,
                                  interruptMode,
                                  sharedInterrupt,
                                  (KAFFINITY) deviceExtension->Configuration.TranslatedInterrupt.u.Interrupt.Affinity,
                                  FALSE);
      if (!NT_SUCCESS(status)) {

         DebugPrint((PCMCIA_DEBUG_FAIL, "Unable to connect interrupt\n"));
      } else {
         //
         // We connected. Turn off poll mode
         //
         deviceExtension->Flags &= ~PCMCIA_USE_POLLED_CSC;
      }
   }


   status = PcmciaInitializeController(Fdo);

   if (!NT_SUCCESS(status)) {
      DebugPrint((PCMCIA_DEBUG_FAIL, "PcmciaStartAdapter: PcmciaInitializeFdo failed\n"));
      return status;
   }


   if (deviceExtension->Flags & PCMCIA_USE_POLLED_CSC) {
      LARGE_INTEGER dueTime;

      KeInitializeDpc(&deviceExtension->TimerDpc, PcmciaTimerDpc, deviceExtension->DeviceObject);

      KeInitializeTimer(&deviceExtension->PollTimer);

      //
      // Set first fire to twice the peroidic interval - just
      //
      dueTime.QuadPart = -PCMCIA_CSC_POLL_INTERVAL * 1000 * 10 * 2;

      KeSetTimerEx(&(deviceExtension->PollTimer),
                   dueTime,
                   PCMCIA_CSC_POLL_INTERVAL,
                   &deviceExtension->TimerDpc
                  );
   }
   return STATUS_SUCCESS;
}



NTSTATUS
PcmciaInitializeController(
   IN PDEVICE_OBJECT Fdo
   )
/*++

Routine Description:

     Initializes the pcmcia controller

Arguments:

    Fdo - pointer to the device object for the controller

Return value:

    STATUS_SUCCESS - if initialization is successful

--*/
{
   PFDO_EXTENSION fdoExtension=Fdo->DeviceExtension;
   PSOCKET socket;
   NTSTATUS    status = STATUS_SUCCESS;

   //
   // do vendor-specific init of controller
   //
   
   if (DeviceDispatchTable[fdoExtension->DeviceDispatchIndex].InitController) {
      (*DeviceDispatchTable[fdoExtension->DeviceDispatchIndex].InitController)(fdoExtension);
   }

   //
   // If LegacyIrqMask is not filled in, put a generic mask there in case we need it
   //
   if (fdoExtension->LegacyIrqMask == 0) {
      fdoExtension->LegacyIrqMask = (USHORT)(*(fdoExtension->SocketList->SocketFnPtr->PCBGetIrqMask))(fdoExtension);
   }      
   
   fdoExtension->LegacyIrqMask &= ~globalFilterIrqMask;

   for (socket = fdoExtension->SocketList; socket; socket = socket->NextSocket) {
   
      if (!(*(socket->SocketFnPtr->PCBInitializePcmciaSocket))(socket)) {
         status = STATUS_UNSUCCESSFUL;
         break;
      }

      PcmciaGetSocketStatus(socket);
      
      PcmciaSetZV(fdoExtension, socket, FALSE);
      
      ResetSocketFlag(socket, SOCKET_ENABLED_FOR_CARD_DETECT);
      
      if (!(fdoExtension->Flags & PCMCIA_USE_POLLED_CSC) && (socket->FdoIrq != 0)) {
      
         if ((*(socket->SocketFnPtr->PCBEnableDisableCardDetectEvent))(socket, TRUE)) {
            //
            // card detect event was successfully enabled
            //
            SetSocketFlag(socket, SOCKET_ENABLED_FOR_CARD_DETECT);
         
         } else {
      
            DebugPrint((PCMCIA_DEBUG_FAIL, "fdo %x failed to enable card detect event on IRQ %x\n", 
                                           Fdo, fdoExtension->Configuration.Interrupt.u.Interrupt.Vector));
         }                     
      }
   }

   return status;
}




VOID
PcmciaTimerDpc(
   IN PKDPC          Dpc,
   IN PDEVICE_OBJECT DeviceObject,
   IN PVOID          SystemContext1,
   IN PVOID          SystemContext2
   )
/*++

Routine Description

    This routine polls for card insertions or deletions
    for the given PCMCIA controller. If a card status change
    condition is detected, it invokes the appropriate DPC
    to process the card arrival/departure.

Arguments

    Dpc          - Pointer to the Dpc object
    DeviceObject - Pointer to the FDO of the PCMCIA controller that should be polled

Return Value

    None

--*/

{

   PFDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
   PSOCKET        socket;
   BOOLEAN        isCardInSocket, wasCardInSocket, callDpc = FALSE;

   if (fdoExtension->Flags & PCMCIA_FDO_OFFLINE) {
      return;
   }

   if (!ValidateController(fdoExtension)) {
      //
      // Something is wrong with the controller, hopefully it is just
      // temporary. For now, do nothing
      //
      return;
   }

   for (socket = fdoExtension->SocketList; socket; socket = socket->NextSocket) {
   
      isCardInSocket = (*(socket->SocketFnPtr->PCBDetectCardInSocket))(socket);
      wasCardInSocket = IsCardInSocket(socket);
      
      if (isCardInSocket != wasCardInSocket) {
         DebugPrint((PCMCIA_DEBUG_INFO, "PcmciaTimerDpc: Setting socket %x change interrupt,  cardInSocket=%x Socket->Flags=%x\n", socket, isCardInSocket, socket->Flags));
         SetSocketFlag(socket, SOCKET_CHANGE_INTERRUPT);
         callDpc = TRUE;
      }
   }

   if (callDpc) {
      LARGE_INTEGER dueTime;
     
      KeCancelTimer(&fdoExtension->EventTimer);
      dueTime.QuadPart = -((LONG)EventDpcDelay*10);
      KeSetTimer(&fdoExtension->EventTimer, dueTime, &fdoExtension->EventDpc);      
   }
}



BOOLEAN
PcmciaInterrupt(
   IN PKINTERRUPT InterruptObject,
   PVOID Context
   )

/*++

Routine Description:

    interrupt handler

Arguments:

    InterruptObject - Pointer to the interrupt object.
    Context - Pointer to the device context.

Return Value:

    Status

--*/

{
   PFDO_EXTENSION    deviceExtension;
   PSOCKET           socket;
   BOOLEAN           statusChanged = FALSE;

   deviceExtension=((PDEVICE_OBJECT)Context)->DeviceExtension;

   if (deviceExtension->Flags & PCMCIA_FDO_OFFLINE) {
      return FALSE;
   }

   if (!ValidateController(deviceExtension)) {
      //
      // the controller is broken in some way. Treat like a spurious int
      //
      ASSERT(FALSE);
      return FALSE;
   }

   //
   // Interrupted because of a card removal, or a card insertion.
   //
   for (socket = deviceExtension->SocketList; socket; socket = socket->NextSocket) {
      //
      // Check if the card status changed
      //
      if ((*(socket->SocketFnPtr->PCBDetectCardChanged))(socket)) {
         DebugPrint((PCMCIA_DEBUG_ISR, "skt %x card change\n", socket));
         if (deviceExtension->DevicePowerState == PowerDeviceD0) {
            SetSocketFlag(socket, SOCKET_CHANGE_INTERRUPT);
         }            
         statusChanged = TRUE;
      }
      
      socket->ReadyChanged = (*(socket->SocketFnPtr->PCBDetectReadyChanged))(socket);

      if (socket->ReadyChanged) {
         DebugPrint((PCMCIA_DEBUG_ISR, "skt %x Ready changed\n", socket));
         statusChanged = TRUE;
      }

      //
      // Clear card status interrupt, probably leftover from wait/wake
      //

      if ((socket->SocketFnPtr->PCBDetectCardStatus)) {
         (*(socket->SocketFnPtr->PCBDetectCardStatus))(socket); 
      }
      
   }

   if (statusChanged && (deviceExtension->DevicePowerState == PowerDeviceD0)) {
      //
      // Something changed out there.. could be
      // a card insertion/removal.
      // Request a DPC to check it out.
      //
      IoRequestDpc((PDEVICE_OBJECT) Context, NULL, NULL);
   }
   return statusChanged;
}



VOID
PcmciaInterruptDpc(
   IN PKDPC          Dpc,
   IN PDEVICE_OBJECT DeviceObject,
   IN PVOID          SystemContext1,
   IN PVOID          SystemContext2
   )

/*++

Routine Description:

    This DPC is just an intermediate step in getting to the main DPC
    handler. This is used to "debounce" hardware and give it some time after
    the physical interrupt has come in.

Arguments:

    DeviceObject - Pointer to the device object.

Return Value:


--*/

{
   PFDO_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
   LARGE_INTEGER dueTime;

   KeCancelTimer(&deviceExtension->EventTimer);
   dueTime.QuadPart = -((LONG)EventDpcDelay*10);
   KeSetTimer(&deviceExtension->EventTimer, dueTime, &deviceExtension->EventDpc);      
}   
   
   

VOID
PcmciaDpc(
   IN PKDPC          Dpc,
   IN PDEVICE_OBJECT DeviceObject,
   IN PVOID          SystemContext1,
   IN PVOID          SystemContext2
   )

/*++

Routine Description:

    This deferred procedure will be called due to a request for DPC
    from the interrupt routine.  The device object passed contains
    information concerning which sockets have changed.  Search this
    list and free/clean up any sockets that used to have PCCards.

Arguments:

    DeviceObject - Pointer to the device object.

Return Value:


--*/

{
   PFDO_EXTENSION          fdoExtension = DeviceObject->DeviceExtension;
   PSOCKET                 socket;

   if (fdoExtension->Flags & PCMCIA_FDO_OFFLINE) {
      return;
   }

   DebugPrint((PCMCIA_DEBUG_DPC, "PcmciaDpc: Card Status Change DPC entered...\n"));

   //
   // For synchronization with the enumeration & removal
   // routines which have a tendency to pop off pdo's
   // etc
   //
   PCMCIA_ACQUIRE_DEVICE_LOCK_AT_DPC_LEVEL(fdoExtension);

   for (socket = fdoExtension->SocketList; socket; socket = socket->NextSocket) {

      if (socket->ReadyChanged) {
         KeSetEvent(&socket->PCCardReadyEvent, 0, FALSE);
      }

      if (IsSocketFlagSet(socket,SOCKET_CHANGE_INTERRUPT)) {
         DebugPrint((PCMCIA_DEBUG_DPC, "PcmciaDpc: Socket %x has SOCKET_CHANGE_INTERRUPT set\n", socket));
         //
         // This socket has changed status
         //
         ResetSocketFlag(socket, SOCKET_CHANGE_INTERRUPT);
         ResetSocketFlag(socket, SOCKET_SUPPORT_MESSAGE_SENT);
         SetSocketFlag(socket, SOCKET_CARD_STATUS_CHANGE);

         if ((*(socket->SocketFnPtr->PCBDetectCardInSocket))(socket)) {
            SetSocketFlag(socket, SOCKET_INSERTED_SOUND_PENDING);
            //
            // Assume we have a single function card here.
            // This will be corrected by when we parse the tuple data (for an R2 card)
            // or PCI returns more than one PDO (for a cardbus card)
            //
            socket->NumberOfFunctions = 1;
            ResetSocketFlag(socket, SOCKET_CARD_MULTIFUNCTION);
            //
            // If we get a physical plug in, then we better clean up even if we didn't
            // get the remove yet.
            //
            ResetSocketFlag(socket, SOCKET_CLEANUP_PENDING);
            ResetSocketFlag(socket, SOCKET_ENUMERATE_PENDING);

         } else {

            if (IsSocketFlagSet(socket, SOCKET_REMOVED_SOUND_PENDING)) {
               ResetSocketFlag(socket, SOCKET_REMOVED_SOUND_PENDING);
               PcmciaPlaySound(CARD_REMOVED_SOUND);
            }

            if (socket->PdoList) {
               PPDO_EXTENSION pdoExtension;
               PDEVICE_OBJECT pdo, nextPdo;
               //
               // Mark all the pdo's which hang off this socket (more than one possible only
               // if this is a Multifunction PC-Card)
               //
               for (pdo = socket->PdoList; pdo!=NULL; pdo=nextPdo) {
                  pdoExtension = pdo->DeviceExtension;
                  nextPdo = pdoExtension->NextPdoInSocket;
                  pdoExtension->NextPdoInSocket = NULL;

                  MarkDevicePhysicallyRemoved(pdoExtension);
               }

               socket->PdoList = NULL;
            }

            //
            // Hack for Topic95 controllers staying in 3.3v
            //
            if (fdoExtension->ControllerType == PcmciaTopic95) {
               ULONG state = CBReadSocketRegister(socket, CARDBUS_SOCKET_PRESENT_STATE_REG);

               if ((state & CARDBUS_CB_CARD) && !(state & (CARDBUS_CD1 | CARDBUS_CD2))) {
                  state &= ~(SKTFORCE_CBCARD | SKTFORCE_3VCARD);
                  CBWriteSocketRegister(socket, CARDBUS_SOCKET_FORCE_EVENT_REG, state);
               }
            }
            
            //
            // Clear power requirements
            //
            socket->Vcc = socket->Vpp1 = socket->Vpp2 = 0;

            //
            // Make sure i/o arbiter is not hanging on the devnode
            //            
            if (CardBusExtension(fdoExtension)) {
               IoInvalidateDeviceState(fdoExtension->Pdo);
            }
         }
      }
   }

   PCMCIA_RELEASE_DEVICE_LOCK_FROM_DPC_LEVEL(fdoExtension);

   IoInvalidateDeviceRelations(fdoExtension->Pdo, BusRelations);

   return;
}



VOID
PcmciaSetControllerType(
   IN PFDO_EXTENSION FdoExtension,
   IN PCMCIA_CONTROLLER_TYPE ControllerType
   )
/*++
Routine Description

   This routine does the housekeeping for setting the controller type,
   and the corresponding device index.

Arguments

   FdoExtension - Pointer to device extension for the pcmcia controller
   ControllerType - new controller type to set into the extension

Return Value

    None. Must succeed.

--*/
{
   PCMCIA_CONTROLLER_CLASS ctlClass;
   ULONG index;

   FdoExtension->ControllerType = ControllerType;
   ctlClass = PcmciaClassFromControllerType(FdoExtension->ControllerType);

   //
   // first assume cardbus
   //
   MarkDeviceCardBus(FdoExtension);
   
   switch(ctlClass) {
      case PcmciaIntelCompatible:
      case PcmciaPciPcmciaBridge:
      case PcmciaElcController:
      case PcmciaDatabook:
      case PcmciaNEC_98:
         MarkDevice16Bit(FdoExtension);
         break;

      case PcmciaCirrusLogic:
         if (ControllerType == PcmciaCLPD6729) {
            MarkDevice16Bit(FdoExtension);
         }            
         break;         
   }
   
   
   //
   // Look up the device in our dispatch table
   //
   for (index = 0; DeviceDispatchTable[index].ControllerClass != PcmciaInvalidControllerClass; index++) {
      if (DeviceDispatchTable[index].ControllerClass == ctlClass) {
         FdoExtension->DeviceDispatchIndex = index;
         break;
      }
   }
   
   
   FdoExtension->Flags &= ~PCMCIA_MEMORY_24BIT;
   
   if (!HasWindowPageRegister(FdoExtension)) {
      FdoExtension->Flags |= PCMCIA_MEMORY_24BIT;
   }

   if ((FdoExtension->InterfaceType == InterfaceTypeUndefined) ||
       (FdoExtension->InterfaceType == Isa)) {
      FdoExtension->Flags |= PCMCIA_MEMORY_24BIT;
   }       
   
   
   switch(ControllerType) {
      case PcmciaTI1031:
      case PcmciaTI1130:
         //
         // restrict memory ranges for PDO's to 24bit 
         // (because of missing "window page" functionality).
         //    
         FdoExtension->Flags |= PCMCIA_MEMORY_24BIT;
         break;
                     
   }            
         
   
   DebugPrint((PCMCIA_DEBUG_INFO, "fdo %08x Controller Type %x\n",
                                    FdoExtension->DeviceObject, ControllerType));

}



NTSTATUS
PcmciaGetPciControllerType(
   IN PDEVICE_OBJECT Pdo,
   IN PDEVICE_OBJECT Fdo
   )
/*++

Routine Description:
   Look at the PCI hardware ID to see if it is already a device we know about. If so,
   set the appropriate controller type in the fdoExtension.

Arguments:
   Pdo - Physical Device object for the Pcmcia controller owned by the PCI driver
   Fdo - Functional Device object for the pcmcia controller owned by this driver, whose
         extension will store the relevant controller information upon exit from this routine.

Return Value:
   STATUS_SUCCESS             Things are fine and information obtained
   STATUS_NOT_SUPPORTED       This is actually a healthy status for this routine: all it means
                               is that this PDO is not on a PCI bus, so no information needs to be
                               obtained anyways.
   Any other status            Failure. Caller probably needs to back out & not support this controller
--*/
{
   PFDO_EXTENSION fdoExtension    = Fdo->DeviceExtension;
   PIRP                             irp;
   IO_STATUS_BLOCK                  statusBlock;
   PIO_STACK_LOCATION               irpSp;
   PCI_COMMON_CONFIG                pciConfig;
   PPCI_CONTROLLER_INFORMATION      id;
   PPCI_VENDOR_INFORMATION          vid;
   KEVENT                           event;
   NTSTATUS                         status;
   BOOLEAN                          foundController = FALSE;

   PAGED_CODE();
   //
   // Allocate & initialize an Irp (IRP_MN_READ_CONFIG) to be sent down
   // to the PCI bus driver to get config. header for this controller
   //
   // Following is all standard stuff to send an IRP down - needs no documentation

   //
   // Fresh PDO. No need to jump through hoops to get attached devices
   //
   KeInitializeEvent (&event, NotificationEvent, FALSE);
   irp = IoBuildSynchronousFsdRequest( IRP_MJ_PNP,
                                       Pdo,
                                       NULL,
                                       0,
                                       0,
                                       &event,
                                       &statusBlock
                                     );

   if (irp == NULL) {
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
   irp->IoStatus.Information = 0;

   irpSp = IoGetNextIrpStackLocation(irp);

   irpSp->MinorFunction = IRP_MN_READ_CONFIG;

   irpSp->Parameters.ReadWriteConfig.WhichSpace = PCI_WHICHSPACE_CONFIG;
   irpSp->Parameters.ReadWriteConfig.Buffer = &pciConfig;
   irpSp->Parameters.ReadWriteConfig.Offset = 0;
   irpSp->Parameters.ReadWriteConfig.Length = sizeof(pciConfig);


   status = IoCallDriver(Pdo, irp);

   if (status == STATUS_PENDING) {
      KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
      status = statusBlock.Status;
   }

   if (!NT_SUCCESS(status)) {
      return status;
   }
   //
   // Now weed out the critical information from the config header and
   // store it away in the fdo's extension
   //

   if (pciConfig.SubClass == PCI_SUBCLASS_BR_PCMCIA) {
   
      PcmciaSetControllerType(fdoExtension, PcmciaPciPcmciaBridge);
      
   } else if (pciConfig.SubClass == PCI_SUBCLASS_BR_CARDBUS) {
   
      PcmciaSetControllerType(fdoExtension, PcmciaCardBusCompatible);
      
   } else {
      //
      // Unknown controller
      //
      return STATUS_UNSUCCESSFUL;
   }

   //
   // Look up the PCI device id in our table
   //
   for (id = (PPCI_CONTROLLER_INFORMATION) PciControllerInformation;id->VendorID != PCI_INVALID_VENDORID; id++) {
      if ((id->VendorID == pciConfig.VendorID) && (id->DeviceID == pciConfig.DeviceID)) {

         PcmciaSetControllerType(fdoExtension, id->ControllerType);
         foundController = TRUE;

         break;
      }
   }

   //
   // Didn't find a specific vendor/device id, try to just base it on the vendor id
   //   
   if (!foundController) {
      for (vid = (PPCI_VENDOR_INFORMATION) PciVendorInformation;vid->VendorID != PCI_INVALID_VENDORID; vid++) {
         if (vid->VendorID == pciConfig.VendorID) {
     
            PcmciaSetControllerType(fdoExtension, vid->ControllerClass);
            break;
         }
      }
   }

   return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\memcard\utils.c ===
/*++

Copyright (c) 1991-1998  Microsoft Corporation

Module Name:

    utils.c

Abstract:

Author:

    Neil Sandlin (neilsa) 26-Apr-99

Environment:

    Kernel mode only.

--*/
#include "pch.h"

//
// Internal References
//

ULONG
MemCardGetCapacityFromCIS(
   IN PMEMCARD_EXTENSION memcardExtension
   );
   
ULONG
MemCardGetCapacityFromBootSector(
   IN PMEMCARD_EXTENSION memcardExtension
   );

ULONG
MemCardProbeForCapacity(
   IN PMEMCARD_EXTENSION memcardExtension
   );



#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,MemCardGetCapacityFromCIS)
#pragma alloc_text(PAGE,MemCardGetCapacityFromBootSector)
#pragma alloc_text(PAGE,MemCardProbeForCapacity)
#endif



ULONG
MemCardGetCapacity(
   IN PMEMCARD_EXTENSION memcardExtension
   )
/*++

Routine Description:

Arguments:

   device extension for the card

Return Value:


--*/
{
   ULONG capacity;
   
   capacity = MemCardGetCapacityFromCIS(memcardExtension);
   
   if (capacity) {
      return capacity;
   }
   
   capacity = MemCardGetCapacityFromBootSector(memcardExtension);
   
   if (capacity) {
      return capacity;
   }
   
   return MemCardProbeForCapacity(memcardExtension);   
}



ULONG
MemCardGetCapacityFromBootSector(
   IN PMEMCARD_EXTENSION memcardExtension
   )
/*++

Routine Description:

Arguments:

   device extension for the card

Return Value:


--*/

{
   NTSTATUS status;
   BOOT_SECTOR_INFO BootSector;
   ULONG capacity = 0;
   
   status = MEMCARD_READ(memcardExtension, 0, &BootSector, sizeof(BootSector));
   
   if (NT_SUCCESS(status)) {

#define BYTES_PER_SECTOR 512
      //
      // see if this really looks like a boot sector
      // These are the same tests done in the win9x sram support
      //
      if ((BootSector.JumpByte == 0xE9 || BootSector.JumpByte == 0xEB) &&
      
          BootSector.BytesPerSector == BYTES_PER_SECTOR &&
      
          BootSector.SectorsPerCluster != 0 &&
          
          BootSector.ReservedSectors == 1 &&
          
         (BootSector.NumberOfFATs == 1 || BootSector.NumberOfFATs == 2) &&
         
          BootSector.RootEntries != 0 && (BootSector.RootEntries & 15) == 0 &&
          
         (BootSector.TotalSectors != 0 || BootSector.BigTotalSectors != 0) &&
         
          BootSector.SectorsPerFAT != 0 &&
          
          BootSector.SectorsPerTrack != 0 &&
          
          BootSector.Heads != 0 &&
          
          BootSector.MediaDescriptor >= 0xF0) {

         //
         // Finally it appears valid, return total size of region.
         //
         capacity = BootSector.TotalSectors * BYTES_PER_SECTOR;
   
      }
   }
   return capacity;
}



ULONG
MemCardGetCapacityFromCIS(
   IN PMEMCARD_EXTENSION memcardExtension
   )
/*++

Routine Description:

   This is a quick and dirty routine to read the tuples of the card, if they
   exist, to get the capacity.

Arguments:

   device extension for the card

Return Value:

   The # of bytes of memory on the device

--*/

{
   UCHAR tupleData[16];
   ULONG bytesRead;
   ULONG dataCount;
   ULONG unitSize;
   ULONG unitCount;
   ULONG i;
   
   //
   // get device capacity
   // all this stuff should really be in the bus driver
   //
   
   bytesRead = (memcardExtension->PcmciaBusInterface.ReadConfig)(memcardExtension->UnderlyingPDO, 
                                                                 PCCARD_ATTRIBUTE_MEMORY,
                                                                 tupleData,
                                                                 0,
                                                                 16);

   if ((bytesRead != 16) || (tupleData[0] != 1)){
      return 0;
   }
   
   dataCount = (ULONG)tupleData[1];                                                                       

   if ((dataCount < 2) || (dataCount>14)){   
      return 0;
   }

   i = 3;
   if ((tupleData[2] & 7) == 7) {
      while(tupleData[i] & 0x80) {
         if ((i-2) > dataCount) {
            return 0;
         }
         i++;
      }
   }
   
   if ((tupleData[i]&7) == 7) {
      return 0;
   }      
   unitSize = 512 << ((tupleData[i]&7)*2);
   unitCount = (tupleData[i]>>3)+1;
   
   return(unitCount * unitSize);
}


ULONG
MemCardProbeForCapacity(
   IN PMEMCARD_EXTENSION memcardExtension
   )
/*++

Routine Description:

   Since we were unable to determine the card capacity through other means, 
   here we actually write stuff out on the card to check how big it is.
   This algorithm for testing the card capacity was ported from win9x.

Arguments:

   device extension for the card

Return Value:

   byte capacity of device

--*/
{
   NTSTATUS status;
   ULONG capacity = 0;
   USHORT origValue, ChkValue, StartValue;
   USHORT mcSig = 'Mc';
   USHORT zeroes = 0;
#define SRAM_BLK_SIZE (16*1024)   
   ULONG CardOff = SRAM_BLK_SIZE;
   USHORT CurValue;

   if ((memcardExtension->PcmciaInterface.IsWriteProtected)(memcardExtension->UnderlyingPDO)) {
      return 0;
   }

   //
   // 
   if (!NT_SUCCESS(MEMCARD_READ (memcardExtension, 0, &origValue, sizeof(origValue))) ||
       !NT_SUCCESS(MEMCARD_WRITE(memcardExtension, 0, &mcSig,     sizeof(mcSig)))     ||
       !NT_SUCCESS(MEMCARD_READ (memcardExtension, 0, &ChkValue,  sizeof(ChkValue))))   {
      return 0;
   }   

   if (ChkValue != mcSig) {
      //
      // not sram
      //
      return 0;
   }

   for (;;) {
      if (!NT_SUCCESS(MEMCARD_READ (memcardExtension, CardOff, &CurValue, sizeof(CurValue))) ||
          !NT_SUCCESS(MEMCARD_WRITE(memcardExtension, CardOff, &zeroes,   sizeof(zeroes)))   ||
          !NT_SUCCESS(MEMCARD_READ (memcardExtension, CardOff, &ChkValue, sizeof(ChkValue))) ||
          !NT_SUCCESS(MEMCARD_READ (memcardExtension, 0, &StartValue, sizeof(StartValue)))) {
         break;
      }

      // We stop when either we can't write 0 anymore or the 0
      // has wrapped over the 0x9090 at card offset 0

      if (ChkValue != zeroes || StartValue == zeroes) {
         capacity = CardOff;
         break;
      }

      // Restore the saved value from the start of the block.

      if (!NT_SUCCESS(MEMCARD_WRITE(memcardExtension, CardOff, &CurValue, sizeof(CurValue)))) {
         break;
      }
      CardOff += SRAM_BLK_SIZE;       // increment to the next block
   }   
   
   //
   // try to restore original value
   //   
   MEMCARD_WRITE(memcardExtension, 0, &origValue, sizeof(origValue));
   
   return capacity;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\pcmcibus\data.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    data.c

Abstract:

    Data definitions for discardable/pageable data

Author:
    Ravisankar Pudipeddi (ravisp) -  1 Feb 1997
    Neil Sandlin (neilsa) June 1 1999    

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg ("INIT")
#endif
//
// Beginning of Init Data
//

//
// Global registry values (in pcmcia\\parameters)
//
#define PCMCIA_REGISTRY_INTERRUPT_MASK_VALUE        L"ForcedInterruptMask"
#define PCMCIA_REGISTRY_INTERRUPT_FILTER_VALUE      L"FilterInterruptMask"
#define PCMCIA_REGISTRY_ATTRIBUTE_MEMORY_LO_VALUE   L"AttributeMemoryLow"
#define PCMCIA_REGISTRY_ATTRIBUTE_MEMORY_HI_VALUE   L"AttributeMemoryHigh"
#define PCMCIA_REGISTRY_ATTRIBUTE_MEMORY_SIZE_VALUE L"AttributeMemorySize"
#define PCMCIA_REGISTRY_SOUNDS_ENABLED_VALUE        L"SoundsEnabled"
#define PCMCIA_REGISTRY_POWER_POLICY_VALUE          L"PowerPolicy"
#define PCMCIA_REGISTRY_FORCE_CTLR_DEVICE_WAKE      L"ForceControllerDeviceWake"
#define PCMCIA_REGISTRY_IO_HIGH_VALUE               L"IoHigh"
#define PCMCIA_REGISTRY_IO_LOW_VALUE                L"IoLow"
#define PCMCIA_REGISTRY_READY_DELAY_ITER_VALUE      L"ReadyDelayIter"
#define PCMCIA_REGISTRY_READY_STALL_VALUE           L"ReadyStall"
#define PCMCIA_REGISTRY_USE_POLLED_CSC_VALUE        L"ForcePolledMode"
#define PCMCIA_REGISTRY_CBMODEM_DELAY_VALUE         L"CBModemReadyDelay"
#define PCMCIA_REGISTRY_PCIC_MEMORY_WINDOW_DELAY    L"PcicMemoryWindowDelay"
#define PCMCIA_REGISTRY_PCIC_RESET_WIDTH_DELAY      L"PcicResetWidthDelay"
#define PCMCIA_REGISTRY_PCIC_RESET_SETUP_DELAY      L"PcicResetSetupDelay"
#define PCMCIA_REGISTRY_CB_RESET_WIDTH_DELAY        L"CBResetWidthDelay"
#define PCMCIA_REGISTRY_CB_RESET_SETUP_DELAY        L"CBResetSetupDelay"
#define PCMCIA_REGISTRY_CONTROLLER_POWERUP_DELAY    L"ControllerPowerUpDelay"
#define PCMCIA_REGISTRY_DISABLE_ISA_PCI_ROUTING     L"DisableIsaToPciRouting"
#define PCMCIA_REGISTRY_DEFAULT_ROUTE_R2_TO_ISA     L"DefaultRouteToIsa"
#define PCMCIA_REGISTRY_DISABLE_ACPI_NAMESPACE_CHK  L"DisableAcpiNameSpaceCheck"
#define PCMCIA_REGISTRY_IRQ_ROUTE_PCI_CTLR          L"IrqRouteToPciController"
#define PCMCIA_REGISTRY_IRQ_ROUTE_ISA_CTLR          L"IrqRouteToIsaController"
#define PCMCIA_REGISTRY_IRQ_ROUTE_PCI_LOC           L"IrqRouteToPciLocation"
#define PCMCIA_REGISTRY_IRQ_ROUTE_ISA_LOC           L"IrqRouteToIsaLocation"
#define PCMCIA_REGISTRY_REPORT_MTD0002_AS_ERROR     L"ReportMTD0002AsError"
#define PCMCIA_REGISTRY_DEBUG_MASK                  L"DebugMask"
#define PCMCIA_REGISTRY_EVENT_DPC_DELAY             L"EventDpcDelay"

//
// Table which defines global registry settings
//
//          RegistryName                           Internal Variable              Default Value
//          ------------                           -----------------              -------------
GLOBAL_REGISTRY_INFORMATION GlobalRegistryInfo[] = {
#if DBG
   PCMCIA_REGISTRY_DEBUG_MASK,                  &PcmciaDebugMask,             1,
#endif   
   PCMCIA_REGISTRY_INTERRUPT_MASK_VALUE,        &globalOverrideIrqMask,       0,
   PCMCIA_REGISTRY_INTERRUPT_FILTER_VALUE,      &globalFilterIrqMask,         0,
   PCMCIA_REGISTRY_ATTRIBUTE_MEMORY_LO_VALUE,   &globalAttributeMemoryLow,    PCMCIA_DEFAULT_ATTRIBUTE_MEMORY_LOW,
   PCMCIA_REGISTRY_ATTRIBUTE_MEMORY_HI_VALUE,   &globalAttributeMemoryHigh,   PCMCIA_DEFAULT_ATTRIBUTE_MEMORY_HIGH,
   PCMCIA_REGISTRY_ATTRIBUTE_MEMORY_SIZE_VALUE, &globalAttributeMemorySize,   0,
   PCMCIA_REGISTRY_SOUNDS_ENABLED_VALUE,        &initSoundsEnabled,           1,
   PCMCIA_REGISTRY_POWER_POLICY_VALUE,          &PcmciaPowerPolicy,           1,
   PCMCIA_REGISTRY_FORCE_CTLR_DEVICE_WAKE,      &PcmciaControllerDeviceWake,  0,
   PCMCIA_REGISTRY_IO_HIGH_VALUE,               &globalIoHigh,                PCMCIA_DEFAULT_IO_HIGH,
   PCMCIA_REGISTRY_IO_LOW_VALUE,                &globalIoLow,                 PCMCIA_DEFAULT_IO_LOW, 
   PCMCIA_REGISTRY_READY_DELAY_ITER_VALUE,      &globalReadyDelayIter,        PCMCIA_DEFAULT_READY_DELAY_ITER,
   PCMCIA_REGISTRY_READY_STALL_VALUE,           &globalReadyStall,            PCMCIA_DEFAULT_READY_STALL,
   PCMCIA_REGISTRY_USE_POLLED_CSC_VALUE,        &initUsePolledCsc,            0,
   PCMCIA_REGISTRY_DISABLE_ISA_PCI_ROUTING,     &pcmciaDisableIsaPciRouting,  0,
   PCMCIA_REGISTRY_ISA_IRQ_RESCAN_COMPLETE,     &pcmciaIsaIrqRescanComplete,  0,
   PCMCIA_REGISTRY_IRQ_ROUTE_PCI_CTLR,          &pcmciaIrqRouteToPciController, 0,
   PCMCIA_REGISTRY_IRQ_ROUTE_ISA_CTLR,          &pcmciaIrqRouteToIsaController, 0,
   PCMCIA_REGISTRY_IRQ_ROUTE_PCI_LOC,           &pcmciaIrqRouteToPciLocation, 0,
   PCMCIA_REGISTRY_IRQ_ROUTE_ISA_LOC,           &pcmciaIrqRouteToIsaLocation, 0,
   PCMCIA_REGISTRY_DISABLE_ACPI_NAMESPACE_CHK,  &initDisableAcpiNameSpaceCheck, 0,
   PCMCIA_REGISTRY_DEFAULT_ROUTE_R2_TO_ISA,     &initDefaultRouteR2ToIsa,     0,
   PCMCIA_REGISTRY_CBMODEM_DELAY_VALUE,         &CBModemReadyDelay,           PCMCIA_DEFAULT_CB_MODEM_READY_DELAY,
   PCMCIA_REGISTRY_PCIC_MEMORY_WINDOW_DELAY,    &PcicMemoryWindowDelay,       PCMCIA_DEFAULT_PCIC_MEMORY_WINDOW_DELAY,
   PCMCIA_REGISTRY_PCIC_RESET_WIDTH_DELAY,      &PcicResetWidthDelay,         PCMCIA_DEFAULT_PCIC_RESET_WIDTH_DELAY,
   PCMCIA_REGISTRY_PCIC_RESET_SETUP_DELAY,      &PcicResetSetupDelay,         PCMCIA_DEFAULT_PCIC_RESET_SETUP_DELAY,
   PCMCIA_REGISTRY_CB_RESET_WIDTH_DELAY,        &CBResetWidthDelay,           PCMCIA_DEFAULT_CB_RESET_WIDTH_DELAY,
   PCMCIA_REGISTRY_CB_RESET_SETUP_DELAY,        &CBResetSetupDelay,           PCMCIA_DEFAULT_CB_RESET_SETUP_DELAY,
   PCMCIA_REGISTRY_CONTROLLER_POWERUP_DELAY,    &ControllerPowerUpDelay,      PCMCIA_DEFAULT_CONTROLLER_POWERUP_DELAY,
   PCMCIA_REGISTRY_EVENT_DPC_DELAY,             &EventDpcDelay,               PCMCIA_DEFAULT_EVENT_DPC_DELAY,
   PCMCIA_REGISTRY_REPORT_MTD0002_AS_ERROR,     &pcmciaReportMTD0002AsError,  1
};

ULONG GlobalInfoCount = sizeof(GlobalRegistryInfo) / sizeof(GLOBAL_REGISTRY_INFORMATION);

ULONG initSoundsEnabled;
ULONG initUsePolledCsc; 
ULONG initDisableAcpiNameSpaceCheck;
ULONG initDefaultRouteR2ToIsa;
//
// end of Init Data
//
#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg ()
#endif


#ifdef ALLOC_DATA_PRAGMA
   #pragma data_seg()
#endif
//
// Non-Paged global variables
//

//
// List of FDOs managed by this driver
//
PDEVICE_OBJECT   FdoList;
//
// GLobal Flags
//
ULONG            PcmciaGlobalFlags = 0;
//
// Event used by PcmciaWait
//
KEVENT           PcmciaDelayTimerEvent;
//
// Objects used by PcmciaPlayTone
//

PPCMCIA_SOUND_EVENT PcmciaToneList;
KTIMER PcmciaToneTimer;
KDPC PcmciaToneDpc;
KSPIN_LOCK PcmciaToneLock;
KSPIN_LOCK PcmciaGlobalLock;
PPCMCIA_NTDETECT_DATA pNtDetectDataList = NULL;

ULONG PcicStallPower = PWRON_DELAY;

//
// Various values set by PcmciaLoadGlobalRegistryValues
//
ULONG PcicMemoryWindowDelay;
ULONG PcicResetWidthDelay;
ULONG PcicResetSetupDelay;
ULONG CBResetWidthDelay;
ULONG CBResetSetupDelay;
ULONG CBModemReadyDelay;
ULONG ControllerPowerUpDelay;
ULONG EventDpcDelay;
ULONG PcmciaPowerPolicy;
LONG PcmciaControllerDeviceWake;

ULONG globalOverrideIrqMask;   
ULONG globalFilterIrqMask;   
ULONG globalIoLow;              
ULONG globalIoHigh;             
ULONG globalReadyDelayIter;     
ULONG globalReadyStall;         
ULONG globalAttributeMemoryLow; 
ULONG globalAttributeMemoryHigh;
ULONG globalAttributeMemorySize;
ULONG pcmciaDisableIsaPciRouting; 
ULONG pcmciaIsaIrqRescanComplete; 
ULONG pcmciaIrqRouteToPciController;
ULONG pcmciaIrqRouteToIsaController;
ULONG pcmciaIrqRouteToPciLocation;
ULONG pcmciaIrqRouteToIsaLocation;
ULONG pcmciaReportMTD0002AsError;
#if DBG
ULONG PcmciaDebugMask;
#endif

#ifdef ALLOC_DATA_PRAGMA
   #pragma data_seg("PAGE")
#endif
//
// Paged const tables
//


const
PCI_CONTROLLER_INFORMATION PciControllerInformation[] = {

   // Vendor id                 Device Id                 Controller type
   // -------------------------------------------------------------------------------
   PCI_CIRRUSLOGIC_VENDORID, PCI_CLPD6729_DEVICEID,    PcmciaCLPD6729,     
   PCI_CIRRUSLOGIC_VENDORID, PCI_CLPD6832_DEVICEID,    PcmciaCLPD6832,     
   PCI_CIRRUSLOGIC_VENDORID, PCI_CLPD6834_DEVICEID,    PcmciaCLPD6834,     
   PCI_TI_VENDORID,          PCI_TI1031_DEVICEID,      PcmciaTI1031,       
   PCI_TI_VENDORID,          PCI_TI1130_DEVICEID,      PcmciaTI1130,       
   PCI_TI_VENDORID,          PCI_TI1131_DEVICEID,      PcmciaTI1131,       
   PCI_TI_VENDORID,          PCI_TI1250_DEVICEID,      PcmciaTI1250,       
   PCI_TI_VENDORID,          PCI_TI1220_DEVICEID,      PcmciaTI1220,       
   PCI_TI_VENDORID,          PCI_TI1251B_DEVICEID,     PcmciaTI1251B,      
   PCI_TI_VENDORID,          PCI_TI1450_DEVICEID,      PcmciaTI1450,       
   PCI_TOSHIBA_VENDORID,     PCI_TOPIC95_DEVICEID,     PcmciaTopic95,      
   PCI_RICOH_VENDORID,       PCI_RL5C465_DEVICEID,     PcmciaRL5C465,      
   PCI_RICOH_VENDORID,       PCI_RL5C466_DEVICEID,     PcmciaRL5C466,      
   PCI_RICOH_VENDORID,       PCI_RL5C475_DEVICEID,     PcmciaRL5C475,      
   PCI_RICOH_VENDORID,       PCI_RL5C476_DEVICEID,     PcmciaRL5C476,      
   PCI_RICOH_VENDORID,       PCI_RL5C478_DEVICEID,     PcmciaRL5C478,      
   PCI_DATABOOK_VENDORID,    PCI_DB87144_DEVICEID,     PcmciaDB87144,      
   PCI_OPTI_VENDORID,        PCI_OPTI82C814_DEVICEID,  PcmciaOpti82C814,   
   PCI_OPTI_VENDORID,        PCI_OPTI82C824_DEVICEID,  PcmciaOpti82C824,   
   PCI_TRIDENT_VENDORID,     PCI_TRID82C194_DEVICEID,  PcmciaTrid82C194,   
   PCI_NEC_VENDORID,         PCI_NEC66369_DEVICEID,    PcmciaNEC66369,     
   // --------------------------------------------------------------------
   // Additional database entries go above this line
   //
   PCI_INVALID_VENDORID,     0,                        0,                  
};

const
PCI_VENDOR_INFORMATION PciVendorInformation[] = {
   PCI_TI_VENDORID,           PcmciaTI,
   PCI_TOSHIBA_VENDORID,      PcmciaTopic,
   PCI_RICOH_VENDORID,        PcmciaRicoh,
   PCI_O2MICRO_VENDORID,      PcmciaO2Micro,
   PCI_NEC_VENDORID,          PcmciaNEC,
   PCI_DATABOOK_VENDORID,     PcmciaDatabook,
   PCI_OPTI_VENDORID,         PcmciaOpti,
   PCI_TRIDENT_VENDORID,      PcmciaTrid,
   PCI_INVALID_VENDORID,      0
};

const
DEVICE_DISPATCH_TABLE DeviceDispatchTable[] = {
   {PcmciaIntelCompatible, NULL,         PcicSetPower,  NULL,          NULL,       NULL},
   {PcmciaPciPcmciaBridge, NULL,         PcicSetPower,  NULL,          NULL,       NULL},
   {PcmciaElcController,   NULL,         PcicSetPower,  NULL,          NULL,       NULL},
                                                                      
   {PcmciaCardBusCompatible, NULL,       CBSetPower,    NULL,          NULL,       CBSetWindowPage},
   {PcmciaDatabook,   NULL,              TcicSetPower,  NULL,          NULL,       NULL},
   {PcmciaTI,         TIInitialize,      CBSetPower,    NULL,          TISetZV,    TISetWindowPage},
   {PcmciaCirrusLogic,CLInitialize,      CLSetPower,    NULL,          CLSetZV,    CBSetWindowPage},
   {PcmciaTopic,      TopicInitialize,   TopicSetPower, TopicSetAudio, TopicSetZV, CBSetWindowPage},
   {PcmciaRicoh,      RicohInitialize,   CBSetPower,    NULL,          RicohSetZV, CBSetWindowPage},
   {PcmciaDatabookCB, DBInitialize,      CBSetPower,    NULL,          DBSetZV,    CBSetWindowPage},
   {PcmciaOpti,       OptiInitialize,    OptiSetPower,  NULL,          OptiSetZV,  NULL},
   {PcmciaTrid,       NULL,              CBSetPower,    NULL,          NULL,       NULL},
   {PcmciaO2Micro,    O2MInitialize,     O2MSetPower,   NULL,          O2MSetZV,   CBSetWindowPage},
   {PcmciaNEC_98,     NULL,              PcicSetPower,  NULL,          NULL,       NULL},
   {PcmciaNEC,        NULL,              CBSetPower,    NULL,          NULL,       NULL},

   //------------------------------------------------------------------
   // Additional dispatch table entries go above this line
   //
   {PcmciaInvalidControllerClass,  NULL, NULL, NULL, NULL}
};

const
PCMCIA_ID_ENTRY PcmciaAdapterHardwareIds[] = {
   PcmciaIntelCompatible,       "*PNP0E00",
   PcmciaElcController,         "*PNP0E02",
   PcmciaDatabook,              "*DBK0000",
   PcmciaCLPD6729,              "*PNP0E01",
   PcmciaNEC98,                 "*nEC1E01",
   PcmciaNEC98102,              "*nEC8091",
   PcmciaInvalidControllerType,  0
};

const
PCMCIA_REGISTER_INIT PcicRegisterInitTable[] = {
   PCIC_INTERRUPT,            IGC_PCCARD_RESETLO,
   PCIC_CARD_CHANGE,          0x00,
   PCIC_CARD_INT_CONFIG,      0x00,
   PCIC_ADD_WIN_ENA,          0x00,
   PCIC_IO_CONTROL,           0x00,
   //
   // Init the 2 I/O windows
   //
   PCIC_IO_ADD0_STRT_L,       0x00,
   PCIC_IO_ADD0_STRT_H,       0x00,
   PCIC_IO_ADD0_STOP_L,       0x00,
   PCIC_IO_ADD0_STOP_H,       0x00,

   PCIC_IO_ADD1_STRT_L,       0x00,
   PCIC_IO_ADD1_STRT_H,       0x00,
   PCIC_IO_ADD1_STOP_L,       0x00,
   PCIC_IO_ADD1_STOP_H,       0x00,
   //
   // Init all 5 memory windows
   //
   PCIC_MEM_ADD0_STRT_L,      0xFF,
   PCIC_MEM_ADD0_STRT_H,      0x0F,
   PCIC_MEM_ADD0_STOP_L,      0xFF,
   PCIC_MEM_ADD0_STOP_H,      0x0F,
   PCIC_CRDMEM_OFF_ADD0_L,    0x00,
   PCIC_CRDMEM_OFF_ADD0_H,    0x00,

   PCIC_MEM_ADD1_STRT_L,      0xFF,
   PCIC_MEM_ADD1_STRT_H,      0x0F,
   PCIC_MEM_ADD1_STOP_L,      0xFF,
   PCIC_MEM_ADD1_STOP_H,      0x0F,
   PCIC_CRDMEM_OFF_ADD1_L,    0x00,
   PCIC_CRDMEM_OFF_ADD1_H,    0x00,

   PCIC_MEM_ADD2_STRT_L,      0xFF,
   PCIC_MEM_ADD2_STRT_H,      0x0F,
   PCIC_MEM_ADD2_STOP_L,      0xFF,
   PCIC_MEM_ADD2_STOP_H,      0x0F,
   PCIC_CRDMEM_OFF_ADD2_L,    0x00,
   PCIC_CRDMEM_OFF_ADD2_H,    0x00,

   PCIC_MEM_ADD3_STRT_L,      0xFF,
   PCIC_MEM_ADD3_STRT_H,      0x0F,
   PCIC_MEM_ADD3_STOP_L,      0xFF,
   PCIC_MEM_ADD3_STOP_H,      0x0F,
   PCIC_CRDMEM_OFF_ADD3_L,    0x00,
   PCIC_CRDMEM_OFF_ADD3_H,    0x00,

   PCIC_MEM_ADD4_STRT_L,      0xFF,
   PCIC_MEM_ADD4_STRT_H,      0x0F,
   PCIC_MEM_ADD4_STOP_L,      0xFF,
   PCIC_MEM_ADD4_STOP_H,      0x0F,
   PCIC_CRDMEM_OFF_ADD4_L,    0x00,
   PCIC_CRDMEM_OFF_ADD4_H,    0x00,
   //
   // Any other registers go here
   //
   0xFFFFFFFF,                0x00
};

#ifdef ALLOC_DATA_PRAGMA
   #pragma data_seg()
#endif
//
// Non-paged const tables
//

//
// This should be non-pageable since it is referenced by the
// Power management code - most of which runs at raised IRQL
// This represents the default set of registers that need to be
// saved/restored on a cardbus controller power-down/power-up
//

//
// Register context for the pcmcia controller
//
const
PCMCIA_CONTEXT_RANGE DefaultPciContextSave[] = {
   CFGSPACE_BRIDGE_CTRL,           2,
   CFGSPACE_LEGACY_MODE_BASE_ADDR, 4,
//   CFGSPACE_CB_LATENCY_TIMER, 1,
   0, 0
};

//
// cardbus socket registers required to be saved
//   
const
PCMCIA_CONTEXT_RANGE DefaultCardbusContextSave[] = {
   0, 0
};

//
// cardbus socket registers excluded from context save
//   
const
PCMCIA_CONTEXT_RANGE ExcludeCardbusContextRange[] = {
   CARDBUS_SOCKET_EVENT_REG,              0x4,
   CARDBUS_SOCKET_PRESENT_STATE_REG,      0xc,
   0, 0
};

//
// The following table defines any devices that need special
// attention during configuration. Note that values of 0xffff
// mean "don't care". The table is scanned until a match is made
// for the current device. 
//
// Values are:
//  validentry, devicetype, manufacturer, code, crc, configdelay1, configdelay2, configdelay3, configflags
//
// delay values are in milliseconds
//
const
PCMCIA_DEVICE_CONFIG_PARAMS DeviceConfigParams[] = {
   1, PCCARD_TYPE_MODEM,  0x109,  0x505, 0xD293,   3100,  900,    0, CONFIG_WORKER_APPLY_MODEM_HACK,  // motorola BitSurfr 56k
   1, PCCARD_TYPE_MODEM, 0xffff, 0xffff, 0xffff,      0, 1800,    0, 0,                               // any other modem
   1, PCCARD_TYPE_ATA,   0xffff, 0xffff, 0xffff,      0,    0, 2000, 0,                               // any ata device
   0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\pcmcibus\detect.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    detect.c

Abstract:

    This module contains the code that controls the PCMCIA slots.

Authors:

    Bob Rinne (BobRi) 3-Nov-1994
    Neil Sandlin (neilsa) June 1 1999

Environment:

    Kernel mode

Revision History:
    Modified for plug'n'play support
        Ravisankar Pudipeddi (ravisp) 1 Dec 1996


--*/

#include "pch.h"


NTSTATUS
PcmciaDetectControllers(
   IN PDRIVER_OBJECT          DriverObject,
   IN PUNICODE_STRING         RegistryPath,
   IN PPCMCIA_DETECT_ROUTINE  PcmciaDetectFn
   );

NTSTATUS
PcmciaReportDetectedDevice(
   IN PFDO_EXTENSION DeviceExtension
   );

NTSTATUS
PcmciaAllocateOpenMemoryWindow(
   IN PFDO_EXTENSION DeviceExtension,
   IN PPHYSICAL_ADDRESS PhysicalAddress,
   IN PULONG PhysicalAddressSize
   );


#ifdef ALLOC_PRAGMA
   #pragma alloc_text(INIT,PcmciaLegacyDetectionOk)
   #pragma alloc_text(INIT,PcmciaDetectPcmciaControllers)
   #pragma alloc_text(INIT,PcmciaDetectControllers)
   #pragma alloc_text(INIT,PcmciaReportDetectedDevice)
   #pragma alloc_text(INIT,PcmciaAllocateOpenMemoryWindow)
#endif



BOOLEAN
PcmciaLegacyDetectionOk(
   VOID
   )
/*++

Routine Description

    Checks if legacy detection needs to be done for pcmcia controllers

Arguments

    None

Return Value

    TRUE    - If legacy detection can be done
    FALSE   - If legacy detection should NOT be attempted

--*/
{
   UNICODE_STRING                 unicodeKey, unicodeValue;
   OBJECT_ATTRIBUTES              objectAttributes;
   HANDLE                         handle;
   UCHAR                          buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION)+
                                         sizeof(ULONG)];
   PKEY_VALUE_PARTIAL_INFORMATION value = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
   ULONG                          length;
   NTSTATUS                       status;

   PAGED_CODE();

   RtlInitUnicodeString(&unicodeKey,
                        L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Pnp");

   RtlZeroMemory(&objectAttributes, sizeof(OBJECT_ATTRIBUTES));
   InitializeObjectAttributes(&objectAttributes,
                              &unicodeKey,
                              OBJ_CASE_INSENSITIVE,
                              NULL,
                              NULL);

   if (!NT_SUCCESS(ZwOpenKey(&handle,
                             KEY_QUERY_VALUE,
                             &objectAttributes))) {
      //
      // Key doesn't exist
      //
      return TRUE;
   }

   RtlInitUnicodeString(&unicodeValue, L"DisableFirmwareMapper");

   status =  ZwQueryValueKey(handle,
                             &unicodeValue,
                             KeyValuePartialInformation,
                             value,
                             sizeof(buffer),
                             &length);
   ZwClose(handle);

   if (!NT_SUCCESS(status)) {
      //
      // Value doesn't exist
      //
      return TRUE;
   }

   if (value->Type == REG_DWORD) {
      //
      // If value is non-zero don't do legacy detection
      // otherwise it's ok
      //
      return  ((ULONG) (*((PULONG)value->Data)) ? FALSE : TRUE);
   }
   return TRUE;
}



NTSTATUS
PcmciaDetectPcmciaControllers(
   IN PDRIVER_OBJECT DriverObject,
   IN PUNICODE_STRING RegistryPath
   )
/*++

Routine Description:
   Detects appropriate PCMCIA controllers both ISA & PCI based
   in the system.

Arguments:

   DriverObject    Just as passed in to DriverEntry
   RegistryPath

Return Value:
   STATUS_SUCCESS if any PCMCIA controllers were found
   STATUS_NO_SUCH_DEVICE otherwise

--*/
{
   NTSTATUS pcicIsaStatus = STATUS_UNSUCCESSFUL, tcicStatus = STATUS_UNSUCCESSFUL;

   PAGED_CODE();

   //
   // We enumerate the PCI devices first to ensure that the ISA detect
   // doesn't probe those address ports which are already claimed by
   // detected PCI devices
   //
   pcicIsaStatus = PcmciaDetectControllers(DriverObject, RegistryPath, PcicIsaDetect);

   tcicStatus = PcmciaDetectControllers(DriverObject, RegistryPath, TcicDetect);

   //
   // Indicate success if we found any controllers
   //
   return ((NT_SUCCESS(pcicIsaStatus) ||
            NT_SUCCESS(tcicStatus) ) ? STATUS_SUCCESS : STATUS_NO_SUCH_DEVICE);
}



NTSTATUS
PcmciaDetectControllers(
   IN PDRIVER_OBJECT           DriverObject,
   IN PUNICODE_STRING          RegistryPath,
   IN PPCMCIA_DETECT_ROUTINE   PcmciaDetectFn
   )
/*++

Routine Description:
   Detects PCMCIA controllers in the system and reports them. This is called
   by PcmciaDetectPcmciaControllers. This reports bus specific controllers.

Arguments:
   DriverObject, RegistryPath - See DriverEntry
   PcmciaDetectFn             - Pointer to the function that actually probes the hardware
                                to find PCMCIA controllers. So this routine can be called
                                with an ISA detect function or a PCI detect function for eg.

Return Value:
   STATUS_SUCCESS                Found one or more PCMCIA controllers
   STATUS_NO_SUCH_DEVICE         No controllers found.
   STATUS_INSUFFICIENT_RESOURCES Pool allocation failures etc.

--*/
{

   PFDO_EXTENSION            deviceExtension = NULL;
   NTSTATUS                  status = STATUS_SUCCESS;
   NTSTATUS                  detectStatus;
   BOOLEAN                   controllerDetected = FALSE;

   PAGED_CODE();

   //
   // Allocate a dummy device extension which is used by the Pcic & Tcic detect modules
   // Have to do this since the original detection code required device extensions
   // Too painful to change this structure now.
   //
   deviceExtension = ExAllocatePool(NonPagedPool, sizeof(FDO_EXTENSION));
   if (deviceExtension == NULL) {
      DebugPrint((PCMCIA_DEBUG_FAIL, "Cannot allocate pool for FDO extension\n"));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   do {

      RtlZeroMemory(deviceExtension, sizeof(FDO_EXTENSION));

      deviceExtension->RegistryPath = RegistryPath;
      deviceExtension->DriverObject = DriverObject;

      detectStatus = (*PcmciaDetectFn)(deviceExtension);

      if (detectStatus != STATUS_SUCCESS) {
         continue;
      }

      controllerDetected = TRUE;

      status = PcmciaReportDetectedDevice(deviceExtension);

      if (!NT_SUCCESS(status)) {
         DebugPrint((PCMCIA_DEBUG_FAIL, "PcmciaDetectControllers: PcmciaReportDetectedDevice "
                     "failed, status %x\n", status));
         continue;
      }

   } while (detectStatus != STATUS_NO_MORE_ENTRIES);

   ExFreePool(deviceExtension);

   if (controllerDetected) {
      return STATUS_SUCCESS;
   }

   return (STATUS_NO_SUCH_DEVICE);
}



NTSTATUS
PcmciaReportDetectedDevice(
   IN PFDO_EXTENSION DeviceExtension
   )
/*++

Routine Description:

   Reports the PCMCIA controllers detected to the IO subsystem which creates the
   madeup devnodes for these DeviceObjects.

Arguments:

   DeviceExtension - DeviceExtension for the DeviceObject (FDO) of the PCMCIA controller
                     being reported
Return Value:

--*/
{
   PDEVICE_OBJECT            pdo = NULL, fdo, lowerDevice;
   PFDO_EXTENSION            fdoExtension;
   ULONG                     pcmciaInterruptVector;
   KIRQL                     pcmciaInterruptLevel;
   KAFFINITY                 pcmciaAffinity;
   PSOCKET                   socket;
   NTSTATUS                  status;
   ULONG                     pcmciaIrq;
   ULONG                     count, ioResourceReqSize;
   PHYSICAL_ADDRESS          halMemoryAddress;
   ULONG                     addressSpace;
   PIO_RESOURCE_REQUIREMENTS_LIST  ioResourceReq=NULL;
   PIO_RESOURCE_LIST               ioResourceList;
   PIO_RESOURCE_DESCRIPTOR         ioResourceDesc;
   PCM_RESOURCE_LIST               allocatedResources;
   PCM_RESOURCE_LIST               scratchResources;
   PCM_PARTIAL_RESOURCE_DESCRIPTOR cmResourceDesc;
   BOOLEAN                   translated;
   UCHAR                     option;

   PAGED_CODE();

   //
   // Do initial setup in our "fake" device extension
   //
   PcmciaGetControllerRegistrySettings(DeviceExtension);

   DeviceExtension->Configuration.InterruptPin = 0;
   DeviceExtension->Configuration.Interrupt.u.Interrupt.Vector = 0;
   DeviceExtension->Configuration.Interrupt.u.Interrupt.Level = 0;

   count=0;
   //
   // Get an 'open' memory window
   //
   status = PcmciaAllocateOpenMemoryWindow(DeviceExtension,
                                           &DeviceExtension->PhysicalBase,
                                           &DeviceExtension->AttributeMemorySize);
   count++;

   if (DeviceExtension->Configuration.UntranslatedPortAddress) {
      count++;
   }

   ioResourceReqSize = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) + (count-1)*sizeof(IO_RESOURCE_DESCRIPTOR);

   ioResourceReq = ExAllocatePool(PagedPool, ioResourceReqSize);
   if (ioResourceReq == NULL) {
      return STATUS_INSUFFICIENT_RESOURCES;
   }
   RtlZeroMemory(ioResourceReq, ioResourceReqSize);

   ioResourceReq->ListSize = ioResourceReqSize;
   ioResourceReq->InterfaceType = Isa; // DeviceExtension->Configuration.InterfaceType;
   ioResourceReq->BusNumber = DeviceExtension->Configuration.BusNumber;
   ioResourceReq->SlotNumber= DeviceExtension->Configuration.SlotNumber;
   ioResourceReq->AlternativeLists=1;

   ioResourceList = &(ioResourceReq->List[0]);
   ioResourceList->Version  = IO_RESOURCE_LIST_VERSION;
   ioResourceList->Revision = IO_RESOURCE_LIST_REVISION;
   ioResourceList->Count    = count;

   ioResourceDesc = ioResourceList->Descriptors;

   //
   //Request IO
   //
   if (DeviceExtension->Configuration.UntranslatedPortAddress) {
       ioResourceDesc->Option = 0;
       ioResourceDesc->Type = CmResourceTypePort;
       ioResourceDesc->ShareDisposition = CmResourceShareDeviceExclusive;
       ioResourceDesc->Flags = CM_RESOURCE_PORT_IO;
       ioResourceDesc->u.Port.MinimumAddress.LowPart = (ULONG)(DeviceExtension->Configuration.UntranslatedPortAddress);
       ioResourceDesc->u.Port.MaximumAddress.LowPart = (ULONG)(DeviceExtension->Configuration.UntranslatedPortAddress+
                                                               DeviceExtension->Configuration.PortSize - 1);
       ioResourceDesc->u.Port.Length = DeviceExtension->Configuration.PortSize;
       ioResourceDesc->u.Port.Alignment =  1;
       ioResourceDesc++;
   }

   //
   // Request memory
   //
   ioResourceDesc->Option = 0;
   ioResourceDesc->Type = CmResourceTypeMemory;
   ioResourceDesc->ShareDisposition = CmResourceShareDeviceExclusive;
   ioResourceDesc->Flags = CM_RESOURCE_MEMORY_READ_WRITE;
   if (DeviceExtension->PhysicalBase.QuadPart) {
      ioResourceDesc->u.Memory.MinimumAddress = DeviceExtension->PhysicalBase;
      ioResourceDesc->u.Memory.MaximumAddress.QuadPart = DeviceExtension->PhysicalBase.QuadPart+DeviceExtension->AttributeMemorySize-1;
      ioResourceDesc->u.Memory.Length = DeviceExtension->AttributeMemorySize;
      ioResourceDesc->u.Memory.Alignment = 1;
      ioResourceDesc++;
   } else {
      //
      ioResourceDesc->u.Memory.MinimumAddress.LowPart = DeviceExtension->AttributeMemoryLow;
      ioResourceDesc->u.Memory.MaximumAddress.LowPart = DeviceExtension->AttributeMemoryHigh;
      ioResourceDesc->u.Memory.Length = DeviceExtension->AttributeMemorySize;
      switch (DeviceExtension->ControllerType) {

      case PcmciaDatabook: {
            ioResourceDesc->u.Memory.Alignment = TCIC_WINDOW_ALIGNMENT;
            break;
         }
      default: {
            ioResourceDesc->u.Memory.Alignment = PCIC_WINDOW_ALIGNMENT;
            break;
         }
      }
      ioResourceDesc++;
   }


   status = IoAssignResources(DeviceExtension->RegistryPath,
                              NULL,
                              DeviceExtension->DriverObject,
                              NULL,
                              ioResourceReq,
                              &allocatedResources
                             );

   if (!NT_SUCCESS(status)) {
      //
      // Log an event here
      //
      PcmciaLogError(DeviceExtension,  PCMCIA_NO_RESOURCES, 1, 0);

      DebugPrint((PCMCIA_DEBUG_FAIL, "PcmciaReportDetectedDevice: IoAssignResources failed status %x\n",
                  status));
      ExFreePool(ioResourceReq);
      return status;
   }


   //
   // Fish out the Memory Base allocated to this controller from the
   // nether depths of the CM_RESOURCE_LIST
   //
   count = allocatedResources->List[0].PartialResourceList.Count;
   cmResourceDesc = &(allocatedResources->List[0].PartialResourceList.PartialDescriptors[0]);

   while (count--) {
      switch (cmResourceDesc->Type) {

      case CmResourceTypeMemory: {

            DeviceExtension->PhysicalBase = cmResourceDesc->u.Memory.Start;
            DeviceExtension->AttributeMemorySize = cmResourceDesc->u.Memory.Length;

            addressSpace=0;
            translated = HalTranslateBusAddress(Isa,
                                                0,
                                                cmResourceDesc->u.Memory.Start,
                                                &addressSpace,
                                                &halMemoryAddress);
            ASSERT(translated);
            if (addressSpace) {
               DeviceExtension->AttributeMemoryBase = (PUCHAR)(halMemoryAddress.QuadPart);
               DeviceExtension->Flags &= ~PCMCIA_ATTRIBUTE_MEMORY_MAPPED;
            }
         
            else {
               DeviceExtension->AttributeMemoryBase = MmMapIoSpace(halMemoryAddress,
                                                                   cmResourceDesc->u.Memory.Length,
                                                                   FALSE);
               DeviceExtension->Flags |= PCMCIA_ATTRIBUTE_MEMORY_MAPPED;
            }
            DebugPrint((PCMCIA_DEBUG_INFO,
                        "Attribute Memory Physical Base: %x Virtual Addr: %x\n",
                        DeviceExtension->PhysicalBase,
                        DeviceExtension->AttributeMemoryBase));
            break;
         }
         // Don't bother to parse IO, it was a fixed resource requirement which we already know about
      }
      cmResourceDesc++;
   }

   //
   // Free resources so IoReportDetectedDevice can assign them for the PDO
   //
   IoAssignResources(DeviceExtension->RegistryPath,
                     NULL,
                     DeviceExtension->DriverObject,
                     NULL,
                     NULL,
                     &scratchResources
                    );

   pdo = NULL;
   status = IoReportDetectedDevice(
                DeviceExtension->DriverObject,
                InterfaceTypeUndefined,
                -1,
                -1,
                allocatedResources,
                ioResourceReq,
                FALSE,
                &pdo
            );

   ExFreePool(allocatedResources);
   ExFreePool(ioResourceReq);

   if (!NT_SUCCESS(status)) {
      DebugPrint((PCMCIA_DEBUG_FAIL, "PcmciaReportDetectedDevice: IoReportDetectedDevice failed\n"));
      return status;
   }

   //
   // Set up registry params for the madeup pdo so we'll recognize it on the next boot
   // when the PNP manager gives us an AddDevice/IRP_MN_START_DEVICE
   //
   PcmciaSetLegacyDetectedControllerType(pdo, DeviceExtension->ControllerType);

   //
   // The I/O subsystem has created the true PDO which we will use during this boot. So we
   // have to attach to this PDO, and initialize our new FDO extension to values already set
   // into our original (fake) FDO extension.
   //

   status = PcmciaAddDevice(DeviceExtension->DriverObject, pdo);

   if (!NT_SUCCESS(status)) {

      DebugPrint((PCMCIA_DEBUG_FAIL, "PcmciaReportDetectedDevice: AddDevice failed status %x\n", status));
      return status;
   }

   pdo->Flags &= ~DO_DEVICE_INITIALIZING;

   //
   // Head of list is our fdo
   //
   fdo = FdoList;
   fdoExtension = fdo->DeviceExtension;

   //
   // Copy in the rest of the config. from the DeviceExtension
   //
   fdoExtension->SocketList = DeviceExtension->SocketList;
   fdoExtension->Configuration = DeviceExtension->Configuration;
   fdoExtension->PhysicalBase = DeviceExtension->PhysicalBase;
   fdoExtension->AttributeMemoryBase = DeviceExtension->AttributeMemoryBase;
   fdoExtension->AttributeMemorySize = DeviceExtension->AttributeMemorySize;
   fdoExtension->Flags = DeviceExtension->Flags;

   // Reinitialize the socket's device extensions
   //
   for (socket = fdoExtension->SocketList; socket!=NULL; socket=socket->NextSocket) {
      socket->DeviceExtension = fdoExtension;
   }

   fdoExtension->Flags |= PCMCIA_DEVICE_STARTED;
   //
   // This is legacy detected..
   //
   fdoExtension->Flags |= PCMCIA_DEVICE_LEGACY_DETECTED;

   status=PcmciaStartPcmciaController(fdo);

   if (!NT_SUCCESS(status)) {
      fdoExtension->Flags &= ~PCMCIA_DEVICE_STARTED;
   }

   return status;
}



NTSTATUS
PcmciaAllocateOpenMemoryWindow(
   IN PFDO_EXTENSION DeviceExtension,
   IN PPHYSICAL_ADDRESS PhysicalAddress,
   IN PULONG PhysicalAddressSize
   )

/*++

Routine Description:

    Search the 640K to 1MB region for an open area to be used
    for mapping PCCARD attribute memory.

Arguments:


Return Value:

    A physical address for the window to the card or zero meaning
    there is no opening.

--*/

{
#define NUMBER_OF_TEST_BYTES 25
   PHYSICAL_ADDRESS physicalMemoryAddress;
   PHYSICAL_ADDRESS halMemoryAddress;
   BOOLEAN          translated;
   ULONG            untranslatedAddress;
   PUCHAR           memoryAddress;
   PUCHAR           bogus;
   ULONG            addressSpace;
   ULONG            index;
   UCHAR            memory[NUMBER_OF_TEST_BYTES];
   PCM_RESOURCE_LIST cmResourceList = NULL;
   PCM_PARTIAL_RESOURCE_LIST cmPartialResourceList;
   PCM_PARTIAL_RESOURCE_DESCRIPTOR cmResourceDesc;
   BOOLEAN conflict = TRUE;
   NTSTATUS                        status;
   ULONG             windowSize, windowAlignment;

   PAGED_CODE();


   cmResourceList = ExAllocatePool(PagedPool, sizeof(CM_RESOURCE_LIST));
   if (!cmResourceList) {
      return STATUS_INSUFFICIENT_RESOURCES;
   }
   RtlZeroMemory(cmResourceList, sizeof(CM_RESOURCE_LIST));
   cmResourceList->Count = 1;
   cmResourceList->List[0].InterfaceType = Isa;
   cmPartialResourceList = &(cmResourceList->List[0].PartialResourceList);
   cmPartialResourceList->Version  = 1;
   cmPartialResourceList->Revision = 1;
   cmPartialResourceList->Count    = 1;
   cmResourceDesc = cmPartialResourceList->PartialDescriptors;
   cmResourceDesc->Type = CmResourceTypeMemory;
   cmResourceDesc->ShareDisposition = CmResourceShareDeviceExclusive;
   cmResourceDesc->Flags = CM_RESOURCE_MEMORY_READ_WRITE;

   //
   // Size of the attr. memory window
   //
   switch (DeviceExtension->ControllerType) {

   case PcmciaDatabook: {
         windowSize      = TCIC_WINDOW_SIZE;
         windowAlignment = TCIC_WINDOW_ALIGNMENT;
         break;
      }

   default: {
         windowSize = PCIC_WINDOW_SIZE;
         windowAlignment = PCIC_WINDOW_ALIGNMENT;
         break;
      }
   }

   for (untranslatedAddress = DeviceExtension->AttributeMemoryLow;
       untranslatedAddress < DeviceExtension->AttributeMemoryHigh;
       untranslatedAddress += windowAlignment) {

      if (untranslatedAddress == 0xc0000) {

         //
         // This is VGA.  Keep this test if the for loop should
         // ever change.
         //

         continue;
      }

      //
      // Check if it's available
      //
      cmResourceDesc->u.Memory.Start.LowPart = untranslatedAddress;
      cmResourceDesc->u.Memory.Length = windowSize;

      status=IoReportResourceForDetection(
                                         DeviceExtension->DriverObject,
                                         cmResourceList,
                                         sizeof(CM_RESOURCE_LIST),
                                         NULL,
                                         NULL,
                                         0,
                                         &conflict);
      if (!NT_SUCCESS(status) || conflict) {
         //
         // This range's already taken. Move on to the next
         //
         continue;
      }

      addressSpace = 0;
      physicalMemoryAddress.LowPart = untranslatedAddress;
      physicalMemoryAddress.HighPart = 0;

      translated = HalTranslateBusAddress(Isa,
                                          0,
                                          physicalMemoryAddress,
                                          &addressSpace,
                                          &halMemoryAddress);

      if (!translated) {

         //
         // HAL doesn't like this translation
         //

         continue;
      }
      if (addressSpace) {
         memoryAddress = (PUCHAR)(halMemoryAddress.QuadPart);
      } else {
         memoryAddress = MmMapIoSpace(halMemoryAddress, windowSize, FALSE);
      }

      //
      // Test the memory window to determine if it is a BIOS, video
      // memory, or open memory.  Only want to keep the window if it
      // is not being used by something else.
      //

      for (index = 0; index < NUMBER_OF_TEST_BYTES; index++) {
         memory[index] = READ_REGISTER_UCHAR(memoryAddress + index);
         if (index) {
            if (memory[index] != memory[index - 1]) {
               break;
            }
         }
      }

      if (index == NUMBER_OF_TEST_BYTES) {

         //
         // There isn't a BIOS here
         //

         UCHAR memoryPattern[NUMBER_OF_TEST_BYTES];
         BOOLEAN changed = FALSE;

         //
         // Check for video memory - open memory should always remain
         // the same regardless what the changes are.  Change the
         // pattern previously found.
         //

         for (index = 0; index < NUMBER_OF_TEST_BYTES; index++) {
            memoryPattern[index] = ~memory[index];
            WRITE_REGISTER_UCHAR(memoryAddress + index,
                                 memoryPattern[index]);
         }

         //
         // See if the pattern in memory changed.
         // Some system exhibit a problem where the memory pattern
         // seems to be cached.  If this code is debugged it will
         // work as expected, but if it is run normally it will
         // always return that the memory changed.  This random
         // wandering seems to remove this problem.
         //

         for (index = 0; index < NUMBER_OF_TEST_BYTES; index++) {
            memoryPattern[index] = 0;
         }
         bogus = ExAllocatePool(PagedPool, 64 * 1024);

         if (bogus) {
            for (index = 0; index < 64 * 1024; index++) {
               bogus[index] = 0;
            }
            ExFreePool(bogus);
         }

         //
         // Now go off and do the actual check to see if the memory
         // changed.
         //

         for (index = 0; index < NUMBER_OF_TEST_BYTES; index++) {

            if ((memoryPattern[index] = READ_REGISTER_UCHAR(memoryAddress + index)) != memory[index]) {

               //
               // It changed - this is not an area of open memory
               //

               changed = TRUE;
            }
            WRITE_REGISTER_UCHAR(memoryAddress + index,
                                 memory[index]);
         }

         if (!changed) {

            //
            // Area isn't a BIOS and didn't change when written.
            // Use this region for the memory window to PCMCIA
            // attribute memory.
            //

            PhysicalAddress->LowPart = untranslatedAddress;
            PhysicalAddress->HighPart = 0;
            *PhysicalAddressSize = windowSize;
            if (!addressSpace) {
               MmUnmapIoSpace(memoryAddress, windowSize);
            }
            ExFreePool(cmResourceList);
            return STATUS_SUCCESS;
         }
      }

      if (!addressSpace) {
         MmUnmapIoSpace(memoryAddress, windowSize);
      }
   }
   ExFreePool(cmResourceList);
   return STATUS_UNSUCCESSFUL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\pcmcibus\debug.c ===
/*++      

Copyright (c) 1997 Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module provides debugging support.

Author:

    Neil Sandlin (neilsa) 10-Aug-98
      - code merged from mf.sys and pcmcia.sys

Revision History:


--*/


#include "pch.h"

//
// Get mappings from status codes to strings
//

#include <ntstatus.dbg>

#undef MAP
#define MAP(_Value) { (_Value), #_Value }
#define END_STRING_MAP  { 0xFFFFFFFF, NULL }
#if DBG

typedef struct _DBG_MASK_STRING {
   ULONG Mask;
   PUCHAR String;
} DBG_MASK_STRING, *PDBG_MASK_STRING;


DBG_MASK_STRING MaskStrings[] = {
   PCMCIA_DEBUG_FAIL,      "ERR",
   PCMCIA_DEBUG_INFO,      "INF",
   PCMCIA_DEBUG_PNP,       "PNP", 
   PCMCIA_DEBUG_POWER,     "PWR", 
   PCMCIA_DEBUG_SOCKET,    "SKT",
   PCMCIA_DEBUG_CONFIG,    "CFG",
   PCMCIA_DEBUG_TUPLES,    "TPL", 
   PCMCIA_DEBUG_RESOURCES, "RES", 
   PCMCIA_DEBUG_ENUM,      "ENU", 
   PCMCIA_DEBUG_INTERFACE, "IFC", 
   PCMCIA_DEBUG_IOCTL,     "IOC",
   PCMCIA_DEBUG_DPC,       "DPC",
   PCMCIA_DEBUG_ISR,       "ISR",
   PCMCIA_PCCARD_READY,    "PCR", 
   PCMCIA_DEBUG_DETECT,    "DET", 
   PCMCIA_COUNTERS,        "CNT",
   PCMCIA_DEBUG_IRQMASK,   "MSK",
   PCMCIA_DUMP_SOCKET,     "DSK",
   0, NULL
   };


PPCMCIA_STRING_MAP PcmciaDbgStatusStringMap = (PPCMCIA_STRING_MAP) ntstatusSymbolicNames;

PCMCIA_STRING_MAP PcmciaDbgPnpIrpStringMap[] = {

    MAP(IRP_MN_START_DEVICE),
    MAP(IRP_MN_QUERY_REMOVE_DEVICE),
    MAP(IRP_MN_REMOVE_DEVICE),
    MAP(IRP_MN_CANCEL_REMOVE_DEVICE),
    MAP(IRP_MN_STOP_DEVICE),
    MAP(IRP_MN_QUERY_STOP_DEVICE),
    MAP(IRP_MN_CANCEL_STOP_DEVICE),
    MAP(IRP_MN_QUERY_DEVICE_RELATIONS),
    MAP(IRP_MN_QUERY_INTERFACE),
    MAP(IRP_MN_QUERY_CAPABILITIES),
    MAP(IRP_MN_QUERY_RESOURCES),
    MAP(IRP_MN_QUERY_RESOURCE_REQUIREMENTS),
    MAP(IRP_MN_QUERY_DEVICE_TEXT),
    MAP(IRP_MN_FILTER_RESOURCE_REQUIREMENTS),
    MAP(IRP_MN_READ_CONFIG),
    MAP(IRP_MN_WRITE_CONFIG),
    MAP(IRP_MN_EJECT),
    MAP(IRP_MN_SET_LOCK),
    MAP(IRP_MN_QUERY_ID),
    MAP(IRP_MN_QUERY_PNP_DEVICE_STATE),
    MAP(IRP_MN_QUERY_BUS_INFORMATION),
    MAP(IRP_MN_DEVICE_USAGE_NOTIFICATION),
    MAP(IRP_MN_SURPRISE_REMOVAL),
    MAP(IRP_MN_QUERY_LEGACY_BUS_INFORMATION),
    END_STRING_MAP
};


PCMCIA_STRING_MAP PcmciaDbgPoIrpStringMap[] = {

    MAP(IRP_MN_WAIT_WAKE),
    MAP(IRP_MN_POWER_SEQUENCE),
    MAP(IRP_MN_SET_POWER),
    MAP(IRP_MN_QUERY_POWER),
    END_STRING_MAP
};



PCMCIA_STRING_MAP PcmciaDbgDeviceRelationStringMap[] = {
    
    MAP(BusRelations),
    MAP(EjectionRelations),
    MAP(PowerRelations),
    MAP(RemovalRelations),
    MAP(TargetDeviceRelation),
    END_STRING_MAP
    
};

PCMCIA_STRING_MAP PcmciaDbgSystemPowerStringMap[] = {
    
    MAP(PowerSystemUnspecified),
    MAP(PowerSystemWorking),
    MAP(PowerSystemSleeping1),
    MAP(PowerSystemSleeping2),
    MAP(PowerSystemSleeping3),
    MAP(PowerSystemHibernate),
    MAP(PowerSystemShutdown),
    MAP(PowerSystemMaximum),
    END_STRING_MAP

};

PCMCIA_STRING_MAP PcmciaDbgDevicePowerStringMap[] = {
    
    MAP(PowerDeviceUnspecified),
    MAP(PowerDeviceD0),
    MAP(PowerDeviceD1),
    MAP(PowerDeviceD2),
    MAP(PowerDeviceD3),
    MAP(PowerDeviceMaximum),
    END_STRING_MAP

};

PCMCIA_STRING_MAP PcmciaDbgPdoPowerWorkerStringMap[] = {
    
    MAP(PPW_Stopped),
    MAP(PPW_Exit),
    MAP(PPW_InitialState),
    MAP(PPW_PowerUp),
    MAP(PPW_PowerUpComplete),
    MAP(PPW_PowerDown),
    MAP(PPW_PowerDownComplete),
    MAP(PPW_SendIrpDown),
    MAP(PPW_16BitConfigure),
    MAP(PPW_CardBusRefresh),
    MAP(PPW_CardBusDelay),

    END_STRING_MAP
};

PCMCIA_STRING_MAP PcmciaDbgFdoPowerWorkerStringMap[] = {
    
    MAP(FPW_Stopped),
    MAP(FPW_BeginPowerDown),
    MAP(FPW_PowerDown),
    MAP(FPW_PowerDownSocket),
    MAP(FPW_PowerDownComplete),
    MAP(FPW_BeginPowerUp),
    MAP(FPW_PowerUp),
    MAP(FPW_PowerUpSocket),
    MAP(FPW_PowerUpSocket2),
    MAP(FPW_PowerUpSocketVerify),
    MAP(FPW_PowerUpSocketComplete),
    MAP(FPW_PowerUpComplete),
    MAP(FPW_SendIrpDown),
    MAP(FPW_CompleteIrp),
    END_STRING_MAP
};

PCMCIA_STRING_MAP PcmciaDbgSocketPowerWorkerStringMap[] = {
    
    MAP(SPW_Stopped),
    MAP(SPW_Exit),
    MAP(SPW_RequestPower),
    MAP(SPW_ReleasePower),
    MAP(SPW_SetPowerOn),
    MAP(SPW_SetPowerOff),
    MAP(SPW_ResetCard),
    MAP(SPW_Deconfigure),

    END_STRING_MAP
};

PCMCIA_STRING_MAP PcmciaDbgConfigurationWorkerStringMap[] = {
    
    MAP(CW_Stopped),
    MAP(CW_InitialState),
    MAP(CW_ResetCard),
    MAP(CW_Phase1),
    MAP(CW_Phase2),
    MAP(CW_Phase3),
    MAP(CW_Exit),

    END_STRING_MAP
};


PCMCIA_STRING_MAP PcmciaDbgTupleStringMap[] = {

    MAP(CISTPL_NULL),
    MAP(CISTPL_DEVICE),
    MAP(CISTPL_INDIRECT),
    MAP(CISTPL_CONFIG_CB),
    MAP(CISTPL_CFTABLE_ENTRY_CB),
    MAP(CISTPL_LONGLINK_MFC),
    MAP(CISTPL_CHECKSUM),
    MAP(CISTPL_LONGLINK_A),
    MAP(CISTPL_LONGLINK_C),
    MAP(CISTPL_LINKTARGET),
    MAP(CISTPL_NO_LINK),
    MAP(CISTPL_VERS_1),
    MAP(CISTPL_ALTSTR),
    MAP(CISTPL_DEVICE_A),
    MAP(CISTPL_JEDEC_C),
    MAP(CISTPL_JEDEC_A),
    MAP(CISTPL_CONFIG),
    MAP(CISTPL_CFTABLE_ENTRY),
    MAP(CISTPL_DEVICE_OC),
    MAP(CISTPL_DEVICE_OA),
    MAP(CISTPL_GEODEVICE),
    MAP(CISTPL_GEODEVICE_A),
    MAP(CISTPL_MANFID),
    MAP(CISTPL_FUNCID),
    MAP(CISTPL_FUNCE),
    MAP(CISTPL_VERS_2),
    MAP(CISTPL_FORMAT),
    MAP(CISTPL_GEOMETRY),
    MAP(CISTPL_BYTEORDER),
    MAP(CISTPL_DATE),
    MAP(CISTPL_BATTERY),
    MAP(CISTPL_ORG),
    MAP(CISTPL_LONGLINK_CB),
    MAP(CISTPL_END),

    END_STRING_MAP
};


PCMCIA_STRING_MAP PcmciaDbgWakeStateStringMap[] = {
    
    MAP(WAKESTATE_DISARMED),
    MAP(WAKESTATE_WAITING),
    MAP(WAKESTATE_WAITING_CANCELLED),
    MAP(WAKESTATE_ARMED),
    MAP(WAKESTATE_ARMING_CANCELLED),
    MAP(WAKESTATE_COMPLETING),

    END_STRING_MAP
};


PCHAR
PcmciaDbgLookupString(
    IN PPCMCIA_STRING_MAP Map,
    IN ULONG Id
    )

/*++

Routine Description:

    Looks up the string associated with Id in string map Map
    
Arguments:

    Map - The string map
    
    Id - The id to lookup

Return Value:

    The string
        
--*/

{
    PPCMCIA_STRING_MAP current = Map;
    
    while(current->Id != 0xFFFFFFFF) {

        if (current->Id == Id) {
            return current->String;
        }
        
        current++;
    }
    
    return "** UNKNOWN **";
}


VOID
PcmciaDebugPrint(
                ULONG  DebugMask,
                PCCHAR DebugMessage,
                ...
                )

/*++

Routine Description:

    Debug print for the PCMCIA enabler.

Arguments:

    Check the mask value to see if the debug message is requested.

Return Value:

    None

--*/

{
   va_list ap;
   char    buffer[256];
   ULONG i = 0;

   va_start(ap, DebugMessage);

   strcpy(buffer, "Pcmcia ");
   
   for (i = 0; (MaskStrings[i].Mask != 0); i++) {
      if (DebugMask & MaskStrings[i].Mask) {
         strcat(buffer, MaskStrings[i].String);
         strcat(buffer, ": ");
         break;
      }
   }
   
   if (MaskStrings[i].Mask == 0) {
         strcat(buffer, "???: ");
   }         

   if (DebugMask & PcmciaDebugMask) {
      vsprintf(&buffer[12], DebugMessage, ap);
      DbgPrint(buffer);
   }

   va_end(ap);

} // end PcmciaDebugPrint()


VOID
PcmciaDumpSocket(
   IN PSOCKET Socket
   )
{
   UCHAR index;
#define MAX_SOCKET_INDEX 64
   UCHAR buffer[MAX_SOCKET_INDEX];
   
   for (index = 0; index < MAX_SOCKET_INDEX; index++) {
      buffer[index] = PcicReadSocket(Socket, index);
   }

   for (index = 0; index < 8; index++) {
      DebugPrint((PCMCIA_DEBUG_INFO,"%.02x: %.02x\n", index, buffer[index]));
   }      
   
   for (index = 8; index < MAX_SOCKET_INDEX; index+=2) {
      USHORT data;
      
      data = buffer[index] | (buffer[index+1]<<8);
      DebugPrint((PCMCIA_DEBUG_INFO,"%.02x: %.04x\n", index, data));
   }      
}   
   

TRACE_ENTRY GlobalTraceEntry;

VOID
PcmciaWriteTraceEntry(
   IN PSOCKET Socket,
   IN ULONG Context
   )
/*++

Routine Description:


Arguments:


Return Value:

    None

--*/

{
   UCHAR i;
   PTRACE_ENTRY pEntry = &GlobalTraceEntry;
   
   pEntry->Context = Context;

   if (CardBusExtension(Socket->DeviceExtension)) {   
      for (i = 0; i < 5; i++) {
         pEntry->CardBusReg[i] = CBReadSocketRegister(Socket, (UCHAR)(i*sizeof(ULONG)));
      }         
   }

   for (i = 0; i < 70; i++) {
      pEntry->ExcaReg[i] = PcicReadSocket(Socket, i);
   }      
}   



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\pcmcibus\db.c ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    db.c

Abstract:

    This module contains the code that contains
    Databook carbus controller specific initialization and
    other dispatches

Author:

    Ravisankar Pudipeddi (ravisp) 1-Nov-97


Environment:

    Kernel mode

Revision History :


--*/

#include "pch.h"



VOID
DBInitialize(IN PFDO_EXTENSION FdoExtension)
/*++

Routine Description:

    Initialize Databook cardbus controllers

Arguments:

    FdoExtension - Pointer to the device extension for the controller FDO

Return Value:

    None
--*/
{

   PcicWriteSocket(FdoExtension->SocketList,
                   PCIC_INTERRUPT,
           (UCHAR) (PcicReadSocket(FdoExtension->SocketList, PCIC_INTERRUPT)
                    | IGC_INTR_ENABLE));
}


BOOLEAN
DBSetZV(
   IN PSOCKET Socket,
   IN BOOLEAN Enable
   )
{

   if (Enable) {
      PcicWriteSocket(Socket, PCIC_DBK_ZV_ENABLE, DBK_ZVE_MM_MODE);
   } else {
      PcicWriteSocket(Socket, PCIC_DBK_ZV_ENABLE, DBK_ZVE_STANDARD_MODE);
   }

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\pcmcibus\fdopnp.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    fdopnp.c

Abstract:

    This module contains the code that handles PNP irps for pcmcia bus driver
    targeted towards the FDO's (for the pcmcia controller object)

Author:

    Ravisankar Pudipeddi (ravisp) Oct 15 1996
    Neil Sandlin (neilsa) June 1 1999

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"

//
// Internal References
//

NTSTATUS
PcmciaFdoFilterResourceRequirements(
   IN  PDEVICE_OBJECT Fdo,
   IN  PIRP           Irp
   );

NTSTATUS
PcmciaFdoGetHardwareIds(
   IN PDEVICE_OBJECT Fdo,
   OUT PUNICODE_STRING HardwareIds
   );

NTSTATUS
PcmciaFdoStartDevice(
   IN  PDEVICE_OBJECT Fdo,
   IN  PIRP           Irp,
   OUT BOOLEAN        *PassedDown,
   OUT BOOLEAN        *NeedsRecompletion
   );

NTSTATUS
PcmciaFdoStopDevice(
   IN  PDEVICE_OBJECT Fdo,
   IN  PIRP           Irp,
   OUT BOOLEAN        *PassedDown,
   OUT BOOLEAN        *NeedsRecompletion
   );

NTSTATUS
PcmciaFdoRemoveDevice(
   IN PDEVICE_OBJECT Fdo,
   IN PIRP  Irp
   );

VOID
PcmciaCleanupFdo(
   IN PFDO_EXTENSION FdoExtension
   );

NTSTATUS
PcmciaFdoDeviceCapabilities(
   IN  PDEVICE_OBJECT Fdo,
   IN  PIRP           Irp,
   OUT BOOLEAN        *PassedDown,
   OUT BOOLEAN        *NeedsRecompletion
   );

NTSTATUS
PcmciaAreCardBusCardsSupported(
   IN PFDO_EXTENSION FdoExtension
   );

NTSTATUS
PcmciaFdoGetAssignedResources(
   IN PCM_RESOURCE_LIST ResourceList,
   IN PCM_RESOURCE_LIST TranslatedResourceList,
   IN PFDO_EXTENSION    DeviceExtension
   );


#ifdef ALLOC_PRAGMA
   #pragma alloc_text(PAGE, PcmciaFdoPnpDispatch)
   #pragma alloc_text(PAGE, PcmciaFdoGetHardwareIds)
   #pragma alloc_text(PAGE, PcmciaFdoStartDevice)
   #pragma alloc_text(PAGE, PcmciaFdoStopDevice)
   #pragma alloc_text(PAGE, PcmciaFdoRemoveDevice)
   #pragma alloc_text(PAGE, PcmciaFdoFilterResourceRequirements)
   #pragma alloc_text(PAGE, PcmciaFdoGetAssignedResources)
   #pragma alloc_text(PAGE, PcmciaFdoDeviceCapabilities)
   #pragma alloc_text(PAGE, PcmciaAreCardBusCardsSupported)
#endif



NTSTATUS
PcmciaFdoPnpDispatch (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   )

/*++

Routine Description:

    PNP/Power IRPs dispatch routine for the PCMCIA bus controller

Arguments:

    DeviceObject - Pointer to the device object.
    Irp - Pointer to the IRP

Return Value:

    Status

--*/
{

   PIO_STACK_LOCATION nextIrpStack;
   PIO_STACK_LOCATION irpStack          = IoGetCurrentIrpStackLocation(Irp);
   PFDO_EXTENSION     deviceExtension   = DeviceObject->DeviceExtension;
   NTSTATUS           status            = Irp->IoStatus.Status;
   BOOLEAN            PassedDown        = FALSE;
   BOOLEAN            NeedsReCompletion = FALSE;

   PAGED_CODE();

#if DBG
   if (irpStack->MinorFunction > IRP_MN_PNP_MAXIMUM_FUNCTION) {
      DebugPrint((PCMCIA_DEBUG_PNP, "fdo %08x irp %08x - Unknown PNP irp\n",
                                     DeviceObject, irpStack->MinorFunction));
   } else {
      DebugPrint((PCMCIA_DEBUG_PNP, "fdo %08x irp %08x --> %s\n",
                    DeviceObject, Irp, PNP_IRP_STRING(irpStack->MinorFunction)));
   }
#endif

   switch (irpStack->MinorFunction) {

   case IRP_MN_START_DEVICE: {
         status = PcmciaFdoStartDevice(DeviceObject,
                                       Irp,
                                       &PassedDown,
                                       &NeedsReCompletion);
         break;
      }

   case IRP_MN_QUERY_STOP_DEVICE: {
         status = STATUS_SUCCESS;
         break;
      }

   case IRP_MN_CANCEL_STOP_DEVICE: {
         status = STATUS_SUCCESS;
         break;
      }

   case IRP_MN_STOP_DEVICE: {
         status = PcmciaFdoStopDevice(DeviceObject,
                                      Irp,
                                      &PassedDown,
                                      &NeedsReCompletion);

         break;
      }

   case IRP_MN_QUERY_DEVICE_RELATIONS: {

         //
         // Return the list of devices on the bus
         //

         status = PcmciaDeviceRelations(
                                       DeviceObject,
                                       Irp,
                                       irpStack->Parameters.QueryDeviceRelations.Type,
                                       (PDEVICE_RELATIONS *) &Irp->IoStatus.Information
                                       );
         break;
      }

   case IRP_MN_FILTER_RESOURCE_REQUIREMENTS: {
         status = PcmciaFdoFilterResourceRequirements(DeviceObject, Irp);
         PassedDown = TRUE;
         NeedsReCompletion = TRUE;
         break;
      }

   case IRP_MN_QUERY_REMOVE_DEVICE: {
         status = STATUS_SUCCESS;
         break;
      }

   case IRP_MN_CANCEL_REMOVE_DEVICE: {
         status = STATUS_SUCCESS;
         break;
      }

   case IRP_MN_REMOVE_DEVICE:{
         status = PcmciaFdoRemoveDevice(DeviceObject, Irp);
         PassedDown = TRUE ;
         NeedsReCompletion = TRUE ;
         break;
      }

   case IRP_MN_SURPRISE_REMOVAL: {
         PcmciaFdoStopDevice(DeviceObject, NULL, NULL, NULL);
         status = STATUS_SUCCESS;
         break;
      }

   case IRP_MN_QUERY_ID: {

         UNICODE_STRING unicodeId;

         if (deviceExtension->Flags & PCMCIA_DEVICE_LEGACY_DETECTED) {

            RtlInitUnicodeString(&unicodeId, NULL);

            switch (irpStack->Parameters.QueryId.IdType) {

            case BusQueryHardwareIDs: {

                  DebugPrint((PCMCIA_DEBUG_INFO, " Hardware Ids for fdo %x\n", DeviceObject));
                  status = PcmciaFdoGetHardwareIds(DeviceObject, &unicodeId);

                  if (NT_SUCCESS(status)) {
                     Irp->IoStatus.Information = (ULONG_PTR) unicodeId.Buffer;
                  }
                  break;
               }
            }
         }
         break;
      }

   case IRP_MN_QUERY_CAPABILITIES: {
         status = PcmciaFdoDeviceCapabilities(DeviceObject,
                                              Irp,
                                              &PassedDown,
                                              &NeedsReCompletion);
         break;
      }

   case IRP_MN_QUERY_LEGACY_BUS_INFORMATION:
         //
         // If this FDO represents a CardBus bridge, we pass this irp down
         // to the PCI PDO which will fill in the PCI bus type and number,
         // otherwise we fail the IRP.
         //

         if (!CardBusExtension(deviceExtension)) {
             status = STATUS_NOT_IMPLEMENTED;
         }

         //
         // if status is still STATUS_NOT_SUPPORTED, then later code will pass
         // this irp down the stack.
         //
         break;

   default: {
         DebugPrint((PCMCIA_DEBUG_PNP, "fdo %08x irp %08x - Skipping unsupported irp\n", DeviceObject, Irp));
         break;
      }
   }


   if (!PassedDown) {
       //
       // Set the IRP status only if we set it to something other than
       // STATUS_NOT_SUPPORTED.
       //
       if (status != STATUS_NOT_SUPPORTED) {

           Irp->IoStatus.Status = status ;
       }
       //
       // Pass down if success or STATUS_NOT_SUPPORTED. Otherwise, Complete.
       //
       if (NT_SUCCESS(status) || (status == STATUS_NOT_SUPPORTED)) {

           DebugPrint((PCMCIA_DEBUG_PNP, "fdo %08x irp %08x pass %s %08x\n",
                                               DeviceObject, Irp,
                                               STATUS_STRING(Irp->IoStatus.Status), Irp->IoStatus.Status));
           //
           // Below macro fills status with return of IoCallDriver. It does
           // not change the Irps status in any way.
           //
           PcmciaSkipCallLowerDriver(status, deviceExtension->LowerDevice, Irp);

       } else {
           DebugPrint((PCMCIA_DEBUG_PNP, "fdo %08x irp %08x comp %s %08x\n",
                                               DeviceObject, Irp,
                                               STATUS_STRING(status), status));
           IoCompleteRequest(Irp, IO_NO_INCREMENT);
       }

   } else if (NeedsReCompletion) {
       //
       // Set the IRP status only if we set it to something other than
       // STATUS_NOT_SUPPORTED.
       //
       if (status != STATUS_NOT_SUPPORTED) {

           Irp->IoStatus.Status = status ;
       }

       status = Irp->IoStatus.Status ;
       DebugPrint((PCMCIA_DEBUG_PNP, "fdo %08x irp %08x comp %s %08x\n",
                                           DeviceObject, Irp,
                                           STATUS_STRING(status), status));
       IoCompleteRequest(Irp, IO_NO_INCREMENT);
   }

   return status ;
}



NTSTATUS
PcmciaFdoDeviceCapabilities(
   IN  PDEVICE_OBJECT Fdo,
   IN  PIRP           Irp,
   OUT BOOLEAN        *PassedDown,
   OUT BOOLEAN        *NeedsRecompletion
   )
/*++

Routine Description
   Records the device capabilities of this pcmcia controller,
   so  1. they can be used in the power management for the controller
   and 2. they can be used for determining the capabilities of the
          child pc-card PDO's of this pcmcia controller.
   If this is legacy detected pcmcia controller (ISA-based), the pdo for
   the pcmcia controller is a dummy madeup device - hence  the capabilities
   are filled in by ourselves.
   Otherwise, the capabilities are obtained by sending down the Irp
   to the parent bus.
   In either case, the capabilities are cached in the device extension of
   the pcmcia controller for future use.

Arguments

   Fdo               - Pointer to functional device object of the pcmcia
                       controller
   Irp               - Pointer to the i/o request packet
   PassedDown        - Contains FALSE on entry, which means caller must
                       complete or pass down irp based on status. If set
                       to TRUE, Irp may need to be re-completed...
   NeedsRecompletion - ...In which case this parameter will be checked

Return Value

   STATUS_SUCCESS                       Capabilities returned
   STATUS_INSUFFICIENT_RESOURCES        Could not allocate memory to cache the capabilities

--*/
{
   PFDO_EXTENSION fdoExtension;
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
   PDEVICE_CAPABILITIES capabilities;
   NTSTATUS       status;

   PAGED_CODE();

   capabilities = irpStack->Parameters.DeviceCapabilities.Capabilities;
   fdoExtension = Fdo->DeviceExtension;

   if (fdoExtension->Flags & PCMCIA_DEVICE_LEGACY_DETECTED) {

      //
      // This is a madeup devnode (ISA based PCMCIA controller).
      // Fill in the capabilities ourselves
      //
      RtlZeroMemory(capabilities,
                    sizeof(DEVICE_CAPABILITIES));
      //
      // Non removable, non ejectable
      //
      capabilities->Removable      = FALSE;
      capabilities->UniqueID       = FALSE;
      capabilities->EjectSupported = FALSE;
      //
      // Address & number need work..
      //
      capabilities->Address  = -1;
      capabilities->UINumber = -1;
      //
      // We cannot power down this controller
      //
      capabilities->DeviceState[PowerSystemSleeping1] = PowerDeviceD0;
      capabilities->DeviceState[PowerSystemSleeping2] = PowerDeviceD0;
      capabilities->DeviceState[PowerSystemSleeping3] = PowerDeviceD0;
      capabilities->DeviceState[PowerSystemHibernate] = PowerDeviceD3;
      //
      // Obviously wake is not supported on this legacy detected
      // piece of xxxx
      //
      capabilities->SystemWake = PowerSystemUnspecified;
      capabilities->DeviceWake = PowerDeviceUnspecified;
      capabilities->D1Latency = 0;
      capabilities->D2Latency = 0;
      capabilities->D3Latency = 0;
      status = STATUS_SUCCESS;
   } else {

      //
      // Either a PCI-PCMCIA bridge or PCI-Cardbus bridge
      // Send this down the stack to obtain the capabilities
      //
      ASSERT (fdoExtension->LowerDevice != NULL);
      
      status = PcmciaIoCallDriverSynchronous(fdoExtension->LowerDevice, Irp);

      *PassedDown        = TRUE ;
      *NeedsRecompletion = TRUE ;
   }

   if (NT_SUCCESS(status)) {
   
      //
      // NOTE: HACKHACK:
      //
      // Here we provide an option to override the device wake of the pcmcia controller.
      // There are several controllers, notably TI 12xx controllers, which say they
      // can wake from D3, but really can effectively only do WOL from D2. That's because they
      // turn of socket power when put into D3. They fixed this on the TI 14xx line.
      //
      // So here we update the device wake field, and potentially the device states from the BIOS.
      // Note that this has to be used carefully, and only override a particular BIOS's settings
      // where it has been verified the device still works at the lower (more awake) device state.
      //   
      if (PcmciaControllerDeviceWake) {
         if (PcmciaControllerDeviceWake < capabilities->DeviceWake) {
            capabilities->DeviceWake = PcmciaControllerDeviceWake;
         }            
         if (PcmciaControllerDeviceWake < capabilities->DeviceState[PowerSystemSleeping1]) {
            capabilities->DeviceState[PowerSystemSleeping1] = PcmciaControllerDeviceWake;
         }            
         if (PcmciaControllerDeviceWake < capabilities->DeviceState[PowerSystemSleeping2]) {
            capabilities->DeviceState[PowerSystemSleeping2] = PcmciaControllerDeviceWake;
         }            
         if (PcmciaControllerDeviceWake < capabilities->DeviceState[PowerSystemSleeping3]) {
            capabilities->DeviceState[PowerSystemSleeping3] = PcmciaControllerDeviceWake;
         }
      }      
   
      //
      // Cache the device capabilities in the device extension
      // for this pcmcia controller.
      //
      RtlCopyMemory(&fdoExtension->DeviceCapabilities,
                    capabilities,
                    sizeof(DEVICE_CAPABILITIES));

   } else {

      RtlZeroMemory(&fdoExtension->DeviceCapabilities, sizeof(DEVICE_CAPABILITIES));
   
   }

   return status;
}



NTSTATUS
PcmciaFdoFilterResourceRequirements(
   IN PDEVICE_OBJECT Fdo,
   IN PIRP           Irp
   )
/*++

Routine Description

    Filters Resource requirements for PCMCIA controllers generated
    by the bus driver controlling the PDO for the PCMCIA controller.
    Currently adds memory range as an additional resource requirement
    since the BAR doesn't specify this

    Note for CardBus controllers:
    It is necessary to request an attribute memory window here for
    reading CIS of 16-bit PC-Cards - we need a 24 bit address for that,
    and this is the most elegant way of doing it - instead of
    special casing it in PCI driver

Arguments

    DeviceExtension - Pointer to extension for the PCMCIA controller in question
    IoReqList       - Pointer the the original resource requiremnts ejected by
                      the bus driver
    FilteredRequirements - Pointer to the filtered resource req. list will be returned
                           in this variable

Return Value:

    STATUS_SUCCESS  if filtering is successful
    Any other status - could not filter

--*/
{

   PFDO_EXTENSION                  fdoExtension = Fdo->DeviceExtension;
   PIO_RESOURCE_REQUIREMENTS_LIST  oldReqList;
   PIO_RESOURCE_REQUIREMENTS_LIST  newReqList;
   PIO_RESOURCE_LIST               oldList, newList;
   PIO_RESOURCE_DESCRIPTOR         ioResourceDesc;
   ULONG                           newReqSize;
   ULONG                           oldlistSize, newlistSize, altListSize;
   ULONG                           index;
   ULONG                           IntCount = 0;
   PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation(Irp);
   NTSTATUS                        status;

   PAGED_CODE();

   status = PcmciaIoCallDriverSynchronous(fdoExtension->LowerDevice, Irp);

   if (!NT_SUCCESS(status)) {
      return status;
   }

   if (Irp->IoStatus.Information == 0) {

      oldReqList = irpStack->Parameters.FilterResourceRequirements.IoResourceRequirementList;

      if (oldReqList == NULL) {
         //
         // NULL List, nothing to do
         //
         return(Irp->IoStatus.Status);
      }

   } else {
      //
      // Use the returned list
      //
      oldReqList = (PIO_RESOURCE_REQUIREMENTS_LIST)Irp->IoStatus.Information;
   }


   //
   // Add an alternative list without the IRQ requirement, if one exists. Model the
   // new alternative list after the first list.
   //

   oldList = oldReqList->List;
   ioResourceDesc = oldList->Descriptors;
   altListSize = 0;

   for (index = 0; index < oldList->Count; index++) {
      // Count the descriptors, excluding any IRQ descriptors
      if (ioResourceDesc->Type == CmResourceTypeInterrupt) {
         IntCount++;
      }
      ioResourceDesc++;
   }

   if (IntCount) {
      //
      // "+1" because we are adding two later, but IO_RESOURCE_LIST already has 1
      //
      altListSize = sizeof(IO_RESOURCE_LIST) + ((oldList->Count+1)-IntCount)*sizeof(IO_RESOURCE_DESCRIPTOR);
   }

   //
   // Add a memory range requirement to what we already have..
   //
   newReqSize = oldReqList->ListSize +
                oldReqList->AlternativeLists*2*sizeof(IO_RESOURCE_DESCRIPTOR) +
                altListSize;
   newReqList = ExAllocatePool(PagedPool, newReqSize);

   if (newReqList == NULL) {
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlCopyMemory(newReqList, oldReqList, FIELD_OFFSET(IO_RESOURCE_REQUIREMENTS_LIST, List));
   newReqList->ListSize = newReqSize;

   newList = newReqList->List;
   oldList = oldReqList->List;

   for (index = 0; index < oldReqList->AlternativeLists; index++) {
      //
      // Compute the size of the current original list
      //
      oldlistSize = sizeof(IO_RESOURCE_LIST) + (oldList->Count-1) * sizeof(IO_RESOURCE_DESCRIPTOR);
      newlistSize = oldlistSize;
      RtlCopyMemory(newList, oldList, newlistSize);

      //
      // Add memory requirement
      //
      ioResourceDesc = (PIO_RESOURCE_DESCRIPTOR) (((PUCHAR) newList) + newlistSize);

      ioResourceDesc->Option = IO_RESOURCE_PREFERRED;
      ioResourceDesc->Type = CmResourceTypeMemory;
      ioResourceDesc->ShareDisposition = CmResourceShareDeviceExclusive;
      ioResourceDesc->Flags = CM_RESOURCE_MEMORY_READ_WRITE;
      ioResourceDesc->u.Memory.MinimumAddress.QuadPart = fdoExtension->AttributeMemoryLow;
      ioResourceDesc->u.Memory.MaximumAddress.QuadPart = fdoExtension->AttributeMemoryHigh;
      ioResourceDesc->u.Memory.Length                  = fdoExtension->AttributeMemorySize;
      ioResourceDesc->u.Memory.Alignment               = fdoExtension->AttributeMemoryAlignment;
      ioResourceDesc++;
      //
      // The other - less restrictive - alternative.
      //
      ioResourceDesc->Option = IO_RESOURCE_ALTERNATIVE;
      ioResourceDesc->Type = CmResourceTypeMemory;
      ioResourceDesc->ShareDisposition = CmResourceShareDeviceExclusive;
      ioResourceDesc->Flags = CM_RESOURCE_MEMORY_READ_WRITE;
      ioResourceDesc->u.Memory.MinimumAddress.QuadPart = 0;
      if ((fdoExtension->Flags & PCMCIA_MEMORY_24BIT) == 0) {
         ioResourceDesc->u.Memory.MaximumAddress.QuadPart = 0xFFFFFFFF;
      } else {
         ioResourceDesc->u.Memory.MaximumAddress.QuadPart = 0xFFFFFF;
      }
      ioResourceDesc->u.Memory.Length    = fdoExtension->AttributeMemorySize;
      ioResourceDesc->u.Memory.Alignment = fdoExtension->AttributeMemoryAlignment;

      newList->Count += 2;
      newlistSize += 2*sizeof(IO_RESOURCE_DESCRIPTOR);

      oldList = (PIO_RESOURCE_LIST) (((PUCHAR) oldList) + oldlistSize);
      newList = (PIO_RESOURCE_LIST) (((PUCHAR) newList) + newlistSize);
   }

   if (altListSize != 0) {
      PIO_RESOURCE_DESCRIPTOR oldResourceDesc;
      //
      // Here we add the alternate list which doesn't contain an IRQ requirement.
      // Note that we use the first "new list" as the "old list". This way, we
      // pick up the things we added in the previous loop. All we have to do is
      // copy every descriptor except for the interrupt descriptor.
      //
      // Note: newList is still set from previous loop
      //
      oldList = newReqList->List;

      //
      // First copy the basic structure without the descriptors
      //
      RtlCopyMemory(newList, oldList, sizeof(IO_RESOURCE_LIST) - sizeof(IO_RESOURCE_DESCRIPTOR));

      oldResourceDesc = oldList->Descriptors;
      ioResourceDesc = newList->Descriptors;

      for (index = 0; index < oldList->Count; index++) {

         if (oldResourceDesc->Type != CmResourceTypeInterrupt) {
            *ioResourceDesc = *oldResourceDesc;
            ioResourceDesc++;

         } else {
            //
            // We've deleted a descriptor
            //
            newList->Count--;
         }
         oldResourceDesc++;
      }
      newReqList->AlternativeLists++;
   }


   Irp->IoStatus.Information = (ULONG_PTR) newReqList;
   irpStack->Parameters.FilterResourceRequirements.IoResourceRequirementList =
                                                                  newReqList;

   //
   // Free up the old resource reqs
   //
   ExFreePool(oldReqList);

   fdoExtension->Flags |= PCMCIA_FILTER_ADDED_MEMORY;
   return STATUS_SUCCESS;
}



NTSTATUS
PcmciaFdoGetHardwareIds(
   IN PDEVICE_OBJECT Fdo,
   OUT PUNICODE_STRING HardwareIds
   )

/*++

Routine description:

    This routine returns the hardware ids for the given 'legacy' pcmcia controller
    NOTE: this routine is required only for pcmcia controllers detected by this driver
    itself and registered via IoReportDetectedDevice.

Arguments:

   Fdo - Pointer to the functional device object representing the pcmcia controller
   CompatibleIds - Pointer to the unicode string which would contain the hardware ids
                   as a multi-string on return

Return value:

   STATUS_SUCCESS
   Any other status - could not generate compatible ids
--*/

{
   PCSTR    strings[2];
   PCMCIA_CONTROLLER_TYPE controllerType;
   ULONG    count, index;
   BOOLEAN  found;

   PAGED_CODE();

   controllerType  = ((PFDO_EXTENSION)Fdo->DeviceExtension)->ControllerType;
   found = FALSE;

   for (index = 0; (PcmciaAdapterHardwareIds[index].ControllerType != PcmciaInvalidControllerType); index++) {
      if (PcmciaAdapterHardwareIds[index].ControllerType == controllerType) {
         found = TRUE;
         break;
      }
   }

   if (found) {
      strings[0] = PcmciaAdapterHardwareIds[index].Id;
   } else {
      DebugPrint((PCMCIA_DEBUG_INFO, "PcmciaGetAdapterHardwareIds: Could not find find hardware id for %x, controllerType %x\n",
                  Fdo,
                  controllerType
                 ));

      strings[0] = "";
   }

   count = 1;
   return PcmciaStringsToMultiString(strings,
                                     count,
                                     HardwareIds);
}




NTSTATUS
PcmciaFdoStartDevice(
   IN  PDEVICE_OBJECT Fdo,
   IN  PIRP           Irp,
   OUT BOOLEAN        *PassedDown,
   OUT BOOLEAN        *NeedsRecompletion
   )
/*++

Routine Description:

    This routine will start the PCMCIA controller with the supplied
    resources.  The IRP is sent down to the pdo first, so PCI or ISAPNP
    or whoever sits underneath gets a chance to program the controller
    to decode the resources.

Arguments:

    Fdo               - Functional device object of the PCMCIA controller
    Irp               - Well, it's the start irp, yah?
    PassedDown        - Contains FALSE on entry, which means caller must
                        complete or pass down irp based on status. If set
                        to TRUE, Irp may need to be re-completed...
    NeedsRecompletion - ...In which case this parameter will be checked

Return value:

    Status

--*/
{
   NTSTATUS           status;
   PFDO_EXTENSION     deviceExtension = Fdo->DeviceExtension;
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
   PCM_RESOURCE_LIST  resList, translatedResList, newResList, newTranslatedResList;

   PAGED_CODE();

   if (deviceExtension->Flags & PCMCIA_DEVICE_STARTED) {
      //
      // Start to already started device
      //
      DebugPrint((PCMCIA_DEBUG_FAIL,"PcmciaFdoStartDevice: Fdo %x already started\n",
                  Fdo));
      return STATUS_SUCCESS;
   }

   //
   // Parse AllocatedResources & get IoPort/AttributeMemoryBase/IRQ info.
   //
   status = PcmciaFdoGetAssignedResources(irpStack->Parameters.StartDevice.AllocatedResources,
                                          irpStack->Parameters.StartDevice.AllocatedResourcesTranslated,
                                          deviceExtension
                                          );

   if (!NT_SUCCESS(status)) {
      //
      // Ha. This is most likely a START for a madeup devnode (report-detected legacy PCMCIA controller)
      // which has been removed subsequently, hence not reported again with proper resources.
      // We return an appropriate status
      //
      DebugPrint((PCMCIA_DEBUG_FAIL, "Pcmcia: No  resources assigned to FDO, probably bogus START for"
                  "non-existent controller\n" ));
      return STATUS_NO_SUCH_DEVICE;
   }

   DebugPrint((PCMCIA_DEBUG_PNP, "fdo %08x StartAdapter: AttrMem Base %x\n", Fdo, deviceExtension->PhysicalBase));
   DebugPrint((PCMCIA_DEBUG_PNP, "                       VirtualBase %x AttrMem Size %x\n", deviceExtension->AttributeMemoryBase, deviceExtension->AttributeMemorySize));

   if (deviceExtension->Flags & PCMCIA_FILTER_ADDED_MEMORY) {
      ULONG newSize;
      ULONG index;
      PCM_PARTIAL_RESOURCE_LIST  resPartialList, translatedResPartialList;
      PCM_PARTIAL_RESOURCE_DESCRIPTOR resDesc, translatedResDesc;
      PCM_PARTIAL_RESOURCE_DESCRIPTOR newResDesc, newTranslatedResDesc;
      //
      // We need to remove the memory resource requirement
      //
      resList= irpStack->Parameters.StartDevice.AllocatedResources;
      resPartialList = &resList->List[0].PartialResourceList;
      translatedResList= irpStack->Parameters.StartDevice.AllocatedResourcesTranslated;
      translatedResPartialList = &translatedResList->List[0].PartialResourceList;

      newSize = sizeof(CM_RESOURCE_LIST) + (resPartialList->Count-2)*sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);
      newResList = ExAllocatePool(PagedPool,
                                  newSize);
      if (newResList == NULL) {
         return STATUS_INSUFFICIENT_RESOURCES;
      }

      newTranslatedResList = ExAllocatePool(PagedPool,
                                            newSize);

      if (newTranslatedResList == NULL) {
         ExFreePool(newResList);
         return STATUS_INSUFFICIENT_RESOURCES;
      }
      newResList->Count = newTranslatedResList->Count = 1;
      newResList->List[0].InterfaceType = resList->List[0].InterfaceType;
      newTranslatedResList->List[0].InterfaceType = translatedResList->List[0].InterfaceType;
      newResList->List[0].BusNumber = resList->List[0].BusNumber;
      newTranslatedResList->List[0].BusNumber = translatedResList->List[0].BusNumber;

      newResList->List[0].PartialResourceList.Version  = resPartialList->Version;
      newResList->List[0].PartialResourceList.Revision = resPartialList->Revision;
      newResList->List[0].PartialResourceList.Count    = resPartialList->Count - 1;

      newTranslatedResList->List[0].PartialResourceList.Version  = translatedResPartialList->Version;
      newTranslatedResList->List[0].PartialResourceList.Revision = translatedResPartialList->Revision;
      newTranslatedResList->List[0].PartialResourceList.Count    = translatedResPartialList->Count - 1;


      resDesc = resPartialList->PartialDescriptors;
      translatedResDesc = translatedResPartialList->PartialDescriptors;
      newResDesc = newResList->List[0].PartialResourceList.PartialDescriptors;
      newTranslatedResDesc = newTranslatedResList->List[0].PartialResourceList.PartialDescriptors;

      if (CardBusExtension(deviceExtension)) {
         //
         // Remove last memory descriptor - which is what we added
         //
         RtlCopyMemory(newResDesc,
                       resDesc,
                       newResList->List[0].PartialResourceList.Count * sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));

         RtlCopyMemory(newTranslatedResDesc,
                       translatedResDesc,
                       newTranslatedResList->List[0].PartialResourceList.Count * sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));

      } else {
         //
         // Remove the only memory descriptor..
         //
         for (index = 0; index < resPartialList->Count;
             index++, resDesc++, translatedResDesc++, newResDesc++, newTranslatedResDesc++) {
            if (resDesc->Type != CmResourceTypeMemory) {
               *newResDesc = *resDesc;
               *newTranslatedResDesc = *translatedResDesc;
            }
         }
      }

      irpStack->Parameters.StartDevice.AllocatedResources = newResList;
      irpStack->Parameters.StartDevice.AllocatedResourcesTranslated = newTranslatedResList;
   }

   //
   // Send this down to the PDO first
   //

   status = PcmciaIoCallDriverSynchronous(deviceExtension->LowerDevice, Irp);
   *PassedDown = TRUE ;

   //
   // We set this because the completion routine returns
   // STATUS_MORE_PROCESSING_REQUIRED, which means it needs to be completed
   // again.
   //
   *NeedsRecompletion = TRUE ;

   if (deviceExtension->Flags & PCMCIA_FILTER_ADDED_MEMORY) {
      ExFreePool(newResList);
      ExFreePool(newTranslatedResList);
      irpStack->Parameters.StartDevice.AllocatedResources = resList;
      irpStack->Parameters.StartDevice.AllocatedResourcesTranslated = translatedResList;
   }

   if (!NT_SUCCESS(status)) {
      return status;
   }

   //
   // Give the hardware some time to settle after returning from the pdo
   //
   PcmciaWait(256);
   
   //
   // Initialize the hardware
   //

   status = PcmciaStartPcmciaController(Fdo);


   if (NT_SUCCESS(status)) {
      deviceExtension->Flags |= PCMCIA_DEVICE_STARTED;
   }
   //
   // Remember if cardbus cards will be supported for this controller
   //
   if (CardBusExtension(deviceExtension) &&
       !PcmciaAreCardBusCardsSupported(deviceExtension)) {
      deviceExtension->Flags |= PCMCIA_CARDBUS_NOT_SUPPORTED;
   }
   return status;
}





NTSTATUS
PcmciaFdoStopDevice(
   IN  PDEVICE_OBJECT Fdo,
   IN  PIRP           Irp                OPTIONAL,
   OUT BOOLEAN        *PassedDown        OPTIONAL,
   OUT BOOLEAN        *NeedsRecompletion OPTIONAL
   )
/*++

Routine Description:

   IRP_MN_STOP_DEVICE handler for the given pcmcia controller.
   If Irp is present, it'll send it down first to the PDO.
   Unhooks the interrupt/cancels poll timer etc.

Arguments:

   Fdo               - Pointer to functional device object for the pcmcia
                       controller
   Irp               - If present it's the pointer to the stop Irp initiated
                       by PnP
   PassedDown        - Contains FALSE on entry, which means caller must
                       complete or pass down irp based on status. If set
                       to TRUE, Irp may need to be re-completed...
   NeedsRecompletion - ...In which case this parameter will be checked.

                       Note: PassedDown and NeedsCompletion are ignored and
                             optional only if Irp is NULL.

Return value:

   STATUS_SUCCESS    - Pcmcia controller successfully stopped
   Other             - Stop failed

--*/
{
   PFDO_EXTENSION deviceExtension = Fdo->DeviceExtension;
   PSOCKET        socket;
   NTSTATUS       status;

   if (!(deviceExtension->Flags & PCMCIA_DEVICE_STARTED)) {
      //
      // Already stopped
      //
      return STATUS_SUCCESS;
   }
   
   PcmciaFdoDisarmWake(deviceExtension);

   //
   // Disable the interrupt
   //
   if (deviceExtension->PcmciaInterruptObject) {

      for (socket = deviceExtension->SocketList; socket; socket = socket->NextSocket) {
         //
         // Disable the controller interrupts
         //
         (*(socket->SocketFnPtr->PCBEnableDisableCardDetectEvent))(socket, FALSE);
         (*(socket->SocketFnPtr->PCBEnableDisableWakeupEvent))(socket, NULL, FALSE);
         //
         // Apparently IBM ThinkPads like this
         //
         PcmciaWait(PCMCIA_ENABLE_DELAY);
      }
   }

   //
   // the bus driver below us will make us go offline
   //
   deviceExtension->Flags |= PCMCIA_FDO_OFFLINE;

   //
   // clear pending event
   //   
   KeCancelTimer(&deviceExtension->EventTimer);

   //
   // Send this down to the PDO 
   //
   if (ARGUMENT_PRESENT(Irp)) {

      status = PcmciaIoCallDriverSynchronous(deviceExtension->LowerDevice, Irp);

      *PassedDown = TRUE ;
      *NeedsRecompletion = TRUE ;


      if (!NT_SUCCESS(status)) {
         return status;
      }
   }

   if (deviceExtension->Flags & PCMCIA_USE_POLLED_CSC) {
      //
      // cancel the card status change poller
      //
      KeCancelTimer(&deviceExtension->PollTimer);
      deviceExtension->Flags &= ~PCMCIA_USE_POLLED_CSC;
   }

   if (deviceExtension->PcmciaInterruptObject) {
      //
      // unhook the interrupt
      //
      IoDisconnectInterrupt(deviceExtension->PcmciaInterruptObject);
      deviceExtension->PcmciaInterruptObject = NULL;
   }

   //
   // Unmap any i/o space or memory we might have mapped
   //
   if (deviceExtension->Flags & PCMCIA_ATTRIBUTE_MEMORY_MAPPED) {
      MmUnmapIoSpace(deviceExtension->AttributeMemoryBase,
                     deviceExtension->AttributeMemorySize);
      deviceExtension->Flags &= ~PCMCIA_ATTRIBUTE_MEMORY_MAPPED;
      deviceExtension->AttributeMemoryBase = 0;
      deviceExtension->AttributeMemorySize = 0;
   }

   if (deviceExtension->Flags & PCMCIA_SOCKET_REGISTER_BASE_MAPPED) {
      MmUnmapIoSpace(deviceExtension->CardBusSocketRegisterBase,
                     deviceExtension->CardBusSocketRegisterSize);
      deviceExtension->Flags &= ~PCMCIA_SOCKET_REGISTER_BASE_MAPPED;
      deviceExtension->CardBusSocketRegisterBase = 0;
      deviceExtension->CardBusSocketRegisterSize = 0;
   }

   deviceExtension->Flags &= ~PCMCIA_DEVICE_STARTED;
   return STATUS_SUCCESS;
}



NTSTATUS
PcmciaFdoRemoveDevice(
   IN PDEVICE_OBJECT Fdo,
   IN PIRP           Irp
   )
/*++

Routine Description:

   Handles IRP_MN_REMOVE for the pcmcia controller.
   Stops the adapter if it isn't already, sends the IRP
   to the PDO first & cleans up the Fdo for this controller
   and detaches & deletes the device object.

Arguments:

   Fdo   - Pointer to functional device object for the controller
           to be removed

Return value:

   Status

--*/
{
   PFDO_EXTENSION fdoExtension = Fdo->DeviceExtension;
   PDEVICE_OBJECT pdo, nextPdo, fdo, prevFdo;
   PPDO_EXTENSION pdoExtension;
   NTSTATUS       status;

   UNREFERENCED_PARAMETER(Irp);

   if (fdoExtension->Flags & PCMCIA_DEVICE_STARTED) {
      //
      // Stop the fdo first.
      //
      PcmciaFdoStopDevice(Fdo, NULL, NULL, NULL);
   }

   //
   // Send this down to the PDO
   //

   status = PcmciaIoCallDriverSynchronous(fdoExtension->LowerDevice, Irp);

   if (!NT_SUCCESS(status)) {
      return status;
   }

   //
   // If the PdoList in the fdoExtension is non-empty it means:
   // that the PDOs in the list were not physically removed, but
   // a soft REMOVE was issued, hence they are still hanging on
   // and now this controller itself is being REMOVED.
   // Hence we dispose of those PDOs now
   //

   for (pdo = fdoExtension->PdoList; pdo != NULL ; pdo = nextPdo) {
      DebugPrint((PCMCIA_DEBUG_INFO,
                  "RemoveDevice: pdo %x child of fdo %x was not removed before fdo\n",
                  pdo, Fdo));

      pdoExtension = pdo->DeviceExtension;

      ASSERT (!IsDevicePhysicallyRemoved(pdoExtension));
      //
      // It's possible for this bit to be on, if the device was added,
      // but never started (because of some other error.
      //ASSERT (!IsDeviceAlive(pdoExtension));

      nextPdo =  pdoExtension->NextPdoInFdoChain;
      if (!IsDeviceDeleted(pdoExtension)) {
         MarkDeviceDeleted(pdoExtension);
         PcmciaCleanupPdo(pdo);
         IoDeleteDevice(pdo);
      }
   }

   MarkDeviceDeleted(fdoExtension);
   PcmciaCleanupFdo(fdoExtension);

   //
   // Remove this from the fdo list..
   //
   prevFdo = NULL;
   for (fdo = FdoList; fdo != NULL; prevFdo = fdo, fdo = fdoExtension->NextFdo) {
      fdoExtension = fdo->DeviceExtension;
      if (fdo == Fdo) {
         if (prevFdo) {
            //
            // Delink this fdo
            //
            ((PFDO_EXTENSION)prevFdo->DeviceExtension)->NextFdo
            = fdoExtension->NextFdo;
         } else {
            FdoList = fdoExtension->NextFdo;
         }
         break;
      }
   }

   DebugPrint((PCMCIA_DEBUG_PNP, "fdo %08x Remove detach & delete\n", Fdo));
   IoDetachDevice(((PFDO_EXTENSION)Fdo->DeviceExtension)->LowerDevice);
   IoDeleteDevice(Fdo);

   return STATUS_SUCCESS;
}



VOID
PcmciaCleanupContext(
   IN PPCMCIA_CONTEXT pContext
   )
/*++

Routine Description

   Frees up allocated pool associated with a specific controller
   register context.

Arguments

   pContext - pointer to a PCMCIA_CONTEXT structure

Return value

   none

--*/
{
   pContext->RangeCount = 0;

   if (pContext->Range) {
      ExFreePool(pContext->Range);
      pContext->Range = NULL;
   }
}



VOID
PcmciaCleanupFdo(
   IN PFDO_EXTENSION FdoExtension
   )
/*++

Routine Description

   Frees up allocated pool, deletes symbolic links etc. for the
   associated FDO for the pcmcia controller which is to be removed.

Arguments

   FdoExtension   - Pointer to the device extension for the FDO of the pcmcia controller
                    which is being removed

Return value

   none

--*/
{
   PSOCKET        socket, nextSocket;

   //
   // Free the controller register context
   //
   PcmciaCleanupContext(&FdoExtension->PciContext);
   if (FdoExtension->PciContextBuffer) {
      ExFreePool(FdoExtension->PciContextBuffer);
      FdoExtension->PciContextBuffer = NULL;
   }

   PcmciaCleanupContext(&FdoExtension->CardbusContext);
   PcmciaCleanupContext(&FdoExtension->ExcaContext);

   //
   // Delete symbolic links to this fdo
   //
   if (FdoExtension->LinkName.Buffer != NULL) {
      IoDeleteSymbolicLink(&FdoExtension->LinkName);
      RtlFreeUnicodeString(&FdoExtension->LinkName);
   }

   //
   // Cleanup the socket structures
   //
   for (socket = FdoExtension->SocketList; socket != NULL; socket = nextSocket) {

      if (socket->CardbusContextBuffer) {
         ExFreePool(socket->CardbusContextBuffer);
         socket->CardbusContextBuffer = NULL;
      }

      if (socket->ExcaContextBuffer) {
         ExFreePool(socket->ExcaContextBuffer);
         socket->ExcaContextBuffer = NULL;
      }

      nextSocket = socket->NextSocket;
      ExFreePool(socket);
   }

   FdoExtension->SocketList = NULL;
   return;
}



NTSTATUS
PcmciaFdoGetAssignedResources(
   IN PCM_RESOURCE_LIST ResourceList,
   IN PCM_RESOURCE_LIST TranslatedResourceList,
   IN PFDO_EXTENSION    DeviceExtension
   )
/*++

Routine Description:

   Extracts the assigned resources to the pcmcia controller

Arguments:

   ResourceList            - Raw resource list
   TranslatedResourceList
   DeviceExtension         - Device extension of the PCMCIA controller

Return value:

   STATUS_SUCCESS
   STATUS_UNSUCCESSFUL      if resources are not right or enough.

--*/
{
   PCM_FULL_RESOURCE_DESCRIPTOR     fullResourceDesc;
   PCM_PARTIAL_RESOURCE_LIST        partialResourceList;
   PCM_PARTIAL_RESOURCE_DESCRIPTOR  partialResourceDesc;
   ULONG                            addressSpace;
   PHYSICAL_ADDRESS                 physicalAddress;
   PHYSICAL_ADDRESS                 translatedAddress;
   ULONG i;
   ULONG attributeIndex;
   PULONG                           devicePrivate;
   BOOLEAN                          translated;

   PAGED_CODE();


   if ((ResourceList == NULL) || (ResourceList->Count <=0) ) {
      return STATUS_UNSUCCESSFUL;
   }


   if (CardBusExtension(DeviceExtension)) {

      fullResourceDesc=&TranslatedResourceList->List[0];
      DeviceExtension->Configuration.InterfaceType = fullResourceDesc->InterfaceType;
      DeviceExtension->Configuration.BusNumber = fullResourceDesc->BusNumber;

      partialResourceList = &fullResourceDesc->PartialResourceList;
      partialResourceDesc = partialResourceList->PartialDescriptors;
      //
      // We need just the exca register base
      // According to PeterJ the first descriptor
      // for us is the cardbus socket register base.
      // We trust him.
      for (i=0; (i < partialResourceList->Count) && (partialResourceDesc->Type != CmResourceTypeMemory);
          i++, partialResourceDesc++);
      if (i >= partialResourceList->Count) {
         return STATUS_UNSUCCESSFUL;
      };

      //
      // This is memory. We need to map it
      //
      DeviceExtension->CardBusSocketRegisterBase = MmMapIoSpace(partialResourceDesc->u.Memory.Start,
                                                                partialResourceDesc->u.Memory.Length,
                                                                FALSE);
      DeviceExtension->CardBusSocketRegisterSize = partialResourceDesc->u.Memory.Length;

      DeviceExtension->Flags |= PCMCIA_SOCKET_REGISTER_BASE_MAPPED;

      //
      // Last BAR is attribute memory window. This will be peeled off later.
      // It might be a good idea to tack a device private on at the end to
      // confirm this. However how do we guarantee our device private does
      // not contain the same data as somebody else's? PnP is lacking here -
      // we need some convention so that devices can set uniquely identifying stuff
      // in there - like maybe the device object they own - to identify it is
      // theirs. Till then this should do.
      //
      if (i > (partialResourceList->Count - 2)) {
         //
         // No more resources? Bail out.
         //
         return STATUS_INSUFFICIENT_RESOURCES;
      }

      for (i++, partialResourceDesc++; (i < (partialResourceList->Count - 1));i++,partialResourceDesc++);
      //
      // partialResourceDesc points to the last descriptor
      //
      ASSERT (partialResourceDesc->Type == CmResourceTypeMemory);
      DeviceExtension->PhysicalBase = partialResourceDesc->u.Memory.Start;
      //
      // This is memory. We need to map it
      //
      DeviceExtension->AttributeMemoryBase = MmMapIoSpace(partialResourceDesc->u.Memory.Start,
                                                          partialResourceDesc->u.Memory.Length,
                                                          FALSE);
      DeviceExtension->AttributeMemorySize = partialResourceDesc->u.Memory.Length;
      DeviceExtension->Flags |= PCMCIA_ATTRIBUTE_MEMORY_MAPPED;

      //
      // Finally see if an IRQ is assigned
      //

      for (i = 0, partialResourceDesc = partialResourceList->PartialDescriptors;
          (i < partialResourceList->Count) && (partialResourceDesc->Type != CmResourceTypeInterrupt);
          i++,partialResourceDesc++);


      if (i < partialResourceList->Count) {
         //
         // We have an interrupt to used for CSC
         // PCI will ensure that this interrupt is exactly the
         // same as the one assigned to the functional interrupt
         // for a cardbus pc-card in this controller's socket
         //
         DebugPrint((PCMCIA_DEBUG_INFO, "PcmciaGetAssignedResources: Interrupt resource assigned\n"));
         DeviceExtension->Configuration.TranslatedInterrupt = *partialResourceDesc;
         //
         // Get the raw interrupt resource  - needed to enable the interrupt on the controller
         //
         fullResourceDesc=&ResourceList->List[0];
         partialResourceList = &fullResourceDesc->PartialResourceList;
         partialResourceDesc = partialResourceList->PartialDescriptors;
         for (i=0; (i< partialResourceList->Count) && (partialResourceDesc->Type != CmResourceTypeInterrupt);
             i++, partialResourceDesc++);
         if (i < partialResourceList->Count) {
            DeviceExtension->Configuration.Interrupt = *partialResourceDesc;
         } else {
            //
            // Should not happen.. translated descriptor was present, but raw is missing!
            // Just reset the translated interrupt and pretend no interrupt was assigned
            //
            RtlZeroMemory(&DeviceExtension->Configuration.TranslatedInterrupt, sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));
         }
      }
   } else {
      //
      // 16-bit pcmcia controller
      //
      fullResourceDesc=&ResourceList->List[0];
      DeviceExtension->Configuration.InterfaceType = fullResourceDesc->InterfaceType;
      DeviceExtension->Configuration.BusNumber = fullResourceDesc->BusNumber;

      partialResourceList = &fullResourceDesc->PartialResourceList;
      partialResourceDesc = partialResourceList->PartialDescriptors;

      for (i=0; i<partialResourceList->Count; i++, partialResourceDesc++) {

         devicePrivate = partialResourceDesc->u.DevicePrivate.Data;

         switch (partialResourceDesc->Type) {

         case CmResourceTypeInterrupt: {
               if (DeviceExtension->ControllerType != PcmciaCLPD6729 &&
                   DeviceExtension->ControllerType != PcmciaPciPcmciaBridge &&
                   DeviceExtension->ControllerType != PcmciaNEC98 &&
                   DeviceExtension->ControllerType != PcmciaNEC98102) {

                  // We always poll for Cirrus Logic PCI to PCMCIA  controllers
                  // and other PCI-PCMCIA bridges
                  //

                  DeviceExtension->Configuration.Interrupt = *partialResourceDesc;
               }
               break;
            }
         case CmResourceTypePort: {
               DeviceExtension->Configuration.UntranslatedPortAddress = (USHORT) partialResourceDesc->u.Port.Start.QuadPart;
               DeviceExtension->Configuration.PortSize = (USHORT) partialResourceDesc->u.Port.Length;
               break;
            }
         case CmResourceTypeMemory: {
               DeviceExtension->PhysicalBase =         partialResourceDesc->u.Memory.Start;
               DeviceExtension->AttributeMemorySize =  partialResourceDesc->u.Memory.Length;
               attributeIndex = i;
               break;
            }
         }
      }

      if ((DeviceExtension->PhysicalBase.QuadPart == 0) ||
          (DeviceExtension->Configuration.UntranslatedPortAddress == 0)) {

         DebugPrint((PCMCIA_DEBUG_FAIL, "PcmciaGetAssignedResources: Need both memory and i/o for pcmcia controller 0x%X\n",
                     DeviceExtension->DeviceObject));
         return STATUS_INSUFFICIENT_RESOURCES;
      }


      fullResourceDesc=&TranslatedResourceList->List[0];
      partialResourceList = &fullResourceDesc->PartialResourceList;
      partialResourceDesc = &partialResourceList->PartialDescriptors[attributeIndex];


      switch (partialResourceDesc->Type) {

      case CmResourceTypeMemory:
         DeviceExtension->AttributeMemoryBase = MmMapIoSpace(partialResourceDesc->u.Memory.Start,
                                                             DeviceExtension->AttributeMemorySize,
                                                             FALSE);
         DeviceExtension->Flags |= PCMCIA_ATTRIBUTE_MEMORY_MAPPED;
         break;

      case CmResourceTypePort:
         DeviceExtension->AttributeMemoryBase = (PUCHAR)(partialResourceDesc->u.Port.Start.QuadPart);
         DeviceExtension->Flags &= ~PCMCIA_ATTRIBUTE_MEMORY_MAPPED;
         break;

      default:
         ASSERT(FALSE);
         return STATUS_INSUFFICIENT_RESOURCES;
      }

   }
   return STATUS_SUCCESS;
}



NTSTATUS
PcmciaAreCardBusCardsSupported(
   IN PFDO_EXTENSION FdoExtension
   )
/*++

Routine Description:

    Indicates if cardbus cards will be supported on the given PCMCIA
    controller on this system
    Currently we support cardbus cards only on:
       Machines on which BIOS programmed the bus numbers & IntLine

Arguments:

    FdoExtension - Pointer to device extension for the pcmcia controller

Return Value:

    TRUE  - if cardbus cards are supported
    FALSE - if not

--*/
{
    UCHAR             byte;

    PAGED_CODE();

    //
    // Check int line
    //
    GetPciConfigSpace(FdoExtension,
                      CFGSPACE_INT_LINE,
                      &byte,
                      1);
    if (byte == 0xff) {
         return FALSE;
    }

    //
    // Check  cardbus bus number
    //
    GetPciConfigSpace(FdoExtension,
                      CFGSPACE_CARDBUS_BUSNUM,
                      &byte,
                      1);
    if (byte == 0) {
         return FALSE;
    }

    //
    // Check subordinate bus number
    //
    GetPciConfigSpace(FdoExtension,
                      CFGSPACE_SUB_BUSNUM,
                      &byte,
                      1);
    if (byte == 0) {
         return FALSE;
    }

    //
    // All tests passed
    //
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\pcmcibus\enum.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    enum.c

Abstract:

    This module contains the bus enum code for Pcmcia driver

Authors:

    Ravisankar Pudipeddi (ravisp) 10/15/96
    Neil Sandlin (neilsa) 1-Jun-1999    

Environment:

    Kernel mode only

Notes:

Revision History:

--*/

#include "pch.h"

//
// Internal References
//

NTSTATUS
PcmciaEnumerateDevices(
   IN PDEVICE_OBJECT Fdo,
   IN PIRP           Irp
   );

NTSTATUS
PcmciaEnumerateCardBusCard(
   IN PSOCKET socket,
   IN PIRP    Irp
   );

NTSTATUS
PcmciaEnumerateR2Card(
   IN PSOCKET socket
   );

NTSTATUS
PcmciaCreatePdo(
   IN PDEVICE_OBJECT  Fdo,
   IN PSOCKET         Socket,
   OUT PDEVICE_OBJECT *PdoPtr
   );

VOID
PcmciaSetPowerFromConfigData(
   IN PSOCKET         Socket,
   IN PDEVICE_OBJECT  Pdo
   );

#ifdef ALLOC_PRAGMA
   #pragma alloc_text(PAGE, PcmciaEnumerateDevices)
   #pragma alloc_text(PAGE, PcmciaEnumerateCardBusCard)
   #pragma alloc_text(PAGE, PcmciaCreatePdo)
   #pragma alloc_text(PAGE, PcmciaDeviceRelations)
#endif

NTSTATUS
PcmciaEnumerateDevices(
   IN PDEVICE_OBJECT Fdo,
   IN PIRP           Irp
   )
/*++

Routine Description:

   This enumerates the pcmcia bus which is represented by Fdo (a pointer to the device object representing
   the pcmcia controller. It creates new PDOs for any new PC-Cards which have been discovered
   since the last enumeration
   
Notes:

   Because a user can yank a pccard at any time, the enumeration code only updates the current socket
   status after PnP has had a chance to gracefully remove the device. Specifically, if a surprise remove
   happens, then a number of things has to happen:
    - power has to be reset on the socket
    - bridge windows need to be closed
    - if cardbus, PCI.SYS needs to be informed
   The problem is that we can't do these things immediately here. Instead, on a surprise remove, we
   check to see if there is still state that has yet to be cleared. If so, we report the socket as
   empty, and bail out, even if another card has been inserted (or the same card re-inserted). Later,
   the remove code will cause a new enumeration call, at which point we can update the state and honestly
   report the new device.   

Arguments:

   Fdo - Pointer to the functional device object for the PCMCIA controller which needs to be enumerated

Return value:

   None

--*/
{
   PFDO_EXTENSION fdoExtension = Fdo->DeviceExtension;
   PPDO_EXTENSION pdoExtension = NULL;
   PDEVICE_OBJECT pdo;
   PSOCKET        socket;
   NTSTATUS       status = STATUS_SUCCESS;
   ULONG          i;
   PDEVICE_OBJECT nextPdo;

   PAGED_CODE();
   
   DebugPrint((PCMCIA_DEBUG_ENUM, "fdo %08x enumerate devices\n", Fdo));

   for (socket = fdoExtension->SocketList; socket != NULL; socket = socket->NextSocket) {

      if (!IsSocketFlagSet(socket, SOCKET_CARD_STATUS_CHANGE)) {
         //
         // return previous results 
         //
         DebugPrint((PCMCIA_DEBUG_ENUM, "fdo %08x skt %08x No status change\n", Fdo, socket));
         continue;
      }

      ResetDeviceFlag(fdoExtension, PCMCIA_FDO_DISABLE_AUTO_POWEROFF);

      //
      // The socket either has a new card, or the card has been
      // removed. Either way, the old pdo list on this socket, if
      // it exists, will now be thrown away.
      //
      for (pdo = socket->PdoList; pdo!=NULL; pdo=nextPdo) {
         pdoExtension = pdo->DeviceExtension;
         nextPdo = pdoExtension->NextPdoInSocket;
         pdoExtension->NextPdoInSocket = NULL;

         DebugPrint((PCMCIA_DEBUG_INFO, "fdo %08x enumeration marking pdo %08x REMOVED\n", Fdo, pdo));
         MarkDevicePhysicallyRemoved(pdoExtension);
      }
      socket->PdoList = NULL;

      if (fdoExtension->PciCardBusDeviceContext != NULL) {
         //
         // If we previously had a cardbus card, and that status has changed, 
         // let PCI learn about the empty slot. If there is currently a
         // cardbus card in the slot then PCI found out anyway.
         //
         status = (*fdoExtension->PciCardBusInterface.DispatchPnp)(fdoExtension->PciCardBusDeviceContext, Irp);
      }         
         
      //
      // Check to see if we are waiting on a remove to finish cleaning up the socket. If so,
      // then don't enumerate anything just yet. Let the remove happen, and enumerate later.
      //
      if (socket->Flags & SOCKET_CLEANUP_MASK) {
         socket->Flags |= SOCKET_ENUMERATE_PENDING;
         DebugPrint((PCMCIA_DEBUG_ENUM, "fdo %08x skt %08x Enumeration deferred! Waiting on remove\n", Fdo, socket));
         continue;
      }

      //
      // Update the current socket status
      //
      PcmciaGetSocketStatus(socket);

      //
      // Now that we are committed to enumerating the card, this can be reset
      //
      ResetSocketFlag(socket, SOCKET_CARD_STATUS_CHANGE);
      
      //
      // Cleanup PCI state if we learn that the status has changed
      //
      
      if (fdoExtension->PciCardBusDeviceContext != NULL) {

         //
         // Let pci clean up 
         //
         (*fdoExtension->PciCardBusInterface.DeleteCardBus)(fdoExtension->PciCardBusDeviceContext);
         fdoExtension->PciCardBusDeviceContext = NULL;
         
         if (IsDeviceFlagSet(fdoExtension, PCMCIA_INT_ROUTE_INTERFACE)) {
            //
            // Here is one might dereference the interface, that is if that
            // ever had any affect, which it doesn't.
            //
            ResetDeviceFlag(fdoExtension, PCMCIA_INT_ROUTE_INTERFACE);
         }
      }
      

      if (!IsCardInSocket(socket)) {
         //
         // This socket is empty, continue
         //
         DebugPrint((PCMCIA_DEBUG_ENUM, "fdo %08x skt %08x Socket is empty\n", Fdo, socket));
         continue;
      }

      //
      // If this is a cardbus card, check to see if we can run it
      //
      
      if (IsCardBusCardInSocket(socket) && IsDeviceFlagSet(fdoExtension, PCMCIA_CARDBUS_NOT_SUPPORTED)) {

         if (!IsSocketFlagSet(socket, SOCKET_SUPPORT_MESSAGE_SENT)) {
            SetSocketFlag(socket, SOCKET_SUPPORT_MESSAGE_SENT);
            PcmciaReportControllerError(fdoExtension, STATUS_CARDBUS_NOT_SUPPORTED);
         }
         continue;
      }
      
      //
      // Some cards may be in a funky state, particularly if the machine crashed
      // previously... power is shown to be on, but the device won't respond. The fix is
      // to force power off first.
      //
      if (!IsDeviceFlagSet(fdoExtension, PCMCIA_FDO_ON_DEBUG_PATH)) {
      
         // 
         // Fool SetSocketPower into actually powering off the card no matter what
         // state it thinks it is in
         //
         SetSocketFlag(socket, SOCKET_CARD_POWERED_UP);
         
         PcmciaSetSocketPower(socket, NULL, NULL, PCMCIA_POWEROFF);
      }
      
      //
      // Power up the socket so the device(s) can be enumerated
      //
      if (!NT_SUCCESS(PcmciaSetSocketPower(socket, NULL, NULL, PCMCIA_POWERON))) {
         //
         // Tell the user there was an error
         //
         PcmciaLogError(fdoExtension, PCMCIA_DEVICE_POWER_ERROR, 1, 0);
         continue;
      }

      //
      // Card found here - but no Pdo for it
      // We create a new pdo for the card & initialize the
      // socket to point to it.
      //

      if (IsCardBusCardInSocket(socket)) {
         //
         // 32-bit cardbus card. Enum via PCI
         //
         
         status = PcmciaEnumerateCardBusCard(socket, Irp);

      } else {
         //
         // R2 card
         //
         status = PcmciaEnumerateR2Card(socket);
         
      }
      
      if (!NT_SUCCESS(status)) {
         DebugPrint((PCMCIA_DEBUG_FAIL, "fdo %08x CardBus enumeration failed: %x\n", Fdo, status));
         //
         // Tell the user there was an error
         //
         PcmciaSetSocketPower(socket, NULL, NULL, PCMCIA_POWEROFF);
         PcmciaLogError(fdoExtension, PCMCIA_DEVICE_ENUMERATION_ERROR, 1, 0);
         continue;
      }
   
      PcmciaSetPowerFromConfigData(socket, fdoExtension->PdoList);
   }

   fdoExtension->LivePdoCount = 0;
   for (pdo = fdoExtension->PdoList; pdo != NULL; pdo = pdoExtension->NextPdoInFdoChain) {
      pdoExtension = pdo->DeviceExtension;
      if (!IsDevicePhysicallyRemoved(pdoExtension)) {
         fdoExtension->LivePdoCount++;
      }
   }

   DebugPrint((PCMCIA_DEBUG_ENUM, "fdo %08x live pdo count = %d\n", Fdo, fdoExtension->LivePdoCount));

   if (fdoExtension->LivePdoCount == 0) {
       //
       // Hint for the controller to check if it should turn itself off
       //               
       PcmciaFdoCheckForIdle(fdoExtension);
   }            
   return status;
}



VOID
PcmciaSetPowerFromConfigData(
   IN PSOCKET         Socket,
   IN PDEVICE_OBJECT  Pdo
   )
/*++

Routine Description:

   This routine will reset the socket power if the CIS of the device contains
   more specific power requirements than is shown on the controller hardware.

Arguments


Return value

   None
   
--*/
{
   PPDO_EXTENSION pdoExtension;
   PSOCKET_DATA   socketData;
   BOOLEAN powerChange = FALSE;
   
   pdoExtension = Pdo->DeviceExtension;
   socketData = pdoExtension->SocketData;

   //
   // Only change Vcc if we are lowering it
   //   
   if (socketData->Vcc && (socketData->Vcc < Socket->Vcc)) {
      //
      // Here we should check the controller if it can support the requested
      // voltage. This isn't implemented, so just hard-wire a check for 5v
      // and 3.3v.
      // 
      if ((socketData->Vcc == 50) || (socketData->Vcc == 33)) {
         powerChange = TRUE;
         Socket->Vcc = socketData->Vcc;
      }         
   }
   
   if (socketData->Vpp1 && (socketData->Vpp1 != Socket->Vpp1)) {
      powerChange = TRUE;
      Socket->Vpp1 = socketData->Vpp1;
   }
   
   if (socketData->Vpp2 && (socketData->Vpp2 != Socket->Vpp2)) {
      powerChange = TRUE;
      Socket->Vpp2 = socketData->Vpp2;
   }

   if (powerChange) {
      PcmciaSetSocketPower(Socket, NULL, NULL, PCMCIA_POWEROFF);
      PcmciaSetSocketPower(Socket, NULL, NULL, PCMCIA_POWERON);
   }   
}
   


NTSTATUS
PcmciaEnumerateCardBusCard(
   IN PSOCKET socket,
   IN PIRP    Irp
   )
/*++

Routine Description:

   This enumerates the cardbus card present in the given cardbus controller

   Note: this routine effectively parties on Irp->IoStatus.Information. This
   value should not be relied upon after return from this routine.

Arguments

   socket          - pointer to the socket structure which contains the cardbus card
   Irp             -  Enumeration irp (IRP_MN_DEVICE_RELATIONS) sent to the controller

Return value

   Status
--*/
{
   PFDO_EXTENSION FdoExtension = socket->DeviceExtension;
   PDEVICE_OBJECT Fdo = FdoExtension->DeviceObject;
   PDEVICE_OBJECT pdo;
   PPDO_EXTENSION pdoExtension = NULL;
   PVOID deviceContext;
   NTSTATUS  status;
   ULONG   i;
   PDEVICE_RELATIONS deviceRelations;

   PAGED_CODE();
   //
   // We should have already done a delete on any previous context
   //
   ASSERT(FdoExtension->PciCardBusDeviceContext == NULL);
   ASSERT(!IsDeviceFlagSet(FdoExtension, PCMCIA_INT_ROUTE_INTERFACE));

   //
   // Call PCI's private AddDevice routine to
   // indicate it needs to play a role in enumerating
   // cardbus cards
   //

   status = (*FdoExtension->PciCardBusInterface.AddCardBus)(FdoExtension->Pdo, &deviceContext);
   FdoExtension->PciCardBusDeviceContext = deviceContext;

   if (!NT_SUCCESS(status)) {
      return status;
   }
   
   status = PcmciaGetInterface(FdoExtension->Pdo,
                               &GUID_INT_ROUTE_INTERFACE_STANDARD,
                               sizeof(INT_ROUTE_INTERFACE_STANDARD),
                               (PINTERFACE) &FdoExtension->PciIntRouteInterface
                               );
                               
   if (NT_SUCCESS(status)) {
      SetDeviceFlag(FdoExtension, PCMCIA_INT_ROUTE_INTERFACE);
   }                                  

   //
   // Call PCI repeatedly till the card is enumerated.
   //
   // We don't let PCI report what has already been reported
   //
   Irp->IoStatus.Information = 0;
   status = STATUS_DEVICE_NOT_READY;

   for (i = 0; i < CARDBUS_CONFIG_RETRY_COUNT; i++) {

      status =  (*FdoExtension->PciCardBusInterface.DispatchPnp)(deviceContext, Irp);

      if (!NT_SUCCESS(status)) {
         //
         // PCI failed this IRP for some reason.
         //
         break;
      }
      deviceRelations = (PDEVICE_RELATIONS) Irp->IoStatus.Information;
      if ((deviceRelations == NULL) ||
          ((deviceRelations)->Count <= 0)) {
         //
         // This is the problem case: try again
         //
         DebugPrint((PCMCIA_DEBUG_ENUM, "fdo %08x Pci enumerated ZERO device objects\n", FdoExtension->DeviceObject));
         status = STATUS_DEVICE_NOT_READY;
      } else {
         //
         // Cardbus card is enumerated, get out of this loop
         //
         DebugPrint((PCMCIA_DEBUG_ENUM, "fdo %08x Pci enumerated %d device object(s)\n",
                              FdoExtension->DeviceObject, (deviceRelations)->Count));
         status = STATUS_SUCCESS;
         break;
      }
   }

   if (!NT_SUCCESS(status)) {
      //
      // Let pci clean up
      //
      (*FdoExtension->PciCardBusInterface.DeleteCardBus)(FdoExtension->PciCardBusDeviceContext);
      FdoExtension->PciCardBusDeviceContext = NULL;
      ResetDeviceFlag(FdoExtension, PCMCIA_INT_ROUTE_INTERFACE);
      return status;
   }                                  
   
   ASSERT (deviceRelations && (deviceRelations->Count > 0));
   for (i = 0; i < deviceRelations->Count; i++) {
      PDEVICE_OBJECT pdo;
      PPDO_EXTENSION pdoExtension;
      //
      // Create a filter device for this pci owned pdo
      //
      status = PcmciaCreatePdo(Fdo, socket, &pdo);
      if (!NT_SUCCESS(status)) {
         //
         // Cleanup allocated socket data structures, if any
         //
         DebugPrint((PCMCIA_DEBUG_FAIL, "fdo %08x create pdo failed %08x\n", Fdo, status));
         continue;
      }
      DebugPrint((PCMCIA_DEBUG_INFO, "fdo %08x created pdo %08x (cardbus)\n", Fdo, pdo));
      pdoExtension = pdo->DeviceExtension;
      //
      // Layer ourselves on top of the PCI ejected pdo
      //
      pdoExtension->PciPdo = deviceRelations->Objects[i];
      MarkDeviceCardBus(pdoExtension);

      if (!NT_SUCCESS(PcmciaGetInterface(pdoExtension->PciPdo,
                                         &GUID_BUS_INTERFACE_STANDARD,
                                         sizeof(BUS_INTERFACE_STANDARD),
                                         (PINTERFACE) &pdoExtension->PciBusInterface))) {
         ASSERT(FALSE);
      }

      GetPciConfigSpace(pdoExtension,
                        CFGSPACE_VENDOR_ID,
                        &pdoExtension->CardBusId,
                        sizeof(ULONG));
      DebugPrint((PCMCIA_DEBUG_ENUM, "pdo %08x CardBusId %08x\n", pdo, pdoExtension->CardBusId));
      
      //
      // Make the intline register of this cardbus card match the parent
      //            
      PcmciaUpdateInterruptLine(pdoExtension, FdoExtension);

      //
      // See if there is any CIS data we may need
      //
      PcmciaGetConfigData(pdoExtension);
      //
      // Attach to stack
      //
      pdoExtension->LowerDevice = IoAttachDeviceToDeviceStack(pdo, deviceRelations->Objects[i]);
      //
      // Link this to the flat chain of PDOs hanging off the controller's extension
      //
      pdoExtension->NextPdoInFdoChain = FdoExtension->PdoList;
      FdoExtension->PdoList = pdo;
      pdoExtension->NextPdoInSocket = socket->PdoList;
      socket->PdoList = pdo;
      pdo->Flags &= ~DO_DEVICE_INITIALIZING;
   }
   //
   // Make the current socket point to the head of the pdo list off this socket
   //
   socket->NumberOfFunctions = (UCHAR) deviceRelations->Count;
   if (socket->NumberOfFunctions > 1) {
      //
      // This socket has a multifunction card in it
      //
      SetSocketFlag(socket, SOCKET_CARD_MULTIFUNCTION);
   }
   
   FdoExtension->PciAddCardBusCount = deviceRelations->Count;
   SetSocketFlag(socket, SOCKET_CLEANUP_PENDING);
   
   ExFreePool(deviceRelations);
   
   return status;
}



NTSTATUS
PcmciaEnumerateR2Card(
   IN PSOCKET socket
   )
/*++

Routine Description:

   This enumerates the R2 card present in the given PCMCIA controller,
   and updates the internal structures to reflect the new card state.


Arguments

   socket - pointer to the socket structure which contains the R2 card

Return value

   Status
--*/
{
   PFDO_EXTENSION fdoExtension = socket->DeviceExtension;
   PDEVICE_OBJECT Fdo = fdoExtension->DeviceObject;
   PDEVICE_OBJECT pdo;
   PPDO_EXTENSION pdoExtension = NULL;
   UCHAR          DeviceType;
   NTSTATUS  status;
   
   status = PcmciaCreatePdo(Fdo, socket, &pdo);

   if (!NT_SUCCESS(status)) {
      return status;
   }
   DebugPrint((PCMCIA_DEBUG_ENUM, "fdo %08x created PDO %08x (R2)\n", Fdo, pdo));
   //
   // initialize the pointers
   //
   pdoExtension = pdo->DeviceExtension;
   //
   // Add a reference count on the socket for power
   //
   PcmciaRequestSocketPower(pdoExtension, NULL);
   
   //
   // Get configuration info
   //
   status = PcmciaGetConfigData(pdoExtension);

   if (!NT_SUCCESS(status)) {
      DebugPrint((PCMCIA_DEBUG_FAIL, "socket %08x GetConfigData failed %08x\n", socket, status));
      MarkDeviceDeleted(pdoExtension);
      IoDeleteDevice(pdo);
      return status;
   }

   DebugPrint((PCMCIA_DEBUG_ENUM, "pdo %08x R2 CardId %x-%x-%x\n", pdo,
                                   pdoExtension->SocketData->ManufacturerCode,
                                   pdoExtension->SocketData->ManufacturerInfo,
                                   pdoExtension->SocketData->CisCrc
                                   ));
   
   //
   // Make the socket point to the head of the pdo's hanging off this socket
   //
   socket->PdoList = pdo;
   //
   // Link this to the flat chain of PDOs hanging off the controller's extension
   //
   pdoExtension->NextPdoInFdoChain = fdoExtension->PdoList;
   fdoExtension->PdoList = pdo;
   //
   // Remember if this is a multifunction card in the
   // parent pdo itself
   //
   if (socket->NumberOfFunctions > 1) {
         //
         // This is a multifunction card
         //
         MarkDeviceMultifunction(pdoExtension);
   }

   pdo->Flags &= ~DO_DEVICE_INITIALIZING;

   ASSERT(pdoExtension->SocketData);
   DeviceType = pdoExtension->SocketData->DeviceType;
   if (DeviceType == PCCARD_TYPE_MODEM   ||
       DeviceType == PCCARD_TYPE_SERIAL  ||
       DeviceType == PCCARD_TYPE_NETWORK ||
       DeviceType == PCCARD_TYPE_MULTIFUNCTION3) {
       //
       // We want power IRPs at < DPC_LEVEL
       //
       pdo->Flags |= DO_POWER_PAGABLE;
   }

   SetSocketFlag(socket, SOCKET_CLEANUP_PENDING);
   return status;
}


NTSTATUS
PcmciaDeviceRelations(
   IN PDEVICE_OBJECT Fdo,
   IN PIRP           Irp,
   IN DEVICE_RELATION_TYPE RelationType,
   OUT PDEVICE_RELATIONS *DeviceRelations
   )

/*++

Routine Description:

    This routine will force enumeration of the PCMCIA controller represented by Fdo,
    allocate a device relations structure and fill in the count and object array with
    referenced object pointers to the valid PDOs which are created during enumeration

Arguments:

    Fdo - a pointer to the functional device object being enumerated
    Irp - pointer to the Irp
    RelationType - Type of relationship to be retrieved
    DeviceRelations - Structure to store the device relations

--*/

{

   PDEVICE_OBJECT currentPdo;
   PPDO_EXTENSION currentPdoExtension;
   PFDO_EXTENSION fdoExtension = Fdo->DeviceExtension;
   ULONG newRelationsSize, oldRelationsSize = 0;
   PDEVICE_RELATIONS deviceRelations = NULL, oldDeviceRelations;
   ULONG i;
   ULONG count;

   NTSTATUS status;

   PAGED_CODE();

   //
   // Handle only bus, ejection & removal relations for now
   //

   if (RelationType != BusRelations &&
       RelationType != RemovalRelations) {
      DebugPrint((PCMCIA_DEBUG_INFO,
                  "PcmciaDeviceRelations: RelationType %d, not handled\n",
                  (USHORT) RelationType));
      return STATUS_NOT_SUPPORTED;
   }

   //
   // Need reenumeration only if bus relations are required
   // We need to save the pointer to the old device relations
   // before we call PcmciaReenumerateDevices, as it might trample
   // on it
   //
   oldDeviceRelations = (PDEVICE_RELATIONS) Irp->IoStatus.Information;
   
   // I don't understand how this can be non-null, so I added this
   // assert to find out.
   ASSERT(oldDeviceRelations == NULL);

   if (RelationType == BusRelations) {
      status =  PcmciaEnumerateDevices(Fdo, Irp);
      if (!NT_SUCCESS(status)) {
         return status;
      }
   }

   if ((fdoExtension->LivePdoCount == 0) ||
       (RelationType == RemovalRelations)) {
      //
      // No PDO's to report, we can return early.
      // If no device_relations structure has yet been allocated, however,
      // we need to allocate one & set the count to zero. This will ensure
      // that regardless of whether we pass this IRP down or not, the IO
      // subsystem won't barf.
      //
      if (oldDeviceRelations == NULL) {
         *DeviceRelations = ExAllocatePool(PagedPool, sizeof(DEVICE_RELATIONS));
         if (*DeviceRelations == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
         }
         (*DeviceRelations)->Count = 0;
         (*DeviceRelations)->Objects[0] = NULL;
      }
      return STATUS_SUCCESS;
   }

   if (!(oldDeviceRelations) || (oldDeviceRelations->Count == 0)) {
      newRelationsSize =  sizeof(DEVICE_RELATIONS)+(fdoExtension->LivePdoCount - 1)
                          * sizeof(PDEVICE_OBJECT);
   } else {
      oldRelationsSize = sizeof(DEVICE_RELATIONS) +
                         (oldDeviceRelations->Count-1) * sizeof(PDEVICE_OBJECT);
      newRelationsSize = oldRelationsSize + fdoExtension->LivePdoCount
                         * sizeof(PDEVICE_OBJECT);
   }

   deviceRelations = ExAllocatePool(PagedPool, newRelationsSize);

   if (deviceRelations == NULL) {

      DebugPrint((PCMCIA_DEBUG_FAIL,
                  "PcmciaDeviceRelations: unable to allocate %d bytes for device relations\n",
                  newRelationsSize));
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   if (oldDeviceRelations) {
      if ((oldDeviceRelations)->Count > 0) {
         RtlCopyMemory(deviceRelations, oldDeviceRelations, oldRelationsSize);
      }
      count = oldDeviceRelations->Count; // May be zero
      ExFreePool (oldDeviceRelations);
   } else {
      count = 0;
   }
   //
   // Copy the object pointers into the structure
   //
   for (currentPdo = fdoExtension->PdoList ;currentPdo != NULL;
       currentPdo = currentPdoExtension->NextPdoInFdoChain) {

      currentPdoExtension = currentPdo->DeviceExtension;

      if (!IsDevicePhysicallyRemoved(currentPdoExtension)) {
         //
         // Return PCI pdo if it's a cardbus card
         //
         if (IsCardBusCard(currentPdoExtension)) {
            ASSERT(currentPdoExtension->PciPdo != NULL);
            //
            // Return the PDO provided by PCI instead of our filter
            //
            deviceRelations->Objects[count++] = currentPdoExtension->PciPdo;
            status = ObReferenceObjectByPointer(currentPdoExtension->PciPdo,
                                                0,
                                                NULL,
                                                KernelMode);
         } else {
            //
            // Devices have to be referenced by the bus driver
            // before returning them to PNP
            //
            deviceRelations->Objects[count++] = currentPdo;
            status = ObReferenceObjectByPointer(currentPdo,
                                                0,
                                                NULL,
                                                KernelMode);
         }

         if (!NT_SUCCESS(status)) {

            DebugPrint((PCMCIA_DEBUG_FAIL, "PcmciaDeviceRelations: status %#08lx "
                        "while referencing object %#08lx\n",
                        status,
                        currentPdo));
         }
      }
   }

   deviceRelations->Count = count;
   *DeviceRelations = deviceRelations;
   return STATUS_SUCCESS;
}



NTSTATUS
PcmciaCreatePdo(
   IN PDEVICE_OBJECT Fdo,
   IN PSOCKET Socket,
   OUT PDEVICE_OBJECT *PdoPtr
   )
/*++

Routine Description:
   Creates and initializes a device object - which will be referred to as a Physical Device
   Object or PDO - for the PC-Card in the socket represented by Socket, hanging off the PCMCIA
   controller represented by Fdo.

Arguments:

   Fdo    - Functional device object representing the PCMCIA controller
   Socket - Socket in which the PC-Card for which we're creating a PDO resides
   PdoPtr - Pointer to an area of memory where the created PDO is returned

Return value:

    STATUS_SUCCESS - Pdo creation/initialization successful, PdoPtr contains the pointer
                     to the Pdo
    Any other status - creation/initialization unsuccessful

--*/
{
   ULONG pdoNameIndex = 0, socketNumber;
   PSOCKET currentSocket;
   PPDO_EXTENSION pdoExtension;
   PFDO_EXTENSION fdoExtension=Fdo->DeviceExtension;
   char deviceName[128];
   ANSI_STRING ansiName;
   UNICODE_STRING unicodeName;
   NTSTATUS status;

   PAGED_CODE();

   //
   // Locate socket 'number'
   //
   for (currentSocket=fdoExtension->SocketList, socketNumber=0;
       currentSocket && (currentSocket != Socket);
       currentSocket = currentSocket->NextSocket, socketNumber++);

   //
   // Allocate space for the Unicode string:(handles upto 0xFFFF
   // devices for now :)
   //
   sprintf(deviceName, "%s%d-%d", PCMCIA_PCCARD_NAME,socketNumber, 0xFFFF);
   RtlInitAnsiString(&ansiName, deviceName);
   status = RtlAnsiStringToUnicodeString(&unicodeName, &ansiName, TRUE);
   if (!NT_SUCCESS(status)) {
      return status;
   }

   //
   // Attempt to create the device with a unique name
   //
   do {
      sprintf(deviceName, "%s%d-%d", PCMCIA_PCCARD_NAME,socketNumber, pdoNameIndex++);
      RtlInitAnsiString(&ansiName, deviceName);
      status = RtlAnsiStringToUnicodeString(&unicodeName, &ansiName, FALSE);

      if (!NT_SUCCESS(status)) {
         RtlFreeUnicodeString(&unicodeName);
         return status;
      }

      status = IoCreateDevice(
                             Fdo->DriverObject,
                             sizeof(PDO_EXTENSION),
                             &unicodeName,
                             FILE_DEVICE_UNKNOWN,
                             0,
                             FALSE,
                             PdoPtr
                             );
   } while ((status == STATUS_OBJECT_NAME_EXISTS) ||
            (status == STATUS_OBJECT_NAME_COLLISION));

   RtlFreeUnicodeString(&unicodeName);

   if (!NT_SUCCESS(status)) {
      return status;
   }

   //
   // Initialize the device extension for the PDO
   //
   pdoExtension = (*PdoPtr)->DeviceExtension;
   RtlZeroMemory(pdoExtension, sizeof(PDO_EXTENSION));

   pdoExtension->DeviceObject = *PdoPtr;
   pdoExtension->Socket = Socket;

   //
   // Initialize power states
   //
   pdoExtension->SystemPowerState = PowerSystemWorking;
   pdoExtension->DevicePowerState = PowerDeviceD0;

   //
   // Initialize pending enable objects
   //
   KeInitializeTimer(&pdoExtension->ConfigurationTimer);

   KeInitializeDpc(&pdoExtension->ConfigurationDpc,
                   PcmciaConfigurationWorker,
                   pdoExtension);

   KeInitializeTimer(&pdoExtension->PowerWorkerTimer);

   KeInitializeDpc(&pdoExtension->PowerWorkerDpc,
                   PcmciaPdoPowerWorkerDpc,
                   pdoExtension);

   //
   // PNP is going to mark the PDO as a DO_BUS_ENUMERATED_DEVICE,
   // but for CardBus cards- the PDO we return is owned by PCI.
   // Hence we need to mark this device object (in that case a
   // filter on top of PCI's PDO) as PDO explicitly.
   //
   MARK_AS_PDO(*PdoPtr);

   return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\pcmcibus\fdopower.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    fdopower.c

Abstract:

    This module contains code to handle
    IRP_MJ_POWER dispatches for PCMCIA controllers
    Contains support routines for pc-card power management


Authors:

    Ravisankar Pudipeddi (ravisp) May 30, 1997
    Neil Sandlin (neilsa) June 1, 1999

Environment:

    Kernel mode only

Notes:

Revision History:

    Neil Sandlin (neilsa) April 16, 1999
      - split setpower into device and system, fixed synchronization

--*/

#include "pch.h"

//
// Internal References
//

NTSTATUS
PcmciaFdoWaitWake(
   IN PDEVICE_OBJECT Fdo,
   IN PIRP           Irp
   );

NTSTATUS
PcmciaFdoWaitWakeIoCompletion(
   IN PDEVICE_OBJECT Fdo,
   IN PIRP           Irp,
   IN PVOID          Context
   );
   
NTSTATUS
PcmciaFdoSaveControllerContext(
   IN PFDO_EXTENSION FdoExtension
   );

NTSTATUS
PcmciaFdoRestoreControllerContext(
   IN PFDO_EXTENSION FdoExtension
   );

NTSTATUS
PcmciaFdoSaveSocketContext(
   IN PSOCKET Socket
   );

NTSTATUS
PcmciaFdoRestoreSocketContext(
   IN PSOCKET Socket
   );

NTSTATUS
PcmciaSetFdoPowerState(
   IN PDEVICE_OBJECT Fdo,
   IN OUT PIRP Irp
   );

NTSTATUS
PcmciaSetFdoSystemPowerState(
   IN PDEVICE_OBJECT Fdo,
   IN OUT PIRP Irp
   );

VOID
PcmciaFdoSystemPowerDeviceIrpComplete(
   IN PDEVICE_OBJECT Fdo,
   IN UCHAR MinorFunction,
   IN POWER_STATE PowerState,
   IN PVOID Context,
   IN PIO_STATUS_BLOCK IoStatus
   );
   
NTSTATUS
PcmciaSetFdoDevicePowerState(
   IN PDEVICE_OBJECT Fdo,
   IN OUT PIRP Irp
   );

NTSTATUS
PcmciaFdoPowerWorker (
   IN PVOID Context,
   IN NTSTATUS Status
   );
   
NTSTATUS
PcmciaFdoDevicePowerCompletion(
   IN PDEVICE_OBJECT Fdo,
   IN PIRP Irp,
   IN PVOID Context
   );
   
//
//
//   


NTSTATUS
PcmciaFdoPowerDispatch(
   IN PDEVICE_OBJECT Fdo,
   IN PIRP Irp
   )

/*++

Routine Description:

    This routine handles power requests
    for the PDOs.

Arguments:

    Pdo - pointer to the physical device object
    Irp - pointer to the io request packet

Return Value:

    status

--*/

{
   PFDO_EXTENSION fdoExtension = Fdo->DeviceExtension;
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
   NTSTATUS        status = STATUS_INVALID_DEVICE_REQUEST;


   switch (irpStack->MinorFunction) {

   case IRP_MN_SET_POWER: {

         DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x irp %08x --> IRP_MN_SET_POWER\n", Fdo, Irp));
         DebugPrint((PCMCIA_DEBUG_POWER, "                              (%s%x context %x)\n",
                     (irpStack->Parameters.Power.Type == SystemPowerState)  ?
                     "S":
                     ((irpStack->Parameters.Power.Type == DevicePowerState) ?
                      "D" :
                      "Unknown"),
                     irpStack->Parameters.Power.State,
                     irpStack->Parameters.Power.SystemContext
                    ));
         status = PcmciaSetFdoPowerState(Fdo, Irp);
         break;
      }

   case IRP_MN_QUERY_POWER: {

         DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x irp %08x --> IRP_MN_QUERY_POWER\n", Fdo, Irp));
         DebugPrint((PCMCIA_DEBUG_POWER, "                              (%s%x context %x)\n",
                     (irpStack->Parameters.Power.Type == SystemPowerState)  ?
                     "S":
                     ((irpStack->Parameters.Power.Type == DevicePowerState) ?
                      "D" :
                      "Unknown"),
                     irpStack->Parameters.Power.State,
                     irpStack->Parameters.Power.SystemContext
                    ));
         //
         // Let the pdo handle it
         //
         PoStartNextPowerIrp(Irp);
         IoSkipCurrentIrpStackLocation(Irp);
         status = PoCallDriver(fdoExtension->LowerDevice, Irp);
         break;
      }

   case IRP_MN_WAIT_WAKE: {
         DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x irp %08x --> IRP_MN_WAIT_WAKE\n", Fdo, Irp));
         status = PcmciaFdoWaitWake(Fdo, Irp);
         break;
      }

   default: {
         DebugPrint((PCMCIA_DEBUG_POWER, "FdoPowerDispatch: Unhandled Irp %x received for 0x%08x\n",
                     Irp,
                     Fdo));

         PoStartNextPowerIrp(Irp);
         IoSkipCurrentIrpStackLocation(Irp);
         status = PoCallDriver(fdoExtension->LowerDevice, Irp);
         break;
      }
   }
   DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x irp %08x <-- %08x\n", Fdo, Irp, status));
   return status;
}


/**************************************************************************

   WAKE ROUTINES

 **************************************************************************/
 

NTSTATUS
PcmciaFdoWaitWake(
   IN PDEVICE_OBJECT Fdo,
   IN PIRP           Irp
   )
/*++


Routine Description

   Handles WAIT_WAKE for the given pcmcia controller

Arguments

   Pdo - Pointer to the functional device object for the pcmcia controller
   Irp - The IRP_MN_WAIT_WAKE Irp

Return Value

   STATUS_PENDING    - Wait wake is pending
   STATUS_SUCCESS    - Wake is already asserted, wait wake IRP is completed
                       in this case
   Any other status  - Error
--*/

{
   PFDO_EXTENSION fdoExtension = Fdo->DeviceExtension;
   WAKESTATE oldWakeState;

   //
   // Record the wait wake Irp..
   //
   fdoExtension->WaitWakeIrp = Irp;
   
   oldWakeState = InterlockedCompareExchange(&fdoExtension->WaitWakeState,
                                             WAKESTATE_ARMED, WAKESTATE_WAITING);
                                             
   DebugPrint((PCMCIA_DEBUG_POWER, "fdo %x irp %x WaitWake: prevState %s\n",
                                    Fdo, Irp, WAKESTATE_STRING(oldWakeState)));
                  
   if (oldWakeState == WAKESTATE_WAITING_CANCELLED) {
      fdoExtension->WaitWakeState = WAKESTATE_COMPLETING;
      
      Irp->IoStatus.Status = STATUS_CANCELLED;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
      return STATUS_CANCELLED;
   }
   
   IoMarkIrpPending(Irp);

   IoCopyCurrentIrpStackLocationToNext (Irp);
   //
   // Set our completion routine in the Irp..
   //
   IoSetCompletionRoutine(Irp,
                          PcmciaFdoWaitWakeIoCompletion,
                          Fdo,
                          TRUE,
                          TRUE,
                          TRUE);
   //
   // now pass this down to the lower driver..
   //
   PoCallDriver(fdoExtension->LowerDevice, Irp);
   return STATUS_PENDING;
}


NTSTATUS
PcmciaFdoWaitWakeIoCompletion(
   IN PDEVICE_OBJECT Fdo,
   IN PIRP           Irp,
   IN PVOID          Context
   )
/*++

Routine Description:

   Completion routine for the IRP_MN_WAIT_WAKE request for this
   pcmcia controller. This is called when the WAIT_WAKE IRP is
   completed by the lower driver (PCI/ACPI) indicating either that
   1. PCMCIA controller asserted wake
   2. WAIT_WAKE was cancelled
   3. Lower driver returned an error for some reason

Arguments:
   Fdo            -    Pointer to Functional device object for the pcmcia controller
   Irp            -    Pointer to the IRP for the  power request (IRP_MN_WAIT_WAKE)
   Context        -    Not used

Return Value:

   STATUS_SUCCESS   - WAIT_WAKE was completed with success
   Any other status - Wake could be not be accomplished.

--*/
{
   PFDO_EXTENSION fdoExtension = Fdo->DeviceExtension;
   PPDO_EXTENSION pdoExtension;
   PDEVICE_OBJECT pdo;
   WAKESTATE oldWakeState;

   UNREFERENCED_PARAMETER(Context);

   oldWakeState = InterlockedExchange(&fdoExtension->WaitWakeState, WAKESTATE_COMPLETING);

   DebugPrint((PCMCIA_DEBUG_POWER, "fdo %x irp %x WW IoComp: prev=%s\n",
                                    Fdo, Irp, WAKESTATE_STRING(oldWakeState)));
                  
   if (oldWakeState != WAKESTATE_ARMED) {
      ASSERT(oldWakeState == WAKESTATE_ARMING_CANCELLED);
      return STATUS_MORE_PROCESSING_REQUIRED;
   }            


   if (IsFdoFlagSet(fdoExtension, PCMCIA_FDO_WAKE_BY_CD)) {
      POWER_STATE powerState;

      ResetFdoFlag(fdoExtension, PCMCIA_FDO_WAKE_BY_CD);
   
      PoStartNextPowerIrp(Irp);
      
      powerState.DeviceState = PowerDeviceD0;
      PoRequestPowerIrp(fdoExtension->DeviceObject, IRP_MN_SET_POWER, powerState, NULL, NULL, NULL);
      
   } else {
      // NOTE:
      // At this point we do NOT know how to distinguish which function
      // in a multifunction device has asserted wake.
      // So we go through the entire list of PDOs hanging off this FDO
      // and complete all the outstanding WAIT_WAKE Irps for every PDO that
      // that's waiting. We leave it up to the FDO for the device to figure
      // if it asserted wake
      //
     
      for (pdo = fdoExtension->PdoList; pdo != NULL ; pdo = pdoExtension->NextPdoInFdoChain) {
     
         pdoExtension = pdo->DeviceExtension;
     
         if (IsDeviceLogicallyRemoved(pdoExtension) ||
             IsDevicePhysicallyRemoved(pdoExtension)) {
            //
            // This pdo is about to be removed ..
            // skip it
            //
            continue;
         }
     
         if (pdoExtension->WaitWakeIrp != NULL) {
            PIRP  finishedIrp;
            //
            // Ah.. this is a possible candidate to have asserted the wake
            //
            //
            // Make sure this IRP will not be completed again or cancelled
            //
            finishedIrp = pdoExtension->WaitWakeIrp;
            
            DebugPrint((PCMCIA_DEBUG_POWER, "fdo %x WW IoComp: irp %08x for pdo %08x\n",
                                             Fdo, finishedIrp, pdo));

     
            IoSetCancelRoutine(finishedIrp, NULL);
            //
            // Propagate parent's status to child
            //
            PoStartNextPowerIrp(finishedIrp);
            finishedIrp->IoStatus.Status = Irp->IoStatus.Status;
            
            //
            // Since we didn't pass this IRP down, call our own completion routine
            //
            PcmciaPdoWaitWakeCompletion(pdo, finishedIrp, pdoExtension);
            IoCompleteRequest(finishedIrp, IO_NO_INCREMENT);
         }
      }
      PoStartNextPowerIrp(Irp);
   }
   
   return Irp->IoStatus.Status;
}



VOID
PcmciaFdoWaitWakePoCompletion(
   IN PDEVICE_OBJECT Fdo,
   IN UCHAR MinorFunction,
   IN POWER_STATE PowerState,
   IN PVOID Context,
   IN PIO_STATUS_BLOCK IoStatus
   )
/*++

Routine Description

   This routine is called on completion of a D irp generated by an S irp.

Parameters

   DeviceObject   -  Pointer to the Fdo for the PCMCIA controller
   MinorFunction  -  Minor function of the IRP_MJ_POWER request
   PowerState     -  Power state requested 
   Context        -  Context passed in to the completion routine
   IoStatus       -  Pointer to the status block which will contain
                     the returned status
Return Value

   Status

--*/
{
   PFDO_EXTENSION fdoExtension = Fdo->DeviceExtension;

   DebugPrint((PCMCIA_DEBUG_POWER, "fdo %x irp %x WaitWakePoCompletion: prevState %s\n",
                                    Fdo, fdoExtension->WaitWakeIrp,
                                    WAKESTATE_STRING(fdoExtension->WaitWakeState)));
   
   ASSERT (fdoExtension->WaitWakeIrp);
   fdoExtension->WaitWakeIrp = NULL;
   ASSERT (fdoExtension->WaitWakeState == WAKESTATE_COMPLETING);
   fdoExtension->WaitWakeState = WAKESTATE_DISARMED;
}



NTSTATUS
PcmciaFdoArmForWake(
   PFDO_EXTENSION FdoExtension
   )
/*++

Routine Description:

   This routine is called to enable the controller for wake. It is called by the Pdo
   wake routines when a wake-enabled controller gets a wait-wake irp, and also by
   the idle routine to arm for wake from D3 by card insertion.

Arguments:

   FdoExtension - device extension of the controller

Return Value:

   status

--*/
{
   NTSTATUS status = STATUS_PENDING;
   PIO_STACK_LOCATION irpStack;
   PIRP irp;
   LONG oldWakeState;
   POWER_STATE powerState;
   
   oldWakeState = InterlockedCompareExchange(&FdoExtension->WaitWakeState,
                                             WAKESTATE_WAITING, WAKESTATE_DISARMED);

   DebugPrint((PCMCIA_DEBUG_POWER, "fdo %x ArmForWake: prevState %s\n",
                                    FdoExtension->DeviceObject, WAKESTATE_STRING(oldWakeState)));
   
   if ((oldWakeState == WAKESTATE_ARMED) || (oldWakeState == WAKESTATE_WAITING)) {
      return STATUS_SUCCESS;
   }
   if (oldWakeState != WAKESTATE_DISARMED) {
      return STATUS_UNSUCCESSFUL;
   }

   
   
   powerState.SystemState = FdoExtension->DeviceCapabilities.SystemWake;
   
   status = PoRequestPowerIrp(FdoExtension->DeviceObject,
                              IRP_MN_WAIT_WAKE, 
                              powerState,
                              PcmciaFdoWaitWakePoCompletion,
                              NULL,
                              NULL);
   
   if (!NT_SUCCESS(status)) {
   
      FdoExtension->WaitWakeState = WAKESTATE_DISARMED;
       
      DebugPrint((PCMCIA_DEBUG_POWER, "WaitWake to FDO, expecting STATUS_PENDING, got %08X\n", status));
   }
   
   return status;
}



NTSTATUS
PcmciaFdoDisarmWake(
   PFDO_EXTENSION FdoExtension
   )
/*++

Routine Description:

   This routine is called to disable the controller for wake.

Arguments:

   FdoExtension - device extension of the controller

Return Value:

   status

--*/
{
   WAKESTATE oldWakeState;
   
   oldWakeState = InterlockedCompareExchange(&FdoExtension->WaitWakeState,
                                             WAKESTATE_WAITING_CANCELLED, WAKESTATE_WAITING);
                                             
   DebugPrint((PCMCIA_DEBUG_POWER, "fdo %x DisarmWake: prevState %s\n",
                                    FdoExtension->DeviceObject, WAKESTATE_STRING(oldWakeState)));
   
   if (oldWakeState != WAKESTATE_WAITING) {                                             

      oldWakeState = InterlockedCompareExchange(&FdoExtension->WaitWakeState,
                                                WAKESTATE_ARMING_CANCELLED, WAKESTATE_ARMED);
                                                
      if (oldWakeState != WAKESTATE_ARMED) {
         return STATUS_UNSUCCESSFUL;
      }
   }

   if (oldWakeState == WAKESTATE_ARMED) {
      IoCancelIrp(FdoExtension->WaitWakeIrp);

      //
      // Now that we've cancelled the IRP, try to give back ownership
      // to the completion routine by restoring the WAKESTATE_ARMED state
      //
      oldWakeState = InterlockedCompareExchange(&FdoExtension->WaitWakeState,
                                                WAKESTATE_ARMED, WAKESTATE_ARMING_CANCELLED);

      if (oldWakeState == WAKESTATE_COMPLETING) {
         //
         // We didn't give control back of the IRP in time, we we own it now
         //
         IoCompleteRequest(FdoExtension->WaitWakeIrp, IO_NO_INCREMENT);
      }

   }                                                

   return STATUS_SUCCESS;
}



NTSTATUS
PcmciaFdoCheckForIdle(
   IN PFDO_EXTENSION FdoExtension
   )
{
   POWER_STATE powerState;
   NTSTATUS status;
   PSOCKET socket;
   
   if (!(PcmciaPowerPolicy & PCMCIA_PP_D3_ON_IDLE)) {
      return STATUS_SUCCESS;
   }

   //
   // Make sure all sockets are empty
   //
   
   for (socket = FdoExtension->SocketList; socket != NULL; socket = socket->NextSocket) {
      if (IsCardInSocket(socket)) {
         return STATUS_UNSUCCESSFUL;
      }
   }
   
   //
   // Arm for wakeup
   //
      
   status = PcmciaFdoArmForWake(FdoExtension);
   
   if (!NT_SUCCESS(status)) {
      return status;
   }   

   SetFdoFlag(FdoExtension, PCMCIA_FDO_WAKE_BY_CD);

   powerState.DeviceState = PowerDeviceD3;
   PoRequestPowerIrp(FdoExtension->DeviceObject, IRP_MN_SET_POWER, powerState, NULL, NULL, NULL);
   
   return STATUS_SUCCESS;
}   
            
           

/**************************************************************************

   POWER ROUTINES

 **************************************************************************/
 


NTSTATUS
PcmciaSetFdoPowerState(
   IN PDEVICE_OBJECT Fdo,
   IN OUT PIRP Irp
   )
/*++

Routine Description

   Dispatches the IRP based on whether a system power state
   or device power state transition is requested

Arguments

   DeviceObject      - Pointer to the functional device object for the pcmcia controller
   Irp               - Pointer to the Irp for the power dispatch

Return value

   status

--*/
{
   PFDO_EXTENSION     fdoExtension = Fdo->DeviceExtension;
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
   NTSTATUS           status;
   
   if (irpStack->Parameters.Power.Type == DevicePowerState) {
      status = PcmciaSetFdoDevicePowerState(Fdo, Irp);

   } else if (irpStack->Parameters.Power.Type == SystemPowerState) {
      status = PcmciaSetFdoSystemPowerState(Fdo, Irp);

   } else {
      status = Irp->IoStatus.Status;
      PoStartNextPowerIrp (Irp);
      IoCompleteRequest(Irp, IO_NO_INCREMENT);      
   }

   return status;
}


NTSTATUS
PcmciaSetFdoSystemPowerState(
   IN PDEVICE_OBJECT Fdo,
   IN OUT PIRP Irp
   )
/*++

Routine Description

   Handles system power state IRPs for the pccard controller.

Arguments

   DeviceObject      - Pointer to the functional device object for the pcmcia controller
   Irp               - Pointer to the Irp for the power dispatch

Return value

   status

--*/
{
   PFDO_EXTENSION     fdoExtension = Fdo->DeviceExtension;
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
   SYSTEM_POWER_STATE newSystemState = irpStack->Parameters.Power.State.SystemState;
   NTSTATUS           status = STATUS_SUCCESS;
   POWER_STATE        powerState;

   ASSERT(irpStack->Parameters.Power.Type == SystemPowerState);

   //
   // Find the device power state corresponding to this system state
   //
   if (newSystemState >= PowerSystemHibernate) {
      //
      // Turn device off beyond hibernate..
      //
      powerState.DeviceState = PowerDeviceD3;
   } else {
      //
      // Switch to the appropriate device power state
      //

      powerState.DeviceState = fdoExtension->DeviceCapabilities.DeviceState[newSystemState];
         
         
      if (powerState.DeviceState == PowerDeviceUnspecified) {
          //
          // Capabilities not obtained?
          // do the best we can
          //
          // Working --> D0
          // otherwise power it off
          //
          if (newSystemState == PowerSystemWorking) {
              powerState.DeviceState = PowerDeviceD0;
          } else {
              powerState.DeviceState = PowerDeviceD3;
          }
      }
      
      // NOTE: HACKHACK:
      //
      // This hack is available to work around a BIOS bug. The way that WOL is supposed to work
      // is that, after the device causes the wake, then the BIOS should run a method which 
      // issues a "notify(,0x2)", and thus prompting ACPI to complete the wait-wake IRP. If the
      // W/W IRP is completed, then this allows the device state to be cleared before repowering
      // the device.
      //
      // If the device state is not cleared, then we get an interrupt storm. This happens because
      // when PCI.SYS switches the device to D0, then the PME# which was asserted to wake the system
      // is still firing, which becomes a cardbus STSCHG interrupt, which asserts the PCI IRQ. But
      // the act of switching the device to D0 has cleared the socket register BAR, so now the ISR
      // can't clear the interrupt.
      //
      // The risk of forcing the device to D0 while going to standby is that the machine may be
      // designed such that cardbus bridge may not function. So this should only be applied when
      // we know that it will work.
      //

      if ((PcmciaPowerPolicy & PCMCIA_PP_WAKE_FROM_D0) &&
         (powerState.DeviceState != PowerDeviceD0) && (fdoExtension->WaitWakeState != WAKESTATE_DISARMED) &&
         (newSystemState < PowerSystemHibernate)) {      
         powerState.DeviceState = PowerDeviceD0;   // force D0
      }       
   }
   //
   // Transitioned to system state
   //
   DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x irp %08x transition S state %d => %d, sending D%d\n",
                                   Fdo, Irp, fdoExtension->SystemPowerState-1, newSystemState-1, powerState.DeviceState-1));

   fdoExtension->SystemPowerState = newSystemState;
   //
   // Send a D IRP to the cardbus controller stack if necessary
   //
   if ((powerState.DeviceState > PowerDeviceUnspecified) &&
       (powerState.DeviceState != fdoExtension->DevicePowerState)) {


      if (powerState.DeviceState == PowerDeviceD0) {
         //
         // Powering up, optimize by letting the S irp complete immediately
         //
         PoRequestPowerIrp(fdoExtension->DeviceObject, IRP_MN_SET_POWER, powerState, NULL, NULL, NULL);
         PoSetPowerState (Fdo, SystemPowerState, irpStack->Parameters.Power.State);
         //
         // Send the S IRP to the pdo
         //
         PoStartNextPowerIrp (Irp);
         IoSkipCurrentIrpStackLocation(Irp);
         status = PoCallDriver(fdoExtension->LowerDevice, Irp);
         
      } else {
      
         IoMarkIrpPending(Irp);

         status = PoRequestPowerIrp(fdoExtension->DeviceObject,
                                    IRP_MN_SET_POWER,
                                    powerState,
                                    PcmciaFdoSystemPowerDeviceIrpComplete,
                                    Irp,
                                    NULL
                                    );

         if (status != STATUS_PENDING) {
            //
            // Probably low memory failure
            //
            ASSERT( !NT_SUCCESS(status) );
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            //
            // We've already marked the IRP pending, so we must return STATUS_PENDING
            // (ie fail it asynchronously)
            //
            status = STATUS_PENDING;
         }
                                    
      }
                                       
   } else {
      PoSetPowerState (Fdo, SystemPowerState, irpStack->Parameters.Power.State);
      //
      // Send the S IRP to the pdo
      //
      PoStartNextPowerIrp (Irp);
      IoSkipCurrentIrpStackLocation(Irp);
      status = PoCallDriver(fdoExtension->LowerDevice, Irp);
   }

   DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x irp %08x <-- %08x\n", Fdo, Irp, status));
                                   
   return status;
}


VOID
PcmciaFdoSystemPowerDeviceIrpComplete(
   IN PDEVICE_OBJECT Fdo,
   IN UCHAR MinorFunction,
   IN POWER_STATE PowerState,
   IN PVOID Context,
   IN PIO_STATUS_BLOCK IoStatus
   )
/*++

Routine Description

   This routine is called on completion of a D irp generated by an S irp.

Parameters

   DeviceObject   -  Pointer to the Fdo for the PCMCIA controller
   MinorFunction  -  Minor function of the IRP_MJ_POWER request
   PowerState     -  Power state requested 
   Context        -  Context passed in to the completion routine
   IoStatus       -  Pointer to the status block which will contain
                     the returned status
Return Value

   Status

--*/
{
   PFDO_EXTENSION fdoExtension = Fdo->DeviceExtension;
   PIRP Irp = Context;
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
   
   ASSERT(NT_SUCCESS(IoStatus->Status));
   
   PoSetPowerState (Fdo, SystemPowerState, irpStack->Parameters.Power.State);
   
   DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x irp %08x request for D%d complete, passing S irp down\n",
                                    Fdo, Irp, PowerState.DeviceState-1));
   //
   // Send the S IRP to the pdo
   //
   PoStartNextPowerIrp (Irp);
   IoSkipCurrentIrpStackLocation(Irp);
   PoCallDriver(fdoExtension->LowerDevice, Irp);
}



NTSTATUS
PcmciaSetFdoDevicePowerState (
   IN PDEVICE_OBJECT Fdo,
   IN OUT PIRP Irp
   )
/*++

Routine Description

   Handles device power state IRPs for the pccard controller.

Arguments

   DeviceObject      - Pointer to the functional device object for the pcmcia controller
   Irp               - Pointer to the Irp for the power dispatch

Return value

   status

--*/
{
   NTSTATUS           status;
   PFDO_EXTENSION     fdoExtension = Fdo->DeviceExtension;
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

   if ((fdoExtension->PendingPowerIrp != NULL) || (fdoExtension->PowerWorkerState != FPW_Stopped)) {
      //
      // oops. We already have a pending irp.
      //
      ASSERT(fdoExtension->PendingPowerIrp == NULL);
      status = STATUS_DEVICE_BUSY;
      Irp->IoStatus.Status = status;
      PoStartNextPowerIrp (Irp);
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
      
   } else {
      
      fdoExtension->PendingPowerIrp = Irp;
      
      if (irpStack->Parameters.Power.State.DeviceState != PowerDeviceD0) {
         fdoExtension->PowerWorkerState = FPW_BeginPowerDown;
      } else {
         fdoExtension->PowerWorkerState = FPW_BeginPowerUp;
      }         
      status = PcmciaFdoPowerWorker(Fdo, STATUS_SUCCESS);               

   }
   return status;
}      



VOID
MoveToNextFdoPowerWorkerState(
   PFDO_EXTENSION fdoExtension,
   LONG increment
   )
/*++

Routine Description

   This routine controls the sequencing of FDO power worker. 
   
   Initially, the state must be set to one of two states, namely BeginPowerDown
   or BeginPowerUp. From there, this routine defines the list of states to follow.
   
   The parameter "increment" is normally the value '1'. Other values are used
   to modify the normal sequence. For example, '-1' backs the engine up 1 step.
   Use FPW_END_SEQUENCE to skip to the end of the sequence.

Arguments


Return Value

   status

--*/
{

   //
   // NOTE!: code in power worker dependent on the following state sequences
   // in PowerUpSequence remaining adjacent:
   //
   //    FPW_PowerUpSocket : FPW_PowerUpSocketVerify : FPW_PowerUpComplete
   //
   //    FPW_IrpComplete : FPW_Stopped
   //


   static FDO_POWER_WORKER_STATE PowerUpSequence[] = {
      FPW_SendIrpDown,
      FPW_PowerUp,
      FPW_PowerUpSocket,               
      FPW_PowerUpSocket2,               
      FPW_PowerUpSocketVerify,
      FPW_PowerUpSocketComplete,       
      FPW_PowerUpComplete,
      FPW_CompleteIrp,
      FPW_Stopped
      };

   static FDO_POWER_WORKER_STATE PowerDownSequence[] = {
      FPW_PowerDown,
      FPW_PowerDownSocket,
      FPW_PowerDownComplete,
      FPW_SendIrpDown,
      FPW_CompleteIrp,
      FPW_Stopped
      };

   static FDO_POWER_WORKER_STATE NoOpSequence[] = {
      FPW_SendIrpDown,
      FPW_CompleteIrp,
      FPW_Stopped
      };


   if (fdoExtension->PowerWorkerState == FPW_BeginPowerDown) {

      //
      // Initialize sequence and phase
      //
      fdoExtension->PowerWorkerPhase = (UCHAR) -1;
      
      if (fdoExtension->DevicePowerState == PowerDeviceD0) {
         fdoExtension->PowerWorkerSequence = PowerDownSequence;
         fdoExtension->PowerWorkerMaxPhase = sizeof(PowerDownSequence)/sizeof(FDO_POWER_WORKER_STATE) - 1;
      } else {
         fdoExtension->PowerWorkerSequence = NoOpSequence;
         fdoExtension->PowerWorkerMaxPhase = sizeof(NoOpSequence)/sizeof(FDO_POWER_WORKER_STATE) - 1;
      }

   } else if (fdoExtension->PowerWorkerState == FPW_BeginPowerUp) {

      //
      // Initialize sequence and phase
      //
      fdoExtension->PowerWorkerPhase = (UCHAR) -1;
      
      if (fdoExtension->DevicePowerState > PowerDeviceD0) {
         fdoExtension->PowerWorkerSequence = PowerUpSequence;
         fdoExtension->PowerWorkerMaxPhase = sizeof(PowerUpSequence)/sizeof(FDO_POWER_WORKER_STATE) - 1;
      } else {
         fdoExtension->PowerWorkerSequence = NoOpSequence;
         fdoExtension->PowerWorkerMaxPhase = sizeof(NoOpSequence)/sizeof(FDO_POWER_WORKER_STATE) - 1;
      }
   }

   //
   // Increment the phase, but not past the end of the sequence
   //
   if (fdoExtension->PowerWorkerState != FPW_Stopped) {

      if (increment == FPW_END_SEQUENCE) {

         fdoExtension->PowerWorkerPhase = fdoExtension->PowerWorkerMaxPhase;

      } else {      
         fdoExtension->PowerWorkerPhase += (UCHAR)increment;
         
         if (fdoExtension->PowerWorkerPhase > fdoExtension->PowerWorkerMaxPhase) {
            fdoExtension->PowerWorkerPhase = fdoExtension->PowerWorkerMaxPhase;
         }
      }

      //
      // The next state is pointed to by the current phase
      //
      fdoExtension->PowerWorkerState =
         fdoExtension->PowerWorkerSequence[ fdoExtension->PowerWorkerPhase ];
   }
   
   DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x power worker next state : %s\n", fdoExtension->DeviceObject, 
                                    FDO_POWER_WORKER_STRING(fdoExtension->PowerWorkerState)));

}


NTSTATUS
PcmciaFdoPowerWorker (
   IN PVOID Context,
   IN NTSTATUS Status
   )
/*++

Routine Description

   This routine handles sequencing of the device power state change for the
   ppcard controller. 

Arguments

   DeviceObject      - Pointer to the functional device object for the pcmcia controller
   Status            - status from previous operation

Return value

   status

--*/



{
   PDEVICE_OBJECT Fdo = Context;
   PFDO_EXTENSION     fdoExtension = Fdo->DeviceExtension;
   PIRP Irp = fdoExtension->PendingPowerIrp;
   PIO_STACK_LOCATION irpStack;
   NTSTATUS           status = Status;
   PDEVICE_OBJECT     pdo;
   PPDO_EXTENSION     pdoExtension;
   PSOCKET            socket;
   BOOLEAN            cardInSocket;
   BOOLEAN            deviceChange;
   ULONG              DelayTime = 0;

   DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x power worker - %s\n", Fdo, 
                                    FDO_POWER_WORKER_STRING(fdoExtension->PowerWorkerState)));

   switch(fdoExtension->PowerWorkerState) {

   //-------------------------------------------------------------------------
   // POWER DOWN STATES
   //-------------------------------------------------------------------------
   

   case FPW_BeginPowerDown:
      MoveToNextFdoPowerWorkerState(fdoExtension, 1);
      break;
   

   case FPW_PowerDown:
      //
      // Controller being powered down
      //          
      DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x irp %08x preparing for powerdown\n", Fdo, Irp));
      //
      // Getting out of D0
      //
      if (fdoExtension->Flags & PCMCIA_USE_POLLED_CSC) {
         //
         // Cancel the poll timer
         //
         KeCancelTimer(&fdoExtension->PollTimer);
      }
      //
      // Save necessary controller registers
      //
      PcmciaFdoSaveControllerContext(fdoExtension);
      fdoExtension->PendingPowerSocket = fdoExtension->SocketList;
      MoveToNextFdoPowerWorkerState(fdoExtension, 1);
      break;
   

   case FPW_PowerDownSocket:

      if ((socket = fdoExtension->PendingPowerSocket) == NULL) {
         MoveToNextFdoPowerWorkerState(fdoExtension, 1);
         break;
      }

      //
      // Ready to turn off the socket
      //
      PcmciaFdoSaveSocketContext(socket);

      //
      // Clear card detect unless we intend to wake using it
      //      
      if (IsSocketFlagSet(socket, SOCKET_ENABLED_FOR_CARD_DETECT) && !IsFdoFlagSet(fdoExtension, PCMCIA_FDO_WAKE_BY_CD)) {
         (*(socket->SocketFnPtr->PCBEnableDisableCardDetectEvent))(socket, FALSE);
      }

      //
      // Cardbus cards need socket power all the time to allow PCI.SYS to read config space, even
      // if the device is logically removed. So instead of turning off socket power when the
      // children go to D3, we turn it off here when the parent goes to D3. 
      // For R2 cards, the power may already be off, since the socket power does follow the
      // children. So this step would typically be superfluous.
      //

      DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x skt %08x power worker SystemState=S%d\n",
                                       Fdo, socket, fdoExtension->SystemPowerState-1));
      
      switch(fdoExtension->SystemPowerState) {
      
      case PowerSystemWorking:
         //
         // The system is still running, we must be powering down because the socket is idle
         //
         ASSERT(!IsCardInSocket(socket));
         status = PcmciaSetSocketPower(socket, PcmciaFdoPowerWorker, Fdo, PCMCIA_POWEROFF);
         break;   
      
      case PowerSystemSleeping1:
      case PowerSystemSleeping2:
      case PowerSystemSleeping3:
         //
         // If the device is armed for wakeup, we need to leave socket power on
         //
         if (fdoExtension->WaitWakeState == WAKESTATE_DISARMED) {
            status = PcmciaSetSocketPower(socket, PcmciaFdoPowerWorker, Fdo, PCMCIA_POWEROFF);
         }
         break;
      
      case PowerSystemHibernate:
         status = PcmciaSetSocketPower(socket, PcmciaFdoPowerWorker, Fdo, PCMCIA_POWEROFF);
         break;   
      
      case PowerSystemShutdown:
         //
         // Doing a shutdown - check to see if we need to leave socket power on since NDIS
         // and SCSIPORT leaves their devices in D0. This can be a problem since many machines
         // will hang in the BIOS if devices are left powered up.
         //
         if (!IsDeviceFlagSet(fdoExtension, PCMCIA_FDO_DISABLE_AUTO_POWEROFF)) {
            status = PcmciaSetSocketPower(socket, PcmciaFdoPowerWorker, Fdo, PCMCIA_POWEROFF);
         }
         break;
      
      default:
         ASSERT(FALSE);
      }
      
      //
      // if success, then recurse below
      // if pending, then release_socket_power will call us back
      // Prepare to go to next socket
      //
      fdoExtension->PendingPowerSocket = fdoExtension->PendingPowerSocket->NextSocket;

      if (fdoExtension->PendingPowerSocket == NULL) {
         //
         // Done, ready to move on
         //
         MoveToNextFdoPowerWorkerState(fdoExtension, 1);
      } 
      break;

   case FPW_PowerDownComplete:
      irpStack = IoGetCurrentIrpStackLocation(Irp);
      fdoExtension->DevicePowerState = irpStack->Parameters.Power.State.DeviceState;
      
      PoSetPowerState (Fdo, DevicePowerState, irpStack->Parameters.Power.State);
      fdoExtension->Flags |= PCMCIA_FDO_OFFLINE;
      MoveToNextFdoPowerWorkerState(fdoExtension, 1);
      break;


   //-------------------------------------------------------------------------
   // POWER UP STATES
   //-------------------------------------------------------------------------


   case FPW_BeginPowerUp:
      //
      // Back in D0. Restore the minimal context so we can access the registers
      //
      PcmciaFdoRestoreControllerContext(fdoExtension);

      //
      // Delay for a while after restoring PCI config space to allow the controller
      // to settle. The Panasonic Toughbook with at TI-1251B seemed to need this delay
      // before the cardbus state register showed the right value.
      //
      DelayTime = 8192;
      
      MoveToNextFdoPowerWorkerState(fdoExtension, 1);
      break;   

   case FPW_PowerUp:
      //
      // Should be ready to touch the registers again
      //
      fdoExtension->Flags &= ~PCMCIA_FDO_OFFLINE;
      
      //
      // Get registers to a known state
      //      
      PcmciaInitializeController(Fdo);
      
      if (!ValidateController(fdoExtension)) {
         status = STATUS_DEVICE_NOT_READY;
         //
         // Fast forward the sequence skipping to complete the irp
         //         
         MoveToNextFdoPowerWorkerState(fdoExtension, FPW_END_SEQUENCE);   // moves to state: Stopped
         MoveToNextFdoPowerWorkerState(fdoExtension, -1);   // moves to state: CompleteIrp
         break;
      }
      //
      // We just transitioned into D0
      // Set socket flags to current state
      //
      for (socket = fdoExtension->SocketList; socket != NULL; socket = socket->NextSocket) {
     
         if (fdoExtension->PcmciaInterruptObject) {
            //
            // this should clear any pending interrupts in the socket event register
            //
            ((*(socket->SocketFnPtr->PCBDetectCardChanged))(socket));
         }            

         //
         // Some cardbus cards (NEC based 1394 cards) are not quiet when they power up,
         // avoid an interrupt storm here by setting ISA irq routing
         //
         if (IsCardBusCardInSocket(socket)) {
            USHORT word;
            GetPciConfigSpace(fdoExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
            word |= BCTRL_IRQROUTING_ENABLE;
            SetPciConfigSpace(fdoExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
         }         
      }
      
      fdoExtension->PendingPowerSocket = fdoExtension->SocketList;
      MoveToNextFdoPowerWorkerState(fdoExtension, 1);
      break;      

      
   case FPW_PowerUpSocket:

      MoveToNextFdoPowerWorkerState(fdoExtension, 1);
      if ((socket = fdoExtension->PendingPowerSocket) == NULL) {
         break;
      }

      //
      // Make sure socket is really off first before powering up
      //
      
      status = PcmciaSetSocketPower(socket, PcmciaFdoPowerWorker, Fdo, PCMCIA_POWEROFF);
      break;

   case FPW_PowerUpSocket2:

      MoveToNextFdoPowerWorkerState(fdoExtension, 1);
      if ((socket = fdoExtension->PendingPowerSocket) == NULL) {
         break;
      }

      //
      // We now decide if the socket should be turned on. We really want to turn
      // at this point to make sure the device hasn't been swapped while the
      // controller was off. If status_change is already set on the socket flags,
      // then we anyway will power it on during enumeration, so don't bother now.
      //
      
      if (!IsSocketFlagSet(socket, SOCKET_CARD_STATUS_CHANGE) && IsCardInSocket(socket)) {
      
         DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x power worker - PowerON socket %08x\n", Fdo, socket));
         status = PcmciaSetSocketPower(socket, PcmciaFdoPowerWorker, Fdo, PCMCIA_POWERON);
         
      }         
         
      break;

   
   case FPW_PowerUpSocketVerify:

      MoveToNextFdoPowerWorkerState(fdoExtension, 1);
      if ((socket = fdoExtension->PendingPowerSocket) == NULL) {
         break;
      }

      //
      // verify the same card is still inserted.
      //
      
      if (!IsSocketFlagSet(socket, SOCKET_CARD_STATUS_CHANGE) &&
          IsCardInSocket(socket) &&
          IsSocketFlagSet(socket, SOCKET_CARD_POWERED_UP)) { 

          PcmciaVerifyCardInSocket(socket);
      }       
      
      //
      // Now we decide whether or not to turn the power back off. 
      //
      if (Is16BitCardInSocket(socket)) {
         if (IsSocketFlagSet(socket, SOCKET_CARD_STATUS_CHANGE) ||
            (socket->PowerRequests == 0)) {
            status = PcmciaSetSocketPower(socket, PcmciaFdoPowerWorker, Fdo, PCMCIA_POWEROFF);
         }
      }         
      break;       
      

      
   case FPW_PowerUpSocketComplete:

      if (fdoExtension->PendingPowerSocket == NULL) {
         MoveToNextFdoPowerWorkerState(fdoExtension, 1);
         break;
      }

      //
      // go to next socket, if any
      //
      fdoExtension->PendingPowerSocket = fdoExtension->PendingPowerSocket->NextSocket;

      if (fdoExtension->PendingPowerSocket != NULL) {
         //
         // Back up sequence to FPW_PowerUpSocket
         //
         MoveToNextFdoPowerWorkerState(fdoExtension, -2);
         break;
      }
      MoveToNextFdoPowerWorkerState(fdoExtension, 1);
      break;


   case FPW_PowerUpComplete:

      irpStack = IoGetCurrentIrpStackLocation(Irp);
      deviceChange = FALSE;
      for (socket = fdoExtension->SocketList; socket != NULL; socket = socket->NextSocket) {
         if (IsSocketFlagSet(socket, SOCKET_CARD_STATUS_CHANGE)) {
            deviceChange = TRUE;
         } 
         PcmciaFdoRestoreSocketContext(socket);
   
         if (CardBus(socket)) {
            CBEnableDeviceInterruptRouting(socket);
         }     
         
         if (IsSocketFlagSet(socket, SOCKET_ENABLED_FOR_CARD_DETECT)) {
            (*(socket->SocketFnPtr->PCBEnableDisableCardDetectEvent))(socket, TRUE);
         }
      }

      fdoExtension->DevicePowerState = irpStack->Parameters.Power.State.DeviceState;
      PoSetPowerState (Fdo, DevicePowerState, irpStack->Parameters.Power.State);
      
      if (deviceChange) {
         //
         // Make sure i/o arbiter is not hanging on the devnode
         //
         if (CardBusExtension(fdoExtension)) {
            IoInvalidateDeviceState(fdoExtension->Pdo);
         }         
         //
         // Device state changed..
         //
         DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x power worker - Invalidating Device Relations!\n", Fdo));
         IoInvalidateDeviceRelations(fdoExtension->Pdo, BusRelations);
      }

      //
      // Getting back to D0, set the poll timer on
      //
      if (fdoExtension->Flags & PCMCIA_USE_POLLED_CSC) {
         LARGE_INTEGER dueTime;
         //
         // Set first fire to twice the peroidic interval - just
         //
         dueTime.QuadPart = -PCMCIA_CSC_POLL_INTERVAL * 1000 * 10 * 2;
     
         KeSetTimerEx(&(fdoExtension->PollTimer),
                      dueTime,
                      PCMCIA_CSC_POLL_INTERVAL,
                      &fdoExtension->TimerDpc
                     );
      }
      
      PCMCIA_ACQUIRE_DEVICE_LOCK(fdoExtension);
      
      if (!IsListEmpty(&fdoExtension->PdoPowerRetryList)) {
         PLIST_ENTRY NextEntry;
         PIRP pdoIrp;
      
         NextEntry = RemoveHeadList(&fdoExtension->PdoPowerRetryList);
         PCMCIA_RELEASE_DEVICE_LOCK(fdoExtension);
         
         pdoIrp = CONTAINING_RECORD(NextEntry, IRP, Tail.Overlay.DriverContext[0]);
         KeInsertQueueDpc(&fdoExtension->PdoPowerRetryDpc, pdoIrp, NULL);  
      } else {
         PCMCIA_RELEASE_DEVICE_LOCK(fdoExtension);
      }         
         
      MoveToNextFdoPowerWorkerState(fdoExtension, 1);
      break;

   //-------------------------------------------------------------------------
   // IRP HANDLING STATES
   //-------------------------------------------------------------------------


   case FPW_SendIrpDown:
      DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x irp %08x sending irp down to PDO\n", Fdo, Irp));
      MoveToNextFdoPowerWorkerState(fdoExtension, 1);
      //
      // Send the IRP to the pdo
      //
      IoMarkIrpPending(Irp);
      
      IoCopyCurrentIrpStackLocationToNext (Irp);
     
      IoSetCompletionRoutine(Irp,
                             PcmciaFdoDevicePowerCompletion,
                             NULL,
                             TRUE,
                             TRUE,
                             TRUE);
     
      status = PoCallDriver(fdoExtension->LowerDevice, Irp);
      
      if (NT_SUCCESS(status)) {
         status = STATUS_PENDING;
      }
      break;

   case FPW_CompleteIrp:
   
      MoveToNextFdoPowerWorkerState(fdoExtension, 1);
      if (Irp) {
         fdoExtension->PendingPowerIrp = NULL;         
         Irp->IoStatus.Status = status;
        
         DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x irp %08x comp %08x\n", fdoExtension->DeviceObject, Irp, Irp->IoStatus.Status));
                     
         PoStartNextPowerIrp(Irp);
         IoCompleteRequest(Irp, IO_NO_INCREMENT);
      }         
      fdoExtension->PowerWorkerState = FPW_Stopped;
      break;
      
   case FPW_Stopped:      
      DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x power worker final exit %08x\n", Fdo, status));
      if (!NT_SUCCESS(status)) {
         for (socket = fdoExtension->SocketList; socket != NULL; socket = socket->NextSocket) {
            SetSocketFlag(socket, SOCKET_CARD_STATUS_CHANGE);
         }
      }      
      return status;
   default:
      ASSERT(FALSE);      
   }

   DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x power worker status %08x\n", Fdo, status));
                                    
   if (status == STATUS_PENDING) {
      DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x power worker exit (pending)\n", Fdo));
      //
      // Current action calls us back
      //
      if ((Irp=fdoExtension->PendingPowerIrp)!=NULL) {
         IoMarkIrpPending(Irp);
      }         
      return status;
   }
   //
   // Not done yet. Recurse or call timer
   //

   if (DelayTime) {

      DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x power worker delay type %s, %d usec\n", Fdo,
                                                (KeGetCurrentIrql() < DISPATCH_LEVEL) ? "Wait" : "Timer",
                                                DelayTime));

      if (KeGetCurrentIrql() < DISPATCH_LEVEL) {
         PcmciaWait(DelayTime);
      } else {
         LARGE_INTEGER  dueTime;
         //
         // Running on a DPC, kick of a kernel timer
         //

         dueTime.QuadPart = -((LONG) DelayTime*10);
         KeSetTimer(&fdoExtension->PowerTimer, dueTime, &fdoExtension->PowerDpc);

         //
         // We will reenter on timer dpc
         //
         if ((Irp=fdoExtension->PendingPowerIrp)!=NULL) {
            IoMarkIrpPending(Irp);
         }         
         return STATUS_PENDING;
      }
   }   
   
   //
   // recurse
   //
   return (PcmciaFdoPowerWorker(Fdo, status));   
}



NTSTATUS
PcmciaFdoDevicePowerCompletion(
   IN PDEVICE_OBJECT Fdo,
   IN PIRP Irp,
   IN PVOID Context
   )
/*++

Routine Description

   Completion routine for the power IRP sent down to the PDO for the
   pcmcia controller. If we are getting out of a working system state,
   requests a power IRP to put the device in appropriate device power state.
   Also makes sure that we stop poking device registers when the controller
   is powered down and reenables that if necessary when it powers up

Parameters

   DeviceObject   -    Pointer to FDO for the controller
   Irp            -    Pointer to the IRP for the power request
   Context        -    Pointer to the FDO_POWER_CONTEXT which is
                       filled in when the IRP is passed down
Return Value

   Status

--*/
{
   PFDO_EXTENSION     fdoExtension = Fdo->DeviceExtension;
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
   ULONG              timerInterval;
   NTSTATUS           status;
   LARGE_INTEGER      dueTime;

   DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x irp %08x DevicePowerCompletion PDO status %08x\n", Fdo, Irp, Irp->IoStatus.Status));

   if ((NT_SUCCESS(Irp->IoStatus.Status))) {

      if (irpStack->Parameters.Power.State.DeviceState == PowerDeviceD0) {

         timerInterval = ControllerPowerUpDelay;
      } else {
         //
         // powering down
         // stall to avoid hardware problem on ThinkPads where power
         // to the device is left on after the system in general powers off
         //
         timerInterval = 20000;
      }
      //
      // Do the rest in our timer routine
      //
      
      dueTime.QuadPart = -((LONG) timerInterval*10);
      KeSetTimer(&fdoExtension->PowerTimer, dueTime, &fdoExtension->PowerDpc);
      
      status = STATUS_MORE_PROCESSING_REQUIRED;

   } else {
      DebugPrint ((PCMCIA_DEBUG_POWER, "fdo %08x irp %08x power irp failed by pdo %08x\n", Fdo, Irp, fdoExtension->LowerDevice));
      PoStartNextPowerIrp (Irp);
      status = Irp->IoStatus.Status;
      //
      // This irp is now complete
      //
      fdoExtension->PendingPowerIrp = NULL;         
      MoveToNextFdoPowerWorkerState(fdoExtension, FPW_END_SEQUENCE);   // moves to state: Stopped
      PcmciaFdoPowerWorker(Fdo, status);      
   }

   DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x irp %08x DevicePowerCompletion <-- %08x\n", Fdo, Irp, status));
   return status;
}



VOID
PcmciaFdoPowerWorkerDpc(
   IN PKDPC Dpc,
   IN PVOID Context,
   IN PVOID SystemArgument1,
   IN PVOID SystemArgument2
   )
/*++

Routine Description

   This routine is called a short time after the controller power state
   is changed in order to give the hardware a chance to stabilize. It
   is called in the context of a device power request.

Parameters

   same as KDPC (Context is fdoExtension)

Return Value

   none

--*/
{
   PFDO_EXTENSION fdoExtension = Context;
   
   DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x irp %08x PowerWorkerDpc\n", fdoExtension->DeviceObject, fdoExtension->PendingPowerIrp));
   //
   // Fdo power worker will complete the irp
   //   
   PcmciaFdoPowerWorker(fdoExtension->DeviceObject, STATUS_SUCCESS);               
}


VOID
PcmciaFdoRetryPdoPowerRequest(
   IN PKDPC Dpc,
   IN PVOID Context,
   IN PVOID SystemArgument1,
   IN PVOID SystemArgument2
   )
/*++

Routine Description

   This routine is called to finish off any PDO power irps that may have
   been queued.

Parameters

   same as KDPC (Context is fdoExtension)

Return Value

   none

--*/
{
   PFDO_EXTENSION fdoExtension = Context;
   PIRP Irp = SystemArgument1;
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
   
   DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x irp %08x FdoRetryPdoPowerRequest\n", fdoExtension->DeviceObject, Irp));
   
   PcmciaSetPdoDevicePowerState(irpStack->DeviceObject, Irp);
   
   while(TRUE) {
      PLIST_ENTRY NextEntry;
      
      PCMCIA_ACQUIRE_DEVICE_LOCK(fdoExtension);
      
      if (IsListEmpty(&fdoExtension->PdoPowerRetryList)) {
         PCMCIA_RELEASE_DEVICE_LOCK(fdoExtension);
         break;
      }
      
      NextEntry = RemoveHeadList(&fdoExtension->PdoPowerRetryList);
      
      PCMCIA_RELEASE_DEVICE_LOCK(fdoExtension);

      Irp = CONTAINING_RECORD(NextEntry, IRP, Tail.Overlay.DriverContext[0]);
      irpStack = IoGetCurrentIrpStackLocation(Irp);
      
      PcmciaSetPdoDevicePowerState(irpStack->DeviceObject, Irp);
   }      
}



NTSTATUS
PcmciaFdoSaveControllerContext(
   IN PFDO_EXTENSION FdoExtension
   )
/*++

Routine Description:

   Saves the state of the necessary PCI config registers
   in the device extension of the cardbus controller

Arguments:

   FdoExtension      - Pointer to device extension for the FDO of the
                       cardbus controller

Return Value:

   Status
--*/
{
   ULONG index, offset, count;
   PULONG alignedBuffer;

   DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x save reg context\n", FdoExtension->DeviceObject));

   if (!FdoExtension->PciContext.BufferLength) {
      // nothing to save
      return STATUS_SUCCESS;
   }

   if (!ValidateController(FdoExtension)) {
      return STATUS_DEVICE_NOT_READY;
   }
   
   SetDeviceFlag(FdoExtension, PCMCIA_FDO_CONTEXT_SAVED);

   if (FdoExtension->PciContextBuffer == NULL) {
      FdoExtension->PciContextBuffer = ExAllocatePool(NonPagedPool, FdoExtension->PciContext.BufferLength);
      
      if (FdoExtension->PciContextBuffer == NULL) {
         return STATUS_INSUFFICIENT_RESOURCES;
      }
   }         

   alignedBuffer = ExAllocatePool(NonPagedPool, FdoExtension->PciContext.MaxLen);
   if (alignedBuffer == NULL) {
      return STATUS_INSUFFICIENT_RESOURCES;
   }      

   if (CardBusExtension(FdoExtension)) {
      //
      // Save PCI context
      //
     
      for (index = 0, offset = 0; index < FdoExtension->PciContext.RangeCount; index++) {
     
         DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x saving PCI context, offset %x length %x\n",
                                          FdoExtension->DeviceObject,
                                          FdoExtension->PciContext.Range[index].wOffset,
                                          FdoExtension->PciContext.Range[index].wLen));

         ASSERT(FdoExtension->PciContext.Range[index].wLen <= FdoExtension->PciContext.MaxLen);
     
         GetPciConfigSpace(FdoExtension,
                           (ULONG) FdoExtension->PciContext.Range[index].wOffset,
                           alignedBuffer,
                           FdoExtension->PciContext.Range[index].wLen);
     
         RtlCopyMemory(&FdoExtension->PciContextBuffer[offset], alignedBuffer, FdoExtension->PciContext.Range[index].wLen);
         offset += FdoExtension->PciContext.Range[index].wLen;
      }
   }

   ExFreePool(alignedBuffer);
   return STATUS_SUCCESS;
}



NTSTATUS
PcmciaFdoSaveSocketContext(
   IN PSOCKET Socket
   )
/*++

Routine Description:

   Saves the state of the necessary socket registers (CB, EXCA)

Arguments:

   Socket            - Pointer to socket data structure

Return Value:

   Status
--*/
{
   PFDO_EXTENSION fdoExtension = Socket->DeviceExtension;
   ULONG index, offset, count;

   if (CardBusExtension(fdoExtension) && fdoExtension->CardbusContext.BufferLength) {
      //
      // Save Cardbus context
      //
      if (Socket->CardbusContextBuffer == NULL) {
         Socket->CardbusContextBuffer = ExAllocatePool(NonPagedPool, fdoExtension->CardbusContext.BufferLength);
         
         if (Socket->CardbusContextBuffer == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
         }
      }         
     
      for (index = 0, offset = 0; index < fdoExtension->CardbusContext.RangeCount; index++) {
         PULONG pBuffer = (PULONG) &Socket->CardbusContextBuffer[offset];
     
         DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x saving Cardbus context, offset %x length %x\n",
                                          fdoExtension->DeviceObject,
                                          fdoExtension->CardbusContext.Range[index].wOffset,
                                          fdoExtension->CardbusContext.Range[index].wLen));
     
         for (count = 0; count < (fdoExtension->CardbusContext.Range[index].wLen/sizeof(ULONG)) ; count++) {
     
            *pBuffer++ = CBReadSocketRegister(Socket,
                                              (UCHAR) (fdoExtension->CardbusContext.Range[index].wOffset + count*sizeof(ULONG)));
         }
     
         offset += fdoExtension->CardbusContext.Range[index].wLen;
      }
   }

   //
   // Save Exca context
   //

   if (fdoExtension->ExcaContext.BufferLength) {

      if (Socket->ExcaContextBuffer == NULL) {
         Socket->ExcaContextBuffer = ExAllocatePool(NonPagedPool, fdoExtension->ExcaContext.BufferLength);
         
         if (Socket->ExcaContextBuffer == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
         }
      }         

      for (index = 0, offset = 0; index < fdoExtension->ExcaContext.RangeCount; index++) {
         PUCHAR pBuffer = &Socket->ExcaContextBuffer[offset];
     
         DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x saving Exca context, offset %x length %x\n",
                                          fdoExtension->DeviceObject,
                                          fdoExtension->ExcaContext.Range[index].wOffset,
                                          fdoExtension->ExcaContext.Range[index].wLen));
     
         for (count = 0; count < fdoExtension->ExcaContext.Range[index].wLen; count++) {
     
            *pBuffer++ = PcicReadSocket(Socket,
                                        fdoExtension->ExcaContext.Range[index].wOffset + count);
         }
     
         offset += fdoExtension->ExcaContext.Range[index].wLen;
      }
   }      

   return STATUS_SUCCESS;
}


NTSTATUS
PcmciaFdoRestoreControllerContext(
   IN PFDO_EXTENSION FdoExtension
   )
/*++

Routine Description:

   Restores the state of the necessary PCI config registers
   from the device extension of the cardbus controller

Arguments:

   FdoExtension      - Pointer to device extension for the FDO of the
                       cardbus controller

Return Value:

   Status
--*/
{
   ULONG index, offset, count;
   PULONG alignedBuffer;

   if (!CardBusExtension(FdoExtension)) {
      return STATUS_SUCCESS;
   }

   //
   // Make sure we don't restore stale or uninitialized data
   //
   if (!IsDeviceFlagSet(FdoExtension, PCMCIA_FDO_CONTEXT_SAVED)) {
      ASSERT(IsDeviceFlagSet(FdoExtension, PCMCIA_FDO_CONTEXT_SAVED));
      return STATUS_UNSUCCESSFUL;
   }
   ResetDeviceFlag(FdoExtension, PCMCIA_FDO_CONTEXT_SAVED);
   
   if (FdoExtension->PciContextBuffer == NULL) {
      // nothing to restore... strange since our flag was set
      ASSERT(FALSE);
      return STATUS_SUCCESS;
   }


   alignedBuffer = ExAllocatePool(NonPagedPool, FdoExtension->PciContext.MaxLen);
   if (alignedBuffer == NULL) {
      return STATUS_INSUFFICIENT_RESOURCES;
   }      
   
   DebugPrint((PCMCIA_DEBUG_POWER,
               "fdo %08x restore reg context\n", FdoExtension->DeviceObject));

   //
   // Restore PCI context
   //
   
   for (index = 0, offset = 0; index < FdoExtension->PciContext.RangeCount; index++) {
   
      DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x restoring PCI context, offset %x length %x\n",
                                       FdoExtension->DeviceObject,
                                       FdoExtension->PciContext.Range[index].wOffset,
                                       FdoExtension->PciContext.Range[index].wLen));
   
      ASSERT(FdoExtension->PciContext.Range[index].wLen <= FdoExtension->PciContext.MaxLen);
      
      RtlCopyMemory(alignedBuffer, &FdoExtension->PciContextBuffer[offset], FdoExtension->PciContext.Range[index].wLen);
      
      SetPciConfigSpace(FdoExtension,
                        (ULONG) FdoExtension->PciContext.Range[index].wOffset,
                        alignedBuffer,
                        FdoExtension->PciContext.Range[index].wLen);
   
      offset += FdoExtension->PciContext.Range[index].wLen;
      
      //
      // hang on resume on NEC NX laptop (w/ Ricoh devid 0x475) is avoided with a stall here.
      // The hang occurs if CBRST is turned OFF. I'm unclear about the reason for it, this
      // is just an empirically derived hack.
      //
      PcmciaWait(1);
   }
   ExFreePool(alignedBuffer);
   return STATUS_SUCCESS;
}

   

NTSTATUS
PcmciaFdoRestoreSocketContext(
   IN PSOCKET Socket
   )
/*++

Routine Description:

   Restores the state of the necessary socket registers (CB, EXCA)

Arguments:

   Socket            - Pointer to socket data structure

Return Value:

   Status
--*/
{
   PFDO_EXTENSION fdoExtension = Socket->DeviceExtension;
   ULONG index, offset, count;

   if (CardBusExtension(fdoExtension) && (Socket->CardbusContextBuffer != NULL)) {
      //
      // Restore Cardbus context
      //
     
      for (index = 0, offset = 0; index < fdoExtension->CardbusContext.RangeCount; index++) {
         PULONG pBuffer = (PULONG) &Socket->CardbusContextBuffer[offset];
     
         DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x restoring Cardbus context offset %x length %x\n",
                                          fdoExtension->DeviceObject,
                                          fdoExtension->CardbusContext.Range[index].wOffset,
                                          fdoExtension->CardbusContext.Range[index].wLen));
     
         for (count = 0; count < (fdoExtension->CardbusContext.Range[index].wLen/sizeof(ULONG)) ; count++) {
     
            CBWriteSocketRegister(Socket,
                                  (UCHAR) (fdoExtension->CardbusContext.Range[index].wOffset + count*sizeof(ULONG)),
                                  *pBuffer++);
         }
     
         offset += fdoExtension->CardbusContext.Range[index].wLen;
      }
   }

   //
   // Restore Exca context
   //
   
   if (Socket->ExcaContextBuffer != NULL) {
      for (index = 0, offset = 0; index < fdoExtension->ExcaContext.RangeCount; index++) {
         PUCHAR pBuffer = &Socket->ExcaContextBuffer[offset];
      
         DebugPrint((PCMCIA_DEBUG_POWER, "fdo %08x Restoring Exca context, offset %x length %x\n",
                                          fdoExtension->DeviceObject,
                                          fdoExtension->ExcaContext.Range[index].wOffset,
                                          fdoExtension->ExcaContext.Range[index].wLen));
      
         for (count = 0; count < fdoExtension->ExcaContext.Range[index].wLen; count++) {
     
            PcicWriteSocket(Socket,
                            fdoExtension->ExcaContext.Range[index].wOffset + count,
                            *pBuffer++);
         }
      
         offset += fdoExtension->ExcaContext.Range[index].wLen;
      }
   }      

   return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\pcmcibus\id.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    id.c

Abstract:

    This module contains the code to handle IRP_MN_QUERY_ID

Authors:

    Ravisankar Pudipeddi (ravisp)

Environment:

    Kernel mode only

Notes:

Revision History:

    Neil Sandlin (neilsa) - split off from pdopnp.c

--*/

#include "pch.h"

//
// Internal References
//

NTSTATUS
PcmciaGenerateDeviceId(
   IN  PSOCKET_DATA    SocketData,
   IN  ULONG           FunctionNumber,
   OUT PUCHAR         *DeviceId
   );

BOOLEAN
PcmciaCheckInstance(
   IN PUCHAR  DeviceId,
   IN ULONG   Instance
   );

NTSTATUS
PcmciaGetDeviceType(
   IN  PDEVICE_OBJECT Pdo,
   IN  ULONG FunctionNumber,
   OUT PUCHAR DeviceType
   );

VOID
PcmciaFilterIdString(
   IN PUCHAR pIn,
   OUT PUCHAR pOut,
   ULONG MaxLen
   );
         

#ifdef ALLOC_PRAGMA
   #pragma alloc_text(PAGE,  PcmciaGenerateDeviceId)
   #pragma alloc_text(PAGE,  PcmciaGetDeviceId)
   #pragma alloc_text(PAGE,  PcmciaGetHardwareIds)
   #pragma alloc_text(PAGE,  PcmciaGetCompatibleIds)
   #pragma alloc_text(PAGE,  PcmciaGetDeviceType)
   #pragma alloc_text(PAGE,  PcmciaFilterIdString)
#endif


#define PCMCIA_MAX_DEVICE_TYPE_SUPPORTED 12

const
UCHAR *PcmciaCompatibleIds[PCMCIA_MAX_DEVICE_TYPE_SUPPORTED+1] = {
   "",            // Unknown..
   "",            // Memory card (RAM, ROM, EPROM, Flash)
   "",            // Serial I/O port, includes modems
   "",            // Parallel printer port
   "*PNP0600",    // Disk driver (ATA)
   "",            // Video interface
   "",            // Local Area Network adapter
   "",            // Auto Increment Mass Storage card
   "",            // SCSI bridge card
   "",            // Security card
   "*PNP0D00",    // Multi-Function 3.0 PC Card
   "",            // Flash memory card
   "*PNPC200",    // Modem card (sync with PCCARD_TYPE_MODEM)
};



NTSTATUS
PcmciaGenerateDeviceId(
   IN  PSOCKET_DATA    SocketData,
   IN  ULONG           FunctionNumber,
   OUT PUCHAR         *DeviceId
   )
/*++
   The device ID is created from tuple information on the PC Card
   The goal is to create a unique ID for each
   card.  The device ID is created from the manufacturer name string,
   the product name string, and a 16-bit CRC of a set of tuples.

   The ID is created by concatenating the "PCMCIA" prefix, the manufacturer
   name string, the product name string and the 16-bit CRC for the card.

       PCMCIA\<manuf_name>-<prod_name>-<crc>

   If the CISTPL_VERS_1 tuple is not available, or the manufacturer name is
   NULL, the string "UNKNOWN_MANUFACTURER" will be included in its place.

   If this is for a child function within a multifunctionn card, the generated
   device id would be:

       PCMCIA\<manuf_name>-<prod_name>-DEV<function number>-<crc>

   This device id is compatible with win 9x device id's (excluding the instance
   number which is returned separtely by handling another IRP.

Arguments:

   Pdo            - Pointer to the physical device object for the pc-card
   FunctionNumber - Function number of the function in  a multi-function card.
                    If this is PCMCIA_MULTIFUNCTION_PARENT, then the requested device id
                    is for the parent device - not for any individual function
   DeviceId       - Pointer to the string in which device id is returned

Return Value

   Status

--*/
{
   PUCHAR deviceId;

   PAGED_CODE();

   deviceId = ExAllocatePool(PagedPool, PCMCIA_MAXIMUM_DEVICE_ID_LENGTH);

   if (deviceId == NULL) {
      return STATUS_INSUFFICIENT_RESOURCES;
   }
   //
   //  Generate the device id
   //
   if (*(SocketData->Mfg) == '\0' ) {
      //
      // No manufacturer name available
      //
      if (FunctionNumber == PCMCIA_MULTIFUNCTION_PARENT) {
         //
         // Device id for the pc-card
         //
         if (SocketData->Flags & SDF_JEDEC_ID) {
            //
            // Flash memory cards have the special device id
            //
            sprintf(deviceId, "%s\\%s-%04x",
                    PCMCIA_ID_STRING,
                    PCMCIA_MEMORY_ID_STRING,
                    SocketData->JedecId);

         } else {
            sprintf(deviceId, "%s\\%s-%04X",
                    PCMCIA_ID_STRING,
                    PCMCIA_UNKNOWN_MANUFACTURER_STRING,
                    SocketData->CisCrc);
         }
      } else {
         //
         // This is for the individual multifunction child
         //
         sprintf(deviceId, "%s\\%s-DEV%d-%04X",
                 PCMCIA_ID_STRING,
                 PCMCIA_UNKNOWN_MANUFACTURER_STRING,
                 FunctionNumber,
                 SocketData->CisCrc);
      }

   } else {
      UCHAR Mfg[MAX_MANFID_LENGTH];
      UCHAR Ident[MAX_IDENT_LENGTH];
   
      PcmciaFilterIdString(SocketData->Mfg, Mfg, MAX_MANFID_LENGTH);
      PcmciaFilterIdString(SocketData->Ident, Ident, MAX_IDENT_LENGTH);
   
      if (FunctionNumber == PCMCIA_MULTIFUNCTION_PARENT) {
         //
         // Device id for the pc-card
         //
         sprintf(deviceId, "%s\\%s-%s-%04X",
                 PCMCIA_ID_STRING,
                 Mfg,
                 Ident,
                 SocketData->CisCrc);
      } else {
         //
         // This is for the individual multifunction child
         //
         sprintf(deviceId, "%s\\%s-%s-DEV%d-%04X",
                 PCMCIA_ID_STRING,
                 Mfg,
                 Ident,
                 FunctionNumber,
                 SocketData->CisCrc);

      }
   }

   *DeviceId = deviceId;

   if ((FunctionNumber == PCMCIA_MULTIFUNCTION_PARENT) &&
       (SocketData->PdoExtension != NULL) &&
       (SocketData->PdoExtension->DeviceId == NULL)) {
      //
      // Keep a copy of the device id
      //
      PPDO_EXTENSION pdoExtension = SocketData->PdoExtension;

      pdoExtension->DeviceId = ExAllocatePool(NonPagedPool, strlen(deviceId)+1);
      if (pdoExtension->DeviceId) {
         RtlCopyMemory(pdoExtension->DeviceId, deviceId, strlen(deviceId)+1);
      }
   }
   return STATUS_SUCCESS;
}


NTSTATUS
PcmciaGetDeviceId(
   IN  PDEVICE_OBJECT   Pdo,
   IN  ULONG            FunctionNumber,
   OUT PUNICODE_STRING  DeviceId
   )
/*++

   Generated device id is returned for the supplied pc-card

Arguments:

   Pdo            - Pointer to the physical device object for the pc-card
   FunctionNumber - Function number of the function in  a multi-function card.
                    If this is PCMCIA_MULTIFUNCTION_PARENT, then the requested device id
                    is for the parent device - not for any individual function
   DeviceId       - Pointer to the unicode string in which device id is returned

Return Value

   Status

--*/
{
   PPDO_EXTENSION pdoExtension=Pdo->DeviceExtension;
   PSOCKET_DATA   socketData = pdoExtension->SocketData;
   ANSI_STRING ansiId;
   PUCHAR      deviceId;
   NTSTATUS    status;

   PAGED_CODE();

   ASSERT(DeviceId);

   if (!socketData) {
      ASSERT (socketData);
      return STATUS_DEVICE_NOT_READY;
   }

   status = PcmciaGenerateDeviceId(socketData,
                                   FunctionNumber,
                                   &deviceId);
   if (!NT_SUCCESS(status)) {
      return status;
   }


   DebugPrint((PCMCIA_DEBUG_INFO, "pdo %08x Device Id=%s\n", Pdo, deviceId));

   RtlInitAnsiString(&ansiId,  deviceId);

   status =  RtlAnsiStringToUnicodeString(DeviceId,
                                          &ansiId,
                                          TRUE);
   ExFreePool(deviceId);
   return status;
}


NTSTATUS
PcmciaGetHardwareIds(
   IN  PDEVICE_OBJECT  Pdo,
   IN  ULONG           FunctionNumber,
   OUT PUNICODE_STRING HardwareIds
   )
/*++

Routine Description:

   This routine generates the hardware id's for the given PC-Card and returns them
   as a Unicode multi-string.
   Hardware ids for PC-Cards are:

   1. The device id of the PC-Card
   2. The device id of the PC-Card with the CRC replaced with the Manufacturer code and
      Manufacturer info fields obtained from the tuple information on the PC-Card

   These hardware id's are compatible with win 9x hardware ids

Arguments:

   Pdo - Pointer to device object representing the PC-Card
   FunctionNumber - Function number of the function in  a multi-function card.
                    If this is PCMCIA_MULTIFUNCTION_PARENT, then the requested hardware id
                    is for the parent device - not for any individual function
   HardwareIds - Pointer to the unicode string which contains the hardware id's as a multi-string

Return value:

--*/
{
   PPDO_EXTENSION pdoExtension=Pdo->DeviceExtension;
   PSOCKET socket = pdoExtension->Socket;
   PSOCKET_DATA socketData = pdoExtension->SocketData;
   NTSTATUS status;
   PSTR     strings[4] = {NULL};
   PUCHAR   hwId, hwId2;
   UCHAR    deviceType;
   UCHAR    stringCount = 0;

   PAGED_CODE();

   if (!socketData) {
      ASSERT (socketData);
      return STATUS_DEVICE_NOT_READY;
   }

   //
   // get the device type for later use
   //            
   status = PcmciaGetDeviceType(Pdo, FunctionNumber, &deviceType);
   
   if (!NT_SUCCESS(status)) {
      return status;
   }
            
   //
   // The first hardware id is identical to the device id
   // Generate the device id
   //
   status = PcmciaGenerateDeviceId(socketData,
                                   FunctionNumber,
                                   &strings[stringCount++]);
   if (!NT_SUCCESS(status)) {
      return status;
   }

   try {
      status = STATUS_INSUFFICIENT_RESOURCES;
   
      hwId = ExAllocatePool(PagedPool, PCMCIA_MAXIMUM_DEVICE_ID_LENGTH);
     
      if (!hwId) {
         leave;
      }
      strings[stringCount++] = hwId;
      
      //
      // The second hardware is the device id with the CRC replaced
      // with the manufacturer code and info
      //
      if (*(socketData->Mfg) == '\0' ) {
         //
         // No manufacturer name available
         //
         if (FunctionNumber == PCMCIA_MULTIFUNCTION_PARENT) {
            if (socketData->Flags & SDF_JEDEC_ID) {
               sprintf(hwId, "%s\\%s-%04x",
                       PCMCIA_ID_STRING,
                       PCMCIA_MEMORY_ID_STRING,
                       socketData->JedecId);
            } else {
               sprintf(hwId, "%s\\%s-%04X-%04X",
                       PCMCIA_ID_STRING,
                       PCMCIA_UNKNOWN_MANUFACTURER_STRING,
                       socketData->ManufacturerCode,
                       socketData->ManufacturerInfo);
            }
         } else {
            sprintf(hwId, "%s\\%s-DEV%d-%04X-%04X", PCMCIA_ID_STRING,
                    PCMCIA_UNKNOWN_MANUFACTURER_STRING,
                    FunctionNumber,
                    socketData->ManufacturerCode,
                    socketData->ManufacturerInfo);
     
         }
         
      } else {
         UCHAR Mfg[MAX_MANFID_LENGTH];
         UCHAR Ident[MAX_IDENT_LENGTH];
      
         PcmciaFilterIdString(socketData->Mfg, Mfg, MAX_MANFID_LENGTH);
         PcmciaFilterIdString(socketData->Ident, Ident, MAX_IDENT_LENGTH);

         //
         // Here a mistake on Win2000 is forcing us to now generate two different
         // IDs. The intended and documented form at this point is to generate:
         //
         //   PCMCIA\<mfg>-<ident>-<code>-<info>
         //
         // but Win2000 had a bug where this was generated instead:
         //
         //   PCMCIA\<mfg>-<code>-<info>
         //
         // So now we generate both in case someone started using the bogus format.
         //
         
         hwId2 = ExAllocatePool(PagedPool, PCMCIA_MAXIMUM_DEVICE_ID_LENGTH);
         
         if (!hwId2) {
            leave;
         }
         strings[stringCount++] = hwId2;
     
         if (FunctionNumber == PCMCIA_MULTIFUNCTION_PARENT) {
            sprintf(hwId, "%s\\%s-%s-%04X-%04X", PCMCIA_ID_STRING,
                    Mfg,
                    Ident,
                    socketData->ManufacturerCode,
                    socketData->ManufacturerInfo);
     
            sprintf(hwId2, "%s\\%s-%04X-%04X", PCMCIA_ID_STRING,
                    Mfg,
                    socketData->ManufacturerCode,
                    socketData->ManufacturerInfo);
         } else {
            sprintf(hwId, "%s\\%s-%s-DEV%d-%04X-%04X",
                    PCMCIA_ID_STRING,
                    Mfg,
                    Ident,
                    FunctionNumber,
                    socketData->ManufacturerCode,
                    socketData->ManufacturerInfo);
     
            sprintf(hwId2, "%s\\%s-DEV%d-%04X-%04X",
                    PCMCIA_ID_STRING,
                    Mfg,
                    FunctionNumber,
                    socketData->ManufacturerCode,
                    socketData->ManufacturerInfo);
         }
      }
     
      
      if (deviceType == PCCARD_TYPE_ATA) {
      
         hwId = ExAllocatePool(PagedPool, PCMCIA_MAXIMUM_DEVICE_ID_LENGTH);
        
         if (!hwId) {
            leave;
         }
         strings[stringCount++] = hwId;
                         
         sprintf(hwId, "%s\\%s",
                 PCMCIA_ID_STRING,
                 PcmciaCompatibleIds[PCCARD_TYPE_ATA]);
      }

      status = PcmciaStringsToMultiString(strings , stringCount, HardwareIds);
      
   } finally {      
   
      while(stringCount != 0) {
         ExFreePool(strings[--stringCount]);
      }
      
   }

   return  status;
}


NTSTATUS
PcmciaGetCompatibleIds(
   IN  PDEVICE_OBJECT Pdo,
   IN  ULONG FunctionNumber,
   OUT PUNICODE_STRING CompatibleIds
   )
/*++

Routine Description:

   This routine returns the  compatible ids for the given PC-Card.
   Compatible id's are generated based on the Function Id of the PC-Card
   obtained from the CISTPL_FUNCID in the CIS tuple info. on the PC-Card.
   A table lookup is done based on the CISTPL_FUNCID to obtain the compatible id

   This compatible id is identical to the win 9x generated compatible ids

Arguments:

   Pdo - Pointer to the device object representing the PC-Card
   FunctionNumber - Function number of the function in  a multi-function card.
                    If this is PCMCIA_MULTIFUNCTION_PARENT, then the requested compatibleid
                    is for the parent device - not for any individual function
   CompatibleIds - Pointer to the unicode string which would contain the compatible ids
                   as a multi-string on return

Return value:

   STATUS_SUCCESS
   Any other status - could not generate compatible ids

--*/
{
   UCHAR    deviceType ;
   NTSTATUS status;
   PCSTR strings[1] = {""};

   PAGED_CODE();

   status = PcmciaGetDeviceType(Pdo, FunctionNumber, &deviceType);
   
   if (!NT_SUCCESS(status)) {
      return status;
   }

   if ((deviceType == PCCARD_TYPE_RESERVED) ||
       (deviceType > PCMCIA_MAX_DEVICE_TYPE_SUPPORTED)) {
      status =  PcmciaStringsToMultiString(strings, 1, CompatibleIds);
   } else {
      status =  PcmciaStringsToMultiString(&PcmciaCompatibleIds[deviceType], 1, CompatibleIds);
   }

   return status;
}


NTSTATUS
PcmciaGetDeviceType(
   IN  PDEVICE_OBJECT Pdo,
   IN  ULONG FunctionNumber,
   OUT PUCHAR DeviceType
   )
/*++

Routine Description:

   This routine returns the device type for the given PC-Card.
   device type is obtained from the CISTPL_FUNCID in the CIS tuple info. on the PC-Card.

Arguments:

   Pdo - Pointer to the device object representing the PC-Card
   FunctionNumber - Function number of the function in  a multi-function card.
                    If this is PCMCIA_MULTIFUNCTION_PARENT, then the requested compatibleid
                    is for the parent device - not for any individual function

Return value:

   device type

--*/
{
   UCHAR    deviceType ;
   PPDO_EXTENSION pdoExtension;

   PAGED_CODE();

   pdoExtension = Pdo->DeviceExtension;

   if (IsDeviceMultifunction(pdoExtension)) {
      if (FunctionNumber == PCMCIA_MULTIFUNCTION_PARENT) {
         //
         // This is for the root multifunction pc-card
         //
         deviceType = PCCARD_TYPE_MULTIFUNCTION3;
      } else {
         //
         // This is for the individual multifunction child
         //
         PSOCKET_DATA socketData;
         ULONG index;

         for (socketData = pdoExtension->SocketData, index = 0; (socketData != NULL);
             socketData = socketData->Next,index++) {
            if (socketData->Function == FunctionNumber) {
               //
               // Found the child;
               //
               break;
            }
         }
         if (!socketData) {
            ASSERT (socketData);
            return STATUS_DEVICE_NOT_READY;
         }
         deviceType = socketData->DeviceType;
      }
   } else {
      //
      // This is a run-of-the mill single function card
      //
      deviceType = pdoExtension->SocketData->DeviceType;
   }

   *DeviceType = deviceType;
   return STATUS_SUCCESS;
}
           

NTSTATUS
PcmciaStringsToMultiString(
   IN PCSTR * Strings,
   IN ULONG Count,
   IN PUNICODE_STRING MultiString
   )
/*++

Routine Description:

   This routine formats a set of supplied strings into a multi string format, terminating
   it with  a double '\0' character

Arguments:

   Strings - Pointer to an array of strings
   Count -   Number of strings in the supplied array which are packed into the multi-string
   MultiString - Pointer to the Unicode string which packs the supplied string as a multi-string
                 terminated by double NULL

Return value:

   STATUS_SUCCESS
   STATUS_INSUFFICIENT_RESOURCES - Could not allocate memory for the multi-string


--*/
{
   ULONG i, multiStringLength=0;
   UNICODE_STRING tempMultiString;
   PCSTR * currentString;
   ANSI_STRING ansiString;
   NTSTATUS status;


   ASSERT (MultiString->Buffer == NULL);

   for (i = Count, currentString = Strings; i > 0;i--, currentString++) {
      RtlInitAnsiString(&ansiString, *currentString);
      multiStringLength += RtlAnsiStringToUnicodeSize(&ansiString);

   }
   ASSERT(multiStringLength != 0);
   multiStringLength += sizeof(WCHAR);

   MultiString->Buffer = ExAllocatePool(PagedPool, multiStringLength);
   if (MultiString->Buffer == NULL) {

      return STATUS_INSUFFICIENT_RESOURCES;

   }

   MultiString->MaximumLength = (USHORT) multiStringLength;
   MultiString->Length = (USHORT) multiStringLength;

   tempMultiString = *MultiString;

   for (i = Count, currentString = Strings; i > 0;i--, currentString++) {
      RtlInitAnsiString(&ansiString, *currentString);
      status = RtlAnsiStringToUnicodeString(&tempMultiString,
                                            &ansiString,
                                            FALSE);
      ASSERT(NT_SUCCESS(status));
      ((PSTR) tempMultiString.Buffer) += tempMultiString.Length + sizeof(WCHAR);
   };

   //
   // Add one more NULL to terminate the multi string
   //
   RtlZeroMemory(tempMultiString.Buffer, sizeof(WCHAR));
   return STATUS_SUCCESS;
}


NTSTATUS
PcmciaGetInstanceId(
   IN PDEVICE_OBJECT Pdo,
   OUT PUNICODE_STRING InstanceId
   )
/*++

Routine Description:

   This routine generates a unique instance id  (1 upwards) for the supplied
   PC-Card which is guaranteed not to clash with any other instance ids under
   the same pcmcia controller, for the same type of card.
   A new instance id is computed only if it was not already  present for the PC-Card.

Arguments:

   Pdo - Pointer to the  device object representing the PC-Card
   InstanceId -  Pointer to a unicode string which will contain the generated
                 instance id.
                 Memory for the unicode string allocated by this routine.
                 Caller's responsibility to free it .

Return value:

   STATUS_SUCCESS
   STATUS_UNSUCCESSFUL - Currently there's a cap on the maximum value of instance id - 999999
                         This status returned only if more than 999999 PC-Cards exist under
                         this PCMCIA controller!
   Any other status - Something failed in the string allocation/conversion

--*/
{
   PPDO_EXTENSION pdoExtension=Pdo->DeviceExtension;
   PSOCKET socket = pdoExtension->Socket;
   PSOCKET_DATA socketData = pdoExtension->SocketData;
   ULONG    instance;
   NTSTATUS status;
   ANSI_STRING sizeString;

   ASSERT(InstanceId);

   if (!socketData) {
      return STATUS_DEVICE_NOT_READY;
   }
   //
   // Allocate memory for the unicode string
   // Maximum of 6 digits in the instance..
   //
   RtlInitAnsiString(&sizeString, "123456");
   status = RtlAnsiStringToUnicodeString(InstanceId, &sizeString, TRUE);

   if (!NT_SUCCESS(status)) {
      return status;
   }

   //
   // Don't recompute instance if it's already present
   //
   if (socketData->Instance) {

      status = RtlIntegerToUnicodeString(socketData->Instance, 10, InstanceId);

   } else {
      KIRQL OldIrql;
      //
      // Synchronize access to prevent two identical ids/instances
      //
      KeAcquireSpinLock(&PcmciaGlobalLock, &OldIrql);

      //
      // assume failure
      //   
      status = STATUS_UNSUCCESSFUL;
      
      for (instance = 1; instance <= PCMCIA_MAX_INSTANCE; instance++) {
         if (PcmciaCheckInstance(pdoExtension->DeviceId,
                                 instance)) {
            socketData->Instance = instance;
            break;
         }
      }

      KeReleaseSpinLock(&PcmciaGlobalLock, OldIrql);
      
      if (socketData->Instance) {
         status = RtlIntegerToUnicodeString(instance, 10, InstanceId);
      }
   }
   
   if (!NT_SUCCESS(status)) {
      RtlFreeUnicodeString(InstanceId);
   }
   
   return status;
}


BOOLEAN
PcmciaCheckInstance(
   IN PUCHAR  DeviceId,
   IN ULONG   Instance
   )
/*++

Routine Description:

   This routine checks to see if the supplied instance id clashes with any other PC-card
   with the same device id

Arguments:

   SocketList - Pointer to the list of sockets on the PCMCIA controller
   DeviceId   - Pointer to the device id of the PC-Card for which the Instance Id is being checked
   Instance   - Instance Id which needs to be verified

Return value:

   TRUE - Instance is unique for the given DeviceId and may be used
   FALSE - Instance clashes with another instance id for the same device id

--*/
{
   PPDO_EXTENSION pdoExtension;
   PFDO_EXTENSION fdoExtension;
   PSOCKET_DATA   socketData;
   PDEVICE_OBJECT fdo, pdo;

   for (fdo = FdoList; fdo != NULL; fdo = fdoExtension->NextFdo) {
      fdoExtension = fdo->DeviceExtension;
      ASSERT (fdoExtension);

      if (!IsDeviceStarted(fdoExtension)) {
         continue;
      }

      for (pdo = fdoExtension->PdoList; pdo != NULL; pdo = pdoExtension->NextPdoInFdoChain) {
         pdoExtension = pdo->DeviceExtension;
         socketData = pdoExtension->SocketData;

         if (IsDevicePhysicallyRemoved(pdoExtension)) {
            //
            // going to be removed soon
            //
            continue;
         }
         if (!socketData) {
            //
            // socketData already cleaned up
            //
            continue;
         }
         //
         // If  an instance has not
         // been assigned yet to this card, skip
         //
         if (socketData->Instance == 0) {
            continue;
         }

         //
         // If this socket's device id matches the given socket's device id
         // compare the instances: if equal, then this instance is not ok.
         //
         //
         if ((pdoExtension->DeviceId == NULL) || (DeviceId == NULL)) {
            continue;
         }

         if ((strcmp(pdoExtension->DeviceId, DeviceId)==0) &&
             (socketData->Instance == Instance)) {
            return FALSE;
         }
      }
   }
   //
   // Instance is ok and unique
   //
   return TRUE;
}



VOID
PcmciaFilterIdString(
   IN PUCHAR pIn,
   OUT PUCHAR pOut,
   ULONG MaxLen
   )
/*++

   Filters out characters that shouldn't appear in device id's

Arguments:

   pIn    - pointer to input string
   pOut   - pointer to output string
   MaxLen - size of buffers

Return Value

   none

--*/
{
   ULONG i;
   
   for (i=0; i < MaxLen; i++) {
   
      if (*pIn == 0) {
         *pOut = 0;
         break;
      }
      
      if (*pIn >= ' ' && *pIn < 0x7F) {
          *pOut++ = *pIn++;
      } else {
          pIn++;
      }
      
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\pcmcibus\dispatch.c ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

    This module contains the global dispatch related
    routines for the pcmcia controller & it's child devices

Author:

    Ravisankar Pudipeddi  (ravisp) 11/1/96

Environment:

    Kernel mode

Revision History :


--*/

#include "pch.h"

#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, PcmciaInitDeviceDispatchTable)
#endif

//
// Dispatch table array for FDOs/PDOs
//
PDRIVER_DISPATCH DeviceObjectDispatch[sizeof(DEVICE_OBJECT_TYPE)][IRP_MJ_MAXIMUM_FUNCTION + 1];

VOID
PcmciaInitDeviceDispatchTable(
                    IN PDRIVER_OBJECT DriverObject
                 )
/*++

Routine Description:
    Initializes the IRP dispatch tables for Pdo's & Fdo's

Arguments:
    None

Return value:
    None

--*/
{
   ULONG i;

   PAGED_CODE();

   //
   // Init the controller (FDO) dispatch table
   //
   DeviceObjectDispatch[FDO][IRP_MJ_CREATE] =         PcmciaOpenCloseDispatch;
   DeviceObjectDispatch[FDO][IRP_MJ_CLOSE]  =         PcmciaOpenCloseDispatch;
   DeviceObjectDispatch[FDO][IRP_MJ_CLEANUP]=         PcmciaCleanupDispatch;
   DeviceObjectDispatch[FDO][IRP_MJ_DEVICE_CONTROL] = PcmciaDeviceControl;
   DeviceObjectDispatch[FDO][IRP_MJ_SYSTEM_CONTROL] = PcmciaFdoSystemControl;
   DeviceObjectDispatch[FDO][IRP_MJ_PNP] =            PcmciaFdoPnpDispatch;
   DeviceObjectDispatch[FDO][IRP_MJ_POWER] =          PcmciaFdoPowerDispatch;

   //
   // Init the PDO dispatch table
   //
   DeviceObjectDispatch[PDO][IRP_MJ_DEVICE_CONTROL] = PcmciaPdoDeviceControl;
   DeviceObjectDispatch[PDO][IRP_MJ_SYSTEM_CONTROL] = PcmciaPdoSystemControl;
   DeviceObjectDispatch[PDO][IRP_MJ_PNP] =            PcmciaPdoPnpDispatch;
   DeviceObjectDispatch[PDO][IRP_MJ_POWER] =          PcmciaPdoPowerDispatch;

   //
   // Set the global dispatch table
   DriverObject->MajorFunction[IRP_MJ_CREATE] =         PcmciaDispatch;
   DriverObject->MajorFunction[IRP_MJ_CLOSE] =          PcmciaDispatch;
   DriverObject->MajorFunction[IRP_MJ_CLEANUP] =        PcmciaDispatch;
   DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = PcmciaDispatch;
   DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = PcmciaDispatch;
   DriverObject->MajorFunction[IRP_MJ_SHUTDOWN] =       PcmciaDispatch;
   DriverObject->MajorFunction[IRP_MJ_PNP] =            PcmciaDispatch;
   DriverObject->MajorFunction[IRP_MJ_POWER] =          PcmciaDispatch;
}

NTSTATUS
PcmciaDispatch(
      IN PDEVICE_OBJECT DeviceObject,
      IN PIRP Irp
      )

/*++

Routine Description:

   Dispatch routine for all IRPs handled by this driver. This dispatch would then
   call the appropriate real dispatch routine which corresponds to the device object
   type (physical or functional).

Arguments:

   DeviceObject -  Pointer to the device object this dispatch is intended for
   Irp          -  Pointer to the IRP to be handled

Return value:
   Returns the status from the 'real' dispatch routine which handles this IRP

--*/

{
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
   NTSTATUS status;
   DEVICE_OBJECT_TYPE devtype = IS_PDO(DeviceObject) ? PDO : FDO;
   UCHAR MajorFunction = irpStack->MajorFunction;
   
   if ((MajorFunction > IRP_MJ_MAXIMUM_FUNCTION) || 
      (DeviceObjectDispatch[devtype][MajorFunction] == NULL)) {
      
      DebugPrint((PCMCIA_DEBUG_INFO, "PCMCIA: Dispatch skipping unimplemented Irp MJ function %x\n", MajorFunction));
      status = Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);

   } else if (((devtype == PDO) && IsDeviceDeleted((PPDO_EXTENSION)DeviceObject->DeviceExtension)) ||
              ((devtype == FDO) && IsDeviceDeleted((PFDO_EXTENSION)DeviceObject->DeviceExtension))) {
      //
      // This do was supposed to have been already deleted
      // so we don't support any IRPs on it
      //
      DebugPrint((PCMCIA_DEBUG_INFO, "PCMCIA: Dispatch skipping Irp on deleted DO %08x MJ function %x\n", DeviceObject, MajorFunction));
      
      if (MajorFunction == IRP_MJ_POWER) {
         PoStartNextPowerIrp(Irp);
      }
      status = Irp->IoStatus.Status = STATUS_DELETE_PENDING;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
      
   } else if (((KeGetCurrentIrql() == DISPATCH_LEVEL) && (MajorFunction != IRP_MJ_POWER)) ||
              (KeGetCurrentIrql() > DISPATCH_LEVEL)) {
      //
      // This is too high an IRQL to handle
      //

      if (MajorFunction == IRP_MJ_POWER) {
         PoStartNextPowerIrp(Irp);
      }
      status = Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
   
   } else {
   
      //
      // Dispatch the irp
      //   
      status = ((*DeviceObjectDispatch[devtype][MajorFunction])(DeviceObject, Irp));
      
   }
   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\pcmcibus\o2m.c ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    o2m.c

Abstract:

    This module contains the code that contains
    O2 micro cardbus controller specific initialization and
    other dispatches

Author:

    Ravisankar Pudipeddi (ravisp) 1-Nov-97


Environment:

    Kernel mode

Revision History :


--*/

#include "pch.h"



VOID
O2MInitialize(
   IN PFDO_EXTENSION FdoExtension
   )
/*++

Routine Description:

    Initialize O2Micro controllers

Arguments:

    FdoExtension - Pointer to the device extension for the controller FDO

Return Value:

    None
--*/
{
   UCHAR byte;
   USHORT word;

   //
   // patch for o2micro controllers courtesy of Eric Still (ejstill@o2micro.com)
   //
   byte = PcicReadSocket(FdoExtension->SocketList, 0x3a) | 0xa0;
   PcicWriteSocket(FdoExtension->SocketList, 0x3a, byte);

   //
   // initialize IRQ routing to ISA
   //

   GetPciConfigSpace(FdoExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
   word |= BCTRL_IRQROUTING_ENABLE;
   SetPciConfigSpace(FdoExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
}


NTSTATUS
O2MSetPower(
   IN PSOCKET Socket,
   IN BOOLEAN Enable,
   OUT PULONG pDelayTime
   )

/*++

Routine Description:

    Set power to the specified socket.

Arguments:

    SocketPtr - the socket to set
    Enable - TRUE means to set power - FALSE is to turn it off.
    pDelayTime - specifies delay (msec) to occur after the current phase

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED - increment phase, perform delay, recall
    other status values terminate sequence

--*/

{
   NTSTATUS status;

   status = CBSetPower(Socket, Enable, pDelayTime);
   
   if (NT_SUCCESS(status) & Enable) {
      UCHAR byte;
      
      //
      // patch for o2micro controllers courtesy of Eric Still (ejstill@o2micro.com)
      //
      byte = PcicReadSocket(Socket, 0x3a) | 0xa0;
      PcicWriteSocket(Socket, 0x3a, byte);
   }
   return status;
}   


BOOLEAN
O2MSetZV(
   IN PSOCKET Socket,
   IN BOOLEAN Enable
   )
{
   ULONG oldValue;
   
   if (Enable) {
      oldValue = CBReadSocketRegister(Socket, CBREG_O2MICRO_ZVCTRL);
      oldValue |= ZVCTRL_ZV_ENABLE;
      CBWriteSocketRegister(Socket, CBREG_O2MICRO_ZVCTRL, oldValue);
   } else {
      oldValue = CBReadSocketRegister(Socket, CBREG_O2MICRO_ZVCTRL);
      oldValue &= ~ZVCTRL_ZV_ENABLE;
      CBWriteSocketRegister(Socket, CBREG_O2MICRO_ZVCTRL, oldValue);
   }

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\pcmcibus\intrface.c ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    intrface.c

Abstract:

    This module contains the external interfaces of the
    pcmcia driver

Author:

    Neil Sandlin (neilsa) 3-Mar-1999

Environment:

    Kernel mode

Revision History :


--*/

#include "pch.h"

//
// Internal References
//

ULONG
PcmciaReadCardMemory(
   IN  PDEVICE_OBJECT Pdo,
   IN  ULONG          WhichSpace,
   OUT PUCHAR         Buffer,
   IN  ULONG          Offset,
   IN  ULONG          Length
   );
   
ULONG
PcmciaWriteCardMemory(
   IN PDEVICE_OBJECT Pdo,
   IN ULONG          WhichSpace,
   IN PUCHAR         Buffer,
   IN ULONG          Offset,
   IN ULONG          Length
   );

NTSTATUS
PcmciaMfEnumerateChild(
   IN  PPDO_EXTENSION PdoExtension,
   IN  ULONG Index,
   OUT PMF_DEVICE_INFO ChildInfo
   );

BOOLEAN
PcmciaModifyMemoryWindow(
   IN PDEVICE_OBJECT Pdo,
   IN ULONGLONG HostBase,
   IN ULONGLONG CardBase,
   IN BOOLEAN   Enable,
   IN ULONG     WindowSize  OPTIONAL,
   IN UCHAR     AccessSpeed OPTIONAL,
   IN UCHAR     BusWidth    OPTIONAL,
   IN BOOLEAN   IsAttributeMemory OPTIONAL
   );

BOOLEAN
PcmciaSetVpp(
   IN PDEVICE_OBJECT Pdo,
   IN UCHAR          VppLevel
   );

BOOLEAN
PcmciaIsWriteProtected(
   IN PDEVICE_OBJECT Pdo
   );

BOOLEAN
PcmciaTranslateBusAddress(
    IN PVOID Context,
    IN PHYSICAL_ADDRESS BusAddress,
    IN ULONG Length,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

PDMA_ADAPTER
PcmciaGetDmaAdapter(
   IN PVOID Context,
   IN struct _DEVICE_DESCRIPTION *DeviceDescriptor,
   OUT PULONG NumberOfMapRegisters
   );

VOID
PcmciaNop(
   IN PVOID Context
   );
   

#ifdef ALLOC_PRAGMA
   #pragma alloc_text(PAGE,  PcmciaPdoQueryInterface)
   #pragma alloc_text(PAGE,  PcmciaMfEnumerateChild)
   #pragma alloc_text(PAGE,  PcmciaNop)
   #pragma alloc_text(PAGE,  PcmciaGetInterface)
   #pragma alloc_text(PAGE,  PcmciaUpdateInterruptLine)
#endif



NTSTATUS
PcmciaPdoQueryInterface(
   IN PDEVICE_OBJECT Pdo,
   IN OUT PIRP       Irp
   )
/*++

Routine Description:

   Fills in the interface requested


   Interfaces supported are:

    GUID_PCMCIA_INTERFACE_STANDARD:

    This returns a pointer to a PCMCIA_INTERFACE_STANDARD structure.
    These interfaces are exported solely for flash memory card support as
    a means for flash memory card drivers to slide memory windows,
    set Vpp levels etc.

    GUID_TRANSLATOR_INTERFACE_STANDARD:

    This returns an interrupt translator for 16-bit pc-cards which is used
    by PnP for translating raw IRQs. We simply return the Hal implemented
    translator, since PCMCIA does not need any specific translation. We do not
    return a translator if this is for a cardbus card

    GUID_PCMCIA_BUS_INTERFACE_STANDARD:

    This returns a pointer to a PCMCIA_BUS_INTERFACE_STANDARD structure.
    This contains entry points to set/get PCMCIA config data for the pc-card


    GUID_MF_ENUMERATION_INTERFACE

    For 16-bit multifunction pc-cards returns a pointer to MF_ENUMERATION_INTERFACE
    structure which contains entry points to enumerate multifunction children of
    the pc-card

    Completes the Passed in IRP before returning

Arguments

   Pdo - Pointer to the device object
   Irp - Pointer to the io request packet

Return Value

   STATUS_SUCCESS
   STATUS_INSUFFICIENT_RESOURCES - if supplied interface size is
                                   not big enough to accomodate the interface
   STATUS_INVALID_PARAMETER_1 - if the requested interface is not supported
                                by this driver
--*/

{

   PIO_STACK_LOCATION irpStack;
   PPCMCIA_INTERFACE_STANDARD pcmciaInterfaceStandard;
   GUID *interfaceType;
   PPDO_EXTENSION  pdoExtension;
   PFDO_EXTENSION  fdoExtension;
   PSOCKET     socket;
   NTSTATUS    status;

   PAGED_CODE();

   irpStack = IoGetCurrentIrpStackLocation(Irp);
   interfaceType = (GUID *) irpStack->Parameters.QueryInterface.InterfaceType;
   pdoExtension = Pdo->DeviceExtension;
   socket = pdoExtension->Socket;
   fdoExtension = socket->DeviceExtension;
   if (Is16BitCard(pdoExtension) && CompareGuid(interfaceType, (PVOID) &GUID_PCMCIA_INTERFACE_STANDARD)) {

      if (irpStack->Parameters.QueryInterface.Size < sizeof(PCMCIA_INTERFACE_STANDARD)) {
         return STATUS_INVALID_PARAMETER;
      }
      
      //
      // Ignore the version for the present
      //
      pcmciaInterfaceStandard = (PPCMCIA_INTERFACE_STANDARD) irpStack->Parameters.QueryInterface.Interface;

      RtlZeroMemory(pcmciaInterfaceStandard, sizeof (PCMCIA_INTERFACE_STANDARD));
      pcmciaInterfaceStandard->Size =    sizeof(PCMCIA_INTERFACE_STANDARD);
      pcmciaInterfaceStandard->Version = 1;
      pcmciaInterfaceStandard->Context = Pdo;
      //
      // Fill in the exported functions
      //
      socket = pdoExtension->Socket;

      ASSERT (socket != NULL);
      pcmciaInterfaceStandard->InterfaceReference   = (PINTERFACE_REFERENCE) PcmciaNop;
      pcmciaInterfaceStandard->InterfaceDereference = (PINTERFACE_DEREFERENCE) PcmciaNop;
      pcmciaInterfaceStandard->ModifyMemoryWindow   = PcmciaModifyMemoryWindow;
      pcmciaInterfaceStandard->SetVpp               = PcmciaSetVpp;
      pcmciaInterfaceStandard->IsWriteProtected     = PcmciaIsWriteProtected;
      Irp->IoStatus.Status = status = STATUS_SUCCESS;;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);

   } else if (CompareGuid(interfaceType, (PVOID) &GUID_TRANSLATOR_INTERFACE_STANDARD)
              && ((ULONG_PTR)irpStack->Parameters.QueryInterface.InterfaceSpecificData ==
                  CmResourceTypeInterrupt)) {
      if ((Is16BitCard(pdoExtension) && !IsSocketFlagSet(pdoExtension->Socket, SOCKET_CB_ROUTE_R2_TO_PCI)) &&
          //
          // Eject a translator only if  the controller is  PCI enumerated
          // (i.e. we are enumerated by PCI - so we eject a PCI-Isa translator)
          //
          (CardBusExtension(fdoExtension) ||  PciPcmciaBridgeExtension(fdoExtension))) {

         PTRANSLATOR_INTERFACE translator;
         ULONG busNumber;
         //
         // We need a translator for this PDO (16-bit pc-card) which uses
         // ISA resources.
         //
         status = HalGetInterruptTranslator(
                                           PCIBus,
                                           0,
                                           Isa,
                                           irpStack->Parameters.QueryInterface.Size,
                                           irpStack->Parameters.QueryInterface.Version,
                                           (PTRANSLATOR_INTERFACE) irpStack->Parameters.QueryInterface.Interface,
                                           &busNumber
                                           );
         Irp->IoStatus.Status = status;
         IoCompleteRequest(Irp, IO_NO_INCREMENT);
      } else {
         //
         // Translator interface not supported for this card/controller
         //
         if (pdoExtension->LowerDevice != NULL) {
            PcmciaSkipCallLowerDriver(status, pdoExtension->LowerDevice, Irp);
         } else {
            status = Irp->IoStatus.Status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
         }
      }

   } else if (IsDeviceMultifunction(pdoExtension) && CompareGuid(interfaceType, (PVOID)&GUID_MF_ENUMERATION_INTERFACE)) {
      //
      // Multifunction enumeration interface
      //
      PMF_ENUMERATION_INTERFACE mfEnum;

      mfEnum = (PMF_ENUMERATION_INTERFACE) irpStack->Parameters.QueryInterface.Interface;
      mfEnum->Context = pdoExtension;
      mfEnum->InterfaceReference = PcmciaNop;
      mfEnum->InterfaceDereference = PcmciaNop;
      mfEnum->EnumerateChild = (PMF_ENUMERATE_CHILD) PcmciaMfEnumerateChild;
      status = Irp->IoStatus.Status = STATUS_SUCCESS;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);

   } else if (CompareGuid(interfaceType, (PVOID)&GUID_PCMCIA_BUS_INTERFACE_STANDARD)) {

      PPCMCIA_BUS_INTERFACE_STANDARD busInterface;

      busInterface = (PPCMCIA_BUS_INTERFACE_STANDARD) irpStack->Parameters.QueryInterface.Interface;
      busInterface->Context = Pdo;
      busInterface->InterfaceReference   = PcmciaNop;
      busInterface->InterfaceDereference = PcmciaNop;
      busInterface->ReadConfig  = PcmciaReadCardMemory;
      busInterface->WriteConfig = PcmciaWriteCardMemory;
      status = Irp->IoStatus.Status = STATUS_SUCCESS;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);

   } else if (Is16BitCard(pdoExtension) && CompareGuid(interfaceType, (PVOID) &GUID_BUS_INTERFACE_STANDARD)) {
      PBUS_INTERFACE_STANDARD busInterface = (PBUS_INTERFACE_STANDARD)irpStack->Parameters.QueryInterface.Interface;
     
      busInterface->Size = sizeof( BUS_INTERFACE_STANDARD );
      busInterface->Version = 1;
      busInterface->Context = Pdo;
      busInterface->InterfaceReference   = PcmciaNop;
      busInterface->InterfaceDereference = PcmciaNop;
      busInterface->TranslateBusAddress = PcmciaTranslateBusAddress;
      busInterface->GetDmaAdapter = PcmciaGetDmaAdapter;
      busInterface->GetBusData = PcmciaReadCardMemory;
      busInterface->SetBusData = PcmciaWriteCardMemory;
      status = Irp->IoStatus.Status = STATUS_SUCCESS;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
   
   } else {
      //
      // Query Interface type not supported
      //
      if (pdoExtension->LowerDevice != NULL) {
         PcmciaSkipCallLowerDriver(status, pdoExtension->LowerDevice, Irp);
      } else {
         status = Irp->IoStatus.Status;
         IoCompleteRequest(Irp, IO_NO_INCREMENT);
      }
   }
   return status;
}


ULONG
PcmciaReadCardMemory(
   IN      PDEVICE_OBJECT Pdo,
   IN      ULONG          WhichSpace,
   OUT     PUCHAR         Buffer,
   IN      ULONG          Offset,
   IN      ULONG          Length
   )
/*++

Routine Description:

     Stub for reading card memory which is exported via
     PCMCIA_BUS_INTERFACE_STANDARD. This just calls the
     PcmciaReadWriteCardMemory which does the real work

     Note: this has to be non-paged since it can be called by
     clients at DISPATCH_LEVEL

Arguments:

 Pdo -          Device object representing the PC-CARD whose config memory needs to be read
 WhichSpace -   Indicates which memory space needs to be mapped: one of
                PCCARD_COMMON_MEMORY_SPACE
                PCCARD_ATTRIBUTE_MEMORY_SPACE
                PCCARD_PCI_CONFIGURATION_MEMORY_SPACE (only for cardbus cards)


 Buffer -       Caller supplied buffer into which the memory contents are copied
                Offset -       Offset of the attribute memory at which we copy
                Length -       Number of bytes of attribute memory to be copied

 Return value:
 
    Count of bytes read
 
--*/
{

   DebugPrint((PCMCIA_DEBUG_INTERFACE, "pdo %08x read card memory\n", Pdo));
   return NT_SUCCESS(PcmciaReadWriteCardMemory(Pdo, WhichSpace, Buffer, Offset, Length, TRUE)) ?
                     Length : 0;
}



ULONG
PcmciaWriteCardMemory(
   IN      PDEVICE_OBJECT Pdo,
   IN      ULONG          WhichSpace,
   IN      PUCHAR         Buffer,
   IN      ULONG          Offset,
   IN      ULONG          Length
   )
/*++

Routine Description:

     Stub for writing to card memory which is exported via
     PCMCIA_BUS_INTERFACE_STANDARD. This just calls
     PcmciaReadWriteCardMemory which does the real work

     Note: this has to be non-paged since it can be called by
     clients at DISPATCH_LEVEL

Arguments:

 Pdo -          Device object representing the PC-CARD whose config memory needs to be written to
 WhichSpace -   Indicates which memory space needs to be mapped: one of
                PCCARD_COMMON_MEMORY_SPACE
                PCCARD_ATTRIBUTE_MEMORY_SPACE
                PCCARD_PCI_CONFIGURATION_MEMORY_SPACE (only for cardbus cards)


 Buffer -       Caller supplied buffer out of which the memory contents are copied
                Offset -       Offset of the attribute memory at which we copy
                Length -       Number of bytes of buffer to be copied

 Return value:
 
    Count of bytes written
 
--*/
{

   DebugPrint((PCMCIA_DEBUG_INTERFACE, "pdo %08x write card memory\n", Pdo));
   return NT_SUCCESS(PcmciaReadWriteCardMemory(Pdo, WhichSpace, Buffer, Offset, Length, FALSE)) ?
                     Length : 0;
}


BOOLEAN
PcmciaModifyMemoryWindow(
   IN PDEVICE_OBJECT Pdo,
   IN ULONGLONG HostBase,
   IN ULONGLONG CardBase,
   IN BOOLEAN   Enable,
   IN ULONG     WindowSize  OPTIONAL,
   IN UCHAR     AccessSpeed OPTIONAL,
   IN UCHAR     BusWidth    OPTIONAL,
   IN BOOLEAN   IsAttributeMemory OPTIONAL
   )
/*++

Routine Description:

   Part of the interfaces originally developed to
   support flash memory cards.

   This routine enables the caller to 'slide' the supplied
   host memory window across the given (16-bit)pc-card's card memory.
   i.e. the host memory window will be modified to map
   the pc-card at a new card memory offset

Arguments:

   Pdo         - Pointer to the device object for the PC-Card

   HostBase    - Host memory window base to be mapped

   CardBase    - Mandatory if Enable is TRUE
                 New card memory offset to map the host memory window
                 to

   Enable      - If this is FALSE - all the remaining arguments
                 are ignored and the host window will simply be
                 disabled

   WindowSize  - Specifies the size of the host memory window to
                 be mapped. Note this must be at the proper alignment
                 and must be less than or equal to the originally
                 allocated window size for the host base.
                 If this is zero, the originally allocated window
                 size will be used.

   AccessSpeed - Mandatory if Enable is TRUE
                 Specifies the new access speed for the pc-card.
                 (AccessSpeed should be encoded as per the pc-card
                  standard, card/socket services spec)

   BusWidth    - Mandatory if Enable is TRUE
                 One of PCMCIA_MEMORY_8BIT_ACCESS
                 or     PCMCIA_MEMORY_16BIT_ACCESS

   IsAttributeMemory - Mandatory if Enable is TRUE
                       Specifies if the window should be mapped
                       to the pc-card's attribute or common memory


Return Value:

   TRUE  -      Memory window was enabled/disabled as requested
   FALSE -      If not

--*/
{   
   PPDO_EXTENSION pdoExtension;
   PSOCKET socket;
   
   pdoExtension = Pdo->DeviceExtension;
   socket = pdoExtension->Socket;
   
   DebugPrint((PCMCIA_DEBUG_INTERFACE, "pdo %08x modify memory window\n", Pdo));
   if (socket->SocketFnPtr->PCBModifyMemoryWindow == NULL) {
      return FALSE;
   } else {
      return (*(socket->SocketFnPtr->PCBModifyMemoryWindow))(Pdo, HostBase, CardBase, Enable,
                                                             WindowSize, AccessSpeed, BusWidth,
                                                             IsAttributeMemory);
   }      
}      

BOOLEAN
PcmciaSetVpp(
   IN PDEVICE_OBJECT Pdo,
   IN UCHAR          VppLevel
   )
/*++

Routine Description

  Part of the interfaces originally developed to
  support flash memory cards.
  Sets VPP1 to the required setting

Arguments

  Pdo - Pointer to device object  for the PC-Card
  Vpp - Desired Vpp setting. This is currently one of
        PCMCIA_VPP_12V    (12 volts)
        PCMCIA_VPP_0V     (disable VPP)
        PCMCIA_VPP_IS_VCC (route VCC to VPP)

Return

   TRUE - if successful
   FALSE - if not. This will be returned if the
           PC-Card is not already powered up
--*/
{   
   PPDO_EXTENSION pdoExtension;
   PSOCKET socket;
   
   pdoExtension = Pdo->DeviceExtension;
   socket = pdoExtension->Socket;

   DebugPrint((PCMCIA_DEBUG_INTERFACE, "pdo %08x set vpp\n", Pdo));
   if (socket->SocketFnPtr->PCBSetVpp == NULL) {
      return FALSE; 
   } else {         
      return (*(socket->SocketFnPtr->PCBSetVpp))(Pdo, VppLevel);
   }
}   

BOOLEAN
PcmciaIsWriteProtected(
   IN PDEVICE_OBJECT Pdo
   )
/*++

Routine Description:

   Part of the interfaces originally developed to
   support flash memory cards.

   Returns the status of the write protected pin
   for the given PC-Card

Arguments:

   Pdo   - Pointer to the device object for the PC-Card

Return Value:

   TRUE  -      if the PC-Card is write-protected
   FALSE -      if not

--*/
{
   PPDO_EXTENSION pdoExtension;
   PSOCKET socket;
   
   pdoExtension = Pdo->DeviceExtension;
   socket = pdoExtension->Socket;

   DebugPrint((PCMCIA_DEBUG_INTERFACE, "pdo %08x is write protected \n", Pdo));
   if (socket->SocketFnPtr->PCBIsWriteProtected == NULL) {
      return FALSE;
   } else {         
      return (*(socket->SocketFnPtr->PCBIsWriteProtected))(Pdo);
   }      
}



BOOLEAN
PcmciaTranslateBusAddress(
    IN PVOID Context,
    IN PHYSICAL_ADDRESS BusAddress,
    IN ULONG Length,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )
/*++

Routine Description

   This function is used to translate bus addresses from legacy drivers.

Arguments

   Context - Supplies a pointer to the interface context.  This is actually
       the PDO for the root bus.

   BusAddress - Supplies the orginal address to be translated.

   Length - Supplies the length of the range to be translated.

   AddressSpace - Points to the location of of the address space type such as
       memory or I/O port.  This value is updated by the translation.

   TranslatedAddress - Returns the translated address.

Return Value

   Returns a boolean indicating if the operations was a success.

--*/
{
   return HalTranslateBusAddress(Isa,
                                 0,
                                 BusAddress,
                                 AddressSpace,
                                 TranslatedAddress);
}



PDMA_ADAPTER
PcmciaGetDmaAdapter(
   IN PVOID Context,
   IN struct _DEVICE_DESCRIPTION *DeviceDescriptor,
   OUT PULONG NumberOfMapRegisters
   )
/*++

Routine Description

   Passes IoGetDmaAdapter calls to the parent.

Arguments

   Context - Supplies a pointer to the interface context. This is actually the PDO.

   DeviceDescriptor - Supplies the device descriptor used to allocate the dma
       adapter object.

   NubmerOfMapRegisters - Returns the maximum number of map registers a device
       can allocate at one time.

Return Value

   Returns a DMA adapter or NULL.

--*/
{
   PDEVICE_OBJECT Pdo = Context;
   PPDO_EXTENSION pdoExtension;
   PFDO_EXTENSION fdoExtension;
   
   pdoExtension = Pdo->DeviceExtension;
   
   if (!pdoExtension || !pdoExtension->Socket || !pdoExtension->Socket->DeviceExtension) {
      return NULL;
   }      

   //
   // Get the parent FDO extension
   //   
   fdoExtension = pdoExtension->Socket->DeviceExtension;

   //
   // Pass the call on to the parent
   //   
   return IoGetDmaAdapter(fdoExtension->Pdo,
                          DeviceDescriptor,
                          NumberOfMapRegisters);
}


VOID
PcmciaNop(
   IN PVOID Context
   )
/*++

Routine Description

   Does nothing

Arguments

   none

Return Value

   none

--*/
{
   PAGED_CODE();
   UNREFERENCED_PARAMETER(Context);
}



NTSTATUS
PcmciaMfEnumerateChild(
   IN  PPDO_EXTENSION PdoExtension,
   IN  ULONG Index,
   OUT PMF_DEVICE_INFO ChildInfo
   )
/*++

Routine Description

   Returns required enumeration information for the multifunction children
   of the given pc-card. This fills in the required info. for the child
   indicated, returing STATUS_NO_MORE_ENTRIES when there are no more
   children to be enumerated

Arguments

   PdoExtension - Pointer to the device extension for the multifunction parent pc-card
   Index        - Zero based index for the child to be enumerated
   ChildInfo    - Caller allocated buffer in which the info about the child is returned.
                  We may allocate additional buffers for each field in the supplied
                  structure. This will be freed by the caller when no longer needed

Return value

   STATUS_SUCCESS          - supplied child info filled in & returned
   STATUS_NO_MORE_ENTRIES  - No child of the given index exists. Caller is
                             assumed to iteratively call this routine with index incremented
                             from 0 upwards till this status value is returned
   STATUS_NO_SUCH_DEVICE   - if the pc-card no longer exists
--*/
{
   PSOCKET           socket;
   PSOCKET_DATA      socketData;
   PCONFIG_ENTRY     configEntry, mfConfigEntry;
   ULONG             i, currentIndex, count;
   NTSTATUS          status;
   UCHAR             iRes;
   PUCHAR            idString;
   ANSI_STRING       ansiString;

   PAGED_CODE();

   DebugPrint((PCMCIA_DEBUG_INTERFACE,
               "PcmciaMfEnumerateChild: parent ext %x child index %x\n",
               PdoExtension,
               Index
              ));
   try {
      if (IsDeviceDeleted(PdoExtension) ||
          IsDeviceLogicallyRemoved(PdoExtension)) {
         //
         // This pdo is deleted or marked to be deleted
         //
         status = STATUS_NO_SUCH_DEVICE;
         leave;
      }

      socket = PdoExtension->Socket;
      ASSERT (socket != NULL);

      RtlZeroMemory(ChildInfo, sizeof(MF_DEVICE_INFO));

      if (Index >= socket->NumberOfFunctions) {
         //
         // info requested for a child which doesn't exist
         //
         status =  STATUS_NO_MORE_ENTRIES;
         leave;
      }

      //
      // Fill in the name field
      // This is of the form ChildXX
      // where XX is the number of the function
      // Examples: Child00, Child01 etc.
      //
      idString = (PUCHAR) ExAllocatePool(PagedPool, PCMCIA_MAXIMUM_DEVICE_ID_LENGTH);
      if (!idString) {
         status = STATUS_INSUFFICIENT_RESOURCES;
         leave;
      }
      sprintf(idString, "Child%02x", Index);
      RtlInitAnsiString(&ansiString, idString);
      status = RtlAnsiStringToUnicodeString(&ChildInfo->Name,
                                            &ansiString,
                                            TRUE);
      ExFreePool(idString);
      if (!NT_SUCCESS(status)) {
         leave;
      }

      //
      // Get compatible ids
      //
      status = PcmciaGetCompatibleIds(PdoExtension->DeviceObject,
                                      Index,
                                      &ChildInfo->CompatibleID);
      if (!NT_SUCCESS(status)) {
         leave;
      }

      //
      // Get hardware ids
      //
      status = PcmciaGetHardwareIds(PdoExtension->DeviceObject,
                                    Index,
                                    &ChildInfo->HardwareID);
      if (!NT_SUCCESS(status)) {
         leave;
      }

      //
      // Fill in the resource map stuff
      //
      // Locate the socket data structure corresponding to this function
      for (socketData = PdoExtension->SocketData, i=0; (socketData != NULL) && (i != Index); socketData=socketData->Next, i++);

      if (!socketData) {
         //
         // this condition should never be encountered
         //
         ASSERT (FALSE);
         status = STATUS_NO_MORE_ENTRIES;
         leave;
      }

      if (!(socketData->NumberOfConfigEntries > 0)) {
         //
         // No resource map required
         //
         status = STATUS_SUCCESS;
         leave;
      }

      count = (socketData->MfNeedsIrq ? 1 : 0) + socketData->MfIoPortCount + socketData->MfMemoryCount;
      if (count == 0) {
         ASSERT(FALSE);
         //
         // No resource map required
         //
         status = STATUS_SUCCESS;
         leave;
      }

      //
      // Allocate resource map
      //
      ChildInfo->ResourceMap = ExAllocatePool(PagedPool,
                                              sizeof(MF_RESOURCE_MAP) + (count-1) * sizeof(UCHAR));
      if (!ChildInfo->ResourceMap) {
         status = STATUS_INSUFFICIENT_RESOURCES;
         leave;
      }

      ChildInfo->ResourceMap->Count = count;
      //
      // Compute the resource map indices
      // The config entry *already* contains fields (MfIrqResourceMapIndex, MfIoPortResourceMapIndex etc.)
      // which indicate the relative index of the resource requested for this function within the resource type.
      // We calculate the absolute index by adding up the number of instances of each resource type requested,
      // preceding the current resource type, to this relative index.
      //
      currentIndex = 0;
      //
      // Fill the irq map if there's one
      //
      if (socketData->MfNeedsIrq) {
         ChildInfo->ResourceMap->Resources[currentIndex++] = socketData->MfIrqResourceMapIndex;
      }
      //
      // Fill the i/o port map if there's one
      //
      if (socketData->MfIoPortCount) {
         for (iRes=0; iRes<socketData->MfIoPortCount; iRes++) {
         
            ChildInfo->ResourceMap->Resources[currentIndex++] = socketData->MfIoPortResourceMapIndex + iRes;
            
         }            
      }
      //
      // Fill the memory request map if there's one
      //
      if (socketData->MfMemoryCount) {
         for (iRes=0; iRes<socketData->MfMemoryCount; iRes++) {
         
            ChildInfo->ResourceMap->Resources[currentIndex++] = socketData->MfMemoryResourceMapIndex + iRes;
            
         }            
      }

      status = STATUS_SUCCESS;

   } finally {
      if (!NT_SUCCESS(status)) {
         //
         // Free up all the allocated buffers
         //
         if (ChildInfo->Name.Buffer) {
            ExFreePool(ChildInfo->Name.Buffer);
         }

         if (ChildInfo->CompatibleID.Buffer) {
            ExFreePool(ChildInfo->CompatibleID.Buffer);
         }

         if (ChildInfo->HardwareID.Buffer) {
            ExFreePool(ChildInfo->HardwareID.Buffer);
         }

         if (ChildInfo->ResourceMap) {
            ExFreePool(ChildInfo->ResourceMap);
         }

         if (ChildInfo->VaryingResourceMap) {
            ExFreePool(ChildInfo->ResourceMap);
         }
      }
   }

   return status;
}



NTSTATUS
PcmciaGetInterface(
   IN PDEVICE_OBJECT DeviceObject,
   IN CONST GUID *pGuid,
   IN USHORT sizeofInterface,
   OUT PINTERFACE pInterface
   )
/*

Routine Description

   Gets the interface exported by PCI for enumerating 32-bit cardbus cards, which
   appear as regular PCI devices. This interface will be used to respond during
   subsequent enumeration requests from PnP to invoke PCI to enumerate the cards.

Arguments

   Pdo - Pointer to physical device object for the cardbus controller
   PciCardBusInterface -  Pointer to the PCI-Cardbus interface  will be returned
                          in this variable

Return Value

   Status

*/

{
   KEVENT event;
   PIRP   irp;
   NTSTATUS status;
   IO_STATUS_BLOCK statusBlock;
   PIO_STACK_LOCATION irpSp;

   PAGED_CODE();
   
   KeInitializeEvent (&event, NotificationEvent, FALSE);
   irp = IoBuildSynchronousFsdRequest( IRP_MJ_PNP,
                                       DeviceObject,
                                       NULL,
                                       0,
                                       0,
                                       &event,
                                       &statusBlock
                                     );

   irp->IoStatus.Status = STATUS_NOT_SUPPORTED ;
   irp->IoStatus.Information = 0;

   irpSp = IoGetNextIrpStackLocation(irp);

   irpSp->MinorFunction = IRP_MN_QUERY_INTERFACE;

   irpSp->Parameters.QueryInterface.InterfaceType= pGuid;
   irpSp->Parameters.QueryInterface.Size = sizeofInterface;
   irpSp->Parameters.QueryInterface.Version = 1;
   irpSp->Parameters.QueryInterface.Interface = pInterface;

   status = IoCallDriver(DeviceObject, irp);

   if (status == STATUS_PENDING) {
      KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
      status = statusBlock.Status;
   }

   if (!NT_SUCCESS(status)) {
      DebugPrint((PCMCIA_DEBUG_INFO, "GetInterface failed with status %x\n", status));
   }      
   return status;
}


NTSTATUS
PcmciaUpdateInterruptLine(
   IN PPDO_EXTENSION PdoExtension,
   IN PFDO_EXTENSION FdoExtension
   )
/*

Routine Description

   This routine uses the PCI Irq Routing interface to update the raw interrupt
   line of a cardbus card. This is done in order to allow cardbus cards to run
   on non-acpi machines without pci irq routing, as long as the bios supplies
   the interrupt for the cardbus controller.

Arguments

   PdoExtension - Pointer to the extension for the cardbus card
   FdoExtension - Pointer to the extension for the cardbus controller

Return Value

   Status

*/

{

   PAGED_CODE();

   if (!IsDeviceFlagSet(FdoExtension, PCMCIA_INT_ROUTE_INTERFACE)) {
      return STATUS_UNSUCCESSFUL;
   }

   if (FdoExtension->Configuration.Interrupt.u.Interrupt.Vector == 0) {
      return STATUS_UNSUCCESSFUL;
   }

   (FdoExtension->PciIntRouteInterface.UpdateInterruptLine)(PdoExtension->PciPdo,
                                                           (UCHAR) FdoExtension->Configuration.Interrupt.u.Interrupt.Vector);
   return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\pcmcibus\ioctl.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    ioctl.c

Abstract:

    This module handles device ioctl's to the pcmcia driver.

Authors:

    Ravisankar Pudipeddi (ravisp) Oct 15 1996
    Neil Sandlin (neilsa) 1-Jun-1999    

Environment:

    Kernel mode

Revision History :


--*/

#include "pch.h"



NTSTATUS
PcmciaDeviceControl(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   )

/*++

Routine Description:

    IOCTL device routine

Arguments:

    DeviceObject - Pointer to the device object.
    Irp - Pointer to the IRP

Return Value:

    Status

--*/

{
   PFDO_EXTENSION      deviceExtension = DeviceObject->DeviceExtension;
   PDEVICE_OBJECT      pdo;
   PPDO_EXTENSION      pdoExtension;
   PIO_STACK_LOCATION  currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
   NTSTATUS            status = STATUS_SUCCESS;
   ULONG               index;
   PSOCKET             socket;
   USHORT              socketNum;
   PUCHAR              buffer;
   ULONG               bufferSize;


   DebugPrint((PCMCIA_DEBUG_IOCTL, "PcmciaDeviceControl: Entered\n"));

   //
   // Every request requires an input buffer.
   //

   if (!Irp->AssociatedIrp.SystemBuffer ||
       (currentIrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(TUPLE_REQUEST))) {
      Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
      return STATUS_INVALID_PARAMETER;
   }

   socketNum = ((PTUPLE_REQUEST)Irp->AssociatedIrp.SystemBuffer)->Socket;

   //
   // Find the socket pointer for the requested offset.
   //

   socket = deviceExtension->SocketList;
   index = 0;
   while (socket) {
      if (index == socketNum) {
         break;
      }
      socket = socket->NextSocket;
      index++;
   }

   if (socket == NULL) {
      status = STATUS_INVALID_PARAMETER;
      Irp->IoStatus.Status = status;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
      return status;
   }

   pdo = socket->PdoList;

   if (pdo == NULL) {
      status = STATUS_UNSUCCESSFUL;
      Irp->IoStatus.Status = status;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
      return status;
   }

   pdoExtension = pdo->DeviceExtension;

   switch (currentIrpStack->Parameters.DeviceIoControl.IoControlCode) {

   case IOCTL_GET_TUPLE_DATA: {

         DebugPrint((PCMCIA_DEBUG_IOCTL, "Get Tuple Data\n"));

         try {
            ULONG bufLen = currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength;
            //
            // Zero the target buffer
            //
            RtlZeroMemory(Irp->AssociatedIrp.SystemBuffer, bufLen);

            Irp->IoStatus.Information = (*(socket->SocketFnPtr->PCBReadCardMemory))(pdoExtension,
                                                                                       PCCARD_ATTRIBUTE_MEMORY,
                                                                                       0,
                                                                                       Irp->AssociatedIrp.SystemBuffer,
                                                                                       bufLen);
            
         }except(EXCEPTION_EXECUTE_HANDLER)  {
            status = GetExceptionCode();
         }
         break;
      }

   case IOCTL_SOCKET_INFORMATION: {
         PPCMCIA_SOCKET_INFORMATION infoRequest;

         DebugPrint((PCMCIA_DEBUG_IOCTL, "socket info\n"));
         
         infoRequest = (PPCMCIA_SOCKET_INFORMATION)Irp->AssociatedIrp.SystemBuffer;
         if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength < sizeof(PCMCIA_SOCKET_INFORMATION)) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
         }

         //
         // Insure caller data is zero - maintain value for socket.
         //

         index = (ULONG) infoRequest->Socket;
         RtlZeroMemory(infoRequest, sizeof(PCMCIA_SOCKET_INFORMATION));
         infoRequest->Socket = (USHORT) index;

         //
         // Only if there is a card in the socket does this proceed.
         //
         PCMCIA_ACQUIRE_DEVICE_LOCK(socket->DeviceExtension);

         infoRequest->CardInSocket =
         (*(socket->SocketFnPtr->PCBDetectCardInSocket))(socket);
         infoRequest->CardEnabled = (UCHAR) IsSocketFlagSet(pdoExtension->Socket, SOCKET_CARD_CONFIGURED);

         PCMCIA_RELEASE_DEVICE_LOCK(socket->DeviceExtension);

         if (infoRequest->CardInSocket) {
            PSOCKET_DATA socketData = pdoExtension->SocketData;

            //
            // For now returned the cached data.
            //

            if (socketData) {
               RtlMoveMemory(&infoRequest->Manufacturer[0], &socketData->Mfg[0], MANUFACTURER_NAME_LENGTH);
               RtlMoveMemory(&infoRequest->Identifier[0], &socketData->Ident[0], DEVICE_IDENTIFIER_LENGTH);
               infoRequest->TupleCrc = socketData->CisCrc;
               infoRequest->DeviceFunctionId = socketData->DeviceType;
            }

         }

         infoRequest->ControllerType = deviceExtension->ControllerType;

         Irp->IoStatus.Information = sizeof(PCMCIA_SOCKET_INFORMATION);
         break;
      }


#if 0
   case IOCTL_PCMCIA_TEST: {
         PPCMCIA_TEST_INFORMATION testRequest;
         PDO_EXTENSION TestPdoExtension = {0};
         UCHAR attributeBuffer[] = {1, 2, 0, 0xff, 3, 0, 0xff, 0xff};
         UCHAR indirectBuffer[] = {0x13, 3, 0x43, 0x49, 0x53, 0x15, 0x2d, 5};
         ULONG index;

         DebugPrint((PCMCIA_DEBUG_IOCTL, "driver test\n"));
         
         //
         // TEST CODE 
         // Check the CIS of the Margi DVD-to-go card
         // This card has the CIS in attribute indirect memory, and was having problems
         // on ToPIC controllers.
         //
         
         testRequest = (PPCMCIA_TEST_INFORMATION)Irp->AssociatedIrp.SystemBuffer;
         if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength < sizeof(PCMCIA_TEST_INFORMATION)) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
         }

         //
         // Insure caller data is zero - maintain value for socket.
         //

         index = (ULONG) testRequest->Socket;
         RtlZeroMemory(testRequest, sizeof(PCMCIA_TEST_INFORMATION));
         testRequest->Socket = (USHORT) index;


         if (!(*(socket->SocketFnPtr->PCBDetectCardInSocket))(socket)) {
            DebugPrint((PCMCIA_DEBUG_FAIL, "driver test: abort because no card\n"));
            status = STATUS_NOT_FOUND;
            break;
         }
         
         if (IsDeviceStarted(pdoExtension)) {
            DebugPrint((PCMCIA_DEBUG_FAIL, "driver test: abort because the pdo is started\n"));
            status = STATUS_INVALID_DEVICE_STATE;
            break;
         }

         if (IsSocketFlagSet(socket, SOCKET_CARD_POWERED_UP)) {
            PcmciaSetSocketPower(socket, NULL, NULL, PCMCIA_POWEROFF);
         }
         
         status = PcmciaSetSocketPower(socket, NULL, NULL, PCMCIA_POWERON);
         if (!NT_SUCCESS(status)) {
            DebugPrint((PCMCIA_DEBUG_FAIL, "driver test: abort because powerup failed\n"));
            break;
         }

         TestPdoExtension.Socket = socket;         
         
         //
         // Read in attribute memory
         //
         
         for (index = 0; index <= 7; index++) {
            if (attributeBuffer[index] != PcmciaReadCISChar(&TestPdoExtension, PCCARD_ATTRIBUTE_MEMORY, index)) {
               status = STATUS_UNSUCCESSFUL;
               DebugPrint((PCMCIA_DEBUG_FAIL, "driver test: abort because attribute memory test failed\n"));
               break;
            }
         }                  
         
         if (!NT_SUCCESS(status)) {
            break;
         }
         
         //
         // Try Common memory
         //
                  
         if (0xff != PcmciaReadCISChar(&TestPdoExtension, PCCARD_COMMON_MEMORY, 0)) {
            status = STATUS_UNSUCCESSFUL;
            DebugPrint((PCMCIA_DEBUG_FAIL, "driver test: abort because attribute memory test failed\n"));
            break;
         }
         
         //
         // Read in attribute memory indirect
         //
         
         for (index = 0; index <= 7; index++) {
            if (indirectBuffer[index] != PcmciaReadCISChar(&TestPdoExtension, PCCARD_ATTRIBUTE_MEMORY_INDIRECT, index)) {
               status = STATUS_UNSUCCESSFUL;
               DebugPrint((PCMCIA_DEBUG_FAIL, "driver test: abort because attribute memory indirect test failed\n"));
               break;
            }
         }                  
         
         if (!NT_SUCCESS(status)) {
            break;
         }
         
         PcmciaSetSocketPower(socket, NULL, NULL, PCMCIA_POWEROFF);


         testRequest->TestData = 0x123;
         Irp->IoStatus.Information = sizeof(PCMCIA_TEST_INFORMATION);
         break;
      }
#endif      

   default: {
         status = STATUS_INVALID_PARAMETER;
         break;
      }
   }
   Irp->IoStatus.Status = status;
   IoCompleteRequest(Irp, IO_NO_INCREMENT);
   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\pcmcibus\pch.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    PCH.H

Abstract:

    This module includes all  the headers which need
    to be precompiled & are included by all the source
    files in the PCMCIA project.

Author(s):

    Ravisankar Pudipeddi (ravisp) 1-Dec-1997

Environment:

    Kernel mode only

Notes:

Revision History:

--*/

#ifndef _PCMCIA_PCH_H_
#define _PCMCIA_PCH_H_

#include "ntosp.h"
#include <zwapi.h>
#include <initguid.h>
#include "mf.h"
#include "ntddpcm.h"
#include "pciintrf.h"
#include "wdmguid.h"
#include <stdarg.h>
#include <stdio.h>
#include "data.h"
#include "tuple.h"
#include "string.h"
#include "pcmcia.h"
#include "card.h"
#include "extern.h"
#include "pcicfg.h"
#include "exca.h"
#include "cb.h"
#include "tcic2.h"
#include "dbsocket.h"
#include "tcicext.h"
#include "pcmciamc.h"
#include "debug.h"

#endif  // _PCMCIA_PCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\pcmcibus\pcmcia.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    pcmcia.c

Abstract:

    This module contains the code that controls the PCMCIA slots.

Author:

    Bob Rinne (BobRi) 3-Aug-1994
    Jeff McLeman 12-Apr-1994
    Ravisankar Pudipeddi (ravisp) 1-Nov-96
    Neil Sandlin (neilsa) 1-Jun-1999

Environment:

    Kernel mode

Revision History :
    6-Apr-95
        Modified for databook support - John Keys Databook
    1-Nov-96
        Total overhaul to make this a bus enumerator - Ravisankar Pudipeddi (ravisp)


--*/

#include "pch.h"

//
// Internal References
//

NTSTATUS
DriverEntry(
   IN PDRIVER_OBJECT DriverObject,
   IN PUNICODE_STRING RegistryPath
   );

VOID
PcmciaUnload(
   IN PDRIVER_OBJECT DriverObject
   );
   
#ifdef ALLOC_PRAGMA
   #pragma alloc_text(INIT,DriverEntry)
   #pragma alloc_text(PAGE, PcmciaUnload)
   #pragma alloc_text(PAGE, PcmciaOpenCloseDispatch)
   #pragma alloc_text(PAGE, PcmciaCleanupDispatch)
   #pragma alloc_text(PAGE, PcmciaFdoSystemControl)
   #pragma alloc_text(PAGE, PcmciaPdoSystemControl)
#endif

PUNICODE_STRING  DriverRegistryPath;



NTSTATUS
DriverEntry(
   IN PDRIVER_OBJECT DriverObject,
   IN PUNICODE_STRING RegistryPath
   )

/*++

Routine Description:

    The entry point that the system point calls to initialize
    any driver.
    Since this is a plug'n'play driver, we should return after setting
    the entry points & initializing our dispatch table.
    Currently we also detect our own PCMCIA controllers and report
    them - which should not be needed in the future when a root bus
    driver such as PCI or ISAPNP will locate the controllers for us.

Arguments:

    DriverObject - Pointer to object representing this driver

    RegistryPath - Pointer the the registry key for this driver
                   under \CurrentControlSet\Services

Return Value:


--*/

{
   NTSTATUS                  status = STATUS_SUCCESS;
   ULONG                     i;

   PAGED_CODE();

   DebugPrint((PCMCIA_DEBUG_INFO,"Initializing Driver\n"));

   //
   // Load in common parameters from the registry
   //
   status = PcmciaLoadGlobalRegistryValues();
   if (!NT_SUCCESS(status)) {
      return status;
   }

   //
   //
   // Set up the device driver entry points.
   //

   DriverObject->DriverExtension->AddDevice = PcmciaAddDevice;

   DriverObject->DriverUnload = PcmciaUnload;
   //
   //
   // Save our registry path
   DriverRegistryPath = RegistryPath;

   //
   // Initialize the event used by the delay execution
   // routine.
   //
   KeInitializeEvent (&PcmciaDelayTimerEvent,
                      NotificationEvent,
                      FALSE);

   //
   // Initialize tone generation objects
   //
   KeInitializeTimer(&PcmciaToneTimer);
   KeInitializeDpc(&PcmciaToneDpc, PcmciaPlayToneCompletion, NULL);                      
   KeInitializeSpinLock(&PcmciaToneLock);
   //
   // Initialize global lock
   //
   KeInitializeSpinLock(&PcmciaGlobalLock);
   
   //
   // Init device dispatch table
   //
   PcmciaInitDeviceDispatchTable(DriverObject);
   
   //
   // Locate PCMCIA controllers and report them - this
   // is temporary - till the detection for these
   // controllers is moved into
   // appropriate root bus driver such as the PCI bus driver..

   //   if (PcmciaLegacyDetectionOk()) {
   status = PcmciaDetectPcmciaControllers(DriverObject,RegistryPath);
   // }

   //
   // Ignore the status. Regardless of whether we found controllers or not
   // we need to stick around since we might get an AddDevice non-legacy
   // controllers
   //
   return STATUS_SUCCESS;
}



NTSTATUS
PcmciaOpenCloseDispatch(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   )

/*++

Routine Description:

    Open or Close device routine

Arguments:

    DeviceObject - Pointer to the device object.
    Irp - Pointer to the IRP

Return Value:

    Status

--*/

{
   NTSTATUS status;

   PAGED_CODE();

   DebugPrint((PCMCIA_DEBUG_INFO, "PCMCIA: Open / close of Pcmcia controller for IO \n"));

   status = STATUS_SUCCESS;

   Irp->IoStatus.Status = STATUS_SUCCESS;
   Irp->IoStatus.Information = 0;
   IoCompleteRequest(Irp, 0);
   return status;
}



NTSTATUS
PcmciaCleanupDispatch(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   )

/*++

Routine Description:

    Handles IRP_MJ_CLEANUP

Arguments:

    DeviceObject - Pointer to the device object.
    Irp - Pointer to the IRP

Return Value:

    Status

--*/

{
   NTSTATUS status;

   PAGED_CODE();

   DebugPrint((PCMCIA_DEBUG_INFO, "PCMCIA: Cleanup of Pcmcia controller for IO \n"));
   status = STATUS_SUCCESS;

   Irp->IoStatus.Status = STATUS_SUCCESS;
   Irp->IoStatus.Information = 0;
   IoCompleteRequest(Irp, 0);
   return status;
}



NTSTATUS
PcmciaFdoSystemControl(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   )

/*++

Routine Description:

    Handles IRP_MJ_SYSTEM_CONTROL

Arguments:

    DeviceObject - Pointer to the device object.
    Irp - Pointer to the IRP

Return Value:

    Status

--*/

{
   PFDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
   
   PAGED_CODE();

   IoSkipCurrentIrpStackLocation(Irp);
   return IoCallDriver(fdoExtension->LowerDevice, Irp);
}



NTSTATUS
PcmciaPdoSystemControl(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   )

/*++

Routine Description:

    Handles IRP_MJ_SYSTEM_CONTROL

Arguments:

    DeviceObject - Pointer to the device object.
    Irp - Pointer to the IRP

Return Value:

    Status

--*/

{
   NTSTATUS status;
   PPDO_EXTENSION pdoExtension = DeviceObject->DeviceExtension;
   
   PAGED_CODE();

   if (IsCardBusCard(pdoExtension)) {
      //
      // Pass irp down the stack for cardbus cards
      //
      IoSkipCurrentIrpStackLocation(Irp);
      status = IoCallDriver(pdoExtension->LowerDevice, Irp);
   } else {
      //
      // Complete the irp for R2 cards
      //
      status = Irp->IoStatus.Status;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
   }
   return status;
}



VOID
PcmciaUnload(
   IN PDRIVER_OBJECT DriverObject
   )

/*++

Description:

    Unloads the driver after cleaning up

Arguments:

    DriverObject -- THe device drivers object

Return Value:

    None

--*/

{
   PDEVICE_OBJECT    fdo, pdo, nextFdo, nextPdo;
   PFDO_EXTENSION    fdoExtension;
   PSOCKET           socket, nextSocket;
   PPCMCIA_NTDETECT_DATA pData, pNextData;

   PAGED_CODE();

   DebugPrint((PCMCIA_DEBUG_INFO, "PcmciaUnload Entered\n"));
   
   pData = pNtDetectDataList;
   while(pData != NULL) {
      pNextData = pData->Next;
      ExFreePool(pData);
      pData = pNextData;
   }   
   
   for (fdo = FdoList; fdo !=NULL ; fdo = nextFdo) {

      fdoExtension = fdo->DeviceExtension;
      MarkDeviceDeleted(fdoExtension);      
      
      if (fdoExtension->PcmciaInterruptObject) {
         IoDisconnectInterrupt(fdoExtension->PcmciaInterruptObject);
      }
      //
      // Cleanup socket structures
      //
      for (socket=fdoExtension->SocketList; socket !=NULL; socket=nextSocket) {
         nextSocket = socket->NextSocket;
         ExFreePool(socket);
      }

      //
      // Remove symbolic links
      //
      if (fdoExtension->LinkName.Buffer != NULL) {
         IoDeleteSymbolicLink(&fdoExtension->LinkName);
         RtlFreeUnicodeString(&fdoExtension->LinkName);
      }
      //
      // Clean up all the PDOs
      //
      for (pdo=fdoExtension->PdoList; pdo != NULL; pdo=nextPdo) {
         nextPdo = ((PPDO_EXTENSION) pdo->DeviceExtension)->NextPdoInFdoChain;
         MarkDeviceDeleted((PPDO_EXTENSION)pdo->DeviceExtension);
         PcmciaCleanupPdo(pdo);
         IoDeleteDevice(pdo);
      }

      if (fdoExtension->Flags & PCMCIA_USE_POLLED_CSC) {
            //
            // Cancel the poll timer
            //
            KeCancelTimer(&fdoExtension->PollTimer);
      }

      IoDetachDevice(fdoExtension->LowerDevice);
      nextFdo = fdoExtension->NextFdo;
      IoDeleteDevice(fdo);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\pcmcibus\opti.c ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    opti.c

Abstract:

    This module contains the code that contains
    OPTi controller(s) specific initialization and
    other dispatches

Author:

    Ravisankar Pudipeddi (ravisp) 1-Nov-97


Environment:

    Kernel mode

Revision History :

    Neil Sandlin (neilsa) 3-Mar-99
      new setpower routine interface

--*/

#include "pch.h"


VOID
OptiInitialize(
   IN PFDO_EXTENSION FdoExtension
   )
/*++

Routine Description:

    Initialize OPTI cardbus controllers

Arguments:

    FdoExtension - Pointer to the device extension for the controller FDO

Return Value:

    None
--*/

{
   if (FdoExtension->ControllerType == PcmciaOpti82C814) {
      UCHAR byte;

      //
      // This fix per Opti for USB/1394 Combo hang
      //    5Eh[7] - enables the deadlock prevention mechanism
      //    5Fh[1] - reduces the retry count delay to 8 - note that 5Fh is a
      //       WRITE-ONLY  register and always reads 0. All other bits 
      //       of this register can safely be written to 0.
      //    5Eh[5] - enables write posting on upstream transfers
      //    5Eh[4] - sets the chip input buffer scaling (not related to deadlock)

      GetPciConfigSpace(FdoExtension, 0x5e, &byte, 1);
      byte |= 0xB0;
      SetPciConfigSpace(FdoExtension, 0x5e, &byte, 1);
      byte = 2;
      SetPciConfigSpace(FdoExtension, 0x5f, &byte, 1);
   }
}


NTSTATUS
OptiSetPower(
   IN PSOCKET SocketPtr,
   IN BOOLEAN Enable,
   OUT PULONG pDelayTime
   )
/*++

Routine Description:

    Set power to the specified socket.

Arguments:

    SocketPtr - the socket to set
    Enable - TRUE means to set power - FALSE is to turn it off.
    pDelayTime - specifies delay (msec) to occur after the current phase

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED - increment phase, perform delay, recall
    other status values terminate sequence

--*/

{
   NTSTATUS status;
   UCHAR             oldPower, newPower;

   if (IsCardBusCardInSocket(SocketPtr)) {
      //
      // Hand over to generic power setting routine
      //
      return(CBSetPower(SocketPtr, Enable, pDelayTime));

   }
   
   switch(SocketPtr->PowerPhase) {
   case 1:   
      //
      // R2 card - special handling
      //
      oldPower = PcicReadSocket(SocketPtr, PCIC_PWR_RST);
      //
      // Set new vcc
      // VCC always set to 5V if power is to be enabled..
      //
      newPower = (Enable ? PC_VCC_OPTI_050V : PC_VCC_OPTI_NO_CONNECT);
      //
      // Set vpp
      //
      if (Enable) {
          //
          // We - as always - set vpp to vcc..
          //
          newPower |= PC_VPP_OPTI_SETTO_VCC;
      } else {
         newPower |= PC_VPP_OPTI_NO_CONNECT;
      }
     
      newPower |= (oldPower & PC_OUTPUT_ENABLE);
      //
      // If Vcc is turned off, reset OUTPUT_ENABLE & AUTOPWR_ENABLE
      //
      if (!(newPower & PC_VCC_OPTI_MASK)) {
         newPower &= ~PC_OUTPUT_ENABLE;
      }
     
      status = STATUS_SUCCESS;
      if (newPower != oldPower) {
         PcicWriteSocket(SocketPtr, PCIC_PWR_RST, newPower);
         //
         // Allow ramp up.. (actually we don't need to this if
         // Enable was FALSE).  Keep it for paranoia's sake
         //
         *pDelayTime = PcicStallPower;
         SocketPtr->PowerData = (ULONG) newPower;
         status = STATUS_MORE_PROCESSING_REQUIRED;
      }
      break;

   case 2:

      newPower = (UCHAR) SocketPtr->PowerData;                     

      if ((newPower & PC_VCC_OPTI_MASK)  && !(newPower & PC_OUTPUT_ENABLE)){
         //
         // More paranoia?
         //
         newPower |= PC_OUTPUT_ENABLE;
         PcicWriteSocket(SocketPtr, PCIC_PWR_RST, newPower);
      }
      status = STATUS_SUCCESS;
      break;

   default:
      ASSERT(FALSE);
      status = STATUS_UNSUCCESSFUL;                  
   }
   return status;   
}


BOOLEAN
OptiSetZV(
   IN PSOCKET Socket,
   IN BOOLEAN Enable
   )
{
   UCHAR bData;

   if (Enable) {

      bData = PcicReadSocket(Socket, PCIC_OPTI_GLOBAL_CTRL);                   
      bData |= OPTI_ZV_ENABLE;
      PcicWriteSocket(Socket, PCIC_OPTI_GLOBAL_CTRL, bData);            

   } else {

      bData = PcicReadSocket(Socket, PCIC_OPTI_GLOBAL_CTRL);                   
      bData &= ~OPTI_ZV_ENABLE;
      PcicWriteSocket(Socket, PCIC_OPTI_GLOBAL_CTRL, bData);            

   }
   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\pcmcibus\pcicsup.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    pcicsup.c

Abstract:

    This module supplies functions that control the 82365SL chip. In turn,
    these functions are abstracted out to the main PCMCIA support module.

Author(s):

    Bob Rinne (BobRi)   3-Aug-1994
    Jeff McLeman (mcleman@zso.dec.com)
    Neil Sandlin (neilsa) June 1 1999

Revisions:
    6-Apr-95
        Modified for databook support changes - John Keys Databook
    1-Nov-96
        Complete overhaul for plug'n'play support,
        flash interfaces, power support etc.

            - Ravisankar Pudipeddi (ravisp)
--*/

#include "pch.h"

#ifdef POOL_TAGGING
   #undef ExAllocatePool
   #define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'cicP')
#endif

//
// Internal References
//

NTSTATUS
PcicResetCard(
   IN PSOCKET Socket,
   OUT PULONG pDelayTime
   );

BOOLEAN
PcicInitializePcmciaSocket(
   IN PSOCKET Socket
   );

UCHAR
PcicReadController(
   IN PUCHAR Base,
   IN USHORT Socket,
   IN UCHAR  PcicRegister
   );

VOID
PcicWriteController(
   IN PUCHAR Base,
   IN USHORT Socket,
   IN UCHAR  PcicRegister,
   IN UCHAR  DataByte
   );

NTSTATUS
PcicDetect(
   IN PFDO_EXTENSION DeviceExtension,
   IN INTERFACE_TYPE InterfaceType,
   IN ULONG          IoPortBase
   );

BOOLEAN
PcicDetectCardInSocket(
   IN PSOCKET Socket
   );

BOOLEAN
PcicDetectCardChanged(
   IN PSOCKET Socket
   );

BOOLEAN
PcicPCCardReady(
   IN PSOCKET Socket
   );

BOOLEAN
PcicDetectReadyChanged(
   IN PSOCKET Socket
   );
   
BOOLEAN
PcicProcessConfigureRequest(
   IN PSOCKET Socket,
   IN PCARD_REQUEST ConfigRequest,
   IN PUCHAR  Base
   );

VOID
PcicEnableDisableWakeupEvent(
   IN PSOCKET Socket,
   IN PPDO_EXTENSION PdoExtension,   
   IN BOOLEAN Enable
   );

VOID
PcicEnableDisableMemory(
   IN PSOCKET Socket,
   IN MEMORY_SPACE MemorySpace,
   IN ULONG   CardBase,
   IN UCHAR   Mem16BitWindow,
   IN BOOLEAN Enable
   );

BOOLEAN
PcicEnableDisableCardDetectEvent(
   IN PSOCKET Socket,
   IN BOOLEAN Enable
   );

UCHAR
PcicReadExtendedCirrusController(
   IN PUCHAR Base,
   IN USHORT Socket,
   IN UCHAR  Register
   );

VOID
PcicWriteExtendedCirrusController(
   IN PUCHAR Base,
   IN USHORT Socket,
   IN UCHAR  PcicRegister,
   IN UCHAR  DataByte
   );

ULONG
PcicWriteCardMemory(
   IN PPDO_EXTENSION PdoExtension,
   IN  MEMORY_SPACE MemorySpace,
   IN  ULONG  Offset,
   IN  PUCHAR Buffer,
   IN  ULONG  Length
   );
   
ULONG
PcicReadCardMemory(
   IN PPDO_EXTENSION PdoExtension,
   IN MEMORY_SPACE MemorySpace,
   IN ULONG   Offset,
   IN PUCHAR Buffer,
   IN ULONG  Length
   );
   
BOOLEAN
PcicModifyMemoryWindow(
   IN PDEVICE_OBJECT Pdo,
   IN ULONGLONG HostBase,
   IN ULONGLONG CardBase,
   IN BOOLEAN   Enable,
   IN ULONG     WindowSize  OPTIONAL,
   IN UCHAR     AccessSpeed OPTIONAL,
   IN UCHAR     BusWidth    OPTIONAL,
   IN BOOLEAN   IsAttributeMemory OPTIONAL
   );

BOOLEAN
PcicSetVpp(
   IN PDEVICE_OBJECT Pdo,
   IN UCHAR          VppLevel
   );

BOOLEAN
PcicIsWriteProtected(
   IN PDEVICE_OBJECT Pdo
   );

ULONG
PcicGetIrqMask(
   IN PFDO_EXTENSION deviceExtension
   );

NTSTATUS
PcicConvertSpeedToWait(
   IN  UCHAR Speed,
   OUT PUCHAR WaitIndex
   );

//
// Internal Data
//

ULONG  PcicStallCounter = 4000;     //4ms

UCHAR WaitToSpeedTable[4] = {
   0x42,   //350ns
   0x52,   //450ns
   0x62,   //600ns
   0x72    //700ns
};

UCHAR DevSpeedTable[8] = {
   0xff,   // speed 0: invalid
   0x32,   // speed 1: 250ns
   0x2a,   // speed 2: 200ns
   0x22,   // speed 3: 150ns
   0x0a,   // speed 4: 100ns
   0xff,   // speed 5: reserved
   0xff,   // speed 6: reserved
   0xff    // speed 7: invalid
};

PCMCIA_CTRL_BLOCK PcicSupportFns = {
   PcicInitializePcmciaSocket,
   PcicResetCard,
   PcicDetectCardInSocket,
   PcicDetectCardChanged,
   NULL,                                     // PcicDetectCardStatus
   PcicDetectReadyChanged,
   NULL,                                     // GetPowerRequirements
   PcicProcessConfigureRequest,
   PcicEnableDisableCardDetectEvent,
   PcicEnableDisableWakeupEvent,
   PcicGetIrqMask,
   PcicReadCardMemory,
   PcicWriteCardMemory,
   PcicModifyMemoryWindow,
   PcicSetVpp,
   PcicIsWriteProtected
};

#define MEM_16BIT 1
#define MEM_8BIT  0

#ifdef ALLOC_PRAGMA
   #pragma alloc_text(INIT,PcicIsaDetect)
   #pragma alloc_text(INIT,PcicDetect)
   #pragma alloc_text(PAGE,PcicBuildSocketList)
#endif


ULONG
PcicGetIrqMask(
   IN PFDO_EXTENSION DeviceExtension
   )
/*++

Routine Description:

Arguments:

Return value:

--*/
{
   //
   // Return the set of supported IRQs for the controller
   // and PcCards
   //
   if (CLPD6729(DeviceExtension->SocketList)) {
      return CL_SUPPORTED_INTERRUPTS;
   } else {
      return PCIC_SUPPORTED_INTERRUPTS;
   }
}



BOOLEAN
PcicEnableDisableCardDetectEvent(
   IN PSOCKET Socket,
   IN BOOLEAN Enable
   )

/*++

Routine Description:

    Enable card detect interrupt.

Arguments:

    Socket - socket information
    Irq - the interrupt value to set.
    Enable - if  TRUE, CSC interrupt is enabled,
             if FALSE, it is disabled
Return Value:

    None

--*/

{
   PFDO_EXTENSION deviceExtension = Socket->DeviceExtension;
   INTERFACE_TYPE interface;
   UCHAR byte;
   ULONG Irq = Socket->FdoIrq;

   switch (Enable) {

   case TRUE: {
            if (CLPD6729(Socket)) {
               //
               // For Cirrus Logic PCI controller we need to know the interrupt pin
               // (INTA, INTB etc.) corresponding to the level passed in. Hence the
               // passed in Irq is discarded. Actually the Irq parameter is redundant
               // since it can be fetched from the device extension itself.
               // If we remove the Irq param from this routine, the following is
               // not so inelegant..
               //
               interface = PCIBus;
               switch (deviceExtension->Configuration.InterruptPin) {
               case 0: {
                     //
                     // This is what tells us that ISA interrupts are being used...
                     //
                     interface = Isa;
                     break;
                  }
               case 1: {
                     Irq = PCIC_CIRRUS_INTA;
                     break;
                  }
               case 2: {
                     Irq = PCIC_CIRRUS_INTB;
                     break;
                  }
               case 3: {
                     Irq = PCIC_CIRRUS_INTC;
                     break;
                  }
               case 4: {
                     Irq = PCIC_CIRRUS_INTD;
                     break;
                  }
               }
               //
               // Set the Cirrus Logic controller for PCI style interrupts
               //
               byte = PcicReadExtendedCirrusController(Socket->AddressPort,
                                                       Socket->RegisterOffset,
                                                       PCIC_CIRRUS_EXTENSION_CTRL_1);
               if (interface == PCIBus) {
                  byte |= 0x10;  // PCI style interrupt
               } else {
                  byte &= ~0x10; // Isa style interrupt
               }
               PcicWriteExtendedCirrusController(Socket->AddressPort,
                                                 Socket->RegisterOffset,
                                                 PCIC_CIRRUS_EXTENSION_CTRL_1,
                                                 byte);
               PcmciaWait(100);
            }

            byte=PcicReadSocket(Socket, PCIC_CARD_INT_CONFIG);

            byte = byte & CSCFG_BATT_MASK;   // Don't nuke any other enables
            byte = byte | (UCHAR) ((Irq << 4) & 0x00ff); // Put IRQ in upper nibble
            byte |= CSCFG_CD_ENABLE;

            PcicWriteSocket(Socket, PCIC_CARD_INT_CONFIG, byte);
            break;
         }
         
   case FALSE: {
            //
            // Clear pending interrupt (for now)
            //
            byte = PcicReadSocket(Socket, PCIC_CARD_CHANGE);
            DebugPrint((PCMCIA_DEBUG_INFO, "PcicDisableInterrupt:Status Change %x\n", byte));
            PcicWriteSocket(Socket,
                            PCIC_CARD_INT_CONFIG,
                            0x0);
            break;
         }
   }
   
   return TRUE;
}



NTSTATUS
PcicSetPower(
   IN PSOCKET Socket,
   IN BOOLEAN Enable,
   OUT PULONG pDelayTime
   )

/*++

Routine Description:

    Set power to the specified socket.

Arguments:

    Socket - the socket to set
    Enable - TRUE means to set power - FALSE is to turn it off.
    pDelayTime - specifies delay (msec) to occur after the current phase

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED - increment phase, perform delay, recall
    other status values terminate sequence

--*/

{
   NTSTATUS status;
   UCHAR             tmp, vcc;

   //
   // Turn on the power - then turn on output - this is two operations
   // per the Intel 82365SL documentation.
   //

   if (Enable) {
      switch(Socket->PowerPhase) {
      case 1:

         tmp = PcicReadSocket(Socket, PCIC_PWR_RST);
         //
         // 5V for R2 cards..
         //
         vcc = PC_CARDPWR_ENABLE;

         if (Elc(Socket)) {
            tmp = PC_VPP_SETTO_VCC | vcc; // vpp1 = vcc
         } else {
            //
            // Apparently we need to set bit 2 also for some obscure reason
            //
            tmp = 0x4 | PC_VPP_SETTO_VCC | vcc; // vpp1 = vpp2 = vcc
         }

         PcicWriteSocket(Socket, PCIC_PWR_RST, tmp);

         //
         // OUTPUT_ENABLE & AUTOPWR_ENABLE..
         // Disable RESETDRV also..
         //
         tmp |= PC_OUTPUT_ENABLE | PC_AUTOPWR_ENABLE | PC_RESETDRV_DISABLE;

         PcicWriteSocket(Socket, PCIC_PWR_RST, tmp);
         //
         // When power is enabled always stall to give the PCCARD
         // a chance to react.
         //
         *pDelayTime = PcicStallPower;
         status = STATUS_MORE_PROCESSING_REQUIRED;
         break;

      case 2:
         //
         // Check for an as yet unexplained condition on Dell Latitude XPi's
         //
         tmp = PcicReadSocket(Socket, PCIC_STATUS);
         if (!(tmp & 0x40)) {
            //
            // power hasn't come on, flip the mystery bit
            //
            tmp = PcicReadSocket(Socket, 0x2f);
            if (tmp == 0x42) {
               PcicWriteSocket(Socket, 0x2f, 0x40);
               *pDelayTime = PcicStallPower;
            }
         }
         status = STATUS_SUCCESS;
         break;

      default:
         ASSERT(FALSE);
         status = STATUS_UNSUCCESSFUL;
      }

   } else {
      PcicWriteSocket(Socket, PCIC_PWR_RST,  0x00);
      status = STATUS_SUCCESS;
   }
   return status;
}


NTSTATUS
PcicConvertSpeedToWait(
   IN  UCHAR Speed,
   OUT PUCHAR WaitIndex
   )
{
   NTSTATUS status = STATUS_INVALID_PARAMETER;
   UCHAR exponent, exponent2, mantissa, index;


   if (Speed & SPEED_EXT_MASK) {
      return status;
   }

   exponent = Speed & SPEED_EXPONENT_MASK;
   mantissa = Speed & SPEED_MANTISSA_MASK;

   if (mantissa == 0) {
      mantissa = DevSpeedTable[exponent] & SPEED_MANTISSA_MASK;
      exponent = DevSpeedTable[exponent] & SPEED_EXPONENT_MASK;
   }
   for (index = 0; index < sizeof(WaitToSpeedTable); index++) {
      exponent2= WaitToSpeedTable[index] & SPEED_EXPONENT_MASK;
      if ((exponent < exponent2) ||
          ((exponent == exponent2) &&
           (mantissa < (WaitToSpeedTable[index] & SPEED_MANTISSA_MASK)))) {
         *WaitIndex = index;
         status = STATUS_SUCCESS;
         break;
      }
   }
   return status;
}


BOOLEAN
PcicSetVpp(
   IN PDEVICE_OBJECT Pdo,
   IN UCHAR Vpp
   )
/*++

Routine Description

  Part of the interfaces originally developed to
  support flash memory cards.
  Sets VPP1 to the required setting

Arguments

  Pdo - Pointer to device object  for the PC-Card
  Vpp - Desired Vpp setting. This is currently one of
        PCMCIA_VPP_12V    (12 volts)
        PCMCIA_VPP_0V     (disable VPP)
        PCMCIA_VPP_IS_VCC (route VCC to VPP)

Return

   TRUE - if successful
   FALSE - if not. This will be returned if the
           PC-Card is not already powered up
--*/
{

   PSOCKET socketPtr = ((PPDO_EXTENSION) Pdo->DeviceExtension)->Socket;
   UCHAR tmp;

   ASSERT ( socketPtr != NULL );
   tmp = PcicReadSocket(socketPtr, PCIC_PWR_RST);

   if ((tmp & 0x10) == 0) {
      //
      // Vcc not set.
      //
      return FALSE;
   }

   //
   // Turn off Vpp bits
   //
   tmp &= ~0x3;

   switch (Vpp) {
   case PCMCIA_VPP_IS_VCC: {
         tmp |= 0x1;
         break;
      }
   case PCMCIA_VPP_12V: {
         tmp |= 0x2;
         break;
      }
   case PCMCIA_VPP_0V: {
         tmp |= 0x0;
         break;
      }
   }

   PcicWriteSocket(socketPtr, PCIC_PWR_RST, tmp);
   if (Vpp != PCMCIA_VPP_0V) {
      //
      // When power is enabled always stall to give the PCCARD
      // a chance to react.
      //

      PcmciaWait(PcicStallPower);
   }
   return TRUE;
}


BOOLEAN
PcicModifyMemoryWindow(
   IN PDEVICE_OBJECT Pdo,
   IN ULONGLONG HostBase,
   IN ULONGLONG CardBase OPTIONAL,
   IN BOOLEAN   Enable,
   IN ULONG     WindowSize  OPTIONAL,
   IN UCHAR     AccessSpeed OPTIONAL,
   IN UCHAR     BusWidth    OPTIONAL,
   IN BOOLEAN   IsAttributeMemory OPTIONAL
   )
/*++

Routine Description:

   Part of the interfaces originally developed to
   support flash memory cards.

   This routine enables the caller to 'slide' the supplied
   host memory window across the given (16-bit)pc-card's card memory.
   i.e. the host memory window will be modified to map
   the pc-card at a new card memory offset

Arguments:

   Pdo         - Pointer to the device object for the PC-Card

   HostBase    - Host memory window base to be mapped

   CardBase    - Mandatory if Enable is TRUE
                 New card memory offset to map the host memory window
                 to

   Enable      - If this is FALSE - all the remaining arguments
                 are ignored and the host window will simply be
                 disabled

   WindowSize  - Specifies the size of the host memory window to
                 be mapped. Note this must be at the proper alignment
                 and must be less than or equal to the originally
                 allocated window size for the host base.
                 If this is zero, the originally allocated window
                 size will be used.

   AccessSpeed - Mandatory if Enable is TRUE
                 Specifies the new access speed for the pc-card.
                 (AccessSpeed should be encoded as per the pc-card
                  standard, card/socket services spec)

   BusWidth    - Mandatory if Enable is TRUE
                 One of PCMCIA_MEMORY_8BIT_ACCESS
                 or     PCMCIA_MEMORY_16BIT_ACCESS

   IsAttributeMemory - Mandatory if Enable is TRUE
                       Specifies if the window should be mapped
                       to the pc-card's attribute or common memory


Return Value:

   TRUE  -      Memory window was enabled/disabled as requested
   FALSE -      If not

--*/
{
   PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
   PFDO_EXTENSION fdoExtension;
   PSOCKET socketPtr;
   PSOCKET_CONFIGURATION socketConfig;
   USHORT index;
   UCHAR  registerOffset;
   UCHAR  regl;
   UCHAR  regh;
   UCHAR  tmp, waitIndex;

   socketConfig = pdoExtension->SocketConfiguration;
   if (!socketConfig) {
      // doesn't look like we are started.
      return FALSE;
   }

   socketPtr = pdoExtension->Socket;
   ASSERT ( socketPtr != NULL );
   fdoExtension = socketPtr->DeviceExtension;

   for (index = 0 ; index < socketConfig->NumberOfMemoryRanges; index++) {
      if (socketConfig->Memory[index].HostBase == HostBase) {
         break;
      }
   }

   if (index >= socketConfig->NumberOfMemoryRanges) {
      //
      // Unknown hostbase
      //
      return FALSE;
   }

   //
   // Make sure caller isn't asking a bigger window
   // than he is permitted to
   //
   if (WindowSize > socketConfig->Memory[index].Length) {
      return FALSE;
   }

   if (WindowSize == 0) {
      //
      // WindowSize not provided. Default to
      // the largest size permitted for this pc-card
      //
      WindowSize = socketConfig->Memory[index].Length;
   }

   //
   // Determine offset in registers.
   //
   registerOffset = (index * 8);

   //
   // Disable the window first (this has to be done regardless
   // of whether we want to enable/disable the window ultimately)
   //


   PCMCIA_ACQUIRE_DEVICE_LOCK(socketPtr->DeviceExtension);

   tmp = PcicReadSocket(socketPtr, PCIC_ADD_WIN_ENA);
   tmp &= ~(1 << index);
   PcicWriteSocket(socketPtr, PCIC_ADD_WIN_ENA, tmp);

   if (!Enable) {
      //
      // We're done.. Just write zeroes to the window registers anyway
      // before returning
      //
      PcicWriteSocket(socketPtr,
                      (UCHAR)(PCIC_CRDMEM_OFF_ADD0_L+registerOffset),
                      0);
      PcicWriteSocket(socketPtr,
                      (UCHAR)(PCIC_CRDMEM_OFF_ADD0_H+registerOffset),
                      0);
      PcicWriteSocket(socketPtr,
                      (UCHAR)(PCIC_MEM_ADD0_STRT_L+registerOffset),
                      0);
      PcicWriteSocket(socketPtr,
                      (UCHAR)(PCIC_MEM_ADD0_STRT_H+registerOffset),
                      0);
      PcicWriteSocket(socketPtr,
                      (UCHAR)(PCIC_MEM_ADD0_STOP_L+registerOffset),
                      0);
      PcicWriteSocket(socketPtr,
                      (UCHAR)(PCIC_MEM_ADD0_STOP_H+registerOffset),
                      0);
      PcmciaSetWindowPage(fdoExtension, socketPtr, index, 0);
      PCMCIA_RELEASE_DEVICE_LOCK(socketPtr->DeviceExtension);
      return TRUE;
   }

   if (AccessSpeed) {
      if (!NT_SUCCESS(PcicConvertSpeedToWait(AccessSpeed, &waitIndex))) {
         PCMCIA_RELEASE_DEVICE_LOCK(socketPtr->DeviceExtension);
         return FALSE;
      }
   }

   //
   // Calculate and set card base addresses.
   // This is the 2's complement of the host address and
   // the card offset.
   //

   CardBase = (CardBase - (HostBase & OFFSETCALC_BASE_MASK)) & OFFSETCALC_OFFSET_MASK;
   regl = (UCHAR) (CardBase >> 12);
   regh = (UCHAR) ((CardBase >> 20) & 0x003f);
   if (IsAttributeMemory) {
      regh |= 0x40;
   }


   PcicWriteSocket(socketPtr,
                   (UCHAR)(PCIC_CRDMEM_OFF_ADD0_L + registerOffset),
                   regl);
   PcicWriteSocket(socketPtr,
                   (UCHAR)(PCIC_CRDMEM_OFF_ADD0_H + registerOffset),
                   regh);

   //
   // Calculate and set host window.
   //
   if (!PcmciaSetWindowPage(fdoExtension, socketPtr, index, (UCHAR) ((ULONG) HostBase >> 24))) {
      if ((HostBase + WindowSize) > 0xFFFFFF) {
         DebugPrint((PCMCIA_DEBUG_FAIL, "PcicModifyMemorywindow: HostBase %x specified: doesn't fit in 24 bits!\n", (ULONG) HostBase));
         PCMCIA_RELEASE_DEVICE_LOCK(socketPtr->DeviceExtension);
         return FALSE;
      }
   }

   regl = (UCHAR) (HostBase >> 12);
   regh = (UCHAR) (HostBase >> 20) & 0xF;   
   if (BusWidth == PCMCIA_MEMORY_16BIT_ACCESS) {

      regh |= 0x80; // 16-bit access

#if 0
      //
      // If this is not a revision 1 part (0x82), then set
      // the work around register for 16-bit windows.
      //
      // This bit is not used on any chip that I have
      // documentation for. I have no idea why it is here, it is
      // not in win9x.
      // In any case it looks like a NOOP for the vast majority of
      // chips, but since it uses a NOT, then it is invoked on all
      // new controllers. REMOVE after next major release
      //
      if (socketPtr->Revision != PCIC_REVISION) {
         tmp = PcicReadSocket(socketPtr,
                              PCIC_CARD_DETECT);
         tmp |= 0x01;
         PcicWriteSocket(socketPtr,
                         PCIC_CARD_DETECT,
                         tmp);
      }
#endif
   }


   PcicWriteSocket(socketPtr,
                   (UCHAR)(PCIC_MEM_ADD0_STRT_L + registerOffset),
                   regl);
   PcicWriteSocket(socketPtr,
                   (UCHAR)(PCIC_MEM_ADD0_STRT_H + registerOffset),
                   regh);

   //
   // Set stop address.
   //

   HostBase += WindowSize - 1;
   regl = (UCHAR) (HostBase >> 12);
   regh = (UCHAR) (HostBase >> 20) & 0xF;   

   //
   // Set the wait states
   //
   if (AccessSpeed) {
      //
      // New access speed specified, use it
      //
      regh |= (waitIndex << 6);
   } else {
      //
      //  Use existing access speed
      //
      regh |= (PcicReadSocket(socketPtr, (UCHAR)(PCIC_MEM_ADD0_STOP_H + registerOffset)) & 0xC0);

   }

   PcicWriteSocket(socketPtr,
                   (UCHAR)(PCIC_MEM_ADD0_STOP_L + registerOffset),
                   regl);
   PcicWriteSocket(socketPtr,
                   (UCHAR)(PCIC_MEM_ADD0_STOP_H + registerOffset),
                   regh);

   //
   // Memory window set up now enable it
   //
   tmp  = (1 << index);
   tmp |= PcicReadSocket(socketPtr, PCIC_ADD_WIN_ENA);
   PcicWriteSocket(socketPtr, PCIC_ADD_WIN_ENA, tmp);

   //
   // Allow the window to settle
   //
   (VOID) PcicPCCardReady(socketPtr);
   PCMCIA_RELEASE_DEVICE_LOCK(socketPtr->DeviceExtension);
   return TRUE;
}


BOOLEAN
PcicIsWriteProtected(
   IN PDEVICE_OBJECT Pdo
   )
/*++

Routine Description:

   Part of the interfaces originally developed to
   support flash memory cards.

   Returns the status of the write protected pin
   for the given PC-Card

Arguments:

   Pdo   - Pointer to the device object for the PC-Card

Return Value:

   TRUE  -      if the PC-Card is write-protected
   FALSE -      if not

--*/
{
   PSOCKET socketPtr = ((PPDO_EXTENSION) Pdo->DeviceExtension)->Socket;

   ASSERT ( socketPtr != NULL );
   return ((PcicReadSocket(socketPtr, PCIC_STATUS) & 0x10) != 0);
}


VOID
PcicEnableDisableWakeupEvent(
   IN PSOCKET Socket,
   IN PPDO_EXTENSION PdoExtension,   
   IN BOOLEAN Enable
   )
/*++

Routine Description

   This routine sets/resets the Ring Indicate enable bit for the given socket,
   enabling a PC-Card in the socket to assert/not assert wake through the RingIndicate
   pin.

Arguments

Socket         - Pointer to the socket
Enable         - TRUE : set ring indicate enable
                 FALSE: turn off ring indicate, i.e. system cannot be woken up through
                           a pc-card in this socket

Return Value

None

--*/
{
   UCHAR byte;

   byte = PcicReadSocket(Socket, PCIC_INTERRUPT);
   if (Enable) {
      byte |=  IGC_RINGIND_ENABLE;
   } else {
      byte &= ~IGC_RINGIND_ENABLE;
   }
   PcicWriteSocket(Socket, PCIC_INTERRUPT, byte);
}


BOOLEAN
PcicInitializePcmciaSocket(
   PSOCKET Socket
   )

/*++

Routine Description:

    This routine will setup the 82365 into a state where the pcmcia support
    module will be able to issue commands to read device tuples from the
    cards in the sockets.

Arguments:

    Socket - socket specific information

Return Value:

    TRUE if successful
    FALSE if not successful

--*/

{
   UCHAR index;
   UCHAR byte;
   UCHAR reg;

   //
   // Initialize the EXCA registers
   //
   //
   for (index = 0; index < 0xFF; index++) {
      reg  = (UCHAR) PcicRegisterInitTable[index].Register;
      if (reg == 0xFF) {
         //
         // End of table
         //
         break;
      }

      byte = (UCHAR) PcicRegisterInitTable[index].Value;
      if (reg == PCIC_INTERRUPT) {
         //
         // Don't clobber the Ring Enable bit
         // NOTE: this entire if statement should be removed
         // when WAIT_WAKE support is done for modems
         // also don't clobber the interrupt enable bit
         //
         byte |= (PcicReadSocket(Socket, reg) & (IGC_RINGIND_ENABLE | IGC_INTR_ENABLE));
      }
      PcicWriteSocket(Socket, reg, byte);
   }

   if (CLPD6729(Socket)) {

      //
      // Need to program the chip per code in
      // Windows 95.  This will turn on the
      // audio support bit.
      // NOTE: This used to be done in PcicDetect
      //
      byte = PcicReadSocket(Socket, PCIC_CL_MISC_CTRL1);
      byte |= CL_MC1_SPKR_ENABLE;
      PcicWriteSocket(Socket, PCIC_CL_MISC_CTRL1, byte);

      //
      // Set the Cirrus Logic controller for ISA style interrupts
      //
      byte = PcicReadExtendedCirrusController(Socket->AddressPort,
                                              Socket->RegisterOffset,
                                              PCIC_CIRRUS_EXTENSION_CTRL_1);

      byte &= ~0x08; // Isa style interrupt
      PcicWriteExtendedCirrusController(Socket->AddressPort,
                                        Socket->RegisterOffset,
                                        PCIC_CIRRUS_EXTENSION_CTRL_1,
                                        byte);
   }

   return TRUE;
}


NTSTATUS
PcicResetCard (
   IN PSOCKET Socket,
   OUT PULONG pDelayTime
   )
/*++

Routine Description:

   Resets the pc-card in the given socket.

Arguments:

   Socket - Pointer to the socket in which the pc-card resides
   pDelayTime - specifies delay (msec) to occur after the current phase

Return value:

   STATUS_MORE_PROCESSING_REQUIRED - increment phase, perform delay, recall
   other status values terminate sequence

--*/
{
   NTSTATUS status;
   UCHAR byte;

   switch(Socket->CardResetPhase) {
   case 1:
      //
      // Set interface mode to memory to begin with
      //
      byte = PcicReadSocket(Socket, PCIC_INTERRUPT);
      byte &= ~IGC_PCCARD_IO;
      PcicWriteSocket(Socket, PCIC_INTERRUPT, byte);

      //
      // Start reset
      //
      byte = PcicReadSocket(Socket, PCIC_INTERRUPT);
      byte = byte & ~IGC_PCCARD_RESETLO;
      PcicWriteSocket(Socket, PCIC_INTERRUPT, byte);

      *pDelayTime = PcicResetWidthDelay;
      status = STATUS_MORE_PROCESSING_REQUIRED;
      break;

   case 2:
      //
      // Stop reset
      //
      byte = PcicReadSocket(Socket, PCIC_INTERRUPT);
      byte |= IGC_PCCARD_RESETLO;
      PcicWriteSocket(Socket, PCIC_INTERRUPT, byte);

      *pDelayTime = PcicResetSetupDelay;
      status = STATUS_MORE_PROCESSING_REQUIRED;
      break;

   case 3:
      //
      // Wait for the card to settle
      //
      PcicPCCardReady(Socket);
      status = STATUS_SUCCESS;
      break;

   default:
      ASSERT(FALSE);
      status = STATUS_UNSUCCESSFUL;
   }
   return status;
}



UCHAR
PcicReadSocket(
   IN PSOCKET Socket,
   IN ULONG Register
   )

/*++

Routine Description:

    This routine will read a byte from the specified socket EXCA register

Arguments:

    Socket -- Pointer to the socket from which we should read
    Register -- The register to be read

Return Value:

   The data returned from the port.

--*/

{
   UCHAR byte;
   if (CardBus(Socket)) {
      //
      // Sanity check in case controller wasn't started
      //
      if (Socket->DeviceExtension->CardBusSocketRegisterBase) {
         byte = READ_REGISTER_UCHAR((PUCHAR) (Socket->DeviceExtension->CardBusSocketRegisterBase + Register
                                             + CARDBUS_EXCA_REGISTER_BASE));
      } else {
         byte = 0xff;
      }
   } else {
      byte = PcicReadController(Socket->AddressPort, Socket->RegisterOffset,
                                (UCHAR) Register);
   }
   return byte;
}


VOID
PcicWriteSocket(
   IN PSOCKET Socket,
   IN ULONG Register,
   IN UCHAR DataByte
   )

/*++

Routine Description:

    This routine will write a byte to the specified socket EXCA register

Arguments:

    Socket --   Pointer to the socket to which we write
    Register -- The register to be read
    DataByte -- Data to be written

Return Value:

    None

--*/

{
   if (CardBus(Socket)) {
      //
      // Sanity check in case controller wasn't started
      //
      if (Socket->DeviceExtension->CardBusSocketRegisterBase) {
         WRITE_REGISTER_UCHAR((PUCHAR) (Socket->DeviceExtension->CardBusSocketRegisterBase+Register+CARDBUS_EXCA_REGISTER_BASE), DataByte);
      }
   } else {
      PcicWriteController(Socket->AddressPort, Socket->RegisterOffset, (UCHAR)Register, DataByte);
   }
}


UCHAR
PcicReadController(
   IN PUCHAR Base,
   IN USHORT Socket,
   IN UCHAR Register
   )

/*++

Routine Description:

    This routine will read a byte from the controller data port

Arguments:

    Base -- The I/O port for the controller
    Socket -- The socket in for the card being read
    Register -- The register to be read

Return Value:

   The data returned from the port.

--*/

{
   UCHAR dataByte = 0;

   WRITE_PORT_UCHAR(Base, (UCHAR)(Socket+Register));
   dataByte = READ_PORT_UCHAR((PUCHAR)Base + 1);
   return dataByte;
}


VOID
PcicWriteController(
   IN PUCHAR Base,
   IN USHORT Socket,
   IN UCHAR Register,
   IN UCHAR DataByte
   )

/*++

Routine Description:

    This routine will write a byte to the controller data port

Arguments:

    Base -- The I/O port for the controller
    Socket -- The socket in for the card being read
    Register -- The register to be read
    DataByte -- Data to be written

Return Value:

    None

--*/

{
   WRITE_PORT_UCHAR(Base, (UCHAR)(Socket+Register));
   WRITE_PORT_UCHAR((PUCHAR)Base + 1, DataByte);
}


UCHAR
PcicReadExtendedCirrusController(
   IN PUCHAR Base,
   IN USHORT Socket,
   IN UCHAR Register
   )

/*++

Routine Description:

    This routine will read a byte from the Cirrus
    logic extended registers

Arguments:

    Base -- The I/O port for the controller
    Socket -- The socket in for the card being read
    Register -- The register to be read

Return Value:

   The data returned from the port.

--*/

{
   UCHAR dataByte = 0;
   PcicWriteController(Base, Socket, PCIC_CIRRUS_EXTENDED_INDEX, Register);
   dataByte = PcicReadController(Base, Socket, PCIC_CIRRUS_INDEX_REG);
   return dataByte;
}


VOID
PcicWriteExtendedCirrusController(
   IN PUCHAR Base,
   IN USHORT Socket,
   IN UCHAR Register,
   IN UCHAR DataByte
   )

/*++

Routine Description:

    This routine will write a byte to one of the
    Cirrus Logic extended registers

Arguments:

    Base -- The I/O port for the controller
    Socket -- The socket in for the card being read
    Register -- The register to be read
    DataByte -- Data to be written

Return Value:

    None

--*/

{
   //
   // Register needs to be written out to the extended index register
   //
   PcicWriteController(Base, Socket, PCIC_CIRRUS_EXTENDED_INDEX, Register);
   PcicWriteController(Base, Socket, PCIC_CIRRUS_INDEX_REG, DataByte);
}



ULONG
PcicReadWriteCardMemory(
   IN PSOCKET Socket,
   IN MEMORY_SPACE MemorySpace,
   IN ULONG Offset,
   IN PUCHAR Buffer,
   IN ULONG Length,
   IN CONST BOOLEAN Read  
   )
/*++

Routine Description:
   This routine will read or write into the configuration memory on the card
   with the supplied buffer. This is provided as a service to certain
   client drivers (netcard) which need to write to the attribute memory
   (say) to set parameters etc.

Arguments:

    Socket      -- The socket info in for the card being written to
    MemorySpace -- indicates which space - attribute or common memory
    Offset      -- Offset in the memory to write to
    Buffer      -- Buffer contents being dumped to the card
    Length      -- Length of the buffer being written out
    Read        -- boolean indicating read or write

--*/
{
   PFDO_EXTENSION fdoExtension = Socket->DeviceExtension;
   PUCHAR memoryPtr, memoryPtrMax;
   PUCHAR bufferPtr;
   ULONG  index, adjustedOffset, adjustedBase;
   UCHAR  memGran;
   UCHAR memWidth;
   //
   // NOTE: memGran HAS to be a integral divisor of AttributeMemorySize for
   // the rest of the code to work!
   //
   memGran = (MemorySpace == PCCARD_ATTRIBUTE_MEMORY) ? 2 : 1;
   memWidth = (MemorySpace == PCCARD_ATTRIBUTE_MEMORY) ? MEM_8BIT : MEM_16BIT;
   
   //
   // Adjust for offsets > size of attribute memory window.
   //
   adjustedOffset =  (Offset*memGran) % fdoExtension->AttributeMemorySize;
   //
   // Adjusted base is: |_ Offset _| mod AttrributeMemorySize
   //
   adjustedBase = ((Offset*memGran) / fdoExtension->AttributeMemorySize) *
                  fdoExtension->AttributeMemorySize;
   
   bufferPtr = Buffer;
   
   PcicEnableDisableMemory(Socket, MemorySpace, adjustedBase, memWidth, TRUE);
   //
   // Now read the memory contents into the user buffer
   //
   memoryPtr = fdoExtension->AttributeMemoryBase + adjustedOffset;
   memoryPtrMax = fdoExtension->AttributeMemoryBase + fdoExtension->AttributeMemorySize;
   
   for (index = 0; index < Length; index++) {
   
      if (memoryPtr >= memoryPtrMax) {
         //
         // Skip to next page of attribute memory
         // (size of page = fdoExtension->AttributeMemorySize)
         //
         adjustedBase += fdoExtension->AttributeMemorySize;
         //
         // Remap window at new base
         //
         PcicEnableDisableMemory(Socket, MemorySpace, adjustedBase, memWidth, TRUE);
   
         memoryPtr = fdoExtension->AttributeMemoryBase;
      }

      if (Read) {   
         *bufferPtr++ = READ_REGISTER_UCHAR(memoryPtr);
      } else {
         WRITE_REGISTER_UCHAR(memoryPtr, *bufferPtr++);
      }
      memoryPtr += memGran;
   }
   
   PcicEnableDisableMemory(Socket, 0,0,0, FALSE);
   return Length;
}   



ULONG
PcicReadWriteCardMemoryIndirect(
   IN PSOCKET Socket,
   IN MEMORY_SPACE MemorySpace,
   IN ULONG Offset,
   IN PUCHAR Buffer,
   IN ULONG Length,
   IN CONST BOOLEAN Read  
   )
/*++

Routine Description:
   This routine will read or write the memory space of a pcmcia card
   using the indirect access method.

Arguments:

   Socket      -- The socket info in for the card being written to
   MemorySpace -- indicates which space - attribute or common memory
   Offset      -- Offset in the memory to write to
   Buffer      -- Buffer contents being dumped to the card
   Length      -- Length of the buffer being written out
   Read        -- boolean indicating read or write

--*/
{   
   PFDO_EXTENSION fdoExtension = Socket->DeviceExtension;
   ULONG  index, adjustedOffset;
   PUCHAR pMem;
   UCHAR Control = 0;
   UCHAR  memGran;

   PcicEnableDisableMemory(Socket, PCCARD_COMMON_MEMORY, 0, MEM_8BIT, TRUE);

   pMem = (PUCHAR) ((ULONG_PTR)(fdoExtension->AttributeMemoryBase) + IAR_CONTROL_LOW);

   Control = (MemorySpace == PCCARD_ATTRIBUTE_MEMORY_INDIRECT) ? IARF_AUTO_INC :
                                                                 IARF_AUTO_INC | IARF_COMMON | IARF_BYTE_GRAN;
   WRITE_REGISTER_UCHAR(pMem, Control);

   memGran = (MemorySpace == PCCARD_ATTRIBUTE_MEMORY_INDIRECT) ? 2 : 1;
   adjustedOffset = Offset*memGran;

   pMem = (PUCHAR) ((ULONG_PTR)(fdoExtension->AttributeMemoryBase) + IAR_ADDRESS);
   for (index = 0; index < sizeof(ULONG); index++) {
      WRITE_REGISTER_UCHAR(pMem++, (UCHAR)(adjustedOffset>>(index*8)));
   }

   PcicEnableDisableMemory(Socket, PCCARD_COMMON_MEMORY, 0, MEM_16BIT, TRUE);
  
   for (index = 0; index < Length; index++) {
      // Note that pMem should be pointing to IAR_DATA, and is NOT
      // supposed to be incremented
      if (Read) {
         Buffer[index] = READ_REGISTER_UCHAR(pMem);
      } else {
         WRITE_REGISTER_UCHAR(pMem, Buffer[index]);
      }         
   }

   PcicEnableDisableMemory(Socket, 0,0,0, FALSE);
   return Length;
}   

   

ULONG
PcicWriteCardMemory(
   IN PPDO_EXTENSION PdoExtension,
   IN MEMORY_SPACE MemorySpace,
   IN ULONG Offset,
   IN PUCHAR Buffer,
   IN ULONG Length
   )
/*++

Routine Description:
   This routine will write into the configuration memory on the card
   with the supplied buffer. This is provided as a service to certain
   client drivers (netcard) which need to write to the attribute memory
   (say) to set parameters etc.

Arguments:

    PdoExtension-- The extension of the device being written to
    MemorySpace -- indicates which space - attribute or common memory
    Offset      -- Offset in the memory to write to
    Buffer      -- Buffer contents being dumped to the card
    Length      -- Length of the buffer being written out

--*/
{
   PSOCKET Socket = PdoExtension->Socket;
   ULONG retLength;

   ASSERT (IsSocketFlagSet(Socket, SOCKET_CARD_POWERED_UP));

   switch(MemorySpace) {
   
   case PCCARD_ATTRIBUTE_MEMORY_INDIRECT:
   case PCCARD_COMMON_MEMORY_INDIRECT:
   
      retLength = PcicReadWriteCardMemoryIndirect(Socket, MemorySpace, Offset, Buffer, Length, FALSE);
      break;
     
   case PCCARD_ATTRIBUTE_MEMORY:
   case PCCARD_COMMON_MEMORY:

      retLength = PcicReadWriteCardMemory(Socket, MemorySpace, Offset, Buffer, Length, FALSE);
      break;
      
   default:
      retLength = 0;
      ASSERT(FALSE);
   }
     
   return retLength;
}


ULONG
PcicReadCardMemory(
   IN PPDO_EXTENSION PdoExtension,
   IN MEMORY_SPACE MemorySpace,
   IN ULONG Offset,
   IN PUCHAR Buffer,
   IN ULONG Length
   )

/*++

Routine Description:

    This routine will read the configuration memory on the card

Arguments:

    PdoExtension-- The extension of the device being read
    MemorySpace -- indicates which space - attribute or common memory
    Offset      -- Offset in the memory to read
    Buffer      -- pointer to pointer for tuple information.
    Length      -- maximum size of the buffer area for tuple information.

Return Value:



--*/

{
   PSOCKET Socket = PdoExtension->Socket;
   ULONG retLength;

   ASSERT (IsSocketFlagSet(Socket, SOCKET_CARD_POWERED_UP));

   switch(MemorySpace) {
   
   case PCCARD_ATTRIBUTE_MEMORY_INDIRECT:
   case PCCARD_COMMON_MEMORY_INDIRECT:
   
      retLength = PcicReadWriteCardMemoryIndirect(Socket, MemorySpace, Offset, Buffer, Length, TRUE);
      break;
     
   case PCCARD_ATTRIBUTE_MEMORY:
   case PCCARD_COMMON_MEMORY:

      retLength = PcicReadWriteCardMemory(Socket, MemorySpace, Offset, Buffer, Length, TRUE);
     
      DebugPrint((PCMCIA_DEBUG_INFO,"PcicReadCardMemory: "
                  "%.02X %.02X %.02X %.02X %.02X %.02X %.02X %.02X-%.02X %.02X %.02X %.02X %.02X %.02X %.02X %.02X\n",
                  Buffer[0], Buffer[1], Buffer[2], Buffer[3], Buffer[4], Buffer[5], Buffer[6], Buffer[7],
                  Buffer[8], Buffer[9], Buffer[10], Buffer[11], Buffer[12], Buffer[13], Buffer[14], Buffer[15]));
      break;
      
   default:
      retLength = 0;
      ASSERT(FALSE);
   }
     
   return retLength;
}



BOOLEAN
PcicProcessConfigureRequest(
   IN PSOCKET Socket,
   IN PCARD_REQUEST request,
   IN PUCHAR Base
   )

/*++

Routine Description:

    Processes a configure or IRQ setup request.

Arguments:

    ConfigRequest -- Socket config structure
    Base - the I/O port base

Return Value:

    None

--*/

{
   USHORT         index;
   UCHAR          tmp;

   //
   // Since all first entries in the config structure is a RequestType,
   // cast the pointer comming in as a PREQUEST_CONFIG to get the proper
   // RequestType
   //

   switch (request->RequestType) {

   case IO_REQUEST: {
         UCHAR ioControl = 0;

         if (!request->u.Io.IoEntry[0].BasePort) {
            break;
         }


         for (index = 0; index < request->u.Io.NumberOfRanges; index++) {
            UCHAR  registerOffset;

            registerOffset = (index * 4);

            if (request->u.Io.IoEntry[index].BasePort) {

               PcicWriteSocket( Socket,
                                PCIC_IO_ADD0_STRT_L + registerOffset,
                                (UCHAR) (request->u.Io.IoEntry[index].BasePort & 0xff));
               PcicWriteSocket( Socket,
                                PCIC_IO_ADD0_STRT_H + registerOffset,
                                (UCHAR) (request->u.Io.IoEntry[index].BasePort >> 8));
               PcicWriteSocket(Socket,
                               PCIC_IO_ADD0_STOP_L + registerOffset,
                               (UCHAR) ((request->u.Io.IoEntry[index].BasePort +
                                         request->u.Io.IoEntry[index].NumPorts) & 0xff));
               PcicWriteSocket(Socket,
                               PCIC_IO_ADD0_STOP_H + registerOffset,
                               (UCHAR) ((request->u.Io.IoEntry[index].BasePort +
                                         request->u.Io.IoEntry[index].NumPorts) >> 8));
            }


            //
            // set up the io control register
            //
            tmp = 0;

            if (request->u.Io.IoEntry[index].Attributes & IO_DATA_PATH_WIDTH) {
               tmp |= IOC_IO0_DATASIZE;
            }

            if ((request->u.Io.IoEntry[index].Attributes & IO_WAIT_STATE_16) &&
               !((Elc(Socket) || CLPD6729(Socket)))) {
               tmp |= IOC_IO0_WAITSTATE;
            }

            if (request->u.Io.IoEntry[index].Attributes & IO_SOURCE_16) {
               tmp |= IOC_IO0_IOCS16;
            }

            if (request->u.Io.IoEntry[index].Attributes & IO_ZERO_WAIT_8) {
               tmp |= IOC_IO0_ZEROWS;
            }

            ioControl |= tmp << registerOffset;
         }

         PcicWriteSocket(Socket, PCIC_IO_CONTROL, ioControl);

         tmp = PcicReadSocket( Socket, PCIC_ADD_WIN_ENA);
         tmp &= ~(WE_IO0_ENABLE | WE_IO1_ENABLE);

         switch(request->u.Io.NumberOfRanges) {
            case 1:
               tmp |= WE_IO0_ENABLE;
               break;
            case 2:
               tmp |= (WE_IO0_ENABLE | WE_IO1_ENABLE);
               break;
         }

         PcicWriteSocket(Socket, PCIC_ADD_WIN_ENA, tmp);
         break;
      }

   case IRQ_REQUEST: {
         //
         // Do not nuke the reset and cardtype bits.
         //
         tmp = PcicReadSocket(Socket, PCIC_INTERRUPT);
         tmp &= ~IGC_IRQ_MASK;
         tmp |= request->u.Irq.AssignedIRQ;

         DebugPrint((PCMCIA_DEBUG_INFO, "PcicProcessConfigureRequest: Assigned IRQ %x programming IRQ %x\n", request->u.Irq.AssignedIRQ,tmp));

         PcicWriteSocket(Socket, PCIC_INTERRUPT, tmp);

         if (tmp = request->u.Irq.ReadyIRQ) {
            tmp = (tmp << 4) | 0x04;
            PcicWriteSocket(Socket, PCIC_CARD_INT_CONFIG, tmp);
         }

         break;
      }

   case DECONFIGURE_REQUEST: {
         //
         // Deregister the interrupt, re-init to memory interface
         //
         tmp = PcicReadSocket(Socket, PCIC_INTERRUPT);
         tmp &= ~(IGC_PCCARD_IO | IGC_IRQ_MASK);
         PcicWriteSocket(Socket, PCIC_INTERRUPT, tmp);

         //
         // Disable memory/io windows
         // Don't touch the memory window which is
         // is used by the controller for reading attribute memory
         //

         if (IsSocketFlagSet(Socket, SOCKET_MEMORY_WINDOW_ENABLED)) {
            UCHAR enableMask;
            enableMask = WE_MEM0_ENABLE << Socket->CurrentMemWindow;
            tmp = PcicReadSocket(Socket, PCIC_ADD_WIN_ENA);
            tmp &= enableMask;
         } else {
            //
            // no attribute window enabled, just turn off everything
            //
            tmp = 0;
         }

         PcicWriteSocket(Socket, PCIC_ADD_WIN_ENA, tmp);
         //
         // Zero out the I/O windows
         //
         for (index = PCIC_IO_ADD0_STRT_L; index <= PCIC_IO_ADD1_STOP_H; index++) {
            PcicWriteSocket( Socket,
                             (ULONG) index,
                             0);
         }

         break;
      }

   case CONFIGURE_REQUEST:{

         //
         // Tell the socket controller we are an I/O card if InterfaceType says so
         //
         if (request->u.Config.InterfaceType == CONFIG_INTERFACE_IO_MEM) {

            tmp = PcicReadSocket(Socket, PCIC_INTERRUPT);
            tmp |= IGC_PCCARD_IO;
            PcicWriteSocket(Socket, PCIC_INTERRUPT, tmp);

         } else {
            tmp = PcicReadSocket(Socket, PCIC_INTERRUPT);
            tmp &= ~IGC_PCCARD_IO;
            PcicWriteSocket(Socket, PCIC_INTERRUPT, tmp);
         }

         if (request->u.Config.RegisterWriteMask & (REGISTER_WRITE_CONFIGURATION_INDEX |
                                                    REGISTER_WRITE_CARD_CONFIGURATION  |
                                                    REGISTER_WRITE_IO_BASE)) {
            //
            // This is where we setup the card and get it ready for operation
            //
            ULONG  configRegisterBase = request->u.Config.ConfigBase / 2;
            PDEVICE_OBJECT Pdo = Socket->PdoList;
            PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
            MEMORY_SPACE memorySpace = IsPdoFlagSet(pdoExtension, PCMCIA_PDO_INDIRECT_CIS) ? PCCARD_ATTRIBUTE_MEMORY_INDIRECT :
                                                                                             PCCARD_ATTRIBUTE_MEMORY;
            

            if (request->u.Config.RegisterWriteMask & REGISTER_WRITE_IO_BASE) {
               UCHAR ioHigh = (UCHAR)(request->u.Config.IoBaseRegister>>8);
               UCHAR ioLow = (UCHAR) request->u.Config.IoBaseRegister;
            
               PcicWriteCardMemory(pdoExtension, memorySpace, configRegisterBase + 5, &ioLow, 1);
               PcmciaWait(PcicStallCounter);
               PcicWriteCardMemory(pdoExtension, memorySpace, configRegisterBase + 6, &ioHigh, 1);
               PcmciaWait(PcicStallCounter);
            }

            if (request->u.Config.RegisterWriteMask & REGISTER_WRITE_IO_LIMIT) {
               PcicWriteCardMemory(pdoExtension, memorySpace, configRegisterBase + 9, (PUCHAR)&request->u.Config.IoLimitRegister, 1);
               PcmciaWait(PcicStallCounter);
            }

            if (request->u.Config.RegisterWriteMask & REGISTER_WRITE_CONFIGURATION_INDEX) {
               UCHAR configIndex = request->u.Config.ConfigIndex;
            
               PcicWriteCardMemory(pdoExtension, memorySpace, configRegisterBase, &configIndex, 1);
               PcmciaWait(PcicStallCounter);
               
               configIndex |= 0x40;
               PcicWriteCardMemory(pdoExtension, memorySpace, configRegisterBase, &configIndex, 1);
               PcmciaWait(PcicStallCounter);
            }

            if (request->u.Config.RegisterWriteMask & REGISTER_WRITE_CARD_CONFIGURATION) {
               PcicReadCardMemory(pdoExtension, memorySpace, configRegisterBase + 1, &tmp, 1);
               PcmciaWait(PcicStallCounter);

               tmp |= request->u.Config.CardConfiguration;

               //
               // turn off power control bit
               //

               tmp &= ~0x04;
               PcicWriteCardMemory(pdoExtension, memorySpace, configRegisterBase + 1, &tmp, 1);
               PcmciaWait(PcicStallCounter);
            }
         }
         break;
      }

   case MEM_REQUEST: {
         //
         // Set up memory ranges on the controller.
         //

         PFDO_EXTENSION deviceExtension = Socket->DeviceExtension;

         for (index = 0; index < request->u.Memory.NumberOfRanges; index++) {
            UCHAR  registerOffset;
            UCHAR  regl;
            UCHAR  regh;
            ULONG  cardBase = request->u.Memory.MemoryEntry[index].BaseAddress;
            ULONG  base = request->u.Memory.MemoryEntry[index].HostAddress;
            ULONG  size = request->u.Memory.MemoryEntry[index].WindowSize;

            //
            // Determine offset in registers.
            //

            registerOffset = (index * 8);

            //
            // Calculate and set card base addresses.
            // This is the 2's complement of the host address and
            // the card offset.
            //

            cardBase = (cardBase - (base & OFFSETCALC_BASE_MASK)) & OFFSETCALC_OFFSET_MASK;
            regl = (UCHAR) (cardBase >> 12);
            regh = (UCHAR) (cardBase >> 20);
            if (request->u.Memory.MemoryEntry[index].AttributeMemory) {
               regh |= 0x40;
            }
            PcicWriteSocket(Socket,
                            (UCHAR)(PCIC_CRDMEM_OFF_ADD0_L + registerOffset),
                            regl);
            PcicWriteSocket(Socket,
                            (UCHAR)(PCIC_CRDMEM_OFF_ADD0_H + registerOffset),
                            regh);

            //
            // Calculate and set host window.
            //


            if (!PcmciaSetWindowPage(deviceExtension, Socket, index, (UCHAR) (base >> 24))) {
               ASSERT (base <= 0xFFFFFF);
            }

            base &= 0xFFFFFF; // only 24bit host base allowed

            regl = (UCHAR) (base >> 12);
            regh = (UCHAR) (base >> 20);
            if (request->u.Memory.MemoryEntry[index].WindowDataSize16) {
               //
               // This memory window is for a 16-bit data path
               // to the card. Enable appropriately.
               //
               regh |= (MEMBASE_16BIT >> 8);

#if 0
               //
               // If this is not a revision 1 part (0x82), then set
               // the work around register for 16-bit windows.
               //
               // This bit is not used on any chip that I have
               // documentation for. I have no idea why it is here, it is
               // not in win9x.
               // In any case it looks like a NOOP for the vast majority of
               // chips, but since it uses a NOT, then it is invoked on all
               // new controllers. REMOVE after next major release
               //
               if (Socket->Revision != PCIC_REVISION) {
                  tmp = PcicReadSocket(Socket,
                                       PCIC_CARD_DETECT);
                  tmp |= 0x01;
                  PcicWriteSocket(Socket,
                                  PCIC_CARD_DETECT,
                                  tmp);

               }
#endif
            }

            PcicWriteSocket(Socket,
                            (UCHAR)(PCIC_MEM_ADD0_STRT_L + registerOffset),
                            regl);
            PcicWriteSocket(Socket,
                            (UCHAR)(PCIC_MEM_ADD0_STRT_H + registerOffset),
                            regh);

            //
            // Set stop address.
            //
            base += size - 1;
            regl = (UCHAR) (base >> 12);
            regh = (UCHAR) (base >> 20);

            //
            // Add specified wait states
            //
            regh |= (request->u.Memory.MemoryEntry[index].WaitStates << 6);

            PcicWriteSocket(Socket,
                            (UCHAR)(PCIC_MEM_ADD0_STOP_L + registerOffset),
                            regl);
            PcicWriteSocket(Socket,
                            (UCHAR)(PCIC_MEM_ADD0_STOP_H + registerOffset),
                            regh);
         }

         //
         // Memory windows are set up now enable them.
         //

         tmp = 0;
         for (index = 0; index < request->u.Memory.NumberOfRanges; index++) {
            tmp |= (1 << index);
         }
         tmp |= PcicReadSocket(Socket, PCIC_ADD_WIN_ENA);
         PcicWriteSocket(Socket, PCIC_ADD_WIN_ENA, tmp);
         break;
      }

   default: {
         DebugPrint((PCMCIA_DEBUG_FAIL, "ConfigRequest is INVALID!\n"));
      }
   }
   return TRUE;
}


BOOLEAN
PcicDetectCardInSocket(
   IN PSOCKET Socket
   )

/*++

Routine Description:

    This routine will determine if a card is in the socket

Arguments:

    Socket -- Socket information

Return Value:

    TRUE if card is present.

--*/

{
   UCHAR   tmp;
   BOOLEAN cardPresent=FALSE;

   //
   // Read the PCIC status register to see if the card is in there.
   //
   tmp = PcicReadSocket(Socket, PCIC_STATUS);
   tmp &= (CARD_DETECT_1 | CARD_DETECT_2);

   if (tmp == (CARD_DETECT_1 | CARD_DETECT_2)) {
      cardPresent = TRUE;
   }

   return cardPresent;
}


BOOLEAN
PcicDetectCardChanged(
   IN PSOCKET Socket
   )

/*++

Routine Description:

    This routine will determine if socket's card insertion status has changed.

Arguments:

    Socket -- Socket info.

Return Value:

    TRUE if card insertion status has changed.

--*/

{
   //
   // Read the PCIC CardStatusChange register to see if CD's have changed.
   //
   return (BOOLEAN) (PcicReadSocket(Socket, PCIC_CARD_CHANGE) & CSC_CD_CHANGE);
}


BOOLEAN
PcicDetectReadyChanged(
   IN PSOCKET Socket
   )

/*++

Routine Description:

    This routine will determine if socket's card ready status has changed

Arguments:

    Socket -- Socket info.

Return Value:

    TRUE if card ready enable has changed.

--*/

{
   //
   // Read the PCIC Card status change register to see if ready has changed
   //
   return (PcicReadSocket(Socket, PCIC_CARD_CHANGE) & CSC_READY_CHANGE
           ?TRUE :FALSE);
}



VOID
PcicEnableDisableMemory(
   IN PSOCKET Socket,
   IN MEMORY_SPACE MemorySpace,
   IN ULONG   CardBase,
   IN UCHAR   memWidth,
   IN BOOLEAN Enable
   )

/*++

Routine Description:

    This routine will enable or disable attribute/common memory.
    It searches for a free window first to avoid using a window already
    in use. Repeated 'enable' calls to this routine without a disable
    (in order to remap the base) is allowed.

Arguments:

    Socket -- Socket information
    MemorySpace -- Indicates which space - ATTRIBUTE_MEMORY/COMMON_MEMORY
    CardBase -- card offset (base) for the attribute memory window
    Enable -- If TRUE, enable, if FALSE, disable

Return Value:

    None

--*/

{
   ULONG location;
   PUCHAR cisBufferPointer;
   PFDO_EXTENSION deviceExtension= Socket->DeviceExtension;
   PUCHAR PcicCisBufferBase = (PUCHAR) deviceExtension->AttributeMemoryBase;
   ULONG  PcicPhysicalBase  = deviceExtension->PhysicalBase.LowPart;
   BOOLEAN memoryInterface;
   UCHAR tmp;
   UCHAR index;
   UCHAR  registerOffset;
   UCHAR enableMask;
   USHORT word;

   ASSERT (IsSocketFlagSet(Socket, SOCKET_CARD_POWERED_UP));

   if (Enable) {
      tmp = PcicReadSocket(Socket, PCIC_INTERRUPT);
      if (tmp & IGC_PCCARD_IO) {
         //
         // Card configured for i/o interface
         //
         memoryInterface = FALSE;
      } else {
         //
         // Card configured for Memory interface
         //
         memoryInterface = TRUE;
      }

      //
      // Find a window to use.
      //
      tmp = PcicReadSocket(Socket, PCIC_ADD_WIN_ENA);

      if (IsSocketFlagSet(Socket, SOCKET_MEMORY_WINDOW_ENABLED)) {
         index = Socket->CurrentMemWindow;
         enableMask = WE_MEM0_ENABLE << index;
      } else {
         for (index = 0, enableMask = WE_MEM0_ENABLE; index < 5; index++, enableMask <<= 1) {
            if (!(tmp & enableMask)) {
               break;
            }
            if (index==4) {
               //
               // If we are here, we didn't find an available window. Just use the last
               // one anyway, it is likely a pcmcia.sys bug.
               //
//             ASSERT(FALSE); // hits docked thinkpads
               break;
            }
         }
         Socket->CurrentMemWindow = index;
         SetSocketFlag(Socket, SOCKET_MEMORY_WINDOW_ENABLED);
      }

      registerOffset = (index * 8);

      //
      // First turn the window off
      //
      tmp &= ~enableMask;
      tmp &= ~WE_MEMCS16_DECODE;
      PcicWriteSocket(Socket, PCIC_ADD_WIN_ENA, tmp);

      //
      // Calculate and set the memory windows start and stop locations.
      //

      //
      // Only 24 bit addresses programmed
      // For cardbus controllers, 32 bit addresses are supported,
      // but the higher 8 bits are written to the page register (see below)
      location = PcicPhysicalBase & 0xFFFFFF;

      word = (USHORT) ((location >> 12) & MEMBASE_ADDR_MASK);
      
      //
      // typically run attribute memory with 8-bit window, common with 16-bit
      // (except for writing the registers for attribute_indirect)
      //
      if (memWidth == MEM_16BIT) {
         word |= MEMBASE_16BIT;
      }         
      
      PcicWriteSocket(Socket, (UCHAR)(PCIC_MEM_ADD0_STRT_L+registerOffset), (UCHAR)(word));
      PcicWriteSocket(Socket, (UCHAR)(PCIC_MEM_ADD0_STRT_H+registerOffset), (UCHAR)(word >> 8));

      location += (deviceExtension->AttributeMemorySize - 1);

      word = (USHORT) ((location >> 12) & MEMEND_ADDR_MASK);
      //
      // Impose 3 wait states..lessons learnt from win9x implementations
      //
      word |= MEMEND_WS_MASK;
      
      PcicWriteSocket(Socket, (UCHAR)(PCIC_MEM_ADD0_STOP_L+registerOffset), (UCHAR)(word));
      PcicWriteSocket(Socket, (UCHAR)(PCIC_MEM_ADD0_STOP_H+registerOffset), (UCHAR)(word >> 8));

      //
      // Set up the 2's complement card offset to zero
      //
      location = (CardBase - (PcicPhysicalBase & OFFSETCALC_BASE_MASK)) & OFFSETCALC_OFFSET_MASK;
      
      word = (USHORT) ((location >> 12) & MEMOFF_ADDR_MASK);
      if (MemorySpace == PCCARD_ATTRIBUTE_MEMORY) {
         word |= MEMOFF_REG_ACTIVE;
      }
      
      PcicWriteSocket(Socket, (UCHAR)(PCIC_CRDMEM_OFF_ADD0_L+registerOffset), (UCHAR)(word));
      PcicWriteSocket(Socket, (UCHAR)(PCIC_CRDMEM_OFF_ADD0_H+registerOffset), (UCHAR)(word >> 8));

      //
      // Set the page register
      // (this routine is called only for R2 cards)
      // Use mem4 window explicitly
      //
      if (!PcmciaSetWindowPage(deviceExtension, Socket, (USHORT)index, (UCHAR) (PcicPhysicalBase >> 24))) {
         ASSERT (PcicPhysicalBase <= 0xFFFFFF);
      }

      //
      // Enable the address window
      //

      tmp = PcicReadSocket(Socket, PCIC_ADD_WIN_ENA);

      tmp |= enableMask | WE_MEMCS16_DECODE;

      PcicWriteSocket(Socket, PCIC_ADD_WIN_ENA, tmp);

      cisBufferPointer = PcicCisBufferBase;

      if (memoryInterface) {
         //
         // Only wait for card ready if the memory window does not appear
         //

         (VOID) PcicPCCardReady(Socket);
      } else {
         //
         // Wait a little bit for the window to appear
         //
         PcmciaWait(PcicMemoryWindowDelay);
      }

      DebugPrint((PCMCIA_DEBUG_INFO, "skt %08x memory window %d enabled %x\n", Socket, index, PcicPhysicalBase));

   } else {

      if (IsSocketFlagSet(Socket, SOCKET_MEMORY_WINDOW_ENABLED)) {

         enableMask = WE_MEM0_ENABLE << Socket->CurrentMemWindow;
         registerOffset = (Socket->CurrentMemWindow * 8);
         //
         // Disable the Address window
         //

         tmp = PcicReadSocket(Socket, PCIC_ADD_WIN_ENA);
         tmp &= ~enableMask;

         PcicWriteSocket(Socket, PCIC_ADD_WIN_ENA, tmp);
         PcicWriteSocket(Socket, (UCHAR)(PCIC_MEM_ADD0_STRT_L+registerOffset), 0xFF);
         PcicWriteSocket(Socket, (UCHAR)(PCIC_MEM_ADD0_STRT_H+registerOffset), 0x0F);
         PcicWriteSocket(Socket, (UCHAR)(PCIC_MEM_ADD0_STOP_L+registerOffset), 0xFF);
         PcicWriteSocket(Socket, (UCHAR)(PCIC_MEM_ADD0_STOP_H+registerOffset), 0x0F);
         PcicWriteSocket(Socket, (UCHAR)(PCIC_CRDMEM_OFF_ADD0_L+registerOffset), 0x00);
         PcicWriteSocket(Socket, (UCHAR)(PCIC_CRDMEM_OFF_ADD0_H+registerOffset), 0x00);
         PcmciaSetWindowPage(deviceExtension, Socket, Socket->CurrentMemWindow, 0);


         DebugPrint((PCMCIA_DEBUG_INFO, "skt %08x memory window %d disabled\n", Socket, Socket->CurrentMemWindow));
         ResetSocketFlag(Socket, SOCKET_MEMORY_WINDOW_ENABLED);
      }
   }
   return;
}



BOOLEAN
PcicPCCardReady(
   IN PSOCKET Socket
   )

/*++

Routine Description:

    Loop for a reasonable amount of time waiting for the card status to
    return ready.

Arguments:

    Socket - the socket to check.

Return Value:

    TRUE - the card is ready.
    FALSE - after a reasonable delay the card is still not ready.

--*/

{
   ULONG index;
   UCHAR byte;
   PFDO_EXTENSION fdoExtension = Socket->DeviceExtension;
   NTSTATUS       status;
   LARGE_INTEGER  timeout;

#ifdef READY_ENABLE
   if (fdoExtension->PcmciaInterruptObject) {
      byte = PcicReadSocket(Socket, PCIC_STATUS);
      if (byte & 0x20) {
         return TRUE;
      }
      //
      // Enable ready enable controller interrupt
      //
      PcicEnableDisableControllerInterrupt(
                                          Socket,
                                          fdoExtension->Configuration.Interrupt.u.Interrupt.Level,
                                          TRUE,
                                          TRUE);
      RtlConvertLongToLargeInteger(-PCMCIA_READY_WAIT_INTERVAL);
      status = KeWaitForSingleObject(&Socket->PCCardReadyEvent,
                                     Executive,
                                     KernelMode,
                                     FALSE,
                                     &timeout
                                    );
      if (status != STATUS_TIMEOUT) {
         return TRUE;
      }
      return FALSE;
   }
#endif

   for (index = 0; index < fdoExtension->ReadyDelayIter; index++) {
      byte = PcicReadSocket(Socket, PCIC_STATUS);
      if (byte & 0x20) {
         break;
      }
      PcmciaWait(fdoExtension->ReadyStall);
   }

   if (index < fdoExtension->ReadyDelayIter) {
      DebugPrint((PCMCIA_COUNTERS, "PcicPCCardReady: %d\n", index));
      return TRUE;
   }

   return FALSE;
}



NTSTATUS
PcicIsaDetect(
   IN PFDO_EXTENSION DeviceExtension
   )

/*++

Routine Description:

    Locate any PCMCIA sockets supported by this driver.  This routine
    will find the 82365SL and compatible parts and construct SOCKET
    structures to represent all sockets found

Arguments:

    DeviceExtension - the root for the SocketList.

Return Value:

    STATUS_SUCCESS if a controller is found: also indicates this might be called
                   again to locate another controller

    STATUS_UNSUCCESSFUL  if something failed/no controllers found.

    STATUS_NO_MORE_ENTRIES if no more pcic controllers can be found.
                           Stop calling this routine.
--*/

{
#define PCMCIA_NUMBER_ISA_PORT_ADDRESSES 3
   static  ULONG isaIndex=0;
   ULONG   index;
   ULONG   ioPortBases[PCMCIA_NUMBER_ISA_PORT_ADDRESSES] = { 0x3e0, 0x3e2, 0x3e4};
   NTSTATUS status=STATUS_NO_MORE_ENTRIES;

   PAGED_CODE();

   DeviceExtension->Configuration.InterfaceType = Isa;
   DeviceExtension->Configuration.BusNumber = 0x0;

   for (index = isaIndex; !NT_SUCCESS(status) && (index < PCMCIA_NUMBER_ISA_PORT_ADDRESSES); index++) {
      status = PcicDetect(DeviceExtension,Isa, ioPortBases[index]);
   }

   //
   // Set index for next search
   //
   isaIndex = index;
   return status;
}



NTSTATUS
PcicDetect(
   IN PFDO_EXTENSION DeviceExtension,
   IN INTERFACE_TYPE InterfaceType,
   IN ULONG          IoPortBase
   )
/*++

Routine Description:

   This routine is used for legacy detecting PCIC-compatible
   PCMCIA controllers.
   This attempts to sniff the standard PCMCIA controller ports
   to check if anything resembling the PCMCIA revisions exists,
   and if so obtain and initialize socket information for the controller.

Arguments:

   DeviceExtension - pointer to the already allocated device extension
                    for the yet-to-be-detected pcmcia controller.

   InterfaceType  - Bus interface type on which the pcmcia
                    controller is expected to reside. Currently
                    we legacy detect only ISA based controllers

   IoPortBase     - IoPort address we need to sniff at for finding
                    the controller

Return value:

   STATUS_SUCCESS      PCMCIA controller was found

   STATUS_UNSUCCESSFUL otherwise

--*/
{
   ULONG   addressSpace;
   NTSTATUS status;
   PUCHAR  port;
   PUCHAR  elcPort;
   PHYSICAL_ADDRESS cardAddress;
   PHYSICAL_ADDRESS portAddress;
   PCM_RESOURCE_LIST cmResourceList = NULL;
   PCM_PARTIAL_RESOURCE_LIST cmPartialResourceList;
   UCHAR   saveBytes[2];
   UCHAR   dataByte;
   UCHAR   revisionByte;
   USHORT  socket;
   UCHAR   socketNumber = 0;
   BOOLEAN translated;
   BOOLEAN mapped = FALSE;
   BOOLEAN conflict = TRUE;
   BOOLEAN resourcesAllocated = FALSE;

   PAGED_CODE();

   portAddress.LowPart = IoPortBase;
   portAddress.u.HighPart = 0;

   //
   // Get the resources used for detection
   //
   cmResourceList = ExAllocatePool(PagedPool, sizeof(CM_RESOURCE_LIST));

   if (!cmResourceList) {
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto Exit;
   }

   RtlZeroMemory(cmResourceList, sizeof(CM_RESOURCE_LIST));
   cmResourceList->Count = 1;
   cmResourceList->List[0].InterfaceType = Isa;
   cmPartialResourceList = &(cmResourceList->List[0].PartialResourceList);
   cmPartialResourceList->Version  = 1;
   cmPartialResourceList->Revision = 1;
   cmPartialResourceList->Count    = 1;
   cmPartialResourceList->PartialDescriptors[0].Type = CmResourceTypePort;
   cmPartialResourceList->PartialDescriptors[0].ShareDisposition = CmResourceShareDeviceExclusive;
   cmPartialResourceList->PartialDescriptors[0].Flags = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_10_BIT_DECODE;
   cmPartialResourceList->PartialDescriptors[0].u.Port.Start = portAddress;
   cmPartialResourceList->PartialDescriptors[0].u.Port.Length = 2;

   status=IoReportResourceForDetection(
                                      DeviceExtension->DriverObject,
                                      cmResourceList,
                                      sizeof(CM_RESOURCE_LIST),
                                      NULL,
                                      NULL,
                                      0,
                                      &conflict);
   if (!NT_SUCCESS(status) || conflict) {
      goto Exit;
   }
   resourcesAllocated = TRUE;

   addressSpace = 1; // port space
   translated = HalTranslateBusAddress(InterfaceType,
                                       0,
                                       portAddress,
                                       &addressSpace,
                                       &cardAddress);

   if (!translated) {

      //
      // HAL would not translate the address.
      //
      status = STATUS_UNSUCCESSFUL;
      goto Exit;
   }

   if (addressSpace) {
      //
      // I/O port space
      //
      port = (PUCHAR)(cardAddress.QuadPart);
   } else {
      //
      // Memory space.. we need to map this into memory
      //
      port = MmMapIoSpace(cardAddress,
                          2,
                          FALSE);
      mapped = TRUE;
   }

   status = STATUS_UNSUCCESSFUL;
   socket = 0;
   dataByte = PcicReadController(port, socket, PCIC_IDENT);
   revisionByte = dataByte;

   switch (dataByte) {
   case PCIC_REVISION:
   case PCIC_REVISION2:
   case PCIC_REVISION3: {
         //
         // The cirrus logic controller will toggle top 2 lines from the chip info
         // register on the chip. Read from thelocation 3 times and verify that the top two
         // lines are changing. We do this for NEC 98 also..
         //
         ULONG i;
         UCHAR data[4];

         WRITE_PORT_UCHAR(port, (UCHAR)(socket + PCIC_CL_CHIP_INFO));
         for (i = 0; i < 3; i++) {
            data[i] = READ_PORT_UCHAR(port+1);
            if (i) {
               dataByte = data[i - 1] ^ data[i];
               if (dataByte != 0xc0) {
                  break;
               }
            }
         }

         if (i == 3) {
            //
            // Ah. this is a cirrus logic controller
            //
            PcmciaSetControllerType(DeviceExtension, PcmciaCLPD6729);
         }

         dataByte = PcicReadController(port, socket, PCIC_CARD_CHANGE);

         if (dataByte & 0xf0) {

            //
            // Not a socket.
            //

            break;
         }

         //
         // Map and try to locate the Compaq Elite controller
         // This code is a rough approximation of the code in
         // the Windows 95 detection module for the PCIC part.
         //

         addressSpace = 1; // port space
         portAddress.LowPart = IoPortBase + 0x8000;
         portAddress.HighPart = 0;

         translated = HalTranslateBusAddress(Isa,
                                             0,
                                             portAddress,
                                             &addressSpace,
                                             &cardAddress);

         if (translated) {

            if (!addressSpace) {
               elcPort = MmMapIoSpace(cardAddress,
                                      2,
                                      FALSE);
            } else {
               elcPort = (PUCHAR)(cardAddress.QuadPart);
            }

            //
            // Save current index value.
            //

            saveBytes[0] = READ_PORT_UCHAR(elcPort);
            WRITE_PORT_UCHAR(elcPort, (UCHAR)(socket + PCIC_IDENT));

            //
            // Save data byte for the location that will be used
            // for the test.
            //

            saveBytes[1] = READ_PORT_UCHAR(elcPort + 1);

            //
            // Check for an ELC
            //

            WRITE_PORT_UCHAR(elcPort+1, 0x55);
            WRITE_PORT_UCHAR(elcPort, (UCHAR)(socket + PCIC_IDENT));
            dataByte = READ_PORT_UCHAR(elcPort+1);

            if (dataByte == 0x55) {
               WRITE_PORT_UCHAR(elcPort, (UCHAR)(socket + PCIC_IDENT));
               WRITE_PORT_UCHAR(elcPort+1, 0xaa);
               WRITE_PORT_UCHAR(elcPort, (UCHAR)(socket + PCIC_IDENT));
               dataByte = READ_PORT_UCHAR(elcPort+1);

               if (dataByte == 0xaa) {

                  //
                  // ELC found - initialize eaddr registers
                  //

                  WRITE_PORT_UCHAR(elcPort, (UCHAR)(socket + 0));
                  WRITE_PORT_UCHAR(elcPort+1, 0);
                  WRITE_PORT_UCHAR(elcPort, (UCHAR)(socket + 1));
                  WRITE_PORT_UCHAR(elcPort+1, 0);
                  WRITE_PORT_UCHAR(elcPort, (UCHAR)(socket + 2));
                  WRITE_PORT_UCHAR(elcPort+1, 0x10);
                  PcmciaSetControllerType(DeviceExtension, PcmciaElcController);
               }
            }
            //
            // Restore the original values.
            //

            WRITE_PORT_UCHAR(elcPort, (UCHAR)(socket + PCIC_IDENT));
            WRITE_PORT_UCHAR(elcPort+1, saveBytes[1]);
            WRITE_PORT_UCHAR(elcPort, saveBytes[0]);

            if (!addressSpace) {
               MmUnmapIoSpace(elcPort, 2);
            }
         }

         DeviceExtension->Configuration.UntranslatedPortAddress = (USHORT)IoPortBase;
         DeviceExtension->Configuration.PortSize = 2;
         DebugPrint((PCMCIA_DEBUG_DETECT, "Port %x Offset %x\n", port, socket));
         status = STATUS_SUCCESS;
         break;
      }
   default: {
         DebugPrint((PCMCIA_DEBUG_DETECT,
                     "controller at (0x%x:0x%x) not found, returns %x\n",
                     portAddress.LowPart, socket, dataByte));
         break;
      }
   }

   Exit:

   if (!NT_SUCCESS(status) && mapped) {
      MmUnmapIoSpace(port, 2);
   }

   //
   // Free up the allocated resources if any
   //
   if (resourcesAllocated) {
      IoReportResourceForDetection(DeviceExtension->DriverObject,
                                   NULL,
                                   0,
                                   NULL,
                                   NULL,
                                   0,
                                   &conflict);
   }
   //
   // Free up allocated memory if any
   //
   if (cmResourceList) {
      ExFreePool(cmResourceList);
   }
   return status;
}



NTSTATUS
PcicBuildSocketList(
   IN PFDO_EXTENSION DeviceExtension
   )
/*++

Routine Description:

   This routine looks out at the registers of the controller to see how
   many sockets there are. For each socket, a SOCKET structure is allocated
   and chained onto the SocketList pointer of the device extension.

Arguments:

   DeviceExtension - pointer to the device extension
                       enumerated PDO
Return value:

   STATUS_SUCCESS      PCMCIA controller was found and socket structures were
                       succesfully initialized

   STATUS_UNSUCCESSFUL otherwise

--*/
{
   ULONG   addressSpace;
   NTSTATUS status;
   PUCHAR  port;
   PSOCKET socketPtr;
   PSOCKET previousSocket;
   UCHAR   dataByte;
   UCHAR   revisionByte;
   USHORT  socket;
   UCHAR   socketNumber = 0;

   PAGED_CODE();

   previousSocket = DeviceExtension->SocketList;
   port = (PUCHAR)DeviceExtension->Configuration.UntranslatedPortAddress;


   status = STATUS_UNSUCCESSFUL;

   for (socket = 0; socket < 0xFF; socket += 0x40) {
      dataByte = PcicReadController(port, socket, PCIC_IDENT);
      revisionByte = dataByte;

      switch (dataByte) {
      case PCIC_REVISION:
      case PCIC_REVISION2:
      case PCIC_REVISION3: {

            dataByte = PcicReadController(port, socket, PCIC_CARD_CHANGE);

            if (dataByte & 0xf0) {

               //
               // Not a socket.
               //

               continue;
            }

            //
            // Check for IBM 750
            //

            if (socket & 0x80) {
               ULONG i;
               UCHAR tmp;

               //
               // See if this socket shadows the socket without
               // the sign bit.
               //

               tmp = PcicReadController(port, socket, PCIC_MEM_ADD4_STRT_L);
               for (i = 0; i < 8; i++) {

                  //
                  // See if memory window 4 is the same on both sockets
                  //

                  if (PcicReadController(port, socket, (UCHAR) (PCIC_MEM_ADD4_STRT_L + i)) !=
                      PcicReadController(port, (USHORT) (socket & 0x7f), (UCHAR) (PCIC_MEM_ADD4_STRT_L + i))) {
                     break;
                  }
               }

               if (i == 8) {

                  //
                  // Currently window is the same - change the
                  // window at one of the socket offsets.
                  //

                  PcicWriteController(port, (USHORT) (socket & 0x7f), PCIC_MEM_ADD4_STRT_L, (UCHAR) ~tmp);
                  if (PcicReadController(port, socket, PCIC_MEM_ADD4_STRT_L) == (UCHAR) ~tmp) {

                     //
                     // The sockets are the same.
                     //

                     continue;
                  } else {
                     PcicWriteController(port, (USHORT) (socket & 0x7f), PCIC_MEM_ADD4_STRT_L, tmp);
                  }
               }
            }


            socketPtr = ExAllocatePool(NonPagedPool, sizeof(SOCKET));
            if (!socketPtr) {
               return STATUS_INSUFFICIENT_RESOURCES;
            }
            RtlZeroMemory(socketPtr, sizeof(SOCKET));

            socketPtr->DeviceExtension = DeviceExtension;
            socketPtr->SocketFnPtr = &PcicSupportFns;
            socketPtr->RegisterOffset = socket;
            socketPtr->AddressPort = port;
            socketPtr->Revision = revisionByte;

            socketPtr->SocketNumber = socketNumber++;
            if (previousSocket) {
               previousSocket->NextSocket = socketPtr;
            } else {
               DeviceExtension->SocketList = socketPtr;
            }
            previousSocket = socketPtr;
            status = STATUS_SUCCESS;
            break;
         }

      default: {
            break;
         }
      }
   }

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\pcmcibus\pdocb.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    pdocb.c

Abstract:

    This module contains the code to handle
    the IRP_MJ_PNP dispatches for the PDOs
    for cardbus devices

Authors:

    Ravisankar Pudipeddi (ravisp)
    Neil Sandlin (neilsa) 1-Jun-1999

Environment:

    Kernel mode only

Notes:

Revision History:

--*/

#include "pch.h"

//
// Internal References
//

NTSTATUS
PcmciaStartCardBusCard(
   IN PDEVICE_OBJECT Pdo,
   IN OUT PIRP       Irp
   );
   
NTSTATUS
PcmciaRemoveCardBusCard(
   IN PDEVICE_OBJECT Pdo,
   IN PIRP           Irp
   );

NTSTATUS
PcmciaQueryCardBusCardResourceRequirements(
   IN PDEVICE_OBJECT Pdo,
   IN PIRP           Irp
   );
   
NTSTATUS
PcmciaQueryCardBusCardCapabilities(
   IN PDEVICE_OBJECT Pdo,
   IN PIRP           Irp
   );
   

#ifdef ALLOC_PRAGMA
   #pragma alloc_text(PAGE,  PcmciaPdoCardBusPnPDispatch)
   #pragma alloc_text(PAGE,  PcmciaStartCardBusCard)
   #pragma alloc_text(PAGE,  PcmciaRemoveCardBusCard)
   #pragma alloc_text(PAGE,  PcmciaQueryCardBusCardResourceRequirements)
   #pragma alloc_text(PAGE,  PcmciaQueryCardBusCardCapabilities)
#endif



NTSTATUS
PcmciaPdoCardBusPnPDispatch(
   IN PDEVICE_OBJECT Pdo,
   IN PIRP Irp
   )

/*++

Routine Description:

    This routine handles pnp requests for the filter object for CardBus devices.

Arguments:

    Pdo - pointer to the physical device object
    Irp - pointer to the io request packet

Return Value:

    status

--*/

{
   PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
   NTSTATUS status = STATUS_NOT_SUPPORTED;

   PAGED_CODE();
   ASSERT (pdoExtension->LowerDevice);

#if DBG
   if (irpStack->MinorFunction > IRP_MN_PNP_MAXIMUM_FUNCTION) {
      DebugPrint((PCMCIA_DEBUG_PNP, "pdo %08x irp %08x Unknown minor function %x\n",
                                     Pdo, Irp, irpStack->MinorFunction));
   } else {
      DebugPrint((PCMCIA_DEBUG_PNP, "pdo %08x irp %08x --> %s\n",
                    Pdo, Irp, PNP_IRP_STRING(irpStack->MinorFunction)));
   }
#endif

   //
   // CardBus PnP Dispatch
   //

   switch (irpStack->MinorFunction) {
   
   case IRP_MN_START_DEVICE:
      status = PcmciaStartCardBusCard(Pdo, Irp);
      PcmciaDoStartSound(pdoExtension->Socket, status);
      break;
      
   case IRP_MN_REMOVE_DEVICE: 
      status = PcmciaRemoveCardBusCard(Pdo, Irp);
      break;
      
   case IRP_MN_STOP_DEVICE:
      PcmciaSkipCallLowerDriver(status, pdoExtension->LowerDevice, Irp);
      MarkDeviceNotStarted(pdoExtension);
      break;
      
   case IRP_MN_SURPRISE_REMOVAL:
      if (IsDevicePhysicallyRemoved(pdoExtension)) {
         PcmciaSetSocketPower(pdoExtension->Socket, NULL, NULL, PCMCIA_POWEROFF);      
      }         
      PcmciaSkipCallLowerDriver(status, pdoExtension->LowerDevice, Irp);
      break;

   case IRP_MN_QUERY_RESOURCE_REQUIREMENTS: 
      status = PcmciaQueryCardBusCardResourceRequirements(Pdo, Irp);
      break;                                                     
                                                  
   case IRP_MN_QUERY_CAPABILITIES: 
      status = PcmciaQueryCardBusCardCapabilities(Pdo, Irp);
      break;
      
   case IRP_MN_QUERY_INTERFACE: 
      status = PcmciaPdoQueryInterface(Pdo, Irp);
      break;
      
   default:
      PcmciaSkipCallLowerDriver(status, pdoExtension->LowerDevice, Irp);
   }

   DebugPrint((PCMCIA_DEBUG_PNP, "pdo %08x irp %08x <-- %s %08x\n", Pdo, Irp,
                                  STATUS_STRING(status), status));

   return status;
}



NTSTATUS
PcmciaStartCardBusCard(
   IN PDEVICE_OBJECT Pdo,
   IN OUT PIRP       Irp
   )
/*++

Routine Description:

   This routine attempts to start the PC-Card by configuring it with the supplied resources.


Arguments:

   Pdo - Pointer to the device object representing the PC-Card which needs to be started
   ResourceList - Pointer the list of assigned resources for the PC-Card

Return value:

   STATUS_INSUFFICIENT_RESOURCES - Not sufficient resources supplied to start device/
                                   could not allocate memory
   STATUS_UNSUCCESSFUL           - Supplied resources are invalid for this PC-Card
   STATUS_SUCCESS                - Configured and started the card successfully

--*/
{
   PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
   PSOCKET        socket = pdoExtension->Socket;
   PSOCKET_DATA   socketData = pdoExtension->SocketData;
   PFDO_EXTENSION fdoExtension = socket->DeviceExtension;
   USHORT         word;
   UCHAR          BaseClass;
   NTSTATUS       status = STATUS_NOT_SUPPORTED;
   ULONG          i;
   ULONG          devid;
   USHORT         cls_lat;
   BOOLEAN        setAudio = FALSE;
   
   PAGED_CODE();

   ASSERT (pdoExtension->LowerDevice);

   //
   // Apply some hacks if necessary
   //
   status = PcmciaConfigureCardBusCard(pdoExtension);

   if (!NT_SUCCESS(status)) {
      //
      // The card's config space probably never became visible
      //
      Irp->IoStatus.Status = status;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
      return status;
   }
   
   //
   // Select PCI IRQ routing
   //
   
   CBEnableDeviceInterruptRouting(socket);

   //
   // Turn on ZV for this card, if it needs it
   // 
   if (socketData && (socketData->Flags & SDF_ZV)) {
      if (PcmciaSetZV(fdoExtension, socket, TRUE)) {
         SetSocketFlag(socket, SOCKET_CUSTOM_INTERFACE);
      }
   } else if (IsSocketFlagSet(socket, SOCKET_CUSTOM_INTERFACE)) {
      PcmciaSetZV(fdoExtension, socket, FALSE);
      ResetSocketFlag(socket, SOCKET_CUSTOM_INTERFACE);
   }

   //
   // Pci needs to enable this card .. send it down to the PDO
   //

   status = PcmciaIoCallDriverSynchronous(pdoExtension->LowerDevice, Irp);

   //
   // Apparently cardbus modems aren't immune to needing delays
   // This yield duration was emperically determined using the Xircom RBM56G
   //
   GetPciConfigSpace(pdoExtension, CFGSPACE_CLASSCODE_BASECLASS, &BaseClass, 1);
   if (BaseClass == PCI_CLASS_SIMPLE_COMMS_CTLR) {
      //
      // Wait for modem to warm up
      //
      PcmciaWait(CBModemReadyDelay);
      setAudio = TRUE;
   }      
   
   PcmciaSetAudio(fdoExtension, socket, setAudio);   
   
   //
   // Assume that the cardbus controller has the correct CLS and latency
   // timer values, and that the cardbus device has zeroes.
   //
   
   GetPciConfigSpace(fdoExtension, CFGSPACE_CACHE_LINESIZE, &cls_lat, sizeof(cls_lat));
   SetPciConfigSpace(pdoExtension, CFGSPACE_CACHE_LINESIZE, &cls_lat, sizeof(cls_lat));

   if (NT_SUCCESS(status)) {
      MarkDeviceStarted(pdoExtension);
      MarkDeviceLogicallyInserted(pdoExtension);
   }
   
   Irp->IoStatus.Status = status;
   IoCompleteRequest(Irp, IO_NO_INCREMENT);
   return status;
}



NTSTATUS
PcmciaRemoveCardBusCard(
   IN PDEVICE_OBJECT Pdo,
   IN PIRP           Irp
   )
/*++

Routine Description:

Arguments:

Return value:

--*/
{
   PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
   PSOCKET        socket = pdoExtension->Socket;
   NTSTATUS status;

   ASSERT(socket != NULL);

   //
   // Send this down to the PDO first
   //

   status = PcmciaIoCallDriverSynchronous(pdoExtension->LowerDevice, Irp);

   if (!NT_SUCCESS(status)) {
      Irp->IoStatus.Status = status;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
      return status;
   }      

   if (IsDevicePhysicallyRemoved(pdoExtension)) {
      PFDO_EXTENSION fdoExtension = socket->DeviceExtension;
      PDEVICE_OBJECT curPdo, prevPdo;
      PPDO_EXTENSION curPdoExt;
      ULONG waitCount = 0;
      
      //
      // Synchronize with power routines
      // LATER: make these values adjustable
      //     
      while(!PCMCIA_TEST_AND_SET(&pdoExtension->DeletionLock)) {
         PcmciaWait(1000000);
         if (waitCount++ > 20) {
            ASSERT(waitCount <= 20);
            break;
         }
      }
   
      //
      // Delink this Pdo from the FDO list.
      //
      for (curPdo = fdoExtension->PdoList, prevPdo = NULL; curPdo!=NULL; prevPdo=curPdo, curPdo=curPdoExt->NextPdoInFdoChain) {
         curPdoExt = curPdo->DeviceExtension;
         
         if (curPdo == Pdo) {
            if (prevPdo) {
               ((PPDO_EXTENSION)prevPdo->DeviceExtension)->NextPdoInFdoChain = pdoExtension->NextPdoInFdoChain;
            } else {
               fdoExtension->PdoList = pdoExtension->NextPdoInFdoChain;
            }
            break;
         }
      }
      
      //
      // Delink this Pdo from the socket list.
      //
      for (curPdo = socket->PdoList, prevPdo = NULL; curPdo!=NULL; prevPdo=curPdo, curPdo=curPdoExt->NextPdoInSocket) {
         curPdoExt = curPdo->DeviceExtension;
         
         if (curPdo == Pdo) {
            if (prevPdo) {
               ((PPDO_EXTENSION)prevPdo->DeviceExtension)->NextPdoInSocket = pdoExtension->NextPdoInSocket;
            } else {
               socket->PdoList = pdoExtension->NextPdoInSocket;
            }
            break;
         }
      }
   
      PcmciaCleanupPdo(Pdo);
      //
      // Delete..
      //
      if (!IsDeviceDeleted(pdoExtension)) {
         MarkDeviceDeleted(pdoExtension);
         IoDeleteDevice(Pdo);
      }
   
   
      PcmciaSetSocketPower(pdoExtension->Socket, NULL, NULL, PCMCIA_POWEROFF);      
      
      if (--fdoExtension->PciAddCardBusCount == 0) {
         ResetSocketFlag(socket, SOCKET_CLEANUP_PENDING);
         //
         // If a query_device_relations came in after a card was inserted, but before
         // we have removed the previous card configuration, the enumeration would have been
         // postponed. Here, we start it up again
         //
         if (IsSocketFlagSet(socket, SOCKET_ENUMERATE_PENDING)) {
            ResetSocketFlag(socket, SOCKET_ENUMERATE_PENDING);
            SetSocketFlag(socket, SOCKET_CARD_STATUS_CHANGE);
            IoInvalidateDeviceRelations(fdoExtension->Pdo, BusRelations);
         }
      } 
   
   } else {
      //
      // We will keep this Pdo around, since this is not physically ejected.
      //
      MarkDeviceLogicallyRemoved(pdoExtension);
   }
   
   
   Irp->IoStatus.Status = status;
   IoCompleteRequest(Irp, IO_NO_INCREMENT);
   return status;
}



NTSTATUS
PcmciaQueryCardBusCardResourceRequirements(
   IN PDEVICE_OBJECT Pdo,
   IN PIRP           Irp
   )
/*++

Routine Description:

   This routine filters the interrupt requirement generated by pci for the cardbus
   card to restrict it to the parent controller's vector. This is anyway what has to
   happen, and this way, the card will still get the interrupt even if there is no
   irq routing on the machine.

Arguments:

   Pdo - Pointer to the device object representing the PC-Card which needs to be started
   Irp - IRP_MN_QUERY_RESOURCE_REQUIREMENTS Irp

Return value:

   status

--*/
{
   PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
   PFDO_EXTENSION fdoExtension = pdoExtension->Socket->DeviceExtension;
   NTSTATUS       status;
   ULONG          index1, index2;
   PIO_RESOURCE_REQUIREMENTS_LIST IoReqList;
   PIO_RESOURCE_LIST   ioResourceList;
   PIO_RESOURCE_DESCRIPTOR ioResourceDesc;
   
   PAGED_CODE();

   PcmciaUpdateInterruptLine(pdoExtension, fdoExtension);
   //
   // First pass the irp down the stack 
   //
   status = PcmciaIoCallDriverSynchronous(pdoExtension->LowerDevice, Irp);

   IoReqList = (PIO_RESOURCE_REQUIREMENTS_LIST) Irp->IoStatus.Information;
   
   if (!NT_SUCCESS(status) ||
       (IoReqList == NULL) ||
       (fdoExtension->Configuration.Interrupt.u.Interrupt.Vector == 0)) {
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
      return status;
   }

   //
   // Change interrupt descriptors to specifically request the parent vector
   //
   for (index1 = 0, ioResourceList = IoReqList->List;
       index1 < IoReqList->AlternativeLists; index1++) {
      ioResourceDesc = ioResourceList->Descriptors;
      
      for (index2 = 0 ; index2 < ioResourceList->Count; index2++, ioResourceDesc++) {
         if (ioResourceDesc->Type == CmResourceTypeInterrupt) {
            //
            // Cardbus cards by design use the same irq as the parent bus controller
            //         
            ioResourceDesc->u.Interrupt.MinimumVector = fdoExtension->Configuration.Interrupt.u.Interrupt.Vector;
            ioResourceDesc->u.Interrupt.MaximumVector = fdoExtension->Configuration.Interrupt.u.Interrupt.Vector;
         }
      }

      ioResourceList = (PIO_RESOURCE_LIST) (((PUCHAR) ioResourceList) +
                                            sizeof(IO_RESOURCE_LIST) +
                                            (ioResourceList->Count - 1)* sizeof(IO_RESOURCE_DESCRIPTOR));
   } // outer for loop
   
   Irp->IoStatus.Status = status;
   IoCompleteRequest(Irp, IO_NO_INCREMENT);
   return status;
}   



NTSTATUS
PcmciaQueryCardBusCardCapabilities(
   IN PDEVICE_OBJECT Pdo,
   IN PIRP           Irp
   )
/*++

Routine Description:

   Obtains the device capabilities of the given pc-card.

   If the pc-card is an R2 card (16-bit pc-card), the capabilities
   are constructed from the parent PCMCIA controller's capabilities.
   If it's a cardbus card, the capabilities are obtained from the underlying
   PCI pdo for the card.
   Finally the obtained capabilities are cached in the pc-card's device
   extension for use in power management of the card.

Arguments:

   Pdo   -    Pointer to the device object for the pc-card
   Irp   -    Pointer to the query device capabilities Irp

Return Value:

   STATUS_SUCCESS                   - Capabilities obtained and recorded in the passed in pointer
   STATUS_INSUFFICIENT_RESOURCES    - Could not allocate memory to cache the capabilities

--*/
{
   PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
   NTSTATUS status;

   PAGED_CODE();

   //
   // CardBus card. Get the capabilities from PCI
   //

   status = PcmciaIoCallDriverSynchronous(pdoExtension->LowerDevice, Irp);
   
   if (NT_SUCCESS(status)) {
      PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
      PDEVICE_CAPABILITIES capabilities = irpStack->Parameters.DeviceCapabilities.Capabilities;
      
      //
      // Filter the capabilities: we need to set Removable true
      // since this is a pc-card (PCI doesn't know the difference)
      //
      capabilities->Removable = TRUE;
//********************************
// NOTE: HACKHACK
// This is temporary code only to get cardbus wake-on-lan up and running. Here
// we check to see if this has only been marked as a "can't wake" device by
// pci because it said it could wake from D3Hot, but not from D3Cold.
//********************************

      if (capabilities->DeviceWake <= PowerDeviceD0) {
         UCHAR capptr;
         ULONG powercaps;
     
         GetPciConfigSpace(pdoExtension, CBCFG_CAPPTR, &capptr, sizeof(capptr));
         if (capptr) {
            GetPciConfigSpace(pdoExtension, capptr, &powercaps, sizeof(powercaps));
           
            if (((powercaps & 0xff) == 1) && ((powercaps&0x40000000) && !(powercaps&0x80000000))) {
               capabilities->DeviceWake = PowerDeviceD3;
               capabilities->SystemWake = PowerSystemSleeping3;
               capabilities->WakeFromD3 = 1;
            }
         }
      }

      if (capabilities->SystemWake > PowerSystemSleeping3) {
         capabilities->SystemWake = PowerSystemSleeping3;
      }
//********************************
// END HACK
//********************************   
      
      //
      // Store these capabilities away..
      //
      RtlCopyMemory(&pdoExtension->DeviceCapabilities,
                    capabilities,
                    sizeof(DEVICE_CAPABILITIES));
   } else {
   
      RtlZeroMemory(&pdoExtension->DeviceCapabilities, sizeof(DEVICE_CAPABILITIES));   
      
   }

   Irp->IoStatus.Status = status;
   IoCompleteRequest(Irp, IO_NO_INCREMENT);
   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\pcmcibus\registry.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    registry.c

Abstract:

    This module contains the code that manipulates the ARC firmware
    tree and other elements in the registry.

Author:

    Bob Rinne
    Ravisankar Pudipeddi (ravisp) 1 Dec 1996
    Neil Sandlin (neilsa) June 1 1999    

Environment:

    Kernel mode

Revision History :


--*/

#include "pch.h"

//
// Internal References
//

VOID
PcmciaGetRegistryContextRange(
   IN HANDLE instanceHandle,
   IN PCWSTR Name,
   IN OPTIONAL const PCMCIA_CONTEXT_RANGE IncludeRange[], 
   IN OPTIONAL const PCMCIA_CONTEXT_RANGE ExcludeRange[], 
   OUT PPCMCIA_CONTEXT pContext
   );

ULONG
PcmciaGetDetectedFdoIrqMask(
   IN PFDO_EXTENSION FdoExtension
   );
   
NTSTATUS
PcmciaScanHardwareDescription(
   VOID
   );
                              
NTSTATUS
PcmciaGetHardwareDetectedIrqMask(
   IN HANDLE handlePcCard
   );
                         
//
//
// Registry related definitions
//
#define PCMCIA_REGISTRY_PARAMETERS_KEY              L"Pcmcia\\Parameters"
#define PCMCIA_REGISTRY_DETECTED_DEVICE_KEY         L"ControllerProperties"


//
// Per controller values (in control\class)
//

#define PCMCIA_REGISTRY_PCI_CONTEXT_VALUE  L"CBSSCSContextRanges"
#define PCMCIA_REGISTRY_CB_CONTEXT_VALUE   L"CBSSCBContextRanges"
#define PCMCIA_REGISTRY_EXCA_CONTEXT_VALUE L"CBSSEXCAContextRanges"
#define PCMCIA_REGISTRY_CACHED_IRQMASK     L"CachedIrqMask"
#define PCMCIA_REGISTRY_COMPATIBLE_TYPE    L"CompatibleControllerType"
#define PCMCIA_REGISTRY_VOLTAGE_PREFERENCE L"VoltagePreference"

//
// Irq detection values (in hardware\description)
//

#define PCMCIA_REGISTRY_CONTROLLER_TYPE    L"OtherController"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,PcmciaLoadGlobalRegistryValues)
#pragma alloc_text(INIT,PcmciaScanHardwareDescription)
#pragma alloc_text(INIT,PcmciaGetHardwareDetectedIrqMask)
#pragma alloc_text(PAGE,PcmciaGetControllerRegistrySettings)
#pragma alloc_text(PAGE,PcmciaGetRegistryFdoIrqMask)
#pragma alloc_text(PAGE,PcmciaGetDetectedFdoIrqMask)
#pragma alloc_text(PAGE,PcmciaGetLegacyDetectedControllerType)
#pragma alloc_text(PAGE,PcmciaSetLegacyDetectedControllerType)
#pragma alloc_text(PAGE,PcmciaGetRegistryContextRange)
#endif


NTSTATUS
PcmciaGetHardwareDetectedIrqMask(
   HANDLE handlePcCard
   )
/*++

Routine Description:

   This routine looks through the OtherController key for pccard entries
   created by NTDETECT. For each entry, the IRQ scan data is read in and
   saved for later.
   

Arguments:

   handlePcCard - open handle to "OtherController" key in registry at
                  HARDWARE\Description\System\MultifunctionAdapter\<ISA>

Return value:

   status

--*/
{
#define VALUE2_BUFFER_SIZE sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(CM_PCCARD_DEVICE_DATA) + sizeof(CM_FULL_RESOURCE_DESCRIPTOR)
   UCHAR valueBuffer[VALUE2_BUFFER_SIZE];
   PKEY_VALUE_PARTIAL_INFORMATION valueInfo = (PKEY_VALUE_PARTIAL_INFORMATION) valueBuffer;

   NTSTATUS          status;
   KEY_FULL_INFORMATION KeyFullInfo;
   PKEY_BASIC_INFORMATION subKeyInfo = NULL;
   OBJECT_ATTRIBUTES attributes;
   UNICODE_STRING    strSubKey = {0};
   UNICODE_STRING    strIdentifier;
   UNICODE_STRING    strConfigData;
   HANDLE            handleSubKey = NULL;
   ULONG             subKeyInfoSize;
   ULONG             index;
   ULONG             resultLength;
   
   RtlInitUnicodeString(&strIdentifier, L"Identifier");
   RtlInitUnicodeString(&strConfigData, L"Configuration Data");
   
   status = ZwQueryKey(handlePcCard,
                       KeyFullInformation,
                       &KeyFullInfo,
                       sizeof(KeyFullInfo),
                       &resultLength);
   
   if ((!NT_SUCCESS(status) && (status != STATUS_BUFFER_OVERFLOW))) {
      goto cleanup;
   }   

   strSubKey.MaximumLength = (USHORT) KeyFullInfo.MaxNameLen;
   subKeyInfoSize = sizeof(KEY_BASIC_INFORMATION) + KeyFullInfo.MaxNameLen;
   subKeyInfo = ExAllocatePool(PagedPool, subKeyInfoSize);
   
   if (!subKeyInfo) {
      goto cleanup;
   }
   
   for (index=0;;index++) {
   
      //
      // Loop through the children of the PcCardController key
      //
   
      status = ZwEnumerateKey(handlePcCard,
                              index,
                              KeyBasicInformation,
                              subKeyInfo,
                              subKeyInfoSize,
                              &resultLength);

      if (!NT_SUCCESS(status)) {
         goto cleanup;
      }

      //
      // Init the name
      //

      if (subKeyInfo->NameLength > strSubKey.MaximumLength) {
         continue;
      }      
      strSubKey.Length = (USHORT) subKeyInfo->NameLength;
      strSubKey.Buffer = subKeyInfo->Name;
   
      //
      // Get a handle to a child of PcCardController
      //
   
      
      InitializeObjectAttributes(&attributes,
                                 &strSubKey,
                                 0,   //Attributes
                                 handlePcCard,
                                 NULL //SecurityDescriptor
                                 );
   
      if (handleSubKey) {
         // close handle from previous iteration
         ZwClose(handleSubKey);
         handleSubKey = NULL;
      }
      
      status = ZwOpenKey(&handleSubKey, MAXIMUM_ALLOWED, &attributes);
   
      if (!NT_SUCCESS(status)) {
         goto cleanup;
      }

      //
      // Get the value of "Identifier"
      //
 
      status = ZwQueryValueKey(handleSubKey,
                               &strIdentifier,
                               KeyValuePartialInformation,
                               valueInfo,
                               VALUE2_BUFFER_SIZE,
                               &resultLength);
      
      
      if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW)) {
         PWCHAR pData = (PWCHAR)valueInfo->Data;
      
         if ((valueInfo->DataLength == 17*sizeof(WCHAR)) &&
            (pData[0] == (WCHAR)'P') &&
            (pData[1] == (WCHAR)'c') &&
            (pData[2] == (WCHAR)'C') &&
            (pData[3] == (WCHAR)'a') &&
            (pData[4] == (WCHAR)'r') &&
            (pData[5] == (WCHAR)'d')) {
            
            //
            // Get the IRQ detection data
            //
            status = ZwQueryValueKey(handleSubKey,
                                     &strConfigData,
                                     KeyValuePartialInformation,
                                     valueInfo,
                                     VALUE2_BUFFER_SIZE,
                                     &resultLength);
           
            if (NT_SUCCESS(status)) {   
               PCM_FULL_RESOURCE_DESCRIPTOR pFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR) valueInfo->Data;
               PCM_PARTIAL_RESOURCE_DESCRIPTOR pPartialDesc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) pFullDesc->PartialResourceList.PartialDescriptors;

               if ((pPartialDesc->Type == CmResourceTypeDeviceSpecific) &&
                   (pPartialDesc->u.DeviceSpecificData.DataSize == sizeof(CM_PCCARD_DEVICE_DATA))) {
                   
                  PCM_PCCARD_DEVICE_DATA pData = (PCM_PCCARD_DEVICE_DATA) ((ULONG_PTR)&pPartialDesc->u.DeviceSpecificData + 3*sizeof(ULONG));
                  PPCMCIA_NTDETECT_DATA pNewData;
                  
                  pNewData = ExAllocatePool(PagedPool, sizeof(PCMCIA_NTDETECT_DATA));
                  
                  if (pNewData == NULL) {
                     goto cleanup;
                  }

                  pNewData->PcCardData = *pData;
                  pNewData->Next = pNtDetectDataList;
                  pNtDetectDataList = pNewData;

               }
            }
         }
      }
 
   }
cleanup:
   if (handleSubKey) {
      ZwClose(handleSubKey);
   }
   
   if (subKeyInfo) {
      ExFreePool(subKeyInfo);
   }
   return STATUS_SUCCESS;      
}



ULONG
PcmciaGetDetectedFdoIrqMask(
   IN PFDO_EXTENSION FdoExtension
   )
/*++

Routine Description:

   This routine looks through the cached PCMCIA_NTDETECT_DATA entries
   to see if there was an entry for this controller. It then returns the
   detected irq mask for that controller.

Arguments:

   FdoExtension - The fdo extension corresponding to the PCMCIA controller

Return value:

   status

--*/
{

   PPCMCIA_NTDETECT_DATA pData;
   PCM_PCCARD_DEVICE_DATA pPcCardData;
   ULONG detectedIrqMask = 0;
   
   if (FdoExtension->SocketList == NULL) {
      return 0;
   }

   for (pData = pNtDetectDataList; pData != NULL; pData = pData->Next) {

      pPcCardData = &pData->PcCardData;      

      
      if (CardBusExtension(FdoExtension)) {

         if (!(pPcCardData->Flags & PCCARD_DEVICE_PCI) || ((pPcCardData->BusData) == 0) ||
             ((pPcCardData->BusData & 0xff) != FdoExtension->PciBusNumber) ||
             (((pPcCardData->BusData >> 8) & 0xff) != FdoExtension->PciDeviceNumber)) {
            continue;
         }                  
         
         SetFdoFlag(FdoExtension, PCMCIA_FDO_IRQ_DETECT_DEVICE_FOUND);
         
         if (!(pPcCardData->Flags & PCCARD_MAP_ERROR)) {
            //
            // we found the device, and the map looks good
            //
            break;
         }
         
      } else {
      
         if ((pPcCardData->Flags & PCCARD_DEVICE_PCI) ||
            (pPcCardData->LegacyBaseAddress != (ULONG_PTR)FdoExtension->SocketList->AddressPort)) {
            continue;
         }
         
         SetFdoFlag(FdoExtension, PCMCIA_FDO_IRQ_DETECT_DEVICE_FOUND);
         
         if (!(pPcCardData->Flags & PCCARD_MAP_ERROR)) {
            //
            // we found the device, and the map looks good
            //
            break;
         }
         
      }
   }      
   
   if (pData) {
      ULONG i;
      //
      // Found the entry
      //
      // Since we don't currently handle "rewired" irqs, we can compact
      // it down to a bit mask, throwing away irqs that are wired, say
      // IRQ12 on the controller to IRQ15 on the isa bus.
      //

      for (i = 1; i < 16; i++) {
         if (pPcCardData->IRQMap[i] == i) {
            detectedIrqMask |= (1<<i);
         }
      }               
      SetFdoFlag(FdoExtension, PCMCIA_FDO_IRQ_DETECT_COMPLETED);
   }
   return detectedIrqMask;
}



NTSTATUS
PcmciaScanHardwareDescription(
   VOID
   )
/*++

Routine Description:

   This routine finds the "OtherController" entry in
   HARDWARE\Description\System\MultifunctionAdapter\<ISA>. This is
   where NTDETECT stores irq scan results.
   
   It also looks for machines that aren't supported, for example MCA
   bus.

Arguments:

Return value:

   status

--*/
{
#define VALUE_BUFFER_SIZE sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 3*sizeof(WCHAR)

   UCHAR valueBuffer[VALUE_BUFFER_SIZE];
   PKEY_VALUE_PARTIAL_INFORMATION valueInfo = (PKEY_VALUE_PARTIAL_INFORMATION) valueBuffer;
   PKEY_BASIC_INFORMATION subKeyInfo = NULL;
   KEY_FULL_INFORMATION KeyFullInfo;
   
   HANDLE            handleRoot = NULL;
   HANDLE            handleSubKey = NULL;
   HANDLE            handlePcCard = NULL;
   UNICODE_STRING    strRoot, strIdentifier;
   UNICODE_STRING    strSubKey = {0};
   UNICODE_STRING    strPcCard = {0};
   NTSTATUS          status;
   OBJECT_ATTRIBUTES attributes;
   ULONG             subKeyInfoSize;
   ULONG             resultLength;
   ULONG             index;
   
   PAGED_CODE();

   //
   // Get a handle to the MultifunctionAdapter key
   //

   RtlInitUnicodeString(&strRoot, L"\\Registry\\MACHINE\\HARDWARE\\DESCRIPTION\\System\\MultiFunctionAdapter");
   RtlInitUnicodeString(&strIdentifier, L"Identifier");
   RtlInitUnicodeString(&strPcCard, PCMCIA_REGISTRY_CONTROLLER_TYPE);
   
   InitializeObjectAttributes(&attributes,
                              &strRoot,
                              OBJ_CASE_INSENSITIVE,
                              NULL,
                              NULL);

   status = ZwOpenKey(&handleRoot, MAXIMUM_ALLOWED, &attributes);

   if (!NT_SUCCESS(status)) {
      goto cleanup;
   }   

   status = ZwQueryKey(handleRoot,
                       KeyFullInformation,
                       &KeyFullInfo,
                       sizeof(KeyFullInfo),
                       &resultLength);
   
   if ((!NT_SUCCESS(status) && (status != STATUS_BUFFER_OVERFLOW))) {
      goto cleanup;
   }   

   strSubKey.MaximumLength = (USHORT) KeyFullInfo.MaxNameLen;
   subKeyInfoSize = sizeof(KEY_BASIC_INFORMATION) + KeyFullInfo.MaxNameLen;
   subKeyInfo = ExAllocatePool(PagedPool, subKeyInfoSize);
   
   if (!subKeyInfo) {
      goto cleanup;
   }
   
   for (index=0;;index++) {
   
      //
      // Loop through the children of "MultifunctionAdapter"
      //
   
      status = ZwEnumerateKey(handleRoot,
                              index,
                              KeyBasicInformation,
                              subKeyInfo,
                              subKeyInfoSize,
                              &resultLength);

      if (!NT_SUCCESS(status)) {
         goto cleanup;
      }

      //
      // Init the name
      //

      if (subKeyInfo->NameLength > strSubKey.MaximumLength) {
         continue;
      }      
      strSubKey.Length = (USHORT) subKeyInfo->NameLength;
      strSubKey.Buffer = subKeyInfo->Name;
   
      //
      // Get a handle to a child of MultifunctionAdapter
      //
   
      
      InitializeObjectAttributes(&attributes,
                                 &strSubKey,
                                 0,   //Attributes
                                 handleRoot,
                                 NULL //SecurityDescriptor
                                 );
   
      if (handleSubKey) {
         // close handle from previous iteration
         ZwClose(handleSubKey);
         handleSubKey = NULL;
      }
      
      status = ZwOpenKey(&handleSubKey, MAXIMUM_ALLOWED, &attributes);
   
      if (!NT_SUCCESS(status)) {
         goto cleanup;
      }

      //
      // Get the value of "Identifier"
      //
 
      status = ZwQueryValueKey(handleSubKey,
                               &strIdentifier,
                               KeyValuePartialInformation,
                               valueInfo,
                               VALUE_BUFFER_SIZE,
                               &resultLength);
      
      
      if (NT_SUCCESS(status)) {
         PWCHAR pData = (PWCHAR)valueInfo->Data;
      
         if ((valueInfo->DataLength == 4*sizeof(WCHAR)) &&
            (pData[0] == (WCHAR)'M') &&
            (pData[1] == (WCHAR)'C') &&
            (pData[2] == (WCHAR)'A') &&
            (pData[3] == UNICODE_NULL)) {
            status = STATUS_NO_SUCH_DEVICE;
            goto cleanup;
         }
         
         if ((valueInfo->DataLength == 4*sizeof(WCHAR)) &&
            (pData[0] == (WCHAR)'I') &&
            (pData[1] == (WCHAR)'S') &&
            (pData[2] == (WCHAR)'A') &&
            (pData[3] == UNICODE_NULL)) {

            InitializeObjectAttributes(&attributes,
                                       &strPcCard,
                                       0,   //Attributes
                                       handleSubKey,
                                       NULL //SecurityDescriptor
                                       );
                  
            status = ZwOpenKey(&handlePcCard, MAXIMUM_ALLOWED, &attributes);
            
            if (NT_SUCCESS(status)) {
            
               status = PcmciaGetHardwareDetectedIrqMask(handlePcCard);
               ZwClose(handlePcCard);
            }               
         }
      }
   }
   
cleanup:
   if (handleRoot) {
      ZwClose(handleRoot);
   }

   if (handleSubKey) {
      ZwClose(handleSubKey);
   }
   
   if (subKeyInfo) {
      ExFreePool(subKeyInfo);
   }

   if (status == STATUS_NO_SUCH_DEVICE) {      
      //
      // Must be an MCA machine
      //
      return status;
   }
   return STATUS_SUCCESS;      
}   



NTSTATUS
PcmciaLoadGlobalRegistryValues(
   VOID
   )
/*++

Routine Description:

   This routine is called at driver init time to load in various global
   options from the registry.
   These are read in from SYSTEM\CurrentControlSet\Services\Pcmcia\Parameters.

Arguments:

   none

Return value:

   none

--*/
{
   PRTL_QUERY_REGISTRY_TABLE parms;
   NTSTATUS                  status;
   ULONG                     parmsSize;
   ULONG i;
   
   status = PcmciaScanHardwareDescription();
   
   if (!NT_SUCCESS(status)) {
      return status;
   }

   //
   // Needs a null entry to terminate the list
   //   

   parmsSize = sizeof(RTL_QUERY_REGISTRY_TABLE) * (GlobalInfoCount+1);

   parms = ExAllocatePool(PagedPool, parmsSize);

   if (!parms) {
       return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(parms, parmsSize);

   //
   // Fill in the query table from our table
   //

   for (i = 0; i < GlobalInfoCount; i++) {
      parms[i].Flags         = RTL_QUERY_REGISTRY_DIRECT;
      parms[i].Name          = GlobalRegistryInfo[i].Name;
      parms[i].EntryContext  = GlobalRegistryInfo[i].pValue;
      parms[i].DefaultType   = REG_DWORD;
      parms[i].DefaultData   = &GlobalRegistryInfo[i].Default;
      parms[i].DefaultLength = sizeof(ULONG);
   }      

   //
   // Perform the query
   //

   status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES | RTL_REGISTRY_OPTIONAL,
                                   PCMCIA_REGISTRY_PARAMETERS_KEY,
                                   parms,
                                   NULL,
                                   NULL);

   if (!NT_SUCCESS(status)) {
       //
       // This is possible during text mode setup
       //
       
       for (i = 0; i < GlobalInfoCount; i++) {
          *GlobalRegistryInfo[i].pValue = GlobalRegistryInfo[i].Default;
       }      
   }
   
   if (initSoundsEnabled) {
       PcmciaGlobalFlags |= PCMCIA_GLOBAL_SOUNDS_ENABLED;
   }

   if (initUsePolledCsc) {
       PcmciaGlobalFlags |= PCMCIA_GLOBAL_FORCE_POLL_MODE;
   }

   if (initDisableAcpiNameSpaceCheck) {
       PcmciaGlobalFlags |= PCMCIA_DISABLE_ACPI_NAMESPACE_CHECK;
   }

   if (initDefaultRouteR2ToIsa) {
       PcmciaGlobalFlags |= PCMCIA_DEFAULT_ROUTE_R2_TO_ISA;
   }

   if (!pcmciaIsaIrqRescanComplete) {
      UNICODE_STRING    unicodeKey, unicodeValue;
      OBJECT_ATTRIBUTES objectAttributes;      
      HANDLE            handle;
      ULONG             value;

      //
      // This mechanism is used to throw away the cached ISA irq map values. To do this
      // only once, we make sure a value in the registry is zero (or non-existant), and
      // here we set it to one.
      //
      
      RtlInitUnicodeString(&unicodeKey,
                           L"\\Registry\\MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Pcmcia\\Parameters");
      RtlZeroMemory(&objectAttributes, sizeof(OBJECT_ATTRIBUTES));
      InitializeObjectAttributes(&objectAttributes,
                                 &unicodeKey,
                                 OBJ_CASE_INSENSITIVE,
                                 NULL,
                                 NULL);
     
      if (NT_SUCCESS(ZwOpenKey(&handle, KEY_READ | KEY_WRITE, &objectAttributes))) {

         RtlInitUnicodeString(&unicodeValue, PCMCIA_REGISTRY_ISA_IRQ_RESCAN_COMPLETE);      
         value = 1;
            
         ZwSetValueKey(handle,
                       &unicodeValue,
                       0,
                       REG_DWORD,
                       &value,
                       sizeof(value));

         ZwClose(handle);                       
      }
   
   }

   ExFreePool(parms);
   
   return STATUS_SUCCESS;
}



NTSTATUS
PcmciaGetControllerRegistrySettings(
   IN OUT PFDO_EXTENSION FdoExtension
   )
/*++

Routine Description:

   This routine looks in the registry to see if a compatible controller type
   was specified in the INF.

Arguments:

   FdoExtension - The fdo extension corresponding to the PCMCIA controller
   
Return value:

--*/
{
   NTSTATUS status = STATUS_UNSUCCESSFUL;
   UNICODE_STRING    KeyName;
   HANDLE instanceHandle;
   UCHAR             buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG)];
   PKEY_VALUE_PARTIAL_INFORMATION value = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
   ULONG             length;
   BOOLEAN           UseLegacyIrqMask = TRUE;
   ULONG             detectedIrqMask;

   if (FdoExtension->Pdo) {   
      status = IoOpenDeviceRegistryKey(FdoExtension->Pdo,
                                       PLUGPLAY_REGKEY_DRIVER,
                                       KEY_READ,
                                       &instanceHandle
                                       );
   }

   if (!NT_SUCCESS(status)) {
      instanceHandle = NULL;
   }
                                          
   if (instanceHandle) {

      //
      // Look to see if a controller ID was specified
      //
      RtlInitUnicodeString(&KeyName, PCMCIA_REGISTRY_COMPATIBLE_TYPE);
      
      status =  ZwQueryValueKey(instanceHandle,
                                &KeyName,
                                KeyValuePartialInformation,
                                value,
                                sizeof(buffer),
                                &length);
      
      
      if (NT_SUCCESS(status)) {
         PcmciaSetControllerType(FdoExtension, *(PPCMCIA_CONTROLLER_TYPE)(value->Data));
      }
      
      //
      // Check for voltage preference
      // When an 3v R2 card is plugged in, and the controller
      // sets both 5v and 3.3v, this allows 3.3v to be preferred.
      //
      RtlInitUnicodeString(&KeyName, PCMCIA_REGISTRY_VOLTAGE_PREFERENCE);
      
      status =  ZwQueryValueKey(instanceHandle,
                                &KeyName,
                                KeyValuePartialInformation,
                                value,
                                sizeof(buffer),
                                &length);
      
      
      if (NT_SUCCESS(status) && (*(PULONG)(value->Data) == 33)) {
         SetDeviceFlag(FdoExtension, PCMCIA_FDO_PREFER_3V);
      }
   }      
         
   //
   // Retrieve context ranges 
   //
   
   PcmciaGetRegistryContextRange(instanceHandle,
                                 PCMCIA_REGISTRY_PCI_CONTEXT_VALUE,
                                 DefaultPciContextSave,
                                 NULL,
                                 &FdoExtension->PciContext
                                 );
   
   PcmciaGetRegistryContextRange(instanceHandle,
                                 PCMCIA_REGISTRY_CB_CONTEXT_VALUE,
                                 DefaultCardbusContextSave,
                                 ExcludeCardbusContextRange,
                                 &FdoExtension->CardbusContext
                                 );
                                          
   PcmciaGetRegistryContextRange(instanceHandle,
                                 PCMCIA_REGISTRY_EXCA_CONTEXT_VALUE,
                                 NULL,
                                 NULL,
                                 &FdoExtension->ExcaContext);
   

   if (instanceHandle) {
      ZwClose(instanceHandle);
   }


   FdoExtension->IoLow               =  globalIoLow;
   FdoExtension->IoHigh              =  globalIoHigh;
   FdoExtension->ReadyDelayIter      =  globalReadyDelayIter;
   FdoExtension->ReadyStall          =  globalReadyStall;
   FdoExtension->AttributeMemoryLow  =  globalAttributeMemoryLow;
   FdoExtension->AttributeMemoryHigh =  globalAttributeMemoryHigh;
   
   if (FdoExtension->ControllerType == PcmciaDatabook) {
      FdoExtension->AttributeMemoryAlignment = TCIC_WINDOW_ALIGNMENT;
   } else {
      FdoExtension->AttributeMemoryAlignment = PCIC_WINDOW_ALIGNMENT;
   }      
      
   //
   // Assign default attribute memory window size
   //
   
   if (globalAttributeMemorySize == 0) {
      switch (FdoExtension->ControllerType) {
     
      case PcmciaDatabook:
           FdoExtension->AttributeMemorySize = TCIC_WINDOW_SIZE;
           break;
      default: 
           FdoExtension->AttributeMemorySize = PCIC_WINDOW_SIZE;
           break;
      }
   } else {
      FdoExtension->AttributeMemorySize = globalAttributeMemorySize;
   }

   //
   // See if the user asked for some special IRQ routing considerations based
   // on controller type
   //

   if (CardBusExtension(FdoExtension)) {

      //
      // route to PCI based on controller type
      //
         
      if (pcmciaIrqRouteToPciController) {
         ULONG ctlr = pcmciaIrqRouteToPciController;

         //
         // Check for exact match, or class if only a class was specified
         //
         if ((ctlr == FdoExtension->ControllerType) ||
             ((PcmciaClassFromControllerType(ctlr) == ctlr) && (ctlr == PcmciaClassFromControllerType(FdoExtension->ControllerType)))) {
             
            SetFdoFlag(FdoExtension, PCMCIA_FDO_PREFER_PCI_ROUTING);
         }
      }         
      
      //
      // route to ISA based on controller type
      //
      
      if (pcmciaIrqRouteToIsaController) {
         ULONG ctlr = pcmciaIrqRouteToIsaController;
      
         //
         // Check for exact match, or class if only a class was specified
         //
         if ((ctlr == FdoExtension->ControllerType) ||
             ((PcmciaClassFromControllerType(ctlr) == ctlr) && (ctlr == PcmciaClassFromControllerType(FdoExtension->ControllerType)))) {
     
            SetFdoFlag(FdoExtension, PCMCIA_FDO_PREFER_ISA_ROUTING);
         }
      }         

      //
      // route to PCI based on controller location
      //
         
      if (pcmciaIrqRouteToPciLocation) {
         ULONG loc = pcmciaIrqRouteToPciLocation;
      
         if ( ((loc & 0xff) == FdoExtension->PciBusNumber) &&
              (((loc >> 8) & 0xff) == FdoExtension->PciDeviceNumber)) {
              
            SetFdoFlag(FdoExtension, PCMCIA_FDO_FORCE_PCI_ROUTING);
         }
      }         
      
      //
      // route to ISA based on controller location
      //
         
      if (pcmciaIrqRouteToIsaLocation) {
         ULONG loc = pcmciaIrqRouteToIsaLocation;
      
         if ( ((loc & 0xff) == FdoExtension->PciBusNumber) &&
              (((loc >> 8) & 0xff) == FdoExtension->PciDeviceNumber)) {
              
            SetFdoFlag(FdoExtension, PCMCIA_FDO_FORCE_ISA_ROUTING);
         }
      }         
      
   }         

    
   return status;
}

   

VOID
PcmciaGetRegistryFdoIrqMask(
   IN OUT PFDO_EXTENSION FdoExtension
   )
/*++

Routine Description:

   This routine fills in the field "AllocatedIrqMask" in the specified
   fdo extension. 

Arguments:

   instanceHandle - open registry key for this controller
   pIrqMask       - pointer to variable to receive irq mask

Return value:

   none

--*/
{
   ULONG             irqMask, cachedIrqMask = 0;
   UNICODE_STRING    KeyName;
   NTSTATUS          status;
   UCHAR             buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG)];
   PKEY_VALUE_PARTIAL_INFORMATION value = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
   ULONG             length;
   HANDLE            instanceHandle;
   ULONG             detectedIrqMask;
   
   PAGED_CODE();
   
   if (globalOverrideIrqMask) {   
   
      irqMask = globalOverrideIrqMask;
      
   } else {

      detectedIrqMask = PcmciaGetDetectedFdoIrqMask(FdoExtension);
      
      status = STATUS_UNSUCCESSFUL;
      
      if (FdoExtension->Pdo) {   
         status = IoOpenDeviceRegistryKey(FdoExtension->Pdo,
                                       PLUGPLAY_REGKEY_DRIVER,
                                       KEY_READ,
                                       &instanceHandle
                                       );
      }
                                             
      if (NT_SUCCESS(status)) {
         //
         // Here we cache the value, and accumulate bits so that
         // our mask improves with time.
         //
         RtlInitUnicodeString(&KeyName, PCMCIA_REGISTRY_CACHED_IRQMASK);

         if (pcmciaIsaIrqRescanComplete) {      
            status =  ZwQueryValueKey(instanceHandle,
                                      &KeyName,
                                      KeyValuePartialInformation,
                                      value,
                                      sizeof(buffer),
                                      &length);
           
            
            if (NT_SUCCESS(status)) {
               cachedIrqMask = *(PULONG)(value->Data);
            }
         }            
         
         irqMask = detectedIrqMask | cachedIrqMask;
         
         if ((cachedIrqMask != irqMask) || !pcmciaIsaIrqRescanComplete) {
            //
            // something changed, update the cached value
            //
            ZwSetValueKey(instanceHandle, &KeyName, 0, REG_DWORD, &irqMask, sizeof(irqMask));
         }

         ZwClose(instanceHandle);
      } else {
         //
         // Hmmm, no key. Can't cache the value
         //
         irqMask = detectedIrqMask;
      }         

      if (pcmciaDisableIsaPciRouting && (PcmciaCountOnes(irqMask) < 2)) {
         //
         // Perhaps irq detection is broken... fall back on old NT4 behavior
         //   
         irqMask = 0;
      }
   }

   irqMask &= ~globalFilterIrqMask;

   DebugPrint((PCMCIA_DEBUG_INFO, "IrqMask %08x (ovr %08x, flt %08x, det %08x, cache %08x)\n",
                    irqMask, globalOverrideIrqMask, globalFilterIrqMask, detectedIrqMask, cachedIrqMask));
                    
   FdoExtension->DetectedIrqMask = (USHORT)irqMask;
}


VOID
PcmciaGetRegistryContextRange(
   IN HANDLE instanceHandle,
   IN PCWSTR Name,
   IN OPTIONAL const PCMCIA_CONTEXT_RANGE IncludeRange[], 
   IN OPTIONAL const PCMCIA_CONTEXT_RANGE ExcludeRange[], 
   OUT PPCMCIA_CONTEXT pContext
   )
/*++

Routine Description:

    This routine returns a buffer containing the contents of the
    data which set by the controller's inf definition (AddReg). The value
    is in CurrentControlSet\Control\Class\{GUID}\{Instance}.

Arguments:

    FdoExtension - The fdo extension corresponding to the PCMCIA controller
    Name         - The name of the value in the registry
    IncludeRange - defines areas in the range that must be included
    ExcludeRange - defines areas in the range that must be excluded

Return value:

    Status

--*/
{
#define PCMCIA_MAX_CONTEXT_ENTRIES 128
#define MAX_RANGE_OFFSET 256   

   NTSTATUS          status;
   UNICODE_STRING    unicodeKeyName;
   UCHAR             buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) +
                           PCMCIA_MAX_CONTEXT_ENTRIES*sizeof(PCMCIA_CONTEXT_RANGE)];
   PKEY_VALUE_PARTIAL_INFORMATION value = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
   UCHAR             rangeMap[MAX_RANGE_OFFSET] = {0};
   PPCMCIA_CONTEXT_RANGE newRange;
   LONG              rangeCount;
   ULONG             rangeLength;
   ULONG             bufferLength;
   UCHAR             lastEntry;
   ULONG             keyLength;
   USHORT            i, j;
   USHORT            startOffset, endOffset;

   PAGED_CODE();
   
   //
   // Initialize the range map with the minimum range
   //

   if (IncludeRange) {   
      for (i = 0; IncludeRange[i].wLen != 0; i++) {
      
         startOffset = IncludeRange[i].wOffset;
         endOffset   = IncludeRange[i].wOffset + IncludeRange[i].wLen - 1;
         
         if ((startOffset >= MAX_RANGE_OFFSET) ||
             (endOffset >= MAX_RANGE_OFFSET)) {
            continue;
         }
         
         for (j = startOffset; j <= endOffset; j++) {
            rangeMap[j] = 0xff;
         }
      }
   }
   

   if (instanceHandle) {   
      RtlInitUnicodeString(&unicodeKeyName, Name);
      
      status =  ZwQueryValueKey(instanceHandle,
                                &unicodeKeyName,
                                KeyValuePartialInformation,
                                value,
                                sizeof(buffer),
                                &keyLength);

   
      if (NT_SUCCESS(status)) {
      
         //
         // Merge in the range specified in the registry
         //
         newRange = (PPCMCIA_CONTEXT_RANGE) value->Data;
         for (i = 0; i < value->DataLength/sizeof(PCMCIA_CONTEXT_RANGE); i++) {
         
            startOffset = newRange[i].wOffset;
            endOffset   = newRange[i].wOffset + newRange[i].wLen - 1;
            
            if ((startOffset >= MAX_RANGE_OFFSET) ||
                (endOffset >= MAX_RANGE_OFFSET)) {
               continue;
            }
            
            for (j = startOffset; j <= endOffset; j++) {
               rangeMap[j] = 0xff;
            }
         }
      
      }
   }                              

   //
   // Filter out registers defined in the exclude range
   //

   if (ExcludeRange) {   
      for (i = 0; ExcludeRange[i].wLen != 0; i++) {
      
         startOffset = ExcludeRange[i].wOffset;
         endOffset   = ExcludeRange[i].wOffset + ExcludeRange[i].wLen - 1;
         
         if ((startOffset >= MAX_RANGE_OFFSET) ||
             (endOffset >= MAX_RANGE_OFFSET)) {
            continue;
         }
         
         for (j = startOffset; j <= endOffset; j++) {
            rangeMap[j] = 0;
         }
      }
   }
   

   //
   // Now build the resulting merged range in the buffer on the
   // stack, and figure out how big it is.
   //
   newRange = (PPCMCIA_CONTEXT_RANGE) buffer;
   rangeCount = -1;
   bufferLength = 0;
   lastEntry = 0;
   
   for (i = 0; i < MAX_RANGE_OFFSET; i++) {
   
      if (rangeMap[i]) {
         bufferLength++;
         if (lastEntry) {
            //
            // This new byte belongs to the current range
            //
            newRange[rangeCount].wLen++;
         } else {
            //
            // Starting a new range
            //
            if (rangeCount == (PCMCIA_MAX_CONTEXT_ENTRIES - 1)) {
               break;
            }
            rangeCount++;
            newRange[rangeCount].wOffset = i;
            newRange[rangeCount].wLen = 1;
         }                     
      
      } 
      lastEntry = rangeMap[i];
   }            
   rangeCount++;

   pContext->Range = NULL;
   pContext->RangeCount = 0;
   
   if (rangeCount) {
      //
      // Length of data
      //
      rangeLength = rangeCount*sizeof(PCMCIA_CONTEXT_RANGE);

      pContext->Range = ExAllocatePool(NonPagedPool, rangeLength);

      if (pContext->Range != NULL) {
         RtlCopyMemory(pContext->Range, buffer, rangeLength);
         pContext->RangeCount = (ULONG)rangeCount;
         pContext->BufferLength = bufferLength;

         //
         // Find the length of the longest individual range
         //         
         pContext->MaxLen = 0;
         for (i = 0; i < rangeCount; i++) {
            if (pContext->Range[i].wLen > pContext->MaxLen) {
               pContext->MaxLen = pContext->Range[i].wLen;
            }
         }
      } else {
         ASSERT(pContext->Range != NULL);
      }
   }      
}


NTSTATUS
PcmciaGetLegacyDetectedControllerType(
   IN PDEVICE_OBJECT Pdo,
   IN OUT PPCMCIA_CONTROLLER_TYPE ControllerType
   )
/*++

Routine Description:

    This routine returns the previously remembered controller type
    for the supplied pcmcia controller by poking in the registry
    at the appropriate places

Arguments:

    Pdo - The Physical device object corresponding to the PCMCIA controller
    ControllerType - pointer to the object in which the controller type will
                     be returned


Return value:

    Status

--*/
{
   NTSTATUS status;
   OBJECT_ATTRIBUTES objectAttributes;
   UNICODE_STRING    unicodeKeyName;
   HANDLE            instanceHandle=NULL;
   HANDLE            parametersHandle = NULL;
   RTL_QUERY_REGISTRY_TABLE queryTable[3];
   ULONG controllerType;
   ULONG invalid = 0xffffffff;
   

   PAGED_CODE();

   try {
      status = IoOpenDeviceRegistryKey(Pdo,
                                       PLUGPLAY_REGKEY_DEVICE,
                                       KEY_READ,
                                       &instanceHandle
                                      );
      if (!NT_SUCCESS(status)) {
         leave;
      }

      RtlInitUnicodeString(&unicodeKeyName, PCMCIA_REGISTRY_DETECTED_DEVICE_KEY);
      InitializeObjectAttributes(
                                &objectAttributes,
                                &unicodeKeyName,
                                OBJ_CASE_INSENSITIVE,
                                instanceHandle,
                                NULL);

      status = ZwOpenKey(&parametersHandle,
                         KEY_READ,
                         &objectAttributes);

      if (!NT_SUCCESS(status)) {
         leave;
      }


      RtlZeroMemory(queryTable, sizeof(queryTable));

      queryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
      queryTable[0].Name = L"ControllerType";
      queryTable[0].EntryContext = &controllerType;
      queryTable[0].DefaultType = REG_DWORD;
      queryTable[0].DefaultData = &invalid;
      queryTable[0].DefaultLength = sizeof(ULONG);

      status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                      (PWSTR) parametersHandle,
                                      queryTable,
                                      NULL,
                                      NULL);

      if (!NT_SUCCESS(status)) {
         leave;
      }
      
      if (controllerType == invalid) {
         *ControllerType = PcmciaIntelCompatible;
      } else {
         *ControllerType = (PCMCIA_CONTROLLER_TYPE) controllerType;
      }

   } finally {

      if (instanceHandle != NULL) {
         ZwClose(instanceHandle);
      }

      if (parametersHandle != NULL) {
         ZwClose(parametersHandle);
      }
   }

   return status;
}


NTSTATUS
PcmciaSetLegacyDetectedControllerType(
   IN PDEVICE_OBJECT Pdo,
   IN PCMCIA_CONTROLLER_TYPE ControllerType
   )
/*++

Routine Description:

    This routine 'remembers' - by setting a value in the registry -
    the type of the  pcmcia controller that has been legacy detected
    to be retrieved and used in subsequent boots - if legacy re-detection
    of the controller is not performed

Arguments:

    Pdo - The Physical device object corresponding to the PCMCIA controller
    DeviceExtension -  Device extension of the fdo corresponding to the
                       controller

Return value:

    Status

--*/
{
   HANDLE               instanceHandle;
   NTSTATUS             status;
   OBJECT_ATTRIBUTES    objectAttributes;
   HANDLE               parametersHandle;
   UNICODE_STRING       unicodeString;

   PAGED_CODE();

   //
   // Get a handle to the registry devnode for this pdo
   //

   status = IoOpenDeviceRegistryKey(Pdo,
                                    PLUGPLAY_REGKEY_DEVICE,
                                    KEY_CREATE_SUB_KEY,
                                    &instanceHandle);

   if (!NT_SUCCESS(status)) {
      return status;
   }


   //
   // Open or create a sub-key for this devnode to store
   // the information in
   //

   RtlInitUnicodeString(&unicodeString, PCMCIA_REGISTRY_DETECTED_DEVICE_KEY);

   InitializeObjectAttributes(&objectAttributes,
                              &unicodeString,
                              OBJ_CASE_INSENSITIVE,
                              instanceHandle,
                              NULL);

   status = ZwCreateKey(&parametersHandle,
                        KEY_SET_VALUE,
                        &objectAttributes,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        NULL);

   if (!NT_SUCCESS(status)) {
      ZwClose(instanceHandle);
      return status;
   }
   //
   // Set the controller type value in the registry
   //
   RtlInitUnicodeString(&unicodeString, L"ControllerType");
   status = ZwSetValueKey(parametersHandle,
                          &unicodeString,
                          0,
                          REG_DWORD,
                          &ControllerType,
                          sizeof(ControllerType));
   ZwClose(parametersHandle);
   ZwClose(instanceHandle);
   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\pcmcibus\pdopnp.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    pdopnp.c

Abstract:

    This module contains the code to handle
    the IRP_MJ_PNP dispatches for the PDOs
    enumerated by the PCMCIA bus driver


Authors:

    Ravisankar Pudipeddi (ravisp)
    Neil Sandlin (neilsa) 1-Jun-1999

Environment:

    Kernel mode only

Notes:

Revision History:

--*/

#include "pch.h"

//
// Internal References
//

NTSTATUS
PcmciaFilterPcCardResourceRequirements(
   IN  PPDO_EXTENSION DeviceExtension,
   IN  PIRP           Irp
   );
   
NTSTATUS
PcmciaFilterPcCardInterrupts(
   IN  PIO_RESOURCE_REQUIREMENTS_LIST   oldReqList,
   IN  ULONG IrqCount,
   IN  ULONG IrqMask,
   OUT PIO_RESOURCE_REQUIREMENTS_LIST * FilteredReqList,
   BOOLEAN RouteIsaToPci
   );
   
VOID
PcmciaCleanupSocketData(
   IN PSOCKET_DATA SocketData
   );

VOID
PcmciaCleanupSocketConfiguration(
   PPDO_EXTENSION pdoExtension
   );

NTSTATUS
PcmciaPdoDeviceCapabilities(
   IN PDEVICE_OBJECT Pdo,
   IN PIRP           Irp
   );
   
NTSTATUS
PcmciaGetPcCardResourceRequirements(
   IN PPDO_EXTENSION PdoExtension,
   PULONG_PTR        Information
   );

NTSTATUS
PcmciaConfigEntriesToResourceListChain(
   PPDO_EXTENSION pdoExtension,
   PCONFIG_LIST ConfigList,
   ULONG configCount,
   PPCMCIA_RESOURCE_CHAIN *ResListChainHead
   );

NTSTATUS
PcmciaMergeResourceChainToList(
   PPCMCIA_RESOURCE_CHAIN ResListChain,
   PIO_RESOURCE_REQUIREMENTS_LIST *GeneratedResourceRequirementsList
   );

VOID
PcmciaFreeResourceChain(
   PPCMCIA_RESOURCE_CHAIN ResListChain
   );
   
NTSTATUS
PcmciaStartPcCard(
   IN PDEVICE_OBJECT Pdo,
   IN PCM_RESOURCE_LIST AllocatedResources,
   IN OUT PIRP       Irp
   );
   
NTSTATUS
PcmciaStopPcCard(
   IN PDEVICE_OBJECT Pdo
   );

NTSTATUS
PcmciaRemovePcCard(
   IN PDEVICE_OBJECT Pdo,
   IN PIRP           Irp
   );

NTSTATUS
PcmciaMfEnumerateConfigurations(
   IN PPDO_EXTENSION PdoExtension,
   IN PSOCKET_DATA   socketData,
   PCONFIG_LIST      ConfigList,
   IN ULONG          Depth,
   PPCMCIA_RESOURCE_CHAIN *MfResListChain
   );

NTSTATUS
PcmciaMfGetResourceRequirements(
   IN PPDO_EXTENSION PdoExtension,
   PULONG_PTR        Information
   );

VOID
PcmciaMfBuildResourceMapInfo(
   IN PPDO_EXTENSION PdoExtension,
   PCONFIG_LIST      ConfigList,
   ULONG             ConfigCount
   );
   
BOOLEAN
PcmciaMfCheckForOverlappingRanges(
   PCONFIG_LIST ConfigList,
   LONG ConfigCount
   );
   
NTSTATUS
PcmciaPdoGetBusInformation(
   IN  PPDO_EXTENSION         PdoExtension,
   OUT PPNP_BUS_INFORMATION * BusInformation
   );

NTSTATUS
PcmciaQueryDeviceText(
   IN PDEVICE_OBJECT Pdo,
   IN OUT PIRP       Irp
   );
   
VOID
PcmciaPdoGetDeviceInfSettings(
   IN  PPDO_EXTENSION         PdoExtension
   );
   
VOID
PcmciaPdoSetDeviceIrqRouting(
   IN  PPDO_EXTENSION PdoExtension
   );

#ifdef ALLOC_PRAGMA
   #pragma alloc_text(PAGE,  PcmciaPdoPnpDispatch)
   #pragma alloc_text(PAGE,  PcmciaPdoGetDeviceInfSettings)
   #pragma alloc_text(PAGE,  PcmciaPdoSetDeviceIrqRouting)
   #pragma alloc_text(PAGE,  PcmciaFilterPcCardInterrupts)
   #pragma alloc_text(PAGE,  PcmciaFilterPcCardResourceRequirements)
   #pragma alloc_text(PAGE,  PcmciaQueryDeviceText)
   #pragma alloc_text(PAGE,  PcmciaGetPcCardResourceRequirements)
   #pragma alloc_text(PAGE,  PcmciaConfigEntriesToResourceListChain)
   #pragma alloc_text(PAGE,  PcmciaMergeResourceChainToList)
   #pragma alloc_text(PAGE,  PcmciaFreeResourceChain)
   #pragma alloc_text(PAGE,  PcmciaPdoGetBusInformation)   
   #pragma alloc_text(PAGE,  PcmciaStartPcCard)
   #pragma alloc_text(PAGE,  PcmciaStopPcCard)
   #pragma alloc_text(PAGE,  PcmciaRemovePcCard)
   #pragma alloc_text(PAGE,  PcmciaPdoDeviceCapabilities)
   #pragma alloc_text(PAGE,  PcmciaPdoDeviceControl)
   #pragma alloc_text(PAGE,  PcmciaPdoGetDeviceInfSettings)
   #pragma alloc_text(PAGE,  PcmciaMfGetResourceRequirements)
   #pragma alloc_text(PAGE,  PcmciaMfEnumerateConfigurations)
   #pragma alloc_text(PAGE,  PcmciaMfBuildResourceMapInfo)
   #pragma alloc_text(PAGE,  PcmciaMfCheckForOverlappingRanges)
#endif



NTSTATUS
PcmciaPdoPnpDispatch(
   IN PDEVICE_OBJECT Pdo,
   IN PIRP Irp
   )

/*++

Routine Description:

    This routine handles pnp requests
    for the PDOs.

Arguments:

    Pdo - pointer to the physical device object
    Irp - pointer to the io request packet

Return Value:

    status

--*/

{
   PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
   NTSTATUS status;

   PAGED_CODE();

   //
   // CardBus PnP Dispatch
   //

   if (IsCardBusCard(pdoExtension)) {           // 
      return PcmciaPdoCardBusPnPDispatch(Pdo, Irp);
   }
   
#if DBG
   if (irpStack->MinorFunction > IRP_MN_PNP_MAXIMUM_FUNCTION) {
      DebugPrint((PCMCIA_DEBUG_PNP, "pdo %08x irp %08x Unknown minor function %x\n",
                                     Pdo, Irp, irpStack->MinorFunction));
   } else {
      DebugPrint((PCMCIA_DEBUG_PNP, "pdo %08x irp %08x --> %s\n",
                    Pdo, Irp, PNP_IRP_STRING(irpStack->MinorFunction)));
   }
#endif

   //
   // 16-bit (R2) PcCard PnP Dispatch
   //
   switch (irpStack->MinorFunction) {

   case IRP_MN_START_DEVICE: {
         status = PcmciaStartPcCard(Pdo, irpStack->Parameters.StartDevice.AllocatedResources, Irp);
         PcmciaDoStartSound(pdoExtension->Socket, status);
         break;
      }

   case IRP_MN_QUERY_STOP_DEVICE:{
         status = STATUS_SUCCESS;
         break;
      }

   case IRP_MN_CANCEL_STOP_DEVICE:{
         status = STATUS_SUCCESS;
         break;
      }

   case IRP_MN_STOP_DEVICE: {
         status = PcmciaStopPcCard(Pdo);
         break;
      }

   case IRP_MN_QUERY_REMOVE_DEVICE:{
         status = STATUS_SUCCESS;
         break;
      }

   case IRP_MN_CANCEL_REMOVE_DEVICE:{
         status = STATUS_SUCCESS;
         break;
      }

   case IRP_MN_REMOVE_DEVICE: {
         status = PcmciaRemovePcCard(Pdo, Irp);
         break;
      }
   
   case IRP_MN_SURPRISE_REMOVAL: {

         PcmciaReleaseSocketPower(pdoExtension, NULL);   
         status = STATUS_SUCCESS;
         break;
      }

   case IRP_MN_QUERY_ID: {

         UNICODE_STRING unicodeId;

         status = Irp->IoStatus.Status;
         RtlInitUnicodeString(&unicodeId, NULL);

         switch (irpStack->Parameters.QueryId.IdType) {

         case BusQueryDeviceID: {
               DebugPrint((PCMCIA_DEBUG_INFO, " Device Id for pdo %x\n", Pdo));
               status = PcmciaGetDeviceId(Pdo, PCMCIA_MULTIFUNCTION_PARENT, &unicodeId);
               if (NT_SUCCESS(status)) {
                  Irp->IoStatus.Information = (ULONG_PTR) unicodeId.Buffer;
               }
               break;
            }

         case BusQueryInstanceID: {
               DebugPrint((PCMCIA_DEBUG_INFO, " Instance Id for pdo %x\n", Pdo));
               status = PcmciaGetInstanceId(Pdo, &unicodeId);
               if (NT_SUCCESS(status)) {
                  Irp->IoStatus.Information = (ULONG_PTR) unicodeId.Buffer;
               }
               break;
            }

         case BusQueryHardwareIDs: {
               DebugPrint((PCMCIA_DEBUG_INFO, " Hardware Ids for pdo %x\n", Pdo));
               status = PcmciaGetHardwareIds(Pdo, PCMCIA_MULTIFUNCTION_PARENT, &unicodeId);
               if (NT_SUCCESS(status)) {
                  Irp->IoStatus.Information = (ULONG_PTR) unicodeId.Buffer;
               }
               break;
            }

         case BusQueryCompatibleIDs: {
               DebugPrint((PCMCIA_DEBUG_INFO, " Compatible Ids for pdo %x\n", Pdo));
               status = PcmciaGetCompatibleIds( Pdo, PCMCIA_MULTIFUNCTION_PARENT, &unicodeId);
               if (NT_SUCCESS(status)) {
                  Irp->IoStatus.Information = (ULONG_PTR) unicodeId.Buffer;
               }
               break;
            }
         }
         break;
      }


   case IRP_MN_QUERY_RESOURCE_REQUIREMENTS: {
         //
         // PcmciaGetPcCardResourceRequirements will
         // allocate storage for the resource requirements which will be released
         // by the OS.
         //
         Irp->IoStatus.Information = 0;
         
         PcmciaPdoGetDeviceInfSettings(pdoExtension);
         PcmciaPdoSetDeviceIrqRouting(pdoExtension);

         if (IsDeviceMultifunction(pdoExtension)) {
            status = PcmciaMfGetResourceRequirements(pdoExtension,
                                                     &Irp->IoStatus.Information);
         } else {
            status = PcmciaGetPcCardResourceRequirements(pdoExtension,
                                                     &Irp->IoStatus.Information);
         }
         break;
      }

   case IRP_MN_WRITE_CONFIG:
   case IRP_MN_READ_CONFIG: {
         PFDO_EXTENSION fdoExtension= pdoExtension->Socket->DeviceExtension;
         ULONG whichSpace;
         PVOID buffer;
         ULONG offset;
         ULONG length;

         whichSpace = irpStack->Parameters.ReadWriteConfig.WhichSpace;
         buffer     = irpStack->Parameters.ReadWriteConfig.Buffer;
         offset     = irpStack->Parameters.ReadWriteConfig.Offset;
         length     = irpStack->Parameters.ReadWriteConfig.Length;

         if (irpStack->MinorFunction == IRP_MN_READ_CONFIG) {
            status = PcmciaReadWriteCardMemory(Pdo,
                                               whichSpace,
                                               buffer,
                                               offset,
                                               length,
                                               TRUE);
         } else {
            status = PcmciaReadWriteCardMemory(Pdo,
                                               whichSpace,
                                               buffer,
                                               offset,
                                               length,
                                               FALSE);
         }
         break;
      }

   case IRP_MN_QUERY_DEVICE_RELATIONS: {

         PDEVICE_RELATIONS deviceRelations;

         if (irpStack->Parameters.QueryDeviceRelations.Type != TargetDeviceRelation) {
            status = Irp->IoStatus.Status;
            break;
         }

         deviceRelations = ExAllocatePool(PagedPool, sizeof(DEVICE_RELATIONS));
         if (deviceRelations == NULL) {

            DebugPrint((PCMCIA_DEBUG_FAIL,
                        "PcmciaPdoPnpDispatch:unable to allocate memory for device relations\n"));

            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
         }
         status = ObReferenceObjectByPointer(Pdo,
                                             0,
                                             NULL,
                                             KernelMode);
         if (!NT_SUCCESS(status)) {
            ExFreePool(deviceRelations);
            break;
         }

         deviceRelations->Count  = 1;
         deviceRelations->Objects[0] = Pdo;
         Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;
         status = STATUS_SUCCESS;
         break;
      }

   case IRP_MN_QUERY_CAPABILITIES: {
         status = PcmciaPdoDeviceCapabilities(Pdo, Irp);
         break;
      }

   case IRP_MN_QUERY_INTERFACE: {
         status = PcmciaPdoQueryInterface(Pdo, Irp);
         //
         // QueryInterface completes the passed in Irp.
         // So just return immediately.
         //
         return status;
      }

   case IRP_MN_QUERY_DEVICE_TEXT: {

         status = PcmciaQueryDeviceText(Pdo, Irp);

         if (status == STATUS_NOT_SUPPORTED ) {
            //
            // Do not change IRP status if this IRP is
            // not handled
            //
            status = Irp->IoStatus.Status;
         }
         break;
      }

   case IRP_MN_FILTER_RESOURCE_REQUIREMENTS: {
         status = PcmciaFilterPcCardResourceRequirements(pdoExtension, Irp);
         break;
      }

   case IRP_MN_QUERY_BUS_INFORMATION: {
         status = PcmciaPdoGetBusInformation(pdoExtension,
                                            (PPNP_BUS_INFORMATION *) &Irp->IoStatus.Information);
         break;
   }
   
   default: {
         //
         // Retain the status
         //
         DebugPrint((PCMCIA_DEBUG_PNP, "pdo %08x irp %08x Skipping unsupported irp\n", Pdo, Irp));
         status = Irp->IoStatus.Status;
         break;
      }
   }

   Irp->IoStatus.Status = status;
   IoCompleteRequest(Irp, IO_NO_INCREMENT);
   DebugPrint((PCMCIA_DEBUG_PNP, "pdo %08x irp %08x comp %s %08x\n", Pdo, Irp,
                                              STATUS_STRING(status), status));
   return status;
}


NTSTATUS
PcmciaPdoGetBusInformation(
   IN  PPDO_EXTENSION         PdoExtension,
   OUT PPNP_BUS_INFORMATION * BusInformation
   )

/*++

Routine Description:

  Returns the  bus type information for the pc-card.
  Bus type is GUID_BUS_TYPE_PCMCIA(legacy type is PcmciaBus) for R2 cards
  Bus numbers are not implemented for PCMCIA, so it's always 0

Arguments:

  PdoExtension   - pointer to device extension for the pc-card

  BusInformation - pointer to the bus information structure that
                   needs to be filled in

Return value:

  Status

--*/

{

   PAGED_CODE();

   *BusInformation = ExAllocatePool(PagedPool, sizeof (PNP_BUS_INFORMATION));
   if (!*BusInformation) {
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlCopyMemory(&((*BusInformation)->BusTypeGuid),
                 &GUID_BUS_TYPE_PCMCIA,
                 sizeof(GUID));
   (*BusInformation)->LegacyBusType = PCMCIABus;
   (*BusInformation)->BusNumber = 0;

   return STATUS_SUCCESS;
}


VOID
PcmciaPdoGetDeviceInfSettings(
   IN  PPDO_EXTENSION PdoExtension
   )
/*++

Routine Description:

   This routine retrieves settings from the INF for this device. 

Arguments:

   DeviceExtension - Device extension of the Pc-Card

Return value:

   None 

--*/
{
   NTSTATUS status;
   PSOCKET socket = PdoExtension->Socket;
   UNICODE_STRING KeyName;
   HANDLE instanceHandle;
   UCHAR buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG)];
   PKEY_VALUE_PARTIAL_INFORMATION value = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
   ULONG length;   
   
   PAGED_CODE();
   
   status = IoOpenDeviceRegistryKey(PdoExtension->DeviceObject,
                                    PLUGPLAY_REGKEY_DRIVER,
                                    KEY_READ,
                                    &instanceHandle
                                    );
                                    
   if (NT_SUCCESS(status)) {
   
      //
      // Look to see if PcmciaExclusiveIrq is specified
      //
      RtlInitUnicodeString(&KeyName, L"PcmciaExclusiveIrq");
      
      status =  ZwQueryValueKey(instanceHandle,
                                &KeyName,
                                KeyValuePartialInformation,
                                value,
                                sizeof(buffer),
                                &length);

      
      //
      // If the key doesn't exist, or zero was specified, it means that
      // routing is ok
      //     
      if (NT_SUCCESS(status) && (*(PULONG)(value->Data) != 0)) {
         SetDeviceFlag(PdoExtension, PCMCIA_PDO_EXCLUSIVE_IRQ);
      }

      //
      // Look to see if PcmciaAutoPowerOff is specified
      //
      RtlInitUnicodeString(&KeyName, L"PcmciaAutoPowerOff");
      
      status =  ZwQueryValueKey(instanceHandle,
                                &KeyName,
                                KeyValuePartialInformation,
                                value,
                                sizeof(buffer),
                                &length);

      
      //
      // If zero was specified, then don't automatically cut power on shutdown
      //     
      if (NT_SUCCESS(status) && (*(PULONG)(value->Data) == 0)) {
         SetDeviceFlag(socket->DeviceExtension, PCMCIA_FDO_DISABLE_AUTO_POWEROFF);
      }
      
      //
      // Look to see if PcmciaEnableAudio is specified
      //
      RtlInitUnicodeString(&KeyName, L"PcmciaEnableAudio");
      
      status =  ZwQueryValueKey(instanceHandle,
                                &KeyName,
                                KeyValuePartialInformation,
                                value,
                                sizeof(buffer),
                                &length);

      
      //
      // If zero was specified, then don't automatically cut power on shutdown
      //     
      if (NT_SUCCESS(status) && (*(PULONG)(value->Data) != 0)) {
         SetDeviceFlag(PdoExtension, PCMCIA_PDO_ENABLE_AUDIO);
      }
      
      ZwClose(instanceHandle);
   }   
}   



VOID
PcmciaPdoSetDeviceIrqRouting(
   IN  PPDO_EXTENSION PdoExtension
   )
/*++

Routine Description:

   This routine retrieves settings from the INF for this device. 

Notes: 

   PcmciaExclusiveIrq in the INF determines how the IRQ for the R2 card will be routed.
   Currently, the following logic is used:
   
      if (routing disabled)
        choose either detected or legacy
      else
        if !detected, use FdoIrq
   
   So, if routing to PCI at all, then only the PCI IRQ will show up in the IoResList.
   BUT: Another approach would be to use the following logic:
   
      if (routing disabled) 
         choose either detected or legacy
      else
         *merge detected with FdoIrq*

   This way we may end up using an exclusive IRQ or routing to PCI, depending on what
   the arbiter has decided. That is the reason why I kept both Detected and Legacy around
   in the FdoExtension, because otherwise it would have made more sense just to choose
   and merge them back when they were generated.
   
Arguments:

   DeviceExtension - Device extension of the Pc-Card

Return value:

   None (SOCKET structure is updated) 

--*/
{
   NTSTATUS status;
   PSOCKET socket = PdoExtension->Socket;
   PFDO_EXTENSION fdoExtension = socket->DeviceExtension;
   
   PAGED_CODE();
   
   ResetSocketFlag(socket, SOCKET_CB_ROUTE_R2_TO_PCI);

   //
   // First check the conditions that specify we definitely don't want to route to PCI
   //
   
   if (!pcmciaDisableIsaPciRouting &&
      CardBusExtension(fdoExtension) && 
      !IsDeviceFlagSet(PdoExtension, PCMCIA_PDO_EXCLUSIVE_IRQ)) {
      
      //
      // Here we know we *could* route to PCI, now determine if we *should*. This takes
      // into account several registry settings, as well as the result from the NtDetect
      // IRQ detection algorithm.
      //


      //
      // First check to see if there was an override with specifically targeted this
      // controller. This will take precedence.
      // 
      if (IsFdoFlagSet(fdoExtension, PCMCIA_FDO_FORCE_PCI_ROUTING)) {
         SetSocketFlag(socket, SOCKET_CB_ROUTE_R2_TO_PCI);
      }
      else if (IsFdoFlagSet(fdoExtension, PCMCIA_FDO_FORCE_ISA_ROUTING)) {
         ResetSocketFlag(socket, SOCKET_CB_ROUTE_R2_TO_PCI);
      }
         
      //
      // Now check to see if the detection algorithm succeeded. We should honor this result,
      // particularly if the map was zero, which tells us there are no ISA IRQs attached.
      //
      else if (IsFdoFlagSet(fdoExtension, PCMCIA_FDO_IRQ_DETECT_COMPLETED)) {
         if (fdoExtension->DetectedIrqMask == 0) {
            SetSocketFlag(socket, SOCKET_CB_ROUTE_R2_TO_PCI);
         }            
      }
      

      //
      // Now see if there was a general override based on this controller type. This has
      // less precedence than the detection algorithm.
      //         
      else if (IsFdoFlagSet(fdoExtension, PCMCIA_FDO_PREFER_PCI_ROUTING)) {
         SetSocketFlag(socket, SOCKET_CB_ROUTE_R2_TO_PCI);
      }
      else if (IsFdoFlagSet(fdoExtension, PCMCIA_FDO_PREFER_ISA_ROUTING)) {
         ResetSocketFlag(socket, SOCKET_CB_ROUTE_R2_TO_PCI);
      }


      //
      // Here look to see if the device was found, but the irq detection failed for some
      // reason. With no special registry overrides, we fall back on the global default.
      //      
      else if (IsFdoFlagSet(fdoExtension, PCMCIA_FDO_IRQ_DETECT_DEVICE_FOUND)) {
         if (!(PcmciaGlobalFlags & PCMCIA_DEFAULT_ROUTE_R2_TO_ISA)) {
            SetSocketFlag(socket, SOCKET_CB_ROUTE_R2_TO_PCI);
         }
      }
         

      //
      // Here ntdetect never saw the device. Maybe we just hot-docked. 
      // We will base our decision on if it was in ACPI namespace or not. If it
      // isn't in ACPI namespace, then it probably is not connected to ISA
      //
      else {
         if (!IsFdoFlagSet(fdoExtension, PCMCIA_FDO_IN_ACPI_NAMESPACE)) {
            SetSocketFlag(socket, SOCKET_CB_ROUTE_R2_TO_PCI);
         }            
      }

   }   

   socket->IrqMask = fdoExtension->DetectedIrqMask ? fdoExtension->DetectedIrqMask : fdoExtension->LegacyIrqMask;
   
   DebugPrint((PCMCIA_DEBUG_RESOURCES, "pdo %08x IRQ routing=%s, IRQMask=%08x\n", PdoExtension->DeviceObject, 
                                              IsSocketFlagSet(socket, SOCKET_CB_ROUTE_R2_TO_PCI) ? "PCI" : "ISA",
                                              socket->IrqMask));
}   



NTSTATUS
PcmciaFilterPcCardInterrupts(
   IN  PIO_RESOURCE_REQUIREMENTS_LIST   oldReqList,
   IN  ULONG IrqCount,
   IN  ULONG IrqMask,
   OUT PIO_RESOURCE_REQUIREMENTS_LIST * FilteredReqList,
   BOOLEAN RouteIsaToPci
   )
/*++

Routine Description:

    Filters the interrupt resource requirements for R2 Pc-Cards

Arguments:

    oldReqList      - Original, 'raw' resource requirements list
    IrqCount        - # of irq's that will be deleted (already computed by caller)
    IrqMask         - bit mask which indicates which interrupts are valid
    FilteredReqList - pointer to the filtered  requirements list which
                      will be filled in by this routine

Return value:

    Status

--*/
{
   PIO_RESOURCE_REQUIREMENTS_LIST  newReqList;
   PIO_RESOURCE_LIST               oldList, newList;
   ULONG                           newReqSize;
   ULONG                           oldlistSize, newlistSize;
   ULONG                           index, oldIndex, newIndex;
   BOOLEAN                         irqAlternative;

   PAGED_CODE();
   //
   // Compute the size of the structure with the offending IRQs removed.
   //
   newReqSize = oldReqList->ListSize - IrqCount*sizeof(IO_RESOURCE_DESCRIPTOR);

   newReqList = ExAllocatePool(PagedPool, newReqSize);

   if (newReqList == NULL) {
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlCopyMemory(newReqList, oldReqList, FIELD_OFFSET(IO_RESOURCE_REQUIREMENTS_LIST, List));
   newReqList->ListSize = newReqSize;
   
   newList = newReqList->List;
   oldList = oldReqList->List;

   //
   // Loop through each alternative list
   //
   for (index = 0; index < oldReqList->AlternativeLists; index++) {
      newList->Version = oldList->Version;
      newList->Revision = oldList->Revision;

      irqAlternative = FALSE;
      //
      // Loop through each descriptor in the old list
      //
      for (oldIndex = 0, newIndex = 0; oldIndex < oldList->Count; oldIndex++) {
      
         if (oldList->Descriptors[oldIndex].Type == CmResourceTypeInterrupt) {
         
            if (RouteIsaToPci) {
            
               if (!irqAlternative) {
                  //
                  // First interrupt found, this will be the one we use to route
                  //
                  newList->Descriptors[newIndex++] = oldList->Descriptors[oldIndex];
                  irqAlternative = TRUE;
               }
            
            } else {
               //
               // Normal case (not routed). Filter out irqs that aren't in our mask
               //
               if ((IrqMask & (1<<oldList->Descriptors[oldIndex].u.Interrupt.MinimumVector)) != 0) {
                  //
                  // Not a bad interrupt descriptor. Copy the old to the new
                  //
                  newList->Descriptors[newIndex] = oldList->Descriptors[oldIndex];
                  
                  if (newList->Descriptors[newIndex].Type == CmResourceTypeInterrupt) {
                     if (irqAlternative) {
                        newList->Descriptors[newIndex].Option = IO_RESOURCE_ALTERNATIVE;
                     } else {
                        irqAlternative = TRUE;
                        newList->Descriptors[newIndex].Option = 0;
                     }
                  }
                  newIndex++;
               }
            }               
         } else {
            //
            // Not an interrupt descriptor. Copy the old to the new
            //
            newList->Descriptors[newIndex++] = oldList->Descriptors[oldIndex];
         }
      }
      newList->Count = newIndex;
      oldlistSize = sizeof(IO_RESOURCE_LIST) + (oldList->Count-1) * sizeof(IO_RESOURCE_DESCRIPTOR);
      newlistSize = sizeof(IO_RESOURCE_LIST) + (newList->Count-1) * sizeof(IO_RESOURCE_DESCRIPTOR);
      oldList = (PIO_RESOURCE_LIST) (((PUCHAR) oldList) + oldlistSize);
      newList = (PIO_RESOURCE_LIST) (((PUCHAR) newList) + newlistSize);
   }
   
   *FilteredReqList = newReqList;
   return STATUS_SUCCESS;
}



NTSTATUS
PcmciaFilterPcCardResourceRequirements(
   IN PPDO_EXTENSION DeviceExtension,
   IN PIRP           Irp
   )

/*++

Routine Description:

    Filters the resource requirements for R2 Pc-Cards

Arguments:

    DeviceExtension - Device extension of the Pc-Card

Return value:

    Status

--*/
{
   PIO_RESOURCE_REQUIREMENTS_LIST IoReqList;
   PIO_RESOURCE_REQUIREMENTS_LIST newReqList;
   PIO_RESOURCE_LIST   ioResourceList;
   PIO_RESOURCE_DESCRIPTOR ioResourceDesc;
   PSOCKET             socket;
   PFDO_EXTENSION      fdoExtension;
   ULONG               index1, index2, len;
   ULONGLONG           low, high;
   ULONG               IrqsToDeleteCount = 0;
   NTSTATUS            status = STATUS_SUCCESS;
   BOOLEAN             RouteIrqFound;

   PAGED_CODE();
   
   IoReqList = (PIO_RESOURCE_REQUIREMENTS_LIST) Irp->IoStatus.Information;
   
   if (IoReqList == NULL) {
      return STATUS_SUCCESS;
   }

   socket = DeviceExtension->Socket;
   fdoExtension = socket->DeviceExtension;   

   for (index1 = 0, ioResourceList = IoReqList->List;
       index1 < IoReqList->AlternativeLists; index1++) {
      ioResourceDesc = ioResourceList->Descriptors;
      
      RouteIrqFound = FALSE;
      
      for (index2 = 0 ; index2 < ioResourceList->Count; index2++, ioResourceDesc++) {
         if (ioResourceDesc->Type == CmResourceTypeInterrupt) {

            if (IsSocketFlagSet(socket, SOCKET_CB_ROUTE_R2_TO_PCI)) {

               //
               // make sure there is space for just 1 level interrupt requirement
               //            
               if (!RouteIrqFound) {
                  RouteIrqFound = TRUE;
                  ioResourceDesc->Flags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
                  ioResourceDesc->Option = 0;
                  ioResourceDesc->ShareDisposition = CmResourceShareShared;
                  ioResourceDesc->u.Interrupt.MinimumVector = socket->FdoIrq;
                  ioResourceDesc->u.Interrupt.MaximumVector = socket->FdoIrq;
                  
               } else {
                  //
                  // Don't need any other IRQs in this list
                  //
                  IrqsToDeleteCount++;
               }
            
            } else {
               ASSERT (ioResourceDesc->u.Interrupt.MinimumVector == ioResourceDesc->u.Interrupt.MaximumVector);
               //
               // Look to see if there are IRQ's specified in this IoResList which are
               // not in our mask. If so, we are going to have to create a new IoResList.
               // Keep track of how many            
            
               if (!(socket->IrqMask & (1<<ioResourceDesc->u.Interrupt.MinimumVector))) {
                  IrqsToDeleteCount++;
               }
            }
         
         } else if (ioResourceDesc->Type == CmResourceTypePort) {
            //
            // We might want to filter this..
            //
            low  = ioResourceDesc->u.Port.MinimumAddress.QuadPart;
            high = ioResourceDesc->u.Port.MaximumAddress.QuadPart;
            len  = ioResourceDesc->u.Port.Length;

            //
            // A set of messy rules to see if we should filter the requirements.
            //
            // We don't filter if:
            // 1. User requested number of ports which are more than
            // we can legally ask with our filtered high & low caps on the
            // requirements.
            // 2. User requested a 'fixed' resource requirement, i.e. a specific
            // set of ports of a specified length.
            // 3. User specified resource requirements range is smaller
            // than the range we would obtain if we filter it. We don't filter
            // in this case because the filtering is supposed to restrict the range
            // not expand it. If user thinks he can restrict better than us,
            // honor it .
            //
            //
            if (len > (fdoExtension->IoHigh - fdoExtension->IoLow + 1)) {
               //
               // Case 1. above.
               // Don't filter this.
               //
               continue;
            }

            if ((low + len -1) >= high) {
               //
               // Case 2.
               // This is a fixed requirement. Don't filter it
               //
               continue;
            }


            if (((ULONG)(high - low))  <= (fdoExtension->IoHigh - fdoExtension->IoLow)) {
               //
               // Case 3.
               // Don't filter this
               //
               continue;
            }

            if ((ULONG) low < fdoExtension->IoLow) {
               low = (ULONGLONG) fdoExtension->IoLow;
            }

            if ((ULONG) high > fdoExtension->IoHigh) {
               high = (ULONGLONG) fdoExtension->IoHigh;
            }

            ioResourceDesc->u.Port.MinimumAddress.QuadPart = low;
            ioResourceDesc->u.Port.MaximumAddress.QuadPart = high;
            
         } else if (ioResourceDesc->Type == CmResourceTypeMemory) { 
         
            //
            // pccard hardware can't handle > 32bit addressing
            //
            ASSERT(ioResourceDesc->u.Memory.MinimumAddress.HighPart == 0);
            ioResourceDesc->u.Memory.MaximumAddress.HighPart = 0;
            
            if (fdoExtension->Flags & PCMCIA_MEMORY_24BIT) {

               ASSERT((ioResourceDesc->u.Memory.MinimumAddress.LowPart & 0xFF000000) == 0);
               ioResourceDesc->u.Memory.MaximumAddress.LowPart &= 0xFFFFFF;

            }

            //
            // win2k had a bug where o2micro controllers were marked as 24bit. When
            // that was fixed, an o2micro smart card device with an INF bug suddenly
            // stopped working (because the first bug masked the second). This code
            // fixes their INF.
            //
            if ((ioResourceDesc->Flags & CM_RESOURCE_MEMORY_24) &&
                (ioResourceDesc->u.Memory.MinimumAddress.LowPart > 0xFFFFFF) &&
                (PcmciaClassFromControllerType(fdoExtension->ControllerType) == PcmciaO2Micro)) {
                         
               ioResourceDesc->u.Memory.MinimumAddress.LowPart &= 0xFFFFFF;
            }       
         }
      }

      ioResourceList = (PIO_RESOURCE_LIST) (((PUCHAR) ioResourceList) +
                                            sizeof(IO_RESOURCE_LIST) +
                                            (ioResourceList->Count - 1)* sizeof(IO_RESOURCE_DESCRIPTOR));
   } // outer for loop
   
   if (IrqsToDeleteCount) {
   
      status = PcmciaFilterPcCardInterrupts(IoReqList,
                                            IrqsToDeleteCount,
                                            socket->IrqMask,
                                            &newReqList,
                                            IsSocketFlagSet(socket, SOCKET_CB_ROUTE_R2_TO_PCI)
                                            );
                                            
      if (NT_SUCCESS(status)) {
         Irp->IoStatus.Information = (ULONG_PTR) newReqList;
         ExFreePool(IoReqList);
      }     
   }
   
   return status;
}



NTSTATUS
PcmciaQueryDeviceText(
   IN PDEVICE_OBJECT Pdo,
   IN OUT PIRP       Irp
   )

/*++

Routine Description:

   Returns descriptive text information about the
   PDO (location and device desc.)

Arguments:

   Pdo -    Pointer to the PC-Card's device object
   Irp -    IRP_MN_QUERY_DEVICE_TEXT Irp

Return Value:

    STATUS_SUCCESS
    STATUS_NOT_SUPPORTED - if  not supported

--*/
{
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
   PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
   UNICODE_STRING   unicodeString;
   ANSI_STRING      ansiString;
   UCHAR          deviceText[128];
   NTSTATUS       status;
   USHORT         deviceTextLength;
   PSOCKET_DATA   socketData = pdoExtension->SocketData;

   PAGED_CODE();

   if (irpStack->Parameters.QueryDeviceText.DeviceTextType == DeviceTextDescription) {

      if (*(socketData->Mfg) == '\0' ) {
         if (socketData->Flags & SDF_JEDEC_ID) {
            sprintf(deviceText, "%s %s-%04x", PCMCIA_ID_STRING, PCMCIA_MEMORY_ID_STRING, socketData->JedecId);

         } else {
            sprintf(deviceText, "%s %s", PCMCIA_ID_STRING, PCMCIA_UNKNOWN_MANUFACTURER_STRING);
         }
      } else {         
         sprintf(deviceText, "%s %s", socketData->Mfg, socketData->Ident);
      }         
      RtlInitAnsiString(&ansiString, deviceText);

      deviceTextLength = (strlen(deviceText) + 1)*sizeof(WCHAR);
      unicodeString.Buffer = ExAllocatePool(PagedPool, deviceTextLength);
      if (unicodeString.Buffer == NULL) {
         return STATUS_INSUFFICIENT_RESOURCES;
      }

      unicodeString.MaximumLength = deviceTextLength;
      unicodeString.Length = 0;

      status = RtlAnsiStringToUnicodeString(&unicodeString, &ansiString, FALSE);
      if (!NT_SUCCESS(status)) {
         ExFreePool(unicodeString.Buffer);
         return status;
      }

      unicodeString.Buffer[unicodeString.Length/sizeof(WCHAR)] = L'\0';
      Irp->IoStatus.Information = (ULONG_PTR) unicodeString.Buffer;
      status = STATUS_SUCCESS;
   } else {
      status = STATUS_NOT_SUPPORTED ;
   }
   return status;
}



NTSTATUS
PcmciaGetPcCardResourceRequirements(
   PPDO_EXTENSION pdoExtension,
   PULONG_PTR     Information
   )

/*++

Routine Description:
   Fills in the resource requirements for the PC-Card obtained from the tuple information

Arguments:

   PdoExtension   -  Pointer to the device extension for the PDO of the pc-card
   Information - Pointer to an allocated resource requirements list is stored in this
                 argument. Caller's responsibility to free the list

Return value:

  STATUS_INSUFFICIENT_RESOURCES     Could not allocate the list
  STATUS_SUCCES                     Obtained resource requirements, Information contains the pointer
                                    to the IO_RESOURCE_REQUIREMENTS list



--*/
{
   NTSTATUS status;
   PPCMCIA_RESOURCE_CHAIN resListChain = NULL;
   PIO_RESOURCE_REQUIREMENTS_LIST ioResourceRequirementsList;
   PSOCKET socket = pdoExtension->Socket;   
   PSOCKET_DATA socketData = pdoExtension->SocketData;
   PCONFIG_ENTRY currentConfigEntry;
   PFDO_EXTENSION fdoExtension = socket->DeviceExtension;
   CONFIG_LIST configList;

   PAGED_CODE();
   ASSERT (!IsDeviceMultifunction(pdoExtension));

   //
   // Run through the config entry chains for IO space & Mem space requirements
   //
   configList.SocketData = socketData;

   for (currentConfigEntry=socketData->ConfigEntryChain; currentConfigEntry != NULL; currentConfigEntry=currentConfigEntry->NextEntry) {

      if (currentConfigEntry->Flags & PCMCIA_INVALID_CONFIGURATION) {
         continue;
      }

      configList.ConfigEntry = currentConfigEntry;

      status = PcmciaConfigEntriesToResourceListChain(pdoExtension,
                                                      &configList,
                                                      (ULONG)1, 
                                                      &resListChain
                                                      );

      if (!NT_SUCCESS(status)) {
         return status;
      }
   }
   
   status = PcmciaMergeResourceChainToList(resListChain, &ioResourceRequirementsList);
      
   if (NT_SUCCESS(status) && (ioResourceRequirementsList != NULL)) {
      ioResourceRequirementsList->InterfaceType = Isa;
      ioResourceRequirementsList->BusNumber = fdoExtension->Configuration.BusNumber;
      ioResourceRequirementsList->SlotNumber = 0; // Need to revisit this..
      *Information = (ULONG_PTR) ioResourceRequirementsList;
   }

   PcmciaFreeResourceChain(resListChain);   
   
   return status;
}



NTSTATUS
PcmciaConfigEntriesToResourceListChain(
   PPDO_EXTENSION    pdoExtension,
   PCONFIG_LIST      ConfigList,
   ULONG             configCount,
   PPCMCIA_RESOURCE_CHAIN *ResListChainHead
   )
/*++

Routine Description:
   Fills in the resource requirements for the PC-Card obtained from the tuple information

Arguments:

   PdoExtension   -  Pointer to the device extension for the PDO of the pc-card

Return value:

  STATUS_INSUFFICIENT_RESOURCES     Could not allocate the list
  STATUS_SUCCES                     Obtained resource requirements, Information contains the pointer
                                    to the IO_RESOURCE_REQUIREMENTS list



--*/
{
   PSOCKET socket = pdoExtension->Socket;
   PFDO_EXTENSION fdoExtension = socket->DeviceExtension;
   PCONFIG_ENTRY currentConfigEntry;
   PPCMCIA_RESOURCE_CHAIN resListChain;
   PIO_RESOURCE_LIST ioResourceList;
   PIO_RESOURCE_DESCRIPTOR ioResourceDesc;
   ULONG irqMask = 0, i, iConfig;
   ULONG totalDescriptorCount = 0;
   ULONG TotalIoRanges = 0;
   ULONG listSize;
   BOOLEAN IoRangeIs16Bit[MAX_NUMBER_OF_IO_RANGES] = {0};
   BOOLEAN irqAlternative;

   PAGED_CODE();
   DebugPrint((PCMCIA_DEBUG_RESOURCES, "pdo %08x build ioreslist from configlist %08x, config count=%d\n",
                                        pdoExtension->DeviceObject, ConfigList, configCount));

   //
   // Calculate how many descriptors we need. This involves also generating
   // the irqmask with the intersection of the irqmasks of the config entries
   // in the array.
   //

   for (iConfig = 0; iConfig < configCount; iConfig++) {
      currentConfigEntry = ConfigList[iConfig].ConfigEntry;

      irqMask |= currentConfigEntry->IrqMask;

      totalDescriptorCount += currentConfigEntry->NumberOfIoPortRanges;
      totalDescriptorCount += currentConfigEntry->NumberOfMemoryRanges;
   }
   
   if (irqMask) {
      if (IsSocketFlagSet(socket, SOCKET_CB_ROUTE_R2_TO_PCI)) {
         totalDescriptorCount++;
      } else {
         totalDescriptorCount += PcmciaCountOnes(socket->IrqMask);
      }
   }         

   if (!totalDescriptorCount) {
      return STATUS_SUCCESS;
   }

   //
   // Add one more for our private DPTYPE_PCMCIA_CONFIGURATION
   //
   totalDescriptorCount++;

   if (configCount > 1) {
      //
      // Add more for our private DPTYPE_PCMCIA_MF_CONFIGURATION
      //
      totalDescriptorCount+=configCount;
   }

   //
   // Calculate the size of IO_RESOURCE_LIST, allocate and clear it
   //

   listSize = (totalDescriptorCount - 1) * sizeof(IO_RESOURCE_DESCRIPTOR)
              + sizeof(IO_RESOURCE_LIST);

   ioResourceList = ExAllocatePool(PagedPool, listSize);
   if (ioResourceList == NULL) {
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(ioResourceList, listSize);

   //
   // Now that we have the resource list allocated, fill it in
   //

   ioResourceList->Version  =  IO_RESOURCE_LIST_VERSION;
   ioResourceList->Revision =  IO_RESOURCE_LIST_REVISION;
   ioResourceList->Count = totalDescriptorCount;
   ioResourceDesc = &ioResourceList->Descriptors[0];

   //
   // Fill in the IRQ info.
   //
   if (irqMask) {
      if (IsSocketFlagSet(socket, SOCKET_CB_ROUTE_R2_TO_PCI)) {
      
         ioResourceDesc->Type = CmResourceTypeInterrupt;
         ioResourceDesc->Option = 0;
      
         ioResourceDesc->Flags = (USHORT)CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
         ioResourceDesc->ShareDisposition = CmResourceShareShared;
         ioResourceDesc->u.Interrupt.MinimumVector = socket->FdoIrq;
         ioResourceDesc->u.Interrupt.MaximumVector = socket->FdoIrq;
         ioResourceDesc++;
      
      } else {
         ULONG irqn;
      
         irqMask = socket->IrqMask;
         DebugPrint((PCMCIA_DEBUG_RESOURCES, "irq mask %04x\n", irqMask));
         
         //
         // For each IRQ supported, fill in a separate IO descriptor
         //
         irqAlternative = FALSE;
         for (irqn = 0 ;irqMask; irqMask = (irqMask >> 1), irqn++) {
            if (irqMask & 0x1) {
               if (irqAlternative) {
                  ioResourceDesc->Option = IO_RESOURCE_ALTERNATIVE;
               } else {
                  irqAlternative = TRUE;
                  ioResourceDesc->Option = 0;
               }
               ioResourceDesc->Type = CmResourceTypeInterrupt;
               //
               // This is for 16-bit pc-cards.. so request an edge-triggered
               // exclusive interrupt
               //
               ioResourceDesc->Flags = (USHORT)CM_RESOURCE_INTERRUPT_LATCHED;
               ioResourceDesc->ShareDisposition = CmResourceShareDeviceExclusive;
               ioResourceDesc->u.Interrupt.MinimumVector =
               ioResourceDesc->u.Interrupt.MaximumVector = irqn;
               ioResourceDesc++;
            }
         }
      }   
   }      


   for (iConfig = 0; iConfig < configCount; iConfig++) {
      currentConfigEntry = ConfigList[iConfig].ConfigEntry;

      //
      // for each I/O range, fill in an IoResourceDescriptor
      //
      for (i = 0; i < currentConfigEntry->NumberOfIoPortRanges; i++) {
         PHYSICAL_ADDRESS  port;

         ioResourceDesc->Option = 0;
         ioResourceDesc->Type  =  CmResourceTypePort;
         ioResourceDesc->Flags =  CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_16_BIT_DECODE;
         ioResourceDesc->ShareDisposition =  CmResourceShareDeviceExclusive;

         if (currentConfigEntry->IoPortBase[i] == 0) {
            //
            // This is a flexible requirement. Basically means we need
            // any system address range of specified length & alignment
            //
            port=RtlConvertUlongToLargeInteger(fdoExtension->IoLow);
            ioResourceDesc->u.Port.MinimumAddress = port;
            port=RtlConvertUlongToLargeInteger(fdoExtension->IoHigh);
            ioResourceDesc->u.Port.MaximumAddress = port;
         } else {

            port = RtlConvertUlongToLargeInteger((ULONG) currentConfigEntry->IoPortBase[i]);
            ioResourceDesc->u.Port.MinimumAddress = port;
            port = RtlConvertUlongToLargeInteger((ULONG) (currentConfigEntry->IoPortBase[i]+
                                                          currentConfigEntry->IoPortLength[i]));
            ioResourceDesc->u.Port.MaximumAddress =  port;
         }
         ioResourceDesc->u.Port.Length = (ULONG) currentConfigEntry->IoPortLength[i]+1;
         ioResourceDesc->u.Port.Alignment = currentConfigEntry->IoPortAlignment[i];
         
         DebugPrint((PCMCIA_DEBUG_RESOURCES, "Port range: %08x-%08x, Length %04x\n",
                                             ioResourceDesc->u.Port.MinimumAddress.LowPart,
                                             ioResourceDesc->u.Port.MaximumAddress.LowPart, 
                                             ioResourceDesc->u.Port.Length
                                             ));
                                             
         if ((TotalIoRanges < MAX_NUMBER_OF_IO_RANGES) &&
            (currentConfigEntry->Io16BitAccess)) {
            IoRangeIs16Bit[TotalIoRanges] = TRUE;
         }
         TotalIoRanges++;
                                             
         ioResourceDesc++;
      }
   }

   for (iConfig = 0; iConfig < configCount; iConfig++) {
      currentConfigEntry = ConfigList[iConfig].ConfigEntry;

      //
      // for each memory range, fill in an IoResourceDescriptor
      //
      for (i = 0; i < currentConfigEntry->NumberOfMemoryRanges; i++) {
         PHYSICAL_ADDRESS  mem;
         
         ioResourceDesc->Option = 0;
         ioResourceDesc->Type  =  CmResourceTypeMemory;
         ioResourceDesc->Flags =  CM_RESOURCE_MEMORY_READ_WRITE;
         ioResourceDesc->ShareDisposition =  CmResourceShareDeviceExclusive;
         if (currentConfigEntry->MemoryHostBase[i]) {
            mem = RtlConvertUlongToLargeInteger((ULONG) currentConfigEntry->MemoryHostBase[i]);
            ioResourceDesc->u.Memory.MinimumAddress = mem;
            mem = RtlConvertUlongToLargeInteger((ULONG) currentConfigEntry->MemoryHostBase[i]+
                                                (ULONG) currentConfigEntry->MemoryLength[i]-1);
            ioResourceDesc->u.Memory.MaximumAddress = mem;
         } else {
            //
            // Any physical address is ok
            //
            mem = RtlConvertUlongToLargeInteger(0);
            ioResourceDesc->u.Memory.MinimumAddress = mem;
            //
            // Only decode 24 bit memory addresses if there is no page register
            //
            if ((fdoExtension->Flags & PCMCIA_MEMORY_24BIT) == 0) {
               mem = RtlConvertUlongToLargeInteger(0xFFFFFFFF);
            } else {
               mem = RtlConvertUlongToLargeInteger(0xFFFFFF);
            }
            ioResourceDesc->u.Memory.MaximumAddress = mem;
         }

         ioResourceDesc->u.Memory.Length = currentConfigEntry->MemoryLength[i];
         //
         // Alignment has to be 12 bits
         //
         ioResourceDesc->u.Memory.Alignment = 0x1000;

         DebugPrint((PCMCIA_DEBUG_RESOURCES, "Mem range: %08x-%08x, Length %08x\n",
                                             ioResourceDesc->u.Memory.MinimumAddress.LowPart,
                                             ioResourceDesc->u.Memory.MaximumAddress.LowPart,
                                             ioResourceDesc->u.Memory.Length
                                             ));
                                             
         ioResourceDesc++;
      }
   }

   //
   // Fill in device private containing our config index
   //
   ioResourceDesc->Option = 0;
   ioResourceDesc->Type  =  CmResourceTypeDevicePrivate;
   PCMRES_SET_DESCRIPTOR_TYPE(ioResourceDesc, DPTYPE_PCMCIA_CONFIGURATION);

   currentConfigEntry = ConfigList[0].ConfigEntry;
   PCMRES_SET_CONFIG_INDEX(ioResourceDesc, currentConfigEntry->IndexForThisConfiguration);
   
   for (i = 0; i < MAX_NUMBER_OF_IO_RANGES; i++) {
      if (IoRangeIs16Bit[i]) {
         PCMRES_SET_IO_FLAG(ioResourceDesc, i, PCMRESF_IO_16BIT_ACCESS);
         PCMRES_SET_IO_FLAG(ioResourceDesc, i, PCMRESF_IO_SOURCE_16);
         PCMRES_SET_IO_FLAG(ioResourceDesc, i, PCMRESF_IO_WAIT_16);
      }
   }

   PCMRES_SET_MEMORY_CARDBASE(ioResourceDesc, 0, currentConfigEntry->MemoryCardBase[0]);
   PCMRES_SET_MEMORY_CARDBASE(ioResourceDesc, 1, currentConfigEntry->MemoryCardBase[1]);
   
   //
   // Set defaults
   //
   PCMRES_SET_MEMORY_WAITSTATES(ioResourceDesc, 0, PCMRESF_MEM_WAIT_3);
   PCMRES_SET_MEMORY_WAITSTATES(ioResourceDesc, 1, PCMRESF_MEM_WAIT_3);

   DebugPrint((PCMCIA_DEBUG_RESOURCES, "device private %08x %08x %08x\n", 
                                        ioResourceDesc->u.DevicePrivate.Data[0],
                                        ioResourceDesc->u.DevicePrivate.Data[1],
                                        ioResourceDesc->u.DevicePrivate.Data[2]
                                        ));
                                        
   ioResourceDesc++;

   //
   // Fill in device private for MF configurations
   //

   if (configCount > 1) {

      for (iConfig = 0; iConfig < configCount; iConfig++) {
         PSOCKET_DATA socketData;

         currentConfigEntry = ConfigList[iConfig].ConfigEntry;
         socketData = ConfigList[iConfig].SocketData;

         ioResourceDesc->Option = 0;
         ioResourceDesc->Type  =  CmResourceTypeDevicePrivate;
         PCMRES_SET_DESCRIPTOR_TYPE(ioResourceDesc, DPTYPE_PCMCIA_MF_CONFIGURATION);

         PCMRES_SET_CONFIG_OPTIONS(ioResourceDesc, currentConfigEntry->IndexForThisConfiguration);
         PCMRES_SET_PORT_RESOURCE_INDEX(ioResourceDesc, socketData->MfIoPortResourceMapIndex);
         if (socketData->DeviceType == PCCARD_TYPE_MODEM) {
            PCMRES_SET_AUDIO_ENABLE(ioResourceDesc);
         }
         PCMRES_SET_CONFIG_REGISTER_BASE(ioResourceDesc, socketData->ConfigRegisterBase);

         DebugPrint((PCMCIA_DEBUG_RESOURCES, "device private MF %08x %08x %08x\n",
                                              ioResourceDesc->u.DevicePrivate.Data[0],
                                              ioResourceDesc->u.DevicePrivate.Data[1],
                                              ioResourceDesc->u.DevicePrivate.Data[2]
                                              ));
         ioResourceDesc++;
      }
   }
   
   ASSERT(ioResourceDesc == &ioResourceList->Descriptors[ioResourceList->Count]);
   
   //
   // Allocate an PCMCIA_RESOURCE_CHAIN structure to track the IO_RESOURCE_LIST.
   //
   resListChain = ExAllocatePool(PagedPool, sizeof(PCMCIA_RESOURCE_CHAIN));
   if (resListChain == NULL) {
      ExFreePool(ioResourceList);
      return STATUS_INSUFFICIENT_RESOURCES;
   }
   
   resListChain->IoResList = ioResourceList;
   
   //
   // Link this new node onto the passed in chain
   //
   resListChain->NextList = *ResListChainHead;
   *ResListChainHead = resListChain;
   
   DebugPrint((PCMCIA_DEBUG_RESOURCES, "Added resource chain node %08x, ioreslist %08x\n",
                                        resListChain, ioResourceList));
   return STATUS_SUCCESS;
}



NTSTATUS
PcmciaMergeResourceChainToList(
   PPCMCIA_RESOURCE_CHAIN ResListChainHead,
   PIO_RESOURCE_REQUIREMENTS_LIST *GeneratedResourceRequirementsList
   )
/*++

Routine Description:

      
Arguments:


Return value:


--*/
{
   PPCMCIA_RESOURCE_CHAIN resListChain;
   PIO_RESOURCE_REQUIREMENTS_LIST ioResourceRequirementsList;
   PIO_RESOURCE_LIST newIoResList, oldIoResList;
   ULONG listSize, listCount, totalDescriptorCount;
   
   PAGED_CODE();
   //
   // Now merge the newly created IO_RESOURCE_LISTs into one big
   // IO_RESOURCE_REQUIREMENTS list.
   //

   listCount = 0;
   totalDescriptorCount = 0;

   for (resListChain = ResListChainHead; resListChain != NULL; resListChain = resListChain->NextList) {
      listCount++;
      totalDescriptorCount += resListChain->IoResList->Count;
   }

   if (totalDescriptorCount > 0) {

      listSize = (totalDescriptorCount - listCount) * sizeof(IO_RESOURCE_DESCRIPTOR)
                + (listCount-1) * sizeof(IO_RESOURCE_LIST)
                +  sizeof(IO_RESOURCE_REQUIREMENTS_LIST);
     
      //
      // Allocate space for the res. req. list here
      //
      ioResourceRequirementsList = (PIO_RESOURCE_REQUIREMENTS_LIST) ExAllocatePool(PagedPool, listSize);
     
      if (ioResourceRequirementsList == NULL) {
         return STATUS_INSUFFICIENT_RESOURCES;
      }
     
      //
      // Init the list
      //
     
      RtlZeroMemory(ioResourceRequirementsList, listSize);
      ioResourceRequirementsList->ListSize = listSize;
      ioResourceRequirementsList->AlternativeLists = listCount;
     
      //
      // Copy in all the other lists. Point the target pointer (newIoResList)
      // at the end of the list, and lay each new list preceding the old
      // one. This is done because the list is LIFO.
      //
     
      newIoResList = (PIO_RESOURCE_LIST) (((PUCHAR) ioResourceRequirementsList) + listSize);
     
      for (resListChain = ResListChainHead; resListChain != NULL; resListChain = resListChain->NextList) {
     
         oldIoResList = resListChain->IoResList;
         listSize = sizeof(IO_RESOURCE_LIST) + (oldIoResList->Count-1)*sizeof(IO_RESOURCE_DESCRIPTOR);
         newIoResList = (PIO_RESOURCE_LIST) (((PUCHAR) newIoResList) - listSize);
     
         DebugPrint((PCMCIA_DEBUG_RESOURCES, "Merge resource chain node %08x, ioreslist %08x\n",
                                              resListChain, oldIoResList));
     
         RtlCopyMemory(newIoResList, oldIoResList, listSize);
      }
     
      ASSERT(newIoResList == &ioResourceRequirementsList->List[0]);
      
      DebugPrint((PCMCIA_DEBUG_RESOURCES, "Resource chain merged to ioResourceRequirementsList %08x\n",
                                              ioResourceRequirementsList));
                                              
   } else {
      ioResourceRequirementsList = NULL;
   }
                                                
   *GeneratedResourceRequirementsList = ioResourceRequirementsList;
   return STATUS_SUCCESS;
}



VOID
PcmciaFreeResourceChain(
   PPCMCIA_RESOURCE_CHAIN ResListChain
   )
/*++

Routine Description:

      
Arguments:


Return value:


--*/
{
   PPCMCIA_RESOURCE_CHAIN prevResListChain;

   PAGED_CODE();
   //
   // free the temporary structures
   //
   while (ResListChain != NULL) {

      DebugPrint((PCMCIA_DEBUG_RESOURCES, "Delete resource chain node %08x, ioreslist %08x\n",
                                           ResListChain, ResListChain->IoResList));
      if (ResListChain->IoResList) {
         ExFreePool(ResListChain->IoResList);
      }
      prevResListChain = ResListChain;
      ResListChain = ResListChain->NextList;
      ExFreePool(prevResListChain);
   }
}   



NTSTATUS
PcmciaMfEnumerateConfigurations(
   IN PPDO_EXTENSION PdoExtension,
   IN PSOCKET_DATA   socketData,
   PCONFIG_LIST      ConfigList,
   IN ULONG          Depth,
   PPCMCIA_RESOURCE_CHAIN *MfResListChain
   )

/*++

Routine Description:

   This routine is responsible for enumerating combinations of resource
   requirements for the functions in a true R2 MF card. It is called
   recursively to perform this function.
   
   See the description of PcmciaMfGetResourceRequirements() to see the
   initial state. This routine runs down the linked list of SocketData
   structures, and each corresponding linked list of ConfigData structures.
   
   When it finds itself at the end of the SocketData list, it is ready
   to build an IoResList for a single permutation. It calls 
   PcmciaConfigEntriesToResourceList() to build a single IoResList.
   
   In the example MF card with two functions, and 2 and 3 resource 
   alternatives respectively, this routine will build a list that looks
   something like this:

   +--------------+
   |MfResListChain|
   +--------------+
              |        +-----------------------+     +----------------+
              +--------|MF_RESOURCE_LIST(A1+B1)|-----|IoResList(A1+B1)|
                       +-----------------------+     +----------------+
                            |
                       +-----------------------+     +----------------+
                       |MF_RESOURCE_LIST(A1+B2)|-----|IoResList(A1+B2)|
                       +-----------------------+     +----------------+
                            |                   
                       +-----------------------+     +----------------+                        
                       |MF_RESOURCE_LIST(A1+B3)|-----|IoResList(A1+B3)|
                       +-----------------------+     +----------------+
                            |                   
                       +-----------------------+     +----------------+
                       |MF_RESOURCE_LIST(A2+B1)|-----|IoResList(A2+B1)|
                       +-----------------------+     +----------------+
                            |                   
                       +-----------------------+     +----------------+
                       |MF_RESOURCE_LIST(A2+B2)|-----|IoResList(A2+B2)|
                       +-----------------------+     +----------------+
                            |                   
                       +-----------------------+     +----------------+
                       |MF_RESOURCE_LIST(A2+B3)|-----|IoResList(A2+B3)|
                       +-----------------------+     +----------------+

   It returns to PcmciaMfGetResourceRequirements() when the list is complete.
                       

Arguments:

   PdoExtension   -  Pointer to the device extension for the PDO of the pc-card

Return Value:

   STATUS_SUCCESS 

--*/
{
   NTSTATUS status = STATUS_SUCCESS;
   PFDO_EXTENSION fdoExtension = PdoExtension->Socket->DeviceExtension;

   PAGED_CODE();

   if (!socketData) {
      //
      // End of SocketData chain, now ready to generate IoResList for this 
      //

      if (PcmciaMfCheckForOverlappingRanges(ConfigList, (LONG)Depth)) {
         //
         // This combination would have generated a bad IoResList
         //
         return STATUS_SUCCESS;
      }

      //
      // Build an io resource list from the current config list
      //

      status = PcmciaConfigEntriesToResourceListChain(PdoExtension,
                                                      ConfigList,
                                                      Depth,
                                                      MfResListChain
                                                      );

   } else {
      PCONFIG_ENTRY configEntry;
      //
      // Not at the bottom of the tree. Recurse through each config entry
      // in this socket data.
      //

      ConfigList[Depth].SocketData = socketData;

      for (configEntry = socketData->ConfigEntryChain;
           configEntry != NULL; configEntry = configEntry->NextEntry) {

         if (configEntry->Flags & PCMCIA_INVALID_CONFIGURATION) {
            continue;
         }

         ConfigList[Depth].ConfigEntry = configEntry;
         
         DebugPrint((PCMCIA_DEBUG_RESOURCES, "pdo %08x mf enum %d sktdata %08x configEntry %08x\n",
                                              PdoExtension->DeviceObject, Depth, socketData, configEntry));

         status = PcmciaMfEnumerateConfigurations(PdoExtension,
                                                  socketData->Next,
                                                  ConfigList,
                                                  Depth+1,
                                                  MfResListChain);
      }
   }
   return status;
}



NTSTATUS
PcmciaMfGetResourceRequirements(
   IN PPDO_EXTENSION PdoExtension,
   PULONG_PTR Information
   )

/*++

Routine Description:

   For true Multifunction R2 cards, this routine generates a conglomerate
   IoResourceList based on the permutations of configurations of the
   functions. 
   
   Initially the tuple parsing code builds an internal representation of
   the configuration requirements of the cards with SocketData and
   ConfigData structures. Each SocketData structure represents an 
   individual function, and each ConfigData represents an alternative
   resource requirement list for that function. 
   
   So for example, an MF card that has two functions may have an internal
   layout like this:

   +------------+
   |PdoExtension|
   +------------+
             |          +-----------+          +-----------+
             +----------|SocketDataA|----------|SocketDataB|----0
                        +-----------+          +-----------+
                                 |                     |        
                              +------------+       +------------+
                              |ConfigDataA1|       |ConfigDataB1|
                              +------------+       +------------+
                                 |                     |       
                              +------------+       +------------+
                              |ConfigDataA2|       |ConfigDataB2|
                              +------------+       +------------+
                                 |                     |       
                                 0                 +------------+
                                                   |ConfigDataB3|
                                                   +------------+
                                                      |
                                                      0
                                                    
   This example shows that function A has two resource requirement alternatives,
   and function B has three. What we do is make permutations of each alternative,
   e.g.:
       A1-B1, A1-B2, A1-B3, A2-B1, A2-B2, A2-B3
       
   The permutations are built with recursive calls to PcmciaMfEnumerateConfigurations().
   In this example, the result of this enumeration will be six independent
   IoResLists. Each IoResList will be a merge of the particular permutation. When
   PcmciaMfEnumerateConfigurations() returns to this routine, these IoResLists will
   be chained together through the pointer MfResListChain. The rest of the routine
   builds a single "six-member" IoResList from the chain. 
   
   Finally the support structure and lists for performing the operation are freed, and
   the single conglomerate list is returned.                       
                       

Arguments:

   PdoExtension   -  Pointer to the device extension for the PDO of the pc-card
   Information - Pointer to an allocated resource requirements list is stored in this
                 argument. Caller's responsibility to free the list

Return value:

  STATUS_INSUFFICIENT_RESOURCES     Could not allocate the list
  STATUS_SUCCES                     Obtained resource requirements, Information contains the pointer
                                    to the IO_RESOURCE_REQUIREMENTS list



--*/
{
   NTSTATUS status;
   PFDO_EXTENSION fdoExtension = PdoExtension->Socket->DeviceExtension;
   ULONG MaxDepth = 0;
   PSOCKET_DATA socketData;
   PCONFIG_LIST ConfigList;
   PPCMCIA_RESOURCE_CHAIN MfResListChain = NULL;
   PIO_RESOURCE_REQUIREMENTS_LIST ioResourceRequirementsList;

   PAGED_CODE();

   ASSERT (IsDeviceMultifunction(PdoExtension));

   //
   // Find out how deep the enumeration will be.
   // Should be the same as Socket->NumberOfFunctions, but just to be paranoid...
   //
   for (socketData = PdoExtension->SocketData; socketData != NULL; socketData = socketData->Next) {
      MaxDepth++;
   }
   
   if (!MaxDepth) {
      ASSERT (PdoExtension->SocketData);
      return STATUS_UNSUCCESSFUL;
   }

   ConfigList = ExAllocatePool(PagedPool, MaxDepth*sizeof(CONFIG_LIST));
   
   if (!ConfigList) {
      return STATUS_INSUFFICIENT_RESOURCES;
   }
   
   PcmciaMfBuildResourceMapInfo(PdoExtension, ConfigList, MaxDepth);
   

   status = PcmciaMfEnumerateConfigurations(PdoExtension,
                                            PdoExtension->SocketData,
                                            ConfigList,
                                            0,
                                            &MfResListChain);

   ExFreePool(ConfigList);

   if (NT_SUCCESS(status)) {
      //
      // Now merge everything that EnumerateConfigurations built into a single list
      //
      status = PcmciaMergeResourceChainToList(MfResListChain, &ioResourceRequirementsList);
   }      
      
   if (NT_SUCCESS(status) && (ioResourceRequirementsList != NULL)) {
      ioResourceRequirementsList->InterfaceType = Isa;
      ioResourceRequirementsList->BusNumber = fdoExtension->Configuration.BusNumber;
      ioResourceRequirementsList->SlotNumber = 0; // Need to revisit this..
      *Information = (ULONG_PTR) ioResourceRequirementsList;

      DebugPrint((PCMCIA_DEBUG_RESOURCES, "pdo %08x mf returning req list %08x, %d alternatives\n",
                                              PdoExtension->DeviceObject, ioResourceRequirementsList,
                                              ioResourceRequirementsList->AlternativeLists                                              
                                              ));
   }

   PcmciaFreeResourceChain(MfResListChain);   
   
   return status;
}



VOID
PcmciaMfBuildResourceMapInfo(
   IN PPDO_EXTENSION PdoExtension,
   PCONFIG_LIST      ConfigList,
   ULONG             ConfigCount
   )
/*++

Routine Description:

   This routine initializes variables in the SocketData structures to allow 
   PcmciaMfEnumerateChild() to correctly build ChildInfo ResourceMaps for MF.SYS.
   
   It needs to calculate the base index for a particular resource of a particular
   function. So for the example of a 2-function MF R2 card, the resulting CmResList
   will be layed out positionally like:

       CmResList
          IRQ (Shared)
          I/O (Function A)
          I/O (Function B)
          Mem (Function A)
          Mem (Function B)
          
   The reason for this is this is simply how PcmciaConfigEntriesToResourceList()
   happens to lay out the requirements. So in order to generate a valid resource 
   map, this routine has to calculate, for example, the Memory Base for function B
   by adding together:
      1 (if there will be an IRQ in the cmreslist)
      # of I/O port resources for A
      # of I/O port resources for B
      # of Mem resource for A
   This sum will give you the position in the CmReslist for the first memory resource
   that B would use. 
   
   These calculations are stored in the socket data structures for each corresponding
   function so that PcmciaMfEnumerateChild() can simply fill in the maps for MF.
      
Arguments:

   PdoExtension   -  Pointer to the device extension for the PDO of the pc-card
   ConfigList - config list array holds a permutation of configdata's
   ConfigCount - # of card functions

Return value:


--*/
{
   PSOCKET_DATA socketData;
   PCONFIG_ENTRY configEntry;
   ULONG index;
   USHORT count;
   UCHAR currentResourceMapIndex = 0;
   BOOLEAN needsIRQ = FALSE;
      
   for (index = 0, socketData = PdoExtension->SocketData; socketData != NULL; socketData = socketData->Next) {
   
      //
      // In the current implementation we assume that all the alternative lists in the
      // io resource requirements for the multifunction parent pc-card have the same number
      // and types of resource requirements. i.e. it's currently illegal to request
      // one configuration in which only IRQ and I/O are requested, for example, and an
      // alternative configuration in which MEMORY is also specified.
      // This is because of the limitation in the MF enumerator - (which in turn relied
      // on the Win 9x implementation).
      // So we currently look at only the first valid configuration - that is representative
      // of all the other configurations.
      //
      for (configEntry = socketData->ConfigEntryChain; (configEntry != NULL)  &&
          (configEntry->Flags & PCMCIA_INVALID_CONFIGURATION);
          configEntry = configEntry->NextEntry);

      if (configEntry == NULL) {
         return;
      }

      ASSERT(index < ConfigCount);

      ConfigList[index].SocketData = socketData;
      ConfigList[index].ConfigEntry = configEntry;
      index++;
   }

   //
   // IRQ is unique because it is the only shared resource. So if the card needs an IRQ, then
   // all devices point to the same resource

   for (index = 0; index < ConfigCount; index++) {
      if (ConfigList[index].ConfigEntry->IrqMask) {
         //
         // Index always maps to zero since PcmciaConfigEntriesToResourceList
         // builds IRQs first.
         //
         ConfigList[index].SocketData->MfIrqResourceMapIndex = currentResourceMapIndex;
         ConfigList[index].SocketData->MfNeedsIrq = TRUE;
         needsIRQ = TRUE;
      }
   }               
   
   if (needsIRQ) {
      currentResourceMapIndex++;
   }      

   //
   // fill in the bases of the I/O port ranges
   //            
   for (index = 0; index < ConfigCount; index++) {
      ConfigList[index].SocketData->MfIoPortResourceMapIndex = currentResourceMapIndex;
      
      count = ConfigList[index].ConfigEntry->NumberOfIoPortRanges;
      
      ConfigList[index].SocketData->MfIoPortCount = count;
      currentResourceMapIndex += count; 
   }               
   
   //
   // fill in the bases of the memory ranges
   //            
   for (index = 0; index < ConfigCount; index++) {
      ConfigList[index].SocketData->MfMemoryResourceMapIndex = currentResourceMapIndex;
      
      count = ConfigList[index].ConfigEntry->NumberOfMemoryRanges;
      
      ConfigList[index].SocketData->MfMemoryCount = count;
      currentResourceMapIndex += count; 
   }               
}
   


BOOLEAN
PcmciaMfCheckForOverlappingRanges(
   PCONFIG_LIST ConfigList,
   LONG ConfigCount
   )
/*++

Routine Description:

   This routine scans through the current config list to see if the set of configurations
   overlap. For example, if the MF R2 card is a dual-serial card, then each serial device
   may want to have one of the standard com addresses (e.g. 3f8, 2f8, etc.). But now
   that we are merging configurations, we need to weed out any overlapping ranges so
   we don't produce a congolmerate IoResList that contains the same range for different
   functions.
      
Arguments:

   ConfigList - config list array holds a permutation of configdata's
   ConfigCount - # of card functions

Return value:


--*/
{
   PCONFIG_ENTRY configEntry1, configEntry2;
   LONG configIndex1, configIndex2;
   LONG configCount1, configCount2;
   LONG rangeIndex1, rangeIndex2;
   LONG rangeCount1, rangeCount2;
   ULONG rangeStart1, rangeStart2;
   ULONG rangeEnd1, rangeEnd2;
   BOOLEAN rangesOverlap = FALSE;

   DebugPrint((PCMCIA_DEBUG_RESOURCES, "-------Range Check--------------\n"));
   //
   // Check for overlap in the I/O port ranges
   //            
   try {
      for (configIndex1 = 0; configIndex1 < ConfigCount; configIndex1++) {
     
         configEntry1 = ConfigList[configIndex1].ConfigEntry;
         rangeCount1 = configEntry1->NumberOfIoPortRanges;
         
         for (rangeIndex1 = 0; rangeIndex1 < rangeCount1; rangeIndex1++) {
            //
            // Get the current range we will compare
            //
            rangeStart1 = configEntry1->IoPortBase[rangeIndex1];
            rangeEnd1 = rangeStart1 + configEntry1->IoPortLength[rangeIndex1];
     
            if (rangeStart1 == 0) {
               DebugPrint((PCMCIA_DEBUG_RESOURCES, "RangeCheck I/O: skip unrestricted range %x.%x\n",
                                                    configIndex1, rangeIndex1));
               continue;
            }
            
            //
            // Now start comparing this against the rest of the ranges by
            // starting at then end and working backwards. 
            //         
            for (configIndex2 = ConfigCount-1; configIndex2 >= 0; configIndex2--) {
                configEntry2 = ConfigList[configIndex2].ConfigEntry;
                rangeCount2 = configEntry2->NumberOfIoPortRanges;
            
               for (rangeIndex2 = rangeCount2-1; rangeIndex2 >= 0; rangeIndex2--) {
     
                  if ((configEntry1 == configEntry2) && (rangeIndex1 == rangeIndex2)) {
                     leave;
                  }

                  rangeStart2 = configEntry2->IoPortBase[rangeIndex2];
                  rangeEnd2 = rangeStart2 + configEntry2->IoPortLength[rangeIndex2];
                  
                  if (rangeStart2 == 0) {
                     DebugPrint((PCMCIA_DEBUG_RESOURCES, "RangeCheck I/O: skip unrestricted range %x.%x\n",
                                                          configIndex2, rangeIndex2));
                     continue;
                  }
                  DebugPrint((PCMCIA_DEBUG_RESOURCES, "RangeCheck I/O: %x.%x %04x-%04x :: %x.%x %04x-%04x\n",
                                             configIndex1, rangeIndex1, rangeStart1, rangeEnd1,
                                             configIndex2, rangeIndex2, rangeStart2, rangeEnd2));
                                             
                  if (((rangeStart1 >= rangeStart2) && (rangeStart1 <= rangeEnd2)) ||
                      ((rangeEnd1 >= rangeStart2) && (rangeEnd1 <= rangeEnd2))) {
                      rangesOverlap = TRUE;
                      leave;
                  }
               }
            }      
         }
      }               
   } finally {
   }      
   
   if (rangesOverlap) {
      DebugPrint((PCMCIA_DEBUG_RESOURCES, "-------Overlap Detected---------\n"));
      return TRUE;
   }

   //
   // Check for overlap in the memory ranges
   //            
   try {
      for (configIndex1 = 0; configIndex1 < ConfigCount; configIndex1++) {
     
         configEntry1 = ConfigList[configIndex1].ConfigEntry;
         rangeCount1 = configEntry1->NumberOfMemoryRanges;
         
         for (rangeIndex1 = 0; rangeIndex1 < rangeCount1; rangeIndex1++) {
            //
            // Get the current range we will compare
            //
            rangeStart1 = configEntry1->MemoryHostBase[rangeIndex1];
            rangeEnd1 = rangeStart1 + configEntry1->MemoryLength[rangeIndex1] - 1;
     
            if (rangeStart1 == 0) {
               DebugPrint((PCMCIA_DEBUG_RESOURCES, "RangeCheck MEM: skip unrestricted range %x.%x\n",
                                                    configIndex1, rangeIndex1));
               continue;
            }
            
            //
            // Now start comparing this against the rest of the ranges by
            // starting at then end and working backwards. 
            //         
            for (configIndex2 = ConfigCount-1; configIndex2 >= 0; configIndex2--) {
                configEntry2 = ConfigList[configIndex2].ConfigEntry;
                rangeCount2 = configEntry2->NumberOfMemoryRanges;
            
               for (rangeIndex2 = rangeCount2-1; rangeIndex2 >= 0; rangeIndex2--) {
     
                  if ((configEntry1 == configEntry2) && (rangeIndex1 == rangeIndex2)) {
                     leave;
                  }

                  rangeStart2 = configEntry2->MemoryHostBase[rangeIndex2];
                  rangeEnd2 = rangeStart2 + configEntry2->MemoryLength[rangeIndex2] - 1;
                  
                  if (rangeStart2 == 0) {
                     DebugPrint((PCMCIA_DEBUG_RESOURCES, "RangeCheck MEM: skip unrestricted range %x.%x\n",
                                                          configIndex2, rangeIndex2));
                     continue;
                  }
                  DebugPrint((PCMCIA_DEBUG_RESOURCES, "RangeCheck MEM: %x.%x %08x-%08x :: %x.%x %08x-%08x\n",
                                             configIndex1, rangeIndex1, rangeStart1, rangeEnd1,
                                             configIndex2, rangeIndex2, rangeStart2, rangeEnd2));
                                             
                  if (((rangeStart1 >= rangeStart2) && (rangeStart1 <= rangeEnd2)) ||
                      ((rangeEnd1 >= rangeStart2) && (rangeEnd1 <= rangeEnd2))) {
                      DebugPrint((PCMCIA_DEBUG_RESOURCES, "-------Overlap Detected---------\n"));
                      rangesOverlap = TRUE;
                      leave;
                  }
               }
            }      
         }
      }               
   } finally {
   }      

#if DBG
   if (rangesOverlap) {
      DebugPrint((PCMCIA_DEBUG_RESOURCES, "-------Overlap Detected---------\n"));
   } else {
      DebugPrint((PCMCIA_DEBUG_RESOURCES, "-------Generate IoResList-------\n"));
   }
#endif
   
   return rangesOverlap;   
}
   
   


NTSTATUS
PcmciaStartPcCard(
   IN PDEVICE_OBJECT Pdo,
   IN PCM_RESOURCE_LIST ResourceList,
   IN OUT PIRP       Irp
   )
/*++

Routine Description:

   This routine attempts to start the PC-Card by configuring it with the supplied resources.


Arguments:

   Pdo - Pointer to the device object representing the PC-Card which needs to be started
   ResourceList - Pointer the list of assigned resources for the PC-Card

Return value:

   STATUS_INSUFFICIENT_RESOURCES - Not sufficient resources supplied to start device/
                                   could not allocate memory
   STATUS_UNSUCCESSFUL           - Supplied resources are invalid for this PC-Card
   STATUS_SUCCESS                - Configured and started the card successfully

--*/
{
   PCM_FULL_RESOURCE_DESCRIPTOR fullResourceDesc;
   PCM_PARTIAL_RESOURCE_LIST partialResourceList;
   PCM_PARTIAL_RESOURCE_DESCRIPTOR partialResourceDesc;
   ULONG fullResourceDescCount, partialResourceDescCount, i, index;
   PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
   PSOCKET socket = pdoExtension->Socket;
   PFDO_EXTENSION fdoExtension = socket->DeviceExtension;
   PSOCKET_DATA   socketData = pdoExtension->SocketData;
   PSOCKET_CONFIGURATION socketConfig;
   PCONFIG_ENTRY         currentConfig;
   PFUNCTION_CONFIGURATION fnConfig;
   NTSTATUS status;
   ULONG scIoIndex = 0, scMemIndex = 0;

   PAGED_CODE();

   if (IsDeviceStarted(pdoExtension)) {
      //
      // Already started..
      //
      return STATUS_SUCCESS;
   }
   
   if (IsDevicePhysicallyRemoved(pdoExtension)) {
      return STATUS_DEVICE_DOES_NOT_EXIST;
   }

   if ( ResourceList == NULL ) {
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   PcmciaCleanupSocketConfiguration(pdoExtension);

   socketConfig = ExAllocatePool(NonPagedPool, sizeof(SOCKET_CONFIGURATION));
   if (!socketConfig) {
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(socketConfig, sizeof(SOCKET_CONFIGURATION));

   fullResourceDescCount = ResourceList->Count;

   ASSERT(fullResourceDescCount == 1);

   fullResourceDesc = &ResourceList->List[0];
   partialResourceList = &fullResourceDesc->PartialResourceList;
   partialResourceDesc = partialResourceList->PartialDescriptors;
   partialResourceDescCount = partialResourceList->Count;

   socketConfig->NumberOfIoPortRanges =
   socketConfig->NumberOfMemoryRanges = 0;

   for (i=0; i< partialResourceList->Count; i++, partialResourceDesc++) {
      switch (partialResourceDesc->Type) {
      case CmResourceTypePort: {
            index = socketConfig->NumberOfIoPortRanges;
            socketConfig->Io[index].Base =  partialResourceDesc->u.Port.Start.LowPart;
            socketConfig->Io[index].Length = (USHORT) partialResourceDesc->u.Port.Length-1;
            socketConfig->NumberOfIoPortRanges++;
            break;
         }

      case CmResourceTypeMemory: {
            index = socketConfig->NumberOfMemoryRanges;
            socketConfig->Memory[index].HostBase = partialResourceDesc->u.Memory.Start.LowPart;
            socketConfig->Memory[index].Length   = partialResourceDesc->u.Memory.Length;
            socketConfig->NumberOfMemoryRanges++;
            break;
         }

      case CmResourceTypeInterrupt: {
            socketConfig->Irq = partialResourceDesc->u.Interrupt.Level;
            DebugPrint((PCMCIA_DEBUG_RESOURCES, "Assigned Irq: 0x%x for socket register offset %d\n",
                        socketConfig->Irq, socket->RegisterOffset));
            break;
         }

      case CmResourceTypePcCardConfig:
      case CmResourceTypeMfCardConfig:
      case CmResourceTypeDevicePrivate: {
            DebugPrint((PCMCIA_DEBUG_RESOURCES, "DevicePrivate received, Data= %08x %08x %08x\n",
                        partialResourceDesc->u.DevicePrivate.Data[0],
                        partialResourceDesc->u.DevicePrivate.Data[1],
                        partialResourceDesc->u.DevicePrivate.Data[2]));

            if (PCMRES_GET_DESCRIPTOR_TYPE (partialResourceDesc) == DPTYPE_PCMCIA_CONFIGURATION) {
               //
               // Single function configuration private
               //
               socketConfig->IndexForCurrentConfiguration = PCMRES_GET_CONFIG_INDEX(partialResourceDesc);
               socketConfig->ConfigRegisterBase = socketData->ConfigRegisterBase;

               DebugPrint((PCMCIA_DEBUG_RESOURCES, "Pccard config resource\n"));
               DebugPrint((PCMCIA_DEBUG_RESOURCES, "  Index %x\n", socketConfig->IndexForCurrentConfiguration));
               
               for (index = 0; index < PCMRES_PCMCIA_MAX_IO; index++) {
               
                  if (scIoIndex >= MAX_NUMBER_OF_IO_RANGES) {
                     break;
                  }
               
                  socketConfig->Io[scIoIndex].Width16     = PCMRES_GET_IO_FLAG(partialResourceDesc, index, PCMRESF_IO_16BIT_ACCESS);
                  socketConfig->Io[scIoIndex].WaitState16 = PCMRES_GET_IO_FLAG(partialResourceDesc, index, PCMRESF_IO_WAIT_16);
                  socketConfig->Io[scIoIndex].Source16    = PCMRES_GET_IO_FLAG(partialResourceDesc, index, PCMRESF_IO_SOURCE_16);
                  socketConfig->Io[scIoIndex].ZeroWait8   = PCMRES_GET_IO_FLAG(partialResourceDesc, index, PCMRESF_IO_ZERO_WAIT_8);
                  
                  DebugPrint((PCMCIA_DEBUG_RESOURCES, "PcCardConfig IO%d - Width:%d, Wait16:%d, Source16:%d, ZeroWait8:%d\n", scIoIndex,
                              socketConfig->Io[scIoIndex].Width16,
                              socketConfig->Io[scIoIndex].WaitState16,
                              socketConfig->Io[scIoIndex].Source16,
                              socketConfig->Io[scIoIndex].ZeroWait8));  
                  
                  scIoIndex++;
               }
               
               for (index = 0; index < PCMRES_PCMCIA_MAX_MEM; index++) {
               
                  if (scMemIndex >= MAX_NUMBER_OF_MEMORY_RANGES) {
                     break;
                  }
                  
                  socketConfig->Memory[scMemIndex].Width16     = PCMRES_GET_MEMORY_FLAG(partialResourceDesc, index, PCMRESF_MEM_16BIT_ACCESS);
                  socketConfig->Memory[scMemIndex].WaitState   = PCMRES_GET_MEMORY_WAITSTATES(partialResourceDesc, index);
                  socketConfig->Memory[scMemIndex].IsAttribute = PCMRES_GET_MEMORY_FLAG(partialResourceDesc, index, PCMRESF_MEM_ATTRIBUTE);
                  socketConfig->Memory[scMemIndex].CardBase    = PCMRES_GET_MEMORY_CARDBASE(partialResourceDesc, index);
                  
                  DebugPrint((PCMCIA_DEBUG_RESOURCES, "PcCardConfig MEM%d - Width:%d, Wait:%d, IsAttr:%d, CardBase:%x\n", scMemIndex,
                              socketConfig->Memory[scMemIndex].Width16,
                              socketConfig->Memory[scMemIndex].WaitState,
                              socketConfig->Memory[scMemIndex].IsAttribute,
                              socketConfig->Memory[scMemIndex].CardBase));    
                  
                  scMemIndex++;
               }                  
               
                                              

            } else if (PCMRES_GET_DESCRIPTOR_TYPE (partialResourceDesc) == DPTYPE_PCMCIA_MF_CONFIGURATION) {
               //
               // Multifunction configuration private
               //
               UCHAR IoResourceIndex;

               fnConfig = ExAllocatePool(NonPagedPool, sizeof(FUNCTION_CONFIGURATION));
               if (!fnConfig) {
                  return STATUS_INSUFFICIENT_RESOURCES;
               }

               RtlZeroMemory(fnConfig, sizeof(FUNCTION_CONFIGURATION));

               fnConfig->ConfigRegisterBase = PCMRES_GET_CONFIG_REGISTER_BASE(partialResourceDesc);
               fnConfig->ConfigOptions = PCMRES_GET_CONFIG_OPTIONS(partialResourceDesc);
               if (PCMRES_GET_AUDIO_ENABLE(partialResourceDesc)) {
                  fnConfig->ConfigFlags = 0x08;
               }

               if (fnConfig->ConfigOptions & 0x02) {
                  IoResourceIndex = PCMRES_GET_PORT_RESOURCE_INDEX(partialResourceDesc);
                  if ((IoResourceIndex < partialResourceList->Count) &&
                     (partialResourceList->PartialDescriptors[IoResourceIndex].Type == CmResourceTypePort)) {

                     fnConfig->IoLimit = (UCHAR) (partialResourceList->PartialDescriptors[IoResourceIndex].u.Port.Length-1);
                     fnConfig->IoBase = partialResourceList->PartialDescriptors[IoResourceIndex].u.Port.Start.LowPart;
                  }
               }

               if (socketConfig->FunctionConfiguration == NULL) {
                  //
                  // This is the first MfConfig
                  //
                  socketConfig->FunctionConfiguration = fnConfig;
               } else {
                  //
                  // Chain it on the end so it is fifo
                  //
                  PFUNCTION_CONFIGURATION mfTmp = socketConfig->FunctionConfiguration;
                  while (mfTmp->Next != NULL) {
                     mfTmp = mfTmp->Next;
                  }
                  mfTmp->Next = fnConfig;
               }
            }
            break;
         }

      default: {
            DebugPrint((PCMCIA_DEBUG_INFO, "PcmciaStartPcCard:Unknown resource type %d handed down",
                        (ULONG) partialResourceDesc->Type));
            break;
         }
      }
   }

   //
   // Power up the card if it isn't already..
   //
   status = PcmciaRequestSocketPower(pdoExtension, NULL);   
      
   if (!NT_SUCCESS(status)) {
      ASSERT(NT_SUCCESS(status));
      return status;
   }
   
   //
   // Turn on ZV for this card, if it needs it
   // 
   if (socketData->Flags & SDF_ZV) {
      PcmciaSetZV(fdoExtension, socket, TRUE);
      SetSocketFlag(socket, SOCKET_CUSTOM_INTERFACE);
   } else if (IsSocketFlagSet(socket, SOCKET_CUSTOM_INTERFACE)) {
      PcmciaSetZV(fdoExtension, socket, FALSE);
      ResetSocketFlag(socket, SOCKET_CUSTOM_INTERFACE);
   }
   
   PcmciaSetAudio(fdoExtension, socket, IsDeviceFlagSet(pdoExtension, PCMCIA_PDO_ENABLE_AUDIO));   

   pdoExtension->SocketConfiguration = socketConfig;
   if (!NT_SUCCESS(PcmciaConfigurePcCard(pdoExtension, NULL))) {
      //
      // Problems in configuring the card: could be the card
      // was removed while configuring it
      //
      pdoExtension->SocketConfiguration = NULL;
      ExFreePool(socketConfig);
      return STATUS_DEVICE_NOT_READY;
   }

   MarkDeviceStarted(pdoExtension);
   MarkDeviceLogicallyInserted(pdoExtension);

   return STATUS_SUCCESS;
}



NTSTATUS
PcmciaStopPcCard(
   IN PDEVICE_OBJECT Pdo
   )
/*++

Routine Description:

   This routine stops and deconfigures the given PC-Card

Arguments:

   Pdo - Pointer to the device object representing the PC-Card which needs to be stopped

Return value:

  STATUS_SUCCESS - PC-Card was already stopped, or stopped and deconfigured now successfully

--*/
{
   PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
   PSOCKET      socket = pdoExtension->Socket;
   PFDO_EXTENSION fdoExtension = socket->DeviceExtension;
   CARD_REQUEST        cardRequest;

   PAGED_CODE();

   if (!IsDeviceStarted(pdoExtension)) {
      return STATUS_SUCCESS;
   }
   //
   // Need to deconfigure the controller
   //
   PcmciaSocketDeconfigure(socket);
   (socket->SocketFnPtr->PCBInitializePcmciaSocket)(socket);

   MarkDeviceNotStarted(pdoExtension);
   return STATUS_SUCCESS;
}



NTSTATUS
PcmciaRemovePcCard(
   IN PDEVICE_OBJECT Pdo,
   IN PIRP           Irp
   )
/*++

Routine Description:

Arguments:

Return value:

--*/
{
   PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
   PSOCKET        socket = pdoExtension->Socket;
   NTSTATUS status;

   PAGED_CODE();

   if (socket == NULL) {
      return STATUS_SUCCESS;
   }

   PcmciaStopPcCard(Pdo);
   PcmciaReleaseSocketPower(pdoExtension, NULL);

   if (IsDevicePhysicallyRemoved(pdoExtension)) {
      PFDO_EXTENSION fdoExtension = socket->DeviceExtension;
      PDEVICE_OBJECT curPdo, prevPdo;
      PPDO_EXTENSION curPdoExt;
      ULONG waitCount = 0;

      //
      // Synchronize with power routines
      // LATER: make these values adjustable
      //     
      while(!PCMCIA_TEST_AND_SET(&pdoExtension->DeletionLock)) {
         PcmciaWait(1000000);
         if (waitCount++ > 20) {
            ASSERT(waitCount <= 20);
            break;
         }
      }
      
      //
      // Delink this Pdo from the FDO list.
      //
      for (curPdo = fdoExtension->PdoList, prevPdo = NULL; curPdo!=NULL; prevPdo = curPdo, curPdo=curPdoExt->NextPdoInFdoChain) {
         curPdoExt = curPdo->DeviceExtension;
         
         if (curPdo == Pdo) {
            if (prevPdo) {
               ((PPDO_EXTENSION)prevPdo->DeviceExtension)->NextPdoInFdoChain = pdoExtension->NextPdoInFdoChain;
            } else {
               fdoExtension->PdoList = pdoExtension->NextPdoInFdoChain;
            }
            break;
     
         }
      }
      
      for (curPdo = socket->PdoList, prevPdo = NULL; curPdo!=NULL; prevPdo = curPdo, curPdo=curPdoExt->NextPdoInSocket) {
         curPdoExt = curPdo->DeviceExtension;
         
         if (curPdo == Pdo) {
            //
            // Delink this Pdo from the socket list.
            //
            if (prevPdo) {
               ((PPDO_EXTENSION)prevPdo->DeviceExtension)->NextPdoInSocket = pdoExtension->NextPdoInSocket;
            } else {
               socket->PdoList = pdoExtension->NextPdoInSocket;
            }
            break;
         }
      }

      PcmciaCleanupSocketConfiguration(pdoExtension);
      PcmciaCleanupPdo(Pdo);
      //
      // Delete..
      //
      if (!IsDeviceDeleted(pdoExtension)) {
         MarkDeviceDeleted(pdoExtension);
         IoDeleteDevice(Pdo);
      }
   
      ResetSocketFlag(socket, SOCKET_CLEANUP_PENDING);
      //
      // If a query_device_relations came in after a card was inserted, but before
      // we have removed the previous card configuration, the enumeration would have been
      // postponed. Here, we start it up again
      //
      if (IsSocketFlagSet(socket, SOCKET_ENUMERATE_PENDING)) {
         ResetSocketFlag(socket, SOCKET_ENUMERATE_PENDING);
         SetSocketFlag(socket, SOCKET_CARD_STATUS_CHANGE);
         IoInvalidateDeviceRelations(fdoExtension->Pdo, BusRelations);
      }

   } else {
      //
      // We will keep this Pdo around, since this is not physically ejected.
      //
      MarkDeviceLogicallyRemoved(pdoExtension);
   }
   
   return STATUS_SUCCESS;
}


VOID
PcmciaCleanupPdo(
   IN PDEVICE_OBJECT Pdo
   )
/*++

Routine Description:

Arguments:

Return value:

--*/
{
   PPDO_EXTENSION          pdoExtension;
   PSOCKET_DATA            socketData, tmpSocketData;

   ASSERT (Pdo != NULL);

   pdoExtension = Pdo->DeviceExtension;
   
   ASSERT(pdoExtension->WaitWakeIrp == NULL);
   
   if (pdoExtension->LowerDevice!=NULL) {
      //
      // Detach our filter device
      //
      IoDetachDevice(pdoExtension->LowerDevice);
      pdoExtension->LowerDevice = NULL;
   }

   socketData = pdoExtension->SocketData;
   pdoExtension->SocketData = NULL;
   while (socketData != NULL) {
      tmpSocketData = socketData;
      socketData = socketData->Next;
      PcmciaCleanupSocketData(tmpSocketData);
   }

   PcmciaCleanupSocketConfiguration(pdoExtension);

   //
   // Cleanup device id
   //
   if (pdoExtension->DeviceId) {
      ExFreePool(pdoExtension->DeviceId);
      pdoExtension->DeviceId = NULL;
   }
   
   if (pdoExtension->CisCache) {
      ExFreePool(pdoExtension->CisCache);
      pdoExtension->CisCache = NULL;
   }
}


VOID
PcmciaCleanupSocketData(
   IN PSOCKET_DATA SocketData
   )
/*++

Routine Descrption

   Frees up the passed in SocketData structure & any
   structures it might point to

Arguments

   SocketData -   Pointer to the SOCKET_DATA structure

Return Value

   none


--*/
{
   PCONFIG_ENTRY           configEntry, nextConfigEntry;

   if (SocketData == NULL) {
      return;
   }
   //
   // Free up the config entry descriptors
   //
   configEntry = SocketData->ConfigEntryChain;
   SocketData->ConfigEntryChain = NULL;
   while (configEntry) {
      nextConfigEntry = configEntry->NextEntry;
      ExFreePool(configEntry);
      configEntry = nextConfigEntry;
   }

   //
   // Free up socket data
   //
   ExFreePool(SocketData);
   return;
}



VOID
PcmciaCleanupSocketConfiguration(
   PPDO_EXTENSION pdoExtension
   )
/*++

Routine Description:

   Frees up the linked list of function configuration, as well as
   the base socket configuration structure itself.

Arguments:

Return value:

--*/
{
   PSOCKET_CONFIGURATION socketConfig = pdoExtension->SocketConfiguration;
   PFUNCTION_CONFIGURATION fnConfig, fnConfigNext;

   if (socketConfig == NULL) {
      return;
   }

   fnConfig = socketConfig->FunctionConfiguration;
   while(fnConfig) {
      fnConfigNext = fnConfig->Next;
      ExFreePool(fnConfig);
      fnConfig = fnConfigNext;
   }

   ExFreePool(pdoExtension->SocketConfiguration);
   pdoExtension->SocketConfiguration = NULL;
}


NTSTATUS
PcmciaPdoDeviceControl(
   IN PDEVICE_OBJECT Pdo,
   IN PIRP Irp
   )
/*++

Routine Description:

Arguments:

Return value:

--*/
{
   PAGED_CODE();

   //
   // No IOCTLs handled currently
   //
   UNREFERENCED_PARAMETER(Pdo);

   Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
   IoCompleteRequest(Irp, IO_NO_INCREMENT);

   return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
PcmciaPdoDeviceCapabilities(
   IN PDEVICE_OBJECT Pdo,
   IN PIRP           Irp
   )
/*++

Routine Description:

   Obtains the device capabilities of the given pc-card.

   If the pc-card is an R2 card (16-bit pc-card), the capabilities
   are constructed from the parent PCMCIA controller's capabilities.
   Finally the obtained capabilities are cached in the pc-card's device
   extension for use in power management of the card.

Arguments:

   Pdo   -    Pointer to the device object for the pc-card
   Irp   -    Pointer to the query device capabilities Irp

Return Value:

   STATUS_SUCCESS                   - Capabilities obtained and recorded in the passed in pointer
   STATUS_INSUFFICIENT_RESOURCES    - Could not allocate memory to cache the capabilities

--*/
{
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
   PDEVICE_CAPABILITIES capabilities = irpStack->Parameters.DeviceCapabilities.Capabilities;
   PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
   PDEVICE_CAPABILITIES busCapabilities = &pdoExtension->Socket->DeviceExtension->DeviceCapabilities;

   PAGED_CODE();

   //
   // R2 card. Fill in the capabilities ourselves..
   //

   capabilities->Removable = TRUE;
   capabilities->UniqueID = TRUE;
   capabilities->EjectSupported = FALSE;

   capabilities->Address = pdoExtension->Socket->RegisterOffset;
   // Don't know the UINumber, just leave it alone
   

   if (busCapabilities->DeviceState[PowerSystemWorking] != PowerDeviceUnspecified) {
      capabilities->DeviceState[PowerSystemWorking] = busCapabilities->DeviceState[PowerSystemWorking];
      capabilities->DeviceState[PowerSystemSleeping1] = busCapabilities->DeviceState[PowerSystemSleeping1];
      capabilities->DeviceState[PowerSystemSleeping2] = busCapabilities->DeviceState[PowerSystemSleeping2];
      capabilities->DeviceState[PowerSystemSleeping3] = busCapabilities->DeviceState[PowerSystemSleeping3];
      capabilities->DeviceState[PowerSystemHibernate] = busCapabilities->DeviceState[PowerSystemHibernate];
      capabilities->DeviceState[PowerSystemShutdown] = busCapabilities->DeviceState[PowerSystemShutdown];

      capabilities->SystemWake = MIN(PowerSystemSleeping3, busCapabilities->SystemWake);
      capabilities->DeviceWake = PowerDeviceD0; // don't rely on FDO mungeing in the right thing for r2 cards
      capabilities->D1Latency = busCapabilities->D1Latency;
      capabilities->D2Latency = busCapabilities->D2Latency;
      capabilities->D3Latency = busCapabilities->D3Latency;
   } else {
      capabilities->DeviceState[PowerSystemWorking]   = PowerDeviceD0;
      capabilities->DeviceState[PowerSystemSleeping1] = PowerDeviceD3;
      capabilities->DeviceState[PowerSystemSleeping2] = PowerDeviceD3;
      capabilities->DeviceState[PowerSystemSleeping3] = PowerDeviceD3;
      capabilities->DeviceState[PowerSystemHibernate] = PowerDeviceD3;
      capabilities->DeviceState[PowerSystemShutdown] = PowerDeviceD3;

      capabilities->SystemWake = PowerSystemUnspecified;
      capabilities->DeviceWake = PowerDeviceD0; // don't rely on FDO mungeing in the right thing for r2 cards
      capabilities->D1Latency = 0;    // No latency - since we do nothing
      capabilities->D2Latency = 0;    //
      capabilities->D3Latency = 100;
   }
   //
   // Store these capabilities away..
   //

   RtlCopyMemory(&pdoExtension->DeviceCapabilities,
                 capabilities,
                 sizeof(DEVICE_CAPABILITIES));

   return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\pcmcibus\pdopower.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    pdopower.c

Abstract:

    This module contains code to handle
    IRP_MJ_POWER dispatches for PDOs
    enumerated by the PCMCIA bus driver


Authors:

    Ravisankar Pudipeddi (ravisp) May 30, 1997
    Neil Sandlin (neilsa) June 1 1999    

Environment:

    Kernel mode only

Notes:

Revision History:

    Neil Sandlin (neilsa) 04-Mar-1999
      Made device power a state machine

--*/

#include "pch.h"

//
// Internal References
//

NTSTATUS
PcmciaPdoWaitWake(
   IN  PDEVICE_OBJECT Pdo,
   IN  PIRP           Irp,
   OUT BOOLEAN       *CompleteIrp
   );
   
VOID
PcmciaPdoWaitWakeCancelRoutine(
   IN PDEVICE_OBJECT Pdo,
   IN OUT PIRP Irp
   );
   
NTSTATUS
PcmciaSetPdoPowerState(
   IN PDEVICE_OBJECT Pdo,
   IN OUT PIRP Irp
   );
   
NTSTATUS
PcmciaSetPdoSystemPowerState(
   IN PDEVICE_OBJECT Pdo,
   IN OUT PIRP Irp
   );
   
NTSTATUS
PcmciaPdoPowerWorker(
   IN PVOID          Context,
   IN NTSTATUS       DeferredStatus
   );
   
VOID
MoveToNextPdoPowerWorkerState(
   PPDO_EXTENSION pdoExtension
   );
   
NTSTATUS
PcmciaPdoPowerSentIrpComplete(
   IN PDEVICE_OBJECT Pdo,
   IN PIRP           Irp,
   IN PVOID          Context
   );
   
NTSTATUS
PcmciaPdoPowerCompletion(
   IN PDEVICE_OBJECT Pdo,
   IN PIRP           Irp,
   IN PVOID          Context
   );
   
NTSTATUS   
PcmciaPdoCompletePowerIrp(
   IN PPDO_EXTENSION pdoExtension,
   IN PIRP Irp,
   IN NTSTATUS status
   );
   
//
// 
//


NTSTATUS
PcmciaPdoPowerDispatch(
   IN PDEVICE_OBJECT Pdo,
   IN PIRP Irp
   )

/*++

Routine Description:

    This routine handles power requests
    for the PDOs.

Arguments:

    Pdo - pointer to the physical device object
    Irp - pointer to the io request packet

Return Value:

    status

--*/

{
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
   NTSTATUS        status = STATUS_INVALID_DEVICE_REQUEST;
   PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;

   if(IsDevicePhysicallyRemoved(pdoExtension) || IsDeviceDeleted(pdoExtension)) {
      // couldn't aquire RemoveLock - we're in the process of being removed - abort
      status = STATUS_NO_SUCH_DEVICE;
      PoStartNextPowerIrp( Irp );
      Irp->IoStatus.Status = status;
      IoCompleteRequest( Irp, IO_NO_INCREMENT );
      return status;
   }

   InterlockedIncrement(&pdoExtension->DeletionLock);


   switch (irpStack->MinorFunction) {

   case IRP_MN_SET_POWER: {
         DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x irp %08x --> IRP_MN_SET_POWER\n", Pdo, Irp));
         DebugPrint((PCMCIA_DEBUG_POWER, "                              (%s%x, context %x)\n",
                     (irpStack->Parameters.Power.Type == SystemPowerState)  ?
                     "S":
                     ((irpStack->Parameters.Power.Type == DevicePowerState) ?
                      "D" :
                      "Unknown"),
                     irpStack->Parameters.Power.State,
                     irpStack->Parameters.Power.SystemContext
                    ));

         status = PcmciaSetPdoPowerState(Pdo, Irp);
         break;
      }
   case IRP_MN_QUERY_POWER: {


         DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x irp %08x --> IRP_MN_QUERY_POWER\n", Pdo, Irp));
         DebugPrint((PCMCIA_DEBUG_POWER, "                              (%s%x, context %x)\n",
                     (irpStack->Parameters.Power.Type == SystemPowerState)  ?
                     "S":
                     ((irpStack->Parameters.Power.Type == DevicePowerState) ?
                      "D" :
                      "Unknown"),
                     irpStack->Parameters.Power.State,
                     irpStack->Parameters.Power.SystemContext
                    ));

         status = PcmciaPdoCompletePowerIrp(pdoExtension, Irp, STATUS_SUCCESS);
         break;
      }

   case IRP_MN_WAIT_WAKE: {

         BOOLEAN completeIrp;

         DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x irp %08x --> IRP_MN_WAIT_WAKE\n", Pdo, Irp));
         //
         // Should not have a wake pending already
         //
         ASSERT (!(((PPDO_EXTENSION)Pdo->DeviceExtension)->Flags & PCMCIA_DEVICE_WAKE_PENDING));

         status = PcmciaPdoWaitWake(Pdo, Irp, &completeIrp);

         if (completeIrp) {
            InterlockedDecrement(&pdoExtension->DeletionLock);
            PoStartNextPowerIrp(Irp);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
         }
         break;
      }

   default: {
      //
      // Unhandled minor function
      //
      PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;

      status = PcmciaPdoCompletePowerIrp(pdoExtension, Irp, Irp->IoStatus.Status);
      }      
   }

   DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x irp %08x <-- %08x\n", Pdo, Irp, status));
   return status;
}



NTSTATUS
PcmciaPdoWaitWake(
   IN  PDEVICE_OBJECT Pdo,
   IN  PIRP           Irp,
   OUT BOOLEAN       *CompleteIrp
   )
/*++


Routine Description

   Handles WAIT_WAKE for the given pc-card.

Arguments

   Pdo - Pointer to the device object for the pc-card
   Irp - The IRP_MN_WAIT_WAKE Irp
   CompleteIrp - This routine will set this to TRUE if the IRP should be
                 completed after this is called and FALSE if it should not be
                 touched

Return Value

   STATUS_PENDING    - Wait wake is pending
   STATUS_SUCCESS    - Wake is already asserted, wait wake IRP is completed
                       in this case
   Any other status  - Error
--*/
{

   PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
   PSOCKET socket = pdoExtension->Socket;
   PFDO_EXTENSION fdoExtension = socket->DeviceExtension;
   NTSTATUS       status;
   
   *CompleteIrp = FALSE;

   ASSERT (socket != NULL);

   if ((pdoExtension->DeviceCapabilities.DeviceWake == PowerDeviceUnspecified) ||
       (pdoExtension->DeviceCapabilities.DeviceWake < pdoExtension->DevicePowerState)) {
      //
      // Either we don't support wake at all OR the current device power state
      // of the PC-Card doesn't support wake
      //
      return STATUS_INVALID_DEVICE_STATE;
   }

   if (pdoExtension->Flags & PCMCIA_DEVICE_WAKE_PENDING) {
      //
      // A WAKE is already pending
      //
      return STATUS_DEVICE_BUSY;
   }

   status = PcmciaFdoArmForWake(socket->DeviceExtension);
   
   if (!NT_SUCCESS(status)) {
      return status;
   }

   //for the time being, expect STATUS_PENDING from FdoArmForWake
   ASSERT(status == STATUS_PENDING);
   
   //
   // Parent has one (more) waiter..
   //
   InterlockedIncrement(&fdoExtension->ChildWaitWakeCount);
   //for testing, make sure there is only one waiter   
   ASSERT (fdoExtension->ChildWaitWakeCount == 1);
   

   pdoExtension->WaitWakeIrp = Irp;
   pdoExtension->Flags |= PCMCIA_DEVICE_WAKE_PENDING;
   
   //
   // Set Ring enable/cstschg for the card here..
   //
   (*socket->SocketFnPtr->PCBEnableDisableWakeupEvent)(socket, pdoExtension, TRUE);

   //
   // PCI currently does not do anything with a WW irp for a cardbus PDO. So we hack around
   // this here by not passing the irp down. Instead it is held pending here, so we can
   // set a cancel routine just like the read PDO driver would. If PCI were to do something
   // with the irp, we could code something like the following:
   //
   // if (IsCardBusCard(pdoExtension)) {
   //    IoSetCompletionRoutine(Irp, PcmciaPdoWaitWakeCompletion, pdoExtension,TRUE,TRUE,TRUE);
   //    IoCopyCurrentIrpStackLocationToNext(Irp);
   //    status = IoCallDriver (pdoExtension->LowerDevice, Irp);
   //    ASSERT (status == STATUS_PENDING);
   //    return status;
   // }      
       

   IoMarkIrpPending(Irp);

   //
   // Allow IRP to be cancelled..
   //
   IoSetCancelRoutine(Irp, PcmciaPdoWaitWakeCancelRoutine);

   IoSetCompletionRoutine(Irp,
                          PcmciaPdoWaitWakeCompletion,
                          pdoExtension,
                          TRUE,
                          TRUE,
                          TRUE);

   return STATUS_PENDING;
}



NTSTATUS
PcmciaPdoWaitWakeCompletion(
   IN PDEVICE_OBJECT Pdo,
   IN PIRP           Irp,
   IN PPDO_EXTENSION PdoExtension
   )
/*++

Routine Description

   Completion routine called when a pending IRP_MN_WAIT_WAKE Irp completes

Arguments

   Pdo  -   Pointer to the physical device object for the pc-card
   Irp  -   Pointer to the wait wake IRP
   PdoExtension - Pointer to the device extension for the Pdo

Return Value

   Status from the IRP

--*/
{
   PSOCKET socket = PdoExtension->Socket;
   PFDO_EXTENSION fdoExtension = socket->DeviceExtension;
   
   DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x irp %08x --> WaitWakeCompletion\n", Pdo, Irp));

   ASSERT (PdoExtension->Flags & PCMCIA_DEVICE_WAKE_PENDING);

   PdoExtension->Flags &= ~PCMCIA_DEVICE_WAKE_PENDING;
   PdoExtension->WaitWakeIrp = NULL;
   //
   // Reset ring enable/cstschg
   //

   (*socket->SocketFnPtr->PCBEnableDisableWakeupEvent)(socket, PdoExtension, FALSE);
   
   ASSERT (fdoExtension->ChildWaitWakeCount > 0);
   InterlockedDecrement(&fdoExtension->ChildWaitWakeCount);
   //
   // Wake completed
   //
   
   InterlockedDecrement(&PdoExtension->DeletionLock);
   return Irp->IoStatus.Status;
}



VOID
PcmciaPdoWaitWakeCancelRoutine(
   IN PDEVICE_OBJECT Pdo,
   IN OUT PIRP Irp
   )
/*++

Routine Description:

    Cancel an outstanding (pending) WAIT_WAKE Irp.
    Note: The CancelSpinLock is held on entry

Arguments:

    Pdo     -  Pointer to the physical device object for the pc-card
               on which the WAKE is pending
    Irp     -  Pointer to the WAIT_WAKE Irp to be cancelled

Return Value

    None

--*/
{
   PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
   PSOCKET        socket = pdoExtension->Socket;
   PFDO_EXTENSION fdoExtension = socket->DeviceExtension;

   DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x irp %08x --> WaitWakeCancelRoutine\n", Pdo, Irp));

   IoReleaseCancelSpinLock(Irp->CancelIrql);

   if (pdoExtension->WaitWakeIrp == NULL) {
      //
      //  Wait wake already completed/cancelled
      //
      return;
   }

   pdoExtension->Flags &= ~PCMCIA_DEVICE_WAKE_PENDING;
   pdoExtension->WaitWakeIrp = NULL;

   //
   // Reset ring enable, disabling wake..
   //
   (*socket->SocketFnPtr->PCBEnableDisableWakeupEvent)(socket, pdoExtension, FALSE);
   
   //
   // Since this is cancelled, see if parent's wait wake
   // needs to be cancelled too.
   // First, decrement the number of child waiters..
   //
   
   ASSERT (fdoExtension->ChildWaitWakeCount > 0);
   if (InterlockedDecrement(&fdoExtension->ChildWaitWakeCount) == 0) {
      //
      // No more waiters.. cancel the parent's wake IRP
      //
      ASSERT(fdoExtension->WaitWakeIrp);
      
      if (fdoExtension->WaitWakeIrp) {
         IoCancelIrp(fdoExtension->WaitWakeIrp);
      }         
   }

   
   InterlockedDecrement(&pdoExtension->DeletionLock);
   //
   // Complete the IRP
   //
   Irp->IoStatus.Information = 0;

   //
   // Is this necessary?
   //
   PoStartNextPowerIrp(Irp);

   Irp->IoStatus.Status = STATUS_CANCELLED;
   IoCompleteRequest(Irp, IO_NO_INCREMENT);
}



NTSTATUS
PcmciaSetPdoPowerState(
   IN PDEVICE_OBJECT Pdo,
   IN OUT PIRP Irp
   )

/*++

Routine Description

   Dispatches the IRP based on whether a system power state
   or device power state transition is requested

Arguments

   Pdo      - Pointer to the physical device object for the pc-card
   Irp      - Pointer to the Irp for the power dispatch

Return value

   status

--*/
{
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
   PPDO_EXTENSION     pdoExtension = Pdo->DeviceExtension;
   PSOCKET            socket = pdoExtension->Socket;
   PFDO_EXTENSION     fdoExtension=socket->DeviceExtension;
   NTSTATUS status;

   PCMCIA_ACQUIRE_DEVICE_LOCK(fdoExtension);

   //
   // Don't handle any power requests for dead pdos
   //
   if (IsSocketFlagSet(socket, SOCKET_CARD_STATUS_CHANGE)) {
        PCMCIA_RELEASE_DEVICE_LOCK(fdoExtension);
        //
        // Card probably removed..
        //
        
        InterlockedDecrement(&pdoExtension->DeletionLock);
        status = STATUS_NO_SUCH_DEVICE;
        Irp->IoStatus.Status = status;
        DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x irp %08x comp %08x\n", Pdo, Irp, status));
        PoStartNextPowerIrp(Irp);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return status;
   }

   PCMCIA_RELEASE_DEVICE_LOCK(fdoExtension);


   switch (irpStack->Parameters.Power.Type) {
   
   case DevicePowerState:
   
      PCMCIA_ACQUIRE_DEVICE_LOCK(fdoExtension);
      
      if (fdoExtension->DevicePowerState != PowerDeviceD0) {

         IoMarkIrpPending(Irp);
         status = STATUS_PENDING;
         InsertTailList(&fdoExtension->PdoPowerRetryList,
                        (PLIST_ENTRY) Irp->Tail.Overlay.DriverContext);
                        
         PCMCIA_RELEASE_DEVICE_LOCK(fdoExtension);
      } else {                        
         PCMCIA_RELEASE_DEVICE_LOCK(fdoExtension);
      
         status = PcmciaSetPdoDevicePowerState(Pdo, Irp);
      }         
      break;

   case SystemPowerState:
      status = PcmciaSetPdoSystemPowerState(Pdo, Irp);
      break;

   default:
      status = PcmciaPdoCompletePowerIrp(pdoExtension, Irp, Irp->IoStatus.Status);
   }      

   return status;
}



NTSTATUS
PcmciaSetPdoDevicePowerState(
   IN PDEVICE_OBJECT Pdo,
   IN OUT PIRP Irp
   )
/*++

Routine Description

   Handles the device power state transition for the given pc-card.
   If the state corresponds to a power-up, the parent for this pc-card
   is requested to be powered up first. Similarily if this is a power-down
   the parent is notified so that it may power down if all the children
   are powered down.

Arguments

   Pdo      - Pointer to the physical device object for the pc-card
   Irp      - Irp for the system state transition

Return value

   status

--*/
{
   PPDO_EXTENSION  pdoExtension = Pdo->DeviceExtension;
   PSOCKET         socket       = pdoExtension->Socket;
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
   DEVICE_POWER_STATE  newDevicePowerState;
   NTSTATUS status;
   BOOLEAN setPowerRequest;

   newDevicePowerState = irpStack->Parameters.Power.State.DeviceState;

   DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x transitioning D state %d => %d\n",
                                     Pdo, pdoExtension->DevicePowerState, newDevicePowerState));

   setPowerRequest = FALSE;

   if (newDevicePowerState == PowerDeviceD0 ||
       newDevicePowerState == PowerDeviceD1 ||
       newDevicePowerState == PowerDeviceD2) {

      if (pdoExtension->DevicePowerState == PowerDeviceD3) {
         // D3 --> D0, D1 or D2 .. Wake up
         setPowerRequest = TRUE;
         SetDeviceFlag(pdoExtension, PCMCIA_POWER_WORKER_POWERUP);
      } else {
         //
         // Nothing to do here...
         //

      }
   } else {  /* newDevicePowerState == D3 */
      if (pdoExtension->DevicePowerState != PowerDeviceD3) {
         //
         // We need to power down now.
         //
         setPowerRequest=TRUE;
         ResetDeviceFlag(pdoExtension, PCMCIA_POWER_WORKER_POWERUP);
      }

   }

   if (setPowerRequest) {
      if (pdoExtension->DevicePowerState == PowerDeviceD0) {
         //
         // Getting out of D0 -  Call PoSetPowerState first
         //
         POWER_STATE newPowerState;
     
         newPowerState.DeviceState = newDevicePowerState;
     
         PoSetPowerState(Pdo,
                         DevicePowerState,
                         newPowerState);
      }
      
      ASSERT(pdoExtension->PowerWorkerState == PPW_Stopped);
      pdoExtension->PowerWorkerState = PPW_InitialState;
      pdoExtension->PendingPowerIrp = Irp;
      
      status = PcmciaPdoPowerWorker(pdoExtension, STATUS_SUCCESS);

   } else {
      status = PcmciaPdoCompletePowerIrp(pdoExtension, Irp, STATUS_SUCCESS);
   }
   return status;
}



NTSTATUS
PcmciaPdoPowerWorker(
   IN PVOID Context,
   IN NTSTATUS status
   )
/*++

Routine Description

   State machine for executing the requested DevicePowerState change.

Arguments

   Context        - pdoExtension for the device
   DeferredStatus - status from last deferred operation

Return Value

   status

--*/
{
   PPDO_EXTENSION pdoExtension = Context;
   PSOCKET socket = pdoExtension->Socket;
   PIRP Irp;
   UCHAR CurrentState = pdoExtension->PowerWorkerState;
   ULONG DelayTime = 0;
   
   DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x power worker - %s\n", pdoExtension->DeviceObject,
                                    PDO_POWER_WORKER_STRING(CurrentState)));

   MoveToNextPdoPowerWorkerState(pdoExtension);
   
   if (!NT_SUCCESS(status)) {
      //
      // An error occurred previously. Skip to the end of the sequence
      //
      while((CurrentState != PPW_Exit) && (CurrentState != PPW_Stopped)) {
         CurrentState = pdoExtension->PowerWorkerState;
         MoveToNextPdoPowerWorkerState(pdoExtension);
      }
   }      
   
   switch(CurrentState) {

   
   case PPW_InitialState:
      status = STATUS_SUCCESS;
      break;
      

   case PPW_PowerUp:      
      status = PcmciaRequestSocketPower(pdoExtension, PcmciaPdoPowerWorker);
      break;
      
   case PPW_PowerUpComplete:      
      if (!NT_SUCCESS(status)) {
         PcmciaReleaseSocketPower(pdoExtension, NULL);
      }         
      break;
      

   case PPW_PowerDown:      
      status = PcmciaReleaseSocketPower(pdoExtension, PcmciaPdoPowerWorker);
      break;
      

   case PPW_CardBusRefresh:
      //
      // Make sure the cardbus card is really working
      //
      status = PcmciaConfigureCardBusCard(pdoExtension);
      
      if (NT_SUCCESS(status) && pdoExtension->WaitWakeIrp) {
         //
         // Make sure stuff like PME_EN is on
         //
         (*socket->SocketFnPtr->PCBEnableDisableWakeupEvent)(socket, pdoExtension, TRUE);
      } 
      break;
      

   case PPW_SendIrpDown:         
      //
      // We're going to send the IRP down. Set completion routine
      // and copy the stack
      //
      if ((Irp=pdoExtension->PendingPowerIrp)!=NULL) {
         IoMarkIrpPending(Irp);
         IoCopyCurrentIrpStackLocationToNext(Irp);
         IoSetCompletionRoutine(Irp,
                                PcmciaPdoPowerSentIrpComplete,
                                pdoExtension,
                                TRUE, TRUE, TRUE);
         
         status = PoCallDriver(pdoExtension->LowerDevice, Irp);
         DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x irp %08x sent irp returns %08x\n", pdoExtension->DeviceObject, Irp, status));
         ASSERT(NT_SUCCESS(status));
         status = STATUS_PENDING;
      } 
      break;
      

   case PPW_CardBusDelay:
      //
      // Make sure the cardbus card is really working
      //
      {
         UCHAR          BaseClass;
         GetPciConfigSpace(pdoExtension, CFGSPACE_CLASSCODE_BASECLASS, &BaseClass, 1)
         if (BaseClass == PCI_CLASS_SIMPLE_COMMS_CTLR) {
            //
            // Wait for modem to warm up
            //
            DelayTime = CBModemReadyDelay;
         }      
      }         
      break;
      

   case PPW_16BitConfigure:
      
      if (IsDeviceStarted(pdoExtension)) {
      
         status = PcmciaConfigurePcCard(pdoExtension, PcmciaPdoPowerWorker);
         DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x 16bit configure returns %08x\n", pdoExtension->DeviceObject, status));
         
      }
      break;


   case PPW_Exit:
      if ((Irp=pdoExtension->PendingPowerIrp)!=NULL) {
         //
         // This is the IRP (for the pdo) that originally caused us to power up the parent
         // Complete it now
         //
     
         if (NT_SUCCESS(status)) {
            PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
            BOOLEAN callPoSetPowerState;
            
            callPoSetPowerState = TRUE;
        
            Irp->IoStatus.Information = irpStack->Parameters.Power.State.DeviceState;
        
            if (irpStack->Parameters.Power.Type == DevicePowerState) {
        
               if (pdoExtension->DevicePowerState == PowerDeviceD0) {
                  //
                  // PoSetPowerState is called before we power down
                  //
                  callPoSetPowerState = FALSE;
               }
        
               if (pdoExtension->DevicePowerState != irpStack->Parameters.Power.State.DeviceState) {
        
                  DebugPrint ((PCMCIA_DEBUG_POWER, "pdo %08x irp %08x transition D state complete: %d => %d\n",
                               pdoExtension->DeviceObject, Irp, pdoExtension->DevicePowerState, irpStack->Parameters.Power.State.DeviceState));
        
                  pdoExtension->DevicePowerState = (SYSTEM_POWER_STATE)Irp->IoStatus.Information;
               }
            }
        
            if (callPoSetPowerState) {
               //
               // we didn't get out of device D0 state. calling PoSetPowerState now
               //
               PoSetPowerState (
                               pdoExtension->DeviceObject,
                               irpStack->Parameters.Power.Type,
                               irpStack->Parameters.Power.State
                               );
            }
        
         } else {
        
            DebugPrint ((PCMCIA_DEBUG_FAIL,"PDO Ext 0x%x failed power Irp 0x%x. status = 0x%x\n", pdoExtension, Irp, status));
            
            if (status == STATUS_NO_SUCH_DEVICE) {
               PFDO_EXTENSION fdoExtension=socket->DeviceExtension;
               
               SetSocketFlag(socket, SOCKET_CARD_STATUS_CHANGE);
               IoInvalidateDeviceRelations(fdoExtension->Pdo, BusRelations);
            }
         }
         
         //
         // Finally, complete the irp
         //

         pdoExtension->PendingPowerIrp = NULL;
         
         Irp->IoStatus.Status = status;
         DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x irp %08x comp %08x\n", pdoExtension->DeviceObject, Irp, Irp->IoStatus.Status));
         InterlockedDecrement(&pdoExtension->DeletionLock);
         PoStartNextPowerIrp (Irp);
         IoCompleteRequest(Irp, IO_NO_INCREMENT);
      }
      break;
   

   case PPW_Stopped:
      return status;
      
   default:
      ASSERT(FALSE);
   }
   
   if (status == STATUS_PENDING) {
      DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x power worker exit %08x\n", pdoExtension->DeviceObject, status));
      //
      // Current action calls us back
      //
      if ((Irp=pdoExtension->PendingPowerIrp)!=NULL) {
         IoMarkIrpPending(Irp);
      }         
      return status;
   }
   //
   // Not done yet. Recurse or call timer
   //

   if (DelayTime) {

      DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x power worker delay type %s, %d usec\n", pdoExtension->DeviceObject,
                                                (KeGetCurrentIrql() < DISPATCH_LEVEL) ? "Wait" : "Timer",
                                                DelayTime));

      if (KeGetCurrentIrql() < DISPATCH_LEVEL) {
         PcmciaWait(DelayTime);
      } else {
         LARGE_INTEGER  dueTime;
         //
         // Running on a DPC, kick of a kernel timer
         //

         pdoExtension->PowerWorkerDpcStatus = status;
         dueTime.QuadPart = -((LONG) DelayTime*10);
         KeSetTimer(&pdoExtension->PowerWorkerTimer, dueTime, &pdoExtension->PowerWorkerDpc);

         //
         // We will reenter on timer dpc
         //
         if ((Irp=pdoExtension->PendingPowerIrp)!=NULL) {
            IoMarkIrpPending(Irp);
         }         
         return STATUS_PENDING;
      }
   }   
   //
   // recurse
   //
   return (PcmciaPdoPowerWorker(pdoExtension, status));
}



NTSTATUS
PcmciaPdoPowerSentIrpComplete(
   IN PDEVICE_OBJECT Pdo,
   IN PIRP           Irp,
   IN PVOID          Context
   )
/*++

Routine Description

    This is the completion routine for the device power IRPs sent
    by PCMCIA to the underlying PCI PDO for cardbus cards.
    All this does currently is return STATUS_MORE_PROCESSING_REQUIRED
    to indicate that we'll complete the Irp later.

Arguments

    Pdo      - Pointer to device object for the cardbus card
    Irp      - Pointer to the IRP
    Context  - Unreferenced

Return Value

    STATUS_MORE_PROCESSING_REQUIRED

--*/
{
   PPDO_EXTENSION pdoExtension = Context;

#if !(DBG)
   UNREFERENCED_PARAMETER (Pdo);
#endif   

   DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x irp %08x sent irp complete %08x\n", Pdo, Irp, Irp->IoStatus.Status));

   pdoExtension->PowerWorkerDpcStatus = Irp->IoStatus.Status;
   
   KeInsertQueueDpc(&pdoExtension->PowerWorkerDpc, NULL, NULL);
   
   return STATUS_MORE_PROCESSING_REQUIRED;

}



VOID
PcmciaPdoPowerWorkerDpc(
   IN PKDPC Dpc,
   IN PVOID Context,
   IN PVOID SystemArgument1,
   IN PVOID SystemArgument2
   )
/*++

Routine Description

    This is the completion routine for socket power requests coming
    from the PdoPowerWorker.

Arguments


Return Value


--*/
{
   PPDO_EXTENSION pdoExtension = Context;
   NTSTATUS status;
   DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x pdo power worker dpc\n", pdoExtension->DeviceObject));
   
   status = PcmciaPdoPowerWorker(pdoExtension, pdoExtension->PowerWorkerDpcStatus);
   
   DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x pdo power worker dpc exit %08x\n", pdoExtension->DeviceObject, status));
}



VOID
MoveToNextPdoPowerWorkerState(
   PPDO_EXTENSION pdoExtension
   )
/*++

Routine Description

   State machine for executing the requested DevicePowerState change.

Arguments

   Context        - pdoExtension for the device
   DeferredStatus - status from last deferred operation

Return Value

   status

--*/
{
   static UCHAR PowerCardBusUpSequence[]   = {PPW_CardBusRefresh,
                                              PPW_SendIrpDown,
                                              PPW_CardBusDelay,
                                              PPW_Exit,
                                              PPW_Stopped};
                                              
   static UCHAR PowerCardBusDownSequence[] = {PPW_SendIrpDown,
                                              PPW_Exit,
                                              PPW_Stopped};
                                              
   static UCHAR Power16BitUpSequence[]     = {PPW_PowerUp,
                                              PPW_PowerUpComplete,
                                              PPW_16BitConfigure,
                                              PPW_Exit,
                                              PPW_Stopped};
                                              
   static UCHAR Power16BitDownSequence[]   = {PPW_PowerDown,
                                              PPW_Exit,
                                              PPW_Stopped};

   if (pdoExtension->PowerWorkerState == PPW_InitialState) {
      //
      // Initialize sequence and phase
      //
      pdoExtension->PowerWorkerPhase = 0;
   
      pdoExtension->PowerWorkerSequence =
                       IsCardBusCard(pdoExtension) ?
                          (IsDeviceFlagSet(pdoExtension, PCMCIA_POWER_WORKER_POWERUP) ?
                             PowerCardBusUpSequence : PowerCardBusDownSequence)
                                                   :
                          (IsDeviceFlagSet(pdoExtension, PCMCIA_POWER_WORKER_POWERUP) ?
                             Power16BitUpSequence   : Power16BitDownSequence);
   }

   //
   // The next state is pointed to by the current phase
   //   
   pdoExtension->PowerWorkerState =
      pdoExtension->PowerWorkerSequence[ pdoExtension->PowerWorkerPhase ];

   //
   // Increment the phase, but not past the end of the sequence
   //   
   if (pdoExtension->PowerWorkerState != PPW_Stopped) {
      pdoExtension->PowerWorkerPhase++;
   }
}  
   


NTSTATUS
PcmciaSetPdoSystemPowerState(
   IN PDEVICE_OBJECT Pdo,
   IN OUT PIRP Irp
   )
/*++

Routine Description

   Handles the system power state transition for the given pc-card.

Arguments

   Pdo      - Pointer to the physical device object for the pc-card
   Irp      - Irp for the system state transition

Return value

   status
   
--*/
{
   PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
   SYSTEM_POWER_STATE  systemPowerState;


   systemPowerState = irpStack->Parameters.Power.State.SystemState;
   DebugPrint((PCMCIA_DEBUG_POWER, "pdo %08x transitioning S state %d => %d\n",
               Pdo, pdoExtension->SystemPowerState, systemPowerState));

   pdoExtension->SystemPowerState = systemPowerState;
   //
   // We are done.
   //
   return PcmciaPdoCompletePowerIrp(pdoExtension, Irp, STATUS_SUCCESS);
}

 
NTSTATUS   
PcmciaPdoCompletePowerIrp(
   IN PPDO_EXTENSION pdoExtension,
   IN PIRP Irp,
   IN NTSTATUS status
   )
/*++

Routine Description

   Completion routine for the Power Irp directed to the PDO of the
   pc-card. 


Arguments

   DeviceObject   -  Pointer to the PDO for the pc-card
   Irp            -  Irp that needs to be completed

Return Value

   None

--*/   
{
   if (IsCardBusCard(pdoExtension)) {
      //
      // Pass irp down the stack
      //
      InterlockedDecrement(&pdoExtension->DeletionLock);
      PoStartNextPowerIrp(Irp);
      IoSkipCurrentIrpStackLocation(Irp);
      status = PoCallDriver(pdoExtension->LowerDevice, Irp);
   } else {
      //
      // Complete the irp for R2 cards
      //
      InterlockedDecrement(&pdoExtension->DeletionLock);
      Irp->IoStatus.Status = status;
      PoStartNextPowerIrp(Irp);
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
   }
   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\pcmcibus\ricoh.c ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    ricoh.c

Abstract:

    This module contains the code that contains
    Ricoh cardbus controller specific initialization and
    other dispatches

Author:

    Ravisankar Pudipeddi (ravisp) 1-Nov-97


Environment:

    Kernel mode

Revision History :


--*/

#include "pch.h"



VOID
RicohInitialize(IN PFDO_EXTENSION FdoExtension)
/*++

Routine Description:

    Initialize Ricoh cardbus controllers

Arguments:

    FdoExtension - Pointer to the device extension for the controller FDO

Return Value:

    None
--*/
{
    USHORT word;
    UCHAR revisionID;

    //LATER: Remove this IF statement, it was added for paranoia once the other
    // Ricoh controllers were added at the last minute. 
    if (FdoExtension->ControllerType == PcmciaRL5C466) {
    GetPciConfigSpace(FdoExtension, CFGSPACE_RICOH_IF16_CTRL, &word, 2);
    word |= IF16_LEGACY_LEVEL_1 | IF16_LEGACY_LEVEL_2;
    SetPciConfigSpace(FdoExtension, CFGSPACE_RICOH_IF16_CTRL, &word, 2);
    } 
#ifdef HACK_RICOH
    PcicWriteSocket(FdoExtension->SocketList, PCIC_CARD_INT_CONFIG, 0x08);
#endif

    GetPciConfigSpace(FdoExtension, CFGSPACE_REV_ID, &revisionID, 1);
    
    if (((FdoExtension->ControllerType == PcmciaRL5C475) && (revisionID >= 0x80) && (revisionID <= 0x9f)) ||
        ((FdoExtension->ControllerType == PcmciaRL5C476) && (revisionID >= 0x80)) ) {

       //
       // Hack to make sure NICs work ok (information is from Intel)
       // (revision of original hack is from Ricoh)
       //
       // What this does:
       // The power save feature of the Ricoh controllers enables the switching off of
       // portions of the clock domain during certain times when, during design, it
       // appeared that this reduce power consumption of the overall device.  However,
       // when this feature is enabled, timing between the PCI Request, Grant, and Frame
       // control signals is made more stringent such that the controller becomes
       // incompatible with some devices that fully support the PCI specification.
       // The additional current consumed by the controller when the power save feature
       // is disabled is small, on the order of a few milliamps.
       //

       ULONG dword;
       ULONG org_value;

       GetPciConfigSpace(FdoExtension, 0x8C, &org_value, 4);
       org_value &= 0xFF0000FF;

       dword = 0xAA5500;
       SetPciConfigSpace(FdoExtension, 0x8C, &dword, 4);

       dword = org_value | 0x30AA5500;
       SetPciConfigSpace(FdoExtension, 0x8C, &dword, 4);

       dword = org_value | 0x30000000;
       SetPciConfigSpace(FdoExtension, 0x8C, &dword, 4);
    }

   //
   // initialize IRQ routing to ISA
   //

   GetPciConfigSpace(FdoExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
   word |= BCTRL_IRQROUTING_ENABLE;
   SetPciConfigSpace(FdoExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
}


BOOLEAN
RicohSetZV(
   IN PSOCKET Socket,
   IN BOOLEAN Enable
   )
{
   UCHAR bData;

   if (Enable) {

      bData = PcicReadSocket(Socket, PCIC_RICOH_MISC_CTRL1);
      bData |= RICOH_MC1_ZV_ENABLE;
      PcicWriteSocket(Socket, PCIC_RICOH_MISC_CTRL1, bData);

   } else {

      bData = PcicReadSocket(Socket, PCIC_RICOH_MISC_CTRL1);
      bData &= ~RICOH_MC1_ZV_ENABLE;
      PcicWriteSocket(Socket, PCIC_RICOH_MISC_CTRL1, bData);

   }
   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\pcmcibus\socket.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    socket.c

Abstract:

    This module contains the socket functions of the pcmcia driver

Author:

    Neil Sandlin (neilsa) 3-Mar-1999

Environment:

    Kernel mode

Revision History :


--*/

#include "pch.h"

//
// Internal References
//

NTSTATUS
PcmciaQueueSocketPowerRequest(
   IN PSOCKET Socket,
   IN UCHAR InitialState,
   IN PPCMCIA_COMPLETION_ROUTINE PowerCompletionRoutine,
   IN PVOID Context
   );

VOID
PcmciaConfigurationWorkerInitialization(
   PPDO_EXTENSION  pdoExtension
   );

NTSTATUS
PcmciaConfigurePcCardMemIoWindows(
   IN PSOCKET Socket,
   IN PSOCKET_CONFIGURATION SocketConfig
   );

NTSTATUS
PcmciaConfigurePcCardIrq(
   IN PSOCKET Socket,
   IN PSOCKET_CONFIGURATION SocketConfig
   );

NTSTATUS
PcmciaConfigurePcCardRegisters(
   PPDO_EXTENSION  pdoExtension
   );

VOID
PcmciaConfigureModemHack(
   IN PSOCKET Socket,
   IN PSOCKET_CONFIGURATION SocketConfig
   );

BOOLEAN
PcmciaProcessConfigureRequest(
   IN PFDO_EXTENSION DeviceExtension,
   IN PSOCKET Socket,
   IN PCARD_REQUEST CardConfigurationRequest
   );


#ifdef ALLOC_PRAGMA
   #pragma alloc_text(PAGE, PcmciaGetConfigData)
#endif



NTSTATUS
PcmciaRequestSocketPower(
   IN PPDO_EXTENSION PdoExtension,
   IN PPCMCIA_COMPLETION_ROUTINE PowerCompletionRoutine
   )
/*++

Routine Description:

   This routine maintains a reference count of how many devices have requested power.
   When the count increments from zero to one, a call is made to actually turn power
   on.

Arguments:

   Socket -  Pointer to the socket for which power is to be applied
   PowerCompletionRoutine - routine to be called after configuration is complete

Return value:

   status

--*/
{
   NTSTATUS status = STATUS_SUCCESS;
   PSOCKET socket = PdoExtension->Socket;
   PFDO_EXTENSION fdoExtension = socket->DeviceExtension;

   DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %08x request power\n", socket));

   if (PCMCIA_TEST_AND_SET(&PdoExtension->SocketPowerRequested)) {
   
      if (InterlockedIncrement(&socket->PowerRequests) == 1) {
     
         DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %08x power requests now %d, status %08x\n", socket, socket->PowerRequests));
         status = PcmciaSetSocketPower(socket, PowerCompletionRoutine, PdoExtension, TRUE);
         
      }
   }
   return status;
}



NTSTATUS
PcmciaReleaseSocketPower(
   IN PPDO_EXTENSION PdoExtension,
   IN PPCMCIA_COMPLETION_ROUTINE PowerCompletionRoutine
   )
/*++

Routine Description:

   This routine maintains a reference count of how many devices have requested power.
   When the count decrements from one to zero, a call is made to actually turn power
   off.

Arguments:

   Socket -  Pointer to the socket for which power is to be removed
   PowerCompletionRoutine - routine to be called after configuration is complete

Return value:

   status

--*/
{
   NTSTATUS status = STATUS_SUCCESS;
   PSOCKET socket = PdoExtension->Socket;
   PFDO_EXTENSION fdoExtension = socket->DeviceExtension;

   DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %08x release power\n", socket));

   if (PCMCIA_TEST_AND_RESET(&PdoExtension->SocketPowerRequested)) {
      
      if (InterlockedDecrement(&socket->PowerRequests) == 0) {
     
         DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %08x power requests now %d, status %08x\n", socket, socket->PowerRequests));
         //
         // Never actually turn off the drive rails for cardbus functions since
         // we don't have tight integration with pci.sys, and config space will
         // disappear
         //
         if (!IsCardBusCardInSocket(socket)) {
            status = PcmciaSetSocketPower(socket, PowerCompletionRoutine, PdoExtension, FALSE);
         }
      }
      
      ASSERT(socket->PowerRequests >= 0);
   }
   
   return status;
}



NTSTATUS
PcmciaSetSocketPower(
   IN PSOCKET Socket,
   IN PPCMCIA_COMPLETION_ROUTINE PowerCompletionRoutine,
   IN PVOID Context,
   IN BOOLEAN PowerOn
   )
/*++

Routine Description:

   This routine is entered when we know the power state of the socket will
   actually be set.

   NOTE: If this routine is called at less than DISPATCH_LEVEL, then the call
   will complete (not return STATUS_PENDING). If this routine is called at
   DISPATCH_LEVEL or greater, this routine returns STATUS_PENDING, and completes
   the power process using a KTIMER.

Arguments:

   Socket -  Pointer to the socket for which power is to be removed
   PowerCompletionRoutine - routine to be called after configuration is complete

Return value:

   status

--*/
{
   NTSTATUS status;
   PFDO_EXTENSION fdoExtension = Socket->DeviceExtension;
   SPW_STATE InitialState = PowerOn ? SPW_RequestPower : SPW_ReleasePower;

   DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %08x set power %s\n", Socket, PowerOn ? "ON" : "OFF"));

   if (!PCMCIA_TEST_AND_SET(&Socket->WorkerBusy)) {
      return STATUS_DEVICE_BUSY;
   }
   
   ASSERT(Socket->WorkerState == SPW_Stopped);

   //
   // committed, will enter SocketPowerWorker now
   //

   Socket->WorkerState = InitialState;
   Socket->PowerCompletionRoutine = PowerCompletionRoutine;
   Socket->PowerCompletionContext = Context;

   PcmciaSocketPowerWorker(&Socket->PowerDpc, Socket, NULL, NULL);

   DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %08x SetSocketPower returning %08x\n",
                                     Socket, Socket->CallerStatus));
   return(Socket->CallerStatus);
}



VOID
PcmciaSocketPowerWorker(
   IN PKDPC Dpc,
   IN PVOID Context,
   IN PVOID SystemArgument1,
   IN PVOID SystemArgument2
   )
/*++
Routine Description

   This routine handles the power up process of a socket. Because such
   long delays are needed, and because this routine may be called at
   raised irql, this is a state machine that has the capability of
   calling itself on a KTIMER.

Arguments

   same as KDPC (DeferredContext is socket)

Return Value

   status

--*/
{
   PSOCKET               Socket = Context;
   PFDO_EXTENSION fdoExtension = Socket->DeviceExtension;
   NTSTATUS              status = Socket->DeferredStatus;
   ULONG                 DelayTime = 0;
   BOOLEAN               ContinueExecution = TRUE;

#if DBG
   {
      ULONG Phase = 0;
      switch(Socket->WorkerState) {
      case SPW_SetPowerOn:
      case SPW_SetPowerOff:
         Phase = Socket->PowerPhase;
         break;
      }
      if (Phase) {
         DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %08x power worker - %s(%d)\n", Socket,
                                       SOCKET_POWER_WORKER_STRING(Socket->WorkerState), Phase));
      } else {
         DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %08x power worker - %s\n", Socket,
                                       SOCKET_POWER_WORKER_STRING(Socket->WorkerState)));
      }
   }
#endif

   //
   // Socket power state machine
   //

   switch(Socket->WorkerState) {


   case SPW_RequestPower:

      status = STATUS_SUCCESS;

      if (IsSocketFlagSet(Socket, SOCKET_CARD_POWERED_UP)) {
         Socket->WorkerState = SPW_Exit;
      } else {
         if ((KeGetCurrentIrql() >= DISPATCH_LEVEL) && (Socket->PowerCompletionRoutine == NULL)) {
            ASSERT((KeGetCurrentIrql() < DISPATCH_LEVEL) || (Socket->PowerCompletionRoutine != NULL));
            //
            // no completion routine at raised irql
            //
            status = STATUS_INVALID_PARAMETER;
         } else {
            //
            // All ok, continue to next state
            //
            Socket->PowerPhase = 1;
            Socket->WorkerState = SPW_SetPowerOn;
         }
      }

      break;


   case SPW_ReleasePower:

      status = STATUS_SUCCESS;

      if (!IsSocketFlagSet(Socket, SOCKET_CARD_POWERED_UP)) {
         Socket->WorkerState = SPW_Exit;
      } else {
         if ((KeGetCurrentIrql() >= DISPATCH_LEVEL) && (Socket->PowerCompletionRoutine == NULL)) {
            ASSERT((KeGetCurrentIrql() < DISPATCH_LEVEL) || (Socket->PowerCompletionRoutine != NULL));
            //
            // no completion routine at raised irql
            //
            status = STATUS_INVALID_PARAMETER;
         } else {
            //
            // All ok, continue to next state
            //
            Socket->WorkerState = SPW_Deconfigure;
         }
      }

      break;


   case SPW_SetPowerOn:
      //
      // Turn power ON
      //
      status = (*(DeviceDispatchTable[fdoExtension->DeviceDispatchIndex].SetPower))
                                 (Socket, TRUE, &DelayTime);

      Socket->PowerPhase++;
      if (status != STATUS_MORE_PROCESSING_REQUIRED) {
         if (NT_SUCCESS(status)) {
            //
            // Done with power up, proceed to the init sequence
            //
            SetSocketFlag(Socket, SOCKET_CARD_POWERED_UP);
            DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %08x power UP\n", Socket));
            Socket->WorkerState = SPW_ResetCard;
            Socket->CardResetPhase = 1;
         } else if (status == STATUS_INVALID_DEVICE_STATE) {
            //
            // Power was already on, don't reset the card
            //
            SetSocketFlag(Socket, SOCKET_CARD_POWERED_UP);
            DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %08x power already UP\n", Socket));
            Socket->WorkerState = SPW_Exit;
            status = STATUS_SUCCESS;
         } else {
            //
            // Power didn't go on
            //
            DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %08x poweron fail %08x\n", Socket, status));
            Socket->WorkerState = SPW_Exit;
         }
      }
      break;
      

   case SPW_ResetCard:
      //
      // Make sure the card is ready to be enumerated
      //
      status = (*(Socket->SocketFnPtr->PCBResetCard))(Socket, &DelayTime);
      Socket->CardResetPhase++;

      if (status != STATUS_MORE_PROCESSING_REQUIRED) {
         Socket->WorkerState = SPW_Exit;
      }
      break;

   case SPW_Deconfigure:
      PcmciaSocketDeconfigure(Socket);
      Socket->PowerPhase = 1;
      Socket->WorkerState = SPW_SetPowerOff;
      break;

   case SPW_SetPowerOff:
      //
      // Turn power OFF
      //
      status = (*(DeviceDispatchTable[fdoExtension->DeviceDispatchIndex].SetPower))
                                 (Socket, FALSE, &DelayTime);

      Socket->PowerPhase++;
      if (status != STATUS_MORE_PROCESSING_REQUIRED) {
         Socket->WorkerState = SPW_Exit;
         if (NT_SUCCESS(status)) {
            //
            // Power is now off
            //
            ResetSocketFlag(Socket, SOCKET_CARD_POWERED_UP);
            DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %08x power DOWN\n", Socket));
         } else if (status == STATUS_INVALID_DEVICE_STATE) {
            //
            // Power was already off
            //
            ResetSocketFlag(Socket, SOCKET_CARD_POWERED_UP);
            DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %08x power already DOWN\n", Socket));
            status = STATUS_SUCCESS;
         } else {
            //
            // Power didn't go off
            //
            DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %08x poweroff fail %08x\n", Socket, status));
            Socket->WorkerState = SPW_Exit;
         }
      }
      break;


   case SPW_Exit:

      if (!NT_SUCCESS(status)) {
         DebugPrint((PCMCIA_DEBUG_FAIL, "skt %08x SocketPowerWorker FAILED, status %08x\n", Socket, status));
         ASSERT(NT_SUCCESS(status));
      }
      
      //
      // Done. Update flags, and call the completion routine if required
      //
      if (PCMCIA_TEST_AND_RESET(&Socket->DeferredStatusLock)) {
         PPCMCIA_COMPLETION_ROUTINE PowerCompletionRoutine = Socket->PowerCompletionRoutine;
         PVOID PowerCompletionContext = Socket->PowerCompletionContext;

         Socket->WorkerState = SPW_Stopped;
         PCMCIA_TEST_AND_RESET(&Socket->WorkerBusy);
      
         if (PowerCompletionRoutine) {
            (*PowerCompletionRoutine)(PowerCompletionContext, status);
         } else {
            ASSERT(PowerCompletionRoutine != NULL);
         }
      } else {
         Socket->CallerStatus = status;
         Socket->WorkerState = SPW_Stopped;
         PCMCIA_TEST_AND_RESET(&Socket->WorkerBusy);
      }

      return;

   default:
      ASSERT(FALSE);
      return;
   }

   //
   // Now check the results
   //

   if (status == STATUS_PENDING) {
      DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %08x worker exit, status pending\n", Socket));
      //
      // whatever returned pending will call us back
      //
      if (PCMCIA_TEST_AND_SET(&Socket->DeferredStatusLock)) {
         //
         // First time that we are waiting, we will return to original
         // caller. So update the main power status just this time.
         //
         Socket->CallerStatus = STATUS_PENDING;
      }
      return;
   }

   //
   // remember for next time
   //
   Socket->DeferredStatus = status;

   if (!NT_SUCCESS(status) && (status != STATUS_MORE_PROCESSING_REQUIRED)) {
      Socket->WorkerState = SPW_Exit;
      DelayTime = 0;
   }

   //
   // Not done yet. Recurse or call timer
   //

   if (DelayTime) {

      DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %08x power worker delay type %s, %d usec\n", Socket,
                                                (KeGetCurrentIrql() < DISPATCH_LEVEL) ? "Wait" : "Timer",
                                                DelayTime));

      if (KeGetCurrentIrql() < DISPATCH_LEVEL) {
         PcmciaWait(DelayTime);
      } else {
         LARGE_INTEGER  dueTime;
         //
         // Running on a DPC, kick of a kernel timer
         //
         if (PCMCIA_TEST_AND_SET(&Socket->DeferredStatusLock)) {
            //
            // First time that we are waiting, we will return to original
            // caller. So update the main power status just this time.
            //
            Socket->CallerStatus = STATUS_PENDING;
         }

         dueTime.QuadPart = -((LONG) DelayTime*10);
         KeSetTimer(&Socket->PowerTimer, dueTime, &Socket->PowerDpc);

         //
         // We will reenter on timer dpc
         //
         return;
      }
   }
   //
   // Recurse
   //
   PcmciaSocketPowerWorker(&Socket->PowerDpc, Socket, NULL, NULL);
}



VOID
PcmciaGetSocketStatus(
   IN PSOCKET Socket
   )
/*++

Routine Description:

   A small utility routine that returns some common socket flags. The reason
   it exists is to allow the Enumerate Devices routine to remain pagable.

   NOTE: This routine updates the "software view" of the device state. This
         should only be done at well-defined points in the driver. In particular,
         you do not want to be updating the software state immediately after
         a surprise remove. Instead, most of the driver needs to continue to
         believe the card is still there while it does its unconfigure and 
         poweroff.

Arguments:

   Socket - The socket in which the PC-Card resides
   boolean parameters are written according to socket flags

Return Value:

   none

--*/
{
   BOOLEAN isCardInSocket, isCardBusCard;
   UCHAR previousDeviceState;

   PCMCIA_ACQUIRE_DEVICE_LOCK(Socket->DeviceExtension);

   isCardInSocket = (*(Socket->SocketFnPtr->PCBDetectCardInSocket))(Socket);

   isCardBusCard = FALSE;
   if (isCardInSocket && CardBus(Socket)) {
      isCardBusCard = ((CBReadSocketRegister(Socket, CARDBUS_SOCKET_PRESENT_STATE_REG) & CARDBUS_CB_CARD) != 0);
   }      

   previousDeviceState = Socket->DeviceState;
   
   if (!isCardInSocket) {
      SetSocketEmpty(Socket);
   } else if (isCardBusCard) {
      SetCardBusCardInSocket(Socket);
   } else {      
      Set16BitCardInSocket(Socket);
   }
   
   if (previousDeviceState != Socket->DeviceState) {
      DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %x Socket Status: Card Status Change!\n", Socket));
      SetSocketFlag(Socket, SOCKET_CARD_STATUS_CHANGE);
   }      
   
   DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %x Socket Status: %s\n",
                                    Socket, isCardInSocket ? (isCardBusCard ? "INSERTED Cardbus" : "INSERTED R2") : "EMPTY"));

   PCMCIA_RELEASE_DEVICE_LOCK(Socket->DeviceExtension);

   //
   // Fill in socket power values
   //
   if (isCardInSocket && IsSocketFlagSet(Socket, SOCKET_CARD_STATUS_CHANGE) && Socket->SocketFnPtr->PCBGetPowerRequirements) {
      (*(Socket->SocketFnPtr->PCBGetPowerRequirements))(Socket);
   }

}



NTSTATUS
PcmciaGetConfigData(
   PPDO_EXTENSION PdoExtension
   )
/*++

Routine Description:

   This routine controls the translation of the CIS config data for the card into
   SOCKET_DATA structures chained onto the PDO. The action of this routine depends
   on the type of device:

   1) For a standard R2 card, a single SOCKET_DATA structure is linked to the pdo
      extension, which contains a straight translation of the CIS contents.
   2) For a fully compliant true R2 MF card, a chain of SOCKET_DATA structures is
      created, one for each function on the card.
   3) For a non-conforming R2 MF card (the typical case), a single structure is
      linked just like case #1.
   4) For a CardBus card, a single SOCKET_DATA is linked to the pdo extension. If
      there are multiple functions on the device, then there will be multiple pdo
      extensions, each with a single SOCKET_DATA structure.

Arguments:

   pdoExtension - The pdo extension corresponding to the specified pccard or cb function.

Return Value:

   STATUS_SUCCESS
   STATUS_NO_SUCH_DEVICE if no card is present in the socket (i.e. the passed in PDO is 'dead')

--*/
{
   NTSTATUS status = STATUS_SUCCESS;
   PSOCKET_DATA  socketData, prevSocketData;
   PSOCKET_DATA  socketDataList = NULL;
   UCHAR         function = 0;
   PSOCKET Socket = PdoExtension->Socket;

   PAGED_CODE ();

   if (!IsCardInSocket(Socket)) {
      //
      // Card probably removed,
      // and Pdo's ghost still hanging around
      //
      return STATUS_NO_SUCH_DEVICE;
   }

   ResetSocketFlag(Socket, SOCKET_CARD_MEMORY);
   ResetSocketFlag(Socket, SOCKET_CARD_CONFIGURED);

   DebugPrint((PCMCIA_DEBUG_SOCKET, "skt %08x performing GetSocketData\n", Socket));

   Socket->NumberOfFunctions = 1;
   prevSocketData = NULL;

   while (function < 255) {
      //
      // Parse tuples of  next function on the card
      //
      socketData = ExAllocatePool(NonPagedPool, sizeof(SOCKET_DATA));

      if (socketData == NULL) {
         status = STATUS_INSUFFICIENT_RESOURCES;
         break;
      }

      RtlZeroMemory(socketData, sizeof(SOCKET_DATA));
      socketData->Function = function;
      socketData->PdoExtension = PdoExtension;
      socketData->Socket = Socket;
      DebugPrint((PCMCIA_DEBUG_SOCKET, "Parsing function %d...\n", socketData->Function));

      status = PcmciaParseFunctionData(Socket, socketData);

      if (NT_SUCCESS(status)) {
         //
         // Link it to the list of socketdata structures
         //
         socketData->Prev = prevSocketData;
         socketData->Next = NULL;
         if (prevSocketData) {
            prevSocketData->Next = socketData;
         } else {
            //
            // This is the first function on the card
            // Make it the head of the list
            //
            socketDataList = socketData;
         }
         
         if (socketData->DeviceType == PCCARD_TYPE_MODEM) {
            SetDeviceFlag(PdoExtension, PCMCIA_PDO_ENABLE_AUDIO);
         }
      } else {
         //
         // no more functions on this card
         //
         ExFreePool(socketData);
         if ((function > 0) && (status == STATUS_NO_MORE_ENTRIES)) {
            status = STATUS_SUCCESS;
         }
         break;
      }
      function++;
      prevSocketData = socketData;
   }

   if (!NT_SUCCESS(status)) {

      socketData = socketDataList;

      while(socketData) {

         prevSocketData = socketData;
         socketData = socketData->Next;
         ExFreePool(prevSocketData);

      }

   } else {

      PdoExtension->SocketData = socketDataList;
   }
   return status;
}




UCHAR
PcmciaReadCISChar(
   PPDO_EXTENSION PdoExtension,
   IN MEMORY_SPACE MemorySpace,
   IN ULONG Offset
   )

/*++

Routine Description:

    Returns the card data.  This information is cached in the socket
    structure.  This way once a PCCARD is enabled it will not be touched
    due to a query ioctl.

Arguments:

    Context

Return Value:

    TRUE

--*/

{
   PSOCKET socket = PdoExtension->Socket;
   PDEVICE_OBJECT pdo;
   UCHAR retValue = 0xff;
   ULONG relativeOffset;
   ULONG bytesRead;


   if (socket && IsCardInSocket(socket)) {

      if (!PdoExtension->CisCache) {
#define PCMCIA_CIS_CACHE_SIZE 2048
         PdoExtension->CisCache = ExAllocatePool(NonPagedPool, PCMCIA_CIS_CACHE_SIZE);

         PdoExtension->CisCacheSpace = 0xff;
         PdoExtension->CisCacheBase = 0;
      }

      if (PdoExtension->CisCache) {

         if ((MemorySpace != PdoExtension->CisCacheSpace) ||
             (Offset < PdoExtension->CisCacheBase) ||
             (Offset > PdoExtension->CisCacheBase + PCMCIA_CIS_CACHE_SIZE - 1)) {

            //
            // LATER: If devices have CIS > CacheSize, then we should window this
            //
            bytesRead = (*(socket->SocketFnPtr->PCBReadCardMemory))(PdoExtension,
                                                                    MemorySpace,
                                                                    0,
                                                                    PdoExtension->CisCache,
                                                                    PCMCIA_CIS_CACHE_SIZE);

            PdoExtension->CisCacheSpace = MemorySpace;
         }

         relativeOffset = Offset - PdoExtension->CisCacheBase;

         if (relativeOffset < PCMCIA_CIS_CACHE_SIZE) {
            retValue = PdoExtension->CisCache[relativeOffset];
         }
      }
   }

   return retValue;
}



NTSTATUS
PcmciaReadWriteCardMemory(
   IN      PDEVICE_OBJECT Pdo,
   IN      ULONG          WhichSpace,
   IN OUT  PUCHAR         Buffer,
   IN      ULONG          Offset,
   IN      ULONG          Length,
   IN      BOOLEAN        Read
   )
/*++

Routine Description:

    This routine is to provide IRP_MN_READ_CONFIG/WRITE_CONFIG support: this would locate the
    socket on which Pdo resides and map the card's  memory into the system space.
    If Read is TRUE  it would:
      copy the contents of the config memory at a specified offset and length to  the
      caller supplied buffer.
    else
      copy the contents of the caller specified buffer at the specified offset and length of
      the config memory

     Note: this has to be non-paged since it can be called by
     clients at DISPATCH_LEVEL

Arguments:

 Pdo -          Device object representing the PC-CARD whose config memory needs to be read/written
 WhichSpace -   Indicates which memory space needs to be mapped: one of
                PCCARD_COMMON_MEMORY_SPACE
                PCCARD_ATTRIBUTE_MEMORY_SPACE
                PCCARD_PCI_CONFIGURATION_MEMORY_SPACE (only for cardbus cards)


 Buffer -       Caller supplied buffer into/out of which the memory contents are copied
                Offset -       Offset of the attribute memory at which we copy
                Length -       Number of bytes of attribute memory/buffer to be copied

 Return value:
        STATUS_INVALID_PARAMETER_1
        STATUS_INVALID_PARAMETER_2
        STATUS_INVALID_PARAMETER_3    If supplied parameters are not valid
        STATUS_NO_SUCH_DEVICE         No PC-Card in the socket
        STATUS_DEVICE_NOT_READY       PC-Card not initialized yet or some other hardware related error
        STATUS_SUCCESS                Contents copied as requested
--*/
{
   PSOCKET socket;
   PSOCKET_DATA socketData;
   PUCHAR tupleData;
   ULONG  tupleDataSize;
   PPDO_EXTENSION pdoExtension;
   NTSTATUS status = STATUS_UNSUCCESSFUL;

   pdoExtension = Pdo->DeviceExtension;
   socket= pdoExtension->Socket;

   //
   // Got to have a card in the socket to read/write from it..
   //
   if (!IsCardInSocket(socket)) {
      return STATUS_NO_SUCH_DEVICE;
   }
   //
   // Memory space has to be one of the defined ones.
   //
   if ((WhichSpace != PCCARD_COMMON_MEMORY) &&
       (WhichSpace != PCCARD_ATTRIBUTE_MEMORY) &&
       (WhichSpace != PCCARD_PCI_CONFIGURATION_SPACE)) {

      return STATUS_INVALID_PARAMETER_1;
   }

   //
   // We support PCCARD_PCI_CONFIGURATION_SPACE only
   // for cardbus cards (doesn't make sense for R2 cards)
   // Similarily PCCARD_ATTRIBUTE/COMMON_MEMORY only for
   // R2 cards
   //
   if ((((WhichSpace == PCCARD_ATTRIBUTE_MEMORY) ||
         (WhichSpace == PCCARD_COMMON_MEMORY)) && !Is16BitCard(pdoExtension)) ||
       ((WhichSpace == PCCARD_PCI_CONFIGURATION_SPACE) && !IsCardBusCard(pdoExtension))) {
      return STATUS_INVALID_PARAMETER_1;
   }

   if (!Buffer) {
      return STATUS_INVALID_PARAMETER_2;
   }

   if (WhichSpace == PCCARD_PCI_CONFIGURATION_SPACE) {
      //
      // This has to be a cardbus card.
      //
      // NOTE: unimplemented: fill this in! send an IRP down to PCI
      // to get the config space
      status =  STATUS_NOT_SUPPORTED;

   } else {
      //
      // This has to be an R2 Card.
      // Attribute/common memory space
      //
      ASSERT ((WhichSpace == PCCARD_ATTRIBUTE_MEMORY) ||
              (WhichSpace == PCCARD_COMMON_MEMORY));

      //
      // Offset and length are >= 0 because they are ULONGs,
      // so don't worry about that.
      //

      if (!IsSocketFlagSet(socket, SOCKET_CARD_POWERED_UP)) {
         return STATUS_DEVICE_NOT_READY;
      }

      PCMCIA_ACQUIRE_DEVICE_LOCK(socket->DeviceExtension);

      if (Read && (socket->SocketFnPtr->PCBReadCardMemory != NULL)) {
         //
         // Read from card memory
         //
         status = ((*(socket->SocketFnPtr->PCBReadCardMemory))(pdoExtension,
                                                              WhichSpace,
                                                              Offset,
                                                              Buffer,
                                                              Length) == Length)
                  ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;

      } else if (socket->SocketFnPtr->PCBWriteCardMemory != NULL) {
         //
         // Write to card memory
         //
         status = ((*(socket->SocketFnPtr->PCBWriteCardMemory))(pdoExtension,
                                                               WhichSpace,
                                                               Offset,
                                                               Buffer,
                                                               Length) == Length)
                  ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
      }

      PCMCIA_RELEASE_DEVICE_LOCK(socket->DeviceExtension);
   }

   return status;
}



NTSTATUS
PcmciaConfigureCardBusCard(
   PPDO_EXTENSION pdoExtension
   )
/*++

Routine Description:

   This routine does some verification, and applies hacks

Arguments:

   pdoExtension -  Pointer to the physical device object extension for the pc-card

Return value:

   status

--*/
{
   ULONG i, pciConfig;
   NTSTATUS status = STATUS_SUCCESS;
   PSOCKET Socket = pdoExtension->Socket;
   
   for (i = 0; i < CARDBUS_CONFIG_RETRY_COUNT; i++) {
      GetPciConfigSpace(pdoExtension, CFGSPACE_VENDOR_ID, &pciConfig, sizeof(pciConfig));
      if (pciConfig != 0xffffffff) {
         break;
      }
   }      
   
   if (pciConfig == 0xffffffff) {
      DebugPrint((PCMCIA_DEBUG_FAIL, "pdo %08x failed to verify CardBus config space\n", pdoExtension->DeviceObject));
      status = STATUS_DEVICE_NOT_READY;
   } else {
      PFDO_EXTENSION fdoExtension = Socket->DeviceExtension;   

      //
      // The TI1130, 1131, 1031 have a bug such that CAUDIO on a cardbus card
      // is gated by the following bit (which normally only has meaning only
      // for R2 cards). We can workaround the problem simply by turning it on
      // for cardbus cards.
      //   
      if ((fdoExtension->ControllerType == PcmciaTI1130) ||
          (fdoExtension->ControllerType == PcmciaTI1131) ||
          (fdoExtension->ControllerType == PcmciaTI1031)) {
     
         UCHAR byte;
     
         byte = PcicReadSocket(Socket, PCIC_INTERRUPT);
         byte |= IGC_PCCARD_IO;
         PcicWriteSocket(Socket, PCIC_INTERRUPT, byte);
      }      
   }
   return status;      
}



NTSTATUS
PcmciaConfigurePcCard(
   PPDO_EXTENSION pdoExtension,
   IN PPCMCIA_COMPLETION_ROUTINE ConfigCompletionRoutine
   )
/*++

Routine Description:

   This routine does the brunt work of enabling the PC-Card using the supplied
   resources.

   NOTE: If this routine is called at less than DISPATCH_LEVEL, then the call
   will complete (not return STATUS_PENDING). If this routine is called at
   DISPATCH_LEVEL or greater, this routine returns STATUS_PENDING, and completes
   the configuration process using a KTIMER.

Arguments:

   pdoExtension -  Pointer to the physical device object extension for the pc-card
   ConfigCompletionRoutine - routine to be called after configuration is complete

Return value:

   status

--*/
{
   DebugPrint((PCMCIA_DEBUG_CONFIG, "pdo %08x ConfigurePcCard entered\n", pdoExtension->DeviceObject));

   if (!PCMCIA_TEST_AND_SET(&pdoExtension->Socket->WorkerBusy)) {
      return STATUS_DEVICE_BUSY;
   }
   
   ASSERT(pdoExtension->ConfigurationPhase == CW_Stopped);

   pdoExtension->ConfigurationPhase = CW_InitialState;
   pdoExtension->ConfigCompletionRoutine = ConfigCompletionRoutine;
   pdoExtension->ConfigurationStatus = STATUS_SUCCESS;

   PcmciaConfigurationWorker(&pdoExtension->ConfigurationDpc, pdoExtension, NULL, NULL);

   DebugPrint((PCMCIA_DEBUG_CONFIG, "pdo %08x ConfigurePcCard returning %08x\n", pdoExtension->DeviceObject, pdoExtension->ConfigurationStatus));

   return(pdoExtension->ConfigurationStatus);
}



VOID
PcmciaConfigurationWorker(
   IN PKDPC Dpc,
   IN PVOID DeferredContext,
   IN PVOID SystemArgument1,
   IN PVOID SystemArgument2
   )
/*++
Routine Description

   This routine handles the configuration process of a 16-bit R2 pccard.
   Because certain cards are finicky (modems), and require gigantic pauses
   between steps, this worker routine acts as a state machine, and will
   delay after each step.

Arguments

   same as KDPC (DeferredContext is pdoExtension)

Return Value

   status

--*/
{
   PPDO_EXTENSION        pdoExtension = DeferredContext;
   PSOCKET               Socket = pdoExtension->Socket;
   PSOCKET_CONFIGURATION SocketConfig = pdoExtension->SocketConfiguration;
   NTSTATUS              status = pdoExtension->DeferredConfigurationStatus;
   ULONG                 DelayUsec = 0;

   DebugPrint((PCMCIA_DEBUG_CONFIG, "pdo %08x config worker - %s\n", pdoExtension->DeviceObject,
                                    CONFIGURATION_WORKER_STRING(pdoExtension->ConfigurationPhase)));

   switch(pdoExtension->ConfigurationPhase) {

   case CW_InitialState:
   
      if (IsSocketFlagSet(pdoExtension->Socket, SOCKET_CARD_CONFIGURED)) {
         pdoExtension->ConfigurationPhase = CW_Exit;
         break;
      }
      if (!IsCardInSocket(pdoExtension->Socket)) {
         status = STATUS_NO_SUCH_DEVICE;
         pdoExtension->ConfigurationPhase = CW_Exit;
         break;
      }
      
      pdoExtension->ConfigurationPhase = CW_ResetCard;
      Socket->CardResetPhase = 1;
      break;

   case CW_ResetCard:
      //
      // Reset the card
      //
      status = (*(Socket->SocketFnPtr->PCBResetCard))(Socket, &DelayUsec);
      Socket->CardResetPhase++;

      if (status != STATUS_MORE_PROCESSING_REQUIRED) {
         pdoExtension->ConfigurationPhase = CW_Phase1;
      }
      break;
      
   case CW_Phase1:
      //
      // Initialize variables
      //
      PcmciaConfigurationWorkerInitialization(pdoExtension);
      //
      // Configure the cards configuration registers, and the socket mem
      // and I/O windows
      //
      status = PcmciaConfigurePcCardRegisters(pdoExtension);
      if (NT_SUCCESS(status)) {
         status = PcmciaConfigurePcCardMemIoWindows(Socket, SocketConfig);
      }
      DelayUsec = 1000 * (ULONG)pdoExtension->ConfigureDelay1;
      pdoExtension->ConfigurationPhase = CW_Phase2;
      break;

   case CW_Phase2:
      //
      // Take this opportunity to "poke" the modem
      //
      if (pdoExtension->ConfigurationFlags & CONFIG_WORKER_APPLY_MODEM_HACK) {
         PcmciaConfigureModemHack(Socket, SocketConfig);
      }
      DelayUsec = 1000 * (ULONG)pdoExtension->ConfigureDelay2;
      pdoExtension->ConfigurationPhase = CW_Phase3;
      break;

   case CW_Phase3:
      //
      // Configure the IRQ
      //
      status = PcmciaConfigurePcCardIrq(Socket, SocketConfig);

      DelayUsec = 1000 * (ULONG)pdoExtension->ConfigureDelay3;
      pdoExtension->ConfigurationPhase = CW_Exit;
      break;

   case CW_Exit:
      //
      // Done. Update flags, and call the completion routine if required
      //
      if (IsDeviceFlagSet(pdoExtension, PCMCIA_CONFIG_STATUS_DEFERRED)) {
         if (pdoExtension->ConfigCompletionRoutine) {
            (*pdoExtension->ConfigCompletionRoutine)(pdoExtension,
                                                     pdoExtension->DeferredConfigurationStatus);
         }
         ResetDeviceFlag(pdoExtension, PCMCIA_CONFIG_STATUS_DEFERRED);
      } else {
         pdoExtension->ConfigurationStatus = status;
      }

      if (NT_SUCCESS(status)) {
         SetSocketFlag(Socket, SOCKET_CARD_CONFIGURED);
      }
      pdoExtension->ConfigurationPhase = CW_Stopped;
      PCMCIA_TEST_AND_RESET(&Socket->WorkerBusy);

      DebugPrint((PCMCIA_DEBUG_CONFIG, "pdo %08x config worker exit %08x\n", pdoExtension->DeviceObject, status));
      return;

   default:
      ASSERT(FALSE);
      return;
   }

   pdoExtension->DeferredConfigurationStatus = status;

   if (!NT_SUCCESS(status) && (status != STATUS_MORE_PROCESSING_REQUIRED)) {
      DelayUsec = 0;
      pdoExtension->ConfigurationPhase = CW_Exit;
   } 

   //
   // Not done yet. Recurse or call timer
   //

   if (DelayUsec) {

      DebugPrint((PCMCIA_DEBUG_CONFIG, "pdo %08x config worker delay type %s, %d usec\n",
                                                pdoExtension->DeviceObject,
                                                (KeGetCurrentIrql() < DISPATCH_LEVEL) ? "Wait" : "Timer",
                                                DelayUsec));

      if (KeGetCurrentIrql() < DISPATCH_LEVEL) {
         PcmciaWait(DelayUsec);
      } else {
         LARGE_INTEGER  dueTime;
         dueTime.QuadPart = -((LONG) DelayUsec*10);
         //
         // Running on a DPC, kick of a kernel timer
         //
         KeSetTimer(&pdoExtension->ConfigurationTimer,
                    dueTime,
                    &pdoExtension->ConfigurationDpc);

         if (!IsDeviceFlagSet(pdoExtension, PCMCIA_CONFIG_STATUS_DEFERRED)) {
            SetDeviceFlag(pdoExtension, PCMCIA_CONFIG_STATUS_DEFERRED);
            pdoExtension->ConfigurationStatus = STATUS_PENDING;
         }
         return;
      }
   }

   PcmciaConfigurationWorker(&pdoExtension->ConfigurationDpc, pdoExtension, NULL, NULL);
}


VOID
PcmciaConfigurationWorkerInitialization(
   PPDO_EXTENSION  pdoExtension
   )
/*++

Routine Description:

    This routine sets variables which control the configuration process.

Arguments:

   pdoExtension -  Pointer to the physical device object extension for the pc-card

Return value:

   none

--*/
{
   PSOCKET_DATA socketData = pdoExtension->SocketData;
   ULONG i;

   pdoExtension->ConfigurationFlags = 0;
   pdoExtension->ConfigureDelay1 = 0;
   pdoExtension->ConfigureDelay2 = 0;
   pdoExtension->ConfigureDelay3 = 0;

   while (socketData) {

      i = 0;
      while (DeviceConfigParams[i].ValidEntry) {

         if (((DeviceConfigParams[i].DeviceType == 0xff) ||
                 (DeviceConfigParams[i].DeviceType == socketData->DeviceType)) &&
             ((DeviceConfigParams[i].ManufacturerCode == 0xffff) ||
                 (DeviceConfigParams[i].ManufacturerCode == socketData->ManufacturerCode)) &&
             ((DeviceConfigParams[i].ManufacturerInfo == 0xffff) ||
                 (DeviceConfigParams[i].ManufacturerInfo == socketData->ManufacturerInfo)) &&
             ((DeviceConfigParams[i].CisCrc == 0xffff) ||
                 (DeviceConfigParams[i].CisCrc == socketData->CisCrc))) {

            pdoExtension->ConfigurationFlags = DeviceConfigParams[i].ConfigFlags;
            pdoExtension->ConfigureDelay1 = DeviceConfigParams[i].ConfigDelay1;
            pdoExtension->ConfigureDelay2 = DeviceConfigParams[i].ConfigDelay2;
            pdoExtension->ConfigureDelay3 = DeviceConfigParams[i].ConfigDelay3;
            break;

         }
         i++;
      }
      socketData = socketData->Next;
   }
}



NTSTATUS
PcmciaConfigurePcCardMemIoWindows(
   IN PSOCKET Socket,
   IN PSOCKET_CONFIGURATION SocketConfig
   )
/*++

Routine Description:

   This routine enables the socket memory and I/O windows

Arguments:

   Socket - Pointer to the socket containing the PC-Card
   SocketConfig - Pointer to the socket configuration structure which contains the
                  resources required to enable this pc-card

Return value:

   status

--*/
{
   CARD_REQUEST        cardRequest = {0};
   PFDO_EXTENSION      fdoExtension = Socket->DeviceExtension;
   NTSTATUS            status = STATUS_SUCCESS;
   ULONG i;

   DebugPrint((PCMCIA_DEBUG_CONFIG, "socket %08x config MemIo\n", Socket));

   //
   // Setup IO ranges if there are any
   //
   if (SocketConfig->NumberOfIoPortRanges) {
      cardRequest.RequestType = IO_REQUEST;
      cardRequest.u.Io.NumberOfRanges = (USHORT) SocketConfig->NumberOfIoPortRanges;

      for (i = 0; i < SocketConfig->NumberOfIoPortRanges; i++) {

         DebugPrint((PCMCIA_DEBUG_CONFIG, "\tport range: 0x%x-0x%x\n",
                     SocketConfig->Io[i].Base,
                     SocketConfig->Io[i].Base + SocketConfig->Io[i].Length));

         cardRequest.u.Io.IoEntry[i].BasePort = SocketConfig->Io[i].Base;
         cardRequest.u.Io.IoEntry[i].NumPorts = SocketConfig->Io[i].Length;

         cardRequest.u.Io.IoEntry[i].Attributes = 0;

         if (SocketConfig->Io[i].Width16) {
            cardRequest.u.Io.IoEntry[i].Attributes |= IO_DATA_PATH_WIDTH;
         }
         if (SocketConfig->Io[i].WaitState16) {
            cardRequest.u.Io.IoEntry[i].Attributes |= IO_WAIT_STATE_16;
         }
         if (SocketConfig->Io[i].Source16) {
            cardRequest.u.Io.IoEntry[i].Attributes |= IO_SOURCE_16;
         }
         if (SocketConfig->Io[i].ZeroWait8) {
            cardRequest.u.Io.IoEntry[i].Attributes |= IO_ZERO_WAIT_8;
         }

      }


      if (!PcmciaProcessConfigureRequest(fdoExtension, Socket, &cardRequest)) {
         status = STATUS_UNSUCCESSFUL;
         DebugPrint((PCMCIA_DEBUG_FAIL, "Failed to configure PcCardIO for socket %x\n", Socket));
      }
   }

   //
   // Set up Memory space if there is some.
   //
   if (NT_SUCCESS(status) && SocketConfig->NumberOfMemoryRanges) {

      cardRequest.RequestType = MEM_REQUEST;
      cardRequest.u.Memory.NumberOfRanges = (USHORT) SocketConfig->NumberOfMemoryRanges;

      for (i = 0; i < SocketConfig->NumberOfMemoryRanges; i++) {

         DebugPrint((PCMCIA_DEBUG_CONFIG, "\tmemory: host %08x for 0x%x, card %08x\n",
                     SocketConfig->Memory[i].HostBase,
                     SocketConfig->Memory[i].Length,
                     SocketConfig->Memory[i].CardBase));

         cardRequest.u.Memory.MemoryEntry[i].BaseAddress      = SocketConfig->Memory[i].CardBase;
         cardRequest.u.Memory.MemoryEntry[i].HostAddress      = SocketConfig->Memory[i].HostBase;
         cardRequest.u.Memory.MemoryEntry[i].WindowSize       = SocketConfig->Memory[i].Length;
         cardRequest.u.Memory.MemoryEntry[i].AttributeMemory  = SocketConfig->Memory[i].IsAttribute;
         cardRequest.u.Memory.MemoryEntry[i].WindowDataSize16 = SocketConfig->Memory[i].Width16;
         cardRequest.u.Memory.MemoryEntry[i].WaitStates       = SocketConfig->Memory[i].WaitState;
      }

      if (!PcmciaProcessConfigureRequest(fdoExtension, Socket, &cardRequest)) {
         status = STATUS_UNSUCCESSFUL;
         DebugPrint((PCMCIA_DEBUG_FAIL, "Failed to configure PcCardMem for socket %x\n", Socket));
      }
   }
   return status;
}


NTSTATUS
PcmciaConfigurePcCardIrq(
   IN PSOCKET Socket,
   IN PSOCKET_CONFIGURATION SocketConfig
   )
/*++

Routine Description:

   This routine enables the socket IRQ

Arguments:

   Socket - Pointer to the socket containing the PC-Card
   SocketConfig - Pointer to the socket configuration structure which contains the
                  resources required to enable this pc-card

Return value:

   status

--*/
{
   CARD_REQUEST        cardRequest = {0};
   PFDO_EXTENSION      fdoExtension = Socket->DeviceExtension;
   NTSTATUS            status = STATUS_SUCCESS;

   DebugPrint((PCMCIA_DEBUG_CONFIG, "skt %08x irq=0x%x\n",
                                    Socket,
                                    SocketConfig->Irq));
   //
   // Set the IRQ on the controller.
   //

   if (SocketConfig->Irq) {
      cardRequest.RequestType = IRQ_REQUEST;
      cardRequest.u.Irq.AssignedIRQ = (UCHAR) SocketConfig->Irq;
      cardRequest.u.Irq.ReadyIRQ = (UCHAR) SocketConfig->ReadyIrq;

      if (!PcmciaProcessConfigureRequest(fdoExtension, Socket, &cardRequest)) {
         status = STATUS_UNSUCCESSFUL;
         DebugPrint((PCMCIA_DEBUG_FAIL, "Failed to configure PcCardIrq for socket %x\n", Socket));
      }
   }
   return status;
}


NTSTATUS
PcmciaConfigurePcCardRegisters(
   PPDO_EXTENSION  pdoExtension
   )
/*++

Routine Description:

    This routine does the work of configuring the function configuration registers
    on the card.

Arguments:

   pdoExtension -  Pointer to the physical device object extension for the pc-card

Return value:

   status

--*/
{
   PSOCKET             Socket = pdoExtension->Socket;
   PSOCKET_CONFIGURATION SocketConfig = pdoExtension->SocketConfiguration;
   PSOCKET_DATA socketData ;
   CARD_REQUEST        cardRequest = {0};
   PFDO_EXTENSION      fdoExtension = Socket->DeviceExtension;
   NTSTATUS            status = STATUS_UNSUCCESSFUL;
   ULONG               ccrBase;
   PFUNCTION_CONFIGURATION fnConfig;
   UCHAR               configIndex;

   //
   // Set up the configuration index on the PCCARD.
   //

   cardRequest.RequestType = CONFIGURE_REQUEST;
   fnConfig = SocketConfig->FunctionConfiguration;
   socketData = pdoExtension->SocketData;

   ASSERT(socketData != NULL);

   do {
      cardRequest.u.Config.RegisterWriteMask = 0;

      if (fnConfig) {
         //
         // MF card -
         //   pick up the base and options from the linked list
         //
         ccrBase = fnConfig->ConfigRegisterBase;
         configIndex = fnConfig->ConfigOptions;
      } else {
         //
         // Single function card -
         //   get the base and index from base config structure
         //
         ccrBase = SocketConfig->ConfigRegisterBase;
         configIndex = SocketConfig->IndexForCurrentConfiguration;
      }

      DebugPrint((PCMCIA_DEBUG_CONFIG, "pdo %08x config registers ccr %x\n", pdoExtension->DeviceObject, ccrBase));
      //
      // We support only 2 interfaces:
      // Memory only
      // I/o and memory
      // We consider a card to be memory only if:
      //     The card is of device type PCCARD_TYPE_MEMORY: this is true
      //     for flash memory cards currently
      //           OR
      //     The card doesn't have any i/o ranges & the config register base is 0.
      //

      if (((ccrBase == 0) && (SocketConfig->NumberOfIoPortRanges == 0)) ||
          (socketData->DeviceType == PCCARD_TYPE_MEMORY) ||
          (socketData->DeviceType == PCCARD_TYPE_FLASH_MEMORY)) {

         cardRequest.u.Config.InterfaceType =  CONFIG_INTERFACE_MEM;

      } else {
         //
         // i/o mem card
         //
         cardRequest.u.Config.ConfigBase = ccrBase;
         cardRequest.u.Config.InterfaceType =  CONFIG_INTERFACE_IO_MEM;

         cardRequest.u.Config.RegisterWriteMask |= REGISTER_WRITE_CONFIGURATION_INDEX;
         cardRequest.u.Config.ConfigIndex = configIndex;

         if (IsConfigRegisterPresent(socketData, 1)) {
            cardRequest.u.Config.RegisterWriteMask |= REGISTER_WRITE_CARD_CONFIGURATION;
            cardRequest.u.Config.CardConfiguration = 0;
         }

         if (fnConfig) {
            //
            // MF card - set up the rest of the configuration registers
            //

            // Just check audio for now
            if (fnConfig->ConfigFlags & 0x8) {
               // probably a modem
               cardRequest.u.Config.CardConfiguration = 0x08;
            }

            if (fnConfig->ConfigOptions & 0x02) {
               cardRequest.u.Config.IoBaseRegister = fnConfig->IoBase;
               cardRequest.u.Config.IoLimitRegister = fnConfig->IoLimit;
               cardRequest.u.Config.RegisterWriteMask |= (REGISTER_WRITE_IO_BASE | REGISTER_WRITE_IO_LIMIT);
            }

         } else if (IsDeviceFlagSet(pdoExtension, PCMCIA_PDO_ENABLE_AUDIO)) {

            //
            // Request that the audio pin in the card configuration register
            // be set.
            //
            cardRequest.u.Config.CardConfiguration = 0x08;
         }
      }

      if (!PcmciaProcessConfigureRequest(fdoExtension, Socket, &cardRequest)) {
         DebugPrint((PCMCIA_DEBUG_FAIL, "Failed to configure PcCardRegisters for PDO %x\n", pdoExtension->DeviceObject));
         return status;
      }


      if (fnConfig) {
         fnConfig = fnConfig->Next;
      } else {
         //
         // Remember that the socket is configured and what index was used.
         //
         socketData->ConfigIndexUsed = configIndex;
      }

   } while(fnConfig);


   status = STATUS_SUCCESS;
   return status;
}


VOID
PcmciaConfigureModemHack(
   IN PSOCKET Socket,
   IN PSOCKET_CONFIGURATION SocketConfig
   )
/*++

Routine Description:

   This routine does magic to wake the modem up. It is written to accomodate
   the Motorola MobileSURFR 56k, but there may be other modems that need it.

Arguments:

   Socket - Pointer to the socket containing the PC-Card
   SocketConfig - Pointer to the socket configuration structure which contains the
                  resources required to enable this pc-card

Return value:

   status

--*/
{
   static const ULONG ValidPortBases[4] = {0x3f8, 0x2f8, 0x3e8, 0x2e8};
   ULONG i;
   UCHAR ch;
   ULONG base;

   for (i = 0; i < 4; i++) {

      base = SocketConfig->Io[0].Base;

      if (base == ValidPortBases[i]) {
         DebugPrint((PCMCIA_DEBUG_CONFIG, "skt %08x ModemHack base %x\n", Socket, base));

         // read and write the modem control register
         ch = READ_PORT_UCHAR((PUCHAR)ULongToPtr(base + 4));
         WRITE_PORT_UCHAR((PUCHAR)ULongToPtr(base + 4), ch);
         break;
      }
   }
}



VOID
PcmciaSocketDeconfigure(
   IN PSOCKET Socket
   )

/*++

Routine Description:

   deconfigures the card

Arguments:

   Socket - Pointer to the socket containing the PC-Card

Return Value

   none

--*/

{
   CARD_REQUEST  cardReq;

   if (IsSocketFlagSet(Socket, SOCKET_CARD_CONFIGURED)) {

      cardReq.RequestType = DECONFIGURE_REQUEST;

      PcmciaProcessConfigureRequest(Socket->DeviceExtension, Socket, &cardReq);

      ResetSocketFlag(Socket, SOCKET_CARD_CONFIGURED);
   }
   
   //
   // If a query_device_relations came in after a card was inserted, but before
   // we have removed the previous card configuration, the enumeration would have been
   // postponed. Here, we start it up again
   //
   if (IsSocketFlagSet(Socket, SOCKET_ENUMERATE_PENDING)) {
      ResetSocketFlag(Socket, SOCKET_ENUMERATE_PENDING);
      SetSocketFlag(Socket, SOCKET_CARD_STATUS_CHANGE);
      IoInvalidateDeviceRelations(Socket->DeviceExtension->Pdo, BusRelations);
   }
}


BOOLEAN
PcmciaProcessConfigureRequest(
   IN PFDO_EXTENSION DeviceExtension,
   IN PSOCKET        Socket,
   IN PCARD_REQUEST  CardConfigurationRequest
   )

/*++

Routine Description:

    Actually configures the card

Arguments:

    Context

Return Value

    True

--*/

{
   BOOLEAN status;
   ULONG   counter;


   PCMCIA_ACQUIRE_DEVICE_LOCK(DeviceExtension);

   //
   // Configuring the card can be tricky: the user may pop out the card while
   // configuration is taking place.
   //

   counter = 0;
   do {
      status = (*(Socket->SocketFnPtr->PCBProcessConfigureRequest))(Socket,
                                                                    CardConfigurationRequest,
                                                                    Socket->AddressPort);
      if (!status) {
         if (!(Socket->SocketFnPtr->PCBDetectCardInSocket(Socket))) {
            //
            // Somebody popped out the card
            //
            break;
         }
      }
      counter++;
   } while (!status && counter < PCMCIA_MAX_CONFIG_TRIES);

   PCMCIA_RELEASE_DEVICE_LOCK(DeviceExtension);

   return status;
}


BOOLEAN
PcmciaVerifyCardInSocket(
   IN PSOCKET Socket
   )
/*++

Routine Description:

   This routine compares the current known state to the id of the
   card in the slot to determine if the state is consistent. That is,
   if there is no card in the socket, then we would expect to see no
   cards enumerated in the socket data. If there is a card in the socket,
   then we would expect to see the socket data match the card.

Arguments

   Socket      - Point to the socket to verify

Return Value

   TRUE if the logical state of the socket matches its physical state
   FALSE otherwise

--*/
{
   NTSTATUS status;
   PDEVICE_OBJECT pdo, nextPdo;
   PPDO_EXTENSION pdoExtension;
   BOOLEAN verified = FALSE;

   try {
      if (!IsCardInSocket(Socket)) {
         leave;
      }

      if (IsCardBusCardInSocket(Socket)) {
         ULONG pciConfig;
         ULONG i;
         //
         // Cardbus card now in slot, check to see if it matches the
         // PdoList state.
         //
         if (!Socket->PdoList) {
            leave;
         }

         for (pdo = Socket->PdoList; pdo!=NULL; pdo=nextPdo) {
            pdoExtension = pdo->DeviceExtension;
            nextPdo = pdoExtension->NextPdoInSocket;

            if (!IsCardBusCard(pdoExtension)) {
               leave;
            }

            for (i = 0; i < 1000; i++) {
               GetPciConfigSpace(pdoExtension, CFGSPACE_VENDOR_ID, &pciConfig, sizeof(pciConfig));
               if (pdoExtension->CardBusId == pciConfig) {
                  break;
               }
               PcmciaWait(10);
            }
            
            if (i > 0) {
               DebugPrint((PCMCIA_DEBUG_FAIL, "pdo %08x waited %d usec to verify device id %08x\n",
                        pdoExtension->DeviceObject, i*10, pdoExtension->CardBusId));
            }                        

            if (pdoExtension->CardBusId != pciConfig) {
               DebugPrint((PCMCIA_DEBUG_FAIL, "pdo %08x verify device id FAILED: %08x %08x\n",
                           pdoExtension->DeviceObject, pdoExtension->CardBusId, pciConfig));
               leave;
            }
         }

         verified = TRUE;

      } else {
         //
         // R2 card now in slot
         //
         pdo = Socket->PdoList;

         if (pdo) {
            pdoExtension = pdo->DeviceExtension;
            if (Is16BitCard(pdoExtension)) {
               //
               // Invalidate the cache to force re-reading the CIS
               //
               pdoExtension->CisCacheSpace = 0xff;
               if ((NT_SUCCESS(PcmciaParseFunctionDataForID(pdoExtension->SocketData)))) {
                  verified = TRUE;
               }
            }
         }
      }

   } finally {
      if (!verified) {
         SetSocketFlag(Socket, SOCKET_CARD_STATUS_CHANGE);
      }
      DebugPrint((PCMCIA_DEBUG_INFO, "skt %08x - card %s\n", Socket, verified ? "not changed" : "changed!"));
   }
   return verified;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\pcmcibus\tcicsup.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    tcicsup.c

Abstract:

    This module supplies functions that control the Databook TCIC family
    of chips. In turn, these functions are abstracted out to the main PCMCIA
    support module.

Author(s):
        (pcicsup.c - Source that this file was derived from)
        Bob Rinne (BobRi)   3-Aug-1994
        Jeff McLeman (mcleman@zso.dec.com)
        (tcicsup.c - this file)
                John Keys - Databook Inc. 7-Apr-1995

Revisions:
        Overhaul for plug'n'play support
                Ravisankar Pudipeddi (ravisp) 8-Jan-1997
        new setpower and init routine interface
                Neil Sandlin (neilsa) 3-Mar-99
--*/

#include "pch.h"

VOID
TcicRegistryLookupScanLimits(
                            PULONG Start,
                            PULONG End
                            );

NTSTATUS
TcicDetectSockets(
   IN PFDO_EXTENSION DeviceExtension,
   IN BOOLEAN           LegacyDetection
   );

BOOLEAN
TcicInitializePcmciaSocket(
   IN PSOCKET SocketPtr
   );

NTSTATUS
TcicResetCard(
   IN PSOCKET SocketPtr,
   OUT PULONG pDelayTime
   );

ULONG
TcicReadCardMemory(
   IN PPDO_EXTENSION PdoExtension,
   IN MEMORY_SPACE MemorySpace,
   IN ULONG   Offset,
   IN  PUCHAR Buffer,
   IN  ULONG  Length
   );

ULONG
TcicWriteCardMemory(
   IN PPDO_EXTENSION PdoExtension,
   IN  MEMORY_SPACE MemorySpace,
   IN  ULONG  Offset,
   IN  PUCHAR Buffer,
   IN  ULONG  Length
   );

BOOLEAN
TcicDetectCardInSocket(
   IN PSOCKET SocketPtr
   );

BOOLEAN
TcicDetectCardChanged(
   IN PSOCKET SocketPtr
   );

BOOLEAN
TcicDetectReadyChanged(
   IN PSOCKET SocketPtr
   );

NTSTATUS
TcicGetPowerRequirements(
   IN PSOCKET Socket
   );

BOOLEAN
TcicProcessConfigureRequest(
   IN PSOCKET SocketPtr,
   IN PVOID  ConfigRequest,
   IN PUCHAR Base
   );

BOOLEAN
TcicEnableDisableCardDetectEvent(
   IN PSOCKET SocketPtr,
   IN BOOLEAN Enable
   );

VOID
TcicDisableControllerInterrupt(
   IN PSOCKET socketPtr
   );

BOOLEAN
TcicPCCardReady(
   IN PSOCKET SocketPtr
   );

VOID
TcicGetRegisters(
   IN PFDO_EXTENSION DeviceExtension,
   IN PSOCKET SocketPtr,
   IN PUCHAR Buffer
   );

ULONG
TcicGetIrqMask(
   IN PFDO_EXTENSION deviceExtension
   );

BOOLEAN
TcicCardBusCardInSocket(
   IN PSOCKET SocketPtr
   );

#if DBG
VOID
TcicDump(
   IN PSOCKET socketPtr
   );
#endif

#ifdef ALLOC_PRAGMA
   #pragma alloc_text(INIT,TcicDetect)
   #pragma alloc_text(PAGE,TcicFillInAdapter)
   #pragma alloc_text(PAGE,TcicGetAdapterInfo)
   #pragma alloc_text(PAGE,TcicAllocateMemRange)
   #pragma alloc_text(PAGE,TcicReservedBitsOK)
   #pragma alloc_text(PAGE,TcicChipID)
   #pragma alloc_text(PAGE,TcicCheckSkt)
   #pragma alloc_text(PAGE,TcicCheckAliasing)
   #pragma alloc_text(PAGE,TcicCheckAliasType)
   #pragma alloc_text(PAGE,TcicCheckXBufNeeded)
   #pragma alloc_text(PAGE,TcicSetMemWindow)
   #pragma alloc_text(PAGE,TcicGetPossibleIRQs)
   #pragma alloc_text(PAGE,TcicClockRate)
   #pragma alloc_text(PAGE,TcicGetIRQMap)
   #pragma alloc_text(PAGE,TcicGet5vVccVal)
   #pragma alloc_text(PAGE,TcicHasSktIRQPin)
   #pragma alloc_text(PAGE,TcicGetFlags)
   #pragma alloc_text(PAGE,TcicGetnMemWins)
   #pragma alloc_text(PAGE,TcicGetnIOWins)
   #pragma alloc_text(PAGE,TcicRegistryLookupScanLimits)
#endif

#define TCIC_LOW_ADDR_LIMIT     0x240
#define TCIC_HIGH_ADDR_LIMIT    0x2ff


/*
|| IRQ Tables -
|| Each table consists of 16 bytes. Each byte maps an IRQ level (implied by
|| table index) to a register value that will select that IRQ. For instance,
|| with table irqcaps_082, table[11] gives a value of 1, so using '1' as the
|| card status change IRQ value will cause IRQ11 to be fired.
||
*/
/********************* 0 1 2 3 4 5 6 7 8  9 A  B  C  D  E  F *****************/
UCHAR irqcaps_082[]   ={0,0,0,3,4,5,6,7,0, 0,10,1, 0, 0, 14,0};
UCHAR irqcaps_082sw[] ={0,0,0,3,4,5,0,7,0, 6,10,1, 0, 0, 14,0};
UCHAR irqcaps_072[]   ={0,0,0,3,4,5,0,7,0, 0,10,1, 0, 0, 14,0};
UCHAR irqcaps_072sw[] ={0,0,0,3,4,5,0,7,0,14,10,1, 0, 0, 0, 0};
/* in the case of x84 parts, we determine  6,9,12,&15 at run time */
UCHAR irqcaps_084[]   ={0,0,0,3,4,5,0,7,0, 0,10,11,0, 0, 14,0};


/* The Socket Services Public Power Table */
unsigned short PubPwrTbl[] = {
   3,                                      /* number of Public Entries */
   SPWR_ALL_SUPPLY | SPWR_0p0V,            /* Public entry             */
   SPWR_ALL_SUPPLY | SPWR_5p0V,            /* Public entry             */
   SPWR_VPP_SUPPLY | SPWR_12p0V            /* Public entry             */
};


/* The corresponding Private Table for a TMI-140 type implementation        */
USHORT PwrTbl140[] = {
   3, 0x0000, 0x0001, 0x0800,              /* Private table            */
   0x0001                                  /* CtlBits for Vcc=5V       */
};

/* The other  Private Table for a DB86082/071/072 type implementation       */
USHORT PwrTbl082[] = {
   3, 0x0000, 0x0809, 0x0100,              /* Private table            */
   0x0001                                  /* CtlBits for Vcc=5V       */
};

/* The corresponding Private Table for a DB86084/184 implementation         */
USHORT PwrTbl084[] ={
   3, 0x0000, 0x0207, 0x0100,              /* Private table            */
   0x0007                                  /* CtlBits for Vcc=5V       */
};


/* Properties table - use this to bind possible capabilites to a Chip ID    */

CHIPPROPS ChipProperties[] = {
   {SILID_DB86082_1,
      PwrTbl082, 0, irqcaps_082, NUMSOCKETS, IR_IOWIN_NUM,
      IR_MWIN_NUM_082, (fEXTBUF_CHK | fSKTIRQPIN)},
   {SILID_DB86082A,
      PwrTbl082, 0, irqcaps_082, NUMSOCKETS, IR_IOWIN_NUM,
      IR_MWIN_NUM_082A, (fEXTBUF_CHK | fSKTIRQPIN)},
   {SILID_DB86082B,
      PwrTbl082, 0, irqcaps_082, NUMSOCKETS, IR_IOWIN_NUM,
      IR_MWIN_NUM_082B, (fEXTBUF_CHK | fSKTIRQPIN)},
   {SILID_DB86082B_ES,
      PwrTbl082, 0, irqcaps_082, NUMSOCKETS, IR_IOWIN_NUM,
      IR_MWIN_NUM_082B, (fEXTBUF_CHK | fSKTIRQPIN)},
   {SILID_DB86084_1,
      PwrTbl084, 0, irqcaps_084, NUMSOCKETS, IR_IOWIN_NUM,
      IR_MWIN_NUM_084, fIS_PNP},
   {SILID_DB86084A,
      PwrTbl084, 0, irqcaps_084, NUMSOCKETS, IR_IOWIN_NUM,
      IR_MWIN_NUM_084, fIS_PNP},
   {SILID_DB86184_1,
      PwrTbl084, 0, irqcaps_084, NUMSOCKETS, IR_IOWIN_NUM,
      IR_MWIN_NUM_184, fIS_PNP},
   {SILID_DB86072_1,
      PwrTbl082, 0, irqcaps_072, NUMSOCKETS, IR_IOWIN_NUM,
      IR_MWIN_NUM_072, fSKTIRQPIN},
   {SILID_DB86072_1_ES,
      PwrTbl082, 0, irqcaps_072, NUMSOCKETS, IR_IOWIN_NUM,
      IR_MWIN_NUM_072, fSKTIRQPIN},
   {0, NULL, 0, NULL, 0, 0, 0, 0}
};



#ifdef POOL_TAGGING
   #undef ExAllocatePool
   #define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'bdcP')
#endif

PUCHAR TcicCisBufferBase;
ULONG  TcicPhysicalBase;
ULONG  TcicStallCounter = 5000;
ULONG  TcicStallPower   = 20000;

PCMCIA_CTRL_BLOCK TcicSupportFns = {
   TcicInitializePcmciaSocket,
   TcicResetCard,
   TcicDetectCardInSocket,
   TcicDetectCardChanged,
   NULL,                    // DetectCardStatus
   TcicDetectReadyChanged,
   NULL,                    // GetPowerRequirements
   TcicProcessConfigureRequest,
   TcicEnableDisableCardDetectEvent,
   NULL,                    // EnableDisableWakeupEvent
   TcicGetIrqMask,
   TcicReadCardMemory,
   TcicWriteCardMemory,
   NULL,                    // ModifyMemoryWindow
   NULL,                    // SetVpp
   NULL                     // IsWriteProtected
};



VOID
TcicGetControllerProperties(
   IN PSOCKET socketPtr,
   IN PUSHORT pIoPortBase,
   IN PUSHORT pIoPortSize
   )

/*++

Routine Description:

    Gets the Port base and range from the DBSOCKET pointer. The original code
    stored these values in the device extension, but this did not allow for
    multiple controller products such as the TMB-270.

Arguments:

    socketPtr - pointer to our socket structure
    pIoPortBase - where to write the base address.
    pIoPortSize - where to write the range.

Return Value:

    None

--*/

{
   PDBSOCKET pdb;

   if (Databook(socketPtr)) {
      pdb = (PDBSOCKET)socketPtr;
      *pIoPortBase = (USHORT)pdb->physPortAddr;
      *pIoPortSize = 16;
   }
}



ULONG
TcicGetIrqMask(
   IN PFDO_EXTENSION deviceExtension
   )

/*++

Routine Description:

    Gets the IRQ mask from the DBSOCKET pointer. The original code
    had this mask hardcoded in PCMCIA.C but this did not provide the
    flexibility needed to correctly state the mask for Databook products.

Arguments:

    deviceExtension - the root of the socket list

Return Value:

    The compiled IRQ mask for the 1st socket in the list since this socket
    should be representative of all sockets on this controller.

--*/
{
   PDBSOCKET pdb = (PDBSOCKET)(deviceExtension->SocketList);
   ULONG     mask = 0;
   int               j;

   for (j = 0; j < 16; j++) {
      //
      // Changed the way the mask is constructed
      // The older (non-PnP) code put 0s for valid IRQs
      // and 1s for non-valid IRQs. Now it's flipped
      // (since the ControllerInterruptMask operates the same
      // way)
      //
      if (pdb->IRQMapTbl[j] != (UCHAR)0) {
         mask |= ((ULONG)1 << j);
      }
   }
   return (mask);
}



#if DBG
   #include "tcicregs.h"

VOID
TcicDump(
   IN PSOCKET socketPtr
   )

/*++

Routine Description:

    Debug routine to print the registers to the debugger.

Arguments:

    socketPtr - provides base address information for the contoller to dump.

Return Value:

    None

--*/

{
   TCIC  tcic;
   ULONG  origAddr;
   USHORT  j;

   origAddr = TcicReadAddrReg(socketPtr);
   for (j = 0; j < 2; j++) {

      //
      // Select the socket
      //

      TcicSocketSelect(socketPtr, j);

      //
      // Read TCIC base registers for this socket
      //

      tcic.baseregs[j].sctrl = (UCHAR)TcicReadBaseReg(socketPtr, R_SCTRL);
      tcic.baseregs[j].sstat = (UCHAR)TcicReadBaseReg(socketPtr, R_SSTAT);
      tcic.baseregs[j].mode  = (UCHAR)TcicReadBaseReg(socketPtr, R_MODE);
      tcic.baseregs[j].pwr   = (UCHAR)TcicReadBaseReg(socketPtr, R_PWR);
      tcic.baseregs[j].edc   =        TcicReadBaseReg(socketPtr, R_EDC);
      tcic.baseregs[j].icsr  = (UCHAR)TcicReadBaseReg(socketPtr, R_ICSR);
      tcic.baseregs[j].iena  = (UCHAR)TcicReadBaseReg(socketPtr, R_IENA);

      //
      // Read TCIC aux regsiters for this socket
      //

      tcic.baseregs[j].wctl   = TcicReadAuxReg(socketPtr, MODE_AR_WCTL);
      tcic.baseregs[j].syscfg = TcicReadAuxReg(socketPtr, MODE_AR_SYSCFG);
      tcic.baseregs[j].ilock  = TcicReadAuxReg(socketPtr, MODE_AR_ILOCK);
      tcic.baseregs[j].test   = TcicReadAuxReg(socketPtr, MODE_AR_TEST);

      //
      // Restore R_MODE - trashed by reading aux regs
      //

      TcicWriteBaseReg(socketPtr, R_MODE, tcic.baseregs[j].mode);
   }

   for (j = 0; j < 2; j++) {
      TcicReadIndirectRegs(socketPtr, IR_SCFG_S(j), 2, (PUSHORT)&tcic.sktregs[j]);
   }

   for (j = 0; j < 4; j++) {
      TcicReadIndirectRegs(socketPtr, IR_IOBASE_W(j), 2, (PUSHORT)&tcic.iowins[j]);
   }

   for (j = 0; j < 10; j++) {
      TcicReadIndirectRegs(socketPtr, IR_MBASE_W(j), 3, (PUSHORT)&tcic.memwins[j]);
   }

   TcicWriteAddrReg(socketPtr, origAddr);

   DebugPrint((PCMCIA_DUMP_SOCKET, "SCTRL\t%02X\t%02X\n",
               tcic.baseregs[0].sctrl, tcic.baseregs[1].sctrl));

   DebugPrint((PCMCIA_DUMP_SOCKET, "SSTAT\t%02X\t%02X\n",
               tcic.baseregs[0].sstat, tcic.baseregs[1].sstat));

   DebugPrint((PCMCIA_DUMP_SOCKET, "MODE \t%02X\t%02X\n",
               tcic.baseregs[0].mode, tcic.baseregs[1].mode));

   DebugPrint((PCMCIA_DUMP_SOCKET, "PWR  \t%02X\t%02X\n",
               tcic.baseregs[0].pwr  , tcic.baseregs[1].pwr  ));

   DebugPrint((PCMCIA_DUMP_SOCKET, "EDC  \t%04X\t%04X\n",
               tcic.baseregs[0].edc  , tcic.baseregs[1].edc  ));

   DebugPrint((PCMCIA_DUMP_SOCKET, "ICSR \t%02X\t%02X\n",
               tcic.baseregs[0].icsr , tcic.baseregs[1].icsr ));

   DebugPrint((PCMCIA_DUMP_SOCKET, "IENA \t%02X\t%02X\n",
               tcic.baseregs[0].iena , tcic.baseregs[1].iena ));

   DebugPrint((PCMCIA_DUMP_SOCKET, "WCTL \t%02X\t%02X\n",
               tcic.baseregs[0].wctl , tcic.baseregs[1].wctl ));

   DebugPrint((PCMCIA_DUMP_SOCKET, "SYSCFG\t%02X\t%02X\n",
               tcic.baseregs[0].syscfg, tcic.baseregs[1].syscfg));

   DebugPrint((PCMCIA_DUMP_SOCKET, "ILOCK\t%02X\t%02X\n",
               tcic.baseregs[0].ilock, tcic.baseregs[1].ilock));

   DebugPrint((PCMCIA_DUMP_SOCKET, "TEST \t%02X\t%02X\n",
               tcic.baseregs[0].test , tcic.baseregs[1].test ));

   for (j = 0; j < 2; j++ ) {
      DebugPrint((PCMCIA_DUMP_SOCKET,
                  "SKT%d\tSCF1 %04X\tSCF2 %04X\n",
                  j, tcic.sktregs[j].scfg1, tcic.sktregs[j].scfg2));
   }

   for (j = 0; j < 4; j++ ) {
      DebugPrint((PCMCIA_DUMP_SOCKET,
                  "IOWIN%d\tIOBASE %04X\tIOCTL %04X\n",
                  j, tcic.iowins[j].iobase, tcic.iowins[j].ioctl));
   }

   for (j = 0; j < 10; j++ ) {
      DebugPrint((PCMCIA_DUMP_SOCKET,
                  "MEMWIN%d\tMBASE %04X\tMMAP %04X\tMCTL %04X\n",
                  j, tcic.memwins[j].mbase,
                  tcic.memwins[j].mmap,
                  tcic.memwins[j].mctl));
   }
}
#endif



BOOLEAN
TcicEnableDisableCardDetectEvent(
   IN PSOCKET SocketPtr,
   IN BOOLEAN Enable
   )

/*++

Routine Description:

    Enable card detect interrupt.

Arguments:

    SocketPtr - socket information
    Irq - the interrupt value to set if enable is true.
    Enable - if  TRUE, CSC interrupt is enabled,
             if FALSE, it is disabled

Return Value:

    None

--*/

{
   UCHAR mappedIrq;
   PDBSOCKET pdb = (PDBSOCKET)SocketPtr;
   BOOLEAN retVal;

   switch (Enable) {
   case TRUE:
      //
      // Validate the interrupt request. Only setup if the IRQ is valid
      // for this controller
      //

      if ((mappedIrq = pdb->IRQMapTbl[SocketPtr->FdoIrq]) != (UCHAR)0) {

         USHORT word;

         //
         // Mask status change conditions other than CD. The pcic code comments
         // claimed to setup CD and RDY/BSY notification, but the code itself
         // only allows for CD.
         //

         word = (USHORT)(IRSCF2_MLBAT1 | IRSCF2_MLBAT2 | IRSCF2_MRDY | IRSCF2_MWP);
         TcicWriteIndirectRegs(SocketPtr,
                               IR_SCF2_S(SocketPtr->RegisterOffset),
                               1,
                               &word);

         //
         // Set the correct IRQ value in the SYSCFG register
         //

         word = TcicReadAuxReg(SocketPtr, MODE_AR_SYSCFG);
         word &= ~SYSCFG_IRQ_MASK;
         word |= (USHORT)mappedIrq;
         TcicWriteAuxReg(SocketPtr, MODE_AR_SYSCFG, word);

         //
         // Set IRQ polarity and enable via R_IENA
         //

         TcicSocketSelect(SocketPtr, SocketPtr->RegisterOffset);
         TcicWriteBaseReg(SocketPtr, R_IENA, IENA_CDCHG | IENA_CFG_HIGH);

         PcmciaWait(TcicStallCounter);
         //
         // Clear ICSR - so future insertions/removals will generate interrupts
         //
         (VOID) TcicDetectCardChanged(SocketPtr);
         retVal = TRUE;
      } else {
         retVal = FALSE;
      }
      break;
   case FALSE:{
         retVal = FALSE;
         break;
      }
   }
   return retVal;
}



NTSTATUS
TcicResetCard(
   IN PSOCKET SocketPtr,
   OUT PULONG pDelayTime
   )
/*++

Routine Description:

Arguments:

    SocketPtr - socket information
    pDelayTime - specifies delay (msec) to occur after the current phase

Return value:

    STATUS_MORE_PROCESSING_REQUIRED - increment phase, perform delay, recall
    other status values terminate sequence

--*/
{
   NTSTATUS status;
   PDBSOCKET pdb = (PDBSOCKET)SocketPtr;

   USHORT ilock;
   PDBSOCKET dbskt = (PDBSOCKET)(SocketPtr->DeviceExtension->SocketList);

   switch(SocketPtr->CardResetPhase) {
   case 1:
      //
      // reset PCCARD
      //

      ilock = TcicReadAuxReg(SocketPtr, MODE_AR_ILOCK);
      ilock &= ~(ILOCK_CRESET | ILOCK_CRESENA | ILOCK_CWAIT);
      TcicWriteAuxReg(SocketPtr, MODE_AR_ILOCK, (USHORT)(ilock | ILOCK_CRESENA | ILOCK_CRESET));
      *pDelayTime = TcicStallCounter;
      SocketPtr->PowerData = (ULONG) ilock;
      status = STATUS_MORE_PROCESSING_REQUIRED;
      break;

   case 2:

      ilock = (USHORT) SocketPtr->PowerData;
      TcicWriteAuxReg(SocketPtr, MODE_AR_ILOCK, (USHORT)(ilock | ILOCK_CRESENA));
      *pDelayTime = TcicStallCounter;
      status = STATUS_MORE_PROCESSING_REQUIRED;
      break;

   case 3:

      ilock = TcicReadAuxReg(SocketPtr,  MODE_AR_ILOCK);
      if (!(ilock & ILOCK_CWAITSNS)) {
         TcicWriteAuxReg(SocketPtr, MODE_AR_ILOCK, (USHORT)(ilock | ILOCK_CWAIT));
      }
      //
      // If not already started, start a timer to drive the BusyLED
      // Monitor routine.
      if (dbskt->timerStarted == FALSE) {
         IoInitializeTimer(pdb->skt.DeviceExtension->DeviceObject,
                           TcicBusyLedRoutine, NULL);
         IoStartTimer(pdb->skt.DeviceExtension->DeviceObject);
         dbskt->timerStarted = TRUE;
      }
      status = STATUS_SUCCESS;
      break;
   default:
      ASSERT(FALSE);
      status = STATUS_UNSUCCESSFUL;
   }
   return status;
}



NTSTATUS
TcicSetPower(
   IN PSOCKET socketPtr,
   IN BOOLEAN Enable,
   OUT PULONG pDelayTime
   )

/*++

Routine Description:

    Set power to the specified socket.

Arguments:

    SocketPtr - the socket to set
    Enable - TRUE means to set power - FALSE is to turn it off.
    pDelayTime - specifies delay (msec) to occur after the current phase

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED - increment phase, perform delay, recall
    other status values terminate sequence

--*/

{
   NTSTATUS status;

   //
   // Get the specified socket mapped into  the TCIC registers
   //

   TcicSocketSelect(socketPtr, socketPtr->RegisterOffset);

   if (Enable) {
      PDBSOCKET pdb = (PDBSOCKET)socketPtr;

      switch(socketPtr->PowerPhase) {
      case 1:

         //
         // Turn on power
         //

         DebugPrint((PCMCIA_DEBUG_INFO, "TcicSetPower: Powering UP pccard socket\n"));

         TcicWriteBaseReg(socketPtr, R_PWR, pdb->dflt_vcc5v);

         //
         // Enable other strobes to socket
         //

         TcicWriteBaseReg(socketPtr, R_SCTRL, SCTRL_ENA);

         //
         // When power is enabled always stall to give the PCCARD
         // a chance to react.
         //
         *pDelayTime = TcicStallCounter;
         status = STATUS_MORE_PROCESSING_REQUIRED;
         break;

      case 2:

         if (!TcicPCCardReady(socketPtr)) {
            DebugPrint((PCMCIA_PCCARD_READY,
                        "Tcic: PCCARD %x not ready after power\n",
                        socketPtr->RegisterOffset));
         }
         status = STATUS_SUCCESS;
         break;
      default:
         ASSERT(FALSE);
         status = STATUS_UNSUCCESSFUL;
      }
   } else {

      //
      // Disable socket strobes
      //
      DebugPrint((PCMCIA_DEBUG_INFO, "TcicSetPower: Powering DOWN pccard socket\n"));

      TcicWriteBaseReg(socketPtr, R_SCTRL, 0);

      //
      // Diable power
      //

      TcicWriteBaseReg(socketPtr, R_PWR, 0);
      status = STATUS_SUCCESS;
   }
   return status;
}



BOOLEAN
TcicInitializePcmciaSocket(
   PSOCKET SocketPtr
   )

/*++

Routine Description:

    This routine will setup the 82365 into a state where the pcmcia support
    module will be able to issue commands to read device tuples from the
    cards in the sockets.

Arguments:

    SocketPtr - socket specific info

Return Value:

    TRUE if successful
    FALSE if not successful

--*/

{
   PDBSOCKET pdb = (PDBSOCKET)SocketPtr;
   USHORT speedbits = WCTL_300NS;

   speedbits >>= pdb->clkdiv;

   //
   // If this is the first socket on this controller,
   // Reset the controller and do controller-wide initialization.
   //

   if (SocketPtr->RegisterOffset == 0) {
      USHORT words[4];
      int j;

      //
      // Reset Controller
      //

      TcicWriteBaseReg(SocketPtr, R_SCTRL, SCTRL_RESET);
      TcicWriteBaseReg(SocketPtr, R_SCTRL, 0);

      //
      // Initialize indirect socket regs
      //

      words[0] = pdb->dflt_scfg1;
      words[1] = (USHORT)(IRSCF2_MLBAT1 | IRSCF2_MLBAT2 | IRSCF2_MRDY | IRSCF2_MWP);
      TcicWriteIndirectRegs(SocketPtr,  IR_SCFG_S(0), 2, words);
      TcicWriteIndirectRegs(SocketPtr,  IR_SCFG_S(1), 2, words);

      //
      // Initialize indirect memwin regs
      //

      words[0] = words[1] = 0;
      words[2] = pdb->dflt_wrmctl;
      for (j = 0; j < pdb->nmemwins;  j++) {
         TcicWriteIndirectRegs(SocketPtr, IR_MBASE_W(j), 3, words);
      }

      //
      // Initialize indirect iowin regs
      //

      for (j = 0;  j < pdb->niowins; j++ ) {
         TcicWriteIndirectRegs(SocketPtr, IR_IOBASE_W(j), 2, words);
      }


      //
      // Initialize SYSCFG
      //

      TcicWriteAuxReg(SocketPtr, MODE_AR_SYSCFG, pdb->dflt_syscfg);
   }

   //
   // Get the specified Socket mapped into  the TCIC registers
   //

   TcicSocketSelect(SocketPtr, SocketPtr->RegisterOffset);

   //
   // Per/socket we initialize the following base and aux regs:
   // WCTL & ILOCK
   //

   TcicWriteAuxReg(SocketPtr, MODE_AR_WCTL, (USHORT)(pdb->dflt_wctl | speedbits));
   TcicWriteAuxReg(SocketPtr, MODE_AR_ILOCK, pdb->dflt_ilock);

   //
   // Say card is there
   //

   return TRUE;
}



USHORT
TcicReadBaseReg(
   IN PSOCKET SocketPtr,
   IN ULONG  Register
   )

/*++

Routine Description:

    Reads the specified TCIC base register,

Arguments:

    SocketPtr - instance data for this socket
    Register  - index of register to read

Return Value:

    register value read

--*/

{
   USHORT readData = 0;

   switch (Register) {
   case R_DATA:
   case R_ADDR:
   case R_ADDR2:
   case R_EDC:
   case R_AUX:
      readData = READ_PORT_USHORT((PUSHORT)(SocketPtr->AddressPort + Register));
      break;

   case R_SCTRL:
   case R_SSTAT:
   case R_MODE:
   case R_PWR:
   case R_ICSR:
   case R_IENA:
      readData = (USHORT)READ_PORT_UCHAR(SocketPtr->AddressPort + Register);
      break;
   }
   return readData;
}



VOID
TcicWriteBaseReg(
   IN PSOCKET SocketPtr,
   IN ULONG  Register,
   IN USHORT  value
   )

/*++

Routine Description:

    Write a value to the specified TCIC base register

Arguments:

    SocketPtr - instance data for this socket
    Register  - index of register to write
    value    -  value to write to register

Return Value:

    None

--*/

{
   USHORT readData = 0;

   switch (Register) {
   case R_DATA:
   case R_ADDR:
   case R_ADDR2:
   case R_EDC:
   case R_AUX:
      WRITE_PORT_USHORT((PUSHORT)(SocketPtr->AddressPort + Register), value);
      break;

   case R_SCTRL:
   case R_SSTAT:
   case R_MODE:
   case R_PWR:
   case R_ICSR:
   case R_IENA:
      WRITE_PORT_UCHAR(SocketPtr->AddressPort + Register, (UCHAR)value);
      break;
   }
}



ULONG
TcicReadAddrReg(
   IN PSOCKET SocketPtr
   )

/*++

Routine Description:

    Read the current value of the TCIC address register

Arguments:

    SocketPtr - instance data for this socket

Return Value:

    Address read from register

--*/

{
   ULONG retaddr;
   retaddr = (ULONG)TcicReadBaseReg(SocketPtr, R_ADDR);
   retaddr |= ((ULONG)TcicReadBaseReg(SocketPtr, R_ADDR2) << 16);
   return (retaddr);
}



VOID
TcicWriteAddrReg(
   IN PSOCKET SocketPtr,
   IN ULONG   addr
   )

/*++

Routine Description:

    Write an address to the TCIC address register

Arguments:

    SocketPtr - instance data for this socket
    addr - address to write to register

Return Value:

    None

--*/

{
   TcicWriteBaseReg(SocketPtr, R_ADDR, (USHORT)(addr & 0x0000ffff));
   TcicWriteBaseReg(SocketPtr, R_ADDR2, (USHORT)(addr >> 16));
}



USHORT
TcicReadAuxReg(
   IN PSOCKET SocketPtr,
   IN ULONG  Register
   )

/*++

Routine Description:

    Read the specified TCIC AUX register

Arguments:

    SocketPtr - instance data for this socket
    Register  - MODE_AR_xxx justified index of AUX register to read

Return Value:

    contents of specified AUX register

--*/

{
   USHORT readData = 0;
   USHORT OldMode;

   //
   // Get the current mode register value
   //

   OldMode = TcicReadBaseReg(SocketPtr, R_MODE);

   //
   // Mask out previous AUX register selection and add in new selection
   //

   TcicWriteBaseReg(SocketPtr, R_MODE,
                    (USHORT)((OldMode & ~MODE_AUXSEL_MASK) | Register));


   //
   // Read the selected AUX register
   //

   readData = TcicReadBaseReg(SocketPtr, R_AUX);

   //
   // Restore the mode reg to its original state
   //

   TcicWriteBaseReg(SocketPtr, R_MODE, OldMode);
   return readData;
}



VOID
TcicWriteAuxReg(
   IN PSOCKET SocketPtr,
   IN ULONG  Register,
   IN USHORT  value
   )

/*++

Routine Description:

    Write a value into the specified AUX register

Arguments:

    SocketPtr - instance data for this socket
    Register  - MODE_AR_xxx justified index of AUX register to write

Return Value:

    None

--*/

{
   USHORT readData = 0;
   USHORT OldMode;

   //
   // Get the current mode register value
   //

   OldMode = TcicReadBaseReg(SocketPtr, R_MODE);

   //
   // Mask out previous AUX register selection and add in new selection
   //

   TcicWriteBaseReg(SocketPtr, R_MODE,
                    (USHORT)((OldMode & ~MODE_AUXSEL_MASK) | Register));

   //
   // Write the data to the selected AUX register
   //

   TcicWriteBaseReg(SocketPtr, R_AUX, value);

   //
   // Restore the mode reg to its original state
   //

   TcicWriteBaseReg(SocketPtr, R_MODE, OldMode);
}



VOID
TcicReadIndirectRegs(
   IN PSOCKET SocketPtr,
   IN ULONG   StartRegister,
   IN USHORT  numWords,
   IN PUSHORT ReadBuffer
   )

/*++

Routine Description:

    Read one or multiple TCIC indirect registers.

Arguments:

    SocketPtr - instance data for this socket
    StartRegister - starting indirect register
    numWords - number of consecutive registers to read
    ReadBuffer - data buffer

Return Value:

    None

--*/

{
   USHORT OldHaddr;
   USHORT OldLaddr;
   USHORT OldSctrl;
   USHORT j;

   //
   // Get the current TCIC state
   //

   if (numWords > 1) {

      //
      // We won't set AUTO-Inc if only 1 word
      //

      OldSctrl = TcicReadBaseReg(SocketPtr, R_SCTRL);
   }

   OldLaddr = TcicReadBaseReg(SocketPtr, R_ADDR);
   OldHaddr = TcicReadBaseReg(SocketPtr, R_ADDR2);


   //
   // Set the TCIC state required for reading the indirect registers
   //

   TcicWriteBaseReg(SocketPtr, R_ADDR2,
                    (USHORT)(OldHaddr | ADR2_INDREG));
   TcicWriteBaseReg(SocketPtr, R_ADDR, (USHORT)StartRegister);
   if (numWords > 1) {
      TcicWriteBaseReg(SocketPtr, R_SCTRL, (USHORT)(OldSctrl | SCTRL_INCMODE_AUTO));
   }

   //
   // Read the Indirect registert requested
   //

   for (j = 0; j < numWords; j++) {
      *ReadBuffer++ = TcicReadBaseReg(SocketPtr, R_DATA);
   }

   //
   // Restore the original TCIC state
   //

   if (numWords > 1) {

      //
      // We didn't set AUTO-Inc if only 1 word
      //

      TcicWriteBaseReg(SocketPtr, R_SCTRL, OldSctrl);
   }
   TcicWriteBaseReg(SocketPtr, R_ADDR2, OldHaddr);
   TcicWriteBaseReg(SocketPtr, R_ADDR,  OldLaddr);
}



VOID
TcicWriteIndirectRegs(
   IN PSOCKET SocketPtr,
   IN ULONG   StartRegister,
   IN USHORT  numWords,
   IN PUSHORT WriteBuffer
   )

/*++

Routine Description:

    Write one or multiple TCIC indirect registers.

Arguments:

    SocketPtr - instance data for this socket
    StartRegister - starting indirect register
    numWords - number of consecutive registers to write
    WriteBuffer - data buffer

Return Value:

    None

--*/

{
   USHORT OldHaddr;
   USHORT OldLaddr;
   USHORT OldSctrl;
   USHORT j;

   //
   // Get the current TCIC state
   //

   if (numWords > 1) {

      //
      // We won't set AUTO-Inc if only 1 word
      //

      OldSctrl = TcicReadBaseReg(SocketPtr, R_SCTRL);
   }

   OldLaddr = TcicReadBaseReg(SocketPtr, R_ADDR);
   OldHaddr = TcicReadBaseReg(SocketPtr, R_ADDR2);

   //
   // Set the TCIC state required for reading the indirect registers
   //

   TcicWriteBaseReg(SocketPtr, R_ADDR2, (USHORT)(OldHaddr | (USHORT)ADR2_INDREG));
   TcicWriteBaseReg(SocketPtr, R_ADDR, (USHORT)StartRegister);
   if (numWords > 1) {
      TcicWriteBaseReg(SocketPtr, R_SCTRL, (USHORT)(OldSctrl | SCTRL_INCMODE_AUTO));
   }

   //
   // Read the Indirect registert requested
   //

   for (j = 0; j < numWords; j++) {
      TcicWriteBaseReg(SocketPtr, R_DATA, *WriteBuffer++);
   }

   //
   // Restore the original TCIC state
   //

   if (numWords > 1) {

      //
      // We didn't set AUTO-Inc if only 1 word
      //

      TcicWriteBaseReg(SocketPtr, R_SCTRL, OldSctrl);
   }
   TcicWriteBaseReg(SocketPtr, R_ADDR2, OldHaddr);
   TcicWriteBaseReg(SocketPtr, R_ADDR,  OldLaddr);
}





USHORT
TcicSocketSelect(
   IN PSOCKET SocketPtr,
   IN USHORT sktnum
   )

/*++

Routine Description:

    Map the specified socket registers into TCIC register space.

Arguments:

    SocketPtr - instance data for this socket
    sktnum    - socket number to map.

Return Value:

    previous socket mapped.

--*/

{
   USHORT OldAddrHi;

   OldAddrHi = READ_PORT_USHORT((PUSHORT)(SocketPtr->AddressPort + R_ADDR2));

   WRITE_PORT_USHORT((PUSHORT)(SocketPtr->AddressPort + R_ADDR2),
                     (USHORT)((OldAddrHi & ~TCIC_SS_MASK) | (USHORT)(sktnum << TCIC_SS_SHFT)));

   return (USHORT)((OldAddrHi & TCIC_SS_MASK) >> TCIC_SS_SHFT);
}



ULONG
TcicReadCardMemory(
   IN PPDO_EXTENSION PdoExtension,
   IN MEMORY_SPACE MemorySpace,
   IN ULONG   Offset,
   IN PUCHAR  Buffer,
   IN ULONG   Length
   )

/*++

Routine Description:

    This routine will set up the card to read attribute memory.

Arguments:

    SocketPtr -- The socket info in for the card being read
    Offset    -- Offset from which to read
    MemorySpace -- Attribute memory or Common Memory
    Buffer --   Pointer to buffer in which memory contents are returned
    Length --   No. of bytes to be returned

Return Value:

    TRUE - if read was successful.

--*/

{
   PSOCKET SocketPtr = PdoExtension->Socket;
   ULONG  size;
   ULONG  tcicaddr;
   ULONG  i;
   USHORT word;

   //
   // Make sure the card is ready
   //

   if (!TcicPCCardReady(SocketPtr)) {
      DebugPrint((PCMCIA_PCCARD_READY,
                  "Tcic: PCCARD %x not ready for read attribute memory\n",
                  SocketPtr->RegisterOffset));
   }

   if (MemorySpace != PCCARD_ATTRIBUTE_MEMORY) {

      return 0;
   }

   tcicaddr = ADDR_REG | (SocketPtr->RegisterOffset << ADDR_SS_SHFT);
   TcicWriteAddrReg(SocketPtr, tcicaddr);

   word = TcicReadBaseReg(SocketPtr, R_SCTRL);
   word |= SCTRL_INCMODE_AUTO;
   TcicWriteBaseReg(SocketPtr, R_SCTRL, word);

   //
   // Hardware needs to settle
   //
   PcmciaWait(50000);

   //
   // Skip up to the offset
   //
   for (i = 0; i < Offset; i++) {
      (VOID)TcicReadBaseReg(SocketPtr, R_DATA);
   }

   //
   // Read the attribute memory
   //
   for (i = 0; i < Length; i++) {
      *Buffer++ = (UCHAR)TcicReadBaseReg(SocketPtr, R_DATA);
   }

   return Length;
}



ULONG
TcicWriteCardMemory(
   IN PPDO_EXTENSION PdoExtension,
   IN MEMORY_SPACE MemorySpace,
   IN ULONG  Offset,
   IN PUCHAR Buffer,
   IN ULONG  Length
   )
/*++

Routine Description:
   This routine will write into the configuration memory on the card
   with the supplied buffer. This is provided as a service to certain
   client drivers (netcard) which need to write to the attribute memory
   (say) to set parameters etc.

Arguments:

    SocketPtr   -- The socket info in for the card being written to
    MemorySpace -- indicates which space - attribute or common memory
    Offset      -- Offset in the memory to write to
    Buffer      -- Buffer contents being dumped to the card
    Length      -- Length of the buffer being written out

--*/
{

   PSOCKET SocketPtr = PdoExtension->Socket;
#define TCIC_ATTRIBUTE_MEM_WINDOW_INDEX 5
   PUCHAR   memoryPtr;
   ULONG    index;
   UCHAR    memGran;

   memGran = (MemorySpace == PCCARD_ATTRIBUTE_MEMORY)? 2 : 1;

   memoryPtr=((PFDO_EXTENSION) (SocketPtr->DeviceExtension))->AttributeMemoryBase +
             memGran * Offset;

   TcicSetMemWin(SocketPtr,
                 (USHORT) (TCIC_ATTRIBUTE_MEM_WINDOW_INDEX+SocketPtr->SocketNumber),
                 0,
                 SocketPtr->DeviceExtension->PhysicalBase.LowPart,
                 SocketPtr->DeviceExtension->AttributeMemorySize,
                 (UCHAR) (MemorySpace == PCCARD_ATTRIBUTE_MEMORY),
                 0,
                 0);

   if (!TcicPCCardReady(SocketPtr)) {
      DebugPrint((PCMCIA_PCCARD_READY,
                  "TCIC: PCCARD in socket %x not ready for write memory\n",
                  SocketPtr->RegisterOffset));
   }
   for (index=0; index < Length; index++) {
      WRITE_REGISTER_UCHAR(memoryPtr, Buffer[index]);
      memoryPtr += memGran;
   }

   TcicSetMemWin(SocketPtr,
                 (USHORT) (TCIC_ATTRIBUTE_MEM_WINDOW_INDEX+SocketPtr->SocketNumber),
                 0,
                 0,
                 0,
                 0,
                 0,
                 0);
   return Length;
}



BOOLEAN
TcicProcessConfigureRequest(
   IN PSOCKET socketPtr,
   IN PCARD_REQUEST request,
   IN PUCHAR Base
   )

/*++

Routine Description:

    Processes a configure or IRQ setup request.

Arguments:

    socketPtr - instance data for this socket
    ConfigRequest -- Socket config structure
    Base - the I/O port base  - not used

Return Value:

    None

--*/

{
   USHORT         index, index2;
   USHORT         tmp;
   ULONG          ltmp;
   USHORT             words[3];
   PDBSOCKET          pdbs;

   //
   // Since all first entries in the config structure is a RequestType,
   // cast the pointer comming in as a PREQUEST_CONFIG to get the proper
   // RequestType
   //

   switch (request->RequestType) {
   case IO_REQUEST:

      //
      // Set up I/O ranges on the controller
      //

      for (index = 0; index < request->u.Io.NumberOfRanges; index++) {
         if (request->u.Io.IoEntry[index].BasePort != 0) {
            TcicSetIoWin(socketPtr, index,
                         request->u.Io.IoEntry[index].BasePort,
                         request->u.Io.IoEntry[index].NumPorts,
                         request->u.Io.IoEntry[index].Attributes);
         } else {
            DebugPrint((PCMCIA_DEBUG_FAIL, "PCMCIA: Got an IO Configure Request with an invalid Port\n"));
            break;
         }
      }
      break;

   case IRQ_REQUEST:

      pdbs = (PDBSOCKET)socketPtr;
      ltmp = ADDR_INDREG | (socketPtr->RegisterOffset << ADDR_SS_SHFT);
      ltmp |= (ULONG)IR_SCFG_S(socketPtr->RegisterOffset);
      TcicWriteAddrReg(socketPtr, ltmp);
      TcicWriteBaseReg(socketPtr, R_SCTRL, SCTRL_ENA);
      tmp = TcicReadBaseReg(socketPtr, R_DATA);
      tmp &= ~IRSCFG_IRQ_MASK;
      tmp |= pdbs->IRQMapTbl[request->u.Irq.AssignedIRQ];
      TcicWriteBaseReg(socketPtr, R_DATA, tmp);
      break;

   case CONFIGURE_REQUEST:

      //
      // This is where we setup the card and get it ready for operation
      //

      if (!TcicPCCardReady(socketPtr)) {
         DebugPrint((PCMCIA_PCCARD_READY,
                     "Tcic: PCCARD %x not ready for configuration index\n",
                     socketPtr));
         return FALSE;
      }

      if (request->u.Config.RegisterWriteMask & REGISTER_WRITE_CONFIGURATION_INDEX) {
         ltmp = request->u.Config.ConfigBase;
         ltmp |= ADDR_REG | (socketPtr->RegisterOffset << ADDR_SS_SHFT);
         TcicWriteAddrReg(socketPtr, ltmp);
         TcicWriteBaseReg(socketPtr, R_SCTRL, SCTRL_ENA);

         TcicWriteBaseReg(socketPtr, R_DATA, request->u.Config.ConfigIndex);
         PcmciaWait(TcicStallCounter);
         TcicWriteBaseReg(socketPtr, R_DATA,
                          (USHORT)(request->u.Config.ConfigIndex | 0x40));
         PcmciaWait(TcicStallCounter);
      }
      if (request->u.Config.RegisterWriteMask & REGISTER_WRITE_CARD_CONFIGURATION) {
         ltmp = request->u.Config.ConfigBase + 2;
         ltmp |= ADDR_REG | (socketPtr->RegisterOffset << ADDR_SS_SHFT);
         TcicWriteAddrReg(socketPtr, ltmp);
         TcicWriteBaseReg(socketPtr, R_SCTRL, SCTRL_ENA);

         tmp = TcicReadBaseReg(socketPtr, R_DATA);
         tmp |= request->u.Config.CardConfiguration;

         //
         // turn off power control bit
         //

         tmp &= ~0x04;

         TcicWriteBaseReg(socketPtr, R_DATA, tmp);
      }
      break;

   case DECONFIGURE_REQUEST:
      //
      // Deregister the interrupt
      //
      pdbs = (PDBSOCKET)socketPtr;
      ltmp = ADDR_INDREG | (socketPtr->RegisterOffset << ADDR_SS_SHFT);
      ltmp |= (ULONG)IR_SCFG_S(socketPtr->RegisterOffset);
      TcicWriteAddrReg(socketPtr, ltmp);
      TcicWriteBaseReg(socketPtr, R_SCTRL, SCTRL_ENA);
      tmp = TcicReadBaseReg(socketPtr, R_DATA);
      tmp &= ~IRSCFG_IRQ_MASK;
      TcicWriteBaseReg(socketPtr, R_DATA, tmp);

      //
      // Disable I/O, memory windows
      //
      break;

   case MEM_REQUEST:

      //
      // Set up memory ranges on the controller.
      //

      for (index = 0; index < request->u.Memory.NumberOfRanges; index++) {

         TcicSetMemWin(socketPtr,
                       index,
                       request->u.Memory.MemoryEntry[index].BaseAddress,
                       request->u.Memory.MemoryEntry[index].HostAddress,
                       request->u.Memory.MemoryEntry[index].WindowSize,
                       request->u.Memory.MemoryEntry[index].AttributeMemory,
                       request->u.Memory.AccessSpeed,
                       request->u.Memory.Attributes);
      }
      break;


   default:
      DebugPrint((PCMCIA_DEBUG_FAIL, "PCMCIA: ConfigRequest is INVALID!\n"));

   }
   return TRUE;
}



BOOLEAN
TcicDetectCardInSocket(
   IN PSOCKET socketPtr
   )

/*++

Routine Description:

    This routine will determine if a card is in the socket

Arguments:

    SocketPtr -- Socket info.

Return Value:

    TRUE if card is present.

--*/

{
   //
   // Get the specified socket mapped into  the TCIC registers
   //

   TcicSocketSelect(socketPtr, socketPtr->RegisterOffset);

   //
   // Read the Tcic status register to see if the card is in there.
   //
   return (TcicReadBaseReg(socketPtr, R_SSTAT) & SSTAT_CD) ?TRUE :FALSE;
}



BOOLEAN
TcicDetectCardChanged(
   IN PSOCKET socketPtr
   )

/*++

Routine Description:

    This routine will determine if socket's card insertion status has changed.

Arguments:

    socketPtr -- Socket info.

Return Value:

    TRUE if card insertion status has changed.

--*/

{
   BOOLEAN changed;

   //
   // Get the specified socket mapped into  the TCIC registers
   //

   TcicSocketSelect(socketPtr, socketPtr->RegisterOffset);

   //
   // Read the Tcic ICSR register to see if CD's have changed.
   //

   changed = (TcicReadBaseReg(socketPtr, R_ICSR) & ICSR_CDCHG) ?TRUE :FALSE;

   //
   // Clear bits in ICSR
   //

   while (TcicReadBaseReg(socketPtr, R_ICSR)) {
      TcicWriteBaseReg(socketPtr, R_ICSR, ICSR_JAM);
   }

   return (changed);
}



BOOLEAN
TcicDetectReadyChanged(
   IN PSOCKET socketPtr
   )
{
   return FALSE;
}



BOOLEAN
TcicPCCardReady(
   IN PSOCKET SocketPtr
   )

/*++

Routine Description:

    Loop for a reasonable amount of time waiting for the card status to
    return ready.

Arguments:

    SocketPtr - instance data for the socket to check.

Return Value:

    TRUE - the card is ready.
    FALSE - after a reasonable delay the card is still not ready.

--*/

{
   ULONG index;

   //
   // Get the specified socket mapped into  the TCIC registers
   //

   TcicSocketSelect(SocketPtr, SocketPtr->RegisterOffset);

   for (index = 0;
       index < 500000
       && !(TcicReadBaseReg(SocketPtr, R_SSTAT) & SSTAT_RDY);
       index++) {

      PcmciaWait(20);
      //
      // Check if the card is still there: if not, we can return
      //
      if (!TcicDetectCardInSocket(SocketPtr)) {
         return FALSE;
      }
   }

   if (index < 500000) {
      DebugPrint((PCMCIA_COUNTERS, "TcicPCCardReady: %d\n", index));
      return TRUE;
   }
   return FALSE;
}




NTSTATUS
TcicDetect(
   IN PFDO_EXTENSION DeviceExtension
   )

/*++

Routine Description:

    Locate any PCMCIA sockets supported by this driver.  This routine
    will find the TCIC2 and compatible parts.

Arguments:

    DeviceExtension - the root for the SocketList.

Return Value:

    STATUS_SUCCESS if a socket is found - failure status otherwise.

--*/

{
   ULONG            ioPortBase      = 0x100;
   ULONG            ioBaseIncrement = 0x10;
   ULONG            tcicLowAddr;
   ULONG            tcicHighAddr;
   ULONG            addressSpace;
   BOOLEAN          mapped;
   PHYSICAL_ADDRESS cardAddress;
   PHYSICAL_ADDRESS portAddress;
   SOCKET           locskt;
   UCHAR            socketNumber = 0;
   static  BOOLEAN  foundOne = FALSE;
   BOOLEAN          resourcesAllocated = FALSE;
   BOOLEAN          conflict;
   PCM_RESOURCE_LIST cmResourceList = NULL;
   PCM_PARTIAL_RESOURCE_LIST cmPartialResourceList;
   NTSTATUS         status;

   if (foundOne) {
      //
      //  No support for multiple controllers currently..
      //  So we just give up if one controller was already reported
      //
      return STATUS_NO_MORE_ENTRIES;
   }


   DeviceExtension->Configuration.InterfaceType = Isa;
   DeviceExtension->Configuration.BusNumber = 0x0;

   TcicRegistryLookupScanLimits(&tcicLowAddr, &tcicHighAddr);

   //
   // Get the resources used for detection
   //
   cmResourceList = ExAllocatePool(PagedPool, sizeof(CM_RESOURCE_LIST));

   if (!cmResourceList) {
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(cmResourceList, sizeof(CM_RESOURCE_LIST));
   cmResourceList->Count = 1;
   cmResourceList->List[0].InterfaceType = Isa;
   cmPartialResourceList = &(cmResourceList->List[0].PartialResourceList);
   cmPartialResourceList->Version  = 1;
   cmPartialResourceList->Revision = 1;
   cmPartialResourceList->Count    = 1;
   cmPartialResourceList->PartialDescriptors[0].Type = CmResourceTypePort;
   cmPartialResourceList->PartialDescriptors[0].ShareDisposition = CmResourceShareDeviceExclusive;
   cmPartialResourceList->PartialDescriptors[0].Flags = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_10_BIT_DECODE;
   cmPartialResourceList->PartialDescriptors[0].u.Port.Length = 2;


   for (ioPortBase = tcicLowAddr;
       ioPortBase < tcicHighAddr;
       ioPortBase += ioBaseIncrement) {

      //
      // Reset ioBaseIncrement to default value
      //

      ioBaseIncrement = 0x10;

      addressSpace = 1; // port space
      portAddress.LowPart = ioPortBase;
      portAddress.HighPart = 0;

      //
      // Free up the allocated resources if any
      //
      if (resourcesAllocated) {
         IoReportResourceForDetection(DeviceExtension->DriverObject,
                                      NULL, 0, NULL, NULL, 0, &conflict);
      }

      resourcesAllocated = FALSE;
      cmPartialResourceList->PartialDescriptors[0].u.Port.Start = portAddress;

      status=IoReportResourceForDetection(
                                         DeviceExtension->DriverObject,
                                         cmResourceList,
                                         sizeof(CM_RESOURCE_LIST),
                                         NULL,
                                         NULL,
                                         0,
                                         &conflict);
      if (!NT_SUCCESS(status) || conflict) {
         continue;
      }
      resourcesAllocated = TRUE;


      if (!HalTranslateBusAddress(Isa, 0, portAddress, &addressSpace,&cardAddress)) {
         continue;
      }

      if (addressSpace) {
         mapped = FALSE;
         locskt.AddressPort = (PUCHAR)(cardAddress.QuadPart);
      } else {
         mapped = TRUE;
         locskt.AddressPort = MmMapIoSpace(cardAddress, 0x10, FALSE);
      }

      locskt.RegisterOffset = 0;

      //
      // Sniff the address to see if it even resembles a TCIC chip
      //

      foundOne = TcicReservedBitsOK(&locskt);
      if (mapped) {
         MmUnmapIoSpace(locskt.AddressPort, 0x10);
      }

      //
      // Found an adapter
      //

      if (foundOne) {
         PcmciaSetControllerType(DeviceExtension, PcmciaDatabook);
         break;
      }
#if 0
      //
      // Now check for the aliases
      //

      switch (TcicCheckAliasType((PDBSOCKET)socketPtr)) {
      case TCIC_IS140:

         //
         // TMI-140s decode 32 consecutive bytes, make
         // sure we skip past the alias
         //

         ioBaseIncrement += 0x10;
         break;

      }
#endif
   }

   //
   // Free up the allocated resources if any
   //
   if (resourcesAllocated) {
      IoReportResourceForDetection(DeviceExtension->DriverObject,
                                   NULL, 0, NULL, NULL, 0, &conflict);
   }
   //
   // Free up allocated memory if any
   //
   if (cmResourceList) {
      ExFreePool(cmResourceList);
   }
   return foundOne ? STATUS_SUCCESS : STATUS_NO_MORE_ENTRIES;
}



NTSTATUS
TcicBuildSocketList(
   IN PFDO_EXTENSION DeviceExtension
   )

/*++

Routine Description:

    Locate any PCMCIA sockets supported by this driver.  This routine
    will find the TCIC2 and compatible parts and construct DBSOCKET
    structures to represent all sockets found.

Arguments:

    DeviceExtension - the root for the SocketList.

Return Value:

    STATUS_SUCCESS if a socket is found - failure status otherwise.

--*/

{
   PSOCKET          socketPtr = NULL;
   PSOCKET          previousSocketPtr;
   SOCKET           locskt;
   static UCHAR     socketNumber = 0;

   previousSocketPtr = NULL;


   locskt.RegisterOffset = 0;
   locskt.AddressPort = (PUCHAR)DeviceExtension->Configuration.UntranslatedPortAddress;

   //
   // Sniff the address to see if it even resembles a TCIC chip
   //

   if (TcicReservedBitsOK(&locskt) == FALSE ) {
      return STATUS_NO_MORE_ENTRIES;
   }

   //
   // Found an adapter
   //

   TcicFillInAdapter(&locskt,
                     &socketPtr,
                     &previousSocketPtr,
                     DeviceExtension,
                     (ULONG)DeviceExtension->Configuration.UntranslatedPortAddress);
                     
   if (socketPtr == NULL) {
      return STATUS_UNSUCCESSFUL;
   }
                           
   socketPtr->SocketNumber = socketNumber++;

   return STATUS_SUCCESS;
}




VOID
TcicFillInAdapter(
   IN PSOCKET plocskt,
   IN PSOCKET *psocketPtr,
   IN PSOCKET *previousSocketPtr,
   IN PFDO_EXTENSION DeviceExtension,
   IN ULONG   ioPortBase
   )

/*++

Routine Description:

    Fill in the DBSOCKET pointer info for the adapter just located by
    TcicDetect().  This routine is not part of TcicDetect() so as to allow
    for logic flow when dealing with multiple sockets or adapters.

Arguments:

    plocskt - info regarding the socket just found
    psocketPtr   - current socket ptr from caller
    previousSocketPtr - prev socket ptr form caller
    DeviceExtension  - head of socket list
    ioPortBase - physical i/o addr for this controller

Return Value:

    None

--*/

{
   PDBSOCKET dbsocketPtr = ExAllocatePool(NonPagedPool, sizeof(DBSOCKET));

   PAGED_CODE();

   if (!dbsocketPtr) {
      return;
   }
   RtlZeroMemory(dbsocketPtr, sizeof(DBSOCKET));
   dbsocketPtr->physPortAddr = ioPortBase;
   *psocketPtr = (PSOCKET)dbsocketPtr;

   (*psocketPtr)->DeviceExtension = DeviceExtension;
   (*psocketPtr)->RegisterOffset = 0;
   (*psocketPtr)->AddressPort = plocskt->AddressPort;
   (*psocketPtr)->SocketFnPtr = &TcicSupportFns;

   if (*previousSocketPtr) {
      (*previousSocketPtr)->NextSocket = *psocketPtr;
   } else {
      DeviceExtension->SocketList = *psocketPtr;
   }
   *previousSocketPtr = *psocketPtr;

   DebugPrint((PCMCIA_DEBUG_DETECT,
               "PCMCIA: TCIC Port %x\n",
               plocskt->AddressPort));

   //
   // Fill in the rest of the adapter info here...
   //

   TcicGetAdapterInfo(dbsocketPtr);

   //
   // See if there is a second socket on this TCIC
   //

   if (TcicCheckSkt(plocskt, 1)) {
      dbsocketPtr = ExAllocatePool(NonPagedPool, sizeof(DBSOCKET));
      if (dbsocketPtr) {
         RtlMoveMemory(dbsocketPtr, *psocketPtr, sizeof(DBSOCKET));
         *psocketPtr = (PSOCKET)dbsocketPtr;
         (*psocketPtr)->RegisterOffset = 1;
         (*previousSocketPtr)->NextSocket = *psocketPtr;
         *previousSocketPtr = *psocketPtr;
         dbsocketPtr->dflt_vcc5v = TcicGet5vVccVal(dbsocketPtr);
      }
   }
}




VOID
TcicGetAdapterInfo(
   IN PDBSOCKET dbsocketPtr
   )

/*++

Routine Description:

    Deterimine adapter specific information from detection heuristics.

Arguments:

    dbsocketPtr - structure to fill in.

Return Value:

    None

--*/

{
   PAGED_CODE();

   TcicChipID(dbsocketPtr);

   dbsocketPtr->niowins    = (UCHAR)TcicGetnIOWins(dbsocketPtr);
   dbsocketPtr->nmemwins   = (UCHAR)TcicGetnMemWins(dbsocketPtr);
   dbsocketPtr->clkdiv         = TcicClockRate(&dbsocketPtr->skt) - (USHORT)1;
   dbsocketPtr->dflt_vcc5v = TcicGet5vVccVal(dbsocketPtr);

   dbsocketPtr->dflt_wctl = (USHORT)((dbsocketPtr->clkdiv  != 0)
                                     ? (WAIT_BCLK | WAIT_RISING | WAIT_ASYNC)
                                     : (WAIT_ASYNC | WAIT_RISING));

   dbsocketPtr->dflt_syscfg = (USHORT)(SYSCFGMPSEL_EXTSEL | SYSCFG_MCSFULL);

   if (TcicCheckXBufNeeded(&dbsocketPtr->skt)) {
      dbsocketPtr->dflt_syscfg |= (USHORT)(SYSCFG_ICSXB | SYSCFG_MCSXB);
   }

   dbsocketPtr->dflt_ilock  = (USHORT)ILOCK_HOLD_CCLK;
   dbsocketPtr->dflt_wrmctl = (USHORT)0;
   dbsocketPtr->dflt_scfg1  = (USHORT)IRSCFG_IOSTS;

   TcicGetIRQMap(dbsocketPtr);

   //
   // Fiddle the map for all but 084/184 so that SKTIRQ (0bh) has
   // the correct map code (1)    (PNPFIX)
   //

   if (TcicHasSktIRQPin(dbsocketPtr) == TRUE && dbsocketPtr->IRQMapTbl[11] == 11) {
      dbsocketPtr->IRQMapTbl[11] = 1;
   }

}


PUCHAR
TcicAllocateMemRange(
   IN PFDO_EXTENSION DeviceExtension,
   IN PULONG Mapped,
   IN PULONG Physical
   )

/*++

Routine Description:

    Search the 640K to 1MB region for an 8K open area to be used
    for XBuffer checking.

Arguments:

    DeviceExtension - head of socket list
    Mapped   - state info from caller to allow later release
    Physical - state info from caller to allow later release

Return Value:

    A physical address for the window to the card or zero meaning
    there is no opening.

--*/

{
#define NUMBER_OF_TEST_BYTES 5
   PHYSICAL_ADDRESS physicalMemoryAddress;
   PHYSICAL_ADDRESS halMemoryAddress;
   BOOLEAN          translated;
   ULONG            untranslatedAddress;
   PUCHAR           memoryAddress;
   PUCHAR           bogus;
   ULONG            addressSpace;
   ULONG            index;
   UCHAR            memory[NUMBER_OF_TEST_BYTES];

   PAGED_CODE();

   *Mapped = FALSE;

   if (DeviceExtension->PhysicalBase.QuadPart) {
      untranslatedAddress = DeviceExtension->PhysicalBase.LowPart;
   } else {
      untranslatedAddress = 0xd0000;
   }

   for (/* nothing */; untranslatedAddress < 0xFF000; untranslatedAddress += TCIC_WINDOW_ALIGNMENT) {

      if (untranslatedAddress == 0xc0000) {

         //
         // This is VGA.  Keep this test if the for loop should
         // ever change.
         //

         continue;
      }
      addressSpace = 0;
      physicalMemoryAddress.LowPart = untranslatedAddress;
      physicalMemoryAddress.HighPart = 0;

      translated = HalTranslateBusAddress(Isa,
                                          0,
                                          physicalMemoryAddress,
                                          &addressSpace,
                                          &halMemoryAddress);

      if (!translated) {

         //
         // HAL doesn't like this translation
         //

         continue;
      }
      if (addressSpace) {
         memoryAddress = (PUCHAR)(halMemoryAddress.QuadPart);
      } else {
         memoryAddress = MmMapIoSpace(halMemoryAddress, TCIC_WINDOW_SIZE, FALSE);
      }

      //
      // Test the memory window to determine if it is a BIOS, video
      // memory, or open memory.  Only want to keep the window if it
      // is not being used by something else.
      //

      for (index = 0; index < NUMBER_OF_TEST_BYTES; index++) {
         memory[index] = READ_REGISTER_UCHAR(memoryAddress + index);
         if (index) {
            if (memory[index] != memory[index - 1]) {
               break;
            }
         }
      }

      if (index == NUMBER_OF_TEST_BYTES) {

         //
         // There isn't a BIOS here
         //

         UCHAR memoryPattern[NUMBER_OF_TEST_BYTES];
         BOOLEAN changed = FALSE;

         //
         // Check for video memory - open memory should always remain
         // the same regardless what the changes are.  Change the
         // pattern previously found.
         //

         for (index = 0; index < NUMBER_OF_TEST_BYTES; index++) {
            memoryPattern[index] = ~memory[index];
            WRITE_REGISTER_UCHAR(memoryAddress + index,
                                 memoryPattern[index]);
         }

         //
         // See if the pattern in memory changed.
         // Some system exhibit a problem where the memory pattern
         // seems to be cached.  If this code is debugged it will
         // work as expected, but if it is run normally it will
         // always return that the memory changed.  This random
         // wandering seems to remove this problem.
         //

         for (index = 0; index < NUMBER_OF_TEST_BYTES; index++) {
            memoryPattern[index] = 0;
         }
         bogus = ExAllocatePool(NonPagedPool, 64 * 1024);

         if (bogus) {
            for (index = 0; index < 64 * 1024; index++) {
               bogus[index] = 0;
            }
            ExFreePool(bogus);
         }

         //
         // Now go off and do the actual check to see if the memory
         // changed.
         //

         for (index = 0; index < NUMBER_OF_TEST_BYTES; index++) {

            if ((memoryPattern[index] = READ_REGISTER_UCHAR(memoryAddress + index)) != memory[index]) {

               //
               // It changed - this is not an area of open memory
               //

               changed = TRUE;
            }
            WRITE_REGISTER_UCHAR(memoryAddress + index,
                                 memory[index]);
         }

         if (!changed) {

            //
            // Area isn't a BIOS and didn't change when written.
            // Use this region for the memory window to PCMCIA
            // attribute memory.
            //

            *Mapped = addressSpace ? FALSE : TRUE;
            *Physical = untranslatedAddress;
            return memoryAddress;
         }
      }

      if (!addressSpace) {
         MmUnmapIoSpace(memoryAddress, TCIC_WINDOW_SIZE);
      }
   }

   return NULL;
}



BOOLEAN
TcicReservedBitsOK(
   IN PSOCKET pskt
   )

/*++

Routine Description:

    Various offsets from a base IO address are read and checked for
    reasonable values (e.g., see that reserved bits are zero)
    First the primary registers are checked, then if the mode
    register is pointing at an aux register that has reserved bits,
    then that value is checked as well.

    If the TCIC is not in reset, then the programming timers
    will have expired by the time this runs

    Further, a read from the data register should change the
    EDC register.

    Note that these tests are as nondestructive as possible, e.g.
    initially only read accesses are made to the IO range in question.

Arguments:

    pskt - pointer to an Instance data to work from.

Return Value:

    TRUE if all reserved bits are zero

--*/

{
   USHORT i, j, bits;

   PAGED_CODE();
   //
   // R_ADDR bits 30:28 have restricted range
   //

   i = (USHORT)((TcicReadBaseReg(pskt, R_ADDR2) & TCIC_SS_MASK) >> TCIC_SS_SHFT);
   if ( i > 1) {
      return FALSE;
   }

   //
   // R_SCTRL bits 6,2,1 are reserved
   //

   if (TcicReadBaseReg(pskt, R_SCTRL) & ((~(SCTRL_ENA|SCTRL_INCMODE|SCTRL_EDCSUM|SCTRL_RESET)) & 0x00ff)) {
      return FALSE;
   }


   //
   // R_ICSR bit 2 must be same as bit 3
   //

   i = TcicReadBaseReg(pskt, R_ICSR);
   i &= (ICSR_ILOCK | ICSR_STOPCPU);
   if ((i != 0) && (i != (ICSR_ILOCK | ICSR_STOPCPU))) {
      return FALSE;
   }

   //
   // R_IENA bits 7,2 are reserved
   //

   if (TcicReadBaseReg(pskt, R_IENA) & ((~(IENA_CDCHG|IENA_PROGTIME|IENA_ILOCK|IENA_CFG_MASK)) & 0xff)) {
      return FALSE;
   }

   //
   // Some aux registers have reserved bits
   // Which are we looking at?
   //

   i = (USHORT)(TcicReadBaseReg(pskt, R_MODE) & MODE_AUXSEL_MASK);
   j = TcicReadBaseReg(pskt, R_AUX);
   switch (i) {
   case MODE_AR_SYSCFG:
      if (INVALID_AR_SYSCFG(j)) {
         return FALSE;
      }
      break;


   case MODE_AR_ILOCK:
      if (INVALID_AR_ILOCK(j)) {
         return FALSE;
      }
      break;

   case MODE_AR_TEST:
      if (INVALID_AR_TEST(j)) {
         return FALSE;
      }
      break;
   }

   //
   // Various bits set or not depending if in RESET mode
   //

   i = TcicReadBaseReg(pskt, R_SCTRL);
   if (i & SCTRL_RESET) {

      //
      // address bits must be 0 */
      //

      if ((TcicReadBaseReg(pskt, R_ADDR)  != 0) || (TcicReadBaseReg(pskt, R_ADDR2) != 0)) {
         return FALSE;
      }

      //
      // EDC bits must be 0 */
      //

      if (TcicReadBaseReg(pskt, R_EDC) != 0) {
         return FALSE;
      }

      //
      // We're OK, so take it out of reset
      // Note: we can write a 0 because RESET guarantees us that the
      // other bits in SCTRL are 0.
      //

      TcicWriteBaseReg(pskt, R_SCTRL, 0);

   } else {

      //
      // not in reset
      // programming timers must be expired
      //

      i = TcicReadBaseReg(pskt, R_SSTAT);
      if ((i & (SSTAT_6US | SSTAT_10US | SSTAT_PROGTIME)) != (SSTAT_6US | SSTAT_10US | SSTAT_PROGTIME)) {
         return FALSE;
      }

      //
      // EDC bits should change on read from data space
      // as long as either EDC or the data are nonzero
      //

      if ((TcicReadBaseReg(pskt, R_ADDR2) & ADR2_INDREG) == 0) {

         j = TcicReadBaseReg(pskt, R_EDC);
         i = TcicReadBaseReg(pskt, R_DATA);

         if ( i | j ) {
            i = TcicReadBaseReg(pskt, R_EDC);
            if (i==j) {
               return FALSE;
            }
         }
      }

      j = TcicReadBaseReg(pskt, R_MODE);
      i = (USHORT)(j ^ MODE_AUXSEL_MASK);
      TcicWriteBaseReg(pskt, R_MODE, i);
      if (TcicReadBaseReg(pskt, R_MODE) != i) {
         return(FALSE);
      }

      TcicWriteBaseReg(pskt, R_MODE, j);
   }

   //
   // All tests passed
   //

   return TRUE;
}



USHORT
TcicChipID(
   IN PDBSOCKET pInst
   )

/*++

Routine Description:

    Read the silicon ID from a TCIC

Arguments:

    pInst - pointer to an Instance data to work from.

Return Value:

    The TCIC chip id.

--*/

{
   USHORT id, oldtest;

   PAGED_CODE();
   oldtest = TcicReadAuxReg (&pInst->skt, MODE_AR_TEST);
   TcicWriteAuxReg (&pInst->skt, MODE_AR_TEST, (USHORT)TEST_DIAG);
   id = TcicReadAuxReg (&pInst->skt, MODE_AR_ILOCK);
   TcicWriteAuxReg (&pInst->skt, MODE_AR_TEST, oldtest);
   id &= ILOCKTEST_ID_MASK;
   id >>= ILOCKTEST_ID_SHFT;

   //
   // clearn up IRQs inside TCIC
   //

   while (TcicReadBaseReg (&pInst->skt, R_ICSR)) {
      TcicWriteBaseReg (&pInst->skt, R_ICSR, ICSR_JAM);
   }

   return (pInst->chipType = id);
}



BOOLEAN
TcicCheckSkt(
   IN PSOCKET pInst,
   IN int iSocket
   )

/*++

Routine Description:

    If R_SSTAT shows a card inserted, we're done already.
    otherwise, we set up /CRDYBSY and /CWAIT such that if
    there is a socket present, they will float high

Arguments:

    pInst - pointer to an Instance data to work from.
    iSocket - zero-based socket number

Return Value:

    TRUE if given socket exists

--*/

{
   USHORT old_addr2;
   USHORT mode, pwr, sctrl;
   BOOLEAN retval = FALSE;
   BOOLEAN card_in = FALSE;
   int j, rdy, wait;
   USHORT save_pic;

   PAGED_CODE();

   //
   // Socket number OK?
   //

   if (iSocket > 1) {
      return FALSE;
   }

   //
   // save current socket, look at requested
   //

   old_addr2 = TcicReadBaseReg(pInst, R_ADDR2);
   TcicWriteBaseReg(pInst, R_ADDR2,
                    (USHORT)((old_addr2 & ~TCIC_SS_MASK) |
                             (iSocket << ADR2_SS_SHFT)));

   //
   // is there a card?
   //

   if (TcicReadBaseReg(pInst, R_SSTAT) & SSTAT_CD) {

      //
      // should set back address register before return.
      //

      TcicWriteBaseReg(pInst, R_ADDR2, old_addr2);
      return TRUE;

   } else {

      //
      // save mode, sctrl, and power for selected socket
      //

      mode = TcicReadBaseReg(pInst, (USHORT)R_MODE);
      pwr  = TcicReadBaseReg(pInst, (USHORT)R_PWR);
      sctrl = TcicReadBaseReg(pInst, (USHORT)R_SCTRL);

      //
      // check if power is already on- in case someone has
      // inadvertently turned on our power
      //

      if (pwr & 0x27) {
         TcicWriteBaseReg(pInst, R_PWR, (UCHAR)(pwr & ~0x27));
      }


      //
      // put chip into diagnostic mode, turn on VPP enables
      //

      TcicWriteAuxReg(pInst, MODE_AR_TEST,
                      (USHORT)(TEST_DIAG | TEST_VCTL));


      //
      // should see /CRDYBSY and /CWAIT low
      //

      if (!(TcicReadBaseReg(pInst, R_SSTAT) & SSTAT_RDY) &&
          (TcicReadAuxReg(pInst, MODE_AR_ILOCK) & ILOCK_CWAITSNS)) {

         //
         // 5V power on */
         //

         if (TcicIsPnP ((PDBSOCKET)pInst)) {
            TcicWriteBaseReg(pInst, R_PWR, (USHORT)(pwr | 0x27));
         } else {
            TcicWriteBaseReg(pInst, R_PWR,
                             (UCHAR)(pwr | (iSocket==0? 1 : 2)));
         }

         //
         // should see /CRDYBSY and /CWAIT high within about 1.5 sec
         //

         for (j = 0; j < 75; j++) {
            rdy = TcicReadBaseReg(pInst, R_SSTAT) & SSTAT_RDY;
            wait = TcicReadAuxReg(pInst, MODE_AR_ILOCK) & ILOCK_CWAITSNS;

            if (rdy && !wait) {
               retval = TRUE;
               break;
            }
            PcmciaWait(20000);
         }

         //
         // Now be sure /CRDYBSY and /CWAIT drain
         //
         // turn power off
         //

         TcicWriteBaseReg(pInst, R_PWR, 0);

         //
         // force card enable */
         //

         TcicWriteAuxReg(pInst, MODE_AR_TEST,
                         (USHORT)(TEST_DIAG | TEST_VCTL | TEST_ENA) );

         //
         // turn on a bunch of bits for drain path
         //

         TcicWriteBaseReg(pInst, R_MODE,
                          MODE_PGMWR | MODE_PGMRD |
                          MODE_PGMCE | MODE_PGMWORD );

         //
         // enable the socket
         //

         TcicWriteBaseReg(pInst, R_SCTRL, 1);

         //
         // expect CRDYBSY to drain
         //

         for (j = 0; j < 75; j++) {
            rdy = TcicReadBaseReg(pInst, R_SSTAT) & SSTAT_RDY;
            if (!rdy) {
               break;
            }
            PcmciaWait(20000);
         }

         //
         // Wait for noise to settle
         //

         for (j = 0; j < 50; j++) {
            PcmciaWait(20000);
         }
      }

      //
      // out of diag mode
      //

      TcicWriteAuxReg(pInst, MODE_AR_TEST, 0);

      //
      // clearn up IRQs inside TCIC
      //

      while (TcicReadBaseReg (pInst, R_ICSR)) {
         TcicWriteBaseReg (pInst, R_ICSR, ICSR_JAM);
      }

      //
      // restore original mode
      //

      TcicWriteBaseReg(pInst, R_MODE, mode);

      //
      // restore SCTRL
      //

      TcicWriteBaseReg(pInst, R_SCTRL, sctrl);

      //
      // set socket's power correctly
      //

      TcicWriteBaseReg(pInst, R_PWR, pwr);

      //
      // restore originally selected socket
      //

      TcicWriteBaseReg(pInst, R_ADDR2, old_addr2);

   }

   return retval;
}



USHORT
TcicCheckAliasing(
   IN PDBSOCKET pdbskt,
   IN USHORT offst
   )

/*++

Routine Description:

    For each of the 16 I/O locations in the TCIC, if any of
    the corresponding locations |offst| bytes higher are different,
    then aliasing is not occurring.  Exceptions, if the chip is
    active, may be found in R_DATA and R_SSTAT; accordingly, we
    avoid these registers in this check.
    If they all compare, then the R_MODE register is changed;
    if the corresponding change occurs in the image,
    then we have aliasing.

Arguments:

    pInst - pointer to an Instance data to work from.
    offst - offset to check for image of this TCIC at.

Return Value:

    TCIC_NONE:              no TCIC found
    TCIC_NOALIAS:   different TCIC found
    TCIC_ALIAS:             aliasing found

--*/

{
   int j;
   USHORT mode, flipmode;
   SOCKET  locskt;
   USHORT retval;
   PHYSICAL_ADDRESS cardAddress;
   PHYSICAL_ADDRESS portAddress;
   BOOLEAN mapped;
   ULONG   addressSpace;

   PAGED_CODE();
   //
   // Check for TCIC at image location, returning NONE if none found:
   //

   addressSpace = 1; // port space
   portAddress.LowPart = pdbskt->physPortAddr + offst;
   portAddress.HighPart = 0;

   if (!HalTranslateBusAddress(Isa, 0, portAddress, &addressSpace,&cardAddress)) {
      return retval = TCIC_NONE;
   }

   if (addressSpace) {
      mapped = FALSE;
      locskt.AddressPort = (PUCHAR)(cardAddress.QuadPart);

   } else {
      mapped = TRUE;
      locskt.AddressPort = MmMapIoSpace(cardAddress, 0x10, FALSE);
   }

   if (!TcicReservedBitsOK(&locskt)) {
      if (mapped) {
         MmUnmapIoSpace(locskt.AddressPort, 0x10);
      }

      return (retval = TCIC_NONE);
   }

   //
   // Check the R_xxx range for differences
   //

   for (j = R_ADDR; j < 16; ++j) {
      if (j != R_SSTAT) {
         if (READ_PORT_UCHAR(pdbskt->skt.AddressPort + j) != READ_PORT_UCHAR((locskt.AddressPort + j))) {
            if (mapped) {
               MmUnmapIoSpace(locskt.AddressPort, 0x10);
            }
            return (retval = TCIC_NOALIAS);
         }
      }
   }

   //
   // OK, flip the mode register and see if it changes in the
   // aliased range
   //

   mode = TcicReadBaseReg(&pdbskt->skt, R_MODE) ^ 0xe0;
   TcicWriteBaseReg(&pdbskt->skt, R_MODE, mode);
   flipmode = TcicReadBaseReg(&pdbskt->skt, (USHORT)R_MODE + offst);
   TcicWriteBaseReg(&pdbskt->skt, R_MODE, (USHORT)(mode ^ 0xe0));

   if (flipmode == mode) {
      retval = TCIC_ALIAS;
   } else {
      retval = TCIC_NOALIAS;
   }

   if (mapped) {
      MmUnmapIoSpace(locskt.AddressPort, 0x10);
   }

   return retval;
}



USHORT
TcicCheckAliasType (
   IN PDBSOCKET pInst
   )

/*++

Routine Description:

    This function is useful for distinguishing among Databook
    controller cards.  For instance, the TMI-140 will be found
    at its base address and again at the base address + 10h, while
    the TMB-270 has two controllers separated by 400h, with aliases
    at an offset of 800h.

    Use TcicCheckAliasing to determine:
            1) Do we have a 270 (two non-identical TCICs appear, 400h
                    apart)?
            2) Do we have an "new-style" controller, with an image of
                    itself 800h away from the base address?
    For more detail, see TcicCheckAliasing above.

Arguments:

    pInst - socket instance info.

Return Value:

    A value encoding the results found:
    TCIC_IS270 : indicates 270 found
    TCIC_ALIAS800 : indicates base+800h alias found
    TCIC_IS140 : indicates base+10h alias found
    TCIC_ALIAS400 : indicates base+400h alias found

--*/

{
   USHORT retval = 0;

   PAGED_CODE();
   switch (TcicCheckAliasing (pInst, TCIC_OFFSET_400)) {
   case TCIC_NOALIAS :
      /* (indicating TCIC found, but not aliased) */
      retval |= TCIC_IS270;
      break;

   case TCIC_ALIAS :
      /* (indicating this TCIC appears again there) */
      retval |= TCIC_ALIAS400;
      break;
   }

   if (TcicCheckAliasing (pInst, TCIC_OFFSET_800) == TCIC_ALIAS) {
      retval |= TCIC_ALIAS800;
   }

   if (TcicCheckAliasing (pInst, TCIC_ALIAS_OFFSET) == TCIC_ALIAS) {
      retval |= TCIC_IS140;
   }

   return retval;
}



BOOLEAN
TcicCheckXBufNeeded(
   IN PSOCKET pInst
   )

/*++

Routine Description:

    Two overlapping memory windows are set up, a 16 bit and
    an 8 bit.
    We make two accesses to the memory area: 1st one accesses
    the 16-bit window, 2nd accesses the 8-bit window. They
    MUST be done back-to-back so that MCS16# doesn't have time
    to settle between the two accesses.
    We then check the value from accessing win2. (We don't
    care about the value from Win1, we just use it to make
    sure that MSC16# was asserted.) It should either match
    the value in PDATA or match the low byte in PDATA (082
    mem window bug.) If it matches for all iterations of the
    test, then we assume that external buffers are not
    present.

Arguments:

    pInst - pointer to an Instance data to work from.

Return Value:

    TRUE if external buffering needs to be turned on.

--*/

{
   PUCHAR winPhysAddr;
   PUCHAR WinMappedAddr;
   BOOLEAN  ena_buffers = FALSE;
   PUSHORT pfoo1, pfoo2;
   USHORT foo1, foo2;
   int j;
   ULONG  mapped;

   PAGED_CODE();
   //
   // Alloc addr space for an 8K mem window
   //

   WinMappedAddr = TcicAllocateMemRange(pInst->DeviceExtension,
                                        &mapped,
                                        (PULONG)&winPhysAddr);

   //
   // If the alloc failed (WinLinear == NULL), there
   // really is no point in doing the test
   //

   if (WinMappedAddr != NULL) {

      //
      // Set R_ADDR to 0 to make sure that socket 0 is selected
      //

      TcicWriteBaseReg(pInst, R_ADDR, 0);
      TcicWriteBaseReg(pInst, R_ADDR2, 0);

      //
      // Turn on HA24-12 decoding
      //

      TcicWriteAuxReg(pInst, MODE_AR_SYSCFG, SYSCFG_MCSFULL);

      //
      // Setup a test value to drive into the mem windows
      //

      TcicWriteAuxReg(pInst, MODE_AR_PDATA,  0x5678);

      //
      // Set the window to USHORT regardless of CD states
      //

      TcicWriteAuxReg(pInst, MODE_AR_TEST, TEST_ENA | TEST_DRIVECDB);

      //
      // Make sure that PDATA is being driven to the windows
      //

      TcicWriteBaseReg(pInst, R_MODE,  MODE_PGMDBW | MODE_PGMWORD);

      //
      // Enable the socket, set INCMODE for convenience
      //

      TcicWriteBaseReg(pInst, R_SCTRL, SCTRL_ENA | SCTRL_INCMODE_AUTO);

      //
      // cook the TCIC's idea of the base addr
      //

      ((ULONG_PTR)winPhysAddr) >>= MBASE_HA_SHFT;

      //
      // setup the two windows
      //

      TcicSetMemWindow(pInst, 0, (ULONG_PTR)winPhysAddr, 1, (USHORT)MCTL_ENA);
      TcicSetMemWindow(pInst, 1, (ULONG_PTR)(winPhysAddr + 1), 1,
                       (USHORT)(MCTL_ENA | MCTL_B8));

      //
      // Now setup two pointers, one into each window.
      // We'll set pfoo2 to point to the 1st USHORT of Win2 and
      // pfoo1 to point to the last USHORT of Win1.
      //

      pfoo1 = pfoo2 = (PUSHORT)(WinMappedAddr + 0x1000);
      pfoo1--;

      //
      // Now the test
      //

      for (j = 0; j < 100; j++) {
         foo1 = READ_REGISTER_USHORT(pfoo1);
         foo2 = READ_REGISTER_USHORT(pfoo2);

         if (foo2 != 0x5678 && foo2 != 0x7878) {
            ena_buffers = TRUE;
            break;
         }
      }

      //
      // last, restore the TCIC to a sane condition
      //

      TcicSetMemWindow(pInst, 0, 0, 0, 0);
      TcicSetMemWindow(pInst, 1, 0, 0, 0);
      TcicWriteAuxReg(pInst, MODE_AR_SYSCFG, 0);
      TcicWriteAuxReg(pInst, MODE_AR_PDATA, 0);
      TcicWriteAuxReg(pInst, MODE_AR_TEST, 0);
      TcicWriteBaseReg(pInst, R_MODE,  0);
      TcicWriteBaseReg(pInst, R_SCTRL, 0);
   }

   if (WinMappedAddr != NULL && mapped) {
      MmUnmapIoSpace(WinMappedAddr, TCIC_WINDOW_SIZE);
   }

   return ena_buffers;
}



VOID
TcicSetMemWindow(
   IN PSOCKET pInst,
   IN USHORT wnum,
   IN ULONG_PTR base,
   IN USHORT npages,
   IN USHORT mctl
   )

/*++

Routine Description:

    Helper function for TcicCheckXBufNeeded()

Arguments:

    pInst - pointer to an Instance data to work from.
    wnum  - window number (0 - n memwindows)
    base  - base Host addr to map to
    npages- window size in 4k pages
    mctl  - window ctrl reg value

Return Value:

    None

--*/

{
   USHORT map;
   USHORT winvals[3];

   PAGED_CODE();
   winvals[1] = (USHORT)(((short)base * -1) & 0x3fff);
   winvals[0] = npages == 1 ? (USHORT)base | MBASE_4K :(USHORT)base;
   winvals[2] = mctl;

   TcicWriteIndirectRegs(pInst, (USHORT)IR_MBASE_W(wnum), 3, winvals);
}




VOID
TcicGetPossibleIRQs(
   IN PDBSOCKET pInst,
   IN UCHAR *ptbl
   )

/*++

Routine Description:

    The given array is filled in with the irqcaps data determined
    from the chip properties.
    If this is a Plug n Play chip, the IR_ADPTCFG register is
    used to provide additional data

Arguments:

    pInst - pointer to an Instance data to work from.
    ptbl  - pointer to list buffer to fill in.

Return Value:

    None

--*/

{
   int j;
   CHIPPROPS *pcp;
   UCHAR *pbtbl;

   PAGED_CODE();
   if ((pcp = TcicGetChipProperties(pInst)) == NULL) {
      return;
   }

   //
   // If we're using the 082 table, and we've got a divided clock,
   // assume that IRQ6 and IRQ9 are crossed. Likewise, if we've got
   // an 072 table and divided clock, assume that 9 and 14 are
   // crossed.
   //

   pbtbl = pcp->irqcaps;

   if (pInst->clkdiv != 0) {
      if (pbtbl == irqcaps_082) {
         pbtbl = irqcaps_082sw;
      } else {
         if (pbtbl == irqcaps_072) {
            pbtbl = irqcaps_072sw;
         }
      }
   }

   for (j = 0; j < 16 ; j++) {
      ptbl[j] = pbtbl[j];
   }


   /*
    * If this chip is a PNP chip, then we need to consult the
    * IR_ADPTCFG reg to see if additional IRQs are available
    */
   if (TcicIsPnP(pInst)) {
      USHORT adptcfg;
      long old_addr;

      old_addr = TcicReadAddrReg(&pInst->skt);
      TcicWriteAddrReg(&pInst->skt, ADDR_INDREG | IR_ADPTCFG0);

      adptcfg = TcicReadBaseReg(&pInst->skt, R_DATA);
      TcicWriteAddrReg(&pInst->skt, old_addr);

      if (adptcfg & IRADPCF0_IRQ6) {
         ptbl[6] = 6;
      }
      if (adptcfg & IRADPCF0_IRQ9) {
         ptbl[9] = 9;
      }
      if (adptcfg & IRADPCF0_IRQ12) {
         ptbl[12] = 12;
      }
      if (adptcfg & IRADPCF0_IRQ15) {
         ptbl[15] = 15;
      }
   }
}




CHIPPROPS *
TcicGetChipProperties(
   IN PDBSOCKET pInst
   )

/*++

Routine Description:

    Search the ChipProperties table for the matching entry

Arguments:

    pInst - pointer to an Instance data to work from.

Return Value:

    ptr to chip properties table entry.

--*/

{
   int j;

   for (j = 0; ChipProperties[j].chip_id != 0 ;j++) {
      if (ChipProperties[j].chip_id == pInst->chipType) {
         return &ChipProperties[j];
      }
   }
   return (CHIPPROPS *)NULL;
}



BOOLEAN
TcicChipIDKnown(
   IN PDBSOCKET pInst
   )

/*++

Routine Description:

    Determine if the chip id makes sense

Arguments:

    pInst - pointer to an Instance data to work from.

Return Value:

    TRUE if chip ID is sane.

--*/

{
   return (TcicGetChipProperties(pInst) != NULL);
}




USHORT
TcicGetnIOWins(
   IN PDBSOCKET pInst
   )

/*++

Routine Description:

    Get the I/O window count based on chip properties, or zero
    if the chip is unidentified

Arguments:

    pInst - pointer to an Instance data to work from.

Return Value:

    number of io windows present.

--*/

{
   CHIPPROPS *pcp = TcicGetChipProperties(pInst);

   PAGED_CODE();
   return (pcp ?pcp->niowins :0);
}



USHORT
TcicGetnMemWins(
   IN PDBSOCKET pInst
   )

/*++

Routine Description:

    Get the memory window count based on chip properties, or zero
    if the chip is unidentified

Arguments:

    pInst - pointer to an Instance data to work from.

Return Value:

    number of memory windows present.

--*/

{
   CHIPPROPS *pcp = TcicGetChipProperties(pInst);

   PAGED_CODE();
   return (pcp ?pcp->nmemwins :0);
}



USHORT
TcicGetFlags(
   IN PDBSOCKET pInst
   )

/*++

Routine Description:

    Get the properties flag bits for this model of TCIC

Arguments:

    pInst - pointer to an Instance data to work from.

Return Value:

    flag bits from chip properties table.

--*/

{
   CHIPPROPS *pcp = TcicGetChipProperties (pInst);
   PAGED_CODE();
   return (pcp ? pcp->fprops : fINVALID);
}




BOOLEAN
TcicIsPnP(
   IN PDBSOCKET pInst
   )
/*++

Routine Description:

    Determine if this chip is a Plug-n-Play chip

Arguments:

    pInst - pointer to an Instance data to work from.

Return Value:

    True if chip is PnP (084/184)

--*/

{
   CHIPPROPS *pcp = TcicGetChipProperties(pInst);

   return (pcp ?pcp->fprops & fIS_PNP :FALSE);
}



BOOLEAN
TcicHasSktIRQPin(
   IN PDBSOCKET pInst
   )

/*++

Routine Description:

    Determine if this chip has a SKT IRQ pin.

Arguments:

    pInst - pointer to an Instance data to work from.

Return Value:

    TRUE if chip has the SktIRQ pin.

--*/

{
   CHIPPROPS *pcp = TcicGetChipProperties(pInst);

   PAGED_CODE();
   return (pcp ?pcp->fprops & fSKTIRQPIN :FALSE);
}




USHORT
TcicGet5vVccVal(
   IN PDBSOCKET pInst
   )

/*++

Routine Description:

    Get the correct R_PWR bits to establish 5V.

Arguments:

    pInst - pointer to an Instance data to work from.

Return Value:

    5v Vcc R_PWR bits.

--*/

{
   USHORT j;
   USHORT pwr;
   CHIPPROPS *pcp = TcicGetChipProperties(pInst);

   PAGED_CODE();
   //
   // Get Table size
   //
   if (pcp == NULL) {
      return 0;
   }

   j = pcp->privpwrtbl[0];

   pwr = pcp->privpwrtbl[j + 1];

   //
   // If not from the 084 family, adjust power value for socket number.
   //

   if (!TcicIsPnP(pInst)) {
      pwr <<= pInst->skt.RegisterOffset;
   }
   return pwr;
}



VOID
TcicGetIRQMap(
   IN PDBSOCKET pInst
   )

/*++

Routine Description:

    Constructs an IRQ cross-mapping table for the controller in question.
    This code just does a copy from a static table.  It should be replaced
    with the Win95 heuristic code.

Arguments:

    pInst - pointer to an Instance data to work from.

Return Value:

    None

--*/

{
   int    i, j;
   UCHAR loc_tbl[16] = {0};

   PAGED_CODE();
   TcicGetPossibleIRQs(pInst, loc_tbl);

   for (j = 0; j < 16; j++) {
      pInst->IRQMapTbl[j] = loc_tbl[j];
   }

   //
   // Don't let IRQ 14 through.. This is also done for the PCIC
   //

   pInst->IRQMapTbl[14] = 0;
}



USHORT
TcicClockRate(
   PSOCKET pInst
   )

/*++

Routine Description:

    This routine determines if CCLK is running at 1:1 (14.318 Mhz) or divided
    by 2.

Arguments:

    pInst - pointer to an Instance data to work from.

Return Value:

    CCLK divisor as a shift count (0 or 1)

--*/

{
   int i;
   LARGE_INTEGER accum = RtlConvertLongToLargeInteger(0L);
   LARGE_INTEGER start, stop, pc, tmp, tmp2;
   USHORT mode;
   USHORT wctl;

   PAGED_CODE();
   //
   // The Ratio break point is the midpoint between 16K ticks at 14.31813 Mhz
   // (14,318130 / 16K = 873 | 1:1 CCLK) and 16K ticks at 7.159065 Mhz
   // (7,159,065 / 16K = 436 | 1:2 CCLK). We calculate the midpoint between
   // these two values: ((873 - 436) / 2) + 436 = 654  to give a comparison
   // value. If x < 654 we assume 1/2 CCLK, otherwise we assume 1/1 CCLK.
   //

#define CLKRATIO_BRKPOINT       654L

   mode = TcicReadBaseReg(pInst, R_MODE);

   //
   // set AR_PCTL to 0x4000
   //

   TcicWriteAuxReg(pInst, MODE_AR_PCTL, 0x4000);
   TcicWriteBaseReg(pInst, R_MODE, MODE_AR_WCTL);
   wctl = TcicReadBaseReg(pInst, R_AUX);

   //
   // Get the performance counter time base
   //

   KeQueryPerformanceCounter(&pc);

   for (i = 0; i < 10; i++) {

      //
      // start the TCIC timer */
      //

      TcicWriteBaseReg(pInst, R_AUX, (USHORT)(wctl & 0xff));
      start = KeQueryPerformanceCounter(NULL);

      //
      // wait for SSTAT_PROGTIME to go high */
      //

      while (!(TcicReadBaseReg(pInst, R_SSTAT) & SSTAT_PROGTIME))
         ;

      //
      // nab the timer count
      //

      stop = KeQueryPerformanceCounter(NULL);
      tmp = RtlLargeIntegerSubtract(stop, start);
      accum = RtlLargeIntegerAdd(accum, tmp);
   }

   //
   // Zero out the timer for power conservation
   //

   TcicWriteAuxReg(pInst, MODE_AR_PCTL, 0);

   //
   // replace Mode
   //

   TcicWriteBaseReg(pInst, R_MODE, mode);

   //
   // Get average elapsed time for 1 iter.
   //

   accum = RtlLargeIntegerDivide(accum, RtlConvertLongToLargeInteger(10L), &tmp2);

   //
   // Divide PC Freq by accum to base accum on some portion of 1 second
   //

   tmp = RtlLargeIntegerDivide(pc, accum, &tmp2);

   return (RtlLargeIntegerLessThan(tmp, RtlConvertLongToLargeInteger(CLKRATIO_BRKPOINT))
           ?(USHORT)2 : (USHORT)1);
}



VOID
TcicSetIoWin(
   IN PSOCKET socketPtr,
   IN USHORT  winIdx,
   IN ULONG   BasePort,
   IN ULONG   NumPorts,
   IN UCHAR   Attributes
   )

/*++

Routine Description:

    Setup a TCIC I/O window.

Arguments:

    socketPtr - ptr to socket instance data
    winIdx    - index of window to setup
    BasePort  - start base port address
    NumPorts  - size of range - 1
    Attributes- window attributes

Return Value:

    None

--*/

{
   PDBSOCKET       pdb = (PDBSOCKET)socketPtr;
   USHORT      tmp;
   USHORT          words[2];

   //
   // Simulate 365 by arbitrary attachment of IOW1:2 to SKT1 and IOW3:4 to SKT2
   //

   winIdx += (socketPtr->RegisterOffset * 2);

   //
   // NumPorts from CIS metaformat is really (NumPorts -1), normalize it now.
   //

   ++NumPorts;

   words[0] = (USHORT)(BasePort + (NumPorts >> 1));

   TcicReadIndirectRegs(socketPtr, IR_SCFG_S(socketPtr->RegisterOffset), 1, &tmp);
   tmp |= (USHORT)(IRSCFG_SPKR | IRSCFG_FINPACK);
   TcicWriteIndirectRegs(socketPtr, IR_SCFG_S(socketPtr->RegisterOffset), 1, &tmp);

   TcicReadIndirectRegs(socketPtr, IR_SCF2_S(socketPtr->RegisterOffset), 1, &tmp);
   tmp &= ~(IRSCF2_IDBR | IRSCF2_MDBR);

   if (Attributes & IO_DATA_PATH_WIDTH) {
      words[1] = ICTL_ENA;
      tmp     |= IRSCF2_IDBR;
   } else {
      words[1] = ICTL_B8 | ICTL_QUIET | ICTL_ENA;
   }
   TcicWriteIndirectRegs(socketPtr, IR_SCF2_S(socketPtr->RegisterOffset), 1, &tmp);

   if (NumPorts < 1024) {
      words[1] |= ICTL_1K;

      if (NumPorts == 1) {
         words[1] |= ICTL_TINY;
      }
   }
   words[1] |= socketPtr->RegisterOffset << ICTL_SS_SHFT;
   words[1] |= 3 + pdb->clkdiv;

   TcicWriteIndirectRegs(socketPtr, IR_IOBASE_W(winIdx), 2, words);
}




USHORT
TcicMapSpeedCode(
   IN PDBSOCKET pdb,
   IN UCHAR AccessSpeed
   )

/*++

Routine Description:

    Determine the correct wait state bits for this controller

Arguments:

    pdb - socket instance data
    AccessSpeed - callers desired speed (unused)

Return Value:

    TCIC wait state bits.

--*/

{

   UNREFERENCED_PARAMETER(AccessSpeed);

   if (pdb->clkdiv) {
      return (3);
   } else {
      return (7);
   }
}



VOID
TcicSetMemWin(
   IN PSOCKET socketPtr,
   IN USHORT  winIdx,
   IN ULONG   cardbase,
   IN ULONG   hostbase,
   IN ULONG   size,
   IN UCHAR   AttrMem,
   IN UCHAR   AccessSpeed,
   IN USHORT  Attributes
   )

/*++

Routine Description:

    Setup the specified TCIC memory window

Arguments:

    socketPtr - socket instance data
    winIdx    - index of window to setup
    cardbase  - PCCard base address
    hostbase  - host base address
    size      - window size
    AttrMem   - attribute or common space
    AccessSpeed     - wait states
    Attributes      - window attributes

Return Value:

    None

--*/

{
   PDBSOCKET       pdb = (PDBSOCKET)socketPtr;
   USHORT      tmp;
   USHORT          words[4];

   //
   // Simulate 365 by arbitrary attachment of MEM1:(x/2-1) to SKT1
   // and MEMx/2:x to SKT2
   //

   winIdx += (socketPtr->RegisterOffset * (pdb->nmemwins / 2));

   //
   // convert base, size, & map to 4K pages
   //

   cardbase >>= 12;
   size >>= 12;
   hostbase >>= 12;

   //
   // combine hostbase & size
   //

   words[0] = (USHORT)hostbase | (USHORT)(size / 2);

   //
   // Check if 4K bit is needed
   //

   if (size == 1) {
      words[0] |= MBASE_4K;
   }

   //
   // setup mapping of cardbase to host addr space
   //

   words[1] = (USHORT)(cardbase - (hostbase & 0xfff)) & 0x3fff;
   if (AttrMem) {
      words[1] |= MMAP_REG;
   }

   //
   // now cook the control bits
   //

   words[2] = MCTL_ENA | MCTL_QUIET;
   if (!(Attributes & MEM_DATA_PATH_WIDTH_16)) {
      words[2] |= MCTL_B8;
   }

   //
   // Now add in the socket selector
   //

   words[2] |= (socketPtr->RegisterOffset << MCTL_SS_SHFT);

   //
   // Last, add in the speed bits
   //

   words[2] |= TcicMapSpeedCode(pdb, AccessSpeed);

   //
   // HW BugFix1: First Rev of 082 needs to have SYSCFG_MCSFULL turned on
   // if we have any open windows. We're opening one so we better assert.
   //

   tmp = TcicReadAuxReg(socketPtr, MODE_AR_SYSCFG);
   tmp |= SYSCFG_MCSFULL;
   TcicWriteAuxReg(socketPtr, MODE_AR_SYSCFG, tmp);

   //
   // HW BugFix2: '2' Step of 082 needs the wait state count written into
   // window[~index] instead of index.
   //

   if (pdb->chipType != SILID_DB86082_1) {

      //
      // No bug case
      //

      TcicWriteIndirectRegs(socketPtr, IR_MBASE_W(winIdx), 3, words);

   } else {

      //
      // Bug case
      //

      words[3] = words[2] & MCTL_WSCNT_MASK;
      words[2] &= ~MCTL_WSCNT_MASK;
      TcicWriteIndirectRegs(socketPtr, IR_MBASE_W(winIdx), 3, words);
      TcicWriteIndirectRegs(socketPtr, IR_MBASE_W((~winIdx) & 7), 1, &words[3]);
   }
}



VOID
TcicAutoBusyOff(
   IN PDBSOCKET pdbs
   )

/*++

Routine Description:

    Turn off the busy LED, re-arm so that it comes on automatically with
    any card access.

Arguments:

    pdbs - socket instance data

Return Value:

    None

--*/

{
   USHORT syscfg;
   USHORT oldmode;

   //
   // Save R_MODE for later restore
   //

   oldmode = TcicReadBaseReg(&pdbs->skt, R_MODE);

   //
   // R/M/W SYSCFG to add in the autobusy bit.
   // This will turn LED off for now but allow it to come on automatically
   // with the next access to this socket.
   //

   syscfg = TcicReadAuxReg(&pdbs->skt, MODE_AR_SYSCFG);
   syscfg |= SYSCFG_AUTOBUSY;
   TcicWriteAuxReg(&pdbs->skt, MODE_AR_SYSCFG, syscfg);

   //
   // Restore Mode
   //

   TcicWriteBaseReg(&pdbs->skt, R_MODE, oldmode);
}



UCHAR
TcicAutoBusyCheck(
   IN PDBSOCKET pdbs
   )

/*++

Routine Description:

    Check SYSCFG access bit to see if PCCard has been accessed since last
    call.  If so, force LED to stay on and clear access bit.

Arguments:

    pdbs - socket instance data

Return Value:

    access bit as a right-justified UCHAR

--*/

{
   USHORT syscfg;
   USHORT oldmode;
   UCHAR activity = 0;

   //
   // Save R_MODE for later restore
   //

   oldmode = TcicReadBaseReg(&pdbs->skt, R_MODE);

   //
   // Read AR_SYSCFG to check for recent activity
   //

   syscfg = TcicReadAuxReg(&pdbs->skt, MODE_AR_SYSCFG);
   if (syscfg & SYSCFG_ACC) {

      //
      // the socket has been accessed since last check
      // clear the access bit and disable AUTOBUSY to force LED to
      // follow socket SCTRL_ENA.
      //

      syscfg &= ~(SYSCFG_ACC | SYSCFG_AUTOBUSY);
      TcicWriteAuxReg(&pdbs->skt, MODE_AR_SYSCFG, syscfg);
      ++activity;
   }

   //
   // Restore Mode
   //

   TcicWriteBaseReg(&pdbs->skt, R_MODE, oldmode);

   return activity;
}




VOID
TcicCheckSktLED(
   IN PDBSOCKET pdbs
   )

/*++

Routine Description:

    Drive the low-level functions to check for PCcard access and control
    the busy LED on this socket/controller.

Arguments:

    pdbs - socket instance data

Return Value:

    None

--*/

{
   UCHAR lastbusy = pdbs->busyLed;

   pdbs->busyLed = TcicAutoBusyCheck(pdbs);

   if (lastbusy & !(pdbs->busyLed)) {
      TcicAutoBusyOff(pdbs);
   }
}




VOID
TcicBusyLedRoutine(
   IN PDEVICE_OBJECT DeviceObject,
   IN PVOID Context
   )

/*++

Routine Description:

    Main timer routine to drive Busy LED monitor

Arguments:

    DeviceObject - instance data for driver
    Context - unused parameter

Return Value:

    None

--*/

{
   PFDO_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
   PDBSOCKET pdbs;

   UNREFERENCED_PARAMETER(Context);

   pdbs = (PDBSOCKET)(deviceExtension->SocketList);

   while (pdbs) {

      //
      // If this device is from the 084 family, LED control is per/socket
      //

      if (TcicIsPnP(pdbs)) {
         ULONG   oldaddr = TcicReadAddrReg(&pdbs->skt);

         // Do the first socket
         //

         TcicSocketSelect(&pdbs->skt, pdbs->skt.RegisterOffset);
         TcicCheckSktLED(pdbs);
         TcicWriteAddrReg(&pdbs->skt, oldaddr);
         pdbs = (PDBSOCKET)(pdbs->skt.NextSocket);

         // If a second socket is present, do it too.
         //

         if (pdbs && pdbs->skt.RegisterOffset == 1) {
            oldaddr = TcicReadAddrReg(&pdbs->skt);
            TcicSocketSelect(&pdbs->skt, pdbs->skt.RegisterOffset);
            TcicCheckSktLED(pdbs);
            TcicWriteAddrReg(&pdbs->skt, oldaddr);
            pdbs = (PDBSOCKET)(pdbs->skt.NextSocket);
         }

      } else {

         //
         // Otherwise, LED control is per adapter so do the check and skip
         // over the second socket if present.
         //

         TcicCheckSktLED(pdbs);
         pdbs = (PDBSOCKET)(pdbs->skt.NextSocket);
         if (pdbs && pdbs->skt.RegisterOffset == 1) {
            pdbs = (PDBSOCKET)(pdbs->skt.NextSocket);
         }
      }
   }
}



VOID
TcicDecodeMemWin(
   USHORT  mbase,
   USHORT  mmap,
   USHORT  mctl,
   ULONG  *Host,
   ULONG  *Card,
   ULONG  *Size,
   UCHAR  *Attr
   )

/*++

Routine Description:

    Convert TCIC mem window register values to something understandable

Arguments:

    mbase - TCIC MBASE register value
    mmap  - TCIC MMAP register value
    mctl  - TCIC MCTL register value
    Host  - where to put Host address
    Card  - where to put PCCard address
    Size  - where to put window size
    Attr  - where to put attribute space flag

Return Value:

    None

--*/

{
   USHORT shft;
   USHORT tmp;

   //
   // take care of mapping to common or attr space first.
   // Strip ATTR bit if set
   //

   *Attr = 0;
   if (mmap & MMAP_REG) {
      *Attr = 1;
      mmap &= ~MMAP_REG;
   }

   //
   // Now concentrate on getting the host addr and window size
   //

   if (mbase & MBASE_4K) {
      *Size = 1;
      *Host = (ULONG)(mbase & ~MBASE_4K);
   } else {
      for (*Size = 2, shft = 0, tmp = mbase; !(tmp & 1) ; shft++ ) {
         tmp >>= 1;
         *Size <<= 1;
      }
      *Host = (ULONG)(mbase - (1 << shft));
   }

   //
   // Now for the fun part. We're left with mmap being a 14-bit signed
   // number. We need to normalize it so we can work with it.
   //
   // Check for negative (bit 13 set)
   //

   if (mmap & (1 << 13)) {
      mmap |= 0xc000;
      *Card = (ULONG)((short)mmap + (short)*Host);
   } else {
      *Card = (ULONG)(mmap) + *Host;
   }
   (*Size)--;
   *Host <<= MBASE_HA_SHFT;
   *Size <<= MBASE_HA_SHFT;
   *Card <<= MMAP_CA_SHFT;
}



VOID
TcicDecodeIoWin(
   USHORT  iobase,
   USHORT  ioctl,
   USHORT  *NumPorts,
   USHORT  *BasePort
   )

/*++

Routine Description:

    Convert TCIC I/O window register values to something understandable

Arguments:

    iobase -  TCIC IOBASE register contents
    ioctl  -  TCIC IOCTL register contents
    NumPorts - where to put window size (size - 1)
    BasePort - where to put base address

Return Value:

    None

--*/

{
   if (ioctl & ICTL_TINY) {
      *BasePort = iobase;
      *NumPorts = 1;
   } else {
      USHORT shft;
      USHORT tmp;

      for (*NumPorts = 2, shft = 0, tmp = iobase; !(tmp & 1) ; shft++ ) {
         tmp >>= 1;
         *NumPorts <<= 1;
      }

      *BasePort = (iobase - (1 << shft));
   }
   *NumPorts -= 1;
}



VOID
TcicRegistryLookupScanLimits(
   PULONG Start,
   PULONG End
   )

/*++

Routine Description:

    Open the registry key in the services entry for pcmcia and see if there
    are some values set for TCIC searching.  If not, use the defaults.

Arguments:

    Start - the I/O location for start of search.
    End   - the I/O location to end the search (i.e. nothing greater than).

Return Values:

    None - parameters are modified.

--*/

{
#define ITEMS_TO_QUERY 4
   ULONG                     defaultStart = TCIC_LOW_ADDR_LIMIT;
   ULONG                     defaultEnd   = TCIC_HIGH_ADDR_LIMIT;
   PRTL_QUERY_REGISTRY_TABLE params;
   NTSTATUS                  status;
   PWSTR                     keyName;

   PAGED_CODE();
   //
   // Set up return codes in case there are errors in setting up processing.
   //

   *Start = defaultStart;
   *End = defaultEnd;

   //
   // Allocate memory for operation.
   //

   params = ExAllocatePool(NonPagedPool,
                           sizeof(RTL_QUERY_REGISTRY_TABLE)*ITEMS_TO_QUERY);

   if (!params) {
      return;
   }

   //
   // Set up registry path.  This should not be hard coded, but is for now.
   //

   keyName = L"\\registry\\machine\\system\\currentcontrolset\\services\\pcmcia";

   //
   // Set up query structure.
   //

   RtlZeroMemory(params, sizeof(RTL_QUERY_REGISTRY_TABLE)*ITEMS_TO_QUERY);
   params[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
   params[0].Name          = L"TCICStartSearch";
   params[0].EntryContext  = Start;
   params[0].DefaultType   = REG_DWORD;
   params[0].DefaultData   = &defaultStart;
   params[0].DefaultLength = sizeof(ULONG);

   params[1].Flags         = RTL_QUERY_REGISTRY_DIRECT;
   params[1].Name          = L"TCICStopSearch";
   params[1].EntryContext  = End;
   params[1].DefaultType   = REG_DWORD;
   params[1].DefaultData   = &defaultEnd;
   params[1].DefaultLength = sizeof(ULONG);

   //
   // Perform the registry search
   //

   status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                                   keyName,
                                   params,
                                   NULL,
                                   NULL);

   //
   // Insure that start is less than end - if not, go back to default
   // values
   //

   if (*Start > *End) {
      *Start = defaultStart;
      *End = defaultEnd;
   }

   //
   // Free resources.
   //

   ExFreePool(params);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\pcmcibus\ti.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    ti.c

Abstract:

    This module contains the code that contains
    Texas Instruments cardbus controller specific
    initialization and other dispatches

Author:

    Ravisankar Pudipeddi (ravisp) 1-Nov-97
    Neil Sandlin (neilsa) 1-Jun-1999


Environment:

    Kernel mode

Revision History :


--*/

#include "pch.h"



VOID
TIInitialize(
   IN PFDO_EXTENSION FdoExtension
   )
/*++

Routine Description:

    Initialize TI cardbus controllers

Arguments:

    FdoExtension - Pointer to the device extension for the controller FDO

Return Value:

    None
--*/

{
   UCHAR                byte;
   USHORT               word;
   BOOLEAN              TiOldRev = FALSE;
   PSOCKET              socket = FdoExtension->SocketList;

   if (FdoExtension->ControllerType == PcmciaTI1130) {
      UCHAR revisionID;
   
      GetPciConfigSpace(FdoExtension, CFGSPACE_REV_ID, &revisionID, 1);
      if (revisionID < 4) {
         TiOldRev = TRUE;
      }
   }      

   GetPciConfigSpace(FdoExtension, CFGSPACE_CACHE_LINESIZE, &byte, 1);
   if (byte == 0) {
      byte = 8;
      SetPciConfigSpace(FdoExtension, CFGSPACE_CACHE_LINESIZE, &byte, 1);
   }

   byte = RETRY_CBRETRY_TIMEOUT_ENABLE|RETRY_PCIRETRY_TIMEOUT_ENABLE;
   SetPciConfigSpace(FdoExtension, CFGSPACE_TI_RETRY_STATUS, &byte, 1);

   GetPciConfigSpace(FdoExtension, CFGSPACE_TI_CARD_CTRL, &byte, 1);

   byte &= ~(CARDCTRL_CSCINT_ENABLE | CARDCTRL_FUNCINT_ENABLE |
             CARDCTRL_PCIINT_ENABLE);
   byte |= CARDCTRL_CSCINT_ENABLE | CARDCTRL_PCIINT_ENABLE;

   if (!TiOldRev) {
      byte |= CARDCTRL_FUNCINT_ENABLE;
   }

   SetPciConfigSpace(FdoExtension, CFGSPACE_TI_CARD_CTRL, &byte, 1);

   byte=PcicReadSocket(socket, PCIC_INTERRUPT);
   PcicWriteSocket(socket, PCIC_INTERRUPT , (UCHAR) (byte | IGC_INTR_ENABLE));


   GetPciConfigSpace(FdoExtension, CFGSPACE_TI_DEV_CTRL, &byte, 1);
   if ((byte & DEVCTRL_INTMODE_MASK) == DEVCTRL_INTMODE_DISABLED) {
      DebugPrint((PCMCIA_DEBUG_INFO, "TIInitialize: ISA interrupt mode is not enabled, assume simple ISA mode"));

      byte |= DEVCTRL_INTMODE_ISA;
      SetPciConfigSpace(FdoExtension, CFGSPACE_TI_DEV_CTRL, &byte, 1);
   } else if ((byte & DEVCTRL_INTMODE_MASK)==DEVCTRL_INTMODE_SERIAL) {
      //
      // We use serial interrupts
      //
   }

   if (((FdoExtension->ControllerType == PcmciaTI1130) || (FdoExtension->ControllerType == PcmciaTI1131)) &&
       ((byte & DEVCTRL_INTMODE_MASK) == DEVCTRL_INTMODE_ISA)) {

      FdoExtension->LegacyIrqMask = 0xCEA0; // 5, 7, 9, 10, 11, 14, 15
      
   }

   if ((byte & DEVCTRL_INTMODE_MASK) == DEVCTRL_INTMODE_COMPAQ) {
       FdoExtension->Flags |= PCMCIA_INTMODE_COMPAQ;
   } else {
       FdoExtension->Flags &= ~PCMCIA_INTMODE_COMPAQ;
   }

   //NOTE: This only initializes the page register on the 113x
   PcicWriteSocket(socket, PCIC_PAGE_REG, 0);

   //
   // NOTE: this is not done on win9x, I doubt we even need it. It
   // was previously being done because it was in the PcicRegisterInitTable.
   // But it was a bug to have it in that table, since this register is
   // adapter specific. Now I'm putting it here only for paranoia since
   // it has been in the driver for a long time. 
   //
   // The comment in data.c was:
   // // Set GLOBAL_CONTROL for auto-clearing of status bit
   //
   PcicWriteSocket(socket, PCIC_TI_GLOBAL_CONTROL, 0);

   //
   // Workaround for CCLK instability problem 
   //

   if ((FdoExtension->ControllerType == PcmciaTI1220) ||
       (FdoExtension->ControllerType == PcmciaTI1250) ||
       (FdoExtension->ControllerType == PcmciaTI1251B)) {
       
      CBWriteSocketRegister(socket, CBREG_TI_SKT_POWER_MANAGEMENT,
                                    (CBREG_TI_CLKCTRLLEN | CBREG_TI_CLKCTRL));       
                                          
   }

   //
   // initialize IRQ routing to ISA
   //

   GetPciConfigSpace(FdoExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
   word |= BCTRL_IRQROUTING_ENABLE;
   SetPciConfigSpace(FdoExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
}


BOOLEAN
TISetZV(
   IN PSOCKET Socket,
   IN BOOLEAN Enable
   )
{
   UCHAR TiCardCtl;
   PFDO_EXTENSION FdoExtension = Socket->DeviceExtension;
   
   if (Enable) {
   
      GetPciConfigSpace(FdoExtension, CFGSPACE_TI_CARD_CTRL, &TiCardCtl, 1);
      TiCardCtl |= CARDCTRL_ZV_ENABLE;
      TiCardCtl &= ~CARDCTRL_SPKR_ENABLE;
      SetPciConfigSpace(FdoExtension, CFGSPACE_TI_CARD_CTRL, &TiCardCtl, 1);
      
   } else {

      //
      // check for devices that have the problem of leaking current when zv is
      // disabled
      //
      if ((FdoExtension->ControllerType == PcmciaTI1450) ||
          (FdoExtension->ControllerType == PcmciaTI1251B)) {
         return TRUE;
      }

      GetPciConfigSpace(FdoExtension, CFGSPACE_TI_CARD_CTRL, &TiCardCtl, 1);
      TiCardCtl &= ~CARDCTRL_ZV_ENABLE;
      TiCardCtl |= CARDCTRL_SPKR_ENABLE;
      SetPciConfigSpace(FdoExtension, CFGSPACE_TI_CARD_CTRL, &TiCardCtl, 1);
      
   }
   
   return TRUE;
}


BOOLEAN
TISetWindowPage(IN PSOCKET Socket,
                USHORT Index,
                UCHAR Page)
{
   PFDO_EXTENSION FdoExtension = Socket->DeviceExtension;
   ASSERT(Index <= 4);


   if (FdoExtension->ControllerType == PcmciaTI1031) {
      return FALSE;
   }
   
   if (FdoExtension->ControllerType != PcmciaTI1130) {
      return CBSetWindowPage(Socket, Index, Page);
   }
   

   if ((PcicReadSocket(Socket, PCIC_ADD_WIN_ENA) & WE_MEMWIN_MASK) == 0)
      PcicWriteSocket(Socket, PCIC_TI_MEMWIN_PAGE, Page);
   else if ((Page != 0) && (PcicReadSocket(Socket, PCIC_TI_MEMWIN_PAGE) != Page)) {
      DebugPrint((PCMCIA_DEBUG_FAIL,
                 "PCMCIA: TISetWindowPage setting a 2nd memory window in a different 16M page (Page=%x)",
                 Page));
      return FALSE;                 
   }
   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\pcmcibus\topic.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    topic.c

Abstract:

    This module contains the code that contains
    Toshiba topic cardbus controller specific initialization
    and other dispatches

Author:

    Ravisankar Pudipeddi (ravisp) 1-Nov-97
    Neil Sandlin (neilsa) 1-Jun-1999


Environment:

    Kernel mode

Revision History :

    Neil Sandlin (neilsa) 3-Mar-99
      new setpower routine interface

--*/

#include "pch.h"



VOID
TopicInitialize(
   IN PFDO_EXTENSION FdoExtension
   )
/*++

Routine Description:

    Initialize Toshiba Topic cardbus controllers

Arguments:

    FdoExtension - Pointer to the device extension for the controller FDO

Return Value:

    None
--*/
{
    UCHAR byte;
    USHORT word;

   if (FdoExtension->ControllerType == PcmciaTopic95) {
      //
      // 480CDT in a dock needs this for socket registers to be visible.
      // It should be on all the time anyway.
      //
      GetPciConfigSpace(FdoExtension, CFGSPACE_TO_CD_CTRL, &byte, 1);
      byte |= CDCTRL_PCCARD_16_32;
      SetPciConfigSpace(FdoExtension, CFGSPACE_TO_CD_CTRL, &byte, 1);
   }      
      
    //enable 3.3V capable

    byte = PcicReadSocket(FdoExtension->SocketList, PCIC_TO_FUNC_CTRL) | TO_FCTRL_CARDPWR_ENABLE;
    PcicWriteSocket(FdoExtension->SocketList,
                    PCIC_TO_FUNC_CTRL,
                    byte);

   //
   // initialize IRQ routing to ISA
   //

   GetPciConfigSpace(FdoExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
   word |= BCTRL_IRQROUTING_ENABLE;
   SetPciConfigSpace(FdoExtension, CFGSPACE_BRIDGE_CTRL, &word, 2);
}



NTSTATUS
TopicSetPower(
   IN PSOCKET Socket,
   IN BOOLEAN Enable,
   OUT PULONG pDelayTime
   )
   
/*++

Routine Description:

    Set power to the specified socket.

Arguments:

    Socket - the socket to set
    Enable - TRUE means to set power - FALSE is to turn it off.
    pDelayTime - specifies delay (msec) to occur after the current phase

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED - increment phase, perform delay, recall
    other status values terminate sequence

--*/

{
   NTSTATUS status;
   UCHAR             oldPower, newPower;

   if (IsCardBusCardInSocket(Socket)) {
      //
      // Hand over to generic power setting routine
      //
      return(CBSetPower(Socket, Enable, pDelayTime));
   }
   
   switch(Socket->PowerPhase) {
   case 1:
      //
      // R2 card - special handling
      //
      oldPower = PcicReadSocket(Socket, PCIC_PWR_RST);
      
      //
      // Set power values
      //
      if (Enable) {
         //
         // turn power on
         //         
         newPower = PC_CARDPWR_ENABLE;
      
         if (Socket->Vcc == 33) {
            newPower |= PC_VCC_TOPIC_033V;
         }            
         
         //        
         // set Vpp
         //
         if (Socket->Vcc == Socket->Vpp1) {
            newPower |= PC_VPP_SETTO_VCC;
         } else if (Socket->Vpp1 == 120) {
            newPower |= PC_VPP_SETTO_VPP;
         }            
      
      } else {
         //
         // turn power off
         //
         newPower = 0;
      }         
      
      //
      // Don't nuke the non-power related bits in the register..
      //
      newPower |= (oldPower & PC_PWRON_BITS);
      //
      // If Vcc is turned off, reset OUTPUT_ENABLE & AUTOPWR_ENABLE
      //
      if (!(newPower & PC_CARDPWR_ENABLE)) {
         newPower &= ~PC_PWRON_BITS;
      }
      //
      // Disable ResetDrv
      //
      newPower |= PC_RESETDRV_DISABLE;

      status = STATUS_SUCCESS;
      if (newPower != oldPower) {
         PcicWriteSocket(Socket, PCIC_PWR_RST, newPower);
         //
         // Allow ramp up.. (actually we don't need to this if
         // Enable was FALSE).  Keep it for paranoia's sake
         //
         *pDelayTime = PcicStallPower;
         Socket->PowerData = (ULONG) newPower;
         status = STATUS_MORE_PROCESSING_REQUIRED;
      }
      break;
      
   case 2:         
   
      newPower = (UCHAR) Socket->PowerData;

      if ((newPower & PC_CARDPWR_ENABLE) &&
          ((newPower & PC_PWRON_BITS) != PC_PWRON_BITS)) {
         //
         // More paranoia?
         //
         newPower |= PC_PWRON_BITS;
         PcicWriteSocket(Socket, PCIC_PWR_RST, newPower);
      }

      status = STATUS_SUCCESS;
      *pDelayTime = PcicStallPower;
      break;
      
   default:
      ASSERT(FALSE);         
      status = STATUS_UNSUCCESSFUL;
   }
   return status;
}



VOID
TopicSetAudio(
   IN PSOCKET Socket,
   IN BOOLEAN Enable
   )
{
   PFDO_EXTENSION FdoExtension = Socket->DeviceExtension;
   ULONG data;
   ULONG orig_data;
   BOOLEAN setBit;
   
   
   setBit = (IsCardBusCardInSocket(Socket) ^ Enable);

   GetPciConfigSpace(FdoExtension, CFGSPACE_TO_CBREG_CTRL, &data, sizeof(data));   
   orig_data = data;

   if (setBit) {
      data |= CSRCR_TO_CAUDIO_OFF;
   } else {
      data &= ~CSRCR_TO_CAUDIO_OFF;
   }      

   if (orig_data != data) {   
      SetPciConfigSpace(FdoExtension, CFGSPACE_TO_CBREG_CTRL, &data, sizeof(data));   
   }      

}



BOOLEAN
TopicSetZV(
   IN PSOCKET Socket,
   IN BOOLEAN Enable
   )
{
   UCHAR bData;

   if (Enable) {

      PcicWriteSocket(Socket, PCIC_TO_MMI_CTRL, TO_MMI_VIDEO_CTRL | TO_MMI_AUDIO_CTRL);
      bData = PcicReadSocket(Socket, PCIC_TO_ADDITIONAL_GENCTRL);
      bData |= TO_GCTRL_CARDREMOVAL_RESET;
      PcicWriteSocket(Socket, PCIC_TO_ADDITIONAL_GENCTRL, bData);

   } else {

      PcicWriteSocket(Socket, PCIC_TO_MMI_CTRL, 0);
      bData = PcicReadSocket(Socket, PCIC_TO_ADDITIONAL_GENCTRL);
      bData &= ~TO_GCTRL_CARDREMOVAL_RESET;
      PcicWriteSocket(Socket, PCIC_TO_ADDITIONAL_GENCTRL, bData);

   }
   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\busdrv\pccard\pcmcibus\tuples.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    tuples.c

Abstract:

    This module contains the code that parses and processes
    the configuration tuples of the PC Cards in the PCMCIA sockets

Author:

    Bob Rinne (BobRi) 3-Aug-1994
    Jeff McLeman 12-Apr-1994
    Ravisankar Pudipeddi (ravisp) 1-Nov-1996
    Neil Sandlin (neilsa) 1-Jun-1999

Revision History:

    Lotsa cleaning up. Support for PnP.
    orthogonalized tuple processing.
    Support links etc.

     - Ravisankar Pudipeddi (ravisp) 1-Dec-1996


Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"

#define  MAX_MISSED_TUPLES     256    // how many bad tuples will we tolerate?
#define  MAX_TUPLE_DATA_LENGTH 128    // Enough for the longest tuple


BOOLEAN
CheckLinkTarget(
   IN PTUPLE_PACKET TuplePacket
   );

UCHAR
ConvertVoltage(
   UCHAR MantissaExponentByte,
   UCHAR ExtensionByte
   );

VOID
PcmciaProcessPower(
   IN PTUPLE_PACKET TuplePacket,
   UCHAR        FeatureByte
   );

VOID
PcmciaProcessIoSpace(
   IN PTUPLE_PACKET TuplePacket,
   PCONFIG_ENTRY ConfigEntry
   );

VOID
PcmciaProcessIrq(
   IN PTUPLE_PACKET TuplePacket,
   PCONFIG_ENTRY ConfigEntry
   );

VOID
PcmciaProcessTiming(
   IN PTUPLE_PACKET TuplePacket,
   IN PCONFIG_ENTRY ConfigEntry
   );

VOID
PcmciaProcessMemSpace(
   IN PTUPLE_PACKET TuplePacket,
   IN PCONFIG_ENTRY ConfigEntry,
   IN UCHAR         MemSpace
   );

VOID
PcmciaMiscFeatures(
   IN PTUPLE_PACKET TuplePacket
   );

PCONFIG_ENTRY
PcmciaProcessConfigTable(
   IN PTUPLE_PACKET TuplePacket
   );

VOID
ProcessConfig(
   IN PTUPLE_PACKET TuplePacket
   );

VOID
ProcessConfigCB(
   IN PTUPLE_PACKET TuplePacket
   );

NTSTATUS
InitializeTuplePacket(
   IN PTUPLE_PACKET TuplePacket
   );

NTSTATUS
GetFirstTuple(
   IN PTUPLE_PACKET TuplePacket
   );

BOOLEAN
TupleMatches(
   IN PTUPLE_PACKET TuplePacket
   );

NTSTATUS
GetNextTuple(
   IN PTUPLE_PACKET TuplePacket
   );

NTSTATUS
NextTupleInChain(
   IN PTUPLE_PACKET TuplePacket
   );

NTSTATUS
GetAnyTuple(
   IN PTUPLE_PACKET TuplePacket
   );

NTSTATUS
FollowLink(
   IN PTUPLE_PACKET TuplePacket
   );

NTSTATUS
NextLink(
   IN PTUPLE_PACKET TuplePacket
   );

NTSTATUS
GetTupleData(
   IN PTUPLE_PACKET TuplePacket
   );

UCHAR
GetTupleChar(
   IN PTUPLE_PACKET TuplePacket
   );

NTSTATUS
ProcessLinkTuple(
   IN PTUPLE_PACKET TuplePacket
   );

BOOLEAN
PcmciaQuickVerifyTupleChain(
   IN PUCHAR Buffer,
   IN ULONG Length
   );

NTSTATUS
PcmciaMemoryCardHack(
   IN PSOCKET Socket,
   PSOCKET_DATA SocketData
   );

VOID
PcmciaCheckForRecognizedDevice(
   IN PSOCKET Socket,
   IN OUT PSOCKET_DATA SocketData
   );


//
// Some useful macros
//
// VOID
// PcmciaCopyIrqConfig(
//                    IN CONFIG_ENTRY DestConfig,
//                    IN CONFIG_ENTRY SourceConfig
//                    )
// Routine Description:
//      Copies the IRQ information from SourceConfig to DestConfig
//
// Arguments:
//
//     DestConfig - a pointer to the destination configuration entry
//     SourceConfig - a pointer to the source configuration entry
//
// Return Values:
//     None
//

#define PcmciaCopyIrqConfig(DestConfig, SourceConfig)                         \
                        {                                                     \
                           DestConfig->IrqMask = SourceConfig->IrqMask;       \
                           DestConfig->LevelIrq = SourceConfig->LevelIrq;     \
                           DestConfig->ShareDisposition =                     \
                                             SourceConfig->ShareDisposition;  \
                        }

//
// VOID
// PcmciaCopyIoConfig(
//                    IN CONFIG_ENTRY DestConfig,
//                    IN CONFIG_ENTRY SourceConfig
//                    )
// Routine Description:
//      Copies the Io space information from SourceConfig to DestConfig
//
// Arguments:
//
//     DestConfig - a pointer to the destination configuration entry
//     SourceConfig - a pointer to the source configuration entry
//
// Return Values:
//     None
//

#define PcmciaCopyIoConfig(DestConfig, SourceConfig)                               \
                        {                                                          \
                           DestConfig->NumberOfIoPortRanges =                      \
                                  SourceConfig->NumberOfIoPortRanges;              \
                           DestConfig->Io16BitAccess =                             \
                                  SourceConfig->Io16BitAccess;                     \
                           DestConfig->Io8BitAccess =                              \
                                  SourceConfig->Io8BitAccess;                      \
                           RtlCopyMemory(DestConfig->IoPortBase,                   \
                                         SourceConfig->IoPortBase,                 \
                                         sizeof(SourceConfig->IoPortBase[0])*      \
                                         SourceConfig->NumberOfIoPortRanges);      \
                           RtlCopyMemory(DestConfig->IoPortLength,                 \
                                         SourceConfig->IoPortLength,               \
                                         sizeof(SourceConfig->IoPortLength[0])*    \
                                         SourceConfig->NumberOfIoPortRanges);      \
                           RtlCopyMemory(DestConfig->IoPortAlignment,              \
                                         SourceConfig->IoPortAlignment,            \
                                         sizeof(SourceConfig->IoPortAlignment[0])* \
                                         SourceConfig->NumberOfIoPortRanges);      \
                        }

//
// VOID
// PcmciaCopyMemConfig(
//                    IN CONFIG_ENTRY DestConfig,
//                    IN CONFIG_ENTRY SourceConfig
//                    )
// Routine Description:
//      Copies the Memory space information from SourceConfig to DestConfig
//
// Arguments:
//
//     DestConfig - a pointer to the destination configuration entry
//     SourceConfig - a pointer to the source configuration entry
//
// Return Values:
//     None
//

#define PcmciaCopyMemConfig(DestConfig,SourceConfig)                              \
                        {                                                         \
                           DestConfig->NumberOfMemoryRanges =                     \
                                  SourceConfig->NumberOfMemoryRanges;             \
                           RtlCopyMemory(DestConfig->MemoryHostBase,              \
                                         SourceConfig->MemoryHostBase,            \
                                         sizeof(SourceConfig->MemoryHostBase[0])* \
                                         SourceConfig->NumberOfMemoryRanges);     \
                           RtlCopyMemory(DestConfig->MemoryCardBase,              \
                                         SourceConfig->MemoryCardBase,            \
                                         sizeof(SourceConfig->MemoryCardBase[0])* \
                                         SourceConfig->NumberOfMemoryRanges);     \
                           RtlCopyMemory(DestConfig->MemoryLength,                \
                                         SourceConfig->MemoryLength,              \
                                         sizeof(SourceConfig->MemoryLength[0])*   \
                                         SourceConfig->NumberOfMemoryRanges);     \
                        }




USHORT VoltageConversionTable[16] = {
   10, 12, 13, 15, 20, 25, 30, 35,
   40, 45, 50, 55, 60, 70, 80, 90
};

UCHAR TplList[] = {
   CISTPL_DEVICE,
   CISTPL_VERS_1,
   CISTPL_CONFIG,
   CISTPL_CFTABLE_ENTRY,
   CISTPL_MANFID,
   CISTPL_END
};

static unsigned short crc16a[] = {
   0000000,  0140301,  0140601,  0000500,
   0141401,  0001700,  0001200,  0141101,
   0143001,  0003300,  0003600,  0143501,
   0002400,  0142701,  0142201,  0002100,
};
static unsigned short crc16b[] = {
   0000000,  0146001,  0154001,  0012000,
   0170001,  0036000,  0024000,  0162001,
   0120001,  0066000,  0074000,  0132001,
   0050000,  0116001,  0104001,  0043000,
};




UCHAR
GetCISChar(
   IN PTUPLE_PACKET TuplePacket,
   IN ULONG Offset
   )
/*++

Routine Description:

  Returns the contents of the CIS memory of the PC-Card
  in the given socket, at the specified offset

Arguments:

   TuplePacket    - Pointer to the initialized tuple packet
   Offset         - Offset at which the CIS memory contents need to be read
                    This offset is added to the current offset position
                    of the CIS being read as indicated through the TuplePacket
                    to obtain the actual offset

Return Value:

   The byte at the specified offset of the CIS


--*/

{
   PPDO_EXTENSION pdoExtension = TuplePacket->SocketData->PdoExtension;
   MEMORY_SPACE MemorySpace;

   if (Is16BitCardInSocket(pdoExtension->Socket)) {
      if (TuplePacket->Flags & TPLF_COMMON) {

         MemorySpace = (TuplePacket->Flags & TPLF_INDIRECT) ?
                           PCCARD_COMMON_MEMORY_INDIRECT :
                           PCCARD_COMMON_MEMORY;

      } else {

         MemorySpace = (TuplePacket->Flags & TPLF_INDIRECT) ?
                           PCCARD_ATTRIBUTE_MEMORY_INDIRECT :
                           PCCARD_ATTRIBUTE_MEMORY;

      }
   } else {
      switch((TuplePacket->Flags & TPLF_ASI) >> TPLF_ASI_SHIFT) {
      case 0:
         MemorySpace = PCCARD_PCI_CONFIGURATION_SPACE;
         break;
      case 1:
         MemorySpace = PCCARD_CARDBUS_BAR0;
         break;
      case 2:
         MemorySpace = PCCARD_CARDBUS_BAR1;
         break;
      case 3:
         MemorySpace = PCCARD_CARDBUS_BAR2;
         break;
      case 4:
         MemorySpace = PCCARD_CARDBUS_BAR3;
         break;
      case 5:
         MemorySpace = PCCARD_CARDBUS_BAR4;
         break;
      case 6:
         MemorySpace = PCCARD_CARDBUS_BAR5;
         break;
      case 7:
         MemorySpace = PCCARD_CARDBUS_ROM;
         break;
      }
   }

   return PcmciaReadCISChar(pdoExtension, MemorySpace, TuplePacket->CISOffset + Offset);
}



UCHAR
ConvertVoltage(
   UCHAR MantissaExponentByte,
   UCHAR ExtensionByte
   )

/*++

Routine Description:

    Convert the voltage requirements for the PCCARD based on the
    mantissa and extension byte.

Arguments:

    MantissaExponentByte
    ExtensionByte

Return Value:

    The voltage specified in tenths of a volt.

--*/

{
   SHORT power;
   USHORT value;

   value = (USHORT) VoltageConversionTable[(MantissaExponentByte >> 3) & 0x0f];
   power = 1;

   if ((MantissaExponentByte & EXTENSION_BYTE_FOLLOWS) &&
       (((value / 10) * 10) == value) &&
       (ExtensionByte < 100)) {
      value = (10 * value + (ExtensionByte & 0x7f));
      power += 1;
   }

   power = (MantissaExponentByte & 0x07) - 4 - power;

   while (power > 0) {
      value *= 10;
      power--;
   }

   while (power < 0) {
      value /= 10;
      power++;
   }

   return (UCHAR) value;
}


VOID
PcmciaProcessPower(
   IN PTUPLE_PACKET TuplePacket,
   UCHAR        FeatureByte
   )

/*++

Routine Description:

    Process power information from CIS.

Arguments:

    TuplePacket - Pointer the caller supplied, initialized tuple packet
    FeatureByte - the feature byte from the tuple containing power information.

Return Value:

    none

--*/

{
   PSOCKET_DATA SocketData = TuplePacket->SocketData;
   UCHAR  powerSelect;
   UCHAR  bit;
   UCHAR  item;
   UCHAR  rawItem;
   UCHAR  extensionByte;
   UCHAR  index = 0;
   UCHAR  count = FeatureByte;
   UCHAR  skipByte;

   ASSERT(count <= 3);

   while (index < count) {
      powerSelect = GetTupleChar(TuplePacket);
      for (bit = 0; bit < 7; bit++) {
         if (powerSelect & (1 << bit)) {

            rawItem = GetTupleChar(TuplePacket);
            if (rawItem & EXTENSION_BYTE_FOLLOWS) {
               extensionByte = GetTupleChar(TuplePacket);

               //
               // Skip the rest
               //
               skipByte = extensionByte;
               while (skipByte & EXTENSION_BYTE_FOLLOWS) {
                  skipByte = GetTupleChar(TuplePacket);
               }
            } else {
               extensionByte = (UCHAR) 0;
            }

            if (bit == 0) {

               //
               // Convert nominal power for output.
               //

               item = ConvertVoltage(rawItem, extensionByte);
               switch (index) {
               case 0:
                  SocketData->Vcc = item;
                  break;
               case 1:
                  SocketData->Vpp2 = SocketData->Vpp1 = item;
                  break;
               case 2:
                  SocketData->Vpp2 = item;
                  break;
               }
            }
         }
      }
      index++;
   }
}


VOID
PcmciaProcessIoSpace(
   IN PTUPLE_PACKET TuplePacket,
   PCONFIG_ENTRY ConfigEntry
   )

/*++

Routine Description:

    Process I/O space information from CIS.

Arguments:

    TuplePacket - Pointer the caller supplied, initialized tuple packet
    ConfigEntry - a config entry structure in which to store the information.

Return Value:

    none

--*/

{
   ULONG  address = 0;
   ULONG  index=0, i;
   UCHAR  item = GetTupleChar(TuplePacket);
   UCHAR  ioAddrLines = (item & IO_ADDRESS_LINES_MASK);
   UCHAR  ranges=0;
   UCHAR  addressSize=0;
   UCHAR  lengthSize=0;

   ConfigEntry->Io16BitAccess = Is16BitAccess(item);
   ConfigEntry->Io8BitAccess  = Is8BitAccess(item);

   ranges = HasRanges(item);

   if ((!ranges) && (!ioAddrLines)) {

      //
      // The IBM token ring card has a slightly different interpretation
      // of the tuple data here.  It isn't clear it is incorrect.
      //

      ranges = 0xFF;
   }

   if (ranges) {
      //
      // Specific ranges listed in the tuple.
      //
      if (ranges == 0xFF) {
         //
         // Special processing for IBM token ring IoSpace layout.
         //

         addressSize = 2;
         lengthSize = 1;
         ranges = 1;
      } else {
         item = GetTupleChar(TuplePacket);
         ranges = item & RANGE_MASK;
         ranges++;

         addressSize = GetAddressSize(item);
         lengthSize  = GetLengthSize(item);
      }
      index = 0;
      while (ranges) {
         address = 0;
         if (addressSize >= 1) {
            address = (ULONG) GetTupleChar(TuplePacket);
         }
         if (addressSize >= 2) {
            address |= (GetTupleChar(TuplePacket)) << 8;
         }
         if (addressSize >= 3) {
            address |= (GetTupleChar(TuplePacket)) << 16;
            address |= (GetTupleChar(TuplePacket)) << 24;
         }
         ConfigEntry->IoPortBase[index] = (USHORT) address;

         address = 0;
         if (lengthSize >= 1) {
            address = (ULONG) GetTupleChar(TuplePacket);
         }
         if (lengthSize >= 2) {
            address |= (GetTupleChar(TuplePacket)) << 8;
         }
         if (lengthSize >= 3) {
            address |= (GetTupleChar(TuplePacket)) << 16;
            address |= (GetTupleChar(TuplePacket)) << 24;
         }
         ConfigEntry->IoPortLength[index] = (USHORT) address;
         ConfigEntry->IoPortAlignment[index] = 1;

         index++;

         if (index == MAX_NUMBER_OF_IO_RANGES) {
            break;
         }
         ranges--;
      }
      ConfigEntry->NumberOfIoPortRanges = (USHORT) index;
   }

   //
   // Handle all combinations as specified in table on p. 80
   // (Basic compatibility Layer 1, i/o space encoding guidelines) of
   // PC Card standard Metaformat Specification, March 1997 (PCMCIA/JEIDA)
   //

   if (ioAddrLines) {
      //
      // A modulo base specified
      //
      if (addressSize == 0) {

         //
         // No I/O Base address specified
         //
         if (lengthSize == 0) {
            //
            // No ranges specified. This is a pure modulo base case
            //
            ConfigEntry->NumberOfIoPortRanges = 1;
            ConfigEntry->IoPortBase[0] = 0;
            ConfigEntry->IoPortLength[0] = (1 << ioAddrLines)-1;
            ConfigEntry->IoPortAlignment[0] = (1 << ioAddrLines);
         } else {
            //
            // Length specified. Modulo base is used only to specify alignment.
            //
            for (i=0; i < ConfigEntry->NumberOfIoPortRanges; i++) {
               ConfigEntry->IoPortBase[i] = 0;
               ConfigEntry->IoPortAlignment[i] = (1 << ioAddrLines);
            }
         }
      } else {
         //
         // Alignment specified..
         // This fix is for Xircom CE3 card
         //
         for (i=0; i < ConfigEntry->NumberOfIoPortRanges; i++) {
            if (ConfigEntry->IoPortBase[i] != 0) {
               //
               // Fixed base address supplied....
               // Don't specify alignment!
               //
               continue;
            }
            ConfigEntry->IoPortAlignment[i] = (1 << ioAddrLines);
         }
      }
   } else {
      //
      // No Modulo Base. So specific ranges should've been specified
      //
      if (lengthSize == 0) {
         //
         //   Error! Length HAS to be specified
         //
         DebugPrint((PCMCIA_DEBUG_FAIL, "PcmciaProcessIoSpace: Length not specified in TPCE_IO descriptor for PC Card\n"));
      } else if (addressSize == 0) {
         for (i = 0; i < ConfigEntry->NumberOfIoPortRanges; i++) {
            ConfigEntry->IoPortBase[i]  = 0x0;
            ConfigEntry->IoPortAlignment[i] = 2;
         }
      } else {
         //
         // Proper ranges specified
         // Don't change anything
      }
   }
}


VOID
PcmciaProcessIrq(
   IN PTUPLE_PACKET TuplePacket,
   PCONFIG_ENTRY ConfigEntry
   )

/*++

Routine Description:

    Process IRQ from CIS.

Arguments:

    TuplePacket - Pointer the caller supplied, initialized tuple packet
    ConfigEntry - a place to store the IRQ.

Return Value:

    none

--*/

{
   USHORT mask;
   UCHAR  level = GetTupleChar(TuplePacket);

   if (!level) {

      //
      // NOTE: It looks like Future Domain messed up on this
      // and puts an extra zero byte into the structure.
      // skip it for now.
      //

      level = GetTupleChar(TuplePacket);
   }

   if (level & 0x20) {
      ConfigEntry->LevelIrq = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
   } else {
      ConfigEntry->LevelIrq = CM_RESOURCE_INTERRUPT_LATCHED;
   }

   if (level & 0x80) {
      ConfigEntry->ShareDisposition = CmResourceShareShared;
   } else {
      ConfigEntry->ShareDisposition = CmResourceShareDeviceExclusive;
   }

   mask = level & 0x10;

   //
   // 3COM 3C589-75D5 has a peculiar problem
   // where mask bit is 0, but should have been 1.
   // Handle this case here
   //

   if ((mask==0) && ((level & 0xf) == 0)) {
      mask = 1;
   }

   if (mask) {
      //
      // Each bit set in the mask indicates the corresponding IRQ
      // (from 0-15) may be assigned to this card's interrupt req. pin
      //
      mask = (USHORT) GetTupleChar(TuplePacket);
      mask |= ((USHORT) GetTupleChar(TuplePacket)) << 8;
      ConfigEntry->IrqMask = mask;
   } else {
      ConfigEntry->IrqMask = 1 << (level & 0x0f);
   }
}


VOID
PcmciaProcessTiming(
   IN PTUPLE_PACKET TuplePacket,
   IN PCONFIG_ENTRY ConfigEntry
   )

/*++

Routine Description:

    Move the data pointer around the timing information structure.
    No processing of this data occurs at this time.

Arguments:

    TuplePacket - Pointer the caller supplied, initialized tuple packet
    ConfigEntry - currently unused.

Return Value:

    none

--*/

{
   UCHAR  item = GetTupleChar(TuplePacket);
   UCHAR  reservedScale = (item & 0xe0) >> 5;
   UCHAR  readyBusyScale = (item & 0x1c) >> 2;
   UCHAR  waitScale = (item & 0x03);

   //
   // NOTE: It looks like the processing of extension bytes is not
   // coded correctly in this routine.
   //

   if (waitScale != 3) {
      item = GetTupleChar(TuplePacket);
      while (item & EXTENSION_BYTE_FOLLOWS) {
         item = GetTupleChar(TuplePacket);
      }
   }

   if (readyBusyScale != 7) {
      item = GetTupleChar(TuplePacket);
      while (item & EXTENSION_BYTE_FOLLOWS) {
         item = GetTupleChar(TuplePacket);
      }
   }

   if (reservedScale != 7) {
      item = GetTupleChar(TuplePacket);
      while (item & EXTENSION_BYTE_FOLLOWS) {
         item = GetTupleChar(TuplePacket);
      }
   }
}


VOID
PcmciaProcessMemSpace(
   IN PTUPLE_PACKET TuplePacket,
   IN PCONFIG_ENTRY ConfigEntry,
   IN UCHAR         MemSpace
   )

/*++

Routine Description:

    Process memory space requirements from CIS.

Arguments:

    TuplePacket - Pointer the caller supplied, initialized tuple packet
    ConfigEntry - the socket configuration structure.
    MemSpace    - the memory space enumerator from the config table entry
                  structure.

Return Value:

    none

--*/

{
   ULONG  longValue;
   ULONG  index;
   UCHAR  lengthSize;
   UCHAR  addrSize;
   UCHAR  number;
   UCHAR  hasHostAddress;

   switch (MemSpace) {

   case 1: {
         //
         // Only length is specified
         //
         longValue = (ULONG) GetTupleChar(TuplePacket);
         longValue |= ((ULONG) GetTupleChar(TuplePacket)) << 8;
         ConfigEntry->MemoryLength[0] = longValue * 256;

         ConfigEntry->NumberOfMemoryRanges++;
         break;
      }

   case 2: {

         longValue = (ULONG) GetTupleChar(TuplePacket);
         longValue |= ((ULONG) GetTupleChar(TuplePacket)) << 8;
         ConfigEntry->MemoryLength[0] = longValue * 256;

         longValue = (ULONG) GetTupleChar(TuplePacket);
         longValue |= ((ULONG) GetTupleChar(TuplePacket)) << 8;
         ConfigEntry->MemoryCardBase[0] =
         ConfigEntry->MemoryHostBase[0] = longValue * 256;

         ConfigEntry->NumberOfMemoryRanges++;
         break;
      }

   case 3: {
         UCHAR  item  = GetTupleChar(TuplePacket);
         lengthSize = (item & 0x18) >> 3;
         addrSize   = (item & 0x60) >> 5;
         number     = (item & 0x07) + 1;
         hasHostAddress = item & 0x80;

         if (number > MAX_NUMBER_OF_MEMORY_RANGES) {
            number = MAX_NUMBER_OF_MEMORY_RANGES;
         }

         for (index = 0; index < (ULONG) number; index++) {
            longValue = 0;
            if (lengthSize >= 1) {
               longValue = (ULONG) GetTupleChar(TuplePacket);
            }
            if (lengthSize >= 2) {
               longValue |= (GetTupleChar(TuplePacket)) << 8;
            }
            if (lengthSize == 3) {
               longValue |= (GetTupleChar(TuplePacket)) << 16;
            }
            ConfigEntry->MemoryLength[index] = longValue * 256;

            longValue = 0;
            if (addrSize >= 1) {
               longValue = (ULONG) GetTupleChar(TuplePacket);
            }
            if (addrSize >= 2) {
               longValue |= (GetTupleChar(TuplePacket)) << 8;
            }
            if (addrSize == 3) {
               longValue |= (GetTupleChar(TuplePacket)) << 16;
            }
            ConfigEntry->MemoryCardBase[index] = longValue * 256;

            if (hasHostAddress) {
               longValue = 0;
               if (addrSize >= 1) {
                  longValue = (ULONG) GetTupleChar(TuplePacket);
               }
               if (addrSize >= 2) {
                  longValue |= (GetTupleChar(TuplePacket)) << 8;
               }
               if (addrSize == 3) {
                  longValue |= (GetTupleChar(TuplePacket)) << 16;
               }
               ConfigEntry->MemoryHostBase[index] = longValue * 256;
            }
         }
         ConfigEntry->NumberOfMemoryRanges = (USHORT) number;
         break;
      }
   }
}


PCONFIG_ENTRY
PcmciaProcessConfigTable(
   IN PTUPLE_PACKET TuplePacket
   )

/*++

Routine Description:

Arguments:

    TuplePacket - Pointer the caller supplied, initialized tuple packet

Return Value:

    A pointer to a config entry structure if one is created.

--*/

{
   PSOCKET_DATA SocketData = TuplePacket->SocketData;
   PCONFIG_ENTRY configEntry;
   UCHAR         item;
   UCHAR         defaultBit;
   UCHAR         memSpace;
   UCHAR         power;
   UCHAR         misc;

   configEntry = ExAllocatePool(NonPagedPool, sizeof(CONFIG_ENTRY));
   if (!configEntry) {
      return NULL;
   }
   RtlZeroMemory(configEntry, sizeof(CONFIG_ENTRY));

   item = GetTupleChar(TuplePacket);
   defaultBit = Default(item);
   configEntry->IndexForThisConfiguration = ConfigEntryNumber(item);

   if (IntFace(item)) {

      //
      // This byte indicates type of interface in tuple (i.e. io or memory)
      // This could be processed, but for now is just skipped.
      //

      item = GetTupleChar(TuplePacket);
   }

   item = GetTupleChar(TuplePacket);
   memSpace = MemSpaceInformation(item);
   power    = PowerInformation(item);
   misc     = MiscInformation(item);

   if (power) {
      PcmciaProcessPower(TuplePacket, power);
   }

   if (TimingInformation(item)) {
      PcmciaProcessTiming(TuplePacket, configEntry);
   }

   if (IoSpaceInformation(item)) {
      PcmciaProcessIoSpace(TuplePacket, configEntry);
   } else if (!defaultBit && (SocketData->DefaultConfiguration != NULL)) {
      PcmciaCopyIoConfig(configEntry, SocketData->DefaultConfiguration);
   }

   if (IRQInformation(item)) {
      PcmciaProcessIrq(TuplePacket, configEntry);
   } else if (!defaultBit && (SocketData->DefaultConfiguration != NULL)) {
      PcmciaCopyIrqConfig(configEntry,SocketData->DefaultConfiguration);
   }

   if (memSpace) {
      PcmciaProcessMemSpace(TuplePacket, configEntry, memSpace);
   } else if (!defaultBit && (SocketData->DefaultConfiguration != NULL)) {
      PcmciaCopyMemConfig(configEntry,SocketData->DefaultConfiguration);
   }

   if (misc) {
      PcmciaMiscFeatures(TuplePacket);
   } // need default bit processing here too

   if (defaultBit) {
      //
      // Save this config as the default config for this pc-card (which
      // may be accessed by subsequent tuples)
      //
      SocketData->DefaultConfiguration = configEntry;
   }
   //
   // One more configuration
   //
   SocketData->NumberOfConfigEntries++;

   DebugPrint((PCMCIA_DEBUG_TUPLES,
                           "config entry %08x idx %x ccr %x\n",
                           configEntry,
                           configEntry->IndexForThisConfiguration,
                           SocketData->ConfigRegisterBase
                           ));
   return configEntry;
}

VOID
PcmciaMiscFeatures(
   IN PTUPLE_PACKET TuplePacket
   )

/*++

Routine Description:

    Parse the miscellaneous features field and look for audio supported
    bit.

Arguments:

    TuplePacket - Pointer the caller supplied, initialized tuple packet

Return Value:

    none

--*/

{
   PSOCKET_DATA SocketData = TuplePacket->SocketData;
   UCHAR item = GetTupleChar(TuplePacket);

   DebugPrint((PCMCIA_DEBUG_TUPLES,
               "TPCE_MS (%lx) is present in  CISTPL_CFTABLE_ENTRY \n",
               item));

   //
   // If the audio bit is set, remember this in the socket information
   // structure.
   //

   if (item & 0x8) {

      DebugPrint((PCMCIA_DEBUG_TUPLES,
                  "Audio bit set in TPCE_MS \n"));
      SocketData->Audio = TRUE;
   }

   //
   //  Step around the miscellaneous features and its extension bytes.
   //

   while (item & EXTENSION_BYTE_FOLLOWS) {
      item = GetTupleChar(TuplePacket);
   }
}



VOID
ProcessConfig(
   IN PTUPLE_PACKET TuplePacket
   )

/*++

Routine Description:

    Parse the CISTPL_CONFIG to extract the last index value and the
    configuration register base for the PCCARD.

Arguments:

    TuplePacket - Pointer the caller supplied, initialized tuple packet

Return Value:

    None

--*/

{
   PSOCKET_DATA SocketData = TuplePacket->SocketData;
   PUCHAR TupleData = TuplePacket->TupleData;
   ULONG  base = 0;
   UCHAR  widthOfBaseAddress;
   UCHAR  widthOfRegPresentMask;
   UCHAR  widthOfReservedArea;
   UCHAR  widthOfInterfaceId;
   UCHAR  index;
   UCHAR  subtupleCount = 0;
   ULONG  InterfaceId;

   widthOfBaseAddress = TpccRasz(TupleData[0]) + 1;
   widthOfRegPresentMask = TpccRmsz(TupleData[0]) + 1;
   widthOfReservedArea = TpccRfsz(TupleData[0]);

   ASSERT (widthOfReservedArea == 0);
   ASSERT (widthOfRegPresentMask <= 16);

   SocketData->LastEntryInCardConfig = TupleData[1];

   switch (widthOfBaseAddress) {
   case 4:
      base  = ((ULONG)TupleData[5] << 24);
   case 3:
      base |= ((ULONG)TupleData[4] << 16);
   case 2:
      base |= ((ULONG)TupleData[3] << 8);
   case 1:
      base |= TupleData[2];
      break;
   default:
      DebugPrint((PCMCIA_DEBUG_FAIL,
                  "ProcessConfig - bad number of bytes %d\n",
                  widthOfBaseAddress));
      break;
   }
   SocketData->ConfigRegisterBase = base;
   DebugPrint((PCMCIA_DEBUG_TUPLES,
               "ConfigRegisterBase in attribute memory is 0x%x\n",
               SocketData->ConfigRegisterBase));

   //
   // Copy the register presence mask
   //

   for (index = 0; index < widthOfRegPresentMask; index++) {
      SocketData->RegistersPresentMask[index] = TupleData[2 + widthOfBaseAddress + index];
   }   

   DebugPrint((PCMCIA_DEBUG_TUPLES,
               "First Byte in RegPresentMask=%x, width is %d\n",
               SocketData->RegistersPresentMask[0], widthOfRegPresentMask));

   //
   // Look for subtuples
   //
   index = 2 + widthOfBaseAddress + widthOfRegPresentMask + widthOfReservedArea;

   while (((index+5) < TuplePacket->TupleDataMaxLength) &&
          (++subtupleCount <= 4) &&
          (TupleData[index] == CCST_CIF)) {

      widthOfInterfaceId = ((TupleData[index+2] & 0xC0) >> 6) + 1 ;

      InterfaceId = 0;

      switch (widthOfInterfaceId) {
      case 4:
         InterfaceId  = ((ULONG)TupleData[index+5] << 24);
      case 3:
         InterfaceId |= ((ULONG)TupleData[index+4] << 16);
      case 2:
         InterfaceId |= ((ULONG)TupleData[index+3] << 8);
      case 1:
         InterfaceId |= TupleData[index+2];
         break;
      default:
         DebugPrint((PCMCIA_DEBUG_FAIL,
                     "ProcessConfig - bad number of bytes %d in subtuple\n",
                     widthOfInterfaceId));
         break;
      }

      DebugPrint((PCMCIA_DEBUG_TUPLES, "Custom Interface ID %8x\n", InterfaceId));
      //
      // Currently don't have generic code for recording sub-tuple information,
      // all we look for is Zoom Video.
      //
      if (InterfaceId == 0x141) {
         SocketData->Flags |= SDF_ZV;
      }

      index += (TupleData[index+1] + 2);
   }
}


VOID
ProcessConfigCB(
   IN PTUPLE_PACKET TuplePacket
   )

/*++

Routine Description:

    Parse the CISTPL_CONFIG_CB to extract the last index value and the
    configuration register base for the PCCARD.

Arguments:

    TuplePacket - Pointer the caller supplied, initialized tuple packet

Return Value:

    None

--*/

{
   PSOCKET_DATA SocketData = TuplePacket->SocketData;
   PUCHAR TupleData = TuplePacket->TupleData;
   ULONG base = 0;
   UCHAR widthOfFields;

   widthOfFields = TupleData[0];

   if (widthOfFields != 3) {
      DebugPrint((PCMCIA_DEBUG_FAIL, "ProcessConfigCB - bad width of fields %d\n", widthOfFields));
      return;
   }

   SocketData->LastEntryInCardConfig = TupleData[1];

   base  = ((ULONG)TupleData[5] << 24);
   base |= ((ULONG)TupleData[4] << 16);
   base |= ((ULONG)TupleData[3] << 8);
   base |= TupleData[2];

   SocketData->ConfigRegisterBase = base;
   DebugPrint((PCMCIA_DEBUG_TUPLES, "ConfigRegisterBase = %08x\n", SocketData->ConfigRegisterBase));

}



VOID
PcmciaSubstituteUnderscore(
   IN OUT PUCHAR Str
   )
/*++
Routine description

    Substitutes underscores ('_' character) for invalid device id
    characters such as spaces & commas in the supplied string

Parameters

    Str - The string for which the substitution is to take place in situ

Return Value

    None

--*/

{
   if (Str == NULL) {
      return;
   }
   while (*Str) {
      if (*Str == ' ' ||
          *Str == ',' ) {
         *Str = '_';
      }
      Str++;
   }
}



/*-------------- Tuple API starts here ----------------------------------------*/

NTSTATUS
InitializeTuplePacket(
   IN PTUPLE_PACKET TuplePacket
   )

/*++

Routine Description:

      Initializes the supplied tuple packet

Arguments:

   TuplePacket - Pointer the caller supplied tuple packet

Return Value:

   Status

--*/
{
   TuplePacket->Flags = TPLF_IMPLIED_LINK;
   TuplePacket->LinkOffset = 0;
   TuplePacket->CISOffset   = 0;
   if (IsCardBusCardInSocket(TuplePacket->Socket)) {
      PPDO_EXTENSION pdoExtension = TuplePacket->SocketData->PdoExtension;

      GetPciConfigSpace(pdoExtension, CBCFG_CISPTR, &TuplePacket->CISOffset, sizeof(TuplePacket->CISOffset));
      DebugPrint((PCMCIA_DEBUG_TUPLES, "CardBus CISPTR = %08x\n", TuplePacket->CISOffset));

      TuplePacket->Flags = TPLF_COMMON | TPLF_IMPLIED_LINK;
      TuplePacket->Flags |= (TuplePacket->CISOffset & 7) << TPLF_ASI_SHIFT;
      TuplePacket->CISOffset &= 0x0ffffff8;
      TuplePacket->LinkOffset = TuplePacket->CISOffset;
   }
   return STATUS_SUCCESS;
}


NTSTATUS
GetFirstTuple(
   IN PTUPLE_PACKET TuplePacket
   )
/*++

Routine Description:

      Retrieves the very first tuple off the pc-card

Arguments:

   TuplePacket - Pointer the caller supplied, initialized tuple packet

Return Value:

   STATUS_SUCCESS if tuple was retrieved
   STATUS_NO_MORE_ENTRIES - if no tuples were found
                            this is possible if this is a flash memory card

--*/
{

   NTSTATUS status;

   status=InitializeTuplePacket(TuplePacket);
   if (!NT_SUCCESS(status)) {
      return status;
   }

   TuplePacket->TupleCode = GetCISChar(TuplePacket, 0);
   TuplePacket->TupleLink = GetCISChar(TuplePacket, 1);

   if (TuplePacket->TupleCode == CISTPL_LINKTARGET) {
      if ((status=FollowLink(TuplePacket)) == STATUS_NO_MORE_ENTRIES) {
         return status;
      }
   } else if (IsCardBusCardInSocket(TuplePacket->Socket)) {
      //
      // First tuple on Cardbus cards must be link target
      //
      return STATUS_NO_MORE_ENTRIES;
   }
   if (!NT_SUCCESS(status) || TupleMatches(TuplePacket)) {
      return status;
   }
   return GetNextTuple(TuplePacket);
}

BOOLEAN
TupleMatches(
   PTUPLE_PACKET TuplePacket
   )

/*++

Routine Description:

      Checks if the retrieved tuple matches  what
      the caller requested

Arguments:

   TuplePacket - Pointer the caller supplied, initialized tuple packet

Return Value:

   TRUE  - if the tuple matches
   FALSE - if not

--*/

{
   if (TuplePacket->TupleCode == TuplePacket->DesiredTuple) {
      return TRUE;
   }

   if (TuplePacket->DesiredTuple != 0xFF) {
      return FALSE;
   }

   //
   // Requested any tuple , but might not want link tuples
   //
   if (TuplePacket->Attributes & TPLA_RET_LINKS) {
      return TRUE;
   }
   return ((TuplePacket->TupleCode != CISTPL_LONGLINK_CB)       &&
           (TuplePacket->TupleCode != CISTPL_INDIRECT)          &&
           (TuplePacket->TupleCode != CISTPL_LONGLINK_MFC)      &&
           (TuplePacket->TupleCode != CISTPL_LONGLINK_A)        &&
           (TuplePacket->TupleCode != CISTPL_LONGLINK_C)        &&
           (TuplePacket->TupleCode != CISTPL_NO_LINK)  &&
           (TuplePacket->TupleCode != CISTPL_LINKTARGET));
}

NTSTATUS
GetNextTuple(
   IN PTUPLE_PACKET TuplePacket
   )
/*++

Routine Description:

      Retrieves the next unprocessed tuple that matches
      the caller requested tuple code off the pc-card

Arguments:

   TuplePacket - Pointer the caller supplied, initialized tuple packet

Return Value:

   STATUS_SUCCESS if tuple was retrieved
   STATUS_NO_MORE_ENTRIES - if no more tuples were found

--*/
{

   ULONG missCount;
   NTSTATUS status;

   for (missCount = 0; missCount < MAX_MISSED_TUPLES; missCount++) {
      if (((status = GetAnyTuple(TuplePacket)) != STATUS_SUCCESS) ||
          TupleMatches(TuplePacket)) {
         break;
      }
      status = STATUS_NO_MORE_ENTRIES;
   }
   return status;
}


NTSTATUS
NextTupleInChain(
   IN PTUPLE_PACKET TuplePacket
   )
/*++

Routine Description:

   Retrieves the immediately next unprocessed tuple on the pc-card

Arguments:

   TuplePacket - Pointer the caller supplied, initialized tuple packet

Return Value:

   status

--*/
{
   NTSTATUS status;
   ULONG    i;
   UCHAR link;

   status = STATUS_SUCCESS;
   switch (GetCISChar(TuplePacket, 0)) {
   case CISTPL_END:{
         status = STATUS_NO_MORE_ENTRIES;
         break;
      }
   case CISTPL_NULL: {
         for (i = 0; i < MAX_MISSED_TUPLES; i++) {
            TuplePacket->CISOffset++;
            if (GetCISChar(TuplePacket, 0) != CISTPL_NULL) {
               break;
            }
         }
         if (i >= MAX_MISSED_TUPLES) {
            status = STATUS_DEVICE_NOT_READY;
         }
         break;
      }
   default: {
         link = GetCISChar(TuplePacket, 1);
         if (link == 0xFF) {
            status = STATUS_NO_MORE_ENTRIES;
         } else {
            TuplePacket->CISOffset += link+2;
         }
         break;
      }
   }
   return (status);
}


NTSTATUS
GetAnyTuple(
   IN PTUPLE_PACKET TuplePacket
   )

/*++

Routine Description:

      Retrieves the next tuple - regardless of