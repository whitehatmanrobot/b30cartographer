           // nothing to do if this fails.
                    }

                    dwPhysicalId = pCallObject->dwPhysicalId;
                    CallObjectDestroy(pCallObject);
                    linkLayerShutdown(dwPhysicalId);
                    if (buf)
                    {
                        Free(buf);
                        buf = NULL;
                    }
                    return;
                }
                if (Result != CS_OK)
                {
                    Q931DBG((DBGERROR, "ReceiveCallback(): Unable to parse ASN.1 data."));
                    break;
                }

                // The "CallerAddr is not passed in the PDU, so the
                // only valuable addr to use is the connection addr
                // passed from the link layer and saved into the call
                // object at connect-time.
                SetupASN.CallerAddrPresent = TRUE;
                SetupASN.CallerAddr = pCallObject->PeerConnectAddr;

                // The "CalleeAddr" which is passed in the PDU is ignored
                // by the ASN parser, and supplied by the link layer
                // instead and saved into the call object at connect-time.
                // here, this address is used as the callee addr.
                SetupASN.CalleeAddrPresent = TRUE;
                SetupASN.CalleeAddr = pCallObject->LocalAddr;

                Result = Q931OnCallSetup(pCallObject, pMessage, &SetupASN);

				_FreeSetupASN(&SetupASN);
	        }
            break;
        case RELEASECOMPLMESSAGETYPE:
            {
                Q931_RELEASE_COMPLETE_ASN ReleaseCompleteASN;

                if (!pMessage->UserToUser.Present || (pMessage->UserToUser.UserInformationLength == 0))
                {
                    Q931DBG((DBGERROR, "ReceiveCallback(): Message is missing ASN.1 UserUser data..."));
                    dwPhysicalId = pCallObject->dwPhysicalId;
                    CallObjectUnlock(pCallObject);
                    PostReceiveBuffer(dwPhysicalId, buf);
                    return;
                }

                Q931DBG((DBGTRACE, "ReceiveCallback(): received ReleaseComplete message..."));
                Result = Q931ReleaseCompleteParseASN(&pCallObject->World,
										pMessage->UserToUser.UserInformation,
                    pMessage->UserToUser.UserInformationLength, &ReleaseCompleteASN);
                if (Result != CS_OK)
                {
                    Q931DBG((DBGERROR, "ReceiveCallback(): Unable to parse ASN.1 data."));
                    break;
                }
                Result = Q931OnCallReleaseComplete(pCallObject, pMessage, &ReleaseCompleteASN);
                if (CallObjectValidate(hQ931Call) == CS_OK)
                {
                     dwPhysicalId = pCallObject->dwPhysicalId;
                     CallObjectDestroy(pCallObject);
                     linkLayerShutdown(dwPhysicalId);
                }
                Free(buf);
				_FreeReleaseCompleteASN(&ReleaseCompleteASN);
                return;
            }
            break;
        case FACILITYMESSAGETYPE:
            {
                Q931_FACILITY_ASN FacilityASN;

                if (!pMessage->UserToUser.Present || (pMessage->UserToUser.UserInformationLength == 0))
                {
                    Q931DBG((DBGERROR, "ReceiveCallback(): Message is missing ASN.1 UserUser data..."));
                    dwPhysicalId = pCallObject->dwPhysicalId;
                    CallObjectUnlock(pCallObject);
                    PostReceiveBuffer(dwPhysicalId, buf);
                    return;
                }

                Q931DBG((DBGTRACE, "ReceiveCallback(): received Facility message..."));
                Result = Q931FacilityParseASN(&pCallObject->World, pMessage->UserToUser.UserInformation,
                    pMessage->UserToUser.UserInformationLength, &FacilityASN);
                if (Result != CS_OK)
                {
                    Q931DBG((DBGERROR, "ReceiveCallback(): Unable to parse ASN.1 data."));
                    break;
                }

                // initiate a disconnect sequence from the caller side.
                Q931SendReleaseCompleteMessage(pCallObject,
                        CC_REJECT_CALL_DEFLECTION, NULL, NULL, NULL);
               
                Result = Q931OnCallFacility(pCallObject, pMessage, &FacilityASN);
               	_FreeFacilityASN(&FacilityASN);
                dwPhysicalId = pCallObject->dwPhysicalId;
                CallObjectDestroy(pCallObject);
                linkLayerShutdown(dwPhysicalId);
                Free(buf);
                return;
            }
            break;
        case CONNECTMESSAGETYPE:
            {
                Q931_CONNECT_ASN ConnectASN;

                if (!pMessage->UserToUser.Present || (pMessage->UserToUser.UserInformationLength == 0))
                {
                    Q931DBG((DBGERROR, "ReceiveCallback(): Message is missing ASN.1 UserUser data..."));
                    dwPhysicalId = pCallObject->dwPhysicalId;
                    CallObjectUnlock(pCallObject);
                    PostReceiveBuffer(dwPhysicalId, buf);
                    return;
                }

                Q931DBG((DBGTRACE, "ReceiveCallback(): received Connect message..."));
                Result = Q931ConnectParseASN(&pCallObject->World, pMessage->UserToUser.UserInformation,
                    pMessage->UserToUser.UserInformationLength, &ConnectASN);
                if (Result != CS_OK)
                {
                    Q931DBG((DBGERROR, "ReceiveCallback(): Unable to parse ASN.1 data."));
                    break;
                }
                Result = Q931OnCallConnect(pCallObject, pMessage, &ConnectASN);
				_FreeConnectASN(&ConnectASN);
            }
            break;
        case PROCEEDINGMESSAGETYPE:
            {
                Q931_CALL_PROCEEDING_ASN ProceedingASN;

                Q931DBG((DBGTRACE, "ReceiveCallback(): received Proceeding message..."));
                if (!pMessage->UserToUser.Present || (pMessage->UserToUser.UserInformationLength == 0))
                {
                    Result = Q931OnCallProceeding(pCallObject, pMessage, NULL);
                }
                else
                {
                    Result = Q931ProceedingParseASN(&pCallObject->World, pMessage->UserToUser.UserInformation,
                        pMessage->UserToUser.UserInformationLength, &ProceedingASN);
                    if (Result != CS_OK)
                    {
                        Q931DBG((DBGERROR, "ReceiveCallback(): Unable to parse ASN.1 data."));
                        break;
                    }
                    Result = Q931OnCallProceeding(pCallObject, pMessage, &ProceedingASN);
					_FreeProceedingASN(&ProceedingASN);
                }
            }
            break;
        case ALERTINGMESSAGETYPE:
            {
                Q931_ALERTING_ASN AlertingASN;

                Q931DBG((DBGTRACE, "ReceiveCallback(): received Alerting message..."));
                if (!pMessage->UserToUser.Present || (pMessage->UserToUser.UserInformationLength == 0))
                {
                    Result = Q931OnCallAlerting(pCallObject, pMessage, NULL);
                }
                else
                {
                    Result = Q931AlertingParseASN(&pCallObject->World, pMessage->UserToUser.UserInformation,
                        pMessage->UserToUser.UserInformationLength, &AlertingASN);
                    if (Result != CS_OK)
                    {
                        Q931DBG((DBGERROR, "ReceiveCallback(): Unable to parse ASN.1 data."));
                        break;
                    }
                    Result = Q931OnCallAlerting(pCallObject, pMessage, &AlertingASN);
					_FreeAlertingASN(&AlertingASN);
                }
            }
            break;
        case RELEASEMESSAGETYPE:
        case STATUSMESSAGETYPE:
            Q931DBG((DBGWARNING, "ReceiveCallback(): message not yet supported."));
            break;
        case STATUSENQUIRYMESSAGETYPE:
            Q931DBG((DBGWARNING, "ReceiveCallback(): message not yet supported."));
            Result = Q931OnCallStatusEnquiry(pCallObject, pMessage);
            break;
        default:
            Q931DBG((DBGERROR, "ReceiveCallback(): unknown message received."));
            break;
        }

        // re-validate the call object:
        if (CallObjectValidate(hQ931Call) == CS_OK)
        {
            dwPhysicalId = pCallObject->dwPhysicalId;
            CallObjectUnlock(pCallObject);
            PostReceiveBuffer(dwPhysicalId, buf);
            if ((CallObjectLock(hQ931Call, &pCallObject) != CS_OK) || (pCallObject == NULL))
              return;
        }
        else
        {
            if (buf)
            {
                Free(buf);
            }
            return;
        }

        if (   Result == CS_INCOMPATIBLE_VERSION
			|| Result == CS_NO_MEMORY
			|| Result == CS_SUBSYSTEM_FAILURE)
        {
            // initiate a disconnect sequence from the caller side.
            Q931SendReleaseCompleteMessage(pCallObject,
                    CC_REJECT_INVALID_REVISION, NULL, NULL, NULL);
            
            dwPhysicalId = pCallObject->dwPhysicalId;
            CallObjectDestroy(pCallObject);
            linkLayerShutdown(dwPhysicalId);
            return;
        }

        if (Result == CS_MANDATORY_IE_MISSING)
        {
            Q931SendStatusMessage(pCallObject, pMessage,
                CAUSE_VALUE_IE_MISSING);
        }
        else if (   Result == CS_BAD_IE_CONTENT
				 || Result == CS_BAD_PARAM
				 || Result == CS_NO_FIELD_DATA)
        {
            Q931SendStatusMessage(pCallObject, pMessage,
                CAUSE_VALUE_IE_CONTENTS);
        }

    }
    else if (message == LINK_RECV_CLOSED)
    {
        // Socket closed
        if (buf)
        {
            Free(buf);
        }
        pCallObject->Callback(Q931_CALL_CONNECTION_CLOSED, pCallObject->hQ931Call,
            pCallObject->dwListenToken,
            pCallObject->dwUserToken, NULL);

        if (CallObjectValidate(hQ931Call) == CS_OK)
        {
             dwPhysicalId = pCallObject->dwPhysicalId;
             pCallObject->bConnected = FALSE;
						 CallObjectUnlock(pCallObject);
             linkLayerShutdown(dwPhysicalId);
        }
        return;
    }
    else if (buf)
    {
        // unknown condition?
        Free(buf);
    }

    if (CallObjectValidate(hQ931Call) == CS_OK)
    {
        CallObjectUnlock(pCallObject);
    }

    return;
}

//====================================================================================
//====================================================================================
void
Q931ReceiveCallback(DWORD instance, HRESULT message, BYTE *buf, DWORD nbytes)
{
    Q931MESSAGE *pMessage = NULL;
    if (message == LINK_RECV_DATA)
    {
        pMessage = (Q931MESSAGE *)Malloc(sizeof(Q931MESSAGE));
        if (pMessage == NULL)
        {
            Q931DBG((DBGERROR, "Not enough memory to process Q931 message."));
            // something more should be done here to indicate SERIOUS error...
            return;
        }
    }
    OnReceiveCallback(instance, message, pMessage, buf, nbytes);
    if (pMessage)
    {
        Free(pMessage);
    }
    return;
}

//====================================================================================
//====================================================================================
void
Q931ConnectCallback(DWORD dwInstance, HRESULT dwMessage,
        CC_ADDR *pLocalAddr, CC_ADDR *pPeerAddr)
{
    HQ931CALL hQ931Call = (HQ931CALL)dwInstance;
    P_CALL_OBJECT pCallObject = NULL;
    HRESULT TempResult;
    DWORD dwPhysicalId;

    Q931DBG((DBGTRACE, "Entering Q931ConnectCallback()..."));

    if ((CallObjectLock(hQ931Call, &pCallObject) != CS_OK) || (pCallObject == NULL))
    {
        Q931DBG((DBGERROR, "CallObjectLock() returned error"));
        return;
    }

    pCallObject->bConnected = TRUE;

    if (FAILED(dwMessage))
    {
        // shut down link layer; report failure to client
        CSS_CALL_FAILED EventData;

        Q931DBG((DBGERROR, "error in connect"));

        EventData.error = dwMessage;
        pCallObject->Callback(Q931_CALL_FAILED, pCallObject->hQ931Call,
            pCallObject->dwListenToken,
            pCallObject->dwUserToken, &EventData);

        if (CallObjectValidate(hQ931Call) == CS_OK)
        {
             DWORD dwId = pCallObject->dwPhysicalId;
             CallObjectDestroy(pCallObject);
             linkLayerShutdown(dwId);
        }
        return;
    }

    if (dwMessage != LINK_CONNECT_COMPLETE)
    {
        Q931DBG((DBGERROR, "unexpected connect callback"));
        CallObjectUnlock(pCallObject);
        return;
    }

    if (pCallObject->bCallState == CALLSTATE_NULL)
    {
        pCallObject->bCallState = CALLSTATE_INITIATED;
    }
    pCallObject->LocalAddr = *pLocalAddr;
    pCallObject->PeerConnectAddr = *pPeerAddr;

    // if the user specified a binary source address with address = 0,
    // fill in the address with the local address and send.
    if ((pCallObject->SourceAddrPresent) &&
            (pCallObject->SourceAddr.nAddrType == CC_IP_BINARY) &&
            (!pCallObject->SourceAddr.Addr.IP_Binary.dwAddr))
    {
        pCallObject->SourceAddr = *pLocalAddr;
    }

    if ((pCallObject->fIsCaller) &&
            (pCallObject->bCallState == CALLSTATE_INITIATED))
    {
        // send the SETUP message to the peer.
        DWORD CodedLengthASN;
        BYTE *CodedPtrASN;
        HRESULT ResultASN = CS_OK;

        DWORD CodedLengthPDU;
        BYTE *CodedPtrPDU;
        HRESULT ResultPDU = CS_OK;

        int nError = 0;
        BOOL ResultSend = FALSE;
        BINARY_STRING UserUserData;
        PCC_VENDORINFO pVendorInfo = NULL;
        CC_NONSTANDARDDATA *pNonStandardData = NULL;
		DWORD dwId;

        if (pCallObject->VendorInfoPresent)
        {
            pVendorInfo = &(pCallObject->VendorInfo);
        }

        if (pCallObject->NonStandardDataPresent)
        {
            pNonStandardData = &(pCallObject->NonStandardData);
        }

        // if there is a special callee alias list, load the calledparty#.
        if (pCallObject->szCalledPartyNumber[0] == 0 &&
            pCallObject->pCalleeAliasList != NULL &&
            pCallObject->pCalleeAliasList->wCount == 1 &&
            pCallObject->pCalleeAliasList->pItems[0].wType == CC_ALIAS_H323_PHONE &&
            pCallObject->pCalleeAliasList->pItems[0].wDataLength > 0 &&
            pCallObject->pCalleeAliasList->pItems[0].pData != NULL)
        {
            PCC_ALIASITEM pItem = &pCallObject->pCalleeAliasList->pItems[0];
            WCHAR szWidePartyNumber[CC_MAX_PARTY_NUMBER_LEN + 1];

            memset(szWidePartyNumber, 0 , CC_MAX_PARTY_NUMBER_LEN + 1);

            if (pItem->wPrefixLength > 0 && pItem->pPrefix != NULL)
            {
                ASSERT((pItem->wPrefixLength + pItem->wDataLength +1) <= (sizeof(szWidePartyNumber)/sizeof(szWidePartyNumber[0])));
                memcpy(&szWidePartyNumber[0],
                       pItem->pPrefix,
                       (pItem->wPrefixLength) * sizeof(WCHAR));
                memcpy(&szWidePartyNumber[pItem->wPrefixLength],
                       pItem->pData,
                       pItem->wDataLength * sizeof(WCHAR));
            }
            else
            {
                ASSERT((pItem->wDataLength +1) <= (sizeof(szWidePartyNumber)/sizeof(szWidePartyNumber[0])));
                memcpy(szWidePartyNumber,
                       pCallObject->pCalleeAliasList->pItems[0].pData,
                       pItem->wDataLength * sizeof(WCHAR));
            }
            WideCharToMultiByte(CP_ACP, 0, szWidePartyNumber,
                pItem->wPrefixLength + pItem->wDataLength * sizeof(WCHAR), 
                pCallObject->szCalledPartyNumber,
                sizeof(pCallObject->szCalledPartyNumber), NULL, NULL);
        }

        // may wish to pass alias parms later instead of NULL, NULL.
        ResultASN = Q931SetupEncodeASN(pNonStandardData,
            pCallObject->SourceAddrPresent ? &(pCallObject->SourceAddr) : NULL,
            pCallObject->PeerCallAddrPresent ? &(pCallObject->PeerCallAddr) : NULL,  // callee
            pCallObject->wGoal,
            pCallObject->wCallType,
            pCallObject->bCallerIsMC,
            &(pCallObject->ConferenceID),
            pCallObject->pCallerAliasList,
            pCallObject->pCalleeAliasList,
            pCallObject->pExtraAliasList,
            pCallObject->pExtensionAliasItem,
            pVendorInfo,
            pCallObject->bIsTerminal,
            pCallObject->bIsGateway,
                                                &pCallObject->World,
            &CodedPtrASN,
            &CodedLengthASN);

        if ((ResultASN != CS_OK) || (CodedLengthASN == 0) ||
                (CodedPtrASN == NULL))
        {
            CSS_CALL_FAILED EventData;
            Q931DBG((DBGERROR, "Q931SetupEncodeASN() failed, nothing to send."));
            if (CodedPtrASN != NULL)
            {
                Q931FreeEncodedBuffer(&pCallObject->World, CodedPtrASN);
            }
            EventData.error = CS_INTERNAL_ERROR;
            dwId = pCallObject->dwPhysicalId;
            pCallObject->Callback(Q931_CALL_FAILED, pCallObject->hQ931Call,
                pCallObject->dwListenToken,
                pCallObject->dwUserToken, &EventData);
            linkLayerShutdown(dwId);
			if (CallObjectValidate(hQ931Call) == CS_OK)
                 CallObjectDestroy(pCallObject);
            return;
        }

        UserUserData.length = (WORD)CodedLengthASN;
        UserUserData.ptr = CodedPtrASN;

        ResultPDU = Q931SetupEncodePDU(pCallObject->wCRV,
            pCallObject->szDisplay, pCallObject->szCalledPartyNumber,
			pCallObject->dwBandwidth,
            &UserUserData, &CodedPtrPDU, &CodedLengthPDU);

        if (CodedPtrASN != NULL)
        {
            Q931FreeEncodedBuffer(&pCallObject->World, CodedPtrASN);
        }

        if ((ResultPDU != CS_OK) || (CodedLengthPDU == 0) ||
                (CodedPtrPDU == NULL))
        {
            CSS_CALL_FAILED EventData;
            Q931DBG((DBGERROR, "Q931SetupEncodePDU() failed, nothing to send."));
            if (CodedPtrPDU != NULL)
            {
                Free(CodedPtrPDU);
            }
            EventData.error = CS_INTERNAL_ERROR;
            dwId = pCallObject->dwPhysicalId;
            pCallObject->Callback(Q931_CALL_FAILED, pCallObject->hQ931Call,
                pCallObject->dwListenToken,
                pCallObject->dwUserToken, &EventData);
            linkLayerShutdown(dwId);
			if (CallObjectValidate(hQ931Call) == CS_OK)
                 CallObjectDestroy(pCallObject);
            return;
        }

        if (pCallObject->NonStandardDataPresent)
        {
            if (pCallObject->NonStandardData.sData.pOctetString != NULL)
            {
                Free(pCallObject->NonStandardData.sData.pOctetString);
                pCallObject->NonStandardData.sData.pOctetString = NULL;
            }
            pCallObject->NonStandardDataPresent = FALSE;
        }
        Q931FreeAliasNames(pCallObject->pCallerAliasList);
        pCallObject->pCallerAliasList = NULL;
        Q931FreeAliasNames(pCallObject->pCalleeAliasList);
        pCallObject->pCalleeAliasList = NULL;
        Q931FreeAliasNames(pCallObject->pExtraAliasList);
        pCallObject->pExtraAliasList = NULL;
        Q931FreeAliasItem(pCallObject->pExtensionAliasItem);
        pCallObject->pExtensionAliasItem = NULL;

        TempResult=Q931SendMessage(pCallObject, CodedPtrPDU, CodedLengthPDU, TRUE);
        if (CallObjectValidate(hQ931Call) != CS_OK)
          return;

        if(FAILED(TempResult))
        {
            CSS_CALL_FAILED EventData;

            EventData.error = TempResult;
			dwId = pCallObject->dwPhysicalId;
            pCallObject->Callback(Q931_CALL_FAILED, pCallObject->hQ931Call,
                pCallObject->dwListenToken,
                pCallObject->dwUserToken, &EventData);
            linkLayerShutdown(dwId);
			if (CallObjectValidate(hQ931Call) == CS_OK)
                 CallObjectDestroy(pCallObject);
            return;
        }

        Q931StartTimer(pCallObject, Q931_TIMER_303);
    }
    dwPhysicalId = pCallObject->dwPhysicalId;
    CallObjectUnlock(pCallObject);
    PostReceiveBuffer(dwPhysicalId, NULL);
}

//====================================================================================
//====================================================================================
void
Q931ListenCallback(DWORD dwInstance, HRESULT dwMessage,
        CC_ADDR *LocalAddr, CC_ADDR *PeerAddr)
{
    HQ931LISTEN hListenObject = (HQ931LISTEN)dwInstance;
    P_LISTEN_OBJECT pListenObject = NULL;
    CS_STATUS CreateObjectResult;
    HQ931CALL hQ931Call;
    P_CALL_OBJECT pCallObject = NULL;
    HRESULT TempResult;
	DWORD dwPhysicalId;

    Q931DBG((DBGTRACE, "Q931ListenCallback."));

    if (dwMessage != LINK_CONNECT_REQUEST)
    {
        Q931DBG((DBGERROR, "unexpected callback received on listen socket"));
        return;
    }

    if (FAILED(dwMessage))
    {
        Q931DBG((DBGERROR, "error on listen socket"));
        return;
    }

    if ((ListenObjectLock(hListenObject, &pListenObject) != CS_OK) || (pListenObject == NULL))
    {
        Q931DBG((DBGERROR, "ListenObjectLock() returned error"));
        return;
    }

    // create call object with all known attributes of this call.
    // a handle of the call object is returned in phQ931Call.
    CreateObjectResult = CallObjectCreate(&hQ931Call,
        pListenObject->dwUserToken,
        CC_INVALID_HANDLE,
        pListenObject->ListenCallback,
        FALSE,                  // I am NOT the caller.
        LocalAddr,              // Local address on which channel is connected
        PeerAddr,               // Address to which channel is connected
        NULL,                   // Address of opposite call end-point.
        NULL,                   // no source addr
        NULL,                   // no conference id yet.
        CSG_NONE,               // no goal yet.
        CC_CALLTYPE_UNKNOWN,    // no call type yet.
        FALSE,                  // caller is assumed to not be the MC.
        NULL,                   // no display yet.
        NULL,                   // no called party number yet.
        NULL,                   // no caller aliases yet.
        NULL,                   // no callee aliases yet.
        NULL,                   // no extra aliases yet.
        NULL,                   // no extension aliases.
        NULL,                   // no EndpointType info yet.
        NULL,
		0,						// no bandwidth yet
		0);						// no CRV yet.
    if (CreateObjectResult != CS_OK)
    {
        Q931DBG((DBGERROR, "CallObjectCreate() failed."));
        ListenObjectUnlock(pListenObject);
        return;
    }

    if ((CallObjectLock(hQ931Call, &pCallObject) != CS_OK) || (pCallObject == NULL))
    {
        Q931DBG((DBGERROR, "CallObjectLock() returned error"));
        ListenObjectUnlock(pListenObject);
        return;
    }

    TempResult = linkLayerInit(&pCallObject->dwPhysicalId, hQ931Call,
        Q931ReceiveCallback, Q931SendComplete);
    if (FAILED(TempResult))
    {
        Q931DBG((DBGERROR, "linkLayerInit() failed"));
        CallObjectDestroy(pCallObject);
        ListenObjectUnlock(pListenObject);
        return;
    }

//    pCallObject->bCallState = CALLSTATE_NULL;

    // unlock CallObject before calling down into h245ws in order to prevent deadlock - which
    // is probably unlikely with linkLayerAccept(), but just to be safe and consistent...
    // not sure if we need to worry about unlocking the listen object???

    dwPhysicalId = pCallObject->dwPhysicalId;
    CallObjectUnlock(pCallObject);

    TempResult = linkLayerAccept(pListenObject->dwPhysicalId,
        dwPhysicalId, Q931ConnectCallback);

    if (FAILED(TempResult))
    {
	      if((CallObjectLock(hQ931Call, &pCallObject) != CS_OK) || (pCallObject == NULL))
   	    {
	           ListenObjectUnlock(pListenObject);
	           return;
  	    }
        Q931DBG((DBGERROR, "linkLayerAccept() failed"));
        {
             DWORD dwId = pCallObject->dwPhysicalId;
             CallObjectDestroy(pCallObject);
             linkLayerShutdown(dwId);
        }
        ListenObjectUnlock(pListenObject);
        return;
    }

    ListenObjectUnlock(pListenObject);
}

//====================================================================================
//
// PUBLIC FUNCTIONS
//
//====================================================================================

//====================================================================================
//====================================================================================
CS_STATUS
Q931Init()
{
    CS_STATUS result;

    if (bQ931Initialized == TRUE)
    {
    	ASSERT(FALSE);
        return CS_DUPLICATE_INITIALIZE;
    }

    bQ931Initialized = TRUE;

    // Register Call Setup for debug output
    ISRREGISTERMODULE(&ghISRInst, "Q931", "Q931 Call Setup");

    // Initialize the current conference ID to 0's, which is intentionally
    // assigned to an invalid conference ID.  Must create one for it
    // to be valid.
    memset(&(ConferenceIDSource), 0, sizeof(ConferenceIDSource));

    __try {

        InitializeCriticalSectionAndSpinCount(&(ConferenceIDSource.Lock),H323_SPIN_COUNT);

    } __except ((GetExceptionCode() == STATUS_NO_MEMORY)
                ? EXCEPTION_EXECUTE_HANDLER
                : EXCEPTION_CONTINUE_SEARCH
                ) {

        // failure
        return CS_NO_MEMORY;
    }

    if ((result = ListenListCreate()) != CS_OK)
    {
        return result;
    }
    if ((result = CallListCreate()) != CS_OK)
    {
        ListenListDestroy();
        return result;
    }

#if (defined(_DEBUG) && defined(PCS_COMPLIANCE))
    Q931Logger = InteropLoad(Q931LOG_PROTOCOL);
#endif

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931DeInit()
{
    CS_STATUS result1;
    CS_STATUS result2;

    if (bQ931Initialized == FALSE)
    {
        return CS_NOT_INITIALIZED;
    }

#if (defined(_DEBUG) && defined(PCS_COMPLIANCE))
// This causes a protection exception, so don't do it for now.  DAC 12/9/96
//    InteropUnload(Q931Logger);
#endif

    result1 = ListenListDestroy();

    result2 = CallListDestroy();

    DeleteCriticalSection(&(ConferenceIDSource.Lock));

    bQ931Initialized = FALSE;

    if (result1 != CS_OK)
    {
        return result1;
    }
    return result2;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931Listen(
    PHQ931LISTEN        phQ931Listen,
    PCC_ADDR               pListenAddr,
    DWORD               dwListenToken,
    Q931_CALLBACK       ListenCallback)
{
    CS_STATUS CreateObjectResult;
    P_LISTEN_OBJECT pListenObject = NULL;
    HRESULT TempResult;

    // make sure q931 is initialized with an initialize flag.
    if (bQ931Initialized == FALSE)
    {
        return CS_NOT_INITIALIZED;
    }

    // make sure parms are validated.
    if ((phQ931Listen == NULL) || (ListenCallback == NULL) || (pListenAddr == NULL))
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }

    SetDefaultPort(pListenAddr);

    // create listen object with all known attributes of this listen session.
    // a handle of the listen object is returned in phQ931Listen.
    
    CreateObjectResult = ListenObjectCreate(phQ931Listen, dwListenToken, ListenCallback);
    if (CreateObjectResult != CS_OK)
    {
        return CS_SUBSYSTEM_FAILURE;
    }

    if (ListenObjectLock(*phQ931Listen, &pListenObject) != CS_OK)
    {
        return CS_BAD_PARAM;
    }

    TempResult = linkLayerListen(&pListenObject->dwPhysicalId, *phQ931Listen,
        pListenAddr, Q931ListenCallback);
    ListenObjectUnlock(pListenObject);
    if (FAILED(TempResult))
    {
        Q931DBG((DBGERROR, "Q931Listen() linkLayerListen failed."));
        return TempResult;
    }

    Q931DBG((DBGTRACE, "Q931Listen() completed successfully."));
    return CS_OK;
}

//====================================================================================
// In the old code, this blocked until thread and socket were finished
// closing...
//====================================================================================
CS_STATUS
Q931CancelListen(
    HQ931LISTEN         hQ931Listen)
{
    P_LISTEN_OBJECT pListenObject = NULL;
    CS_STATUS Status;

    // make sure q931 is initialized with an initialize flag.
    if (bQ931Initialized == FALSE)
    {
        return CS_NOT_INITIALIZED;
    }

    Q931DBG((DBGTRACE, "Q931CancelListen() finding listen object..."));

    // lock the listen object, get the event to wait for, and unlock the listen object.
    if (ListenObjectLock(hQ931Listen, &pListenObject) != CS_OK)
    {
        return CS_BAD_PARAM;
    }

    {
        DWORD dwId = pListenObject->dwPhysicalId;
        linkLayerShutdown(dwId);
        // destroy the object.  dont need to unlock it since entire object will be destroyed.
        Q931DBG((DBGTRACE, "Q931CancelListen(): destroying listen object..."));
        Status = ListenObjectDestroy(pListenObject);
    }

    return Status;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931PlaceCall(
    PHQ931CALL phQ931Call,
    LPWSTR pszDisplay,
    PCC_ALIASNAMES pCallerAliasList,
    PCC_ALIASNAMES pCalleeAliasList,
    PCC_ALIASNAMES pExtraAliasList,
    PCC_ALIASITEM pExtensionAliasItem,
    PCC_NONSTANDARDDATA pNonStandardData,
    PCC_ENDPOINTTYPE pSourceEndpointType,
    LPWSTR pszCalledPartyNumber,
    PCC_ADDR pControlAddr,
    PCC_ADDR pDestinationAddr,
    PCC_ADDR pSourceAddr,
    BOOL bCallerIsMC,
    CC_CONFERENCEID *pConferenceID,
    WORD wGoal,
    WORD wCallType,
    DWORD dwUserToken,
    Q931_CALLBACK ConnectCallback,
	DWORD dwBandwidth,
    WORD wCRV)
{
    CS_STATUS CreateObjectResult;
    P_CALL_OBJECT pCallObject = NULL;
    CC_ADDR PeerCallAddr;
    CC_ADDR PeerConnectAddr;
    CC_ADDR SourceAddr;
    HRESULT TempResult;
    char szAsciiDisplay[CC_MAX_DISPLAY_LENGTH + 1];
    char szAsciiPartyNumber[CC_MAX_PARTY_NUMBER_LEN + 1];
    DWORD dwPhysicalId;

    // make sure q931 is initialized with an initialize flag.
    if (bQ931Initialized == FALSE)
    {
        return CS_NOT_INITIALIZED;
    }

    // make sure parms are validated.
    if ((phQ931Call == NULL) || (ConnectCallback == NULL) ||
            ((pControlAddr == NULL) && (pDestinationAddr == NULL)) ||
            (pSourceEndpointType == NULL))
    {
        return CS_BAD_PARAM;
    }

    {
        CS_STATUS TempStatus;

        TempStatus = Q931ValidateAddr(pControlAddr);
        if (TempStatus != CS_OK)
        {
            return TempStatus;
        }
        TempStatus = Q931ValidateAddr(pDestinationAddr);
        if (TempStatus != CS_OK)
        {
            return TempStatus;
        }
        TempStatus = Q931ValidateAddr(pSourceAddr);
        if (TempStatus != CS_OK)
        {
            return TempStatus;
        }

        TempStatus = Q931ValidateVendorInfo(pSourceEndpointType->pVendorInfo);
        if (TempStatus != CS_OK)
        {
            return TempStatus;
        }
        TempStatus = Q931ValidateDisplay(pszDisplay);
        if (TempStatus != CS_OK)
        {
            return TempStatus;
        }
        TempStatus = Q931ValidatePartyNumber(pszCalledPartyNumber);
        if (TempStatus != CS_OK)
        {
            return TempStatus;
        }

        szAsciiDisplay[0] = '\0';
        if (pszDisplay && WideCharToMultiByte(CP_ACP, 0, pszDisplay, -1, szAsciiDisplay,
                sizeof(szAsciiDisplay), NULL, NULL) == 0)
        {
            return CS_BAD_PARAM;
        }
        szAsciiPartyNumber[0] = '\0';
        if (pszCalledPartyNumber && WideCharToMultiByte(CP_ACP, 0, pszCalledPartyNumber, -1, szAsciiPartyNumber,
                sizeof(szAsciiPartyNumber), NULL, NULL) == 0)
        {
            return CS_BAD_PARAM;
        }
        TempStatus = Q931ValidateNonStandardData(pNonStandardData);
        if (TempStatus != CS_OK)
        {
            return TempStatus;
        }
        TempStatus = Q931ValidateAliasNames(pCallerAliasList);
        if (TempStatus != CS_OK)
        {
            return TempStatus;
        }
        TempStatus = Q931ValidateAliasNames(pCalleeAliasList);
        if (TempStatus != CS_OK)
        {
            return TempStatus;
        }
        TempStatus = Q931ValidateAliasNames(pExtraAliasList);
        if (TempStatus != CS_OK)
        {
            return TempStatus;
        }
        TempStatus = Q931ValidateAliasItem(pExtensionAliasItem);
        if (TempStatus != CS_OK)
        {
            return TempStatus;
        }
    }

    // get the correct callee and control address to use for the call.
    if (pDestinationAddr)
    {
        if (!MakeBinaryADDR(pDestinationAddr, &PeerCallAddr))
        {
            return CS_BAD_PARAM;
        }
        SetDefaultPort(&PeerCallAddr);
    }

    if (pControlAddr)
    {
        if (!MakeBinaryADDR(pControlAddr, &PeerConnectAddr))
        {
            return CS_BAD_PARAM;
        }
        SetDefaultPort(&PeerConnectAddr);
    }
    else
    {
        PeerConnectAddr = PeerCallAddr;
    }

    // get the correct callee and control address to use for the call.
    if (pSourceAddr)
    {
        if (!MakeBinaryADDR(pSourceAddr, &SourceAddr))
        {
            return CS_BAD_PARAM;
        }
        SetDefaultPort(&SourceAddr);
    }

	if (wGoal == CSG_CREATE)
        {
            // caller is asking to start a new conference.
            if (((DWORD *)pConferenceID->buffer)[0] == 0 && 
                ((DWORD *)pConferenceID->buffer)[1] == 0 &&
                ((DWORD *)pConferenceID->buffer)[2] == 0 &&
                ((DWORD *)pConferenceID->buffer)[3] == 0)
            {
                _ConferenceIDNew(pConferenceID);
            }
        }

    // create call object with all known attributes of this call.
    // a handle of the call object is returned in phQ931Call.
    CreateObjectResult = CallObjectCreate(phQ931Call,
        CC_INVALID_HANDLE,
        dwUserToken,
        ConnectCallback,
        TRUE,                  // I am the caller.
        NULL,                  // no local address yet.
        &PeerConnectAddr,
        pDestinationAddr ? &PeerCallAddr : NULL,
        pSourceAddr ? &SourceAddr : NULL,
        pConferenceID,
        wGoal,
        wCallType,
        bCallerIsMC,
        pszDisplay ? szAsciiDisplay : NULL,
        pszCalledPartyNumber ? szAsciiPartyNumber : NULL,
        pCallerAliasList,
        pCalleeAliasList,
        pExtraAliasList,
        pExtensionAliasItem,
        pSourceEndpointType,
        pNonStandardData,
		dwBandwidth,
        wCRV);

    if (CreateObjectResult != CS_OK)
    {
        return CS_SUBSYSTEM_FAILURE;
    }

    if ((CallObjectLock(*phQ931Call, &pCallObject) != CS_OK) || (pCallObject == NULL))
    {
        Q931DBG((DBGERROR, "CallObjectLock() returned error"));
        return CS_SUBSYSTEM_FAILURE;
    }

    TempResult = linkLayerInit(&pCallObject->dwPhysicalId, *phQ931Call,
        Q931ReceiveCallback, Q931SendComplete);
    if (FAILED(TempResult))
    {
        Q931DBG((DBGERROR, "linkLayerInit() failed"));
        CallObjectDestroy(pCallObject);
        *phQ931Call = 0;
        return TempResult;
    }

    // unlock CallObject before calling down into h245ws in order to prevent deadlock - which
    // is probably unlikely with linkLayerConnect(), but just to be safe and consistent...
    dwPhysicalId = pCallObject->dwPhysicalId;
    CallObjectUnlock(pCallObject);
    TempResult = linkLayerConnect(dwPhysicalId, &PeerConnectAddr,
            Q931ConnectCallback);
    if((CallObjectLock(*phQ931Call, &pCallObject) != CS_OK) || (pCallObject == NULL))
    {
        *phQ931Call = 0;
        return(CS_INTERNAL_ERROR);
    }

    if (FAILED(TempResult))
    {
        Q931DBG((DBGERROR, "linkLayerConnect() failed"));
        {
             DWORD dwId = pCallObject->dwPhysicalId;
             CallObjectDestroy(pCallObject);
             linkLayerShutdown(dwId);
        }
        *phQ931Call = 0;
        return TempResult;
    }

//    pCallObject->bCallState = CALLSTATE_NULL;

    CallObjectUnlock(pCallObject);

    Q931DBG((DBGTRACE, "Q931PlaceCall() completed successfully."));
    return CS_OK;
}

//====================================================================================
// In the old code, this blocked until thread and socket were finished
// closing...
//====================================================================================
CS_STATUS
Q931Hangup(
    HQ931CALL hQ931Call,
    BYTE bReason)
{
    P_CALL_OBJECT pCallObject = NULL;
    CS_STATUS Status;

    if (bQ931Initialized == FALSE)
    {
        return CS_NOT_INITIALIZED;
    }

    Q931DBG((DBGTRACE, "Entering Q931Hangup()..."));

    // need parameter checking...
    if ((CallObjectLock(hQ931Call, &pCallObject) != CS_OK) || (pCallObject == NULL))
    {
        Q931DBG((DBGTRACE, "Call Object no longer available: 0x%08lx", hQ931Call));
        return CS_BAD_PARAM;
    }

    {
    
        CS_STATUS SendStatus = CS_OK;
        if (pCallObject->bCallState != CALLSTATE_NULL)
        {
            // send the RELEASE COMPLETE message to the peer to hang-up.
            SendStatus = Q931SendReleaseCompleteMessage(pCallObject,
                bReason, &(pCallObject->ConferenceID), NULL, NULL);
        }

        {
             DWORD dwId = pCallObject->dwPhysicalId;
             Status = CallObjectDestroy(pCallObject);
             linkLayerShutdown(dwId);
        }

        if (FAILED(SendStatus))
        {
            return SendStatus;
        }
    }

    return Status;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931AcceptCall(
    HQ931CALL           hQ931Call,
    LPWSTR              pszDisplay,
    PCC_NONSTANDARDDATA pNonStandardData,
    PCC_ENDPOINTTYPE    pDestinationEndpointType,
    PCC_ADDR            pH245Addr,
	DWORD				dwBandwidth,
    DWORD               dwUserToken)
{
    P_CALL_OBJECT pCallObject = NULL;
    CS_STATUS result = CS_OK;
    char szAsciiDisplay[CC_MAX_DISPLAY_LENGTH + 1];

    if (bQ931Initialized == FALSE)
    {
        return CS_NOT_INITIALIZED;
    }

    Q931DBG((DBGTRACE, "Entering Q931AcceptCall()..."));

    if ((pDestinationEndpointType == NULL) ||
            (pDestinationEndpointType->pVendorInfo == NULL))
    {
        return CS_BAD_PARAM;
    }

    {
        CS_STATUS TempStatus;

        TempStatus = Q931ValidateVendorInfo(pDestinationEndpointType->pVendorInfo);
        if (TempStatus != CS_OK)
        {
            return TempStatus;
        }
        TempStatus = Q931ValidateDisplay(pszDisplay);
        if (TempStatus != CS_OK)
        {
            return TempStatus;
        }
        szAsciiDisplay[0] = '\0';
        if (pszDisplay && WideCharToMultiByte(CP_ACP, 0, pszDisplay, -1, szAsciiDisplay,
                sizeof(szAsciiDisplay), NULL, NULL) == 0)
        {
            return CS_BAD_PARAM;
        }
        TempStatus = Q931ValidateNonStandardData(pNonStandardData);
        if (TempStatus != CS_OK)
        {
            return TempStatus;
        }
    }

    if ((CallObjectLock(hQ931Call, &pCallObject) != CS_OK) || (pCallObject == NULL))
    {
        Q931DBG((DBGERROR, "CallObjectLock() returned error (Socket not found)."));
        return CS_INTERNAL_ERROR;
    }

    if (pCallObject->fIsCaller)
    {
        Q931DBG((DBGERROR, "Caller attempted to accept call."));

        CallObjectUnlock(pCallObject);
        return CS_OUT_OF_SEQUENCE;
    }

    // label with the user supplied UserToken for this call object.
    pCallObject->dwUserToken = dwUserToken;
	pCallObject->dwBandwidth = dwBandwidth;

    // send the CONNECT message to peer to accept call.
    {
        DWORD CodedLengthASN;
        BYTE *CodedPtrASN;
        HRESULT ResultASN = CS_OK;
        CC_ADDR h245Addr;

        if (pH245Addr != NULL)
        {
            MakeBinaryADDR(pH245Addr, &h245Addr);
        }

        ResultASN = Q931ConnectEncodeASN(pNonStandardData,
            &(pCallObject->ConferenceID),
            (pH245Addr ? &h245Addr : NULL),
            pDestinationEndpointType,
                                                &pCallObject->World,
            &CodedPtrASN,
            &CodedLengthASN);
        if ((ResultASN != CS_OK) || (CodedLengthASN == 0) ||
                (CodedPtrASN == NULL))
        {
            Q931DBG((DBGERROR, "Q931ConnectEncodeASN() failed, nothing to send."));
            if (CodedPtrASN != NULL)
            {
                Q931FreeEncodedBuffer(&pCallObject->World, CodedPtrASN);
            }
            CallObjectUnlock(pCallObject);
            return CS_SUBSYSTEM_FAILURE;
        }
        else
        {
            DWORD CodedLengthPDU;
            BYTE *CodedPtrPDU;
            BINARY_STRING UserUserData;
            HRESULT ResultEncode = CS_OK;
            HRESULT TempResult;
            WORD wCRV = (WORD)(pCallObject->wCRV | 0x8000);

            UserUserData.length = (WORD)CodedLengthASN;
            UserUserData.ptr = CodedPtrASN;

            ResultEncode = Q931ConnectEncodePDU(wCRV,
                szAsciiDisplay, pCallObject->dwBandwidth,
				&UserUserData, &CodedPtrPDU, &CodedLengthPDU);
            if (CodedPtrASN != NULL)
            {
                Q931FreeEncodedBuffer(&pCallObject->World, CodedPtrASN);
            }
            if ((ResultEncode != CS_OK) || (CodedLengthPDU == 0) ||
                    (CodedPtrPDU == NULL))
            {
                Q931DBG((DBGERROR, "Q931ConnectEncodePDU() failed, nothing to send."));
                if (CodedPtrPDU != NULL)
                {
                    Free(CodedPtrPDU);
                }
                CallObjectUnlock(pCallObject);
                return CS_SUBSYSTEM_FAILURE;
            }

            TempResult = Q931SendMessage(pCallObject, CodedPtrPDU, CodedLengthPDU, TRUE);
            if (CallObjectValidate(hQ931Call) != CS_OK)
              return CS_INTERNAL_ERROR;


            if (FAILED(TempResult))
            {
                Q931DBG((DBGERROR, "datalinkSendRequest() failed"));

                // when the connect notification fails...what should we do anyway????
                CallObjectUnlock(pCallObject);
                return TempResult;
            }
        }
    }

    pCallObject->bCallState = CALLSTATE_ACTIVE;

    CallObjectUnlock(pCallObject);
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931RejectCall(
    HQ931CALL hQ931Call,
    BYTE bRejectReason,
    PCC_CONFERENCEID pConferenceID,
    PCC_ADDR pAlternateAddr,
    PCC_NONSTANDARDDATA pNonStandardData)
{
    P_CALL_OBJECT pCallObject = NULL;
    CS_STATUS result = CS_OK;
    CS_STATUS Status = CS_OK;

    if (bQ931Initialized == FALSE)
    {
        return CS_NOT_INITIALIZED;
    }

    Q931DBG((DBGTRACE, "Entering Q931RejectCall()..."));

    {
        CS_STATUS TempStatus;

        TempStatus = Q931ValidateNonStandardData(pNonStandardData);
        if (TempStatus != CS_OK)
        {
            return TempStatus;
        }
    }

    // if reason is alternate addr, but there is no alternate addr -->err
    if (((bRejectReason == CC_REJECT_ROUTE_TO_GATEKEEPER) ||
            (bRejectReason == CC_REJECT_CALL_FORWARDED) ||
            (bRejectReason == CC_REJECT_ROUTE_TO_MC)) &&
            (pAlternateAddr == NULL))
    {
        return CS_BAD_PARAM;
    }

    if ((CallObjectLock(hQ931Call, &pCallObject) != CS_OK) || (pCallObject == NULL))
    {
        Q931DBG((DBGERROR, "CallObjectLock() returned error (Socket not found)."));
        return CS_INTERNAL_ERROR;
    }

    if (pCallObject->fIsCaller)
    {
        Q931DBG((DBGERROR, "Caller attempted to reject call."));

        CallObjectUnlock(pCallObject);
        return CS_OUT_OF_SEQUENCE;
    }

    result = Q931SendReleaseCompleteMessage(pCallObject,
        bRejectReason, pConferenceID, pAlternateAddr, pNonStandardData);

    {
        DWORD dwId = pCallObject->dwPhysicalId;
        Status = CallObjectDestroy(pCallObject);
        linkLayerShutdown(dwId);
    }

    if (result != CS_OK)
    {
        return result;
    }


    return Status;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931ReOpenConnection(
    HQ931CALL hQ931Call)
{
    P_CALL_OBJECT pCallObject = NULL;
    HRESULT TempResult = CS_OK;
    CC_ADDR PeerConnectAddr;
    DWORD dwPhysicalId;

    if (bQ931Initialized == FALSE)
    {
        return CS_NOT_INITIALIZED;
    }

    Q931DBG((DBGTRACE, "Entering Q931ReOpenConnection()..."));

    if ((CallObjectLock(hQ931Call, &pCallObject) != CS_OK) || (pCallObject == NULL))
    {
        Q931DBG((DBGERROR, "CallObjectLock() returned error."));
        return CS_INTERNAL_ERROR;
    }

    if (pCallObject->bConnected)
    {
        return CS_OUT_OF_SEQUENCE;
    }

    Q931MakePhysicalID(&pCallObject->dwPhysicalId);
    TempResult = linkLayerInit(&pCallObject->dwPhysicalId, hQ931Call,
        Q931ReceiveCallback, Q931SendComplete);
    if (FAILED(TempResult))
    {
        Q931DBG((DBGERROR, "linkLayerInit() failed on re-connect."));
        CallObjectUnlock(pCallObject);
        return TempResult;
    }

    // unlock CallObject before calling down into h245ws in order to prevent deadlock - which
    // is probably unlikely with linkLayerConnect, but just to be safe and consistent...
    
    // copy stuff we need out of call object before we unlock it
    dwPhysicalId = pCallObject->dwPhysicalId;
    PeerConnectAddr = pCallObject->PeerConnectAddr;

    CallObjectUnlock(pCallObject);

    TempResult = linkLayerConnect(dwPhysicalId,
            &PeerConnectAddr, Q931ConnectCallback);

    if((CallObjectLock(hQ931Call, &pCallObject) != CS_OK) || (pCallObject == NULL))
    {
        return(CS_INTERNAL_ERROR);
    }

    if (FAILED(TempResult))
    {
        Q931DBG((DBGERROR, "linkLayerConnect() failed on re-connect."));
        linkLayerShutdown(pCallObject->dwPhysicalId);
        CallObjectUnlock(pCallObject);
        return TempResult;
    }

    CallObjectUnlock(pCallObject);

    Q931DBG((DBGTRACE, "Q931ReOpenConnection() completed successfully."));
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931GetVersion(
    WORD wLength,
    LPWSTR pszVersion)
{
WCHAR	pszQ931Version[255];

    // parameter validation.
    if ((wLength == 0) || (pszVersion == NULL))
    {
        return CS_BAD_PARAM;
    }

    wcscpy(pszQ931Version, L"Call Setup ");
    wcscat(pszQ931Version, Unicode(__DATE__));
    wcscat(pszQ931Version, L" ");
    wcscat(pszQ931Version, Unicode(__TIME__));

    if (wcslen(pszQ931Version) >= wLength)
    {
		memcpy(pszVersion, pszQ931Version, (wLength-1)*sizeof(WCHAR));
        pszQ931Version[wLength-1] = L'\0';
        return CS_BAD_SIZE;
    }

	wcscpy(pszVersion, pszQ931Version);
    return CS_OK;
}

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Timer Routines...
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

//====================================================================================
// Timer 301 has expired for this object...
//====================================================================================
void
CallBackT301(P_CALL_OBJECT pCallObject)
{
    CSS_CALL_FAILED EventData;
    HQ931CALL hQ931Call = pCallObject->hQ931Call;

    EventData.error = CS_RINGING_TIMER_EXPIRED;
    pCallObject->Callback(Q931_CALL_FAILED, pCallObject->hQ931Call,
        pCallObject->dwListenToken,
        pCallObject->dwUserToken, &EventData);

    if (CallObjectValidate(hQ931Call) == CS_OK)
    {
        if (Q931SendReleaseCompleteMessage(pCallObject,
            CC_REJECT_TIMER_EXPIRED, NULL, NULL, NULL) == CS_OK)
        {
            // nothing to do...
        }
        
        {
             DWORD dwId = pCallObject->dwPhysicalId;
             CallObjectDestroy(pCallObject);
             linkLayerShutdown(dwId);
        }
    }
    return;
}

//====================================================================================
// Timer 303 has expired for this object...
//====================================================================================
void
CallBackT303(P_CALL_OBJECT pCallObject)
{
    CSS_CALL_FAILED EventData;
    HQ931CALL hQ931Call = pCallObject->hQ931Call;

    EventData.error = CS_SETUP_TIMER_EXPIRED;
    pCallObject->Callback(Q931_CALL_FAILED, pCallObject->hQ931Call,
        pCallObject->dwListenToken,
        pCallObject->dwUserToken, &EventData);

    if (CallObjectValidate(hQ931Call) == CS_OK)
    {
        if (Q931SendReleaseCompleteMessage(pCallObject,
            CC_REJECT_TIMER_EXPIRED, NULL, NULL, NULL) == CS_OK)
        {
            // nothing to do...
        }
        
        {
             DWORD dwId = pCallObject->dwPhysicalId;
             CallObjectDestroy(pCallObject);
             linkLayerShutdown(dwId);
        }
    }
    return;
}

//====================================================================================
//====================================================================================
void
Q931SetReceivePDUHook(Q931_RECEIVE_PDU_CALLBACK Q931ReceivePDUCallback)
{
    gReceivePDUHookProc = Q931ReceivePDUCallback;
    return;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931FlushSendQueue(
    HQ931CALL hQ931Call)
{
    P_CALL_OBJECT pCallObject = NULL;
    HRESULT TempResult = CS_OK;
    DWORD dwPhysicalId;

    if (bQ931Initialized == FALSE)
    {
        return CS_NOT_INITIALIZED;
    }

    Q931DBG((DBGTRACE, "Entering Q931FlushSendQueue()..."));

    // need parameter checking...
    if ((CallObjectLock(hQ931Call, &pCallObject) != CS_OK) || (pCallObject == NULL))
    {
        Q931DBG((DBGTRACE, "Call Object no longer available: 0x%08lx", hQ931Call));
        return CS_INTERNAL_ERROR;
    }

    dwPhysicalId = pCallObject->dwPhysicalId;

    CallObjectUnlock(pCallObject);

    TempResult = linkLayerFlushChannel(dwPhysicalId, DATALINK_TRANSMIT);
    if (FAILED(TempResult))
    {
        Q931DBG((DBGERROR, "datalinkSendRequest() failed"));
    }

    return(TempResult);
}

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\q931\hlisten.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/Q931/VCS/hlisten.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1996 Intel Corporation.
 *
 *	$Revision:   1.8  $
 *	$Date:   22 Jul 1996 19:00:20  $
 *	$Author:   rodellx  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *      Listen Object Methods
 *
 *	Notes:
 *
 ***************************************************************************/


#ifndef HLISTEN_H
#define HLISTEN_H

#ifdef __cplusplus
extern "C" {
#endif

#define LISTEN_SHUTDOWN_EVENT 0
#define LISTEN_ACCEPT_EVENT 1

typedef struct LISTEN_OBJECT_tag
{
    HQ931LISTEN         hQ931Listen;
    DWORD               dwUserToken;
    Q931_CALLBACK       ListenCallback;
    DWORD               dwPhysicalId;

    BOOL                bInList;
    struct LISTEN_OBJECT_tag *pNextInList;
    struct LISTEN_OBJECT_tag *pPrevInList;
    CRITICAL_SECTION    Lock;
} LISTEN_OBJECT, *P_LISTEN_OBJECT, **PP_LISTEN_OBJECT;

BOOL ListenListAddrSearch(
    WORD             wListenPort);

CS_STATUS ListenListCreate();

CS_STATUS ListenListDestroy();

CS_STATUS ListenObjectCreate(
    PHQ931LISTEN        phQ931Listen,
    DWORD               dwUserToken,
    Q931_CALLBACK       ListenCallback);

CS_STATUS ListenObjectDestroy(
    P_LISTEN_OBJECT     pListenObject);

CS_STATUS ListenObjectLock(
    HQ931LISTEN         hQ931Listen,
    PP_LISTEN_OBJECT    ppListenObject);

CS_STATUS ListenObjectUnlock(
    P_LISTEN_OBJECT     pListenObject);

#ifdef __cplusplus
}
#endif

#endif HLISTEN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\q931\q931asn.c ===
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for H.323 Messages Call Setup (Q.931) */

#include <windows.h>
#include "q931asn.h"

ASN1module_t Q931ASN_Module = NULL;

static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_routing(ASN1encoding_t enc, TransportAddress_ipSourceRoute_routing *val);
static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_route(ASN1encoding_t enc, PTransportAddress_ipSourceRoute_route *val);
static int ASN1CALL ASN1Enc_H323_UserInformation_user_data(ASN1encoding_t enc, H323_UserInformation_user_data *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_conferenceGoal(ASN1encoding_t enc, Setup_UUIE_conferenceGoal *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCRV(ASN1encoding_t enc, PSetup_UUIE_destExtraCRV *val);
static int ASN1CALL ASN1Enc_TransportAddress_ip6Address(ASN1encoding_t enc, TransportAddress_ip6Address *val);
static int ASN1CALL ASN1Enc_TransportAddress_ipxAddress(ASN1encoding_t enc, TransportAddress_ipxAddress *val);
static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute(ASN1encoding_t enc, TransportAddress_ipSourceRoute *val);
static int ASN1CALL ASN1Enc_TransportAddress_ipAddress(ASN1encoding_t enc, TransportAddress_ipAddress *val);
static int ASN1CALL ASN1Enc_H221NonStandard(ASN1encoding_t enc, H221NonStandard *val);
static int ASN1CALL ASN1Enc_NonStandardIdentifier(ASN1encoding_t enc, NonStandardIdentifier *val);
static int ASN1CALL ASN1Enc_NonStandardParameter(ASN1encoding_t enc, NonStandardParameter *val);
static int ASN1CALL ASN1Enc_CallType(ASN1encoding_t enc, CallType *val);
static int ASN1CALL ASN1Enc_Q954Details(ASN1encoding_t enc, Q954Details *val);
static int ASN1CALL ASN1Enc_QseriesOptions(ASN1encoding_t enc, QseriesOptions *val);
static int ASN1CALL ASN1Enc_H310Caps(ASN1encoding_t enc, H310Caps *val);
static int ASN1CALL ASN1Enc_H320Caps(ASN1encoding_t enc, H320Caps *val);
static int ASN1CALL ASN1Enc_H321Caps(ASN1encoding_t enc, H321Caps *val);
static int ASN1CALL ASN1Enc_H322Caps(ASN1encoding_t enc, H322Caps *val);
static int ASN1CALL ASN1Enc_H323Caps(ASN1encoding_t enc, H323Caps *val);
static int ASN1CALL ASN1Enc_H324Caps(ASN1encoding_t enc, H324Caps *val);
static int ASN1CALL ASN1Enc_VoiceCaps(ASN1encoding_t enc, VoiceCaps *val);
static int ASN1CALL ASN1Enc_T120OnlyCaps(ASN1encoding_t enc, T120OnlyCaps *val);
static int ASN1CALL ASN1Enc_McuInfo(ASN1encoding_t enc, McuInfo *val);
static int ASN1CALL ASN1Enc_TerminalInfo(ASN1encoding_t enc, TerminalInfo *val);
static int ASN1CALL ASN1Enc_GatekeeperInfo(ASN1encoding_t enc, GatekeeperInfo *val);
static int ASN1CALL ASN1Enc_VendorIdentifier(ASN1encoding_t enc, VendorIdentifier *val);
static int ASN1CALL ASN1Enc_SupportedProtocols(ASN1encoding_t enc, SupportedProtocols *val);
static int ASN1CALL ASN1Enc_GatewayInfo(ASN1encoding_t enc, GatewayInfo *val);
static int ASN1CALL ASN1Enc_EndpointType(ASN1encoding_t enc, EndpointType *val);
static int ASN1CALL ASN1Enc_TransportAddress(ASN1encoding_t enc, TransportAddress *val);
static int ASN1CALL ASN1Enc_AliasAddress(ASN1encoding_t enc, AliasAddress *val);
static int ASN1CALL ASN1Enc_Setup_UUIE(ASN1encoding_t enc, Setup_UUIE *val);
static int ASN1CALL ASN1Enc_CallProceeding_UUIE(ASN1encoding_t enc, CallProceeding_UUIE *val);
static int ASN1CALL ASN1Enc_Connect_UUIE(ASN1encoding_t enc, Connect_UUIE *val);
static int ASN1CALL ASN1Enc_Alerting_UUIE(ASN1encoding_t enc, Alerting_UUIE *val);
static int ASN1CALL ASN1Enc_UI_UUIE(ASN1encoding_t enc, UI_UUIE *val);
static int ASN1CALL ASN1Enc_ReleaseCompleteReason(ASN1encoding_t enc, ReleaseCompleteReason *val);
static int ASN1CALL ASN1Enc_ReleaseComplete_UUIE(ASN1encoding_t enc, ReleaseComplete_UUIE *val);
static int ASN1CALL ASN1Enc_FacilityReason(ASN1encoding_t enc, FacilityReason *val);
static int ASN1CALL ASN1Enc_Facility_UUIE(ASN1encoding_t enc, Facility_UUIE *val);
static int ASN1CALL ASN1Enc_H323_UU_PDU_h323_message_body(ASN1encoding_t enc, H323_UU_PDU_h323_message_body *val);
static int ASN1CALL ASN1Enc_Facility_UUIE_alternativeAliasAddress(ASN1encoding_t enc, PFacility_UUIE_alternativeAliasAddress *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCallInfo(ASN1encoding_t enc, PSetup_UUIE_destExtraCallInfo *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_destinationAddress(ASN1encoding_t enc, PSetup_UUIE_destinationAddress *val);
static int ASN1CALL ASN1Enc_Setup_UUIE_sourceAddress(ASN1encoding_t enc, PSetup_UUIE_sourceAddress *val);
static int ASN1CALL ASN1Enc_GatewayInfo_protocol(ASN1encoding_t enc, PGatewayInfo_protocol *val);
static int ASN1CALL ASN1Enc_H323_UU_PDU(ASN1encoding_t enc, H323_UU_PDU *val);
static int ASN1CALL ASN1Enc_H323_UserInformation(ASN1encoding_t enc, H323_UserInformation *val);
static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_routing(ASN1decoding_t dec, TransportAddress_ipSourceRoute_routing *val);
static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_route(ASN1decoding_t dec, PTransportAddress_ipSourceRoute_route *val);
static int ASN1CALL ASN1Dec_H323_UserInformation_user_data(ASN1decoding_t dec, H323_UserInformation_user_data *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_conferenceGoal(ASN1decoding_t dec, Setup_UUIE_conferenceGoal *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCRV(ASN1decoding_t dec, PSetup_UUIE_destExtraCRV *val);
static int ASN1CALL ASN1Dec_TransportAddress_ip6Address(ASN1decoding_t dec, TransportAddress_ip6Address *val);
static int ASN1CALL ASN1Dec_TransportAddress_ipxAddress(ASN1decoding_t dec, TransportAddress_ipxAddress *val);
static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute(ASN1decoding_t dec, TransportAddress_ipSourceRoute *val);
static int ASN1CALL ASN1Dec_TransportAddress_ipAddress(ASN1decoding_t dec, TransportAddress_ipAddress *val);
static int ASN1CALL ASN1Dec_H221NonStandard(ASN1decoding_t dec, H221NonStandard *val);
static int ASN1CALL ASN1Dec_NonStandardIdentifier(ASN1decoding_t dec, NonStandardIdentifier *val);
static int ASN1CALL ASN1Dec_NonStandardParameter(ASN1decoding_t dec, NonStandardParameter *val);
static int ASN1CALL ASN1Dec_CallType(ASN1decoding_t dec, CallType *val);
static int ASN1CALL ASN1Dec_Q954Details(ASN1decoding_t dec, Q954Details *val);
static int ASN1CALL ASN1Dec_QseriesOptions(ASN1decoding_t dec, QseriesOptions *val);
static int ASN1CALL ASN1Dec_H310Caps(ASN1decoding_t dec, H310Caps *val);
static int ASN1CALL ASN1Dec_H320Caps(ASN1decoding_t dec, H320Caps *val);
static int ASN1CALL ASN1Dec_H321Caps(ASN1decoding_t dec, H321Caps *val);
static int ASN1CALL ASN1Dec_H322Caps(ASN1decoding_t dec, H322Caps *val);
static int ASN1CALL ASN1Dec_H323Caps(ASN1decoding_t dec, H323Caps *val);
static int ASN1CALL ASN1Dec_H324Caps(ASN1decoding_t dec, H324Caps *val);
static int ASN1CALL ASN1Dec_VoiceCaps(ASN1decoding_t dec, VoiceCaps *val);
static int ASN1CALL ASN1Dec_T120OnlyCaps(ASN1decoding_t dec, T120OnlyCaps *val);
static int ASN1CALL ASN1Dec_McuInfo(ASN1decoding_t dec, McuInfo *val);
static int ASN1CALL ASN1Dec_TerminalInfo(ASN1decoding_t dec, TerminalInfo *val);
static int ASN1CALL ASN1Dec_GatekeeperInfo(ASN1decoding_t dec, GatekeeperInfo *val);
static int ASN1CALL ASN1Dec_VendorIdentifier(ASN1decoding_t dec, VendorIdentifier *val);
static int ASN1CALL ASN1Dec_SupportedProtocols(ASN1decoding_t dec, SupportedProtocols *val);
static int ASN1CALL ASN1Dec_GatewayInfo(ASN1decoding_t dec, GatewayInfo *val);
static int ASN1CALL ASN1Dec_EndpointType(ASN1decoding_t dec, EndpointType *val);
static int ASN1CALL ASN1Dec_TransportAddress(ASN1decoding_t dec, TransportAddress *val);
static int ASN1CALL ASN1Dec_AliasAddress(ASN1decoding_t dec, AliasAddress *val);
static int ASN1CALL ASN1Dec_Setup_UUIE(ASN1decoding_t dec, Setup_UUIE *val);
static int ASN1CALL ASN1Dec_CallProceeding_UUIE(ASN1decoding_t dec, CallProceeding_UUIE *val);
static int ASN1CALL ASN1Dec_Connect_UUIE(ASN1decoding_t dec, Connect_UUIE *val);
static int ASN1CALL ASN1Dec_Alerting_UUIE(ASN1decoding_t dec, Alerting_UUIE *val);
static int ASN1CALL ASN1Dec_UI_UUIE(ASN1decoding_t dec, UI_UUIE *val);
static int ASN1CALL ASN1Dec_ReleaseCompleteReason(ASN1decoding_t dec, ReleaseCompleteReason *val);
static int ASN1CALL ASN1Dec_ReleaseComplete_UUIE(ASN1decoding_t dec, ReleaseComplete_UUIE *val);
static int ASN1CALL ASN1Dec_FacilityReason(ASN1decoding_t dec, FacilityReason *val);
static int ASN1CALL ASN1Dec_Facility_UUIE(ASN1decoding_t dec, Facility_UUIE *val);
static int ASN1CALL ASN1Dec_H323_UU_PDU_h323_message_body(ASN1decoding_t dec, H323_UU_PDU_h323_message_body *val);
static int ASN1CALL ASN1Dec_Facility_UUIE_alternativeAliasAddress(ASN1decoding_t dec, PFacility_UUIE_alternativeAliasAddress *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCallInfo(ASN1decoding_t dec, PSetup_UUIE_destExtraCallInfo *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_destinationAddress(ASN1decoding_t dec, PSetup_UUIE_destinationAddress *val);
static int ASN1CALL ASN1Dec_Setup_UUIE_sourceAddress(ASN1decoding_t dec, PSetup_UUIE_sourceAddress *val);
static int ASN1CALL ASN1Dec_GatewayInfo_protocol(ASN1decoding_t dec, PGatewayInfo_protocol *val);
static int ASN1CALL ASN1Dec_H323_UU_PDU(ASN1decoding_t dec, H323_UU_PDU *val);
static int ASN1CALL ASN1Dec_H323_UserInformation(ASN1decoding_t dec, H323_UserInformation *val);
static void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute_route(PTransportAddress_ipSourceRoute_route *val);
static void ASN1CALL ASN1Free_H323_UserInformation_user_data(H323_UserInformation_user_data *val);
static void ASN1CALL ASN1Free_Setup_UUIE_destExtraCRV(PSetup_UUIE_destExtraCRV *val);
static void ASN1CALL ASN1Free_TransportAddress_ip6Address(TransportAddress_ip6Address *val);
static void ASN1CALL ASN1Free_TransportAddress_ipxAddress(TransportAddress_ipxAddress *val);
static void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute(TransportAddress_ipSourceRoute *val);
static void ASN1CALL ASN1Free_TransportAddress_ipAddress(TransportAddress_ipAddress *val);
static void ASN1CALL ASN1Free_NonStandardIdentifier(NonStandardIdentifier *val);
static void ASN1CALL ASN1Free_NonStandardParameter(NonStandardParameter *val);
static void ASN1CALL ASN1Free_H310Caps(H310Caps *val);
static void ASN1CALL ASN1Free_H320Caps(H320Caps *val);
static void ASN1CALL ASN1Free_H321Caps(H321Caps *val);
static void ASN1CALL ASN1Free_H322Caps(H322Caps *val);
static void ASN1CALL ASN1Free_H323Caps(H323Caps *val);
static void ASN1CALL ASN1Free_H324Caps(H324Caps *val);
static void ASN1CALL ASN1Free_VoiceCaps(VoiceCaps *val);
static void ASN1CALL ASN1Free_T120OnlyCaps(T120OnlyCaps *val);
static void ASN1CALL ASN1Free_McuInfo(McuInfo *val);
static void ASN1CALL ASN1Free_TerminalInfo(TerminalInfo *val);
static void ASN1CALL ASN1Free_GatekeeperInfo(GatekeeperInfo *val);
static void ASN1CALL ASN1Free_VendorIdentifier(VendorIdentifier *val);
static void ASN1CALL ASN1Free_SupportedProtocols(SupportedProtocols *val);
static void ASN1CALL ASN1Free_GatewayInfo(GatewayInfo *val);
static void ASN1CALL ASN1Free_EndpointType(EndpointType *val);
static void ASN1CALL ASN1Free_TransportAddress(TransportAddress *val);
static void ASN1CALL ASN1Free_AliasAddress(AliasAddress *val);
static void ASN1CALL ASN1Free_Setup_UUIE(Setup_UUIE *val);
static void ASN1CALL ASN1Free_CallProceeding_UUIE(CallProceeding_UUIE *val);
static void ASN1CALL ASN1Free_Connect_UUIE(Connect_UUIE *val);
static void ASN1CALL ASN1Free_Alerting_UUIE(Alerting_UUIE *val);
static void ASN1CALL ASN1Free_UI_UUIE(UI_UUIE *val);
static void ASN1CALL ASN1Free_ReleaseComplete_UUIE(ReleaseComplete_UUIE *val);
static void ASN1CALL ASN1Free_Facility_UUIE(Facility_UUIE *val);
static void ASN1CALL ASN1Free_H323_UU_PDU_h323_message_body(H323_UU_PDU_h323_message_body *val);
static void ASN1CALL ASN1Free_Facility_UUIE_alternativeAliasAddress(PFacility_UUIE_alternativeAliasAddress *val);
static void ASN1CALL ASN1Free_Setup_UUIE_destExtraCallInfo(PSetup_UUIE_destExtraCallInfo *val);
static void ASN1CALL ASN1Free_Setup_UUIE_destinationAddress(PSetup_UUIE_destinationAddress *val);
static void ASN1CALL ASN1Free_Setup_UUIE_sourceAddress(PSetup_UUIE_sourceAddress *val);
static void ASN1CALL ASN1Free_GatewayInfo_protocol(PGatewayInfo_protocol *val);
static void ASN1CALL ASN1Free_H323_UU_PDU(H323_UU_PDU *val);
static void ASN1CALL ASN1Free_H323_UserInformation(H323_UserInformation *val);

typedef ASN1PerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[1] = {
    (ASN1EncFun_t) ASN1Enc_H323_UserInformation,
};
typedef ASN1PerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[1] = {
    (ASN1DecFun_t) ASN1Dec_H323_UserInformation,
};
static const ASN1FreeFun_t freefntab[1] = {
    (ASN1FreeFun_t) ASN1Free_H323_UserInformation,
};
static const ULONG sizetab[1] = {
    SIZE_Q931ASN_Module_PDU_0,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */

void ASN1CALL Q931ASN_Module_Startup(void)
{
    Q931ASN_Module = ASN1_CreateModule(0x10000, ASN1_PER_RULE_ALIGNED, ASN1FLAGS_NONE, 1, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x31333971);
}

void ASN1CALL Q931ASN_Module_Cleanup(void)
{
    ASN1_CloseModule(Q931ASN_Module);
    Q931ASN_Module = NULL;
}

static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_routing(ASN1encoding_t enc, TransportAddress_ipSourceRoute_routing *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_routing(ASN1decoding_t dec, TransportAddress_ipSourceRoute_routing *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_route(ASN1encoding_t enc, PTransportAddress_ipSourceRoute_route *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_TransportAddress_ipSourceRoute_route_ElmFn);
}

static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_route_ElmFn(ASN1encoding_t enc, PTransportAddress_ipSourceRoute_route val)
{
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &val->value, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_route(ASN1decoding_t dec, PTransportAddress_ipSourceRoute_route *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_TransportAddress_ipSourceRoute_route_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_route_ElmFn(ASN1decoding_t dec, PTransportAddress_ipSourceRoute_route val)
{
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &val->value, 4))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute_route(PTransportAddress_ipSourceRoute_route *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_TransportAddress_ipSourceRoute_route_ElmFn);
    }
}

static void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute_route_ElmFn(PTransportAddress_ipSourceRoute_route val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_H323_UserInformation_user_data(ASN1encoding_t enc, H323_UserInformation_user_data *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->protocol_discriminator))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->user_information, 1, 131, 8))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H323_UserInformation_user_data(ASN1decoding_t dec, H323_UserInformation_user_data *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->protocol_discriminator))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->user_information, 1, 131, 8))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H323_UserInformation_user_data(H323_UserInformation_user_data *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE_conferenceGoal(ASN1encoding_t enc, Setup_UUIE_conferenceGoal *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_conferenceGoal(ASN1decoding_t dec, Setup_UUIE_conferenceGoal *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCRV(ASN1encoding_t enc, PSetup_UUIE_destExtraCRV *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Setup_UUIE_destExtraCRV_ElmFn);
}

static int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCRV_ElmFn(ASN1encoding_t enc, PSetup_UUIE_destExtraCRV val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCRV(ASN1decoding_t dec, PSetup_UUIE_destExtraCRV *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Setup_UUIE_destExtraCRV_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCRV_ElmFn(ASN1decoding_t dec, PSetup_UUIE_destExtraCRV val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    val->value += 1;
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE_destExtraCRV(PSetup_UUIE_destExtraCRV *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Setup_UUIE_destExtraCRV_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Setup_UUIE_destExtraCRV_ElmFn(PSetup_UUIE_destExtraCRV val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_TransportAddress_ip6Address(ASN1encoding_t enc, TransportAddress_ip6Address *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->ip, 16))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->port))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ip6Address(ASN1decoding_t dec, TransportAddress_ip6Address *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->ip, 16))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->port))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress_ip6Address(TransportAddress_ip6Address *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_TransportAddress_ipxAddress(ASN1encoding_t enc, TransportAddress_ipxAddress *val)
{
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->node, 6))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->netnum, 4))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->port, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ipxAddress(ASN1decoding_t dec, TransportAddress_ipxAddress *val)
{
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->node, 6))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->netnum, 4))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->port, 2))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress_ipxAddress(TransportAddress_ipxAddress *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute(ASN1encoding_t enc, TransportAddress_ipSourceRoute *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->ip, 4))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->port))
	return 0;
    if (!ASN1Enc_TransportAddress_ipSourceRoute_route(enc, &(val)->route))
	return 0;
    if (!ASN1Enc_TransportAddress_ipSourceRoute_routing(enc, &(val)->routing))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute(ASN1decoding_t dec, TransportAddress_ipSourceRoute *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->ip, 4))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->port))
	return 0;
    if (!ASN1Dec_TransportAddress_ipSourceRoute_route(dec, &(val)->route))
	return 0;
    if (!ASN1Dec_TransportAddress_ipSourceRoute_routing(dec, &(val)->routing))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute(TransportAddress_ipSourceRoute *val)
{
    if (val) {
	ASN1Free_TransportAddress_ipSourceRoute_route(&(val)->route);
    }
}

static int ASN1CALL ASN1Enc_TransportAddress_ipAddress(ASN1encoding_t enc, TransportAddress_ipAddress *val)
{
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->ip, 4))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->port))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress_ipAddress(ASN1decoding_t dec, TransportAddress_ipAddress *val)
{
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->ip, 4))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->port))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress_ipAddress(TransportAddress_ipAddress *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_H221NonStandard(ASN1encoding_t enc, H221NonStandard *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->t35CountryCode))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->t35Extension))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->manufacturerCode))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H221NonStandard(ASN1decoding_t dec, H221NonStandard *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->t35CountryCode))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->t35Extension))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->manufacturerCode))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_NonStandardIdentifier(ASN1encoding_t enc, NonStandardIdentifier *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.object))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H221NonStandard(enc, &(val)->u.h221NonStandard))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardIdentifier(ASN1decoding_t dec, NonStandardIdentifier *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.object))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H221NonStandard(dec, &(val)->u.h221NonStandard))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardIdentifier(NonStandardIdentifier *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1objectidentifier_free(&(val)->u.object);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_NonStandardParameter(ASN1encoding_t enc, NonStandardParameter *val)
{
    if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->nonStandardIdentifier))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->data))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardParameter(ASN1decoding_t dec, NonStandardParameter *val)
{
    if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->nonStandardIdentifier))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->data))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardParameter(NonStandardParameter *val)
{
    if (val) {
	ASN1Free_NonStandardIdentifier(&(val)->nonStandardIdentifier);
	ASN1octetstring_free(&(val)->data);
    }
}

static int ASN1CALL ASN1Enc_CallType(ASN1encoding_t enc, CallType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CallType(ASN1decoding_t dec, CallType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_Q954Details(ASN1encoding_t enc, Q954Details *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->conferenceCalling))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->threePartyService))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Q954Details(ASN1decoding_t dec, Q954Details *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->conferenceCalling))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->threePartyService))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_QseriesOptions(ASN1encoding_t enc, QseriesOptions *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->q932Full))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->q951Full))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->q952Full))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->q953Full))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->q955Full))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->q956Full))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->q957Full))
	return 0;
    if (!ASN1Enc_Q954Details(enc, &(val)->q954Info))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_QseriesOptions(ASN1decoding_t dec, QseriesOptions *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->q932Full))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->q951Full))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->q952Full))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->q953Full))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->q955Full))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->q956Full))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->q957Full))
	return 0;
    if (!ASN1Dec_Q954Details(dec, &(val)->q954Info))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H310Caps(ASN1encoding_t enc, H310Caps *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H310Caps(ASN1decoding_t dec, H310Caps *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H310Caps(H310Caps *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_NonStandardParameter(&(val)->nonStandardData);
	}
    }
}

static int ASN1CALL ASN1Enc_H320Caps(ASN1encoding_t enc, H320Caps *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H320Caps(ASN1decoding_t dec, H320Caps *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H320Caps(H320Caps *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_NonStandardParameter(&(val)->nonStandardData);
	}
    }
}

static int ASN1CALL ASN1Enc_H321Caps(ASN1encoding_t enc, H321Caps *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H321Caps(ASN1decoding_t dec, H321Caps *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H321Caps(H321Caps *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_NonStandardParameter(&(val)->nonStandardData);
	}
    }
}

static int ASN1CALL ASN1Enc_H322Caps(ASN1encoding_t enc, H322Caps *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H322Caps(ASN1decoding_t dec, H322Caps *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H322Caps(H322Caps *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_NonStandardParameter(&(val)->nonStandardData);
	}
    }
}

static int ASN1CALL ASN1Enc_H323Caps(ASN1encoding_t enc, H323Caps *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H323Caps(ASN1decoding_t dec, H323Caps *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H323Caps(H323Caps *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_NonStandardParameter(&(val)->nonStandardData);
	}
    }
}

static int ASN1CALL ASN1Enc_H324Caps(ASN1encoding_t enc, H324Caps *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H324Caps(ASN1decoding_t dec, H324Caps *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H324Caps(H324Caps *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_NonStandardParameter(&(val)->nonStandardData);
	}
    }
}

static int ASN1CALL ASN1Enc_VoiceCaps(ASN1encoding_t enc, VoiceCaps *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_VoiceCaps(ASN1decoding_t dec, VoiceCaps *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_VoiceCaps(VoiceCaps *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_NonStandardParameter(&(val)->nonStandardData);
	}
    }
}

static int ASN1CALL ASN1Enc_T120OnlyCaps(ASN1encoding_t enc, T120OnlyCaps *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_T120OnlyCaps(ASN1decoding_t dec, T120OnlyCaps *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_T120OnlyCaps(T120OnlyCaps *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_NonStandardParameter(&(val)->nonStandardData);
	}
    }
}

static int ASN1CALL ASN1Enc_McuInfo(ASN1encoding_t enc, McuInfo *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_McuInfo(ASN1decoding_t dec, McuInfo *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_McuInfo(McuInfo *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_NonStandardParameter(&(val)->nonStandardData);
	}
    }
}

static int ASN1CALL ASN1Enc_TerminalInfo(ASN1encoding_t enc, TerminalInfo *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalInfo(ASN1decoding_t dec, TerminalInfo *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TerminalInfo(TerminalInfo *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_NonStandardParameter(&(val)->nonStandardData);
	}
    }
}

static int ASN1CALL ASN1Enc_GatekeeperInfo(ASN1encoding_t enc, GatekeeperInfo *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_GatekeeperInfo(ASN1decoding_t dec, GatekeeperInfo *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_GatekeeperInfo(GatekeeperInfo *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_NonStandardParameter(&(val)->nonStandardData);
	}
    }
}

static int ASN1CALL ASN1Enc_VendorIdentifier(ASN1encoding_t enc, VendorIdentifier *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1Enc_H221NonStandard(enc, &(val)->vendor))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->productId, 1, 256, 8))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->versionId, 1, 256, 8))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_VendorIdentifier(ASN1decoding_t dec, VendorIdentifier *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1Dec_H221NonStandard(dec, &(val)->vendor))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->productId, 1, 256, 8))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->versionId, 1, 256, 8))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_VendorIdentifier(VendorIdentifier *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	}
    }
}

static int ASN1CALL ASN1Enc_SupportedProtocols(ASN1encoding_t enc, SupportedProtocols *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandardData))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H310Caps(enc, &(val)->u.h310))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_H320Caps(enc, &(val)->u.h320))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_H321Caps(enc, &(val)->u.h321))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_H322Caps(enc, &(val)->u.h322))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_H323Caps(enc, &(val)->u.h323))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_H324Caps(enc, &(val)->u.h324))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_VoiceCaps(enc, &(val)->u.voice))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_T120OnlyCaps(enc, &(val)->u.t120_only))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SupportedProtocols(ASN1decoding_t dec, SupportedProtocols *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandardData))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H310Caps(dec, &(val)->u.h310))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_H320Caps(dec, &(val)->u.h320))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_H321Caps(dec, &(val)->u.h321))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_H322Caps(dec, &(val)->u.h322))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_H323Caps(dec, &(val)->u.h323))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_H324Caps(dec, &(val)->u.h324))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_VoiceCaps(dec, &(val)->u.voice))
	    return 0;
	break;
    case 9:
	if (!ASN1Dec_T120OnlyCaps(dec, &(val)->u.t120_only))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SupportedProtocols(SupportedProtocols *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardData);
	    break;
	case 2:
	    ASN1Free_H310Caps(&(val)->u.h310);
	    break;
	case 3:
	    ASN1Free_H320Caps(&(val)->u.h320);
	    break;
	case 4:
	    ASN1Free_H321Caps(&(val)->u.h321);
	    break;
	case 5:
	    ASN1Free_H322Caps(&(val)->u.h322);
	    break;
	case 6:
	    ASN1Free_H323Caps(&(val)->u.h323);
	    break;
	case 7:
	    ASN1Free_H324Caps(&(val)->u.h324);
	    break;
	case 8:
	    ASN1Free_VoiceCaps(&(val)->u.voice);
	    break;
	case 9:
	    ASN1Free_T120OnlyCaps(&(val)->u.t120_only);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_GatewayInfo(ASN1encoding_t enc, GatewayInfo *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_GatewayInfo_protocol(enc, &(val)->protocol))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_GatewayInfo(ASN1decoding_t dec, GatewayInfo *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_GatewayInfo_protocol(dec, &(val)->protocol))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_GatewayInfo(GatewayInfo *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_GatewayInfo_protocol(&(val)->protocol);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_NonStandardParameter(&(val)->nonStandardData);
	}
    }
}

static int ASN1CALL ASN1Enc_EndpointType(ASN1encoding_t enc, EndpointType *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_VendorIdentifier(enc, &(val)->vendor))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_GatekeeperInfo(enc, &(val)->gatekeeper))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_GatewayInfo(enc, &(val)->gateway))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_McuInfo(enc, &(val)->mcu))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Enc_TerminalInfo(enc, &(val)->terminal))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->mc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->undefinedNode))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EndpointType(ASN1decoding_t dec, EndpointType *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_VendorIdentifier(dec, &(val)->vendor))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_GatekeeperInfo(dec, &(val)->gatekeeper))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_GatewayInfo(dec, &(val)->gateway))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_McuInfo(dec, &(val)->mcu))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Dec_TerminalInfo(dec, &(val)->terminal))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->mc))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->undefinedNode))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EndpointType(EndpointType *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_NonStandardParameter(&(val)->nonStandardData);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_VendorIdentifier(&(val)->vendor);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_GatekeeperInfo(&(val)->gatekeeper);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_GatewayInfo(&(val)->gateway);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_McuInfo(&(val)->mcu);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_TerminalInfo(&(val)->terminal);
	}
    }
}

static int ASN1CALL ASN1Enc_TransportAddress(ASN1encoding_t enc, TransportAddress *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_TransportAddress_ipAddress(enc, &(val)->u.ipAddress))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_TransportAddress_ipSourceRoute(enc, &(val)->u.ipSourceRoute))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_TransportAddress_ipxAddress(enc, &(val)->u.ipxAddress))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_TransportAddress_ip6Address(enc, &(val)->u.ip6Address))
	    return 0;
	break;
    case 5:
	if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->u.netBios, 16))
	    return 0;
	break;
    case 6:
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->u.nsap, 1, 20, 5))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandardAddress))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TransportAddress(ASN1decoding_t dec, TransportAddress *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_TransportAddress_ipAddress(dec, &(val)->u.ipAddress))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_TransportAddress_ipSourceRoute(dec, &(val)->u.ipSourceRoute))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_TransportAddress_ipxAddress(dec, &(val)->u.ipxAddress))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_TransportAddress_ip6Address(dec, &(val)->u.ip6Address))
	    return 0;
	break;
    case 5:
	if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->u.netBios, 16))
	    return 0;
	break;
    case 6:
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->u.nsap, 1, 20, 5))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandardAddress))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransportAddress(TransportAddress *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_TransportAddress_ipAddress(&(val)->u.ipAddress);
	    break;
	case 2:
	    ASN1Free_TransportAddress_ipSourceRoute(&(val)->u.ipSourceRoute);
	    break;
	case 3:
	    ASN1Free_TransportAddress_ipxAddress(&(val)->u.ipxAddress);
	    break;
	case 4:
	    ASN1Free_TransportAddress_ip6Address(&(val)->u.ip6Address);
	    break;
	case 5:
	    break;
	case 6:
	    break;
	case 7:
	    ASN1Free_NonStandardParameter(&(val)->u.nonStandardAddress);
	    break;
	}
    }
}

static ASN1stringtableentry_t AliasAddress_e164_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t AliasAddress_e164_StringTable = {
    4, AliasAddress_e164_StringTableEntries
};

static int ASN1CALL ASN1Enc_AliasAddress(ASN1encoding_t enc, AliasAddress *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	t = lstrlenA((val)->u.e164);
	if (!ASN1PEREncBitVal(enc, 7, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->u.e164, 4, &AliasAddress_e164_StringTable))
	    return 0;
	break;
    case 2:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->u.h323_ID).length - 1))
	    return 0;
	if (!ASN1PEREncChar16String(enc, ((val)->u.h323_ID).length, ((val)->u.h323_ID).value, 16))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AliasAddress(ASN1decoding_t dec, AliasAddress *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecU32Val(dec, 7, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.e164, 4, &AliasAddress_e164_StringTable))
	    return 0;
	break;
    case 2:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, 8, &((val)->u.h323_ID).length))
	    return 0;
	((val)->u.h323_ID).length += 1;
	if (!ASN1PERDecChar16String(dec, ((val)->u.h323_ID).length, &((val)->u.h323_ID).value, 16))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AliasAddress(AliasAddress *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    break;
	case 2:
	    ASN1char16string_free(&(val)->u.h323_ID);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE(ASN1encoding_t enc, Setup_UUIE *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
	return 0;
    if (!ASN1PEREncBits(enc, 7, (val)->o))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->h245Address))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_Setup_UUIE_sourceAddress(enc, &(val)->sourceAddress))
	    return 0;
    }
    if (!ASN1Enc_EndpointType(enc, &(val)->sourceInfo))
	return 0;
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_Setup_UUIE_destinationAddress(enc, &(val)->destinationAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->destCallSignalAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_Setup_UUIE_destExtraCallInfo(enc, &(val)->destExtraCallInfo))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Enc_Setup_UUIE_destExtraCRV(enc, &(val)->destExtraCRV))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->activeMC))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if (!ASN1Enc_Setup_UUIE_conferenceGoal(enc, &(val)->conferenceGoal))
	return 0;
    if ((val)->o[0] & 0x2) {
	if (!ASN1Enc_QseriesOptions(enc, &(val)->callServices))
	    return 0;
    }
    if (!ASN1Enc_CallType(enc, &(val)->callType))
	return 0;
    if (y) {
	if (!ASN1PEREncNormallySmallBits(enc, 2, (val)->o + 1))
	    return 0;
	if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1Enc_TransportAddress(ee, &(val)->sourceCallSignalAddress))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1Enc_AliasAddress(ee, &(val)->remoteExtensionAddress))
		return 0;
	    if (!ASN1PEREncFlushFragmentedToParent(ee))
		return 0;
	}
	ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE(ASN1decoding_t dec, Setup_UUIE *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 7, (val)->o))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->h245Address))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_Setup_UUIE_sourceAddress(dec, &(val)->sourceAddress))
	    return 0;
    }
    if (!ASN1Dec_EndpointType(dec, &(val)->sourceInfo))
	return 0;
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_Setup_UUIE_destinationAddress(dec, &(val)->destinationAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->destCallSignalAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_Setup_UUIE_destExtraCallInfo(dec, &(val)->destExtraCallInfo))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Dec_Setup_UUIE_destExtraCRV(dec, &(val)->destExtraCRV))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->activeMC))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if (!ASN1Dec_Setup_UUIE_conferenceGoal(dec, &(val)->conferenceGoal))
	return 0;
    if ((val)->o[0] & 0x2) {
	if (!ASN1Dec_QseriesOptions(dec, &(val)->callServices))
	    return 0;
    }
    if (!ASN1Dec_CallType(dec, &(val)->callType))
	return 0;
    if (!y) {
	ZeroMemory((val)->o + 1, 1);
    } else {
	if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
	    return 0;
	if ((val)->o[1] & 0x80) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_TransportAddress(dd, &(val)->sourceCallSignalAddress))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	if ((val)->o[1] & 0x40) {
	    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
		return 0;
	    if (ASN1_CreateDecoder(dec->module, &dd, db, ds, dec) < 0)
		return 0;
	    if (!ASN1Dec_AliasAddress(dd, &(val)->remoteExtensionAddress))
		return 0;
	    ASN1_CloseDecoder(dd);
	    ASN1Free(db);
	}
	for (i = 0; i < e; i++) {
	    if (!ASN1PERDecSkipFragmented(dec, 8))
		return 0;
	}
    }
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE(Setup_UUIE *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_TransportAddress(&(val)->h245Address);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_Setup_UUIE_sourceAddress(&(val)->sourceAddress);
	}
	ASN1Free_EndpointType(&(val)->sourceInfo);
	if ((val)->o[0] & 0x20) {
	    ASN1Free_Setup_UUIE_destinationAddress(&(val)->destinationAddress);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_TransportAddress(&(val)->destCallSignalAddress);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_Setup_UUIE_destExtraCallInfo(&(val)->destExtraCallInfo);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_Setup_UUIE_destExtraCRV(&(val)->destExtraCRV);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_TransportAddress(&(val)->sourceCallSignalAddress);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_AliasAddress(&(val)->remoteExtensionAddress);
	}
    }
}

static int ASN1CALL ASN1Enc_CallProceeding_UUIE(ASN1encoding_t enc, CallProceeding_UUIE *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if (!ASN1Enc_EndpointType(enc, &(val)->destinationInfo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->h245Address))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CallProceeding_UUIE(ASN1decoding_t dec, CallProceeding_UUIE *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if (!ASN1Dec_EndpointType(dec, &(val)->destinationInfo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->h245Address))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CallProceeding_UUIE(CallProceeding_UUIE *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	ASN1Free_EndpointType(&(val)->destinationInfo);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_TransportAddress(&(val)->h245Address);
	}
    }
}

static int ASN1CALL ASN1Enc_Connect_UUIE(ASN1encoding_t enc, Connect_UUIE *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->h245Address))
	    return 0;
    }
    if (!ASN1Enc_EndpointType(enc, &(val)->destinationInfo))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Connect_UUIE(ASN1decoding_t dec, Connect_UUIE *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->h245Address))
	    return 0;
    }
    if (!ASN1Dec_EndpointType(dec, &(val)->destinationInfo))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Connect_UUIE(Connect_UUIE *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_TransportAddress(&(val)->h245Address);
	}
	ASN1Free_EndpointType(&(val)->destinationInfo);
    }
}

static int ASN1CALL ASN1Enc_Alerting_UUIE(ASN1encoding_t enc, Alerting_UUIE *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if (!ASN1Enc_EndpointType(enc, &(val)->destinationInfo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->h245Address))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Alerting_UUIE(ASN1decoding_t dec, Alerting_UUIE *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if (!ASN1Dec_EndpointType(dec, &(val)->destinationInfo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->h245Address))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Alerting_UUIE(Alerting_UUIE *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	ASN1Free_EndpointType(&(val)->destinationInfo);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_TransportAddress(&(val)->h245Address);
	}
    }
}

static int ASN1CALL ASN1Enc_UI_UUIE(ASN1encoding_t enc, UI_UUIE *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UI_UUIE(ASN1decoding_t dec, UI_UUIE *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UI_UUIE(UI_UUIE *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
    }
}

static int ASN1CALL ASN1Enc_ReleaseCompleteReason(ASN1encoding_t enc, ReleaseCompleteReason *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ReleaseCompleteReason(ASN1decoding_t dec, ReleaseCompleteReason *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ReleaseComplete_UUIE(ASN1encoding_t enc, ReleaseComplete_UUIE *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_ReleaseCompleteReason(enc, &(val)->reason))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ReleaseComplete_UUIE(ASN1decoding_t dec, ReleaseComplete_UUIE *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_ReleaseCompleteReason(dec, &(val)->reason))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ReleaseComplete_UUIE(ReleaseComplete_UUIE *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
    }
}

static int ASN1CALL ASN1Enc_FacilityReason(ASN1encoding_t enc, FacilityReason *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_FacilityReason(ASN1decoding_t dec, FacilityReason *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_Facility_UUIE(ASN1encoding_t enc, Facility_UUIE *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_TransportAddress(enc, &(val)->alternativeAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_Facility_UUIE_alternativeAliasAddress(enc, &(val)->alternativeAliasAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	    return 0;
    }
    if (!ASN1Enc_FacilityReason(enc, &(val)->reason))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Facility_UUIE(ASN1decoding_t dec, Facility_UUIE *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_TransportAddress(dec, &(val)->alternativeAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_Facility_UUIE_alternativeAliasAddress(dec, &(val)->alternativeAliasAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 16))
	    return 0;
    }
    if (!ASN1Dec_FacilityReason(dec, &(val)->reason))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Facility_UUIE(Facility_UUIE *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_TransportAddress(&(val)->alternativeAddress);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_Facility_UUIE_alternativeAliasAddress(&(val)->alternativeAliasAddress);
	}
	if ((val)->o[0] & 0x20) {
	}
    }
}

static int ASN1CALL ASN1Enc_H323_UU_PDU_h323_message_body(ASN1encoding_t enc, H323_UU_PDU_h323_message_body *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_Setup_UUIE(enc, &(val)->u.setup))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_CallProceeding_UUIE(enc, &(val)->u.callProceeding))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_Connect_UUIE(enc, &(val)->u.connect))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_Alerting_UUIE(enc, &(val)->u.alerting))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_UI_UUIE(enc, &(val)->u.userInformation))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_ReleaseComplete_UUIE(enc, &(val)->u.releaseComplete))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_Facility_UUIE(enc, &(val)->u.facility))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H323_UU_PDU_h323_message_body(ASN1decoding_t dec, H323_UU_PDU_h323_message_body *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_Setup_UUIE(dec, &(val)->u.setup))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_CallProceeding_UUIE(dec, &(val)->u.callProceeding))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_Connect_UUIE(dec, &(val)->u.connect))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_Alerting_UUIE(dec, &(val)->u.alerting))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_UI_UUIE(dec, &(val)->u.userInformation))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_ReleaseComplete_UUIE(dec, &(val)->u.releaseComplete))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_Facility_UUIE(dec, &(val)->u.facility))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H323_UU_PDU_h323_message_body(H323_UU_PDU_h323_message_body *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_Setup_UUIE(&(val)->u.setup);
	    break;
	case 2:
	    ASN1Free_CallProceeding_UUIE(&(val)->u.callProceeding);
	    break;
	case 3:
	    ASN1Free_Connect_UUIE(&(val)->u.connect);
	    break;
	case 4:
	    ASN1Free_Alerting_UUIE(&(val)->u.alerting);
	    break;
	case 5:
	    ASN1Free_UI_UUIE(&(val)->u.userInformation);
	    break;
	case 6:
	    ASN1Free_ReleaseComplete_UUIE(&(val)->u.releaseComplete);
	    break;
	case 7:
	    ASN1Free_Facility_UUIE(&(val)->u.facility);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_Facility_UUIE_alternativeAliasAddress(ASN1encoding_t enc, PFacility_UUIE_alternativeAliasAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Facility_UUIE_alternativeAliasAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_Facility_UUIE_alternativeAliasAddress_ElmFn(ASN1encoding_t enc, PFacility_UUIE_alternativeAliasAddress val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Facility_UUIE_alternativeAliasAddress(ASN1decoding_t dec, PFacility_UUIE_alternativeAliasAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Facility_UUIE_alternativeAliasAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Facility_UUIE_alternativeAliasAddress_ElmFn(ASN1decoding_t dec, PFacility_UUIE_alternativeAliasAddress val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Facility_UUIE_alternativeAliasAddress(PFacility_UUIE_alternativeAliasAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Facility_UUIE_alternativeAliasAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Facility_UUIE_alternativeAliasAddress_ElmFn(PFacility_UUIE_alternativeAliasAddress val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCallInfo(ASN1encoding_t enc, PSetup_UUIE_destExtraCallInfo *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Setup_UUIE_destExtraCallInfo_ElmFn);
}

static int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PSetup_UUIE_destExtraCallInfo val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCallInfo(ASN1decoding_t dec, PSetup_UUIE_destExtraCallInfo *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Setup_UUIE_destExtraCallInfo_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PSetup_UUIE_destExtraCallInfo val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE_destExtraCallInfo(PSetup_UUIE_destExtraCallInfo *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Setup_UUIE_destExtraCallInfo_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Setup_UUIE_destExtraCallInfo_ElmFn(PSetup_UUIE_destExtraCallInfo val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE_destinationAddress(ASN1encoding_t enc, PSetup_UUIE_destinationAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Setup_UUIE_destinationAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_Setup_UUIE_destinationAddress_ElmFn(ASN1encoding_t enc, PSetup_UUIE_destinationAddress val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_destinationAddress(ASN1decoding_t dec, PSetup_UUIE_destinationAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Setup_UUIE_destinationAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Setup_UUIE_destinationAddress_ElmFn(ASN1decoding_t dec, PSetup_UUIE_destinationAddress val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE_destinationAddress(PSetup_UUIE_destinationAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Setup_UUIE_destinationAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Setup_UUIE_destinationAddress_ElmFn(PSetup_UUIE_destinationAddress val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Setup_UUIE_sourceAddress(ASN1encoding_t enc, PSetup_UUIE_sourceAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_Setup_UUIE_sourceAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_Setup_UUIE_sourceAddress_ElmFn(ASN1encoding_t enc, PSetup_UUIE_sourceAddress val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Setup_UUIE_sourceAddress(ASN1decoding_t dec, PSetup_UUIE_sourceAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_Setup_UUIE_sourceAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_Setup_UUIE_sourceAddress_ElmFn(ASN1decoding_t dec, PSetup_UUIE_sourceAddress val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Setup_UUIE_sourceAddress(PSetup_UUIE_sourceAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_Setup_UUIE_sourceAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_Setup_UUIE_sourceAddress_ElmFn(PSetup_UUIE_sourceAddress val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_GatewayInfo_protocol(ASN1encoding_t enc, PGatewayInfo_protocol *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_GatewayInfo_protocol_ElmFn);
}

static int ASN1CALL ASN1Enc_GatewayInfo_protocol_ElmFn(ASN1encoding_t enc, PGatewayInfo_protocol val)
{
    if (!ASN1Enc_SupportedProtocols(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GatewayInfo_protocol(ASN1decoding_t dec, PGatewayInfo_protocol *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_GatewayInfo_protocol_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_GatewayInfo_protocol_ElmFn(ASN1decoding_t dec, PGatewayInfo_protocol val)
{
    if (!ASN1Dec_SupportedProtocols(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GatewayInfo_protocol(PGatewayInfo_protocol *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GatewayInfo_protocol_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GatewayInfo_protocol_ElmFn(PGatewayInfo_protocol val)
{
    if (val) {
	ASN1Free_SupportedProtocols(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H323_UU_PDU(ASN1encoding_t enc, H323_UU_PDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_H323_UU_PDU_h323_message_body(enc, &(val)->h323_message_body))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandardData))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H323_UU_PDU(ASN1decoding_t dec, H323_UU_PDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_H323_UU_PDU_h323_message_body(dec, &(val)->h323_message_body))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandardData))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H323_UU_PDU(H323_UU_PDU *val)
{
    if (val) {
	ASN1Free_H323_UU_PDU_h323_message_body(&(val)->h323_message_body);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_NonStandardParameter(&(val)->nonStandardData);
	}
    }
}

static int ASN1CALL ASN1Enc_H323_UserInformation(ASN1encoding_t enc, H323_UserInformation *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_H323_UU_PDU(enc, &(val)->h323_uu_pdu))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_H323_UserInformation_user_data(enc, &(val)->user_data))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H323_UserInformation(ASN1decoding_t dec, H323_UserInformation *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_H323_UU_PDU(dec, &(val)->h323_uu_pdu))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_H323_UserInformation_user_data(dec, &(val)->user_data))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H323_UserInformation(H323_UserInformation *val)
{
    if (val) {
	ASN1Free_H323_UU_PDU(&(val)->h323_uu_pdu);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_H323_UserInformation_user_data(&(val)->user_data);
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\q931\q931asn.h ===
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for H.323 Messages Call Setup (Q.931) */

#ifndef _Q931ASN_Module_H_
#define _Q931ASN_Module_H_

#include "msper.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct TransportAddress_ipSourceRoute_route * PTransportAddress_ipSourceRoute_route;

typedef struct Setup_UUIE_destExtraCRV * PSetup_UUIE_destExtraCRV;

typedef struct Facility_UUIE_alternativeAliasAddress * PFacility_UUIE_alternativeAliasAddress;

typedef struct Setup_UUIE_destExtraCallInfo * PSetup_UUIE_destExtraCallInfo;

typedef struct Setup_UUIE_destinationAddress * PSetup_UUIE_destinationAddress;

typedef struct Setup_UUIE_sourceAddress * PSetup_UUIE_sourceAddress;

typedef struct GatewayInfo_protocol * PGatewayInfo_protocol;

typedef struct TransportAddress_ipSourceRoute_route_Seq {
    ASN1uint32_t length;
    ASN1octet_t value[4];
} TransportAddress_ipSourceRoute_route_Seq;

typedef struct ConferenceIdentifier {
    ASN1uint32_t length;
    ASN1octet_t value[16];
} ConferenceIdentifier;

typedef ASN1uint16_t CallReferenceValue;

typedef ASN1objectidentifier_t ProtocolIdentifier;

typedef struct TransportAddress_ipSourceRoute_routing {
    ASN1choice_t choice;
#   define strict_chosen 1
#   define loose_chosen 2
} TransportAddress_ipSourceRoute_routing;

typedef struct TransportAddress_ipSourceRoute_route {
    PTransportAddress_ipSourceRoute_route next;
    TransportAddress_ipSourceRoute_route_Seq value;
} TransportAddress_ipSourceRoute_route_Element;

typedef struct H323_UserInformation_user_data {
    ASN1uint16_t protocol_discriminator;
    struct H323_UserInformation_user_data_user_information_user_information {
	ASN1uint32_t length;
	ASN1octet_t value[131];
    } user_information;
} H323_UserInformation_user_data;

typedef struct Setup_UUIE_conferenceGoal {
    ASN1choice_t choice;
#   define create_chosen 1
#   define join_chosen 2
#   define invite_chosen 3
} Setup_UUIE_conferenceGoal;

typedef struct Setup_UUIE_destExtraCRV {
    PSetup_UUIE_destExtraCRV next;
    CallReferenceValue value;
} Setup_UUIE_destExtraCRV_Element;

typedef struct TransportAddress_ip6Address {
    struct TransportAddress_ip6Address_ip_ip {
	ASN1uint32_t length;
	ASN1octet_t value[16];
    } ip;
    ASN1uint16_t port;
} TransportAddress_ip6Address;

typedef struct TransportAddress_ipxAddress {
    struct TransportAddress_ipxAddress_node_node {
	ASN1uint32_t length;
	ASN1octet_t value[6];
    } node;
    struct TransportAddress_ipxAddress_netnum_netnum {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } netnum;
    struct TransportAddress_ipxAddress_port_port {
	ASN1uint32_t length;
	ASN1octet_t value[2];
    } port;
} TransportAddress_ipxAddress;

typedef struct TransportAddress_ipSourceRoute {
    struct TransportAddress_ipSourceRoute_ip_ip {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } ip;
    ASN1uint16_t port;
    PTransportAddress_ipSourceRoute_route route;
    TransportAddress_ipSourceRoute_routing routing;
} TransportAddress_ipSourceRoute;

typedef struct TransportAddress_ipAddress {
    struct TransportAddress_ipAddress_ip_ip {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } ip;
    ASN1uint16_t port;
} TransportAddress_ipAddress;

typedef struct H221NonStandard {
    ASN1uint16_t t35CountryCode;
    ASN1uint16_t t35Extension;
    ASN1uint16_t manufacturerCode;
} H221NonStandard;

typedef struct NonStandardIdentifier {
    ASN1choice_t choice;
    union {
#	define object_chosen 1
	ASN1objectidentifier_t object;
#	define h221NonStandard_chosen 2
	H221NonStandard h221NonStandard;
    } u;
} NonStandardIdentifier;

typedef struct NonStandardParameter {
    NonStandardIdentifier nonStandardIdentifier;
    ASN1octetstring_t data;
} NonStandardParameter;

typedef struct CallType {
    ASN1choice_t choice;
#   define pointToPoint_chosen 1
#   define oneToN_chosen 2
#   define nToOne_chosen 3
#   define nToN_chosen 4
} CallType;

typedef struct Q954Details {
    ASN1bool_t conferenceCalling;
    ASN1bool_t threePartyService;
} Q954Details;

typedef struct QseriesOptions {
    ASN1bool_t q932Full;
    ASN1bool_t q951Full;
    ASN1bool_t q952Full;
    ASN1bool_t q953Full;
    ASN1bool_t q955Full;
    ASN1bool_t q956Full;
    ASN1bool_t q957Full;
    Q954Details q954Info;
} QseriesOptions;

typedef struct H310Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define H310Caps_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} H310Caps;

typedef struct H320Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define H320Caps_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} H320Caps;

typedef struct H321Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define H321Caps_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} H321Caps;

typedef struct H322Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define H322Caps_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} H322Caps;

typedef struct H323Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define H323Caps_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} H323Caps;

typedef struct H324Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define H324Caps_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} H324Caps;

typedef struct VoiceCaps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define VoiceCaps_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} VoiceCaps;

typedef struct T120OnlyCaps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define T120OnlyCaps_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} T120OnlyCaps;

typedef struct McuInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define McuInfo_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} McuInfo;

typedef struct TerminalInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define TerminalInfo_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} TerminalInfo;

typedef struct GatekeeperInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define GatekeeperInfo_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} GatekeeperInfo;

typedef struct VendorIdentifier {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    H221NonStandard vendor;
#   define productId_present 0x80
    struct VendorIdentifier_productId_productId {
	ASN1uint32_t length;
	ASN1octet_t value[256];
    } productId;
#   define versionId_present 0x40
    struct VendorIdentifier_versionId_versionId {
	ASN1uint32_t length;
	ASN1octet_t value[256];
    } versionId;
} VendorIdentifier;

typedef struct SupportedProtocols {
    ASN1choice_t choice;
    union {
#	define nonStandardData_chosen 1
	NonStandardParameter nonStandardData;
#	define h310_chosen 2
	H310Caps h310;
#	define h320_chosen 3
	H320Caps h320;
#	define h321_chosen 4
	H321Caps h321;
#	define h322_chosen 5
	H322Caps h322;
#	define h323_chosen 6
	H323Caps h323;
#	define h324_chosen 7
	H324Caps h324;
#	define voice_chosen 8
	VoiceCaps voice;
#	define t120_only_chosen 9
	T120OnlyCaps t120_only;
    } u;
} SupportedProtocols;

typedef struct GatewayInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define protocol_present 0x80
    PGatewayInfo_protocol protocol;
#   define GatewayInfo_nonStandardData_present 0x40
    NonStandardParameter nonStandardData;
} GatewayInfo;

typedef struct EndpointType {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define EndpointType_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
#   define vendor_present 0x40
    VendorIdentifier vendor;
#   define gatekeeper_present 0x20
    GatekeeperInfo gatekeeper;
#   define gateway_present 0x10
    GatewayInfo gateway;
#   define mcu_present 0x8
    McuInfo mcu;
#   define terminal_present 0x4
    TerminalInfo terminal;
    ASN1bool_t mc;
    ASN1bool_t undefinedNode;
} EndpointType;

typedef struct TransportAddress {
    ASN1choice_t choice;
    union {
#	define ipAddress_chosen 1
	TransportAddress_ipAddress ipAddress;
#	define ipSourceRoute_chosen 2
	TransportAddress_ipSourceRoute ipSourceRoute;
#	define ipxAddress_chosen 3
	TransportAddress_ipxAddress ipxAddress;
#	define ip6Address_chosen 4
	TransportAddress_ip6Address ip6Address;
#	define netBios_chosen 5
	struct TransportAddress_netBios_netBios {
	    ASN1uint32_t length;
	    ASN1octet_t value[16];
	} netBios;
#	define nsap_chosen 6
	struct TransportAddress_nsap_nsap {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsap;
#	define nonStandardAddress_chosen 7
	NonStandardParameter nonStandardAddress;
    } u;
} TransportAddress;

typedef struct AliasAddress {
    ASN1choice_t choice;
    union {
#	define e164_chosen 1
	ASN1char_t e164[129];
#	define h323_ID_chosen 2
	ASN1char16string_t h323_ID;
    } u;
} AliasAddress;

typedef struct Setup_UUIE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    ProtocolIdentifier protocolIdentifier;
#   define Setup_UUIE_h245Address_present 0x80
    TransportAddress h245Address;
#   define sourceAddress_present 0x40
    PSetup_UUIE_sourceAddress sourceAddress;
    EndpointType sourceInfo;
#   define destinationAddress_present 0x20
    PSetup_UUIE_destinationAddress destinationAddress;
#   define destCallSignalAddress_present 0x10
    TransportAddress destCallSignalAddress;
#   define destExtraCallInfo_present 0x8
    PSetup_UUIE_destExtraCallInfo destExtraCallInfo;
#   define destExtraCRV_present 0x4
    PSetup_UUIE_destExtraCRV destExtraCRV;
    ASN1bool_t activeMC;
    ConferenceIdentifier conferenceID;
    Setup_UUIE_conferenceGoal conferenceGoal;
#   define callServices_present 0x2
    QseriesOptions callServices;
    CallType callType;
#   define sourceCallSignalAddress_present 0x8000
    TransportAddress sourceCallSignalAddress;
#   define remoteExtensionAddress_present 0x4000
    AliasAddress remoteExtensionAddress;
} Setup_UUIE;

typedef struct CallProceeding_UUIE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ProtocolIdentifier protocolIdentifier;
    EndpointType destinationInfo;
#   define CallProceeding_UUIE_h245Address_present 0x80
    TransportAddress h245Address;
} CallProceeding_UUIE;

typedef struct Connect_UUIE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ProtocolIdentifier protocolIdentifier;
#   define Connect_UUIE_h245Address_present 0x80
    TransportAddress h245Address;
    EndpointType destinationInfo;
    ConferenceIdentifier conferenceID;
} Connect_UUIE;

typedef struct Alerting_UUIE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ProtocolIdentifier protocolIdentifier;
    EndpointType destinationInfo;
#   define Alerting_UUIE_h245Address_present 0x80
    TransportAddress h245Address;
} Alerting_UUIE;

typedef struct UI_UUIE {
    ProtocolIdentifier protocolIdentifier;
} UI_UUIE;

typedef struct ReleaseCompleteReason {
    ASN1choice_t choice;
#   define noBandwidth_chosen 1
#   define gatekeeperResources_chosen 2
#   define unreachableDestination_chosen 3
#   define destinationRejection_chosen 4
#   define invalidRevision_chosen 5
#   define noPermission_chosen 6
#   define unreachableGatekeeper_chosen 7
#   define gatewayResources_chosen 8
#   define badFormatAddress_chosen 9
#   define adaptiveBusy_chosen 10
#   define inConf_chosen 11
#   define ReleaseCompleteReason_undefinedReason_chosen 12
#   define facilityCallDeflection_chosen 13
} ReleaseCompleteReason;

typedef struct ReleaseComplete_UUIE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ProtocolIdentifier protocolIdentifier;
#   define reason_present 0x80
    ReleaseCompleteReason reason;
} ReleaseComplete_UUIE;

typedef struct FacilityReason {
    ASN1choice_t choice;
#   define routeCallToGatekeeper_chosen 1
#   define callForwarded_chosen 2
#   define routeCallToMC_chosen 3
#   define FacilityReason_undefinedReason_chosen 4
} FacilityReason;

typedef struct Facility_UUIE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ProtocolIdentifier protocolIdentifier;
#   define alternativeAddress_present 0x80
    TransportAddress alternativeAddress;
#   define alternativeAliasAddress_present 0x40
    PFacility_UUIE_alternativeAliasAddress alternativeAliasAddress;
#   define conferenceID_present 0x20
    ConferenceIdentifier conferenceID;
    FacilityReason reason;
} Facility_UUIE;

typedef struct H323_UU_PDU_h323_message_body {
    ASN1choice_t choice;
    union {
#	define setup_chosen 1
	Setup_UUIE setup;
#	define callProceeding_chosen 2
	CallProceeding_UUIE callProceeding;
#	define connect_chosen 3
	Connect_UUIE connect;
#	define alerting_chosen 4
	Alerting_UUIE alerting;
#	define userInformation_chosen 5
	UI_UUIE userInformation;
#	define releaseComplete_chosen 6
	ReleaseComplete_UUIE releaseComplete;
#	define facility_chosen 7
	Facility_UUIE facility;
    } u;
} H323_UU_PDU_h323_message_body;

typedef struct Facility_UUIE_alternativeAliasAddress {
    PFacility_UUIE_alternativeAliasAddress next;
    AliasAddress value;
} Facility_UUIE_alternativeAliasAddress_Element;

typedef struct Setup_UUIE_destExtraCallInfo {
    PSetup_UUIE_destExtraCallInfo next;
    AliasAddress value;
} Setup_UUIE_destExtraCallInfo_Element;

typedef struct Setup_UUIE_destinationAddress {
    PSetup_UUIE_destinationAddress next;
    AliasAddress value;
} Setup_UUIE_destinationAddress_Element;

typedef struct Setup_UUIE_sourceAddress {
    PSetup_UUIE_sourceAddress next;
    AliasAddress value;
} Setup_UUIE_sourceAddress_Element;

typedef struct GatewayInfo_protocol {
    PGatewayInfo_protocol next;
    SupportedProtocols value;
} GatewayInfo_protocol_Element;

typedef struct H323_UU_PDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    H323_UU_PDU_h323_message_body h323_message_body;
#   define H323_UU_PDU_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} H323_UU_PDU;

typedef struct H323_UserInformation {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    H323_UU_PDU h323_uu_pdu;
#   define user_data_present 0x80
    H323_UserInformation_user_data user_data;
} H323_UserInformation;
#define H323_UserInformation_PDU 0
#define SIZE_Q931ASN_Module_PDU_0 sizeof(H323_UserInformation)


extern ASN1module_t Q931ASN_Module;
extern void ASN1CALL Q931ASN_Module_Startup(void);
extern void ASN1CALL Q931ASN_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */
    extern int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_route_ElmFn(ASN1encoding_t enc, PTransportAddress_ipSourceRoute_route val);
    extern int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_route_ElmFn(ASN1decoding_t dec, PTransportAddress_ipSourceRoute_route val);
	extern void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute_route_ElmFn(PTransportAddress_ipSourceRoute_route val);
    extern int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCRV_ElmFn(ASN1encoding_t enc, PSetup_UUIE_destExtraCRV val);
    extern int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCRV_ElmFn(ASN1decoding_t dec, PSetup_UUIE_destExtraCRV val);
	extern void ASN1CALL ASN1Free_Setup_UUIE_destExtraCRV_ElmFn(PSetup_UUIE_destExtraCRV val);
    extern int ASN1CALL ASN1Enc_Facility_UUIE_alternativeAliasAddress_ElmFn(ASN1encoding_t enc, PFacility_UUIE_alternativeAliasAddress val);
    extern int ASN1CALL ASN1Dec_Facility_UUIE_alternativeAliasAddress_ElmFn(ASN1decoding_t dec, PFacility_UUIE_alternativeAliasAddress val);
	extern void ASN1CALL ASN1Free_Facility_UUIE_alternativeAliasAddress_ElmFn(PFacility_UUIE_alternativeAliasAddress val);
    extern int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PSetup_UUIE_destExtraCallInfo val);
    extern int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PSetup_UUIE_destExtraCallInfo val);
	extern void ASN1CALL ASN1Free_Setup_UUIE_destExtraCallInfo_ElmFn(PSetup_UUIE_destExtraCallInfo val);
    extern int ASN1CALL ASN1Enc_Setup_UUIE_destinationAddress_ElmFn(ASN1encoding_t enc, PSetup_UUIE_destinationAddress val);
    extern int ASN1CALL ASN1Dec_Setup_UUIE_destinationAddress_ElmFn(ASN1decoding_t dec, PSetup_UUIE_destinationAddress val);
	extern void ASN1CALL ASN1Free_Setup_UUIE_destinationAddress_ElmFn(PSetup_UUIE_destinationAddress val);
    extern int ASN1CALL ASN1Enc_Setup_UUIE_sourceAddress_ElmFn(ASN1encoding_t enc, PSetup_UUIE_sourceAddress val);
    extern int ASN1CALL ASN1Dec_Setup_UUIE_sourceAddress_ElmFn(ASN1decoding_t dec, PSetup_UUIE_sourceAddress val);
	extern void ASN1CALL ASN1Free_Setup_UUIE_sourceAddress_ElmFn(PSetup_UUIE_sourceAddress val);
    extern int ASN1CALL ASN1Enc_GatewayInfo_protocol_ElmFn(ASN1encoding_t enc, PGatewayInfo_protocol val);
    extern int ASN1CALL ASN1Dec_GatewayInfo_protocol_ElmFn(ASN1decoding_t dec, PGatewayInfo_protocol val);
	extern void ASN1CALL ASN1Free_GatewayInfo_protocol_ElmFn(PGatewayInfo_protocol val);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _Q931ASN_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\confmsp\common.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    common.h

Abstract:

    commonly used headers.

Author:
    
    Mu Han (muhan) 1-November-1997

--*/
#ifndef __COMMON_H_
#define __COMMON_H_

#include "confmsp.h"
#include "confaddr.h"
#include "confpart.h"
#include "confcall.h"
#include "confstrm.h"
#include "confaud.h"
#include "confvid.h"
#include "confutil.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\q931\utils.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/Q931/VCS/utils.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1996 Intel Corporation.
 *
 *	$Revision:   1.16  $
 *	$Date:   21 Jan 1997 16:09:10  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *      Call Setup Utilities
 *
 *	Notes:
 *
 ***************************************************************************/


#ifndef UTILS_H
#define UTILS_H

#ifdef __cplusplus
extern "C" {
#endif

void Q931MakePhysicalID(DWORD *);

#define UnicodeToAscii(src, dest, max)    WideCharToMultiByte(CP_ACP, 0, src, -1, dest, max, NULL, NULL)
#define AsciiToUnicode(src, dest, max)    MultiByteToWideChar(CP_ACP, 0, src, -1, dest, max)

WORD ADDRToInetPort(CC_ADDR *pAddr);
DWORD ADDRToInetAddr(CC_ADDR *pAddr);
void SetDefaultPort(CC_ADDR *pAddr);
BOOL MakeBinaryADDR(CC_ADDR *pInAddr, CC_ADDR *pOutAddr);
void GetDomainAddr(CC_ADDR *pAddr);

#if defined(DBG) && !defined(ISRDBG)

#define DBGFATAL    1
#define DBGERROR    2
#define DBGWARNING  3
#define DBGTRACE    4
#define DBGVERBOSE  5

void Q931DbgPrint(DWORD dwLevel,

#ifdef UNICODE_TRACE
                  LPTSTR pszFormat,
#else
                  LPSTR pszFormat,
#endif               
                ...);

#define Q931DBG(_x_)   Q931DbgPrint _x_

#else

#define Q931DBG(_x_)

#endif

#ifdef __cplusplus
}
#endif

#endif UTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\q931\q931asn1.h ===
#ifndef _Q931_ASN1_H_
#define _Q931_ASN1_H_

#include "av_asn1.h"

#ifdef __cplusplus
extern "C" {
#endif


// H310Caps, H320Caps, H321Caps, H322Caps, H323Caps, H324Caps, VoiceCaps, T120OnlyCaps, McuInfo, TerminalInfo, GatekeeperInfo
#define GtkprInf_nnStndrdDt_present     H310Caps_nonStandardData_present
#define GtkprInf_nnStndrdDt             nonStandardData

// GatewayInfo
#define GtwyInf_nonStandardData_present GatewayInfo_nonStandardData_present
#define GtwyInf_nonStandardData         nonStandardData
#define _seqof1                         GatewayInfo_protocol

// EndpointType
#define EndpntTyp_nnStndrdDt_present    EndpointType_nonStandardData_present
#define EndpntTyp_nnStndrdDt            nonStandardData

// Setup_UUIE
#define _seqof3                         Setup_UUIE_sourceAddress
#define _seqof4                         Setup_UUIE_destinationAddress
#define _seqof5                         Setup_UUIE_destExtraCallInfo
#define _seqof6                         Setup_UUIE_destExtraCRV
#define _choice2                        Setup_UUIE_conferenceGoal

// CallProceeding_UUIE, Alerting_UUIE
#define CPg_UUIE_h245Addrss_present     CallProceeding_UUIE_h245Address_present
#define CPg_UUIE_h245Addrss             h245Address

// Connect_UUIE
#define Cnnct_UUIE_h245Address_present  Connect_UUIE_h245Address_present
#define Cnnct_UUIE_h245Address          h245Address

// ReleaseCompleteReason
#define RlsCmpltRsn_undfndRsn_chosen    ReleaseCompleteReason_undefinedReason_chosen

// FacilityReason
#define FcltyRsn_undefinedReason_chosen FacilityReason_undefinedReason_chosen

// H323_UU_PDU
#define H323_UU_PDU_nnStndrdDt_present  H323_UU_PDU_nonStandardData_present
#define H323_UU_PDU_nnStndrdDt          nonStandardData
#define _choice3                        H323_UU_PDU_h323_message_body


#ifdef __cplusplus
} // extern "C"
#endif

#endif // _Q931_ASN1_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\q931\q931pdu.c ===
/****************************************************************************
 *
 *    $Archive:   S:/STURGEON/SRC/Q931/VCS/q931pdu.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *    Copyright (c) 1996 Intel Corporation.
 *
 *    $Revision:   1.67.1.1  $
 *    $Date:   20 Jun 1997 14:13:22  $
 *    $Author:   MANDREWS  $
 *
 *    Deliverable:
 *
 *    Abstract: Parser routines for Q931 PDUs
 *
 *    Notes:
 *
 ***************************************************************************/
#pragma comment (exestr, "$Workfile:   q931pdu.c  $ $Revision:   1.67.1.1  $")

// [ ]  Do another integration of own q931test area.
// [ ]  Alias values displayed in tracing routines.
// - - - -  -  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
// STANDARDS ISSUES
// - - - -  -  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
// [ ]  !!! EndpointType contains MC info, so Setup_UUIE doesnt need MC field !!!
// [ ]  !!! Need to decide how CallType is to be used !!!
// [ ]  !!! ALERTING message is missing the ConferenceID field !!!
// [ ]  !!! Place needed for Caller and Callee transport addr, or else explanation of how this information is available round-trip !!!
// [ ]  !!! FACILITY message is missing the protocolIdentifier field !!!

//------------------------------------------------------------------------------
// Note:  These parsing details have not yet been supported:
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// 1) variable octet fields having extending groups,
//    extending indications, or escape for extensions. (See 4.5.1)
// 2) codeset recognition and exclusion based on SHIFT (See 4.5.2)
// 3) correct ignoring of escapes for nationally specific message types.
// 4) The call reference value is 2 bytes long sizeof(WORD).
//    A call reference of 0 means, the message pertains to all
//    calls on the same data link.
//------------------------------------------------------------------------------

#pragma warning ( disable : 4100 4115 4201 4214 4514 )

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <string.h>

#include "q931asn.h"
#include "q931asn1.h"

#include "common.h"
#include "q931.h"
#include "isrg.h"

#include "utils.h"
#include "q931pdu.h"

#ifdef UNICODE_TRACE
// We include this header to fix problems with macro expansion when Unicode is turned on.
#include "unifix.h"
#endif


//==========================================================
// CALLED PARTY FIELD DEFINITIONS
//==========================================================
// called party encoding bits...
#define CALLED_PARTY_EXT_BIT        0x80

// called party number type
#define CALLED_PARTY_TYPE_UNKNOWN   0x00
        // ...other types are not defined because they are not used...

// called party numbering plan
#define CALLED_PARTY_PLAN_E164      0x01
        // ...other plans are not defined because they are not used...
 


//==========================================================
// BEARER FIELD DEFINITIONS
//==========================================================
// bearer encoding bits...
#define BEAR_EXT_BIT                0x80

// bearer coding standards...
#define BEAR_CCITT                  0x00
        // ...others not needed...

// bearer information transfer capability...
#define BEAR_UNRESTRICTED_DIGITAL   0x08
        // ...others not needed...

// bearer transfer mode...
#define BEAR_CIRCUIT_MODE			0x00
#define BEAR_PACKET_MODE            0x40
        // ...others not needed...

// bearer information transfer rate...
#define BEAR_NO_CIRCUIT_RATE        0x00
#define BEAR_MULTIRATE				0x18
        // ...others not needed...

// bearer layer1 protocol...
#define BEAR_LAYER1_INDICATOR       0x20
#define BEAR_LAYER1_H221_H242       0x05
        // ...others not needed...


#define Q931_PROTOCOL_ID1           0
#define Q931_PROTOCOL_ID2           0
#define Q931_PROTOCOL_ID3           8
#define Q931_PROTOCOL_ID4           2250
#define Q931_PROTOCOL_ID5           0
#define Q931_PROTOCOL_ID6           1

static struct ObjectID_ ProtocolId1;
static struct ObjectID_ ProtocolId2;
static struct ObjectID_ ProtocolId3;
static struct ObjectID_ ProtocolId4;
static struct ObjectID_ ProtocolId5;
static struct ObjectID_ ProtocolId6;

static struct _seqof1 TempProtocol;

MESSAGEIDTYPE MessageSet[] =
{
    ALERTINGMESSAGETYPE,
    PROCEEDINGMESSAGETYPE,
    CONNECTMESSAGETYPE,
    CONNECTACKMESSAGETYPE,
    PROGRESSMESSAGETYPE,
    SETUPMESSAGETYPE,
    SETUPACKMESSAGETYPE,

    RESUMEMESSAGETYPE,
    RESUMEACKMESSAGETYPE,
    RESUMEREJMESSAGETYPE,
    SUSPENDMESSAGETYPE,
    SUSPENDACKMESSAGETYPE,
    SUSPENDREJMESSAGETYPE,
    USERINFOMESSAGETYPE,

    DISCONNECTMESSAGETYPE,
    RELEASEMESSAGETYPE,
    RELEASECOMPLMESSAGETYPE,
    RESTARTMESSAGETYPE,
    RESTARTACKMESSAGETYPE,

    SEGMENTMESSAGETYPE,
    CONGCTRLMESSAGETYPE,
    INFORMATIONMESSAGETYPE,
    NOTIFYMESSAGETYPE,
    STATUSMESSAGETYPE,
    STATUSENQUIRYMESSAGETYPE,

	HOLDMESSAGETYPE,
	HOLDACKMESSAGETYPE,
	HOLDREJECTMESSAGETYPE,
	RETRIEVEMESSAGETYPE,
	RETRIEVEACKMESSAGETYPE,
	RETRIEVEREJECTMESSAGETYPE,
    FACILITYMESSAGETYPE,
	REGISTERMESSAGETYPE
};

//====================================================================================
//====================================================================================
static CS_STATUS
AliasToSeqof(struct _seqof3 **ppTarget, PCC_ALIASNAMES pSource)
{
    if (ppTarget == NULL)
    {
        return CS_BAD_PARAM;
    }
    *ppTarget = NULL;
    if (pSource == NULL)
    {
        return CS_OK;
    }
    if (pSource && (pSource->wCount))
    {
        struct _seqof3 *ListHead = NULL;
        struct _seqof3 *CurrentNode = NULL;
        LPWSTR pData = NULL;         // UNICODE STRING
        int SourceItem;
        WORD x;

        for (SourceItem = pSource->wCount - 1; SourceItem >= 0; SourceItem--)
        {
            BOOL Cleanup = FALSE;

            // first do the required memory allocations...
            CurrentNode = (struct _seqof3 *)Malloc(sizeof(struct _seqof3));
            if (CurrentNode == NULL)
            {
                Cleanup = TRUE;
            }
            else
            {
                if (pSource->pItems[SourceItem].wType == CC_ALIAS_H323_ID)
                {
                    if ((pSource->pItems[SourceItem].wDataLength != 0) &&
                        (pSource->pItems[SourceItem].pData != NULL))
                    {
                        pData = (LPWSTR)Malloc(pSource->pItems[SourceItem].wDataLength *
                            sizeof(WCHAR));
                        if (pData == NULL)
                        {
                            Free(CurrentNode);
                            Cleanup = TRUE;
                        }
                    }
                }
            }
            if (Cleanup)
            {
                for (CurrentNode = ListHead; CurrentNode; CurrentNode = ListHead)
                {
                    ListHead = CurrentNode->next;
                    if (CurrentNode->value.choice == h323_ID_chosen)
                    {
                        if (CurrentNode->value.u.h323_ID.value)
                        {
                            Free(CurrentNode->value.u.h323_ID.value);
                        }
                    }
                    Free(CurrentNode);
                }
                return CS_NO_MEMORY;
            }

            // then do the required memory copying.
            if (pSource->pItems[SourceItem].wType == CC_ALIAS_H323_ID)
            {
                CurrentNode->value.choice = h323_ID_chosen;
                if ((pSource->pItems[SourceItem].wDataLength != 0) &&
                    (pSource->pItems[SourceItem].pData != NULL))
                {
                    CurrentNode->value.u.h323_ID.length =
                        pSource->pItems[SourceItem].wDataLength;
                    for (x = 0; x < pSource->pItems[SourceItem].wDataLength; x++)
                    {
                        pData[x] = pSource->pItems[SourceItem].pData[x];
                    }
                    CurrentNode->value.u.h323_ID.value = pData;
                }
                else
                {
                    CurrentNode->value.u.h323_ID.length = 0;
                    CurrentNode->value.u.h323_ID.value = NULL;
                }
            }
            else if (pSource->pItems[SourceItem].wType == CC_ALIAS_H323_PHONE)
            {
                CurrentNode->value.choice = e164_chosen;
                if ((pSource->pItems[SourceItem].wDataLength != 0) &&
                    (pSource->pItems[SourceItem].pData != NULL))
                {
                    for (x = 0; x < pSource->pItems[SourceItem].wDataLength; x++)
                    {
                        CurrentNode->value.u.e164[x] = (BYTE)(pSource->pItems[SourceItem].pData[x]);
                    }
                    CurrentNode->value.u.e164[pSource->pItems[SourceItem].wDataLength] = '\0';
                }
                else
                {
                    CurrentNode->value.u.e164[0] = '\0';
                }
            }
            CurrentNode->next = ListHead;
            ListHead = CurrentNode;
        }
        *ppTarget = ListHead;
    }
    return CS_OK;
}

//====================================================================================
//====================================================================================
static CS_STATUS
AliasWithPrefixToSeqof(struct _seqof3 **ppTarget, PCC_ALIASNAMES pSource)
{
    if (ppTarget == NULL)
    {
        return CS_BAD_PARAM;
    }
    *ppTarget = NULL;
    if (pSource == NULL)
    {
        return CS_OK;
    }
    if (pSource && (pSource->wCount))
    {
        struct _seqof3 *ListHead = NULL;
        struct _seqof3 *CurrentNode = NULL;
        int SourceItem;

        for (SourceItem = pSource->wCount - 1; SourceItem >= 0; SourceItem--)
        {
			PCC_ALIASITEM pItem = &pSource->pItems[SourceItem];
			LPWSTR pData = NULL;        // UNICODE STRING
            BOOL Cleanup = FALSE;
            unsigned uPrefixLength;
            unsigned uDataLength;
            unsigned x;
            
            if (pItem->pPrefix != NULL &&
                pItem->wPrefixLength > 0)
            {
                uPrefixLength = (unsigned) pItem->wPrefixLength;
            }
            else
            {
                uPrefixLength = 0;
            }

            if (pItem->pData != NULL &&
                pItem->wDataLength > 0)
            {
                uDataLength = (unsigned) pItem->wDataLength;
            }
            else
            {
                uDataLength = 0;
            }

            // first do the required memory allocations...
            CurrentNode = (struct _seqof3 *)Malloc(sizeof(struct _seqof3));
            if (CurrentNode == NULL)
            {
                Cleanup = TRUE;
            }
            else
            {
                if (pItem->wType == CC_ALIAS_H323_ID)
                {
#ifdef USE_PREFIX_FOR_H323_ID
                    if (uPrefixLength != 0 || uDataLength != 0)
                    {
                        pData = (LPWSTR)Malloc((uPrefixLength + uDataLength) * sizeof(WCHAR));
#else
                    if (uDataLength != 0)
                    {
                        pData = (LPWSTR)Malloc((uDataLength) * sizeof(WCHAR));
#endif
                        if (pData == NULL)
                        {
                            Free(CurrentNode);
                            Cleanup = TRUE;
                        }
                    }
                }
            }
            if (Cleanup)
            {
                for (CurrentNode = ListHead; CurrentNode; CurrentNode = ListHead)
                {
                    ListHead = CurrentNode->next;
                    if (CurrentNode->value.choice == h323_ID_chosen)
                    {
                        if (CurrentNode->value.u.h323_ID.value)
                        {
                            Free(CurrentNode->value.u.h323_ID.value);
                        }
                    }
                    Free(CurrentNode);
                }
                return CS_NO_MEMORY;
            }

            // then do the required memory copying.
            switch (pItem->wType)
            {
            case CC_ALIAS_H323_ID:
                CurrentNode->value.choice = h323_ID_chosen;
#ifdef USE_PREFIX_FOR_H323_ID
                if (uPrefixLength != 0 || uDataLength != 0)
                {
                    CurrentNode->value.u.h323_ID.length = (WORD)(uPrefixLength + uDataLength);
                    for (x = 0; x < uPrefixLength; ++x)
                    {
                        pData[x] = pItem->pPrefix[x];
                    }
                    for (x = 0; x < uDataLength; ++x)
                    {
                        pData[uPrefixLength + x] = pItem->pData[x];
                    }
#else
                if (uDataLength != 0)
                {
                    CurrentNode->value.u.h323_ID.length = (WORD)(uDataLength);
                    for (x = 0; x < uDataLength; ++x)
                    {
                        pData[x] = pItem->pData[x];
                    }
#endif
                    CurrentNode->value.u.h323_ID.value = pData;
                }
                else
                {
                    CurrentNode->value.u.h323_ID.length = 0;
                    CurrentNode->value.u.h323_ID.value  = NULL;
                }
                break;

            case CC_ALIAS_H323_PHONE:
                CurrentNode->value.choice = e164_chosen;
                for (x = 0; x < uPrefixLength; ++x)
                {
                    CurrentNode->value.u.e164[x] = (BYTE)(pItem->pPrefix[x]);
                }
                for (x = 0; x < uDataLength; ++x)
                {
                    CurrentNode->value.u.e164[uPrefixLength + x] = (BYTE)(pItem->pData[x]);
                }
                for (x = uDataLength + uPrefixLength; x < sizeof(CurrentNode->value.u.e164); ++x)
                {
                    CurrentNode->value.u.e164[x] = 0;
                }
                break;

            default:
                Free(CurrentNode);
                for (CurrentNode = ListHead; CurrentNode; CurrentNode = ListHead)
                {
                    ListHead = CurrentNode->next;
                    if (CurrentNode->value.choice == h323_ID_chosen)
                    {
                        if (CurrentNode->value.u.h323_ID.value)
                        {
                            Free(CurrentNode->value.u.h323_ID.value);
                        }
                    }
                    Free(CurrentNode);
                }
                return CS_BAD_PARAM;
            } // switch
            CurrentNode->next = ListHead;
            ListHead = CurrentNode;
        }
        *ppTarget = ListHead;
    }
    return CS_OK;
}

//====================================================================================
//====================================================================================
static CS_STATUS
SeqofToAlias(PCC_ALIASNAMES *ppTarget, struct _seqof3 *pSource)
{
    struct _seqof3 *ListHead = NULL;
    struct _seqof3 *CurrentNode = NULL;
    WORD wCount;
    WORD x = 0;
    PCC_ALIASITEM p = NULL;
    CS_STATUS status = CS_OK;

    if (ppTarget == NULL)
    {
        return CS_BAD_PARAM;
    }
    *ppTarget = NULL;
    if (pSource == NULL)
    {
        return CS_OK;
    }

    wCount = 0;
    for (CurrentNode = pSource; CurrentNode; CurrentNode = CurrentNode->next)
    {
        wCount++;
    }

    *ppTarget = (PCC_ALIASNAMES)Malloc(sizeof(CC_ALIASNAMES));
    if (*ppTarget == NULL)
    {
        return CS_NO_MEMORY;
    }

    (*ppTarget)->pItems = (PCC_ALIASITEM)Malloc(wCount * sizeof(CC_ALIASITEM));
    if ((*ppTarget)->pItems == NULL)
    {
        Free(*ppTarget);
        *ppTarget = NULL;
        return CS_NO_MEMORY;
    }

    p = (*ppTarget)->pItems;

    for (CurrentNode = pSource; CurrentNode; CurrentNode = CurrentNode->next)
    {
        WORD y;

	    p[x].wPrefixLength = 0;
        p[x].pPrefix = NULL;

        switch (CurrentNode->value.choice)
        {
        case h323_ID_chosen:
            p[x].wType = CC_ALIAS_H323_ID;
            if ((CurrentNode->value.u.h323_ID.length != 0) &&
                    (CurrentNode->value.u.h323_ID.value != NULL))
            {
                p[x].wDataLength = (WORD)CurrentNode->value.u.h323_ID.length;
                p[x].pData = (LPWSTR)Malloc(CurrentNode->value.u.h323_ID.length * sizeof(p[x].pData[0]));
                if (p[x].pData != NULL)
                {
                    for (y = 0; y < CurrentNode->value.u.h323_ID.length; y++)
                    {
                        p[x].pData[y] = (WCHAR)((CurrentNode->value.u.h323_ID.value)[y]);
                    }
                    x++;
                }
                else
                {
                    status = CS_NO_MEMORY;
                }
            }
            break;


        case e164_chosen:
            p[x].wType = CC_ALIAS_H323_PHONE;
            p[x].wDataLength = (WORD)strlen(CurrentNode->value.u.e164);
            p[x].pData = (LPWSTR)Malloc((p[x].wDataLength+1) * sizeof(p[x].pData[0]));
            if (p[x].pData != NULL)
            {
                for (y = 0; y < p[x].wDataLength; y++)
                {
                    p[x].pData[y] = CurrentNode->value.u.e164[y];
                }
                p[x].pData[p[x].wDataLength] = 0;
                x++;
            }
            else
            {
                status = CS_NO_MEMORY;
            }
            break;

        default:
            // we don't currently handle other alias types
            break;
        } // switch

        if (status != CS_OK)
        {
            // Free everything that has been allocated so far...
            for (y = 0; y < x; y++)
            {
                Free(p[y].pData);
            }
            Free(p);
            Free(*ppTarget);
            *ppTarget = NULL;
            return status;
        }
    }

    // any aliases?
    if (x > 0) {

        // save number of aliases
        (*ppTarget)->wCount = x;

    } else {

        //
        // Note Q931FreeAliasNames does not free CC_ALIASNAMES structure
        // when wCount is set to zero
        //
        Free(p);
        Free(*ppTarget);
        *ppTarget = NULL;
    }

    return CS_OK;
}

//====================================================================================
//====================================================================================
static CS_STATUS
FreeSeqof(struct _seqof3 *pSource)
{
    struct _seqof3 *CurrentNode = NULL;

    for (CurrentNode = pSource; CurrentNode; CurrentNode = pSource)
    {
        pSource = CurrentNode->next;
        if (CurrentNode->value.choice == h323_ID_chosen)
        {
            if (CurrentNode->value.u.h323_ID.value)
            {
                Free(CurrentNode->value.u.h323_ID.value);
            }
        }
        Free(CurrentNode);
    }
    return CS_OK;
}

//====================================================================================
//====================================================================================
static CS_STATUS
Q931CopyAliasItemToAliasAddr(AliasAddress *pTarget, PCC_ALIASITEM pSource)
{
    AliasAddress *pNewAddress = NULL;
    WORD x;

    if (pTarget == NULL)
    {
        return CS_BAD_PARAM;
    }
    if (pSource == NULL)
    {
        return CS_BAD_PARAM;
    }

    pNewAddress = pTarget;

    if (pSource->wType == CC_ALIAS_H323_ID)
    {
        pNewAddress->choice = h323_ID_chosen;
        if ((pSource->wDataLength != 0) && (pSource->pData != NULL))
        {
            LPWSTR pData = NULL;         // UNICODE STRING
            pData = (LPWSTR)Malloc(pSource->wDataLength * sizeof(WCHAR));
            if (pData == NULL)
            {
                return CS_NO_MEMORY;
            }
            pNewAddress->u.h323_ID.length = pSource->wDataLength;
            for (x = 0; x < pSource->wDataLength; x++)
            {
                pData[x] = pSource->pData[x];
            }
            pNewAddress->u.h323_ID.value = pData;
        }
        else
        {
            pNewAddress->u.h323_ID.length = 0;
            pNewAddress->u.h323_ID.value = NULL;
        }
    }
    else if (pSource->wType == CC_ALIAS_H323_PHONE)
    {
        pNewAddress->choice = e164_chosen;
        if ((pSource->wDataLength != 0) && (pSource->pData != NULL))
        {
            for (x = 0; x < pSource->wDataLength; x++)
            {
                pNewAddress->u.e164[x] = (BYTE)(pSource->pData[x]);
            }
            pNewAddress->u.e164[pSource->wDataLength] = '\0';
        }
        else
        {
            pNewAddress->u.e164[0] = '\0';
        }
    }

    return CS_OK;
}

//====================================================================================
//====================================================================================
static CS_STATUS
Q931AliasAddrToAliasItem(PCC_ALIASITEM *ppTarget, AliasAddress *pSource)
{
    PCC_ALIASITEM pNewItem = NULL;
    WORD y;

    if (ppTarget == NULL)
    {
        return CS_BAD_PARAM;
    }
    if (pSource == NULL)
    {
        *ppTarget = NULL;
        return CS_OK;
    }

    pNewItem = (PCC_ALIASITEM)Malloc(sizeof(CC_ALIASITEM));
    if (pNewItem == NULL)
    {
        *ppTarget = NULL;
        return CS_NO_MEMORY;
    }
    memset(pNewItem, 0, sizeof(*pNewItem));

    switch (pSource->choice)
    {
    case h323_ID_chosen:
        pNewItem->wType = CC_ALIAS_H323_ID;
        if ((pSource->u.h323_ID.length != 0) &&
            (pSource->u.h323_ID.value  != NULL))
        {
            // convert the text from UNICODE to ascii.
            pNewItem->wDataLength = (WORD)pSource->u.h323_ID.length;
            pNewItem->pData = (LPWSTR)Malloc(pSource->u.h323_ID.length * sizeof(pNewItem->pData[0]));
            if (pNewItem->pData == NULL)
            {
                Free(pNewItem);
                return CS_NO_MEMORY;
            }
            for (y = 0; y < pSource->u.h323_ID.length; y++)
            {
                pNewItem->pData[y] = (WCHAR)((pSource->u.h323_ID.value)[y]);
            }
        }
        break;

    case e164_chosen:
        pNewItem->wType = CC_ALIAS_H323_PHONE;
        pNewItem->wDataLength = (WORD)strlen(pSource->u.e164);
        pNewItem->pData = (LPWSTR)Malloc((pNewItem->wDataLength + 1) * sizeof(pNewItem->pData[0]));
        if (pNewItem->pData == NULL)
        {
            Free(pNewItem);
            return CS_NO_MEMORY;
        }
        for (y = 0; y < pNewItem->wDataLength; y++)
        {
            pNewItem->pData[y] = pSource->u.e164[y];
        }
        pNewItem->pData[pNewItem->wDataLength] = 0;
        break;

    default:
        Free(pNewItem);
        *ppTarget = NULL;
        return CS_BAD_PARAM;
    } // switch

    *ppTarget = pNewItem;
    return CS_OK;
}

//====================================================================================
//====================================================================================
static CS_STATUS
Q931ClearAliasAddr(AliasAddress *pSource)
{
    if (pSource)
    {
        if (pSource->choice == h323_ID_chosen)
        {
            if (pSource->u.h323_ID.value)
            {
                Free(pSource->u.h323_ID.value);
            }
        }
    }
    return CS_OK;
}





//------------------------------------------------------------------------------
// Parse and return a single octet encoded value, See Q931 section 4.5.1.
//
// Parameters:
//     BufferPtr  Pointer to a descriptor of the buffer
//                containing the length and a pointer
//                to the raw bytes of the input stream.
//     Ident      Pointer to space for field identifier
//     Value      Pointer to space for field value
//------------------------------------------------------------------------------
static HRESULT 
ParseSingleOctetType1(
    PBUFFERDESCR BufferDescriptor,
    BYTE *Ident,
    BYTE *Value)
{
    // There has to be at least 1 byte in the stream to be
    // able to parse the single octet value
    if (BufferDescriptor->Length < 1)
    {
        return CS_ENDOFINPUT;
    }

    // low bits (0, 1, 2, 3) of the byte are the value
    *Value = (BYTE)(*BufferDescriptor->BufferPtr & TYPE1VALUEMASK);

    // higher bits (4, 5, 6) are the identifier.  bit 7 is always 1,
    // and is not returned as part of the id.
    *Ident = (BYTE)((*BufferDescriptor->BufferPtr & 0x70) >> 4);

    BufferDescriptor->BufferPtr++;
    BufferDescriptor->Length--;

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse and return a single octet encoded value, See Q931 section 4.5.1.
// This octet has no value, only an identifier.
//
// Parameters:
//     BufferPtr  Pointer to a descriptor of the buffer containing the
//                length and a pointer to the raw bytes of the input stream.
//     Ident      Pointer to space for field identifier
//------------------------------------------------------------------------------
static HRESULT
ParseSingleOctetType2(
    PBUFFERDESCR BufferDescriptor,
    BYTE *Ident)
{
    // There has to be at least 1 byte in the stream to be
    // able to parse the single octet value
    if (BufferDescriptor->Length < 1)
    {
        return CS_ENDOFINPUT;
    }

    // low 7 bits of the byte are the identifier
    *Ident = (BYTE)(*BufferDescriptor->BufferPtr & 0x7f);

    BufferDescriptor->BufferPtr++;
    BufferDescriptor->Length--;

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse and return a variable length Q931 field see Q931 section 4.5.1.
//
// Parameters :
//     BufferPtr  Pointer to a descriptor of the buffer
//                containing the length and a pointer
//                to the raw bytes of the input stream.
//     Ident      Pointer to space for field identifier
//     Length     Pointer to space for the length
//     Contents   Pointer to space for the bytes of the field
//------------------------------------------------------------------------------
static HRESULT 
ParseVariableOctet(
    PBUFFERDESCR BufferDescriptor,
    BYTE *Ident,
    BYTE *Length,
    BYTE *Contents)
{
    register int i;
    BYTE *Tempptr;

    // There has to be at least 2 bytes in order just to get 
    // the length and the identifier
    // able to parse the single octet value
    if (BufferDescriptor->Length < 2)
    {
        return CS_ENDOFINPUT;
    }

    // low 7 bits of the first byte are the identifier
    *Ident= (BYTE)(*BufferDescriptor->BufferPtr & 0x7f);

    BufferDescriptor->BufferPtr++;
    BufferDescriptor->Length--;

    // The next byte is the length
    *Length = *BufferDescriptor->BufferPtr;
    BufferDescriptor->BufferPtr++;
    BufferDescriptor->Length--;

    if (BufferDescriptor->Length < *Length)
    {
        return CS_ENDOFINPUT;
    }

    Tempptr = Contents;
    for (i = 0; i < *Length; i++)
    {
        // Copy the bytes out of the rest of the buffer
        *Tempptr = *BufferDescriptor->BufferPtr;
        BufferDescriptor->BufferPtr++;
        BufferDescriptor->Length--;
        Tempptr++;
    }
    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse and return a variable length Q931 field see Q931 section 4.5.1.
//------------------------------------------------------------------------------
static HRESULT 
ParseVariableASN(
    PBUFFERDESCR BufferDescriptor,
    BYTE *Ident,
    BYTE *ProtocolDiscriminator,
    WORD *UserInformationLength,     // Length of the User Information.
    BYTE *UserInformation)           // Bytes of the User Information.
{
    register int i;
    BYTE *Tempptr;
    WORD ContentsLength;     // Length of the full UserUser contents.

    *UserInformationLength = 0;

    // There has to be at least 4 bytes for the IE identifier,
    // the contents length, and the protocol discriminator (1 + 2 + 1).
    if (BufferDescriptor->Length < 4)
    {
        return CS_ENDOFINPUT;
    }

    // low 7 bits of the first byte are the identifier
    *Ident= (BYTE)(*BufferDescriptor->BufferPtr & 0x7f);
    BufferDescriptor->BufferPtr++;
    BufferDescriptor->Length--;

    // The next 2 bytes are the length
    ContentsLength = *(BufferDescriptor->BufferPtr);
    BufferDescriptor->BufferPtr++;
    BufferDescriptor->Length--;
    ContentsLength = (WORD)((ContentsLength << 8) + *BufferDescriptor->BufferPtr);
    BufferDescriptor->BufferPtr++;
    BufferDescriptor->Length--;

    if (BufferDescriptor->Length < ContentsLength)
    {
        return CS_ENDOFINPUT;
    }

    // The next byte is the protocol discriminator.
    *ProtocolDiscriminator = *BufferDescriptor->BufferPtr;
    BufferDescriptor->BufferPtr++;
    BufferDescriptor->Length--;

    if (ContentsLength > 0)
    {
        *UserInformationLength = (WORD)(ContentsLength - 1);
    }

    Tempptr = UserInformation;
    for (i = 0; i < *UserInformationLength; i++)
    {
        // Copy the bytes out of the rest of the buffer
        *Tempptr = *BufferDescriptor->BufferPtr;
        BufferDescriptor->BufferPtr++;
        BufferDescriptor->Length--;
        Tempptr++;
    }
    return CS_OK;
}

//------------------------------------------------------------------------------
// Get the identifier of the next field from the buffer and
// return it.  The buffer pointer is not incremented, To
// parse the field and extract its values, the above functions
// should be used.  See Q931 table 4-3 for the encodings of the 
// identifiers.
//
// Parameters:
//      BufferPtr        Pointer to the buffer space
//------------------------------------------------------------------------------
static BYTE
GetNextIdent(
    void *BufferPtr)
{
    FIELDIDENTTYPE Ident;

    // Extract the first byte from the buffer
    Ident= (*(FIELDIDENTTYPE *)BufferPtr);

    // This value can be returned as the identifier as long
    // as it is not a single Octet - Type 1 element.
    // Those items must have the value removed from them
    // before they can be returned.
    if ((Ident & 0x80) && ((Ident & TYPE1IDENTMASK) != 0xA0))
    {
        return (BYTE)(Ident & TYPE1IDENTMASK);
    }

    return Ident;
}

//------------------------------------------------------------------------------
// Parse and return a protocol discriminator. See Q931 section 4.2.
// The octet pointed to by **BufferPtr is the protocol Discriminator.
//
// Parameters:
//     BufferPtr  Pointer to a descriptor of the buffer
//                containing the length and a pointer
//                to the raw bytes of the input stream.
//     Discrim    Pointer to space for discriminator
//------------------------------------------------------------------------------
static HRESULT
ParseProtocolDiscriminator(
    PBUFFERDESCR BufferDescriptor,
    PDTYPE *Discrim)
{
    // There has to be at least enough bytes left in the 
    // string for the operation
    if (BufferDescriptor->Length < sizeof(PDTYPE))
    {
        return CS_MESSAGE_TOO_SHORT;
    }

    *Discrim = *(PDTYPE *)BufferDescriptor->BufferPtr;
    if (*Discrim != Q931PDVALUE)
    {
        return CS_INVALID_PROTOCOL;
    }

    BufferDescriptor->BufferPtr += sizeof(PDTYPE);
    BufferDescriptor->Length -= sizeof(PDTYPE);
    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse and return a variable length Q931 call reference see 
// Q931 section 4.3.
//
// Parameters:
//     BufferPtr  Pointer to a descriptor of the buffer
//                containing the length and a pointer
//                to the raw bytes of the input stream.
//     Length     Pointer to space for the length
//     Contents   Pointer to space for the bytes of the field
//------------------------------------------------------------------------------
static HRESULT
ParseCallReference(
    PBUFFERDESCR BufferDescriptor,
    CRTYPE *CallReference)
{
    register int i;
    BYTE Length;

    // There has to be at least enough bytes left in the 
    // string for the length byte
    if (BufferDescriptor->Length < 1)
    {
        return CS_MESSAGE_TOO_SHORT;
    }

    // low 4 bits of the first byte are the length.
    // the rest of the bits are zeroes.
    Length = (BYTE)(*BufferDescriptor->BufferPtr & 0x0f);

    BufferDescriptor->BufferPtr++;
    BufferDescriptor->Length--;

    // There has to be at least enough bytes left in the 
    // string for the operation
    if (BufferDescriptor->Length < Length)
    {
        return CS_MESSAGE_TOO_SHORT;
    }

    *CallReference = 0;     // length can be 0, so initialize here first...
    for (i = 0; i < Length; i++)
    {
        if (i < sizeof(CRTYPE))
        {
            // Copy the bytes out of the rest of the buffer
            *CallReference = (WORD)((*CallReference << 8) +
                *BufferDescriptor->BufferPtr);
        }
        BufferDescriptor->BufferPtr++;
        BufferDescriptor->Length--;
    }

    // note:  the high order bit of the value represents callee relationship.

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse and return a message type.  See Q931 section 4.4.
// The octet pointed to by **BufferPtr is the message type.
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     MessageType  Pointer to space for message type
//------------------------------------------------------------------------------
static HRESULT
ParseMessageType(
    PBUFFERDESCR BufferDescriptor,
    MESSAGEIDTYPE *MessageType)
{
    register int i;

    // There has to be at least enough bytes left in the 
    // string for the operation
    if (BufferDescriptor->Length < sizeof(MESSAGEIDTYPE))
    {
        return CS_MESSAGE_TOO_SHORT;
    }

    *MessageType = (BYTE)(*((MESSAGEIDTYPE *)BufferDescriptor->BufferPtr) & MESSAGETYPEMASK);
    for (i = 0; i < sizeof(MessageSet) / sizeof(MESSAGEIDTYPE); i++)
    {
        if (MessageSet[i] == *MessageType)
        {
            break;
        }
    }
    if (i >= sizeof(MessageSet) / sizeof(MESSAGEIDTYPE))
    {
        return CS_INVALID_MESSAGE_TYPE;
    }

    BufferDescriptor->BufferPtr += sizeof(MESSAGEIDTYPE);
    BufferDescriptor->Length -= sizeof(MESSAGEIDTYPE);
    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional shift field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer containing the
//                  length and a pointer to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed shift message information.
//------------------------------------------------------------------------------
static HRESULT
ParseShift(
    PBUFFERDESCR BufferDescriptor,
    PSHIFTIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(SHIFTIE));
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_SHIFT)
    {
        FieldStruct->Present = TRUE;
        return ParseSingleOctetType1(BufferDescriptor,
            &Ident, &FieldStruct->Value);
    }
    else
    {
        FieldStruct->Present = FALSE;
    }
    return CS_OK;
}


//------------------------------------------------------------------------------
// Parse an optional facility ie field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed facility
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseFacility(
    PBUFFERDESCR BufferDescriptor,
    PFACILITYIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(FACILITYIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_FACILITY)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor,
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional more data field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed field information
//------------------------------------------------------------------------------
static HRESULT 
ParseMoreData(
    PBUFFERDESCR BufferDescriptor,
    PMOREDATAIE FieldStruct)
{
    BYTE Ident;

    memset(FieldStruct, 0, sizeof(MOREDATAIE));
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_MORE)
    {
        FieldStruct->Present = TRUE;
        return ParseSingleOctetType2(BufferDescriptor, &Ident);
    }
    else
    {
        FieldStruct->Present = FALSE;
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional sending clomplete field.  Q931 section 4.4.
// The octet pointed to by **BufferPtr is the message type.
//
// Parameters:
//      BufferPtr    Pointer to a descriptor of the buffer
//                   containing the length and a pointer
//                   to the raw bytes of the input stream.
//      MessageType  Pointer to space for message type
//------------------------------------------------------------------------------
static HRESULT
ParseSendingComplete(
    PBUFFERDESCR BufferDescriptor,
    PSENDCOMPLIE FieldStruct)
{
    BYTE Ident;

    memset(FieldStruct, 0, sizeof(SENDCOMPLIE));
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_SENDINGCOMPLETE)
    {
        FieldStruct->Present = TRUE;
        return ParseSingleOctetType2(BufferDescriptor, &Ident);
    }
    else
    {
        FieldStruct->Present = FALSE;
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional congestion level field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed congestion 
//                  level information.
//------------------------------------------------------------------------------
static HRESULT 
ParseCongestionLevel(
    PBUFFERDESCR BufferDescriptor,
    PCONGESTIONIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(CONGESTIONIE));
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_CONGESTION)
    {
        FieldStruct->Present = TRUE;
        return ParseSingleOctetType1(BufferDescriptor,
            &Ident, &FieldStruct->Value);
    }
    else
    {
        FieldStruct->Present = FALSE;
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional repeat indicator field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed repeat
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseRepeatIndicator(
    PBUFFERDESCR BufferDescriptor,
    PREPEATIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(REPEATIE));
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_REPEAT)
    {
        FieldStruct->Present = TRUE;
        return ParseSingleOctetType1(BufferDescriptor,
            &Ident, &FieldStruct->Value);
    }
    else
    {
        FieldStruct->Present = FALSE;
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional segmented message field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed segmented message
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseSegmented(
    PBUFFERDESCR BufferDescriptor,
    PSEGMENTEDIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(SEGMENTEDIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_SEGMENTED)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor,
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional bearer capability field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed bearer capability
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseBearerCapability(
    PBUFFERDESCR BufferDescriptor,
    PBEARERCAPIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(BEARERCAPIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_BEARERCAP)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor,
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional cause field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed cause
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseCause(
    PBUFFERDESCR BufferDescriptor,
    PCAUSEIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(CAUSEIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_CAUSE)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor,
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional call identity field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed call identity
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseCallIdentity(
    PBUFFERDESCR BufferDescriptor,
    PCALLIDENTIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(CALLIDENTIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_CALLIDENT)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor,
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional call state field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed call state
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseCallState(
    PBUFFERDESCR BufferDescriptor,
    PCALLSTATEIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(CALLSTATEIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_CALLSTATE)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor,
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional channel identification field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed channel identity
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseChannelIdentification(
    PBUFFERDESCR BufferDescriptor,
    PCHANIDENTIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(CHANIDENTIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_CHANNELIDENT)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional progress indication field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed progress
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseProgress(
    PBUFFERDESCR BufferDescriptor,
    PPROGRESSIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(PROGRESSIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_PROGRESS)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional network specific facilities field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed network facitlities
//                  information.
//------------------------------------------------------------------------------
static HRESULT 
ParseNetworkSpec(
    PBUFFERDESCR BufferDescriptor,
    PNETWORKIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(NETWORKIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_NETWORKSPEC)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional notification indicator field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parse notification indicator
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseNotificationIndicator(
    PBUFFERDESCR BufferDescriptor,
    PNOTIFICATIONINDIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(NOTIFICATIONINDIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_NOTIFICATION)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional display field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed display
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseDisplay(
    PBUFFERDESCR BufferDescriptor,
    PDISPLAYIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(DISPLAYIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_DISPLAY)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional date/time field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed date/time
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseDate(
    PBUFFERDESCR BufferDescriptor,
    PDATEIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(DATEIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_DATE)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional keypad field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed keypad
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseKeypad(
    PBUFFERDESCR BufferDescriptor,
    PKEYPADIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(KEYPADIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_KEYPAD)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional signal field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed signal
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseSignal(
    PBUFFERDESCR BufferDescriptor,
    PSIGNALIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(SIGNALIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_SIGNAL)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional information rate field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed information rate
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseInformationRate(
    PBUFFERDESCR BufferDescriptor,
    PINFORATEIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(INFORATEIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_INFORMATIONRATE)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional end to end transit delay field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed end to end
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseEndToEndDelay(
    PBUFFERDESCR BufferDescriptor,
    PENDTOENDDELAYIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(ENDTOENDDELAYIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_ENDTOENDDELAY)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional transit delay field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed transit delay
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseTransitDelay(
    PBUFFERDESCR BufferDescriptor,
    PTRANSITDELAYIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(TRANSITDELAYIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_TRANSITDELAY)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional packet layer binary params field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParsePacketLayerParams(
    PBUFFERDESCR BufferDescriptor,
    PPLBINARYPARAMSIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(PLBINARYPARAMSIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_PLBINARYPARAMS)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional packet layer window size field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParsePacketLayerWindowSize(
    PBUFFERDESCR BufferDescriptor,
    PPLWINDOWSIZEIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(PLWINDOWSIZEIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_PLWINDOWSIZE)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional packet size field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parse packet size
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParsePacketSize(
    PBUFFERDESCR BufferDescriptor,
    PPACKETSIZEIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(PACKETSIZEIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_PACKETSIZE)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional closed user group field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseClosedUserGroup(
    PBUFFERDESCR BufferDescriptor,
    PCLOSEDUGIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(CLOSEDUGIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_CLOSEDUG)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional reverse charge field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseReverseCharge(
    PBUFFERDESCR BufferDescriptor,
    PREVERSECHARGEIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(REVERSECHARGEIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_REVCHARGE)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional calling party number field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseCallingPartyNumber(
    PBUFFERDESCR BufferDescriptor,
    PCALLINGNUMBERIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(CALLINGNUMBERIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_CALLINGNUMBER)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional calling party subaddress field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseCallingPartySubaddress(
    PBUFFERDESCR BufferDescriptor,
    PCALLINGSUBADDRIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(CALLINGSUBADDRIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_CALLINGSUBADDR)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional called party number field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseCalledPartyNumber(
    PBUFFERDESCR BufferDescriptor, 
    PCALLEDNUMBERIE FieldStruct)
{
    memset(FieldStruct, 0, sizeof(PCALLEDNUMBERIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_CALLEDNUMBER)
    {
        register int i;
        BYTE RemainingLength = 0;
        BYTE *Tempptr;
    
        // Need 3 bytes for the ident (1), length (1),
        // and type + plan (1) fields.
        if (BufferDescriptor->Length < 3)
        {
            return CS_ENDOFINPUT;
        }

        // skip the ie identifier...    
        BufferDescriptor->BufferPtr++;
        BufferDescriptor->Length--;

        // Get the length of the contents following the length field.
        RemainingLength = *BufferDescriptor->BufferPtr;
        BufferDescriptor->BufferPtr++;
        BufferDescriptor->Length--;

        // make sure we have at least that much length left...    
        if (BufferDescriptor->Length < RemainingLength)
        {
            return CS_ENDOFINPUT;
        }

        // Get the type + plan fields.
        if (*(BufferDescriptor->BufferPtr) & 0x80)
        {
            FieldStruct->NumberType =
                (BYTE)(*BufferDescriptor->BufferPtr & 0xf0);
            FieldStruct->NumberingPlan =
                (BYTE)(*BufferDescriptor->BufferPtr & 0x0f);
            BufferDescriptor->BufferPtr++;
            BufferDescriptor->Length--;
            RemainingLength--;
        }

        FieldStruct->PartyNumberLength = RemainingLength;
        FieldStruct->Present = TRUE;

        Tempptr = FieldStruct->PartyNumbers;
        for (i = 0; i < RemainingLength; i++)
        {
            // Copy the bytes out of the rest of the buffer
            *Tempptr = *(BufferDescriptor->BufferPtr);
            BufferDescriptor->BufferPtr++;
            BufferDescriptor->Length--;
            Tempptr++;
        }
        *Tempptr = (BYTE)0;
    }
    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional called party subaddress field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseCalledPartySubaddress(
    PBUFFERDESCR BufferDescriptor,
    PCALLEDSUBADDRIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(CALLEDSUBADDRIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_CALLEDSUBADDR)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional redirecting number field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseRedirectingNumber(
    PBUFFERDESCR BufferDescriptor, 
    PREDIRECTINGIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(REDIRECTINGIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_REDIRECTING)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional transit network selection field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseTransitNetwork(
    PBUFFERDESCR BufferDescriptor, 
    PTRANSITNETIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(TRANSITNETIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_TRANSITNET)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional restart indicator field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseRestart(
    PBUFFERDESCR BufferDescriptor,
    PRESTARTIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(PRESTARTIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_RESTART)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional lower layer compatibility field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseLowLayerCompatibility(
    PBUFFERDESCR BufferDescriptor,
    PLLCOMPATIBILITYIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(LLCOMPATIBILITYIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_LLCOMPATIBILITY)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional higher layer compatibility field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseHighLayerCompatibility(
    PBUFFERDESCR BufferDescriptor,
    PHLCOMPATIBILITYIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(HLCOMPATIBILITYIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_HLCOMPATIBILITY)
    {
        HRESULT ParseResult;
        ParseResult = ParseVariableOctet(BufferDescriptor, 
            &Ident, &FieldStruct->Length, &FieldStruct->Contents[0]);
        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->Length > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse an optional user to user field
//
// Parameters:
//     BufferPtr    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     FieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
static HRESULT
ParseUserToUser(
    PBUFFERDESCR BufferDescriptor,
    PUSERUSERIE FieldStruct)
{
    BYTE Ident;
    
    memset(FieldStruct, 0, sizeof(USERUSERIE));
    FieldStruct->Present = FALSE;
    if (GetNextIdent(BufferDescriptor->BufferPtr) == IDENT_USERUSER)
    {
        HRESULT ParseResult;

        ParseResult = ParseVariableASN(BufferDescriptor, 
            &Ident, &(FieldStruct->ProtocolDiscriminator),
            &(FieldStruct->UserInformationLength),
            &(FieldStruct->UserInformation[0]));

        if (ParseResult != CS_OK)
        {
            return ParseResult;
        }
        if (FieldStruct->UserInformationLength > 0)
        {
            FieldStruct->Present = TRUE;
        }
    }

    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse the next Q931 field in the given message
//
// Parameters:
//      BufferDescriptor  Pointer to buffer descriptor of a 
//                        the network packet of the 931 message
//      Message           Pointer to space for parsed information.
//------------------------------------------------------------------------------
static HRESULT
ParseQ931Field(
    PBUFFERDESCR BufferDescriptor,
    PQ931MESSAGE Message)
{
    FIELDIDENTTYPE Ident;

    Ident = GetNextIdent(BufferDescriptor->BufferPtr);
    switch (Ident)
    {
    case IDENT_SHIFT:
        return ParseShift(BufferDescriptor,
            &Message->Shift);
    case IDENT_FACILITY:
        return ParseFacility(BufferDescriptor,
            &Message->Facility);
    case IDENT_MORE:
        return ParseMoreData(BufferDescriptor,
            &Message->MoreData);
    case IDENT_SENDINGCOMPLETE:
        return ParseSendingComplete(BufferDescriptor,
            &Message->SendingComplete);
    case IDENT_CONGESTION:
        return ParseCongestionLevel(BufferDescriptor,
            &Message->CongestionLevel);
    case IDENT_REPEAT:
        return ParseRepeatIndicator(BufferDescriptor,
            &Message->RepeatIndicator);
    case IDENT_SEGMENTED:
        return ParseSegmented(BufferDescriptor,
            &Message->SegmentedMessage);
    case IDENT_BEARERCAP:
        return ParseBearerCapability(BufferDescriptor,
            &Message->BearerCapability);
    case IDENT_CAUSE:
        return ParseCause(BufferDescriptor,
            &Message->Cause);
    case IDENT_CALLIDENT:
        return ParseCallIdentity(BufferDescriptor,
            &Message->CallIdentity);
    case IDENT_CALLSTATE:
        return ParseCallState(BufferDescriptor,
            &Message->CallState);
    case IDENT_CHANNELIDENT:
        return ParseChannelIdentification(BufferDescriptor,
            &Message->ChannelIdentification);
    case IDENT_PROGRESS:
        return ParseProgress(BufferDescriptor,
            &Message->ProgressIndicator);
    case IDENT_NETWORKSPEC:
        return ParseNetworkSpec(BufferDescriptor,
            &Message->NetworkFacilities);
    case IDENT_NOTIFICATION:
        return ParseNotificationIndicator(BufferDescriptor,
            &Message->NotificationIndicator);
    case IDENT_DISPLAY:
        return ParseDisplay(BufferDescriptor,
            &Message->Display);
    case IDENT_DATE:
        return ParseDate(BufferDescriptor,
            &Message->Date);
    case IDENT_KEYPAD:
        return ParseKeypad(BufferDescriptor,
            &Message->Keypad);
    case IDENT_SIGNAL:
        return ParseSignal(BufferDescriptor,
            &Message->Signal);
    case IDENT_INFORMATIONRATE:
        return ParseInformationRate(BufferDescriptor,
            &Message->InformationRate);
    case IDENT_ENDTOENDDELAY:
        return ParseEndToEndDelay(BufferDescriptor,
            &Message->EndToEndTransitDelay);
    case IDENT_TRANSITDELAY:
        return ParseTransitDelay(BufferDescriptor,
            &Message->TransitDelay);
    case IDENT_PLBINARYPARAMS:
        return ParsePacketLayerParams(BufferDescriptor,
            &Message->PacketLayerBinaryParams);
    case IDENT_PLWINDOWSIZE:
        return ParsePacketLayerWindowSize(BufferDescriptor,
            &Message->PacketLayerWindowSize);
    case IDENT_PACKETSIZE:
        return ParsePacketSize(BufferDescriptor,
            &Message->PacketSize);
    case IDENT_CLOSEDUG:
        return ParseClosedUserGroup(BufferDescriptor,
            &Message->ClosedUserGroup);
    case IDENT_REVCHARGE:
        return ParseReverseCharge(BufferDescriptor,
            &Message->ReverseChargeIndication);
    case IDENT_CALLINGNUMBER:
        return ParseCallingPartyNumber(BufferDescriptor,
            &Message->CallingPartyNumber);
    case IDENT_CALLINGSUBADDR:
        return ParseCallingPartySubaddress(BufferDescriptor,
            &Message->CallingPartySubaddress);
    case IDENT_CALLEDNUMBER:
        return ParseCalledPartyNumber(BufferDescriptor,
            &Message->CalledPartyNumber);
    case IDENT_CALLEDSUBADDR:
        return ParseCalledPartySubaddress(BufferDescriptor,
            &Message->CalledPartySubaddress);
    case IDENT_REDIRECTING:
        return ParseRedirectingNumber(BufferDescriptor,
            &Message->RedirectingNumber);
    case IDENT_TRANSITNET:
        return ParseTransitNetwork(BufferDescriptor,
            &Message->TransitNetworkSelection);
    case IDENT_RESTART:
        return ParseRestart(BufferDescriptor,
            &Message->RestartIndicator);
    case IDENT_LLCOMPATIBILITY:
        return ParseLowLayerCompatibility(BufferDescriptor,
            &Message->LowLayerCompatibility);
    case IDENT_HLCOMPATIBILITY:
        return ParseHighLayerCompatibility(BufferDescriptor,
            &Message->HighLayerCompatibility);
    case IDENT_USERUSER:
        return ParseUserToUser(BufferDescriptor,
            &Message->UserToUser);
    default:
        return CS_INVALID_FIELD;
    }
}

//------------------------------------------------------------------------------
// Parse a generic Q931 message and place the fields of the buffer
// into the appropriate structure fields.
//
// Parameters:
//     BufferDescriptor  Pointer to buffer descriptor of an
//                       input packet containing the 931 message.
//     Message           Pointer to space for parsed output information.
//------------------------------------------------------------------------------
HRESULT
Q931ParseMessage(
    BYTE *CodedBufferPtr,
    DWORD CodedBufferLength,
    PQ931MESSAGE Message)
{
    HRESULT Result;
    BUFFERDESCR BufferDescriptor;

    BufferDescriptor.Length = CodedBufferLength;
    BufferDescriptor.BufferPtr = CodedBufferPtr;

    memset(Message, 0, sizeof(Q931MESSAGE));

    if ((Result = ParseProtocolDiscriminator(&BufferDescriptor,
        &Message->ProtocolDiscriminator)) != CS_OK)
    {
        return Result;
    }

    if ((Result = ParseCallReference(&BufferDescriptor,
        &Message->CallReference)) != CS_OK)
    {
        return Result;
    }

    if ((Result = ParseMessageType(&BufferDescriptor,
        &Message->MessageType)) != CS_OK)
    {
        return Result;
    }

    while (BufferDescriptor.Length)
    {
        Result = ParseQ931Field(&BufferDescriptor, Message);
        if (Result != CS_OK)
        {
            return Result;
        }
    }
    return CS_OK;
}


//==============================================================================
//==============================================================================
//==============================================================================
// BELOW HERE ARE THE OUTPUT ROUTINES...
//==============================================================================
//==============================================================================
//==============================================================================


//------------------------------------------------------------------------------
// Write the protocol discriminator. See Q931 section 4.2.
//------------------------------------------------------------------------------
static HRESULT
WriteProtocolDiscriminator(
    PBUFFERDESCR BufferDescriptor)
{
    BufferDescriptor->Length += sizeof(PDTYPE);
    if (BufferDescriptor->BufferPtr)
    {
        *(PDTYPE *)BufferDescriptor->BufferPtr = Q931PDVALUE;
        BufferDescriptor->BufferPtr += sizeof(PDTYPE);
    }
    return CS_OK;
}

//------------------------------------------------------------------------------
// Write a variable length Q931 call reference.  See Q931 section 4.3.
//------------------------------------------------------------------------------
static HRESULT
WriteCallReference(
    PBUFFERDESCR BufferDescriptor,
    CRTYPE *CallReference)
{
    register int i;

    // space for the length byte
    BufferDescriptor->Length++;

    // the length byte
    if (BufferDescriptor->BufferPtr != NULL)
    {
        *BufferDescriptor->BufferPtr = (BYTE)sizeof(CRTYPE);
        BufferDescriptor->BufferPtr++;
    }

    for (i = 0; i < sizeof(CRTYPE); i++)
    {
        // Copy the value bytes to the buffer
        BufferDescriptor->Length++;
        if (BufferDescriptor->BufferPtr != NULL)
        {
            *BufferDescriptor->BufferPtr =
                (BYTE)(((*CallReference) >> ((sizeof(CRTYPE) - 1 -i) * 8)) & 0xff);
            BufferDescriptor->BufferPtr++;
        }
    }
    return CS_OK;
}

//------------------------------------------------------------------------------
// Write a Q931 message type.  See Q931 section 4.4.
//------------------------------------------------------------------------------
static HRESULT
WriteMessageType(
    PBUFFERDESCR BufferDescriptor,
    MESSAGEIDTYPE *MessageType)
{
    register int i;

    for (i = 0; i < sizeof(MessageSet) / sizeof(MESSAGEIDTYPE); i++)
    {
        if (MessageSet[i] == *MessageType)
        {
            break;
        }
    }
    if (i >= sizeof(MessageSet) / sizeof(MESSAGEIDTYPE))
    {
        return CS_INVALID_MESSAGE_TYPE;
    }

    BufferDescriptor->Length += sizeof(MESSAGEIDTYPE);
    if (BufferDescriptor->BufferPtr != NULL)
    {
        *(MESSAGEIDTYPE *)(BufferDescriptor->BufferPtr) =
            (BYTE)(*MessageType & MESSAGETYPEMASK);
        BufferDescriptor->BufferPtr += sizeof(MESSAGEIDTYPE);
    }
    return CS_OK;
}

//------------------------------------------------------------------------------
// Write a single octet encoded value, See Q931 section 4.5.1.
//------------------------------------------------------------------------------
static HRESULT 
WriteSingleOctetType1(
    PBUFFERDESCR BufferDescriptor,
    BYTE Ident,
    BYTE Value)
{
    BufferDescriptor->Length++;
    if (BufferDescriptor->BufferPtr)
    {
        *BufferDescriptor->BufferPtr =
            (BYTE)(0x80 | Ident | (Value & TYPE1VALUEMASK));
        BufferDescriptor->BufferPtr++;
    }
    return CS_OK;
}

//------------------------------------------------------------------------------
// Write a single octet encoded value, See Q931 section 4.5.1.
//------------------------------------------------------------------------------
static HRESULT 
WriteSingleOctetType2(
    PBUFFERDESCR BufferDescriptor,
    BYTE Ident)
{
    BufferDescriptor->Length++;
    if (BufferDescriptor->BufferPtr)
    {
        *BufferDescriptor->BufferPtr = (BYTE)(0x80 | Ident);
        BufferDescriptor->BufferPtr++;
    }
    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse and return a variable length Q931 field see Q931 section 4.5.1.
//------------------------------------------------------------------------------
static HRESULT 
WriteVariableOctet(
    PBUFFERDESCR BufferDescriptor,
    BYTE Ident,
    BYTE Length,
    BYTE *Contents)
{
    register int i;
    BYTE *Tempptr;

    if (Contents == NULL)
    {
        Length = 0;
    }

    // space for the length and the identifier bytes
    BufferDescriptor->Length += 2;

    // the id byte, then the length byte
    if (BufferDescriptor->BufferPtr != NULL)
    {
        // low 7 bits of the first byte are the identifier
        *BufferDescriptor->BufferPtr = (BYTE)(Ident & 0x7f);
        BufferDescriptor->BufferPtr++;
        *BufferDescriptor->BufferPtr = Length;
        BufferDescriptor->BufferPtr++;
    }

    Tempptr = Contents;
    for (i = 0; i < Length; i++)
    {
        // Copy the value bytes to the buffer
        BufferDescriptor->Length++;
        if (BufferDescriptor->BufferPtr != NULL)
        {
            *BufferDescriptor->BufferPtr = *Tempptr;
            BufferDescriptor->BufferPtr++;
            Tempptr++;
        }
    }
    return CS_OK;
}

//------------------------------------------------------------------------------
//Write out the Party number.
//------------------------------------------------------------------------------
static HRESULT 
WritePartyNumber(
    PBUFFERDESCR BufferDescriptor,
    BYTE Ident,
    BYTE NumberType,
    BYTE NumberingPlan,
    BYTE PartyNumberLength,
    BYTE *PartyNumbers)
{
    register int i;
    BYTE *Tempptr;

    if (PartyNumbers == NULL)
    {
        PartyNumberLength = 0;
    }

    // space for the ident (1), length (1), and type + plan (1) fields.
    BufferDescriptor->Length += 3;

    // write the fields out.
    if (BufferDescriptor->BufferPtr != NULL)
    {
        // low 7 bits of byte 1 are the ie identifier
        *BufferDescriptor->BufferPtr = (BYTE)(Ident & 0x7f);
        BufferDescriptor->BufferPtr++;

        // byte 2 is the ie contents length following the length field.
        *BufferDescriptor->BufferPtr = (BYTE)(PartyNumberLength + 1);
        BufferDescriptor->BufferPtr++;

        // byte 3 is the type and plan field.
        *BufferDescriptor->BufferPtr = (BYTE)(NumberType | NumberingPlan);
        BufferDescriptor->BufferPtr++;
    }

    Tempptr = PartyNumbers;
    for (i = 0; i < PartyNumberLength; i++)
    {
        // Copy the value bytes to the buffer
        BufferDescriptor->Length++;
        if (BufferDescriptor->BufferPtr != NULL)
        {
            *BufferDescriptor->BufferPtr = *Tempptr;
            BufferDescriptor->BufferPtr++;
            Tempptr++;
        }
    }
    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse and return a variable length Q931 field see Q931 section 4.5.1.
//------------------------------------------------------------------------------
static HRESULT 
WriteVariableASN(
    PBUFFERDESCR BufferDescriptor,
    BYTE Ident,
    WORD UserInformationLength,
    BYTE *UserInformation)
{
    register int i;
    BYTE *Tempptr;
    WORD ContentsLength = (WORD)(UserInformationLength + 1);

    // There has to be at least 4 bytes for the IE identifier,
    // the contents length, and the protocol discriminator (1 + 2 + 1).
    BufferDescriptor->Length += 4;

    if (BufferDescriptor->BufferPtr != NULL)
    {
        // low 7 bits of the first byte are the identifier
        *BufferDescriptor->BufferPtr = (BYTE)(Ident & 0x7f);
        BufferDescriptor->BufferPtr++;

        // write the contents length bytes.
        *BufferDescriptor->BufferPtr = (BYTE)(ContentsLength >> 8);
        BufferDescriptor->BufferPtr++;
        *BufferDescriptor->BufferPtr = (BYTE)ContentsLength;
        BufferDescriptor->BufferPtr++;

        // write the protocol discriminator byte.
        *(BufferDescriptor->BufferPtr) = Q931_PROTOCOL_X209;
        BufferDescriptor->BufferPtr++;
    }

    Tempptr = UserInformation;
    for (i = 0; i < UserInformationLength; i++)
    {
        // Copy the value bytes to the buffer
        BufferDescriptor->Length++;
        if (BufferDescriptor->BufferPtr != NULL)
        {
            *BufferDescriptor->BufferPtr = *Tempptr;
            BufferDescriptor->BufferPtr++;
            Tempptr++;
        }
    }
    return CS_OK;
}

//------------------------------------------------------------------------------
// Write the Q931 fields to the encoding buffer.
//
// Parameters:
//      BufferDescriptor  Pointer to buffer descriptor for
//                        the encoded output buffer.
//      Message           Pointer to space for parsed input information.
//------------------------------------------------------------------------------
static HRESULT
WriteQ931Fields(
    PBUFFERDESCR BufferDescriptor,
    PQ931MESSAGE Message)
{
    // write the required information elements...
    WriteProtocolDiscriminator(BufferDescriptor);
    WriteCallReference(BufferDescriptor,
        &Message->CallReference);
    WriteMessageType(BufferDescriptor,
        &Message->MessageType);

    // try to write all other information elements...
// don't write this message.
#if 0
    if (Message->Shift.Present)
    {
        WriteSingleOctetType1(BufferDescriptor, IDENT_SHIFT,
            Message->Shift.Value);
    }
#endif

    if (Message->Facility.Present)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_FACILITY,
            Message->Facility.Length,
            Message->Facility.Contents);
    }

    if (Message->MoreData.Present)
    {
        WriteSingleOctetType2(BufferDescriptor, IDENT_MORE);
    }
    if (Message->SendingComplete.Present)
    {
        WriteSingleOctetType2(BufferDescriptor, IDENT_SENDINGCOMPLETE);
    }
    if (Message->CongestionLevel.Present)
    {
        WriteSingleOctetType1(BufferDescriptor, IDENT_CONGESTION,
            Message->CongestionLevel.Value);
    }
    if (Message->RepeatIndicator.Present)
    {
        WriteSingleOctetType1(BufferDescriptor, IDENT_REPEAT,
            Message->RepeatIndicator.Value);
    }

    if (Message->SegmentedMessage.Present &&
            Message->SegmentedMessage.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_SEGMENTED,
            Message->SegmentedMessage.Length,
            Message->SegmentedMessage.Contents);
    }
    if (Message->BearerCapability.Present &&
            Message->BearerCapability.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_BEARERCAP,
            Message->BearerCapability.Length,
            Message->BearerCapability.Contents);
    }
    if (Message->Cause.Present &&
            Message->Cause.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_CAUSE,
            Message->Cause.Length,
            Message->Cause.Contents);
    }
    if (Message->CallIdentity.Present &&
            Message->CallIdentity.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_CALLIDENT,
            Message->CallIdentity.Length,
            Message->CallIdentity.Contents);
    }
    if (Message->CallState.Present &&
            Message->CallState.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_CALLSTATE,
            Message->CallState.Length,
            Message->CallState.Contents);
    }
    if (Message->ChannelIdentification.Present &&
            Message->ChannelIdentification.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_CHANNELIDENT,
            Message->ChannelIdentification.Length,
            Message->ChannelIdentification.Contents);
    }
    if (Message->ProgressIndicator.Present &&
            Message->ProgressIndicator.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_PROGRESS,
            Message->ProgressIndicator.Length,
            Message->ProgressIndicator.Contents);
    }
    if (Message->NetworkFacilities.Present &&
            Message->NetworkFacilities.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_NETWORKSPEC,
            Message->NetworkFacilities.Length,
            Message->NetworkFacilities.Contents);
    }
    if (Message->NotificationIndicator.Present &&
            Message->NotificationIndicator.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_NOTIFICATION,
            Message->NotificationIndicator.Length,
            Message->NotificationIndicator.Contents);
    }
    if (Message->Display.Present &&
            Message->Display.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_DISPLAY,
            Message->Display.Length,
            Message->Display.Contents);
    }
    if (Message->Date.Present &&
            Message->Date.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_DATE,
            Message->Date.Length,
            Message->Date.Contents);
    }
    if (Message->Keypad.Present &&
            Message->Keypad.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_KEYPAD,
            Message->Keypad.Length,
            Message->Keypad.Contents);
    }
    if (Message->Signal.Present &&
            Message->Signal.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_SIGNAL,
            Message->Signal.Length,
            Message->Signal.Contents);
    }
    if (Message->InformationRate.Present &&
            Message->InformationRate.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_INFORMATIONRATE,
            Message->InformationRate.Length,
            Message->InformationRate.Contents);
    }
    if (Message->EndToEndTransitDelay.Present &&
            Message->EndToEndTransitDelay.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_ENDTOENDDELAY,
            Message->EndToEndTransitDelay.Length,
            Message->EndToEndTransitDelay.Contents);
    }
    if (Message->TransitDelay.Present &&
            Message->TransitDelay.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_TRANSITDELAY,
            Message->TransitDelay.Length,
            Message->TransitDelay.Contents);
    }
    if (Message->PacketLayerBinaryParams.Present &&
            Message->PacketLayerBinaryParams.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_PLBINARYPARAMS,
            Message->PacketLayerBinaryParams.Length,
            Message->PacketLayerBinaryParams.Contents);
    }
    if (Message->PacketLayerWindowSize.Present &&
            Message->PacketLayerWindowSize.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_PLWINDOWSIZE,
            Message->PacketLayerWindowSize.Length,
            Message->PacketLayerWindowSize.Contents);
    }
    if (Message->PacketSize.Present &&
            Message->PacketSize.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_PACKETSIZE,
            Message->PacketSize.Length,
            Message->PacketSize.Contents);
    }
    if (Message->ClosedUserGroup.Present &&
            Message->ClosedUserGroup.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_CLOSEDUG,
            Message->ClosedUserGroup.Length,
            Message->ClosedUserGroup.Contents);
    }
    if (Message->ReverseChargeIndication.Present &&
            Message->ReverseChargeIndication.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_REVCHARGE,
            Message->ReverseChargeIndication.Length,
            Message->ReverseChargeIndication.Contents);
    }
    if (Message->CallingPartyNumber.Present &&
            Message->CallingPartyNumber.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_CALLINGNUMBER,
            Message->CallingPartyNumber.Length,
            Message->CallingPartyNumber.Contents);
    }
    if (Message->CallingPartySubaddress.Present &&
            Message->CallingPartySubaddress.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_CALLINGSUBADDR,
            Message->CallingPartySubaddress.Length,
            Message->CallingPartySubaddress.Contents);
    }
    if (Message->CalledPartyNumber.Present)
    {
        WritePartyNumber(BufferDescriptor, IDENT_CALLEDNUMBER,
            Message->CalledPartyNumber.NumberType,
            Message->CalledPartyNumber.NumberingPlan,
            Message->CalledPartyNumber.PartyNumberLength,
            Message->CalledPartyNumber.PartyNumbers);
     }
    if (Message->CalledPartySubaddress.Present &&
            Message->CalledPartySubaddress.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_CALLEDSUBADDR,
            Message->CalledPartySubaddress.Length,
            Message->CalledPartySubaddress.Contents);
    }
    if (Message->RedirectingNumber.Present &&
            Message->RedirectingNumber.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_REDIRECTING,
            Message->RedirectingNumber.Length,
            Message->RedirectingNumber.Contents);
    }
    if (Message->TransitNetworkSelection.Present &&
            Message->TransitNetworkSelection.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_TRANSITNET,
            Message->TransitNetworkSelection.Length,
            Message->TransitNetworkSelection.Contents);
    }
    if (Message->RestartIndicator.Present &&
            Message->RestartIndicator.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_RESTART,
            Message->RestartIndicator.Length,
            Message->RestartIndicator.Contents);
    }
    if (Message->LowLayerCompatibility.Present &&
            Message->LowLayerCompatibility.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_LLCOMPATIBILITY,
            Message->LowLayerCompatibility.Length,
            Message->LowLayerCompatibility.Contents);
    }
    if (Message->HighLayerCompatibility.Present &&
            Message->HighLayerCompatibility.Length)
    {
        WriteVariableOctet(BufferDescriptor, IDENT_HLCOMPATIBILITY,
            Message->HighLayerCompatibility.Length,
            Message->HighLayerCompatibility.Contents);
    }
    if (Message->UserToUser.Present &&
            Message->UserToUser.UserInformationLength)
    {
        WriteVariableASN(BufferDescriptor,
            IDENT_USERUSER,
            Message->UserToUser.UserInformationLength,
            Message->UserToUser.UserInformation);
    }
    return CS_OK;
}

//------------------------------------------------------------------------------
// Parse a generic Q931 message and place the fields of the 
// of the buffer into the appropriate field structure.
//
// Parameters:
//     BufferDescriptor  Pointer to buffer descriptor of a 
//                       the network packet of the 931 message
//     Message           Pointer to space for parsed information.
//------------------------------------------------------------------------------
HRESULT
Q931MakeEncodedMessage(
    PQ931MESSAGE Message,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength)
{
    BUFFERDESCR BufferDescriptor;
    BYTE *OutBuffer = NULL;
    DWORD Pass1Length = 0;

    if ((CodedBufferPtr == NULL) || (CodedBufferLength == NULL))
    {
        return CS_BAD_PARAM;
    }

    BufferDescriptor.Length = 0;
    BufferDescriptor.BufferPtr = NULL;

    WriteQ931Fields(&BufferDescriptor, Message);
    if (BufferDescriptor.Length == 0)
    {
        return CS_NO_FIELD_DATA;
    }

    Pass1Length = BufferDescriptor.Length;

    OutBuffer = (BYTE *)Malloc(BufferDescriptor.Length + 1000);
    if (OutBuffer == NULL)
    {
        return CS_NO_MEMORY;
    }

    BufferDescriptor.Length = 0;
    BufferDescriptor.BufferPtr = OutBuffer;

    WriteQ931Fields(&BufferDescriptor, Message);

    if (Pass1Length != BufferDescriptor.Length)
    {
        // this is a serious error, since memory may have been overrun.
        return CS_BAD_PARAM;
    }

    *CodedBufferPtr = OutBuffer;
    *CodedBufferLength = BufferDescriptor.Length;

    return CS_OK;
}


//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931SetupEncodePDU(
    WORD wCallReference,
    char *pszDisplay,
    char *pszCalledPartyNumber,
	DWORD dwBandwidth,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength)
{
    Q931MESSAGE *pMessage;
    HRESULT Result = CS_OK;
	BYTE bBandwidth;

    pMessage = (Q931MESSAGE *)Malloc(sizeof(Q931MESSAGE));
    if (pMessage == NULL)
    {
        return CS_NO_MEMORY;
    }

    // fill in the required fields for the setup message.
    memset(pMessage, 0, sizeof(Q931MESSAGE));
    pMessage->ProtocolDiscriminator = Q931PDVALUE;
    pMessage->CallReference = wCallReference;
    pMessage->MessageType = SETUPMESSAGETYPE;

    pMessage->BearerCapability.Present = TRUE;
    pMessage->BearerCapability.Length = 4;
    pMessage->BearerCapability.Contents[0] =
        (BYTE)(BEAR_EXT_BIT | BEAR_CCITT | BEAR_UNRESTRICTED_DIGITAL);
    pMessage->BearerCapability.Contents[1] = 
        (BYTE)(BEAR_CIRCUIT_MODE | BEAR_MULTIRATE);
	bBandwidth = (BYTE)(dwBandwidth / 64000);
	if ((dwBandwidth % 64000) != 0)
		bBandwidth++;
    pMessage->BearerCapability.Contents[2] =
		(BYTE)(BEAR_EXT_BIT | bBandwidth);
    pMessage->BearerCapability.Contents[3] = 
        (BYTE)(BEAR_EXT_BIT | BEAR_LAYER1_INDICATOR | BEAR_LAYER1_H221_H242);

    if (pszDisplay && *pszDisplay)
    {
        pMessage->Display.Present = TRUE;
        pMessage->Display.Length = (BYTE)(strlen(pszDisplay) + 1);
        strcpy((char *)pMessage->Display.Contents, pszDisplay);
    }

    if (pszCalledPartyNumber && *pszCalledPartyNumber)
    {
        WORD wLen = (WORD)strlen(pszCalledPartyNumber);
        pMessage->CalledPartyNumber.Present = TRUE;

        pMessage->CalledPartyNumber.NumberType =
            (BYTE)(CALLED_PARTY_EXT_BIT | CALLED_PARTY_TYPE_UNKNOWN);
        pMessage->CalledPartyNumber.NumberingPlan =
            (BYTE)(CALLED_PARTY_PLAN_E164);
        pMessage->CalledPartyNumber.PartyNumberLength = (BYTE)wLen;
        memcpy(pMessage->CalledPartyNumber.PartyNumbers,
            pszCalledPartyNumber, wLen);
    }

    if (pUserUserData && pUserUserData->ptr)
    {
        if (pUserUserData->length > sizeof(pMessage->UserToUser.UserInformation))
        {
            Free(pMessage);
            return CS_BAD_PARAM;
        }
        pMessage->UserToUser.Present = TRUE;
        pMessage->UserToUser.UserInformationLength = (pUserUserData->length);
        memcpy(pMessage->UserToUser.UserInformation,
            pUserUserData->ptr, pUserUserData->length);
    }
    Result = Q931MakeEncodedMessage(pMessage, CodedBufferPtr,
        CodedBufferLength);

    Free(pMessage);
    return Result;
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931ReleaseCompleteEncodePDU(
    WORD wCallReference,
    BYTE *pbCause,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength)
{
    Q931MESSAGE *pMessage;
    HRESULT Result = CS_OK;

    if (pbCause)
    {
        switch (*pbCause)
        {
            case CAUSE_VALUE_NORMAL_CLEAR:
            case CAUSE_VALUE_USER_BUSY:
            case CAUSE_VALUE_NO_ANSWER:
            case CAUSE_VALUE_REJECTED:
            case CAUSE_VALUE_NOT_IMPLEMENTED:
            case CAUSE_VALUE_INVALID_CRV:
            case CAUSE_VALUE_IE_MISSING:
            case CAUSE_VALUE_IE_CONTENTS:
            case CAUSE_VALUE_TIMER_EXPIRED:
                break;
            default:
                return CS_BAD_PARAM;
                break;
        }
    }

    pMessage = (Q931MESSAGE *)Malloc(sizeof(Q931MESSAGE));
    if (pMessage == NULL)
    {
        return CS_NO_MEMORY;
    }

    // fill in the required fields for the setup message.
    memset(pMessage, 0, sizeof(Q931MESSAGE));
    pMessage->ProtocolDiscriminator = Q931PDVALUE;
    pMessage->CallReference = wCallReference;
    pMessage->MessageType = RELEASECOMPLMESSAGETYPE;

    if (pbCause)
    {
        pMessage->Cause.Present = TRUE;
        pMessage->Cause.Length = 3;
        pMessage->Cause.Contents[0] = (BYTE)(CAUSE_CODING_CCITT | CAUSE_LOCATION_USER);
        pMessage->Cause.Contents[1] = (BYTE)(CAUSE_RECOMMENDATION_Q931);
        pMessage->Cause.Contents[2] = (BYTE)(CAUSE_EXT_BIT | *pbCause);
    }
    else
    {
        pMessage->Cause.Present = FALSE;
    }

    if (pUserUserData && pUserUserData->ptr)
    {
        if (pUserUserData->length > sizeof(pMessage->UserToUser.UserInformation))
        {
            Free(pMessage);
            return CS_BAD_PARAM;
        }
        pMessage->UserToUser.Present = TRUE;
        pMessage->UserToUser.UserInformationLength = (pUserUserData->length);
        memcpy(pMessage->UserToUser.UserInformation,
            pUserUserData->ptr, pUserUserData->length);
    }
    Result = Q931MakeEncodedMessage(pMessage, CodedBufferPtr,
        CodedBufferLength);

    Free(pMessage);
    return Result;
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931ConnectEncodePDU(
    WORD wCallReference,
    char *pszDisplay,
	DWORD dwBandwidth,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength)
{
    Q931MESSAGE *pMessage;
    HRESULT Result = CS_OK;
	BYTE bBandwidth;

    pMessage = (Q931MESSAGE *)Malloc(sizeof(Q931MESSAGE));
    if (pMessage == NULL)
    {
        return CS_NO_MEMORY;
    }

    // fill in the required fields for the setup message.
    memset(pMessage, 0, sizeof(Q931MESSAGE));
    pMessage->ProtocolDiscriminator = Q931PDVALUE;
    pMessage->CallReference = wCallReference;
    pMessage->MessageType = CONNECTMESSAGETYPE;

    pMessage->BearerCapability.Present = TRUE;
    pMessage->BearerCapability.Length = 4;
    pMessage->BearerCapability.Contents[0] =
        (BYTE)(BEAR_EXT_BIT | BEAR_CCITT | BEAR_UNRESTRICTED_DIGITAL);
    pMessage->BearerCapability.Contents[1] = 
        (BYTE)(BEAR_CIRCUIT_MODE | BEAR_MULTIRATE);
	bBandwidth = (BYTE)(dwBandwidth / 64000);
	if ((dwBandwidth % 64000) != 0)
		bBandwidth++;
    pMessage->BearerCapability.Contents[2] =
		(BYTE)(BEAR_EXT_BIT | bBandwidth);
    pMessage->BearerCapability.Contents[3] = 
        (BYTE)(BEAR_EXT_BIT | BEAR_LAYER1_INDICATOR | BEAR_LAYER1_H221_H242);

    if (pszDisplay && *pszDisplay)
    {
        pMessage->Display.Present = TRUE;
        pMessage->Display.Length = (BYTE)strlen(pszDisplay);
        strcpy((char *)pMessage->Display.Contents, pszDisplay);
    }

    if (pUserUserData && pUserUserData->ptr)
    {
        if (pUserUserData->length > sizeof(pMessage->UserToUser.UserInformation))
        {
            Free(pMessage);
            return CS_BAD_PARAM;
        }
        pMessage->UserToUser.Present = TRUE;
        pMessage->UserToUser.UserInformationLength = (pUserUserData->length);
        memcpy(pMessage->UserToUser.UserInformation,
            pUserUserData->ptr, pUserUserData->length);
    }
    Result = Q931MakeEncodedMessage(pMessage, CodedBufferPtr,
        CodedBufferLength);

    Free(pMessage);
    return Result;
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931ProceedingEncodePDU(
    WORD wCallReference,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength)
{
    Q931MESSAGE *pMessage;
    HRESULT Result = CS_OK;

    pMessage = (Q931MESSAGE *)Malloc(sizeof(Q931MESSAGE));
    if (pMessage == NULL)
    {
        return CS_NO_MEMORY;
    }

    // fill in the required fields for the setup message.
    memset(pMessage, 0, sizeof(Q931MESSAGE));
    pMessage->ProtocolDiscriminator = Q931PDVALUE;
    pMessage->CallReference = wCallReference;
    pMessage->MessageType = PROCEEDINGMESSAGETYPE;

    if (pUserUserData && pUserUserData->ptr)
    {
        if (pUserUserData->length > sizeof(pMessage->UserToUser.UserInformation))
        {
            Free(pMessage);
            return CS_BAD_PARAM;
        }
        pMessage->UserToUser.Present = TRUE;
        pMessage->UserToUser.UserInformationLength = (pUserUserData->length);
        memcpy(pMessage->UserToUser.UserInformation,
            pUserUserData->ptr, pUserUserData->length);
    }
    Result = Q931MakeEncodedMessage(pMessage, CodedBufferPtr,
        CodedBufferLength);

    Free(pMessage);
    return Result;
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931AlertingEncodePDU(
    WORD wCallReference,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength)
{
    Q931MESSAGE *pMessage;
    HRESULT Result = CS_OK;

    pMessage = (Q931MESSAGE *)Malloc(sizeof(Q931MESSAGE));
    if (pMessage == NULL)
    {
        return CS_NO_MEMORY;
    }

    // fill in the required fields for the setup message.
    memset(pMessage, 0, sizeof(Q931MESSAGE));
    pMessage->ProtocolDiscriminator = Q931PDVALUE;
    pMessage->CallReference = wCallReference;
    pMessage->MessageType = ALERTINGMESSAGETYPE;

    if (pUserUserData && pUserUserData->ptr)
    {
        if (pUserUserData->length > sizeof(pMessage->UserToUser.UserInformation))
        {
            Free(pMessage);
            return CS_BAD_PARAM;
        }
        pMessage->UserToUser.Present = TRUE;
        pMessage->UserToUser.UserInformationLength = (pUserUserData->length);
        memcpy(pMessage->UserToUser.UserInformation,
            pUserUserData->ptr, pUserUserData->length);
    }
    Result = Q931MakeEncodedMessage(pMessage, CodedBufferPtr,
        CodedBufferLength);

    Free(pMessage);
    return Result;
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931FacilityEncodePDU(
    WORD wCallReference,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength)
{
    Q931MESSAGE *pMessage;
    HRESULT Result = CS_OK;

    pMessage = (Q931MESSAGE *)Malloc(sizeof(Q931MESSAGE));
    if (pMessage == NULL)
    {
        return CS_NO_MEMORY;
    }

    // fill in the required fields for the setup message.
    memset(pMessage, 0, sizeof(Q931MESSAGE));
    pMessage->ProtocolDiscriminator = Q931PDVALUE;
    pMessage->CallReference = wCallReference;
    pMessage->MessageType = FACILITYMESSAGETYPE;

    // The facility ie is encoded as present, but empty...
    pMessage->Facility.Present = TRUE;
    pMessage->Facility.Length = 0;
    pMessage->Facility.Contents[0] = 0;

    if (pUserUserData && pUserUserData->ptr)
    {
        if (pUserUserData->length > sizeof(pMessage->UserToUser.UserInformation))
        {
            Free(pMessage);
            return CS_BAD_PARAM;
        }
        pMessage->UserToUser.Present = TRUE;
        pMessage->UserToUser.UserInformationLength = (pUserUserData->length);
        memcpy(pMessage->UserToUser.UserInformation,
            pUserUserData->ptr, pUserUserData->length);
    }
    Result = Q931MakeEncodedMessage(pMessage, CodedBufferPtr,
        CodedBufferLength);

    Free(pMessage);
    return Result;
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931StatusEncodePDU(
    WORD wCallReference,
    char *pszDisplay,
    BYTE bCause,
    BYTE bCallState,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength)
{
    Q931MESSAGE *pMessage;
    HRESULT Result = CS_OK;

    pMessage = (Q931MESSAGE *)Malloc(sizeof(Q931MESSAGE));
    if (pMessage == NULL)
    {
        return CS_NO_MEMORY;
    }

    // fill in the required fields for the setup message.
    memset(pMessage, 0, sizeof(Q931MESSAGE));
    pMessage->ProtocolDiscriminator = Q931PDVALUE;
    pMessage->CallReference = wCallReference;
    pMessage->MessageType = STATUSMESSAGETYPE;

    if (pszDisplay && *pszDisplay)
    {
        pMessage->Display.Present = TRUE;
        pMessage->Display.Length = (BYTE)(strlen(pszDisplay) + 1);
        strcpy((char *)pMessage->Display.Contents, pszDisplay);
    }

    pMessage->Cause.Present = TRUE;
    pMessage->Cause.Length = 3;
    pMessage->Cause.Contents[0] = (BYTE)(CAUSE_CODING_CCITT | CAUSE_LOCATION_USER);
    pMessage->Cause.Contents[1] = (BYTE)(CAUSE_RECOMMENDATION_Q931);
    pMessage->Cause.Contents[2] = (BYTE)(CAUSE_EXT_BIT | bCause);

    pMessage->CallState.Present = TRUE;
    pMessage->CallState.Length = 1;
    pMessage->CallState.Contents[0] = (BYTE)(bCallState);

    Result = Q931MakeEncodedMessage(pMessage, CodedBufferPtr,
        CodedBufferLength);

    Free(pMessage);
    return Result;
}
#if(0)
//========================================================================
//========================================================================
//========================================================================
// THIS IS THE ASN PART...
//========================================================================
//========================================================================
//========================================================================

static ERROR_MAP EncodeErrorMap[] =
{
    PDU_ENCODED, __TEXT("PDU successfully encoded"),
    MORE_BUF, __TEXT("User-provided output buffer too small"),
    PDU_RANGE, __TEXT("PDU specified out of range"),
    BAD_ARG, __TEXT("Bad pointer was passed"),
    BAD_VERSION, __TEXT("Versions of encoder and table do not match"),
    OUT_MEMORY, __TEXT("Memory-allocation error"),
    BAD_CHOICE, __TEXT("Unknown selector for a choice"),
    BAD_OBJID, __TEXT("Object identifier conflicts with x.208"),
    BAD_PTR, __TEXT("Unexpected NULL pointer in input buffer"),
    BAD_TIME, __TEXT("Bad value in time type"),
    MEM_ERROR, __TEXT("Memory violation signal trapped"),
    BAD_TABLE, __TEXT("Table was bad, but not NULL"),
    TOO_LONG, __TEXT("Type was longer than constraint"),
    CONSTRAINT_VIOLATED, __TEXT("Constraint violation error occured"),
    FATAL_ERROR, __TEXT("Serious internal error"),
    ACCESS_SERIALIZATION_ERROR, __TEXT("Thread access to global data failed"),
    NULL_TBL, __TEXT("NULL control table pointer"),
    NULL_FCN, __TEXT("Encoder called via a NULL pointer"),
    BAD_ENCRULES, __TEXT("Unknown encoding rules"),
    UNAVAIL_ENCRULES, __TEXT("Encoding rules requested are not implemented"),
    UNIMPLEMENTED, __TEXT("Type was not implemented yet"),
//    LOAD_ERR, __TEXT("Unable to load DLL"),
    CANT_OPEN_TRACE_FILE, __TEXT("Error when opening a trace file"),
    TRACE_FILE_ALREADY_OPEN, __TEXT("Trace file has been opened"),
    TABLE_MISMATCH, __TEXT("Control table mismatch"),
    0, NULL
};

static ERROR_MAP DecodeErrorMap[] =
{
    PDU_DECODED, __TEXT("PDU successfully decoded"),
    MORE_BUF, __TEXT("User-provided output buffer too small"),
    NEGATIVE_UINTEGER, __TEXT("The first unsigned bit of the encoding is 1"),
    PDU_RANGE, __TEXT("Pdu specified out of range"),
    MORE_INPUT, __TEXT("Unexpected end of input buffer"),
    DATA_ERROR, __TEXT("An error exists in the encoded data"),
    BAD_VERSION, __TEXT("Versions of encoder and table do not match"),
    OUT_MEMORY, __TEXT("Memory-allocation error"),
    PDU_MISMATCH, __TEXT("The PDU tag does not match data"),
    LIMITED, __TEXT("Size implementation limit exceeded"),
    CONSTRAINT_VIOLATED, __TEXT("Constraint violation error occured"),
    ACCESS_SERIALIZATION_ERROR, __TEXT("Thread access to global data failed"),
    NULL_TBL, __TEXT("NULL control table pointer"),
    NULL_FCN, __TEXT("Encoder called via a NULL pointer"),
    BAD_ENCRULES, __TEXT("Unknown encoding rules"),
    UNAVAIL_ENCRULES, __TEXT("Encoding rules requested are not implemented"),
    UNIMPLEMENTED, __TEXT("The type was not implemented yet"),
//    LOAD_ERR, __TEXT("Unable to load DLL"),
    CANT_OPEN_TRACE_FILE, __TEXT("Error when opening a trace file"),
    TRACE_FILE_ALREADY_OPEN, __TEXT("The trace file has been opened"),
    TABLE_MISMATCH, __TEXT("Control table mismatch"),
    0, NULL
};

#endif // if(0)

//====================================================================================
//====================================================================================
#ifdef UNICODE_TRACE
LPWSTR
#else
LPSTR
#endif
ErrorToTextASN(ERROR_MAP *Map, int nErrorCode)
{
    register int nIndex = 0;

    if (Map != NULL)
    {
        for (nIndex = 0; Map[nIndex].pszErrorText; nIndex++)
        {
            if (Map[nIndex].nErrorCode == nErrorCode)
            {
                return Map[nIndex].pszErrorText;
            }
        }
    }
    return __TEXT("Unknown ASN.1 Error");
}

#if 0
//------------------------------------------------------------------------
//------------------------------------------------------------------------
int
ASN1LinePrint(FILE *stream, const char *format, ...)
{
    va_list marker;
    char buf[300];
    int i;

    va_start(marker, format);
    i = wsprintf(buf, format, marker);
    va_end(marker);

    // TRACE the buf...
    QTRACE((buf));

    return i;
}
#endif


//------------------------------------------------------------------------
//------------------------------------------------------------------------
HRESULT
Q931InitPER()
{
    // initialize TELES ASN.1 module structure
    if (Q931_InitModule() != ASN1_SUCCESS)
    {
        ASSERT(FALSE);
        return CS_SUBSYSTEM_FAILURE;
    }

    // note: init of world struct moved to CreateCallObject()

    ProtocolId1.value = Q931_PROTOCOL_ID1;
    ProtocolId1.next = &ProtocolId2;
    ProtocolId2.value = Q931_PROTOCOL_ID2;
    ProtocolId2.next = &ProtocolId3;
    ProtocolId3.value = Q931_PROTOCOL_ID3;
    ProtocolId3.next = &ProtocolId4;
    ProtocolId4.value = Q931_PROTOCOL_ID4;
    ProtocolId4.next = &ProtocolId5;
    ProtocolId5.value = Q931_PROTOCOL_ID5;
    ProtocolId5.next = &ProtocolId6;
    ProtocolId6.value = Q931_PROTOCOL_ID6;
    ProtocolId6.next = NULL;

    // gateway protocol supported.  For now, hard-coded to only 1:  H323.
    TempProtocol.next = NULL;
    TempProtocol.value.choice = h323_chosen;

    return CS_OK;
}

//------------------------------------------------------------------------
//------------------------------------------------------------------------
HRESULT
Q931DeInitPER()
{
    // clean up TELES ASN.1 module structure
    Q931_TermModule();
    return CS_OK;
}

#define USE_ASN1_ENCODING 5

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931SetupEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_ADDR *pCallerAddr,                     // this data is not yet passed in the PDU...
    CC_ADDR *pCalleeAddr,
    WORD wGoal,
    WORD wCallType,
    BOOL bCallerIsMC,
    CC_CONFERENCEID *pConferenceID,
    PCC_ALIASNAMES pCallerAliasList,
    PCC_ALIASNAMES pCalleeAliasList,
    PCC_ALIASNAMES pExtraAliasList,
    PCC_ALIASITEM pExtensionAliasItem,
    PCC_VENDORINFO pVendorInfo,
    BOOL bIsTerminal,
    BOOL bIsGateway,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength)
{
    int rc;
    H323_UserInformation UserInfo;

    *ppEncodedBuf = NULL;
    *pdwEncodedLength = 0;

    memset(&UserInfo, 0, sizeof(H323_UserInformation));

    UserInfo.bit_mask = 0;

    // make sure the user_data_present flag is turned off.
    UserInfo.bit_mask &= (~user_data_present);

    if (pNonStandardData)
    {
        UserInfo.h323_uu_pdu.bit_mask |= H323_UU_PDU_nnStndrdDt_present;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.choice = h221NonStandard_chosen;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35CountryCode =
            pNonStandardData->bCountryCode;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35Extension =
            pNonStandardData->bExtension;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.manufacturerCode =
            pNonStandardData->wManufacturerCode;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.length =
            pNonStandardData->sData.wOctetStringLength;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.value =
            pNonStandardData->sData.pOctetString;
    }
    else
    {
        UserInfo.h323_uu_pdu.bit_mask &= (~H323_UU_PDU_nnStndrdDt_present);
    }

    UserInfo.h323_uu_pdu.h323_message_body.choice = setup_chosen;
    UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask = 0;

    UserInfo.h323_uu_pdu.h323_message_body.u.setup.protocolIdentifier = &ProtocolId1;

    if (pCallerAliasList)
    {
        CS_STATUS AliasResult = CS_OK;
        AliasResult = AliasToSeqof((struct _seqof3 **)&(UserInfo.h323_uu_pdu.
            h323_message_body.u.setup.sourceAddress), pCallerAliasList);
        if (AliasResult != CS_OK)
        {
            return CS_NO_MEMORY;
        }
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask |=
            (sourceAddress_present);
    }
    else
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask &=
            (~sourceAddress_present);
    }

    UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.bit_mask = 0;

    if (pVendorInfo)
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.bit_mask |= vendor_present;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.bit_mask = 0;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.vendor.t35CountryCode = pVendorInfo->bCountryCode;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.vendor.t35Extension = pVendorInfo->bExtension;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.vendor.manufacturerCode = pVendorInfo->wManufacturerCode;
        if (pVendorInfo->pProductNumber && pVendorInfo->pProductNumber->pOctetString &&
                pVendorInfo->pProductNumber->wOctetStringLength)
        {
            UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.bit_mask |= productId_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.productId.length =
                pVendorInfo->pProductNumber->wOctetStringLength;
            memcpy(UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.productId.value,
                pVendorInfo->pProductNumber->pOctetString,
                pVendorInfo->pProductNumber->wOctetStringLength);
        }
        if (pVendorInfo->pVersionNumber && pVendorInfo->pVersionNumber->pOctetString &&
                pVendorInfo->pVersionNumber->wOctetStringLength)
        {
            UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.bit_mask |= versionId_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.versionId.length =
                pVendorInfo->pVersionNumber->wOctetStringLength;
            memcpy(UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.versionId.value,
                pVendorInfo->pVersionNumber->pOctetString,
                pVendorInfo->pVersionNumber->wOctetStringLength);
        }
    }

    if (bIsTerminal)
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.bit_mask |=
            terminal_present;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.terminal.bit_mask = 0;
    }

    if (bIsGateway)
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.bit_mask |=
            gateway_present;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.gateway.bit_mask = protocol_present;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.gateway.protocol = &TempProtocol;
    }

    UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.mc = (ASN1_BOOL)bCallerIsMC;
    UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceInfo.undefinedNode = 0;

    if (pCalleeAliasList)
    {
        CS_STATUS AliasResult = CS_OK;
        AliasResult = AliasWithPrefixToSeqof((struct _seqof3 **)&(UserInfo.h323_uu_pdu.
            h323_message_body.u.setup.destinationAddress), pCalleeAliasList);
        if (AliasResult != CS_OK)
        {
            FreeSeqof((struct _seqof3 *)UserInfo.h323_uu_pdu.
                h323_message_body.u.setup.sourceAddress);
            UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceAddress = NULL;
            return CS_NO_MEMORY;
        }
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask |=
            (destinationAddress_present);
    }
    else
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask &=
            (~destinationAddress_present);
    }

    if (pExtraAliasList)
    {
        CS_STATUS AliasResult = CS_OK;
        AliasResult = AliasWithPrefixToSeqof((struct _seqof3 **)&(UserInfo.h323_uu_pdu.
            h323_message_body.u.setup.destExtraCallInfo), pExtraAliasList);
        if (AliasResult != CS_OK)
        {
            FreeSeqof((struct _seqof3 *)UserInfo.h323_uu_pdu.h323_message_body.u.setup.destinationAddress);
            UserInfo.h323_uu_pdu.h323_message_body.u.setup.destinationAddress = NULL;
            FreeSeqof((struct _seqof3 *)UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceAddress);
            UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceAddress = NULL;
            return CS_NO_MEMORY;
        }
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask |=
            (destExtraCallInfo_present);
    }
    else
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask &=
            (~destExtraCallInfo_present);
    }

    if (pCalleeAddr)
    {
        DWORD a = pCalleeAddr->Addr.IP_Binary.dwAddr;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.destCallSignalAddress.choice = ipAddress_chosen;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.destCallSignalAddress.u.ipAddress.ip.length = 4;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.destCallSignalAddress.u.ipAddress.port =
            pCalleeAddr->Addr.IP_Binary.wPort;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.destCallSignalAddress.u.ipAddress.ip.value[0] =
            ((BYTE *)&a)[3];
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.destCallSignalAddress.u.ipAddress.ip.value[1] =
            ((BYTE *)&a)[2];
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.destCallSignalAddress.u.ipAddress.ip.value[2] =
            ((BYTE *)&a)[1];
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.destCallSignalAddress.u.ipAddress.ip.value[3] =
            ((BYTE *)&a)[0];
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask |=
            (destCallSignalAddress_present);
    }
    else
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask &=
            (~destCallSignalAddress_present);
    }

    UserInfo.h323_uu_pdu.h323_message_body.u.setup.activeMC = (ASN1_BOOL)bCallerIsMC;

    if (pConferenceID != NULL)
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.conferenceID.length =
            sizeof(UserInfo.h323_uu_pdu.h323_message_body.u.setup.conferenceID.value);
        memcpy(UserInfo.h323_uu_pdu.h323_message_body.u.setup.conferenceID.value,
            pConferenceID->buffer,
            UserInfo.h323_uu_pdu.h323_message_body.u.setup.conferenceID.length);
    }

    switch (wGoal)
	{
	case CSG_INVITE:
		UserInfo.h323_uu_pdu.h323_message_body.u.setup.conferenceGoal.choice = invite_chosen;
		break;
    case CSG_JOIN:
		UserInfo.h323_uu_pdu.h323_message_body.u.setup.conferenceGoal.choice = join_chosen;
		break;
	default:
		UserInfo.h323_uu_pdu.h323_message_body.u.setup.conferenceGoal.choice = create_chosen;
	} // switch

	switch (wCallType)
	{
	case CC_CALLTYPE_1_N:
		UserInfo.h323_uu_pdu.h323_message_body.u.setup.callType.choice = oneToN_chosen;
		break;
	case CC_CALLTYPE_N_1:
		UserInfo.h323_uu_pdu.h323_message_body.u.setup.callType.choice = nToOne_chosen;
		break;
	case CC_CALLTYPE_N_N:
		UserInfo.h323_uu_pdu.h323_message_body.u.setup.callType.choice = nToN_chosen;
		break;
	default:
		UserInfo.h323_uu_pdu.h323_message_body.u.setup.callType.choice = pointToPoint_chosen;
	} // switch

    if (pCallerAddr)
    {
        DWORD a = pCallerAddr->Addr.IP_Binary.dwAddr;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceCallSignalAddress.choice = ipAddress_chosen;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceCallSignalAddress.u.ipAddress.ip.length = 4;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceCallSignalAddress.u.ipAddress.port =
            pCallerAddr->Addr.IP_Binary.wPort;
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceCallSignalAddress.u.ipAddress.ip.value[0] =
            ((BYTE *)&a)[3];
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceCallSignalAddress.u.ipAddress.ip.value[1] =
            ((BYTE *)&a)[2];
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceCallSignalAddress.u.ipAddress.ip.value[2] =
            ((BYTE *)&a)[1];
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceCallSignalAddress.u.ipAddress.ip.value[3] =
            ((BYTE *)&a)[0];
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask |=
            (sourceCallSignalAddress_present);
    }
    else
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask &=
            (~sourceCallSignalAddress_present);
    }

    if (pExtensionAliasItem)
    {
        CS_STATUS AliasResult = CS_OK;
        AliasResult = Q931CopyAliasItemToAliasAddr(&(UserInfo.h323_uu_pdu.
            h323_message_body.u.setup.remoteExtensionAddress), pExtensionAliasItem);
        if (AliasResult != CS_OK)
        {
            FreeSeqof((struct _seqof3 *)UserInfo.h323_uu_pdu.h323_message_body.u.setup.destExtraCallInfo);
            UserInfo.h323_uu_pdu.h323_message_body.u.setup.destExtraCallInfo = NULL;
            FreeSeqof((struct _seqof3 *)UserInfo.h323_uu_pdu.h323_message_body.u.setup.destinationAddress);
            UserInfo.h323_uu_pdu.h323_message_body.u.setup.destinationAddress = NULL;
            FreeSeqof((struct _seqof3 *)UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceAddress);
            UserInfo.h323_uu_pdu.h323_message_body.u.setup.sourceAddress = NULL;
            return CS_NO_MEMORY;
        }
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask |=
            (remoteExtensionAddress_present);
    }
    else
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.setup.bit_mask &=
            (~remoteExtensionAddress_present);
    }

    rc = Q931_Encode(pWorld,
                     (void *) &UserInfo,
                     H323_UserInformation_PDU,
                     ppEncodedBuf,
                     pdwEncodedLength);

    // Free the alias name structures from the UserInfo area.
    FreeSeqof((struct _seqof3 *)UserInfo.h323_uu_pdu.h323_message_body.u.
        setup.sourceAddress);
    FreeSeqof((struct _seqof3 *)UserInfo.h323_uu_pdu.h323_message_body.u.
        setup.destinationAddress);
    FreeSeqof((struct _seqof3 *)UserInfo.h323_uu_pdu.h323_message_body.u.
        setup.destExtraCallInfo);
    Q931ClearAliasAddr(&(UserInfo.h323_uu_pdu.h323_message_body.u.setup.remoteExtensionAddress));

    if (ASN1_FAILED(rc))
    {
        ASSERT(FALSE);
        return CS_SUBSYSTEM_FAILURE;
    }

    return CS_OK;
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
void
Q931FreeEncodedBuffer(ASN1_CODER_INFO *pWorld, BYTE *pEncodedBuf)
{
    ASN1_FreeEncoded(pWorld->pEncInfo, pEncodedBuf);
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931ReleaseCompleteEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_CONFERENCEID *pConferenceID,          // not passed in PDU!
    BYTE *pbReason,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength)
{
    int rc;
    H323_UserInformation UserInfo;

    *ppEncodedBuf = NULL;
    *pdwEncodedLength = 0;

    memset(&UserInfo, 0, sizeof(H323_UserInformation));

    UserInfo.bit_mask = 0;

    // make sure the user_data_present flag is turned off.
    UserInfo.bit_mask &= (~user_data_present);

    UserInfo.h323_uu_pdu.bit_mask = 0;

    if (pNonStandardData)
    {
        UserInfo.h323_uu_pdu.bit_mask |= H323_UU_PDU_nnStndrdDt_present;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.choice = h221NonStandard_chosen;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35CountryCode =
            pNonStandardData->bCountryCode;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35Extension =
            pNonStandardData->bExtension;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.manufacturerCode =
            pNonStandardData->wManufacturerCode;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.length =
            pNonStandardData->sData.wOctetStringLength;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.value =
            pNonStandardData->sData.pOctetString;
    }
    else
    {
        UserInfo.h323_uu_pdu.bit_mask &= (~H323_UU_PDU_nnStndrdDt_present);
    }

    UserInfo.h323_uu_pdu.h323_message_body.choice = releaseComplete_chosen;

    UserInfo.h323_uu_pdu.h323_message_body.u.releaseComplete.protocolIdentifier = &ProtocolId1;

    if (pbReason)
    {
        unsigned short choice = 0;

        UserInfo.h323_uu_pdu.h323_message_body.u.releaseComplete.bit_mask |=
            (reason_present);
        switch (*pbReason)
        {
        case CC_REJECT_NO_BANDWIDTH:
            choice = noBandwidth_chosen;
            break;
        case CC_REJECT_GATEKEEPER_RESOURCES:
            choice = gatekeeperResources_chosen;
            break;
        case CC_REJECT_UNREACHABLE_DESTINATION:
            choice = unreachableDestination_chosen;
            break;
        case CC_REJECT_DESTINATION_REJECTION:
            choice = destinationRejection_chosen;
            break;
        case CC_REJECT_INVALID_REVISION:
            choice = invalidRevision_chosen;
            break;
        case CC_REJECT_NO_PERMISSION:
            choice = noPermission_chosen;
            break;
        case CC_REJECT_UNREACHABLE_GATEKEEPER:
            choice = unreachableGatekeeper_chosen;
            break;
        case CC_REJECT_GATEWAY_RESOURCES:
            choice = gatewayResources_chosen;
            break;
        case CC_REJECT_BAD_FORMAT_ADDRESS:
            choice = badFormatAddress_chosen;
            break;
        case CC_REJECT_ADAPTIVE_BUSY:
            choice = adaptiveBusy_chosen;
            break;
        case CC_REJECT_IN_CONF:
            choice = inConf_chosen;
            break;
        case CC_REJECT_CALL_DEFLECTION:
            choice = facilityCallDeflection_chosen;
            break;
        case CC_REJECT_UNDEFINED_REASON:
            choice = RlsCmpltRsn_undfndRsn_chosen;
            break;
        case CC_REJECT_USER_BUSY:
            choice = inConf_chosen;
            break;
        default:
            return CS_BAD_PARAM;
            break;
        }
        UserInfo.h323_uu_pdu.h323_message_body.u.releaseComplete.reason.choice = choice;
    }

    rc = Q931_Encode(pWorld,
                     (void *) &UserInfo,
                     H323_UserInformation_PDU,
                     ppEncodedBuf,
                     pdwEncodedLength);

    if (ASN1_FAILED(rc))
    {
        ASSERT(FALSE);
        return CS_SUBSYSTEM_FAILURE;
    }

    return CS_OK;
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931ConnectEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_CONFERENCEID *pConferenceID, // must be able to support 16 byte conf id's!
    CC_ADDR *h245Addr,
    PCC_ENDPOINTTYPE pEndpointType,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength)
{
    int rc;
    H323_UserInformation UserInfo;

    *ppEncodedBuf = NULL;
    *pdwEncodedLength = 0;

    memset(&UserInfo, 0, sizeof(H323_UserInformation));
    UserInfo.bit_mask = 0;

    // make sure the user_data_present flag is turned off.
    UserInfo.bit_mask &= (~user_data_present);

    UserInfo.h323_uu_pdu.bit_mask = 0;

    if (pNonStandardData)
    {
        UserInfo.h323_uu_pdu.bit_mask |= H323_UU_PDU_nnStndrdDt_present;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.choice = h221NonStandard_chosen;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35CountryCode =
            pNonStandardData->bCountryCode;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35Extension =
            pNonStandardData->bExtension;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.manufacturerCode =
            pNonStandardData->wManufacturerCode;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.length =
            pNonStandardData->sData.wOctetStringLength;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.value =
            pNonStandardData->sData.pOctetString;
    }
    else
    {
        UserInfo.h323_uu_pdu.bit_mask &= (~H323_UU_PDU_nnStndrdDt_present);
    }

    UserInfo.h323_uu_pdu.h323_message_body.choice = connect_chosen;

    UserInfo.h323_uu_pdu.h323_message_body.u.connect.protocolIdentifier = &ProtocolId1;

    if (h245Addr != NULL)
    {
        DWORD a = h245Addr->Addr.IP_Binary.dwAddr;
        UserInfo.h323_uu_pdu.h323_message_body.u.connect.Cnnct_UUIE_h245Address.choice = ipAddress_chosen;
        UserInfo.h323_uu_pdu.h323_message_body.u.connect.Cnnct_UUIE_h245Address.u.ipAddress.ip.length = 4;
        UserInfo.h323_uu_pdu.h323_message_body.u.connect.Cnnct_UUIE_h245Address.u.ipAddress.port =
            h245Addr->Addr.IP_Binary.wPort;
        UserInfo.h323_uu_pdu.h323_message_body.u.connect.Cnnct_UUIE_h245Address.u.ipAddress.ip.value[0] =
            ((BYTE *)&a)[3];
        UserInfo.h323_uu_pdu.h323_message_body.u.connect.Cnnct_UUIE_h245Address.u.ipAddress.ip.value[1] =
            ((BYTE *)&a)[2];
        UserInfo.h323_uu_pdu.h323_message_body.u.connect.Cnnct_UUIE_h245Address.u.ipAddress.ip.value[2] =
            ((BYTE *)&a)[1];
        UserInfo.h323_uu_pdu.h323_message_body.u.connect.Cnnct_UUIE_h245Address.u.ipAddress.ip.value[3] =
            ((BYTE *)&a)[0];
        UserInfo.h323_uu_pdu.h323_message_body.u.connect.bit_mask |=
            (Cnnct_UUIE_h245Address_present);
    }
    else
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.connect.bit_mask &=
            (~Cnnct_UUIE_h245Address_present);
    }

    UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.bit_mask = 0;

    if (pEndpointType)
    {
        PCC_VENDORINFO pVendorInfo = pEndpointType->pVendorInfo;
        if (pVendorInfo)
        {
            UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.bit_mask |= vendor_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.bit_mask = 0;
            UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.vendor.t35CountryCode = pVendorInfo->bCountryCode;
            UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.vendor.t35Extension = pVendorInfo->bExtension;
            UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.vendor.manufacturerCode = pVendorInfo->wManufacturerCode;

            if (pVendorInfo->pProductNumber && pVendorInfo->pProductNumber->pOctetString &&
                    pVendorInfo->pProductNumber->wOctetStringLength)
            {
                UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.bit_mask |= productId_present;
                UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.productId.length =
                    pVendorInfo->pProductNumber->wOctetStringLength;
                memcpy(UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.productId.value,
                    pVendorInfo->pProductNumber->pOctetString,
                    pVendorInfo->pProductNumber->wOctetStringLength);
            }
            if (pVendorInfo->pVersionNumber && pVendorInfo->pVersionNumber->pOctetString &&
                    pVendorInfo->pVersionNumber->wOctetStringLength)
            {
                UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.bit_mask |= versionId_present;
                UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.versionId.length =
                    pVendorInfo->pVersionNumber->wOctetStringLength;
                memcpy(UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.versionId.value,
                    pVendorInfo->pVersionNumber->pOctetString,
                    pVendorInfo->pVersionNumber->wOctetStringLength);
            }
        }
        if (pEndpointType->bIsTerminal)
        {
            UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.bit_mask |=
                terminal_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.terminal.bit_mask = 0;
        }
        if (pEndpointType->bIsGateway)
        {
            UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.bit_mask |=
                gateway_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.gateway.bit_mask = protocol_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.gateway.protocol = &TempProtocol;
        }
    }

    UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.mc = 0;
    UserInfo.h323_uu_pdu.h323_message_body.u.connect.destinationInfo.undefinedNode = 0;

    if (pConferenceID != NULL)
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.connect.conferenceID.length =
            sizeof(UserInfo.h323_uu_pdu.h323_message_body.u.connect.conferenceID.value);
        memcpy(UserInfo.h323_uu_pdu.h323_message_body.u.connect.conferenceID.value,
            pConferenceID->buffer,
            UserInfo.h323_uu_pdu.h323_message_body.u.connect.conferenceID.length);
    }

    rc = Q931_Encode(pWorld,
                     (void *) &UserInfo,
                     H323_UserInformation_PDU,
                     ppEncodedBuf,
                     pdwEncodedLength);

    if (ASN1_FAILED(rc))
    {
        ASSERT(FALSE);
        return CS_SUBSYSTEM_FAILURE;
    }

    return CS_OK;
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931AlertingEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_ADDR *h245Addr,
    PCC_ENDPOINTTYPE pEndpointType,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength)
{
    int rc;
    H323_UserInformation UserInfo;

    *ppEncodedBuf = NULL;
    *pdwEncodedLength = 0;

    memset(&UserInfo, 0, sizeof(H323_UserInformation));
    UserInfo.bit_mask = 0;

    // make sure the user_data_present flag is turned off.
    UserInfo.bit_mask &= (~user_data_present);

    UserInfo.h323_uu_pdu.bit_mask = 0;

    if (pNonStandardData)
    {
        UserInfo.h323_uu_pdu.bit_mask |= H323_UU_PDU_nnStndrdDt_present;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.choice = h221NonStandard_chosen;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35CountryCode =
            pNonStandardData->bCountryCode;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35Extension =
            pNonStandardData->bExtension;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.manufacturerCode =
            pNonStandardData->wManufacturerCode;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.length =
            pNonStandardData->sData.wOctetStringLength;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.value =
            pNonStandardData->sData.pOctetString;
    }
    else
    {
        UserInfo.h323_uu_pdu.bit_mask &= (~H323_UU_PDU_nnStndrdDt_present);
    }

    UserInfo.h323_uu_pdu.h323_message_body.choice = alerting_chosen;

    UserInfo.h323_uu_pdu.h323_message_body.u.alerting.protocolIdentifier = &ProtocolId1;

    UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.bit_mask = 0;
    if (pEndpointType)
    {
        PCC_VENDORINFO pVendorInfo = pEndpointType->pVendorInfo;
        if (pVendorInfo)
        {
            UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.bit_mask |= vendor_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.vendor.bit_mask = 0;
            UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.vendor.vendor.t35CountryCode = pVendorInfo->bCountryCode;
            UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.vendor.vendor.t35Extension = pVendorInfo->bExtension;
            UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.vendor.vendor.manufacturerCode = pVendorInfo->wManufacturerCode;

            if (pVendorInfo->pProductNumber && pVendorInfo->pProductNumber->pOctetString &&
                    pVendorInfo->pProductNumber->wOctetStringLength)
            {
                UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.vendor.bit_mask |= productId_present;
                UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.vendor.productId.length =
                    pVendorInfo->pProductNumber->wOctetStringLength;
                memcpy(UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.vendor.productId.value,
                    pVendorInfo->pProductNumber->pOctetString,
                    pVendorInfo->pProductNumber->wOctetStringLength);
            }
            if (pVendorInfo->pVersionNumber && pVendorInfo->pVersionNumber->pOctetString &&
                    pVendorInfo->pVersionNumber->wOctetStringLength)
            {
                UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.vendor.bit_mask |= versionId_present;
                UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.vendor.versionId.length =
                    pVendorInfo->pVersionNumber->wOctetStringLength;
                memcpy(UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.vendor.versionId.value,
                    pVendorInfo->pVersionNumber->pOctetString,
                    pVendorInfo->pVersionNumber->wOctetStringLength);
            }
        }
        if (pEndpointType->bIsTerminal)
        {
            UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.bit_mask =
                terminal_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.terminal.bit_mask = 0;
        }
        if (pEndpointType->bIsGateway)
        {
            UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.bit_mask =
                gateway_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.gateway.bit_mask = protocol_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.gateway.protocol = &TempProtocol;
        }
    }

    UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.mc = 0;
    UserInfo.h323_uu_pdu.h323_message_body.u.alerting.destinationInfo.undefinedNode = 0;

    if (h245Addr != NULL)
    {
        DWORD a = h245Addr->Addr.IP_Binary.dwAddr;
        UserInfo.h323_uu_pdu.h323_message_body.u.alerting.CPg_UUIE_h245Addrss.choice = ipAddress_chosen;
        UserInfo.h323_uu_pdu.h323_message_body.u.alerting.CPg_UUIE_h245Addrss.u.ipAddress.ip.length = 4;
        UserInfo.h323_uu_pdu.h323_message_body.u.alerting.CPg_UUIE_h245Addrss.u.ipAddress.port =
            h245Addr->Addr.IP_Binary.wPort;
        UserInfo.h323_uu_pdu.h323_message_body.u.alerting.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[0] =
            ((BYTE *)&a)[3];
        UserInfo.h323_uu_pdu.h323_message_body.u.alerting.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[1] =
            ((BYTE *)&a)[2];
        UserInfo.h323_uu_pdu.h323_message_body.u.alerting.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[2] =
            ((BYTE *)&a)[1];
        UserInfo.h323_uu_pdu.h323_message_body.u.alerting.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[3] =
            ((BYTE *)&a)[0];
        UserInfo.h323_uu_pdu.h323_message_body.u.alerting.bit_mask |=
            (CPg_UUIE_h245Addrss_present);
    }
    else
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.alerting.bit_mask &=
            (~CPg_UUIE_h245Addrss_present);
    }

    rc = Q931_Encode(pWorld,
                     (void *) &UserInfo,
                     H323_UserInformation_PDU,
                     ppEncodedBuf,
                     pdwEncodedLength);

    if (ASN1_FAILED(rc))
    {
        ASSERT(FALSE);
        return CS_SUBSYSTEM_FAILURE;
    }

    return CS_OK;
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931ProceedingEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_ADDR *h245Addr,
    PCC_ENDPOINTTYPE pEndpointType,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength)
{
    int rc;
    H323_UserInformation UserInfo;

    *ppEncodedBuf = NULL;
    *pdwEncodedLength = 0;

    memset(&UserInfo, 0, sizeof(H323_UserInformation));
    UserInfo.bit_mask = 0;

    // make sure the user_data_present flag is turned off.
    UserInfo.bit_mask &= (~user_data_present);

    UserInfo.h323_uu_pdu.bit_mask = 0;

    if (pNonStandardData)
    {
        UserInfo.h323_uu_pdu.bit_mask |= H323_UU_PDU_nnStndrdDt_present;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.choice = h221NonStandard_chosen;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35CountryCode =
            pNonStandardData->bCountryCode;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35Extension =
            pNonStandardData->bExtension;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.manufacturerCode =
            pNonStandardData->wManufacturerCode;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.length =
            pNonStandardData->sData.wOctetStringLength;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.value =
            pNonStandardData->sData.pOctetString;
    }
    else
    {
        UserInfo.h323_uu_pdu.bit_mask &= (~H323_UU_PDU_nnStndrdDt_present);
    }

    UserInfo.h323_uu_pdu.h323_message_body.choice = callProceeding_chosen;

    UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.protocolIdentifier = &ProtocolId1;

    if (h245Addr != NULL)
    {
        DWORD a = h245Addr->Addr.IP_Binary.dwAddr;
        UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.CPg_UUIE_h245Addrss.choice = ipAddress_chosen;
        UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.CPg_UUIE_h245Addrss.u.ipAddress.ip.length = 4;
        UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.CPg_UUIE_h245Addrss.u.ipAddress.port =
            h245Addr->Addr.IP_Binary.wPort;
        UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[0] =
            ((BYTE *)&a)[3];
        UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[1] =
            ((BYTE *)&a)[2];
        UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[2] =
            ((BYTE *)&a)[1];
        UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[3] =
            ((BYTE *)&a)[0];
        UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.bit_mask |=
            (CPg_UUIE_h245Addrss_present);
    }
    else
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.bit_mask &=
            (~CPg_UUIE_h245Addrss_present);
    }

    UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.bit_mask = 0;
    if (pEndpointType)
    {
        PCC_VENDORINFO pVendorInfo = pEndpointType->pVendorInfo;
        if (pVendorInfo)
        {
            UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.bit_mask |= vendor_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.vendor.bit_mask = 0;
            UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.vendor.vendor.t35CountryCode = pVendorInfo->bCountryCode;
            UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.vendor.vendor.t35Extension = pVendorInfo->bExtension;
            UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.vendor.vendor.manufacturerCode = pVendorInfo->wManufacturerCode;

            if (pVendorInfo->pProductNumber && pVendorInfo->pProductNumber->pOctetString &&
                pVendorInfo->pProductNumber->wOctetStringLength)
            {
                UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.vendor.bit_mask |= productId_present;
                UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.vendor.productId.length =
                    pVendorInfo->pProductNumber->wOctetStringLength;
                memcpy(UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.vendor.productId.value,
                    pVendorInfo->pProductNumber->pOctetString,
                    pVendorInfo->pProductNumber->wOctetStringLength);
            }
            if (pVendorInfo->pVersionNumber && pVendorInfo->pVersionNumber->pOctetString &&
                    pVendorInfo->pVersionNumber->wOctetStringLength)
            {
                UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.vendor.bit_mask |= versionId_present;
                UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.vendor.versionId.length =
                    pVendorInfo->pVersionNumber->wOctetStringLength;
                memcpy(UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.vendor.versionId.value,
                    pVendorInfo->pVersionNumber->pOctetString,
                    pVendorInfo->pVersionNumber->wOctetStringLength);
            }
        }
        if (pEndpointType->bIsTerminal)
        {
            UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.bit_mask =
                terminal_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.terminal.bit_mask = 0;
        }
        if (pEndpointType->bIsGateway)
        {
            UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.bit_mask =
                gateway_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.gateway.bit_mask = protocol_present;
            UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.gateway.protocol = &TempProtocol;
        }
    }

    UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.mc = 0;
    UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding.destinationInfo.undefinedNode = 0;

    rc = Q931_Encode(pWorld,
                     (void *) &UserInfo,
                     H323_UserInformation_PDU,
                     ppEncodedBuf,
                     pdwEncodedLength);

    if (ASN1_FAILED(rc))
    {
        ASSERT(FALSE);
        return CS_SUBSYSTEM_FAILURE;
    }

    return CS_OK;
}

//-------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------
HRESULT
Q931FacilityEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_ADDR *AlternativeAddr,
    BYTE bReason,
    CC_CONFERENCEID *pConferenceID,
    PCC_ALIASNAMES pAlternativeAliasList,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength)
{
    int rc;
    H323_UserInformation UserInfo;

    *ppEncodedBuf = NULL;
    *pdwEncodedLength = 0;

    memset(&UserInfo, 0, sizeof(H323_UserInformation));

    UserInfo.bit_mask = 0;

    // make sure the user_data_present flag is turned off.
    UserInfo.bit_mask &= (~user_data_present);

    if (pNonStandardData)
    {
        UserInfo.h323_uu_pdu.bit_mask |= H323_UU_PDU_nnStndrdDt_present;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.choice = h221NonStandard_chosen;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35CountryCode =
            pNonStandardData->bCountryCode;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35Extension =
            pNonStandardData->bExtension;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.manufacturerCode =
            pNonStandardData->wManufacturerCode;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.length =
            pNonStandardData->sData.wOctetStringLength;
        UserInfo.h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.value =
            pNonStandardData->sData.pOctetString;
    }
    else
    {
        UserInfo.h323_uu_pdu.bit_mask &= (~H323_UU_PDU_nnStndrdDt_present);
    }

    UserInfo.h323_uu_pdu.h323_message_body.choice = facility_chosen;

    UserInfo.h323_uu_pdu.h323_message_body.u.facility.protocolIdentifier = &ProtocolId1;

    if (AlternativeAddr != NULL)
    {
        DWORD a = AlternativeAddr->Addr.IP_Binary.dwAddr;
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.alternativeAddress.choice = ipAddress_chosen;
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.alternativeAddress.u.ipAddress.ip.length = 4;
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.alternativeAddress.u.ipAddress.port =
            AlternativeAddr->Addr.IP_Binary.wPort;
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.alternativeAddress.u.ipAddress.ip.value[0] =
            ((BYTE *)&a)[3];
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.alternativeAddress.u.ipAddress.ip.value[1] =
            ((BYTE *)&a)[2];
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.alternativeAddress.u.ipAddress.ip.value[2] =
            ((BYTE *)&a)[1];
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.alternativeAddress.u.ipAddress.ip.value[3] =
            ((BYTE *)&a)[0];
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.bit_mask |=
            (alternativeAddress_present);
    }
    else
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.bit_mask &=
            (~alternativeAddress_present);
    }

    if (pAlternativeAliasList)
    {
        CS_STATUS AliasResult = CS_OK;
        AliasResult = AliasToSeqof((struct _seqof3 **)&(UserInfo.h323_uu_pdu.
            h323_message_body.u.facility.alternativeAliasAddress), pAlternativeAliasList);
        if (AliasResult != CS_OK)
        {
            return CS_NO_MEMORY;
        }
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.bit_mask |=
            (alternativeAliasAddress_present);
    }
    else
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.bit_mask &=
            (~alternativeAliasAddress_present);
    }

    if (pConferenceID != NULL)
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.conferenceID.length =
            sizeof(UserInfo.h323_uu_pdu.h323_message_body.u.facility.conferenceID.value);
        memcpy(UserInfo.h323_uu_pdu.h323_message_body.u.facility.conferenceID.value,
            pConferenceID->buffer,
            UserInfo.h323_uu_pdu.h323_message_body.u.facility.conferenceID.length);
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.bit_mask |=
            (conferenceID_present);
    }
    else
    {
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.bit_mask &=
            (~conferenceID_present);
    }

    switch (bReason)
	{
	case CC_REJECT_ROUTE_TO_GATEKEEPER:
		UserInfo.h323_uu_pdu.h323_message_body.u.facility.reason.choice = routeCallToGatekeeper_chosen;
		break;
	case CC_REJECT_CALL_FORWARDED:
		UserInfo.h323_uu_pdu.h323_message_body.u.facility.reason.choice = callForwarded_chosen;
		break;
	case CC_REJECT_ROUTE_TO_MC:
		UserInfo.h323_uu_pdu.h323_message_body.u.facility.reason.choice = routeCallToMC_chosen;
		break;
	default:
        UserInfo.h323_uu_pdu.h323_message_body.u.facility.reason.choice = RlsCmpltRsn_undfndRsn_chosen;
	} // switch

    rc = Q931_Encode(pWorld,
                     (void *) &UserInfo,
                     H323_UserInformation_PDU,
                     ppEncodedBuf,
                     pdwEncodedLength);

    // Free the alias name structures from the UserInfo area.
    FreeSeqof((struct _seqof3 *)UserInfo.h323_uu_pdu.h323_message_body.u.
        facility.alternativeAliasAddress);

    if (ASN1_FAILED(rc))
    {
        ASSERT(FALSE);
        return CS_SUBSYSTEM_FAILURE;
    }
    
    return CS_OK;
}

//------------------------------------------------------------------------
//------------------------------------------------------------------------
BOOL
Q931ValidPduVersion(struct ObjectID_ *id)
{
// not sure what version checking to put here
#if 0
    if ((id != NULL) && (id->value == 0) && (id->next != NULL) && (id->next->value <= 1))
    {
        return TRUE;
    }
    return FALSE;
#else
    return TRUE;
#endif
}

//------------------------------------------------------------------------
//------------------------------------------------------------------------
HRESULT
Q931SetupParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_SETUP_ASN *pParsedData)
{
    int PDU = H323_UserInformation_PDU;
    char *pDecodedBuf = NULL;
    H323_UserInformation *pUserInfo;
    struct ObjectID_ *id;
    int Result;

    if (pParsedData == NULL)
    {
        return CS_BAD_PARAM;
    }

    Result = Q931_Decode(pWorld,
                         (void **) &pDecodedBuf,
                         PDU,
                         pEncodedBuf,
                         dwEncodedLength);

    if (ASN1_FAILED(Result) || (pDecodedBuf == NULL))
    {
        ASSERT(FALSE);
        // trace and return an decoding error of some sort.
        // Note: some values of Result should cause CS_SUBSYSTEM_FAILURE return.
        return CS_BAD_PARAM;
    }

    // validate some basic things about the PDU...
    pUserInfo = (H323_UserInformation *)pDecodedBuf;

    // validate that this is a H323 PDU.
    if (PDU != H323_UserInformation_PDU)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // validate that the PDU user-data uses ASN encoding.
    if (((pUserInfo->bit_mask & user_data_present) != 0) &&
            (pUserInfo->user_data.protocol_discriminator != USE_ASN1_ENCODING))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // validate that the PDU is H323 Setup information.
    if (pUserInfo->h323_uu_pdu.h323_message_body.choice != setup_chosen)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    id = pUserInfo->h323_uu_pdu.h323_message_body.u.setup.protocolIdentifier;
    if (!Q931ValidPduVersion(id))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_INCOMPATIBLE_VERSION;
    }

    // make sure that the conference id is formed correctly.
    if (pUserInfo->h323_uu_pdu.h323_message_body.u.setup.conferenceID.length >
            sizeof(pUserInfo->h323_uu_pdu.h323_message_body.u.setup.conferenceID.value))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

#if 0
    if (pUserInfo->h323_uu_pdu.h323_message_body.u.setup.conferenceGoal.choice != create_chosen)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_OPTION_NOT_IMPLEMENTED;
    }
    if (pUserInfo->h323_uu_pdu.h323_message_body.u.setup.callType.choice != pointToPoint_chosen)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_OPTION_NOT_IMPLEMENTED;
    }
#endif

    // parse the message contained in pUserInfo.
    memset(pParsedData, 0, sizeof(Q931_SETUP_ASN));
    pParsedData->SourceAddr.bMulticast = FALSE;
    pParsedData->CallerAddr.bMulticast = FALSE;
    pParsedData->CalleeDestAddr.bMulticast = FALSE;
    pParsedData->CalleeAddr.bMulticast = FALSE;

    // no validation of sourceInfo needed.

    pParsedData->EndpointType.pVendorInfo = NULL;
    if (pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceInfo.bit_mask & (vendor_present))
    {
        pParsedData->EndpointType.pVendorInfo = &(pParsedData->VendorInfo);
        pParsedData->VendorInfo.bCountryCode =
            (BYTE)pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.vendor.t35CountryCode;
        pParsedData->VendorInfo.bExtension =
            (BYTE)pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.vendor.t35Extension;
        pParsedData->VendorInfo.wManufacturerCode =
            pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.vendor.manufacturerCode;
        if (pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.bit_mask & (productId_present))
        {
            pParsedData->VendorInfo.pProductNumber = Malloc(sizeof(CC_OCTETSTRING));
            if (pParsedData->VendorInfo.pProductNumber == NULL)
            {
                freePDU(pWorld, PDU, pDecodedBuf, q931asn);
                return CS_NO_MEMORY;
            }
            pParsedData->VendorInfo.pProductNumber->wOctetStringLength = (WORD)
                min(pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.productId.length,
                CC_MAX_PRODUCT_LENGTH - 1);
            memcpy(pParsedData->bufProductValue,
                pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.productId.value,
                pParsedData->VendorInfo.pProductNumber->wOctetStringLength);
            pParsedData->bufProductValue[pParsedData->VendorInfo.pProductNumber->wOctetStringLength] = '\0';
            pParsedData->VendorInfo.pProductNumber->pOctetString = pParsedData->bufProductValue;
        }
        if (pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.bit_mask & (versionId_present))
        {
            pParsedData->VendorInfo.pVersionNumber = Malloc(sizeof(CC_OCTETSTRING));
            if (pParsedData->VendorInfo.pVersionNumber == NULL)
            {
                Free(pParsedData->VendorInfo.pProductNumber);
                freePDU(pWorld, PDU, pDecodedBuf, q931asn);
                return CS_NO_MEMORY;
            }
            pParsedData->VendorInfo.pVersionNumber->wOctetStringLength = (WORD)
                min(pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.versionId.length,
                CC_MAX_VERSION_LENGTH - 1);
            memcpy(pParsedData->bufVersionValue,
                pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceInfo.vendor.versionId.value,
                pParsedData->VendorInfo.pVersionNumber->wOctetStringLength);
            pParsedData->bufVersionValue[pParsedData->VendorInfo.pVersionNumber->wOctetStringLength] = '\0';
            pParsedData->VendorInfo.pVersionNumber->pOctetString = pParsedData->bufVersionValue;
        }
    }

    pParsedData->EndpointType.bIsTerminal = FALSE;
    if (pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceInfo.bit_mask & (terminal_present))
    {
        pParsedData->EndpointType.bIsTerminal = TRUE;
    }
    pParsedData->EndpointType.bIsGateway = FALSE;
    if (pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceInfo.bit_mask & (gateway_present))
    {
        pParsedData->EndpointType.bIsGateway = TRUE;
    }

    if ((pUserInfo->h323_uu_pdu.bit_mask & H323_UU_PDU_nnStndrdDt_present) != 0)
    {
        pParsedData->NonStandardDataPresent = TRUE;
        if (pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.choice ==
                h221NonStandard_chosen)
        {
            pParsedData->NonStandardData.bCountryCode =
                (BYTE)(pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35CountryCode);
            pParsedData->NonStandardData.bExtension =
                (BYTE)(pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35Extension);
            pParsedData->NonStandardData.wManufacturerCode =
                pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.manufacturerCode;
        }
        pParsedData->NonStandardData.sData.wOctetStringLength =	(WORD)
            pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.length;
		pParsedData->NonStandardData.sData.pOctetString =
			(BYTE *)Malloc(pParsedData->NonStandardData.sData.wOctetStringLength);
		if (pParsedData->NonStandardData.sData.pOctetString == NULL)
		{
            Free(pParsedData->VendorInfo.pProductNumber);
            Free(pParsedData->VendorInfo.pVersionNumber);
            freePDU(pWorld, PDU, pDecodedBuf, q931asn);
            return CS_NO_MEMORY;
		}
		memcpy(pParsedData->NonStandardData.sData.pOctetString,
			   pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.value,
			   pParsedData->NonStandardData.sData.wOctetStringLength);
    }
    else
    {
        pParsedData->NonStandardDataPresent = FALSE;
    }

//RMO. ignore the h245 address.

    {
        CS_STATUS AliasResult = CS_OK;

        // parse the sourceAddress aliases here...
        AliasResult = SeqofToAlias(&(pParsedData->pCallerAliasList),
            (struct _seqof3 *)pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceAddress);
        if (AliasResult != CS_OK)
        {
  			if (pParsedData->NonStandardData.sData.pOctetString != NULL)
				Free(pParsedData->NonStandardData.sData.pOctetString);
			Free(pParsedData->VendorInfo.pProductNumber);
            Free(pParsedData->VendorInfo.pVersionNumber);
            freePDU(pWorld, PDU, pDecodedBuf, q931asn);
            return CS_NO_MEMORY;
        }

        // parse the destinationAddress aliases here...
        AliasResult = SeqofToAlias(&(pParsedData->pCalleeAliasList),
            (struct _seqof3 *)pUserInfo->h323_uu_pdu.h323_message_body.u.setup.destinationAddress);
        if (AliasResult != CS_OK)
        {
            Q931FreeAliasNames(pParsedData->pCallerAliasList);
   			if (pParsedData->NonStandardData.sData.pOctetString != NULL)
				Free(pParsedData->NonStandardData.sData.pOctetString);
            pParsedData->pCallerAliasList = NULL;
            Free(pParsedData->VendorInfo.pProductNumber);
            Free(pParsedData->VendorInfo.pVersionNumber);
            freePDU(pWorld, PDU, pDecodedBuf, q931asn);
            return CS_NO_MEMORY;
        }

        // parse the destExtraCallInfo aliases here...
        AliasResult = SeqofToAlias(&(pParsedData->pExtraAliasList),
            (struct _seqof3 *)pUserInfo->h323_uu_pdu.h323_message_body.u.setup.destExtraCallInfo);
        if (AliasResult != CS_OK)
        {
            Q931FreeAliasNames(pParsedData->pCalleeAliasList);
            Q931FreeAliasNames(pParsedData->pCallerAliasList);
  			if (pParsedData->NonStandardData.sData.pOctetString != NULL)
				Free(pParsedData->NonStandardData.sData.pOctetString);
            pParsedData->pCallerAliasList = NULL;
            Free(pParsedData->VendorInfo.pProductNumber);
            Free(pParsedData->VendorInfo.pVersionNumber);
            freePDU(pWorld, PDU, pDecodedBuf, q931asn);
            return CS_NO_MEMORY;
        }

        // parse the remoteExtensionAddress aliases here...
        if ((pUserInfo->h323_uu_pdu.h323_message_body.u.setup.bit_mask &
                remoteExtensionAddress_present) != 0)
        {
            AliasResult = Q931AliasAddrToAliasItem(&(pParsedData->pExtensionAliasItem),
                &(pUserInfo->h323_uu_pdu.h323_message_body.u.setup.remoteExtensionAddress));
            if (AliasResult != CS_OK)
            {
                Q931FreeAliasNames(pParsedData->pExtraAliasList);
                Q931FreeAliasNames(pParsedData->pCalleeAliasList);
                Q931FreeAliasNames(pParsedData->pCallerAliasList);
                pParsedData->pCallerAliasList = NULL;
  				if (pParsedData->NonStandardData.sData.pOctetString != NULL)
					Free(pParsedData->NonStandardData.sData.pOctetString);
                Free(pParsedData->VendorInfo.pProductNumber);
                Free(pParsedData->VendorInfo.pVersionNumber);
                freePDU(pWorld, PDU, pDecodedBuf, q931asn);
                return CS_NO_MEMORY;
            }
        }
    }

    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.setup.bit_mask &
            destCallSignalAddress_present) != 0)
    {
        BYTE *a = (BYTE *)(&(pParsedData->CalleeDestAddr.Addr.IP_Binary.dwAddr));
        pParsedData->CalleeDestAddr.nAddrType = CC_IP_BINARY;
        pParsedData->CalleeDestAddr.Addr.IP_Binary.wPort = 
            pUserInfo->h323_uu_pdu.h323_message_body.u.setup.destCallSignalAddress.u.ipAddress.port;
        a[3] = pUserInfo->h323_uu_pdu.h323_message_body.u.setup.destCallSignalAddress.u.ipAddress.ip.value[0];
        a[2] = pUserInfo->h323_uu_pdu.h323_message_body.u.setup.destCallSignalAddress.u.ipAddress.ip.value[1];
        a[1] = pUserInfo->h323_uu_pdu.h323_message_body.u.setup.destCallSignalAddress.u.ipAddress.ip.value[2];
        a[0] = pUserInfo->h323_uu_pdu.h323_message_body.u.setup.destCallSignalAddress.u.ipAddress.ip.value[3];
        pParsedData->CalleeDestAddrPresent = TRUE;
    }

    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.setup.bit_mask &
            sourceCallSignalAddress_present) != 0)
    {
        BYTE *a = (BYTE *)(&(pParsedData->SourceAddr.Addr.IP_Binary.dwAddr));
        pParsedData->SourceAddr.nAddrType = CC_IP_BINARY;
        pParsedData->SourceAddr.Addr.IP_Binary.wPort = 
            pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceCallSignalAddress.u.ipAddress.port;
        a[3] = pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceCallSignalAddress.u.ipAddress.ip.value[0];
        a[2] = pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceCallSignalAddress.u.ipAddress.ip.value[1];
        a[1] = pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceCallSignalAddress.u.ipAddress.ip.value[2];
        a[0] = pUserInfo->h323_uu_pdu.h323_message_body.u.setup.sourceCallSignalAddress.u.ipAddress.ip.value[3];
        pParsedData->SourceAddrPresent = TRUE;
    }

    pParsedData->bCallerIsMC = pUserInfo->h323_uu_pdu.h323_message_body.u.setup.activeMC;

    memcpy(pParsedData->ConferenceID.buffer,
        pUserInfo->h323_uu_pdu.h323_message_body.u.setup.conferenceID.value,
        pUserInfo->h323_uu_pdu.h323_message_body.u.setup.conferenceID.length);

    switch (pUserInfo->h323_uu_pdu.h323_message_body.u.setup.conferenceGoal.choice)
	{
	case invite_chosen:
		pParsedData->wGoal = CSG_INVITE;
		break;
	case join_chosen:
		pParsedData->wGoal = CSG_JOIN;
		break;
	default:
		pParsedData->wGoal = CSG_CREATE;
	} // switch

	switch (pUserInfo->h323_uu_pdu.h323_message_body.u.setup.callType.choice)
    {
	case oneToN_chosen:
        pParsedData->wCallType = CC_CALLTYPE_1_N;
		break;
	case nToOne_chosen:
        pParsedData->wCallType = CC_CALLTYPE_N_1;
		break;
	case nToN_chosen:
        pParsedData->wCallType = CC_CALLTYPE_N_N;
		break;
	default:
        pParsedData->wCallType = CC_CALLTYPE_PT_PT;
    } // switch

    // Free the PDU data.
    Result = freePDU(pWorld, PDU, pDecodedBuf, q931asn);
    ASSERT(ASN1_SUCCEEDED(Result));
    return CS_OK;
}

//------------------------------------------------------------------------
//------------------------------------------------------------------------
HRESULT
Q931ReleaseCompleteParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_RELEASE_COMPLETE_ASN *pParsedData)
{
    int PDU = H323_UserInformation_PDU;
    char *pDecodedBuf = NULL;
    H323_UserInformation *pUserInfo;
    struct ObjectID_ *id;
    int Result;

    if (pParsedData == NULL)
    {
        return CS_BAD_PARAM;
    }

    Result = Q931_Decode(pWorld,
                         (void **) &pDecodedBuf,
                         PDU,
                         pEncodedBuf,
                         dwEncodedLength);

    if (ASN1_FAILED(Result) || (pDecodedBuf == NULL))
    {
        ASSERT(FALSE);
        // trace and return an decoding error of some sort.
        // Note: some values of Result should cause CS_SUBSYSTEM_FAILURE return.
        return CS_BAD_PARAM;
    }

    // validate some basic things about the PDU...
    pUserInfo = (H323_UserInformation *)pDecodedBuf;

    // validate that this is a H323 PDU.
    if (PDU != H323_UserInformation_PDU)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // validate that the PDU user-data uses ASN encoding.
    if (((pUserInfo->bit_mask & user_data_present) != 0) &&
            (pUserInfo->user_data.protocol_discriminator != USE_ASN1_ENCODING))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // validate that the PDU is H323 Release Complete information.
    if (pUserInfo->h323_uu_pdu.h323_message_body.choice != releaseComplete_chosen)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    id = pUserInfo->h323_uu_pdu.h323_message_body.u.releaseComplete.protocolIdentifier;
    if (!Q931ValidPduVersion(id))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_INCOMPATIBLE_VERSION;
    }

    // parse the message contained in pUserInfo.
    memset(pParsedData, 0, sizeof(Q931_RELEASE_COMPLETE_ASN));

    if ((pUserInfo->h323_uu_pdu.bit_mask & H323_UU_PDU_nnStndrdDt_present) != 0)
    {
        pParsedData->NonStandardDataPresent = TRUE;
        if (pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.choice ==
                h221NonStandard_chosen)
        {
            pParsedData->NonStandardData.bCountryCode =
                (BYTE)(pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35CountryCode);
            pParsedData->NonStandardData.bExtension =
                (BYTE)(pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35Extension);
            pParsedData->NonStandardData.wManufacturerCode =
                pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.manufacturerCode;
        }
        pParsedData->NonStandardData.sData.wOctetStringLength =	(WORD)
            pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.length;
		pParsedData->NonStandardData.sData.pOctetString =
			(BYTE *)Malloc(pParsedData->NonStandardData.sData.wOctetStringLength);
		if (pParsedData->NonStandardData.sData.pOctetString == NULL)
		{
            freePDU(pWorld, PDU, pDecodedBuf, q931asn);
            return CS_NO_MEMORY;
		}
		memcpy(pParsedData->NonStandardData.sData.pOctetString,
			   pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.value,
			   pParsedData->NonStandardData.sData.wOctetStringLength);    }
    else
    {
        pParsedData->NonStandardDataPresent = FALSE;
    }

    if (pUserInfo->h323_uu_pdu.h323_message_body.u.releaseComplete.bit_mask & reason_present)
    {
        switch (pUserInfo->h323_uu_pdu.h323_message_body.u.releaseComplete.reason.choice)
		{
        case noBandwidth_chosen:
			pParsedData->bReason = CC_REJECT_NO_BANDWIDTH;
			break;
        case gatekeeperResources_chosen:
			pParsedData->bReason = CC_REJECT_GATEKEEPER_RESOURCES;
			break;
        case unreachableDestination_chosen:
			pParsedData->bReason = CC_REJECT_UNREACHABLE_DESTINATION;
			break;
        case destinationRejection_chosen:
			pParsedData->bReason = CC_REJECT_DESTINATION_REJECTION;
			break;
        case invalidRevision_chosen:
			pParsedData->bReason = CC_REJECT_INVALID_REVISION;
			break;
        case noPermission_chosen:
			pParsedData->bReason = CC_REJECT_NO_PERMISSION;
			break;
        case unreachableGatekeeper_chosen:
			pParsedData->bReason = CC_REJECT_UNREACHABLE_GATEKEEPER;
			break;
        case gatewayResources_chosen:
			pParsedData->bReason = CC_REJECT_GATEWAY_RESOURCES;
			break;
        case badFormatAddress_chosen:
			pParsedData->bReason = CC_REJECT_BAD_FORMAT_ADDRESS;
			break;
        case adaptiveBusy_chosen:
			pParsedData->bReason = CC_REJECT_ADAPTIVE_BUSY;
			break;
        case inConf_chosen:
			pParsedData->bReason = CC_REJECT_IN_CONF;
			break;
        case facilityCallDeflection_chosen:
			pParsedData->bReason = CC_REJECT_CALL_DEFLECTION;
			break;
		default:
            pParsedData->bReason = CC_REJECT_UNDEFINED_REASON;
		} // switch
    }
	else
	{
		pParsedData->bReason = CC_REJECT_UNDEFINED_REASON;
	}

    // Free the PDU data.
    Result = freePDU(pWorld, PDU, pDecodedBuf, q931asn);
    ASSERT(ASN1_SUCCEEDED(Result));
    return CS_OK;
}

//------------------------------------------------------------------------
//------------------------------------------------------------------------
HRESULT
Q931ConnectParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_CONNECT_ASN *pParsedData)
{
    int PDU = H323_UserInformation_PDU;
    char *pDecodedBuf = NULL;
    H323_UserInformation *pUserInfo;
    struct ObjectID_ *id;
    int Result;

    if (pParsedData == NULL)
    {
        return CS_BAD_PARAM;
    }

    Result = Q931_Decode(pWorld,
                         (void **) &pDecodedBuf,
                         PDU,
                         pEncodedBuf,
                         dwEncodedLength);

    if (ASN1_FAILED(Result) || (pDecodedBuf == NULL))
    {
        ASSERT(FALSE);
        // trace and return an decoding error of some sort.
        // Note: some values of Result should cause CS_SUBSYSTEM_FAILURE return.
        return CS_BAD_PARAM;
    }

    // validate some basic things about the PDU...
    pUserInfo = (H323_UserInformation *)pDecodedBuf;

    // validate that this is a H323 PDU.
    if (PDU != H323_UserInformation_PDU)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // validate that the PDU user-data uses ASN encoding.
    if (((pUserInfo->bit_mask & user_data_present) != 0) &&
            (pUserInfo->user_data.protocol_discriminator != USE_ASN1_ENCODING))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // validate that the PDU is H323 Connect information.
    if (pUserInfo->h323_uu_pdu.h323_message_body.choice != connect_chosen)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    id = pUserInfo->h323_uu_pdu.h323_message_body.u.connect.protocolIdentifier;
    if (!Q931ValidPduVersion(id))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_INCOMPATIBLE_VERSION;
    }

    // make sure that the conference id is formed correctly.
    if (pUserInfo->h323_uu_pdu.h323_message_body.u.connect.conferenceID.length >
            sizeof(pUserInfo->h323_uu_pdu.h323_message_body.u.connect.conferenceID.value))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // parse the message contained in pUserInfo.
    memset(pParsedData, 0, sizeof(Q931_CONNECT_ASN));
    pParsedData->h245Addr.bMulticast = FALSE;

    if ((pUserInfo->h323_uu_pdu.bit_mask & H323_UU_PDU_nnStndrdDt_present) != 0)
    {
        pParsedData->NonStandardDataPresent = TRUE;
        if (pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.choice ==
                h221NonStandard_chosen)
        {
            pParsedData->NonStandardData.bCountryCode =
                (BYTE)(pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35CountryCode);
            pParsedData->NonStandardData.bExtension =
                (BYTE)(pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35Extension);
            pParsedData->NonStandardData.wManufacturerCode =
                pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.manufacturerCode;
        }
        pParsedData->NonStandardData.sData.wOctetStringLength = (WORD)
            pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.length;
		pParsedData->NonStandardData.sData.pOctetString =
			(BYTE *)Malloc(pParsedData->NonStandardData.sData.wOctetStringLength);
		if (pParsedData->NonStandardData.sData.pOctetString == NULL)
		{
            freePDU(pWorld, PDU, pDecodedBuf, q931asn);
            return CS_NO_MEMORY;
		}
		memcpy(pParsedData->NonStandardData.sData.pOctetString,
			   pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.value,
			   pParsedData->NonStandardData.sData.wOctetStringLength);
    }
    else
    {
        pParsedData->NonStandardDataPresent = FALSE;
    }

    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.connect.bit_mask &
            Cnnct_UUIE_h245Address_present) != 0)
    {
        BYTE *a = (BYTE *)(&(pParsedData->h245Addr.Addr.IP_Binary.dwAddr));
        pParsedData->h245Addr.nAddrType = CC_IP_BINARY;
        pParsedData->h245Addr.Addr.IP_Binary.wPort = 
            pUserInfo->h323_uu_pdu.h323_message_body.u.connect.Cnnct_UUIE_h245Address.u.ipAddress.port;
        a[3] = pUserInfo->h323_uu_pdu.h323_message_body.u.connect.Cnnct_UUIE_h245Address.u.ipAddress.ip.value[0];
        a[2] = pUserInfo->h323_uu_pdu.h323_message_body.u.connect.Cnnct_UUIE_h245Address.u.ipAddress.ip.value[1];
        a[1] = pUserInfo->h323_uu_pdu.h323_message_body.u.connect.Cnnct_UUIE_h245Address.u.ipAddress.ip.value[2];
        a[0] = pUserInfo->h323_uu_pdu.h323_message_body.u.connect.Cnnct_UUIE_h245Address.u.ipAddress.ip.value[3];
        pParsedData->h245AddrPresent = TRUE;
    }
    else
    {
        pParsedData->h245AddrPresent = FALSE;
    }

    // no validation of destinationInfo needed.

    pParsedData->EndpointType.pVendorInfo = NULL;
    if (pUserInfo->h323_uu_pdu.h323_message_body.u.connect.destinationInfo.bit_mask & (vendor_present))
    {
        pParsedData->EndpointType.pVendorInfo = &(pParsedData->VendorInfo);
        pParsedData->VendorInfo.bCountryCode =
            (BYTE)pUserInfo->h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.vendor.t35CountryCode;
        pParsedData->VendorInfo.bExtension =
            (BYTE)pUserInfo->h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.vendor.t35Extension;
        pParsedData->VendorInfo.wManufacturerCode =
            pUserInfo->h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.vendor.manufacturerCode;

        if (pUserInfo->h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.bit_mask & (productId_present))
        {
            pParsedData->VendorInfo.pProductNumber = Malloc(sizeof(CC_OCTETSTRING));
            if (pParsedData->VendorInfo.pProductNumber == NULL)
            {
				if (pParsedData->NonStandardData.sData.pOctetString != NULL)
					Free(pParsedData->NonStandardData.sData.pOctetString);
                freePDU(pWorld, PDU, pDecodedBuf, q931asn);
                return CS_NO_MEMORY;
            }
            pParsedData->VendorInfo.pProductNumber->wOctetStringLength = (WORD)
                min(pUserInfo->h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.productId.length,
                CC_MAX_PRODUCT_LENGTH - 1);
            memcpy(pParsedData->bufProductValue,
                pUserInfo->h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.productId.value,
                pParsedData->VendorInfo.pProductNumber->wOctetStringLength);
            pParsedData->bufProductValue[pParsedData->VendorInfo.pProductNumber->wOctetStringLength] = '\0';
            pParsedData->VendorInfo.pProductNumber->pOctetString = pParsedData->bufProductValue;
        }
        if (pUserInfo->h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.bit_mask & (versionId_present))
        {
            pParsedData->VendorInfo.pVersionNumber = Malloc(sizeof(CC_OCTETSTRING));
            if (pParsedData->VendorInfo.pVersionNumber == NULL)
            {
				if (pParsedData->NonStandardData.sData.pOctetString != NULL)
					Free(pParsedData->NonStandardData.sData.pOctetString);
                Free(pParsedData->VendorInfo.pProductNumber);
                freePDU(pWorld, PDU, pDecodedBuf, q931asn);
                return CS_NO_MEMORY;
            }
            pParsedData->VendorInfo.pVersionNumber->wOctetStringLength = (WORD)
                min(pUserInfo->h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.versionId.length,
                CC_MAX_VERSION_LENGTH - 1);
            memcpy(pParsedData->bufVersionValue,
                pUserInfo->h323_uu_pdu.h323_message_body.u.connect.destinationInfo.vendor.versionId.value,
                pParsedData->VendorInfo.pVersionNumber->wOctetStringLength);
            pParsedData->bufVersionValue[pParsedData->VendorInfo.pVersionNumber->wOctetStringLength] = '\0';
            pParsedData->VendorInfo.pVersionNumber->pOctetString = pParsedData->bufVersionValue;
        }

    }

    pParsedData->EndpointType.bIsTerminal = FALSE;
    if (pUserInfo->h323_uu_pdu.h323_message_body.u.connect.destinationInfo.bit_mask & (terminal_present))
    {
        pParsedData->EndpointType.bIsTerminal = TRUE;
    }
    pParsedData->EndpointType.bIsGateway = FALSE;
    if (pUserInfo->h323_uu_pdu.h323_message_body.u.connect.destinationInfo.bit_mask & (gateway_present))
    {
        pParsedData->EndpointType.bIsGateway = TRUE;
    }


    memcpy(pParsedData->ConferenceID.buffer,
        pUserInfo->h323_uu_pdu.h323_message_body.u.connect.conferenceID.value,
        pUserInfo->h323_uu_pdu.h323_message_body.u.connect.conferenceID.length);

    // Free the PDU data.
    Result = freePDU(pWorld, PDU, pDecodedBuf, q931asn);
    ASSERT(ASN1_SUCCEEDED(Result));
    return CS_OK;
}

//------------------------------------------------------------------------
//------------------------------------------------------------------------
HRESULT
Q931AlertingParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_ALERTING_ASN *pParsedData)
{
    int PDU = H323_UserInformation_PDU;
    char *pDecodedBuf = NULL;
    H323_UserInformation *pUserInfo;
    struct ObjectID_ *id;
    int Result;

    if (pParsedData == NULL)
    {
        return CS_BAD_PARAM;
    }

    Result = Q931_Decode(pWorld,
                         (void **) &pDecodedBuf,
                         PDU,
                         pEncodedBuf,
                         dwEncodedLength);

    if (ASN1_FAILED(Result) || (pDecodedBuf == NULL))
    {
        ASSERT(FALSE);
        // trace and return an decoding error of some sort.
        // Note: some values of Result should cause CS_SUBSYSTEM_FAILURE return.
        return CS_BAD_PARAM;
    }

    // validate some basic things about the PDU...
    pUserInfo = (H323_UserInformation *)pDecodedBuf;

    // validate that this is a H323 PDU.
    if (PDU != H323_UserInformation_PDU)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // validate that the PDU user-data uses ASN encoding.
    if (((pUserInfo->bit_mask & user_data_present) != 0) &&
            (pUserInfo->user_data.protocol_discriminator != USE_ASN1_ENCODING))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // validate that the PDU is H323 Alerting information.
    if (pUserInfo->h323_uu_pdu.h323_message_body.choice != alerting_chosen)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    id = pUserInfo->h323_uu_pdu.h323_message_body.u.alerting.protocolIdentifier;
    if (!Q931ValidPduVersion(id))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_INCOMPATIBLE_VERSION;
    }

    // parse the message contained in pUserInfo.
    memset(pParsedData, 0, sizeof(Q931_ALERTING_ASN));
    pParsedData->h245Addr.bMulticast = FALSE;

    if ((pUserInfo->h323_uu_pdu.bit_mask & H323_UU_PDU_nnStndrdDt_present) != 0)
    {
        pParsedData->NonStandardDataPresent = TRUE;
        if (pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.choice ==
                h221NonStandard_chosen)
        {
            pParsedData->NonStandardData.bCountryCode =
                (BYTE)(pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35CountryCode);
            pParsedData->NonStandardData.bExtension =
                (BYTE)(pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35Extension);
            pParsedData->NonStandardData.wManufacturerCode =
                pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.manufacturerCode;
        }
        pParsedData->NonStandardData.sData.wOctetStringLength =	(WORD)
            pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.length;
		pParsedData->NonStandardData.sData.pOctetString =
			(BYTE *)Malloc(pParsedData->NonStandardData.sData.wOctetStringLength);
		if (pParsedData->NonStandardData.sData.pOctetString == NULL)
		{
            freePDU(pWorld, PDU, pDecodedBuf, q931asn);
            return CS_NO_MEMORY;
		}
		memcpy(pParsedData->NonStandardData.sData.pOctetString,
			   pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.value,
			   pParsedData->NonStandardData.sData.wOctetStringLength);
    }
    else
    {
        pParsedData->NonStandardDataPresent = FALSE;
    }

    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.alerting.bit_mask &
            CPg_UUIE_h245Addrss_present) != 0)
    {
        BYTE *a = (BYTE *)(&(pParsedData->h245Addr.Addr.IP_Binary.dwAddr));
        pParsedData->h245Addr.nAddrType = CC_IP_BINARY;
        pParsedData->h245Addr.Addr.IP_Binary.wPort = 
            pUserInfo->h323_uu_pdu.h323_message_body.u.alerting.CPg_UUIE_h245Addrss.u.ipAddress.port;
        a[3] = pUserInfo->h323_uu_pdu.h323_message_body.u.alerting.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[0];
        a[2] = pUserInfo->h323_uu_pdu.h323_message_body.u.alerting.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[1];
        a[1] = pUserInfo->h323_uu_pdu.h323_message_body.u.alerting.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[2];
        a[0] = pUserInfo->h323_uu_pdu.h323_message_body.u.alerting.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[3];
    }

//RMO. ignore the destinationInfo field.

    // Free the PDU data.
    Result = freePDU(pWorld, PDU, pDecodedBuf, q931asn);
    ASSERT(ASN1_SUCCEEDED(Result));
    return CS_OK;
}

//------------------------------------------------------------------------
//------------------------------------------------------------------------
HRESULT
Q931ProceedingParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_CALL_PROCEEDING_ASN *pParsedData)
{
    int PDU = H323_UserInformation_PDU;
    char *pDecodedBuf = NULL;
    H323_UserInformation *pUserInfo;
    struct ObjectID_ *id;
    int Result;

    if (pParsedData == NULL)
    {
        return CS_BAD_PARAM;
    }

    Result = Q931_Decode(pWorld,
                         (void **) &pDecodedBuf,
                         PDU,
                         pEncodedBuf,
                         dwEncodedLength);

    if (ASN1_FAILED(Result) || (pDecodedBuf == NULL))
    {
        ASSERT(FALSE);
        // trace and return an decoding error of some sort.
        // Note: some values of Result should cause CS_SUBSYSTEM_FAILURE return.
        return CS_BAD_PARAM;
    }

    // validate some basic things about the PDU...
    pUserInfo = (H323_UserInformation *)pDecodedBuf;

    // validate that this is a H323 PDU.
    if (PDU != H323_UserInformation_PDU)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // validate that the PDU user-data uses ASN encoding.
    if (((pUserInfo->bit_mask & user_data_present) != 0) &&
            (pUserInfo->user_data.protocol_discriminator != USE_ASN1_ENCODING))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // validate that the PDU is H323 Call Proceeding information.
    if (pUserInfo->h323_uu_pdu.h323_message_body.choice != callProceeding_chosen)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    id = pUserInfo->h323_uu_pdu.h323_message_body.u.callProceeding.protocolIdentifier;
    if (!Q931ValidPduVersion(id))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_INCOMPATIBLE_VERSION;
    }

    // parse the message contained in pUserInfo.
    memset(pParsedData, 0, sizeof(Q931_CALL_PROCEEDING_ASN));
    pParsedData->h245Addr.bMulticast = FALSE;

    if ((pUserInfo->h323_uu_pdu.bit_mask & H323_UU_PDU_nnStndrdDt_present) != 0)
    {
        pParsedData->NonStandardDataPresent = TRUE;
        if (pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.choice ==
                h221NonStandard_chosen)
        {
            pParsedData->NonStandardData.bCountryCode =
                (BYTE)(pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35CountryCode);
            pParsedData->NonStandardData.bExtension =
                (BYTE)(pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35Extension);
            pParsedData->NonStandardData.wManufacturerCode =
                pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.manufacturerCode;
        }
        pParsedData->NonStandardData.sData.wOctetStringLength =	(WORD)
        pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.length;
				pParsedData->NonStandardData.sData.pOctetString =
			(BYTE *)Malloc(pParsedData->NonStandardData.sData.wOctetStringLength);
		if (pParsedData->NonStandardData.sData.pOctetString == NULL)
		{
            freePDU(pWorld, PDU, pDecodedBuf, q931asn);
            return CS_NO_MEMORY;
		}
		memcpy(pParsedData->NonStandardData.sData.pOctetString,
			   pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.value,
			   pParsedData->NonStandardData.sData.wOctetStringLength);
    }
    else
    {
        pParsedData->NonStandardDataPresent = FALSE;
    }

    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.callProceeding.bit_mask &
            CPg_UUIE_h245Addrss_present) != 0)
    {
        BYTE *a = (BYTE *)(&(pParsedData->h245Addr.Addr.IP_Binary.dwAddr));
        pParsedData->h245Addr.nAddrType = CC_IP_BINARY;
        pParsedData->h245Addr.Addr.IP_Binary.wPort = 
            pUserInfo->h323_uu_pdu.h323_message_body.u.callProceeding.CPg_UUIE_h245Addrss.u.ipAddress.port;
        a[3] = pUserInfo->h323_uu_pdu.h323_message_body.u.callProceeding.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[0];
        a[2] = pUserInfo->h323_uu_pdu.h323_message_body.u.callProceeding.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[1];
        a[1] = pUserInfo->h323_uu_pdu.h323_message_body.u.callProceeding.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[2];
        a[0] = pUserInfo->h323_uu_pdu.h323_message_body.u.callProceeding.CPg_UUIE_h245Addrss.u.ipAddress.ip.value[3];
    }

//RMO. ignore the destinationInfo field.

    // Free the PDU data.
    Result = freePDU(pWorld, PDU, pDecodedBuf, q931asn);
    ASSERT(ASN1_SUCCEEDED(Result));
    return CS_OK;
}

//------------------------------------------------------------------------
//------------------------------------------------------------------------
HRESULT
Q931FacilityParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_FACILITY_ASN *pParsedData)
{
    int PDU = H323_UserInformation_PDU;
    char *pDecodedBuf = NULL;
    H323_UserInformation *pUserInfo;
    int Result;

    if (pParsedData == NULL)
    {
        return CS_BAD_PARAM;
    }

    Result = Q931_Decode(pWorld,
                         (void **) &pDecodedBuf,
                         PDU,
                         pEncodedBuf,
                         dwEncodedLength);

    if (ASN1_FAILED(Result) || (pDecodedBuf == NULL))
    {
        ASSERT(FALSE);
        // trace and return an decoding error of some sort.
        // Note: some values of Result should cause CS_SUBSYSTEM_FAILURE return.
        return CS_BAD_PARAM;
    }

    // validate some basic things about the PDU...
    pUserInfo = (H323_UserInformation *)pDecodedBuf;

    // validate that this is a H323 PDU.
    if (PDU != H323_UserInformation_PDU)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // validate that the PDU user-data uses ASN encoding.
    if (((pUserInfo->bit_mask & user_data_present) != 0) &&
            (pUserInfo->user_data.protocol_discriminator != USE_ASN1_ENCODING))
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    // validate that the PDU is H323 Facility information.
    if (pUserInfo->h323_uu_pdu.h323_message_body.choice != facility_chosen)
    {
        freePDU(pWorld, PDU, pDecodedBuf, q931asn);
        return CS_BAD_PARAM;
    }

    {
        struct ObjectID_ *id;

        id = pUserInfo->h323_uu_pdu.h323_message_body.u.facility.protocolIdentifier;
        if (!Q931ValidPduVersion(id))
        {
            freePDU(pWorld, PDU, pDecodedBuf, q931asn);
            return CS_INCOMPATIBLE_VERSION;
        }
    }

    // if there is a conference id, make sure that it is formed correctly.
    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.facility.bit_mask &
            conferenceID_present) != 0)
    {
        if (pUserInfo->h323_uu_pdu.h323_message_body.u.facility.conferenceID.length >
                sizeof(pUserInfo->h323_uu_pdu.h323_message_body.u.facility.conferenceID.value))
        {
            freePDU(pWorld, PDU, pDecodedBuf, q931asn);
            return CS_BAD_PARAM;
        }
    }

    // parse the message contained in pUserInfo.
    memset(pParsedData, 0, sizeof(Q931_FACILITY_ASN));
    pParsedData->AlternativeAddr.bMulticast = FALSE;

    if ((pUserInfo->h323_uu_pdu.bit_mask & H323_UU_PDU_nnStndrdDt_present) != 0)
    {
        pParsedData->NonStandardDataPresent = TRUE;
        if (pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.choice ==
                h221NonStandard_chosen)
        {
            pParsedData->NonStandardData.bCountryCode =
                (BYTE)(pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35CountryCode);
            pParsedData->NonStandardData.bExtension =
                (BYTE)(pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.t35Extension);
            pParsedData->NonStandardData.wManufacturerCode =
                pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.nonStandardIdentifier.u.h221NonStandard.manufacturerCode;
        }
        pParsedData->NonStandardData.sData.wOctetStringLength =	(WORD)
            pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.length;
		pParsedData->NonStandardData.sData.pOctetString =
			(BYTE *)Malloc(pParsedData->NonStandardData.sData.wOctetStringLength);
		if (pParsedData->NonStandardData.sData.pOctetString == NULL)
		{
            freePDU(pWorld, PDU, pDecodedBuf, q931asn);
            return CS_NO_MEMORY;
		}
		memcpy(pParsedData->NonStandardData.sData.pOctetString,
			   pUserInfo->h323_uu_pdu.H323_UU_PDU_nnStndrdDt.data.value,
			   pParsedData->NonStandardData.sData.wOctetStringLength);
    }
    else
    {
        pParsedData->NonStandardDataPresent = FALSE;
    }

    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.facility.bit_mask &
            alternativeAddress_present) != 0)
    {
        BYTE *a = (BYTE *)(&(pParsedData->AlternativeAddr.Addr.IP_Binary.dwAddr));
        pParsedData->AlternativeAddr.nAddrType = CC_IP_BINARY;
        pParsedData->AlternativeAddr.Addr.IP_Binary.wPort = 
            pUserInfo->h323_uu_pdu.h323_message_body.u.facility.alternativeAddress.u.ipAddress.port;
        a[3] = pUserInfo->h323_uu_pdu.h323_message_body.u.facility.alternativeAddress.u.ipAddress.ip.value[0];
        a[2] = pUserInfo->h323_uu_pdu.h323_message_body.u.facility.alternativeAddress.u.ipAddress.ip.value[1];
        a[1] = pUserInfo->h323_uu_pdu.h323_message_body.u.facility.alternativeAddress.u.ipAddress.ip.value[2];
        a[0] = pUserInfo->h323_uu_pdu.h323_message_body.u.facility.alternativeAddress.u.ipAddress.ip.value[3];
    }

    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.facility.bit_mask &
            alternativeAliasAddress_present) != 0)
    {
        CS_STATUS AliasResult = CS_OK;

        // parse the sourceAddress aliases here...
        AliasResult = SeqofToAlias(&(pParsedData->pAlternativeAliasList),
            (struct _seqof3 *)pUserInfo->h323_uu_pdu.h323_message_body.u.facility.alternativeAliasAddress);
        if (AliasResult != CS_OK)
        {
            freePDU(pWorld, PDU, pDecodedBuf, q931asn);
            return CS_NO_MEMORY;
        }
    }

    if ((pUserInfo->h323_uu_pdu.h323_message_body.u.facility.bit_mask &
            conferenceID_present) != 0)
    {
        memcpy(pParsedData->ConferenceID.buffer,
            pUserInfo->h323_uu_pdu.h323_message_body.u.facility.conferenceID.value,
            pUserInfo->h323_uu_pdu.h323_message_body.u.facility.conferenceID.length);
        pParsedData->ConferenceIDPresent = TRUE;
    }

	switch (pUserInfo->h323_uu_pdu.h323_message_body.u.facility.reason.choice)
    {
	case routeCallToGatekeeper_chosen:
        pParsedData->bReason = CC_REJECT_ROUTE_TO_GATEKEEPER;
		break;
	case callForwarded_chosen:
        pParsedData->bReason = CC_REJECT_CALL_FORWARDED;
		break;
	case routeCallToMC_chosen:
        pParsedData->bReason = CC_REJECT_ROUTE_TO_MC;
		break;
	default:
        pParsedData->bReason = CC_REJECT_UNDEFINED_REASON;
	} // switch

    // Free the PDU data.
    Result = freePDU(pWorld, PDU, pDecodedBuf, q931asn);
    ASSERT(ASN1_SUCCEEDED(Result));
    return CS_OK;
}

// THE FOLLOWING IS ADDED FOR TELES ASN.1 INTEGRATION

int Q931_InitModule(void)
{
    Q931ASN_Module_Startup();
    return (Q931ASN_Module != NULL) ? ASN1_SUCCESS : ASN1_ERR_MEMORY;
}

int Q931_TermModule(void)
{
    Q931ASN_Module_Cleanup();
    return ASN1_SUCCESS;
}

int Q931_InitWorld(ASN1_CODER_INFO *pWorld)
{
    int rc;

    ZeroMemory(pWorld, sizeof(*pWorld));

    if (Q931ASN_Module == NULL)
    {
        return ASN1_ERR_BADARGS;
    }

    rc = ASN1_CreateEncoder(
                Q931ASN_Module,         // ptr to mdule
                &(pWorld->pEncInfo),    // ptr to encoder info
                NULL,                   // buffer ptr
                0,                      // buffer size
                NULL);                  // parent ptr
    if (rc == ASN1_SUCCESS)
    {
        ASSERT(pWorld->pEncInfo != NULL);
        rc = ASN1_CreateDecoder(
                Q931ASN_Module,         // ptr to mdule
                &(pWorld->pDecInfo),    // ptr to decoder info
                NULL,                   // buffer ptr
                0,                      // buffer size
                NULL);                  // parent ptr
        ASSERT(pWorld->pDecInfo != NULL);
    }

    if (rc != ASN1_SUCCESS)
    {
        Q931_TermWorld(pWorld);
    }

    return rc;
}

int Q931_TermWorld(ASN1_CODER_INFO *pWorld)
{
    if (Q931ASN_Module == NULL)
    {
        return ASN1_ERR_BADARGS;
    }

    ASN1_CloseEncoder(pWorld->pEncInfo);
    ASN1_CloseDecoder(pWorld->pDecInfo);

    ZeroMemory(pWorld, sizeof(*pWorld));

    return ASN1_SUCCESS;
}

int Q931_Encode(ASN1_CODER_INFO *pWorld, void *pStruct, int nPDU, BYTE **ppEncoded, DWORD *pcbEncodedSize)
{
    ASN1encoding_t pEncInfo = pWorld->pEncInfo;
    int rc = ASN1_Encode(
                    pEncInfo,                   // ptr to encoder info
                    pStruct,                    // pdu data structure
                    nPDU,                       // pdu id
                    ASN1ENCODE_ALLOCATEBUFFER,  // flags
                    NULL,                       // do not provide buffer
                    0);                         // buffer size if provided
    if (ASN1_SUCCEEDED(rc))
    {
        ASSERT(rc == ASN1_SUCCESS);
        *pcbEncodedSize = pEncInfo->len;        // len of encoded data in buffer
        *ppEncoded = pEncInfo->buf;             // buffer to encode into
    }
    else
    {
        ASSERT(FALSE);
        *pcbEncodedSize = 0;
        *ppEncoded = NULL;
    }
    return rc;
}

int Q931_Decode(ASN1_CODER_INFO *pWorld, void **ppStruct, int nPDU, BYTE *pEncoded, DWORD cbEncodedSize)
{
    ASN1decoding_t pDecInfo = pWorld->pDecInfo;
    int rc = ASN1_Decode(
                    pDecInfo,                   // ptr to encoder info
                    ppStruct,                   // pdu data structure
                    nPDU,                       // pdu id
                    ASN1DECODE_SETBUFFER,       // flags
                    pEncoded,                   // do not provide buffer
                    cbEncodedSize);             // buffer size if provided
    if (ASN1_SUCCEEDED(rc))
    {
        ASSERT(rc == ASN1_SUCCESS);
    }
    else
    {
        ASSERT(FALSE);
        *ppStruct = NULL;
    }
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\q931\utils.c ===
/****************************************************************************
 *
 *	$Archive:   S:\sturgeon\src\q931\vcs\utils.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1996 Intel Corporation.
 *
 *	$Revision:   1.33  $
 *	$Date:   23 Jan 1997 20:42:54  $
 *	$Author:   SBELL1  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#pragma warning ( disable : 4115 4201 4214 4514 )

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <string.h>
#include <stdio.h>

#include "common.h"
#include "q931.h"
#include "isrg.h"
#include "utils.h"
#include "linkapi.h"

//====================================================================================
//===============/=====================================================================
void
Q931MakePhysicalID(DWORD *pdwPhysicalID)
{
   *pdwPhysicalID = INVALID_PHYS_ID;
}

//====================================================================================
//====================================================================================
WORD
ADDRToInetPort(CC_ADDR *pAddr)
{
    WORD HostPort = 0;
    switch (pAddr->nAddrType)
    {
    case CC_IP_DOMAIN_NAME:
        HostPort = pAddr->Addr.IP_DomainName.wPort;
        break;
    case CC_IP_DOT:
        HostPort = pAddr->Addr.IP_Dot.wPort;
        break;
    case CC_IP_BINARY:
        HostPort = pAddr->Addr.IP_Binary.wPort;
        break;
    }
    return htons(HostPort);
}

//====================================================================================
//====================================================================================
DWORD
ADDRToInetAddr(CC_ADDR *pAddr)
{
    struct hostent *pHostEnt;

    switch (pAddr->nAddrType)
    {
    case CC_IP_DOMAIN_NAME:
        {
            char buf[sizeof(pAddr->Addr.IP_DomainName.cAddr) / sizeof(WCHAR)];

            WideCharToMultiByte(CP_ACP, 0, pAddr->Addr.IP_DomainName.cAddr, -1, buf, sizeof(buf), NULL, NULL);

            pHostEnt = gethostbyname(buf);
        }
        if (pHostEnt == NULL || pHostEnt->h_addr_list == NULL)
        {
            return htonl(0L);
        }
        return *((DWORD *)pHostEnt->h_addr_list[0]);
    
    case CC_IP_DOT:
        {
            char buf[sizeof(pAddr->Addr.IP_Dot.cAddr) / sizeof(WCHAR)];

            WideCharToMultiByte(CP_ACP, 0, pAddr->Addr.IP_Dot.cAddr, -1, buf, sizeof(buf), NULL, NULL);

            return inet_addr(buf);
        }
    case CC_IP_BINARY:
        return htonl(pAddr->Addr.IP_Binary.dwAddr);
    }
    return 0L;
}

//====================================================================================
// If Port 0 is passed in, use default listen port.
//====================================================================================
void
SetDefaultPort(CC_ADDR *pAddr)
{
    switch (pAddr->nAddrType)
    {
    case CC_IP_DOMAIN_NAME:
        if (pAddr->Addr.IP_DomainName.wPort == 0)
        {
            pAddr->Addr.IP_DomainName.wPort = CC_H323_HOST_CALL;
        }
        return;
    case CC_IP_DOT:
        if (pAddr->Addr.IP_Dot.wPort == 0)
        {
            pAddr->Addr.IP_Dot.wPort = CC_H323_HOST_CALL;
        }
        return;
    case CC_IP_BINARY:
        if (pAddr->Addr.IP_Binary.wPort == 0)
        {
            pAddr->Addr.IP_Binary.wPort = CC_H323_HOST_CALL;
        }
        return;
    }
    return;
}

//====================================================================================
//====================================================================================
BOOL
MakeBinaryADDR(CC_ADDR *pInAddr, CC_ADDR *pOutAddr)
{
    if (pOutAddr == NULL)
    {
        return FALSE;
    }

    memset(pOutAddr, 0, sizeof(CC_ADDR));

    if (pInAddr == NULL)
    {
        return FALSE;
    }

    pOutAddr->nAddrType = CC_IP_BINARY;
    pOutAddr->bMulticast = pInAddr->bMulticast;

    switch (pInAddr->nAddrType)
    {
    case CC_IP_DOMAIN_NAME:
    {
        struct hostent *pHostEnt;
        DWORD net_addr;
        {
            char buf[sizeof(pInAddr->Addr.IP_DomainName.cAddr) / sizeof(WCHAR)];

            WideCharToMultiByte(CP_ACP, 0, pInAddr->Addr.IP_DomainName.cAddr, -1, buf, sizeof(buf), NULL, NULL);

            if (buf[0] == '\0')
            {
                return FALSE;
            }
            pHostEnt = gethostbyname(buf);
        }
        if (pHostEnt == NULL || pHostEnt->h_addr_list == NULL)
        {
            return FALSE;
        }
        net_addr = *((DWORD *)pHostEnt->h_addr_list[0]);
        pOutAddr->Addr.IP_Binary.wPort = pInAddr->Addr.IP_DomainName.wPort;
        pOutAddr->Addr.IP_Binary.dwAddr = ntohl(net_addr);
    }
        break;
    case CC_IP_DOT:
        {
            char buf[sizeof(pInAddr->Addr.IP_Dot.cAddr) / sizeof(WCHAR)];

            WideCharToMultiByte(CP_ACP, 0, pInAddr->Addr.IP_Dot.cAddr, -1, buf, sizeof(buf), NULL, NULL);

            if (buf[0] == '\0')
            {
                return FALSE;
            }
            pOutAddr->Addr.IP_Binary.dwAddr = ntohl(inet_addr(buf));
        }
        pOutAddr->Addr.IP_Binary.wPort = pInAddr->Addr.IP_Dot.wPort;
        break;
    default:
        pOutAddr->Addr.IP_Binary.wPort = pInAddr->Addr.IP_Binary.wPort;
        pOutAddr->Addr.IP_Binary.dwAddr = pInAddr->Addr.IP_Binary.dwAddr;
        break;
    }
    return TRUE;
}

//====================================================================================
//====================================================================================
void
GetDomainAddr(CC_ADDR *pAddr)
{
    WORD wTemp;
    char szHostName[80];

    if (gethostname(szHostName, sizeof(szHostName)) != SOCKET_ERROR)
    {
        wTemp = pAddr->Addr.IP_Binary.wPort;
        pAddr->nAddrType = CC_IP_DOMAIN_NAME;

        MultiByteToWideChar(CP_ACP, 0, szHostName, -1,
            pAddr->Addr.IP_DomainName.cAddr,
            sizeof(pAddr->Addr.IP_DomainName.cAddr) /
            sizeof(pAddr->Addr.IP_DomainName.cAddr[0]));

        pAddr->Addr.IP_DomainName.wPort = wTemp;
    }
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931ValidateAddr(PCC_ADDR pAddr)
{
    if (pAddr == NULL)
    {
        return CS_OK;
    }
    if ((pAddr->nAddrType != CC_IP_DOMAIN_NAME) &&
            (pAddr->nAddrType != CC_IP_DOT) &&
            (pAddr->nAddrType != CC_IP_BINARY))
    {
        return CS_BAD_PARAM;
    }

    if (pAddr->nAddrType == CC_IP_DOT)
    {
        WCHAR *p = pAddr->Addr.IP_Dot.cAddr;

        while (*p)
        {
            if (wcschr((const WCHAR *)CC_ODOTTO_CHARS, *p) == NULL)
            {
                return CS_BAD_PARAM;
            }
            p++;
        }
    }

    if (pAddr->bMulticast == TRUE)
    {
        return CS_BAD_PARAM;
    }

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931ValidateAliasItem(PCC_ALIASITEM pSource)
{
    register unsigned int y;

    if (pSource)
    {
        if ((pSource->pData == NULL) || (pSource->wDataLength == 0))
        {
            return CS_BAD_PARAM;
        }
        if (pSource->pPrefix != NULL)
        {
            if (pSource->wPrefixLength == 0)
            {
                return CS_BAD_PARAM;
            }
        }
        else if (pSource->wPrefixLength != 0)
        {
            return CS_BAD_PARAM;
        }
        switch (pSource->wType)
        {
        case CC_ALIAS_H323_ID:
            if ((pSource->wDataLength + pSource->wPrefixLength) > CC_ALIAS_MAX_H323_ID)
            {
                return CS_BAD_PARAM;
            }
            break;

        case CC_ALIAS_H323_PHONE:
            if ((pSource->wDataLength + pSource->wPrefixLength +1) > CC_ALIAS_MAX_H323_PHONE)
            {
                return CS_BAD_PARAM;
            }
            for (y = 0; y < pSource->wDataLength; ++y)
            {
                if (wcschr((const WCHAR *)CC_ALIAS_H323_PHONE_CHARS, pSource->pData[y]) == NULL)
                {
                    return CS_BAD_PARAM;
                }
            }
            if (pSource->pPrefix != NULL)
            {
                for (y = 0; y < pSource->wPrefixLength; ++y)
                {
                    if (wcschr((const WCHAR *)CC_ALIAS_H323_PHONE_CHARS, pSource->pPrefix[y]) == NULL)
                    {
                        return CS_BAD_PARAM;
                    }
                }
            }
        }
    }
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931CopyAliasItem(PCC_ALIASITEM *ppTarget, PCC_ALIASITEM pSource)
{
    PCC_ALIASITEM pNewItem = NULL;

    if (ppTarget == NULL)
    {
        return CS_BAD_PARAM;
    }
    *ppTarget = NULL;
    if (pSource == NULL)
    {
        return CS_OK;
    }

    pNewItem = (PCC_ALIASITEM)Malloc(sizeof(CC_ALIASITEM));
    if (pNewItem == NULL)
    {
        return CS_NO_MEMORY;
    }
    pNewItem->wType = pSource->wType;

  	if ((pSource->wPrefixLength != 0) && (pSource->pPrefix != NULL))
	{
        pNewItem->wPrefixLength = pSource->wPrefixLength;
        pNewItem->pPrefix = (LPWSTR)Malloc(pSource->wPrefixLength * sizeof(pNewItem->pPrefix[0]));
        if (pNewItem->pPrefix == NULL)
        {
            Free(pNewItem);
            return CS_NO_MEMORY;
        }
        memcpy(pNewItem->pPrefix, pSource->pPrefix, pSource->wPrefixLength * sizeof(WCHAR));
    }
    else
    {
        pNewItem->wPrefixLength = 0;
        pNewItem->pPrefix = NULL;
    }


    if ((pSource->wDataLength != 0) && (pSource->pData != NULL))
    {
        pNewItem->wDataLength = pSource->wDataLength;
        pNewItem->pData = (LPWSTR)Malloc(pSource->wDataLength * sizeof(pNewItem->pData[0]));
        if (pNewItem->pData == NULL)
        {
            if (pNewItem->pPrefix)
            {
               Free(pNewItem->pPrefix);
            }
            Free(pNewItem);
            return CS_NO_MEMORY;
        }
        memcpy(pNewItem->pData, pSource->pData, pSource->wDataLength * sizeof(WCHAR));
    }
    else
    {
        pNewItem->wDataLength = 0;
        pNewItem->pData = NULL;
    }
    *ppTarget = pNewItem;

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931FreeAliasItem(PCC_ALIASITEM pSource)
{
    if (pSource)
    {
        if ((pSource->pPrefix) != NULL)
        {
            Free(pSource->pPrefix);
        }
        if ((pSource->pData) != NULL)
        {
            Free(pSource->pData);
        }
        Free(pSource);
    }
    return CS_OK;
}












//====================================================================================
//====================================================================================
CS_STATUS
Q931ValidateAliasNames(PCC_ALIASNAMES pSource)
{
    CS_STATUS TempResult = CS_OK;
    WORD x;

    if (pSource)
    {
        for (x = 0; x < pSource->wCount; x++)
        {
            TempResult = Q931ValidateAliasItem(&(pSource->pItems[x]));
            if (TempResult != CS_OK)
            {
                return TempResult;
            }
        }
    }
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931CopyAliasNames(PCC_ALIASNAMES *ppTarget, PCC_ALIASNAMES pSource)
{
    if (ppTarget == NULL)
    {
        return CS_BAD_PARAM;
    }
    *ppTarget = NULL;
    if (pSource == NULL)
    {
        return CS_OK;
    }
    if (pSource->wCount)
    {
        WORD x;
        *ppTarget = (PCC_ALIASNAMES)Malloc(sizeof(CC_ALIASNAMES));
        if (*ppTarget == NULL)
        {
            return CS_NO_MEMORY;
        }
        (*ppTarget)->pItems = (PCC_ALIASITEM)Malloc(pSource->wCount *
            sizeof(CC_ALIASITEM));
        if ((*ppTarget)->pItems == NULL)
        {
            Free(*ppTarget);
            *ppTarget = NULL;
            return CS_NO_MEMORY;
        }
        (*ppTarget)->wCount = pSource->wCount;
        {
            PCC_ALIASITEM p = (*ppTarget)->pItems;

            for (x = 0; x < pSource->wCount; x++)
            {
                p[x].wType = pSource->pItems[x].wType;

                if ((pSource->pItems[x].wPrefixLength != 0) &&
                        (pSource->pItems[x].pPrefix != NULL))
                {
                    p[x].wPrefixLength = pSource->pItems[x].wPrefixLength;
                    p[x].pPrefix = (LPWSTR)Malloc(pSource->pItems[x].wPrefixLength * sizeof(p[x].pPrefix[0]));
                    if (p[x].pPrefix == NULL)
                    {
                        // Free everything that has been allocated so far...
                        int y;
                        for (y = 0; y < x; y++)
                        {
                            if (p[y].pPrefix)
                            {
                                Free(p[y].pPrefix);
                            }
                            if (p[y].pData)
                            {
                                Free(p[y].pData);
                            }
                        }
                        Free(p);
                        Free(*ppTarget);
                        *ppTarget = NULL;
                        return CS_NO_MEMORY;
                    }
                    memcpy(p[x].pPrefix, pSource->pItems[x].pPrefix,
                        pSource->pItems[x].wPrefixLength * sizeof(WCHAR));
                }
                else
                {
                    p[x].wPrefixLength = 0;
                    p[x].pPrefix = NULL;
                }


                if ((pSource->pItems[x].wDataLength != 0) &&
                        (pSource->pItems[x].pData != NULL))
                {
                    p[x].wDataLength = pSource->pItems[x].wDataLength;
                    p[x].pData = (LPWSTR)Malloc(pSource->pItems[x].wDataLength * sizeof(p[x].pData[0]));
                    if (p[x].pData == NULL)
                    {
                        // Free everything that has been allocated so far...
                        int y;
                        if (p[x].pPrefix)
                        {
                            Free(p[x].pPrefix);
                        }
                        for (y = 0; y < x; y++)
                        {
                            if (p[y].pPrefix)
                            {
                                Free(p[y].pPrefix);
                            }
                            if (p[y].pData)
                            {
                                Free(p[y].pData);
                            }
                         }
                        Free(p);
                        Free(*ppTarget);
                        *ppTarget = NULL;
                        return CS_NO_MEMORY;
                    }
                    memcpy(p[x].pData, pSource->pItems[x].pData,
                        pSource->pItems[x].wDataLength * sizeof(WCHAR));
                }
                else
                {
                    p[x].wDataLength = 0;
                    p[x].pData = NULL;
                }
            }
        }
    }
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931FreeAliasNames(PCC_ALIASNAMES pSource)
{
    if (pSource && (pSource->wCount))
    {
        // Free everything that has been allocated so far...
        int x;
        for (x = 0; x < pSource->wCount; x++)
        {
            if ((pSource->pItems[x].pPrefix) != NULL)
            {
                Free(pSource->pItems[x].pPrefix);
            }
            if ((pSource->pItems[x].pData) != NULL)
            {
                Free(pSource->pItems[x].pData);
            }
        }
        if (pSource->pItems != NULL)
        {
            Free(pSource->pItems);
        }
        if (pSource != NULL)
        {
            Free(pSource);
        }
    }
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931ValidateDisplay(LPWSTR pszDisplay)
{
    if (pszDisplay == NULL)
    {
        return CS_OK;
    }
    if (wcslen(pszDisplay) > CC_MAX_DISPLAY_LENGTH)
    {
        return CS_BAD_PARAM;
    }
#if 0 // turn this on to validate display field against IA5 characters...
    while (*pszDisplay)
    {
        if (wcschr(CC_UNICODE_IA5_CHARS, *pszDisplay) == NULL)
        {
            return CS_BAD_PARAM;
        }
        pszDisplay++;
    }
#endif
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931ValidatePartyNumber(LPWSTR pszPartyNumber)
{
    if (pszPartyNumber == NULL)
    {
        return CS_OK;
    }
    if (wcslen(pszPartyNumber) > CC_MAX_PARTY_NUMBER_LEN)
    {
        return CS_BAD_PARAM;
    }
#if 0 // turn this on to validate party number field against IA5 characters...
    while (*pszPartyNumber)
    {
        if (wcschr(CC_UNICODE_IA5_CHARS, *pszPartyNumber) == NULL)
        {
            return CS_BAD_PARAM;
        }
        pszPartyNumber++;
    }
#endif
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931CopyDisplay(LPWSTR *ppDest, LPWSTR pSource)
{
    if (ppDest == NULL)
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }
    if (pSource == NULL)
    {
        *ppDest = NULL;
        return CS_OK;
    }
    *ppDest = (LPWSTR)Malloc((wcslen(pSource) + 1) * sizeof(WCHAR));
    if (*ppDest == NULL)
    {
        return CS_NO_MEMORY;
    }
    wcscpy(*ppDest, pSource);
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931FreeDisplay(LPWSTR pszDisplay)
{
    if (pszDisplay == NULL)
    {
        return CS_OK;
    }
    Free(pszDisplay);
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931ValidateVendorInfo(PCC_VENDORINFO pVendorInfo)
{
    if (pVendorInfo == NULL)
    {
        return CS_OK;
    }

    if (pVendorInfo->pProductNumber)
    {
        if (pVendorInfo->pProductNumber->wOctetStringLength)
        {
            if (pVendorInfo->pProductNumber->wOctetStringLength > CC_MAX_PRODUCT_LENGTH)
            {
                return CS_BAD_PARAM;
            }
            if (pVendorInfo->pProductNumber->pOctetString == NULL)
            {
                return CS_BAD_PARAM;
            }
        }
        else if (pVendorInfo->pProductNumber->pOctetString)
        {
            return CS_BAD_PARAM;
        }
    }

    if (pVendorInfo->pVersionNumber)
    {
        if (pVendorInfo->pVersionNumber->wOctetStringLength)
        {
            if (pVendorInfo->pVersionNumber->wOctetStringLength > CC_MAX_VERSION_LENGTH)
            {
                return CS_BAD_PARAM;
            }
            if (pVendorInfo->pVersionNumber->pOctetString == NULL)
            {
                return CS_BAD_PARAM;
            }
        }
        else if (pVendorInfo->pVersionNumber->pOctetString)
        {
            return CS_BAD_PARAM;
        }
    }

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931CopyVendorInfo(PCC_VENDORINFO *ppDest, PCC_VENDORINFO pSource)
{
    if (ppDest == NULL)
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }
    if (pSource == NULL)
    {
        *ppDest = NULL;
        return CS_OK;
    }
    *ppDest = (PCC_VENDORINFO)Malloc(sizeof(CC_VENDORINFO));
    if (*ppDest == NULL)
    {
        return CS_NO_MEMORY;
    }
    memset(*ppDest, 0, sizeof(CC_VENDORINFO));
    (*ppDest)->bCountryCode = pSource->bCountryCode;
    (*ppDest)->bExtension = pSource->bExtension;
    (*ppDest)->wManufacturerCode = pSource->wManufacturerCode;

    if ((pSource->pProductNumber == NULL) ||
            (pSource->pProductNumber->pOctetString == NULL) ||
            (pSource->pProductNumber->wOctetStringLength == 0))
    {
        (*ppDest)->pProductNumber = NULL;
    }
    else
    {
        (*ppDest)->pProductNumber = (PCC_OCTETSTRING)Malloc(sizeof(CC_OCTETSTRING));
        if ((*ppDest)->pProductNumber == NULL)
        {
            Q931FreeVendorInfo(*ppDest);
            *ppDest = NULL;
            return CS_NO_MEMORY;
        }
        memset((*ppDest)->pProductNumber, 0, sizeof(CC_OCTETSTRING));
        (*ppDest)->pProductNumber->pOctetString =
            (BYTE *)Malloc(pSource->pProductNumber->wOctetStringLength);
        if ((*ppDest)->pProductNumber->pOctetString == NULL)
        {
            Q931FreeVendorInfo(*ppDest);
            *ppDest = NULL;
            return CS_NO_MEMORY;
        }
        (*ppDest)->pProductNumber->wOctetStringLength =
            pSource->pProductNumber->wOctetStringLength;
        memcpy((*ppDest)->pProductNumber->pOctetString,
            pSource->pProductNumber->pOctetString,
            pSource->pProductNumber->wOctetStringLength);
    }

    if ((pSource->pVersionNumber == NULL) ||
            (pSource->pVersionNumber->pOctetString == NULL) ||
            (pSource->pVersionNumber->wOctetStringLength == 0))
    {
        (*ppDest)->pVersionNumber = NULL;
    }
    else
    {
        (*ppDest)->pVersionNumber = (PCC_OCTETSTRING)Malloc(sizeof(CC_OCTETSTRING));
        if ((*ppDest)->pVersionNumber == NULL)
        {
            Q931FreeVendorInfo(*ppDest);
            *ppDest = NULL;
            return CS_NO_MEMORY;
        }
        memset((*ppDest)->pVersionNumber, 0, sizeof(CC_OCTETSTRING));
        (*ppDest)->pVersionNumber->pOctetString =
            (BYTE *)Malloc(pSource->pVersionNumber->wOctetStringLength);
        if ((*ppDest)->pVersionNumber->pOctetString == NULL)
        {
            Q931FreeVendorInfo(*ppDest);
            *ppDest = NULL;
            return CS_NO_MEMORY;
        }
        (*ppDest)->pVersionNumber->wOctetStringLength =
            pSource->pVersionNumber->wOctetStringLength;
        memcpy((*ppDest)->pVersionNumber->pOctetString,
            pSource->pVersionNumber->pOctetString,
            pSource->pVersionNumber->wOctetStringLength);
    }

    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931FreeVendorInfo(PCC_VENDORINFO pVendorInfo)
{
    if (pVendorInfo == NULL)
    {
        return CS_OK;
    }
    if (pVendorInfo->pProductNumber != NULL)
    {
        if (pVendorInfo->pProductNumber->pOctetString != NULL)
        {
            Free(pVendorInfo->pProductNumber->pOctetString);
        }
        Free(pVendorInfo->pProductNumber);
    }
    if (pVendorInfo->pVersionNumber != NULL)
    {
        if (pVendorInfo->pVersionNumber->pOctetString != NULL)
        {
            Free(pVendorInfo->pVersionNumber->pOctetString);
        }
        Free(pVendorInfo->pVersionNumber);
    }
    Free(pVendorInfo);
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931ValidateNonStandardData(PCC_NONSTANDARDDATA pNonStandardData)
{
    if (pNonStandardData)
    {
        if ((pNonStandardData->sData.pOctetString == NULL) ||
                (pNonStandardData->sData.wOctetStringLength == 0))
        {
            return CS_BAD_PARAM;
        }
    }
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931CopyNonStandardData(PCC_NONSTANDARDDATA *ppDest, PCC_NONSTANDARDDATA pSource)
{
    if (ppDest == NULL)
    {
        ASSERT(FALSE);
        return CS_BAD_PARAM;
    }
    if (pSource == NULL)
    {
        *ppDest = NULL;
        return CS_OK;
    }
    *ppDest = (PCC_NONSTANDARDDATA)Malloc(sizeof(CC_NONSTANDARDDATA));
    if (*ppDest == NULL)
    {
        return CS_NO_MEMORY;
    }
    (*ppDest)->bCountryCode = pSource->bCountryCode;
    (*ppDest)->bExtension = pSource->bExtension;
    (*ppDest)->wManufacturerCode = pSource->wManufacturerCode;
    (*ppDest)->sData.wOctetStringLength = pSource->sData.wOctetStringLength;
    if (pSource->sData.pOctetString == NULL)
    {
        (*ppDest)->sData.pOctetString = NULL;
    }
    else
    {
        (*ppDest)->sData.pOctetString = (void *)Malloc(pSource->sData.wOctetStringLength);
        if ((*ppDest)->sData.pOctetString == NULL)
        {
            Free(*ppDest);
            *ppDest = NULL;
            return CS_NO_MEMORY;
        }
        memcpy((*ppDest)->sData.pOctetString, pSource->sData.pOctetString,
            pSource->sData.wOctetStringLength);
    }
    return CS_OK;
}

//====================================================================================
//====================================================================================
CS_STATUS
Q931FreeNonStandardData(PCC_NONSTANDARDDATA pNonStandardData)
{
    if (pNonStandardData == NULL)
    {
        return CS_OK;
    }
    if (pNonStandardData->sData.pOctetString != NULL)
    {
        Free(pNonStandardData->sData.pOctetString);
    }
    Free(pNonStandardData);
    return CS_OK;
}


#if defined(DBG) && !defined(ISRDBG)

DWORD g_dwQ931DbgLevel = 0;
BOOL  g_fQ931DbgInitialized = FALSE;

void Q931DbgInit() {

#define H323_REGKEY_ROOT \
    TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\H323TSP")

#define H323_REGVAL_DEBUGLEVEL \
    TEXT("DebugLevel")

#define H323_REGVAL_Q931DEBUGLEVEL \
    TEXT("Q931DebugLevel")

    HKEY hKey;
    LONG lStatus;
    DWORD dwValue;
    DWORD dwValueSize;
    DWORD dwValueType;
    LPSTR pszValue;
    LPSTR pszKey = H323_REGKEY_ROOT;

    // only call this once
    g_fQ931DbgInitialized = TRUE;

    // open registry subkey
    lStatus = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                pszKey,
                0,
                KEY_READ,
                &hKey
                );

    // validate return code
    if (lStatus != ERROR_SUCCESS) {
        return; // bail...
    }
    
    // initialize values
    dwValueType = REG_DWORD;
    dwValueSize = sizeof(DWORD);

    // retrieve q931 debug level
    pszValue = H323_REGVAL_Q931DEBUGLEVEL;

    // query for registry value
    lStatus = RegQueryValueEx(
                hKey,
                pszValue,
                NULL,
                &dwValueType,
                (LPBYTE)&dwValue,
                &dwValueSize
                );                    

    // validate return code
    if (lStatus != ERROR_SUCCESS) {

        // initialize values
        dwValueType = REG_DWORD;
        dwValueSize = sizeof(DWORD);

        // retrieve tsp debug level
        pszValue = H323_REGVAL_DEBUGLEVEL;

        // query for registry value
        lStatus = RegQueryValueEx(
                    hKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (LPBYTE)&dwValue,
                    &dwValueSize
                    );
    }

    // validate return code
    if (lStatus == ERROR_SUCCESS) {

        // update debug level
        g_dwQ931DbgLevel  = dwValue;
    }

    // close key
    RegCloseKey(hKey);
}

void Q931DbgPrint(DWORD dwLevel,

#ifdef UNICODE_TRACE
				LPTSTR pszFormat,
#else
				LPSTR pszFormat,
#endif               
                ...)
{
#define DEBUG_FORMAT_HEADER     "Q931 "
#define DEBUG_FORMAT_TIMESTAMP  "[%02u:%02u:%02u.%03u"
#define DEBUG_FORMAT_THREADID   ",tid=%x] "

#define MAXDBG_STRLEN        512

    va_list Args;
    SYSTEMTIME SystemTime;
    char szDebugMessage[MAXDBG_STRLEN+1];
    int nLengthRemaining;
    int nLength = 0;

    // make sure initialized
    if (g_fQ931DbgInitialized == FALSE) {
        Q931DbgInit();
    }

    // verify debug log level
    if (dwLevel > g_dwQ931DbgLevel) {
        return; // bail...
    }

    // retrieve local time
    GetLocalTime(&SystemTime);

    // add component header to the debug message
    nLength += sprintf(&szDebugMessage[nLength],
                       DEBUG_FORMAT_HEADER
                       );

    // add timestamp to the debug message
    nLength += sprintf(&szDebugMessage[nLength],
                       DEBUG_FORMAT_TIMESTAMP,
                       SystemTime.wHour,
                       SystemTime.wMinute,
                       SystemTime.wSecond,
                       SystemTime.wMilliseconds
                       );

    // add thread id to the debug message
    nLength += sprintf(&szDebugMessage[nLength],
                       DEBUG_FORMAT_THREADID,
                       GetCurrentThreadId()
                       );

    // point at first argument
    va_start(Args, pszFormat);

    // determine number of bytes left in buffer
    nLengthRemaining = sizeof(szDebugMessage) - nLength;

    // add user specified debug message
    _vsnprintf(&szDebugMessage[nLength],
               nLengthRemaining,
               pszFormat,
               Args
               );

    // release pointer
    va_end(Args);

    // output message to specified sink
    OutputDebugString(szDebugMessage);
    OutputDebugString("\n");
}

#endif

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\q931\q931plog.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************/

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// AUTHOR    Tony Moy, Stacy Bell
//
// DESCRIPTION
//		This file contains protocol logging definitions needed by Q931 and
//		the Q931 PDU logging class.
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

// This define identifies the Q931 protocol as the one to be logged.  In the 
// Q931 code, it is used only in the InteorpLoad() call.  
// For example:  Q931Logger = InteropLoad( Q931LOG_PROTOCOL );
//

#define Q931LOG_PROTOCOL "Q931_PDU"

// PDU encoding type flags and PDU type flags.  These flags are passed from
// Q931 to the logging via user data.  Bit zero of the user data represents
// whether the PDU was sent or received.
//

#define Q931LOG_SENT_PDU        1UL
#define Q931LOG_RECEIVED_PDU    0UL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\confmsp\confaddr.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    confaddr.h

Abstract:

    Declaration of the CIPConfMSP

Author:
    
    Mu Han (muhan) 1-November-1997

--*/

#ifndef __CONFADDR_H_
#define __CONFADDR_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"

const DWORD IPCONFCALLMEDIATYPES = (TAPIMEDIATYPE_AUDIO | TAPIMEDIATYPE_VIDEO);
const DWORD MAXIPADDRLEN = 40;

/////////////////////////////////////////////////////////////////////////////
// CIPConfMSP
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CIPConfMSP : 
    public CMSPAddress,
    public CComCoClass<CIPConfMSP, &CLSID_IPConfMSP>,
    public CMSPObjectSafetyImpl
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_IPCONFMSP)
DECLARE_POLY_AGGREGATABLE(CIPConfMSP)

public:

    BEGIN_COM_MAP(CIPConfMSP)
        COM_INTERFACE_ENTRY(IObjectSafety)
        COM_INTERFACE_ENTRY_CHAIN(CMSPAddress)
    END_COM_MAP()

    CIPConfMSP() 
        : m_dwIPInterface(INADDR_ANY),
          m_hSocket(NULL)
    {}

    HRESULT FinalConstruct();
    void    FinalRelease();
    DWORD FindLocalInterface(DWORD dwIP);

    STDMETHOD (CreateTerminal) (
        IN      BSTR                pTerminalClass,
        IN      long                lMediaType,
        IN      TERMINAL_DIRECTION  Direction,
        OUT     ITTerminal **       ppTerminal
        );

    STDMETHOD (CreateMSPCall) (
        IN      MSP_HANDLE      htCall,
        IN      DWORD           dwReserved,
        IN      DWORD           dwMediaType,
        IN      IUnknown *      pOuterUnknown,
        OUT     IUnknown **     ppMSPCall
        );

    STDMETHOD (ShutdownMSPCall) (
        IN      IUnknown *      pMSPCall
        );

    ULONG MSPAddressAddRef(void);

    ULONG MSPAddressRelease(void);

#ifdef USEIPADDRTABLE
    STDMETHOD (get_DefaultIPInterface) (
        OUT     BSTR *          ppIPAddress
        );
    
    STDMETHOD (put_DefaultIPInterface) (
        IN      BSTR            pIPAddress
        );

    STDMETHOD (get_IPInterfaces) (
        OUT     VARIANT *       pVariant
        );
    
    STDMETHOD (EnumerateIPInterfaces) (
        OUT     IEnumBstr **   ppIEnumBstr
        );
#endif

protected:

    DWORD GetCallMediaTypes(void);

protected:

    // the default interface to join the conference.
    DWORD   m_dwIPInterface;

    // the critical section to protect the local data.
    CMSPCritSection     m_Lock;

    SOCKET              m_hSocket;
};

#ifdef USEIPADDRTABLE
/////////////////////////////////////////////////////////////////////////////
// _CopyBSTR is used in creating BSTR enumerators.
/////////////////////////////////////////////////////////////////////////////
class _CopyBSTR
{
public:
    static void copy(BSTR *p1, BSTR *p2)
    {
            (*p1) = SysAllocString(*p2);
    }
    static void init(BSTR* p) {*p = NULL;}
    static void destroy(BSTR* p) { SysFreeString(*p);}
};
#endif

#endif //__CONFADDR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\confmsp\confaddr.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    confaddr.cpp 

Abstract:

    This module contains implementation of CIPConfMSP.

Author:
    
    Mu Han (muhan)   5-September-1997

--*/
#include "stdafx.h"
#include "common.h"

#ifdef USEIPADDRTABLE

#include <iprtrmib.h>

typedef DWORD (WINAPI * PFNGETIPADDRTABLE)(
                OUT    PMIB_IPADDRTABLE pIPAddrTable,
                IN OUT PDWORD           pdwSize,
                IN     BOOL             bOrder
                );

#define IPHLPAPI_DLL        L"IPHLPAPI.DLL"

#define GETIPADDRTABLE      "GetIpAddrTable"    

#define IsValidInterface(_dwAddr_) \
    (((_dwAddr_) != 0) && \
     ((_dwAddr_) != htonl(INADDR_LOOPBACK)))

#endif

#define IPCONF_WINSOCKVERSION     MAKEWORD(2,0)

HRESULT CIPConfMSP::FinalConstruct()
{
    // initialize winsock stack
    WSADATA wsaData;
    if (WSAStartup(IPCONF_WINSOCKVERSION, &wsaData) != 0)
    {
        LOG((MSP_ERROR, "WSAStartup failed with:%x", WSAGetLastError()));
        return E_FAIL;
    }

    // allocate control socket
    m_hSocket = WSASocket(
        AF_INET,            // af
        SOCK_DGRAM,         // type
        IPPROTO_IP,         // protocol
        NULL,               // lpProtocolInfo
        0,                  // g
        0                   // dwFlags
        );

    // validate handle
    if (m_hSocket == INVALID_SOCKET) {

        LOG((
            MSP_ERROR,
            "error %d creating control socket.\n",
            WSAGetLastError()
            ));

        // failure
		WSACleanup();
     
        return E_FAIL;
    }

    HRESULT hr = CMSPAddress::FinalConstruct();

	if (hr != S_OK)
	{
		// close socket
		closesocket(m_hSocket);

		// shutdown
		WSACleanup();
	}
	
	return hr;
}

void CIPConfMSP::FinalRelease()
{
    CMSPAddress::FinalRelease();

    if (m_hSocket != INVALID_SOCKET)
    {
        // close socket
        closesocket(m_hSocket);
    }

    // shutdown
    WSACleanup();
}

DWORD CIPConfMSP::FindLocalInterface(DWORD dwIP)
{

    SOCKADDR_IN DestAddr;
    DestAddr.sin_family         = AF_INET;
    DestAddr.sin_port           = 0;
    DestAddr.sin_addr.s_addr    = htonl(dwIP);

    SOCKADDR_IN LocAddr;

    // query for default address based on destination

    DWORD dwStatus;
    DWORD dwLocAddrSize = sizeof(SOCKADDR_IN);
    DWORD dwNumBytesReturned = 0;

    if ((dwStatus = WSAIoctl(
		    m_hSocket, // SOCKET s
		    SIO_ROUTING_INTERFACE_QUERY, // DWORD dwIoControlCode
		    &DestAddr,           // LPVOID lpvInBuffer
		    sizeof(SOCKADDR_IN), // DWORD cbInBuffer
		    &LocAddr,            // LPVOID lpvOUTBuffer
		    dwLocAddrSize,       // DWORD cbOUTBuffer
		    &dwNumBytesReturned, // LPDWORD lpcbBytesReturned
		    NULL, // LPWSAOVERLAPPED lpOverlapped
		    NULL  // LPWSAOVERLAPPED_COMPLETION_ROUTINE lpComplROUTINE
	    )) == SOCKET_ERROR) 
    {

	    dwStatus = WSAGetLastError();

	    LOG((MSP_ERROR, "WSAIoctl failed: %d (0x%X)", dwStatus, dwStatus));

        return INADDR_NONE;
    } 

    DWORD dwAddr = ntohl(LocAddr.sin_addr.s_addr);

    if (dwAddr == 0x7f000001)
    {
        // it is loopback address, just return none.
        return INADDR_NONE;
    }

    return dwAddr;
}

STDMETHODIMP CIPConfMSP::CreateTerminal(
    IN      BSTR                pTerminalClass,
    IN      long                lMediaType,
    IN      TERMINAL_DIRECTION  Direction,
    OUT     ITTerminal **       ppTerminal
    )
/*++

Routine Description:

This method is called by TAPI3 to create a dynamic terminal. It asks the 
terminal manager to create a dynamic terminal. 

Arguments:

iidTerminalClass
    IID of the terminal class to be created.

dwMediaType
    TAPI media type of the terminal to be created.

Direction
    Terminal direction of the terminal to be created.

ppTerminal
    Returned created terminal object
    
Return Value:

S_OK

E_OUTOFMEMORY
TAPI_E_INVALIDMEDIATYPE
TAPI_E_INVALIDTERMINALDIRECTION
TAPI_E_INVALIDTERMINALCLASS

--*/
{
    LOG((MSP_TRACE,
        "CIPConfMSP::CreateTerminal - enter"));

    //
    // Check if initialized.
    //

    // lock the event related data
    m_EventDataLock.Lock();

    if ( m_htEvent == NULL )
    {
        // unlock the event related data
        m_EventDataLock.Unlock();

        LOG((MSP_ERROR,
            "CIPConfMSP::CreateTerminal - "
            "not initialized - returning E_UNEXPECTED"));

        return E_UNEXPECTED;
    }

    // unlock the event related data
    m_EventDataLock.Unlock();

    //
    // Get the IID from the BSTR representation.
    //

    HRESULT hr;
    IID     iidTerminalClass;

    hr = CLSIDFromString(pTerminalClass, &iidTerminalClass);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CIPConfMSP::CreateTerminal - "
            "bad CLSID string - returning E_INVALIDARG"));

        return E_INVALIDARG;
    }

    //
    // Make sure we support the requested media type.
    // The terminal manager checks the terminal class, terminal direction, 
    // and return pointer.
    //

    if ( ! IsValidSingleMediaType( (DWORD) lMediaType, GetCallMediaTypes() ) )
    {
        LOG((MSP_ERROR, "CIPConfMSP::CreateTerminal - "
            "non-audio terminal requested - returning E_INVALIDARG"));

        return E_INVALIDARG;
    }

    //
    // Use the terminal manager to create the dynamic terminal.
    //

    _ASSERTE( m_pITTerminalManager != NULL );

    hr = m_pITTerminalManager->CreateDynamicTerminal(NULL,
                                                     iidTerminalClass,
                                                     (DWORD) lMediaType,
                                                     Direction,
                                                     (MSP_HANDLE) this,
                                                     ppTerminal);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CIPConfMSP::CreateTerminal - "
            "create dynamic terminal failed - returning 0x%08x", hr));

        return hr;
    }

    if ((iidTerminalClass == CLSID_MediaStreamTerminal)
        && (lMediaType == TAPIMEDIATYPE_AUDIO))
    {
        // Set the format of the audio to 8KHZ, 16Bit/Sample, MONO.
        hr = ::SetAudioFormat(
            *ppTerminal, 
            g_wAudioCaptureBitPerSample, 
            g_dwG711AudioSampleRate
            );

        if (FAILED(hr))
        {
            LOG((MSP_WARN, "can't set audio format, %x", hr));
        }
    }

    LOG((MSP_TRACE, "CIPConfMSP::CreateTerminal - exit S_OK"));

    return S_OK;
}

STDMETHODIMP CIPConfMSP::CreateMSPCall(
    IN      MSP_HANDLE          htCall,
    IN      DWORD               dwReserved,
    IN      DWORD               dwMediaType,
    IN      IUnknown *          pOuterUnknown,
    OUT     IUnknown **         ppMSPCall
    )
/*++

Routine Description:

This method is called by TAPI3 before a call is made or answered. It creates 
a aggregated MSPCall object and returns the IUnknown pointer. It calls the
helper template function defined in mspaddress.h to handle the real creation.

Arguments:

htCall
    TAPI 3.0's identifier for this call.  Returned in events passed back 
    to TAPI.

dwReserved
    Reserved parameter.  Not currently used.

dwMediaType
    Media type of the call being created.  These are TAPIMEDIATYPES and more 
    than one mediatype can be selected (bitwise).

pOuterUnknown
    pointer to the IUnknown interface of the containing object.

ppMSPCall
    Returned MSP call that the MSP fills on on success.
    
Return Value:

    S_OK
    E_OUTOFMEMORY
    E_POINTER
    TAPI_E_INVALIDMEDIATYPE


--*/
{
    LOG((MSP_TRACE, 
        "CreateMSPCall entered. htCall:%x, dwMediaType:%x, ppMSPCall:%x",
        htCall, dwMediaType, ppMSPCall
        ));

    CIPConfMSPCall * pMSPCall = NULL;

    HRESULT hr = ::CreateMSPCallHelper(
        this, 
        htCall, 
        dwReserved, 
        dwMediaType, 
        pOuterUnknown, 
        ppMSPCall,
        &pMSPCall
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CreateMSPCallHelper failed:%x", hr));
        return hr;
    }

    // this function doesn't return anything.
    pMSPCall->SetIPInterface(m_dwIPInterface);

    return hr;
}

STDMETHODIMP CIPConfMSP::ShutdownMSPCall(
    IN      IUnknown *   pUnknown
    )
/*++

Routine Description:

This method is called by TAPI3 to shutdown a MSPCall. It calls the helper
function defined in MSPAddress to to the real job.

Arguments:

pUnknown
    pointer to the IUnknown interface of the contained object. It is a
    CComAggObject that contains our call object.
    
Return Value:

    S_OK
    E_POINTER
    TAPI_E_INVALIDMEDIATYPE


--*/
{
    LOG((MSP_TRACE, "ShutDownMSPCall entered. pUnknown:%x", pUnknown));

    if (IsBadReadPtr(pUnknown, sizeof(VOID *) * 3))
    {
        LOG((MSP_ERROR, "ERROR:pUnknow is a bad pointer"));
        return E_POINTER;
    }

    
    CIPConfMSPCall * pMSPCall = NULL;
    HRESULT hr = ::ShutdownMSPCallHelper(pUnknown, &pMSPCall);
    
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "ShutDownMSPCallhelper failed:: %x", hr));
        return hr;
    }

    return hr;
}

DWORD CIPConfMSP::GetCallMediaTypes(void)
{
    return IPCONFCALLMEDIATYPES;
}

ULONG CIPConfMSP::MSPAddressAddRef(void)
{
    return MSPAddRefHelper(this);
}

ULONG CIPConfMSP::MSPAddressRelease(void)
{
    return MSPReleaseHelper(this);
}

#ifdef USEIPADDRTABLE
PMIB_IPADDRTABLE GetIPTable()
/*++

Routine Description:

This method is used to get the table of local IP interfaces.

Arguments:

Return Value:

    NULL - failed.
    Pointer - a memory buffer that contains the IP interface table.


--*/
{
    // dynamically load iphlpapi.dll
    HMODULE hIPHLPAPI = LoadLibraryW(IPHLPAPI_DLL);

    // validate handle
    if (hIPHLPAPI == NULL) 
    {
        LOG((MSP_ERROR, "could not load %s.\n", IPHLPAPI_DLL));
        // failure
        return NULL;
    }

    PFNGETIPADDRTABLE pfnGetIpAddrTable = NULL;

    // retrieve function pointer to retrieve addresses
    pfnGetIpAddrTable = (PFNGETIPADDRTABLE)GetProcAddress(
                                                hIPHLPAPI, 
                                                GETIPADDRTABLE
                                                );

    // validate function pointer
    if (pfnGetIpAddrTable == NULL) 
    {
        LOG((MSP_ERROR, "could not resolve GetIpAddrTable.\n"));
        // release
        FreeLibrary(hIPHLPAPI);
        // failure
        return NULL;
    }

    PMIB_IPADDRTABLE pIPAddrTable = NULL;
    DWORD dwBytesRequired = 0;
    DWORD dwStatus;

    // determine amount of memory needed for table
    dwStatus = (*pfnGetIpAddrTable)(pIPAddrTable, &dwBytesRequired, FALSE);

    // validate status is what we expect
    if (dwStatus != ERROR_INSUFFICIENT_BUFFER) 
    {
        LOG((MSP_ERROR, "error 0x%08lx calling GetIpAddrTable.\n", dwStatus));
        // release
        FreeLibrary(hIPHLPAPI);
        // failure, but we need to return true to load.
        return NULL;
    }
        
    // attempt to allocate memory for table
    pIPAddrTable = (PMIB_IPADDRTABLE)malloc(dwBytesRequired);

    // validate pointer
    if (pIPAddrTable == NULL) 
    {
        LOG((MSP_ERROR, "could not allocate address table.\n"));
        // release
        FreeLibrary(hIPHLPAPI);
        // failure, but we need to return true to load.
        return NULL;
    }

    // retrieve ip address table from tcp/ip stack via utitity library
    dwStatus = (*pfnGetIpAddrTable)(pIPAddrTable, &dwBytesRequired, FALSE);    

    // validate status
    if (dwStatus != NOERROR) 
    {
        LOG((MSP_ERROR, "error 0x%08lx calling GetIpAddrTable.\n", dwStatus));
        // release table
        free(pIPAddrTable);
        // release
        FreeLibrary(hIPHLPAPI);
        // failure, but we need to return true to load. 
        return NULL;
    }
        
    // release library
    FreeLibrary(hIPHLPAPI);

    return pIPAddrTable;
}

BSTR IPToBstr(
    DWORD dwIP
    )
{
    struct in_addr Addr;
    Addr.s_addr = dwIP;
    
    // convert the interface to a string.
    CHAR *pChar = inet_ntoa(Addr);
    if (pChar == NULL)
    {
        LOG((MSP_ERROR, "bad IP address:%x", dwIP));
        return NULL;
    }

    // convert the ascii string to WCHAR.
    WCHAR szAddressName[MAXIPADDRLEN + 1];
    wsprintfW(szAddressName, L"%hs", pChar);

    // create a BSTR.
    BSTR bAddress = SysAllocString(szAddressName);
    if (bAddress == NULL)
    {
        LOG((MSP_ERROR, "out of mem in allocation address name"));
        return NULL;
    }

    return bAddress;
}

STDMETHODIMP CIPConfMSP::get_DefaultIPInterface(
    OUT     BSTR *         ppIPAddress
    )
{
    LOG((MSP_TRACE, "get_DefaultIPInterface, ppIPAddress:%p", ppIPAddress));

    if (IsBadWritePtr(ppIPAddress, sizeof(BSTR)))
    {
        LOG((MSP_ERROR, 
            "get_DefaultIPInterface, ppIPAddress is bad:%p", ppIPAddress));
        return E_POINTER;
    }

    // get the current local interface.
    m_Lock.Lock();
    DWORD dwIP= m_dwIPInterface;
    m_Lock.Unlock();

    BSTR bAddress = IPToBstr(dwIP);

    if (bAddress == NULL)
    {
        return E_OUTOFMEMORY;
    }

    *ppIPAddress = bAddress;

    LOG((MSP_TRACE, "get_DefaultIPInterface, returning %ws", bAddress));

    return S_OK;
}

STDMETHODIMP CIPConfMSP::put_DefaultIPInterface(
    IN      BSTR            pIPAddress
    )
{
    LOG((MSP_TRACE, "put_DefaultIPInterface, pIPAddress:%p", pIPAddress));

    if (IsBadStringPtrW(pIPAddress, MAXIPADDRLEN))
    {
        LOG((MSP_ERROR, 
            "put_DefaultIPInterface, invalid pointer:%p", pIPAddress));
        return E_POINTER;
    }

    char buffer[MAXIPADDRLEN + 1];

    if (WideCharToMultiByte(
        GetACP(),
        0,
        pIPAddress,
        -1,
        buffer,
        MAXIPADDRLEN,
        NULL,
        NULL
        ) == 0)
    {
        LOG((MSP_ERROR, "put_DefaultIPInterface, can't covert:%ws", pIPAddress));
        return E_INVALIDARG;
    }

    DWORD dwAddr;
    if ((dwAddr = inet_addr(buffer)) == INADDR_NONE)
    {
        LOG((MSP_ERROR, "put_DefaultIPInterface, bad address:%s", buffer));
        return E_INVALIDARG;
    }

    // set the current local interface.
    m_Lock.Lock();
    m_dwIPInterface = dwAddr;
    m_Lock.Unlock();


    LOG((MSP_TRACE, "put_DefaultIPInterface, set to %s", buffer));

    return S_OK;
}

HRESULT CreateBstrCollection(
    IN  BSTR  *     pBstr,
    IN  DWORD       dwCount,
    OUT VARIANT *   pVariant
    )
{
    //
    // create the collection object - see mspcoll.h
    //

    CComObject<CTapiBstrCollection> * pCollection;
    HRESULT hr = CComObject<CTapiBstrCollection>::CreateInstance( &pCollection );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "get_IPInterfaces - "
            "can't create collection - exit 0x%08x", hr));

        return hr;
    }

    //
    // get the Collection's IDispatch interface
    //

    IDispatch * pDispatch;

    hr = pCollection->_InternalQueryInterface(IID_IDispatch,
                                              (void **) &pDispatch );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "get_IPInterfaces - "
            "QI for IDispatch on collection failed - exit 0x%08x", hr));

        delete pCollection;

        return hr;
    }

    //
    // Init the collection using an iterator -- pointers to the beginning and
    // the ending element plus one.
    //

    hr = pCollection->Initialize( dwCount,
                                  pBstr,
                                  pBstr + dwCount);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "get_IPInterfaces - "
            "Initialize on collection failed - exit 0x%08x", hr));
        
        pDispatch->Release();

        return hr;
    }

    //
    // put the IDispatch interface pointer into the variant
    //

    LOG((MSP_ERROR, "get_IPInterfaces - "
        "placing IDispatch value %08x in variant", pDispatch));

    VariantInit(pVariant);
    pVariant->vt = VT_DISPATCH;
    pVariant->pdispVal = pDispatch;

    LOG((MSP_TRACE, "get_IPInterfaces - exit S_OK"));
 
    return S_OK;
}


STDMETHODIMP CIPConfMSP::get_IPInterfaces(
    OUT     VARIANT *       pVariant
    )
{
    PMIB_IPADDRTABLE pIPAddrTable = GetIPTable();

    if (pIPAddrTable == NULL)
    {
        return E_FAIL;
    }

    BSTR *Addresses = 
        (BSTR *)malloc(sizeof(BSTR *) * pIPAddrTable->dwNumEntries);
    
    if (Addresses == NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = S_OK;
    DWORD dwCount = 0;

    // loop through the interfaces and find the valid ones.
    for (DWORD i = 0; i < pIPAddrTable->dwNumEntries; i++) 
    {
        if (IsValidInterface(pIPAddrTable->table[i].dwAddr))
        {
            DWORD dwIPAddr   = ntohl(pIPAddrTable->table[i].dwAddr);
            Addresses[i] = IPToBstr(dwIPAddr);
            if (Addresses[i] == NULL)
            {
                hr = E_OUTOFMEMORY;
                break;
            }
        }
    }

    // release table memory 
    free(pIPAddrTable);

    if (FAILED(hr))
    {
        // release all the BSTRs and the array.
        for (i = 0; i < dwCount; i ++)
        {
            SysFreeString(Addresses[i]);
        }
        free(Addresses);
        return hr;
    }

    hr = CreateBstrCollection(Addresses, dwCount, pVariant);

    // if the collection is not created, release all the BSTRs.
    if (FAILED(hr))
    {
        for (i = 0; i < dwCount; i ++)
        {
            SysFreeString(Addresses[i]);
        }
    }

    // delete the pointer array.
    free(Addresses);

    return hr;
}

HRESULT CreateBstrEnumerator(
    IN  BSTR *                  begin,
    IN  BSTR *                  end,
    OUT IEnumBstr **           ppIEnum
    )
{
typedef CSafeComEnum<IEnumBstr, &IID_IEnumBstr, BSTR, _CopyBSTR>> CEnumerator;

    HRESULT hr;

    CComObject<CEnumerator> *pEnum = NULL;

    hr = CComObject<CEnumerator>::CreateInstance(&pEnum);
    if (pEnum == NULL)
    {
        LOG((MSP_ERROR, "Could not create enumerator object, %x", hr));
        return hr;
    }

    IEnumBstr * pIEnum;

    // query for the IID_IEnumDirectory i/f
    hr = pEnum->_InternalQueryInterface(
        IID_IEnumBstr,
        (void**)&pIEnum
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "query enum interface failed, %x", hr));
        delete pEnum;
        return hr;
    }

    hr = pEnum->Init(begin, end, NULL, AtlFlagTakeOwnership);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "init enumerator object failed, %x", hr));
        pIEnum->Release();
        return hr;
    }

    *ppIEnum = pIEnum;

    return hr;
}

STDMETHODIMP CIPConfMSP::EnumerateIPInterfaces(
    OUT     IEnumBstr **   ppIEnumBstr
    )
{
    PMIB_IPADDRTABLE pIPAddrTable = GetIPTable();

    if (pIPAddrTable == NULL)
    {
        return E_FAIL;
    }

    BSTR *Addresses = 
        (BSTR *)malloc(sizeof(BSTR *) * pIPAddrTable->dwNumEntries);
    
    if (Addresses == NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = S_OK;
    DWORD dwCount = 0;

    // loop through the interfaces and find the valid ones.
    for (DWORD i = 0; i < pIPAddrTable->dwNumEntries; i++) 
    {
        if (IsValidInterface(pIPAddrTable->table[i].dwAddr))
        {
            DWORD dwIPAddr   = ntohl(pIPAddrTable->table[i].dwAddr);
            Addresses[i] = IPToBstr(dwIPAddr);
            if (Addresses[i] == NULL)
            {
                hr = E_OUTOFMEMORY;
                break;
            }
        }
    }

    // release table memory 
    free(pIPAddrTable);

    if (FAILED(hr))
    {
        // release all the BSTRs and the array.
        for (i = 0; i < dwCount; i ++)
        {
            SysFreeString(Addresses[i]);
        }
        free(Addresses);
        return hr;
    }

    hr = CreateBstrEnumerator(Addresses, Addresses + dwCount, ppIEnumBstr);

    // if the collection is not created, release all the BSTRs.
    if (FAILED(hr))
    {
        for (i = 0; i < dwCount; i ++)
        {
            SysFreeString(Addresses[i]);
        }
        free(Addresses);
        return hr;
    }

    // the enumerator will destroy the bstr array eventually,
    // so no need to free anything here. Even if we tell it to hand
    // out zero objects, it will delete the array on destruction.

    return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\confmsp\confmsp.cpp ===
// ipconf.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//        To build a separate proxy/stub DLL, 
//        run nmake -f ipconfps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "confmsp.h"
#include "confaddr.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

#include "confmsp_i.c"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_IPConfMSP, CIPConfMSP)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        MSPLogRegister(_T("confmsp"));
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    { 
        _Module.Term();
        MSPLogDeRegister();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\confmsp\confcall.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    confcall.cpp 

Abstract:

    This module contains implementation of CIPConfMSPCall.

Author:
    
    Mu Han (muhan)   5-September-1998

--*/
#include "stdafx.h"
#include "common.h"
#include <confpdu.h>

CIPConfMSPCall::CIPConfMSPCall()
    : m_fLocalInfoRetrieved(FALSE)
{
    ZeroMemory(m_InfoItems, sizeof(m_InfoItems));
}

STDMETHODIMP CIPConfMSPCall::CreateStream(
    IN      long                lMediaType,
    IN      TERMINAL_DIRECTION  Direction,
    IN OUT  ITStream **         ppStream
    )
{
    // This MSP doesn't support creating new streams on the fly.
    return TAPI_E_NOTSUPPORTED;
}

STDMETHODIMP CIPConfMSPCall::RemoveStream(
    IN      ITStream *          pStream
    )
{
    // This MSP doesn't support removing streams either.
    return TAPI_E_NOTSUPPORTED;
}

HRESULT CIPConfMSPCall::InitializeLocalParticipant()
/*++

Routine Description:

    This function uses the RTP filter to find out the local information that
    will be used in the call. The infomation is stored in a local participant 
    object.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    m_fLocalInfoRetrieved = TRUE;

    // Create the RTP fitler.
    IRTCPStream *pIRTCPStream;

    HRESULT hr = CoCreateInstance(
            CLSID_RTPSourceFilter,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IRTCPStream,
            (void **) &pIRTCPStream
            );
    
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't create RTP filter for local info. %x", hr));
        return hr;
    }

    // Get the available local SDES info from the filter.
    char Buffer[MAX_PARTICIPANT_TYPED_INFO_LENGTH];
    DWORD dwLen = MAX_PARTICIPANT_TYPED_INFO_LENGTH;

    for (int i = 0; i < RTCP_SDES_LAST - 1; i ++)
    {
        if (Buffer == NULL)
        {
            pIRTCPStream->Release();
            return E_OUTOFMEMORY;
        }

        hr = pIRTCPStream->GetLocalSDESItem(
            RTCP_SDES_CNAME + i,
            (BYTE*)Buffer,
            &dwLen
            );
        
        if (SUCCEEDED(hr) && dwLen > 0)
        {
            if (dwLen > MAX_PARTICIPANT_TYPED_INFO_LENGTH)
            {
                dwLen = MAX_PARTICIPANT_TYPED_INFO_LENGTH;
            }

            // allocate memory to store the string.
            m_InfoItems[i] = (WCHAR *)malloc(dwLen * sizeof(WCHAR));
            if (m_InfoItems[i] == NULL)
            {
                LOG((MSP_ERROR, "out of mem for local info"));

                pIRTCPStream->Release();
                return E_OUTOFMEMORY;
            }
    
            // conver the char string to WCHAR string.
            if (!MultiByteToWideChar(
                GetACP(),
                0,
                Buffer,
                dwLen,
                m_InfoItems[i],
                dwLen
                ))
            {
                LOG((MSP_ERROR, "coverting failed, error:%x", GetLastError()));
                
                free(m_InfoItems[i]);
                m_InfoItems[i] = NULL;

                pIRTCPStream->Release();
                return E_FAIL;
            }
        }
    }

    pIRTCPStream->Release();
    
    return S_OK;
}


HRESULT CIPConfMSPCall::Init(
    IN      CMSPAddress *       pMSPAddress,
    IN      MSP_HANDLE          htCall,
    IN      DWORD               dwReserved,
    IN      DWORD               dwMediaType
    )
/*++

Routine Description:

    This method is called when the call is first created. It sets
    up the streams based on the mediatype specified.

Arguments:
    
    pMSPAddress - The pointer to the address object.

    htCall      - The handle to the Call in TAPI's space. 
                    Used in sending events.

    dwReserved  - Reserved.

    dwMediaType - The media type of this call.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, 
        "IPConfMSP call %x initialize entered,"
        " pMSPAddress:%x, htCall %x, dwMediaType %x",
        this, pMSPAddress, htCall, dwMediaType
        ));

#ifdef DEBUG_REFCOUNT
    if (g_lStreamObjects != 0)
    {
        LOG((MSP_ERROR, "Number of Streams alive: %d", g_lStreamObjects));
        DebugBreak();
    }
#endif

    // initialize the participant array so that the array is not NULL.
    if (!m_Participants.Grow())
    {
        LOG((MSP_ERROR, "out of mem for participant list"));
        return E_OUTOFMEMORY;
    }

    // Call the base class's init.
    HRESULT hr= CMSPCallMultiGraph::Init(
        pMSPAddress, 
        htCall, 
        dwReserved, 
        dwMediaType
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "MSPCallMultiGraph init failed:%x", hr));
        return hr;
    }

    // create streams based on the media types.
    if (dwMediaType & TAPIMEDIATYPE_AUDIO)
    {
        ITStream * pStream;

        // create a stream object.
        hr = InternalCreateStream(TAPIMEDIATYPE_AUDIO, TD_RENDER, &pStream);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "create audio render stream failed:%x", hr));
            return hr;
        }

        // The stream is already in our array, we don't need this pointer.
        pStream->Release();

        // create a stream object.
        hr = InternalCreateStream(TAPIMEDIATYPE_AUDIO, TD_CAPTURE, &pStream);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "create audio capture stream failed:%x", hr));
            return hr;
        }

        // The stream is already in our array, we don't need this pointer.
        pStream->Release();
    }

    if (dwMediaType & TAPIMEDIATYPE_VIDEO)
    {
        ITStream * pStream;

        // create a stream object.
        hr = InternalCreateStream(TAPIMEDIATYPE_VIDEO, TD_RENDER, &pStream);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "create video render stream failed:%x", hr));
            return hr;
        }

        // The stream is already in our array, we don't need this pointer.
        pStream->Release();

        // create a stream object.
        hr = InternalCreateStream(TAPIMEDIATYPE_VIDEO, TD_CAPTURE, &pStream);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "create video capture stream failed:%x", hr));
            return hr;
        }

        // The stream is already in our array, we don't need this pointer.
        pStream->Release();
    }
    
    m_fShutDown = FALSE;
    
    return S_OK;
}

HRESULT CIPConfMSPCall::ShutDown()
/*++

Routine Description:

    Shutdown the call. 

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    InternalShutDown();

    // acquire the lock on call.
    m_lock.Lock();

    // release all the streams
    for (int i = m_Streams.GetSize() - 1; i >= 0; i --)
    {
        m_Streams[i]->Release();
    }
    m_Streams.RemoveAll();

    for (i = 0; i < RTCP_SDES_LAST - 1; i ++)
    {
        if (m_InfoItems[i])
        {
            free(m_InfoItems[i]);
            m_InfoItems[i] = NULL;
        }
    }

    m_lock.Unlock();

    return S_OK;
}

HRESULT CIPConfMSPCall::InternalShutDown()
/*++

Routine Description:

    First call the base class's shutdown and then release all the participant
    objects.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    if (InterlockedCompareExchange((long*)&m_fShutDown, TRUE, FALSE))
    {
        return S_OK;
    }

    LOG((MSP_TRACE, "ConfMSPCall.InternalShutdown, entered"));

    // acquire the lock on the call.
    m_lock.Lock();

    // Shutdown all the streams
    for (int i = m_Streams.GetSize() - 1; i >= 0; i --)
    {
        UnregisterWaitEvent(i);
        ((CMSPStream*)m_Streams[i])->ShutDown();
    }
    m_ThreadPoolWaitBlocks.RemoveAll();

    m_lock.Unlock();

    // release all the participants
    m_ParticipantLock.Lock();

    for (i = 0; i < m_Participants.GetSize(); i ++)
    {
        m_Participants[i]->Release();
    }
    m_Participants.RemoveAll();

    m_ParticipantLock.Unlock();

    return S_OK;
}

template <class T>
HRESULT CreateStreamHelper(
    IN      T *                     pT,
    IN      HANDLE                  hAddress,
    IN      CIPConfMSPCall*         pMSPCall,
    IN      IMediaEvent *           pGraph,
    IN      DWORD                   dwMediaType,
    IN      TERMINAL_DIRECTION      Direction,
    OUT     ITStream **             ppITStream
    )
/*++

Routine Description:

    Create a stream object and initialize it. This method is called internally
    to create a stream object of different class.

Arguments:
    
    hAddress    - the handle to the address object.

    pCall       - the call object.

    pGraph      - the filter graph for this stream.

    dwMediaType - the media type of the stream. 

    Direction   - the direction of the steam.
    
    ppITStream  - the interface on this stream object.

Return Value:

    HRESULT.

--*/
{
    CComObject<T> * pCOMMSPStream;

    HRESULT hr = CComObject<T>::CreateInstance(&pCOMMSPStream);

    if (NULL == pCOMMSPStream)
    {
        LOG((MSP_ERROR, "CreateMSPStream:could not create stream:%x", hr));
        return hr;
    }

    // get the interface pointer.
    hr = pCOMMSPStream->_InternalQueryInterface(
        IID_ITStream, 
        (void **)ppITStream
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CreateMSPStream:QueryInterface failed: %x", hr));
        delete pCOMMSPStream;
        return hr;
    }

    // Initialize the object.
    hr = pCOMMSPStream->Init(
        hAddress,
        pMSPCall, 
        pGraph,
        dwMediaType,
        Direction
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CreateMSPStream:call init failed: %x", hr));
        (*ppITStream)->Release();
        return hr;
    }

    return S_OK;
}


HRESULT CIPConfMSPCall::CreateStreamObject(
    IN      DWORD               dwMediaType,
    IN      TERMINAL_DIRECTION  Direction,
    IN      IMediaEvent *       pGraph,
    IN      ITStream **         ppStream
    )
/*++

Routine Description:

    Create a media stream object based on the mediatype and direction.

Arguments:
    
    pMediaType  - TAPI3 media type.

    Direction   - direction of this stream.

    IMediaEvent - The filter graph used in this stream.

    ppStream    - the return pointer of the stream interface

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "CreateStreamObject, entered"));

    HRESULT         hr = S_OK;
    ITStream   * pIMSPStream = NULL;

    // Create a stream object based on the media type.
    if (dwMediaType == TAPIMEDIATYPE_AUDIO)
    {
        if (Direction == TD_RENDER)
        {
            CStreamAudioRecv *pAudioRecv = NULL;
            hr = ::CreateStreamHelper(
                pAudioRecv,
                m_pMSPAddress,
                this, 
                pGraph,
                TAPIMEDIATYPE_AUDIO,
                TD_RENDER,
                &pIMSPStream
                );
            LOG((MSP_TRACE, "create audio receive:%x, hr:%x", pIMSPStream,hr));
        }
        else if (Direction == TD_CAPTURE)
        {
            CStreamAudioSend *pAudioSend = NULL;
            hr = ::CreateStreamHelper(
                pAudioSend,
                m_pMSPAddress,
                this, 
                pGraph,
                TAPIMEDIATYPE_AUDIO,
                TD_CAPTURE,
                &pIMSPStream
                );
            LOG((MSP_TRACE, "create audio send:%x, hr:%x", pIMSPStream,hr));
        }
    }
    else if (dwMediaType == TAPIMEDIATYPE_VIDEO)
    {
        if (Direction == TD_RENDER)
        {
            CStreamVideoRecv *pVideoRecv = NULL;
            hr = ::CreateStreamHelper(
                pVideoRecv,
                m_pMSPAddress,
                this, 
                pGraph,
                TAPIMEDIATYPE_VIDEO,
                TD_RENDER,
                &pIMSPStream
                );
            LOG((MSP_TRACE, "create video Recv:%x, hr:%x", pIMSPStream,hr));
        }
        else if (Direction == TD_CAPTURE)
        {
            CStreamVideoSend *pVideoSend = NULL;
            hr = ::CreateStreamHelper(
                pVideoSend,
                m_pMSPAddress,
                this, 
                pGraph,
                TAPIMEDIATYPE_VIDEO,
                TD_CAPTURE,
                &pIMSPStream
                );
            LOG((MSP_TRACE, "create video send:%x, hr:%x", pIMSPStream,hr));
        }
    }
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "create stream failed. %x", hr));
        return hr;
    }

    *ppStream = pIMSPStream;

    return S_OK;
}

DWORD CIPConfMSPCall::FindInterfaceByName(IN WCHAR *pMachineName)
/*++

Routine Description:

    Given the machine name of the originator, find out which local interface
    can be used to reach that machine.

Arguments:
    
    pMachineName - The machine name of the originator.
    
Return Value:

    INADDR_NONE - nothing can be found.
    valid IP - succeeded.

--*/
{
    char buffer[MAXIPADDRLEN + 1];

    if (WideCharToMultiByte(
        GetACP(),
        0,
        pMachineName,
        -1,
        buffer,
        MAXIPADDRLEN,
        NULL,
        NULL
        ) == 0)
    {
        LOG((MSP_ERROR, "can't convert originator's address:%ws", pMachineName));

        return INADDR_NONE;
    }

    DWORD dwAddr;
    if ((dwAddr = inet_addr(buffer)) != INADDR_NONE)
    {
        dwAddr = ntohl(dwAddr);

        LOG((MSP_INFO, "originator's IP:%x", dwAddr));
        
        return ((CIPConfMSP *)m_pMSPAddress)->FindLocalInterface(dwAddr);
    }

    struct hostent * pHost;

    // attempt to lookup hostname
    pHost = gethostbyname(buffer);

    // validate pointer
    if (pHost == NULL) 
    {
        LOG((MSP_ERROR, "can't resolve address:%s", buffer));
        return INADDR_NONE;

    }

    // for each of the addresses returned, find the local interface.
    for (DWORD i = 0; TRUE; i ++)
    {
        if (pHost->h_addr_list[i] == NULL)
        {
            break;
        }

        // retrieve host address from structure
        dwAddr = ntohl(*(unsigned long *)pHost->h_addr_list[i]);

        LOG((MSP_INFO, "originator's IP:%x", dwAddr));
        
        DWORD dwInterface = 
            ((CIPConfMSP *)m_pMSPAddress)->FindLocalInterface(dwAddr);

        if (dwInterface != INADDR_NONE)
        {
            return dwInterface;
        }
    }

    return INADDR_NONE;
}

HRESULT CIPConfMSPCall::CheckOrigin(
    IN      ITSdp *     pITSdp, 
    OUT     BOOL *      pFlag,
    OUT     DWORD *     pdwIP
    )
/*++

Routine Description:

    Check to see if the current user is the originator of the conference.
    If he is, he can send to a receive only conference.

Arguments:
    
    pITSdp  - a pointer to the ITSdp interface.

    pFlag   - The result.

    pdwIP   - The local IP interface that should be used to reach the originator.
    
Return Value:

    HRESULT.

--*/
{
    const DWORD MAXUSERNAMELEN = 127;
    DWORD dwUserNameLen = MAXUSERNAMELEN;
    WCHAR szUserName[MAXUSERNAMELEN+1];

    // determine the name of the current user
    if (!GetUserNameW(szUserName, &dwUserNameLen))
    {
        LOG((MSP_ERROR, "cant' get user name. %x", GetLastError()));
        return E_UNEXPECTED;
    }

    LOG((MSP_INFO, "current user: %ws", szUserName));

    // find out if the current user is the originator of the conference.
    BSTR Originator = NULL;
    HRESULT hr = pITSdp->get_Originator(&Originator);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "cant' get originator. %x", hr));
        return hr;
    }

    LOG((MSP_INFO, "originator: %ws", Originator));

    *pFlag = (_wcsnicmp(szUserName, Originator, lstrlenW(szUserName)) == 0);
    
    SysFreeString(Originator);
    
    // Get the machine IP address of the originator.
    BSTR MachineAddress = NULL;
    hr = pITSdp->get_MachineAddress(&MachineAddress);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "cant' get MachineAddress. %x", hr));
        return hr;
    }

    LOG((MSP_INFO, "MachineAddress: %ws", MachineAddress));

    DWORD dwIP = FindInterfaceByName(MachineAddress);

    SysFreeString(MachineAddress);

    *pdwIP = dwIP;

    LOG((MSP_INFO, "Interface to use:%x", *pdwIP));
    
    return S_OK;
}


HRESULT GetAddress(
    IN      IUnknown *          pIUnknown, 
    OUT     DWORD *             pdwAddress, 
    OUT     DWORD *             pdwTTL
    )
/*++

Routine Description:

    Get the IP address and TTL value from a connection. It is a "c=" line
    in the SDP blob.

Arguments:
    
    pIUnknow    - an object that might contain connection information.

    pdwAddress  - the mem address to store the IP address.

    pdwTTL      - the mem address to store the TTL value.
    
Return Value:

    HRESULT.

--*/
{
    // query for the ITConnection i/f
    CComPtr<ITConnection> pITConnection;
    HRESULT hr = pIUnknown->QueryInterface(IID_ITConnection, (void **)&pITConnection);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get connection interface. %x", hr));
        return hr;
    }

    // get the start address,
    BSTR StartAddress = NULL;
    hr = pITConnection->get_StartAddress(&StartAddress);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get start address. %x", hr));
        return hr;
    }
    
    // Get the IP address from the string.
    const DWORD MAXIPADDRLEN = 20;
    char Buffer[MAXIPADDRLEN+1];

    // first convert the string to ascii.
    Buffer[0] = '\0';
    if (!WideCharToMultiByte(
        CP_ACP, 
        0, 
        StartAddress, 
        -1, 
        Buffer, 
        MAXIPADDRLEN, 
        NULL, 
        NULL
        ))
    {
        LOG((MSP_ERROR, "converting address. %ws", StartAddress));
        SysFreeString(StartAddress);
        return E_UNEXPECTED;
    }

    SysFreeString(StartAddress);

    // convert the string to DWORD IP address.
    DWORD dwIP = ntohl(inet_addr(Buffer));
    if (dwIP == INADDR_NONE)
    {
        LOG((MSP_ERROR, "invalid IP address. %s", Buffer));
        return E_UNEXPECTED;
    }

    // get the TTL value.
    BYTE Ttl;
    hr = pITConnection->get_Ttl(&Ttl);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get TTL."));
        return hr;
    }

    *pdwAddress = dwIP;
    *pdwTTL     = Ttl;

    return S_OK;
}

HRESULT CheckAttributes(
    IN      IUnknown *  pIUnknown,
    OUT     BOOL *      pbSendOnly,
    OUT     BOOL *      pbRecvOnly,
    OUT     DWORD *     pdwMSPerPacket,
    OUT     BOOL *      pbCIF
    )
/*++

Routine Description:

    Check the direction of the media, find out if it is send only or 
    receive only.

Arguments:
    
    pIUnknow    - an object that might have a attribute list.

    pbSendOnly   - the mem address to store the returned BOOL.

    pbRecvOnly   - the mem address to store the returned BOOL.

    pbCIF        - if CIF is used for video. 
    
Return Value:

    HRESULT.

--*/
{
    // query for the ITAttributeList i/f
    CComPtr<ITAttributeList> pIAttList;
    HRESULT hr = pIUnknown->QueryInterface(IID_ITAttributeList, (void **)&pIAttList);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get attribute interface. %x", hr));
        return hr;
    }

    // get the number of attributes
    long lCount;
    hr = pIAttList->get_Count(&lCount);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get attribute count. %x", hr));
        return hr;
    }

    *pbRecvOnly = FALSE;
    *pbSendOnly = FALSE;
    *pdwMSPerPacket = 0;
    *pbCIF      = FALSE;

    const WCHAR * const SENDONLY = L"sendonly";
    const WCHAR * const RECVONLY = L"recvonly";
    const WCHAR * const FORMAT  = L"fmtp";
    const WCHAR * const PTIME  = L"ptime:";
    const WCHAR * const CIF  = L" CIF=";

    for (long i = 1; i <= lCount; i ++)
    {

        // get the attributes and check if sendonly of recvonly is specified.
        BSTR Attribute = NULL;
        hr = pIAttList->get_Item(i, &Attribute);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "get attribute item. %x", hr));
            return hr;
        }
        
        if (_wcsnicmp(SENDONLY, Attribute, lstrlen(SENDONLY)) == 0)
        {
            *pbSendOnly = TRUE;
        }
        else if (_wcsnicmp(RECVONLY, Attribute, lstrlen(RECVONLY)) == 0)
        {
            *pbRecvOnly = TRUE;
        }
        else if (_wcsnicmp(PTIME, Attribute, lstrlen(PTIME)) == 0)
        {
            // read the number of milliseconds per packet.
            *pdwMSPerPacket = (DWORD)_wtol(Attribute + lstrlen(PTIME));

            // RFC 1890 only requires an app to support 200ms packets.
            if (*pdwMSPerPacket > 200)
            {
                // invalid tag, we just use our default.
                *pdwMSPerPacket = 0;
            }

        }
        else if (_wcsnicmp(FORMAT, Attribute, lstrlen(FORMAT)) == 0)
        {
            if (wcsstr(Attribute, CIF))
            {
                *pbCIF = TRUE;
            }
        }

        SysFreeString(Attribute);
    }
    
    return S_OK;
}

HRESULT CIPConfMSPCall::ProcessMediaItem(
    IN      ITMedia *           pITMedia,
    IN      DWORD               dwMediaTypeMask,
    OUT     DWORD *             pdwMediaType,
    OUT     WORD *              pwPort,
    OUT     DWORD *             pdwPayloadType
    )
/*++

Routine Description:

    Process a "m=" line, find out the media type, port, and payload type.

Arguments:

    dwMediaTypeMask - the media type of this call.

    pdwMediaType    - return the media type of this media item.

    pwPort          - return the port number used for this media.

    pdwPayloadType  - the RTP payload type.

Return Value:

    HRESULT.

    S_FALSE - everything is all right but the media type is not needed.

--*/
{
    // get the name of the media.
    BSTR MediaName = NULL;
    HRESULT hr = pITMedia->get_MediaName(&MediaName);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get media name. %x", hr));
        return hr;
    }

    LOG((MSP_INFO, "media name: %ws", MediaName));

    // check if the media is audio or video.
    const WCHAR * const AUDIO = L"audio";
    const WCHAR * const VIDEO = L"video";
    const DWORD NAMELEN = 5;

    DWORD dwMediaType = 0;
    if (_wcsnicmp(AUDIO, MediaName, NAMELEN) == 0)
    {
        dwMediaType = TAPIMEDIATYPE_AUDIO;
    }
    else if (_wcsnicmp(VIDEO, MediaName, NAMELEN) == 0)
    {
        dwMediaType = TAPIMEDIATYPE_VIDEO;
    }

    SysFreeString(MediaName);

    // check if the call wants this media type.
    if ((dwMediaType & dwMediaTypeMask) == 0)
    {
        // We don't need this media type in this call.
        LOG((MSP_INFO, "media skipped."));
        return S_FALSE;
    }

    // get start port
    long  lStartPort;
    hr = pITMedia->get_StartPort(&lStartPort);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get start port. %x", hr));
        return hr;
    }

    // get the transport Protocol
    BSTR TransportProtocol = NULL;
    hr = pITMedia->get_TransportProtocol(&TransportProtocol);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get transport Protocol. %x", hr));
        return hr;
    }

    // varify that the protocol is RTP.
    const WCHAR * const RTP = L"RTP";
    const DWORD PROTOCOLLEN = 3;

    if (_wcsnicmp(RTP, TransportProtocol, PROTOCOLLEN) != 0)
    {
        LOG((MSP_ERROR, "wrong transport Protocol:%ws", TransportProtocol));
        SysFreeString(TransportProtocol);
        return S_FALSE;
    }

    SysFreeString(TransportProtocol);

    // get the format code list
    VARIANT Variant;
    VariantInit(&Variant);

    hr = pITMedia->get_FormatCodes(&Variant);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get format codes. %x", hr));
        return hr;
    }

    // Verify that the SafeArray is in proper shape.
    if(SafeArrayGetDim(V_ARRAY(&Variant)) != 1)
    {
        LOG((MSP_ERROR, "wrong dimension for the format code. %x", hr));
	    VariantClear(&Variant);
        return E_UNEXPECTED;
    }

    long index = 1;
    hr = SafeArrayGetLBound(V_ARRAY(&Variant), 1, &index);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Can't get the lower bound. %x", hr));
	    VariantClear(&Variant);
        return E_UNEXPECTED;
    }
    
    // Get the first format code because we only support one format.
    BSTR Format = NULL;
    hr = SafeArrayGetElement(V_ARRAY(&Variant), &index, &Format);

    // clear the variant because we don't need it any more
    VariantClear(&Variant);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get first format code. %x", hr));
        return hr;
    }

    LOG((MSP_INFO, "format code: %ws", Format));
        
    DWORD dwPayloadType = (DWORD)_wtoi(Format);

    SysFreeString(Format);

    *pdwMediaType   = dwMediaType;
    *pwPort         = (WORD)lStartPort;
    *pdwPayloadType = dwPayloadType;

    return S_OK;
}

HRESULT CIPConfMSPCall::ConfigStreamsBasedOnSDP(
    IN  ITSdp *     pITSdp,
    IN  DWORD       dwAudioQOSLevel,
    IN  DWORD       dwVideoQOSLevel
    )
/*++

Routine Description:

    Configure the streams based on the information in the SDP blob.

Arguments:

    pITSdp  - the SDP object. It contains parsed information.

Return Value:

    HRESULT.

--*/
{
    // find out if the current user is the originator of the conference.
    BOOL fIsOriginator;
    DWORD dwLocalInterface = INADDR_NONE;

    HRESULT hr = CheckOrigin(pITSdp, &fIsOriginator, &dwLocalInterface);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "check origin. %x", hr));
        return hr;
    }
    
    LOG((MSP_INFO, "Local interface: %x", dwLocalInterface));

    // get the start IP address and TTL value from the connection.
    DWORD dwIPGlobal, dwTTLGlobal;
    hr = GetAddress(pITSdp, &dwIPGlobal, &dwTTLGlobal);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get global address. %x", hr));
        return hr;
    }

    // find out if this conference is sendonly or recvonly.
    BOOL fSendOnlyGlobal = FALSE, fRecvOnlyGlobal = FALSE, fCIF = FALSE;
    DWORD dwMSPerPacket;
    hr = CheckAttributes(
        pITSdp, &fSendOnlyGlobal, &fRecvOnlyGlobal, &dwMSPerPacket, &fCIF);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "check global attributes. %x", hr));
        return hr;
    }

    // get the media information
    CComPtr<ITMediaCollection> pICollection;
    hr = pITSdp->get_MediaCollection(&pICollection);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get the media collection. %x", hr));
        return hr;
    }

    // find out how many media sessions are in the blobl.
    long lCount;
    hr = pICollection->get_Count(&lCount);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get number of media items. %x", hr));
        return hr;
    }

    if (lCount > 0)
    {
        // change the call into connected state since the SDP is OK.
        // We are going to set up each every streams next.
        SendTSPMessage(CALL_CONNECTED, 0);
    }

    DWORD dwNumSucceeded = 0;

    // for each media session, get info configure a stream.
    for(long i=1; i <= lCount; i++)
    {
        // get the media item first.
        ITMedia *pITMedia;
        hr = pICollection->get_Item(i, &pITMedia);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "get media item. %x", hr));
            continue;
        }

        DWORD dwMediaType;
        STREAMSETTINGS Setting;

        ZeroMemory(&Setting, sizeof(STREAMSETTINGS));

        // find out the information about the media. Here we pass in the media
        // type of call so that we won't wasting time reading the attributes
        // for a media type we don't need.
        hr = ProcessMediaItem(
            pITMedia,
            m_dwMediaType,
            &dwMediaType,
            &Setting.wRTPPortRemote,
            &Setting.dwPayloadType
            );

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "process media. %x", hr));
            continue;
        }

        // if the return value is S_FALSE from the previous call, this media
        // type is not needed for the call.
        if (hr != S_OK)
        {
            // the media is not needed.
            continue;
        }
        
        Setting.dwQOSLevel = (dwMediaType == TAPIMEDIATYPE_AUDIO)
            ? dwAudioQOSLevel : dwVideoQOSLevel;

        // Get the local connect information.
        DWORD dwIP, dwTTL;
        hr = GetAddress(pITMedia, &dwIP, &dwTTL);
        if (FAILED(hr))
        {
            LOG((MSP_WARN, "no local address, use global one", hr));
            Setting.dwIPRemote  = dwIPGlobal;
            Setting.dwTTL       = dwTTLGlobal;
        }
        else
        {
            Setting.dwIPRemote  = dwIP;
            Setting.dwTTL       = dwTTL;
        }

        // find out if this media is sendonly or recvonly.
        BOOL fSendOnly = FALSE, fRecvOnly = FALSE, fCIF = FALSE;
        hr = CheckAttributes(
            pITMedia, &fSendOnly, &fRecvOnly, &dwMSPerPacket, &fCIF);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "check local attributes. %x", hr));
        }
        
        fSendOnly = fSendOnly || fSendOnlyGlobal;
        fRecvOnly = (fRecvOnly || fRecvOnlyGlobal) && (!fIsOriginator);
        Setting.dwMSPerPacket = dwMSPerPacket;
        Setting.fCIF = fCIF;

        // The media item is not needed after this point.
        pITMedia->Release();

        // Go through the existing streams and find out if any stream
        // can be configured.

        // Note: we are not creating any new streams now. We might want to 
        // do it in the future if we want to support two sessions of the
        // same media type.

        CLock lock(m_lock);
        for (long j = 0; j < m_Streams.GetSize(); j ++)
        {
            CIPConfMSPStream* pStream = (CIPConfMSPStream*)m_Streams[j];
        
            if ((pStream->MediaType() != dwMediaType)
                || pStream->IsConfigured()
                || (fSendOnly && pStream->Direction() == TD_RENDER)
                || (fRecvOnly && pStream->Direction() == TD_CAPTURE)
                )
            {
                // this stream should not be configured.
                continue;
            }

            // set the local interface that the call should bind to.
            Setting.dwIPLocal = m_dwIPInterface;

            if ((m_dwIPInterface == INADDR_ANY)
                && (dwLocalInterface != INADDR_NONE))
            {
                Setting.dwIPLocal = dwLocalInterface;
            }

            // configure the stream, it will be started as well.
            hr = pStream->Configure(Setting);
            if (FAILED(hr))
            {
               LOG((MSP_ERROR, "configure stream failed. %x", hr));
            }
            else
            {
                dwNumSucceeded ++;
            }
        }
    }

    if (dwNumSucceeded == 0)
    {
        LOG((MSP_ERROR, "No media succeeded."));
        return E_FAIL;
    }

    return S_OK;        
}

HRESULT CIPConfMSPCall::ParseSDP(
    IN  WCHAR * pSDP,
    IN  DWORD dwAudioQOSLevel,
    IN  DWORD dwVideoQOSLevel
    )
/*++

Routine Description:

    Parse the SDP string. The function uses the SdpConferenceBlob object
    to parse the string.

Arguments:

    pSDP  - the SDP string.
    dwAudioQOSLevel - the QOS requirement for audio.
    dwVideoQOSLevel - the QOS requirement for video.

Return Value:

    HRESULT.

--*/
{
    // co-create an sdp conference blob component
    // query for the ITConferenceBlob interface
    CComPtr<ITConferenceBlob>   pIConfBlob;   

    HRESULT hr = ::CoCreateInstance(
        CLSID_SdpConferenceBlob,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_ITConferenceBlob,
        (void **)&pIConfBlob
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "creating a SDPBlob object. %x", hr));
        return hr;
    }
    
    // conver the sdp into a BSTR to use the interface.
    BSTR bstrSDP = SysAllocString(pSDP);
    if (bstrSDP == NULL)
    {
        LOG((MSP_ERROR, "out of mem converting SDP to a BSTR."));
        return E_OUTOFMEMORY;
    }

    // Parse the SDP string.
    hr = pIConfBlob->Init(NULL, BCS_ASCII, bstrSDP);
    
    // the string is not needed any more.
    SysFreeString(bstrSDP);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "parse the SDPBlob object. %x", hr));
        return hr;
    }
    
    // Get the ITSdp interface.
    CComPtr<ITSdp>  pITSdp;
    hr = pIConfBlob->QueryInterface(IID_ITSdp, (void **)&pITSdp);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get the ITSdp interface. %x", hr));
        return hr;
    }

    // check main sdp validity
    VARIANT_BOOL IsValid;
    hr = pITSdp->get_IsValid(&IsValid);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get the valid flag on the SDP %x", hr));
        return hr;
    }

    if (!IsValid)
    {
        LOG((MSP_ERROR, "the SDP is not valid %x", hr));
        return E_FAIL;
    }

    return ConfigStreamsBasedOnSDP(
        pITSdp,
        dwAudioQOSLevel,
        dwVideoQOSLevel
        );
}

HRESULT CIPConfMSPCall::SendTSPMessage(
    IN  TSP_MSP_COMMAND command,
    IN  DWORD           dwParam1,
    IN  DWORD           dwParam2
    ) const
/*++

Routine Description:

    Send the TSP a message from the MSP. 

Arguments:

    command     - the command to be sent.

    dwParam1    - the first DWORD used in the command.

    dwParam2    - the second DWORD used in the command.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "SendTSPMessage, command %d, dwParam1 %d, dwParam2", 
        command, dwParam1, dwParam2));

    if (InterlockedCompareExchange((long*)&m_fShutDown, TRUE, TRUE))
    {
        return E_UNEXPECTED;
    }

    // first allocate the memory.
    DWORD dwSize = sizeof(MSG_TSPMSPDATA);

    MSPEVENTITEM* pEventItem = AllocateEventItem(dwSize);

    if (pEventItem == NULL)
    {
        LOG((MSP_ERROR, "No memory for the TSPMSP data, size: %d", dwSize));
        return E_OUTOFMEMORY;
    }
    
    // Fill in the necessary fields for the event structure.
    pEventItem->MSPEventInfo.dwSize = 
        sizeof(MSP_EVENT_INFO) + sizeof(MSG_TSPMSPDATA);
    pEventItem->MSPEventInfo.Event  = ME_TSP_DATA;
    pEventItem->MSPEventInfo.hCall  = m_htCall;

    // Fill in the data for the TSP.
    pEventItem->MSPEventInfo.MSP_TSP_DATA.dwBufferSize = sizeof(MSG_TSPMSPDATA);

    MSG_TSPMSPDATA *pData = (MSG_TSPMSPDATA *)
        pEventItem->MSPEventInfo.MSP_TSP_DATA.pBuffer;

    pData->command = command;
    switch (command)
    {

    case CALL_DISCONNECTED:
        pData->CallDisconnected.dwReason = dwParam1;
        break;

    case CALL_QOS_EVENT:
        pData->QosEvent.dwEvent = dwParam1;
        pData->QosEvent.dwMediaMode = dwParam2;
        break;

    case CALL_CONNECTED:
        break;

	default:
		
		LOG((MSP_ERROR, "Wrong command type for TSP"));

        FreeEventItem(pEventItem);
		return E_UNEXPECTED;
    }

    HRESULT hr = m_pMSPAddress->PostEvent(pEventItem);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Post event failed %x", hr));

        FreeEventItem(pEventItem);

        return hr;
    }
    return S_OK;
}

HRESULT CIPConfMSPCall::CheckUnusedStreams()
/*++

Routine Description:

    Find out which streams are not used and send tapi events about them.

Arguments:

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "CheckUnusedStreams"));

    CLock lock(m_lock);
    for (long j = 0; j < m_Streams.GetSize(); j ++)
    {
        CIPConfMSPStream* pStream = (CIPConfMSPStream*)m_Streams[j];
    
        if (pStream->IsConfigured())
        {
            // find the next.
            continue;
        }
        
        MSPEVENTITEM* pEventItem = AllocateEventItem();

        if (pEventItem == NULL)
        {
            LOG((MSP_ERROR, "No memory for the TSPMSP data, size: %d", sizeof(MSPEVENTITEM)));

            return E_OUTOFMEMORY;
        }
    
        // Fill in the necessary fields for the event structure.
        pEventItem->MSPEventInfo.dwSize = sizeof(MSP_EVENT_INFO);;
        pEventItem->MSPEventInfo.Event  = ME_CALL_EVENT;
        pEventItem->MSPEventInfo.hCall  = m_htCall;
    
        pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.Type = CALL_STREAM_NOT_USED;
        pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.Cause = CALL_CAUSE_REMOTE_REQUEST;
        pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.pStream = m_Streams[j];
        
        // Addref to prevent it from going away.
        m_Streams[j]->AddRef();

        pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.pTerminal = NULL;
        pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.hrError= 0;

        // send the event to tapi.
        HRESULT hr = m_pMSPAddress->PostEvent(pEventItem);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "Post event failed %x", hr));
        
            FreeEventItem(pEventItem);
            return hr;
        }
    }
    return S_OK;
}

DWORD WINAPI CIPConfMSPCall::WorkerCallbackDispatcher(VOID *pContext)
/*++

Routine Description:

    Because Parsing the SDP and configure the streams uses a lot of COM
    stuff, we can't rely on the RPC thread the calls into the MSP to 
    receive the TSP data. So, we let our own working thread do the work.
    This method is the callback function for the queued work item. It 
    just gets the call object from the context structure and calls a method
    on the call object to handle the work item.

Arguments:

    pContext - A pointer to a CALLWORKITEM structure.

Return Value:

    HRESULT.

--*/
{
    _ASSERTE(!IsBadReadPtr(pContext, sizeof CALLWORKITEM));

    CALLWORKITEM *pItem = (CALLWORKITEM *)pContext;
    
    pItem->pCall->ProcessWorkerCallBack(pItem->Buffer, pItem->dwLen);
    pItem->pCall->MSPCallRelease();

    free(pItem);

    return NOERROR;
}

DWORD CIPConfMSPCall::ProcessWorkerCallBack(
    IN      PBYTE               pBuffer,
    IN      DWORD               dwSize
    )
/*++

Routine Description:

    This function handles the work item given by the TSP. 

Arguments:

    pBuffer - a buffer that contains a TSP_MSP command block.

    dwSize  - the size of the buffer.

Return Value:

    NOERROR.

--*/
{
    LOG((MSP_TRACE, "PreocessWorkerCallBAck"));

    _ASSERTE(!IsBadReadPtr(pBuffer, dwSize));

    MSG_TSPMSPDATA * pData = (MSG_TSPMSPDATA *)pBuffer;

    HRESULT hr;

    switch (pData->command)
    {
    case CALL_START:

        // Parse the SDP contained in the command block.
        hr = ParseSDP(pData->CallStart.szSDP, 
            pData->CallStart.dwAudioQOSLevel,
            pData->CallStart.dwVideoQOSLevel
            );

        if (FAILED(hr))
        {
            // disconnect the call if someting terrible happend.
            SendTSPMessage(CALL_DISCONNECTED, 0);

            LOG((MSP_ERROR, "parsing theSDPBlob object. %x", hr));
            return NOERROR;
        }

        // go through the streams and send events if they are not used.
        hr = CheckUnusedStreams();
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "start the streams failed. %x", hr));
        }
        break;

    case CALL_STOP:
        InternalShutDown();
        break;
    }

    return NOERROR;
}

HRESULT CIPConfMSPCall::ReceiveTSPCallData(
    IN      PBYTE               pBuffer,
    IN      DWORD               dwSize
    )
/*++

Routine Description:

    This function handles the work item given by the TSP. 

Arguments:

    pBuffer - a buffer that contains a TSP_MSP command block.

    dwSize  - the size of the buffer.

Return Value:

    NOERROR.

--*/
{
    LOG((MSP_TRACE, 
        "ReceiveTSPCallData, pBuffer %x, dwSize %d", pBuffer, dwSize));

    MSG_TSPMSPDATA * pData = (MSG_TSPMSPDATA *)pBuffer;
    switch (pData->command)
    {
    case CALL_START:

        // make sure the string is valid.
        if ((IsBadReadPtr(pData->CallStart.szSDP, 
            (pData->CallStart.dwSDPLen + 1) * sizeof (WCHAR)))
            || (pData->CallStart.szSDP[pData->CallStart.dwSDPLen] != 0))
        {
            LOG((MSP_ERROR, "the TSP data is invalid."));
            return E_UNEXPECTED;
        }

        LOG((MSP_INFO, "SDP string\n%ws", pData->CallStart.szSDP));

        break;

    case CALL_STOP:
        break;

    default:
        LOG((MSP_ERROR, 
            "wrong command received from the TSP:%x", pData->command));
        return E_UNEXPECTED; 
    }

    // allocate a work item structure for our worker thread.
    CALLWORKITEM *pItem = (CALLWORKITEM *)malloc(sizeof(CALLWORKITEM) + dwSize);

    if (pItem == NULL)
    {
        // Disconnect the call because of out of memory.
        SendTSPMessage(CALL_DISCONNECTED, 0);

        LOG((MSP_ERROR, "out of memory for work item."));
        return E_OUTOFMEMORY;
    }

    this->MSPCallAddRef();
    pItem->pCall = this;
    pItem->dwLen = dwSize;
    CopyMemory(pItem->Buffer, pBuffer, dwSize);
    
    // post a work item to our worker thread.
    HRESULT hr = g_Thread.QueueWorkItem(
        WorkerCallbackDispatcher,           // the callback
        pItem,                              // the context.
        FALSE                               // sync (FALSE means asyn)
        );

    if (FAILED(hr))
    {
        if (pData->command == CALL_START)
        {
            // Disconnect the call because we can't handle the work.
            SendTSPMessage(CALL_DISCONNECTED, 0);
        }

        this->MSPCallRelease();
        free(pItem);

        LOG((MSP_ERROR, "queue work item failed."));
    }

    return hr;
}


STDMETHODIMP CIPConfMSPCall::EnumerateParticipants(
    OUT     IEnumParticipant **      ppEnumParticipant
    )
/*++

Routine Description:

    This method returns an enumerator to the participants. 

Arguments:
    ppEnumParticipant - the memory location to store the returned pointer.
  
Return Value:

S_OK
E_POINTER
E_OUTOFMEMORY

--*/
{
    LOG((MSP_TRACE, 
        "EnumerateParticipants entered. ppEnumParticipant:%x", ppEnumParticipant));

    //
    // Check parameters.
    //

    if (IsBadWritePtr(ppEnumParticipant, sizeof(VOID *)))
    {
        LOG((MSP_ERROR, "CIPConfMSPCall::EnumerateParticipants - "
            "bad pointer argument - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // First see if this call has been shut down.
    // acquire the lock before accessing the Participant object list.
    //

    CLock lock(m_ParticipantLock);

    if (m_Participants.GetData() == NULL)
    {
        LOG((MSP_ERROR, "CIPConfMSPCall::EnumerateParticipants - "
            "call appears to have been shut down - exit E_UNEXPECTED"));

        // This call has been shut down.
        return E_UNEXPECTED;
    }

    //
    // Create an enumerator object.
    //
    HRESULT hr = CreateParticipantEnumerator(
        m_Participants.GetData(),                        // the begin itor
        m_Participants.GetData() + m_Participants.GetSize(),  // the end itor,
        ppEnumParticipant
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CIPConfMSPCall::EnumerateParticipants - "
            "create enumerator object failed, %x", hr));

        return hr;
    }

    LOG((MSP_TRACE, "CIPConfMSPCall::EnumerateParticipants - exit S_OK"));

    return hr;
}

STDMETHODIMP CIPConfMSPCall::get_Participants(
    OUT     VARIANT *              pVariant
    )
{
    LOG((MSP_TRACE, "CIPConfMSPCall::get_Participants - enter"));

    //
    // Check parameters.
    //

    if ( IsBadWritePtr(pVariant, sizeof(VARIANT) ) )
    {
        LOG((MSP_ERROR, "CIPConfMSPCall::get_Participants - "
            "bad pointer argument - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // See if this call has been shut down. Acquire the lock before accessing
    // the Participant object list.
    //

    CLock lock(m_ParticipantLock);

    if (m_Participants.GetData() == NULL)
    {
        LOG((MSP_ERROR, "CIPConfMSPCall::get_Participants - "
            "call appears to have been shut down - exit E_UNEXPECTED"));

        // This call has been shut down.
        return E_UNEXPECTED;
    }

    //
    // create the collection object - see mspcoll.h
    //
    HRESULT hr = CreateParticipantCollection(
        m_Participants.GetData(),                        // the begin itor
        m_Participants.GetData() + m_Participants.GetSize(),  // the end itor,
        m_Participants.GetSize(),                        // the size
        pVariant
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CIPConfMSPCall::get_Participants - "
            "create collection failed - exit 0x%08x", hr));
        
        return hr;
    }

    LOG((MSP_TRACE, "CIPConfMSPCall::get_Participants - exit S_OK"));
 
    return S_OK;
}

// ITLocalParticipant methods, called by the app.
STDMETHODIMP CIPConfMSPCall::get_LocalParticipantTypedInfo(
    IN  PARTICIPANT_TYPED_INFO  InfoType,
    OUT BSTR *                  ppInfo
    )
/*++

Routine Description:

    Get a information item for the local participant. This information is
    sent out to other participants in the conference.

Arguments:
    
    InfoType - The type of the information asked.

    ppInfo  - the mem address to store a BSTR.

Return Value:

    S_OK,
    E_INVALIDARG,
    E_POINTER,
    E_OUTOFMEMORY,
    TAPI_E_NOITEMS
*/
{
    LOG((MSP_TRACE, "CParticipant get info, type:%d", InfoType));
    
    if (InfoType > PTI_PRIVATE || InfoType < PTI_CANONICALNAME)
    {
        LOG((MSP_ERROR, "CParticipant get info - invalid type:%d", InfoType));
        return E_INVALIDARG;
    }

    if (IsBadWritePtr(ppInfo, sizeof(BSTR)))
    {
        LOG((MSP_ERROR, "CParticipant get info - exit E_POINTER"));
        return E_POINTER;
    }

    // check if we have that info.
    CLock lock(m_lock);
    
    if (!m_fLocalInfoRetrieved)
    {
        HRESULT hr = InitializeLocalParticipant();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    int index = (int)InfoType; 
    if (m_InfoItems[index] == NULL)
    {
        LOG((MSP_INFO, "no local participant info item for %d", InfoType));
        return TAPI_E_NOITEMS;
    }

    // make a BSTR out of it.
    BSTR pName = SysAllocString(m_InfoItems[index]);

    if (pName == NULL)
    {
        LOG((MSP_ERROR, "CParticipant get info - exit out of mem"));
        return E_POINTER;
    }

    // return the BSTR.
    *ppInfo = pName;

    return S_OK; 
}

// ITLocalParticipant methods, called by the app.
STDMETHODIMP CIPConfMSPCall::put_LocalParticipantTypedInfo(
    IN  PARTICIPANT_TYPED_INFO  InfoType,
    IN  BSTR                    pInfo
    )
/*++

Routine Description:

    Set a information item for the local participant. This information is
    sent out to other participants in the conference.

Arguments:
    
    InfoType - The type of the information item.

    pInfo  - the information item.

Return Value:

    S_OK,
    E_INVALIDARG,
    E_POINTER,
    E_OUTOFMEMORY,
    TAPI_E_NOITEMS
*/
{
    LOG((MSP_TRACE, "set local info, type:%d", InfoType));
    
    // We don't allow the app to change canonical name
    if (InfoType > PTI_PRIVATE || InfoType <= PTI_CANONICALNAME)
    {
        LOG((MSP_ERROR, "set local info - invalid type:%d", InfoType));
        return E_INVALIDARG;
    }

    if (IsBadStringPtr(pInfo, MAX_PARTICIPANT_TYPED_INFO_LENGTH))
    {
        LOG((MSP_ERROR, "set local info, bad ptr:%p", pInfo));
        return E_POINTER;
    }

    DWORD dwLen = lstrlenW(pInfo) + 1;
    if (dwLen > MAX_PARTICIPANT_TYPED_INFO_LENGTH)
    {
        LOG((MSP_ERROR, "local info too long"));
        return E_INVALIDARG;
    }

    // check if we have that info.
    CLock lock(m_lock);
    
    if (!m_fLocalInfoRetrieved)
    {
        HRESULT hr = InitializeLocalParticipant();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    int index = (int)InfoType; 
    if (m_InfoItems[index] != NULL)
    {
        if (lstrcmpW(m_InfoItems[index], pInfo) == 0)
        {
            // The info is the same as what we are using.
            return S_OK;
        }

		// the infomation is different, release the old info.
		free(m_InfoItems[index]);
		m_InfoItems[index] = NULL;
    }

	// save the info.
    m_InfoItems[index] = (WCHAR *)malloc(dwLen * sizeof(WCHAR));
    if (m_InfoItems[index] == NULL)
    {
        LOG((MSP_ERROR, "out of mem for local info"));

        return E_OUTOFMEMORY;
    }

    CopyMemory(m_InfoItems[index], pInfo, dwLen * sizeof(WCHAR));

    //
    // The info is new, we need to set it on the streams.
    //

    // conver the WCHAR string to multibytes.
    char Buffer[MAX_PARTICIPANT_TYPED_INFO_LENGTH];

    DWORD dwNumBytes = WideCharToMultiByte(
        GetACP(),
        0,
        pInfo,
        dwLen,
        Buffer,
        MAX_PARTICIPANT_TYPED_INFO_LENGTH,
        NULL,
        NULL
        );

    if (dwNumBytes == 0)
    {
        LOG((MSP_ERROR, "coverting failed, error:%x", GetLastError()));
        return E_FAIL;
    }

    for (int i = 0; i < m_Streams.GetSize(); i ++)
    {
        ((CIPConfMSPStream*)m_Streams[i])->SetLocalParticipantInfo(
            InfoType,
            Buffer,
            dwNumBytes
            );
    }

    return S_OK; 
}

HRESULT CIPConfMSPCall::NewParticipant(
    IN  ITStream *          pITStream,
    IN  DWORD               dwSSRC,
    IN  DWORD               dwSendRecv,
    IN  DWORD               dwMediaType,
    IN  char *              szCName,
    OUT ITParticipant **    ppITParticipant
    )
/*++

Routine Description:
    
    This method is called by a stream object when a new participant appears.
    It looks throught the call's participant list, if the partcipant is 
    already in the list, it returns the pointer to the object. If it is not
    found, a new object will be created and added into the list.

Arguments:

    pITStream - the stream object.

    dwSSRC - the SSRC of the participant in the stream.

    dwSendRecv - a sender or a receiver.
    
    dwMediaType - the media type of the stream.

    szCName - the canonical name of the participant.

    ppITParticipant - the address to store the returned pointer.

Return Value:

S_OK
E_OUTOFMEMORY

--*/
{
    CLock lock(m_ParticipantLock);

    HRESULT hr;

    // First check to see if the participant is in our list. If he is already
    // in the list, just return the object.
    int index;
    if (m_Participants.FindByCName(szCName, &index))
    {
        hr = ((CParticipant *)m_Participants[index])->
                AddStream(pITStream, dwSSRC, dwSendRecv, dwMediaType);

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "can not add a stream to a participant:%x", hr));
            return hr;
        }

        *ppITParticipant = m_Participants[index];
        (*ppITParticipant)->AddRef();

        return S_OK;
    }

    // create a new participant object.
    CComObject<CParticipant> * pCOMParticipant;

    hr = CComObject<CParticipant>::CreateInstance(&pCOMParticipant);

    if (NULL == pCOMParticipant)
    {
        LOG((MSP_ERROR, "can not create a new participant:%x", hr));
        return hr;
    }

    ITParticipant* pITParticipant;

    // get the interface pointer.
    hr = pCOMParticipant->_InternalQueryInterface(
        IID_ITParticipant, 
        (void **)&pITParticipant
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Participant QueryInterface failed: %x", hr));
        delete pCOMParticipant;
        return hr;
    }

    // Initialize the object.
    hr = pCOMParticipant->Init(
        szCName, pITStream, dwSSRC, dwSendRecv, dwMediaType
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Create participant:call init failed: %x", hr));
        pITParticipant->Release();

        return hr;
    }

    // Add the Participant into our list of Participants.
    if (!m_Participants.InsertAt(index, pITParticipant))
    {
        pITParticipant->Release();

        LOG((MSP_ERROR, "out of memory in adding a Participant."));
        return E_OUTOFMEMORY;
    }

    // AddRef the interface pointer and return it.
    pITParticipant->AddRef(); 
    *ppITParticipant = pITParticipant;

    SendParticipantEvent(PE_NEW_PARTICIPANT, pITParticipant);

    return S_OK;
}

HRESULT CIPConfMSPCall::ParticipantLeft(
    IN  ITParticipant *     pITParticipant
    )
/*++

Routine Description:
    
    This method is called by a stream object when a participant left the
    conference.

Arguments:

    pITParticipant - the participant that left.

Return Value:

S_OK

--*/
{
    m_ParticipantLock.Lock();

    BOOL fRemoved = m_Participants.Remove(pITParticipant);

    m_ParticipantLock.Unlock();
    
    if (fRemoved)
    {
        SendParticipantEvent(PE_PARTICIPANT_LEAVE, pITParticipant);
        pITParticipant->Release();
    }
    else
    {
        LOG((MSP_ERROR, "can't remove Participant %p", pITParticipant));
    }

    return S_OK;
}

void CIPConfMSPCall::SendParticipantEvent(
    IN  PARTICIPANT_EVENT   Event,
    IN  ITParticipant *     pITParticipant,
    IN  ITSubStream *       pITSubStream
    ) const
/*++

Routine Description:
    
    This method is called by a stream object to send a participant related
    event to the app.

Arguments:

    Event - the event code.

    pITParticipant - the participant object.

    pITSubStream - the substream object, if any.

Return Value:

nothing.

--*/
{
    LOG((MSP_TRACE, "send participant event, event %d, participant: %p",
        Event, pITParticipant));


    // Just want to be safe here.
    if (InterlockedCompareExchange((long*)&m_fShutDown, TRUE, TRUE)) 
    {
        return;
    }

    // Create a private event object.
    CComPtr<IDispatch> pEvent;
    HRESULT hr = CreateParticipantEvent(
        Event, 
        pITParticipant, 
        pITSubStream, 
        &pEvent
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "create event returned: %x", hr));
        return;
    }

    MSPEVENTITEM* pEventItem = AllocateEventItem();

    if (pEventItem == NULL)
    {
        LOG((MSP_ERROR, "No memory for the TSPMSP data, size: %d", sizeof(MSPEVENTITEM)));

        return;
    }

    // Fill in the necessary fields for the event structure.
    pEventItem->MSPEventInfo.dwSize = sizeof(MSP_EVENT_INFO);;
    pEventItem->MSPEventInfo.Event  = ME_PRIVATE_EVENT;
    pEventItem->MSPEventInfo.hCall  = m_htCall;
    
    pEventItem->MSPEventInfo.MSP_PRIVATE_EVENT_INFO.pEvent = pEvent;
    pEventItem->MSPEventInfo.MSP_PRIVATE_EVENT_INFO.lEventCode = Event;
    pEvent->AddRef();

    // send the event to tapi.
    hr = m_pMSPAddress->PostEvent(pEventItem);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Post event failed %x", hr));
    
        pEvent->Release();
        FreeEventItem(pEventItem);
    }
}

VOID CIPConfMSPCall::HandleGraphEvent(
    IN  MSPSTREAMCONTEXT * pContext
    )
{
    long     lEventCode;
    LONG_PTR lParam1, lParam2; // win64 fix

    HRESULT hr = pContext->pIMediaEvent->GetEvent(&lEventCode, &lParam1, &lParam2, 0);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Can not get the actual event. %x", hr));
        return;
    }

    LOG((MSP_EVENT, "ProcessGraphEvent, code:%d param1:%x param2:%x",
        lEventCode, lParam1, lParam2));

    if (lEventCode == EC_PALETTE_CHANGED 
        || lEventCode == EC_VIDEO_SIZE_CHANGED)
    {
        LOG((MSP_EVENT, "event %d ignored", lEventCode));
        return;
    }

    //
    // Create an event data structure that we will pass to the worker thread.
    //

    MULTI_GRAPH_EVENT_DATA * pData;
    pData = new MULTI_GRAPH_EVENT_DATA;
    
    if (pData == NULL)
    {
        LOG((MSP_ERROR, "Out of memory for event data."));
        return;
    }
    
    pData->pCall      = this;
    pData->pITStream  = pContext->pITStream;
    pData->lEventCode = lEventCode;
    pData->lParam1    = (long) lParam1; // win64 fix -- also need to change struct?
    pData->lParam2    = (long) lParam2; // win64 fix -- also need to change struct?
 
    //
    // Make sure the call and stream don't go away while we handle the event.
    // but use our special inner object addref for the call
    //

    pData->pCall->MSPCallAddRef();
    pData->pITStream->AddRef();

    //
    // Queue an async work item to call ProcessGraphEvent.
    //

    hr = g_Thread.QueueWorkItem(AsyncMultiGraphEvent,
                                (void *) pData,
                                FALSE);  // asynchronous

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "QueueWorkItem failed, return code:%x", hr));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\confmsp\confcall.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    confcall.h

Abstract:

    Declaration of the CIPConfMSPCall

Author:
    
    Mu Han (muhan) 5-September-1998

--*/

#ifndef __CONFCALL_H_
#define __CONFCALL_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <confpdu.h>

typedef struct _STREAMSETTINGS
{
    DWORD   dwPayloadType;    // The RTP payload type. In the future the
                              // MSP will use H245 defines to remove this 
                              // dependency on the payload type number.

    DWORD   dwMSPerPacket;    // milliseconds per packet.

    DWORD   dwQOSLevel;
    DWORD   dwTTL;
    DWORD   dwIPLocal;        // local interface to bind to.
    DWORD   dwIPRemote;       // remote IP address in host byte order.
    WORD    wRTPPortRemote;   // remote port number in host byte order.

    BOOL    fCIF;             // if CIF is used for video.

} STREAMSETTINGS, *PSTREAMSETTINGS;


/////////////////////////////////////////////////////////////////////////////
// CIPConfMSPCall
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CIPConfMSPCall : 
    public CMSPCallMultiGraph,
    public IDispatchImpl<ITParticipantControl, &IID_ITParticipantControl, 
                            &LIBID_IPConfMSPLib>,
    public IDispatchImpl<ITLocalParticipant, &IID_ITLocalParticipant, 
                            &LIBID_IPConfMSPLib>,
    public CMSPObjectSafetyImpl
{

public:

BEGIN_COM_MAP(CIPConfMSPCall)
    COM_INTERFACE_ENTRY(ITParticipantControl)
    COM_INTERFACE_ENTRY(ITLocalParticipant)
    COM_INTERFACE_ENTRY2(IDispatch, ITStreamControl)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_CHAIN(CMSPCallMultiGraph)
END_COM_MAP()

    CIPConfMSPCall();

// ITStreamControl methods, called by the app.
    STDMETHOD (CreateStream) (
        IN      long                lMediaType,
        IN      TERMINAL_DIRECTION  Direction,
        IN OUT  ITStream **         ppStream
        );
    
    STDMETHOD (RemoveStream) (
        IN      ITStream *          pStream
        );                      

// ITParticipantControl methods, called by the app.
    STDMETHOD (EnumerateParticipants) (
        OUT     IEnumParticipant ** ppEnumParticipants
        );

    STDMETHOD (get_Participants) (
        OUT     VARIANT * pVariant
        );

// ITLocalParticipant methods, called by the app.
    STDMETHOD (get_LocalParticipantTypedInfo) (
        IN  PARTICIPANT_TYPED_INFO  InfoType,
        OUT BSTR *                  ppInfo
        );

    STDMETHOD (put_LocalParticipantTypedInfo) (
        IN  PARTICIPANT_TYPED_INFO  InfoType,
        IN  BSTR                    pInfo
        );

// methods called by the MSPAddress object.
    HRESULT Init(
        IN      CMSPAddress *       pMSPAddress,
        IN      MSP_HANDLE          htCall,
        IN      DWORD               dwReserved,
        IN      DWORD               dwMediaType
        );

    HRESULT ShutDown();

    HRESULT ReceiveTSPCallData(
        IN      PBYTE               pBuffer,
        IN      DWORD               dwSize
        );

// medthod called by the worker thread.
    static DWORD WINAPI WorkerCallbackDispatcher(VOID *pContext);

    virtual VOID HandleGraphEvent(
        IN      MSPSTREAMCONTEXT *  pContext
        );

    DWORD ProcessWorkerCallBack(
        IN      PBYTE               pBuffer,
        IN      DWORD               dwSize
        );

    HRESULT InternalShutDown();
    
    DWORD MSPCallAddRef()
    {
        return MSPAddRefHelper(this);
    }

    DWORD MSPCallRelease()
    {
        return MSPReleaseHelper(this);
    }

// medthod called by the streams for participants
    HRESULT NewParticipant(
        IN  ITStream *              pITStream,
        IN  DWORD                   dwSSRC,
        IN  DWORD                   dwSendRecv,
        IN  DWORD                   dwMediaType,
        IN  char *                  szCName,
        OUT ITParticipant **        pITParticipant
        );

    HRESULT ParticipantLeft(
        IN ITParticipant *          pITParticipant
        );

    void SendParticipantEvent(
        IN  PARTICIPANT_EVENT       Event,
        IN  ITParticipant *         pITParticipant,
        IN  ITSubStream *           pITSubStream = NULL
        ) const;                          

    HRESULT SendTSPMessage(
        IN      TSP_MSP_COMMAND     command,
        IN      DWORD               dwParam1 = 0,
        IN      DWORD               dwParam2 = 0
        ) const;

    // this function is called at the call init time.
    void SetIPInterface(DWORD dwIPInterface)
    { m_dwIPInterface = dwIPInterface; }

protected:

    HRESULT InitializeLocalParticipant();
    
    virtual HRESULT CreateStreamObject(
        IN      DWORD               dwMediaType,
        IN      TERMINAL_DIRECTION  Direction,
        IN      IMediaEvent *       pGraph,
        IN      ITStream **         ppStream
        );

    HRESULT ProcessMediaItem(
        IN      ITMedia *           pITMedia,
        IN      DWORD               dwMediaTypeMask,
        OUT     DWORD *             pdwMediaType,
        OUT     WORD *              pwPort,
        OUT     DWORD *             pdwPayloadType
        );

    DWORD FindInterfaceByName(
        IN      WCHAR *             pMachineName
        );

    HRESULT CIPConfMSPCall::CheckOrigin(
        IN      ITSdp *             pITSdp, 
        OUT     BOOL *              pFlag,
        OUT     DWORD *             pdwIP
        );

    HRESULT ConfigStreamsBasedOnSDP(
        IN      ITSdp *             pITSdp,
        IN      DWORD               dwAudioQOSLevel,
        IN      DWORD               dwVideoQOSLevel
        );

    HRESULT ParseSDP(
        IN      WCHAR *             pSDP,
        IN      DWORD               dwAudioQOSLevel,
        IN      DWORD               dwVideoQOSLevel
        );                          

    HRESULT CheckUnusedStreams();

protected:

    // The list of participant in the call.
    CParticipantList    m_Participants;

    // the information items for local participant. The index is the 
    // value of RTCP_SDES_TYPE_T - 1, see RTP.h.
    WCHAR *             m_InfoItems[RTCP_SDES_LAST - 1];
    BOOL                m_fLocalInfoRetrieved;

    // The critical section to protect the participant list.
    CMSPCritSection     m_ParticipantLock;

    BOOL                m_fShutDown;

    DWORD               m_dwIPInterface;
};

typedef struct _CALLWORKITEM
{
    CIPConfMSPCall  *pCall;
    DWORD           dwLen;
    BYTE            Buffer[1];

} CALLWORKITEM, *PCALLWORKITEM;

#endif //__CONFCALL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\confmsp\confaud.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    confaud.cpp

Abstract:

    This module contains implementation of the audio send and receive
    stream implementations.

Author:

    Mu Han (muhan)   15-September-1999

--*/

#include "stdafx.h"
#include "common.h"

#include <initguid.h>
#include <amrtpnet.h>   // rtp guids
#include <amrtpdmx.h>   // demux guid
#include <amrtpuid.h>   // AMRTP media types
#include <amrtpss.h>    // for silence suppression filter
#include <irtprph.h>    // for IRTPRPHFilter
#include <irtpsph.h>    // for IRTPSPHFilter
#include <mixflter.h>   // audio mixer
#include <g711uids.h>   // for G711 codec CLSID
#include <g723uids.h>   // for G723 codec CLSID

//#define DISABLE_MIXER 1

/////////////////////////////////////////////////////////////////////////////
//
//  CStreamAudioRecv
//
/////////////////////////////////////////////////////////////////////////////

CStreamAudioRecv::CStreamAudioRecv()
    : CIPConfMSPStream(),
      m_pWaveFormatEx(NULL),
      m_dwSizeWaveFormatEx(0),
      m_fUseACM(FALSE),
      m_dwMaxPacketSize(0),
      m_dwAudioSampleRate(0)
{
    m_szName = L"AudioRecv";
}

void CStreamAudioRecv::FinalRelease()
{
    CIPConfMSPStream::FinalRelease();

    if (m_pWaveFormatEx)
    {
        free(m_pWaveFormatEx);
    }
}

HRESULT CStreamAudioRecv::Configure(
    IN STREAMSETTINGS &StreamSettings
    )
/*++

Routine Description:

    Configure the settings of this stream.

Arguments:
    
    StreamSettings - The setting structure got from the SDP blob.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "AudioRecv Configure entered."));

    CLock lock(m_lock);

    _ASSERTE(m_fIsConfigured == FALSE);

    switch (StreamSettings.dwPayloadType)
    {
    case PAYLOAD_G711U:
        
        // The mixer can convert them, no codec needed.
        m_pClsidCodecFilter  = &GUID_NULL;
        m_pRPHInputMinorType = &MEDIASUBTYPE_RTP_Payload_G711U; 
        m_pClsidPHFilter     = &CLSID_INTEL_RPHAUD;
        m_dwMaxPacketSize    = g_dwMaxG711PacketSize;
        m_dwAudioSampleRate  = g_dwG711AudioSampleRate;
        
        break;

    case PAYLOAD_G711A:
        
        m_pClsidCodecFilter  = &CLSID_G711Codec;
        m_pRPHInputMinorType = &MEDIASUBTYPE_RTP_Payload_G711A; 
        m_pClsidPHFilter     = &CLSID_INTEL_RPHAUD;
        m_dwMaxPacketSize    = g_dwMaxG711PacketSize;
        m_dwAudioSampleRate  = g_dwG711AudioSampleRate;
        
        break;

    case PAYLOAD_GSM:
      
        m_fUseACM            = TRUE;
        m_pClsidCodecFilter  = &CLSID_ACMWrapper;
        m_pRPHInputMinorType = &MEDIASUBTYPE_RTP_Payload_ANY; 
        m_pClsidPHFilter     = &CLSID_INTEL_RPHGENA;
        m_dwMaxPacketSize    = g_dwMaxGSMPacketSize;
        m_dwAudioSampleRate  = g_dwGSMAudioSampleRate;

        {
            GSM610WAVEFORMAT * pWaveFormat = 
                (GSM610WAVEFORMAT *)malloc(sizeof GSM610WAVEFORMAT);

            if (pWaveFormat == NULL)
            {
                return E_OUTOFMEMORY;
            }

            pWaveFormat->wfx.wFormatTag          = WAVE_FORMAT_GSM610;
            pWaveFormat->wfx.wBitsPerSample      = 0;
            pWaveFormat->wfx.nChannels           = g_wAudioChannels;
            pWaveFormat->wfx.nSamplesPerSec      = m_dwAudioSampleRate;
            pWaveFormat->wfx.nAvgBytesPerSec     = g_dwGSMBytesPerSecond;
            pWaveFormat->wfx.nBlockAlign         = g_wGSMBlockAlignment;
            pWaveFormat->wfx.cbSize              = 
                sizeof GSM610WAVEFORMAT - sizeof WAVEFORMATEX;
            pWaveFormat->wSamplesPerBlock        = g_wGSMSamplesPerBlock;

            m_pWaveFormatEx = (BYTE *)pWaveFormat;
            m_dwSizeWaveFormatEx = sizeof GSM610WAVEFORMAT;
        }

        break;

    // This is a test of the MSAudio wideband codec
    case PAYLOAD_MSAUDIO:
      
        m_fUseACM            = TRUE;
        m_pClsidCodecFilter  = &CLSID_ACMWrapper;
        m_pRPHInputMinorType = &MEDIASUBTYPE_RTP_Payload_ANY; 
        m_pClsidPHFilter     = &CLSID_INTEL_RPHGENA;
        m_dwMaxPacketSize    = g_dwMaxMSAudioPacketSize;
        m_dwAudioSampleRate  = g_dwMSAudioSampleRate;

        {
            MSAUDIO1WAVEFORMAT * pWaveFormat = 
                (MSAUDIO1WAVEFORMAT *)malloc(sizeof MSAUDIO1WAVEFORMAT);

            if (pWaveFormat == NULL)
            {
                return E_OUTOFMEMORY;
            }

            pWaveFormat->wfx.wFormatTag          = WAVE_FORMAT_MSAUDIO1;
            pWaveFormat->wfx.wBitsPerSample      = MSAUDIO1_BITS_PER_SAMPLE;
            pWaveFormat->wfx.nChannels           = MSAUDIO1_MAX_CHANNELS;
            pWaveFormat->wfx.nSamplesPerSec      = m_dwAudioSampleRate;
            pWaveFormat->wfx.nAvgBytesPerSec     = g_dwMSAudioBytesPerSecond;
            pWaveFormat->wfx.nBlockAlign         = g_wMSAudioBlockAlignment;
            pWaveFormat->wfx.cbSize              = 
                sizeof MSAUDIO1WAVEFORMAT - sizeof WAVEFORMATEX;
            pWaveFormat->wSamplesPerBlock        = g_wMSAudioSamplesPerBlock;

            m_pWaveFormatEx = (BYTE *)pWaveFormat;
            m_dwSizeWaveFormatEx = sizeof MSAUDIO1WAVEFORMAT;
        }

        break;

#ifdef DVI
    case PAYLOAD_DVI4_8:
      
        m_fUseACM            = TRUE;
        m_pClsidCodecFilter  = &CLSID_ACMWrapper;
        m_pRPHInputMinorType = &MEDIASUBTYPE_RTP_Payload_ANY; 
        m_pClsidPHFilter     = &CLSID_INTEL_RPHGENA;
        m_dwMaxPacketSize    = g_dwMaxDVI4PacketSize;
        m_dwAudioSampleRate  = g_dwDVI4AudioSampleRate;
        
        {
            IMAADPCMWAVEFORMAT * pWaveFormat = 
                (IMAADPCMWAVEFORMAT *)malloc(sizeof IMAADPCMWAVEFORMAT);

            if (pWaveFormat == NULL)
            {
                return E_OUTOFMEMORY;
            }

            pWaveFormat->wfx.wFormatTag          = WAVE_FORMAT_IMA_ADPCM;
            pWaveFormat->wfx.wBitsPerSample      = g_wDVI4BitsPerSample;
            pWaveFormat->wfx.nChannels           = g_wAudioChannels;
            pWaveFormat->wfx.nSamplesPerSec      = m_dwAudioSampleRate;
            pWaveFormat->wfx.nAvgBytesPerSec     = g_dwDVI4BytesPerSecond;
            pWaveFormat->wfx.nBlockAlign         = g_wDVI4BlockAlignment;
            pWaveFormat->wfx.cbSize              = 
                sizeof IMAADPCMWAVEFORMAT - sizeof WAVEFORMATEX;
            pWaveFormat->wSamplesPerBlock        = g_wDVI4SamplesPerBlock;

            m_pWaveFormatEx = (BYTE *)pWaveFormat;
            m_dwSizeWaveFormatEx = sizeof IMAADPCMWAVEFORMAT;
        }
        break;
#endif

    default:
        LOG((MSP_ERROR, "unknown payload type, %x", StreamSettings.dwPayloadType));
        return E_FAIL;
    }
    
    m_Settings      = StreamSettings;
    m_fIsConfigured = TRUE;

    return InternalConfigure();
}

HRESULT CStreamAudioRecv::ConfigureRTPFilter(
    IN  IBaseFilter *   pIBaseFilter
    )
/*++

Routine Description:

    Configure the source RTP filter. Including set the address, port, TTL,
    QOS, thread priority, clcokrate, etc.

Arguments:
    
    pIBaseFilter - The source RTP Filter.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "AudioRecv ConfigureRTPFilter"));

    HRESULT hr;

    // Get the IRTPStream interface pointer on the filter.
    CComQIPtr<IRTPStream, &IID_IRTPStream> pIRTPStream(pIBaseFilter);
    if (pIRTPStream == NULL)
    {
        LOG((MSP_ERROR, "get RTP Stream interface"));
        return E_NOINTERFACE;
    }

    LOG((MSP_INFO, "set remote Address:%x, port:%d", 
        m_Settings.dwIPRemote, m_Settings.wRTPPortRemote));

    // Set the address and port used in the filter.
    if (FAILED(hr = pIRTPStream->SetAddress(
        htons(m_Settings.wRTPPortRemote),   // local port to listen on.
        0,                                  // remote port.
        htonl(m_Settings.dwIPRemote)        // remote address.
        )))
    {
        LOG((MSP_ERROR, "set remote Address, hr:%x", hr));
        return hr;
    }

    // Set the TTL used in the filter.
    if (FAILED(hr = pIRTPStream->SetMulticastScope(m_Settings.dwTTL)))
    {
        LOG((MSP_ERROR, "set TTL. %x", hr));
        return hr;
    }

    if (m_Settings.dwIPLocal != INADDR_ANY)
    {
        // set the local interface that the socket should bind to
        LOG((MSP_INFO, "set locol Address:%x", m_Settings.dwIPLocal));

        if (FAILED(hr = pIRTPStream->SelectLocalIPAddress(
            htonl(m_Settings.dwIPLocal)
            )))
        {
            LOG((MSP_ERROR, "set locol Address, hr:%x", hr));
            return hr;
        }
    }

    // Set the priority of the session
    if (FAILED(hr = pIRTPStream->SetSessionClassPriority(
        RTP_CLASS_AUDIO,
        g_dwAudioThreadPriority
        )))
    {
        LOG((MSP_WARN, "set session class and priority. %x", hr));
    }

    // Set the sample rate of the session
    LOG((MSP_INFO, "setting session sample rate to %d", m_dwAudioSampleRate));
    
    if (FAILED(hr = pIRTPStream->SetDataClock(m_dwAudioSampleRate)))
    {
        LOG((MSP_WARN, "set session sample rate. %x", hr));
    }

    // Enable the RTCP events
    if (FAILED(hr = ::EnableRTCPEvents(pIBaseFilter)))
    {
        LOG((MSP_WARN, "can not enable RTCP events %x", hr));
    }

    DWORD dwLoopback = 0;
    if (TRUE == ::GetRegValue(gszMSPLoopback, &dwLoopback)
        && dwLoopback != 0)
    {
        // Loopback is required.
        if (FAILED(hr = ::SetLoopbackOption(pIBaseFilter, dwLoopback)))
        {
            LOG((MSP_ERROR, "set loopback option. %x", hr));
            return hr;
        }
    }

    if (m_Settings.dwQOSLevel != QSL_BEST_EFFORT)
    {
        if (FAILED(hr = ::SetQOSOption(
            pIBaseFilter,
            m_Settings.dwPayloadType,       // payload
            -1,                             // use the default bitrate 
            (m_Settings.dwQOSLevel == QSL_NEEDED),  // fail if no qos.
            TRUE,                           // receive stream.
            g_wAudioDemuxPins               // number of streams reserved.
            )))
        {
            LOG((MSP_ERROR, "set QOS option. %x", hr));
            return hr;
        }
    }
    
    SetLocalInfoOnRTPFilter(pIBaseFilter);

    return S_OK;
}

HRESULT CStreamAudioRecv::ConnectTerminal(
    IN  ITTerminal *   pITTerminal
    )
/*++

Routine Description:

    connect the mixer to the audio render terminal.

Arguments:
    
    pITTerminal - The terminal to be connected.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "AudioRecv.ConnectTerminal, pITTerminal %p", pITTerminal));

    HRESULT hr;

    // if our filters have not been contructed, do it now.
    if (m_pEdgeFilter == NULL)
    {
        hr = SetUpInternalFilters();
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "Set up internal filter failed, %x", hr));
            
            CleanUpFilters();

            return hr;
        }
    }

    // get the terminal control interface.
    CComQIPtr<ITTerminalControl, &IID_ITTerminalControl> 
        pTerminal(pITTerminal);
    if (pTerminal == NULL)
    {
        LOG((MSP_ERROR, "can't get Terminal Control interface"));

        SendStreamEvent(
            CALL_TERMINAL_FAIL,
            CALL_CAUSE_BAD_DEVICE,
            E_NOINTERFACE, 
            pITTerminal
            );
        
        return E_NOINTERFACE;
    }

    const DWORD MAXPINS     = 8;
    
    DWORD       dwNumPins   = MAXPINS;
    IPin *      Pins[MAXPINS];

    // Get the pins.
    hr = pTerminal->ConnectTerminal(
        m_pIGraphBuilder, 0, &dwNumPins, Pins
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't connect to terminal, %x", hr));

        SendStreamEvent(
            CALL_TERMINAL_FAIL,
            CALL_CAUSE_BAD_DEVICE,
            hr, 
            pITTerminal
            );
        
        return hr;
    }

    // the pin count should never be 0.
    if (dwNumPins == 0)
    {
        LOG((MSP_ERROR, "terminal has no pins."));

        SendStreamEvent(
            CALL_TERMINAL_FAIL,
            CALL_CAUSE_BAD_DEVICE,
            hr, 
            pITTerminal
            );
        
        pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

        return E_UNEXPECTED;
    }

    // Connect the mixer filter to the audio render terminal.
    hr = ::ConnectFilters(
        m_pIGraphBuilder,
        (IBaseFilter *)m_pEdgeFilter, 
        (IPin *)Pins[0]
        );

    // release the refcounts on the pins.
    for (DWORD i = 0; i < dwNumPins; i ++)
    {
        Pins[i]->Release();
    }

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "connect to the mixer filter. %x", hr));

        pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

        return hr;
    }
    
    //
    // Now we are actually connected. Update our state and perform postconnection
    // (ignore postconnection error code).
    //
    pTerminal->CompleteConnectTerminal();

    return hr;
}

HRESULT CStreamAudioRecv::SetUpInternalFilters()
/*++

Routine Description:

    set up the filters used in the stream.

    RTP->Demux->RPH(->DECODER)->Mixer

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "AudioRecv.SetUpInternalFilters"));

    CComPtr<IBaseFilter> pSourceFilter;

    HRESULT hr;

    // create and add the source fitler.
    if (FAILED(hr = ::AddFilter(
            m_pIGraphBuilder,
            CLSID_RTPSourceFilter, 
            L"RtpSource", 
            &pSourceFilter)))
    {
        LOG((MSP_ERROR, "adding source filter. %x", hr));
        return hr;
    }

    if (FAILED(hr = ConfigureRTPFilter(pSourceFilter)))
    {
        LOG((MSP_ERROR, "configure RTP source filter. %x", hr));
        return hr;
    }

    CComPtr<IBaseFilter> pDemuxFilter;

    // create and add the demux fitler.
    if (FAILED(hr = ::AddFilter(
            m_pIGraphBuilder,
            CLSID_IntelRTPDemux, 
            L"RtpDemux",
            &pDemuxFilter)))
    {
        LOG((MSP_ERROR, "adding demux filter. %x", hr));
        return hr;
    }

    // Connect the source filter and the demux filter.
    if (FAILED(hr = ::ConnectFilters(
            m_pIGraphBuilder,
            (IBaseFilter *)pSourceFilter, 
            (IBaseFilter *)pDemuxFilter)))
    {
        LOG((MSP_ERROR, "connect source filter and demux filter. %x", hr));
        return hr;
    }

    // Get the IRTPDemuxFilter interface used in configuring the demux filter.
    CComQIPtr<IRTPDemuxFilter, &IID_IRTPDemuxFilter> pIRTPDemux(pDemuxFilter);
    if (pIRTPDemux == NULL)
    {
        LOG((MSP_ERROR, "get RTP Demux interface"));
        return E_NOINTERFACE;
    }

    // Set the number of output pins on the demux filter based on the number 
    // of channels needed.
    if (FAILED(hr = pIRTPDemux->SetPinCount(
        g_wAudioDemuxPins
        )))
    {
        LOG((MSP_ERROR, "set demux output pin count"));
        return hr;
    }

    LOG((MSP_INFO, 
        "set demux output pin count to %d", 
        g_wAudioDemuxPins
        ));

    // Get the enumerator of pins on the demux filter.
    CComPtr<IEnumPins> pIEnumPins;
    if (FAILED(hr = pDemuxFilter->EnumPins(&pIEnumPins)))
    {
        LOG((MSP_ERROR, "enumerate pins on the demux filter %x", hr));
        return hr;
    }

#ifndef DISABLE_MIXER
    // Create and add the mixer filter into the filtergraph.
    CComPtr<IBaseFilter> pIMixerFilter;

    if (FAILED(hr = ::AddFilter(
        m_pIGraphBuilder,
        CLSID_AudioMixFilter, 
        L"Mixer", 
        &pIMixerFilter
        )))
    {
        LOG((MSP_ERROR, "add Mixer filter. %x", hr));
        return hr;
    }

    LOG((MSP_INFO, "Added Mixer filter"));

    // currently we support only one format for each stream.
#endif

#ifndef DISABLE_MIXER
    for (DWORD i = 0; i < g_wAudioDemuxPins; i++)
#else
    CComPtr<IBaseFilter> pIFilter;
    for (DWORD i = 0; i < 1; i++)
#endif
    {
        // Find the next output pin on the demux fitler.    
        CComPtr<IPin> pIPinOutput;
        
        for (;;)
        {
            if ((hr = pIEnumPins->Next(1, &pIPinOutput, NULL)) != S_OK)
            {
                LOG((MSP_ERROR, "find output pin on demux."));
                break;
            }
            PIN_DIRECTION dir;
            if (FAILED(hr = pIPinOutput->QueryDirection(&dir)))
            {
                LOG((MSP_ERROR, "query pin direction. %x", hr));
                pIPinOutput.Release();
                break;
            }
            if (PINDIR_OUTPUT == dir)
            {
                break;
            }
            pIPinOutput.Release();
        }

        if (hr != S_OK)  
        {
            // There is no more output pin on the demux filter.
            // This should never happen.
            hr = E_UNEXPECTED;
            break;
        }

        // Set the media type on this output pin.
        if (FAILED(hr = pIRTPDemux->SetPinTypeInfo(
                pIPinOutput, 
                (BYTE)m_Settings.dwPayloadType,
                *m_pRPHInputMinorType 
                )))
        {
            LOG((MSP_ERROR, "set demux output pin type info"));
            break;
        }

        LOG((MSP_INFO, 
            "set demux output pin payload type to %d", 
            m_Settings.dwPayloadType
            ));

        // Create and add the payload handler into the filtergraph.
        CComPtr<IBaseFilter> pIRPHFilter;

        if (FAILED(hr = ::AddFilter(
            m_pIGraphBuilder,
            *m_pClsidPHFilter, 
            L"RPH", 
            &pIRPHFilter
            )))
        {
            LOG((MSP_ERROR, "add RPH filter. %x", hr));
            break;
        }

        // Connect the payload handler to the output pin on the demux.
        if (FAILED(hr = ::ConnectFilters(
            m_pIGraphBuilder,
            (IPin *)pIPinOutput, 
            (IBaseFilter *)pIRPHFilter
            )))
        {
            LOG((MSP_ERROR, "connect demux and RPH filter. %x", hr));
            break;
        }

        // Get the IRTPRPHFilter interface.
        CComQIPtr<IRTPRPHFilter, &IID_IRTPRPHFilter>pIRTPRPHFilter(pIRPHFilter);
        if (pIRTPRPHFilter == NULL)
        {
            LOG((MSP_ERROR, "get IRTPRPHFilter interface"));
            break;
        }

        // set the media buffer size so that the receive buffers are of the
        // right size. Note, G723 needs smaller buffers than G711. 
        if (FAILED(hr = pIRTPRPHFilter->SetMediaBufferSize(        
            m_dwMaxPacketSize
            )))
        {
            LOG((MSP_ERROR, "Set media buffer size. %x", hr));
            break;
        }

        LOG((MSP_INFO, "Set RPH media buffer size to %d", m_dwMaxPacketSize));
 
        if (m_fUseACM)
        {
            // We are using the ACM codec, so we have to set the media types
            AM_MEDIA_TYPE mt;

            mt.majortype            = MEDIATYPE_Audio;
            mt.subtype              = MEDIASUBTYPE_NULL;
            mt.bFixedSizeSamples    = TRUE;
            mt.bTemporalCompression = FALSE;
            mt.lSampleSize          = 0;
            mt.formattype           = FORMAT_WaveFormatEx;
            mt.pUnk                 = NULL;
            mt.cbFormat             = m_dwSizeWaveFormatEx;
            mt.pbFormat             = m_pWaveFormatEx;

            if (FAILED(hr = pIRTPRPHFilter->SetOutputPinMediaType(&mt)))
            {
                LOG((MSP_ERROR, "Set RPHGENA output pin media type. %x", hr));
                return FALSE;
            }

            if (FAILED(hr = pIRTPRPHFilter->OverridePayloadType(
                (BYTE)m_Settings.dwPayloadType
                )))
            {
                LOG((MSP_ERROR, "Set RPHGENA output pin media type. %x", hr));
                return FALSE;
            }
        }
#ifndef DISABLE_MIXER
        CComPtr<IBaseFilter> pIFilter;
#endif
        // connect the codec filter if it is needed.
        if (*m_pClsidCodecFilter != GUID_NULL)
        {

            if (FAILED(hr = ::AddFilter(
                m_pIGraphBuilder,
                *m_pClsidCodecFilter, 
                L"codec", 
                &pIFilter
                )))
            {
                LOG((MSP_ERROR, "add Codec filter. %x", hr));
                break;
            }

            // Connect the payload handler to the output pin on the demux.
            if (FAILED(hr = ::ConnectFilters(
                m_pIGraphBuilder,
                (IBaseFilter *)pIRPHFilter, 
                (IBaseFilter *)pIFilter
                )))
            {
                LOG((MSP_ERROR, "connect RPH filter and codec. %x", hr));
                break;
            }
        }
        else 
        {
            pIFilter = pIRPHFilter;
        }
#ifndef DISABLE_MIXER
        // Connect the payload handler or the codec filter to the mixer filter.
        if (FAILED(hr = ::ConnectFilters(
            m_pIGraphBuilder,
            (IBaseFilter *)pIFilter, 
            (IBaseFilter *)pIMixerFilter
            )))
        {
            LOG((MSP_ERROR, "connect to the mixer filter. %x", hr));
            break;
        }
#endif

    }

    if (SUCCEEDED(hr))
    {
        // keep a reference to the last filter so that the change of terminal 
        // will not require a recreating of all the filters.
#ifndef DISABLE_MIXER
        m_pEdgeFilter = pIMixerFilter;
#else        
        m_pEdgeFilter = pIFilter;
#endif
        m_pEdgeFilter->AddRef();
        
        // Get the IRTPParticipant interface pointer on the RTP filter.
        CComQIPtr<IRTPParticipant, 
            &IID_IRTPParticipant> pIRTPParticipant(pSourceFilter);
        if (pIRTPParticipant == NULL)
        {
            LOG((MSP_WARN, "can't get RTP participant interface"));
        }
        else
        {
            m_pRTPFilter = pIRTPParticipant;
            m_pRTPFilter->AddRef();
        }
    }

    return hr;
}

HRESULT CStreamAudioRecv::SetUpFilters()
/*++

Routine Description:

    Insert filters into the graph and connect to the terminals.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "AudioRecv SetupFilters entered."));
    HRESULT hr;

    // we only support one terminal for this stream.
    if (m_Terminals.GetSize() != 1)
    {
        return E_UNEXPECTED;
    }

    // Connect the mixer to the terminal.
    if (FAILED(hr = ConnectTerminal(
        m_Terminals[0]
        )))
    {
        LOG((MSP_ERROR, "connect the mixer filter to terminal. %x", hr));

        return hr;
    }
    return hr;
}

HRESULT CStreamAudioRecv::ProcessSSRCMappedEvent(
    IN  DWORD dwSSRC
    )
/*++

Routine Description:

    a SSRC is active, file a participant active event.

Arguments:

    dwSSRC - the SSRC of the participant.

Return Value:

    S_OK,
    E_UNEXPECTED

--*/
{
    LOG((MSP_TRACE, "%ls Processes pin mapped event, pIPin: %p", m_szName, dwSSRC));
    
    CLock lock(m_lock);

    ITParticipant * pITParticipant = NULL;

    // find the SSRC in our participant list.
    for (int i = 0; i < m_Participants.GetSize(); i ++)
    {
        if (((CParticipant *)m_Participants[i])->
                HasSSRC((ITStream *)this, dwSSRC))
        {
            pITParticipant = m_Participants[i];
        }
    }

    // if the participant is not there yet, put the event in a queue and it
    // will be fired when we have the CName fo the participant.
    if (!pITParticipant)
    {
        LOG((MSP_INFO, "can't find a participant that has SSRC %x", dwSSRC));

        m_PendingSSRCs.Add(dwSSRC);
        
        LOG((MSP_INFO, "added the event to pending list, new list size:%d", 
            m_PendingSSRCs.GetSize()));

        return S_OK;
    }
   
    ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
        PE_PARTICIPANT_ACTIVE, 
        pITParticipant
        );

    return S_OK;
}

HRESULT CStreamAudioRecv::NewParticipantPostProcess(
    IN  DWORD dwSSRC, 
    IN  ITParticipant *pITParticipant
    )
/*++

Routine Description:

    A mapped event happended when we didn't have the participant's name so
    it was queued in a list. Now that we have a new participant, let's check
    if this is the same participant. If it is, we complete the mapped event
    by sending the app an notification.

Arguments:

    dwSSRC - the SSRC of the participant.

    pITParticipant - the participant object.

Return Value:

    S_OK,
    E_UNEXPECTED

--*/
{
    LOG((MSP_TRACE, "%ls Check pending mapped event, dwSSRC: %x", m_szName, dwSSRC));
    
    // look at the pending SSRC list and find out if this report
    // fits in the list.
    int i = m_PendingSSRCs.Find(dwSSRC);

    if (i < 0)
    {
        // the SSRC is not in the list of pending PinMappedEvents.
        LOG((MSP_TRACE, "the SSRC %x is not in the pending list", dwSSRC));
        return S_OK;
    }
    
    // get rid of the peding SSRC.
    m_PendingSSRCs.RemoveAt(i);

    // complete the event.
    ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
        PE_PARTICIPANT_ACTIVE, 
        pITParticipant
        );

    return S_OK;
}

HRESULT CStreamAudioRecv::ProcessSSRCUnmapEvent(
    IN  DWORD dwSSRC
    )
/*++

Routine Description:

    A SSRC just got unmapped by the demux. Notify the app that a participant
    becomes inactive.

Arguments:

    dwSSRC - the SSRC of the participant.

Return Value:

    S_OK,
    E_UNEXPECTED

--*/
{
    LOG((MSP_TRACE, "%ls Processes SSRC unmapped event, pIPin: %p", m_szName, dwSSRC));
    
    CLock lock(m_lock);

    // look at the pending SSRC list and find out if it is in the pending list.
    int i = m_PendingSSRCs.Find(dwSSRC);

    // if the SSRC is in the pending list, just remove it.
    if (i >= 0)
    {
        m_PendingSSRCs.RemoveAt(i);
        return S_OK;
    }

    ITParticipant *pITParticipant = NULL;

    // find the SSRC in our participant list.
    for (i = 0; i < m_Participants.GetSize(); i ++)
    {
        if (((CParticipant *)m_Participants[i])->
                HasSSRC((ITStream *)this, dwSSRC))
        {
            pITParticipant = m_Participants[i];
        }
    }

    if (pITParticipant)
    {
        // fire an event to tell the app that the participant is inactive.
        ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
            PE_PARTICIPANT_INACTIVE, 
            pITParticipant
            );
    }
    return S_OK;
}

HRESULT CStreamAudioRecv::ProcessParticipantLeave(
    IN  DWORD   dwSSRC
    )
/*++

Routine Description:

    When participant left the session, remove the stream from the participant
    object's list of streams. If all streams are removed, remove the 
    participant from the call object's list too.

Arguments:
    
    dwSSRC - the SSRC of the participant left.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "%ls ProcessParticipantLeave, SSRC: %x", m_szName, dwSSRC));
    
    CLock lock(m_lock);
    
    // look at the pending SSRC list and find out if it is in the pending list.
    int i = m_PendingSSRCs.Find(dwSSRC);

    // if the SSRC is in the pending list, remove it.
    if (i >= 0)
    {
        m_PendingSSRCs.RemoveAt(i);
    }

    CParticipant *pParticipant;
    BOOL fLast = FALSE;

    HRESULT hr = E_FAIL;

    // first try to find the SSRC in our participant list.
    for (i = 0; i < m_Participants.GetSize(); i ++)
    {
        pParticipant = (CParticipant *)m_Participants[i];
        hr = pParticipant->RemoveStream(
                (ITStream *)this,
                dwSSRC,
                &fLast
                );
        
        if (SUCCEEDED(hr))
        {
            break;
        }
    }

    // if the participant is not found
    if (FAILED(hr))
    {
        LOG((MSP_WARN, "%ws, can't find the SSRC %x", m_szName, dwSSRC));

        return hr;
    }

    ITParticipant *pITParticipant = m_Participants[i];

    // fire an event to tell the app that the participant is in active.
    ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
        PE_PARTICIPANT_INACTIVE, 
        pITParticipant
        );

    m_Participants.RemoveAt(i);

    // if this stream is the last stream that the participant is on,
    // tell the call object to remove it from its list.
    if (fLast)
    {
        ((CIPConfMSPCall *)m_pMSPCall)->ParticipantLeft(pITParticipant);
    }

    pITParticipant->Release();

    return S_OK;
}

HRESULT CStreamAudioRecv::ProcessGraphEvent(
    IN  long lEventCode,
    IN  long lParam1,
    IN  long lParam2
    )
{
    LOG((MSP_TRACE, "%ws ProcessGraphEvent %d", m_szName, lEventCode));

    switch (lEventCode)
    {
    case RTPDMX_EVENTBASE + RTPDEMUX_SSRC_MAPPED:
        LOG((MSP_INFO, "handling SSRC mapped event, SSRC%x", lParam1));
        
        ProcessSSRCMappedEvent((DWORD)lParam1);

        break;

    case RTPDMX_EVENTBASE + RTPDEMUX_SSRC_UNMAPPED:
        LOG((MSP_INFO, "handling SSRC unmap event, SSRC%x", lParam1));

        ProcessSSRCUnmapEvent((DWORD)lParam1);

        break;

    default:
        return CIPConfMSPStream::ProcessGraphEvent(
            lEventCode, lParam1, lParam2
            );
    }
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//  CStreamAudioSend
//
/////////////////////////////////////////////////////////////////////////////

CStreamAudioSend::CStreamAudioSend()
    : CIPConfMSPStream(),
      m_iACMID(0),
      m_dwMSPerPacket(0),
      m_fUseACM(FALSE),
      m_dwMaxPacketSize(0),
      m_dwAudioSampleRate(0)
{
      m_szName = L"AudioSend";
}

HRESULT CStreamAudioSend::Configure(
    IN STREAMSETTINGS &StreamSettings
    )
/*++

Routine Description:

    Configure the settings of this stream.

Arguments:
    
    StreamSettings - The setting structure got from the SDP blob.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "AudioSend Configure entered."));

    CLock lock(m_lock);

    _ASSERTE(m_fIsConfigured == FALSE);

    switch (StreamSettings.dwPayloadType)
    {
    case PAYLOAD_G711U:
    case PAYLOAD_G711A:
        
        m_pClsidCodecFilter  = &CLSID_G711Codec;
        m_pClsidPHFilter     = &CLSID_INTEL_SPHAUD;
        m_dwMSPerPacket      = g_dwG711MSPerPacket;
        m_dwMaxPacketSize    = g_dwG711BytesPerPacket + g_dwRTPHeaderSize;
        m_dwAudioSampleRate  = g_dwG711AudioSampleRate;

        if (StreamSettings.dwMSPerPacket != 0)
        {
            m_dwMSPerPacket = StreamSettings.dwMSPerPacket;
            m_dwMaxPacketSize = m_dwMSPerPacket * m_dwAudioSampleRate / 1000
                + g_dwRTPHeaderSize;
        }

        break;

#ifdef DVI
    case PAYLOAD_DVI4_8:

        m_fUseACM            = TRUE;
        m_iACMID             = WAVE_FORMAT_IMA_ADPCM;
        m_pClsidCodecFilter  = &CLSID_ACMWrapper;
        m_pRPHInputMinorType = &MEDIASUBTYPE_RTP_Payload_ANY; 
        m_pClsidPHFilter     = &CLSID_INTEL_SPHGENA;
        m_dwMSPerPacket      = g_dwDVI4MSPerPacket;
        m_dwMaxPacketSize    = g_dwDVI4BytesPerPacket + g_dwRTPHeaderSize;
        m_dwAudioSampleRate  = g_dwDVI4AudioSampleRate;

        break;
#endif
        
    case PAYLOAD_GSM:
      
        m_fUseACM            = TRUE;
        m_iACMID             = WAVE_FORMAT_GSM610;
        m_pClsidCodecFilter  = &CLSID_ACMWrapper;
        m_pRPHInputMinorType = &MEDIASUBTYPE_RTP_Payload_ANY; 
        m_pClsidPHFilter     = &CLSID_INTEL_SPHGENA;
        m_dwMSPerPacket      = g_dwGSMMSPerPacket;
        m_dwMaxPacketSize    = g_dwGSMBytesPerPacket + g_dwRTPHeaderSize;
        m_dwAudioSampleRate  = g_dwGSMAudioSampleRate;

        break;

    case PAYLOAD_MSAUDIO:
      
        m_fUseACM            = TRUE;
        m_iACMID             = WAVE_FORMAT_MSAUDIO1;
        m_pClsidCodecFilter  = &CLSID_ACMWrapper;
        m_pRPHInputMinorType = &MEDIASUBTYPE_RTP_Payload_ANY; 
        m_pClsidPHFilter     = &CLSID_INTEL_SPHGENA;
        m_dwMSPerPacket      = g_dwMSAudioMSPerPacket;
        m_dwMaxPacketSize    = g_dwMaxMSAudioPacketSize;
        m_dwAudioSampleRate  = g_dwMSAudioSampleRate;

        break;

    default:
        LOG((MSP_ERROR, 
            "unknow payload type, %x", StreamSettings.dwPayloadType));
        return E_FAIL;
    }
    
    m_Settings      = StreamSettings;
    m_fIsConfigured = TRUE;

    return InternalConfigure();
}

HRESULT CStreamAudioSend::ConfigureAudioCaptureTerminal(
    IN      ITTerminalControl *     pTerminal,
    OUT     IPin **                 ppIPin
    )
/*++

Routine Description:

    Configure the audio capture terminal. This function gets a output pin from
    the capture terminal and the configure the audio format and media type.

Arguments:
    
    pTerminal - An audio capture terminal.

    ppIPin - the address to hold the returned pointer to IPin interface.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "AudioSend configure audio capture terminal."));

    const DWORD MAXPINS     = 8;
    
    DWORD       dwNumPins   = MAXPINS;
    IPin *      Pins[MAXPINS];

    // Get the pins from the first terminal because we only use on terminal
    // on this stream.
    HRESULT hr = pTerminal->ConnectTerminal(
        m_pIGraphBuilder, 0, &dwNumPins, Pins
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't connect to terminal, %x", hr));
        return hr;
    }

    // The number of pins should never be 0.
    if (dwNumPins == 0)
    {
        LOG((MSP_ERROR, "terminal has no pins."));
        return E_UNEXPECTED;
    }

    // Save the first pin and release the others.
    CComPtr <IPin> pIPin = Pins[0];
    for (DWORD i = 0; i < dwNumPins; i ++)
    {
        Pins[i]->Release();
    }

    // Set the format of the audio to 8KHZ, 16Bit/Sample, MONO.
    hr = SetAudioFormat(
        pIPin, 
        g_wAudioCaptureBitPerSample, 
        m_dwAudioSampleRate
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't set audio format, %x", hr));
        return hr;
    }

    // Set the capture buffer size.
    hr = SetAudioBufferSize(
        pIPin, 
        g_dwAudioCaptureNumBufffers, 
        AudioCaptureBufferSize(m_dwMSPerPacket, m_dwAudioSampleRate)
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't set aduio capture buffer size, %x", hr));
        return hr;
    }

    pIPin->AddRef();
    *ppIPin = pIPin;

    return hr;
}

HRESULT CStreamAudioSend::ConnectTerminal(
    IN  ITTerminal *   pITTerminal
    )
/*++

Routine Description:

    connect the audio capture terminal to the stream.

Arguments:

    pITTerminal - The terminal to be connected.
    
Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "AudioSend ConnectTerminal, pITTerminal %p", pITTerminal));

    CComQIPtr<ITTerminalControl, &IID_ITTerminalControl> 
        pTerminal(pITTerminal);
    if (pTerminal == NULL)
    {
        LOG((MSP_ERROR, "can't get Terminal Control interface"));
        
        SendStreamEvent(
            CALL_TERMINAL_FAIL, 
            CALL_CAUSE_BAD_DEVICE,
            E_NOINTERFACE, 
            pITTerminal
            );

        return E_NOINTERFACE;
    }

    // configure the terminal.
    CComPtr<IPin>   pIPin;
    HRESULT hr = ConfigureAudioCaptureTerminal(pTerminal, &pIPin);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "configure audio capture termianl failed. %x", hr));

        SendStreamEvent(
            CALL_TERMINAL_FAIL,
            CALL_CAUSE_BAD_DEVICE,
            hr, 
            pITTerminal
            );
        
        return hr;
    }

    // Create other filters to be use in the stream.
    hr = CreateSendFilters(pIPin);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Create audio send filters failed. %x", hr));

        pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

        // clean up internal filters as well.
        CleanUpFilters();

        return hr;
    }

    //
    // Now we are actually connected. Update our state and perform postconnection
    // (ignore postconnection error code).
    //
    pTerminal->CompleteConnectTerminal();

    return hr;
}

HRESULT CStreamAudioSend::SetUpFilters()
/*++

Routine Description:

    Insert filters into the graph and connect to the terminals.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "AudioSend SetUpFilters"));

    // we only support one terminal for this stream.
    if (m_Terminals.GetSize() != 1)
    {
        return E_UNEXPECTED;
    }

    HRESULT hr;

    // Connect the terminal to the rest of the stream.
    if (FAILED(hr = ConnectTerminal(
        m_Terminals[0]
        )))
    {
        LOG((MSP_ERROR, "connect the terminal to the filters. %x", hr));

        return hr;
    }
    return hr;
}

HRESULT CStreamAudioSend::ConfigureRTPFilter(
    IN  IBaseFilter *   pIBaseFilter
    )
/*++

Routine Description:

    Configure the source RTP filter. Including set the address, port, TTL,
    QOS, thread priority, clcokrate, etc.

Arguments:
    
    pIBaseFilter - The source RTP Filter.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "AudioSend ConfigureRTPFilter"));

    HRESULT hr;

    // Get the IRTPStream interface pointer on the filter.
    CComQIPtr<IRTPStream, &IID_IRTPStream> pIRTPStream(pIBaseFilter);
    if (pIRTPStream == NULL)
    {
        LOG((MSP_ERROR, "get IRTPStream interface"));
        return E_NOINTERFACE;
    }

    LOG((MSP_INFO, "set remote Address:%x, port:%d, TTL:%d", 
        m_Settings.dwIPRemote, m_Settings.wRTPPortRemote, m_Settings.dwTTL));

    // Set the remote address and port used in the filter.
    if (FAILED(hr = pIRTPStream->SetAddress(
        0,                                  // local port.
        htons(m_Settings.wRTPPortRemote),   // remote port.
        htonl(m_Settings.dwIPRemote)
        )))
    {
        LOG((MSP_ERROR, "set remote Address, hr:%x", hr));
        return hr;
    }

    // Set the TTL used in the filter.
    if (FAILED(hr = pIRTPStream->SetMulticastScope(m_Settings.dwTTL)))
    {
        LOG((MSP_ERROR, "set TTL. %x", hr));
        return hr;
    }

    if (m_Settings.dwIPLocal != INADDR_ANY)
    {
        // set the local interface that the socket should bind to
        LOG((MSP_INFO, "set locol Address:%x", m_Settings.dwIPLocal));

        if (FAILED(hr = pIRTPStream->SelectLocalIPAddress(
            htonl(m_Settings.dwIPLocal)
            )))
        {
            LOG((MSP_ERROR, "set local Address, hr:%x", hr));
            return hr;
        }
    }
    // Set the priority of the session
    if (FAILED(hr = pIRTPStream->SetSessionClassPriority(
        RTP_CLASS_AUDIO,
        g_dwAudioThreadPriority
        )))
    {
        LOG((MSP_WARN, "set session class and priority. %x", hr));
    }

    // Set the sample rate of the session
    LOG((MSP_INFO, "setting session sample rate to %d", m_dwAudioSampleRate));
    
    if (FAILED(hr = pIRTPStream->SetDataClock(m_dwAudioSampleRate)))
    {
        LOG((MSP_WARN, "set session sample rate. %x", hr));
    }

    // Enable the RTCP events
    if (FAILED(hr = ::EnableRTCPEvents(pIBaseFilter)))
    {
        LOG((MSP_WARN, "can not enable RTCP events %x", hr));
    }

    if (m_Settings.dwQOSLevel != QSL_BEST_EFFORT)
    {
        if (FAILED(hr = ::SetQOSOption(
            pIBaseFilter,
            m_Settings.dwPayloadType,        // payload
            -1,                             // use the default bitrate 
            (m_Settings.dwQOSLevel == QSL_NEEDED)  // fail if no qos.
            )))
        {
            LOG((MSP_ERROR, "set QOS option. %x", hr));
            return hr;
        }
    }

    SetLocalInfoOnRTPFilter(pIBaseFilter);
    
    return S_OK;
}

HRESULT CStreamAudioSend::CreateSendFilters(
    IN    IPin          *pPin
    )
/*++

Routine Description:

    Insert filters into the graph and connect to the capture pin.

    Capturepin->SilenceSuppressor->Encoder->SPH->RTPRender

Arguments:
    
    pPin - The output pin on the capture filter.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "AudioSend.CreateSendFilters"));

    HRESULT hr;

    // if the the internal filters have been created before, just
    // connect the terminal to the first filter in the chain.
    if (m_pEdgeFilter != NULL)
    {
        if (FAILED(hr = ::ConnectFilters(
            m_pIGraphBuilder,
            pPin, 
            (IBaseFilter *)m_pEdgeFilter
            )))
        {
            LOG((MSP_ERROR, "connect capture and ss %x", hr));
            return hr;
        }
        return hr;
    }

    // Create the silence suppression filter and add it into the graph. 
    CComPtr<IBaseFilter> pISSFilter;

    if (FAILED(hr = ::AddFilter(
        m_pIGraphBuilder,
        CLSID_SilenceSuppressionFilter, 
        L"SS", 
        &pISSFilter
        )))
    {
        LOG((MSP_ERROR, "can't add SS filter, %x", hr));
        return hr;
    }

    DWORD dwAGC = 0;
    if (FALSE == ::GetRegValue(L"AGC", &dwAGC) || dwAGC != 0)
    {
        // AGC is not disabled, just do it.
        CComQIPtr<ISilenceSuppressor, &IID_ISilenceSuppressor> 
            pISilcnecSuppressor(pISSFilter);
        if (pISilcnecSuppressor != NULL)
        {
            hr = pISilcnecSuppressor->EnableEvents(
                (1 << AGC_INCREASE_GAIN) | 
                (1 << AGC_DECREASE_GAIN) |
                (1 << AGC_TALKING) | 
                (1 << AGC_SILENCE),
                2000       // no more that an event every two seconds.
                );

            if (FAILED(hr))
            {
                LOG((MSP_WARN, "can't enable AGC events, %x", hr));
            }
        }
    }

    // connect the capture pin with the SS filter.
    if (FAILED(hr = ::ConnectFilters(
        m_pIGraphBuilder,
        pPin, 
        (IBaseFilter *)pISSFilter
        )))
    {
        LOG((MSP_ERROR, "connect capture and ss %x", hr));
        return hr;
    }

    // Create the codec filter and add it into the graph.
    CComPtr<IBaseFilter> pICodecFilter;

    if (m_fUseACM)
    {
        if (S_OK != (hr = ::FindACMAudioCodec(
            m_Settings.dwPayloadType,
            &pICodecFilter
            )))
        {
            LOG((MSP_ERROR, "Find Codec filter. %x", hr));
            return hr;
        }
    
        if (FAILED(hr = m_pIGraphBuilder->AddFilter(
            pICodecFilter, L"AudioCodec"
            )))
        {
            LOG((MSP_ERROR, "add codec filter. %x", hr));
            return hr;
        }
    }
    else
    {
        if (FAILED(hr = ::AddFilter(
                m_pIGraphBuilder,
                *m_pClsidCodecFilter, 
                L"Encoder", 
                &pICodecFilter)))
        {
            LOG((MSP_ERROR, "add Codec filter. %x", hr));
            return hr;
        }
    }

    // connect the SS filter and the Codec filter.
    if (FAILED(hr = ::ConnectFilters(
        m_pIGraphBuilder,
        (IBaseFilter *)pISSFilter, 
        (IBaseFilter *)pICodecFilter
        )))
    {
        LOG((MSP_ERROR, "connect ss filter and codec filter. %x", hr));
        return hr;
    }

    // Create the send payload handler and add it into the graph.
    CComPtr<IBaseFilter> pISPHFilter;
    if (FAILED(hr = ::AddFilter(
        m_pIGraphBuilder,
        *m_pClsidPHFilter, 
        L"SPH", 
        &pISPHFilter
        )))
    {
        LOG((MSP_ERROR, "add SPH filter. %x", hr));
        return hr;
    }

    // Get the IRTPSPHFilter interface.
    CComQIPtr<IRTPSPHFilter, 
        &IID_IRTPSPHFilter> pIRTPSPHFilter(pISPHFilter);
    if (pIRTPSPHFilter == NULL)
    {
        LOG((MSP_ERROR, "get IRTPSPHFilter interface"));
        return E_NOINTERFACE;
    }

    // Set the packetSize.
    if (FAILED(hr= pIRTPSPHFilter->SetMaxPacketSize(m_dwMaxPacketSize)))
    {
        LOG((MSP_ERROR, "set SPH filter Max packet size: %d hr: %x", 
            m_dwMaxPacketSize, hr));
        return hr;
    }

    if (FAILED(hr = pIRTPSPHFilter->OverridePayloadType(
        (BYTE)m_Settings.dwPayloadType
        )))
    {
        LOG((MSP_ERROR, "Set SPHGENA payload type. %x", hr));
        return hr;
    }

    // Connect the Codec filter with the SPH filter .
    if (FAILED(hr = ::ConnectFilters(
        m_pIGraphBuilder,
        (IBaseFilter *)pICodecFilter, 
        (IBaseFilter *)pISPHFilter
        )))
    {
        LOG((MSP_ERROR, "connect codec filter and SPH filter. %x", hr));
        return hr;
    }

    // Create the RTP render filter and add it into the graph.
    CComPtr<IBaseFilter> pRenderFilter;

    if (FAILED(hr = ::AddFilter(
            m_pIGraphBuilder,
            CLSID_RTPRenderFilter, 
            L"RtpRender", 
            &pRenderFilter)))
    {
        LOG((MSP_ERROR, "adding render filter. %x", hr));
        return hr;
    }

    // Set the address for the render fitler.
    if (FAILED(hr = ConfigureRTPFilter(pRenderFilter)))
    {
        LOG((MSP_ERROR, "set destination address. %x", hr));
        return hr;
    }

    // Connect the SPH filter with the RTP Render filter.
    if (FAILED(hr = ::ConnectFilters(
        m_pIGraphBuilder,
        (IBaseFilter *)pISPHFilter, 
        (IBaseFilter *)pRenderFilter
        )))
    {
        LOG((MSP_ERROR, "connect SPH filter and Render filter. %x", hr));
        return hr;
    }

    // remember the first filter after the terminal 
    m_pEdgeFilter = pISSFilter;
    m_pEdgeFilter->AddRef();

    // Get the IRTPParticipant interface pointer on the RTP filter.
    CComQIPtr<IRTPParticipant, 
        &IID_IRTPParticipant> pIRTPParticipant(pRenderFilter);
    if (pIRTPParticipant == NULL)
    {
        LOG((MSP_WARN, "can't get RTP participant interface"));
    }
    else
    {
        m_pRTPFilter = pIRTPParticipant;
        m_pRTPFilter->AddRef();
    }

    return S_OK;
}

HRESULT AdjustGain(
    IN  IUnknown *  pIUnknown,
    IN  long        lPercent
    )
/*++

Routine Description:

    This function uses IAMAudioInputMixer interface to adjust the gain.

Arguments:

    pIUnknown - the object that supports IAMAudioInputMixer

    lPercent - the adjustment, a negative value means decrease.

Return Value:

    S_OK,
    E_NOINTERFACE,
    E_UNEXPECTED

--*/
{
    CComPtr <IAMAudioInputMixer> pMixer;
    HRESULT hr = pIUnknown->QueryInterface(
        IID_IAMAudioInputMixer, (void **)&pMixer
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get IAMAudioInputMixer interface."));
        return hr;
    }
    
    BOOL fEnabled;
    hr = pMixer->get_Enable(&fEnabled);
    if (SUCCEEDED(hr) && !fEnabled)
    {
        return S_OK;
    }

    double MixLevel;
    hr = pMixer->get_MixLevel(&MixLevel);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get_MixLevel returned %d", hr));
        return hr;
    }

    LOG((MSP_INFO, "get_MixLevel returned %d", hr));
    MixLevel = MixLevel * (100 + lPercent) / 100;

    hr = pMixer->put_MixLevel(MixLevel);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "put_MixLevel returned %d", hr));
        return hr;
    }

    return S_OK;
}

HRESULT CStreamAudioSend::ProcessAGCEvent(
    IN  AGC_EVENT   Event,
    IN  long        lPercent
    )
/*++

Routine Description:

    The filters fire AGC events to requste a change in the microphone gain.
    This function finds the capture terminal and adjust the gain on it.

Arguments:

    Event - either AGC_INCREASE_GAIN or AGC_DECREASE_GAIN.

Return Value:

    S_OK,
    E_UNEXPECTED

--*/
{
    LOG((MSP_TRACE, "ProcessAGCEvent %s %d percent", 
        (Event == AGC_INCREASE_GAIN) ? "Increase" : "Decrease",
        lPercent
        ));

    _ASSERTE(lPercent > 0 && lPercent <= 100);

    CLock lock(m_lock);
    if (m_pEdgeFilter == NULL)
    {
        LOG((MSP_ERROR, "No filter to adjust gain."));
        return E_UNEXPECTED;
    }

    CComPtr<IPin> pMyPin, pCapturePin;

    // find the first pin in the stream
    HRESULT hr = ::FindPin(m_pEdgeFilter, &pMyPin, PINDIR_INPUT, FALSE);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get find the first pin the stream, %x", hr));
        return hr;
    }

    // find the capture pin that connects to our first pin.
    hr = pMyPin->ConnectedTo(&pCapturePin);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't find the capture pin, %x", hr));
        return hr;
    }

    // find the filter that has the capture pin.
    PIN_INFO PinInfo;
    hr = pCapturePin->QueryPinInfo(&PinInfo);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't find the capture filter, %x", hr));
        return hr;
    }

    // save the filter pointer.
    CComPtr<IBaseFilter> pICaptureFilter = PinInfo.pFilter;
    PinInfo.pFilter->Release();

    // get the amount to adjust.
    if (Event == AGC_DECREASE_GAIN)
    {
        lPercent = -lPercent;
    }

    AdjustGain(pICaptureFilter, lPercent);

    // Get the enumerator of pins on the filter.
    CComPtr<IEnumPins> pIEnumPins;
    if (FAILED(hr = pICaptureFilter->EnumPins(&pIEnumPins)))
    {
        LOG((MSP_ERROR, "enumerate pins on the filter %x", hr));
        return hr;
    }

    // Enumerate all the pins and adjust gains on each active one.
    for (;;)
    {
        CComPtr<IPin> pIPin;
        DWORD dwFeched;
        if (pIEnumPins->Next(1, &pIPin, &dwFeched) != S_OK)
        {
            LOG((MSP_ERROR, "find pin on filter."));
            break;
        }
        
        AdjustGain(pIPin, lPercent);
    }
    
    return hr;
}

HRESULT CStreamAudioSend::ProcessGraphEvent(
    IN  long lEventCode,
    IN  long lParam1,
    IN  long lParam2
    )
{
    LOG((MSP_TRACE, "%ws ProcessGraphEvent %d", m_szName, lEventCode));

    switch (lEventCode)
    {
    case AGC_EVENTBASE + AGC_INCREASE_GAIN:
        
        ProcessAGCEvent(AGC_INCREASE_GAIN, lParam1);

        break;

    case AGC_EVENTBASE + AGC_DECREASE_GAIN:

        ProcessAGCEvent(AGC_DECREASE_GAIN, lParam1);

        break;

    case AGC_EVENTBASE + AGC_TALKING:

        m_lock.Lock();

        if (m_pMSPCall != NULL)
        {
            ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
                PE_LOCAL_TALKING, 
                NULL
                );
        }

        m_lock.Unlock();

        break;

    case AGC_EVENTBASE + AGC_SILENCE:

        m_lock.Lock();

        if (m_pMSPCall != NULL)
        {
            ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
                PE_LOCAL_SILENT, 
                NULL
                );
        }

        m_lock.Unlock();

        break;
    default:
        return CIPConfMSPStream::ProcessGraphEvent(
            lEventCode, lParam1, lParam2
            );
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\confmsp\confpart.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    Confpart.h

Abstract:

    Definitions for participant related classes..

Author:

    Mu Han (muhan) 30-September-1998

--*/
#ifndef __CONFPART_H
#define __CONFPART_H

const DWORD PART_SEND = 0x0001;
const DWORD PART_RECV = 0x0002;

typedef struct _STREAM_INFO
{
    DWORD       dwSSRC;
    DWORD       dwSendRecv;

} STREAM_INFO;

class ATL_NO_VTABLE CParticipant : 
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public IDispatchImpl<ITParticipant, &IID_ITParticipant, &LIBID_IPConfMSPLib>,
    public CMSPObjectSafetyImpl
{
public:

BEGIN_COM_MAP(CParticipant)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITParticipant)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

DECLARE_GET_CONTROLLING_UNKNOWN()

#ifdef DEBUG_REFCOUNT
    
    ULONG InternalAddRef();
    ULONG InternalRelease();

#endif

    CParticipant(); 

// methods of the CComObject
    virtual void FinalRelease();

// ITParticipant methods, called by the app.
    STDMETHOD (get_ParticipantTypedInfo) (
        IN  PARTICIPANT_TYPED_INFO  InfoType,
        OUT BSTR *                  ppInfo
        );

    STDMETHOD (get_MediaTypes) (
//        IN  TERMINAL_DIRECTION  Direction,
        OUT long *              plMediaTypes
        );

    STDMETHOD (put_Status) (
        IN  ITStream *          pITStream,
        IN  VARIANT_BOOL        fEnable
        );

    STDMETHOD (get_Status) (
        IN  ITStream *          pITStream,
        OUT VARIANT_BOOL *      pStatus
        );

    STDMETHOD (get_Streams) (
        OUT VARIANT * pVariant
        );

    STDMETHOD (EnumerateStreams) (
        OUT IEnumStream ** ppEnumStream
        );

// methods called by the call object.
    HRESULT Init(
        IN  char *              szCName,
        IN  ITStream *          pITStream, 
        IN  DWORD               dwSSRC,
        IN  DWORD               dwSendRecv,
        IN  DWORD               dwMediaType
        );

    BOOL UpdateInfo(
        IN  int                 Type,
        IN  DWORD               dwLen,
        IN  char *              szInfo
        );

    BOOL UpdateSSRC(
        IN  ITStream *      pITStream, 
        IN  DWORD           dwSSRC,
        IN  DWORD           dwSendRecv
        );

    BOOL HasSSRC(
        IN  ITStream *      pITStream, 
        IN  DWORD           dwSSRC
        );

    BOOL GetSSRC(
        IN  ITStream *      pITStream, 
        OUT DWORD  *        pdwSSRC
        );

    HRESULT AddStream(
        IN  ITStream *          pITStream, 
        IN  DWORD               dwSSRC,
        IN  DWORD               dwSendRecv,
        IN  DWORD               dwMediaType
        );

    HRESULT RemoveStream(
        IN  ITStream *          pITStream,
        IN  DWORD               dwSSRC,
        OUT BOOL *              pbLast
        );

    DWORD GetSendRecvStatus(
        IN  ITStream *          pITStream
        );

    int CompareCName(IN  const char *   szCName) const
    { return lstrcmpA(m_InfoItems[RTCP_SDES_CNAME - 1], szCName); }

protected:
    // Pointer to the free threaded marshaler.
    IUnknown *                  m_pFTM;

    // The lock that protects the participant object. 
    CMSPCritSection             m_lock;

    // The list of streams that the participant is rendering on.
    CMSPArray <ITStream *>      m_Streams;

    // The list of SSRC for the partcipant in each stream.
    CMSPArray <STREAM_INFO>     m_StreamInfo;

    // the information items for this participant. The index is the 
    // value of RTCP_SDES_TYPE_T - 1, see RTP.h.
    char *                      m_InfoItems[RTCP_SDES_LAST - 1];

    // The media types that this participant is sending.
    DWORD                       m_dwSendingMediaTypes;

    // The media types that this participant is receiving.
    DWORD                       m_dwReceivingMediaTypes;
};

class CParticipantList : public CMSPArray<ITParticipant *>
{
public:
    BOOL HasSpace() const { return m_nSize < m_nAllocSize; }

    BOOL FindByCName(char *szCName, int *pIndex) const;

    BOOL InsertAt(int index, ITParticipant *pITParticipant);
};

class ATL_NO_VTABLE CParticipantEvent : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<ITParticipantEvent, &IID_ITParticipantEvent, &LIBID_IPConfMSPLib>,
    public CMSPObjectSafetyImpl
{
public:

BEGIN_COM_MAP(CParticipantEvent)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITParticipantEvent)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

DECLARE_GET_CONTROLLING_UNKNOWN()

    CParticipantEvent(); 

// methods of the CComObject
    virtual void FinalRelease();
    
    STDMETHOD (get_Event) (
        OUT PARTICIPANT_EVENT * pParticipantEvent
        );
    
    STDMETHOD (get_Participant) (
        OUT ITParticipant ** ppITParticipant
        );
    
    STDMETHOD (get_SubStream) (
        OUT ITSubStream** ppSubStream
        );

// methods called by the call object.
    HRESULT Init(
        IN  PARTICIPANT_EVENT   Event,
        IN  ITParticipant *     pITParticipant,
        IN  ITSubStream *       pITSubStream
        );

protected:
    // Pointer to the free threaded marshaler.
    IUnknown *          m_pFTM;

    PARTICIPANT_EVENT   m_Event;

    ITParticipant *     m_pITParticipant;

    ITSubStream *       m_pITSubStream;
};


class CIPConfMSPCall;

HRESULT CreateParticipantEvent(
    IN  PARTICIPANT_EVENT       Event,
    IN  ITParticipant *         pITParticipant,
    IN  ITSubStream *           pITSubStream,
    OUT IDispatch **            pIDispatch
    );

HRESULT CreateParticipantEnumerator(
    IN  ITParticipant **    begin,
    IN  ITParticipant **    end,
    OUT IEnumParticipant ** ppEnumParticipant
    );

HRESULT CreateParticipantCollection(
    IN  ITParticipant **    begin,
    IN  ITParticipant **    end,
    IN  int                 nSize,
    OUT VARIANT *           pVariant
    );

#endif // __CONFPART_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\confmsp\confaud.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    Confaud.h

Abstract:

    Definitions for audio streams

Author:

    Mu Han (muhan) 15-September-1998

--*/
#ifndef __CONFAUD_H_
#define __CONFAUD_H_

#include <amrtpdmx.h>   // demux guid
#include <amrtpss.h>    // AGC events

#define USE_WIDEBAND_CODEC 1

const DWORD g_dwMaxAudioPacketDuration      = 80;

const DWORD g_dwAudioThreadPriority         = THREAD_PRIORITY_TIME_CRITICAL;
const WORD  g_wAudioDemuxPins               = 5;  
const WORD  g_wAudioChannels                = 1;  
const DWORD g_wAudioCaptureBitPerSample     = 16;  
const DWORD g_dwAudioCaptureNumBufffers     = 32;  
const DWORD g_dwRTPHeaderSize               = 12; 

const DWORD g_dwG711MSPerPacket             = 30;   // 30ms samples.
const DWORD g_dwG711BytesPerPacket          = 240;  // 30ms samples.
const DWORD g_dwG711AudioSampleRate         = 8000;  
const DWORD g_dwMaxG711PacketSize    = 
    g_dwMaxAudioPacketDuration * g_dwG711BytesPerPacket / g_dwG711MSPerPacket
    + g_dwRTPHeaderSize;

const DWORD g_dwGSMMSPerPacket              = 40;   // 40ms samples.
const DWORD g_dwGSMBytesPerPacket           = 65;   // 40ms samples.
const DWORD g_dwGSMAudioSampleRate          = 8000;  
const WORD  g_wGSMBlockAlignment            = 65;   // 40ms samples.
const DWORD g_dwGSMBytesPerSecond           = 
    g_dwGSMBytesPerPacket * 1000 / g_dwGSMMSPerPacket;

const DWORD g_wGSMSamplesPerBlock           = 
    g_dwGSMMSPerPacket * g_dwGSMAudioSampleRate / 1000;
const DWORD g_dwMaxGSMPacketSize    = 
    g_dwMaxAudioPacketDuration / g_dwGSMMSPerPacket * g_dwGSMBytesPerPacket
    + g_dwRTPHeaderSize;

#ifdef DVI

const DWORD g_dwDVI4MSPerPacket             = 80;   // 80 ms samples.
const WORD  g_wDVI4BlockAlignment           = 324; 
const DWORD g_dwDVI4BytesPerPacket          = g_wDVI4BlockAlignment;
const DWORD g_wDVI4BitsPerSample            = 4;
const DWORD g_dwDVI4AudioSampleRate         = 8000;  
const DWORD g_dwMaxDVI4PacketSize           = g_dwDVI4BytesPerPacket + g_dwRTPHeaderSize;
const DWORD g_dwDVI4BytesPerSecond          = 4000; // ignore header here.
const DWORD g_wDVI4SamplesPerBlock          = 
    (g_wDVI4BlockAlignment - 4) * 8 / g_wDVI4BitsPerSample + 1;

#endif
 
// MSAudio defines
#define WAVE_FORMAT_MSAUDIO1	0x0160
typedef struct msaudio1waveformat_tag {
        WAVEFORMATEX    wfx;

        //only counting "new" samples "= half of what will be used due to overlapping
        WORD            wSamplesPerBlock;	

} MSAUDIO1WAVEFORMAT;

#define MSAUDIO1_BITS_PER_SAMPLE	0
#define MSAUDIO1_MAX_CHANNELS		1
#define MSAUDIO1_WFX_EXTRA_BYTES    2

#ifdef USE_WIDEBAND_CODEC
// At 16kHz, 
#define FRAME_TIME 64
#define PACKET_SIZE 64
#define BYTES_PER_SECOND 1920
#define SAMPLES_PER_BLOCK 512
#else
// At 8kHz, 
#define FRAME_TIME 64
#define PACKET_SIZE 32
#define BYTES_PER_SECOND 960
#define SAMPLES_PER_BLOCK 256
#endif

const DWORD g_dwMSAudioMSPerPacket              = FRAME_TIME; // This will make sure that we always capture 1024 byte PCM16 buffers (at 8kHz: 512 samples = 64ms, at 16kHz: 512 samples = 32ms)
const DWORD g_dwMSAudioBytesPerPacket           = PACKET_SIZE; // The MS Audio codec will only use 512 bytes of an PCM16 input buffer of size 1024 bytes and generate a 32 bytes frame
const DWORD g_dwMSAudioSampleRate               = 16000;  
const WORD  g_wMSAudioBlockAlignment            = PACKET_SIZE; // 32 bytes of block alignment.
const DWORD g_dwMSAudioBytesPerSecond           = BYTES_PER_SECOND; // 8kHz: Measurements show that a 8000 samples buffer is compressed to 960 bytes
const WORD  g_wMSAudioExtraDataSize             = 2;
const DWORD g_wMSAudioSamplesPerBlock           = SAMPLES_PER_BLOCK;

// We only care to be able to send and receive MSAudio packets that contain 64ms worth of data.
const DWORD g_dwMaxMSAudioPacketSize = g_dwMSAudioBytesPerPacket + g_dwRTPHeaderSize; // 8kHz: 32 + 12 bytes

inline DWORD AudioCaptureBufferSize(DWORD dwMillisecondPerPacket, DWORD dwAudioSampleRate)
{ 
    return dwMillisecondPerPacket 
    * (dwAudioSampleRate / 1000) 
    * (g_wAudioCaptureBitPerSample / 8);
}

class ATL_NO_VTABLE CStreamAudioRecv : 
    public CIPConfMSPStream
{
public:

    CStreamAudioRecv();

    void FinalRelease();

    HRESULT Configure(
        IN      STREAMSETTINGS &    StreamSettings
        );

protected:
    HRESULT SetUpFilters();

    HRESULT ConfigureRTPFilter(
        IN      IBaseFilter *       pIBaseFilter
        );

    HRESULT SetUpInternalFilters();

    HRESULT ConnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT ProcessSSRCMappedEvent(
        IN  DWORD   dwSSRC
        );

    HRESULT ProcessSSRCUnmapEvent(
        IN  DWORD   dwSSRC
        );

    HRESULT ProcessGraphEvent(
        IN  long lEventCode,
        IN  long lParam1,
        IN  long lParam2
        );

    HRESULT ProcessParticipantLeave(
        IN  DWORD   dwSSRC
        );

    HRESULT NewParticipantPostProcess(
        IN  DWORD dwSSRC, 
        IN  ITParticipant *pITParticipant
        );

protected:

    BOOL        m_fUseACM;
    DWORD       m_dwMaxPacketSize;
    DWORD       m_dwAudioSampleRate;

    BYTE *      m_pWaveFormatEx;
    DWORD       m_dwSizeWaveFormatEx;

    // a small buffer to queue up pin mapped events.
    CMSPArray <DWORD>       m_PendingSSRCs;
};

class ATL_NO_VTABLE CStreamAudioSend : public CIPConfMSPStream
{
public:
    CStreamAudioSend();

    virtual HRESULT Configure(
        IN STREAMSETTINGS &StreamSettings
        );

protected:

    HRESULT SetUpFilters();

    HRESULT ConnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT CreateSendFilters(
        IN    IPin          *pPin
        );

    HRESULT ConfigureRTPFilter(
        IN  IBaseFilter *   pIBaseFilter
        );

    HRESULT ConfigureAudioCaptureTerminal(
        IN   ITTerminalControl *    pTerminal,
        OUT  IPin **                ppIPin
        );

    HRESULT ProcessAGCEvent(
        IN  AGC_EVENT   Event,
        IN  long        lPercent
        );

    HRESULT ProcessGraphEvent(
        IN  long lEventCode,
        IN  long lParam1,
        IN  long lParam2
        );
protected:

    BOOL        m_fUseACM;
    int         m_iACMID;
    DWORD       m_dwMSPerPacket;
    DWORD       m_dwMaxPacketSize;
    DWORD       m_dwAudioSampleRate;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\confmsp\confpart.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    confpart.cpp

Abstract:

    This module contains implementation of the participant classes.

Author:

    Mu Han (muhan)   15-September-1999

--*/

#include "stdafx.h"
#include "common.h"
#include "confpart.h"

#ifdef DEBUG_REFCOUNT

ULONG CParticipant::InternalAddRef()
{
    ULONG lRef = CComObjectRootEx<CComMultiThreadModelNoCS>::InternalAddRef();

    LOG((MSP_TRACE, "%p, %s Addref, ref = %d", 
        this, (m_InfoItems[0]) ? m_InfoItems[0] : "new participant", lRef));

    return lRef;
}

ULONG CParticipant::InternalRelease()
{
    ULONG lRef = CComObjectRootEx<CComMultiThreadModelNoCS>::InternalRelease();
    
    LOG((MSP_TRACE, "%p, %s Release, ref = %d", 
        this, (m_InfoItems[0]) ? m_InfoItems[0] : "new participant", lRef));

    return lRef;
}
#endif

CParticipant::CParticipant()
    : m_pFTM(NULL),
      m_dwSendingMediaTypes(0),
      m_dwReceivingMediaTypes(0)
{
    // initialize the info item array.
    ZeroMemory(m_InfoItems, sizeof(char *) * (RTCP_SDES_LAST - 1));
}

// methods called by the call object.
HRESULT CParticipant::Init(
    IN  char *              szCName,
    IN  ITStream *          pITStream, 
    IN  DWORD               dwSSRC,
    IN  DWORD               dwSendRecv,
    IN  DWORD               dwMediaType
    )
/*++

Routine Description:

    Initialize the participant object.

Arguments:
    
    szCName - the canonical name of the participant.

    pITStream - the stream that has the participant.

    dwSSRC - the SSRC of the participant in that stream.

    dwSendRecv - a sender or a receiver.

    dwMediaType - the media type of the participant.

Return Value:

    S_OK,
    E_OUTOFMEMORY.

--*/
{
    LOG((MSP_TRACE, "CParticipant::Init, name:%s", szCName));

    // create the marshaler.
    HRESULT hr;
    hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), &m_pFTM);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "create marshaler failed, %x", hr));
        return hr;
    }

    m_InfoItems[0] = (char *)malloc(lstrlenA(szCName) + 1);
    if (m_InfoItems[0] == NULL)
    {
        LOG((MSP_ERROR, "out of mem for CName"));
        return E_OUTOFMEMORY;
    }

    lstrcpyA(m_InfoItems[0], szCName);

    // add the stream into out list.
    hr = AddStream(pITStream, dwSSRC, dwSendRecv, dwMediaType);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "failed to add stream %x", hr));
        return hr;
    }

    LOG((MSP_TRACE, "CParticipant: %s, Init returns S_OK", szCName));
    return S_OK;
}

BOOL CParticipant::UpdateInfo(
    IN  int                 Type,
    IN  DWORD               dwLen,
    IN  char *              szInfo
    )
/*++

Routine Description:

    Update one item of the participant info.

Arguments:
    
    Type - the type of the INFO, 
    
    dwLen - the length of the information.

    szInfo - the information.

Return Value:

    TRUE - information changed.

    FALSE - the information is the same, no change was made.

--*/
{
    int index = Type - 1;

    // if we have an item already, find out if it is the same.
    if (m_InfoItems[index] != NULL)
    {
        if (lstrcmpA(m_InfoItems[index], szInfo) == 0)
        {
            return FALSE;
        }

        // if the item is new, free the old one
        free(m_InfoItems[index]);
    }

    // allocate memory and store it.
    m_InfoItems[index] = (char *)malloc(dwLen + 1);
    if (m_InfoItems[index] == NULL)
    {
        return FALSE;
    }

    lstrcpynA(m_InfoItems[index], szInfo, dwLen);

    return TRUE;
}

BOOL CParticipant::UpdateSSRC(
    IN  ITStream *      pITStream, 
    IN  DWORD           dwSSRC,
    IN  DWORD           dwSendRecv
    )
/*++

Routine Description:

    Update the SSRC for a stream.

Arguments:
    
    pITStream - the stream that the participant is on.

    dwSSRC - the SSRC of the participant.

    dwSendRecv - the participant is a sender or a receiver.

Return Value:

    TRUE - information changed.

    FALSE - the stream is not found.

--*/
{
    CLock lock(m_lock);

    // if the stream is already there, update the SSRC and return.
    int index = m_Streams.Find(pITStream);
    if ( index >= 0)
    {
        m_StreamInfo[index].dwSSRC  = dwSSRC;
        m_StreamInfo[index].dwSendRecv |= dwSendRecv;
        return TRUE;
    }

    return FALSE;
}

BOOL CParticipant::HasSSRC(
    IN  ITStream *      pITStream, 
    IN  DWORD           dwSSRC
    )
/*++

Routine Description:

    find out if the participant has the SSRC for a stream.

Arguments:
    
    pITStream - the stream that the participant is on.

    dwSSRC - the SSRC of the participant.

Return Value:

    TRUE - the SSRC exists.

    FALSE - the SSRC does not exist.

--*/
{
    CLock lock(m_lock);

    int index = m_Streams.Find(pITStream);
    if (index >= 0)
    {
        return (m_StreamInfo[index].dwSSRC == dwSSRC);
    }

    return FALSE;
}

BOOL CParticipant::GetSSRC(
    IN  ITStream *      pITStream, 
    OUT DWORD  *        pdwSSRC
    )
/*++

Routine Description:

    Update the SSRC for a stream.

Arguments:
    
    pITStream - the stream that the participant is on.

    pdwSSRC - the address to store the SSRC of the participant.

Return Value:

    TRUE - the SSRC is found.

    FALSE - the SSRC is not found.

--*/
{
    CLock lock(m_lock);

    // if the stream is already there, update the SSRC and return.
    int index = m_Streams.Find(pITStream);
    if ( index >= 0)
    {
        *pdwSSRC = m_StreamInfo[index].dwSSRC;
        return TRUE;
    }

    return FALSE;
}

DWORD CParticipant::GetSendRecvStatus(
    IN  ITStream *      pITStream
    )
/*++

Routine Description:

    find out the current send and recv status on a given stream.

Arguments:
    
    pITStream - the stream that the participant is on.

Return Value:

    A bit mask of send and receive status

--*/
{
    CLock lock(m_lock);

    int index = m_Streams.Find(pITStream);
    if (index >= 0)
    {
        return m_StreamInfo[index].dwSendRecv;
    }

    return 0;
}

void CParticipant::FinalRelease()
/*++

Routine Description:

    release everything before being deleted. 

Arguments:
    
Return Value:

--*/
{
    LOG((MSP_TRACE, "CParticipant::FinalRelease, name %s", m_InfoItems[0]));

    if (m_pFTM)
    {
        m_pFTM->Release();
    }
    
    for (int i = 0; i < RTCP_SDES_LAST - 1; i ++)
    {
        if (m_InfoItems[i])
        {
            free(m_InfoItems[i]);
        }
    }

    for (i = 0; i < m_Streams.GetSize(); i ++)
    {
        m_Streams[i]->Release();
    }
    m_Streams.RemoveAll();

    LOG((MSP_TRACE, "CParticipant::FinalRelease - exit"));
}


// ITParticipant methods, called by the app.
STDMETHODIMP CParticipant::get_ParticipantTypedInfo(
    IN  PARTICIPANT_TYPED_INFO  InfoType,
    OUT BSTR *                  ppInfo
    )
/*++

Routine Description:

    Get a information item for this participant.

Arguments:
    
    InfoType - The type of the information asked.

    ppInfo  - the mem address to store a BSTR.

Return Value:

    S_OK,
    E_INVALIDARG,
    E_POINTER,
    E_OUTOFMEMORY,
    TAPI_E_NOITEMS
*/
{
    LOG((MSP_TRACE, "CParticipant get info, type:%d", InfoType));
    
    if (InfoType > PTI_PRIVATE || InfoType < 0)
    {
        LOG((MSP_ERROR, "CParticipant get info - exit invalid arg"));
        return E_INVALIDARG;
    }

    if (IsBadWritePtr(ppInfo, sizeof(BSTR)))
    {
        LOG((MSP_ERROR, "CParticipant get info - exit E_POINTER"));
        return E_POINTER;
    }

    // check if we have that info.
    CLock lock(m_lock);
    
    int index = (int)InfoType; 
    if (m_InfoItems[index] == NULL)
    {
        LOG((MSP_INFO, "CParticipant get info - no item for %d", InfoType));
        return TAPI_E_NOITEMS;
    }

    // conver the char string to WCHAR string.
    WCHAR Buffer[RTP_MAX_SDES + 1];
    
    if (!MultiByteToWideChar(
        GetACP(),
        0,
        m_InfoItems[index],
        -1,
        Buffer,
        RTP_MAX_SDES
        ))
    {
        LOG((MSP_ERROR, "coverting failed, error:%x", GetLastError()));
        return E_FAIL;
    }

    // make a BSTR out of it.
    BSTR pName = SysAllocString(Buffer);

    if (pName == NULL)
    {
        LOG((MSP_ERROR, "CParticipant get info - exit out of mem"));
        return E_OUTOFMEMORY;
    }

    // return the BSTR.
    *ppInfo = pName;

    return S_OK; 
}

STDMETHODIMP CParticipant::get_MediaTypes(
//    IN  TERMINAL_DIRECTION  Direction,
    OUT long *  plMediaTypes
    )
/*++

Routine Description:

    Get the media type of the participant

Arguments:
    
    plMediaType - the mem address to store a long.

Return Value:

    S_OK,
    E_POINTER,
*/
{
    LOG((MSP_TRACE, "CParticipant::get_MediaTypes - enter"));

    if (IsBadWritePtr(plMediaTypes, sizeof (long)))
    {
        LOG((MSP_ERROR, "CParticipant::get_MediaType - exit E_POINTER"));

        return E_POINTER;
    }

    CLock lock(m_lock);

#if 0
    if (Direction == TD_RENDER)
    {
        *plMediaTypes = (long)m_dwReceivingMediaTypes;
    }
    else
    {
        *plMediaTypes = (long)m_dwSendingMediaTypes;
    }
#endif

    *plMediaTypes = (long)(m_dwSendingMediaTypes | m_dwReceivingMediaTypes);

    LOG((MSP_TRACE, "CParticipant::get_MediaType:%x - exit S_OK", *plMediaTypes));

    return S_OK;
}


STDMETHODIMP CParticipant::put_Status(
    IN  ITStream *      pITStream,
    IN  VARIANT_BOOL    fEnable
    )
{
/* this is a new feature, we still can not really control the participant.
    LOG((MSP_TRACE, "CParticipant::put_Status, pITStream %p, status %hs",
        pITStream, fEnable ? "Enable" : "Disable"
        ));

    HRESULT hr;

    // if the caller specified a stream, find the stream and use it.
    if (pITStream != NULL)
    {
        m_lock.Lock();

        int index;
        if ((index = m_Streams.Find(pITStream)) < 0)
        {
            m_lock.Unlock();
            
            LOG((MSP_ERROR, "CParticipant::put_Status, stream %p not found",
                pITStream,));

            return E_INVALIDARG;
        }
        
        // add ref so that it won't go away.
        pITStream->AddRef();

        m_lock.Unlock;

        hr = ((CIPConfMSPStream *)pITStream)->EnableParticipant(
            fEnable
            );

        pITStream->Release();

        return hr;
    }

    // if the caller didn't specify a stream, set the status on all streams.
    m_lock.Lock();
    int nSize = m_Streams.GetSize();
    ITStream ** Streams = (ITSTream **)malloc(sizeof(ITStream*) * nSize);

    if (Streams == NULL)
    {
        m_lock.Unlock();
        LOG((MSP_ERROR, "CParticipant::put_Status out of memory"));
        return E_OUTOFMEMORY;
    }

    for (int i = 0; i < nSize; i ++)
    {
        Streams[i] = m_Streams[i];
        Streams[i]->AddRef();
    }
    m_lock.Unlock();

    for (i = 0; i < nSize; i ++)
    {
        hr = Streams[i]->EnableParticipant(fEnable);

        if (FAILED(hr))
        {
            break;
        }
    }

    for (i = 0; i < nSize; i ++)
    {
        Streams[i]->Release();
    }
    free(Streams);

    return hr;
*/
    return E_NOTIMPL;
}

STDMETHODIMP CParticipant::get_Status(
    IN  ITStream *      pITStream,
    OUT VARIANT_BOOL *  pStatus
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP CParticipant::EnumerateStreams(
    OUT     IEnumStream **      ppEnumStream
    )
{
    LOG((MSP_TRACE, 
        "EnumerateStreams entered. ppEnumStream:%x", ppEnumStream));

    //
    // Check parameters.
    //

    if (IsBadWritePtr(ppEnumStream, sizeof(VOID *)))
    {
        LOG((MSP_ERROR, "CMSPCallBase::EnumerateStreams - "
            "bad pointer argument - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // First see if this call has been shut down.
    // acquire the lock before accessing the stream object list.
    //

    CLock lock(m_lock);

    if (m_Streams.GetData() == NULL)
    {
        LOG((MSP_ERROR, "CMSPCallBase::EnumerateStreams - "
            "call appears to have been shut down - exit E_UNEXPECTED"));

        // This call has been shut down.
        return E_UNEXPECTED;
    }

    //
    // Create an enumerator object.
    //

    typedef _CopyInterface<ITStream> CCopy;
    typedef CSafeComEnum<IEnumStream, &IID_IEnumStream, 
                ITStream *, CCopy> CEnumerator;

    HRESULT hr;

    CComObject<CEnumerator> *pEnum = NULL;

    hr = CComObject<CEnumerator>::CreateInstance(&pEnum);
    if (pEnum == NULL)
    {
        LOG((MSP_ERROR, "CMSPCallBase::EnumerateStreams - "
            "Could not create enumerator object, %x", hr));

        return hr;
    }

    //
    // query for the IID_IEnumStream i/f
    //

    hr = pEnum->_InternalQueryInterface(IID_IEnumStream, (void**)ppEnumStream);
    
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CMSPCallBase::EnumerateStreams - "
            "query enum interface failed, %x", hr));

        delete pEnum;
        return hr;
    }

    //
    // Init the enumerator object. The CSafeComEnum can handle zero-sized array.
    //

    hr = pEnum->Init(
        m_Streams.GetData(),                        // the begin itor
        m_Streams.GetData() + m_Streams.GetSize(),  // the end itor, 
        NULL,                                       // IUnknown
        AtlFlagCopy                                 // copy the data.
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CMSPCallBase::EnumerateStreams - "
            "init enumerator object failed, %x", hr));

        (*ppEnumStream)->Release();
        return hr;
    }

    LOG((MSP_TRACE, "CMSPCallBase::EnumerateStreams - exit S_OK"));

    return hr;
}

STDMETHODIMP CParticipant::get_Streams(
    OUT     VARIANT *           pVariant
    )
{
    LOG((MSP_TRACE, "CParticipant::get_Streams - enter"));

    //
    // Check parameters.
    //

    if ( IsBadWritePtr(pVariant, sizeof(VARIANT) ) )
    {
        LOG((MSP_ERROR, "CParticipant::get_Streams - "
            "bad pointer argument - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // See if this call has been shut down. Acquire the lock before accessing
    // the stream object list.
    //

    CLock lock(m_lock);

    if (m_Streams.GetData() == NULL)
    {
        LOG((MSP_ERROR, "CParticipant::get_Streams - "
            "call appears to have been shut down - exit E_UNEXPECTED"));

        // This call has been shut down.
        return E_UNEXPECTED;
    }

    //
    // create the collection object - see mspcoll.h
    //

    typedef CTapiIfCollection< ITStream * > StreamCollection;
    CComObject<StreamCollection> * pCollection;
    HRESULT hr = CComObject<StreamCollection>::CreateInstance( &pCollection );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CParticipant::get_Streams - "
            "can't create collection - exit 0x%08x", hr));

        return hr;
    }

    //
    // get the Collection's IDispatch interface
    //

    IDispatch * pDispatch;

    hr = pCollection->_InternalQueryInterface(IID_IDispatch,
                                              (void **) &pDispatch );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CParticipant::get_Streams - "
            "QI for IDispatch on collection failed - exit 0x%08x", hr));

        delete pCollection;

        return hr;
    }

    //
    // Init the collection using an iterator -- pointers to the beginning and
    // the ending element plus one.
    //

    hr = pCollection->Initialize( m_Streams.GetSize(),
                                  m_Streams.GetData(),
                                  m_Streams.GetData() + m_Streams.GetSize() );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CParticipant::get_Streams - "
            "Initialize on collection failed - exit 0x%08x", hr));
        
        pDispatch->Release();
        return hr;
    }

    //
    // put the IDispatch interface pointer into the variant
    //

    LOG((MSP_INFO, "CParticipant::get_Streams - "
        "placing IDispatch value %08x in variant", pDispatch));

    VariantInit(pVariant);
    pVariant->vt = VT_DISPATCH;
    pVariant->pdispVal = pDispatch;

    LOG((MSP_TRACE, "CParticipant::get_Streams - exit S_OK"));
    return S_OK;
}

HRESULT CParticipant::AddStream(
    IN  ITStream *      pITStream, 
    IN  DWORD           dwSSRC,
    IN  DWORD           dwSendRecv,
    IN  DWORD           dwMediaType
    )
/*++

Routine Description:

    A participant might appear on more than one streams. This function adds
    a new stream and the SSRC into the participant's list.

Arguments:
    
    pITStream - the stream that has the participant.

    dwSSRC - the SSRC of the participant in that stream.

    dwSendRecv - the participant is a sender or receiver in the stream.

    dwMediaType - the media type of the stream.

Return Value:

    S_OK,
    E_OUTOFMEMORY,
*/
{
    CLock lock(m_lock);

    // if the stream is already there, update the SSRC and return.
    int index = m_Streams.Find(pITStream);
    if ( index >= 0)
    {
        m_StreamInfo[index].dwSSRC = dwSSRC;
        m_StreamInfo[index].dwSendRecv |= dwSendRecv;
        return S_OK;
    }

    // add the stream.
    if (!m_Streams.Add(pITStream))
    {
        return E_OUTOFMEMORY;
    }
    
    // add the SSRC and sender flag.
    STREAM_INFO Info;
    Info.dwSSRC = dwSSRC;
    Info.dwSendRecv = dwSendRecv;

    if (!m_StreamInfo.Add(Info))
    {
        m_Streams.Remove(pITStream);

        return E_OUTOFMEMORY;
    }

    pITStream->AddRef();

    // update the mediatype.
    if (dwSendRecv & PART_SEND)
    {
        m_dwSendingMediaTypes |= dwMediaType;
    }
    if (dwSendRecv & PART_RECV)
    {
        m_dwReceivingMediaTypes |= dwMediaType;
    }

    return S_OK;
}

HRESULT CParticipant::RemoveStream(
    IN  ITStream *  pITStream,
    IN  DWORD       dwSSRC,
    OUT BOOL *      pbLast
    )
/*++

Routine Description:

    A participant might appear on more than one streams. This function remove
    a stream from the participant's list.

Arguments:
    
    pITStream - the stream that has the participant.

    dwSSRC - the SSRC of the participant in that stream.

    pbLast - the memory space to store a boolean value, specifying if the 
             stream removed was the last one in the list.

Return Value:

    S_OK,
    E_POINTER,
*/
{
    CLock lock(m_lock);
    
    // first find the stream.
    int index = m_Streams.Find(pITStream);

    if (index < 0)
    {
        return E_FAIL;
    }
    
    if (m_Streams.GetSize()  != m_StreamInfo.GetSize())
    {
        return E_UNEXPECTED;
    }

    // then check the SSRC.
    if (m_StreamInfo[index].dwSSRC != dwSSRC)
    {
        // this is not the participant being looking for.
        return E_FAIL;
    }

    // SSRC match, we found the participant. remove the stream and info.
    m_Streams.RemoveAt(index);
    m_StreamInfo.RemoveAt(index);

    // release the refcount we had in the list.
    pITStream->Release();

    // recalculate the media types.
    m_dwSendingMediaTypes = 0;
    m_dwReceivingMediaTypes = 0;
    
    for (int i = 0; i < m_Streams.GetSize(); i ++)
    {
        if (m_StreamInfo[i].dwSendRecv & PART_SEND)
        {
            m_dwSendingMediaTypes |= ((CIPConfMSPStream *)m_Streams[i])->MediaType();
        }

        if (m_StreamInfo[i].dwSendRecv & PART_RECV)
        {
            m_dwReceivingMediaTypes |= ((CIPConfMSPStream *)m_Streams[i])->MediaType();
        }
    }

    *pbLast = (m_Streams.GetSize() == 0);

    return S_OK;
}

BOOL CParticipantList::FindByCName(char *szCName, int *pIndex) const
/*++

Routine Description:

    Find a participant by its canonical name. If the function returns true,
    *pIndex contains the index of the participant. If the function returns
    false, *pIndex contains the index where the new participant should be
    inserted.

Arguments:
    
    szCName - the canonical name of the participant.

    pIndex - the memory address to store an integer.

Return Value:

    TRUE - the participant is found.

    FALSE - the participant is not in the list.
*/
{
    for(int i = 0; i < m_nSize; i++)
    {
        // This list is an ordered list based on dictionary order. We are using
        // a linear search here, it could be changed to a binary search.

        // CompareCName will return 0 if the name is the same, <0 if the szCName
        // is bigger, >0 if the szCName is smaller.
        int res = ((CParticipant *)m_aT[i])->CompareCName(szCName);
        if(res >= 0) 
        {
            *pIndex = i;
            return (res == 0);
        }
    }
    *pIndex = m_nSize;
    return FALSE;   // not found
}

BOOL CParticipantList::InsertAt(int nIndex, ITParticipant *pITParticipant)
/*++

Routine Description:

    Insert a participant into the list at a given index.

Arguments:
    
    nIndex - the location where the new object is inserted.

    pITParticipant - the object to be inserted.

Return Value:

    TRUE - the participant is inserted.

    FALSE - out of memory.
*/
{
    _ASSERTE(nIndex >= 0 && nIndex <= m_nSize);
    if(m_nSize == m_nAllocSize)
    {
        if (!Grow()) return FALSE;
    }

    memmove((void*)&m_aT[nIndex+1], (void*)&m_aT[nIndex], 
        (m_nSize - nIndex) * sizeof(ITParticipant *));

    m_nSize++;

    SetAtIndex(nIndex, pITParticipant);

    return TRUE;
}

CParticipantEvent::CParticipantEvent()
    : m_pFTM(NULL),
      m_pITParticipant(NULL),
      m_pITSubStream(NULL),
      m_Event(PE_NEW_PARTICIPANT)
{}

// methods called by the call object.
HRESULT CParticipantEvent::Init(
    IN  PARTICIPANT_EVENT   Event,
    IN  ITParticipant *     pITParticipant,
    IN  ITSubStream *       pITSubStream
    )
/*++

Routine Description:

    Initialize the ParticipantEvent object.

Arguments:
    
    Event - the event.

    pITParticipant - the participant.

    pITSubStream - the substream, can be NULL.

Return Value:

    S_OK,

--*/
{
    LOG((MSP_TRACE, "CParticipantEvent::Init"));

    // create the marshaler.
    HRESULT hr;
    hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), &m_pFTM);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "create marshaler failed, %x", hr));
        return hr;
    }

    m_Event             = Event;
    
    m_pITParticipant    = pITParticipant;
    if (m_pITParticipant) m_pITParticipant->AddRef();

    m_pITSubStream      = pITSubStream;
    if (m_pITSubStream) m_pITSubStream->AddRef();

    LOG((MSP_TRACE, "CParticipantEvent Init returns S_OK"));
    return S_OK;
}

void CParticipantEvent::FinalRelease()
/*++

Routine Description:

    release everything before being deleted. 

Arguments:
    
Return Value:

--*/
{
    LOG((MSP_TRACE, "CParticipantEvent::FinalRelease - enter"));

    if (m_pFTM)
    {
        m_pFTM->Release();
    }
    
    if (m_pITParticipant) m_pITParticipant->Release();

    if (m_pITSubStream) m_pITSubStream->Release();

    LOG((MSP_TRACE, "CParticipantEvent::FinalRelease - exit"));
}

STDMETHODIMP CParticipantEvent::get_Event(
    OUT PARTICIPANT_EVENT * pParticipantEvent
    )
{
    if (IsBadWritePtr(pParticipantEvent, sizeof (PARTICIPANT_EVENT)))
    {
        LOG((MSP_ERROR, "CParticipantEvent::get_Event - exit E_POINTER"));

        return E_POINTER;
    }

    *pParticipantEvent = m_Event;

    return S_OK;
}

STDMETHODIMP CParticipantEvent::get_Participant(
    OUT ITParticipant ** ppITParticipant
    )
{
    if (IsBadWritePtr(ppITParticipant, sizeof (void *)))
    {
        LOG((MSP_ERROR, "CParticipantEvent::get_participant - exit E_POINTER"));

        return E_POINTER;
    }

    if (!m_pITParticipant)
    {
        LOG((MSP_ERROR, "CParticipantevnt::get_Participant - exit no item"));
        return TAPI_E_NOITEMS;
    }

    m_pITParticipant->AddRef();
    *ppITParticipant = m_pITParticipant;

    return S_OK;
}

STDMETHODIMP CParticipantEvent::get_SubStream(
    OUT ITSubStream** ppSubStream
    )
{
    if (IsBadWritePtr(ppSubStream, sizeof (void *)))
    {
        LOG((MSP_ERROR, "CParticipantEvent::get_SubStream - exit E_POINTER"));

        return E_POINTER;
    }

    if (!m_pITSubStream)
    {
        LOG((MSP_WARN, "CParticipantevnt::get_SubStream - exit no item"));
        return TAPI_E_NOITEMS;
    }

    m_pITSubStream->AddRef();
    *ppSubStream = m_pITSubStream;

    return S_OK;
}

HRESULT CreateParticipantEvent(
    IN  PARTICIPANT_EVENT       Event,
    IN  ITParticipant *         pITParticipant,
    IN  ITSubStream *           pITSubStream,
    OUT IDispatch **            ppIDispatch
    )
{
    // create the object.
    CComObject<CParticipantEvent> * pCOMParticipantEvent;

    HRESULT hr = CComObject<CParticipantEvent>
                    ::CreateInstance(&pCOMParticipantEvent);

    if (NULL == pCOMParticipantEvent)
    {
        LOG((MSP_ERROR, "could not create participant event:%x", hr));
        return hr;
    }

    IDispatch * pIDispatch;

    // get the interface pointer.
    hr = pCOMParticipantEvent->_InternalQueryInterface(
        IID_IDispatch, 
        (void **)&pIDispatch
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Create ParticipantEvent QueryInterface failed: %x", hr));
        delete pCOMParticipantEvent;
        return hr;
    }

    // Initialize the object.
    hr = pCOMParticipantEvent->Init(
        Event,
        pITParticipant,
        pITSubStream
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CreateMSPParticipantEvent:call init failed: %x", hr));
        pIDispatch->Release();

        return hr;
    }

    *ppIDispatch = pIDispatch;
    
    return S_OK;
}

HRESULT CreateParticipantEnumerator(
    IN  ITParticipant **    begin,
    IN  ITParticipant **    end,
    OUT IEnumParticipant ** ppEnumParticipant
    )
{
    //
    // Create an enumerator object.
    //

    typedef _CopyInterface<ITParticipant> CCopy;
    typedef CSafeComEnum<IEnumParticipant, &IID_IEnumParticipant, 
                ITParticipant *, CCopy> CEnumerator;

    HRESULT hr;

    CComObject<CEnumerator> *pEnum = NULL;

    hr = CComObject<CEnumerator>::CreateInstance(&pEnum);
    if (pEnum == NULL)
    {
        LOG((MSP_ERROR, "CreateParticipantEnumerator - "
            "Could not create enumerator object, %x", hr));

        return hr;
    }

    //
    // query for the IID_IEnumParticipant i/f
    //

    hr = pEnum->_InternalQueryInterface(
        IID_IEnumParticipant, 
        (void**)ppEnumParticipant
        );
    
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CreateParticipantEnumerator - "
            "query enum interface failed, %x", hr));

        delete pEnum;
        return hr;
    }

    //
    // Init the enumerator object. The CSafeComEnum can handle zero-sized array.
    //

    hr = pEnum->Init(
        begin,                        // the begin itor
        end,  // the end itor, 
        NULL,                                       // IUnknown
        AtlFlagCopy                                 // copy the data.
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CreateParticipantEnumerator - "
            "init enumerator object failed, %x", hr));

        (*ppEnumParticipant)->Release();
        return hr;
    }

    LOG((MSP_TRACE, "CreateParticipantEnumerator - exit S_OK"));

    return hr;
}

HRESULT CreateParticipantCollection(
    IN  ITParticipant **    begin,
    IN  ITParticipant **    end,
    IN  int                 nSize,
    OUT VARIANT *           pVariant
    )
{
    //
    // create the collection object - see mspcoll.h
    //

    typedef CTapiIfCollection< ITParticipant * > ParticipantCollection;
    CComObject<ParticipantCollection> * pCollection;
    HRESULT hr = CComObject<ParticipantCollection>::CreateInstance( &pCollection );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CreateParticipantCollection - "
            "can't create collection - exit 0x%08x", hr));

        return hr;
    }

    //
    // get the Collection's IDispatch interface
    //

    IDispatch * pDispatch;

    hr = pCollection->_InternalQueryInterface(IID_IDispatch,
                                              (void **) &pDispatch );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CreateParticipantCollection - "
            "QI for IDispatch on collection failed - exit 0x%08x", hr));

        delete pCollection;

        return hr;
    }

    //
    // Init the collection using an iterator -- pointers to the beginning and
    // the ending element plus one.
    //

    hr = pCollection->Initialize(nSize, begin, end);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CreateParticipantCollection- "
            "Initialize on collection failed - exit 0x%08x", hr));
        
        pDispatch->Release();
        return hr;
    }

    //
    // put the IDispatch interface pointer into the variant
    //

    VariantInit(pVariant);
    pVariant->vt = VT_DISPATCH;
    pVariant->pdispVal = pDispatch;

    LOG((MSP_TRACE, "CreateParticipantCollection - exit S_OK"));
 
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\confmsp\confstrm.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    confstrm.cpp

Abstract:

    This module contains implementation of CMSPStream. The object represents
    one stream in the filter graph.

Author:

    Mu Han (muhan)   1-November-1997

--*/

#include "stdafx.h"
#include "common.h"

/*  State Transition Table


States:

RO   - Running whithout terminal. This is the initial state.
PO   - Paused without terminal
SO   - Stopped without terminal.
RT   - Runing with terminal.
PT   - Paused with termianl.
ST   - Stopped with terminal.

Actions:
S   - Stop graph.
P   - Pause graph.
C   - Change graph.
D   - Disonnect terminals.
F   - Free extra references to filters and terminals.
R   - Run Graph.
NIU - Not in use.

Note: the same graph operation can be called multiple times, the graph
just returns S_OK if it is already in desired state.

NOTE: if the stream is not configured, the transition will happen without
really doing anything to the graph.

CONFIG will only be called for NC streams.

        CONFIG  Select  Unselect    Run     Pause   Stop    ShutDown

RO      OK      C/R     FAIL        OK      OK      OK      F
        RO       RT      RO         RO      PO      SO      -

PO      OK      C/P     FAIL        OK      OK      OK      F
        PO       PT      PO         RO      PO      SO      -

SO      OK      C       FAIL        OK      OK      OK      F
        SO       ST      SO         RO      PO      SO      -

RT      C/R     S/C/R   S/C/(R)     R       P       S       S/D/F
        RT       RT     RT,RO       RT      PT      ST      -

PT      C/P     S/C/P   S/C/(P)     R       P       S       S/D/F
        PT       PT     PT,PO       RT      PT      ST      -

ST      C       C       C           R       P       S       D/F
        ST       ST     ST,SO       RT      PT      ST      -

*/

CIPConfMSPStream::CIPConfMSPStream()
    : CMSPStream(),
      m_szName(L""),
      m_pClsidPHFilter(NULL),
      m_pClsidCodecFilter(NULL),
      m_pRPHInputMinorType(NULL),
      m_fIsConfigured(FALSE),
      m_pEdgeFilter(NULL),
      m_pRTPFilter(NULL)
{
    // The default state is always running.
    m_dwState   = STRM_RUNNING;
    ZeroMemory(m_InfoItems, sizeof(m_InfoItems));
    ZeroMemory(&m_Settings, sizeof(m_Settings));
}

#ifdef DEBUG_REFCOUNT
LONG g_lStreamObjects = 0;

ULONG CIPConfMSPStream::InternalAddRef()
{
    InterlockedIncrement(&g_lStreamObjects);
    
    ULONG lRef = CMSPStream::InternalAddRef();
    
    LOG((MSP_TRACE, "%ws Addref, ref = %d", m_szName, lRef));

    return lRef;
}

ULONG CIPConfMSPStream::InternalRelease()
{
    InterlockedDecrement(&g_lStreamObjects);

    ULONG lRef = CMSPStream::InternalRelease();
    
    LOG((MSP_TRACE, "%ws Release, ref = %d", m_szName, lRef));

    return lRef;
}
#endif

BOOL CIPConfMSPStream::IsConfigured()
{
    CLock lock(m_lock);
    return m_fIsConfigured;
}

// methods called by the MSPCall object.
HRESULT CIPConfMSPStream::Init(
    IN     HANDLE                   hAddress,
    IN     CMSPCallBase *           pMSPCall,
    IN     IMediaEvent *            pGraph,
    IN     DWORD                    dwMediaType,
    IN     TERMINAL_DIRECTION       Direction
    )
/*++

Routine Description:
    Initialize the stream object.

Arguments:

    hAddress    - a handle to the address, used in identify terminals.

    pMSPCall    - the call object that owns the stream.

    pIGraphBuilder - the filter graph object.

    dwMediaType - the mediatype of this stream.

    Direction  - the direction of this stream.

Return Value:
    
    S_OK,
    E_OUTOFMEMORY

--*/
{
    LOG((MSP_TRACE, "CIPConfMSPStream::Init - enter"));

    // initialize the participant array so that the array is not NULL.
    if (!m_Participants.Grow())
    {
        LOG((MSP_ERROR, "out of mem for participant list"));
        return E_OUTOFMEMORY;
    }

    return CMSPStream::Init(
        hAddress, pMSPCall, pGraph, dwMediaType, Direction
        );
}

HRESULT CIPConfMSPStream::SetLocalParticipantInfo(
    IN      PARTICIPANT_TYPED_INFO  InfoType,
    IN      char *                  pInfo,
    IN      DWORD                   dwLen
    )
/*++

Routine Description:

    Get the name of this stream.

Arguments:
    
    InfoType    - the type of the information item.

    pInfo       - the string containing the info.

    dwLen       - the length of the string(including EOS).

Return Value:

    HRESULT.
*/
{
    CLock lock(m_lock);

    //
    // Save the information localy first.
    //
    int index = (int)InfoType; 
    if (m_InfoItems[index] != NULL)
    {
        free(m_InfoItems[index]);
    }

    m_InfoItems[index] = (char *)malloc(dwLen);

    if (m_InfoItems[index] == NULL)
    {
        return E_OUTOFMEMORY;
    }

    lstrcpynA(m_InfoItems[index], pInfo, dwLen);

    if (!m_pRTPFilter)
    {
        return S_OK;
    }

    //
    // if the RTP filter has been created, apply the change to the fitler.
    //

    IRTCPStream *pIRTCPStream;
    HRESULT hr = m_pRTPFilter->QueryInterface(
        IID_IRTCPStream, 
        (void **)&pIRTCPStream
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%ls can't get IRTCPStream interface %d", m_szName, hr));
        return hr;
    }

    hr = pIRTCPStream->SetLocalSDESItem(
        RTCP_SDES_CNAME + index,
        (BYTE*)pInfo,
        dwLen
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%ls can't set item:%s", pInfo));
    }

    pIRTCPStream->Release();
    return hr;
}

STDMETHODIMP CIPConfMSPStream::get_Name(
    OUT     BSTR *                  ppName
    )
/*++

Routine Description:

    Get the name of this stream.

Arguments:
    
    ppName  - the mem address to store a BSTR.

Return Value:

    HRESULT.

*/
{
    LOG((MSP_TRACE, "CIPconfMSPStream::get_Name - enter"));
    
    if (IsBadWritePtr(ppName, sizeof(BSTR)))
    {
        LOG((MSP_ERROR, "CMSPStream::get_Name - exit E_POINTER"));
        return E_POINTER;
    }

    DWORD dwID;

    if (m_dwMediaType == TAPIMEDIATYPE_AUDIO)
    {
        if (m_Direction == TD_CAPTURE)
        {
            dwID = IDS_AUDIO_CAPTURE_STREAM;
        }
        else
        {
            dwID = IDS_AUDIO_RENDER_STREAM;
        }
    }
    else
    {
        if (m_Direction == TD_CAPTURE)
        {
            dwID = IDS_VIDEO_CAPTURE_STREAM;
        }
        else
        {
            dwID = IDS_VIDEO_RENDER_STREAM;
        }
    }

    const int   BUFSIZE = 1024;
    WCHAR       wszName[BUFSIZE];

    if (LoadStringW( 
            _Module.GetModuleInstance(),
            dwID,
            wszName,
            BUFSIZE - 1 ) == 0)
    {
        *ppName = NULL;

        LOG((MSP_ERROR, "CMSPStream::get_Name - "
            "LoadString failed - returning E_UNEXPECTED"));

        return E_UNEXPECTED;
    }

    //
    // Convert to a BSTR and return the BSTR.
    //

    BSTR pName = SysAllocString(wszName);

    if (pName == NULL)
    {
        LOG((MSP_ERROR, "CMSPStream::get_Name - exit out of mem"));
        return E_OUTOFMEMORY;
    }

    *ppName = pName;

    return S_OK; 
}

HRESULT CIPConfMSPStream::SendStreamEvent(
    IN      MSP_CALL_EVENT          Event,
    IN      MSP_CALL_EVENT_CAUSE    Cause,
    IN      HRESULT                 hrError = 0,
    IN      ITTerminal *            pTerminal = NULL
    )
/*++

Routine Description:

    Send a event to the app to notify that this stream is not used.
*/
{
    CLock lock(m_lock);

    if (m_pMSPCall == NULL)
    {
        LOG((MSP_WARN, "The call has shut down the stream."));
        return S_OK;
    }

    ITStream *  pITStream;
    HRESULT hr = this->_InternalQueryInterface(
        IID_ITStream, 
        (void **)&pITStream
    );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "SendStreamEvent:QueryInterface failed: %x", hr));
        return hr;
    }


    MSPEVENTITEM* pEventItem = AllocateEventItem();

    if (pEventItem == NULL)
    {
        LOG((MSP_ERROR, "No memory for the TSPMSP data, size: %d", sizeof(MSPEVENTITEM)));
        pITStream->Release();

        return E_OUTOFMEMORY;
    }
    
    // Fill in the necessary fields for the event structure.
    pEventItem->MSPEventInfo.dwSize = sizeof(MSP_EVENT_INFO);
    pEventItem->MSPEventInfo.Event  = ME_CALL_EVENT;
    
    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.Type = Event;
    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.Cause = Cause;

    // pITStream has a refcount becaust it was from QI.
    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.pStream = pITStream;

    // the terminal needs to be addrefed.
    if (pTerminal) pTerminal->AddRef();
    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.pTerminal = pTerminal;

    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.hrError= hrError;

    hr = m_pMSPCall->HandleStreamEvent(pEventItem);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Post event failed %x", hr));
        
        pITStream->Release();
        FreeEventItem(pEventItem);

        return hr;
    }
    return S_OK;
}

HRESULT CIPConfMSPStream::CleanUpFilters()
/*++

Routine Description:

    remove all the filters in the graph.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "CleanUpFilters for %ws %p", m_szName, this));
   
    if (m_pEdgeFilter)
    {
        m_pEdgeFilter->Release();
        m_pEdgeFilter = NULL;
    }

    if (m_pRTPFilter)
    {
        m_pRTPFilter->Release();
        m_pRTPFilter = NULL;
    }

    for(;;)
    {
        // Because the enumerator is invalid after removing a filter from
        // the graph, we have to try to get all the filters in one shot.
        // If there are still more, we loop again.

        // Enumerate the filters in the graph.
        CComPtr<IEnumFilters>pEnum;
        HRESULT hr = m_pIGraphBuilder->EnumFilters(&pEnum);

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "cleanup filters, enumfilters failed: %x", hr));
            return hr;
        }

        const DWORD MAXFILTERS = 40;
        IBaseFilter * Filters[MAXFILTERS];
        DWORD dwFetched;
    
        hr = pEnum->Next(MAXFILTERS, Filters, &dwFetched);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "get next filter failed: %x", hr));
            return hr;
        }

        for (DWORD i = 0; i< dwFetched; i ++)
        {
            m_pIGraphBuilder->RemoveFilter(Filters[i]);
            Filters[i]->Release();
        }

        if (hr != S_OK)
        {
            break;
        }
    }
    return S_OK;
}

HRESULT CIPConfMSPStream::InternalConfigure()
/*++

Routine Description:

    This method is called by the derived streams to handle the state
    transition needed for configure. It should be called after the
    stream finished configuring itself.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    _ASSERTE(m_fIsConfigured == TRUE);

    // if there is no terminal selected, just return.
    if (m_Terminals.GetSize() == 0)
    {
        LOG((MSP_INFO, "stream %ws %p needs terminal", m_szName, this));

        return S_OK;
    }

    // set up the filters and the terminals.
    HRESULT hr = SetUpFilters();

    if (FAILED(hr))
    {
        SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_CONNECT_FAIL, hr);

        LOG((MSP_ERROR, "stream %ws %p set up filters failed, %x", 
            m_szName, this, hr));
        return hr;
    }
    
    switch (m_dwState)
    {
    case STRM_RUNNING:
        // start the graph.
        hr = CMSPStream::StartStream();
        if (FAILED(hr))
        {
            // if the stream failed to start, let the app now.
            SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_UNKNOWN, hr);
            LOG((MSP_ERROR, "stream %ws %p failed to start, %x", m_szName, this, hr));
            return hr;
        }

        SendStreamEvent(CALL_STREAM_ACTIVE, CALL_CAUSE_REMOTE_REQUEST);
        LOG((MSP_INFO, "stream %ws %p started", m_szName, this));
        break;

    case STRM_PAUSED:
        // pause the graph.
        hr = CMSPStream::PauseStream();
        if (FAILED(hr))
        {
            // if the stream failed to start, let the app now.
            SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_UNKNOWN, hr);
            LOG((MSP_ERROR, "stream %ws %p failed to pause, %x", m_szName, this, hr));
            return hr;
        }

        LOG((MSP_INFO, "stream %ws %p paused", m_szName, this));
        break;

    case STRM_STOPPED:
        break;
    }

    LOG((MSP_INFO, "stream %ws %p configure exit S_OK", m_szName, this));

    return S_OK;
}

STDMETHODIMP CIPConfMSPStream::StartStream()
/*++

Routine Description:

    Start the stream. This is the basic state machine for all the derived 
    streams.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    CLock lock(m_lock);

    // if there is no terminal selected
    if (m_Terminals.GetSize() == 0)
    {
        LOG((MSP_INFO, "stream %ws %p needs terminal", m_szName, this));

        // Enter Runing state. (RO)
        m_dwState = STRM_RUNNING; 
        
        return S_OK;
    }

    if (!m_fIsConfigured)
    {
        LOG((MSP_INFO, "stream %ws %p is not configured yet", m_szName, this));

        // Enter Runing state. (RO, RT)
        m_dwState = STRM_RUNNING; 

        return S_OK;
    }

    // Start the stream.
    HRESULT hr = CMSPStream::StartStream();
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "stream %ws %p failed to start, %x", m_szName, this, hr));
        return hr;
    }

    SendStreamEvent(CALL_STREAM_ACTIVE, CALL_CAUSE_LOCAL_REQUEST);
    LOG((MSP_INFO, "stream %ws %p started", m_szName, this));

    // Enter Runing state.(RT)
    m_dwState = STRM_RUNNING;

    return S_OK;
}

STDMETHODIMP CIPConfMSPStream::PauseStream()
/*++

Routine Description:

    Pause the stream. This is the basic state machine for all the derived 
    streams.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    CLock lock(m_lock);

    // if there is no terminal selected
    if (m_Terminals.GetSize() == 0)
    {
        LOG((MSP_INFO, "stream %ws %p needs terminal", m_szName, this));

        // Enter paused state. (PO)
        m_dwState = STRM_PAUSED; 
        
        return S_OK;
    }

    if (!m_fIsConfigured)
    {
        LOG((MSP_INFO, "stream %ws %p is not configured yet", m_szName, this));

        // Enter paused state. (PO, PT)
        m_dwState = STRM_PAUSED; 
        
        return S_OK;
    }

    // Start the stream.
    HRESULT hr = CMSPStream::PauseStream();
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "stream %ws %p failed to pause, %x", m_szName, this, hr));
        return hr;
    }

    LOG((MSP_INFO, "stream %ws %p paused", m_szName, this));

    // Enter paused state.(PT)
    m_dwState = STRM_PAUSED;

    return S_OK;
}

STDMETHODIMP CIPConfMSPStream::StopStream()
/*++

Routine Description:

    Stop the stream. This is the basic state machine for all the derived 
    streams.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    CLock lock(m_lock);

    // if there is no terminal selected
    if (m_Terminals.GetSize() == 0)
    {
        LOG((MSP_INFO, "stream %ws %p needs terminal", m_szName, this));

        // Enter stopped state. (SO)
        m_dwState = STRM_STOPPED; 
        
        return S_OK;
    }

    if (!m_fIsConfigured)
    {
        LOG((MSP_INFO, "stream %ws %p is not configured yet", m_szName, this));

        // Enter stopped state. (SO, ST)
        m_dwState = STRM_STOPPED; 
        
        return S_OK;
    }

    // Stop the graph.
    HRESULT hr = CMSPStream::StopStream();
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "stream %ws %p failed to stop, %x", m_szName, this, hr));
        return hr;
    }

    SendStreamEvent(CALL_STREAM_INACTIVE, CALL_CAUSE_LOCAL_REQUEST);
    LOG((MSP_INFO, "stream %ws %p stopped", m_szName, this));

    // Enter stopped state.(ST)
    m_dwState = STRM_STOPPED; 

    return S_OK;
}

HRESULT CIPConfMSPStream::CheckTerminalTypeAndDirection(
    IN      ITTerminal *            pTerminal
    )
/*++

Routine Description:

    The implementation in this class checks to see if the terminal
    is th right type and direction and it only allows on terminal per
    stream.

Arguments:
    
    pTerminal - the terminal object.

*/
{
    // check the media type of this terminal.
    long lMediaType;
    HRESULT hr = pTerminal->get_MediaType(&lMediaType);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get terminal media type. %x", hr));
        return TAPI_E_INVALIDTERMINAL;
    }

    if ((DWORD)lMediaType != m_dwMediaType)
    {
        return TAPI_E_INVALIDTERMINAL;
    }

    // check the direction of this terminal.
    TERMINAL_DIRECTION Direction;
    hr = pTerminal->get_Direction(&Direction);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get terminal direction. %x", hr));
        return TAPI_E_INVALIDTERMINAL;
    }

    if (Direction != m_Direction)
    {
        return TAPI_E_INVALIDTERMINAL;
    }

    // By default, only one terminal is supported per stream.
    if (m_Terminals.GetSize() > 0)
    {
        return TAPI_E_MAXTERMINALS;
    }

    return S_OK;
}

HRESULT CIPConfMSPStream::SelectTerminal(
    IN      ITTerminal *            pTerminal
    )
/*++

Routine Description:

    Select a terminal on the stream. The stream will start itself if it
    was in running state. See the state transition table at the beginning
    of this file.

Arguments:
    
    pTerminal - the terminal object.

Return Value:

S_OK

E_POINTER
E_OUTOFMEMORY
TAPI_E_MAXTERMINALS
TAPI_E_INVALIDTERMINAL

--*/
{
    LOG((MSP_TRACE, "CMSPStream::SelectTerminal, %p", pTerminal));

    //
    // Check parameter.
    //
    if ( IsBadReadPtr(pTerminal, sizeof(ITTerminal) ) )
    {
        LOG((MSP_ERROR, "CIPconfMSPStream.SelectTerminal - exit E_POINTER"));

        return E_POINTER;
    }

    CLock lock(m_lock);

    // validate the terminal.
    HRESULT hr = CheckTerminalTypeAndDirection(pTerminal);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "wrong terminal. %x", hr));
        return hr;
    }

    // put the terminal into our list.
    hr = CMSPStream::SelectTerminal(pTerminal);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "SelectTerminal on CMSPStream failed, %x", hr));
        return hr;
    }

    // At this point, the select terminal opration succeeded. All the 
    // failure cases are handled by sending events after this.

    if (!m_fIsConfigured)
    {
        LOG((MSP_INFO, "stream %ws %p is not configured yet", m_szName, this));
        return S_OK;
    }

    // stop the graph before making changes.
    hr = CMSPStream::StopStream();
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "stream %ws %p failed to stop, %x", m_szName, this, hr));

        SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_UNKNOWN, hr);
        return S_OK;
    }

    // connect the new terminal into the graph. 
    // this method will send events if the terminal failed.
    hr = ConnectTerminal(pTerminal);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "stream %ws %p connect to terminal failed, %x", 
            m_szName, this, hr));

        SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_CONNECT_FAIL, hr);

        return S_OK;
    }

    // after connecting the termanal, go back to the original state.
    switch  (m_dwState)
    {
    case STRM_RUNNING:

        // start the stream.
        hr = CMSPStream::StartStream();
        
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "stream %ws %p failed, %x", m_szName, this, hr));
            SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_UNKNOWN, hr);
            break;
        }
    
        SendStreamEvent(CALL_STREAM_ACTIVE, CALL_CAUSE_LOCAL_REQUEST);
        break;

    case STRM_PAUSED:

        // pause the stream.
        hr = CMSPStream::PauseStream();
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "stream %ws %p failed, %x", m_szName, this, hr));
            SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_UNKNOWN, hr);
        }
    
        break;
    }

    return S_OK;
}

STDMETHODIMP CIPConfMSPStream::UnselectTerminal(
    IN      ITTerminal *            pTerminal
    )
/*++

Routine Description:

  Unselect a terminal from the stream. It handles changing the graph and
  going back to the original state.

Arguments:
    

Return Value:

S_OK

E_POINTER
E_OUTOFMEMORY
TAPI_E_MAXTERMINALS
TAPI_E_INVALIDTERMINAL

--*/
{
    LOG((MSP_TRACE, 
        "CIPConfMSPStream::UnselectTerminal, pTerminal %p", pTerminal));

    CLock lock(m_lock);
    int index;

    if ((index = m_Terminals.Find(pTerminal)) < 0)
    {
        LOG((MSP_ERROR, "UnselectTerminal - exit TAPI_E_INVALIDTERMINAL"));
    
        return TAPI_E_INVALIDTERMINAL;
    }

    // if the stream is not configured, just remove it and return.
    if (!m_fIsConfigured)
    {
        if (!m_Terminals.RemoveAt(index))
        {
            LOG((MSP_ERROR, "CMSPStream::UnselectTerminal - "
                "exit E_UNEXPECTED"));
    
            return E_UNEXPECTED;
        }

        // release the refcount that was in our list.
        pTerminal->Release();

        LOG((MSP_INFO, "stream %ws %p is not configured yet", m_szName, this));
        return S_OK;
    }

    // stop the graph before making changes.
    HRESULT hr = CMSPStream::StopStream();
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "stream %ws %p failed to stop, %x", m_szName, this, hr));

        return hr;
    }

    SendStreamEvent(CALL_STREAM_INACTIVE, CALL_CAUSE_LOCAL_REQUEST);
       
    // disconnect the terminal from the graph. 
    // this method will send events if the terminal failed.
    hr = DisconnectTerminal(pTerminal);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "stream %ws %p disconnectTerminal failed, %x", 
            m_szName, this, hr));

        return hr;
    }

    if (!m_Terminals.RemoveAt(index))
    {
        LOG((MSP_ERROR, "CMSPStream::UnselectTerminal - "
            "exit E_UNEXPECTED"));

        return E_UNEXPECTED;
    }

    // release the refcount that was in our list.
    pTerminal->Release();

    // if there is no terminal selected, just return and wait for terminals.
    if (m_Terminals.GetSize() == 0)
    {
        LOG((MSP_INFO, "stream %ws %p needs terminal", m_szName, this));
        return S_OK;
    }

    // At this point, the Unselect terminal opration succeeded. All the 
    // failure cases are handled by sending events after this.

    // after disconnecting the termanal, go back to the original state.
    switch  (m_dwState)
    {
    case STRM_RUNNING:

        // start the stream.
        hr = CMSPStream::StartStream();
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "stream %ws %p failed to start, %x", m_szName, this, hr));
            SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_UNKNOWN, hr);
            break;
        }
    
        SendStreamEvent(CALL_STREAM_ACTIVE, CALL_CAUSE_LOCAL_REQUEST);
        
        break;

    case STRM_PAUSED:

        // pause the stream.
        hr = CMSPStream::PauseStream();
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "stream %ws %p failed to pause, %x", m_szName, this, hr));
            SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_UNKNOWN, hr);
        }
        break;
    }

    return S_OK;
}

HRESULT CIPConfMSPStream::ShutDown()
/*++

Routine Description:

    Shut down the stream. It release the filters and terminals.

Arguments:
    

Return Value:

S_OK

--*/
{
    LOG((MSP_TRACE, "CIPConfMSPStream::Shutdown %ws - enter", m_szName));

    CLock lock(m_lock);

    for (int j = 0; j < RTCP_SDES_LAST - 1; j ++)
    {
        if (m_InfoItems[j])
        {
            free(m_InfoItems[j]);
            m_InfoItems[j] = NULL;
        }
    }

    if (m_pMSPCall)
    {
        m_pMSPCall->MSPCallRelease();
        m_pMSPCall  = NULL;
    }

    // free the extra filter reference.
    if (m_pEdgeFilter)
    {
        m_pEdgeFilter->Release();
        m_pEdgeFilter = NULL;
    }

    if (m_pRTPFilter)
    {
        m_pRTPFilter->Release();
        m_pRTPFilter = NULL;
    }

    // If the stream is not configured, just free the terminals.
    if (!m_fIsConfigured)
    {
        LOG((MSP_INFO, "stream %ws %p is not configured yet", m_szName, this));

        for ( int i = 0; i < m_Terminals.GetSize(); i ++ )
        {
            m_Terminals[i]->Release();
        }
        m_Terminals.RemoveAll();

        return S_OK;
    }

    // if there are terminals and configured, we need to disconnect 
    // the terminals.
    if (m_Terminals.GetSize() > 0)
    {
        // Stop the graph before disconnecting the terminals.
        HRESULT hr = CMSPStream::StopStream();
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, 
                "stream %ws %p failed to stop, %x", m_szName, this, hr));
            return hr;
        }

        for ( int i = 0; i < m_Terminals.GetSize(); i ++ )
        {
            hr = DisconnectTerminal(m_Terminals[i]);
            LOG((MSP_TRACE, "Disconnect terminal returned %x", hr));

            m_Terminals[i]->Release();
        }
        m_Terminals.RemoveAll();
    }

    for (int i = 0; i < m_Participants.GetSize(); i ++)
    {
        m_Participants[i]->Release();
    }
    m_Participants.RemoveAll();

    LOG((MSP_TRACE, "CIPConfMSPStream::Shutdown - exit S_OK"));

    return S_OK;
}

HRESULT CIPConfMSPStream::DisconnectTerminal(
    IN  ITTerminal *   pITTerminal
    )
/*++

Routine Description:

    Disconnect a terminal. It will remove its filters from the graph and
    also release its references to the graph.

Arguments:
    
    pITTerminal - the terminal.

Return Value:

    HRESULT.

--*/
{
    CComQIPtr<ITTerminalControl, &IID_ITTerminalControl> 
        pTerminalControl(pITTerminal);
    if (pTerminalControl == NULL)
    {
        LOG((MSP_ERROR, "can't get Terminal Control interface"));
        return E_NOINTERFACE;
    }

    HRESULT hr = pTerminalControl->DisconnectTerminal(m_pIGraphBuilder, 0);

    LOG((MSP_TRACE, "terminal %p is disonnected. hr:%x", pITTerminal, hr));

    return hr;
}

HRESULT CIPConfMSPStream::ProcessNewSender(
    IN  DWORD dwSSRC, 
    IN  ITParticipant *pITParticipant
    )
{
    return S_OK;
}

HRESULT CIPConfMSPStream::ProcessNewParticipant(
    IN  int                 index,
    IN  DWORD               dwSSRC,
    IN  DWORD               dwSendRecv,
    IN  char *              szCName,
    OUT ITParticipant **    ppITParticipant
    )
{
    if (!m_Participants.HasSpace())
    {
        if (!m_Participants.Grow())
        {
            LOG((MSP_ERROR, "Out of mem for participant list"));
    
            return E_OUTOFMEMORY;
        }
    }

    // create a new participant if it is not in the list.
    HRESULT hr = ((CIPConfMSPCall *)m_pMSPCall)->NewParticipant(
        (ITStream *)this,
        dwSSRC,
        dwSendRecv,
        m_dwMediaType,
        szCName,
        ppITParticipant
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "new participant returns %x", hr));
        
        return hr;
    }

    // insert the new participant at the index where the search
    // stopped. The list is ordered by CName. We know the list has
    // space, this function will not fail.
    m_Participants.InsertAt(index, *ppITParticipant);

    LOG((MSP_INFO, "%ws new participant %s", m_szName, szCName));

    (*ppITParticipant)->AddRef();

    return S_OK;
}

HRESULT CIPConfMSPStream::ProcessRTCPReport(
    IN  DWORD               dwSSRC,
    IN  DWORD               dwSendRecv
    )
/*++

Routine Description:

    Process a sender report, create a participant if necessary. If a new
    participant is created, a new participant event will be fired. If the
    participant already exists, the new report is compared with the current
    information, if anything change, a info change event will be fired. 

    If there is a pending map event(new source without CName), compare its
    SSRC with lParam1. If it is the same, fire the map event as well.

Arguments:
    
    dwSSRC - the SSRC of this participant.

    dwSendRecv - a sender report or a receiver report.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "ProcessRTCPReport, SSRC: %x", dwSSRC));

    CLock Lock(m_lock);

    if (m_pRTPFilter == NULL)
    {
        LOG((MSP_ERROR, "ProcessRTCPReport RTP filter is NULL"));
        return E_UNEXPECTED;
    }

    // prepare the buffer to get the SDES_ITEMS.
    // We need all the items from CNAME to PRIV, see rtp.h.
    SDES_DATA SDESBuffer[RTCP_SDES_LAST - 1];

    for (int i = 0; i < RTCP_SDES_LAST - 1; i ++)
    {
        SDESBuffer[i].dwSdesType = RTCP_SDES_CNAME + i;
        SDESBuffer[i].dwSdesLength = 0;
    }

    // Ask the stream to get the SDES_ITEMS.
    HRESULT hr = m_pRTPFilter->GetParticipantSDESAll(
        dwSSRC, SDESBuffer, RTCP_SDES_LAST - 1
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get sdes data for ssrc:%x. %x", dwSSRC, hr));
        return hr;
    }

    // Check CName,
    if (SDESBuffer[0].dwSdesLength == 0)
    {
        LOG((MSP_WARN, "CName doesn't exist for SSRC %x", dwSSRC));
        return hr;
    }

    ITParticipant * pITParticipant;
    BOOL fChanged = FALSE;
    
    if (m_pMSPCall == NULL)
    {
        LOG((MSP_WARN, "The call has shut down the stream."));

        return S_OK;
    }
    
    CParticipant * pParticipant;
        
    // find out if the participant is in our list.
    int index;
    if (m_Participants.FindByCName(SDESBuffer[0].sdesBfr, &index))
    {
        pITParticipant = m_Participants[index];

        // addref to keep it after unlock;
        pITParticipant->AddRef();
    
        // check to see if this participant just turned into a sender.
        pParticipant = (CParticipant *)pITParticipant;

        if ((!(pParticipant->GetSendRecvStatus((ITStream *)this) & PART_SEND)) 
                && (dwSendRecv & PART_SEND))
        {
            ProcessNewSender(dwSSRC, pITParticipant);
        }
    }
    else
    {
        hr = ProcessNewParticipant(
            index,
            dwSSRC,
            dwSendRecv,
            SDESBuffer[0].sdesBfr,
            &pITParticipant
            );

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "new participant returns %x", hr));
            return hr;
        }

        pParticipant = (CParticipant *)pITParticipant;
    
        // Senders needs special attention.
        if (dwSendRecv & PART_SEND)
        {
            ProcessNewSender(dwSSRC, pITParticipant);
        }

        // There might be things the stream needs to do with the new participant
        NewParticipantPostProcess(dwSSRC, pITParticipant);

        // a new stream is added into the participant's list
        // fire a info changed event.
        fChanged = TRUE;
    }

    // update the information of the participant.

    // just in case the SSRC changed.
    pParticipant->UpdateSSRC(
        (ITStream *)this,
        dwSSRC,
        dwSendRecv
        );

    // start from the SDES_NAME, skip CNAME.
    for (i = 1; i < RTCP_SDES_LAST - 1; i ++)
    {
        if (SDESBuffer[i].dwSdesLength > 0)
        {
            fChanged = fChanged || pParticipant->UpdateInfo(
                RTCP_SDES_CNAME + i,
                SDESBuffer[i].dwSdesLength,
                (char *)SDESBuffer[i].sdesBfr
                );
        }
    }

    if(fChanged)
    {
        ((CIPConfMSPCall *)m_pMSPCall)->
            SendParticipantEvent(PE_INFO_CHANGE, pITParticipant);
    }

    pITParticipant->Release();

    return S_OK;
}

HRESULT CIPConfMSPStream::ProcessParticipantLeave(
    IN  DWORD   dwSSRC
    )
/*++

Routine Description:

    When participant left the session, remove the stream from the participant
    object's list of streams. If all streams are removed, remove the 
    participant from the call object's list too.

Arguments:
    
    dwSSRC - the SSRC of the participant left.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "ProcessParticipantLeave, SSRC: %x", dwSSRC));
    
    m_lock.Lock();
    
    CParticipant *pParticipant;
    BOOL fLast = FALSE;

    HRESULT hr = E_FAIL;

    // first try to find the SSRC in our participant list.
    for (int i = 0; i < m_Participants.GetSize(); i ++)
    {
        pParticipant = (CParticipant *)m_Participants[i];
        hr = pParticipant->RemoveStream(
                (ITStream *)this,
                dwSSRC,
                &fLast
                );
        
        if (SUCCEEDED(hr))
        {
            break;
        }
    }

    // if the participant is not found
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't find the SSRC", dwSSRC));

        m_lock.Unlock();
        
        return hr;
    }

    ITParticipant *pITParticipant = m_Participants[i];

    m_Participants.RemoveAt(i);

    // if this stream is the last stream that the participant is on,
    // tell the call object to remove it from its list.
    if (fLast)
    {
        ((CIPConfMSPCall *)m_pMSPCall)->ParticipantLeft(pITParticipant);
    }

    m_lock.Unlock();

    pITParticipant->Release();

    return S_OK;
}

HRESULT CIPConfMSPStream::ProcessParticipantTimeOutOrRecovered(
    IN  BOOL    fTimeOutOrRecovered,
    IN  DWORD   dwSSRC
    )
/*++

Routine Description:

    When RTP detects a timeout for a certain participant, the msp needs to
    notify the app about it.

Arguments:
    
    dwSSRC - the SSRC of the participant that times out.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "ProcessParticipantTimeOutOrRecovered, SSRC: %x", dwSSRC));
    
    ITParticipant *pITParticipant = NULL;

    CLock Lock(m_lock);
    
    // find the SSRC in our participant list.
    for (int i = 0; i < m_Participants.GetSize(); i ++)
    {
        if (((CParticipant *)m_Participants[i])->
                HasSSRC((ITStream *)this, dwSSRC))
        {
            pITParticipant = m_Participants[i];
            pITParticipant->AddRef();
        }
    }

    // if the participant is not found
    if (pITParticipant == NULL)
    {
        LOG((MSP_ERROR, "can't find the SSRC", dwSSRC));

        return S_OK;
    }

    ((CIPConfMSPCall *)m_pMSPCall)->
        SendParticipantEvent(
            fTimeOutOrRecovered ? PE_PARTICIPANT_TIMEOUT : PE_PARTICIPANT_RECOVERED, 
            pITParticipant
            );

    pITParticipant->Release();

    return S_OK;
}

HRESULT CIPConfMSPStream::NewParticipantPostProcess(
    IN  DWORD dwSSRC, 
    IN  ITParticipant *pITParticipant
    )
{
    // This function does nothing. The derived class will do the work.
    return S_OK;
}

HRESULT CIPConfMSPStream::ProcessQOSEvent(
    IN  long lEventCode
    )
{
    CLock lock(m_lock);

    if (m_pMSPCall == NULL)
    {
        LOG((MSP_WARN, "The call has shut down the stream."));
        return S_OK;
    }

    switch (lEventCode)
    {
    case DXMRTP_QOSEVENT_NOQOS:
        ((CIPConfMSPCall*)m_pMSPCall)->SendTSPMessage(
            CALL_QOS_EVENT, 
            QE_NOQOS, 
            m_dwMediaType
            );
        break;

    case DXMRTP_QOSEVENT_RECEIVERS:
    case DXMRTP_QOSEVENT_SENDERS:
    case DXMRTP_QOSEVENT_NO_SENDERS:
    case DXMRTP_QOSEVENT_NO_RECEIVERS:
        break;
    
    case DXMRTP_QOSEVENT_REQUEST_CONFIRMED:
        break;
    
    case DXMRTP_QOSEVENT_ADMISSION_FAILURE:
        ((CIPConfMSPCall*)m_pMSPCall)->SendTSPMessage(
            CALL_QOS_EVENT, 
            QE_ADMISSIONFAILURE, 
            m_dwMediaType
            );
        break;
    
    case DXMRTP_QOSEVENT_POLICY_FAILURE:
        ((CIPConfMSPCall*)m_pMSPCall)->SendTSPMessage(
            CALL_QOS_EVENT, 
            QE_POLICYFAILURE, 
            m_dwMediaType
            );
        break;

    case DXMRTP_QOSEVENT_BAD_STYLE:
    case DXMRTP_QOSEVENT_BAD_OBJECT:
    case DXMRTP_QOSEVENT_TRAFFIC_CTRL_ERROR:
    case DXMRTP_QOSEVENT_GENERIC_ERROR:
        ((CIPConfMSPCall*)m_pMSPCall)->SendTSPMessage(
            CALL_QOS_EVENT, 
            QE_GENERICERROR, 
            m_dwMediaType
            );
        break;
    
    case DXMRTP_QOSEVENT_NOT_ALLOWEDTOSEND:
        SendStreamEvent(CALL_STREAM_INACTIVE, CALL_CAUSE_REMOTE_REQUEST);
        break;
    
    case DXMRTP_QOSEVENT_ALLOWEDTOSEND:
        SendStreamEvent(CALL_STREAM_ACTIVE, CALL_CAUSE_REMOTE_REQUEST);
        break;
    }
    return S_OK;
}

HRESULT CIPConfMSPStream::ProcessGraphEvent(
    IN  long lEventCode,
    IN  long lParam1,
    IN  long lParam2
    )
{
    LOG((MSP_TRACE, "%ws ProcessGraphEvent %d", m_szName, lEventCode));

    switch (lEventCode)
    {
    case DXMRTP_EVENTBASE + DXMRTP_RECV_RTCP_SNDR_REPORT_EVENT:

        // lparam1 is the SSRC, lparam2 is the session ID
        ProcessRTCPReport((DWORD)lParam1, PART_SEND);

        break;

    case DXMRTP_EVENTBASE + DXMRTP_RECV_RTCP_RECV_REPORT_EVENT:

        // lparam1 is the SSRC, lparam2 is the session ID
        ProcessRTCPReport((DWORD)lParam1, PART_RECV);

        break;

    case DXMRTP_EVENTBASE + DXMRTP_TIMEOUT_EVENT:
    case DXMRTP_EVENTBASE + DXMRTP_BYE_EVENT:

        // lparam1 is the SSRC, lparam2 is the source IP
        ProcessParticipantLeave((DWORD)lParam1);

        break;

    case DXMRTP_EVENTBASE + DXMRTP_INACTIVE_EVENT:
        
        // lparam1 is the SSRC, lparam2 is the source IP
        ProcessParticipantTimeOutOrRecovered(TRUE, (DWORD)lParam1);
        
        break;

    case DXMRTP_EVENTBASE + DXMRTP_ACTIVE_AGAIN_EVENT:

        // lparam1 is the SSRC, lparam2 is the source IP
        ProcessParticipantTimeOutOrRecovered(FALSE, (DWORD)lParam1);
        
        break;

    case EC_COMPLETE:

        SendStreamEvent(CALL_STREAM_INACTIVE, CALL_CAUSE_UNKNOWN);
        break;

    case EC_USERABORT:

        SendStreamEvent(CALL_STREAM_INACTIVE, CALL_CAUSE_UNKNOWN);
        break;

    case EC_ERRORABORT:
    case EC_STREAM_ERROR_STOPPED:
    case EC_STREAM_ERROR_STILLPLAYING:
    case EC_ERROR_STILLPLAYING:

        SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_UNKNOWN, (HRESULT) lParam1);
        break;
    
    default:
        if ((lEventCode >= DXMRTP_QOSEVENTBASE + DXMRTP_QOSEVENT_NOQOS)
            && (lEventCode < DXMRTP_QOSEVENTBASE + DXMRTP_QOSEVENT_LAST))
        {
            ProcessQOSEvent(lEventCode - DXMRTP_QOSEVENTBASE);
        }

        break;
    }

    LOG((MSP_TRACE, "TRACE:CIPConfMSPStream::ProcessGraphEvent - exit S_OK"));
    return S_OK;
}

HRESULT CIPConfMSPStream::SetLocalInfoOnRTPFilter(
    IN  IBaseFilter *   pRTPFilter
    )
{
    IRTCPStream *pIRTCPStream;
    HRESULT hr = pRTPFilter->QueryInterface(
        IID_IRTCPStream, 
        (void **)&pIRTCPStream
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%ls can't get IRTCPStream interface %d", m_szName, hr));
        return hr;
    }

    for (int i = 0; i < RTCP_SDES_LAST - 1; i ++)
    {
        if (m_InfoItems[i] != NULL)
        {
            hr = pIRTCPStream->SetLocalSDESItem(
                RTCP_SDES_CNAME + i,
                (BYTE *)m_InfoItems[i],
                lstrlenA(m_InfoItems[i]) + 1
                );

            if (FAILED(hr))
            {
                LOG((MSP_WARN, "%ls can't set item:%s", m_InfoItems[i]));
            }
        }
    }

    pIRTCPStream->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\confmsp\confstrm.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ConfStrm.h

Abstract:

    Definitions for CIPConfMSPStream class.

Author:

    Mu Han (muhan) 1-November-1997

--*/
#ifndef __CONFSTRM_H
#define __CONFSTRM_H

#include <amrtpnet.h>   // rtp guilds

/////////////////////////////////////////////////////////////////////////////
// CIPConfMSPStream
/////////////////////////////////////////////////////////////////////////////

//#define DEBUG_REFCOUNT

#ifdef DEBUG_REFCOUNT
extern LONG g_lStreamObjects;
#endif

class ATL_NO_VTABLE CIPConfMSPStream : 
    public CMSPStream,
    public CMSPObjectSafetyImpl

{
public:

    BEGIN_COM_MAP(CIPConfMSPStream)
        COM_INTERFACE_ENTRY(IObjectSafety)
        COM_INTERFACE_ENTRY_CHAIN(CMSPStream)
    END_COM_MAP()

    CIPConfMSPStream();

#ifdef DEBUG_REFCOUNT
    
    ULONG InternalAddRef();
    ULONG InternalRelease();

#endif

    DWORD   MediaType() const               { return m_dwMediaType; }
    TERMINAL_DIRECTION  Direction() const   { return m_Direction;   }
    
    BOOL IsConfigured();

    virtual HRESULT Configure(
        IN      STREAMSETTINGS &StreamSettings
        ) = 0;

    // CMSPStream methods.
    HRESULT ShutDown ();

     // ITStream
    STDMETHOD (get_Name) (
        OUT     BSTR *      ppName
        );

    STDMETHOD (StartStream) ();
    STDMETHOD (PauseStream) ();
    STDMETHOD (StopStream) ();

    STDMETHOD (SelectTerminal)(
        IN      ITTerminal *            pTerminal
        );

    STDMETHOD (UnselectTerminal)(
        IN      ITTerminal *            pTerminal
        );

    // methods called by the MSPCall object.
    HRESULT Init(
        IN     HANDLE                   hAddress,
        IN     CMSPCallBase *           pMSPCall,
        IN     IMediaEvent *            pGraph,
        IN     DWORD                    dwMediaType,
        IN     TERMINAL_DIRECTION       Direction
        );

    HRESULT SetLocalParticipantInfo(
        IN      PARTICIPANT_TYPED_INFO  InfoType,
        IN      char *                  pInfo,
        IN      DWORD                   dwLen
        );

    // Called by stream and substream to send event to tapi.
    virtual HRESULT SendStreamEvent(
        IN      MSP_CALL_EVENT          Event,
        IN      MSP_CALL_EVENT_CAUSE    Cause,
        IN      HRESULT                 hrError,
        IN      ITTerminal *            pTerminal
        );

protected:
    HRESULT ProcessGraphEvent(
        IN  long lEventCode,
        IN  long lParam1,
        IN  long lParam2
        );

    virtual HRESULT CheckTerminalTypeAndDirection(
        IN      ITTerminal *    pTerminal
        );

    virtual HRESULT ConnectTerminal(
        IN  ITTerminal *   pITTerminal
        ) = 0;

    virtual HRESULT DisconnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    virtual HRESULT InternalConfigure();
    virtual HRESULT SetUpFilters() = 0;
    virtual HRESULT CleanUpFilters();

    virtual HRESULT ProcessParticipantTimeOutOrRecovered(
        IN  BOOL    fTimeOutOrRecovered,
        IN  DWORD   dwSSRC
        );

    virtual HRESULT ProcessRTCPReport(
        IN  DWORD   dwSSRC,
        IN  DWORD   dwSendRecv
        );

    virtual HRESULT ProcessParticipantLeave(
        IN  DWORD   dwSSRC
        );

    virtual HRESULT ProcessQOSEvent(
        IN  long lEventCode
        );

    virtual HRESULT ProcessNewSender(
        IN  DWORD dwSSRC, 
        IN  ITParticipant *pITParticipant
        );

    virtual HRESULT ProcessNewParticipant(
        IN  int                 index,
        IN  DWORD               dwSSRC,
        IN  DWORD               dwSendRecv,
        IN  char *              szCName,
        OUT ITParticipant **    ppITParticipant
        );

    virtual HRESULT NewParticipantPostProcess(
        IN  DWORD dwSSRC, 
        IN  ITParticipant *pITParticipant
        );

    virtual HRESULT SetLocalInfoOnRTPFilter(
        IN  IBaseFilter *   pRTPFilter
        );

protected:
    const WCHAR *       m_szName;

    const GUID *        m_pClsidPHFilter;
    const GUID *        m_pClsidCodecFilter;
    const GUID *        m_pRPHInputMinorType;  //only used in receiving stream.

    BOOL                m_fIsConfigured;
    STREAMSETTINGS      m_Settings;

    IBaseFilter *       m_pEdgeFilter;
    IRTPParticipant *   m_pRTPFilter;

    // The list of participant in the stream.
    CParticipantList    m_Participants;

    // the local info needed to be set on the RTP filter.
    char *              m_InfoItems[RTCP_SDES_LAST - 1];
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\confmsp\resource.h ===
#ifndef __RESOURCE_h_
#define __RESOURCE_h_

#define IDS_PROJNAME                  100
#define IDR_IPCONFMSP                 101

#define IDS_AUDIO_CAPTURE_STREAM      102
#define IDS_AUDIO_RENDER_STREAM       103
#define IDS_VIDEO_CAPTURE_STREAM      104
#define IDS_VIDEO_RENDER_STREAM       105

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\confmsp\confutil.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    MSPutil.cpp 

Abstract:

    This module contains implementation of msp utility functions.

Author:
    
    Mu Han (muhan)   1-November-1997

--*/
#include "stdafx.h"
#include "common.h"
#include <amrtpnet.h>   // rtp guilds
#include <amrtpdmx.h>   // demux guild
#include <amrtpuid.h>   // AMRTP media types

HRESULT
AddFilter(
    IN IGraphBuilder *      pIGraph,
    IN const CLSID &        Clsid,
    IN LPCWSTR              pwstrName,
    OUT IBaseFilter **      ppIBaseFilter
    )
/*++

Routine Description:

    Create a filter and add it into the filtergraph.

Arguments:
    
    pIGraph         - the filter graph.

    Clsid           - reference to the CLSID of the filter

    pwstrName       - The name of ther filter added.

    ppIBaseFilter   - pointer to a pointer that stores the returned IBaseFilter
                      interface pointer to the newly created filter.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "AddFilter %ws", pwstrName));

    _ASSERTE(ppIBaseFilter != NULL);

    HRESULT hr;

    if (FAILED(hr = CoCreateInstance(
            Clsid,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IBaseFilter,
            (void **) ppIBaseFilter
            )))
    {
        LOG((MSP_ERROR, "create filter %x", hr));
        return hr;
    }

    if (FAILED(hr = pIGraph->AddFilter(*ppIBaseFilter, pwstrName)))
    {
        LOG((MSP_ERROR, "add filter. %x", hr));
        (*ppIBaseFilter)->Release();
        *ppIBaseFilter = NULL;
        return hr;
    }

    return S_OK;
}

HRESULT
EnableRTCPEvents(
    IN  IBaseFilter *pIBaseFilter
    )
/*++

Routine Description:

    Set the address of a rtp stream

Arguments:
    
    pIBaseFilter    - an rtp source filters.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "EnableRTCPEvents"));

    HRESULT hr;

    // Get the IRTCPStream interface pointer on the filter.
    CComQIPtr<IRTCPStream, 
        &IID_IRTCPStream> pIRTCPStream(pIBaseFilter);
    if (pIRTCPStream == NULL)
    {
        LOG((MSP_ERROR, "get RTCP Stream interface"));
        return E_NOINTERFACE;
    }

    // enable events.
    if (FAILED(hr = pIRTCPStream->ModifyRTCPEventMask(  
            (1 << DXMRTP_NEW_SOURCE_EVENT) |
            (1 << DXMRTP_RECV_RTCP_SNDR_REPORT_EVENT) |
            (1 << DXMRTP_RECV_RTCP_RECV_REPORT_EVENT) |
            (1 << DXMRTP_TIMEOUT_EVENT) |
            (1 << DXMRTP_BYE_EVENT)   
            , 1
            )))
    {
        LOG((MSP_ERROR, "set Address. %x", hr));
        return hr;
    }

    return S_OK;
}


HRESULT
SetLoopbackOption(
    IN IBaseFilter *pIBaseFilter,
    IN BOOL         bLoopback
    )
/*++

Routine Description:

    Enable of disable loopback based on registry settings.

Arguments:
    
    pIBaseFilter    - rtp source filter.

    bLoopback       - enable loopback or not.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "SetLoopbackOption"));

    HRESULT hr;

    // Get the IRTPStream interface pointer on the filter.
    CComQIPtr<IRTPStream, 
        &IID_IRTPStream> pIRTPStream(pIBaseFilter);
    if (pIRTPStream == NULL)
    {
        LOG((MSP_ERROR, "get RTP Stream interface"));
        return E_NOINTERFACE;
    }

    // Set the TTL used in the filter.
    if (FAILED(hr = pIRTPStream->SetMulticastLoopBack(bLoopback)))
    {
        LOG((MSP_ERROR, "set loopback. %x", hr));
        return hr;
    }

    LOG((MSP_INFO, "loopback enabled."));
    return hr;
}

HRESULT
SetQOSOption(
    IN IBaseFilter *    pIBaseFilter,
    IN DWORD            dwPayloadType,
    IN DWORD            dwMaxBitRate,
    IN BOOL             bFailIfNoQOS,
    IN BOOL             bReceive,
    IN DWORD            dwNumStreams,
    IN BOOL             bCIF
    )
/*++

Routine Description:

    Enable QOS.

Arguments:
    
    pIBaseFilter    - rtp source filter.

    dwPayloadType   - the rtp payload type of this stream.

    bFailIfNoQOS    - fail the stream is QOS is not available.

    bReceive        - if this stream is a receiving stream.

    dwNumStreams    - the number of streams reserved.

    bCIF            - CIF or QCIF.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "SetQOSOption"));

    char * szQOSName;
    DWORD fSharedStyle = DXMRTP_RESERVE_EXPLICIT;

    switch (dwPayloadType)
    {
    case PAYLOAD_G711U:
    case PAYLOAD_G711A:
        szQOSName       = "G711";
        fSharedStyle    = DXMRTP_RESERVE_WILCARD;

        break;

    case PAYLOAD_GSM:
        
        szQOSName       = "GSM6.10";
        fSharedStyle    = DXMRTP_RESERVE_WILCARD;
        
        break;

    case PAYLOAD_G723:
        
        szQOSName       = "G723";
        fSharedStyle    = DXMRTP_RESERVE_WILCARD;

        break;

    case PAYLOAD_H261:
        szQOSName = (bCIF) ? "H261CIF" : "H261QCIF";
        break;

    case PAYLOAD_H263:
        szQOSName = (bCIF) ? "H263CIF" : "H263QCIF";
        break;

    default:
        LOG((MSP_WARN, "Don't know the QOS name for payload type: %d", 
            dwPayloadType));
        return S_FALSE;
    }

    // Get the IRTPStream interface pointer on the filter.
    CComQIPtr<IRTPStream, 
        &IID_IRTPStream> pIRTPStream(pIBaseFilter);
    if (pIRTPStream == NULL)
    {
        LOG((MSP_ERROR, "get RTP Stream interface"));
        return E_NOINTERFACE;
    }

    HRESULT hr;

    // Enable QOS, 
    if (FAILED(hr = pIRTPStream->SetQOSByName(szQOSName, bFailIfNoQOS)))
    {
        LOG((MSP_ERROR, "set QOS by name. %x", hr));
        return hr;
    }

    // Get the IRTPParticipant interface pointer on the filter.
    CComQIPtr<IRTPParticipant,
        &IID_IRTPParticipant> pIRTPParticipant(pIBaseFilter);
    if (pIRTPParticipant == NULL)
    {
        LOG((MSP_ERROR, "get RTP participant interface"));
        return E_NOINTERFACE;
    }

    if (FAILED(hr = pIRTPParticipant->SetMaxQOSEnabledParticipants(
            (bReceive) ? dwNumStreams : 1,
            dwMaxBitRate,
            fSharedStyle 
        )))
    {
        LOG((MSP_ERROR, "SetMaxQOSEnabledParticipants. %x", hr));
        return hr;
    }

    DWORD dwQOSEventMask = 
            (1 << DXMRTP_QOSEVENT_NOQOS) |
            (1 << DXMRTP_QOSEVENT_REQUEST_CONFIRMED) |
            (1 << DXMRTP_QOSEVENT_ADMISSION_FAILURE) |
            (1 << DXMRTP_QOSEVENT_POLICY_FAILURE) |
            (1 << DXMRTP_QOSEVENT_BAD_STYLE) |
            (1 << DXMRTP_QOSEVENT_BAD_OBJECT) |
            (1 << DXMRTP_QOSEVENT_TRAFFIC_CTRL_ERROR) |
            (1 << DXMRTP_QOSEVENT_GENERIC_ERROR);

    if (bReceive)
    {
        dwQOSEventMask |= 
            (1 << DXMRTP_QOSEVENT_SENDERS) |
            (1 << DXMRTP_QOSEVENT_NO_SENDERS);
    }
    else
    {
        dwQOSEventMask |= 
            (1 << DXMRTP_QOSEVENT_RECEIVERS) |
            (1 << DXMRTP_QOSEVENT_NO_RECEIVERS) |
            (1 << DXMRTP_QOSEVENT_NOT_ALLOWEDTOSEND) |
            (1 << DXMRTP_QOSEVENT_ALLOWEDTOSEND);
    }

    // enable events.
    if (FAILED(hr = pIRTPStream->ModifyQOSEventMask(dwQOSEventMask, 1)))
    {
        LOG((MSP_ERROR, "set QOSEventMask. %x", hr));
        return hr;
    }

    LOG((MSP_INFO, "enabled qos for %s.", szQOSName));
    return hr;
}

HRESULT
FindPin(
    IN  IBaseFilter *   pIFilter, 
    OUT IPin **         ppIPin, 
    IN  PIN_DIRECTION   direction,
    IN  BOOL            bFree
    )
/*++

Routine Description:

    Find a input pin or output pin on a filter.

Arguments:
    
    pIFilter    - the filter that has pins.

    ppIPin      - the place to store the returned interface pointer.

    direction   - PINDIR_INPUT or PINDIR_OUTPUT.

    bFree       - look for a free pin or not.

Return Value:

    HRESULT

--*/
{
    _ASSERTE(ppIPin != NULL);

    HRESULT hr;
    DWORD dwFeched;

    // Get the enumerator of pins on the filter.
    CComPtr<IEnumPins> pIEnumPins;
    if (FAILED(hr = pIFilter->EnumPins(&pIEnumPins)))
    {
        LOG((MSP_ERROR, "enumerate pins on the filter %x", hr));
        return hr;
    }

    IPin * pIPin = NULL;

    // Enumerate all the pins and break on the 
    // first pin that meets requirement.
    for (;;)
    {
        if (pIEnumPins->Next(1, &pIPin, &dwFeched) != S_OK)
        {
            LOG((MSP_ERROR, "find pin on filter."));
            return E_FAIL;
        }
        if (0 == dwFeched)
        {
            LOG((MSP_ERROR, "get 0 pin from filter."));
            return E_FAIL;
        }

        PIN_DIRECTION dir;
        if (FAILED(hr = pIPin->QueryDirection(&dir)))
        {
            LOG((MSP_ERROR, "query pin direction. %x", hr));
            pIPin->Release();
            return hr;
        }
        if (direction == dir)
        {
            if (!bFree)
            {
                break;
            }

            // Check to see if the pin is free.
            CComPtr<IPin> pIPinConnected;
            hr = pIPin->ConnectedTo(&pIPinConnected);
            if (pIPinConnected == NULL)
            {
                break;
            }
        }
        pIPin->Release();
    }

    *ppIPin = pIPin;

    return S_OK;
}

HRESULT
ConnectFilters(
    IN IGraphBuilder *  pIGraph,
    IN IBaseFilter *    pIFilter1, 
    IN IBaseFilter *    pIFilter2,
    IN BOOL             fDirect,
    IN AM_MEDIA_TYPE *  pmt
    )
/*++

Routine Description:

    Connect the output pin of the first filter to the input pin of the
    second filter.

Arguments:

    pIGraph     - the filter graph.

    pIFilter1   - the filter that has the output pin.

    pIFilter2   - the filter that has the input pin.

    pmt         - a pointer to a AM_MEDIA_TYPE used in the connection.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "ConnectFilters"));

    HRESULT hr;

    CComPtr<IPin> pIPinOutput;
    if (FAILED(hr = ::FindPin(pIFilter1, &pIPinOutput, PINDIR_OUTPUT)))
    {
        LOG((MSP_ERROR, "find output pin on filter1. %x", hr));
        return hr;
    }

    CComPtr<IPin> pIPinInput;
    if (FAILED(hr = ::FindPin(pIFilter2, &pIPinInput, PINDIR_INPUT)))
    {
        LOG((MSP_ERROR, "find input pin on filter2. %x", hr));
        return hr;
    }

    if (fDirect)
    {
        if (FAILED(hr = pIGraph->ConnectDirect(pIPinOutput, pIPinInput, pmt))) 
        {
            LOG((MSP_ERROR, "connect pins direct failed: %x", hr));
            return hr;
        }
    }
    else
    {
        if (FAILED(hr = pIGraph->Connect(pIPinOutput, pIPinInput))) 
        {
            LOG((MSP_ERROR, "connect pins %x", hr));
            return hr;
        }
    }
 
    return S_OK;
}

HRESULT
ConnectFilters(
    IN IGraphBuilder *  pIGraph,
    IN IPin *           pIPinOutput, 
    IN IBaseFilter *    pIFilter,
    IN BOOL             fDirect,
    IN AM_MEDIA_TYPE *  pmt
    )
/*++

Routine Description:

    Connect an output pin to the input pin of a filter.

Arguments:
    
    pIGraph     - the filter graph.

    pIPinOutput - an output pin.

    pIFilter    - a filter that has the input pin.

    pmt         - a pointer to a AM_MEDIA_TYPE used in the connection.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "ConnectFilters"));

    HRESULT hr;
    CComPtr<IPin> pIPinInput;

    if (FAILED(hr = ::FindPin(pIFilter, &pIPinInput, PINDIR_INPUT)))
    {
        LOG((MSP_ERROR, "find input pin on filter. %x", hr));
        return hr;
    }

    if (fDirect)
    {
        if (FAILED(hr = pIGraph->ConnectDirect(pIPinOutput, pIPinInput, pmt))) 
        {
            LOG((MSP_ERROR, "connect pins direct failed: %x", hr));
            return hr;
        }
    }
    else
    {
        if (FAILED(hr = pIGraph->Connect(pIPinOutput, pIPinInput))) 
        {
            LOG((MSP_ERROR, "connect pins %x", hr));
            return hr;
        }
    }
    return S_OK;
}

HRESULT
ConnectFilters(
    IN IGraphBuilder *  pIGraph,
    IN IBaseFilter *    pIFilter,
    IN IPin *           pIPinInput, 
    IN BOOL             fDirect,
    IN AM_MEDIA_TYPE *  pmt
    )
/*++

Routine Description:

    Connect an filter to the input pin of a filter.

Arguments:
    
    pIGraph     - the filter graph.

    pIPinOutput - an output pin.

    pIFilter    - a filter that has the input pin.

    pmt         - a pointer to a AM_MEDIA_TYPE used in the connection.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "ConnectFilters"));

    HRESULT hr;
    CComPtr<IPin> pIPinOutput;

    if (FAILED(hr = ::FindPin(pIFilter, &pIPinOutput, PINDIR_OUTPUT)))
    {
        LOG((MSP_ERROR, "find input pin on filter. %x", hr));
        return hr;
    }

    if (fDirect)
    {
        if (FAILED(hr = pIGraph->ConnectDirect(pIPinOutput, pIPinInput, pmt))) 
        {
            LOG((MSP_ERROR, "connect pins direct failed: %x", hr));
            return hr;
        }
    }
    else
    {
        if (FAILED(hr = pIGraph->Connect(pIPinOutput, pIPinInput))) 
        {
            LOG((MSP_ERROR, "connect pins %x", hr));
            return hr;
        }
    }

    return S_OK;
}


void WINAPI MSPDeleteMediaType(AM_MEDIA_TYPE *pmt)
/*++

Routine Description:
    
    Delete a AM media type returned by the filters.

Arguments:

    pmt     - a pointer to a AM_MEDIA_TYPE structure.

Return Value:

    HRESULT

--*/
{
    // allow NULL pointers for coding simplicity

    if (pmt == NULL) {
        return;
    }

    if (pmt->cbFormat != 0) {
        CoTaskMemFree((PVOID)pmt->pbFormat);

        // Strictly unnecessary but tidier
        pmt->cbFormat = 0;
        pmt->pbFormat = NULL;
    }
    if (pmt->pUnk != NULL) {
        pmt->pUnk->Release();
        pmt->pUnk = NULL;
    }

    CoTaskMemFree((PVOID)pmt);
}


BOOL 
GetRegValue(
    IN  LPCWSTR szName, 
    OUT DWORD   *pdwValue
    )
/*++

Routine Description:

    Get a dword from the registry in the ipconfmsp key.

Arguments:
    
    szName  - The name of the value.

    pdwValue  - a pointer to the dword returned.

Return Value:

    TURE    - SUCCEED.

    FALSE   - MSP_ERROR

--*/
{
    HKEY  hKey;
    DWORD dwDataSize, dwDataType, dwValue;

    if (::RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        gszSDPMSPKey,
        0,
        KEY_READ,
        &hKey) != NOERROR)
    {
        return FALSE;
    }

    dwDataSize = sizeof(DWORD);
    if (::RegQueryValueExW(
        hKey,
        szName,
        0,
        &dwDataType,
        (LPBYTE) &dwValue,
        &dwDataSize) != NOERROR)
    {
        RegCloseKey (hKey);
        return FALSE;
    }

    *pdwValue = dwValue;

    RegCloseKey (hKey);
    
    return TRUE;
}


HRESULT
FindACMAudioCodec(
    IN DWORD dwPayloadType,
    OUT IBaseFilter **ppIBaseFilter
    )
/*++

Routine Description:

    Find the audio codec filter based on the payload type.

Arguments:
    
    dwPayloadType   - The rtp payload type.

    ppIBaseFilter   - The returned interface pointer.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "Find audio codec Called."));

    _ASSERTE(ppIBaseFilter != NULL);

    HRESULT hr;

    int AcmId;

    switch (dwPayloadType)
    {
    case PAYLOAD_G711A:
        AcmId = WAVE_FORMAT_ALAW;
        break;

    case PAYLOAD_G711U:
        AcmId = WAVE_FORMAT_MULAW;
        break;

    case PAYLOAD_GSM:
        AcmId = WAVE_FORMAT_GSM610;
        break;

    case PAYLOAD_MSAUDIO:
        AcmId = WAVE_FORMAT_MSAUDIO1;
        break;

    case PAYLOAD_G721:
        AcmId = WAVE_FORMAT_ADPCM;
        break;
    
    case PAYLOAD_DVI4_8:
        AcmId = WAVE_FORMAT_DVI_ADPCM;
        break;
    
    default:
        return E_FAIL;
    }

    //
    // Create the DirectShow Category enumerator Creator
    //
    CComPtr<ICreateDevEnum> pCreateDevEnum;
    CComPtr<IEnumMoniker> pCatEnum;

    hr = CoCreateInstance(
        CLSID_SystemDeviceEnum, 
        NULL, 
        CLSCTX_INPROC_SERVER,
        IID_ICreateDevEnum, 
        (void**)&pCreateDevEnum);

    if (FAILED(hr)) 
    {
        LOG((MSP_ERROR, "Create system device enum - hr: %8x", hr));
        return hr;
    }

    hr = pCreateDevEnum->CreateClassEnumerator(
        CLSID_CAcmCoClassManager, 
        &pCatEnum, 
        0
        );

    if (hr != S_OK) 
    {
        LOG((MSP_ERROR, "CreateClassEnumerator - hr: %8x", hr));
        return hr;
    }

    // find the acm wrapper we want to use.
    for (;;)
    {
        ULONG cFetched;
        CComPtr<IMoniker> pMoniker;

        if (S_OK != (hr = pCatEnum->Next(1, &pMoniker, &cFetched)))
        {
            break;
        }

        // Get the ACMid for this filter out of the property bag.
        CComPtr<IPropertyBag> pBag;
        hr = pMoniker->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pBag);
        if (FAILED(hr)) 
        {
            LOG((MSP_ERROR, "get property bag - hr: %8x", hr));
            continue;
        }

        VARIANT var;
        var.vt = VT_I4;
        hr = pBag->Read(L"AcmId", &var, 0);
        if (FAILED(hr)) 
        {
            LOG((MSP_ERROR, "read acmid - hr: %8x", hr));
            continue;
        }

        if (AcmId == V_I4(&var))
        {
            // Now make the filter for this.
            hr = pMoniker->BindToObject(
                0, 
                0, 
                IID_IBaseFilter, 
                (void**)ppIBaseFilter
                );

            if (FAILED(hr))
            {
                LOG((MSP_ERROR, "BindToObject - hr: %8x", hr));
            }
            break;
        }
    }

    return hr;
}

HRESULT SetAudioFormat(
    IN  IUnknown*   pIUnknown,
    IN  WORD        wBitPerSample,
    IN  DWORD       dwSampleRate
    )
/*++

Routine Description:

    Get the IAMStreamConfig interface on the pin and config the
    audio format by using WAVEFORMATEX.

Arguments:
    
    pIUnknown - an object to configure.

    wBitPerSample  - the number of bits in each sample.

    dwSampleRate    - number of samples per second.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "SetAudioFormat entered"));

    HRESULT hr;

    CComPtr<IAMStreamConfig> pIAMStreamConfig;

    if (FAILED(hr = pIUnknown->QueryInterface(
        IID_IAMStreamConfig,
        (void **)&pIAMStreamConfig
        )))
    {
        LOG((MSP_ERROR, "Can't get IAMStreamConfig interface.%8x", hr));
        return hr;
    }

    AM_MEDIA_TYPE mt;
    WAVEFORMATEX wfx;

    wfx.wFormatTag          = WAVE_FORMAT_PCM;
    wfx.wBitsPerSample      = wBitPerSample;
    wfx.nChannels           = 1;
    wfx.nSamplesPerSec      = dwSampleRate;
    wfx.nBlockAlign         = wfx.wBitsPerSample * wfx.nChannels / 8;
    wfx.nAvgBytesPerSec     = ((DWORD) wfx.nBlockAlign * wfx.nSamplesPerSec);
    wfx.cbSize              = 0;

    mt.majortype            = MEDIATYPE_Audio;
    mt.subtype              = MEDIASUBTYPE_PCM;
    mt.bFixedSizeSamples    = TRUE;
    mt.bTemporalCompression = FALSE;
    mt.lSampleSize          = 0;
    mt.formattype           = FORMAT_WaveFormatEx;
    mt.pUnk                 = NULL;
    mt.cbFormat             = sizeof(WAVEFORMATEX);
    mt.pbFormat             = (BYTE*)&wfx;

    // set the format of the audio capture terminal.
    if (FAILED(hr = pIAMStreamConfig->SetFormat(&mt)))
    {
        LOG((MSP_ERROR, "SetFormat returns error: %8x", hr));
        return hr;
    }

    return S_OK;
}

HRESULT SetAudioBufferSize(
    IN  IUnknown*   pIUnknown,
    IN  DWORD       dwNumBuffers,
    IN  DWORD       dwBufferSize
    )
/*++

Routine Description:

    Set the audio capture output pin's buffer size. The buffer size
    determins how many milliseconds worth of samples are contained 
    in a buffer.

Arguments:
    
    pIUnknown - an object to configure.

    dwNumBuffers - the number of buffers to be allocated. Too few buffers
    might cause starvation on the capture device.

    dwBufferSize - The size of each buffer.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "SetAudioBufferSize, dwNumBuffers %d, dwBuffersize %d",
        dwNumBuffers, dwBufferSize));

    _ASSERTE(dwNumBuffers != 0 && dwBufferSize != 0);

    HRESULT hr;

    CComPtr<IAMBufferNegotiation> pBN;
    if (FAILED(hr = pIUnknown->QueryInterface(
            IID_IAMBufferNegotiation,
            (void **)&pBN
            )))
    {
        LOG((MSP_ERROR, "Can't get buffer negotiation.%8x", hr));
        return hr;
    }

    ALLOCATOR_PROPERTIES prop;

    // Set the number of buffers.
    prop.cBuffers = dwNumBuffers;
    prop.cbBuffer = dwBufferSize;

    prop.cbAlign  = -1;
    prop.cbPrefix = -1;

    if (FAILED(hr = pBN->SuggestAllocatorProperties(&prop)))
    {
        LOG((MSP_ERROR, "SuggestAllocatorProperties returns error: %8x", hr));
    }
    else
    {
        LOG((MSP_INFO, 
            "SetAudioBuffersize"
            " buffers: %d, buffersize: %d, align: %d, Prefix: %d",
            prop.cBuffers,
            prop.cbBuffer,
            prop.cbAlign,
            prop.cbPrefix
            ));
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\confmsp\confutil.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    MSPCall.h

Abstract:

    Definitions for MSP utililty functions. There are all related to 
    active movie filter manipulation.

Author:
    
    Mu Han (muhan) 1-November-1997

--*/

#ifndef __MSPUTIL_H
#define __MSPUTIL_H

const DWORD PAYLOAD_G711U   = 0;
const DWORD PAYLOAD_G721    = 2;
const DWORD PAYLOAD_GSM     = 3;
const DWORD PAYLOAD_G723    = 4;
const DWORD PAYLOAD_DVI4_8  = 5;
const DWORD PAYLOAD_DVI4_16 = 6;
const DWORD PAYLOAD_G711A   = 8;
const DWORD PAYLOAD_MSAUDIO = 12;
const DWORD PAYLOAD_H261    = 31;
const DWORD PAYLOAD_H263    = 34;

const WCHAR gszMSPLoopback[] = L"Loopback";
const WCHAR gszNumVideoCaptureBuffers[] = L"NumVideoCaptureBuffers";

const TCHAR gszSDPMSPKey[]   =
   _T("Software\\Microsoft\\Windows\\CurrentVersion\\IPConfMSP\\");


HRESULT
FindPin(
    IN  IBaseFilter *   pIFilter, 
    OUT IPin **         ppIPin, 
    IN  PIN_DIRECTION   direction,
    IN  BOOL            bFree = TRUE
    );

HRESULT
AddFilter(
    IN  IGraphBuilder *     pIGraph,
    IN  const CLSID &       Clsid,
    IN  LPCWSTR             pwstrName,
    OUT IBaseFilter **      ppIBaseFilter
    );

HRESULT
SetLoopbackOption(
    IN IBaseFilter *pIBaseFilter,
    IN BOOL         bLoopback
    );

HRESULT
SetQOSOption(
    IN IBaseFilter *    pIBaseFilter,
    IN DWORD            dwPayloadType,
    IN DWORD            dwMaxBitRate,
    IN BOOL             bFailIfNoQOS,
    IN BOOL             bReceive = FALSE,
    IN DWORD            dwNumStreams = 1,
    IN BOOL             bCIF = FALSE
    );

HRESULT
ConnectFilters(
    IN IGraphBuilder *  pIGraph,
    IN IBaseFilter *    pIFilter1, 
    IN IBaseFilter *    pIFilter2,
    IN BOOL             fDirect = TRUE,
    IN AM_MEDIA_TYPE *  pmt = NULL
    );

HRESULT
ConnectFilters(
    IN IGraphBuilder *  pIGraph,
    IN IPin *           pIPinOutput, 
    IN IBaseFilter *    pIFilter,
    IN BOOL             fDirect = TRUE,
    IN AM_MEDIA_TYPE *  pmt = NULL
    );

HRESULT
ConnectFilters(
    IN IGraphBuilder *  pIGraph,
    IN IBaseFilter *    pIFilter,
    IN IPin *           pIPinInput, 
    IN BOOL             fDirect = TRUE,
    IN AM_MEDIA_TYPE *  pmt = NULL
    );

HRESULT
EnableRTCPEvents(
    IN  IBaseFilter *pIBaseFilter
    );

void WINAPI MSPDeleteMediaType(AM_MEDIA_TYPE *pmt);


BOOL 
GetRegValue(
    IN  LPCWSTR szName, 
    OUT DWORD   *pdwValue
    );

HRESULT
FindACMAudioCodec(
    IN DWORD dwPayloadType,
    OUT IBaseFilter **ppIBaseFilter
    );

HRESULT SetAudioFormat(
    IN  IUnknown*   pIUnknown,
    IN  WORD        wBitPerSample,
    IN  DWORD       dwSampleRate
    );

HRESULT SetAudioBufferSize(
    IN  IUnknown*   pIUnknown,
    IN  DWORD       dwNumBuffers,
    IN  DWORD       dwBufferSize
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\confmsp\confvid.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    confvid.cpp

Abstract:

    This module contains implementation of the video send and receive
    stream implementations.

Author:

    Mu Han (muhan)   15-September-1999

--*/

#include "stdafx.h"
#include "common.h"

#include <irtprph.h>    // for IRTPRPHFilter
#include <irtpsph.h>    // for IRTPSPHFilter
#include <amrtpuid.h>   // AMRTP media types
#include <amrtpnet.h>   // rtp guids
#include <ih26xcd.h>    // for the h26X encoder filter

#include <initguid.h>
#include <amrtpdmx.h>   // demux guid

#include <viduids.h>    // for video CLSIDs

/////////////////////////////////////////////////////////////////////////////
//
//  CStreamVideoRecv
//
/////////////////////////////////////////////////////////////////////////////

CStreamVideoRecv::CStreamVideoRecv()
    : CIPConfMSPStream(),
      m_pIRTPDemux(NULL)
{
      m_szName = L"VideoRecv";
}

HRESULT CStreamVideoRecv::Init(
    IN     HANDLE                   hAddress,
    IN     CMSPCallBase *           pMSPCall,
    IN     IMediaEvent *            pIGraphBuilder,
    IN     DWORD                    dwMediaType,
    IN     TERMINAL_DIRECTION       Direction
    )
/*++

Routine Description:
    Init our substream array and then call the base class' Init.

Arguments:

    hAddress    - a handle to the address, used in identify terminals.

    pMSPCall    - the call object that owns the stream.

    pIGraphBuilder - the filter graph object.

    dwMediaType - the mediatype of this stream.

    Direction  - the direction of this stream.

Return Value:
    
    S_OK,
    E_OUTOFMEMORY

--*/
{
    LOG((MSP_TRACE, "CSubStreamVideoRecvVideoSend::Init - enter"));

    // initialize the stream array so that the array is not NULL.
    if (!m_SubStreams.Grow())
    {
        LOG((MSP_TRACE, "CSubStreamVideoRecvVideoSend::Init - return out of memory"));
        return E_OUTOFMEMORY;
    }

    return CIPConfMSPStream::Init(
        hAddress, pMSPCall, pIGraphBuilder,dwMediaType, Direction
        );
}

HRESULT CStreamVideoRecv::ShutDown()
/*++

Routine Description:

    Shut down the stream. 

Arguments:
    

Return Value:

S_OK

--*/
{
    CLock lock(m_lock);

    // Release the memory for the local participant info items.
    for (int j = 0; j < RTCP_SDES_LAST - 1; j ++)
    {
        if (m_InfoItems[j])
        {
            free(m_InfoItems[j]);
            m_InfoItems[j] = NULL;
        }
    }

    // Release the refcount on the call object.
    if (m_pMSPCall)
    {
        m_pMSPCall->MSPCallRelease();
        m_pMSPCall  = NULL;
    }

    // if there are branches and configured, we need to disconnect 
    // the terminals and remove the branches.
    if (m_Branches.GetSize() > 0)
    {
        // Stop the graph before disconnecting the terminals.
        HRESULT hr = CMSPStream::StopStream();
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, 
                "stream %ws %p failed to stop, %x", m_szName, this, hr));
            return hr;
        }

        for (int i = 0; i < m_Branches.GetSize(); i ++)
        {
            RemoveOneBranch(&m_Branches[i]);
        }
        m_Branches.RemoveAll();
    }

    // free the extra filter reference.
    if (m_pEdgeFilter)
    {
        m_pEdgeFilter->Release();
        m_pEdgeFilter = NULL;
    }

    if (m_pIRTPDemux)
    {
        m_pIRTPDemux->Release();
        m_pIRTPDemux = NULL;
    }

    if (m_pRTPFilter)
    {
        m_pRTPFilter->Release();
        m_pRTPFilter = NULL;
    }

    // release all the substream objects.
    for (int i = 0; i < m_SubStreams.GetSize(); i ++)
    {
        m_SubStreams[i]->Release();
    }
    m_SubStreams.RemoveAll();

    // release all the terminals.
    for (i = 0; i < m_Terminals.GetSize(); i ++ )
    {
        m_Terminals[i]->Release();
    }
    m_Terminals.RemoveAll();

    // release all the participants.
    for (i = 0; i < m_Participants.GetSize(); i ++)
    {
        m_Participants[i]->Release();
    }
    m_Participants.RemoveAll();

    LOG((MSP_TRACE, "CStreamVideoRecv::Shutdown - exit S_OK"));

    return S_OK;
}

HRESULT CStreamVideoRecv::InternalCreateSubStream(
    OUT ITSubStream ** ppSubStream
    )
/*++

Routine Description:
    This method creat a substream object and add it into out list.
    
Arguments:
    ppSubStream - the memory location that will store the returned SubStream.
  
Return Value:

S_OK
E_OUTOFMEMORY
E_NOINTERFACE

--*/
{
    CComObject<CSubStreamVideoRecv> * pCOMSubStream;

    HRESULT hr = CComObject<CSubStreamVideoRecv>::CreateInstance(&pCOMSubStream);

    if (NULL == pCOMSubStream)
    {
        LOG((MSP_ERROR, "could not create video recv sub stream:%x", hr));
        return hr;
    }

    ITSubStream* pSubStream;

    // get the interface pointer.
    hr = pCOMSubStream->_InternalQueryInterface(
        IID_ITSubStream, 
        (void **)&pSubStream
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Create VideoRecv Substream QueryInterface failed: %x", hr));
        delete pCOMSubStream;
        return hr;
    }

    // Initialize the object.
    hr = pCOMSubStream->Init(this);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CreateMSPSubStream:call init failed: %x", hr));
        pSubStream->Release();

        return hr;
    }

    // Add the SubStream into our list of SubStreams. This takes a refcount.
    if (!m_SubStreams.Add(pSubStream))
    {
        pSubStream->Release();

        LOG((MSP_ERROR, "out of memory in adding a SubStream."));
        return E_OUTOFMEMORY;
    }
    
    // AddRef the interface pointer and return it.
    pSubStream->AddRef(); 
    *ppSubStream = pSubStream;

    return S_OK;
}

// ITSubStreamControl methods, called by the app.
STDMETHODIMP CStreamVideoRecv::CreateSubStream(
    IN OUT  ITSubStream **         ppSubStream
    )
/*++

Routine Description:
    This method creates a new substream on this video receive stream. Since
    the substreams are created based on the participants, this function
    returns only TAPI_E_NOTSUPPORTED.

Arguments:
    ppSubStream - the memory location that will store the returned SubStream.
  
Return Value:

TAPI_E_NOTSUPPORTED

--*/
{
    return TAPI_E_NOTSUPPORTED;
}

STDMETHODIMP CStreamVideoRecv::RemoveSubStream(
    IN      ITSubStream *          pSubStream
    )
/*++

Routine Description:
    This method remove substream on this video receive stream. Since
    the substreams are created based on the participants, this function
    returns only TAPI_E_NOTSUPPORTED.

Arguments:
    pSubStream - the SubStream to be removed.
  
Return Value:

TAPI_E_NOTSUPPORTED
--*/
{
    return TAPI_E_NOTSUPPORTED;
}

STDMETHODIMP CStreamVideoRecv::EnumerateSubStreams(
    OUT     IEnumSubStream **      ppEnumSubStream
    )
/*++

Routine Description:
    This method returns an enumerator of the substreams. 

Arguments:
    ppEnumSubStream - the memory location to store the returned pointer.
  
Return Value:

S_OK
E_POINTER
E_UNEXPECTED
E_OUTOFMEMORY

--*/
{
    LOG((MSP_TRACE, 
        "EnumerateSubStreams entered. ppEnumSubStream:%x", ppEnumSubStream));

    //
    // Check parameters.
    //

    if (IsBadWritePtr(ppEnumSubStream, sizeof(VOID *)))
    {
        LOG((MSP_ERROR, "CMSPCallBase::EnumerateSubStreams - "
            "bad pointer argument - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // First see if this call has been shut down.
    // acquire the lock before accessing the SubStream object list.
    //

    CLock lock(m_lock);

    if (m_SubStreams.GetData() == NULL)
    {
        LOG((MSP_ERROR, "CMSPCallBase::EnumerateSubStreams - "
            "call appears to have been shut down - exit E_UNEXPECTED"));

        // This call has been shut down.
        return E_UNEXPECTED;
    }

    //
    // Create an enumerator object.
    //

    typedef _CopyInterface<ITSubStream> CCopy;
    typedef CSafeComEnum<IEnumSubStream, &IID_IEnumSubStream, 
                ITSubStream *, CCopy> CEnumerator;

    HRESULT hr;

    CComObject<CEnumerator> *pEnum = NULL;

    hr = CComObject<CEnumerator>::CreateInstance(&pEnum);
    if (pEnum == NULL)
    {
        LOG((MSP_ERROR, "CMSPCallBase::EnumerateSubStreams - "
            "Could not create enumerator object, %x", hr));

        return hr;
    }

    //
    // query for the IID_IEnumSubStream i/f
    //


    IEnumSubStream *      pEnumSubStream;
    hr = pEnum->_InternalQueryInterface(IID_IEnumSubStream, (void**)&pEnumSubStream);
    
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CMSPCallBase::EnumerateSubStreams - "
            "query enum interface failed, %x", hr));

        delete pEnum;
        return hr;
    }

    //
    // Init the enumerator object. The CSafeComEnum can handle zero-sized array.
    //

    hr = pEnum->Init(
        m_SubStreams.GetData(),                        // the begin itor
        m_SubStreams.GetData() + m_SubStreams.GetSize(),  // the end itor, 
        NULL,                                       // IUnknown
        AtlFlagCopy                                 // copy the data.
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CMSPCallBase::EnumerateSubStreams - "
            "init enumerator object failed, %x", hr));

        pEnumSubStream->Release();
        return hr;
    }

    LOG((MSP_TRACE, "CMSPCallBase::EnumerateSubStreams - exit S_OK"));

    *ppEnumSubStream = pEnumSubStream;

    return hr;
}

STDMETHODIMP CStreamVideoRecv::get_SubStreams(
    OUT     VARIANT *              pVariant
    )
/*++

Routine Description:
    This method returns a collection of the substreams. 

Arguments:
    pVariant - a variant structure.
  
Return Value:

S_OK
E_POINTER
E_UNEXPECTED
E_OUTOFMEMORY

--*/
{
    LOG((MSP_TRACE, "CStreamVideoRecv::get_SubStreams - enter"));

    //
    // Check parameters.
    //

    if ( IsBadWritePtr(pVariant, sizeof(VARIANT) ) )
    {
        LOG((MSP_ERROR, "CStreamVideoRecv::get_SubStreams - "
            "bad pointer argument - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // See if this call has been shut down. Acquire the lock before accessing
    // the SubStream object list.
    //

    CLock lock(m_lock);

    if (m_SubStreams.GetData() == NULL)
    {
        LOG((MSP_ERROR, "CStreamVideoRecv::get_SubStreams - "
            "call appears to have been shut down - exit E_UNEXPECTED"));

        // This call has been shut down.
        return E_UNEXPECTED;
    }

    //
    // create the collection object - see mspcoll.h
    //

    typedef CTapiIfCollection< ITSubStream * > SubStreamCollection;
    CComObject<SubStreamCollection> * pCollection;
    HRESULT hr = CComObject<SubStreamCollection>::CreateInstance( &pCollection );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CStreamVideoRecv::get_SubStreams - "
            "can't create collection - exit 0x%08x", hr));

        return hr;
    }

    //
    // get the Collection's IDispatch interface
    //

    IDispatch * pDispatch;

    hr = pCollection->_InternalQueryInterface(IID_IDispatch,
                                              (void **) &pDispatch );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CStreamVideoRecv::get_SubStreams - "
            "QI for IDispatch on collection failed - exit 0x%08x", hr));

        delete pCollection;

        return hr;
    }

    //
    // Init the collection using an iterator -- pointers to the beginning and
    // the ending element plus one.
    //

    hr = pCollection->Initialize( m_SubStreams.GetSize(),
                                  m_SubStreams.GetData(),
                                  m_SubStreams.GetData() + m_SubStreams.GetSize() );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CStreamVideoRecv::get_SubStreams - "
            "Initialize on collection failed - exit 0x%08x", hr));
        
        pDispatch->Release();
        return hr;
    }

    //
    // put the IDispatch interface pointer into the variant
    //

    VariantInit(pVariant);
    pVariant->vt = VT_DISPATCH;
    pVariant->pdispVal = pDispatch;

    LOG((MSP_TRACE, "CStreamVideoRecv::get_SubStreams - exit S_OK"));
 
    return S_OK;
}

HRESULT CStreamVideoRecv::Configure(
    IN STREAMSETTINGS &StreamSettings
    )
/*++

Routine Description:

    Configure the settings of this stream.

Arguments:
    
    StreamSettings - The setting structure got from the SDP blob.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "VideoRecv configure entered."));

    CLock lock(m_lock);
    
    _ASSERTE(m_fIsConfigured == FALSE);

    switch (StreamSettings.dwPayloadType)
    {
    case PAYLOAD_H261:

        m_pClsidCodecFilter  = &CLSID_H261_DECODE_FILTER;
        m_pRPHInputMinorType = &MEDIASUBTYPE_RTP_Payload_H261; 
        m_pClsidPHFilter     = &CLSID_INTEL_RPHH26X;
        break;

    case PAYLOAD_H263:

        m_pClsidCodecFilter  = &CLSID_H263_DECODE_FILTER;
        m_pRPHInputMinorType = &MEDIASUBTYPE_RTP_Payload_H263; 
        m_pClsidPHFilter     = &CLSID_INTEL_RPHH26X;

        break;

    default:
        LOG((MSP_ERROR, "unknow payload type, %x", StreamSettings.dwPayloadType));
        return E_FAIL;
    }
    
    m_Settings      = StreamSettings;
    m_fIsConfigured = TRUE;

    return InternalConfigure();
}

HRESULT CStreamVideoRecv::CheckTerminalTypeAndDirection(
    IN      ITTerminal *            pTerminal
    )
/*++

Routine Description:
    
    Check to see if the terminal is allowed on this stream. Only video 
    render terminal is allowed.

Arguments:

    pTerminal   - the terminal.

Return value:

    S_OK 
    TAPI_E_INVALIDTERMINAL
*/
{
    LOG((MSP_TRACE, "VideoRecv.CheckTerminalTypeAndDirection"));

    // check the media type of this terminal.
    long lMediaType;
    HRESULT hr = pTerminal->get_MediaType(&lMediaType);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get terminal media type. %x", hr));
        return TAPI_E_INVALIDTERMINAL;
    }

    if ((DWORD)lMediaType != m_dwMediaType)
    {
        return TAPI_E_INVALIDTERMINAL;
    }

    // check the direction of this terminal.
    TERMINAL_DIRECTION Direction;
    hr = pTerminal->get_Direction(&Direction);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get terminal direction. %x", hr));
        return TAPI_E_INVALIDTERMINAL;
    }

    if (Direction != m_Direction)
    {
        return TAPI_E_INVALIDTERMINAL;
    }

    return S_OK;
}

HRESULT CStreamVideoRecv::SubStreamSelectTerminal(
    IN  ITSubStream * pITSubStream, 
    IN  ITTerminal * pITTerminal
    )
/*++

Routine Description:

    handle terminals being selected on the sub streams. It gives the terminal
    to one free branch and then sets up a mapping between the branch and the
    substream, so that the participant in the substream is displayed on the
    terminal selected.

Arguments:
    
    pITSubStream - the Substream that got a terminal selected.

    pITTerminal - the terminal object.

Return Value:

S_OK

--*/
{
    LOG((MSP_TRACE, "VideoRecv SubStreamSelectTerminal"));

    HRESULT hr;

    CLock lock(m_lock);
    
    // Call the base class's select terminal first. The terminal will be put
    // into the terminal pool and a branch of filters will be created for it.
    hr = CIPConfMSPStream::SelectTerminal(pITTerminal);

    if (FAILED(hr))
    {
        return hr;
    }

    // Find out which branch got the terminal.
    int i;
    for (i = 0; i < m_Branches.GetSize(); i ++)
    {
        if (m_Branches[i].pITTerminal == pITTerminal)
        {
            break;
        }
    }

    _ASSERTE(i < m_Branches.GetSize());

    if (i >= m_Branches.GetSize())
    {
        return E_UNEXPECTED;
    }

    // Find out the participant on the SubStream.
    ITParticipant *pITParticipant = NULL;
    DWORD dwSSRC;

    if (((CSubStreamVideoRecv*)m_SubStreams[i])->GetCurrentParticipant(
        &dwSSRC,
        &pITParticipant
        ) == FALSE)
    {
        return E_UNEXPECTED;
    }

    pITParticipant->Release();

    if (m_pIRTPDemux == NULL)
    {
        LOG((MSP_ERROR, "no demux filter"));
        return E_UNEXPECTED;
    }

    // map the pin to this SSRC only.
    hr = m_pIRTPDemux->MapSSRCToPin(dwSSRC, m_Branches[i].pIPin);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "map SSRC %x to pin %p returned %x", 
            dwSSRC, m_Branches[i].pIPin, hr));
        return hr;
    }    

    _ASSERTE(m_Branches[i].pITSubStream == NULL);

    pITSubStream->AddRef();
    m_Branches[i].pITSubStream = pITSubStream;
    m_Branches[i].dwSSRC = dwSSRC;
    
    return hr;
}

HRESULT CStreamVideoRecv::ConfigureRTPFilter(
    IN  IBaseFilter *   pIBaseFilter
    )
/*++

Routine Description:

    Configure the source RTP filter. Including set the address, port, TTL,
    QOS, thread priority, clockrate, etc.

Arguments:
    
    pIBaseFilter - The source RTP Filter.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "VideoRecv ConfigureRTPFilter"));

    HRESULT hr;

    // Get the IRTPStream interface pointer on the filter.
    CComQIPtr<IRTPStream, &IID_IRTPStream> pIRTPStream(pIBaseFilter);
    if (pIRTPStream == NULL)
    {
        LOG((MSP_ERROR, "get RTP Stream interface"));
        return E_NOINTERFACE;
    }

    LOG((MSP_INFO, "set remote Address:%x, port:%d", 
        m_Settings.dwIPRemote, m_Settings.wRTPPortRemote));

    // Set the address and port used in the filter.
    if (FAILED(hr = pIRTPStream->SetAddress(
        htons(m_Settings.wRTPPortRemote),   // local port to listen on.
        0,                                  // remote port.
        htonl(m_Settings.dwIPRemote)        // remote address.
        )))
    {
        LOG((MSP_ERROR, "set remote Address, hr:%x", hr));
        return hr;
    }

    // Set the TTL used in the filter.
    if (FAILED(hr = pIRTPStream->SetMulticastScope(m_Settings.dwTTL)))
    {
        LOG((MSP_ERROR, "set TTL. %x", hr));
        return hr;
    }

    if (m_Settings.dwIPLocal != INADDR_ANY)
    {
        // set the local interface that the socket should bind to
        LOG((MSP_INFO, "set locol Address:%x", m_Settings.dwIPLocal));

        if (FAILED(hr = pIRTPStream->SelectLocalIPAddress(
            htonl(m_Settings.dwIPLocal)
            )))
        {
            LOG((MSP_ERROR, "set locol Address, hr:%x", hr));
            return hr;
        }
    }

    // Set the priority of the session
    if (FAILED(hr = pIRTPStream->SetSessionClassPriority(
        RTP_CLASS_VIDEO,
        g_dwVideoThreadPriority
        )))
    {
        LOG((MSP_ERROR, "set session class and priority. %x", hr));
    }

    // Set the sample rate of the session
    LOG((MSP_INFO, "setting session sample rate to %d", g_dwVideoSampleRate));
    
    if (FAILED(hr = pIRTPStream->SetDataClock(g_dwVideoSampleRate)))
    {
        LOG((MSP_ERROR, "set session sample rate. %x", hr));
    }

    // Enable the RTCP events
    if (FAILED(hr = ::EnableRTCPEvents(pIBaseFilter)))
    {
        LOG((MSP_WARN, "can not enable RTCP events %x", hr));
    }

    DWORD dwLoopback = 0;
    if (TRUE == ::GetRegValue(gszMSPLoopback, &dwLoopback)
        && dwLoopback != 0)
    {
        // Loopback is required.
        if (FAILED(hr = ::SetLoopbackOption(pIBaseFilter, dwLoopback)))
        {
            LOG((MSP_ERROR, "set loopback option. %x", hr));
            return hr;
        }
    }

    if (m_Settings.dwQOSLevel != QSL_BEST_EFFORT)
    {
        if (FAILED(hr = ::SetQOSOption(
            pIBaseFilter,
            m_Settings.dwPayloadType,        // payload
            -1,                             // use the default bitrate 
            (m_Settings.dwQOSLevel == QSL_NEEDED),  // fail if no qos.
            TRUE,                           // receive stream.
            g_dwVideoChannels,               // number of streams reserved.
            m_Settings.fCIF
            )))
        {
            LOG((MSP_ERROR, "set QOS option. %x", hr));
            return hr;
        }
    }

    SetLocalInfoOnRTPFilter(pIBaseFilter);

    return S_OK;
}

HRESULT CStreamVideoRecv::SetUpInternalFilters()
/*++

Routine Description:

    set up the filters used in the stream.

    RTP->Demux->RPH->DECODER->Render terminal

    This function only creates the RTP and demux filter and the rest of the
    graph is connected in ConnectTerminal.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "VideoRecv.SetUpInternalFilters"));

    CComPtr<IBaseFilter> pSourceFilter;

    HRESULT hr;

    // create and add the source fitler.
    if (FAILED(hr = ::AddFilter(
            m_pIGraphBuilder,
            CLSID_RTPSourceFilter, 
            L"RtpSource", 
            &pSourceFilter)))
    {
        LOG((MSP_ERROR, "adding source filter. %x", hr));
        return hr;
    }

    if (FAILED(hr = ConfigureRTPFilter(pSourceFilter)))
    {
        LOG((MSP_ERROR, "configure RTP source filter. %x", hr));
        return hr;
    }

    CComPtr<IBaseFilter> pDemuxFilter;

    // create and add the demux fitler.
    if (FAILED(hr = ::AddFilter(
            m_pIGraphBuilder,
            CLSID_IntelRTPDemux, 
            L"RtpDemux",
            &pDemuxFilter)))
    {
        LOG((MSP_ERROR, "adding demux filter. %x", hr));
        return hr;
    }

    // Connect the source filter and the demux filter.
    if (FAILED(hr = ::ConnectFilters(
            m_pIGraphBuilder,
            (IBaseFilter *)pSourceFilter, 
            (IBaseFilter *)pDemuxFilter)))
    {
        LOG((MSP_ERROR, "connect source filter and demux filter. %x", hr));
        return hr;
    }

    // Get the IRTPParticipant interface pointer on the RTP filter.
    CComQIPtr<IRTPParticipant, 
        &IID_IRTPParticipant> pIRTPParticipant(pSourceFilter);
    if (pIRTPParticipant == NULL)
    {
        LOG((MSP_ERROR, "can't get RTP participant interface"));
        return E_NOINTERFACE;
    }

    CComQIPtr<IRTPDemuxFilter, &IID_IRTPDemuxFilter> pIRTPDemux(pDemuxFilter);
    if (pIRTPDemux == NULL)
    {
        LOG((MSP_ERROR, "get RTP Demux interface"));
        return E_NOINTERFACE;
    }

    m_pEdgeFilter = pDemuxFilter;
    m_pEdgeFilter->AddRef();

    _ASSERTE(m_pIRTPDemux == NULL);
    m_pIRTPDemux = pIRTPDemux;
    m_pIRTPDemux->AddRef();

    m_pRTPFilter = pIRTPParticipant;
    m_pRTPFilter->AddRef();

    return hr;
}

HRESULT CStreamVideoRecv::AddOneBranch(
    BRANCH * pBranch
    )
/*++

Routine Description:

    Create a new branch of filters off the demux.

Arguments:
    
    pBranch - a pointer to a structure that remembers the info about the branch.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "AddOneBranch entered."));

    _ASSERTE(m_pIRTPDemux != NULL);

    // Find the next output pin on the demux fitler.
    CComPtr<IPin> pIPinOutput;
    
    HRESULT hr;
    // Set the media type on this output pin.
    if (FAILED(hr = ::FindPin(
            (IBaseFilter *)m_pEdgeFilter,
            (IPin**)&pIPinOutput, 
            PINDIR_OUTPUT
            )))
    {
        LOG((MSP_ERROR, "find free pin on demux, %x", hr));
        return hr;
    }

    // Set the media type on this output pin.
    if (FAILED(hr = m_pIRTPDemux->SetPinTypeInfo(
            pIPinOutput, 
            (BYTE)m_Settings.dwPayloadType,
            *m_pRPHInputMinorType 
            )))
    {
        LOG((MSP_ERROR, "set demux output pin type info, %x", hr));
        return hr;
    }

    LOG((MSP_INFO, "set demux output pin payload type to %d", 
        m_Settings.dwPayloadType));

    // Set the default timeout on this output pin.
    if (FAILED(hr = m_pIRTPDemux->SetPinSourceTimeout(
            pIPinOutput, 
            g_dwVideoPinTimeOut
            )))
    {
        LOG((MSP_ERROR, "set demux output pin type info, %x", hr));
        return hr;
    }

    LOG((MSP_INFO, "set demux output pin timeout to %dms", g_dwVideoPinTimeOut));

    // Create and add the payload handler into the filtergraph.
    CComPtr<IBaseFilter> pIRPHFilter;

    if (FAILED(hr = ::AddFilter(
        m_pIGraphBuilder,
        *m_pClsidPHFilter, 
        L"RPH", 
        &pIRPHFilter
        )))
    {
        LOG((MSP_ERROR, "add RPH filter. %x", hr));
        return hr;
    }

     // Get the IRPHH26XSettings interface used in configuring the RPH 
    // filter to the right image size.
    CComQIPtr<IRPHH26XSettings, 
        &IID_IRPHH26XSettings> pIRPHH26XSettings(pIRPHFilter);
    if (pIRPHH26XSettings == NULL)
    {
        LOG((MSP_WARN, "can't get IRPHH26XSettings interface"));
    }
    else if (FAILED(pIRPHH26XSettings->SetCIF(m_Settings.fCIF)))
    {
        LOG((MSP_WARN, "can't set CIF or QCIF"));
    }
            
    // Connect the payload handler to the output pin on the demux.
    if (FAILED(hr = ::ConnectFilters(
        m_pIGraphBuilder,
        (IPin *)pIPinOutput, 
        (IBaseFilter *)pIRPHFilter
        )))
    {
        LOG((MSP_ERROR, "connect demux and RPH filter. %x", hr));
        m_pIGraphBuilder->RemoveFilter(pIRPHFilter);

        return hr;
    }

    CComPtr<IBaseFilter> pCodecFilter;

    if (FAILED(hr = ::AddFilter(
        m_pIGraphBuilder,
        *m_pClsidCodecFilter, 
        L"codec", 
        &pCodecFilter
        )))
    {
        LOG((MSP_ERROR, "add Codec filter. %x", hr));
        return hr;
    }

    // Connect the payload handler to the output pin on the demux.
    if (FAILED(hr = ::ConnectFilters(
        m_pIGraphBuilder,
        (IBaseFilter *)pIRPHFilter, 
        (IBaseFilter *)pCodecFilter
        )))
    {
        LOG((MSP_ERROR, "connect RPH filter and codec. %x", hr));
        
        m_pIGraphBuilder->RemoveFilter(pIRPHFilter);
        m_pIGraphBuilder->RemoveFilter(pCodecFilter);

        return hr;
    }
    
    pBranch->pIPin           = pIPinOutput;
    pBranch->pRPHFilter      = pIRPHFilter;
    pBranch->pCodecFilter    = pCodecFilter;

    pBranch->pIPin->AddRef();
    pBranch->pRPHFilter->AddRef();
    pBranch->pCodecFilter->AddRef();

    LOG((MSP_TRACE, "AddOneBranch exits ok."));
    return S_OK;
}

HRESULT CStreamVideoRecv::RemoveOneBranch(
    BRANCH * pBranch
    )
/*++

Routine Description:

    Remove all the filters in a branch and release all the pointers.
    the caller of this function should not use any member of this branch
    after this function call. 

Arguments:
    
    pBranch - a pointer to a structure that has the info about the branch.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "RemoveOneBranch entered."));

    if (pBranch->pIPin)
    {
        pBranch->pIPin->Release();
    }

    if (pBranch->pRPHFilter)
    {
        m_pIGraphBuilder->RemoveFilter(pBranch->pRPHFilter);
        pBranch->pRPHFilter->Release();
    }

    if (pBranch->pCodecFilter)
    {
        m_pIGraphBuilder->RemoveFilter(pBranch->pCodecFilter);
        pBranch->pCodecFilter->Release();
    }

    if (pBranch->pITTerminal)
    {
        // get the terminal control interface.
        CComQIPtr<ITTerminalControl, &IID_ITTerminalControl> 
            pTerminal(pBranch->pITTerminal);
        
        _ASSERTE(pTerminal != NULL);

        if (pTerminal != NULL)
        {
            HRESULT hr = pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);
            LOG((MSP_TRACE, 
                "terminal %p is disonnected. hr:%x", pBranch->pITTerminal, hr));
        }
        pBranch->pITTerminal->Release();
    }

    if (pBranch->pITSubStream)
    {
        ((CSubStreamVideoRecv*)pBranch->pITSubStream)->
            ClearCurrentTerminal();
        pBranch->pITSubStream->Release();
    }
    LOG((MSP_TRACE, "RemoveOneBranch exits ok."));
    return S_OK;
}

HRESULT CStreamVideoRecv::ConnectCodecToTerminal(
    IN  IBaseFilter *  pCodecFilter,
    IN  ITTerminal *   pITTerminal
    )
/*++

Routine Description:

    Connect the codec filter to the render filter inside the terminal.

Arguments:
    
    pCodecFilter - a pointer to the Codec filter.

    pITTerminal - the terminal object.

Return Value:

    HRESULT.

--*/
{
    // get the terminal control interface.
    CComQIPtr<ITTerminalControl, &IID_ITTerminalControl> 
        pTerminal(pITTerminal);
    if (pTerminal == NULL)
    {
        LOG((MSP_ERROR, "can't get Terminal Control interface"));

        SendStreamEvent(CALL_TERMINAL_FAIL, 
            CALL_CAUSE_BAD_DEVICE, E_NOINTERFACE, pITTerminal);
        
        return E_NOINTERFACE;
    }

    // try to disable DDraw because our decoders can't handle DDraw.
    HRESULT hr2; 
    IDrawVideoImage *pIDrawVideoImage;
    hr2 = pTerminal->QueryInterface(IID_IDrawVideoImage, (void **)&pIDrawVideoImage); 
    if (SUCCEEDED(hr2))
    {
        hr2 = pIDrawVideoImage->DrawVideoImageBegin();
        if (FAILED(hr2))
        {
            LOG((MSP_WARN, "Can't disable DDraw. %x", hr2));
        }
        else
        {
            LOG((MSP_INFO, "DDraw disabled."));
        }
        
        pIDrawVideoImage->Release();
    }
    else
    {
        LOG((MSP_WARN, "Can't get IDrawVideoImage. %x", hr2));
    }


    const DWORD MAXPINS     = 8;
    
    DWORD       dwNumPins   = MAXPINS;
    IPin *      Pins[MAXPINS];

    HRESULT hr = pTerminal->ConnectTerminal(m_pIGraphBuilder, 0, &dwNumPins, Pins);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't connect to terminal, %x", hr));

        SendStreamEvent(CALL_TERMINAL_FAIL, 
            CALL_CAUSE_CONNECT_FAIL, hr, pITTerminal);
        
        return hr;
    }

    // the number of pins should never be 0.
    if (dwNumPins == 0)
    {
        LOG((MSP_ERROR, "terminal has no pins."));

        SendStreamEvent(CALL_TERMINAL_FAIL, 
            CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);
        
        pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

        m_lock.Unlock();
        return E_UNEXPECTED;
    }

    // Connect the codec filter to the video render terminal.
    hr = ::ConnectFilters(
        m_pIGraphBuilder,
        (IBaseFilter *)pCodecFilter, 
        (IPin *)Pins[0],
        FALSE               // use Connect instead of ConnectDirect.
        );

    // release the refcounts on the pins.
    for (DWORD i = 0; i < dwNumPins; i ++)
    {
        Pins[i]->Release();
    }

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "connect to the codec filter. %x", hr));

        pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);
	
        return hr;

    }

    //
    // Now we are actually connected. Update our state and perform postconnection
    // (ignore postconnection error code).
    //
    pTerminal->CompleteConnectTerminal();

    return hr;
}

HRESULT CStreamVideoRecv::ConnectTerminal(
    IN  ITTerminal *   pITTerminal
    )
/*++

Routine Description:

    connect video render terminal.

Arguments:
    
    pITTerminal - The terminal to be connected.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "VideoRecv.ConnectTerminal, pTerminal %p", pITTerminal));

    HRESULT hr;

    // if our filters have not been contructed, do it now.
    if (m_pEdgeFilter == NULL)
    {
        hr = SetUpInternalFilters();
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "Set up internal filter failed, %x", hr));
            
            CleanUpFilters();

            return hr;
        }
    }

    // first create the RPH and CODEC filter needed before the terminal.
    BRANCH aBranch;
    ZeroMemory(&aBranch, sizeof BRANCH);

    hr = AddOneBranch(&aBranch);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Set up a new decode branch failed, %x", hr));
        return hr;
    }

    // finish the connection.
    hr = ConnectCodecToTerminal(aBranch.pCodecFilter, pITTerminal);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "connecting codec to terminal failed, %x", hr));

        // remove the added filters from the graph.
        RemoveOneBranch(&aBranch);

        return hr;
    }

    pITTerminal->AddRef();
    aBranch.pITTerminal = pITTerminal;

    if (!m_Branches.Add(aBranch))
    {
        RemoveOneBranch(&aBranch);
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

HRESULT CStreamVideoRecv::DisconnectTerminal(
    IN  ITTerminal *   pITTerminal
    )
/*++

Routine Description:

    Disconnect a terminal. It will remove its filters from the graph and
    also release its references to the graph. A branch of filters is also
    released.

Arguments:
    
    pITTerminal - the terminal.

Return Value:

    HRESULT.

--*/
{
    for (int i = 0; i < m_Branches.GetSize(); i ++)
    {
        if (m_Branches[i].pITTerminal == pITTerminal)
        {
            break;
        }
    }

    if (i < m_Branches.GetSize())
    {
        RemoveOneBranch(&m_Branches[i]);
        m_Branches.RemoveAt(i);
    }

    return S_OK;
}

HRESULT CStreamVideoRecv::SetUpFilters()
/*++

Routine Description:

    Insert filters into the graph and connect to the terminals.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "VideoRecv.SetUpFilters"));

    // if our filters have not been contructed, do it now.
    if (m_pEdgeFilter == NULL)
    {
        HRESULT hr = SetUpInternalFilters();
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "Set up internal filter failed, %x", hr));
            
            CleanUpFilters();

            return hr;
        }
    }

    for (int i = 0; i < m_Terminals.GetSize(); i ++)
    {
        HRESULT hr = ConnectTerminal(m_Terminals[i]);

        if (FAILED(hr))
        {
            return hr;
        }
    }

    return S_OK;
}

// ITParticipantSubStreamControl methods, called by the app.
STDMETHODIMP CStreamVideoRecv::get_SubStreamFromParticipant(
    IN  ITParticipant * pITParticipant,
    OUT ITSubStream ** ppITSubStream
    )
/*++

Routine Description:

    Find out which substream is rendering the participant. 

Arguments:

    pITParticipant - the participant.

    ppITSubStream - the returned sub stream.
    
Return Value:

    S_OK,
    TAPI_E_NOITEMS,
    E_UNEXPECTED

--*/
{
    LOG((MSP_TRACE, "get substream from participant:%p", pITParticipant));
    
    if (IsBadWritePtr(ppITSubStream, sizeof(VOID *)))
    {
        LOG((MSP_ERROR, "ppITSubStream is a bad pointer"));
        return E_POINTER;
    }

    CLock lock(m_lock);

    ITSubStream * pITSubStream = NULL;

    // find out which substream has the participant.
    for (int i = 0; i < m_SubStreams.GetSize(); i ++)
    {
        ITParticipant *pTempParticipant;
        DWORD dwSSRC;

        ((CSubStreamVideoRecv*)m_SubStreams[i])->GetCurrentParticipant(
            &dwSSRC, &pTempParticipant
            );

        _ASSERTE(pTempParticipant != NULL);

        pTempParticipant->Release(); // we dont' need the ref here.

        if (pITParticipant == pTempParticipant)
        {
            pITSubStream = m_SubStreams[i];
            pITSubStream->AddRef();

            break;
        }
    }
    
    if (pITSubStream == NULL)
    {
        return TAPI_E_NOITEMS;
    }

    *ppITSubStream = pITSubStream;
    return S_OK;
}

STDMETHODIMP CStreamVideoRecv::get_ParticipantFromSubStream(
    IN  ITSubStream * pITSubStream,
    OUT ITParticipant ** ppITParticipant 
    )
/*++

Routine Description:

    Find out which participant the substream is rendering.

Arguments:

    pITSubStream - the sub stream.

    ppITParticipant - the returned participant
    
Return Value:

    S_OK,
    TAPI_E_NOITEMS,
    E_UNEXPECTED

--*/
{
    LOG((MSP_TRACE, "get participant from substream:%p", pITSubStream));
    
    if (IsBadWritePtr(ppITParticipant, sizeof(VOID *)))
    {
        LOG((MSP_ERROR, "ppITParticipant is a bad pointer"));
        return E_POINTER;
    }

    CLock lock(m_lock);

    int i;

    // check to see if the substream is in our list.
    if ((i = m_SubStreams.Find(pITSubStream)) < 0)
    {
        LOG((MSP_ERROR, "wrong SubStream handle %p", pITSubStream));
        return E_INVALIDARG;
    }

    ITParticipant *pITParticipant;
    DWORD dwSSRC;

    if (((CSubStreamVideoRecv*)m_SubStreams[i])->GetCurrentParticipant(
        &dwSSRC, &pITParticipant
        ) == FALSE)
    {
        return TAPI_E_NOITEMS;
    }

    *ppITParticipant = pITParticipant;
    
    return S_OK;
}

STDMETHODIMP CStreamVideoRecv::SwitchTerminalToSubStream(
    IN  ITTerminal * pITTerminal,
    IN  ITSubStream * pITSubStream
    )
/*++

Routine Description:

    Switch terminal to a substream to display the participant that is on the
    substream.

Arguments:

    pITTerminal - the terminal.

    pITSubStream - the sub stream.
    
Return Value:

    S_OK,
    E_INVALIDARG,
    E_UNEXPECTED

--*/
{
    LOG((MSP_TRACE, "switch terminal %p to substream:%p", 
        pITTerminal, pITSubStream));
    
    CLock lock(m_lock);

    if (m_pIRTPDemux == NULL)
    {
        LOG((MSP_ERROR, "the demux filter doesn't exist."));
        return E_UNEXPECTED;
    }

    // first, find out which branch has the terminal now.
    for (int i = 0; i < m_Branches.GetSize(); i ++)
    {
        if (m_Branches[i].pITTerminal == pITTerminal)
        {
            break;
        }
    }

    if (i >= m_Branches.GetSize())
    {
        LOG((MSP_TRACE, "terminal %p doesn't exist", pITTerminal));
        return E_INVALIDARG;
    }

    // second, find out if the substream exists.
    if (m_SubStreams.Find(pITSubStream) < 0)
    {
        LOG((MSP_TRACE, "SubStream %p doesn't exist", pITSubStream));
        return E_INVALIDARG;
    }


    // thrid, find the participant on the substream and configure the demux
    // filter to render the participant on the chosen branch.
    ITParticipant *pITParticipant = NULL;
    DWORD dwSSRC;

    ((CSubStreamVideoRecv*)pITSubStream)->GetCurrentParticipant(
        &dwSSRC, &pITParticipant
        ) ;

    _ASSERTE(pITParticipant != NULL);

    // we don't need the reference here.
    pITParticipant->Release();

    // map the pin to this SSRC only.
    HRESULT hr = m_pIRTPDemux->MapSSRCToPin(dwSSRC, m_Branches[i].pIPin);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "map SSRC %x to pin %p returned %x", 
            dwSSRC, m_Branches[i].pIPin, hr));
        return hr;
    }    

    DWORD dwOldSSRC = 0;

    // Finally, set up the mappings among the branch, the substream and 
    // the terminal
    
    // release the refcount on the old branch that the substream was on.
    for (int j = 0; j < m_Branches.GetSize(); j ++)
    {
        if (m_Branches[j].pITSubStream == pITSubStream)
        {
            m_Branches[j].pITSubStream->Release();
            m_Branches[j].pITSubStream = NULL;
            break;
        }
    }

    if (m_Branches[i].pITSubStream != NULL)
    {
        ((CSubStreamVideoRecv*)m_Branches[i].pITSubStream)->
            ClearCurrentTerminal();

        m_Branches[i].pITSubStream->Release();
        dwOldSSRC = m_Branches[i].dwSSRC;
    }

    pITSubStream->AddRef();
    m_Branches[i].pITSubStream = pITSubStream;
    m_Branches[i].dwSSRC = dwSSRC;

    ((CSubStreamVideoRecv*)pITSubStream)->ClearCurrentTerminal();
    ((CSubStreamVideoRecv*)pITSubStream)->SetCurrentTerminal(
        m_Branches[i].pITTerminal
        );


    // After all the steps, we still have to change QOS reservation.
    if (dwOldSSRC != 0)
    {
        // cancel QOS for the old participant.
        if (FAILED(hr = m_pRTPFilter->SetParticipantQOSstate(dwOldSSRC, 0)))
        {
            LOG((MSP_ERROR, "disabling QOS for %x. hr:%x", dwOldSSRC, hr));
        }
        else
        {
            LOG((MSP_INFO, "disabled video QOS for %x.", dwOldSSRC));
        }
    }
    
    // reserve QOS for the new participant.
    if (FAILED(hr = m_pRTPFilter->SetParticipantQOSstate(dwSSRC, 1)))
    {
        LOG((MSP_ERROR, "enabling video QOS for %x. hr:%x", dwSSRC, hr));
    }
    else
    {
        LOG((MSP_INFO, "enabled video QOS for %x.", dwSSRC));
    }

    return S_OK;
}


HRESULT CStreamVideoRecv::ProcessNewSender(
    IN  DWORD dwSSRC, 
    IN  ITParticipant *pITParticipant
    )
/*++

Routine Description:

    A sender has just joined. A substream needs to be created for the
    participant. 
    
    A pin mapped event might have happended when we didn't have the 
    participant's name so it was queued in a list. Now that we have a new 
    participant, let's check if this is the same participant. If it is, 
    we complete the pin mapped event by sending the app an notification.

Arguments:

    dwSSRC - the SSRC of the participant.

    pITParticipant - the participant object.

Return Value:

    S_OK,
    E_UNEXPECTED

--*/
{
    CLock lock(m_lock);

    if (m_pRTPFilter == NULL)
    {
        LOG((MSP_ERROR, "the network filter doesn't exist."));
        return E_UNEXPECTED;
    }

    // Find out if a substream has been created for this participant when we
    // processed PinMapped event and receiver reports.
    for (int i = 0; i < m_SubStreams.GetSize(); i ++)
    {
        ITParticipant *pTempParticipant = NULL;
        DWORD dwSSRC;

        ((CSubStreamVideoRecv*)m_SubStreams[i])->GetCurrentParticipant(
            &dwSSRC, &pTempParticipant
            );

        _ASSERTE(pTempParticipant != NULL);

        pTempParticipant->Release(); // we dont' need the ref here.

        if (pITParticipant == pTempParticipant)
        {
            // the participant has been created.
            return S_OK;
        }
    }

    ITSubStream * pITSubStream;
    HRESULT hr = InternalCreateSubStream(&pITSubStream);
    
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%ls can't create a SubStream, %x", m_szName, hr));
        return hr;
    }

    ((CSubStreamVideoRecv*)pITSubStream)->SetCurrentParticipant(
        dwSSRC, pITParticipant
        );

    ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
        PE_NEW_SUBSTREAM, 
        pITParticipant,
        pITSubStream
        );

    // look at the pending SSRC list and find out if this report
    // fits in the list.
    IPin *pIPin = NULL;

    for (i = 0; i < m_PinMappedEvents.GetSize(); i ++)
    {
        if (m_PinMappedEvents[i].dwSSRC == dwSSRC)
        {
            pIPin = m_PinMappedEvents[i].pIPin;
            break;
        }
    }
    
    if (!pIPin)
    {
        // the SSRC is not in the list of pending PinMappedEvents.
        LOG((MSP_TRACE, "the SSRC %x is not in the pending list", dwSSRC));

        pITSubStream->Release();
    
        return S_OK;;
    }

    // get rid of the peding event.
    m_PinMappedEvents.RemoveAt(i);

    // reserve QOS since we are rendering this sender.
    if (FAILED(hr = m_pRTPFilter->SetParticipantQOSstate(dwSSRC, 1)))
    {
        LOG((MSP_ERROR, "enabling video QOS for %x. hr:%x", dwSSRC, hr));
    }
    else
    {
        LOG((MSP_INFO, "enabled video QOS for %x.", dwSSRC));
    }

    // tell the app about the newly mapped sender.
    for (i = 0; i < m_Branches.GetSize(); i ++)
    {
        if (m_Branches[i].pIPin == pIPin)
        {
            if (m_Branches[i].pITSubStream != NULL)
            {
                ((CSubStreamVideoRecv*)m_Branches[i].pITSubStream)
                    ->ClearCurrentTerminal();

                m_Branches[i].pITSubStream->Release();
            }

            m_Branches[i].dwSSRC = dwSSRC;
            m_Branches[i].pITSubStream = pITSubStream;
            pITSubStream->AddRef();

            ((CSubStreamVideoRecv*)pITSubStream)->
                SetCurrentTerminal(m_Branches[i].pITTerminal);

            ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
                PE_SUBSTREAM_MAPPED, 
                pITParticipant,
                pITSubStream
                );

            break;
        }
    }

    pITSubStream->Release();
   
    return S_OK;
}

HRESULT CStreamVideoRecv::NewParticipantPostProcess(
    IN  DWORD dwSSRC, 
    IN  ITParticipant *pITParticipant
    )
/*++

Routine Description:

    A pin mapped event might have happended when we didn't have the 
    participant's name so it was queued in a list. Now that we have a new 
    participant, let's check if this is the same participant. If it is, 
    we complete the pin mapped event by creating a substream and send
    the app a notification.

Arguments:

    dwSSRC - the SSRC of the participant.

    pITParticipant - the participant object.

Return Value:

    S_OK,
    E_UNEXPECTED

--*/
{
    LOG((MSP_TRACE, "%ls Check pending mapped event, dwSSRC: %x", m_szName, dwSSRC));
    
    // look at the pending SSRC list and find out if this report
    // fits in the list.
    IPin *pIPin = NULL;

    for (int i = 0; i < m_PinMappedEvents.GetSize(); i ++)
    {
        if (m_PinMappedEvents[i].dwSSRC == dwSSRC)
        {
            pIPin = m_PinMappedEvents[i].pIPin;
            break;
        }
    }
    
    if (!pIPin)
    {
        // the SSRC is not in the list of pending PinMappedEvents.
        LOG((MSP_TRACE, "the SSRC %x is not in the pending list", dwSSRC));
        return S_OK;;
    }

    ITSubStream * pITSubStream;
    HRESULT hr = InternalCreateSubStream(&pITSubStream);
    
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%ls can't create a SubStream, %x", m_szName, hr));
        return hr;
    }

    ((CSubStreamVideoRecv*)pITSubStream)->SetCurrentParticipant(
        dwSSRC, pITParticipant
        );

    ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
        PE_NEW_SUBSTREAM, 
        pITParticipant,
        pITSubStream
        );

    // get rid of the peding event.
    m_PinMappedEvents.RemoveAt(i);

    if (FAILED(hr = m_pRTPFilter->SetParticipantQOSstate(dwSSRC, 1)))
    {
        LOG((MSP_ERROR, "enabling video QOS for %x. hr:%x", dwSSRC, hr));
    }
    else
    {
        LOG((MSP_INFO, "enabled video QOS for %x.", dwSSRC));
    }
    
    // Now we get the participant, the substream, and the pin. Establish a mapping
    // between the decoding branch and the substream.
    for (i = 0; i < m_Branches.GetSize(); i ++)
    {
        if (m_Branches[i].pIPin == pIPin)
        {
            if (m_Branches[i].pITSubStream != NULL)
            {
                ((CSubStreamVideoRecv*)m_Branches[i].pITSubStream)
                    ->ClearCurrentTerminal();

                m_Branches[i].pITSubStream->Release();
            }

            m_Branches[i].dwSSRC = dwSSRC;
            m_Branches[i].pITSubStream = pITSubStream;
            pITSubStream->AddRef();

            ((CSubStreamVideoRecv*)pITSubStream)->
                SetCurrentTerminal(m_Branches[i].pITTerminal);

            ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
                PE_SUBSTREAM_MAPPED, 
                pITParticipant,
                pITSubStream
                );

            break;
        }
    }

    _ASSERTE(i < m_Branches.GetSize());

    pITSubStream->Release();
   
    return S_OK;
}

HRESULT CStreamVideoRecv::ProcessPinMappedEvent(
    IN  IPin *  pIPin
    )
/*++

Routine Description:

    A pin just got a new SSRC mapped to it. If the participant doesn't exist, 
    put the event in a pending queue and wait for a RTCP report that has the
    participant's name. If the participant exists, check to see if a SubStream
    has been created for the stream. If not, a SubStream is created. Then a
    Particiapnt substream event is fired.

Arguments:

    pIPin - the output pin of the demux filter that just got a new SSRC.

Return Value:

    S_OK,
    E_UNEXPECTED

--*/
{
    LOG((MSP_TRACE, "%ls Process pin mapped event, pIPin: %p", m_szName, pIPin));
    
    CLock lock(m_lock);

    if (m_pIRTPDemux == NULL)
    {
        LOG((MSP_ERROR, "the demux filter doesn't exist."));
        return E_UNEXPECTED;
    }

    for (int iBranch = 0; iBranch < m_Branches.GetSize(); iBranch ++)
    {
        if (m_Branches[iBranch].pIPin == pIPin)
        {
            break;
        }
    }

    LOG((MSP_INFO, "Branch %d has the pin", iBranch));

    if (iBranch >= m_Branches.GetSize())
    {
        LOG((MSP_ERROR, "Wrong pin is mapped. %p", pIPin));
        return E_UNEXPECTED;
    }

    BYTE    PayloadType;
    DWORD   dwSSRC;
    BOOL    fAutoMapping;
    DWORD   dwTimeOut;

    HRESULT hr = m_pIRTPDemux->GetPinInfo(
            pIPin,
            &dwSSRC,
            &PayloadType,
            &fAutoMapping,
            &dwTimeOut
            );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get info for pin:%p, hr:%x", pIPin, hr));
        return E_UNEXPECTED;
    }
    
    // sometimes we might get a mapped event for branches that are still 
    // in use.
    if (m_Branches[iBranch].pITSubStream != NULL)
    {
        // sometimes we might get duplicated map events
        if (m_Branches[iBranch].dwSSRC == dwSSRC)
        {
            LOG((MSP_ERROR, "The same pin mapped twice. %p", pIPin));
            return E_UNEXPECTED;
        }
        else
        {
            LOG((MSP_ERROR, "The branch is in use. Cleaning up."));

            ((CSubStreamVideoRecv*)m_Branches[iBranch].pITSubStream)->
                ClearCurrentTerminal();

            m_Branches[iBranch].pITSubStream->Release();
            m_Branches[iBranch].pITSubStream = NULL;
            m_Branches[iBranch].dwSSRC = 0;
        }
    }

    ITParticipant * pITParticipant = NULL;

    // find the SSRC in our participant list.
    for (int i = 0; i < m_Participants.GetSize(); i ++)
    {
        if (((CParticipant *)m_Participants[i])->
                HasSSRC((ITStream *)this, dwSSRC))
        {
            pITParticipant = m_Participants[i];
            break;
        }
    }

    // if the participant is not there yet, put the event in a queue and it
    // will be fired when we have the CName fo the participant.
    if (!pITParticipant)
    {
        LOG((MSP_INFO, "can't find a participant that has SSRC %x", dwSSRC));

        PINMAPEVENT Event;
        Event.pIPin = pIPin;
        Event.dwSSRC = dwSSRC;

        m_PinMappedEvents.Add(Event);
        
        LOG((MSP_INFO, "added the event to pending list, new list size:%d", 
            m_PinMappedEvents.GetSize()));

        return S_OK;
    }
   
    // Enable QOS for the participant since it is being rendered.
    if (FAILED(hr = m_pRTPFilter->SetParticipantQOSstate(dwSSRC, 1)))
    {
        LOG((MSP_ERROR, "enabling vidoe QOS for %x. hr:%x", dwSSRC, hr));
    }
    else
    {
        LOG((MSP_INFO, "enabled video QOS for %x.", dwSSRC));
    }
    
    // Find out if a substream has been created for this participant who might
    // have been a receiver only and hasn't got a substream.
    ITSubStream *   pITSubStream = NULL;
    for (i = 0; i < m_SubStreams.GetSize(); i ++)
    {
        ITParticipant *pTempParticipant;
        DWORD dwSSRC;

        ((CSubStreamVideoRecv*)m_SubStreams[i])->GetCurrentParticipant(
            &dwSSRC, &pTempParticipant
            );

        _ASSERTE(pTempParticipant != NULL);

        pTempParticipant->Release(); // we dont' need the ref here.

        if (pITParticipant == pTempParticipant)
        {
            pITSubStream = m_SubStreams[i];
            pITSubStream->AddRef();

            break;
        }
    }

    if (pITSubStream == NULL)
    {
        // we need to create a substream for this participant since he has 
        // started sending.
        hr = InternalCreateSubStream(&pITSubStream);
    
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%ls can't create a SubStream, %x", m_szName, hr));
            return hr;
        }

        ((CSubStreamVideoRecv*)pITSubStream)->SetCurrentParticipant(
            dwSSRC, pITParticipant
            );

        ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
            PE_NEW_SUBSTREAM, 
            pITParticipant,
            pITSubStream
            );
    }

    if (((CSubStreamVideoRecv*)pITSubStream)->ClearCurrentTerminal())
    {
        // The substrem has a terminal before. This is an error.
        LOG((MSP_ERROR, "SubStream %p has already got a terminal", pITSubStream));

        // remove the mapping if the substream was mapped to a branch.
        for (i = 0; i < m_Branches.GetSize(); i ++)
        {
            if (m_Branches[i].pITSubStream == pITSubStream)
            {
                m_Branches[i].pITSubStream->Release();
                m_Branches[i].pITSubStream = NULL;
                m_Branches[i].dwSSRC = 0;

                LOG((MSP_ERROR, "SubStream %p was mapped to branch %d", i));
                break;
            }
        }
    }

    // Now we get the participant, the substream, and the pin. Establish a mapping
    // between the decoding branch and the substream.
    m_Branches[iBranch].dwSSRC = dwSSRC;
    m_Branches[iBranch].pITSubStream = pITSubStream;
    pITSubStream->AddRef();

    ((CSubStreamVideoRecv*)pITSubStream)->
        SetCurrentTerminal(m_Branches[iBranch].pITTerminal);

    ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
        PE_SUBSTREAM_MAPPED, 
        pITParticipant,
        pITSubStream
        );

    pITSubStream->Release();
   
    return S_OK;
}

HRESULT CStreamVideoRecv::ProcessPinUnmapEvent(
    IN  IPin *  pIPin
    )
/*++

Routine Description:

    A pin just got unmapped by the demux. Notify the app which substream
    is not going to have any data.

Arguments:

    pIPin - the output pin of the demux filter

Return Value:

    S_OK,
    E_UNEXPECTED

--*/
{
    LOG((MSP_TRACE, "%ls Proces pin unmapped event, pIPin: %p", m_szName, pIPin));
    
    CLock lock(m_lock);

    if (m_pIRTPDemux == NULL)
    {
        LOG((MSP_ERROR, "the demux filter doesn't exist."));
        return E_UNEXPECTED;
    }

    // look at the pending SSRC list and find out if the pin is in the 
    // pending list.
    for (int i = 0; i < m_PinMappedEvents.GetSize(); i ++)
    {
        if (m_PinMappedEvents[i].pIPin == pIPin)
        {
            break;
        }
    }

    // if the pin is in the pending list, just remove it.
    if (i < m_PinMappedEvents.GetSize())
    {
        m_PinMappedEvents.RemoveAt(i);
        return S_OK;
    }

    // find out which substream got unmapped.
    ITSubStream * pITSubStream = NULL;
    for (i = 0; i < m_Branches.GetSize(); i ++)
    {
        if (m_Branches[i].pIPin == pIPin)
        {
            pITSubStream = m_Branches[i].pITSubStream;

            if (pITSubStream)
            {
                // Don't release the ref until the end of this function.
                m_Branches[i].pITSubStream = NULL;
                m_Branches[i].dwSSRC = 0;
            }
            break;
        }
    }

    if (!pITSubStream)
    {
        LOG((MSP_ERROR, "can't find a substream that got unmapped."));
        return TAPI_E_NOITEMS;
    }

    ((CSubStreamVideoRecv*)pITSubStream)->ClearCurrentTerminal();

    ITParticipant *pITParticipant = NULL;
    DWORD dwSSRC;

    ((CSubStreamVideoRecv*)pITSubStream)->GetCurrentParticipant(
        &dwSSRC, &pITParticipant
        ) ;

    _ASSERTE(pITParticipant != NULL);

    if (pITParticipant != NULL)
    {
        // fire an event to tell the app that the substream is not used.
        ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
            PE_SUBSTREAM_UNMAPPED, 
            pITParticipant,
            pITSubStream
            );

        pITParticipant->Release();

        // cancel QOS for this participant.
        HRESULT hr = m_pRTPFilter->SetParticipantQOSstate(dwSSRC, 0);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "disabling QOS for %x. hr:%x", dwSSRC, hr));
        }
        else
        {
            LOG((MSP_INFO, "disabled video QOS for %x.", dwSSRC));
        }
    }

    pITSubStream->Release();

    return S_OK;
}

HRESULT CStreamVideoRecv::ProcessParticipantLeave(
    IN  DWORD   dwSSRC
    )
/*++

Routine Description:

    When participant left the session, remove the stream from the participant
    object's list of streams. If all streams are removed, remove the 
    participant from the call object's list too.

Arguments:
    
    dwSSRC - the SSRC of the participant left.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "%ls ProcessParticipantLeave, SSRC: %x", m_szName, dwSSRC));
    
    CLock lock(m_lock);
    
    if (m_pRTPFilter == NULL)
    {
        LOG((MSP_ERROR, "the network filter doesn't exist."));
        return E_UNEXPECTED;
    }

    CParticipant *pParticipant;
    BOOL fLast = FALSE;

    HRESULT hr = E_FAIL;

    // first try to find the SSRC in our participant list.
    for (int iParticipant = 0; 
        iParticipant < m_Participants.GetSize(); iParticipant ++)
    {
        pParticipant = (CParticipant *)m_Participants[iParticipant];
        hr = pParticipant->RemoveStream(
                (ITStream *)this,
                dwSSRC,
                &fLast
                );
        
        if (SUCCEEDED(hr))
        {
            break;
        }
    }

    // if the participant is not found
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%ws, can't find the SSRC %x", m_szName, dwSSRC));

        return hr;
    }

    ITParticipant *pITParticipant = m_Participants[iParticipant];

    // cancel QOS for this participant.
    if (FAILED(hr = m_pRTPFilter->SetParticipantQOSstate(dwSSRC, 0)))
    {
        LOG((MSP_ERROR, "disabling QOS for %x. hr:%x", dwSSRC, hr));
    }
    else
    {
        LOG((MSP_INFO, "disabled video QOS for %x.", dwSSRC));
    }
    

    // find out which substream is going away.
    ITSubStream * pITSubStream = NULL;
    for (int i = 0; i < m_SubStreams.GetSize(); i ++)
    {
        // Find out the participant on the SubStream.
        ITParticipant *pTempParticipant;
        DWORD dwSSRC;

        ((CSubStreamVideoRecv*)m_SubStreams[i])->GetCurrentParticipant(
            &dwSSRC, &pTempParticipant
            );

        _ASSERTE(pTempParticipant != NULL);

        pTempParticipant->Release(); // we dont' need the ref here.

        if (pTempParticipant == pITParticipant)
        {
            pITSubStream = m_SubStreams[i];
            break;
        }
    }

    if (pITSubStream)
    {
        // remove the mapping if the substream was mapped to a branch.
        for (int i = 0; i < m_Branches.GetSize(); i ++)
        {
            if (m_Branches[i].pITSubStream == pITSubStream)
            {
                m_Branches[i].pITSubStream->Release();
                m_Branches[i].pITSubStream = NULL;
                m_Branches[i].dwSSRC = 0;

                // fire an event to tell the app that the substream is not used.
                ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
                    PE_SUBSTREAM_UNMAPPED, 
                    pITParticipant,
                    pITSubStream
                    );

                break;
            }

        }
    
        ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
            PE_SUBSTREAM_REMOVED, 
            pITParticipant,
            pITSubStream
            );

        if (m_SubStreams.Remove(pITSubStream))
        {
            pITSubStream->Release();
        }
    }

    
    m_Participants.RemoveAt(iParticipant);

    // if this stream is the last stream that the participant is on,
    // tell the call object to remove it from its list.
    if (fLast)
    {
        ((CIPConfMSPCall *)m_pMSPCall)->ParticipantLeft(pITParticipant);
    }

    pITParticipant->Release();

    return S_OK;
}

HRESULT CStreamVideoRecv::ProcessGraphEvent(
    IN  long lEventCode,
    IN  long lParam1,
    IN  long lParam2
    )
{
    LOG((MSP_TRACE, "%ws ProcessGraphEvent %d", m_szName, lEventCode));

    switch (lEventCode)
    {
    // These events are designed to solve the problem of mapping video 
    // windows to incoming streams. The app needs to know which window 
    // should be painted. Whenever the demux starts using a RPH pin to 
    // stream data, it sends a MAPPED event. The first parameter is the 
    // input pin on the RPH, the second parameter is the payload type.
    // When the demux stops using a pin, it sends a UNMAPPED event.

    case RTPDMX_EVENTBASE + RTPDEMUX_PIN_MAPPED:
        LOG((MSP_INFO, "handling pin mapped event, Pin%x", lParam1));
        
        ProcessPinMappedEvent((IPin *)lParam1);

        break;

    case RTPDMX_EVENTBASE + RTPDEMUX_PIN_UNMAPPED:
        LOG((MSP_INFO, "handling pin unmap event, Pin%x", lParam1));

        ProcessPinUnmapEvent((IPin *)lParam1);

        break;

    default:
        return CIPConfMSPStream::ProcessGraphEvent(
            lEventCode, lParam1, lParam2
            );
    }
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//  CStreamVideoSend
//
/////////////////////////////////////////////////////////////////////////////
CStreamVideoSend::CStreamVideoSend()
    : CIPConfMSPStream()
{
      m_szName = L"VideoSend";
}

HRESULT CStreamVideoSend::Configure(
    IN STREAMSETTINGS &StreamSettings
    )
/*++

Routine Description:

    Configure this stream.

Arguments:
    
    StreamSettings - The setting structure got from the SDP blob.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "VideoSend.Configure"));

    CLock lock(m_lock);

    _ASSERTE(m_fIsConfigured == FALSE);

    switch (StreamSettings.dwPayloadType)
    {
    case PAYLOAD_H261:

        m_pClsidCodecFilter  = &CLSID_H261_ENCODE_FILTER;
        m_pRPHInputMinorType = &MEDIASUBTYPE_RTP_Payload_H261; 
        m_pClsidPHFilter     = &CLSID_INTEL_SPHH26X;

        break;

    case PAYLOAD_H263:

        m_pClsidCodecFilter  = &CLSID_H263_ENCODE_FILTER;
        m_pRPHInputMinorType = &MEDIASUBTYPE_RTP_Payload_H263; 
        m_pClsidPHFilter     = &CLSID_INTEL_SPHH26X;

        break;

    default:
        LOG((MSP_ERROR, "unknow payload type, %x", StreamSettings.dwPayloadType));
        return E_FAIL;
    }
    
    m_Settings      = StreamSettings;
    m_fIsConfigured = TRUE;

    if (!GetRegValue(L"FrameRate", &m_dwFrameRate))
    {
        m_dwFrameRate   = g_dwVideoSampleRate;
    }

    return InternalConfigure();
}

HRESULT 
SetVideoFormat(
    IN      IUnknown *  pIUnknown,
    IN      BOOL        bCIF,
    IN      DWORD       dwFramesPerSecond
    )
/*++

Routine Description:

    Set the video format to be CIF or QCIF and also set the frames per second.

Arguments:
    
    pIUnknown - a capture terminal.

    bCIF                - CIF or QCIF.

    dwFramesPerSecond   - Frames per second.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "SetVideoFormat"));

    HRESULT hr;

    // first get eht IAMStreamConfig interface.
    CComPtr<IAMStreamConfig> pIAMStreamConfig;

    if (FAILED(hr = pIUnknown->QueryInterface(
        IID_IAMStreamConfig,
        (void **)&pIAMStreamConfig
        )))
    {
        LOG((MSP_ERROR, "Can't get IAMStreamConfig interface.%8x", hr));
        return hr;
    }
    
    // get the current format of the video capture terminal.
    AM_MEDIA_TYPE *pmt;
    if (FAILED(hr = pIAMStreamConfig->GetFormat(&pmt)))
    {
        LOG((MSP_ERROR, "GetFormat returns error: %8x", hr));
        return hr;
    }

    VIDEOINFO *pVideoInfo = (VIDEOINFO *)pmt->pbFormat;
    if (pVideoInfo == NULL)
    {
        MSPDeleteMediaType(pmt);
        return E_UNEXPECTED;
    }

    BITMAPINFOHEADER *pHeader = HEADER(pmt->pbFormat);
    if (pHeader == NULL)
    {
        MSPDeleteMediaType(pmt);
        return E_UNEXPECTED;
    }

    LOG((MSP_INFO,
        "Video capture: Format BitRate: %d, TimePerFrame: %d",
        pVideoInfo->dwBitRate,
        pVideoInfo->AvgTimePerFrame));

    LOG((MSP_INFO, "Video capture: Format Compression:%c%c%c%c %dbit %dx%d",
        (DWORD)pHeader->biCompression & 0xff,
        ((DWORD)pHeader->biCompression >> 8) & 0xff,
        ((DWORD)pHeader->biCompression >> 16) & 0xff,
        ((DWORD)pHeader->biCompression >> 24) & 0xff,
        pHeader->biBitCount,
        pHeader->biWidth,
        pHeader->biHeight));

    // The time is in 100ns unit.
    pVideoInfo->AvgTimePerFrame = (DWORD) 1e7 / dwFramesPerSecond;
    
    if (bCIF)
    {
        pHeader->biWidth = CIFWIDTH;
        pHeader->biHeight = CIFHEIGHT;
    }
    else
    {
        pHeader->biWidth = QCIFWIDTH;
        pHeader->biHeight = QCIFHEIGHT;
    }

#if defined(ALPHA)
    // update bmiSize with new Width/Height
    pHeader->biSizeImage = DIBSIZE( ((VIDEOINFOHEADER *)pmt->pbFormat)->bmiHeader );
#endif

    if (FAILED(hr = pIAMStreamConfig->SetFormat(pmt)))
    {
        LOG((MSP_ERROR, "putMediaFormat returns error: %8x", hr));
    }
    else
    {
        LOG((MSP_INFO,
            "Video capture: Format BitRate: %d, TimePerFrame: %d",
            pVideoInfo->dwBitRate,
            pVideoInfo->AvgTimePerFrame));

        LOG((MSP_INFO, "Video capture: Format Compression:%c%c%c%c %dbit %dx%d",
            (DWORD)pHeader->biCompression & 0xff,
            ((DWORD)pHeader->biCompression >> 8) & 0xff,
            ((DWORD)pHeader->biCompression >> 16) & 0xff,
            ((DWORD)pHeader->biCompression >> 24) & 0xff,
            pHeader->biBitCount,
            pHeader->biWidth,
            pHeader->biHeight));
    }

    MSPDeleteMediaType(pmt);

    return hr;
}

HRESULT 
SetVideoBufferSize(
    IN IUnknown *pIUnknown
    )
/*++

Routine Description:

    Set the video capture terminal's buffersize.

Arguments:
    
    pIUnknown - a capture terminal.

Return Value:

    HRESULT

--*/
{
// The number of capture buffers is four for now.
#define NUMCAPTUREBUFFER 4

    LOG((MSP_TRACE, "SetVideoBufferSize"));

    HRESULT hr;

    CComPtr<IAMBufferNegotiation> pBN;
    if (FAILED(hr = pIUnknown->QueryInterface(
            IID_IAMBufferNegotiation,
            (void **)&pBN
            )))
    {
        LOG((MSP_ERROR, "Can't get buffer negotiation interface.%8x", hr));
        return hr;
    }

    ALLOCATOR_PROPERTIES prop;

#if 0   // Get allocator property is not working.
    if (FAILED(hr = pBN->GetAllocatorProperties(&prop)))
    {
        LOG((MSP_ERROR, "GetAllocatorProperties returns error: %8x", hr));
        return hr;
    }

    // Set the number of buffers.
    if (prop.cBuffers > NUMCAPTUREBUFFER)
    {
        prop.cBuffers = NUMCAPTUREBUFFER;
    }
#endif
    
    DWORD dwBuffers = NUMCAPTUREBUFFER;
    GetRegValue(gszNumVideoCaptureBuffers, &dwBuffers);

    prop.cBuffers = dwBuffers;
    prop.cbBuffer = -1;
    prop.cbAlign  = -1;
    prop.cbPrefix = -1;

    if (FAILED(hr = pBN->SuggestAllocatorProperties(&prop)))
    {
        LOG((MSP_ERROR, "SuggestAllocatorProperties returns error: %8x", hr));
    }
    else
    {
        LOG((MSP_INFO, 
            "SetVidedobuffersize"
            " buffers: %d, buffersize: %d, align: %d, Prefix: %d",
            prop.cBuffers,
            prop.cbBuffer,
            prop.cbAlign,
            prop.cbPrefix
            ));
    }
    return hr;
}

HRESULT CStreamVideoSend::ConfigureVideoCaptureTerminal(
    IN  ITTerminalControl*  pTerminal,
    IN  WCHAR *             szPinName,
    OUT IPin **             ppIPin
    )
/*++

Routine Description:

    Given a terminal, find the capture pin and configure it.

Arguments:
    
    pTerminal - a capture terminal.

    szPinName - the name of the pin needed.

    ppIPin  - the address to store a pointer to a IPin interface.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "ConfigureVideoCaptureTerminal, pTerminal %x", pTerminal));

    // Get the pins from the first terminal because we only use on terminal
    // on this stream.
    const DWORD MAXPINS     = 8;
    
    DWORD       dwNumPins   = MAXPINS;
    IPin *      Pins[MAXPINS];

    HRESULT hr = pTerminal->ConnectTerminal(
        m_pIGraphBuilder, 0, &dwNumPins, Pins
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't connect to terminal, %x", hr));
        return hr;
    }

    if (dwNumPins == 0)
    {
        LOG((MSP_ERROR, "terminal has no pins."));
        return hr;
    }

    CComPtr <IPin> pIPin;
/*
    // look through the pins to find the right one.
    for (DWORD i = 0; i < dwNumPins; i ++)
    {
        LPWSTR szName;
        hr = Pins[i]->QueryId(&szName);

        if (FAILED(hr))
        {
            continue;
        }

        LOG((MSP_INFO, "Pin name: %ws", szName));

        BOOL fEqual = (lstrcmpiW(szName, szPinName) == 0);

        CoTaskMemFree(szName);

        if (fEqual)
        {
            pIPin = Pins[i];
            break;
        }
    }
*/
    // we only need the first pin
    pIPin = Pins[0];

    // release the refcount because we don't need them.
    for (DWORD i = 0; i < dwNumPins; i ++)
    {
        Pins[i]->Release();
    }

    if (!pIPin)
    {
        LOG((MSP_ERROR, "can't find %ws pin", szPinName));
        return E_UNEXPECTED;
    }

    // set the video format. 7 Frames/Sec. QCIF.
    hr = SetVideoFormat(
        pIPin, 
        m_Settings.fCIF, 
        m_dwFrameRate
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't set video format, %x", hr));
        return hr;
    }

    // set the video buffer size.
    hr = SetVideoBufferSize(
        pIPin
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't set aduio capture buffer size, %x", hr));
        return hr;
    }

    pIPin->AddRef();
    *ppIPin = pIPin;

    return hr;
}

HRESULT CStreamVideoSend::FindPreviewInputPin(
    IN  ITTerminalControl*  pTerminal,
    OUT IPin **             ppIPin
    )
/*++

Routine Description:

    Find the input pin on a preview terminal.

Arguments:
    
    pTerminal - a video render terminal.

    ppIPin  - the address to store a pointer to a IPin interface.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "VideoSend.FindPreviewInputPin, pTerminal %x", pTerminal));

    // try to disable DDraw because our decoders can't handle DDraw.
    HRESULT hr2; 
    IDrawVideoImage *pIDrawVideoImage;
    hr2 = pTerminal->QueryInterface(IID_IDrawVideoImage, (void **)&pIDrawVideoImage); 
    if (SUCCEEDED(hr2))
    {
        hr2 = pIDrawVideoImage->DrawVideoImageBegin();
        if (FAILED(hr2))
        {
            LOG((MSP_WARN, "Can't disable DDraw. %x", hr2));
        }
        else
        {
            LOG((MSP_INFO, "DDraw disabled."));
        }
        
        pIDrawVideoImage->Release();
    }
    else
    {
        LOG((MSP_WARN, "Can't get IDrawVideoImage. %x", hr2));
    }


    // Get the pins from the first terminal because we only use on terminal
    // on this stream.
    const DWORD MAXPINS     = 8;
    
    DWORD       dwNumPins   = MAXPINS;
    IPin *      Pins[MAXPINS];

    HRESULT hr = pTerminal->ConnectTerminal(
        m_pIGraphBuilder, 0, &dwNumPins, Pins
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't connect to terminal, %x", hr));
        return hr;
    }

    if (dwNumPins == 0)
    {
        LOG((MSP_ERROR, "terminal has no pins."));
        return hr;
    }

    // Save the first pin and release the others.
    CComPtr <IPin> pIPin = Pins[0];
    for (DWORD i = 0; i < dwNumPins; i ++)
    {
        Pins[i]->Release();
    }

    pIPin->AddRef();
    *ppIPin = pIPin;

    return hr;
}

HRESULT CStreamVideoSend::CheckTerminalTypeAndDirection(
    IN      ITTerminal *            pTerminal
    )
/*++

Routine Description:
    
    Check if the terminal is allowed on this stream.
    VideoSend allows both a capture terminal and a preivew terminal.

Arguments:

    pTerminal   - the terminal.

Return value:

    HRESULT.
    S_OK means the terminal is OK.
*/
{
    LOG((MSP_TRACE, "VideoSend.CheckTerminalTypeAndDirection"));

    // This stream only support one capture + one preview terminal
    if (m_Terminals.GetSize() > 1)
    {
        return TAPI_E_MAXTERMINALS;
    }

    // check the media type of this terminal.
    long lMediaType;
    HRESULT hr = pTerminal->get_MediaType(&lMediaType);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get terminal media type. %x", hr));
        return TAPI_E_INVALIDTERMINAL;
    }

    if ((DWORD)lMediaType != m_dwMediaType)
    {
        return TAPI_E_INVALIDTERMINAL;
    }

    // check the direction of this terminal.
    TERMINAL_DIRECTION Direction;
    hr = pTerminal->get_Direction(&Direction);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get terminal direction. %x", hr));
        return TAPI_E_INVALIDTERMINAL;
    }

    if (m_Terminals.GetSize() > 0)
    {
        // check the direction of this terminal.
        TERMINAL_DIRECTION Direction2;
        hr = m_Terminals[0]->get_Direction(&Direction2);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "can't get terminal direction. %x", hr));
            return TAPI_E_INVALIDTERMINAL;
        }
        if (Direction == Direction2)
        {
            LOG((MSP_ERROR, 
                "can't have two terminals with the same direction. %x", hr));
            return TAPI_E_MAXTERMINALS;
        }
    }
    return S_OK;
}

HRESULT CStreamVideoSend::SetUpFilters()
/*++

Routine Description:

    Insert filters into the graph and connect to the terminals.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "VideoSend.SetUpFilters"));

    // we only support one capture terminal and one preview 
    // window on this stream.
    if (m_Terminals.GetSize() > 2)
    {
        return E_UNEXPECTED;
    }

    int iCaptureIndex = -1, iPreviewIndex = -1;

    // Find out which terminal is capture and which is preview.
    HRESULT hr;
    for (int i = 0; i < m_Terminals.GetSize(); i ++)
    {
        TERMINAL_DIRECTION Direction;
        hr = m_Terminals[i]->get_Direction(&Direction);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "can't get terminal direction. %x", hr));
            SendStreamEvent(CALL_TERMINAL_FAIL, CALL_CAUSE_BAD_DEVICE, hr, m_Terminals[i]);
        
            return hr;
        }
        if (Direction == TD_CAPTURE)
        {
            iCaptureIndex = i;
        }
        else
        {
            iPreviewIndex = i;
        }
    }

    // the stream will not work without a capture terminal.
    if (iCaptureIndex == -1)
    {
        LOG((MSP_ERROR, "no capture terminal selected."));
        return E_UNEXPECTED;
    }

    // Connect the capture filter to the terminal.
    if (FAILED(hr = ConnectTerminal(
        m_Terminals[iCaptureIndex]
        )))
    {
        LOG((MSP_ERROR, "connect the codec filter to terminal. %x", hr));

        return hr;
    }

    if (iPreviewIndex != -1)
    {
        // Connect the preview filter to the terminal.
        if (FAILED(hr = ConnectTerminal(
            m_Terminals[iPreviewIndex]
            )))
        {
            LOG((MSP_ERROR, "connect the codec filter to terminal. %x", hr));

            return hr;
        }
    }

    return hr;
}

HRESULT CStreamVideoSend::ConfigureRTPFilter(
    IN  IBaseFilter *   pIBaseFilter
    )
/*++

Routine Description:

    Configure the source RTP filter. Including set the address, port, TTL,
    QOS, thread priority, clockrate, etc.

Arguments:
    
    pIBaseFilter - The source RTP Filter.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "VideoSend.ConfigureRTPFilter"));

    HRESULT hr;

    // Get the IRTPStream interface pointer on the filter.
    CComQIPtr<IRTPStream, &IID_IRTPStream> pIRTPStream(pIBaseFilter);
    if (pIRTPStream == NULL)
    {
        LOG((MSP_ERROR, "get RTP Stream interface"));
        return E_NOINTERFACE;
    }

    LOG((MSP_INFO, "set remote Address:%x, port:%d, TTL:%d", 
        m_Settings.dwIPRemote, m_Settings.wRTPPortRemote, m_Settings.dwTTL));

    // Set the remote address and port used in the filter.
    if (FAILED(hr = pIRTPStream->SetAddress(
        0,                                  // local port.
        htons(m_Settings.wRTPPortRemote),   // remote port.
        htonl(m_Settings.dwIPRemote)
        )))
    {
        LOG((MSP_ERROR, "set remote Address, hr:%x", hr));
        return hr;
    }

    // Set the TTL used in the filter.
    if (FAILED(hr = pIRTPStream->SetMulticastScope(m_Settings.dwTTL)))
    {
        LOG((MSP_ERROR, "set TTL. %x", hr));
        return hr;
    }

    if (m_Settings.dwIPLocal != INADDR_ANY)
    {
        // set the local interface that the socket should bind to
        LOG((MSP_INFO, "set locol Address:%x", m_Settings.dwIPLocal));

        if (FAILED(hr = pIRTPStream->SelectLocalIPAddress(
            htonl(m_Settings.dwIPLocal)
            )))
        {
            LOG((MSP_ERROR, "set local Address, hr:%x", hr));
            return hr;
        }
    }

    // Set the priority of the session
    if (FAILED(hr = pIRTPStream->SetSessionClassPriority(
        RTP_CLASS_VIDEO,
        g_dwVideoThreadPriority
        )))
    {
        LOG((MSP_ERROR, "set session class and priority. %x", hr));
    }

    // Set the sample rate of the session
    LOG((MSP_INFO, "setting session sample rate to %d", m_dwFrameRate));
    
    if (FAILED(hr = pIRTPStream->SetDataClock(m_dwFrameRate)))
    {
        LOG((MSP_ERROR, "set session sample rate. %x", hr));
    }

    // Enable the RTCP events
    if (FAILED(hr = ::EnableRTCPEvents(pIBaseFilter)))
    {
        LOG((MSP_WARN, "can not enable RTCP events %x", hr));
    }

    if (m_Settings.dwQOSLevel != QSL_BEST_EFFORT)
    {
        if (FAILED(hr = ::SetQOSOption(
            pIBaseFilter,
            m_Settings.dwPayloadType,        // payload
            -1,                             // use the default bitrate 
            (m_Settings.dwQOSLevel == QSL_NEEDED),  // fail if no qos.
            FALSE,                          // this is the send stream.
            1,                              // only one stream
            m_Settings.fCIF
            )))
        {
            LOG((MSP_ERROR, "set QOS option. %x", hr));
            return hr;
        }
    }

    SetLocalInfoOnRTPFilter(pIBaseFilter);

    return S_OK;
}

HRESULT CStreamVideoSend::ConnectTerminal(
    IN  ITTerminal *   pITTerminal
    )
/*++

Routine Description:

    connect the video terminals to the stream.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "VideoSend.ConnectTerminal %x", pITTerminal));

    // Get the TerminalControl interface on the terminal
    CComQIPtr<ITTerminalControl, &IID_ITTerminalControl> 
        pTerminal(pITTerminal);
    if (pTerminal == NULL)
    {
        LOG((MSP_ERROR, "can't get Terminal Control interface"));
        
        SendStreamEvent(CALL_TERMINAL_FAIL, CALL_CAUSE_BAD_DEVICE, E_NOINTERFACE, pITTerminal);

        return E_NOINTERFACE;
    }

    // Find out the direction of the terminal.
    TERMINAL_DIRECTION Direction;
    HRESULT hr = pITTerminal->get_Direction(&Direction);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get terminal direction. %x", hr));
        SendStreamEvent(CALL_TERMINAL_FAIL, CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);
    
        return hr;
    }

    if (Direction == TD_CAPTURE)
    {
        // find the capture pin on the capture terminal and configure it.
        CComPtr<IPin>   pCapturePin;
        hr = ConfigureVideoCaptureTerminal(pTerminal, L"Capture", &pCapturePin);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "configure video capture termianl failed. %x", hr));
  
            SendStreamEvent(CALL_TERMINAL_FAIL, CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);

            return hr;
        }

        hr = CreateSendFilters(pCapturePin);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "Create video send filters failed. %x", hr));

            // disconnect the terminal.
            pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

            // clean up internal filters as well.
            CleanUpFilters();

            return hr;
        }

        //
        // Now we are actually connected. Update our state and perform postconnection
        // (ignore postconnection error code).
        //
        pTerminal->CompleteConnectTerminal();


#if 0  // We don't have the preview pin now, enable this code later when we 
       // the have preview pin.

        if (FAILED(hr))
        {
            // find the preview pin on the capture terminal and configure it.
            CComPtr<IPin>   pCapturePin;
            hr = ConfigureVideoCaptureTerminal(pTerminal, L"Preview", &pCapturePin);
            if (FAILED(hr))
            {
                LOG((MSP_ERROR, "configure video capture termianl failed. %x", hr));

                SendStreamEvent(CALL_TERMINAL_FAIL, CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);
        
                return hr;
            }

            hr = CreateSendFilters(pCapturePin);
            if (FAILED(hr))
            {
                LOG((MSP_ERROR, "Create video send filters failed. %x", hr));

                // disconnect the terminal.
                pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

                // clean up internal filters as well.
                CleanUpFilters();

                return hr;
         
            }

            //
            // Now we are actually connected. Update our state and perform postconnection
            // (ignore postconnection error code).
            //
            pTerminal->CompleteConnectTerminal();
        }
#endif

    }
    else
    {
        // find the input pin on the preview window. If there is no preview window,
        // we just pass in NULL for the next function.
        CComPtr<IPin>   pPreviewInputPin;

        hr = FindPreviewInputPin(pTerminal, &pPreviewInputPin);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "find preview input pin failed. %x", hr));

            SendStreamEvent(CALL_TERMINAL_FAIL, CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);
            return hr;
        }

        hr = ConnectPreview(pPreviewInputPin);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "Create video send filters failed. %x", hr));

            pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

            return hr;
        }

        //
        // Now we are actually connected. Update our state and perform postconnection
        // (ignore postconnection error code).
        //
        pTerminal->CompleteConnectTerminal();

    }
    return hr;
}

HRESULT CStreamVideoSend::ConnectPreview(
    IN    IPin          *pPreviewInputPin
    )
/*++

Routine Description:

    connect the preview pin the the TEE filter.

    Capturepin->TEE+->Encoder->SPH->RTPRender
                   +->PreviewInputPin

Arguments:
    
    pPin - The output pin on the capture filter.

Return Value:

    HRESULT.

--*/
{
    HRESULT hr;

    if (m_pEdgeFilter == NULL)
    {
        LOG((MSP_ERROR, "no capture to preview"));
        return E_UNEXPECTED;
    }

    // Create the AVI decompressor filter and add it into the graph.
    // This will make the graph construction faster for since the AVI
    // decompressor are always needed for the preview
    CComPtr<IBaseFilter> pAviFilter;
    if (FAILED(hr = ::AddFilter(
            m_pIGraphBuilder,
            CLSID_AVIDec,   
            L"Avi", 
            &pAviFilter)))
    {
        LOG((MSP_ERROR, "add Avi filter. %x", hr));
        return hr;
    }
    
    // connect the preview input pin with the smart tee filter.
    if (FAILED(hr = ::ConnectFilters(
        m_pIGraphBuilder,
        (IBaseFilter *)m_pEdgeFilter,
        (IPin *)pPreviewInputPin,
        FALSE       // not direct connect
        )))
    {
        LOG((MSP_ERROR, "connect preview input pin with the tee. %x", hr));
        return hr;
    }
    return hr;
}

HRESULT 
ConfigureEncoder(
    IN IBaseFilter *    pIFilter,
    IN BOOL             bCIF,
    IN DWORD            dwFramesPerSecond
    )
/*++

Routine Description:

    Set the video capture terminal's buffersize.

Arguments:
    
    pIFilter            - a H26x encoder.

    bCIF                - CIF or QCIF.

    pdwFramesPerSecond  - Frames per second.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "ConfigureEncoder"));

    HRESULT hr;

    CComPtr<IH26XEncoderControl> pIH26XEncoderControl;
    if (FAILED(hr = pIFilter->QueryInterface(
        IID_IH26XEncoderControl, 
        (void **)&pIH26XEncoderControl
        )))
    {
        LOG((MSP_ERROR, "Can't get pIH26XEncoderControl interface.%8x", hr));
        return hr;
    }
    
    // get the current encoder properties of the video capture terminal.
    ENC_CMP_DATA prop;
    if (FAILED(hr = pIH26XEncoderControl->get_EncodeCompression(&prop)))
    {
        LOG((MSP_ERROR, "get_EncodeCompression returns error: %8x", hr));
        return hr;
    }

    LOG((MSP_INFO, 
        "Video encoder::get_EncodeCompression"
        " FrameRate: %d, BitRate: %d, Width %d, bSendKey: %s, Quality: %d",
        prop.dwFrameRate,
        prop.dwDataRate,
        prop.dwWidth,
        prop.bSendKey ? "TRUE" : "FALSE",
        prop.dwQuality
        ));

    // Set the key frame interval.
    prop.bSendKey           = TRUE;
    prop.dwFrameRate        = dwFramesPerSecond;
    prop.dwKeyFramePeriod   = 5000; // a key frame every five seconds.
    prop.dwQuality          = 7500; 

#define SETBITRATE
#ifdef SETBITRATE
    DWORD dwBitRate = 0;
    if (GetRegValue(L"BitRate", &dwBitRate))
    {
        prop.bFrameSizeBRC      = FALSE;                // control bit rate
        prop.dwDataRate         = dwBitRate;

        if (dwBitRate < 100)
        {
            prop.dwQuality      = 0;
            prop.dwKeyFrameInterval = 100; 
        }
    }

    DWORD dwQuality = 0;
    if (GetRegValue(L"Quality", &dwQuality))
    {
        prop.dwQuality          = dwQuality;
    }
#endif

    if (bCIF)
    {
        prop.dwWidth = CIFWIDTH;
    }
    else
    {
        prop.dwWidth = QCIFWIDTH;
    }
    if (FAILED(hr = pIH26XEncoderControl->set_EncodeCompression(&prop)))
    {
        LOG((MSP_ERROR, "set_EncodeCompression returns error: %8x", hr));
    }
    else
    {
        LOG((MSP_INFO, 
            "Video encoder::set_EncodeCompression"
            " FrameRate: %d, BitRate: %d, Width %d, bSendKey: %s, Quality: %d",
            prop.dwFrameRate,
            prop.dwDataRate,
            prop.dwWidth,
            prop.bSendKey ? "TRUE" : "FALSE",
            prop.dwQuality
            ));

    }
    return hr;
}

HRESULT CStreamVideoSend::CreateSendFilters(
    IN    IPin          *pCapturePin
    )
/*++

Routine Description:

    Insert filters into the graph and connect to the capture pin.

    Capturepin->TEE+->Encoder->SPH->RTPRender
 
Arguments:
    
    pPin - The output pin on the capture filter.

Return Value:

    HRESULT.

--*/
{
    HRESULT hr;

    if (m_pEdgeFilter)
    {
        // connect the capture pin with the smart tee filter.
        if (FAILED(hr = ::ConnectFilters(
            m_pIGraphBuilder,
            (IPin *)pCapturePin, 
            (IBaseFilter *)m_pEdgeFilter
            )))
        {
            LOG((MSP_ERROR, "connect capture pin with the tee. %x", hr));
            return hr;
        }
        return hr;
    }

    // Create the tee filter and add it into the graph.
    CComPtr<IBaseFilter> pTeeFilter;
    if (FAILED(hr = ::AddFilter(
            m_pIGraphBuilder,
            CLSID_SmartTee,   
//            CLSID_InfTee, 
            L"tee", 
            &pTeeFilter)))
    {
        LOG((MSP_ERROR, "add smart tee filter. %x", hr));
        return hr;
    }

    // connect the capture pin with the tee filter.
    if (FAILED(hr = ::ConnectFilters(
        m_pIGraphBuilder,
        (IPin *)pCapturePin, 
        (IBaseFilter *)pTeeFilter
        )))
    {
        LOG((MSP_ERROR, "connect capture pin with the tee. %x", hr));
        return hr;
    }

    // Create the codec filter and add it into the graph.
    CComPtr<IBaseFilter> pCodecFilter;

    if (FAILED(hr = ::AddFilter(
            m_pIGraphBuilder,
            *m_pClsidCodecFilter, 
            L"Encoder", 
            &pCodecFilter)))
    {
        LOG((MSP_ERROR, "add Codec filter. %x", hr));
        return hr;
    }

    // tell the encoder to send key frame
    if (FAILED(hr = ::ConfigureEncoder(
        pCodecFilter, 
        m_Settings.fCIF, 
        m_dwFrameRate
        )))
    {
        LOG((MSP_WARN, "Configure video encoder. %x", hr));
    }

    // connect the smart tee filter and the Codec filter.
    if (FAILED(hr = ::ConnectFilters(
        m_pIGraphBuilder,
        (IBaseFilter *)pTeeFilter, 
        (IBaseFilter *)pCodecFilter
        )))
    {
        LOG((MSP_ERROR, "connect Tee filter and codec filter. %x", hr));
        return hr;
    }

    // Create the send payload handler and add it into the graph.
    CComPtr<IBaseFilter> pISPHFilter;
    if (FAILED(hr = ::AddFilter(
        m_pIGraphBuilder,
        *m_pClsidPHFilter, 
        L"SPH", 
        &pISPHFilter
        )))
    {
        LOG((MSP_ERROR, "add SPH filter. %x", hr));
        return hr;
    }

    // Connect the Codec filter with the SPH filter .
    if (FAILED(hr = ::ConnectFilters(
        m_pIGraphBuilder,
        (IBaseFilter *)pCodecFilter, 
        (IBaseFilter *)pISPHFilter
        )))
    {
        LOG((MSP_ERROR, "connect codec filter and SPH filter. %x", hr));
        return hr;
    }

    // Get the IRTPSPHFilter interface.
    CComQIPtr<IRTPSPHFilter, 
        &IID_IRTPSPHFilter> pIRTPSPHFilter(pISPHFilter);
    if (pIRTPSPHFilter == NULL)
    {
        LOG((MSP_ERROR, "get IRTPSPHFilter interface"));
        return E_NOINTERFACE;
    }

    // Create the RTP render filter and add it into the graph.
    CComPtr<IBaseFilter> pRenderFilter;

    if (FAILED(hr = ::AddFilter(
            m_pIGraphBuilder,
            CLSID_RTPRenderFilter, 
            L"RtpRender", 
            &pRenderFilter)))
    {
        LOG((MSP_ERROR, "adding render filter. %x", hr));
        return hr;
    }

    // Set the address for the render fitler.
    if (FAILED(hr = ConfigureRTPFilter(pRenderFilter)))
    {
        LOG((MSP_ERROR, "configure RTP Filter failed %x", hr));
        return hr;
    }

    // Connect the SPH filter with the RTP Render filter.
    if (FAILED(hr = ::ConnectFilters(
        m_pIGraphBuilder,
        (IBaseFilter *)pISPHFilter, 
        (IBaseFilter *)pRenderFilter
        )))
    {
        LOG((MSP_ERROR, "connect SPH filter and Render filter. %x", hr));
        return hr;
    }

    // remember the first filter after the terminal 
    m_pEdgeFilter = pTeeFilter;
    m_pEdgeFilter->AddRef();

    // Get the IRTPParticipant interface pointer on the RTP filter.
    CComQIPtr<IRTPParticipant, 
        &IID_IRTPParticipant> pIRTPParticipant(pRenderFilter);
    if (pIRTPParticipant == NULL)
    {
        LOG((MSP_WARN, "can't get RTP participant interface"));
    }
    else
    {
        m_pRTPFilter = pIRTPParticipant;
        m_pRTPFilter->AddRef();
    }

    return S_OK;
}


CSubStreamVideoRecv::CSubStreamVideoRecv()
    : m_pFTM(NULL),
      m_pStream(NULL),
      m_pCurrentParticipant(NULL)
{
}

// methods called by the videorecv object.
HRESULT CSubStreamVideoRecv::Init(
    IN  CStreamVideoRecv *       pStream
    )
/*++

Routine Description:

    Initialize the substream object.

Arguments:
    
    pStream - The pointer to the stream that owns this substream.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, 
        "CSubStreamVideoRecv::Init, pStream %p", pStream));

    // This method is called only once when the object is created. No other
    // method will be called until this function succeeds. No need to lock.
    _ASSERTE(m_pStream == NULL);

    // initialize the terminal array so that the array is not NULL. Used for
    // generating an empty enumerator if no terminal is selected.
    if (!m_Terminals.Grow())
    {
        LOG((MSP_ERROR, "CSubStreamVideoRecv::Init - exit E_OUTOFMEMORY"));

        return E_OUTOFMEMORY;
    }
    
    // create the marshaler.
    HRESULT hr;
    hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), &m_pFTM);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "create marshaler failed, %x", hr));
        return hr;
    }

    // save the stream reference.
    m_pStream = pStream;
    (pStream->GetControllingUnknown())->AddRef();

    LOG((MSP_TRACE, "CSubStreamVideoRecv::Init returns S_OK"));

    return S_OK;
}

#ifdef DEBUG_REFCOUNT
ULONG CSubStreamVideoRecv::InternalAddRef()
{
    ULONG lRef = CComObjectRootEx<CComMultiThreadModelNoCS>::InternalAddRef();
    
    LOG((MSP_TRACE, "SubStreamVideoRecv %p Addref, ref = %d", this, lRef));

    return lRef;
}

ULONG CSubStreamVideoRecv::InternalRelease()
{
    ULONG lRef = CComObjectRootEx<CComMultiThreadModelNoCS>::InternalRelease();
    
    LOG((MSP_TRACE, "SubStreamVideoRecv %p Release, ref = %d", this, lRef));

    return lRef;
}
#endif

void CSubStreamVideoRecv::FinalRelease()
/*++

Routine Description:

    release everything before being deleted. 

Arguments:
    
Return Value:

--*/
{
    LOG((MSP_TRACE, "CSubStreamVideoRecv::FinalRelease - enter"));

    if (m_pCurrentParticipant)
    {
        m_pCurrentParticipant->Release();
    }

    for ( int i = 0; i < m_Terminals.GetSize(); i ++ )
    {
        m_Terminals[i]->Release();
    }
    m_Terminals.RemoveAll(); 

    if (m_pStream)
    {
        (m_pStream->GetControllingUnknown())->Release();
    }

    if (m_pFTM)
    {
        m_pFTM->Release();
    }

    LOG((MSP_TRACE, "CSubStreamVideoRecv::FinalRelease - exit"));
}

STDMETHODIMP CSubStreamVideoRecv::SelectTerminal(
    IN      ITTerminal *            pTerminal
    )
/*++

Routine Description:

    Select a terminal on this substream. This method calls the same method
    on the stream object to handle that.

Arguments:
    pTerminal - the terminal to be selected.
  
Return Value:

--*/
{
    LOG((MSP_TRACE, 
        "CSubStreamVideoRecv::SelectTerminal, pTerminal %p", pTerminal));

    HRESULT hr;
    
    m_lock.Lock();
    if (m_Terminals.GetSize() > 0)
    {
        m_lock.Unlock();
        return TAPI_E_MAXTERMINALS;
    }

    BOOL bFlag = m_Terminals.Add(pTerminal);

    _ASSERTE(bFlag);

    m_lock.Unlock();

    if (!bFlag)
    {
        return E_OUTOFMEMORY;
    }

    // This is the refcount for the pointer in m_Terminals.
    pTerminal->AddRef();

    // Call the stream's select terminal to handle the state changes and also
    // make sure that locking happens only from the stream to substream.
    hr = m_pStream->SubStreamSelectTerminal(this, pTerminal);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "CSubStreamVideoRecv::SelectTerminal failed, hr:%x", hr));
    
        m_lock.Lock();

        m_Terminals.Remove(pTerminal);
        pTerminal->Release();
        
        m_lock.Unlock();

    }
    return hr;
}

STDMETHODIMP CSubStreamVideoRecv::UnselectTerminal(
    IN     ITTerminal *             pTerminal
    )
/*++

Routine Description:

    Unselect a terminal on this substream. This method calls the same method
    on the stream object to handle that.

Arguments:
    pTerminal - the terminal to be unselected.
  
Return Value:

--*/
{
    LOG((MSP_TRACE, 
        "CSubStreamVideoRecv::UnSelectTerminal, pTerminal %p", pTerminal));

    m_lock.Lock();
    if (!m_Terminals.Remove(pTerminal))
    {
        m_lock.Unlock();
        LOG((MSP_ERROR, "SubStreamVideoRecv::UnselectTerminal, invalid terminal."));

        return TAPI_E_INVALIDTERMINAL;
    }
    pTerminal->Release();

    m_lock.Unlock();

    HRESULT hr;
    
    // Call the stream's unselect terminal to handle the state changes and also
    // make sure that locking happens only from the stream to substream.
    hr = m_pStream->UnselectTerminal(pTerminal);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "CSubStreamVideoRecv::UnSelectTerminal failed, hr:%x", hr));
    }
    return hr;
}

STDMETHODIMP CSubStreamVideoRecv::EnumerateTerminals(
    OUT     IEnumTerminal **        ppEnumTerminal
    )
{
    LOG((MSP_TRACE, 
        "EnumerateTerminals entered. ppEnumTerminal:%x", ppEnumTerminal));

    if (IsBadWritePtr(ppEnumTerminal, sizeof(VOID *)))
    {
        LOG((MSP_ERROR, "ppEnumTerminal is a bad pointer"));
        return E_POINTER;
    }

    // acquire the lock before accessing the Terminal object list.
    CLock lock(m_lock);

    if (m_Terminals.GetData() == NULL)
    {
        LOG((MSP_ERROR, "CSubStreamVideoRecv::EnumerateTerminals - "
            "stream appears to have been shut down - exit E_UNEXPECTED"));

        return E_UNEXPECTED;
    }

    typedef _CopyInterface<ITTerminal> CCopy;
    typedef CSafeComEnum<IEnumTerminal, &IID_IEnumTerminal, 
                ITTerminal *, CCopy> CEnumerator;

    HRESULT hr;

    CMSPComObject<CEnumerator> *pEnum = NULL;

    hr = CMSPComObject<CEnumerator>::CreateInstance(&pEnum);
    if (pEnum == NULL)
    {
        LOG((MSP_ERROR, "Could not create enumerator object, %x", hr));
        return hr;
    }

    // query for the IID_IEnumTerminal i/f
    IEnumTerminal *        pEnumTerminal;
    hr = pEnum->_InternalQueryInterface(IID_IEnumTerminal, (void**)&pEnumTerminal);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "query enum interface failed, %x", hr));
        delete pEnum;
        return hr;
    }

    // The CSafeComEnum can handle zero-sized array.
    hr = pEnum->Init(
        m_Terminals.GetData(),                        // the begin itor
        m_Terminals.GetData() + m_Terminals.GetSize(),  // the end itor, 
        NULL,                                       // IUnknown
        AtlFlagCopy                                 // copy the data.
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "init enumerator object failed, %x", hr));
        pEnumTerminal->Release();
        return hr;
    }

    LOG((MSP_TRACE, "CSubStreamVideoRecv::EnumerateTerminals - exit S_OK"));

    *ppEnumTerminal = pEnumTerminal;

    return hr;
}

STDMETHODIMP CSubStreamVideoRecv::get_Terminals(
    OUT     VARIANT *               pVariant
    )
{
    LOG((MSP_TRACE, "CSubStreamVideoRecv::get_Terminals - enter"));

    //
    // Check parameters.
    //

    if ( IsBadWritePtr(pVariant, sizeof(VARIANT) ) )
    {
        LOG((MSP_ERROR, "CSubStreamVideoRecv::get_Terminals - "
            "bad pointer argument - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // See if this stream has been shut down. Acquire the lock before accessing
    // the terminal object list.
    //

    CLock lock(m_lock);

    if (m_Terminals.GetData() == NULL)
    {
        LOG((MSP_ERROR, "CSubStreamVideoRecv::get_Terminals - "
            "stream appears to have been shut down - exit E_UNEXPECTED"));

        return E_UNEXPECTED;
    }


    //
    // create the collection object - see mspcoll.h
    //

    HRESULT hr;
    typedef CTapiIfCollection< ITTerminal * > TerminalCollection;
    CComObject<TerminalCollection> * pCollection;
    hr = CComObject<TerminalCollection>::CreateInstance( &pCollection );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CSubStreamVideoRecv::get_Terminals - "
            "can't create collection - exit 0x%08x", hr));

        return hr;
    }

    //
    // get the Collection's IDispatch interface
    //

    IDispatch * pDispatch;

    hr = pCollection->_InternalQueryInterface(IID_IDispatch,
                                              (void **) &pDispatch );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CSubStreamVideoRecv::get_Terminals - "
            "QI for IDispatch on collection failed - exit 0x%08x", hr));

        delete pCollection;

        return hr;
    }

    //
    // Init the collection using an iterator -- pointers to the beginning and
    // the ending element plus one.
    //

    hr = pCollection->Initialize( m_Terminals.GetSize(),
                                  m_Terminals.GetData(),
                                  m_Terminals.GetData() + m_Terminals.GetSize() );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CSubStreamVideoRecv::get_Terminals - "
            "Initialize on collection failed - exit 0x%08x", hr));
        
        pDispatch->Release();
        return hr;
    }

    //
    // put the IDispatch interface pointer into the variant
    //

    LOG((MSP_ERROR, "CSubStreamVideoRecv::get_Terminals - "
        "placing IDispatch value %08x in variant", pDispatch));

    VariantInit(pVariant);
    pVariant->vt = VT_DISPATCH;
    pVariant->pdispVal = pDispatch;

    LOG((MSP_TRACE, "CSubStreamVideoRecv::get_Terminals - exit S_OK"));
 
    return S_OK;
}

STDMETHODIMP CSubStreamVideoRecv::get_Stream (
    OUT     ITStream **             ppITStream
    )
{
    LOG((MSP_TRACE, 
        "VideoRecvSubStream.get_Stream, ppITStream %x", ppITStream));
 
    if (IsBadWritePtr(ppITStream, sizeof (VOID *)))
    {
        LOG((MSP_ERROR, "Bad pointer, ppITStream:%x",ppITStream));
        return E_POINTER;
    }

    ITStream *  pITStream;
    HRESULT hr = m_pStream->_InternalQueryInterface(
        IID_ITStream, 
        (void **)&pITStream
    );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get_Stream:QueryInterface failed: %x", hr));
        return hr;
    }

    *ppITStream = pITStream;

    return S_OK;
}

STDMETHODIMP CSubStreamVideoRecv::StartSubStream()
{
    return TAPI_E_NOTSUPPORTED;
}

STDMETHODIMP CSubStreamVideoRecv::PauseSubStream()
{
    return TAPI_E_NOTSUPPORTED;
}

STDMETHODIMP CSubStreamVideoRecv::StopSubStream()
{
    return TAPI_E_NOTSUPPORTED;
}

BOOL CSubStreamVideoRecv::GetCurrentParticipant(
    DWORD * pdwSSRC,
    ITParticipant** ppITParticipant 
    )
{
    CLock lock(m_lock);
    if (m_pCurrentParticipant)
    {
        m_pCurrentParticipant->AddRef();
        *ppITParticipant = m_pCurrentParticipant;
        
        ((CParticipant *)m_pCurrentParticipant)->GetSSRC(
            (ITStream*)m_pStream,
            pdwSSRC
            );

        return TRUE;
    }  
    return FALSE;
}

VOID CSubStreamVideoRecv::SetCurrentParticipant(
    DWORD dwSSRC,
    ITParticipant * pParticipant
    )
{
    CLock lock(m_lock);
    
    if (m_pCurrentParticipant)
    {
        m_pCurrentParticipant->Release();
    }

    m_pCurrentParticipant = pParticipant;

    if (m_pCurrentParticipant)
    {
        m_pCurrentParticipant->AddRef();
    }
}

BOOL CSubStreamVideoRecv::ClearCurrentTerminal()
{
    CLock lock(m_lock);

    if (m_Terminals.GetSize() > 0)
    {
        m_Terminals[0]->Release();
        m_Terminals.RemoveAt(0);

        return TRUE;
    }
    
    return FALSE;
}

BOOL CSubStreamVideoRecv::SetCurrentTerminal(ITTerminal * pTerminal)
{
    CLock lock(m_lock);
    
    if (m_Terminals.GetSize() > 0)
    {
        _ASSERTE(FALSE);
        return FALSE;
    }

    BOOL bFlag = m_Terminals.Add(pTerminal);

    // This should never fail since the terminal array has been grown
    // at the init time.
    _ASSERTE(bFlag);

    if (bFlag)
    {
        pTerminal->AddRef();
        return TRUE;
    }
    
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\confmsp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__F8FF7774_4BD5_11D1_AFD1_00C04FC31FEE__INCLUDED_)
#define AFX_STDAFX_H__F8FF7774_4BD5_11D1_AFD1_00C04FC31FEE__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <mspbase.h>
#include <confpriv.h>
#include <winsock2.h>
#include <sdpblb.h>

#include <streams.h>    // for amvideo stuff
#include <mmreg.h>      // for WAVEFORMATEX
#include <rtp.h>        // for RTP stuff

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__F8FF7774_4BD5_11D1_AFD1_00C04FC31FEE__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\confmsp\confvid.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    Confvid.h

Abstract:

    Definitions for audio streams

Author:

    Mu Han (muhan) 15-September-1998

--*/
#ifndef __CONFVID_H_
#define __CONFVID_H_

// if there is no data for five senconds, the pin can be reused.
const DWORD g_dwVideoPinTimeOut     = 5000; 

const DWORD g_dwVideoThreadPriority = THREAD_PRIORITY_NORMAL;
const DWORD g_dwVideoChannels       = 20;  
const BOOL  g_fCIF                  = FALSE;  
const DWORD g_dwVideoSampleRate     = 7;  

const int CIFWIDTH      = 0x160;
const int CIFHEIGHT     = 0x120;

const int QCIFWIDTH     = 0xb0;
const int QCIFHEIGHT    = 0x90;

typedef struct _PINMAPEVENT
{
    IPin *  pIPin;
    DWORD   dwSSRC;

} PINMAPEVENT;

// This data structure keeps the information for on brach of filters off one
// demux output pin.
typedef struct _BRANCH
{
    IPin *          pIPin;
    DWORD           dwSSRC;
    IBaseFilter *   pRPHFilter;
    IBaseFilter *   pCodecFilter;
    ITTerminal *    pITTerminal;
    ITSubStream *   pITSubStream;

} BRANCH;

class ATL_NO_VTABLE CStreamVideoRecv : 
    public CIPConfMSPStream,
    public IDispatchImpl<ITSubStreamControl, 
        &IID_ITSubStreamControl, &LIBID_TAPI3Lib>,
    public IDispatchImpl<ITParticipantSubStreamControl, 
        &IID_ITParticipantSubStreamControl, &LIBID_IPConfMSPLib>
    {
public:
    CStreamVideoRecv();

BEGIN_COM_MAP(CStreamVideoRecv)
    COM_INTERFACE_ENTRY(ITSubStreamControl)
    COM_INTERFACE_ENTRY(ITParticipantSubStreamControl)
    COM_INTERFACE_ENTRY2(IDispatch, ITStream)
    COM_INTERFACE_ENTRY_CHAIN(CIPConfMSPStream)
END_COM_MAP()

// ITSubStreamControl methods, called by the app.
    STDMETHOD (CreateSubStream) (
        IN OUT  ITSubStream **         ppSubStream
        );
    
    STDMETHOD (RemoveSubStream) (
        IN      ITSubStream *          pSubStream
        );

    STDMETHOD (EnumerateSubStreams) (
        OUT     IEnumSubStream **      ppEnumSubStream
        );

    STDMETHOD (get_SubStreams) (
        OUT     VARIANT *              pSubStreams
        );

// ITParticipantSubStreamControl methods, called by the app.
    STDMETHOD (get_SubStreamFromParticipant) (
        IN  ITParticipant * pITParticipant,
        OUT ITSubStream ** ppITSubStream
        );

    STDMETHOD (get_ParticipantFromSubStream) (
        IN  ITSubStream * pITSubStream,
        OUT ITParticipant ** ppITParticipant 
        );

    STDMETHOD (SwitchTerminalToSubStream) (
        IN  ITTerminal * pITTerminal,
        IN  ITSubStream * pITSubStream
        );

// method called by the MSPCall object.
    virtual HRESULT Init(
        IN     HANDLE                   hAddress,
        IN     CMSPCallBase *           pMSPCall,
        IN     IMediaEvent *            pGraph,
        IN     DWORD                    dwMediaType,
        IN     TERMINAL_DIRECTION       Direction
        );

    HRESULT Configure(
        IN STREAMSETTINGS &StreamSettings
        );

    HRESULT SubStreamSelectTerminal(
        IN  ITSubStream * pITSubStream, 
        IN  ITTerminal * pITTerminal
        );

protected:
    HRESULT CheckTerminalTypeAndDirection(
        IN  ITTerminal *            pTerminal
        );

    HRESULT ShutDown();
    
    HRESULT SetUpFilters();

    HRESULT SetUpInternalFilters();

    HRESULT ConnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT DisconnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT ConfigureRTPFilter(
        IN  IBaseFilter *   pIBaseFilter
        );

    HRESULT InternalCreateSubStream(
        OUT  ITSubStream **         ppITSubStream
        );

    HRESULT ProcessPinMappedEvent(
        IN  IPin *  pIPin
        );

    HRESULT ProcessPinUnmapEvent(
        IN  IPin *  pIPin
        );

    HRESULT ProcessParticipantLeave(
        IN  DWORD   dwSSRC
        );

    HRESULT ProcessNewSender(
        IN  DWORD dwSSRC, 
        IN  ITParticipant *pITParticipant
        );

    HRESULT NewParticipantPostProcess(
        IN  DWORD dwSSRC, 
        IN  ITParticipant *pITParticipant
        );

    HRESULT ProcessGraphEvent(
        IN  long lEventCode,
        IN  long lParam1,
        IN  long lParam2
        );

    HRESULT AddOneBranch(
        BRANCH * pBranch
        );

    HRESULT RemoveOneBranch(
        BRANCH * pBranch
        );

    HRESULT ConnectCodecToTerminal(
        IN  IBaseFilter *  pCodecFilter,
        IN  ITTerminal *   pITTerminal
        );

protected:
    IRTPDemuxFilter *           m_pIRTPDemux;

    CMSPArray <ITSubStream *>   m_SubStreams;

    // This array store information about all the branches off the demux
    CMSPArray <BRANCH>          m_Branches;

    CMSPArray <PINMAPEVENT>     m_PinMappedEvents;   
};

class ATL_NO_VTABLE CStreamVideoSend : public CIPConfMSPStream
{
public:
    CStreamVideoSend();

    HRESULT Configure(
        IN STREAMSETTINGS &StreamSettings
        );

protected:
    HRESULT CheckTerminalTypeAndDirection(
        IN  ITTerminal *            pTerminal
        );

    HRESULT SetUpFilters();

    HRESULT ConnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT CStreamVideoSend::CreateSendFilters(
        IN    IPin          *pCapturePin
        );

    HRESULT CStreamVideoSend::ConnectPreview(
        IN    IPin          *pPreviewInputPin
        );

    HRESULT ConfigureVideoCaptureTerminal(
        IN  ITTerminalControl*  pTerminal,
        IN  WCHAR *             szPinName,
        OUT IPin **             ppIPin
        );

    HRESULT FindPreviewInputPin(
        IN  ITTerminalControl*  pTerminal,
        OUT IPin **             ppIpin
        );

    HRESULT ConfigureRTPFilter(
        IN  IBaseFilter *   pIBaseFilter
        );
protected:

    DWORD   m_dwFrameRate;
};

class ATL_NO_VTABLE CSubStreamVideoRecv : 
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public IDispatchImpl<ITSubStream, &IID_ITSubStream, &LIBID_IPConfMSPLib>,
    public CMSPObjectSafetyImpl
{
public:

BEGIN_COM_MAP(CSubStreamVideoRecv)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITSubStream)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

DECLARE_GET_CONTROLLING_UNKNOWN()

#ifdef DEBUG_REFCOUNT
    
    ULONG InternalAddRef();
    ULONG InternalRelease();

#endif

    CSubStreamVideoRecv(); 

// methods of the CComObject
    virtual void FinalRelease();

// ITSubStream methods, called by the app.
    STDMETHOD (SelectTerminal) (
        IN      ITTerminal *            pTerminal
        );

    STDMETHOD (UnselectTerminal) (
        IN     ITTerminal *             pTerminal
        );

    STDMETHOD (EnumerateTerminals) (
        OUT     IEnumTerminal **        ppEnumTerminal
        );

    STDMETHOD (get_Terminals) (
        OUT     VARIANT *               pTerminals
        );

    STDMETHOD (get_Stream) (
        OUT     ITStream **             ppITStream
        );

    STDMETHOD (StartSubStream) ();

    STDMETHOD (PauseSubStream) ();

    STDMETHOD (StopSubStream) ();

// methods called by the videorecv object.
    virtual HRESULT Init(
        IN  CStreamVideoRecv *  pStream
        );

    BOOL GetCurrentParticipant(
        DWORD *pdwSSRC,
        ITParticipant ** ppParticipant
        );

    VOID SetCurrentParticipant(
        DWORD dwSSRC,
        ITParticipant * pParticipant
        );

    BOOL ClearCurrentTerminal();
    BOOL SetCurrentTerminal(ITTerminal * pTerminal);

protected:
    // Pointer to the free threaded marshaler.
    IUnknown *                  m_pFTM;

    // The list of terminal objects in the substream.
    CMSPArray <ITTerminal *>    m_Terminals;

    // The lock that protects the substream object. The stream object 
    // should never acquire the lock and then call a MSPCall method 
    // that might lock. This is protected by having a const pointer 
    // to the call object.
    CMSPCritSection             m_lock;

    CStreamVideoRecv  *         m_pStream;

    ITParticipant *             m_pCurrentParticipant;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\conftsp\confdbg.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    sdpspdbg.c

Abstract:

    This module contains the debugging support for the multicast conference 
    service provider. 

Author:
    
    Mu Han (muhan)   26-March-1997

--*/


#include "stdafx.h"
#include "confdbg.h"
#include <stdio.h>

#ifdef DBG

#define MAXDEBUGSTRINGLEN 2048
#define MAXPATHLEN 255


VOID
DbgPrt(
    IN int DbgLevel,
    IN PCHAR lpszFormat,
    IN ...
   )
/*++

Routine Description:

    Formats the incoming debug message & calls DbgPrint

Arguments:

    DbgLevel   - level of message verboseness

    DbgMessage - printf-style format string, followed by appropriate
                 list of arguments

Return Value:

--*/
{
    const TCHAR gszTSPKey[] =
                "Software\\Microsoft\\Windows\\CurrentVersion\\IPConfTSP";

    static FILE *log = NULL;
    static int DebugLevel = -1;

    if (DebugLevel == -1)
    {
        HKEY    hTSPKey;
        DWORD   dwDataSize = sizeof (int), dwDataType;
        const TCHAR szTSPDebugLevel[] = "DebugLevel";
        const TCHAR szTSPLogFile[] = "LogFile";

        DebugLevel=0;

        if (RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            gszTSPKey,
            0,
            KEY_READ,
            &hTSPKey
           ) == ERROR_SUCCESS)
        {

            if (RegQueryValueEx(
                hTSPKey,
                szTSPDebugLevel,
                0,
                &dwDataType,
                (LPBYTE) &DebugLevel,
                &dwDataSize
               ) == ERROR_SUCCESS)
            {
 
                char szFileName[MAXPATHLEN + 1];
                dwDataSize = MAXPATHLEN;
                if (RegQueryValueEx(
                    hTSPKey,
                    szTSPLogFile,
                    0,
                    &dwDataType,
                    (LPBYTE) &szFileName,
                    &dwDataSize
                   ) == ERROR_SUCCESS)
                {
                    log = fopen(szFileName, "w");
                }
            }
            RegCloseKey (hTSPKey);
        }
    }
    if (DbgLevel <= DebugLevel)
    {
        char buf[MAXDEBUGSTRINGLEN + 1];
        char *message[5] = 
        {
            "FAIL: ", 
            "WARN: ", 
            "INFO: ", 
            "TRCE: ", 
            "ELSE: "
        };

        va_list ap;

        if (DbgLevel > 5) 
        {
            DbgLevel = 5;
        }

        SYSTEMTIME SystemTime;

        // retrieve local time
        GetLocalTime(&SystemTime);

        wsprintfA(buf, "IPCONF:[%02u:%02u:%02u.%03u,tid=%x:]%s",
           SystemTime.wHour,
           SystemTime.wMinute,
           SystemTime.wSecond,
           SystemTime.wMilliseconds,
           GetCurrentThreadId(),
           message[DbgLevel - 1]
           );

        va_start(ap, lpszFormat);
        _vsnprintf(&buf[strlen(buf)], 
            MAXDEBUGSTRINGLEN - strlen(buf), lpszFormat, ap);
        lstrcatA (buf, "\n");
        OutputDebugStringA (buf);
        if (log != NULL)
        {
            fprintf(log, "%s", buf);
            fflush(log);
        }
        va_end(ap);
    }
}

#endif  //DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\conftsp\confdbg.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    SDPSPDBG.h

Abstract:

    Definitions for multicast service provider debugging support.

Author:
    
    Mu Han (muhan) 1-April-1997

--*/

#ifndef _SDPSPDBG_H
#define _SDPSPDBG_H

#ifdef DBG

#define FAIL 1
#define WARN 2
#define INFO 3
#define TRCE 4
#define ELSE 5


#define DBGOUT(arg) DbgPrt arg

VOID DbgPrt(IN int DbgLevel, IN PCHAR DbgMessage, IN ...);

#else // DBG

#define DBGOUT(arg)

#endif // DBG

#endif // _SDPSPDBG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\conftsp\resource.h ===
#ifndef __RESOURCE_H
#define __RESOURCE_H

#define IDS_IPCONFPROVIDERNAME          1
#define IDS_IPCONFLINENAME              2
#define IDS_IPCONFADDRESSNAME           3

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\conftsp\stdafx.h ===
#ifndef __STDAFX_H_
#define __STDAFX_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <winreg.h>
#include <objbase.h>
#include <tapi.h>
#include <tspi.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__F8FF7774_4BD5_11D1_AFD1_00C04FC31FEE__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\csamsp\common.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    common.h

Abstract:

    commonly used headers.

Author:
    
    Mu Han (muhan) 1-November-1997

--*/
#ifndef __COMMON_H_
#define __COMMON_H_

#include <mmsystem.h>
#include <mmreg.h>
#include <mtype.h>
#include <g711uids.h>
#include <evcode.h>

#include "csamsp.h"
#include "propbag.h"
#include "csaaddr.h"
#include "csastrm.h"
#include "csacall.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\conftsp\conftsp.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

     sdpsp.cpp

Abstract:

    This module contains a multicast conference service provider for TAPI3.0. 
    It is first designed and implemented in c. Later, in order to use the SDP
    parser, which is written in C++, this file is changed to cpp. It still 
    uses only c features except the lines that uses the parser.

Author:
    
    Mu Han (muhan)   26-March-1997

--*/


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include <initguid.h>
#include <confpdu.h>
#include "resource.h"
#include "conftsp.h"
#include "confdbg.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global Variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static WCHAR gszUIDLLName[] = L"IPCONF.TSP";

//
// Some data used in talking with TAPI.
//
HPROVIDER           ghProvider;
DWORD               gdwPermanentProviderID;
DWORD               gdwLineDeviceIDBase;

// The handle of this dll.
extern "C" 
{
    HINSTANCE       g_hInstance;
}

//
// This function is called if the completion of the process will be sent
// as an asynchrous event. Set in TSPI_ProviderInit.
//
ASYNC_COMPLETION    glpfnCompletionProc; 

//
// Notify tapi about events in the provider. Set in TSPI_LineOpen. 
//
LINEEVENT           glpfnLineEventProc;

// This service provider has only one line.
LINE                gLine;

// Calls are stored in an array of structures. The array will grow as needed.
CCallList           gpCallList;
DWORD               gdwNumCallsInUse    = 0;

// The critical section the protects the global variables.
CRITICAL_SECTION    gCritSec;

#if 0 // we dont' need the user name anymore.
// The name of the user.    
CHAR                gszUserName[MAXUSERNAMELEN + 1];
#endif


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Functiion definitions for the call object.                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

DWORD CALL::Init(
    HTAPICALL           htCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    m_htCall        = htCall;
    m_dwState       = LINECALLSTATE_IDLE;
    m_dwStateMode   = 0;
    m_dwMediaMode   = IPCONF_MEDIAMODES;
    m_dwAudioQOSLevel  = LINEQOSSERVICELEVEL_IFAVAILABLE;
    m_dwVideoQOSLevel  = LINEQOSSERVICELEVEL_IFAVAILABLE;
//    m_dwAudioQOSLevel  = LINEQOSSERVICELEVEL_BESTEFFORT;
//    m_dwVideoQOSLevel  = LINEQOSSERVICELEVEL_BESTEFFORT;

    if (!lpCallParams)
    {
        return NOERROR;
    }

    // set my media modes.
    m_dwMediaMode = lpCallParams->dwMediaMode;

    if (lpCallParams->dwReceivingFlowspecOffset == 0)
    {
        // No QOS policy specified.
        DBGOUT((WARN, "no qos level request."));
        return NOERROR;
    }

    // get the QOS policy requirements.
    LPLINECALLQOSINFO pQOSInfo = (LPLINECALLQOSINFO)
        (((LPBYTE)lpCallParams) + lpCallParams->dwReceivingFlowspecOffset);
    
    ASSERT(pQOSInfo->dwKey == LINEQOSSTRUCT_KEY);

    // find out if this is a QOS level request.
    if (pQOSInfo->dwQOSRequestType != LINEQOSREQUESTTYPE_SERVICELEVEL)
    {
        // It is not a request for qos service level.
        DBGOUT((WARN, "wrong qos request type."));
        return NOERROR;
    }

    DWORD dwCount = pQOSInfo->SetQOSServiceLevel.dwNumServiceLevelEntries;
    for (DWORD i = 0; i < dwCount; i ++)
    {
        LINEQOSSERVICELEVEL &QOSLevel = 
            pQOSInfo->SetQOSServiceLevel.LineQOSServiceLevel[i];

        switch (QOSLevel.dwMediaMode)
        {
        case LINEMEDIAMODE_VIDEO:
            m_dwVideoQOSLevel  = QOSLevel.dwQOSServiceLevel;
            break;

        case LINEMEDIAMODE_INTERACTIVEVOICE:
        case LINEMEDIAMODE_AUTOMATEDVOICE:
            m_dwAudioQOSLevel  = QOSLevel.dwQOSServiceLevel;
            break;

        default:
            DBGOUT((WARN, "Unknown mediamode for QOS, %x", dwMediaMode));
            break;
        }
    }

    return NOERROR;
}

void CALL::SetCallState(
    DWORD   dwCallState,
    DWORD   dwCallStateMode
    )
{
    if (m_dwState != dwCallState)
    {
        m_dwState     = dwCallState;
        m_dwStateMode = dwCallStateMode;

        (*glpfnLineEventProc)(
            gLine.htLine,
            m_htCall,
            LINE_CALLSTATE,
            m_dwState,
            m_dwStateMode,
            m_dwMediaMode
            );
        DBGOUT((INFO, "sending event to htCall: %x", m_htCall));
    }
}

DWORD CALL::SendMSPStartMessage(LPCWSTR lpszDestAddress)
{
    DWORD dwStrLen = lstrlenW(lpszDestAddress);
    DWORD dwSize = sizeof(MSG_TSPMSPDATA) + dwStrLen * sizeof(WCHAR);

    MSG_TSPMSPDATA *pData = (MSG_TSPMSPDATA *)MemAlloc(dwSize);

    if (pData == NULL)
    {
        DBGOUT((FAIL, "No memory for the TSPMSP data, size: %d", dwSize));
        return LINEERR_NOMEM;
    }

    pData->command = CALL_START;

    pData->CallStart.dwAudioQOSLevel = m_dwAudioQOSLevel;
    pData->CallStart.dwVideoQOSLevel = m_dwVideoQOSLevel;
    pData->CallStart.dwSDPLen = dwStrLen;
    lstrcpyW(pData->CallStart.szSDP, lpszDestAddress);

    DBGOUT((INFO, "Send MSP call Start message"));
    (*glpfnLineEventProc)(
        gLine.htLine,
        m_htCall,
        LINE_SENDMSPDATA,
        0,
        PtrToUlong(pData),
        dwSize
        );

    MemFree(pData);

    return NOERROR;
}

DWORD CALL::SendMSPStopMessage()
{
    MSG_TSPMSPDATA Data;

    Data.command = CALL_STOP;

    DBGOUT((INFO, "Send MSP call Stop message"));
    (*glpfnLineEventProc)(
        gLine.htLine,
        m_htCall,
        LINE_SENDMSPDATA,
        0,
        PtrToUlong(&Data),
        sizeof(MSG_TSPMSPDATA)
        );

    return NOERROR;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private Functiion definitions                                             //
//                                                                           //
// Note: none of these functions uses critical sections operations inside.   //
//       The caller is responsible for critical sections.                    //
///////////////////////////////////////////////////////////////////////////////

LONG
CheckCallParams(
    LPLINECALLPARAMS    const lpCallParams
    )
{
    // validate pointer
    if (lpCallParams == NULL) 
    {
        return NOERROR;
    }

    // see if the address type is right 
    if (lpCallParams->dwAddressType != LINEADDRESSTYPE_SDP) 
    {
        DBGOUT((FAIL,
            "wrong address type 0x%08lx.\n", lpCallParams->dwAddressType
            ));
        return LINEERR_INVALADDRESSTYPE;
    }

    // see if we support call parameters
    if (lpCallParams->dwCallParamFlags != 0) 
    {
        DBGOUT((FAIL,
            "do not support call parameters 0x%08lx.\n",
            lpCallParams->dwCallParamFlags
            ));
        return LINEERR_INVALCALLPARAMS;
    }

    // see if we support media modes specified
    if (lpCallParams->dwMediaMode & ~IPCONF_MEDIAMODES) 
    {
        DBGOUT((FAIL,
            "do not support media modes 0x%08lx.\n",
             lpCallParams->dwMediaMode
             ));
        return LINEERR_INVALMEDIAMODE;
    }

    // see if we support bearer modes
    if (lpCallParams->dwBearerMode & ~IPCONF_BEARERMODES) 
    {
        DBGOUT((FAIL,
            "do not support bearer mode 0x%08lx.\n",
            lpCallParams->dwBearerMode
            ));
        return LINEERR_INVALBEARERMODE;
    }

    // see if we support address modes
    if (lpCallParams->dwAddressMode & ~IPCONF_ADDRESSMODES) 
    {
        DBGOUT((FAIL,
            "do not support address mode 0x%08lx.\n",
            lpCallParams->dwAddressMode
            ));
        return LINEERR_INVALADDRESSMODE;
    }
    
    // validate address id specified There is only one address per line
    if (lpCallParams->dwAddressID != 0) 
    {
        DBGOUT((FAIL,
            "address id 0x%08lx invalid.\n",
            lpCallParams->dwAddressID
            ));
        return LINEERR_INVALADDRESSID;
    }
    return NOERROR;
}

DWORD
FreeCall(DWORD hdCall)
/*++

Routine Description:

    Decrement the ref count on the call and release the call if the ref
    count gets 0.

Arguments:
    
    hdCall  - The handle of the call.

Return Value:
    
    NOERROR
--*/
{
    if (gpCallList[hdCall] == NULL)
    {
        return NOERROR;
    }

    DWORD dwLine = (DWORD)gpCallList[hdCall]->hdLine();

    MemFree(gpCallList[hdCall]);
    gpCallList[hdCall] = NULL;

    gdwNumCallsInUse --;
    gLine.dwNumCalls --;

    DBGOUT((INFO, "No.%d call was deleted.", hdCall));
    return NOERROR;
}

long FindFreeCallSlot(DWORD &hdCall)
{
    if (gdwNumCallsInUse < gpCallList.size())
    {
        for (DWORD i = 0; i < gpCallList.size(); i++)
        {
            if (gpCallList[i] == NULL)
            {
                hdCall = i;
                return TRUE;;
            }
        }
    }

    if (!gpCallList.add())
    {
        return FALSE;
    }

    hdCall = gpCallList.size() - 1;

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// DllMain definition                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
BOOL
WINAPI
DllMain(
    HINSTANCE   hDLL,
    DWORD       dwReason,
    LPVOID      lpReserved
   )
{
    DWORD i;
    DWORD dwUserNameLen = MAXUSERNAMELEN;

    HRESULT hr;

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            DBGOUT((TRCE, "DLL_PROCESS_ATTACH"));

            DisableThreadLibraryCalls(hDLL);
            g_hInstance = hDLL;

#if 0 // we dont' need the user name anymore.
            // switch in user's context
            RpcImpersonateClient(0);

            // determine name of current user
            GetUserNameA(gszUserName, &dwUserNameLen);

            // switch back
            RpcRevertToSelf();    

#endif 
            // Initialize critical sections.
            __try 
            {
                InitializeCriticalSection(&gCritSec);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) 
            {
                return FALSE;
            }
        break;

        case DLL_PROCESS_DETACH:
            DBGOUT((TRCE, "DLL_PROCESS_DETACH"));

            DeleteCriticalSection(&gCritSec);

        break;
   
    } // switch

    return TRUE;
}


//
// We get a slough of C4047 (different levels of indrection) warnings down
// below in the initialization of FUNC_PARAM structs as a result of the
// real func prototypes having params that are types other than DWORDs,
// so since these are known non-interesting warnings just turn them off
//

#pragma warning (disable:4047)


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// TSPI_lineXxx functions                                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


LONG
TSPIAPI
TSPI_lineClose(
    HDRVLINE    hdLine
   )
{
    DBGOUT((TRCE, "TSPI_lineClose, hdLine %p", hdLine));

    DWORD dwLine = HandleToUlong(hdLine);

    if (dwLine != IPCONF_LINE_HANDLE)
    {
        DBGOUT((FAIL, "invalide line handle, hdLine %p", hdLine));
        return LINEERR_INVALLINEHANDLE;
    }

    EnterCriticalSection(&gCritSec);

    // Clean up all the open calls when this line is closed.
    for (DWORD i = 0; i < gpCallList.size(); i++)
    {
        if ((gpCallList[i] != NULL))
        {
            FreeCall(i);
        }
    }

    gLine.bOpened = FALSE;

    LeaveCriticalSection(&gCritSec);

    DBGOUT((TRCE, "TSPI_lineClose succeeded."));
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineCloseCall(
    HDRVCALL    hdCall
   )
{
    DBGOUT((TRCE, "TSPI_lineCloseCall, hdCall %p", hdCall));

    DWORD dwCall = HandleToUlong(hdCall);

    EnterCriticalSection(&gCritSec);

    if (dwCall >= gpCallList.size())
    {
        LeaveCriticalSection(&gCritSec);
        DBGOUT((FAIL, "TSPI_lineCloseCall invalid call handle: %p", hdCall));
        return LINEERR_INVALCALLHANDLE;
    }

    FreeCall(dwCall);

    LeaveCriticalSection(&gCritSec);

    DBGOUT((TRCE, "TSPI_lineCloseCall succeeded"));
    return NOERROR;
}

LONG
TSPIAPI
TSPI_lineCreateMSPInstance(
    HDRVLINE        hdLine,
    DWORD           dwAddressID,
    HTAPIMSPLINE    htMSPLine,
    LPHDRVMSPLINE   phdMSPLine
    )
{
    DBGOUT((TRCE, "TSPI_lineCreateMSPInstance"));

    if (IsBadWritePtr(phdMSPLine, sizeof (HDRVMSPLINE)))
    {
        DBGOUT((FAIL, "TSPI_lineCreateMSPInstance bad pointer"));
        return LINEERR_INVALPOINTER;
    }

    if (HandleToUlong(hdLine) != IPCONF_LINE_HANDLE)
    {
        DBGOUT((FAIL, "TSPI_lineCreateMSPInstance, bad line handle:%p", hdLine));
        return LINEERR_INVALLINEHANDLE;
    }

    EnterCriticalSection(&gCritSec);

    // We are not keeping the msp handles. Just fake a handle here.
    *phdMSPLine = (HDRVMSPLINE)(gLine.dwNextMSPHandle ++);

    LeaveCriticalSection(&gCritSec);

    DBGOUT((TRCE, "TSPI_lineCloseCall succeeded"));
    return (NOERROR);
}

LONG
TSPIAPI
TSPI_lineCloseMSPInstance(
    HDRVMSPLINE         hdMSPLine
    )
{
    DBGOUT((TRCE, "TSPI_lineCloseMSPInstance, hdMSPLine %p", hdMSPLine));
    DBGOUT((TRCE, "TSPI_lineCloseCall succeeded"));
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineDrop(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    LPCSTR          lpsUserUserInfo,
    DWORD           dwSize
   )
{
    DBGOUT((TRCE, "TSPI_lineDrop, hdCall %p", hdCall));

    DWORD dwCall = HandleToUlong(hdCall);

    EnterCriticalSection(&gCritSec);

    // check the call handle.
    if (dwCall >= gpCallList.size())
    {
        LeaveCriticalSection(&gCritSec);
        (*glpfnCompletionProc)(dwRequestID, LINEERR_INVALCALLHANDLE);

        DBGOUT((FAIL, "TSPI_lineDrop invalid call handle %p", hdCall));
        return dwRequestID;
    }

    CALL *pCall = gpCallList[dwCall];
    if (pCall != NULL)
    {
        pCall->SetCallState(LINECALLSTATE_IDLE, 0);
        pCall->SendMSPStopMessage();
    
        DBGOUT((INFO, "call %d state changed to idle", dwCall));
    }

    LeaveCriticalSection(&gCritSec);

    (*glpfnCompletionProc)(dwRequestID, 0);

    DBGOUT((TRCE, "TSPI_lineDrop succeeded"));
    return dwRequestID;
}

LONG
TSPIAPI
TSPI_lineGetAddressCaps(
    DWORD              dwDeviceID,
    DWORD              dwAddressID,
    DWORD              dwTSPIVersion,
    DWORD              dwExtVersion,
    LPLINEADDRESSCAPS  lpAddressCaps
   )
{
    DBGOUT((TRCE, "TSPI_lineGetAddressCaps"));

    if (dwDeviceID != gdwLineDeviceIDBase)
    {
        DBGOUT((TRCE, "TSPI_lineGetAddressCaps bad device id: %d", dwDeviceID));
        return LINEERR_BADDEVICEID;
    }

    // Check the address ID.
    if (dwAddressID != 0)
    {
        DBGOUT((TRCE, "TSPI_lineGetAddressCaps bad address id: %d", dwAddressID));
        return LINEERR_INVALADDRESSID;
    }

    // load the address name from the string table.
    WCHAR szAddressName[IPCONF_BUFSIZE + 1];
    if (0 == LoadStringW(g_hInstance, IDS_IPCONFADDRESSNAME, szAddressName, IPCONF_BUFSIZE))
    {
        szAddressName[0] = L'\0';
    }

    DWORD dwAddressSize = (lstrlenW(szAddressName) + 1) * (sizeof WCHAR);

    lpAddressCaps->dwNeededSize = sizeof(LINEADDRESSCAPS) + dwAddressSize;

    if (lpAddressCaps->dwTotalSize >= lpAddressCaps->dwNeededSize)
    {
        // Copy the IP address to the end of the structure.
        lpAddressCaps->dwUsedSize = lpAddressCaps->dwNeededSize;

        lpAddressCaps->dwAddressSize   = dwAddressSize;
        lpAddressCaps->dwAddressOffset = sizeof(LINEADDRESSCAPS);
        lstrcpyW ((WCHAR *)(lpAddressCaps + 1), szAddressName);
    }
    else
    {
        lpAddressCaps->dwUsedSize   = sizeof(LINEADDRESSCAPS);
    }
    lpAddressCaps->dwLineDeviceID       = dwDeviceID;
    lpAddressCaps->dwAddressSharing     = LINEADDRESSSHARING_PRIVATE;
    lpAddressCaps->dwCallInfoStates     = LINECALLINFOSTATE_MEDIAMODE;
    lpAddressCaps->dwCallerIDFlags      =
    lpAddressCaps->dwCalledIDFlags      =
    lpAddressCaps->dwConnectedIDFlags   =
    lpAddressCaps->dwRedirectionIDFlags =
    lpAddressCaps->dwRedirectingIDFlags = LINECALLPARTYID_UNAVAIL;
    lpAddressCaps->dwCallStates         = LINECALLSTATE_IDLE |
                                          LINECALLSTATE_DIALING |
                                          LINECALLSTATE_CONNECTED;
    lpAddressCaps->dwDialToneModes      = 0; 
    lpAddressCaps->dwBusyModes          = 0;
    lpAddressCaps->dwSpecialInfo        = 0;
    lpAddressCaps->dwDisconnectModes    = LINEDISCONNECTMODE_NORMAL |
                                          LINEDISCONNECTMODE_UNAVAIL;
    lpAddressCaps->dwMaxNumActiveCalls  = MAXCALLSPERADDRESS;
    lpAddressCaps->dwAddrCapFlags       = LINEADDRCAPFLAGS_DIALED |
                                          LINEADDRCAPFLAGS_ORIGOFFHOOK;

    lpAddressCaps->dwCallFeatures       = LINECALLFEATURE_DROP | 
                                          LINECALLFEATURE_SETQOS;

    lpAddressCaps->dwAddressFeatures    = LINEADDRFEATURE_MAKECALL;

    DBGOUT((TRCE, "TSPI_lineGetAddressCaps succeeded."));
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineGetAddressID(
    HDRVLINE    hdLine,
    LPDWORD     lpdwAddressID,
    DWORD       dwAddressMode,
    LPCWSTR     lpsAddress,
    DWORD       dwSize
   )
{
    DBGOUT((TRCE, "TSPI_lineGetAddressID htLine:%p", hdLine));
    *lpdwAddressID = 0;
    DBGOUT((TRCE, "TSPI_lineGetAddressID succeeded."));
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineGetAddressStatus(
    HDRVLINE            hdLine,
    DWORD               dwAddressID,
    LPLINEADDRESSSTATUS lpAddressStatus
   )
{
    DBGOUT((TRCE, "TSPI_lineGetAddressStatus htLine:%p", hdLine));

    if (HandleToUlong(hdLine) != IPCONF_LINE_HANDLE)
    {
        DBGOUT((FAIL, "TSPI_lineGetAddressStatus htLine:%p", hdLine));
        return LINEERR_INVALLINEHANDLE;
    }

    lpAddressStatus->dwNeededSize =
    lpAddressStatus->dwUsedSize   = sizeof(LINEADDRESSSTATUS);

    EnterCriticalSection(&gCritSec);

    lpAddressStatus->dwNumActiveCalls = gLine.dwNumCalls;

    LeaveCriticalSection(&gCritSec);

    lpAddressStatus->dwAddressFeatures = LINEADDRFEATURE_MAKECALL;

    DBGOUT((TRCE, "TSPI_lineGetAddressStatus succeeded."));
    return NOERROR;
}



LONG
TSPIAPI
TSPI_lineGetCallAddressID(
    HDRVCALL    hdCall,
    LPDWORD     lpdwAddressID
   )
{
    DBGOUT((TRCE, "TSPI_lineGetCallAddressID hdCall %p", hdCall));
    //
    // We only support 1 address (id=0) per line
    //
    *lpdwAddressID = 0;

    DBGOUT((TRCE, "TSPI_lineGetCallAddressID succeeded."));
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineGetCallInfo(
    HDRVCALL        hdCall,
    LPLINECALLINFO  lpLineInfo
   )
{
    DBGOUT((TRCE, "TSPI_lineGetCallInfo hdCall %p", hdCall));

    DWORD dwCall = HandleToUlong(hdCall);

    EnterCriticalSection(&gCritSec);

    if (dwCall >= gpCallList.size())
    {
        LeaveCriticalSection(&gCritSec);
    
        DBGOUT((FAIL, "TSPI_lineGetCallInfo bad call handle %p", hdCall));
        return LINEERR_INVALCALLHANDLE;
    }

    // get the call object.
    CALL *pCall = gpCallList[dwCall];
    if (pCall == NULL)
    {
        LeaveCriticalSection(&gCritSec);
        DBGOUT((FAIL, "TSPI_lineGetCallInfo bad call handle %p", hdCall));
        return LINEERR_INVALCALLHANDLE;
    }

    lpLineInfo->dwMediaMode          = pCall->dwMediaMode();
    LeaveCriticalSection(&gCritSec);

    lpLineInfo->dwLineDeviceID       = gLine.dwDeviceID;
    lpLineInfo->dwAddressID          = 0; // There is only on address per line.

    lpLineInfo->dwBearerMode         = IPCONF_BEARERMODES;
    lpLineInfo->dwCallStates         = LINECALLSTATE_IDLE |
                                       LINECALLSTATE_DIALING |
                                       LINECALLSTATE_CONNECTED;
    lpLineInfo->dwOrigin             = LINECALLORIGIN_OUTBOUND;
    lpLineInfo->dwReason             = LINECALLREASON_DIRECT;

    lpLineInfo->dwCallerIDFlags      =
    lpLineInfo->dwCalledIDFlags      =
    lpLineInfo->dwConnectedIDFlags   =
    lpLineInfo->dwRedirectionIDFlags =
    lpLineInfo->dwRedirectingIDFlags = LINECALLPARTYID_UNAVAIL;

    DBGOUT((TRCE, "TSPI_lineGetCallInfo succeeded."));
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineGetCallStatus(
    HDRVCALL            hdCall,
    LPLINECALLSTATUS    lpLineStatus
   )
{
    DBGOUT((TRCE, "TSPI_lineGetCallStatus hdCall %p", hdCall));

    DWORD dwCall = HandleToUlong(hdCall);

    EnterCriticalSection(&gCritSec);
    
    // check the call handle.
    if (dwCall >= gpCallList.size())
    {
        LeaveCriticalSection(&gCritSec);
        DBGOUT((TRCE, "TSPI_lineGetCallStatus bad call handle %p", hdCall));
        return LINEERR_INVALCALLHANDLE;
    }

    lpLineStatus->dwNeededSize =
    lpLineStatus->dwUsedSize   = sizeof(LINECALLSTATUS);

    lpLineStatus->dwCallState  = gpCallList[dwCall]->dwState();
    if (lpLineStatus->dwCallState != LINECALLSTATE_IDLE)
    {
        lpLineStatus->dwCallFeatures = LINECALLFEATURE_DROP | 
                                       LINECALLFEATURE_SETQOS;
    }
    LeaveCriticalSection(&gCritSec);

    DBGOUT((TRCE, "TSPI_lineGetCallStatus succeeded."));
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineGetDevCaps(
    DWORD           dwDeviceID,
    DWORD           dwTSPIVersion,
    DWORD           dwExtVersion,
    LPLINEDEVCAPS   lpLineDevCaps
   )
{
    DBGOUT((TRCE, "TSPI_lineGetDevCaps"));
    
    if (dwDeviceID != gdwLineDeviceIDBase)
    {
        DBGOUT((FAIL, "TSPI_lineGetDevCaps bad device id %d", dwDeviceID));
        return LINEERR_BADDEVICEID;
    }

    DWORD dwProviderInfoSize;
    DWORD dwLineNameSize;
    DWORD dwDevSpecificSize;
    DWORD dwOffset;
  
    // load the name of the service provider from the string table.
    WCHAR szProviderInfo[IPCONF_BUFSIZE + 1];
    if (0 == LoadStringW(g_hInstance, IDS_IPCONFPROVIDERNAME, szProviderInfo, IPCONF_BUFSIZE))
    {
        szProviderInfo[0] = L'\0';
    }

    dwProviderInfoSize = (lstrlenW(szProviderInfo) + 1) * sizeof(WCHAR);

    // load the line name format from the string table and print the line name.
    WCHAR szLineName[IPCONF_BUFSIZE + 1];
    if (0 == LoadStringW(g_hInstance, IDS_IPCONFLINENAME, szLineName, IPCONF_BUFSIZE))
    {
        szLineName[0] = L'\0';
    }

    dwLineNameSize = (lstrlenW(szLineName) + 1) * (sizeof WCHAR);

    lpLineDevCaps->dwNeededSize = sizeof (LINEDEVCAPS) 
        + dwProviderInfoSize 
        + dwLineNameSize;

    if (lpLineDevCaps->dwTotalSize >= lpLineDevCaps->dwNeededSize)
    {
        lpLineDevCaps->dwUsedSize = lpLineDevCaps->dwNeededSize;

        CHAR *pChar;
        
        pChar = (CHAR *)(lpLineDevCaps + 1);
        dwOffset = sizeof(LINEDEVCAPS);
        
        // fill in the provider info.
        lpLineDevCaps->dwProviderInfoSize   = dwProviderInfoSize;
        lpLineDevCaps->dwProviderInfoOffset = dwOffset;
        lstrcpyW ((WCHAR *)pChar, szProviderInfo);

        pChar += dwProviderInfoSize;
        dwOffset += dwProviderInfoSize;

        // fill in the name of the line.
        lpLineDevCaps->dwLineNameSize   = dwLineNameSize;
        lpLineDevCaps->dwLineNameOffset = dwOffset; 
        lstrcpyW ((WCHAR *)pChar, szLineName);
    }
    else
    {
        lpLineDevCaps->dwUsedSize = sizeof(LINEDEVCAPS);
    }

    // We don't have really "Permanent" line ids. So just fake one here.
    lpLineDevCaps->dwPermanentLineID = 
        ((gdwPermanentProviderID & 0xffff) << 16) | 
        ((dwDeviceID - gdwLineDeviceIDBase) & 0xffff);
    
    CopyMemory(
               &(lpLineDevCaps->PermanentLineGuid),
               &GUID_LINE,
               sizeof(GUID)
              );

    lpLineDevCaps->PermanentLineGuid.Data1 += dwDeviceID - gdwLineDeviceIDBase;

    lpLineDevCaps->dwStringFormat      = STRINGFORMAT_UNICODE;
    lpLineDevCaps->dwAddressModes      = IPCONF_ADDRESSMODES;
    lpLineDevCaps->dwNumAddresses      = IPCONF_NUMADDRESSESPERLINE;
    lpLineDevCaps->dwBearerModes       = IPCONF_BEARERMODES;
    lpLineDevCaps->dwMediaModes        = IPCONF_MEDIAMODES;
    lpLineDevCaps->dwMaxRate           = (1 << 20);
    lpLineDevCaps->dwAddressTypes      = LINEADDRESSTYPE_SDP;
    lpLineDevCaps->dwDevCapFlags       = 
        LINEDEVCAPFLAGS_CLOSEDROP
        | LINEDEVCAPFLAGS_MSP;

    lpLineDevCaps->dwMaxNumActiveCalls = 
        MAXCALLSPERADDRESS * IPCONF_NUMADDRESSESPERLINE;  
    lpLineDevCaps->dwRingModes         = 0;
    lpLineDevCaps->dwLineFeatures      = LINEFEATURE_MAKECALL;

    CopyMemory(
               &(lpLineDevCaps->ProtocolGuid),
               &TAPIPROTOCOL_Multicast,
               sizeof(GUID)
              );
    
    DBGOUT((TRCE, "TSPI_lineGetDevCaps succeeded."));
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineGetIcon(
    DWORD   dwDeviceID,
    LPCWSTR lpgszDeviceClass,
    LPHICON lphIcon
   )
{
    DBGOUT((TRCE, "TSPI_lineGetIcon:"));
    return LINEERR_OPERATIONUNAVAIL;
}


LONG
TSPIAPI
TSPI_lineGetID(
    HDRVLINE    hdLine,
    DWORD       dwAddressID,
    HDRVCALL    hdCall,
    DWORD       dwSelect,
    LPVARSTRING lpDeviceID,
    LPCWSTR     lpgszDeviceClass,
    HANDLE      hTargetProcess
   )
{
    DBGOUT((TRCE, "TSPI_lineGetID:"));
    return LINEERR_OPERATIONUNAVAIL;
}


LONG
TSPIAPI
TSPI_lineGetLineDevStatus(
    HDRVLINE        hdLine,
    LPLINEDEVSTATUS lpLineDevStatus
   )
{
    DBGOUT((TRCE, "TSPI_lineGetLineDevStatus %p", hdLine));

    if (HandleToUlong(hdLine) != IPCONF_LINE_HANDLE)
    {
        DBGOUT((FAIL, "TSPI_lineGetLineDevStatus bad line handle %p", hdLine));
        return LINEERR_INVALLINEHANDLE;
    }

    lpLineDevStatus->dwUsedSize         =
    lpLineDevStatus->dwNeededSize       = sizeof (LINEDEVSTATUS);

    EnterCriticalSection(&gCritSec);
    lpLineDevStatus->dwNumActiveCalls   = gLine.dwNumCalls;
    LeaveCriticalSection(&gCritSec);

    lpLineDevStatus->dwLineFeatures     = LINEFEATURE_MAKECALL;
    lpLineDevStatus->dwDevStatusFlags   = LINEDEVSTATUSFLAGS_CONNECTED |
                                          LINEDEVSTATUSFLAGS_INSERVICE;

    DBGOUT((TRCE, "TSPI_lineGetLineDevStatus succeeded"));
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineGetNumAddressIDs(
    HDRVLINE    hdLine,
    LPDWORD     lpdwNumAddressIDs
   )
{
    DBGOUT((TRCE, "TSPI_lineGetNumAddressIDs"));

    *lpdwNumAddressIDs = IPCONF_NUMADDRESSESPERLINE;

    DBGOUT((TRCE, "TSPI_lineGetNumAddressIDs succeeded."));
    return NOERROR;
}

LONG
TSPIAPI
TSPI_lineMakeCall(
    DRV_REQUESTID       dwRequestID,
    HDRVLINE            hdLine,
    HTAPICALL           htCall,
    LPHDRVCALL          lphdCall,
    LPCWSTR             lpszDestAddress,
    DWORD               dwCountryCode,
    LPLINECALLPARAMS    const lpCallParams
   )
{
    DBGOUT((TRCE, "TSPI_lineMakeCall hdLine %p, htCall %p",
        hdLine, htCall));

    // check the line handle.
    if (HandleToUlong(hdLine) != IPCONF_LINE_HANDLE)
    {
        DBGOUT((FAIL, "TSPI_lineMakeCall Bad line handle %p", hdLine));
        return LINEERR_INVALLINEHANDLE;
    }

    LONG lResult;
    if ((lResult = CheckCallParams(lpCallParams)) != NOERROR)
    {
        DBGOUT((FAIL, "TSPI_lineMakeCall Bad call params"));
        return lResult;
    }

    // check the destination address.
    if (lpszDestAddress == NULL || lstrlenW(lpszDestAddress) == 0)
    {
        DBGOUT((FAIL, "TSPI_lineMakeCall invalid address."));
        return LINEERR_INVALADDRESS;
    }
    
    DBGOUT((TRCE, "TSPI_lineMakeCall making call to %ws", lpszDestAddress));

    // check the line handle.
    EnterCriticalSection(&gCritSec);

    // create a call object.
    CALL * pCall = (CALL *)MemAlloc(sizeof(CALL));

    if (pCall == NULL)
    {
        LeaveCriticalSection(&gCritSec);

        DBGOUT((FAIL, "out of memory for a new call"));
        return LINEERR_NOMEM;
    }

    if (pCall->Init(
        htCall,
        lpCallParams
        ) != NOERROR)
    {
        MemFree(pCall);
        LeaveCriticalSection(&gCritSec);

        DBGOUT((FAIL, "out of memory in init a new call"));
        return LINEERR_NOMEM;
    }

    // add the call into the call list.
    DWORD hdCall; 
    if (!FindFreeCallSlot(hdCall))
    {
        LeaveCriticalSection(&gCritSec);
        MemFree(pCall);
        
        DBGOUT((FAIL, "out of memory finding a new slot"));
        return LINEERR_NOMEM;
    }

    gpCallList[hdCall] = pCall;

    // Increament the call count for the line and the provider.
    gLine.dwNumCalls ++;

    gdwNumCallsInUse ++;

    // Complete the request and set the initial call state.
    (*glpfnCompletionProc)(dwRequestID, lResult);

    *lphdCall = (HDRVCALL)(hdCall);

    // Send the MSP a message about this call. It has the SDP in it.
    lResult = pCall->SendMSPStartMessage(lpszDestAddress);

    if (lResult == NOERROR)
    {
        // Set the call state to dialing. 
        pCall->SetCallState(
            LINECALLSTATE_DIALING, 
            0
            );
        DBGOUT((INFO, "call %d state changed to dialing", hdCall));
    }
    else
    {
        DBGOUT((FAIL, "send MSP message failed, err:%x", lResult));

        // Set the call state to idel. 
        pCall->SetCallState(
            LINECALLSTATE_DISCONNECTED,
            LINEDISCONNECTMODE_UNREACHABLE
            );
        DBGOUT((INFO, "call %d state changed to disconnected", hdCall));
    }

    LeaveCriticalSection(&gCritSec);

    DBGOUT((TRCE, "TSPI_lineMakeCall succeeded."));
    return dwRequestID;
}

LONG                                    
TSPIAPI
TSPI_lineMSPIdentify(
    DWORD               dwDeviceID,
    GUID *              pCLSID
    )
{
    DBGOUT((TRCE, "TSPI_lineMSPIdentify dwDeviceID %d", dwDeviceID));
    
    *pCLSID = CLSID_CONFMSP;
    
    DBGOUT((TRCE, "TSPI_lineMSPIdentify succeeded."));
    return NOERROR;

}

LONG
TSPIAPI
TSPI_lineNegotiateTSPIVersion(
    DWORD   dwDeviceID,
    DWORD   dwLowVersion,
    DWORD   dwHighVersion,
    LPDWORD lpdwTSPIVersion
   )
{
    DBGOUT((TRCE, "TSPI_lineNegotiateTSPIVersion dwDeviceID %d", dwDeviceID));

    LONG        lResult = 0;

    if (TAPI_CURRENT_VERSION <= dwHighVersion 
        && TAPI_CURRENT_VERSION >= dwLowVersion)
    {
        *lpdwTSPIVersion = TAPI_CURRENT_VERSION;
    }
    else
    {
        DBGOUT((FAIL, "TSPI_lineNegotiateTSPIVersion failed."));

        return LINEERR_INCOMPATIBLEAPIVERSION;
    }

    DBGOUT((TRCE, "TSPI_lineNegotiateTSPIVersion succeeded. version %x", 
        TAPI_CURRENT_VERSION));

    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineOpen(
    DWORD       dwDeviceID,
    HTAPILINE   htLine,
    LPHDRVLINE  lphdLine,
    DWORD       dwTSPIVersion,
    LINEEVENT   lpfnEventProc
   )
{
    DBGOUT((TRCE, "TSPI_lineOpen dwDiviceID %d", dwDeviceID)); 

    LONG        lResult;

    if (dwDeviceID != gdwLineDeviceIDBase)
    {
        DBGOUT((FAIL, "TSPI_lineOpen bad DiviceID %d", dwDeviceID)); 
        return LINEERR_BADDEVICEID;
    }

    EnterCriticalSection(&gCritSec);

    lResult = LINEERR_RESOURCEUNAVAIL;

    if (!gLine.bOpened)
    {
        *lphdLine = (HDRVLINE)IPCONF_LINE_HANDLE;
        gLine.bOpened = TRUE;
        gLine.htLine = htLine;
        gLine.dwNumCalls = 0;
        lResult = 0;
    }
    LeaveCriticalSection(&gCritSec);

    DBGOUT((TRCE, "TSPI_lineOpen returns:%d", lResult)); 

    return lResult;
}

LONG 
TSPIAPI
TSPI_lineReceiveMSPData(
    HDRVLINE        hdLine,
    HDRVCALL        hdCall,         // can be NULL
    HDRVMSPLINE     hdMSPLine, // from lineCreateMSPInstance
    LPBYTE          pBuffer,
    DWORD           dwSize
    )
{
    DBGOUT((TRCE, "TSPI_lineReceiveMSPData hdLine %p", hdLine)); 

    if ((dwSize == 0) || IsBadReadPtr(pBuffer, dwSize))
    {
        DBGOUT((FAIL, "TSPI_lineReceiveMSPData bad puffer"));
        return LINEERR_INVALPOINTER;
    }

    DWORD dwCall = HandleToUlong(hdCall);

    EnterCriticalSection(&gCritSec);

    // check the call handle.
    if (dwCall >= gpCallList.size() || gpCallList[dwCall] == NULL)
    {
        LeaveCriticalSection(&gCritSec);

        DBGOUT((FAIL, "TSPI_lineReceiveMSPData invalide call handle: %x", 
            dwCall));
        
        return LINEERR_INVALCALLHANDLE;
    }

    MSG_TSPMSPDATA *pData = (MSG_TSPMSPDATA *)pBuffer;

    long lResult = NOERROR;

    switch (pData->command)
    {
        case CALL_CONNECTED:
            // Set the call state to connected. 
            gpCallList[dwCall]->SetCallState(
                LINECALLSTATE_CONNECTED,
                LINECONNECTEDMODE_ACTIVE
            );
            DBGOUT((INFO, "call %d state changed to connected", dwCall));
            break;

        case CALL_DISCONNECTED:
            // Set the call state to idel. 
            gpCallList[dwCall]->SetCallState(
                LINECALLSTATE_DISCONNECTED,
                LINEDISCONNECTMODE_UNREACHABLE
                );
            DBGOUT((INFO, "call %d state changed to disconnected", dwCall));
            break;

        case CALL_QOS_EVENT:
            (*glpfnLineEventProc)(
                gLine.htLine,
                gpCallList[dwCall]->htCall(),
                LINE_QOSINFO,
                pData->QosEvent.dwEvent,
                pData->QosEvent.dwMediaMode,
                0
                );
            break;

        default:
            DBGOUT((FAIL, "invalide command: %x", pData->command));
            lResult = LINEERR_OPERATIONFAILED;
    }

    LeaveCriticalSection(&gCritSec);

    DBGOUT((TRCE, "TSPI_lineReceiveMSPData returns:%d", lResult)); 
    return lResult;
}

LONG
TSPIAPI
TSPI_lineSetDefaultMediaDetection(
    HDRVLINE    hdLine,
    DWORD       dwMediaModes
    )
{
    DBGOUT((TRCE, "TSPI_lineSetDefaultMediaDetection:"));
    return LINEERR_OPERATIONUNAVAIL;
}

LONG
TSPIAPI
TSPI_lineSetMediaMode(
    HDRVCALL    hdCall,
    DWORD       dwMediaMode
   )
{
    DBGOUT((TRCE, "TSPI_lineSetMediaMode:"));
    return LINEERR_OPERATIONUNAVAIL;
}




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// TSPI_providerXxx functions                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#if 0 // we dont' need the user name anymore.
LONG
TSPIAPI
TSPI_providerCheckForNewUser(
    IN DWORD dwPermanentProviderID
)
/*++

Routine Description:

    Once a line is opened, it will never be opened twice, even when the user
    logs off and logs on. So we need a way to find out when the user changes.
    That's why this function is added. It only work for single user.

    Everytime a new app starts using tapi, tapisrv will call this function.
    We need to check to see if the user has changed and register the new user
    in the ILS server.

Arguments:

    NONE.

Return Values:

    NOERROR always.

--*/
{
    DBGOUT((TRCE, "TSPI_providerCheckForNewUser"));

    DWORD dwUserNameLen = MAXUSERNAMELEN;
    CHAR szNewUserName[MAXUSERNAMELEN + 1];

    UNREFERENCED_PARAMETER(dwPermanentProviderID ); // It is me.

    // switch in user's context
    RpcImpersonateClient(0);

    // determine name of current user
    GetUserNameA(szNewUserName, &dwUserNameLen);

    // switch back
    RpcRevertToSelf();

    EnterCriticalSection(&gCritSec);

    lstrcpy(gszUserName, szNewUserName);

    LeaveCriticalSection(&gCritSec);

    DBGOUT((TRCE, "TSPI_providerCheckForNewUser succeeded, new user :%ws",
        gszUserName ));

    return NOERROR;
}
#endif


LONG
TSPIAPI
TSPI_providerEnumDevices(
    DWORD       dwPermanentProviderID,
    LPDWORD     lpdwNumLines,
    LPDWORD     lpdwNumPhones,
    HPROVIDER   hProvider,
    LINEEVENT   lpfnLineCreateProc,
    PHONEEVENT  lpfnPhoneCreateProc
   )
{
    DBGOUT((TRCE, "TSPI_providerEnumDevices"));

    EnterCriticalSection(&gCritSec);

    *lpdwNumLines = IPCONF_NUMLINES;
    *lpdwNumPhones = IPCONF_NUMPHONES;

    // save provider handle
    ghProvider = hProvider;

    // save the callback used in creating new lines.
    glpfnLineEventProc = lpfnLineCreateProc;

    LeaveCriticalSection(&gCritSec);

    DBGOUT((TRCE, "TSPI_providerEnumDevices succeeded."));
    return NOERROR;
}

LONG
TSPIAPI
TSPI_providerInit(
    DWORD               dwTSPIVersion,
    DWORD               dwPermanentProviderID,
    DWORD               dwLineDeviceIDBase,
    DWORD               dwPhoneDeviceIDBase,
    DWORD               dwNumLines,
    DWORD               dwNumPhones,
    ASYNC_COMPLETION    lpfnCompletionProc,
    LPDWORD             lpdwTSPIOptions
   )
{
    DBGOUT((TRCE, "TSPI_providerInit"));

    LONG        hr = LINEERR_OPERATIONFAILED;
    
    EnterCriticalSection(&gCritSec);

    glpfnCompletionProc = lpfnCompletionProc;
    gdwLineDeviceIDBase = dwLineDeviceIDBase;
    gdwPermanentProviderID = dwPermanentProviderID;

    gLine.dwDeviceID = gdwLineDeviceIDBase;
    gLine.bOpened = FALSE;

    LeaveCriticalSection(&gCritSec);

    DBGOUT((TRCE, "TSPI_providerInit succeeded."));
    return NOERROR;
}


LONG
TSPIAPI
TSPI_providerInstall(
    HWND    hwndOwner,
    DWORD   dwPermanentProviderID
   )
{
    DBGOUT((TRCE, "TSPI_providerInstall:"));
    //
    // Although this func is never called by TAPI v2.0, we export
    // it so that the Telephony Control Panel Applet knows that it
    // can add this provider via lineAddProvider(), otherwise
    // Telephon.cpl will not consider it installable
    //
    //

    return NOERROR;
}

LONG
TSPIAPI
TSPI_providerRemove(
    HWND    hwndOwner,
    DWORD   dwPermanentProviderID
   )
{
    //
    // Although this func is never called by TAPI v2.0, we export
    // it so that the Telephony Control Panel Applet knows that it
    // can configure this provider via lineConfigProvider(),
    // otherwise Telephon.cpl will not consider it configurable
    //

    return NOERROR;
}

LONG
TSPIAPI
TSPI_providerShutdown(
    DWORD   dwTSPIVersion,
    DWORD   dwPermanentProviderID
   )
{
    DBGOUT((TRCE, "TSPI_providerShutdown."));

    EnterCriticalSection(&gCritSec);

    // Clean up all the open calls when this provider is shutted down.
    for (DWORD i = 0; i < gpCallList.size(); i++)
    {
        FreeCall(i);
    }

    LeaveCriticalSection(&gCritSec);

    DBGOUT((TRCE, "TSPI_providerShutdown succeeded."));
    return NOERROR;
}

LONG
TSPIAPI
TSPI_providerUIIdentify(
    LPWSTR   lpszUIDLLName
   )
{
    lstrcpyW(lpszUIDLLName, gszUIDLLName);
    return NOERROR;
}

LONG
TSPIAPI
TUISPI_providerRemove(
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    )
{
    DBGOUT((TRCE, "TUISPI_providerInstall"));
    return NOERROR;
}

LONG
TSPIAPI
TUISPI_providerInstall(
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    )
{
    DBGOUT((TRCE, "TUISPI_providerInstall"));

    const CHAR szKey[] =
        "Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Providers";
    
    HKEY  hKey;
    DWORD dwDataSize, dwDataType;
    DWORD dwNumProviders;

    CHAR szName[IPCONF_BUFSIZE + 1], szPath[IPCONF_BUFSIZE + 1];

    // open the providers key
    if (RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        szKey,
        0,
        KEY_READ,
        &hKey
       ) == ERROR_SUCCESS)
    {
        // first get the number of providers installed.
        dwDataSize = sizeof(DWORD);
        if (RegQueryValueEx(
            hKey,
            "NumProviders",
            0,
            &dwDataType,
            (LPBYTE) &dwNumProviders,
            &dwDataSize
           ) != ERROR_SUCCESS)
        {
            RegCloseKey (hKey);
            return LINEERR_UNINITIALIZED;
        }

        // then go through the list of providers to see if
        // we are already installed.
        for (DWORD i = 0; i < dwNumProviders; i ++)
        {
            wsprintf(szName, "ProviderFileName%d", i);
            dwDataSize = sizeof(szPath);
            if (RegQueryValueEx(
                hKey,
                szName,
                0,
                &dwDataType,
                (LPBYTE) &szPath,
                &dwDataSize
               ) != ERROR_SUCCESS)
            {
                RegCloseKey (hKey);
                return LINEERR_UNINITIALIZED;
            }

            _strupr(szPath);

            if (strstr(szPath, "IPCONF") != NULL)
            {
                RegCloseKey (hKey);

                // found, we don't want to be installed twice.
                return LINEERR_NOMULTIPLEINSTANCE;
            }
        }
        RegCloseKey (hKey);
        return NOERROR;
    }
    
    return LINEERR_UNINITIALIZED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\csamsp\csaaddr.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    waveaddr.cpp 

Abstract:

    This module contains implementation of CWaveMSP.

Author:
    
    Zoltan Szilagyi (zoltans)   September 7, 1998

--*/

#include "stdafx.h"

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

CWaveMSP::CWaveMSP()
{
    LOG((MSP_TRACE, "CWaveMSP::CWaveMSP entered."));
    LOG((MSP_TRACE, "CWaveMSP::CWaveMSP exited."));
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

CWaveMSP::~CWaveMSP()
{
    LOG((MSP_TRACE, "CWaveMSP::~CWaveMSP entered."));
    LOG((MSP_TRACE, "CWaveMSP::~CWaveMSP exited."));
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

ULONG CWaveMSP::MSPAddressAddRef(void)
{
    return MSPAddRefHelper(this);
}

ULONG CWaveMSP::MSPAddressRelease(void)
{
    return MSPReleaseHelper(this);
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CWaveMSP::CreateMSPCall(
    IN      MSP_HANDLE      htCall,
    IN      DWORD           dwReserved,
    IN      DWORD           dwMediaType,
    IN      IUnknown     *  pOuterUnknown,
    OUT     IUnknown    **  ppMSPCall
    )
{
    LOG((MSP_TRACE, "CWaveMSP::CreateMSPCall - enter"));

    CWaveMSPCall * pCWaveMSPCall;

    HRESULT hr = CreateMSPCallHelper<CWaveMSPCall>(this,
                                                   htCall,
                                                   dwReserved,
                                                   dwMediaType,
                                                   pOuterUnknown,
                                                   ppMSPCall,
                                                   &pCWaveMSPCall);

    //
    // pCWaveMSPCall is not addrefed; no need to release.
    //

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSP::CreateMSPCall - template helper returned"
            "0x%08x", hr));

        return hr;
    }

    LOG((MSP_TRACE, "CWaveMSP::CreateMSPCall - exit S_OK"));

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CWaveMSP::ShutdownMSPCall (
    IN      IUnknown *          pMSPCall
    )
{
    LOG((MSP_TRACE, "CWaveMSP::ShutdownMSPCall - enter"));

    CWaveMSPCall * pCWaveMSPCall;

    HRESULT hr = ShutdownMSPCallHelper<CWaveMSPCall>(pMSPCall,
                                                     &pCWaveMSPCall);

    //
    // pCWaveMSPCall is not addrefed; no need to release.
    //

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSP::ShutdownMSPCall - template helper returned"
            "0x%08x", hr));

        return hr;
    }

    LOG((MSP_TRACE, "CWaveMSP::ShutdownMSPCall - exit S_OK"));

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// Mandatory CMSPAddress override. This indicates the media types that
// we support.
//

DWORD CWaveMSP::GetCallMediaTypes(void)
{
    return (DWORD) TAPIMEDIATYPE_AUDIO;
}


// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\conftsp\conftsp.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    SDPSP.h

Abstract:

    Definitions for multicast service provider.

Author:
    
    Mu Han (muhan) 1-April-1997

--*/

#ifndef __CONFTSP_H
#define __CONFTSP_H

// There is no phone devices in this provider.
#define IPCONF_NUMPHONES           0

// By default we have just one line.
#define IPCONF_NUMLINES            1

// Each network interface has only one address.
#define IPCONF_NUMADDRESSESPERLINE 1

#define IPCONF_LINE_HANDLE 'CONF'

// The number of calls for each address.
#define MAXCALLSPERADDRESS  32768

#define IPCONF_MEDIAMODES (LINEMEDIAMODE_INTERACTIVEVOICE | \
                          LINEMEDIAMODE_AUTOMATEDVOICE | \
                          LINEMEDIAMODE_VIDEO | \
                          LINEMEDIAMODE_UNKNOWN)

#define IPCONF_BEARERMODES (LINEBEARERMODE_DATA | LINEBEARERMODE_VOICE)

#define IPCONF_ADDRESSMODES LINEADDRESSMODE_ADDRESSID

#define IPCONF_BUFSIZE      255

#define MAXUSERNAMELEN      255

#define MemAlloc(size) (LocalAlloc(LPTR, size))
#define MemFree(p) if (p) LocalFree((HLOCAL)p)

// {28B853D5-FC04-11d1-8302-00A0244D2298}
DEFINE_GUID(GUID_LINE, 
0x28b853d5, 0xfc04, 0x11d1, 0x83, 0x2, 0x0, 0xa0, 0x24, 0x4d, 0x22, 0x98);

// {0F1BE7F7-45CA-11d2-831F-00A0244D2298}
DEFINE_GUID(CLSID_CONFMSP,
0x0F1BE7F7,0x45CA, 0x11d2, 0x83, 0x1F, 0x0, 0xA0, 0x24, 0x4D, 0x22, 0x98);


typedef struct _LINE
{
    BOOL        bOpened;    // This line is opened or not.
    HTAPILINE   htLine;     // The handle for this line in TAPI's space.
    DWORD       dwDeviceID;
    DWORD       dwNumCalls; // Number of calls made on this line.
    
    DWORD       dwNextMSPHandle; // This is a hack to keep tapi happy.

} LINE, *PLINE;

typedef struct _Call
{

    DWORD
    Init(
        IN  HTAPICALL           htCall,
        IN  LPLINECALLPARAMS    const lpCallParams
        );

    void
    SetCallState(
        IN  DWORD   dwCallState,
        IN  DWORD   dwCallStateMode
        );

    DWORD SendMSPStartMessage(
        IN  LPCWSTR lpszDestAddress
        );
    
    DWORD SendMSPStopMessage();

    DWORD           hdLine()        { return m_hdLine; }
    DWORD           dwState()       { return m_dwState; }
    DWORD           dwMediaMode()   { return m_dwMediaMode; }
    DWORD           dwStateMode()   { return m_dwStateMode; }
    HTAPICALL       htCall()        { return m_htCall; }

    DWORD           dwAudioQOSLevel()   { return m_dwAudioQOSLevel; }
    DWORD           dwVideoQOSLevel()   { return m_dwVideoQOSLevel; }

private:

    DWORD           m_hdLine;     // The handle for this line in this provider. 
                                  // It is the offset of the Line structure in 
                                  // a global array.
    HTAPICALL       m_htCall;     // The hadle of this call in TAPI's space. 
    DWORD           m_dwState;    // The state of this call.
    DWORD           m_dwMediaMode;
    DWORD           m_dwStateMode;

    DWORD           m_dwAudioQOSLevel;
    DWORD           m_dwVideoQOSLevel;

} CALL, *PCALL;

const DWORD DELTA = 8;

template <class T, DWORD delta = DELTA>
class SimpleVector
{
public:
    SimpleVector() : m_dwSize(0), m_dwCapacity(0), m_Elements(NULL) {};
    ~SimpleVector() {if (m_Elements) free(m_Elements); }
    
    void Init()
    {
        m_dwSize = 0; 
        m_dwCapacity = 0; 
        m_Elements = NULL; 
    }

    BOOL add(T& elem) 
    { 
        return grow() ? (m_Elements[m_dwSize ++] = elem, TRUE) : FALSE;
    }

    BOOL add()
    {
        return grow() ? (m_dwSize ++, TRUE) : FALSE;
    }

    DWORD size() const { return m_dwSize; }
    T& operator [] (DWORD index) { return m_Elements[index]; }
    const T* elements() const { return m_Elements; };
    void shrink() {if (m_dwSize > 0) m_dwSize --;}
    void reset() 
    { 
        m_dwSize = 0; 
        m_dwCapacity = 0; 
        if (m_Elements) free(m_Elements); 
        m_Elements = NULL; 
    }

protected:
    BOOL grow()
    {
        if (m_dwSize >= m_dwCapacity)
        {
            T *p = (T*)realloc(m_Elements, (sizeof T)*(m_dwCapacity+delta));
            if (p == NULL)
            {
                return FALSE;
            }
            m_Elements = p;
            m_dwCapacity += delta;
        }
        return TRUE;
    }

protected:
    DWORD m_dwSize;
    DWORD m_dwCapacity;
    T *   m_Elements;
};

typedef SimpleVector<CALL *> CCallList;

#endif //__CONFTSP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\csamsp\csacall.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    wavecall.h

Abstract:

    Declaration of the CWaveMSPCall

Author:
    
    Zoltan Szilagyi September 7th, 1998

--*/

#ifndef __WAVECALL_H_
#define __WAVECALL_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


/////////////////////////////////////////////////////////////////////////////
// CWaveMSPCall
/////////////////////////////////////////////////////////////////////////////

class CWaveMSPCall : public CMSPCallMultiGraph, public CMSPObjectSafetyImpl

{
public:
// DECLARE_POLY_AGGREGATABLE(CWaveMSP)

// To add extra interfaces to this class, use the following:
BEGIN_COM_MAP(CWaveMSPCall)
     COM_INTERFACE_ENTRY( IObjectSafety )
     COM_INTERFACE_ENTRY_CHAIN(CMSPCallMultiGraph)
END_COM_MAP()

public:
    CWaveMSPCall();
    virtual ~CWaveMSPCall();
    virtual ULONG MSPCallAddRef(void);
    virtual ULONG MSPCallRelease(void);

    virtual HRESULT Init(
        IN      CMSPAddress *       pMSPAddress,
        IN      MSP_HANDLE          htCall,
        IN      DWORD               dwReserved,
        IN      DWORD               dwMediaType
        );

    virtual HRESULT CreateStreamObject(
        IN      DWORD               dwMediaType,
        IN      TERMINAL_DIRECTION  Direction,
        IN      IMediaEvent *       pGraph,
        IN      ITStream **         ppStream
        );

    virtual HRESULT ReceiveTSPCallData(
        IN      PBYTE               pBuffer,
        IN      DWORD               dwSize
        );

    //
    // We override these to make sure the number of
    // streams we have is constant.
    //

    STDMETHOD (CreateStream) (
        IN      long                lMediaType,
        IN      TERMINAL_DIRECTION  Direction,
        IN OUT  ITStream **         ppStream
        );
    
    STDMETHOD (RemoveStream) (
        IN      ITStream *          pStream
        );                      

protected:
    // 
    // Protected data members.
    //

    CWaveMSPStream * m_pRenderStream;
    CWaveMSPStream * m_pCaptureStream;
};

#endif //__WAVEADDR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\csamsp\csaaddr.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    waveaddr.h

Abstract:

    Declaration of the CWaveMSP

Author:
    
    Zoltan Szilagyi September 6th, 1998

--*/

#ifndef __WAVEADDR_H_
#define __WAVEADDR_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CWaveMSP
/////////////////////////////////////////////////////////////////////////////
class CWaveMSP : 
    public CMSPAddress,
    public CComCoClass<CWaveMSP, &CLSID_CSAMSP>,
    public CMSPObjectSafetyImpl
{
public:
    CWaveMSP();
    virtual ~CWaveMSP();

    // BUGUBG document it
    virtual ULONG MSPAddressAddRef(void);
    virtual ULONG MSPAddressRelease(void);

DECLARE_REGISTRY_RESOURCEID(IDR_WaveMSP)
DECLARE_POLY_AGGREGATABLE(CWaveMSP)

// To add extra interfaces to this class, use the following:
BEGIN_COM_MAP(CWaveMSP)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_CHAIN(CMSPAddress)
END_COM_MAP()

public:
    STDMETHOD (CreateMSPCall) (
        IN      MSP_HANDLE     htCall,
        IN      DWORD          dwReserved,
        IN      DWORD          dwMediaType,
        IN      IUnknown    *  pOuterUnknown,
        OUT     IUnknown   **  ppMSPCall
        );

    STDMETHOD (ShutdownMSPCall) (
        IN      IUnknown *          pMSPCall
        );

protected:

    DWORD GetCallMediaTypes(void);
};

#endif //__WAVEADDR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\csamsp\csamsp.cpp ===
// csamsp.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To merge the proxy/stub code into the object DLL, add the file 
//		dlldatax.c to the project.  Make sure precompiled headers 
//		are turned off for this file, and add _MERGE_PROXYSTUB to the 
//		defines for the project.  
//
//		If you are not running WinNT4.0 or Win95 with DCOM, then you
//		need to remove the following define from dlldatax.c
//		#define _WIN32_WINNT 0x0400
//
//		Further, if you are running MIDL without /Oicf switch, you also 
//		need to remove the following define from dlldatax.c.
//		#define USE_STUBLESS_PROXY
//
//		Modify the custom build rule for wavemsp.idl by adding the following 
//		files to the Outputs.
//			wavemsp_p.c
//			dlldata.c
//		To build a separate proxy/stub DLL, 
//		run nmake -f wavemspps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"

#include "csamsp_i.c"

//
// For the ntbuild environment we need to include this file to get the base
//  class implementations.

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>


#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

#ifdef DEBUG_HEAPS
#include <crtdbg.h>
#endif // DEBUG_HEAPS

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CSAMSP, CWaveMSP)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	lpReserved;
#ifdef _MERGE_PROXYSTUB
	if (!PrxDllMain(hInstance, dwReason, lpReserved))
		return FALSE;
#endif
	if (dwReason == DLL_PROCESS_ATTACH)
	{

#ifdef DEBUG_HEAPS
	// ZoltanS: turn on leak detection on process exit
	_CrtSetDbgFlag( _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG) | _CRTDBG_LEAK_CHECK_DF );

	// ZoltanS: force a memory leak
	char * leak = new char [ 1977 ];
    	sprintf(leak, "csamsp.dll NORMAL leak");
    	leak = NULL;
#endif // DEBUG_HEAPS

        _Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);

        // Register for trace output.
        MSPLOGREGISTER(_T("CSA MSP"));
	}
	else if (dwReason == DLL_PROCESS_DETACH)
    {
        // Deregister for trace output.
        MSPLOGDEREGISTER();

        _Module.Term();
    }
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
	if (PrxDllCanUnloadNow() != S_OK)
		return S_FALSE;
#endif
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
	if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
		return S_OK;
#endif
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
	HRESULT hRes = PrxDllRegisterServer();
	if (FAILED(hRes))
		return hRes;
#endif
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
	PrxDllUnregisterServer();
#endif
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\csamsp\csacall.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    wavecall.cpp 

Abstract:

    This module contains implementation of CWaveMSPCall.

Author:
    
    Zoltan Szilagyi (zoltans)   September 7, 1998

--*/

#include "stdafx.h"

#include <commctrl.h>   // ONLY to compile unimdmp.h
#include <setupapi.h>   // ONLY to compile unimdmp.h
#include <unimdmp.h>


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

CWaveMSPCall::CWaveMSPCall() : CMSPCallMultiGraph()
{
    LOG((MSP_TRACE, "CWaveMSPCall::CWaveMSPCall entered."));
    LOG((MSP_TRACE, "CWaveMSPCall::CWaveMSPCall exited."));
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

CWaveMSPCall::~CWaveMSPCall()
{
    LOG((MSP_TRACE, "CWaveMSPCall::~CWaveMSPCall entered."));
    LOG((MSP_TRACE, "CWaveMSPCall::~CWaveMSPCall exited."));
}

ULONG CWaveMSPCall::MSPCallAddRef(void)
{
    return MSPAddRefHelper(this);
}

ULONG CWaveMSPCall::MSPCallRelease(void)
{
    return MSPReleaseHelper(this);
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

HRESULT CWaveMSPCall::Init(
    IN      CMSPAddress *       pMSPAddress,
    IN      MSP_HANDLE          htCall,
    IN      DWORD               dwReserved,
    IN      DWORD               dwMediaType
    )
{
    // No need to acquire locks on this call because it is called only
    // once when the object is created. No other calls can be made on
    // this object at this point.

    LOG((MSP_TRACE, "CWaveMSPCall::Init - enter"));
    
    //
    // First do the base class method. We are adding to the functionality,
    // not replacing it.
    //

    HRESULT hr;

    hr = CMSPCallMultiGraph::Init(pMSPAddress,
                                   htCall,
                                   dwReserved,
                                   dwMediaType);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CWaveMSPCall::Init - "
            "base class method failed: %x", hr));

        return hr;
    }

    //
    // Our calls always come with two streams. Create them now. Use the base class
    // methods, as our overriden methods (exposed to the user) purposely fail in order
    // to keep the user from creating or removing streams themselves.
    // These methods return a pointer to the ITStream. They get saved in our list of
    // ITStreams, and we also save them here as CWaveMSPStream pointers.
    //

    ITStream * pStream;

    //
    // Create the capture stream.
    //

    hr = InternalCreateStream (dwMediaType,
                               TD_CAPTURE,
                               &pStream);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CWaveMSPCall::Init - "
            "couldn't create capture stream: %x", hr));

        return hr;
    }

    m_pCaptureStream = dynamic_cast<CWaveMSPStream *> (pStream);

    if ( m_pCaptureStream == NULL )
    {
        LOG((MSP_ERROR, "CWaveMSPCall::Init - "
            "couldn't dynamic_cast capture stream - exit E_FAIL"));

        return E_FAIL;
    }

    pStream->Release();
 
    //
    // Create the render stream.
    //

    hr = InternalCreateStream (dwMediaType,
                               TD_RENDER,
                               &pStream);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CWaveMSPCall::Init - "
            "couldn't create capture stream: %x", hr));

        return hr;
    }

    m_pRenderStream = dynamic_cast<CWaveMSPStream *> (pStream);

    if ( m_pRenderStream == NULL )
    {
        LOG((MSP_ERROR, "CWaveMSPCall::Init - "
            "couldn't dynamic_cast render stream - exit E_FAIL"));

        return E_FAIL;
    }

    pStream->Release();

    LOG((MSP_TRACE, "CWaveMSPCall::Init - exit S_OK"));

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// We override this to make sure the number of
// streams we have is constant.
//

STDMETHODIMP CWaveMSPCall::CreateStream (
    IN      long                lMediaType,
    IN      TERMINAL_DIRECTION  Direction,
    IN OUT  ITStream **         ppStream
    )
{
    LOG((MSP_TRACE, "CWaveMSPCall::CreateStream entered."));
    LOG((MSP_TRACE, "CWaveMSPCall::CreateStream - "
        "we have a fixed set of streams - exit TAPI_E_MAXSTREAMS"));

    return TAPI_E_MAXSTREAMS;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// We override this to make sure the number of
// streams we have is constant.
//

STDMETHODIMP CWaveMSPCall::RemoveStream (
    IN      ITStream *          pStream
    )
{
    LOG((MSP_TRACE, "CWaveMSPCall::RemoveStream entered."));
    LOG((MSP_TRACE, "CWaveMSPCall::RemoveStream - "
        "we have a fixed set of streams - exit TAPI_E_NOTSUPPORTED"));

    return TAPI_E_NOTSUPPORTED;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// This is our override to create the right kind of stream on stream creation.
// The base class checks the arguments for us.
//

HRESULT CWaveMSPCall::CreateStreamObject(
        IN      DWORD               dwMediaType,
        IN      TERMINAL_DIRECTION  Direction,
        IN      IMediaEvent *       pGraph,
        IN      ITStream **         ppStream
        )
{
    LOG((MSP_TRACE, "CWaveMSPCall::CreateStreamObject - enter"));

    HRESULT hr;
    CMSPComObject<CWaveMSPStream> * pStream;
 
    hr = CMSPComObject<CWaveMSPStream>::CreateInstance( &pStream );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSPCall::CreateStreamObject - "
            "can't create stream object - 0x%08x", hr));

        return hr;
    }

    hr = pStream->_InternalQueryInterface( IID_ITStream,
                                           (void **) ppStream );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSPCall::CreateStreamObject - "
            "can't get ITStream interface - 0x%08x", hr));

        delete pStream;
        return hr;
    }

    hr = pStream->Init( (MSP_HANDLE) m_pMSPAddress,
                       this,
                       pGraph,
                       dwMediaType,
                       Direction);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSPCall::CreateStreamObject - "
            "can't Init stream object - 0x%08x", hr));

        (*ppStream)->Release();
        return hr;
    }

    LOG((MSP_TRACE, "CWaveMSPCall::CreateStreamObject - exit S_OK"));
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// First DWORD =	Command		Second DWORD	Third DWORD
// 0		Set wave IDs		WaveIn ID		WaveOut ID
// 1		Start streaming	<ignored>		<ignored>
// 2		Stop streaming	<ignored>		<ignored>
//
// The method returns S_OK even if an individual stream failed to
// start, stop, or initialize. This is because TAPI 3.0 doesn't need to
// know about streaming failures in this code path. Instead, we should
// generate events to note failures.
//

HRESULT CWaveMSPCall::ReceiveTSPCallData(
    IN      PBYTE               pBuffer,
    IN      DWORD               dwSize
    )
{
    CSATSPMSPBLOB   *Blob=(CSATSPMSPBLOB*)pBuffer;

    LOG((MSP_TRACE, "CWaveMSPCall::ReceiveTSPCallData - enter"));

    //
    // Check that the buffer is as big as advertised.
    //

    if ( IsBadReadPtr(pBuffer, sizeof(BYTE) * dwSize) )
    {
        LOG((MSP_ERROR, "CWaveMSPCall::ReceiveTSPCallData - "
            "bad buffer - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // Check if we have a command DWORD.
    //

    if ( dwSize < sizeof(CSATSPMSPBLOB) ) {

        LOG((MSP_ERROR, "CWaveMSPCall::ReceiveTSPCallData - "
            "need a DWORD for command - exit E_INVALIDARG"));

        return E_INVALIDARG;
    }

    //
    // We are going to access the streams lists -- grab the lock
    //

    CLock lock(m_lock);

    _ASSERTE( m_Streams.GetSize() == 2 );

    int i;
    HRESULT hr;

    //
    // Based on the command, take action:
    //

    switch ( Blob->dwCmd )
    {
    case CSATSPMSPCMD_CONNECTED:
        {

            LOG((MSP_INFO, "CWaveMSPCall::ReceiveTSPCallData - "
                "setting WaveInID=%d, WaveOutID=%d",
                ((DWORD *) pBuffer) [1],
                ((DWORD *) pBuffer) [2]));

            //
            // Use our saved class pointers to access the private method,
            // and also to conveniently differentiate between render and
            // capture. Note that the capture stream is the one with a
            // capture terminal, and thus we need to give it the wave out id,
            // and we need to give the render terminal the wave in ID.
            //

            hr = m_pRenderStream ->SetWaveID( &Blob->PermanentGuid ); // wavein

            if ( FAILED(hr) )
            {
                LOG((MSP_ERROR, "CWaveMSPCall::ReceiveTSPCallData - "
                    "render stream SetWaveID failed 0x%08x - "
                    "firing CALL_STREAM_FAIL", hr));

                m_pRenderStream->FireEvent(CALL_STREAM_FAIL, hr, CALL_CAUSE_UNKNOWN);
            }

            hr = m_pCaptureStream->SetWaveID( &Blob->PermanentGuid ); // waveout

            if ( FAILED(hr) )
            {
                LOG((MSP_ERROR, "CWaveMSPCall::ReceiveTSPCallData - "
                    "capture stream SetWaveID failed 0x%08x - "
                    "firing CALL_STREAM_FAIL", hr));

                m_pCaptureStream->FireEvent(CALL_STREAM_FAIL, hr, CALL_CAUSE_UNKNOWN);
            }

        }
//        break;
//
//    case 1: // start streaming
        {
            for ( i = 0; i < m_Streams.GetSize(); i++ )
            {
                hr = m_Streams[i]->StartStream();
            }
        }
        break;

    case CSATSPMSPCMD_DISCONNECTED:
        {
            for ( i = 0; i < m_Streams.GetSize(); i++ )
            {
                hr = m_Streams[i]->StopStream();
            }
        }
        break;

    default:
        LOG((MSP_ERROR, "CWaveMSPCall::ReceiveTSPCallData - "
            "invalid command - exit E_INVALIDARG"));

        return E_INVALIDARG;

    }

    LOG((MSP_TRACE, "CWaveMSPCall::ReceiveTSPCallData - exit S_OK"));
    return S_OK;
}

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\csamsp\csastrm.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    wavestrm.cpp 

Abstract:

    This module contains implementation of CWaveMSPStream.

Author:
    
    Zoltan Szilagyi (zoltans)   September 7, 1998

--*/

#include "stdafx.h"

#include <initguid.h>
#include <g711uids.h>


HRESULT
TryCreateCSAFilter(
    IN  GUID   *PermanentGuid,
    OUT IBaseFilter **ppCSAFilter
    );



///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

CWaveMSPStream::CWaveMSPStream() : CMSPStream()
{
    LOG((MSP_TRACE, "CWaveMSPStream::CWaveMSPStream entered."));

    m_fTerminalConnected = FALSE;
    m_fHaveWaveID        = FALSE;
    m_DesiredGraphState  = State_Stopped;
    m_pFilter            = NULL;
    m_pG711Filter        = NULL;

    LOG((MSP_TRACE, "CWaveMSPStream::CWaveMSPStream exited."));
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

CWaveMSPStream::~CWaveMSPStream()
{
    LOG((MSP_TRACE, "CWaveMSPStream::~CWaveMSPStream entered."));
    LOG((MSP_TRACE, "CWaveMSPStream::~CWaveMSPStream exited."));
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

void CWaveMSPStream::FinalRelease()
{
    LOG((MSP_TRACE, "CWaveMSPStream::FinalRelease entered."));

    //
    // At this point we should have no terminals selected, since
    // Shutdown is supposed to be called before we are destructed.
    //

    _ASSERTE( 0 == m_Terminals.GetSize() );

    //
    // Remove out filter from the graph and release it.
    //

    if ( m_fHaveWaveID )
    {
        _ASSERTE( m_pFilter );

    	m_pIGraphBuilder->RemoveFilter( m_pFilter );
        m_pFilter->Release();
    }

	if ( m_pG711Filter )
    {
    	m_pIGraphBuilder->RemoveFilter( m_pG711Filter );
        m_pG711Filter->Release();
    }

    //
    // Call the base class method to clean up everything else.
    //

    CMSPStream::FinalRelease();

    LOG((MSP_TRACE, "CWaveMSPStream::FinalRelease exited."));
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CWaveMSPStream::get_Name (
    OUT     BSTR *                  ppName
    )
{
    LOG((MSP_TRACE, "CWaveMSPStream::get_Name - enter"));

    //
    // Check argument.
    //

    if ( IsBadWritePtr(ppName, sizeof(BSTR) ) )
    {
        LOG((MSP_TRACE, "CWaveMSPStream::get_Name - "
            "bad return pointer - returning E_POINTER"));

        return E_POINTER;
    }

    //
    // Decide what string to return based on which stream this is.
    //

    ULONG ulID;
    
    if ( m_Direction == TD_CAPTURE )
    {
        ulID = IDS_CAPTURE_STREAM;
    }
    else
    {
        ulID = IDS_RENDER_STREAM;
    }

    //
    // Get the string from the string table.
    //

    const int   ciAllocSize = 2048;
    WCHAR       wszName[ciAllocSize];

    int iReturn = LoadString( _Module.GetModuleInstance(),
                              ulID,
                              wszName,
                              ciAllocSize - 1 );

    if ( iReturn == 0 )
    {
        _ASSERTE( FALSE );
        
        *ppName = NULL;

        LOG((MSP_ERROR, "CWaveMSPStream::get_Name - "
            "LoadString failed - returning E_UNEXPECTED"));

        return E_UNEXPECTED;
    }

    //
    // Convert to a BSTR and return the BSTR.
    //

    *ppName = SysAllocString(wszName);

    if ( *ppName == NULL )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::get_Name - "
            "SysAllocString failed - returning E_OUTOFMEMORY"));

        return E_OUTOFMEMORY;
    }

    LOG((MSP_TRACE, "CWaveMSPStream::get_Name - exit S_OK"));

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CWaveMSPStream::SelectTerminal(
    IN      ITTerminal *            pTerminal
    )
{
    LOG((MSP_TRACE, "CWaveMSPStream::SelectTerminal - enter"));

    //
    // We are going to access the terminal list -- grab the lock
    //

    CLock lock(m_lock);

    //
    // Reject if we already have a terminal selected.
    //

    if ( 0 != m_Terminals.GetSize() )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::SelectTerminal - "
            "exit TAPI_E_MAXTERMINALS"));

        return TAPI_E_MAXTERMINALS;
    }

    //
    // Use base class method to add it to our list of terminals.
    //

    HRESULT hr = CMSPStream::SelectTerminal(pTerminal);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::SelectTerminal - "
            "base class method failed - exit 0x%08x", hr));

        return hr;
    }

    //
    // Re-pause or re-start the stream if needed.
    //

    if ( m_DesiredGraphState == State_Paused )
    {
        hr = PauseStream();
    }
    else if ( m_DesiredGraphState == State_Running )
    {
        hr = StartStream();
    }
    else
    {
        _ASSERTE( m_DesiredGraphState == State_Stopped );

        hr = S_OK;
    }

    if ( FAILED(hr) )
    {
        LOG((MSP_TRACE, "CWaveMSPStream::SelectTerminal - "
            "can't regain old graph state - unselecting terminal - "
            "exit 0x%08x", hr));

		//
		// Unselect it to undo all of the above.
		//

	    UnselectTerminal(pTerminal);

        return hr;
    }

    LOG((MSP_TRACE, "CWaveMSPStream::SelectTerminal - exit S_OK"));

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CWaveMSPStream::UnselectTerminal (
        IN     ITTerminal *             pTerminal
        )
{
    LOG((MSP_TRACE, "CWaveMSPStream::UnselectTerminal - enter"));

    CLock lock(m_lock);

    //
    // Add an extra reference to the terminal so it doesn't go away
    // after we call CMSPStream::UnselectTerminal. We need it later
    // in the function.
    //
    pTerminal->AddRef();


    //
    // Use base class method to remove terminal from our list of terminals.
    //

    HRESULT hr = CMSPStream::UnselectTerminal(pTerminal);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CWaveMSPStream::UnselectTerminal - "
            "base class method failed - exit 0x%08x", hr));

        pTerminal->Release();
        return hr;
    }

    //
    // If we've been given a waveid then we may not be stopped.
    // This does nothing if we are already stopped.
    //

    CMSPStream::StopStream();



    //
    // Disconnect the terminal if this call had it connected.
    //

    if ( m_fTerminalConnected )
    {
        //
        // Get the ITTerminalControl interface.
        //

        ITTerminalControl * pTerminalControl;

        hr = pTerminal->QueryInterface(IID_ITTerminalControl,
                                       (void **) &pTerminalControl);

        if ( FAILED(hr) )
        {
            LOG((MSP_ERROR, "CWaveMSPStream::UnselectTerminal - "
                "QI for ITTerminalControl failed - exit 0x%08x", hr));

            pTerminal->Release();
            return hr;
        }

        //
        // Disconnect the terminal.
        //

        hr = pTerminalControl->DisconnectTerminal(m_pIGraphBuilder, 0);

        pTerminalControl->Release();

        m_fTerminalConnected = FALSE;

        if ( FAILED(hr) )
        {
            LOG((MSP_ERROR, "CWaveMSPStream::UnselectTerminal - "
                "DisconnectTerminal failed - exit 0x%08x", hr));
            pTerminal->Release();
            return hr;
        }
    }

    LOG((MSP_TRACE, "CWaveMSPStream::UnselectTerminal - exit S_OK"));

    pTerminal->Release();
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CWaveMSPStream::StartStream (void)
{
    LOG((MSP_TRACE, "CWaveMSPStream::StartStream - enter"));

    CLock lock(m_lock);

    m_DesiredGraphState = State_Running;

    //
    // Can't start the stream if we don't know the waveid.
    // (We create our filters on discovery of the waveid.)
    //

    if ( ! m_fHaveWaveID )
    {
        LOG((MSP_WARN, "CWaveMSPStream::StartStream - "
            "no waveid so nothing to do yet - exit S_OK"));

        return S_OK;
    }

    //
    // Can't start the stream if no terminal has been selected.
    //

    if ( 0 == m_Terminals.GetSize() )
    {
        LOG((MSP_WARN, "CWaveMSPStream::StartStream - "
            "no Terminal so nothing to do yet - exit S_OK"));

        return S_OK;
    }

    //
    // Connect the terminal. This does nothing if this call already
    // connected the terminal and fails if another call has the
    // terminal connected.
    //

    HRESULT hr;

    hr = ConnectTerminal(m_Terminals[0]);

    if ( FAILED(hr) )
    {
        FireEvent(CALL_TERMINAL_FAIL, hr, CALL_CAUSE_CONNECT_FAIL);
        FireEvent(CALL_STREAM_FAIL, hr, CALL_CAUSE_CONNECT_FAIL);

        LOG((MSP_ERROR, "CWaveMSPStream::StartStream - "
            "our ConnectTerminal failed - exit 0x%08x", hr));

        return hr;
    }

    //
    // Run the stream via the base class method.
    //

    hr = CMSPStream::StartStream();

    if ( FAILED(hr) )
    {
        FireEvent(CALL_STREAM_FAIL, hr, CALL_CAUSE_UNKNOWN);

        LOG((MSP_ERROR, "CWaveMSPStream::StartStream - "
            "Run failed - exit 0x%08x", hr));

        return hr;
    }

    HRESULT hr2 = FireEvent(CALL_STREAM_ACTIVE, hr, CALL_CAUSE_LOCAL_REQUEST);

    if ( FAILED(hr2) )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::StartStream - "
            "FireEvent failed - exit 0x%08x", hr2));

        return hr2;
    }

    LOG((MSP_TRACE, "CWaveMSPStream::StartStream - exit S_OK"));

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CWaveMSPStream::PauseStream (void)
{
    LOG((MSP_TRACE, "CWaveMSPStream::PauseStream - enter"));

    CLock lock(m_lock);

    m_DesiredGraphState = State_Paused;

    //
    // Can't pause the stream if we don't know the waveid.
    // (We create our filters on discovery of the waveid.)
    //

    if ( ! m_fHaveWaveID )
    {
        LOG((MSP_WARN, "CWaveMSPStream::PauseStream - "
            "no waveid so nothing to do yet - exit S_OK"));

        return S_OK;
    }

    //
    // Can't pause the stream if no terminal has been selected.
    //

    if ( 0 == m_Terminals.GetSize() )
    {
        LOG((MSP_WARN, "CWaveMSPStream::PauseStream - "
            "no Terminal so nothing to do yet - exit S_OK"));

        return S_OK;
    }

    //
    // Connect the terminal. This does nothing if this call already
    // connected the terminal and fails if another call has the
    // terminal connected.
    //

    HRESULT hr;

    hr = ConnectTerminal(m_Terminals[0]);

    if ( FAILED(hr) )
    {
        FireEvent(CALL_TERMINAL_FAIL, hr, CALL_CAUSE_CONNECT_FAIL);
        FireEvent(CALL_STREAM_FAIL, hr, CALL_CAUSE_CONNECT_FAIL);

        LOG((MSP_ERROR, "CWaveMSPStream::StartStream - "
            "our ConnectTerminal failed - exit 0x%08x", hr));

        return hr;
    }

    //
    // Pause the stream via the base class method.
    //

    hr = CMSPStream::PauseStream();

    if ( FAILED(hr) )
    {
        FireEvent(CALL_STREAM_FAIL, hr, CALL_CAUSE_UNKNOWN);

        LOG((MSP_ERROR, "CWaveMSPStream::PauseStream - "
            "Pause failed - exit 0x%08x", hr));

        return hr;
    }
    
    HRESULT hr2 = FireEvent(CALL_STREAM_INACTIVE, hr, CALL_CAUSE_LOCAL_REQUEST);

    if ( FAILED(hr2) )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::PauseStream - "
            "FireEvent failed - exit 0x%08x", hr2));

        return hr2;
    }

    LOG((MSP_TRACE, "CWaveMSPStream::PauseStream - exit S_OK"));

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CWaveMSPStream::StopStream (void)
{
    LOG((MSP_TRACE, "CWaveMSPStream::StopStream - enter"));

    CLock lock(m_lock);

    m_DesiredGraphState = State_Stopped;

    //
    // Nothing to do if we don't know our waveid.
    //

    if ( ! m_fHaveWaveID )
    {
        LOG((MSP_WARN, "CWaveMSPStream::StopStream - "
            "no waveid - exit S_OK"));

        return S_OK;
    }

    //
    // Nothing to do if no terminal has been selected.
    //

    if ( 0 == m_Terminals.GetSize() )
    {
        LOG((MSP_WARN, "CWaveMSPStream::StopStream - "
            "no Terminal - exit S_OK"));

        return S_OK;
    }

    //
    // Stop the stream via the base class method.
    //

    HRESULT hr;

    hr = CMSPStream::StopStream();

    if ( FAILED(hr) )
    {
        FireEvent(CALL_STREAM_FAIL, hr, CALL_CAUSE_UNKNOWN);

        LOG((MSP_ERROR, "CWaveMSPStream::StopStream - "
            "Stop failed - exit 0x%08x", hr));

        return hr;
    }
    
    HRESULT hr2 = FireEvent(CALL_STREAM_INACTIVE, hr, CALL_CAUSE_LOCAL_REQUEST);

    if ( FAILED(hr2) )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::StopStream - "
            "FireEvent failed - exit 0x%08x", hr2));

        return hr2;
    }

    LOG((MSP_TRACE, "CWaveMSPStream::StopStream - exit S_OK"));

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//

HRESULT CWaveMSPStream::SetWaveID(GUID * PermanentGuid)
{
    LOG((MSP_TRACE, "CWaveMSPStream::SetWaveID - enter"));

    CLock lock(m_lock);

    //
    // create the correct wave filter
    //

    HRESULT hr;

    hr= TryCreateCSAFilter(
        PermanentGuid,
        &m_pFilter
    );

    if (!(SUCCEEDED(hr)))
    {
        LOG((MSP_ERROR, "CWaveMSPStream::SetWaveID - "
            "Filter creation failed - exit 0x%08x", hr));
        
        return hr;
    }

    //
    // Add the filter. Supply a name to make debugging easier.
    //

	WCHAR * pName = (m_Direction == TD_RENDER) ?
						(L"The Stream's WaveIn (on line device)") :
						(L"The Stream's WaveOut (on line device)");

    hr = m_pIGraphBuilder->AddFilter(m_pFilter, pName);
    
    if (!(SUCCEEDED(hr)))
    {
        LOG((MSP_ERROR, "CWaveMSPStream::SetWaveID - "
            "AddFilter failed - exit 0x%08x", hr));
        
        m_pFilter->Release();

        return hr;
    }

    //
    // We now have the wave ID.
    //

    m_fHaveWaveID = TRUE;

    LOG((MSP_TRACE, "CWaveMSPStream::SetWaveID - exit S_OK"));

    return S_OK;
}

#if 0

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// Create the G711 filter, which we will try to connect if direct
// connection fails.
//

void CWaveMSPStream::CreateAndAddG711(void)
{
    //
    // Create the G711 filter.
    //

    HRESULT hr;

    hr = CoCreateInstance(
                          CLSID_G711Codec,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IBaseFilter,
                          (void **) &m_pG711Filter
                         );

    if (!(SUCCEEDED(hr)))
    {
        LOG((MSP_ERROR, "CWaveMSPStream - Failed to create G711 codec: %lx", hr));

        //
        // Method #2 for connection will not be available.
        //

        m_pG711Filter = NULL;

        return;
    }

    //
    // add the G711 filter
    //
    hr = m_pIGraphBuilder->AddFilter(
                                    m_pG711Filter,
                                    NULL
                                   );

    if (!(SUCCEEDED(hr)))
    {
        LOG((MSP_ERROR, "CWaveMSPStream - Failed to add G711 filter: %lx", hr));

        //
        // If we couldn't add it to the graph, then it's useless to us.
        // Method #2 for connection will not be available.
        //

        m_pG711Filter->Release();
        m_pG711Filter = NULL; 
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
// This function suggests a reasonable buffer size
// on the wave in filter's output pin. It is called right before
// connection.
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

// Dialogic said something about small buffers causing problems for their wave
// driver. 20 ms samples were ok on a dual-proc Pentium Pro but caused choppy
// sound followed by silence on a single-proc 166 Pentium. I hate to do this
// but we had better try raising this for compatibility... :(

static const long DESIRED_BUFFER_SIZE_MS = 20; // milliseconds

HRESULT CWaveMSPStream::DecideDesiredCaptureBufferSize(IUnknown * pUnknown,
                                                   long * plDesiredSize)
{
    LOG((MSP_TRACE, "CWaveMSPStream::DecideDesiredCaptureBufferSize - "
        "enter"));

    _ASSERTE( ! IsBadReadPtr(pUnknown, sizeof(IUnknown)) );
    _ASSERTE( ! IsBadWritePtr(plDesiredSize, sizeof(long)) );

    HRESULT hr;

    IAMStreamConfig * pConfig = NULL;

    hr = pUnknown->QueryInterface(IID_IAMStreamConfig,
                                  (void **) &pConfig
                                 );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::DecideDesiredCaptureBufferSize"
            " - IAMStreamConfig QI failed on IUnknown 0x%08x; hr = 0x%08x",
            pUnknown, hr));

        return hr;
    }

    AM_MEDIA_TYPE * pMediaType;
    
    hr = pConfig->GetFormat(&pMediaType);

    pConfig->Release();
    
    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::DecideDesiredCaptureBufferSize"
            " - GetFormat failed; hr = 0x%08x", hr));

        return hr;
    }

    _ASSERTE( pMediaType->cbFormat >= sizeof(WAVEFORMATEX) );

    *plDesiredSize = DESIRED_BUFFER_SIZE_MS * 
            ((WAVEFORMATEX *) (pMediaType->pbFormat) )->nChannels *
            ( ((WAVEFORMATEX *) (pMediaType->pbFormat) )->nSamplesPerSec / 1000) * 
            ( ((WAVEFORMATEX *) (pMediaType->pbFormat) )->wBitsPerSample / 8);

    DeleteMediaType(pMediaType);

    LOG((MSP_TRACE, "CWaveMSPStream::DecideDesiredCaptureBufferSize - "
        "exit S_OK"));

    return S_OK;
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ManipulateAllocatorProperties
//
// This is a helper function that sets up the allocator properties on the
// capture filter, given the interface pointer required for doing so and 
// an interface pointer that is used to discover downstream allocator
// requirements.
// we are already in a lock; no need to do locking here.
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT CWaveMSPStream::ManipulateAllocatorProperties
                        (IAMBufferNegotiation * pNegotiation,
                         IMemInputPin         * pMemInputPin)
{
    LOG((MSP_TRACE, "CWaveMSPStream::ManipulateAllocatorProperties - enter"));

    HRESULT hr;
    ALLOCATOR_PROPERTIES props;

    hr = pMemInputPin->GetAllocatorRequirements(&props);

    if ( SUCCEEDED(hr) )
    {
        LOG((MSP_TRACE, "CWaveMSPStream::ManipulateAllocatorProperties - "
            "using downstream allocator requirements"));
    }
    else
    {
        LOG((MSP_TRACE, "CWaveMSPStream::ManipulateAllocatorProperties - "
            "using our default allocator properties"));

        long lDesiredSize = 0;
        hr = DecideDesiredCaptureBufferSize(pNegotiation,
                                            &lDesiredSize);

        if ( FAILED(hr) )
        {
            LOG((MSP_ERROR, "CWaveMSPStream::ManipulateAllocatorProperties - "
                "DecideDesiredCaptureBufferSize failed - exit 0x%08x", hr));

            return hr;
        }
    
        props.cBuffers  = 32;   // we use 32 to avoid starvation, just as we do in the terminal manager.
        props.cbBuffer  = lDesiredSize;
        props.cbAlign   = -1;   // means "default"
        props.cbPrefix  = -1;   // means "default"
    }

    hr = pNegotiation->SuggestAllocatorProperties(&props);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::ManipulateAllocatorProperties - "
            "SuggestAllocatorProperties failed - exit 0x%08x", hr));

        return hr;
    }

    LOG((MSP_TRACE, "CWaveMSPStream::ManipulateAllocatorProperties - "
        "exit S_OK"));

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// SetupWaveIn
//
// This is a helper function that sets up the allocator properties on the
// capture filter, given the terminal's pin and our filter's pin. This
// involves deciding where the capture interfaces should be found, checkin
// if the downstream filters have allocator requirements, and then applying
// either these requirements or our default requirements to the capture
// filter.
// we are already in a lock; no need to do locking here.
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    
HRESULT CWaveMSPStream::SetupWaveIn( IPin * pOutputPin,
                                 IPin * pInputPin )
{
    LOG((MSP_TRACE, "CWaveMSPStream::SetupWaveIn - enter"));

    //
    // Ask the output pin for its buffer negotiation interface.
    //

    HRESULT hr;
    IAMBufferNegotiation * pNegotiation;

    hr = pOutputPin->QueryInterface(IID_IAMBufferNegotiation,
                                    (void **) &pNegotiation);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "IAMBufferNegotiation QI failed - hr = 0x%08x", hr));
        return hr;
    }

    //
    // Ask the input pin for its meminputpin interface.
    //

    IMemInputPin         * pMemInputPin;

    hr = pInputPin->QueryInterface(IID_IMemInputPin,
                                   (void **) &pMemInputPin);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "IMemInputPin QI failed - hr = 0x%08x", hr));

        pNegotiation->Release();
        return hr;
    }

    //
    // now set the properties on the negotiation interface, depending
    // on the properties that are set on the meminputpin interface
    //

    hr = ManipulateAllocatorProperties(pNegotiation, pMemInputPin);

    pNegotiation->Release();
    pMemInputPin->Release();

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "ManipulateAllocatorProperties - hr = 0x%08x", hr));
        return hr;
    }

    LOG((MSP_TRACE, "CWaveMSPStream::SetupWaveIn - exit S_OK"));
    return S_OK;
}
#endif
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// This function is for debugging purposes only. It pops up a
// couple of message boxes telling you various information about
// media formats and allocator properties. It's called after
// connection has taken place. pPin is the output pin of the
// wavein filter.
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
        
HRESULT CWaveMSPStream::ExamineWaveInProperties(IPin *pPin)
{
    LOG((MSP_TRACE, "CWaveMSPStream::ExamineWaveInProperties - enter"));

    HRESULT hr;
    IAMBufferNegotiation * pNegotiation = NULL;

    hr = pPin->QueryInterface(IID_IAMBufferNegotiation,
                              (void **) &pNegotiation
                             );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::ExamineWaveInProperties - "
            "IAMBufferNegotiation QI failed on pin 0x%08x; hr = 0x%08x",
            pPin, hr));

        return hr;
    }

    ALLOCATOR_PROPERTIES prop;
    
    hr = pNegotiation->GetAllocatorProperties(&prop);

    pNegotiation->Release();
    
    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::ExamineWaveInProperties - "
            "GetAllocatorProperties failed; hr = 0x%08x",
            hr));

        return hr;
    }

    LOG((MSP_TRACE, "GetAllocatorProperties info:\n"
            "buffer count: %d\n"
            "size of each buffer: %d bytes\n"
            "alignment multiple: %d\n"
            "each buffer has a prefix: %d bytes",
            prop.cBuffers,
            prop.cbBuffer,
            prop.cbAlign,
            prop.cbPrefix
           ));

    IAMStreamConfig * pConfig = NULL;

    hr = pPin->QueryInterface(IID_IAMStreamConfig,
                              (void **) &pConfig
                             );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::ExamineWaveInProperties - "
            "IAMStreamConfig QI failed on pin 0x%08x; hr = 0x%08x", pPin, hr));

        return hr;
    }

    AM_MEDIA_TYPE * pMediaType;
    
    hr = pConfig->GetFormat(&pMediaType);

    pConfig->Release();
    
    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::ExamineWaveInProperties - "
            "GetFormat failed; hr = 0x%08x", hr));

        return hr;
    }

    _ASSERTE( pMediaType->cbFormat >= sizeof(WAVEFORMATEX) );

    LOG((MSP_TRACE, "GetFormat info:\n"
            "sample size: %d bytes\n"
            "channels: %d\n"
            "samples per second: %d\n"
            "bits per sample: %d\n",
            pMediaType->lSampleSize,
            ((WAVEFORMATEX *) (pMediaType->pbFormat) )->nChannels,
            ((WAVEFORMATEX *) (pMediaType->pbFormat) )->nSamplesPerSec,
            ((WAVEFORMATEX *) (pMediaType->pbFormat) )->wBitsPerSample
           ));

    DeleteMediaType(pMediaType);

    LOG((MSP_TRACE, "CWaveMSPStream::ExamineWaveInProperties - "
        "exit S_OK"));

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// Add the terminal to the graph and connect it to our
// filters, if it is not already in use.
//

HRESULT CWaveMSPStream::ConnectTerminal(ITTerminal * pTerminal)
{
    LOG((MSP_TRACE, "CWaveMSPStream::ConnectTerminal - enter"));

    //
    // Find out the terminal's internal state.
    //

    TERMINAL_STATE state;
    HRESULT hr;

    hr = pTerminal->get_State( &state );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::ConnectTerminal - "
            "get_State on terminal failed - exit 0x%08x", hr));

        return hr;
    }

    //
    // If we've already connected the terminal on this stream, then
    // there is nothing for us to do. Just assert that the terminal
    // also thinks it's connected.
    //

    if ( m_fTerminalConnected )
    {
        _ASSERTE( state == TS_INUSE );

        LOG((MSP_ERROR, "CWaveMSPStream::ConnectTerminal - "
            "terminal already connected on this stream - exit S_OK"));

        return S_OK;
    }

    //
    // Otherwise we need to connect the terminal on this call. If the
    // terminal is already connected on another call, we must fail. Note
    // that since we are making several calls on the terminal here, the
    // terminal could become connected on another call while we are
    // in the process of doing this. If this happens, the we will just fail
    // later.
    //

    if ( state == TS_INUSE )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::ConnectTerminal - "
            "terminal in use - exit TAPI_E_TERMINALINUSE"));

        return TAPI_E_TERMINALINUSE;
    }

    //
    // Get the ITTerminalControl interface.
    //

    ITTerminalControl * pTerminalControl;

    hr = m_Terminals[0]->QueryInterface(IID_ITTerminalControl,
                                        (void **) &pTerminalControl);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::ConnectTerminal - "
            "QI for ITTerminalControl failed - exit 0x%08x", hr));

        return hr;
    }

    //
    // Find out how many pins the terminal has. If not one then bail as
    // we have no idea what to do with multiple-pin terminals at this point.
    //

    DWORD dwNumPinsAvailable;

    hr = pTerminalControl->ConnectTerminal(m_pIGraphBuilder,
                                           m_Direction,
                                           &dwNumPinsAvailable,
                                           NULL);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::ConnectTerminal - "
            "query for number of terminal pins failed - exit 0x%08x", hr));
        
        pTerminalControl->Release();

        return hr;
    }

    if ( 1 != dwNumPinsAvailable )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::ConnectTerminal - "
            "unsupported number of terminal pins - exit E_FAIL"));

        pTerminalControl->Release();

        return E_FAIL;
    }

    IPin * pTerminalPin;

    //
    // Actually connect the terminal.
    //

    hr = pTerminalControl->ConnectTerminal(m_pIGraphBuilder,
                                           m_Direction,
                                           &dwNumPinsAvailable,
                                           &pTerminalPin);
    
    if ( FAILED(hr) )
    {
        pTerminalControl->Release();

        LOG((MSP_ERROR, "CWaveMSPStream::ConnectTerminal - "
            "ConnectTerminal on terminal failed - exit 0x%08x", hr));

        return hr;
    }

    if (IsBadReadPtr(pTerminalPin,sizeof(IPin))) {
        //
        //  bad pin
        //
        pTerminalControl->Release();

        LOG((MSP_ERROR, "CWaveMSPStream::ConnectTerminal - "
            "bad IPin returned from ConnectTerminal"));

        return E_POINTER;
    }


    //
    // Now make the connection between our filters and the terminal's pin.
    //

    hr = ConnectToTerminalPin(pTerminalPin);

    pTerminalPin->Release();

    if ( FAILED(hr) )
    {
        pTerminalControl->DisconnectTerminal(m_pIGraphBuilder, 0);

        pTerminalControl->Release();

        LOG((MSP_ERROR, "CWaveMSPStream::ConnectTerminal - "
            "ConnectToTerminalPin failed - exit 0x%08x", hr));

        return hr;
    }

    //
    // Now we are actually connected. Update our state and perform postconnection
    // (ignore postconnection error code).
    //

    m_fTerminalConnected  = TRUE;

    pTerminalControl->CompleteConnectTerminal();

    pTerminalControl->Release();

    LOG((MSP_TRACE, "CWaveMSPStream::ConnectTerminal - exit S_OK"));

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// Tries to connect the waveOut filter. First it tries a
// direct connection, then with an intermediate G711
// codec, then an intelligent connect which may draw in
// more filters.
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

void ShowMediaTypes(IEnumMediaTypes * pEnum)
{
    AM_MEDIA_TYPE * pMediaType;

    while (pEnum->Next(1, &pMediaType, NULL) == S_OK)
    {
        if ( pMediaType->cbFormat < sizeof(WAVEFORMATEX) )
		{
	        LOG((MSP_TRACE, "*** Media Type: *** non-wave"));
		}
		else
		{
			LOG((MSP_TRACE,"*** Media Type: *** "
					"sample size: %d bytes *** "
					"channels: %d *** "
					"samples per second: %d *** "
					"bits per sample: %d",
					pMediaType->lSampleSize,
					((WAVEFORMATEX *) (pMediaType->pbFormat) )->nChannels,
					((WAVEFORMATEX *) (pMediaType->pbFormat) )->nSamplesPerSec,
					((WAVEFORMATEX *) (pMediaType->pbFormat) )->wBitsPerSample
				   ));
		}

        DeleteMediaType(pMediaType);
    }
}


HRESULT CWaveMSPStream::TryToConnect(
                              IPin * pOutputPin,  // on the capture filter or terminal
                              IPin * pInputPin    // on the render filter or terminal
                             )
{
    LOG((MSP_TRACE, "TryToConnect - enter"));

    HRESULT       hr;


    IEnumMediaTypes * pEnum;

    hr = pOutputPin->EnumMediaTypes(&pEnum);

    if (SUCCEEDED(hr))
    {  
        LOG((MSP_TRACE, "Output pin media types:"));
        ShowMediaTypes(pEnum);
        pEnum->Release();
    }

    hr = pInputPin->EnumMediaTypes(&pEnum);
    if (SUCCEEDED(hr))
    {
        LOG((MSP_TRACE, "Input pin media types:"));
        ShowMediaTypes(pEnum);
        pEnum->Release();
    }

    //
    // Method 1: direct connection
    //

    hr = m_pIGraphBuilder->ConnectDirect(
                              pOutputPin,
                              pInputPin,
                              NULL
                             );

    if ( SUCCEEDED(hr) )
    {
        LOG((MSP_TRACE, "TryToConnect: direct connection worked - exit S_OK"));
        return S_OK;
    }

    LOG((MSP_ERROR, "TryToConnect - direct connection failed - %lx", hr));

    //
    // Method 1.5: work around DirectShow bug for Unimodem.
    //   Try 8 KHz 16-bit mono explicitly
    //

    AM_MEDIA_TYPE MediaType;
    WAVEFORMATEX  WaveFormatEx;

    MediaType.majortype = MEDIATYPE_Audio;
    MediaType.subtype = MEDIASUBTYPE_PCM;
    MediaType.bFixedSizeSamples = TRUE;
    MediaType.bTemporalCompression = FALSE;
    MediaType.lSampleSize = 2;
    MediaType.formattype = FORMAT_WaveFormatEx;
    MediaType.pUnk = NULL;
    MediaType.cbFormat = sizeof( WAVEFORMATEX );
    MediaType.pbFormat = (LPBYTE) & WaveFormatEx;

    WaveFormatEx.wFormatTag = WAVE_FORMAT_PCM;
    WaveFormatEx.nChannels = 1;
    WaveFormatEx.nSamplesPerSec = 8000;
    WaveFormatEx.nAvgBytesPerSec = 16000;
    WaveFormatEx.nBlockAlign = 2;
    WaveFormatEx.wBitsPerSample = 16;
    WaveFormatEx.cbSize = 0;

    IAMStreamConfig * pConfig;

    hr = pOutputPin->QueryInterface(IID_IAMStreamConfig,
                                  (void **) &pConfig
                                 );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::TryToConnect"
            " - IAMStreamConfig QI failed on output pin 0x%08x; hr = 0x%08x",
            pOutputPin, hr));
    }
    else
    {
        AM_MEDIA_TYPE * pOldMediaType;
        
        hr = pConfig->GetFormat(&pOldMediaType);

        if ( FAILED(hr) )
        {
            LOG((MSP_ERROR, "CWaveMSPStream::TryToConnect - "
                "GetFormat failed - 0x%08x", hr));
        }
        else
        {
            // Suggest the new format. If it fails, we want to know about it
            // as something is wrong.

            hr = pConfig->SetFormat(&MediaType);

            if ( FAILED(hr) )
            {
                LOG((MSP_ERROR, "CWaveMSPStream::TryToConnect - "
                    "SetFormat failed - 0x%08x", hr));
            }
            else
            {
                hr = m_pIGraphBuilder->ConnectDirect(
                                          pOutputPin,
                                          pInputPin,
                                          &MediaType
                                         );

                if ( SUCCEEDED(hr) )
                {
                    LOG((MSP_TRACE, "TryToConnect: direct connection with explicit "
                        "WaveIn 8KHz 16-bit setting worked - exit S_OK"));
                
                    DeleteMediaType(pOldMediaType);
                    pConfig->Release();

                    return S_OK;
                }
                else
                {
                    // restore old type, best effort
                    hr = pConfig->SetFormat(pOldMediaType);

                    if ( FAILED(hr) )
                    {
                        LOG((MSP_ERROR, "CWaveMSPStream::TryToConnect - "
                            "SetFormat failed to restore old type - 0x%08x", hr));
                    }
                }
            }

            DeleteMediaType(pOldMediaType);
        }

        pConfig->Release();
    }

#if 0
    LOG((MSP_ERROR, "TryToConnect - direct connection with explicit "
                    "WaveIn 8KHz 16-bit setting failed - %lx", hr));

    //
    // Method 2: direct connection with G711 filter in between.
    // If we haven't created and added the G711 filter to the graph yet,
    // do so now.
    //

    if ( ! m_pG711Filter )
    {
        CreateAndAddG711();
    }

    //
    // If the CreateAndAddG711 method worked, now or previously, then try to
    // use the G711.
    //

    if (m_pG711Filter)
    {
        IPin * pG711InputPin = NULL;

        hr = FindPinInFilter(
                             false,          // want input pin
                             m_pG711Filter,
                             &pG711InputPin
                            );

        if ( SUCCEEDED(hr) )
        {
            hr = m_pIGraphBuilder->ConnectDirect(
                                  pOutputPin,
                                  pG711InputPin,
                                  NULL
                                 );

            // We don't release the G711's input pin here because we must
            // hang onto it in order to break the connection if any of the
            // subsequent steps fail.

            if ( SUCCEEDED(hr) )
            {
                IPin * pG711OutputPin = NULL;

                hr = FindPinInFilter(
                                     true,          // want output pin
                                     m_pG711Filter,
                                     &pG711OutputPin
                                    );

                if ( SUCCEEDED(hr) )
                {
                    hr = m_pIGraphBuilder->ConnectDirect(
                                          pG711OutputPin,
                                          pInputPin,
                                          NULL
                                         );

                    pG711OutputPin->Release();

                    if ( SUCCEEDED(hr) )
                    {
                        LOG((MSP_TRACE, "TryToConnect - G711 connection succeeded - exit S_OK"));

                        // Held onto this in case of failure... see above
                        pG711InputPin->Release();

                        return S_OK;
                    }
                    else
                    {
                        LOG((MSP_ERROR, "TryToConnect - could not connect "
                                          "G711 codec's output pin - %lx", hr));

                    }
                }
                else
                {
                    LOG((MSP_ERROR, "TryToConnect - could not find "
                                      "G711 codec's input pin - %lx", hr));
                }


                if ( FAILED(hr) )
                {
                    //
                    // The first G711 connection succeeded but something else
                    // subsequently failed. This means we must disconnect the left
                    // end of the G711 filter. Luckily, we held onto the G711 filter's
                    // input pin above. We must disconnect the them here, otherwise
                    // method #3 won't work.
                    //

                    hr = m_pIGraphBuilder->Disconnect(pOutputPin);

                    LOG((MSP_ERROR, "TryToConnect - error undoing what we did - could not "
                        "disconnect the wave filter's output pin! hr = 0x%08x", hr));

                    hr = m_pIGraphBuilder->Disconnect(pG711InputPin);

                    LOG((MSP_ERROR, "TryToConnect - error undoing what we did - could not "
                        "disconnect the wave filter's output pin! hr = 0x%08x", hr));

                    //
                    // Now we no longer need to talk to the pin...
                    //

                    pG711InputPin->Release();

                    //
                    // And the G711 filter itself sticks around in the graph for next time.
                    //
                }
            }
            else
            {
                LOG((MSP_ERROR, "TryToConnect - could not connect "
                                  "G711 codec's input pin - %lx", hr));
            }
        }
        else
        {
            LOG((MSP_ERROR, "TryToConnect - could not find "
                              "G711 codec's input pin - %lx", hr));
        }
    }
    else
    {
        hr = E_FAIL;

        LOG((MSP_ERROR, "TryToConnect - G711 codec does not exist"));
    }

    LOG((MSP_TRACE, "TryToConnect - G711 connection failed - %lx", hr));

    //
    // Method 3: intelligent connection, which may pull in who knows what other filters
    //

#ifdef ALLOW_INTELLIGENT_CONNECTION
    hr = m_pIGraphBuilder->Connect(
                          pOutputPin,
                          pInputPin
                         );
#else // ALLOW_INTELLIGENT_CONNECTION
    LOG((MSP_ERROR, "TryToConnect - NOTE: we never allow intelligent connection"));
    hr = E_FAIL;
#endif // ALLOW_INTELLIGENT_CONNECTION
#endif
    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "TryToConnect - intelligent connection failed - %lx", hr));
        return hr;
    }

    LOG((MSP_TRACE, "TryToConnect: intelligent connection worked - exit S_OK"));
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

HRESULT CWaveMSPStream::ConnectToTerminalPin(IPin * pTerminalPin)
{
    LOG((MSP_TRACE, "CWaveMSPStream::ConnectToTerminalPin - enter"));

    HRESULT         hr = S_OK;
    IPin *          pMyPin;

    hr = FindPin( &pMyPin );

    if (!SUCCEEDED(hr))
    {
        LOG((MSP_ERROR, "CWaveMSPStream::ConnectToTerminalPin - "
            "could not find pin - exit 0x%08x", hr));

        return hr; // we can't continue without this pin
    }

    // The OUTPUT pin from WAVEIN; the INPUT pin from WAVEOUT
    IPin * pOutputPin  = ( m_Direction == TD_RENDER  ) ? pMyPin : pTerminalPin;
    IPin * pInputPin   = ( m_Direction == TD_CAPTURE ) ? pMyPin : pTerminalPin;
#if 0
    // don't care if this fails
    SetupWaveIn(pOutputPin,
                pInputPin);
#endif
    hr = TryToConnect(pOutputPin,
                      pInputPin);

    if ( SUCCEEDED(hr) )
    {
        // don't care if this fails...

        ExamineWaveInProperties(pOutputPin);
    }

    pMyPin->Release();

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::ConnectToTerminalPin - "
            "could not connect to pin - exit 0x%08x", hr));

        return hr;
    }

    LOG((MSP_TRACE, "CWaveMSPStream::ConnectToTerminalPin - exit S_OK"));

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT CWaveMSPStream::FindPinInFilter(
                     BOOL           bWantOutputPin, // IN:  if false, we want the input pin
                     IBaseFilter *  pFilter,        // IN:  the filter to examine
                     IPin        ** ppPin           // OUT: the pin we found
                     )
{    
    HRESULT         hr;
    IEnumPins     * pEnumPins;
    
    
    *ppPin = NULL;

    // enumerate the pins on the filter
    hr = pFilter->EnumPins( &pEnumPins );

    if (!(SUCCEEDED(hr)))
    {
        return hr;
    }

    // go through the pins
    while (TRUE)
    {
        PIN_DIRECTION       pd;
        
        hr = pEnumPins->Next( 1, ppPin, NULL );

        if (S_OK != hr)
        {
            // didn't find a pin!
            break;
        }

        // get the pin info
        hr = (*ppPin)->QueryDirection( &pd );

        // does it meet the criteria?
        if (bWantOutputPin && (pd == PINDIR_OUTPUT))
        {
            // yes
            break;
        }

        if ( ! bWantOutputPin && (pd == PINDIR_INPUT))
        {
            // yes
            break;
        }
        
        (*ppPin)->Release();
        *ppPin = NULL;
    }

    pEnumPins->Release();

    if (NULL == *ppPin)
    {
        // error
        return E_FAIL;
    }

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// FindPin
//
// Finds the first pin in the filter that meets criteria.
// For bWaveIn == TRUE, the pin must be direction PINDIR_OUTPUT
// For bWaveIn == FALSE, the pin must be direction PINDIR_INPUT
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CWaveMSPStream::FindPin(
        IPin ** ppPin
       )
{
    return FindPinInFilter(m_Direction == TD_RENDER,
                           m_pFilter,
                           ppPin);
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// ProcessGraphEvent
//
// Sends an event to the app when we get an event from the filter graph.
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT CWaveMSPStream::ProcessGraphEvent(
    IN  long lEventCode,
    IN  LONG_PTR lParam1,
    IN  LONG_PTR lParam2
    )
{
    LOG((MSP_EVENT, "CWaveMSPStream::ProcessGraphEvent - enter"));

    HRESULT        hr = S_OK;

    switch (lEventCode)
    {
    case EC_COMPLETE:
        
        hr = FireEvent(CALL_STREAM_INACTIVE, (HRESULT) lParam1, CALL_CAUSE_UNKNOWN);
        break;
    
    case EC_USERABORT:
        
        hr = FireEvent(CALL_STREAM_INACTIVE, S_OK, CALL_CAUSE_UNKNOWN);
        break;

    case EC_ERRORABORT:
    case EC_STREAM_ERROR_STOPPED:
    case EC_STREAM_ERROR_STILLPLAYING:
    case EC_ERROR_STILLPLAYING:

        hr = FireEvent(CALL_STREAM_FAIL, (HRESULT) lParam1, CALL_CAUSE_UNKNOWN);
        break;

    default:
        
        LOG((MSP_EVENT, "CWaveMSPStream::ProcessGraphEvent - "
            "ignoring event code %d", lEventCode));
        break;
    }

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CWaveMSPStream::ProcessGraphEvent - "
            "FireEvent failed - exit 0x%08x", hr));

        return hr;
    }

    LOG((MSP_EVENT, "CWaveMSPStream::ProcessGraphEvent - exit S_OK"));

    return S_OK;
}

HRESULT CWaveMSPStream::FireEvent(
    IN MSP_CALL_EVENT        type,
    IN HRESULT               hrError,
    IN MSP_CALL_EVENT_CAUSE  cause
    )                                          
{
    LOG((MSP_EVENT, "CWaveMSPStream::FireEvent - enter"));


    //
    // First, need to check if the call is shutting down. This is important
    // because UnselectTerminal can fire an event, and UnselectTerminal can
    // be called within ITStream::Shutdown. We can safely discard such
    // events because there is nothing the app can do with them anyway.
    //
    // Note on locking: It is convenient to check the m_pMSPCall here
    // and we don't use it until the end of the method, so we simply lock
    // during the entire method. This could be optimized at the expense of
    // some code complexity; note that we also need to lock while accessing
    // m_Terminals. 
    //

    CLock lock(m_lock);

    if ( m_pMSPCall == NULL )
    {
        LOG((MSP_EVENT, "FireEvent - call is shutting down; dropping event - exit S_OK"));
        
        return S_OK;
    }


    //
    // Create the event structure. Must use "new" as it will be
    // "delete"d later.
    //

    MSPEVENTITEM * pEventItem = AllocateEventItem();

    if (pEventItem == NULL)
    {
        LOG((MSP_ERROR, "CWaveMSPStream::FireEvent - "
            "can't create MSPEVENTITEM structure - exit E_OUTOFMEMORY"));

        return E_OUTOFMEMORY;
    }

    //
    // Fill in the necessary fields for the event structure.
    //

    pEventItem->MSPEventInfo.dwSize = sizeof(MSP_EVENT_INFO);
    pEventItem->MSPEventInfo.Event  = ME_CALL_EVENT;

    ITTerminal * pTerminal = NULL;

    if ( 0 != m_Terminals.GetSize() )
    {
        _ASSERTE( 1 == m_Terminals.GetSize() );
        pTerminal = m_Terminals[0];
        pTerminal->AddRef();
    }

    ITStream * pStream = (ITStream *) this;
    pStream->AddRef();

    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.Type      = type;
    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.Cause     = cause;
    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.pStream   = pStream;
    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.pTerminal = pTerminal;
    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.hrError   = hrError;

    //
    // Send the event to the app.
    //

    HRESULT hr = m_pMSPCall->HandleStreamEvent(pEventItem);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CWaveMSPStream::FireEvent - "
            "HandleStreamEvent failed - returning 0x%08x", hr));

        pStream->Release();
        pTerminal->Release();
        FreeEventItem(pEventItem);

        return hr;
    }

    LOG((MSP_EVENT, "CWaveMSPStream::FireEvent - exit S_OK"));

    return S_OK;
}




DEFINE_GUID(CLSID_Proxy,
0x17CCA71BL, 0xECD7, 0x11D0, 0xB9, 0x08, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96);

DEFINE_GUID(CLSID_WDM_RENDER,
0x65E8773EL, 0x8F56, 0x11D0, 0xA3, 0xB9, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96);


// {F420CB9C-B19D-11d2-A286-00C04F8EC951}
DEFINE_GUID(KSPROPSETID_MODEMCSA,
0xf420cb9c, 0xb19d, 0x11d2, 0xa2, 0x86, 0x0, 0xc0, 0x4f, 0x8e, 0xc9, 0x51);


HRESULT
CheckFilterPropery(
    IBaseFilter *CsaFilter,
    const GUID         *GuidToMatch
    )

{

    IKsPropertySet    *pKsPropSet = NULL;
    HRESULT            hr = S_OK;

    GUID               PermanentGuid;



    hr = CsaFilter->QueryInterface(IID_IKsPropertySet,
                                    (void **)&pKsPropSet);

    if (SUCCEEDED(hr)) {

        DWORD    BytesReturned;

        hr = pKsPropSet->Get(KSPROPSETID_MODEMCSA,
                         0,
                         NULL,
                         0,
                         (LPVOID)&PermanentGuid,
                         sizeof(PermanentGuid),
                         &BytesReturned
                         );



        pKsPropSet->Release();

        if (IsEqualGUID((PermanentGuid), *GuidToMatch)) {

            hr=S_OK;

        } else {

            hr=E_FAIL;
        }
    }

    return hr;
}





HRESULT
FindModemCSA(
    IN  GUID   *PermanentGuid,
    IBaseFilter ** ppFilter
    )

{

    ICreateDevEnum *pCreateDevEnum;

    HRESULT hr;

    //
    //  create system device enumerator
    //
    hr = CoCreateInstance(
            CLSID_SystemDeviceEnum,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_ICreateDevEnum,
            (void**)&pCreateDevEnum
            );

    if (SUCCEEDED(hr)) {

        IEnumMoniker *pEnumMoniker = NULL;

        hr = pCreateDevEnum->CreateClassEnumerator(
            CLSID_WDM_RENDER,
            &pEnumMoniker,
            0
            );

        pCreateDevEnum->Release();

        if (hr == S_OK) {

            pEnumMoniker->Reset();

            while( NULL == *ppFilter ) {

                IMoniker         *pMon;
                VARIANT           var;

                hr = pEnumMoniker->Next(1, &pMon, NULL);

                if ( S_OK != hr ) {

                    break;
                }
                // Bind to selected device
                hr = pMon->BindToObject( 0, 0, IID_IBaseFilter, (void**)ppFilter );

                pMon->Release();

                if (SUCCEEDED(hr)) {

                    hr=CheckFilterPropery(
                        *ppFilter,
                        PermanentGuid
                        );

                    if (SUCCEEDED(hr)) {

                        break;

                    } else {

                        (*ppFilter)->Release();
                        *ppFilter=NULL;
                    }
                }
            }
        }
    }

    return hr;

}


HRESULT
TryCreateCSAFilter(
    IN  GUID   *PermanentGuid,
    OUT IBaseFilter **ppCSAFilter
    )
{
    HRESULT         hr = E_UNEXPECTED;

    if (ppCSAFilter != NULL)
    {
        *ppCSAFilter=NULL;
         hr = FindModemCSA(PermanentGuid,ppCSAFilter);
    }

    return hr;
}





// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\csamsp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by csamsp.rc
//
#define IDS_PROJNAME                    100
#define IDR_WaveMSP                     101
#define IDR_MSPCALL                     102
#define IDR_MSPSTREAM                   103
#define IDR_MSPPropBag                  104
#define IDS_CAPTURE_STREAM              105
#define IDS_RENDER_STREAM               106

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           1000
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\csamsp\csastrm.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    wavestrm.h

Abstract:

    Declaration of the CWaveMSPStream

Author:
    
    Zoltan Szilagyi September 7th, 1998

--*/

#ifndef __WAVESTRM_H_
#define __WAVESTRM_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


/////////////////////////////////////////////////////////////////////////////
// CWaveMSPStream
/////////////////////////////////////////////////////////////////////////////
class CWaveMSPStream : public CMSPStream, public CMSPObjectSafetyImpl
{
public:
// DECLARE_POLY_AGGREGATABLE(CWaveMSP)

// To add extra interfaces to this class, use the following:
BEGIN_COM_MAP(CWaveMSPStream)
    COM_INTERFACE_ENTRY( IObjectSafety )
    COM_INTERFACE_ENTRY_CHAIN(CMSPStream)
END_COM_MAP()

public:

    //
    // Construction and destruction.
    //

    CWaveMSPStream();
    virtual ~CWaveMSPStream();
    virtual void FinalRelease();

    //
    // Required base class overrides.
    // 

    STDMETHOD (get_Name) (
        OUT     BSTR *                  ppName
        );

    //
    // We override these methods to implement our terminal handling.
    // This consists of only allowing one terminal on the stream at a time
    // and adding our filters and the terminal to the graph at the right
    // times.
    //

    STDMETHOD (SelectTerminal) (
        IN      ITTerminal *            pTerminal
        );

    STDMETHOD (UnselectTerminal) (
        IN     ITTerminal *             pTerminal
        );

    STDMETHOD (StartStream) ();

    STDMETHOD (PauseStream) ();

    STDMETHOD (StopStream) ();

    //
    // Overrides for event handling.
    //

    virtual HRESULT ProcessGraphEvent(
        IN  long lEventCode,
        IN  LONG_PTR lParam1,
        IN  LONG_PTR lParam2
        );

    //
    // Public methods specific to our implementation.
    //

    virtual HRESULT SetWaveID(GUID *PermanentGuid);
    virtual HRESULT FireEvent(IN MSP_CALL_EVENT       type,
                              IN HRESULT              hrError,
                              IN MSP_CALL_EVENT_CAUSE cause);

protected:
    //
    // Protected data members.
    //

    BOOL          m_fHaveWaveID;
    BOOL          m_fTerminalConnected;
    IBaseFilter * m_pFilter;
    IBaseFilter * m_pG711Filter;
    FILTER_STATE  m_DesiredGraphState;

private:
    //
    // Private helper methods.
    //

    HRESULT ConnectTerminal(ITTerminal * pTerminal);
    HRESULT ConnectToTerminalPin(IPin * pTerminalPin);
    HRESULT TryToConnect(IPin * pOutputPin, IPin * pInputPin);
    void    CreateAndAddG711(void);

    HRESULT FindPinInFilter(
            BOOL           bWantOutputPin, // IN:  if false, we want the input pin
            IBaseFilter *  pFilter,        // IN:  the filter to examine
            IPin        ** ppPin           // OUT: the pin we found
            );
    HRESULT FindPin(
            IPin ** ppPin
            );
    HRESULT DecideDesiredCaptureBufferSize(IUnknown * pUnknown,
                                           long * plDesiredSize);
    HRESULT SetupWaveIn( IPin * pOutputPin,
                         IPin * pInputPin );
    HRESULT ExamineWaveInProperties(IPin *pPin);
    HRESULT ManipulateAllocatorProperties(IAMBufferNegotiation * pNegotiation,
                                         IMemInputPin          * pMemInputPin);
};

#endif //__WAVEADDR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\filters.inc ===
# DXMRTP=1   Link all binaries into DXMRTP
# DXMRTP=0   Every binary is a separate DLL
DXMRTP=1

!if $(DXMRTP)
C_DEFINES=$(C_DEFINES) \
    -DDXMRTP=1
!endif

# DXMRTP_NOVIDEO=1 Remove video from dxmrtp.dll
# DXMRTP_NOVIDEO=0 Keep video in dxmrtp.dll (default)
DXMRTP_NOVIDEO=0

!if $(DXMRTP_NOVIDEO)
C_DEFINES=$(C_DEFINES) \
    -DDXMRTP_NOVIDEO=1
!endif

# AEC=1   Enable AEC.
# AEC=0   Disable AEC.
AEC=1

!if $(AEC)
C_DEFINES=$(C_DEFINES) \
    -DAEC=1
!endif

# XTRA_TRACE=1   Enable xtra trace options (even in free builds)
# XTRA_TRACE=0   Clean retail build w/o any xtra trace features
XTRA_TRACE=0

!if $(XTRA_TRACE)
C_DEFINES=$(C_DEFINES) \
    -DXTRA_TRACE=1
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\csamsp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__902A4A47_56FA_11D1_8F46_00C04FB6809F__INCLUDED_)
#define AFX_STDAFX_H__902A4A47_56FA_11D1_8F46_00C04FB6809F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <mspbase.h>
#include "common.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // AFX_STDAFX_H__902A4A47_56FA_11D1_8F46_00C04FB6809F__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\csamsp\propbag.h ===
// propbag.h : Declaration of the CMyPropertyBag

#ifndef __CMyPropertyBag_H_
#define __CMyPropertyBag_H_

//
// CMyPropertyBag
class ATL_NO_VTABLE CMyPropertyBag :
	public CComObjectRootEx<CComMultiThreadModel>,
	public IPropertyBag
{
private:
    
    DWORD m_dwDeviceInID;
    DWORD m_dwDeviceOutID;
    
public:

    BEGIN_COM_MAP(CMyPropertyBag)
            COM_INTERFACE_ENTRY(IPropertyBag)
    END_COM_MAP()


    HRESULT
    STDMETHODCALLTYPE
    Read( 
          LPCOLESTR pszPropName,
          VARIANT *pVar,
          IErrorLog *pErrorLog
        )
    {
        if (lstrcmpiW( pszPropName, L"WaveInId" ) == 0)
        {
            pVar->vt = VT_I4;
            pVar->lVal = m_dwDeviceInID;
            return S_OK;
        }

        if (lstrcmpiW( pszPropName, L"WaveOutId" ) == 0)
        {
            pVar->vt = VT_I4;
            pVar->lVal = m_dwDeviceOutID;
            return S_OK;
        }

        return S_FALSE;
    }
        
    HRESULT
    STDMETHODCALLTYPE
    Write( 
           LPCOLESTR pszPropName,
           VARIANT *pVar
         )
    {
        if (lstrcmpiW( pszPropName, L"WaveInId" ) == 0)
        {
            m_dwDeviceInID = pVar->lVal;
            return S_OK;
        }

        if (lstrcmpiW( pszPropName, L"WaveOutId" ) == 0)
        {
            m_dwDeviceOutID = pVar->lVal;
            return S_OK;
        }

        

        return S_FALSE;
        
    };
    
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\dxmrtp\dxmrtp.cpp ===
#if DXMRTP > 0

#include <objbase.h>
#include <windows.h>
#include <winbase.h>
#include <streams.h>

// #include <crtdbg.h>

#include <tapiaud.h>
#include <tapivid.h>
#include <tapirtp.h>
#include <filterid.h>
#include <audtempl.h>
#include <rtptempl.h>
#include <rtpinit.h>
#include <vidctemp.h>
#include <viddtemp.h>
#include <tpdbg.h>

CFactoryTemplate g_Templates[] = 
{
    /* enchdler */
    AUDIO_HANDLER_TEMPLATE_ENCODING
    ,AUDIO_HANDLER_TEMPLATE_DECODING

    /* tpaudcap */
    ,AUDIO_CAPTURE_TEMPLATE
#if AEC
    ,AUDIO_DUPLEX_DEVICE_TEMPLATE
#endif
    /* tpauddec */
    ,AUDIO_DECODE_TEMPLATE

    /* tpaudenc */
    ,AUDIO_ENCODE_TEMPLATE

    /* tpaudren */
    ,AUDIO_RENDER_TEMPLATE

    /* tpaudmix */
    ,AUDIO_MIXER_TEMPLATE

    /* tapih26x */
    /* NA */

#if defined(i386) && (DXMRTP_NOVIDEO == 0)
    /* tapivcap */
    ,VIDEO_CAPTURE_TEMPLATE
    
#ifdef USE_PROPERTY_PAGES
    /* Begin properties */

#ifdef USE_SOFTWARE_CAMERA_CONTROL
    ,CAPCAMERA_CONTROL_TEMPLATE
#endif
    
#ifdef USE_NETWORK_STATISTICS
    ,NETWORK_STATISTICS_TEMPLATE
#endif
    
#ifdef USE_PROGRESSIVE_REFINEMENT
    ,CAPTURE_PIN_TEMPLATE
#endif
    
    ,CAPTURE_PIN_PROP_TEMPLATE
    ,PREVIEW_PIN_TEMPLATE
    ,CAPTURE_DEV_PROP_TEMPLATE
    
#ifdef USE_CPU_CONTROL
    ,CPU_CONTROL_TEMPLATE
#endif
    
    ,RTP_PD_PROP_TEMPLATE
    
    /* End properties */
#endif /* USE_PROPERTY_PAGES */

    /* tapivdec */
    ,VIDEO_DECODER_TEMPLATE

#ifdef USE_PROPERTY_PAGES
/* Begin properties */

    ,INPUT_PIN_PROP_TEMPLATE

    ,OUTPUT_PIN_PROP_TEMPLATE

#ifdef USE_CAMERA_CONTROL
    ,DECCAMERA_CONTROL_TEMPLATE
#endif

#ifdef USE_VIDEO_PROCAMP
    ,VIDEO_SETTING_PROP_TEMPLATE
#endif

/* End properties */
#endif /* USE_PROPERTY_PAGES */

#endif //defined(i386) && (DXMRTP_NOVIDEO == 0)

    ,RTP_SOURCE_TEMPLATE

    ,RTP_RENDER_TEMPLATE
};

int g_cTemplates = (sizeof(g_Templates)/sizeof(g_Templates[0]));

//
// Register with Amovie's helper functions.
//
STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2( TRUE );

}

STDAPI DllUnregisterServer()
{
    return AMovieDllRegisterServer2( FALSE );

} 

/*********************************************************************
 * Entry point
 *********************************************************************/

extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE, ULONG, LPVOID);

BOOL WINAPI DllMain(
        HINSTANCE        hInstance,
        ULONG            ulReason,
        LPVOID           pv
    )
{
    BOOL             res;
    HRESULT          hr;

/*
    if (ulReason == DLL_PROCESS_ATTACH)
    {
        _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
    }
*/

#if defined(i386) && (DXMRTP_NOVIDEO == 0)
    if (!VideoInit(ulReason))
        return FALSE;
#endif

    if (ulReason == DLL_PROCESS_ATTACH)
    {
        AudInit();
        
        hr = MSRtpInit1(hInstance);

        if (FAILED(hr))
        {
            AudDeinit();

            res = FALSE;

            goto end;
        }
    }
    
    res = DllEntryPoint(hInstance, ulReason, pv);

    if (ulReason == DLL_PROCESS_DETACH)
    {
/*
        _RPT0( _CRT_WARN, "Going to call dump memory leaks.\n");
        _CrtDumpMemoryLeaks();
*/
        AudDeinit();
        
        hr = MSRtpDelete1();

        if (FAILED(hr))
        {
            res = FALSE;

            goto end;
        }
    }

 end:
    return(res);
}

#endif /* DXMRTP > 0 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\inc\audtempl.h ===
#ifndef _audio_template_h_
#define _audio_template_h_

/**********************************************************************
 * enchdler
 **********************************************************************/
extern CUnknown*
CALLBACK
CreateEncodingHandlerInstance(
    IN LPUNKNOWN pIUnknownOuter,
    OUT HRESULT* phr
    );

#define AUDIO_HANDLER_TEMPLATE_ENCODING \
{ \
    L"codec handler", \
    &__uuidof(TAPI_ENCODING_HANDLER), \
    CreateEncodingHandlerInstance, \
    NULL, \
    NULL \
}

extern CUnknown*
CALLBACK
CreateDecodingHandlerInstance(
    IN LPUNKNOWN pIUnknownOuter,
    OUT HRESULT* phr
    );

#define AUDIO_HANDLER_TEMPLATE_DECODING \
{ \
    L"DecodingHandler", \
    &__uuidof(TAPI_DECODING_HANDLER), \
    CreateDecodingHandlerInstance, \
    NULL, \
    NULL \
}

/**********************************************************************
 * tpaudcap
 **********************************************************************/

extern CUnknown*
CALLBACK
CreateAudioCaptureInstance(
    IN LPUNKNOWN pIUnknownOuter,
    OUT HRESULT* phr
    );


#ifdef USE_GRAPHEDT
extern const AMOVIESETUP_FILTER sudAudCap;

#define AUDIO_CAPTURE_TEMPLATE \
{ \
    L"Tapi Audio Capture Filter", \
    &__uuidof(TAPIAudioCapture), \
    CreateAudioCaptureInstance, \
    NULL, \
    &sudAudCap \
}
#else /* USE_GRAPHEDT */
#define AUDIO_CAPTURE_TEMPLATE \
{ \
    L"Tapi Audio Capture Filter", \
    &__uuidof(TAPIAudioCapture), \
    CreateAudioCaptureInstance, \
    NULL, \
    NULL \
}
#endif /* USE_GRAPHEDT */

#if AEC

extern CUnknown*
CALLBACK
CreateDuplexControllerInstance(
    IN LPUNKNOWN pIUnknownOuter,
    OUT HRESULT* phr
    );


#define AUDIO_DUPLEX_DEVICE_TEMPLATE \
{ \
    L"TAPI audio duplex device controller", \
    &__uuidof(TAPIAudioDuplexController), \
    CreateDuplexControllerInstance, \
    NULL, \
    NULL \
}
#endif /* AEC */

/**********************************************************************
 * tpauddec
 **********************************************************************/
extern CUnknown*
CALLBACK
CreateAudioDecoderInstance(
    IN LPUNKNOWN pIUnknownOuter,
    OUT HRESULT* phr
    );

#ifdef USE_GRAPHEDT
extern const AMOVIESETUP_FILTER sudAudDec;

#define AUDIO_DECODE_TEMPLATE \
{ \
    L"Tapi Audio Decode Filter", \
    &__uuidof(TAPIAudioDecoder), \
    CreateAudioDecoderInstance, \
    NULL, \
    &sudAudDec \
}
#else /* USE_GRAPHEDT */
#define AUDIO_DECODE_TEMPLATE \
{ \
    L"Tapi Audio Decode Filter", \
    &__uuidof(TAPIAudioDecoder), \
    CreateAudioDecoderInstance, \
    NULL, \
    NULL \
}
#endif /* USE_GRAPHEDT */

/**********************************************************************
 * tpaudenc
 **********************************************************************/
extern CUnknown*
CALLBACK
CreateAudioEncoderInstance(
    IN LPUNKNOWN pIUnknownOuter,
    OUT HRESULT* phr
    );

#ifdef USE_GRAPHEDT
extern const AMOVIESETUP_FILTER sudAudEnc;

#define AUDIO_ENCODE_TEMPLATE \
{ \
    L"Tapi Audio Encoder Filter", \
    &__uuidof(TAPIAudioEncoder), \
    CreateAudioEncoderInstance, \
    NULL, \
    &sudAudEnc \
}
#else /* USE_GRAPHEDT */
#define AUDIO_ENCODE_TEMPLATE \
{ \
    L"Tapi Audio Encoder Filter", \
    &__uuidof(TAPIAudioEncoder), \
    CreateAudioEncoderInstance, \
    NULL, \
    NULL \
}
#endif /* USE_GRAPHEDT */

/**********************************************************************
 * tpaudren
 **********************************************************************/
extern CUnknown*
CALLBACK
CreateAudioRenderInstance(
    IN LPUNKNOWN pIUnknownOuter,
    OUT HRESULT* phr
    );

#ifdef USE_GRAPHEDT
extern const AMOVIESETUP_FILTER sudAudRen;

#define AUDIO_RENDER_TEMPLATE \
{ \
    L"Tapi Audio Render Filter", \
    &__uuidof(TAPIAudioRender), \
    CreateAudioRenderInstance, \
    NULL, \
    &sudAudRen \
}
#else /* USE_GRAPHEDT */
#define AUDIO_RENDER_TEMPLATE \
{ \
    L"Tapi Audio Render Filter", \
    &__uuidof(TAPIAudioRender), \
    CreateAudioRenderInstance, \
    NULL, \
    NULL \
}
#endif /* USE_GRAPHEDT */

/**********************************************************************
 * tpaudmix
 **********************************************************************/
extern CUnknown*
CALLBACK
CreateAudioMixerInstance(
    IN LPUNKNOWN pIUnknownOuter,
    OUT HRESULT* phr
    );

#ifdef USE_GRAPHEDT
extern const AMOVIESETUP_FILTER sudAudMix;

#define AUDIO_MIXER_TEMPLATE \
{ \
    L"Tapi Audio Mixer Filter", \
    &__uuidof(TAPIAudioMixer), \
    CreateAudioMixerInstance, \
    NULL, \
    &sudAudMix \
}
#else /* USE_GRAPHEDT */
#define AUDIO_MIXER_TEMPLATE \
{ \
    L"Tapi Audio Mixer Filter", \
    &__uuidof(TAPIAudioMixer), \
    CreateAudioMixerInstance, \
    NULL, \
    NULL \
}
#endif /* USE_GRAPHEDT */

#endif /* _audio_template_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\inc\rtptempl.h ===
#ifndef _rtp_template_h_
#define _rtp_template_h_

#if USE_GRAPHEDT > 0
#define SOURCE_INFO &g_RtpSourceFilter
#define RENDER_INFO &g_RtpRenderFilter
#else
#define SOURCE_INFO NULL
#define RENDER_INFO NULL
#endif

/* RTP Source */
extern const AMOVIESETUP_FILTER g_RtpSourceFilter;
extern CUnknown *CRtpSourceFilterCreateInstance(LPUNKNOWN pUnk, HRESULT *phr);
#define RTP_SOURCE_TEMPLATE \
{ \
    L"Tapi RTP Source Filter", \
    &__uuidof(MSRTPSourceFilter), \
    CRtpSourceFilterCreateInstance, \
    NULL, \
    SOURCE_INFO \
}

/* RTP Render */
extern const AMOVIESETUP_FILTER g_RtpRenderFilter;
extern CUnknown *CRtpRenderFilterCreateInstance(LPUNKNOWN pUnk, HRESULT *phr);
#define RTP_RENDER_TEMPLATE \
{ \
    L"Tapi RTP Render Filter", \
    &__uuidof(MSRTPRenderFilter), \
    CRtpRenderFilterCreateInstance, \
    NULL, \
    RENDER_INFO \
}

#endif /* _rtp_template_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\inc\rtpinit.h ===
#ifndef _rtp_init_h_
#define _rtp_init_h_

#if defined(_DSRTP_)
/* The API functions are linked as a library with DShow RTP */
#define RTPSTDAPI HRESULT
#else
/* The API functions are in separate dll (not COM, not DShow) */
#define RTPSTDAPI __declspec (dllexport) HRESULT WINAPI
#endif

#if defined(__cplusplus)
extern "C" {
#endif  // (__cplusplus)
#if 0
}
#endif

/*
 * Initializes all the modules that require initialization. This
 * function can be called from DllMain(PROCESS_ATTACH) if linked as a
 * DLL, or explicitly from an application initializing the RTP stack
 * if linked as a library. */
RTPSTDAPI MSRtpInit1(HINSTANCE hInstance);

/*
 * Complementary function of MSRtpInit(). Can be called from
 * DllMain(PROCESS_DETACH) if linked as a DLL, or explicitly from an
 * application de-initializing the RTP stack if linked as a
 * library. */
RTPSTDAPI MSRtpDelete1(void);

/*
 * This functions does initialization not allowed during process
 * attach, e.g. initialize winsock2 */
RTPSTDAPI MSRtpInit2(void);

/*
 * Complementary function of MSRtpInit2(). */
RTPSTDAPI MSRtpDelete2(void);

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif /* _rtp_init_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\inc\filterid.h ===
#ifndef _filterid_h_
#define _filterid_h_

// 
// This file defines guids shared among filters.
//

/**********************************************************************
 * object GUIDs
 **********************************************************************/

// {1dcd0710-0b41-11d3-a565-00c04f8ef6e3} 
struct DECLSPEC_UUID("1dcd0710-0b41-11d3-a565-00c04f8ef6e3") TAPI_ENCODING_HANDLER;
#define CLSID_TAPI_ENCODING_HANDLER (__uuidof(TAPI_ENCODING_HANDLER))

struct DECLSPEC_UUID("1dcd0711-0b41-11d3-a565-00c04f8ef6e3") TAPI_DECODING_HANDLER;
#define CLSID_TAPI_DECODING_HANDLER (__uuidof(TAPI_DECODING_HANDLER))


/**********************************************************************
 * Media types GUIDs
 **********************************************************************/

/* {14099BC0-787B-11d0-9CD3-00A0C9081C19} */
// DEFINE_GUID(MEDIATYPE_RTP_Single_Stream, 
// 0x14099bc0, 0x787b, 0x11d0, 0x9c, 0xd3, 0x0, 0xa0, 0xc9, 0x8, 0x1c, 0x19);
struct DECLSPEC_UUID("14099BC0-787B-11d0-9CD3-00A0C9081C19") _MEDIATYPE_RTP_Single_Stream;
#define MEDIATYPE_RTP_Single_Stream (__uuidof(_MEDIATYPE_RTP_Single_Stream))

// DEFINE_GUID(MEDIASUBTYPE_H263_V1,
// 0x3336324DL, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71);
struct DECLSPEC_UUID("3336324D-0000-0010-8000-00AA00389B71") _MEDIASUBTYPE_H263_V1;
#define MEDIASUBTYPE_H263_V1 (__uuidof(_MEDIASUBTYPE_H263_V1))


// DEFINE_GUID(MEDIASUBTYPE_H261,
// 0x3136324DL, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71);
struct DECLSPEC_UUID("3136324D-0000-0010-8000-00AA00389B71") _MEDIASUBTYPE_H261;
#define MEDIASUBTYPE_H261 (__uuidof(_MEDIASUBTYPE_H261))

// DEFINE_GUID(MEDIASUBTYPE_H263_V2,
// 0x3336324EL, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71);
struct DECLSPEC_UUID("3336324e-0000-0010-8000-00AA00389B71") _MEDIASUBTYPE_H263_V2;
#define MEDIASUBTYPE_H263_V2 (__uuidof(_MEDIASUBTYPE_H263_V2))

// RTP packetization descriptor pin GUID
struct DECLSPEC_UUID("9e2fb490-2051-46cd-b9f0-063307996935") _KSDATAFORMAT_TYPE_RTP_PD;
#define KSDATAFORMAT_TYPE_RTP_PD (__uuidof(_KSDATAFORMAT_TYPE_RTP_PD))

// Undefined DDraw formats
// DEFINE_GUID(MEDIASUBTYPE_I420,
// 0x30323449L, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71);
struct DECLSPEC_UUID("30323449-0000-0010-8000-00AA00389B71") _MEDIASUBTYPE_I420;
#define MEDIASUBTYPE_I420 (__uuidof(_MEDIASUBTYPE_I420))

/**********************************************************************
 * Property page GUIDs
 **********************************************************************/


#ifdef USE_PROPERTY_PAGES

// Capture pin property page CLSID
struct DECLSPEC_UUID("efc975b3-9c92-4ebb-b966-4e861aedd897") CapturePropertyPage;

// Preview pin property page CLSID
struct DECLSPEC_UUID("5cfcacbd-0e35-47d5-9e07-a4c8c4f12145") PreviewPropertyPage;

// Capture device property page CLSID
struct DECLSPEC_UUID("cc73d6f6-93a8-4a56-91f7-be1e272212a6") CaptureDevicePropertyPage;

// Rtp Pd pin property page CLSID
struct DECLSPEC_UUID("be24891b-ebe5-43a2-a18b-1299104157d9") RtpPdPropertyPage;

#ifdef USE_CPU_CONTROL
// CPU Control property page CLSID
struct DECLSPEC_UUID("a485a8e8-55d4-4ebc-9221-5564117d15c9") CPUCPropertyPage;
#endif

#ifdef USE_PROGRESSIVE_REFINEMENT
// Progressive refinement property page CLSID
struct DECLSPEC_UUID("9a80c9de-24f1-4f28-9b5c-2746573c8c7e") ProgRefPropertyPage;
#endif

#ifdef USE_SOFTWARE_CAMERA_CONTROL
// Camera control property page CLSID
struct DECLSPEC_UUID("78a22d55-3519-4ed4-b204-d6e1a9dcdb4b") TAPICameraControlPropertyPage;
#endif

// Video proc amp property page CLSID
struct DECLSPEC_UUID("b6787f6b-1e36-489a-9460-d59b9ac40199") TAPIProcAmpPropertyPage;

#ifdef USE_NETWORK_STATISTICS
// Network statistics property page CLSID
struct DECLSPEC_UUID("b62b51ba-53ff-4d58-9b29-f134e41b9a73") NetworkStatsPropertyPage;
#endif

// Video decoder input pin property page CLSID
struct DECLSPEC_UUID("fe8877d2-eb94-4d85-ae07-f450f3d2e50a") TAPIVDecInputPinPropertyPage;

// Video decoder output pin property page CLSID
struct DECLSPEC_UUID("58336f1b-42c6-494b-9601-5830ec502500") TAPIVDecOutputPinPropertyPage;

#ifdef USE_CAMERA_CONTROL
// Camera control property page CLSID
struct DECLSPEC_UUID("f6890a20-e6b5-4aa5-8817-796c7027418f") TAPICameraControlPropertyPage;
#endif

#ifdef USE_VIDEO_PROCAMP
// Video proc amp property page CLSID
struct DECLSPEC_UUID("7e38868e-824b-465f-9b67-5524efb4a62a") TAPIProcAmpPropertyPage;
#endif

#endif // USE_PROPERTY_PAGES


/* {14099BC1-787B-11d0-9CD3-00A0C9081C19} */
struct DECLSPEC_UUID("14099bc1-787b-11d0-9cd3-00a0c9081c19") _MEDIATYPE_RTP_Multiple_Stream;
#define MEDIATYPE_RTP_Multiple_Stream (__uuidof(_MEDIATYPE_RTP_Multiple_Stream))

struct DECLSPEC_UUID("14099bc2-787b-11d0-9cd3-00a0c9081c19") _MEDIASUBTYPE_RTP_Payload_Mixed;
#define MEDIASUBTYPE_RTP_Payload_Mixed (__uuidof(_MEDIASUBTYPE_RTP_Payload_Mixed))

/* {14099BC3-787B-11d0-9CD3-00A0C9081C19} */
struct DECLSPEC_UUID("14099bc3-787b-11d0-9cd3-00a0c9081c19") _MEDIASUBTYPE_RTP_Payload_G711U;
#define MEDIASUBTYPE_RTP_Payload_G711U (__uuidof(_MEDIASUBTYPE_RTP_Payload_G711U))

/* {14099BC4-787B-11d0-9CD3-00A0C9081C19} */
struct DECLSPEC_UUID("14099bc4-787b-11d0-9cd3-00a0c9081c19") _MEDIASUBTYPE_RTP_Payload_G711A;
#define MEDIASUBTYPE_RTP_Payload_G711A (__uuidof(_MEDIASUBTYPE_RTP_Payload_G711A))

/* {14099BC5-787B-11d0-9CD3-00A0C9081C19} */
struct DECLSPEC_UUID("14099bc5-787b-11d0-9cd3-00a0c9081c19") _MEDIASUBTYPE_RTP_Payload_G723;
#define MEDIASUBTYPE_RTP_Payload_G723 (__uuidof(_MEDIASUBTYPE_RTP_Payload_G723))

/* {14099BC6-787B-11d0-9CD3-00A0C9081C19} */
struct DECLSPEC_UUID("14099bc6-787b-11d0-9cd3-00a0c9081c19") _MEDIASUBTYPE_RTP_Payload_H261;
#define MEDIASUBTYPE_RTP_Payload_H261 (__uuidof(_MEDIASUBTYPE_RTP_Payload_H261))

/* {14099BC7-787B-11d0-9CD3-00A0C9081C19} */
struct DECLSPEC_UUID("14099bc7-787b-11d0-9cd3-00a0c9081c19") _MEDIASUBTYPE_RTP_Payload_H263;
#define MEDIASUBTYPE_RTP_Payload_H263 (__uuidof(_MEDIASUBTYPE_RTP_Payload_H263))

/* {14099BCA-787B-11d0-9CD3-00A0C9081C19} */
struct DECLSPEC_UUID("14099bc8-787b-11d0-9cd3-00a0c9081c19") _MEDIASUBTYPE_RTP_Payload_ANY;
#define MEDIASUBTYPE_RTP_Payload_ANY (__uuidof(_MEDIASUBTYPE_RTP_Payload_ANY))

/* {33363248-0000-0010-8000-00AA00389B71} */
struct DECLSPEC_UUID("33363248-0000-0010-8000-00aa00389b71") _MEDIASUBTYPE_H263;
#define MEDIASUBTYPE_H263 (__uuidof(_MEDIASUBTYPE_H263))

/* {14099BC8-787B-11d0-9CD3-00A0C9081C19} */
struct DECLSPEC_UUID("14099bc8-787b-11d0-9cd3-00a0c9081c19") _MEDIASUBTYPE_H263EX;
#define MEDIASUBTYPE_H263EX (__uuidof(_MEDIASUBTYPE_H263EX))

#if 0
/* {31363248-0000-0010-8000-00AA00389B71} */
struct DECLSPEC_UUID("31363248-0000-0010-8000-00aa00389b71") _MEDIASUBTYPE_H261;
#define MEDIASUBTYPE_H261 (__uuidof(_MEDIASUBTYPE_H261))
#endif

/* {14099BC9-787B-11d0-9CD3-00A0C9081C19} */
struct DECLSPEC_UUID("14099bc9-787b-11d0-9cd3-00a0c9081c19") _MEDIASUBTYPE_H261EX;
#define MEDIASUBTYPE_H261EX (__uuidof(_MEDIASUBTYPE_H261EX))


#endif /* _filterid_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\inc\tpdbg.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    tpdbg.h
 *
 *  Abstract:
 *
 *    Some debuging support for TAPI filters
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    2000/08/31 created
 *
 **********************************************************************/
#ifndef _tpdbg_h_
#define _tpdbg_h_

#if defined(__cplusplus)
extern "C" {
#endif  /* (__cplusplus) */
#if 0
}
#endif

#define AUDTAG_FIRST                    0x00  /*  0 */
#define AUDTAG_AUDENCHANDLER            0x01  /*  1 */
#define AUDTAG_AUDCAPINPIN              0x02  /*  2 */
#define AUDTAG_AUDCAPOUTPIN             0x03  /*  3 */
#define AUDTAG_AUDCAPFILTER             0x04  /*  4 */
#define AUDTAG_AUDCAPDUPLEXCONTROLLER   0x05  /*  5 */
#define AUDTAG_AUDCAPDSOUNDCAPTURE      0x06  /*  6 */
#define AUDTAG_AUDCAPDTMFCONTROL        0x07  /*  7 */
#define AUDTAG_AUDWAVEINCAPTURE         0x08  /*  8 */
#define AUDTAG_AUDDECINPIN              0x09  /*  9 */
#define AUDTAG_AUDDECOUTPIN             0x0A  /* 10 */
#define AUDTAG_AUDDECFILTER             0x0B  /* 11 */
#define AUDTAG_AUDENCINPIN              0x0C  /* 12 */
#define AUDTAG_AUDENCOUTPIN             0x0D  /* 13 */
#define AUDTAG_AUDENCFILTER             0x0E  /* 14 */
#define AUDTAG_AUDMIXINPIN              0x0F  /* 15 */
#define AUDTAG_AUDMIXOUTPIN             0x10  /* 16 */
#define AUDTAG_AUDMIXFILTER             0x11  /* 17 */
#define AUDTAG_AUDRENINPIN              0x12  /* 18 */
#define AUDTAG_AUDRENFILTER             0x13  /* 19 */
#define AUDTAG_AUDMIXCHANEL             0x14  /* 20 */
#define AUDTAG_AUDDSOUNDREND            0x15  /* 21 */
#define AUDTAG_LAST                     0x16  /* 22 */

#define AUDOBJECTID_B2B1       0x005bb500

#define BUILD_OBJECTID(t)       (((t) << 24) | AUDOBJECTID_B2B1 | t)
#define INVALIDATE_OBJECTID(oi) (oi &= ~0xff)

#define OBJECTID_AUDENCHANDLER          BUILD_OBJECTID(AUDTAG_AUDENCHANDLER)
#define OBJECTID_AUDCAPINPIN            BUILD_OBJECTID(AUDTAG_AUDCAPINPIN)
#define OBJECTID_AUDCAPOUTPIN           BUILD_OBJECTID(AUDTAG_AUDCAPOUTPIN)
#define OBJECTID_AUDCAPFILTER           BUILD_OBJECTID(AUDTAG_AUDCAPFILTER)
#define OBJECTID_AUDCAPDUPLEXCONTROLLER BUILD_OBJECTID(AUDTAG_AUDCAPDUPLEXCONTROLLER)
#define OBJECTID_AUDCAPDSOUNDCAPTURE    BUILD_OBJECTID(AUDTAG_AUDCAPDSOUNDCAPTURE)
#define OBJECTID_AUDCAPDTMFCONTROL      BUILD_OBJECTID(AUDTAG_AUDCAPDTMFCONTROL)
#define OBJECTID_AUDWAVEINCAPTURE       BUILD_OBJECTID(AUDTAG_AUDWAVEINCAPTURE)
#define OBJECTID_AUDDECINPIN            BUILD_OBJECTID(AUDTAG_AUDDECINPIN)
#define OBJECTID_AUDDECOUTPIN           BUILD_OBJECTID(AUDTAG_AUDDECOUTPIN)
#define OBJECTID_AUDDECFILTER           BUILD_OBJECTID(AUDTAG_AUDDECFILTER)
#define OBJECTID_AUDENCINPIN            BUILD_OBJECTID(AUDTAG_AUDENCINPIN)
#define OBJECTID_AUDENCOUTPIN           BUILD_OBJECTID(AUDTAG_AUDENCOUTPIN)
#define OBJECTID_AUDENCFILTER           BUILD_OBJECTID(AUDTAG_AUDENCFILTER)
#define OBJECTID_AUDMIXINPIN            BUILD_OBJECTID(AUDTAG_AUDMIXINPIN)
#define OBJECTID_AUDMIXOUTPIN           BUILD_OBJECTID(AUDTAG_AUDMIXOUTPIN)
#define OBJECTID_AUDMIXFILTER           BUILD_OBJECTID(AUDTAG_AUDMIXFILTER)
#define OBJECTID_AUDRENINPIN            BUILD_OBJECTID(AUDTAG_AUDRENINPIN)
#define OBJECTID_AUDRENFILTER           BUILD_OBJECTID(AUDTAG_AUDRENFILTER)
#define OBJECTID_AUDMIXCHANEL           BUILD_OBJECTID(AUDTAG_AUDMIXCHANEL)
#define OBJECTID_AUDDSOUNDREND          BUILD_OBJECTID(AUDTAG_AUDDSOUNDREND)

typedef struct _QueueItem_t QueueItem_t;
typedef struct _Queue_t     Queue_t;

/*
 * Every object maintained in a queue or a queue/hash will include
 * this structure */
typedef struct _QueueItem_t {
    struct _QueueItem_t *pNext; /* next item */
    struct _QueueItem_t *pPrev; /* previous item */
    struct _Queue_t     *pHead; /* used for robustness, points to
                                    * queue's head */
    /* The next field is used at the programer's discretion. Can be
     * used to point back to the parent object, or as a key during
     * searches, it is the programer's responsibility to set this
     * value, it is not used by the queue/hash functions (except
     * the "Ordered queue insertion" functions) */
    union {
        void  *pvOther;        /* may be used as a general purpose ptr */
        double dKey;           /* may be used as a double key for searches */
        DWORD  dwKey;          /* may be used as DWORD key for searches */
    };
} QueueItem_t;

/*
 * !!! WARNING !!!
 *
 * RtpQueue_t and RtpQueueHash can be casted to each other.
 *
 * A negative count indicates pFirst (or indeed pvTable) is a hash
 * table. This is safe because a hash is destroyed when it has zero
 * elements (becoming a regular queue) and won't be expanded to a hash
 * again but until MAX_QUEUE2HASH_ITEMS items are enqueued */

/*
 * The owner of a queue will include this structure */
typedef struct _Queue_t {
    QueueItem_t         *pFirst;   /* points to first item */
    long                 lCount;   /* number of items in queue (positive) */
} Queue_t;

typedef struct _AudCritSect_t {
    BOOL              bInitOk;
    CRITICAL_SECTION  CritSect;/* critical section */
} AudCritSect_t;

void AudInit();

void AudDeinit();

void AudObjEnqueue(QueueItem_t *pQueueItem, DWORD dwObjectID);

void AudObjDequeue(QueueItem_t *pQueueItem);

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  /* (__cplusplus) */

#endif /* _tpdbg_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\inc\tptrace.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name

    tptrace.h

Description

    Defines functions used for tracing for all the TAPI filters.

Note

    Revised based on msplog.h by

    MU Han (muhan) Apr 17 2000

--*/

#ifndef __TPTRACE_H
#define __TPTRACE_H

#ifdef DBG

#if defined(__cplusplus)
extern "C" {
#endif  // (__cplusplus)

double RtpGetTimeOfDay(void *);

#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif

#ifdef DBG

#include <rtutils.h>
#define FAIL ((DWORD)0x00010000 | TRACE_USE_MASK)
#define WARN ((DWORD)0x00020000 | TRACE_USE_MASK)
#define INFO ((DWORD)0x00040000 | TRACE_USE_MASK)
#define TRCE ((DWORD)0x00080000 | TRACE_USE_MASK)
#define ELSE ((DWORD)0x00100000 | TRACE_USE_MASK)



void DBGPrint(DWORD dwTraceID, DWORD dwDbgLevel, LPCSTR lpszFormat, IN ...);
#define DBGOUT(arg) DBGPrint arg

#define ENTER_FUNCTION(s) static char *__fxName = s

#else

#define DBGOUT(arg)
#define ENTER_FUNCTION(s)

#endif // DBG


#endif // _TPTRACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\inc\rtphdr.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtphdr.h
 *
 *  Abstract:
 *
 *    Defines only the RTP/RTCP specific headers
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/18 created
 *
 **********************************************************************/

#ifndef _rtphdr_h_
#define _rtphdr_h_

/*
 * !!! WARNING !!!
 *
 * Diagrams below are in NETWORK order (big endian) which is different
 * from x86 (little endian).
 *
 * All fields are data coming/goin from/to the network, hence they are
 * received/sent in NETWORK order
 * */

/*
 * Current protocol version.
 * */
#define RTP_VERSION    2

#define RTP_SEQ_MOD    (1<<16)
#define RTP_MAX_SDES   255      /* maximum text length for SDES */

#define MAX_RTCP_RBLOCKS 31     /* 5 bits */

#define NO_PAYLOADTYPE 255
#define NO_SSRC        ~0
#define NO_FREQUENCY   ~0


/**********************************************************************
 * RTP data header.
 **********************************************************************
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=2|P|X|  CC   |M|     PT      |       sequence number         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           timestamp                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           synchronization source (SSRC) identifier            |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |            contributing source (CSRC) identifiers             |
   |                             ....                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   
*/
typedef struct _RtpHdr_t {
    WORD cc      : 4; /* CSRC count */
    WORD x       : 1; /* header extension flag */
    WORD p       : 1; /* padding flag */
    WORD version : 2; /* protocol version */
    
    WORD pt      : 7; /* payload type */
    WORD m       : 1; /* marker bit */
    
    WORD seq;         /* sequence number */

    DWORD ts;         /* timestamp */
    
    DWORD ssrc;       /* synchronization source */
} RtpHdr_t;

/**********************************************************************
 * RTP Header Extension
 **********************************************************************

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      defined by profile       |           length              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        header extension                       |
   |                             ....                              |
*/

typedef struct _RtpHdrExt_t {
    WORD             exttype;
    WORD             length;  /* number of 32-bit words in the
                               * extension, excluding the four-octet
                               * extension header */
} RtpHdrExt_t;

/**********************************************************************
 * RTCP common header word.
 **********************************************************************
     0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=2|P|    RC   |      PT       |             length            | header
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

*/

/*
 * RTCP packets's payload type (pt) field
 * */
enum {
    RTCP_SR   = 200,
    RTCP_RR   = 201,
    RTCP_SDES = 202,
    RTCP_BYE  = 203,
    RTCP_APP  = 204
};

/*
 * RTCP common header
 * */
typedef struct _RtcpCommon_t {
    BYTE count   : 5; /* varies by packet type */
    BYTE p       : 1; /* padding flag */
    BYTE version : 2; /* protocol version */
    
    BYTE pt;          /* RTCP packet type */
    
    WORD length;      /* packet len in 32-bit words, w/o this word */
} RtcpCommon_t;

/*
 * Network order (big-endian) mask for version, padding bit and packet
 * type pair on a little endian processor
 * */
#define RTCP_VALID_MASK   (0xc0 | 0x20 | 0xfe00)
#define RTCP_VALID_VALUE  ((RTP_VERSION << 6) | (RTCP_SR << 8))

/**********************************************************************
 * RTPC receiver report (RR) header.
 **********************************************************************

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=2|P|    RC   |   PT=RR=201   |             length            | header
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     SSRC of packet sender                     |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |                 SSRC_1 (SSRC of first source)                 | report
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ block
   | fraction lost |       cumulative number of packets lost       |   1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           extended highest sequence number received           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      interarrival jitter                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         last SR (LSR)                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                   delay since last SR (DLSR)                  |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |                 SSRC_2 (SSRC of second source)                | report
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ block
   :                               ...                             :   2
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |                  profile-specific extensions                  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*/

/*
 * Reception report block
 * */
typedef struct _RtcpRBlock_t {
    DWORD ssrc;             /* data source being reported */
    
    DWORD frac_cumlost;     /* fraction lost since last SR/RR and
                             * cumulative number of packets lost
                             * (signed!) (in NETWORK order, fraction =
                             * higher 8 bits, lost = 24 lower bits) */
    
    DWORD last_seq;         /* extended last seq. no. received */
    DWORD jitter;           /* interarrival jitter */
    DWORD lsr;              /* last SR packet from this source (low 16
                             * bits of integer part and high 16 bits
                             * of fraction) */
    DWORD dlsr;             /* delay since last SR packet (16 bits for
                             * integer part and 16 bits for fraction) */
} RtcpRBlock_t;

/**********************************************************************
 * RTPC sender report (SR) header.
 **********************************************************************
 
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=2|P|    RC   |   PT=SR=200   |             length            | header
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         SSRC of sender                        |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |              NTP timestamp, most significant word             | sender
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ info
   |             NTP timestamp, least significant word             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         RTP timestamp                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     sender's packet count                     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      sender's octet count                     |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |                 SSRC_1 (SSRC of first source)                 | report
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ block
   | fraction lost |       cumulative number of packets lost       |   1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           extended highest sequence number received           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      interarrival jitter                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         last SR (LSR)                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                   delay since last SR (DLSR)                  |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |                 SSRC_2 (SSRC of second source)                | report
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ block
   :                               ...                             :   2
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |                  profile-specific extensions                  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

*/

/*
 * sender information
 * */
typedef struct _RtcpSInfo_t {
    DWORD ntp_sec;  /* NTP timestamp (seconds)*/
    DWORD ntp_frac; /* NTP timestamp (fraction) */
    DWORD rtp_ts;   /* RTP timestamp */
    DWORD psent;    /* packets sent */
    DWORD bsent;    /* bytes sent */
} RtcpSInfo_t;

/**********************************************************************
 * RTCP SDES
 **********************************************************************

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=2|P|    SC   |  PT=SDES=202  |             length            | header
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |                          SSRC/CSRC_1                          | chunk
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   1
   |                           SDES items                          |
   |                              ...                              |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |                          SSRC/CSRC_2                          | chunk
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   2
   |                           SDES items                          |
   |                              ...                              |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
*/

/**********************************************************************
 * SDES items
 **********************************************************************
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    CNAME=1    |     length    | user and domain name         ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     NAME=2    |     length    | common name of source        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    EMAIL=3    |     length    | email address of source      ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    PHONE=4    |     length    | phone number of source       ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     LOC=5     |     length    | geographic location of site  ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     TOOL=6    |     length    | name/version of source appl. ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     NOTE=7    |     length    | note about the source        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     PRIV=8    |     length    | prefix length | prefix string...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ...             |                  value string                ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*/

/*
 * Types of SDES information
 * */
enum {
    RTCP_SDES_END   = 0,
    RTCP_SDES_CNAME = 1,
    RTCP_SDES_NAME  = 2,
    RTCP_SDES_EMAIL = 3,
    RTCP_SDES_PHONE = 4,
    RTCP_SDES_LOC   = 5,
    RTCP_SDES_TOOL  = 6,
    RTCP_SDES_NOTE  = 7,
    RTCP_SDES_PRIV  = 8,
    RTCP_SDES_BYE   = 9, /* Used to save the BYE reason */
    RTCP_SDES_LAST
};

#define RTCP_SDES_FIRST RTCP_SDES_END

#define RTCP_NUM_SDES (RTCP_SDES_LAST - RTCP_SDES_FIRST - 1)
#define RTCP_MAX_SDES_SIZE 256

/*
 * Sdes item
 * */
typedef struct _RtcpSdesItem_t {
    BYTE type;              /* type of item (SDES) */
    BYTE length;            /* length of item (in octets), not
                             * including this two-octet header */
  /*char data[2];              text, not null-terminated */
} RtcpSdesItem_t;

/**********************************************************************
 * BYE
 **********************************************************************
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=2|P|    SC   |   PT=BYE=203  |             length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           SSRC/CSRC                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   :                              ...                              :
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |     length    |               reason for leaving             ... (opt)
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*/

/**********************************************************************
 * DTMF (RFC2833)
 **********************************************************************
 
                     Event  encoding (decimal)
                     _________________________
                     0--9                0--9
                     *                     10
                     #                     11
                     A--D              12--15
                     Flash                 16

                        DTMF named events

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     event     |E|R| volume    |          duration             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*/

typedef struct _RtpDtmfEvent_t {
    BYTE event;       /* Event encoded as shown in rfc2833/3.10 */

    BYTE volume  : 6; /* Tone's volume rfc2833/3.5 */
    BYTE r       : 1; /* Reserved */
    BYTE e       : 1; /* End of the event */

    WORD duration;    /* Duration of this digit in timestamp units */
} RtpDtmfEvent_t;

/**********************************************************************
 * Redundant audio (RFC2198)
 **********************************************************************

 When F=1
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |F|   block PT  |  timestamp offset         |   block length    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

 When F=0
    0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+
   |F|   Block PT  |
   +-+-+-+-+-+-+-+-+

   timestamp offset (14) unsigned (negative) offset of timestamp of
   this block relative to timestamp given in RTP header
   
   block length (10) in bytes of the corresponding data block
   excluding header

*/

typedef struct _RtpRedHdr_t {
    BYTE pt      : 7; /* payload type for this block */
    BYTE F       : 1; /* set to 1 indicates more headers follow, 0 for
                       * final/main */
    BYTE ts_high;     /* 8 msbits of timestamp offset */

    BYTE len_high: 2; /* 2 msbits of length */
    BYTE ts_low  : 6; /* 6 lsbits of timestamp offset */

    BYTE len_low;     /* 8 lsbits of length */
} RtpRedHdr_t;

#define RTP_PLUS_RED_HDR_SIZE (sizeof(RtpHdr_t) + \
                               sizeof(RtpRedHdr_t) * (RTP_RED_MAXRED+1))

#define RedLen(pr) ((DWORD)pr->len_low | (pr->len_high << 8))
#define RedTs(pr)  ((DWORD)pr->ts_low  | (pr->ts_high  << 6))

#define PutRedLen(pr, len) \
        {pr->len_low=(BYTE)((len)&0xff);pr->len_high=(BYTE)(((len)>>8)&0x03);}

#define PutRedTs(pr, ts) \
        {pr->ts_low= (BYTE)((ts)&0x3f); pr->ts_high= (BYTE)(((ts) >>6)&0xff);}

/**********************************************************************
 * Profile Extension header
 **********************************************************************

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |            type               |          length               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*/

typedef struct _RtpPEHdr_t {
    WORD  type; /* Type of profile extension */
    WORD  len;  /* Lenght in bytes for the extension including this
                 * header */
} RtpPEHdr_t;

/* Type of profile extensions supported */
enum {
    RTPPE_FIRST,

    RTPPE_BANDESTIMATION,   /* Bandwidth estimation */
    RTPPE_REDLOSSRATE,      /* Loss rate after packet reconstruction */
    
    RTPPE_LAST
};

typedef struct _RtpBandEst_t {
    WORD  type; /* Type of profile extension */
    WORD  len;  /* Lenght in bytes for the extension including this
                 * header */
    DWORD       dwSSRC;       /* SSRC for whom bandwidth is reported */
    DWORD       dwBandwidth;  /* Bandwidth in Kbps */
} RtpBandEst_t;

#endif /* _rtphdr_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\inc\vidctemp.h ===
#ifndef _vidcap_template_h_
#define _vidcap_template_h_

/**********************************************************************
 * tapih26x
 **********************************************************************/
#if DXMRTP > 0
LRESULT WINAPI H26XDriverProc(
        DWORD            dwDriverID,
        HDRVR            hDriver,
        UINT             uiMessage,
        LPARAM           lParam1,
        LPARAM           lParam2
    );
#endif
/**********************************************************************
 * tapivcap
 **********************************************************************/

extern CUnknown *CALLBACK 
CreateTAPIVCapInstance(IN LPUNKNOWN pUnkOuter, OUT HRESULT *pHr);

#if DXMRTP > 0
BOOL VideoInit(DWORD dwReason);
#endif

#if USE_GRAPHEDT > 0
extern const AMOVIESETUP_FILTER sudVideoCapture;

#define VIDEO_CAPTURE_TEMPLATE \
{ \
    L"TAPI Video Capture", \
    &__uuidof(TAPIVideoCapture), \
    CreateTAPIVCapInstance, \
    NULL, \
    &sudVideoCapture \
}
#else
#define VIDEO_CAPTURE_TEMPLATE \
{ \
    L"TAPI Video Capture", \
    &__uuidof(TAPIVideoCapture), \
    CreateTAPIVCapInstance, \
    NULL, \
    NULL \
}
#endif

#ifdef USE_PROPERTY_PAGES
/* Begin properties */

#ifdef USE_SOFTWARE_CAMERA_CONTROL
extern CUnknown* CALLBACK CCameraControlPropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr);
#define CAPCAMERA_CONTROL_TEMPLATE \
{ \
    L"TAPI Camera Control Property Page", \
    &__uuidof(TAPICameraControlPropertyPage), \
    CCameraControlPropertiesCreateInstance, \
    NULL, \
    NULL \
}
#endif

#ifdef USE_NETWORK_STATISTICS
extern CUnknown* CALLBACK CNetworkStatsPropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr);
#define NETWORK_STATISTICS_TEMPLATE \
{ \
    L"TAPI Network Statistics Property Page", \
    &__uuidof(NetworkStatsPropertyPage), \
    CNetworkStatsPropertiesCreateInstance, \
    NULL, \
    NULL \
}
#endif

#ifdef USE_PROGRESSIVE_REFINEMENT
extern CUnknown* CALLBACK CProgRefPropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr);
#define CAPTURE_PIN_TEMPLATE \
{ \
    L"TAPI Progressive Refinement Property Page", \
    &__uuidof(ProgRefPropertyPage), \
    CProgRefPropertiesCreateInstance, \
    NULL, \
    NULL \
}
#endif

extern CUnknown* CALLBACK CCapturePropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr);
#define CAPTURE_PIN_PROP_TEMPLATE \
{ \
    L"TAPI Capture Pin Property Page", \
    &__uuidof(CapturePropertyPage), \
    CCapturePropertiesCreateInstance, \
    NULL, \
    NULL \
}

extern CUnknown* CALLBACK CPreviewPropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr);
#define PREVIEW_PIN_TEMPLATE \
{ \
    L"TAPI Preview Pin Property Page", \
    &__uuidof(PreviewPropertyPage), \
    CPreviewPropertiesCreateInstance, \
    NULL, \
    NULL \
}

extern CUnknown* CALLBACK CDevicePropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr);
#define CAPTURE_DEV_PROP_TEMPLATE \
{ \
    L"TAPI Capture Device Property Page", \
    &__uuidof(CaptureDevicePropertyPage), \
    CDevicePropertiesCreateInstance, \
    NULL, \
    NULL \
}

#ifdef USE_CPU_CONTROL
extern CUnknown* CALLBACK CCPUCPropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr);
#define CPU_CONTROL_TEMPLATE \
{ \
    L"TAPI CPU Control Property Page", \
    &__uuidof(CPUCPropertyPage), \
    CCPUCPropertiesCreateInstance, \
    NULL, \
    NULL \
}
#endif

extern CUnknown* CALLBACK CRtpPdPropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr);
#define RTP_PD_PROP_TEMPLATE \
{ \
    L"TAPI Rtp Pd Property Page", \
    &__uuidof(RtpPdPropertyPage), \
    CRtpPdPropertiesCreateInstance, \
    NULL, \
    NULL \
}

/* End properties */
#endif /* USE_PROPERTY_PAGES */

#endif /* _vidcap_template_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\inc\viddtemp.h ===
#ifndef _viddec_template_h_
#define _viddec_template_h_

/**********************************************************************
 * tapih26x
 **********************************************************************/
#if DXMRTP > 0
LRESULT WINAPI H26XDriverProc(
        DWORD            dwDriverID,
        HDRVR            hDriver,
        UINT             uiMessage,
        LPARAM           lParam1,
        LPARAM           lParam2
    );
#endif

/**********************************************************************
 * tapivdec
 **********************************************************************/

extern CUnknown *CALLBACK CTAPIVDecCreateInstance(IN LPUNKNOWN pUnkOuter, OUT HRESULT *pHr);

#if USE_GRAPHEDT > 0
extern const AMOVIESETUP_FILTER sudVideoDecoder;
#define VIDEO_DECODER_TEMPLATE \
{ \
    L"TAPI H.26X Video Decoder", \
    &__uuidof(TAPIVideoDecoder), \
    CTAPIVDecCreateInstance, \
    NULL, \
    &sudVideoDecoder \
}
#else
#define VIDEO_DECODER_TEMPLATE \
{ \
    L"TAPI H.26X Video Decoder", \
    &__uuidof(TAPIVideoDecoder), \
    CTAPIVDecCreateInstance, \
    NULL, \
    NULL \
}
#endif

#ifdef USE_PROPERTY_PAGES
/* Begin properties */

extern CUnknown* CALLBACK CInputPinPropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr);
#define INPUT_PIN_PROP_TEMPLATE \
{ \
    L"Input Pin Property Page", \
    &__uuidof(TAPIVDecInputPinPropertyPage), \
    CInputPinPropertiesCreateInstance, \
    NULL, \
    NULL \
}

extern CUnknown* CALLBACK COutputPinPropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr);
#define OUTPUT_PIN_PROP_TEMPLATE \
{ \
    L"Output Pin Property Page", \
    &__uuidof(TAPIVDecOutputPinPropertyPage), \
    COutputPinPropertiesCreateInstance, \
    NULL, \
    NULL \
}

#ifdef USE_CAMERA_CONTROL
extern CUnknown* CALLBACK CCameraControlPropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr);
#define DECCAMERA_CONTROL_TEMPLATE \
{ \
    L"TAPI Camera Control Property Page", \
    &__uuidof(TAPICameraControlPropertyPage), \
    CCameraControlPropertiesCreateInstance, \
    NULL, \
    NULL \
}
#endif

#ifdef USE_VIDEO_PROCAMP
extern CUnknown* CALLBACK CProcAmpPropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr);
#define VIDEO_SETTING_PROP_TEMPLATE \
{ \
    L"TAPI Video Settings Property Page", \
    &__uuidof(TAPIProcAmpPropertyPage), \
    CProcAmpPropertiesCreateInstance, \
    NULL, \
    NULL \
}
#endif

/* End properties */
#endif /* USE_PROPERTY_PAGES */

#endif /* _viddec_template_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\common.inc ===
#**********************************************************************
#*
#*  Copyright (C) Microsoft Corporation, 1999
#*
#*  File name:
#*
#*    common.inc
#*
#*  Abstract:
#*
#*    Common build definitions and libraries
#*
#*  Author:
#*
#*    Andres Vega-Garcia (andresvg)
#*
#*  Revision:
#*
#*    1999/05/20 created
#*
#**********************************************************************
FILTERS=$(RTPROOT)\..
RTPBIN=$(FILTERS)\lib\$(_OBJ_DIR)

!include $(FILTERS)\filters.inc

# MSVCRT.LIB Import library for MSVCRT.DLL, retail version
USE_CRTDLL=1

# Generate map file
USE_MAPSYM=1
BROWSER_INFO=1
USE_ICECAP4=1

!INCLUDE $(RTPROOT)\options.inc

!if !$(FREEBUILD)

#########
# Debug
#########
C_DEFINES=\
    $(C_DEFINES) \
    -DDEBUG=1 \
    -D_DEBUG=1

!endif

!if $(RTPOPT_USE_UNICODE)
C_DEFINES=\
    $(C_DEFINES) \
    -D_UNICODE \
    -DUNICODE
!endif

INCLUDES=\
    $(INCLUDES);\
    $(BASEDIR)\public\sdk\amovie\inc; \
    ..\inc;\
    ..\..\inc;\
    ..\..\..\inc; \
    ..\..\..\..\inc; \
    ..\..\..\..\..\inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\dsrtp\inc\dsrtpid.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    dsrtpid.h
 *
 *  Abstract:
 *
 *    CLSIDs, IIDs and GUIDs
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/17 created
 *
 **********************************************************************/

#ifndef _dsrtpid_h_
#define _dsrtpid_h_

#include <olectl.h>

/**********************************************************************
 * Media types GUIDs
 **********************************************************************/

#if 0 // remove later

/* {14099BC0-787B-11d0-9CD3-00A0C9081C19} */
DEFINE_GUID(MEDIATYPE_RTP_Single_Stream, 
0x14099bc0, 0x787b, 0x11d0, 0x9c, 0xd3, 0x0, 0xa0, 0xc9, 0x8, 0x1c, 0x19);

/* {14099BC1-787B-11d0-9CD3-00A0C9081C19} */
DEFINE_GUID(MEDIATYPE_RTP_Multiple_Stream, 
0x14099bc1, 0x787b, 0x11d0, 0x9c, 0xd3, 0x0, 0xa0, 0xc9, 0x8, 0x1c, 0x19);

/* {14099BC2-787B-11d0-9CD3-00A0C9081C19} */
DEFINE_GUID(MEDIASUBTYPE_RTP_Payload_Mixed, 
0x14099bc2, 0x787b, 0x11d0, 0x9c, 0xd3, 0x0, 0xa0, 0xc9, 0x8, 0x1c, 0x19);



/* {14099BC3-787B-11d0-9CD3-00A0C9081C19} */
DEFINE_GUID(MEDIASUBTYPE_RTP_Payload_G711U, 
0x14099bc3, 0x787b, 0x11d0, 0x9c, 0xd3, 0x0, 0xa0, 0xc9, 0x8, 0x1c, 0x19);

/* {14099BC4-787B-11d0-9CD3-00A0C9081C19} */
DEFINE_GUID(MEDIASUBTYPE_RTP_Payload_G711A, 
0x14099bc4, 0x787b, 0x11d0, 0x9c, 0xd3, 0x0, 0xa0, 0xc9, 0x8, 0x1c, 0x19);

/* {14099BC5-787B-11d0-9CD3-00A0C9081C19} */
DEFINE_GUID(MEDIASUBTYPE_RTP_Payload_G723, 
0x14099bc5, 0x787b, 0x11d0, 0x9c, 0xd3, 0x0, 0xa0, 0xc9, 0x8, 0x1c, 0x19);

/* {14099BC6-787B-11d0-9CD3-00A0C9081C19} */
DEFINE_GUID(MEDIASUBTYPE_RTP_Payload_H261, 
0x14099bc6, 0x787b, 0x11d0, 0x9c, 0xd3, 0x0, 0xa0, 0xc9, 0x8, 0x1c, 0x19);

/* {14099BC7-787B-11d0-9CD3-00A0C9081C19} */
DEFINE_GUID(MEDIASUBTYPE_RTP_Payload_H263, 
0x14099bc7, 0x787b, 0x11d0, 0x9c, 0xd3, 0x0, 0xa0, 0xc9, 0x8, 0x1c, 0x19);

/* {14099BCA-787B-11d0-9CD3-00A0C9081C19} */
DEFINE_GUID(MEDIASUBTYPE_RTP_Payload_ANY, 
0x14099bc8, 0x787b, 0x11d0, 0x9c, 0xd3, 0x0, 0xa0, 0xc9, 0x8, 0x1c, 0x19);

/* {33363248-0000-0010-8000-00AA00389B71} */
DEFINE_GUID(MEDIASUBTYPE_H263, 
0x33363248, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);

/* {14099BC8-787B-11d0-9CD3-00A0C9081C19} */
DEFINE_GUID(MEDIASUBTYPE_H263EX, 
0x14099bc8, 0x787b, 0x11d0, 0x9c, 0xd3, 0x0, 0xa0, 0xc9, 0x8, 0x1c, 0x19);

#if 0
/* {31363248-0000-0010-8000-00AA00389B71} */
DEFINE_GUID(MEDIASUBTYPE_H261, 
0x31363248, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
#endif
/* {14099BC9-787B-11d0-9CD3-00A0C9081C19} */
DEFINE_GUID(MEDIASUBTYPE_H261EX, 
0x14099bc9, 0x787b, 0x11d0, 0x9c, 0xd3, 0x0, 0xa0, 0xc9, 0x8, 0x1c, 0x19);

#endif

#endif /* _dsrtpid_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\dsrtp\inc\dsglob.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    dsglob.h
 *
 *  Abstract:
 *
 *    DShow global variables
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/18 created
 *
 **********************************************************************/

#ifndef _dsglob_h_
#define _dsglob_h_

#define WRTP_PIN_ANY                 L""
#define WRTP_PIN_INPUT               L"RTP Input"
#define WRTP_PIN_OUTPUT              L"RTP Output"
#define WRTP_RENDER_FILTER           L"Tapi RTP Render Filter"
#define WRTP_SOURCE_FILTER           L"Tapi RTP Source Filter"
#define WRTP_FILTER_VENDOR_INFO      L"Tapi RTP Network Filters"

#if USE_GRAPHEDT > 0
extern const AMOVIESETUP_MEDIATYPE   g_RtpOutputType;
extern const AMOVIESETUP_PIN         g_RtpOutputPin;
extern const AMOVIESETUP_FILTER      g_RtpSourceFilter;

extern const AMOVIESETUP_MEDIATYPE   g_RtpInputType;
extern const AMOVIESETUP_PIN         g_RtpInputPin;
extern const AMOVIESETUP_FILTER      g_RtpRenderFilter;
#endif

extern const WCHAR                   g_RtpVendorInfo[];

#define RTPDEFAULT_SAMPLE_NUM        MIN_ASYNC_RECVBUF
#define RTPDEFAULT_SAMPLE_SIZE       1500
#if USE_RTPPREFIX_HDRSIZE > 0
#define RTPDEFAULT_SAMPLE_PREFIX     sizeof(RtpPrefixHdr_t)
#else
#define RTPDEFAULT_SAMPLE_PREFIX     0
#endif
#define RTPDEFAULT_SAMPLE_ALIGN      4 /* (sizeof(DWORD)) */

#endif /* _dsglob_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\dsrtp\inc\classes.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    classes.h
 *
 *  Abstract:
 *
 *    DShow classes
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/14 created
 *
 **********************************************************************/

#ifndef _classes_h_
#define _classes_h_

#include <streams.h>

#include "gtypes.h"
#include "tapirtp.h"

#include "struct.h"

/**********************************************************************
 *
 * Forward declarations
 *
 **********************************************************************/

class CIRtpSession;

class CRtpSourceAllocator;
class CRtpOutputPin;
class CRtpMediaSample;
class CRtpSourceAllocator;
class CRtpSourceFilter;

class CRtpInputPin;
class CRtpRenderFilter;

/**********************************************************************
 *
 * CIRtpSession base class for source and render filters, implemets
 * interface
 *
 **********************************************************************/

enum {
    CIRTPMODE_FIRST,
    CIRTPMODE_AUTO,
    CIRTPMODE_MANUAL,
    CIRTPMODE_LAST
};

#define CIRTPMODE_NOTSET CIRTPMODE_FIRST

/*++++++++++++++++++++++++++++++++++++++*/
class CIRtpSession : public IRtpSession
/*======================================*/
{
    DWORD            m_dwObjectID;
protected:
    /* pointer to RTP session (this is the main owner) */
    RtpSess_t       *m_pRtpSess;

    /* pointer to current address (this is the main owner) */
    RtpAddr_t       *m_pRtpAddr;

    /* Is this for a source or render filter */
    DWORD            m_dwRecvSend;
    
    /* Mode, either auto or manual initialization */
    int              m_iMode;
    
    /* Filter state, can only be State_Running or State_Stopped */
    FILTER_STATE     m_RtpFilterState;
    
private:
    CBaseFilter     *m_pCBaseFilter;
    
    DWORD            m_dwIRtpFlags;

public:

    /* constructor */
    CIRtpSession(
            LPUNKNOWN        pUnk,
            HRESULT         *phr,
            DWORD            dwFlags
        );

    /* destructor */
    ~CIRtpSession();

    void Cleanup(void);

    inline void SetBaseFilter(
            CBaseFilter     *pCBaseFilter
        )
        {
            m_pCBaseFilter = pCBaseFilter;
        }
    
    inline RtpSess_t *GetpRtpSess()
        {
            return(m_pRtpSess);
        }

    inline RtpAddr_t *GetpRtpAddr()
        {
            return(m_pRtpAddr);
        }

    inline FILTER_STATE GetFilterState(void)
        {
            return(m_RtpFilterState);
        }
    
    inline int GetMode()
        {
            return(m_iMode);
        }
    
    inline int SetMode(DWORD iMode)
        {
            return( (m_iMode = iMode) );
        }

    inline DWORD FlagTest(DWORD dwFlag)
        {
            return(RtpBitTest(m_dwIRtpFlags, dwFlag));
        }
    
    inline DWORD FlagSet(DWORD dwFlag)
        {
            return(RtpBitSet(m_dwIRtpFlags, dwFlag));
        }
    
    inline DWORD FlagReset(DWORD dwFlag)
        {
            return(RtpBitReset(m_dwIRtpFlags, dwFlag));
        }
    /**************************************************
     * IRtpSession methods
     **************************************************/
    
    STDMETHODIMP Control(
            DWORD            dwControl,
            DWORD_PTR        dwPar1,
            DWORD_PTR        dwPar2
        );

    STDMETHODIMP GetLastError(
            DWORD           *pdwError
        );

    STDMETHODIMP Init(
            HANDLE          *phCookie,
            DWORD            dwFlags
        );

    STDMETHODIMP Deinit(
            void
        );
    
    STDMETHODIMP GetPorts(
            WORD            *pwRtpLocalPort,
            WORD            *pwRtpremotePort,
            WORD            *pwRtcpLocalPort,
            WORD            *pwRtcpRemotePort
        );
   
    STDMETHODIMP SetPorts(
            WORD             wRtpLocalPort,
            WORD             wRtpremotePort,
            WORD             wRtcpLocalPort,
            WORD             wRtcpRemotePort
        );
   
    STDMETHODIMP SetAddress(
            DWORD            dwLocalAddr,
            DWORD            dwRemoteAddr
        );

    STDMETHODIMP GetAddress(
            DWORD           *pdwLocalAddr,
            DWORD           *pdwRemoteAddr
        );

    STDMETHODIMP SetScope(
            DWORD            dwTTL,
            DWORD            dwFlags
        );

    STDMETHODIMP SetMcastLoopback(
            int              iMcastLoopbackMode,
            DWORD            dwFlags
        );

    /* Miscelaneous */
    
    STDMETHODIMP ModifySessionMask(
            DWORD            dwKind,
            DWORD            dwEventMask,
            DWORD            dwValue,
            DWORD           *pdwModifiedMask
        );

    /* Set the bandwidth limits. A value of -1 will make the parameter
     * to be ignored.
     *
     * All the parameters are in bits/sec */
    STDMETHODIMP SetBandwidth(
            DWORD            dwOutboundBw,
            DWORD            dwInboundBw,
            DWORD            dwReceiversRtcpBw,
            DWORD            dwSendersRtcpBw
        );

    /* Participants */
    /* pdwSSRC points to an array of DWORDs where to copy the SSRCs,
     * pdwNumber contains the maximum entries to copy, and returns the
     * actual number of SSRCs copied. If pdwSSRC is NULL, pdwNumber
     * will return the current number of SSRCs (i.e. the current
     * number of participants) */
    STDMETHODIMP EnumParticipants(
            DWORD           *pdwSSRC,
            DWORD           *pdwNumber
        );

    /* Get the participant state. dwSSRC specifies the
     * participant. piState will return the current participant's
     * state (e.g. RTPPARINFO_TALKING, RTPPARINFO_SILENT). */
    STDMETHODIMP GetParticipantState(
            DWORD            dwSSRC,
            DWORD           *pdwState
        );

    /* Get the participant's mute state. dwSSRC specifies the
     * participant. pbMuted will return the participant's mute state
     * */
    STDMETHODIMP GetMuteState(
            DWORD            dwSSRC,
            BOOL            *pbMuted
        );

    /* Query the network metrics computation state for the specific SSRC */
    STDMETHODIMP GetNetMetricsState(
            DWORD            dwSSRC,
            BOOL            *pbState
        );
    
    /* Enable or disable the computation of networks metrics, this is
     * mandatory in order of the corresponding event to be fired if
     * enabled. This is done for the specific SSRC or the first one
     * found if SSRC=-1, if SSRC=0, then the network metrics
     * computation will be performed for any and all the SSRCs */
    STDMETHODIMP SetNetMetricsState(
            DWORD            dwSSRC,
            BOOL             bState
        );

    /* Retrieves network information, if the network metric
     * computation is enabled for the specific SSRC, all the fields in
     * the structure will be meaningful, if not, only the average
     * values will contain valid data */
    STDMETHODIMP GetNetworkInfo(
            DWORD            dwSSRC,
            RtpNetInfo_t    *pRtpNetInfo
        );

    /* Set the participant's mute state. dwSSRC specifies the
     * participant. bMuted specifies the new state. Note that mute is
     * used to refer to the permission or not to pass packets received
     * up to the application, and it applies equally to audio or video
     * */
    STDMETHODIMP SetMuteState(
            DWORD            dwSSRC,
            BOOL             bMuted
        );

    /* SDES */
    STDMETHODIMP SetSdesInfo(
            DWORD            dwSdesItem,
            WCHAR           *psSdesData
        );

    STDMETHODIMP GetSdesInfo(
            DWORD            dwSdesItem,
            WCHAR           *psSdesData,
            DWORD           *pdwSdesDataLen,
            DWORD            dwSSRC
        );

    /* QOS */
    STDMETHODIMP SetQosByName(
            TCHAR_t         *psQosName,
            DWORD            dwResvStyle,
            DWORD            dwMaxParticipants,
            DWORD            dwQosSendMode,
            DWORD            dwFrameSize
       );

    /* Not yet implemented */
    STDMETHODIMP SetQosParameters(
            RtpQosSpec_t    *pRtpQosSpec,
            DWORD            dwMaxParticipants,/* WF and SE */
            DWORD            dwQosSendMode
        );

    STDMETHODIMP SetQosAppId(
            TCHAR_t         *psAppName,
            TCHAR_t         *psAppGUID,
            TCHAR_t         *psPolicyLocator
        );

    STDMETHODIMP SetQosState(
            DWORD            dwSSRC,
            BOOL             bEnable
        );

    STDMETHODIMP ModifyQosList(
            DWORD           *pdwSSRC,
            DWORD           *pdwNumber,
            DWORD            dwOperation
        );

    /* Cryptography */
    STDMETHODIMP SetEncryptionMode(
            int              iMode,
            DWORD            dwFlags
        );
    
    STDMETHODIMP SetEncryptionKey(
            TCHAR           *psPassPhrase,
            TCHAR           *psHashAlg,
            TCHAR           *psDataAlg,
            BOOL            bRtcp
        );


    /**************************************************
     * Helper methods
     **************************************************/
    
    HRESULT CIRtpSessionNotifyEvent(
            long             EventCode,
            LONG_PTR         EventParam1,
            LONG_PTR         EventParam2
        );
};

/**********************************************************************
 *
 * RTP Output Pin
 *
 **********************************************************************/

/* Some flags in CRtpOutputPin.m_dwFlags */
enum {
    FGOPIN_FIRST,
    FGOPIN_MAPPED,
    FGOPIN_LAST
};

#if USE_DYNGRAPH > 0
#define CBASEOUTPUTPIN CBaseOutputPinEx
#else
#define CBASEOUTPUTPIN CBaseOutputPin
#endif

/* Each pin supports 1 or more PT, a specific SSRC and can operate on
 * a certain mode (the mode has to do with the way the pin is assigned
 * to a specific participant) */
/*++++++++++++++++++++++++++++++++++++++*/
class CRtpOutputPin : public CBASEOUTPUTPIN
/*======================================*/
{
    friend class CRtpSourceFilter;

    DWORD            m_dwObjectID;
    
    RtpQueueItem_t   m_OutputPinQItem;
    
    /* Pointer to owner filter */
    CRtpSourceFilter *m_pCRtpSourceFilter;

    CIRtpSession    *m_pCIRtpSession;

    DWORD            m_dwFlags;

    /* Corresponding RTP output */
    RtpOutput_t     *m_pRtpOutput;

    BYTE             m_bPT;

#if USE_GRAPHEDT > 0
    int              m_iCurrFormat;
#endif

    
public:
    /* constructor */
    CRtpOutputPin(
            CRtpSourceFilter *pCRtpSourceFilter,
            CIRtpSession     *pCIRtpSession,
            HRESULT          *phr,
            LPCWSTR           pPinName
        );

    /* destructor */
    ~CRtpOutputPin();

    void *operator new(size_t size);

    void operator delete(void *pVoid);

    /**************************************************
     * CBasePin overrided methods
     **************************************************/
    
    HRESULT Active(void);

    /* verify we can handle this format */
    HRESULT CheckMediaType(
            const CMediaType *pCMediaType
        );

    HRESULT GetMediaType(
            int              iPosition,
            CMediaType      *pCMediaType
        );

#if USE_GRAPHEDT > 0
    
    HRESULT SetMediaType(
            CMediaType      *pCMediaType
        );
#endif

    STDMETHODIMP Connect(
            IPin            *pReceivePin,
            const AM_MEDIA_TYPE *pmt   // optional media type
        );

    STDMETHODIMP Disconnect();

    /**************************************************
     * CBaseOutputPin overrided methods
     **************************************************/

    HRESULT DecideAllocator(
            IMemInputPin    *pPin,
            IMemAllocator  **ppAlloc
        );

    HRESULT DecideBufferSize(
            IMemAllocator   *pIMemAllocator,
            ALLOCATOR_PROPERTIES *pProperties
        );

    /**************************************************
     * IQualityControl overrided methods
     **************************************************/

    STDMETHODIMP Notify(IBaseFilter *pSelf, Quality q);

    /**************************************************
     * Helper functions
     **************************************************/

    /* Process packets received */
    void OutPinRecvCompletion(
            IMediaSample    *pIMediaSample,
            BYTE             bPT
        );

    inline RtpOutput_t *SetOutput(RtpOutput_t *pRtpOutput)
        {
            return( (m_pRtpOutput = pRtpOutput) );
        }
    
    inline BYTE GetPT()
        {
            return(m_bPT);
        }

    inline BYTE SetPT(BYTE bPT)
        {
            return( (m_bPT = bPT) );
        }
    
    inline DWORD OutPinBitTest(DWORD dwBit)
        {
            return( RtpBitTest(m_dwFlags, dwBit) );
        }

    inline DWORD OutPinBitSet(DWORD dwBit)
        {
            return( RtpBitSet(m_dwFlags, dwBit) );
        }

    inline DWORD OutPinBitReset(DWORD dwBit)
        {
            return( RtpBitReset(m_dwFlags, dwBit) );
        }

    inline RtpOutput_t *GetpRtpOutput()
        {
            return(m_pRtpOutput);
        }
};

/**********************************************************************
 *
 * CRtpSourceAllocator private memory allocator
 *
 **********************************************************************/

/*++++++++++++++++++++++++++++++++++++++*/
class CRtpMediaSample : public CMediaSample
/*======================================*/
{
    friend class CRtpSourceAllocator;

    DWORD            m_dwObjectID;

    /* Link together all the samples */
    RtpQueueItem_t   m_RtpSampleItem;

    /* Owner */
    CRtpSourceAllocator *m_pCRtpSourceAllocator;
    
public:
    CRtpMediaSample(
            TCHAR           *pName,
            CRtpSourceAllocator *pAllocator,
            HRESULT         *phr
        );

    ~CRtpMediaSample();

    void *operator new(size_t size, long lBufferSize);
    
    void operator delete(void *pVoid);
};

/*++++++++++++++++++++++++++++++++++++++*/
class CRtpSourceAllocator : public CBaseAllocator
/*======================================*/
{
    DWORD            m_dwObjectID;
    
    /* Filter owner */
    CRtpSourceFilter *m_pCRtpSourceFilter;

    /* Critical section to access the samples queue's */
    RtpCritSect_t    m_RtpSampleCritSect;

    /* Busy samples queue */
    RtpQueue_t       m_RtpBusySamplesQ;
    
    /* Free samples queue */
    RtpQueue_t       m_RtpFreeSamplesQ;
    
 public:
    DECLARE_IUNKNOWN
    
    CRtpSourceAllocator(
            TCHAR           *pName,
            LPUNKNOWN        pUnk,
            HRESULT         *phr,
            CRtpSourceFilter *pCRtpSourceFilter 
       );
    
    ~CRtpSourceAllocator();

    void Free(void);

    HRESULT Alloc(void);
    
    void *operator new(size_t size);

    void operator delete(void *pVoid);

    /**************************************************
     * INonDelegatingUnknown implemented methods
     **************************************************/

    STDMETHODIMP NonDelegatingQueryInterface(
            REFIID           riid,
            void           **ppv
        );

    /**************************************************
     * IMemAllocator implemented methods
     **************************************************/

    STDMETHODIMP SetProperties(
		    ALLOCATOR_PROPERTIES *pRequest,
		    ALLOCATOR_PROPERTIES *pActual
        );

    STDMETHODIMP GetProperties(
		    ALLOCATOR_PROPERTIES *pProps
        );

    STDMETHODIMP Commit();

    STDMETHODIMP Decommit();

    STDMETHODIMP GetBuffer(
            IMediaSample   **ppBuffer,
            REFERENCE_TIME  *pStartTime,
            REFERENCE_TIME  *pEndTime,
            DWORD            dwFlags
        );

    STDMETHODIMP ReleaseBuffer(
            IMediaSample    *pBuffer
        );

    STDMETHODIMP GetFreeCount(LONG *plBuffersFree);
};

/**********************************************************************
 *
 * RTP Source Filter
 *
 **********************************************************************/

typedef struct _MEDIATYPE_MAPPING
{
    DWORD            dwRTPPayloadType;
    DWORD            dwFrequency;
    CMediaType      *pMediaType;

} MEDIATYPE_MAPPING;

/*++++++++++++++++++++++++++++++++++++++*/
class CRtpSourceFilter : public CBaseFilter,
                         public CIRtpSession,
                         public IRtpMediaControl,
                         public IRtpDemux,
                         public IRtpRedundancy
/*======================================*/
{
    friend class CRtpOutputPin;
    
    /* Identifies object */
    DWORD            m_dwObjectID;

    /* serializes access to filter state */
    CCritSec         m_cRtpSrcCritSec;

    /* pointer to the class implementing the IRtpSession interface */
    CIRtpSession    *m_pCIRtpSession;

    /* Output pins queue critical section */
    RtpCritSect_t    m_OutPinsCritSect;
    
    /* Output pins queue (CRtpOutputPin) */
    RtpQueue_t       m_OutPinsQ;

    /* Remember the prefix length */
    long             m_lPrefix;

    MEDIATYPE_MAPPING m_MediaTypeMappings[MAX_MEDIATYPE_MAPPINGS];
    DWORD            m_dwNumMediaTypeMappings;

    /* Keep track of the start time for all the samples delivered,
     * when a new talkspurt begins, make sure the new start time is
     * not smaller than the last start tiem from the last sample
     * delivered */
    LONGLONG         m_StartTime;
    
#if USE_DYNGRAPH > 0
    HANDLE           m_hStopEvent;
#endif
    
protected:
    /* Private memory allocator */
    CRtpSourceAllocator *m_pCRtpSourceAllocator;

private:
    /**************************************************
     * Private helper functions
     **************************************************/

    /* called on constructor failure and in the destructure */
    void Cleanup(void);

public:
    DECLARE_IUNKNOWN
    
    /* constructor */
    CRtpSourceFilter(
            LPUNKNOWN        pUnk,
            HRESULT         *phr
        );

    /* destructor */
    ~CRtpSourceFilter();

    void *operator new(size_t size);

    void operator delete(void *pVoid);

    /**************************************************
     * Helper functions
     **************************************************/
    
    /* expose state lock to other objects */
    CCritSec *pStateLock(void) { return &m_cRtpSrcCritSec; }

    HRESULT GetMediaType(int iPosition, CMediaType *pCMediaType);

    /* Process packets received */
    void SourceRecvCompletion(
            IMediaSample    *pIMediaSample,
            void            *pvUserInfo,
            RtpUser_t       *pRtpUser,
            double           dPlayTime,
            DWORD            dwError,
            long             lHdrSize,
            DWORD            dwTransfered,
            DWORD            dwFlags
        );

#if USE_GRAPHEDT <= 0
    HRESULT PayloadTypeToMediaType(
            IN DWORD         dwRTPPayloadType, 
            IN CMediaType   *pCMediaType,
            OUT DWORD       *pdwFrequency
       );
#endif

    CRtpOutputPin *FindIPin(IPin *pIPin);

    HRESULT MapPinsToOutputs();

    HRESULT UnmapPinsFromOutputs();

    HRESULT AddPt2FrequencyMap(
            DWORD        dwPt,
            DWORD        dwFrequency
        );
    
    /**************************************************
     * CBaseFilter overrided methods
     **************************************************/

    /* Get number of output pins */
    int GetPinCount();

    /* Get the nth pin */
    CBasePin *GetPin(
            int n
        );

    FILTER_STATE GetState()
        {
            return(m_State);
        }

    STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State);

    STDMETHODIMP Run(REFERENCE_TIME tStart);

    STDMETHODIMP Stop();
    
#if USE_DYNGRAPH > 0

    BOOL CRtpSourceFilter::ConfigurePins(
            IN IGraphConfig* pGraphConfig,
            IN HANDLE        hEvent
        );

    STDMETHOD (JoinFilterGraph) ( 
            IFilterGraph*    pGraph, 
            LPCWSTR          pName 
        );
#endif


    /**************************************************
     * INonDelegatingUnknown implemented methods
     **************************************************/

    /* obtain pointers to active movie and private interfaces */

    STDMETHODIMP NonDelegatingQueryInterface(
            REFIID           riid,
            void           **ppv
        );

    /**************************************************
     * IRtpMediaControl implemented methods
     **************************************************/

    /* set the mapping between RTP payload and DShow media types */
    STDMETHODIMP SetFormatMapping(
	        IN DWORD         dwRTPPayLoadType, 
            IN DWORD         dwFrequency,
            IN AM_MEDIA_TYPE *pMediaType
        );
    
    /* Empties the format mapping table */
    STDMETHODIMP FlushFormatMappings(void);
    
    /**************************************************
     * IRtpDemux implemented methods
     **************************************************/
    
    /* Add a single pin, may return its position */
    STDMETHODIMP AddPin(
            IN  int          iOutMode,
            OUT int         *piPos
        );

    /* Set the number of pins, can only be >= than current number of
     * pins */
    STDMETHODIMP SetPinCount(
            IN  int          iCount,
            IN  int          iOutMode
        );

    /* Set the pin mode (e.g. auto, manual, etc), if iPos >= 0 use it,
     * otherwise use pIPin */
    STDMETHODIMP SetPinMode(
            IN  int          iPos,
            IN  IPin        *pIPin,
            IN  int          iOutMode
        );

    /* Map/unmap pin i to/from user with SSRC, if iPos >= 0 use it,
     * otherwise use pIPin, when unmapping, only the pin or the SSRC
     * is required */
    STDMETHODIMP SetMappingState(
            IN  int          iPos,
            IN  IPin        *pIPin,
            IN  DWORD        dwSSRC,
            IN  BOOL         bMapped
        );

    /* Find the Pin assigned (if any) to the SSRC, return either
     * position or pin or both */
    STDMETHODIMP FindPin(
            IN  DWORD        dwSSRC,
            OUT int         *piPos,
            OUT IPin       **ppIPin
        );

    /* Find the SSRC mapped to the Pin, if iPos >= 0 use it, otherwise
     * use pIPin */
    STDMETHODIMP FindSSRC(
            IN  int          iPos,
            IN  IPin        *pIPin,
            OUT DWORD       *pdwSSRC
        );

    /**************************************************
     * IRtpRedundancy implemented methods
     **************************************************/
    
     /* Configures redundancy parameters */
    STDMETHODIMP SetRedParameters(
            DWORD            dwPT_Red, /* Payload type for redundant packets */
            DWORD            dwInitialRedDistance,/* Initial red distance */
            DWORD            dwMaxRedDistance /* default used when passing 0 */
        );
};

/**********************************************************************
 *
 * RTP Input Pin
 *
 **********************************************************************/

/* Some flags in CRtpOutputPin.m_dwFlags */
enum {
    FGIPIN_FIRST,
    FGIPIN_LAST
};

/*++++++++++++++++++++++++++++++++++++++*/
class CRtpInputPin : public CBaseInputPin
/*======================================*/
{
    DWORD            m_dwObjectID;
    
    /* Pointer to owner filter */
    CRtpRenderFilter *m_pCRtpRenderFilter;

    CIRtpSession    *m_pCIRtpSession;
    
    DWORD            m_dwFlags;
    
    /* Pin's possition */
    int              m_iPos;
    
    /* this pin is for capture (as opossed for RTP packetization
       descriptors) */
    BOOL             m_bCapture;

    BYTE             m_bPT;
    DWORD            m_dwSamplingFreq;
    
public:
    /* constructor */
    CRtpInputPin(
            int              iPos,
            BOOL             bCapture,
            CRtpRenderFilter *pCRtpRenderFilter,
            CIRtpSession    *pCIRtpSession,
            HRESULT         *phr,
            LPCWSTR          pPinName
        );

    /* destructor */
    ~CRtpInputPin();

    void *operator new(size_t size);

    void operator delete(void *pVoid);

    inline DWORD GetSamplingFreq(void)
        {
            if (m_dwSamplingFreq)
            {
                return(m_dwSamplingFreq);
            }
            else
            {
                return(DEFAULT_SAMPLING_FREQ);
            }
        }
    
    /**************************************************
     * CBasePin overrided methods
     **************************************************/
    
    /* verify we can handle this format */
    HRESULT CheckMediaType(const CMediaType *pCMediaType);

    HRESULT SetMediaType(const CMediaType *pCMediaType);

    STDMETHODIMP ReceiveConnection(
        IPin * pConnector,      // this is the initiating connecting pin
        const AM_MEDIA_TYPE *pmt   // this is the media type we will exchange
    );

    STDMETHODIMP EndOfStream(void);
    
    /**************************************************
     * CBaseInputPin overrided methods
     **************************************************/

    STDMETHODIMP GetAllocatorRequirements(ALLOCATOR_PROPERTIES *pProps);

    /**************************************************
     * IMemInputPin implemented methods
     **************************************************/

    /* send input stream over network */
    STDMETHODIMP Receive(IMediaSample *pIMediaSample);
};

/**********************************************************************
 *
 * RTP Render Filter
 *
 **********************************************************************/

/*++++++++++++++++++++++++++++++++++++++*/
class CRtpRenderFilter : public CBaseFilter,
                         public CIRtpSession,
                         public IRtpMediaControl,
                         public IAMFilterMiscFlags,
                         public IRtpDtmf,
                         public IRtpRedundancy
/*======================================*/
{
     /* Identifies object */
    DWORD            m_dwObjectID;

    /* serializes access to filter state */
    CCritSec         m_cRtpRndCritSec;

    /* pointer to the class implementing the IRtpSession interface */
    CIRtpSession    *m_pCIRtpSession;

    DWORD            m_dwFeatures;
    
    int              m_iPinCount;
    
    /* 2 pins (capture and packetization descriptor) */
    CRtpInputPin    *m_pCRtpInputPin[2];

    /* save the MediaSample from capture when using RTP PDs */
    IMediaSample    *m_pMediaSample;

    /* This filter sends only to 1 address, so the PT can be kept in
     * the filter rather than in the pin */
    DWORD            m_dwPT;

    /* This filter sends only to 1 address, so the sampling frequency
     * can be kept in the filter rather than in the pin */
    DWORD            m_dwFreq;
    
    MEDIATYPE_MAPPING m_MediaTypeMappings[MAX_MEDIATYPE_MAPPINGS];
    DWORD            m_dwNumMediaTypeMappings;
    
    IMediaSample    *m_pRedMediaSample[RTP_RED_MAXDISTANCE];
    DWORD            m_dwRedIndex;

    DWORD            m_dwDtmfId;
    DWORD            m_dwDtmfDuration;
    DWORD            m_dwDtmfTimeStamp;
    BOOL             m_bDtmfEnd;
    
    /**************************************************
     * Private helper functions
     **************************************************/

    /* called on constructor failure and in the destructure */
    void Cleanup(void);
    
public:
    DECLARE_IUNKNOWN

    /* constructor */
    CRtpRenderFilter(
            LPUNKNOWN        pUnk,
            HRESULT         *phr
        );
    
    /* destructor */
    ~CRtpRenderFilter();
    
    void *operator new(size_t size);

    void operator delete(void *pVoid);

    /**************************************************
     * Helper functions
     **************************************************/
    
    /* expose state lock to other objects */
    CCritSec *pStateLock(void) { return &m_cRtpRndCritSec; }

    HRESULT MediaType2PT(
        IN const CMediaType *pCMediaType, 
        OUT DWORD           *pdwPT,
        OUT DWORD           *pdwFreq
        );

    /* MAYDO this might be a list of samples so more than 1 can be
       safely queued. Note that should not happen becase that means
       samples are produced faster than they can be consumed, but we
       must be prepared for that */
    /* Save the MediaSample to be used later when the packetization
     * descriptor is available, if there was already a sample, release
     * it */
    inline void PutMediaSample(IMediaSample *pMediaSample)
        {
            if (m_pMediaSample)
            {
                m_pMediaSample->Release();
            }
            
            m_pMediaSample = pMediaSample;
        }

    /* retrieves the saved MediaSample to be consumed */
    inline IMediaSample *GetMediaSample(void)
        {
            IMediaSample    *pMediaSample;

            pMediaSample = m_pMediaSample;
            
            m_pMediaSample = (IMediaSample *)NULL;
            
            return(pMediaSample);
        }

    inline void ModifyFeature(int iFeature, BOOL bValue)
        {
            if (bValue)
            {
                RtpBitSet(m_dwFeatures, iFeature);
            }
            else
            {
                RtpBitReset(m_dwFeatures, iFeature);
            }
        }

    /**************************************************
     * CBaseFilter overrided methods
     **************************************************/

    /* Get number of input pins */
    int GetPinCount();

    /* Get the nth pin */
    CBasePin *GetPin(
            int              n
        );

    STDMETHODIMP Run(REFERENCE_TIME tStart);

    STDMETHODIMP Stop();

    /**************************************************
     * INonDelegatingUnknown implemented methods
     **************************************************/

    /* obtain pointers to active movie and private interfaces */
    STDMETHODIMP NonDelegatingQueryInterface(
            REFIID           riid,
            void           **ppv
        );

    /**************************************************
     * IRtpMediaControl implemented methods
     **************************************************/

    /* set the mapping between RTP payload and DShow media types */
    STDMETHODIMP SetFormatMapping(
	        IN DWORD         dwRTPPayLoadType, 
            IN DWORD         dwFrequency,
            IN AM_MEDIA_TYPE *pMediaType
        );
    
    /* Empties the format mapping table */
    STDMETHODIMP FlushFormatMappings(void);

    /**************************************************
     * IAMFilterMiscFlags implemented methods
     **************************************************/

    /* tell the filter graph that we generate EC_COMPLETE */
    STDMETHODIMP_(ULONG) GetMiscFlags(void);

    /**************************************************
     * IRtpDtmf implemented methods
     **************************************************/

    /* Configures DTMF parameters */
    STDMETHODIMP SetDtmfParameters(
            DWORD            dwPT_Dtmf  /* Payload type for DTMF events */
        );

    /* Directs an RTP render filter to send a packet formatted
     * according to rfc2833 containing the specified event, specified
     * volume level, duration in milliseconds, and the END flag,
     * following the rules in section 3.6 for events sent in multiple
     * packets. Parameter dwId changes from one digit to the next one.
     *
     * NOTE the duration is given in milliseconds, then it is
     * converted to RTP timestamp units which are represented using 16
     * bits, the maximum value is hence dependent on the sampling
     * frequency, but for 8KHz the valid values would be 0 to 8191 ms
     * */
    STDMETHODIMP SendDtmfEvent(
            DWORD            dwId,
            DWORD            dwEvent,
            DWORD            dwVolume,
            DWORD            dwDuration, /* ms */
            BOOL             bEnd
        );
    
    /**************************************************
     * IRtpRedundancy implemented methods
     **************************************************/
    
     /* Configures redundancy parameters */
    STDMETHODIMP SetRedParameters(
            DWORD            dwPT_Red, /* Payload type for redundant packets */
            DWORD            dwInitialRedDistance,/* Initial red distance */
            DWORD            dwMaxRedDistance /* default used when passing 0 */
        );

    /**************************************************
     * Methods for IRtpRedundancy support
     **************************************************/

    STDMETHODIMP AddRedundantSample(
            IMediaSample *pIMediaSample
        );

    STDMETHODIMP ClearRedundantSamples(void);
};

#endif /* _classes_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\options.inc ===
#**********************************************************************
#*
#*  Copyright (C) Microsoft Corporation, 1999
#*
#*  File name:
#*
#*    common.inc
#*
#*  Abstract:
#*
#*    Common build definitions and libraries
#*
#*  Author:
#*
#*    Andres Vega-Garcia (andresvg)
#*
#*  Revision:
#*
#*    1999/08/31 created
#*
#**********************************************************************

#* To test using GRAPHEDT use
#*     USE_GRAPHEDT=1

#*
#* USE_GRAPHEDT
#*
#* Set to 1 (default 0) if want to use to use RTP under graphedt, i.e. 
#* no body is going to call Init(). Some temporary *MediaType* 
#* functions will also be used
#*
C_DEFINES=\
    $(C_DEFINES) \
    -DUSE_GRAPHEDT=0

#*
#* USE_RTPPREFIX_HDRSIZE
#*
#* Set to 1 (default 1) if want support for RTP header size to
#* be included as a prefix.
#* The buffer is:
#*
#* 1) Prefix: RTP prefix header
#* 2) Begin buffer: RTP header (variable size because of CSRC and extensions)
#* 3) Payload
#*
#* If USE_RTPPREFIX_HDRSIZE is set to 0, then (1) is not used.
#*
C_DEFINES=\
    $(C_DEFINES) \
    -DUSE_RTPPREFIX_HDRSIZE=1

#*
#* Enable Dynamic graph changes
#* Needs some DShow features not present in W2k
#*
C_DEFINES=\
    $(C_DEFINES) \
    -DUSE_DYNGRAPH=0

#*
#* To use UNICODE
#* 0=don't use UNICODE
#* 1=use UNICODE
#*
RTPOPT_USE_UNICODE=1

#*
#* Enable using thread pool for RTCP thread (default 1).
#* By using thread pool, the limitation in RTCP thread to
#* handle 31 RTCP sessions (per thread) is removed.
#* 0=Don't use thread pool
#* 1=Use thread pool
C_DEFINES=\
    $(C_DEFINES) \
    -DUSE_RTCP_THREAD_POOL=1

#*
#* Enable all the TraceDebug to be dependent on the use
#* of UseAdvancedTracing
C_DEFINES=\
    $(C_DEFINES) \
    -DUSE_TRACE_DEBUG=0

#*
#* Enable simulation of random losses in receiver or sender
C_DEFINES=\
    $(C_DEFINES) \
    -DUSE_GEN_LOSSES=0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\dsrtp\src\dsrtp.cpp ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    dsrtp.cpp
 *
 *  Abstract:
 *
 *    DShow  RTP templates and entry point
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/17 created
 *
 **********************************************************************/
#include <winsock2.h>

#include "classes.h"

#include "tapirtp.h"

#include <filterid.h>

#include <rtptempl.h>

#include "dsglob.h"

#include "msrtpapi.h"


/**********************************************************************
 *
 * DShow setup information
 *
 **********************************************************************/

/*
 * RTP Source
 */

#if USE_GRAPHEDT > 0

const AMOVIESETUP_MEDIATYPE g_RtpOutputType =
{
    &MEDIATYPE_RTP_Single_Stream,	        // clsMajorType
    &GUID_NULL	        // clsMinorType
}; 

const AMOVIESETUP_PIN g_RtpOutputPin =
{
    WRTP_PIN_OUTPUT,                        // strName
    FALSE,                                  // bRendered
    TRUE,                                   // bOutput
    FALSE,                                  // bZero
    FALSE,                                  // bMany
    &CLSID_NULL,                            // clsConnectsToFilter
    WRTP_PIN_ANY,                           // strConnectsToPin
    1,                                      // nTypes
    &g_RtpOutputType                        // lpTypes
};

const AMOVIESETUP_FILTER g_RtpSourceFilter =
{
    &__uuidof(MSRTPSourceFilter),           // clsID
    WRTP_SOURCE_FILTER,                     // strName
    MERIT_DO_NOT_USE,                       // dwMerit
    1,                                      // nPins
    &g_RtpOutputPin                         // lpPin
};                              

/*
 * RTP Render
 */

const AMOVIESETUP_MEDIATYPE g_RtpInputType =
{
    &MEDIATYPE_NULL,                        // Major type
    &MEDIASUBTYPE_NULL                      // Minor type
}; 

const AMOVIESETUP_PIN g_RtpInputPin =
{ 
    WRTP_PIN_INPUT,                         // strName
    FALSE,                                  // bRendered
    FALSE,                                  // bOutput
    FALSE,                                  // bZero
    TRUE,                                   // bMany
    &CLSID_NULL,                            // clsConnectsToFilter
    WRTP_PIN_ANY,                           // strConnectsToPin
    1,                                      // nTypes
    &g_RtpInputType                         // lpTypes
};

const AMOVIESETUP_FILTER g_RtpRenderFilter =
{ 
    &_uuidof(MSRTPRenderFilter),            // clsID
    WRTP_RENDER_FILTER,                     // strName
    MERIT_DO_NOT_USE,                       // dwMerit
    1,                                      // nPins
    &g_RtpInputPin                          // lpPin
};

#endif /* USE_GRAPHEDT > 0 */

#if DXMRTP <= 0

/**********************************************************************
 *
 * DShow templates
 *
 **********************************************************************/

CFactoryTemplate g_Templates[] =
{
    /* RTP Source */
    RTP_SOURCE_TEMPLATE,

    /* RTP Render */
    RTP_RENDER_TEMPLATE
};

int g_cTemplates = (sizeof(g_Templates)/sizeof(g_Templates[0]));

/**********************************************************************
 *
 * Filter Vendor Information
 *
 **********************************************************************/
const WCHAR g_RtpVendorInfo[] = WRTP_FILTER_VENDOR_INFO; 



/**********************************************************************
 *
 * Public procedures
 *
 **********************************************************************/

extern "C" BOOL WINAPI DllMain(HINSTANCE, ULONG, LPVOID);
extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE, ULONG, LPVOID);

/**********************************************************************
 *
 *  Routine Description:
 *
 *    Wrapper around ActiveMovie DLL entry point.
 *
 *  Arguments:
 *
 *    Same as DllEntryPoint.   
 *
 *  Return Values:
 *
 *  Returns TRUE if successful.
 *
 **********************************************************************/

BOOL WINAPI DllMain(
        HINSTANCE hInstance, 
        ULONG     ulReason, 
        LPVOID    pv)
{
    BOOL    error;
    HRESULT hr;

    error = TRUE;
    
    switch(ulReason) {
    case DLL_PROCESS_ATTACH:
        /* RTP global initialization */
        hr = MSRtpInit1(hInstance);

        if (SUCCEEDED(hr)) {
            error = DllEntryPoint(hInstance, ulReason, pv);
        } else {
            error = FALSE;
        }        
        break;
    case DLL_PROCESS_DETACH:
        error = DllEntryPoint(hInstance, ulReason, pv);

        /* RTP global de-initialization */
        hr = MSRtpDelete1();

        if (FAILED(hr)) {
            error = FALSE;
        }
        
        break;
    default:
        ;
    }

    return(error);
}


/**********************************************************************
 *
 *  Routine Description:
 *
 *    Instructs an in-process server to create its registry entries
 *    for * all classes supported in this server module.
 *
 *  Arguments:
 *
 *    None.
 *
 *  Return Values:
 *
 *    NOERROR - The registry entries were created successfully.
 *
 *    E_UNEXPECTED - An unknown error occurred.
 *
 *    E_OUTOFMEMORY - There is not enough memory to complete the
 *    registration.
 *
 *    SELFREG_E_TYPELIB - The server was unable to complete the
 *    registration of all the type libraries used by its classes.
 *
 *    SELFREG_E_CLASS - The server was unable to complete the *
 *    registration of all the object classes.
 **********************************************************************/
HRESULT DllRegisterServer()
{
    // forward to amovie framework
    return AMovieDllRegisterServer2( TRUE );
}


/**********************************************************************
 *
 *  Routine Description:
 *
 *    Instructs an in-process server to remove only registry entries
 *    created through DllRegisterServer.
 *
 *  Arguments:
 *
 *    None.
 *
 *  Return Values:
 *
 *    NOERROR - The registry entries were created successfully.
 *
 *    S_FALSE - Unregistration of this server's known entries was
 *    successful, but other entries still exist for this server's
 *    classes.
 *
 *    E_UNEXPECTED - An unknown error occurred.
 *
 *    E_OUTOFMEMORY - There is not enough memory to complete the
 *    unregistration.
 *
 *    SELFREG_E_TYPELIB - The server was unable to remove the entries
 *    of all the type libraries used by its classes.
 *
 *    SELFREG_E_CLASS - The server was unable to remove the entries of
 *    all the object classes.
**********************************************************************/
HRESULT DllUnregisterServer()
{
    // forward to amovie framework
    return AMovieDllRegisterServer2( FALSE );
}

#endif /* DXMRTP <= 0 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\dsrtp\src\render.cpp ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    render.cpp
 *
 *  Abstract:
 *
 *    CRtpRenderFilter and CRtpInputPin implementation
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/18 created
 *
 **********************************************************************/

#include <winsock2.h>

#include <filterid.h>
#include "gtypes.h"
#include "classes.h"
#include "rtpqos.h"
#include "rtpglobs.h"
#include "msrtpapi.h"
#include "dsglob.h"
#include "rtppt.h"
#include "rtppktd.h"
#include "rtpdemux.h"
#include "rtpdtmf.h"
#include "rtpred.h"

#include "tapirtp.h"
#include "dsrtpid.h"

/**********************************************************************
 *
 * RTP Input Pin class implementation: CRtpInputPin
 *
 **********************************************************************/

/*
 * CRtpInputPin constructor
 * */
CRtpInputPin::CRtpInputPin(
        int               iPos,
        BOOL              bCapture,
        CRtpRenderFilter *pCRtpRenderFilter,
        CIRtpSession     *pCIRtpSession,
        HRESULT          *phr,
        LPCWSTR           pPinName
    )
    : CBaseInputPin(
            _T("CRtpInputPin"),
            pCRtpRenderFilter,                   
            pCRtpRenderFilter->pStateLock(),                     
            phr,                       
            pPinName
          ),
      
      m_pCRtpRenderFilter(
              pCRtpRenderFilter
          )
{
    m_dwObjectID = OBJECTID_RTPIPIN;
    
    m_pCIRtpSession = pCIRtpSession;

    m_dwFlags = 0;
     
    m_iPos = iPos;
      
    m_bCapture = bCapture;
    /* TODO should fail if a valid filter is not passed */

    /* TODO some initialization can be removed once I use a private
     * heap for this objects (which will zero the segment) */
}

/*
 * CRtpInputPin destructor
 * */
CRtpInputPin::~CRtpInputPin()
{
    INVALIDATE_OBJECTID(m_dwObjectID);
}

void *CRtpInputPin::operator new(size_t size)
{
    void            *pVoid;
    
    TraceFunctionName("CRtpInputPin::operator new");

    pVoid = RtpHeapAlloc(g_pRtpRenderHeap, size);

    if (!pVoid)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_RENDER,
                _T("%s: failed to allocate memory:%u"),
                _fname, size
            ));
    }
    
    return(pVoid);
}

void CRtpInputPin::operator delete(void *pVoid)
{
    if (pVoid)
    {
        RtpHeapFree(g_pRtpRenderHeap, pVoid);
    }
}

/**************************************************
 * CBasePin overrided methods
 **************************************************/
    
/*
 * Verify we can handle this format
 * */
HRESULT CRtpInputPin::CheckMediaType(const CMediaType *pCMediaType)
{
    /* accepts everything */
    return(NOERROR);
}

HRESULT CRtpInputPin::SetMediaType(const CMediaType *pCMediaType)
{
    HRESULT hr;
    DWORD   dwPT;
    DWORD   dwFreq;

    TraceFunctionName("CRtpInputPin::SetMediaType");
    
    hr = CBasePin::SetMediaType(pCMediaType);

    if (SUCCEEDED(hr))
    {
        /* Get default payload type and sampling frequency for Capture
         * pin */
        if (m_bCapture)
        {
            ((CRtpRenderFilter*)m_pFilter)->
                MediaType2PT(pCMediaType, &dwPT, &dwFreq);

            m_bPT = (BYTE)dwPT;
            m_dwSamplingFreq = dwFreq;

            if (*pCMediaType->Type() == MEDIATYPE_RTP_Single_Stream)
            {
                m_pCRtpRenderFilter->
                    ModifyFeature(RTPFEAT_PASSHEADER, TRUE);
            }
            else
            {
                m_pCRtpRenderFilter->
                    ModifyFeature(RTPFEAT_PASSHEADER, FALSE);
            }

            TraceRetail((
                    CLASS_INFO, GROUP_DSHOW, S_DSHOW_RENDER,
                    _T("%s: m_pFilter[0x%p] Will send ")
                    _T("PT:%u Frequency:%u"),
                    _fname, m_pFilter, m_bPT, m_dwSamplingFreq
                ));
        }
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_RENDER,
                _T("%s: m_pFilter[0x%p] failed: %u (0x%X)"),
                _fname, m_pFilter, hr, hr
            ));
    }
    
    return(hr);
}

STDMETHODIMP CRtpInputPin::EndOfStream()
{
    HRESULT          hr;

    hr = m_pFilter->NotifyEvent(
            EC_COMPLETE, 
            S_OK,
            (LONG_PTR)(IBaseFilter*)m_pFilter
        );

    return(hr);
}

STDMETHODIMP CRtpInputPin::ReceiveConnection(
    IPin * pConnector,      // this is the initiating connecting pin
    const AM_MEDIA_TYPE *pmt   // this is the media type we will exchange
    )
{
    if(pConnector != m_Connected)
    {
        return CBaseInputPin::ReceiveConnection(pConnector, pmt);
    }

    CMediaType cmt(*pmt);
    HRESULT hr = CheckMediaType(&cmt);
    ASSERT(hr == S_OK);

    if(hr == S_OK)
    {
        SetMediaType(&cmt);
    }
    else 
    {
        DbgBreak("??? CheckMediaType failed in dfc ReceiveConnection.");
        hr = E_UNEXPECTED;
    }

    return hr;
}


/**************************************************
 * CBaseInputPin overrided methods
 **************************************************/

STDMETHODIMP CRtpInputPin::GetAllocatorRequirements(
        ALLOCATOR_PROPERTIES *pProps
    )
{
    /* Set here my specific requirements, as I don't know at this
     * point if redundancy is going to be used or not, I need to be
     * prepared and ask resources as if redundancy were to be used
     * (should be the default anyway), and in such case I would hold
     * at the most N buffers (the max redundancy distance), and the
     * previous filter (the encoder or capture) needs to have enough
     * buffers so it will not run out of them */
    pProps->cBuffers = RTP_RED_MAXDISTANCE;

    return(NOERROR);
}

/**************************************************
 * IMemInputPin implemented methods
 **************************************************/

/* send input stream over network */
STDMETHODIMP CRtpInputPin::Receive(IMediaSample *pIMediaSample)
{
    HRESULT          hr;
    RtpAddr_t       *pRtpAddr;
    WSABUF           wsaBuf[3+RTP_RED_MAXRED];
    DWORD            dwNumBuf;
    DWORD            dwSendFlags;
    DWORD            dwTimeStamp;
    DWORD            dwPT;
    DWORD            dwNewFreq;
    int              iFreqChange;
    int              iTsAdjust;
    double           dTime;
    REFERENCE_TIME   AMTimeStart, AMTimeEnd;
    IMediaSample    *pIMediaSampleData;
    
    RTP_PD_HEADER   *pRtpPDHdr;
    RTP_PD          *pRtpPD;
    DWORD            dwNumBlocks;
    char            *pHdr;
    char            *pData;
    DWORD            marker;
    FILTER_STATE     FilterState;
    
    TraceFunctionName("CRtpInputPin::Receive");
    
    hr = CBaseInputPin::Receive(pIMediaSample);

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_WARNING, GROUP_DSHOW, S_DSHOW_RENDER,
                _T("%s: CBaseInputPin::Receive failed: %u (0x%X)"),
                _fname, hr, hr
            ));
        
        return(hr);
    }

    if (!(m_pCIRtpSession && m_pCIRtpSession->FlagTest(FGADDR_IRTP_INITDONE)))
    {
        hr = RTPERR_NOTINIT;
        
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_RENDER,
                _T("%s: m_pFilter[0x%p] is in an invalid state: %s (0x%X)"),
                _fname, m_pFilter, RTPERR_TEXT(hr), hr
            ));
        
        return(hr);
    }

    FilterState = State_Stopped;
    
    m_pFilter->GetState(0, &FilterState);

    if (FilterState != State_Running ||
        m_pCRtpRenderFilter->GetFilterState() != State_Running)
    {
        hr = RTPERR_INVALIDSTATE;
        
        TraceRetail((
                CLASS_WARNING, GROUP_DSHOW, S_DSHOW_RENDER,
                _T("%s: m_pFilter[0x%p] is not running: %s (0x%X)"),
                _fname, m_pFilter, RTPERR_TEXT(hr), hr
            ));
        
        return(NOERROR);
    }
    
    pRtpAddr = m_pCIRtpSession->GetpRtpAddr();

    dwTimeStamp = 0;
    dwSendFlags = NO_FLAGS;
    
    iFreqChange = 0;
            
    if (m_bCapture)
    {
        /* Capture data */

        /* Handle in-band format changes. This needs to be done before
         * the timestamp is computed as the frequency might be
         * different */
        if (m_SampleProps.dwSampleFlags & AM_SAMPLE_TYPECHANGED)
        {
            ((CRtpRenderFilter*)m_pFilter)->
                MediaType2PT((CMediaType *)m_SampleProps.pMediaType,
                             &dwPT,
                             &dwNewFreq);

            iFreqChange = (int)m_dwSamplingFreq - dwNewFreq;
            
            m_bPT = (BYTE)dwPT;
            m_dwSamplingFreq = dwNewFreq;
            
            pRtpAddr->RtpNetSState.bPT = m_bPT;
            pRtpAddr->RtpNetSState.dwSendSamplingFreq = m_dwSamplingFreq;

            TraceRetail((
                    CLASS_INFO, GROUP_DSHOW, S_DSHOW_RENDER,
                    _T("%s: m_pFilter[0x%p] RtpAddr[0x%p] ")
                    _T("Sending PT:%u Frequency:%u"),
                    _fname, m_pFilter, pRtpAddr, dwPT, dwNewFreq
                ));
        }
    }

    if (!RtpBitTest(pRtpAddr->pRtpSess->dwFeatureMask, RTPFEAT_PASSHEADER))
    {
        /* Need to generate timestamp. If this flag is set, then this
         * generation is not needed as the timestamp is part of the
         * RTP header which is already contained in the buffer and
         * will be used unchanged */
        
        if (!RtpBitTest(pRtpAddr->pRtpSess->dwFeatureMask,
                        RTPFEAT_GENTIMESTAMP))
        {
            hr = pIMediaSample->GetTime(&AMTimeStart, &AMTimeEnd);

            if (FAILED(hr))
            {
                TraceRetail((
                        CLASS_ERROR, GROUP_DSHOW, S_DSHOW_RENDER,
                        _T("%s: m_pFilter[0x%p] ")
                        _T("pIMediaSample->GetTime failed: %u (0x%X)"),
                        _fname, m_pFilter, hr, hr
                    ));
    
                /* MAYDO may be an alternative time stamp can be obtained
                 * instead */
                return(VFW_E_SAMPLE_REJECTED);
            }

            if (iFreqChange)
            {
                /* If changing frequency, adjust the random timestamp
                 * offset to compensate for the timestamp jump. A
                 * forward jump when passing from lower -> higher
                 * frequency, and a backwards jump when passing from
                 * higher -> lower frequency */
                iTsAdjust = (int)
                    (ConvertToMilliseconds(AMTimeStart) * iFreqChange / 1000);


                pRtpAddr->RtpNetSState.dwTimeStampOffset += (DWORD) iTsAdjust;

                TraceRetail((
                        CLASS_INFO, GROUP_DSHOW, S_DSHOW_RENDER,
                        _T("%s: m_pFilter[0x%p] pRtpAddr[0x%p] Start:%0.3f ")
                        _T("frequency change: %u to %u, ts adjust:%d"),
                        _fname, m_pFilter, pRtpAddr,
                        (double)ConvertToMilliseconds(AMTimeStart)/1000,
                        iFreqChange + (int)m_dwSamplingFreq,
                        m_dwSamplingFreq,
                        iTsAdjust
                    ));
            }
            
            /* timestamp */
            dwTimeStamp = (DWORD)
                ( ConvertToMilliseconds(AMTimeStart) *
                  pRtpAddr->RtpNetSState.dwSendSamplingFreq / 1000 );

#if 0
            /* USED TO DEBUG ONLY */
            TraceRetail((
                    CLASS_INFO, GROUP_DSHOW, S_DSHOW_RENDER,
                    _T("%s: pRtpAddr[0x%p] SSRC:0x%X ts:%u ")
                    _T("StartTime:%I64u/%u ")
                    _T("EndTime:%I64u/%u"),
                    _fname, pRtpAddr,
                    ntohl(pRtpAddr->RtpNetSState.dwSendSSRC),
                    dwTimeStamp,
                    AMTimeStart,
                    ((CRefTime *)&AMTimeStart)->Millisecs(),
                    AMTimeEnd,
                    ((CRefTime *)&AMTimeEnd)->Millisecs()
                ));
#endif
        }
        else
        {
            dTime = (double)RtpGetTime();
            
            if (iFreqChange)
            {
                /* If changing frequency, adjust the random timestamp
                 * offset to compensate for the timestamp jump. A
                 * forward jump when passing from lower -> higher
                 * frequency, and a backwards jump when passing from
                 * higher -> lower frequency */
                
                pRtpAddr->RtpNetSState.dwTimeStampOffset += (DWORD)
                    (dTime * iFreqChange / 1000);
            }
            
             /* Generate the right timestamp based on the sampling
             * frequency and the RTP's relative elapsed time. It seems
             * that for audio the original timestamp (above code)
             * generates less jitter, but for video the original timestamp
             * has more jitter than the locally generated (this path). As
             * jitter is more noticeble in audio, use by default the above
             * path */
            dwTimeStamp = (DWORD)
                ( dTime *
                  pRtpAddr->RtpNetSState.dwSendSamplingFreq /
                  1000.0 );
        }
    }
    
    dwNumBuf = 0;
    hr = NOERROR;
    
    if (m_bCapture)
    {
        /* Capture data */

        /* decide if using PDs (this happens only with video) */
        CBasePin *pCBasePinPD;

        pCBasePinPD = m_pCRtpRenderFilter->GetPin(1);

        if (pCBasePinPD->IsConnected())
        {
            /* Save video data to be used later when the packetization
             * descriptor is available */
            pIMediaSample->AddRef();
            m_pCRtpRenderFilter->PutMediaSample(pIMediaSample);
        }
        else
        {
            /* Decide if redundant encoding is in place */
            if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_REDSEND) &&
                pRtpAddr->RtpNetSState.dwNxtRedDistance)
            {
                /* Redundancy is used if enabled and the current
                 * redundancy distance is greater than zero. If the
                 * distance is zero (default at the begining), that
                 * means there are not enough losses to trigger the
                 * use of redundancy */

                RtpBitSet(dwSendFlags, FGSEND_USERED);
            }
            
            /* send the data now */
            /* Payload data */
            wsaBuf[1].len = pIMediaSample->GetActualDataLength();

            pIMediaSample->GetPointer((unsigned char **)&wsaBuf[1].buf);

            /* TODO when doing async I/O, the sample will need to be addref
               and released when the overlapped I/O completes */

            /* IsDiscontinuity returns S_OK if the sample is a
             * discontinuous sample, or S_FALSE if not; otherwise,
             * returns an HRESULT error value */
            if (pIMediaSample->IsDiscontinuity() == S_OK)
            {
                pRtpAddr->RtpNetSState.bMarker = 1;

                if (RtpBitTest(dwSendFlags, FGSEND_USERED))
                {
                    m_pCRtpRenderFilter->ClearRedundantSamples();
                }
            }
            else
            {
                pRtpAddr->RtpNetSState.bMarker = 0;
            }
   
            hr = RtpSendTo(pRtpAddr, wsaBuf, 2, dwTimeStamp, dwSendFlags);

            if (RtpBitTest(dwSendFlags, FGSEND_USERED))
            {
                /* Save this sample, we only hold a small number of
                 * the last recently used ones, the oldest may be
                 * removed and  released */
                m_pCRtpRenderFilter->AddRedundantSample(pIMediaSample);
            }
        }
    }
    else
    {
        /* Got RTP packetization descriptor, send now */
        
        pIMediaSample->GetPointer((unsigned char **)&pHdr);
        pRtpPDHdr = (RTP_PD_HEADER *)pHdr;
        
        pIMediaSampleData = m_pCRtpRenderFilter->GetMediaSample();

        if (pIMediaSampleData)
        {
            /* get stored sample */
            pIMediaSampleData->GetPointer((unsigned char **)&pData);

            dwNumBlocks = pRtpPDHdr->dwNumHeaders;

            pRtpPD = (RTP_PD *)(pRtpPDHdr + 1);
            
            /* generate packets */
            for(; dwNumBlocks; dwNumBlocks--, pRtpPD++)
            {
                /* get data sample, read PD and
                 * send as many packets as needed */
                wsaBuf[1].len = pRtpPD->dwPayloadHeaderLength;
                wsaBuf[1].buf = pHdr + pRtpPD->dwPayloadHeaderOffset;

                wsaBuf[2].len = (pRtpPD->dwPayloadEndBitOffset / 8) -
                    (pRtpPD->dwPayloadStartBitOffset / 8) + 1;
                wsaBuf[2].buf = pData + (pRtpPD->dwPayloadStartBitOffset / 8);

                if (pRtpPD->fEndMarkerBit)
                {
                    pRtpAddr->RtpNetSState.bMarker = 1;
                }
                else
                {
                    pRtpAddr->RtpNetSState.bMarker = 0;
                }
            
                hr = RtpSendTo(pRtpAddr, wsaBuf, 3, dwTimeStamp, dwSendFlags);
            }
        
            /* release stored sample */
            pIMediaSampleData->Release();

            /* TODO need to be able to store a list of samples */
        }
        else
        {
            TraceRetail((
                    CLASS_WARNING, GROUP_DSHOW, S_DSHOW_RENDER,
                    _T("%s: m_pFilter[0x%p] failed: ")
                    _T("packetization info but no sample to deliver"),
                    _fname, m_pFilter
                ));
        }
    }

    if (FAILED(hr))
    {
        /*
         * WARNING:
         *
         * Do not report failures to capture as it may stop producing
         * samples
         * */

        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_RENDER,
                _T("%s: m_pFilter[0x%p] failed: %u (0x%X)"),
                _fname, m_pFilter, hr, hr
            ));
        
        hr = NOERROR;
    }
    
    return(hr);
}

/**********************************************************************
 *
 * RTP Render Filter class implementation: CRtpRenderFilter
 *
 **********************************************************************/

/*
 * CRtpRenderFilter constructor
 * */
CRtpRenderFilter::CRtpRenderFilter(LPUNKNOWN pUnk, HRESULT *phr)
    :
    CBaseFilter(
            _T("CRtpRenderFilter"), 
            pUnk, 
            &m_cRtpRndCritSec, 
            __uuidof(MSRTPRenderFilter)
        ),

    CIRtpSession(
            pUnk,
            phr,
            RtpBitPar(FGADDR_IRTP_ISSEND)),

    m_dwDtmfId(NO_DW_VALUESET),
    m_bDtmfEnd(FALSE)
{
    HRESULT          hr;
    int              i;
    long             lMaxFilter;
    
    TraceFunctionName("CRtpRenderFilter::CRtpRenderFilter");

    m_pCIRtpSession = static_cast<CIRtpSession *>(this);

    /* Test for NULL pointers, do not test pUnk which may be NULL */
    if (!phr)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_RENDER,
                _T("%s: CRtpRenderFilter[0x%p] has phr NULL"),
                _fname, this
            ));
        
        /* TODO this is a really bad situation, we can not pass any
         * error and the memory is allocated, this will be fixed when
         * I find out how to validate this parameters before
         * allocating memory in the overriden new */

        phr = &hr; /* Use this pointer instead */
    }

    *phr = NOERROR;

    lMaxFilter = InterlockedIncrement(&g_RtpContext.lNumRenderFilter);
    if (lMaxFilter > g_RtpContext.lMaxNumRenderFilter)
    {
        g_RtpContext.lMaxNumRenderFilter = lMaxFilter;
    }

    SetBaseFilter(this);
 
    m_dwObjectID = OBJECTID_RTPRENDER;

    m_iPinCount = 2;

    /*
     * Create input pins
     * */

    for(i = 0; i < m_iPinCount; i++)
    {
        m_pCRtpInputPin[i] = (CRtpInputPin *)NULL;
    }
    
    for(i = 0; i < m_iPinCount; i++)
    {
        /* TODO pins are created whenever a new address is added */
        m_pCRtpInputPin[i] = (CRtpInputPin *)
            new CRtpInputPin(i,
                             (i & 1)? FALSE : TRUE, /* bCapture */
                             this,
                             m_pCIRtpSession,
                             phr,
                             (i & 1)? L"RtpPd" : L"Capture");
    
        if (FAILED(*phr))
        {
            /* pass up the same returned error */
            goto bail;
        }

        if (!m_pCRtpInputPin[i])
        {
            /* low in memory, failed to create object */
            *phr = E_OUTOFMEMORY;
            goto bail;
        }
    }

#if USE_GRAPHEDT > 0
    /* When using graphedt, initialize automatically, the coockie can
     * be NULL as a global variable will be shared between source and
     * render */
    *phr = m_pCIRtpSession->Init(NULL, RtpBitPar2(RTPINITFG_AUTO, RTPINITFG_QOS));
    
    if (FAILED(*phr))
    {
        /* pass up the same returned error */
        goto bail;
    }

#endif /* USE_GRAPHEDT > 0 */
    
    *phr = NOERROR;
    
    TraceRetail((
            CLASS_INFO, GROUP_DSHOW, S_DSHOW_RENDER,
            _T("%s: CRtpRenderFilter[0x%p] CIRtpSession[0x%p] created"),
            _fname, this, static_cast<CIRtpSession *>(this)
        ));
    
    return;
    
 bail:
    Cleanup();
}

/*
 * CRtpRenderFilter destructor
 * */
CRtpRenderFilter::~CRtpRenderFilter()
{
    RtpAddr_t       *pRtpAddr;
    
    TraceFunctionName("CRtpRenderFilter::~CRtpRenderFilter");

    if (m_dwObjectID != OBJECTID_RTPRENDER)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_RENDER,
                _T("%s: CRtpRenderFilter[0x%p] ")
                _T("Invalid object ID 0x%X != 0x%X"),
                _fname, this,
                m_dwObjectID, OBJECTID_RTPRENDER
            ));

        return;
    }

    TraceRetail((
            CLASS_INFO, GROUP_DSHOW, S_DSHOW_RENDER,
            _T("%s: CRtpRenderFilter[0x%p] CIRtpSession[0x%p] being deleted..."),
            _fname, this, static_cast<CIRtpSession *>(this)
        ));
    
    if (m_RtpFilterState == State_Running)
    {
        TraceRetail((
                CLASS_WARNING, GROUP_DSHOW, S_DSHOW_RENDER,
                _T("%s: CRtpRenderFilter[0x%p] being deleted ")
                _T("while still running"),
                _fname, this
            ));
        
        Stop();
    }
     
    pRtpAddr = m_pCIRtpSession->GetpRtpAddr();

    if (pRtpAddr &&
        RtpBitTest(pRtpAddr->dwIRtpFlags, FGADDR_IRTP_PERSISTSOCKETS))
    {
        RtpStop(pRtpAddr->pRtpSess,
                RtpBitPar2(FGADDR_ISSEND, FGADDR_FORCESTOP));
    }
    
    Cleanup();

    InterlockedDecrement(&g_RtpContext.lNumRenderFilter);

    m_pCIRtpSession = (CIRtpSession *)NULL;

    INVALIDATE_OBJECTID(m_dwObjectID);
}

void CRtpRenderFilter::Cleanup(void)
{
    int              i;

    TraceFunctionName("CRtpRenderFilter::Cleanup");

    for(i = 0; i < 2; i++)
    {
        if (m_pCRtpInputPin[i])
        {
            delete m_pCRtpInputPin[i];
            m_pCRtpInputPin[i] = (CRtpInputPin *)NULL;
        }
    }
    
    FlushFormatMappings();
}

void *CRtpRenderFilter::operator new(size_t size)
{
    void            *pVoid;
    
    TraceFunctionName("CRtpRenderFilter::operator new");

    MSRtpInit2();
    
    pVoid = RtpHeapAlloc(g_pRtpRenderHeap, size);

    if (pVoid)
    {
        ZeroMemory(pVoid, size);
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_RENDER,
                _T("%s: failed to allocate memory:%u"),
                _fname, size
            ));

        /* On low memory failure, the destructor will not be called,
         * so decrese the reference count that was increased above */
        MSRtpDelete2(); 
    }
    
    return(pVoid);
}

void CRtpRenderFilter::operator delete(void *pVoid)
{
    if (pVoid)
    {
        RtpHeapFree(g_pRtpRenderHeap, pVoid);

        /* Reduce the reference count only for objects that got
         * memory, those that failed to obtain memory do not increase
         * the counter */
        MSRtpDelete2();
    }
}

/*
 * Create a CRtpRenderFilter instance (for active movie class factory)
 * */
CUnknown *CRtpRenderFilterCreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    /* Test for NULL pointers, do not test pUnk which may be NULL */
    if (!phr)
    {
        return((CUnknown *)NULL);
    }

    *phr = NOERROR;
    
    /* On failure during the constructor, the caller is responsible to
     * delete the object (that is consistent with DShow) */
    CRtpRenderFilter *pCRtpRenderFilter = new CRtpRenderFilter(pUnk, phr);

    if (!pCRtpRenderFilter)
    {
        *phr = RTPERR_MEMORY; 
    }

    return(pCRtpRenderFilter);
}

/**************************************************
 * CBaseFilter overrided methods
 **************************************************/

/*
 * Get the number of input pins
 * */
int CRtpRenderFilter::GetPinCount()
{
    /* WARNING: Only used for DShow's benefit */
    
    /* object lock on filter object */
    CAutoLock LockThis(&m_cRtpRndCritSec);

    /* TODO must go into RtpAddrQ and find out how many items exist in
     * that queue owned by RtpSess_t */
    /* return count */
    return(m_iPinCount);
}

/*
 * Get a reference to the nth pin
 * */
CBasePin *CRtpRenderFilter::GetPin(int n)
{
    /* WARNING: Only used for DShow's benefit */
    
    /* object lock on filter object */
    CAutoLock LockThis(&m_cRtpRndCritSec);

    /* TODO scan list and retrieve the nth element, check there exist at
     * least that many pins */
    if (n < 0 || n >= m_iPinCount) {
        return((CBasePin *)NULL);
    }

    return(m_pCRtpInputPin[n]);
}

STDMETHODIMP CRtpRenderFilter::Run(REFERENCE_TIME tStart)
{
    HRESULT          hr;
    RtpSess_t       *pRtpSess;
    RtpAddr_t       *pRtpAddr;
    
    TraceFunctionName("CRtpRenderFilter::Run");

    if (m_RtpFilterState == State_Running)
    {
        /* Alredy running, do nothing but call base class */
        hr = CBaseFilter::Run(tStart);

        return(hr);
    }

    hr = NOERROR;

    if (!m_pCIRtpSession->FlagTest(FGADDR_IRTP_INITDONE))
    {
        return(RTPERR_NOTINIT);
    }
    
    /* MAYDO when we have multiple addresses, there should be a way to
     * assign to each pin an address */

    pRtpSess = m_pCIRtpSession->GetpRtpSess();
    pRtpAddr = m_pCIRtpSession->GetpRtpAddr();

    if (pRtpSess && pRtpAddr)
    {
        RTPASSERT(pRtpAddr && pRtpAddr->pRtpSess == pRtpSess);
    }
    else
    {
        hr = RTPERR_INVALIDSTATE;
        
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_RENDER,
                _T("%s: failed: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("null session or address"),
                _fname, pRtpSess, pRtpAddr
            ));
    }
    
    /* Call base class */
    if (SUCCEEDED(hr))
    {
        hr = CBaseFilter::Run(tStart); /* will call CBasePin::Run in
                                        * all filters */
    }
    
    /* Initialize sockets and start worker thread */
    if (SUCCEEDED(hr))
    {
        pRtpAddr->RtpNetSState.bPT = (BYTE)m_dwPT;
        pRtpAddr->RtpNetSState.dwSendSamplingFreq = m_dwFreq;

        if (RtpBitTest(m_dwFeatures, RTPFEAT_GENTIMESTAMP))
        {
            RtpBitSet(pRtpSess->dwFeatureMask, RTPFEAT_GENTIMESTAMP);
        }
        else
        {
            RtpBitReset(pRtpSess->dwFeatureMask, RTPFEAT_GENTIMESTAMP);
        }
        if (RtpBitTest(m_dwFeatures, RTPFEAT_PASSHEADER))
        {
            RtpBitSet(pRtpSess->dwFeatureMask, RTPFEAT_PASSHEADER);
        }
        else
        {
            RtpBitReset(pRtpSess->dwFeatureMask, RTPFEAT_PASSHEADER);
        }
        
        hr = RtpStart(pRtpSess, RtpBitPar(FGADDR_ISSEND));

        if (SUCCEEDED(hr))
        {
            m_RtpFilterState = State_Running;
        }
    }
    
    return(hr);
}

STDMETHODIMP CRtpRenderFilter::Stop()
{
    HRESULT          hr;
    HRESULT          hr2;
    RtpSess_t       *pRtpSess;
    IMediaSample    *pIMediaSample;
    
    if (m_RtpFilterState == State_Stopped)
    {
        /* Alredy stopped, do nothing but call base class */
        hr2 = CBaseFilter::Stop();

        pIMediaSample = GetMediaSample();

        if (pIMediaSample)
        {
            /* release stored sample */
            pIMediaSample->Release();
        }
    
        return(hr2);
    }

    if (!m_pCIRtpSession->FlagTest(FGADDR_IRTP_INITDONE))
    {
        hr = RTPERR_NOTINIT;
        
        goto end;
    }

    pRtpSess = m_pCIRtpSession->GetpRtpSess();

    if (pRtpSess)
    {
        hr = RtpStop(pRtpSess, RtpBitPar(FGADDR_ISSEND));
    }
    else
    {
        hr = RTPERR_INVALIDSTATE;
    }

 end:
    /* Call base class */
    hr2 = CBaseFilter::Stop(); /* will decommit */

    if (SUCCEEDED(hr))
    {
        hr = hr2;
    }

    pIMediaSample = GetMediaSample();

    if (pIMediaSample)
    {
        /* release stored sample */
        pIMediaSample->Release();
    }
    
    ClearRedundantSamples();
    
    m_RtpFilterState = State_Stopped;
   
    return(hr);
}


/**************************************************
 * INonDelegatingUnknown implemented methods
 **************************************************/

/* obtain pointers to active movie and private interfaces */
STDMETHODIMP CRtpRenderFilter::NonDelegatingQueryInterface(
        REFIID riid,
        void **ppv
    )
{
    HRESULT hr;
    
    if (riid == __uuidof(IRtpMediaControl))
    {
        return GetInterface(static_cast<IRtpMediaControl *>(this), ppv);
    }
    else if (riid == IID_IAMFilterMiscFlags) 
    {
        return GetInterface((IAMFilterMiscFlags *)this, ppv);
    } 
    else if (riid == __uuidof(IRtpSession))
    {
        return GetInterface(static_cast<IRtpSession *>(this), ppv);  
    }
    else if (riid == __uuidof(IRtpDtmf))
    {
        return GetInterface(static_cast<IRtpDtmf *>(this), ppv);
    }
    else if (riid == __uuidof(IRtpRedundancy))
    {
        return GetInterface(static_cast<IRtpRedundancy *>(this), ppv);
    }
    else
    {
        hr = CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
    }

    return(hr);
}

/**************************************************
 * IRtpMediaControl implemented methods
 **************************************************/

/* set the mapping between RTP payload and DShow media types */
STDMETHODIMP CRtpRenderFilter::SetFormatMapping(
	    IN DWORD         dwRTPPayLoadType, 
        IN DWORD         dwFrequency,
        IN AM_MEDIA_TYPE *pMediaType
    )
{
    DWORD            dw;

    TraceFunctionName("CRtpRenderFilter::SetFormatMapping");

    ASSERT(!IsBadReadPtr(pMediaType, sizeof(AM_MEDIA_TYPE)));

    if (!pMediaType)
    {
        return(RTPERR_POINTER);
    }
    
    CAutoLock Lock( &m_cRtpRndCritSec );
    
    for (dw = 0; dw < m_dwNumMediaTypeMappings; dw ++)
    {
        if ( (m_MediaTypeMappings[dw].pMediaType->majortype ==
              pMediaType->majortype)  &&
             (m_MediaTypeMappings[dw].pMediaType->subtype ==
              pMediaType->subtype) &&
              m_MediaTypeMappings[dw].dwFrequency == dwFrequency)
        {
            // the media type is known, update the payload type to be used.
            m_MediaTypeMappings[dw].dwRTPPayloadType = dwRTPPayLoadType;
            return NOERROR;
        }
    }

    if (dw >= MAX_MEDIATYPE_MAPPINGS)
    {
        // we don't have space for more mappings.
        return RTPERR_RESOURCES;
    }

    // This is a new mapping. remember it.
    m_MediaTypeMappings[dw].pMediaType = new CMediaType(*pMediaType);
    if (m_MediaTypeMappings[dw].pMediaType == NULL)
    {
        return RTPERR_MEMORY;
    }
    m_MediaTypeMappings[dw].dwRTPPayloadType = dwRTPPayLoadType;
    m_MediaTypeMappings[dw].dwFrequency = dwFrequency;

    TraceRetail((
            CLASS_INFO, GROUP_DSHOW, S_DSHOW_RENDER,
            _T("%s: CRtpRenderFilter[0x%p] New mapping[%u]: ")
            _T("PT:%u Frequency:%u"),
            _fname, this,
            m_dwNumMediaTypeMappings, dwRTPPayLoadType, dwFrequency
        ));
    
    m_dwNumMediaTypeMappings++;

    return NOERROR;
}

/* Empties the format mapping table */
STDMETHODIMP CRtpRenderFilter::FlushFormatMappings(void)
{
    DWORD            dw;
    
    CAutoLock Lock( &m_cRtpRndCritSec );

    for (dw = 0; dw < m_dwNumMediaTypeMappings; dw ++)
    {
        if (m_MediaTypeMappings[dw].pMediaType)
        {
            delete m_MediaTypeMappings[dw].pMediaType;
            m_MediaTypeMappings[dw].pMediaType = NULL;
        }
    }

    m_dwNumMediaTypeMappings = 0;
    
    return(NOERROR);
}

/* Get RTP payload type and sampling frequency from the mediatype */
HRESULT CRtpRenderFilter::MediaType2PT(
        IN const CMediaType *pCMediaType, 
        OUT DWORD           *pdwPT,
        OUT DWORD           *pdwFreq
    )
{
    HRESULT          hr;
    
    TraceFunctionName("CRtpRenderFilter::MediaType2PT");

    ASSERT(!IsBadWritePtr(pdwPT, sizeof(DWORD)));
    ASSERT(!IsBadWritePtr(pdwFreq, sizeof(DWORD)));

    CAutoLock Lock( &m_cRtpRndCritSec );
    
#if USE_GRAPHEDT <= 0
    DWORD dw;

    m_dwPT = 96;
    m_dwFreq = 8000;
    hr = S_FALSE;
    
    for (dw = 0; dw < m_dwNumMediaTypeMappings; dw ++)
    {
        if (m_MediaTypeMappings[dw].pMediaType->majortype ==
            pCMediaType->majortype
            &&
            m_MediaTypeMappings[dw].pMediaType->subtype ==
            pCMediaType->subtype)
        {

            if (pCMediaType->formattype == FORMAT_WaveFormatEx)
            {
                // we need to do an additional check for audio formats
                // because some audio formats have the same guid but
                // different frequency. (DVI4)
                WAVEFORMATEX *pWaveFormatEx = (WAVEFORMATEX *)
                    pCMediaType->pbFormat;
                ASSERT(!IsBadReadPtr(pWaveFormatEx, pCMediaType->cbFormat));

                if (pWaveFormatEx->nSamplesPerSec !=
                    m_MediaTypeMappings[dw].dwFrequency)
                {
                    // this is not the one. try next one.
                    continue;
                }
            }
            
            m_dwPT = m_MediaTypeMappings[dw].dwRTPPayloadType;

            m_dwFreq = m_MediaTypeMappings[dw].dwFrequency;

            hr = NOERROR;

            break;
        }
    }
#else /* USE_GRAPHEDT <= 0 */
    hr = NOERROR;
    
    if (pCMediaType->subtype == MEDIASUBTYPE_RTP_Payload_G711U)
    {
        m_dwPT = RTPPT_PCMU;
        m_dwFreq = 8000;
    }
    else if (pCMediaType->subtype == MEDIASUBTYPE_RTP_Payload_G711A)
    {
        m_dwPT = RTPPT_PCMA;
        m_dwFreq = 8000;
    }
    else if (pCMediaType->subtype == MEDIASUBTYPE_RTP_Payload_G723)
    {
        m_dwPT = RTPPT_G723;
        m_dwFreq = 8000;
    }
    else if (pCMediaType->subtype == MEDIASUBTYPE_H261)
    {
        m_dwPT = RTPPT_H261;
        m_dwFreq = 90000;
    }
    else if ( (pCMediaType->subtype == MEDIASUBTYPE_H263_V1) ||
                (pCMediaType->subtype == MEDIASUBTYPE_H263_V2) ||
              (pCMediaType->subtype == MEDIASUBTYPE_RTP_Payload_H263) )
    {
        m_dwPT = RTPPT_H263;
        m_dwFreq = 90000;
    }
    else
    {
        m_dwPT = 96; /* a dynamic PT */
        m_dwFreq = 8000;
        hr = S_FALSE;
    }
    
#endif /* USE_GRAPHEDT <= 0 */

    if (hr == NOERROR)
    {
        TraceRetail((
                CLASS_INFO, GROUP_DSHOW, S_DSHOW_RENDER,
                _T("%s: CRtpRenderFilter[0x%p]: PT:%u Frequency:%u"),
                _fname, this, m_dwPT, m_dwFreq
            ));
    }
    else
    {
        TraceRetail((
                CLASS_WARNING, GROUP_DSHOW, S_DSHOW_RENDER,
                _T("%s: CRtpRenderFilter[0x%p]: No mapping found, ")
                _T("using default: PT:%u Frequency:%u"),
                _fname, this, m_dwPT, m_dwFreq
            ));
    }
    
    if (pdwPT)
    {
        *pdwPT = m_dwPT;
    }
    
    if (pdwFreq)
    {
        *pdwFreq = m_dwFreq;
    }

    return(hr);
}

/**************************************************
 * IAMFilterMiscFlags implemented methods
 **************************************************/
STDMETHODIMP_(ULONG) CRtpRenderFilter::GetMiscFlags(void)
/*++
  Routine Description:

  Implement the IAMFilterMiscFlags::GetMiscFlags method. Retrieves the
  miscelaneous flags. This consists of whether or not the filter moves
  data out of the graph system through a Bridge or None pin.

  Arguments:

  None.
  --*/
{
    return(AM_FILTER_MISC_FLAGS_IS_RENDERER);
}

/**************************************************
 * IRtpDtmf implemented methods
 **************************************************/

/* Configures DTMF parameters */
STDMETHODIMP CRtpRenderFilter::SetDtmfParameters(
        DWORD            dwPT_Dtmf  /* Payload type for DTMF events */
    )
{
    HRESULT          hr;

    TraceFunctionName("CRtpRenderFilter::SetDtmfParameters");  

    hr = RTPERR_NOTINIT;
    
    if (m_pCIRtpSession->FlagTest(FGADDR_IRTP_INITDONE))
    {
        hr = RtpSetDtmfParameters(m_pRtpAddr, dwPT_Dtmf);
    }
    
    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_RENDER,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }
    
    return(hr);
}

/* Directs an RTP render filter to send a packet formatted
 * according to rfc2833 containing the specified event, specified
 * volume level, duration in milliseconds, and the END flag,
 * following the rules in section 3.6 for events sent in multiple
 * packets. Parameter dwId changes from one digit to the next one.
 *
 * NOTE the duration is given in milliseconds, then it is
 * converted to RTP timestamp units which are represented using 16
 * bits, the maximum value is hence dependent on the sampling
 * frequency, but for 8KHz the valid values would be 0 to 8191 ms
 * */
STDMETHODIMP CRtpRenderFilter::SendDtmfEvent(
        DWORD            dwId,
        DWORD            dwEvent,
        DWORD            dwVolume,
        DWORD            dwDuration,
        BOOL             bEnd
    )
{
    HRESULT          hr;
    DWORD            dwSamplingFreq;
    DWORD            dwDtmfFlags;
    REFERENCE_TIME   CurrentTime;
    IReferenceClock *pClock;
    
    TraceFunctionName("CRtpRenderFilter::SendDtmfEvent");  

    hr = RTPERR_NOTINIT;
    
    if (m_pCIRtpSession->FlagTest(FGADDR_IRTP_INITDONE))
    {
        dwDtmfFlags = 0;

        if (bEnd)
        {
            dwDtmfFlags |= RtpBitPar(FGDTMF_END);
        }
        
        if (m_dwDtmfId != dwId)
        {
            /* I have the beginning of a new digit */
            m_dwDtmfId = dwId;

            /* First packet must have marker bit set */
            dwDtmfFlags |= RtpBitPar(FGDTMF_MARKER);
            
            m_dwDtmfDuration = dwDuration;

            m_bDtmfEnd = FALSE;
            
            /* Compute initial timestamp */

            hr = RTPERR_FAIL;
        
            m_dwDtmfTimeStamp = 0;

            if (m_pClock)
            {
                hr = m_pClock->GetTime(&CurrentTime);

                if (SUCCEEDED(hr))
                {
                    CurrentTime -= m_tStart;
                    
                    m_dwDtmfTimeStamp = (DWORD)
                        ( ConvertToMilliseconds(CurrentTime) *
                          m_pRtpAddr->RtpNetSState.dwSendSamplingFreq / 1000 );
                }
            }

            if (FAILED(hr))
            {
                /* Alternate timestamp generation */
                m_dwDtmfTimeStamp = (DWORD)
                    ( timeGetTime() *
                      m_pRtpAddr->RtpNetSState.dwSendSamplingFreq / 1000 );

                hr = NOERROR;
            }
        }
        else
        {
            /* Succesive packets for the same digit, update duration */

            if (!m_bDtmfEnd)
            {
                /* Increase duration for all the request that have the
                 * bit end set to 0 and the first one with bit end set
                 * to 1 */
                m_dwDtmfDuration += dwDuration;
            }
        }
        
        if (!m_bDtmfEnd && bEnd)
        {
            /* Prevent advancing the duration if more packets are to
             * be sent with the bit end set to 1 */
            m_bDtmfEnd = TRUE;
        }
        
        /* Get sender's sampling frequency from the Capture pin, not
         * from the RtpPD pin */
        dwSamplingFreq = m_pCRtpInputPin[0]->GetSamplingFreq();

        /* Convert duration from milliseconds to timestamp units */
        dwDuration = m_dwDtmfDuration * dwSamplingFreq / 1000;

        hr = RtpSendDtmfEvent(m_pRtpAddr, m_dwDtmfTimeStamp,
                              dwEvent, dwVolume, dwDuration, dwDtmfFlags);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_RENDER,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }
    else
    {
        TraceDebug((
                CLASS_INFO, GROUP_DSHOW, S_DSHOW_RENDER,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("ID:%X timestamp:%u event:%u vol:%u duration:%u, end:%u"),
                _fname, m_pRtpSess, m_pRtpAddr,
                dwId, m_dwDtmfTimeStamp, dwEvent, dwVolume, dwDuration, bEnd
            ));
    }
    
    return(hr);
}

/**************************************************
 * IRtpRedundancy implemented methods
 **************************************************/

/* Configures redundancy parameters */
STDMETHODIMP CRtpRenderFilter::SetRedParameters(
        DWORD            dwPT_Red, /* Payload type for redundant packets */
        DWORD            dwInitialRedDistance,/* Initial redundancy distance*/
        DWORD            dwMaxRedDistance /* default used when passing 0 */
    )
{
    HRESULT          hr;

    TraceFunctionName("CRtpRenderFilter::SetRedParameters");  

    hr = RTPERR_NOTINIT;
    
    if (m_pCIRtpSession->FlagTest(FGADDR_IRTP_INITDONE))
    {
        hr = RtpSetRedParameters(m_pRtpAddr,
                                 RtpBitPar(SEND_IDX),
                                 dwPT_Red,
                                 dwInitialRedDistance,
                                 dwMaxRedDistance);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_RENDER,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }
    
    return(hr);
}


/**************************************************
 * Methods for IRtpRedundancy support
 **************************************************/

/* Store and AddRef() a sample for later use as redundance, if the LRU
 * entry is busy, Release() it, then store the new sample */
STDMETHODIMP CRtpRenderFilter::AddRedundantSample(
        IMediaSample    *pIMediaSample
    )
{
    HRESULT          hr;

    hr = RTPERR_POINTER;
    
    if (pIMediaSample)
    {
        pIMediaSample->AddRef();

        if (m_pRedMediaSample[m_dwRedIndex])
        {
            /* Release old sample */
            m_pRedMediaSample[m_dwRedIndex]->Release();
        }

        m_pRedMediaSample[m_dwRedIndex] = pIMediaSample;

        /* Advance index */
        m_dwRedIndex = (m_dwRedIndex + 1) % RTP_RED_MAXDISTANCE;

        hr = NOERROR;
    }
    
    return(hr);
}

STDMETHODIMP CRtpRenderFilter::ClearRedundantSamples(void)
{
    DWORD            i;

    for(i = 0; i < RTP_RED_MAXDISTANCE; i++)
    {
        if (m_pRedMediaSample[i])
        {
            m_pRedMediaSample[i]->Release();

            m_pRedMediaSample[i] = NULL;
        }
    }

    m_dwRedIndex = 0;
    
    return(NOERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\lookup.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    lookup.h
 *
 *  Abstract:
 *
 *    Helper functions to look up SSRCs
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/17 created
 *
 **********************************************************************/

#ifndef _lookup_h_
#define _lookup_h_

#include "gtypes.h"
#include "struct.h"

#if defined(__cplusplus)
extern "C" {
#endif  // (__cplusplus)
#if 0
}
#endif

RtpUser_t *LookupSSRC(RtpAddr_t *pRtpAddr, DWORD dwSSRC, BOOL *pbCreate);

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif /* _lookup_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\msrtpapi.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    msrtpapi.h
 *
 *  Abstract:
 *
 *    Microsoft RTP API (not a DShow API)
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/18 created
 *
 **********************************************************************/

#ifndef _msapi_h_
#define _msapi_h_

#include <rtpinit.h>
#include "gtypes.h"
#include "struct.h"

#if defined(__cplusplus)
extern "C" {
#endif  // (__cplusplus)
#if 0
}
#endif

RTPSTDAPI CreateRtpSess(
        RtpSess_t      **ppRtpSess
    );

RTPSTDAPI DeleteRtpSess(
        RtpSess_t       *pRtpSess
    );

RTPSTDAPI CreateRtpAddr(
        RtpSess_t       *pRtpSess,
        RtpAddr_t      **ppRtpAddr,
        DWORD            dwFlags
    );

RTPSTDAPI DeleteRtpAddr(
        RtpSess_t       *pRtpSess,
        RtpAddr_t       *pRtpAddr
    );

RTPSTDAPI RtpControl(
        RtpSess_t       *pRtpSess,
        DWORD            dwControl,
        DWORD_PTR        dwPar1,
        DWORD_PTR        dwPar2
    );

RTPSTDAPI RtpGetLastError(
        RtpSess_t       *pRtpSess
    );

RTPSTDAPI RtpRegisterRecvCallback(
        RtpAddr_t       *pRtpAddr,
        PRTP_RECVCOMPLETIONFUNC pRtpRecvCompletionFunc
    );

RTPSTDAPI RtpRecvFrom(
        RtpAddr_t       *pRtpAddr,
        WSABUF          *pWSABuf,
        void            *pvUserInfo1,
        void            *pvUserInfo2
    );

RTPSTDAPI RtpSendTo(
        RtpAddr_t       *pRtpAddr,
        WSABUF          *pWSABuf,
        DWORD            dwWSABufCount,
        DWORD            dwTimeStamp,
        DWORD            dwSendFlags
    );

RTPSTDAPI RtpStart(
        RtpSess_t       *pRtpSess,
        DWORD            dwFlags
    );

RTPSTDAPI RtpStop(
        RtpSess_t       *pRtpSess,
        DWORD            dwFlags
    );


#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif /* _msapi_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\dsrtp\src\source.cpp ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    source.cpp
 *
 *  Abstract:
 *
 *    CRtpSourceFilter and CRtpOutputPin implementation
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/18 created
 *
 **********************************************************************/

#include <winsock2.h>

#include "classes.h"
#include "dsglob.h"
#include "rtpqos.h"
#include "rtpuser.h"
#include "rtppt.h"
#include "rtpdemux.h"
#include "rtprecv.h"
#include "rtpred.h"
#include "rtpaddr.h"

#include "tapirtp.h"
#include "dsrtpid.h"

#include "rtpglobs.h"
#include "msrtpapi.h"

/**********************************************************************
 * Callback function to process a packet arrival in a CRtpSourceFilter
 **********************************************************************/
void CALLBACK DsRecvCompletionFunc(
        void            *pvUserInfo1, /* pCRtpSourceFilter */
        void            *pvUserInfo2, /* pIMediaSample */
        void            *pvUserInfo3, /* pIPin of pCRtpOutputPin */
        RtpUser_t       *pRtpUser,
        double           dPlayTime,
        DWORD            dwError,
        long             lHdrSize,
        DWORD            dwTransfered,
        DWORD            dwFlags
    )
{
    CRtpSourceFilter *pCRtpSourceFilter;
    
    pCRtpSourceFilter = (CRtpSourceFilter *)pvUserInfo1;

    
    pCRtpSourceFilter->SourceRecvCompletion(
            (IMediaSample *)pvUserInfo2,
            pvUserInfo3,
            pRtpUser,
            dPlayTime,
            dwError,
            lHdrSize,
            dwTransfered,
            dwFlags
        );
}

/**********************************************************************
 *
 * RTP Output Pin class implementation: CRtpOutputPin
 *
 **********************************************************************/

/*
 * CRtpOutputPin constructor
 * */
CRtpOutputPin::CRtpOutputPin(CRtpSourceFilter *pCRtpSourceFilter,
                             CIRtpSession     *pCIRtpSession,
                             HRESULT          *phr,
                             LPCWSTR           pPinName)
    :    
    CBASEOUTPUTPIN(
            _T("CRtpOutputPin"),
            pCRtpSourceFilter,                   
            pCRtpSourceFilter->pStateLock(),                     
            phr,                       
            pPinName
        )
{
    m_dwObjectID = OBJECTID_RTPOPIN;
    
    m_pCRtpSourceFilter = pCRtpSourceFilter;
    
    m_pCIRtpSession = pCIRtpSession;
    
    m_bPT = NO_PAYLOADTYPE;

    m_bCanReconnectWhenActive = TRUE;

#if USE_GRAPHEDT > 0
      /* Temporary SetMediaType */
    m_iCurrFormat = -1;
#endif

    if (phr)
    {
        *phr = NOERROR;
    }
    
    /* TODO should fail if a valid filter and address are not passed */
}

/*
 * CRtpOutputPin destructor
 * */
CRtpOutputPin::~CRtpOutputPin()
{
    INVALIDATE_OBJECTID(m_dwObjectID);
}

void *CRtpOutputPin::operator new(size_t size)
{
    void            *pVoid;
    
    TraceFunctionName("CRtpOutputPin::operator new");

    pVoid = RtpHeapAlloc(g_pRtpSourceHeap, size);

    if (pVoid)
    {
        ZeroMemory(pVoid, size);
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                _T("%s: failed to allocate memory:%u"),
                _fname, size
            ));
    }
    
    return(pVoid);
}

void CRtpOutputPin::operator delete(void *pVoid)
{
    if (pVoid)
    {
        RtpHeapFree(g_pRtpSourceHeap, pVoid);
    }
}

/**************************************************
 * CBasePin overrided methods
 **************************************************/
#if USE_GRAPHEDT <= 0 /* Temporary SetMediaType (stmtype.cpp) */
/*
 * Verify we can handle this format
 * */
HRESULT CRtpOutputPin::CheckMediaType(const CMediaType *pCMediaType)
{
    if (m_bPT == NO_PAYLOADTYPE)
    {
        /* TODO: we might want to check against the list. */
        return(NOERROR);
    }

    if (m_mt != *pCMediaType)
    {
        /* We only accept one media type when the payload type is set. */
        return(VFW_E_INVALIDMEDIATYPE);
    }

    return(NOERROR);
}

/*
 * Get the media type delivered by the output pins
 * */
HRESULT CRtpOutputPin::GetMediaType(int iPosition, CMediaType *pCMediaType)
{
    HRESULT hr;
    
    hr = NOERROR;

    if (m_bPT == NO_PAYLOADTYPE)
    {
        hr = ((CRtpSourceFilter *)m_pFilter)->
            GetMediaType(iPosition, pCMediaType);
    }
    else
    {
        if (iPosition != 0)
        {
            return(VFW_S_NO_MORE_ITEMS);
        }

        /* Only return the current format */
        *pCMediaType = m_mt;
    }

    return(hr);
}
#endif /* USE_GRAPHEDT <= 0 */

/* The purpose of overriding this method is to enable the
 * corresponding output pin after it is connected */
STDMETHODIMP CRtpOutputPin::Connect(
        IPin            *pReceivePin,
        const AM_MEDIA_TYPE *pmt   // optional media type
    )
{
    HRESULT          hr;

    TraceFunctionName("CRtpOutputPin::Connect");
    
    CAutoLock cObjectLock(m_pLock);
    
    /* Call base class */
    hr = CBasePin::Connect(pReceivePin, pmt);

    if (SUCCEEDED(hr) && m_pRtpOutput)
    {
        /* Now enable the RTP output */
        RtpOutputEnable(m_pRtpOutput, TRUE);
    }

    TraceRetail((
            CLASS_INFO, GROUP_DSHOW, S_DSHOW_SOURCE,
            _T("%s: pCRtpOutputPin[%p] pRtpOutput[%p] hr:%u"),
            _fname, this, m_pRtpOutput, hr
        ));
  
    return(hr);
}

/* The purpose of overriding this method is to allow the disconnection
 * while the filter is still running, and disable and unmap the RTP
 * output when this happens. */
STDMETHODIMP CRtpOutputPin::Disconnect()
{
    HRESULT          hr;
    
    TraceFunctionName("CRtpOutputPin::Disconnect");
    
    CAutoLock cObjectLock(m_pLock);

    /*
     * Do not check if the filter is active
     */
#if 0
    /* This code is here only for reference */
    if (!IsStopped()) {
        return VFW_E_NOT_STOPPED;
    }
#endif

    /* Disable the corresponding RTP output so it will not be selected
     * for another participant */
    if (m_pRtpOutput)
    {
        RtpOutputEnable(m_pRtpOutput, FALSE);
    }
    
    /* Unmapping is needed as the pin, once unmapped, might stay
     * disconnected. During that time it should not be mapped to
     * anyone */
    m_pCRtpSourceFilter->SetMappingState(
            -1,   /* Don't use index */
            static_cast<IPin *>(this),
            0,    /* Use whatever SSRC is currently mapped */
            FALSE /* Unmap */);
    
    hr = DisconnectInternal();
    
    TraceRetail((
            CLASS_INFO, GROUP_DSHOW, S_DSHOW_SOURCE,
            _T("%s: pCRtpOutputPin[%p] pRtpOutput[%p] hr:%u"),
            _fname, this, m_pRtpOutput, hr
        ));

    return(hr);
}

/**************************************************
 * CBaseOutputPin overrided methods
 **************************************************/

HRESULT CRtpOutputPin::DecideAllocator(
        IMemInputPin   *pPin,
        IMemAllocator **ppAlloc
    )
{
    HRESULT hr;
    ALLOCATOR_PROPERTIES prop;

    hr = NOERROR;
    *ppAlloc = NULL;

    /* Get requested properties from downstream filter */
    ZeroMemory(&prop, sizeof(prop));
    pPin->GetAllocatorRequirements(&prop);

    /* if he doesn't care about alignment, then set it to 1 */
    if (prop.cbAlign == 0)
    {
        prop.cbAlign = 1;
    }

	RTPASSERT(m_pCRtpSourceFilter->m_pCRtpSourceAllocator);

    *ppAlloc = m_pCRtpSourceFilter->m_pCRtpSourceAllocator;
    
    if (*ppAlloc != NULL)
    {
        /* We will either keep a reference to this or release it below
         * on an error return */
        (*ppAlloc)->AddRef();

	    hr = DecideBufferSize(*ppAlloc, &prop);
	    if (SUCCEEDED(hr))
        {
	        hr = pPin->NotifyAllocator(*ppAlloc, FALSE);
	        if (SUCCEEDED(hr))
            {
    		    return(NOERROR);
	        }
	    }
    }

    /* We may or may not have an allocator to release at this
     * point. */
    if (*ppAlloc)
    {
	    (*ppAlloc)->Release();
	    *ppAlloc = NULL;
    }
    
    return(hr);
}

/*
 * Decide the number of buffers, size, etc.
 * */
HRESULT CRtpOutputPin::DecideBufferSize(
        IMemAllocator        *pIMemAllocator,
        ALLOCATOR_PROPERTIES *pProperties
    )
{
    HRESULT          hr;
    ALLOCATOR_PROPERTIES ActualProperties; /* negotiated properties */

    /* default to something reasonable */
    if (pProperties->cBuffers == 0)
    {
        // use hard-coded defaults values for now
        /* I will hold at the most 2 samples while waiting for
         * redundancy (when using red (i, i-3)), in addition, have 2
         * more ready to receive new packets */
        pProperties->cBuffers = max(RTPDEFAULT_SAMPLE_NUM,
                                    RTP_RED_MAXDISTANCE - 1 + 2);
        pProperties->cbBuffer = RTPDEFAULT_SAMPLE_SIZE;   

        pProperties->cbPrefix = RTPDEFAULT_SAMPLE_PREFIX;      
        pProperties->cbAlign  = RTPDEFAULT_SAMPLE_ALIGN;      
    }

    pProperties->cBuffers = max(pProperties->cBuffers, RTPDEFAULT_SAMPLE_NUM);

    /* Get current properties */
    hr = pIMemAllocator->GetProperties(&ActualProperties);

    if (FAILED(hr))
    {
        return(hr);
    }

    if(m_pFilter->IsActive())
    {
        /* Add the number of buffers requested */
        if (pProperties->cBuffers > ActualProperties.cBuffers
            || pProperties->cbBuffer > ActualProperties.cbBuffer
            || pProperties->cbPrefix > ActualProperties.cbPrefix)
        {
            /* We don't want to change the allocator property at runtime. */
            return(E_FAIL);
        }
        
        return(NOERROR);
    }
    
    /* Add the number of buffers requested */
    pProperties->cBuffers += ActualProperties.cBuffers;

    /* ... and don't let that number be smaller than a certain value */
    pProperties->cBuffers = max(pProperties->cBuffers,
                                2*RTPDEFAULT_SAMPLE_NUM);
    
    /* ...  use the biggest buffer size */
    pProperties->cbBuffer =
        max(pProperties->cbBuffer, ActualProperties.cbBuffer);

    /* ... and max prefix */
    pProperties->cbPrefix =
        max(pProperties->cbPrefix, ActualProperties.cbPrefix);
    
    /* attempt to set negotiated/default values */
    hr = pIMemAllocator->SetProperties(pProperties, &ActualProperties);

    return(hr);
}

/*
 * Process 1 sample and repost the buffer */
void CRtpOutputPin::OutPinRecvCompletion(
        IMediaSample    *pIMediaSample,
        BYTE             bPT
    )
{
    HRESULT          hr;
    DWORD            dwFrequency;

    TraceFunctionName("CRtpOutputPin::OutPinRecvCompletion");
    
    if (bPT == m_bPT)
    {
        hr = Deliver(pIMediaSample);
        return;
    }

    if (m_pInputPin == NULL)
    {
        return;
    }

#if USE_GRAPHEDT > 0
    if (m_pInputPin != NULL)
    {
        if (m_bPT != bPT)
        {
            m_bPT = bPT;

            TraceRetail((
                    CLASS_INFO, GROUP_DSHOW, S_DSHOW_SOURCE,
                    _T("%s: CRtpOutputPin[0x%p] pRtpUser[0x%p] ")
                    _T("Receiving PT:%u"),
                    _fname, this, m_pRtpOutput->pRtpUser, bPT
                ));
        }

        hr = Deliver(pIMediaSample);
    }

    return;
#else /* USE_GRAPHEDT > 0 */
    // try dynamic format change.
    CMediaType MediaType;
    
    hr = m_pCRtpSourceFilter->
        PayloadTypeToMediaType(bPT, &MediaType, &dwFrequency);

    if (FAILED(hr))
    {
        // TODO: log, we got some packets with strange PT.
        return;
    }
#if USE_DYNGRAPH > 0
    
#ifdef DO_IT_OURSELVES
    
    /* This is a new payload type. Ask if the downstream
     * filter likes it. */
    IPinConnection *pIPinConnection;
    hr = m_pInputPin->QueryInterface(&pIPinConnection);
    if (FAILED(hr))
    {
        // we can't do dynamic format change here.
        return;
    }

    hr = pIPinConnection->DynamicQueryAccept(&MediaType);
    pIPinConnection->Release();
    
    if (hr == S_OK) // QuerryAccept only returns S_OK or S_FALSE.
    {
        hr = pIMediaSample->SetMediaType(&MediaType);
        if (SUCCEEDED(hr))
        {
            hr = Deliver(pIMediaSample);
            m_bPT = bPT;
            pIMediaSample->SetMediaType(NULL);
        }
        return;
    }

    // pGraph is not addrefed, so we don't need to release it either.
    // what if the graph is not valid any more? what lock should I hold here?
    if (!m_pGraphConfig)
    {
        // this should not happen.
        return;
    }

    // we have to set the media type here for the reconnect code.
    m_bPT = bPT;
    SetMediaType(&MediaType);

    /*  Now call through to the graph to reconnect us */
    hr = m_pGraphConfig->Reconnect(
        this, 
        NULL, 
        NULL,
        m_hStopEvent,
        AM_GRAPH_CONFIG_RECONNECT_CACHE_REMOVED_FILTERS 
        );

    pGraphConfig->Release();

    // TBD - This should be in the filter graph
    //m_pFilter->NotifyEvent(EC_GRAPH_CHANGED, 0, 0);  

#else // DO_IT_OURSELVES

    // we have to set the media type here for the reconnect code.
    m_bPT = bPT;
    SetMediaType(&MediaType);

    // try dynamic format change.
    hr = ChangeMediaType(&MediaType);
    if (FAILED(hr))
    {
        // TODO: fire events.
        return;
    }

    pIMediaSample->SetDiscontinuity(TRUE);
    hr = pIMediaSample->SetMediaType(&MediaType);
    if (SUCCEEDED(hr))
    {
        hr = Deliver(pIMediaSample);
        pIMediaSample->SetMediaType(NULL);
    }

    return;

#endif // DO_IT_OURSELVES
    
#else  /* USE_DYNGRAPH > 0 */

    /* This is a new payload type. Ask if the downstream
     * filter likes it. */
    IPin *pIPin;
    hr = m_pInputPin->QueryInterface(&pIPin);
    ASSERT(SUCCEEDED(hr));

    hr = pIPin->QueryAccept(&MediaType);
    pIPin->Release();
            
    if (hr != S_OK) // QueryAccept returns only S_OK or S_FALSE.
    {
        TraceRetail((
                CLASS_WARNING, GROUP_DSHOW, S_DSHOW_SOURCE,
                _T("%s: CRtpOutputPin[0x%p] pRtpUser[0x%p] ")
                _T("PT:%u pIPin->QueryAccept failed:0x%X"),
                _fname, this, m_pRtpOutput->pRtpUser, bPT, hr
            ));

        return;
    }

    hr = pIMediaSample->SetMediaType(&MediaType);
    if (SUCCEEDED(hr))
    {
        hr = Deliver(pIMediaSample);
        /* If deliver fails, do not update m_bPT because that means
         * the media type might not have been propagated to all the
         * filters down stream, hence I want to try again on next
         * packet until it succeeds */
        if (SUCCEEDED(hr))
        {
            m_bPT = bPT;
        }

        pIMediaSample->SetMediaType(NULL);
    }
    return;
#endif /* USE_DYNGRAPH > 0 */
    
#endif /* USE_GRAPHEDT > 0 */
}

/**************************************************
 * IQualityControl overrided methods
 **************************************************/

HRESULT CRtpOutputPin::Active(void)
{
    m_bPT = NO_PAYLOADTYPE;
    return CBASEOUTPUTPIN::Active();
}

STDMETHODIMP CRtpOutputPin::Notify(IBaseFilter *pSelf, Quality q)
{
    return(S_FALSE);
}

/**********************************************************************
 *
 * CRtpSourceAllocator private memory allocator
 *
 **********************************************************************/

CRtpMediaSample::CRtpMediaSample(
        TCHAR           *pName,
        CRtpSourceAllocator *pAllocator,
        HRESULT         *phr
    )
    : CMediaSample(pName, pAllocator, phr, NULL, 0)
{
    m_dwObjectID = OBJECTID_RTPSAMPLE;
}

CRtpMediaSample::~CRtpMediaSample()
{
    TraceFunctionName("CRtpMediaSample::~CRtpMediaSample");

    if (m_dwObjectID != OBJECTID_RTPSAMPLE)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                _T("%s: pCRtpMediaSample[0x%p] ")
                _T("Invalid object ID 0x%X != 0x%X"),
                _fname, this,
                m_dwObjectID, OBJECTID_RTPSAMPLE
            ));

        return;
    }

    INVALIDATE_OBJECTID(m_dwObjectID);
}

void *CRtpMediaSample::operator new(size_t size, long lBufferSize)
{
    void            *pVoid;
    long             lTotalSize;

    TraceFunctionName("CRtpMediaSample::operator new");

    lTotalSize = size + lBufferSize;
    
    pVoid = RtpHeapAlloc(g_pRtpSampleHeap, lTotalSize);

    if (pVoid)
    {
        /* Initialize to zero only the sizeof(CRtpMediaSample) */
        ZeroMemory(pVoid, size);
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                _T("%s: failed to allocate memory:%u+%u=%u"),
                _fname, size, lBufferSize, size+lBufferSize
            ));
    }

    return(pVoid);
}
    
void CRtpMediaSample::operator delete(void *pVoid)
{
    if (pVoid)
    {
        RtpHeapFree(g_pRtpSampleHeap, pVoid);
    }
}

CRtpSourceAllocator::CRtpSourceAllocator(
        TCHAR           *pName,
        LPUNKNOWN        pUnk,
        HRESULT         *phr,
        CRtpSourceFilter *pCRtpSourceFilter 
    )
    :
    CBaseAllocator(pName, pUnk, phr)
{
    BOOL             bOk;
    HRESULT          hr;
    
    if (*phr != NOERROR)
    {
        /* Already an error?, return with same error */
        return;
    }

    hr = NOERROR;
    
    m_dwObjectID = OBJECTID_RTPALLOCATOR;

    m_pCRtpSourceFilter = pCRtpSourceFilter;

    bOk = RtpInitializeCriticalSection(&m_RtpSampleCritSect,
                                       this,
                                       _T("m_RtpSamplesCritSect"));

    if (!bOk)
    {
        hr = RTPERR_CRITSECT;;
    }

    *phr = hr;
}

CRtpSourceAllocator::~CRtpSourceAllocator()
{
    long             lCount;
    RtpQueueItem_t  *pRtpQueueItem;
    CRtpMediaSample *pCRtpMediaSample;
    
    TraceFunctionName("CRtpSourceAllocator::~CRtpSourceAllocator");

    if (m_dwObjectID != OBJECTID_RTPALLOCATOR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                _T("%s: pCRtpSourceAllocator[0x%p] ")
                _T("Invalid object ID 0x%X != 0x%X"),
                _fname, this,
                m_dwObjectID, OBJECTID_RTPALLOCATOR
            ));

        return;
    }

    /* Verify there are no samples in the busy queue, and release all
     * free samples */

    lCount = GetQueueSize(&m_RtpBusySamplesQ);
    
    if (lCount > 0)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                _T("%s: pCRtpSourceAllocator[0x%p] Busy samples:%u"),
                _fname, this, lCount
            ));

        while( (pRtpQueueItem = dequeuef(&m_RtpBusySamplesQ,
                                         &m_RtpSampleCritSect)) )
        {
            pCRtpMediaSample =
                CONTAINING_RECORD(pRtpQueueItem,
                                  CRtpMediaSample,
                                  m_RtpSampleItem);

            delete pCRtpMediaSample;
        }
    }
    
    while( (pRtpQueueItem = dequeuef(&m_RtpFreeSamplesQ,
                                     &m_RtpSampleCritSect)) )
    {
        pCRtpMediaSample =
            CONTAINING_RECORD(pRtpQueueItem,
                              CRtpMediaSample,
                              m_RtpSampleItem);

        delete pCRtpMediaSample;
    }

    RtpDeleteCriticalSection(&m_RtpSampleCritSect);
    
    INVALIDATE_OBJECTID(m_dwObjectID);
}

/**************************************************
 * INonDelegatingUnknown implemented methods
 **************************************************/

STDMETHODIMP CRtpSourceAllocator::NonDelegatingQueryInterface(
        REFIID           riid,
        void           **ppv
    )
{
    if (riid == __uuidof(IMemAllocator))
    {
        return GetInterface((IMemAllocator *)this, ppv);
    }

    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
}

/**************************************************
 * IMemAllocator implemented methods
 **************************************************/

STDMETHODIMP CRtpSourceAllocator::SetProperties(
        ALLOCATOR_PROPERTIES *pRequest,
        ALLOCATOR_PROPERTIES *pActual
    )
{
    TraceFunctionName("CRtpSourceAllocator::SetProperties");

    if (!pRequest || !pActual)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                _T("%s: pCRtpSourceAllocator[0x%p] NULL pointer passed:%u"),
                _fname, this
            ));

        return(RTPERR_POINTER);
    }

    CAutoLock cObjectLock(this);
    
    pActual->cbBuffer = m_lSize = pRequest->cbBuffer;
    pActual->cBuffers = m_lCount = pRequest->cBuffers;
    pActual->cbAlign = m_lAlignment = pRequest->cbAlign;
    pActual->cbPrefix = m_lPrefix = pRequest->cbPrefix;

    return(NOERROR);
}

STDMETHODIMP CRtpSourceAllocator::GetProperties(
        ALLOCATOR_PROPERTIES *pActual
    )
{
    CAutoLock cObjectLock(this);

    pActual->cbBuffer = m_lSize;
    pActual->cBuffers = m_lCount;
    pActual->cbAlign = m_lAlignment;
    pActual->cbPrefix = m_lPrefix;
   
    return(NOERROR);
}

STDMETHODIMP CRtpSourceAllocator::Commit()
{
    return(NOERROR);
}

STDMETHODIMP CRtpSourceAllocator::Decommit()
{
    return(NOERROR);
}

STDMETHODIMP CRtpSourceAllocator::GetBuffer(
        IMediaSample   **ppIMedisSample,
        REFERENCE_TIME  *pStartTime,
        REFERENCE_TIME  *pEndTime,
        DWORD            dwFlags
    )
{
    HRESULT          hr;
    BOOL             bOk;
    CRtpMediaSample *pCRtpMediaSample;
    RtpQueueItem_t  *pRtpQueueItem;
    BYTE            *pBuffer;

    TraceFunctionName("CRtpSourceAllocator::GetBuffer");

    pRtpQueueItem = (RtpQueueItem_t *)NULL;
    
    bOk = RtpEnterCriticalSection(&m_RtpSampleCritSect);

    if (!bOk)
    {
        hr = RTPERR_CRITSECT;

        goto end;
    }
    
    hr = RTPERR_RESOURCES;
    
    if (GetQueueSize(&m_RtpFreeSamplesQ) > 0)
    {
        /* If we have at least one free sample, get it */
        pRtpQueueItem = dequeuef(&m_RtpFreeSamplesQ, NULL);

        pCRtpMediaSample =
            CONTAINING_RECORD(pRtpQueueItem, CRtpMediaSample, m_RtpSampleItem);
    }

    RtpLeaveCriticalSection(&m_RtpSampleCritSect);

    if (!pRtpQueueItem)
    {
        /* Create a new sample */
        pCRtpMediaSample =
            new(m_lSize + m_lPrefix) CRtpMediaSample(_T("RTP Media Sample"),
                                                     this,
                                                     &hr);

        if (pCRtpMediaSample)
        {
            pBuffer = ((BYTE *)pCRtpMediaSample) +
                sizeof(CRtpMediaSample) + m_lPrefix;
            
            pCRtpMediaSample->SetPointer(pBuffer, m_lSize);

            InterlockedIncrement(&m_lAllocated);

            if (m_lAllocated > m_lCount)
            {
                TraceRetail((
                        CLASS_WARNING, GROUP_DSHOW, S_DSHOW_SOURCE,
                        _T("%s: pCRtpSourceAllocator[0x%p] ")
                        _T("Buffers allocated exceeds agreed number: %d > %d"),
                        _fname, this, m_lAllocated, m_lCount
                    ));
            }
        }
    }

    if (pCRtpMediaSample)
    {
        /* The RefCount should be 0 if taken from the free list or
         * just created */
        if (pCRtpMediaSample->m_cRef != 0)
        {
            TraceRetail((
                    CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                    _T("%s: pCRtpSourceAllocator[0x%p] RefCount:%u != 0"),
                    _fname, this, pCRtpMediaSample->m_cRef
                ));
        }

        pCRtpMediaSample->m_cRef = 1;

        /* Keep it in the busy queue */
        enqueuel(&m_RtpBusySamplesQ,
                 &m_RtpSampleCritSect,
                 &pCRtpMediaSample->m_RtpSampleItem);

        *ppIMedisSample = pCRtpMediaSample;

        hr = NOERROR;
    }

 end:
    return(hr);
}

STDMETHODIMP CRtpSourceAllocator::ReleaseBuffer(
        IMediaSample    *pIMediaSample
    )
{
    CRtpMediaSample *pCRtpMediaSample;

    pCRtpMediaSample = (CRtpMediaSample *)pIMediaSample;
    
    move2qf(&m_RtpFreeSamplesQ,
            &m_RtpBusySamplesQ,
            &m_RtpSampleCritSect,
            &pCRtpMediaSample->m_RtpSampleItem);
    
    return(NOERROR);
}

STDMETHODIMP CRtpSourceAllocator::GetFreeCount(LONG *plBuffersFree)
{
    if (plBuffersFree)
    {
        *plBuffersFree = GetQueueSize(&m_RtpFreeSamplesQ);
    }
    
    return(NOERROR);
}

void CRtpSourceAllocator::Free(void)
{
    RTPASSERT(0);
}

HRESULT CRtpSourceAllocator::Alloc(void)
{
    RTPASSERT(0);
    return(NOERROR);
}

void *CRtpSourceAllocator::operator new(size_t size)
{
    void            *pVoid;
    
    TraceFunctionName("CRtpSourceFilter::operator new");

    pVoid = RtpHeapAlloc(g_pRtpSourceHeap, size);

    if (pVoid)
    {
        ZeroMemory(pVoid, size);
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                _T("%s: failed to allocate memory:%u"),
                _fname, size
            ));
    }
    
    return(pVoid);
}

void CRtpSourceAllocator::operator delete(void *pVoid)
{
    if (pVoid)
    {
        RtpHeapFree(g_pRtpSourceHeap, pVoid);
    }
}

/**********************************************************************
 *
 * RTP Source Filter class implementation: CRtpSourceFilter
 *
 **********************************************************************/

/*
 * CRtpSourceFilter constructor
 * */
CRtpSourceFilter::CRtpSourceFilter(LPUNKNOWN pUnk, HRESULT *phr)
    :
    CBaseFilter(
            _T("CRtpSourceFilter"), 
            pUnk, 
            &m_cRtpSrcCritSec, 
            __uuidof(MSRTPSourceFilter)
        ),

    CIRtpSession(
            pUnk,
            phr,
            RtpBitPar(FGADDR_IRTP_ISRECV)
        )
{
    HRESULT              hr;
    int                  i;
    BOOL                 bOk;
    long                 lMaxFilter;
    CRtpOutputPin       *pCRtpOutputPin;
    
    TraceFunctionName("CRtpSourceFilter::CRtpSourceFilter");

    m_pCIRtpSession = static_cast<CIRtpSession *>(this);
    
    /* Test for NULL pointers, do not test pUnk which may be NULL */
    if (!phr)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                _T("%s: CRtpSourceFilter[0x%p] has phr NULL"),
                _fname, this
            ));
        
        /* MAYDO this is a really bad situation, we can not pass any
         * error and the memory for this object is allocated, this may
         * be fixed if this parameter is tested before allocating
         * memory using an overriden new */

        phr = &hr; /* Use this pointer instead */
    }

    SetBaseFilter(this);
    
    *phr = NOERROR;

    lMaxFilter = InterlockedIncrement(&g_RtpContext.lNumSourceFilter);
    if (lMaxFilter > g_RtpContext.lMaxNumSourceFilter)
    {
        g_RtpContext.lMaxNumSourceFilter = lMaxFilter;
    }
    
    /* Initialize some fields */
    m_dwObjectID = OBJECTID_RTPSOURCE;

    bOk = RtpInitializeCriticalSection(&m_OutPinsCritSect,
                                       this,
                                       _T("m_OutPinsCritSec"));

    if (bOk == FALSE)
    {
        *phr = RTPERR_CRITSECT;
        goto bail;
    }
    
#if USE_DYNGRAPH > 0
    /* Create the stop event */
    m_hStopEvent = ::CreateEvent( NULL, FALSE, FALSE, NULL );

    /* The Win32 SDK function CreateEvent() returns NULL if an error occurs */
    if( m_hStopEvent == NULL )
    {
        *phr = E_OUTOFMEMORY;
        goto bail;
    }
#endif
    
    /* Create the allocator to use by all the output pins */
    m_pCRtpSourceAllocator = new CRtpSourceAllocator(
            _T("CRtpSourceAllocator"),
            NULL,
            phr,
            this);

    if (FAILED(*phr))
    {
        /* pass up the same returned error */
        goto bail;
    }
    
    if (!m_pCRtpSourceAllocator)
    {
        /* low in memory, failed to create object */
        *phr = E_OUTOFMEMORY;
        goto bail;
    }

    /* Add ref our allocator */
    m_pCRtpSourceAllocator->AddRef();

#if USE_GRAPHEDT > 0
    /* When using graphedt, initialize automatically, the coockie can
     * be NULL as a global variable will be shared between source and
     * render */
    *phr = m_pCIRtpSession->Init(NULL, RtpBitPar2(RTPINITFG_AUTO, RTPINITFG_QOS));
    
    if (FAILED(*phr))
    {
        /* pass up the same returned error */
        goto bail;
    }

    /* Set 2 output pins */
    SetPinCount(2, RTPDMXMODE_AUTO);
#else
    SetPinCount(1, RTPDMXMODE_AUTO);
#endif /* USE_GRAPHEDT > 0 */
    
    *phr = NOERROR;

    TraceRetail((
            CLASS_INFO, GROUP_DSHOW, S_DSHOW_SOURCE,
            _T("%s: CRtpSourceFilter[0x%p] CIRtpSession[0x%p] created"),
            _fname, this, static_cast<CIRtpSession *>(this)
        ));
    
    return;

 bail:
    Cleanup();
}

/*
 * RtpSourceFilter destructor
 * */
CRtpSourceFilter::~CRtpSourceFilter()
{
    RtpAddr_t       *pRtpAddr;
    
    TraceFunctionName("CRtpSourceFilter::~CRtpSourceFilter");

    TraceRetail((
            CLASS_INFO, GROUP_DSHOW, S_DSHOW_SOURCE,
            _T("%s: CRtpSourceFilter[0x%p] CIRtpSession[0x%p] being deleted..."),
            _fname, this, static_cast<CIRtpSession *>(this)
        ));
    
    if (m_RtpFilterState == State_Running)
    {
        TraceRetail((
                CLASS_WARNING, GROUP_DSHOW, S_DSHOW_SOURCE,
                _T("%s: Filter[0x%p] being deleted while still running"),
                _fname, this
            ));

        /* Will call RtpStop, which in turn will call RtpRealstop if
         * FGADDR_IRTP_PERSISTSOCKETS is not set, otherwise the
         * session will be stopped for DShow but in RTP will continue
         * running in a muted state */
        Stop();
    }

    pRtpAddr = m_pCIRtpSession->GetpRtpAddr();

    if (pRtpAddr &&
        RtpBitTest(pRtpAddr->dwIRtpFlags, FGADDR_IRTP_PERSISTSOCKETS))
    {
        /* If FGADDR_IRTP_PERSISTSOCKETS is set, the session may be
         * still running in a muted state regardless the call to the
         * DShow Stop, to force a real stop, MUST use the flag
         * provided for that */
        RtpStop(pRtpAddr->pRtpSess,
                RtpBitPar2(FGADDR_ISRECV, FGADDR_FORCESTOP));
    }

    Cleanup();

    InterlockedDecrement(&g_RtpContext.lNumSourceFilter);

    m_pCIRtpSession = (CIRtpSession *)NULL;
    
    INVALIDATE_OBJECTID(m_dwObjectID);
}

void CRtpSourceFilter::Cleanup(void)
{
    long             lCount;
    CRtpOutputPin   *pCRtpOutputPin;
    RtpQueueItem_t  *pRtpQueueItem;

    TraceFunctionName("CRtpSourceFilter::Cleanup");

    /* Remove the DShow pins <-> RTP outputs mapping */
    UnmapPinsFromOutputs();
    
    /* Delete all the output pins */
    while( (pRtpQueueItem = m_OutPinsQ.pFirst) )
    {
        dequeue(&m_OutPinsQ, &m_OutPinsCritSect, pRtpQueueItem);

        pCRtpOutputPin =
            CONTAINING_RECORD(pRtpQueueItem, CRtpOutputPin, m_OutputPinQItem);

        delete pCRtpOutputPin;
    }

    if (m_pCRtpSourceAllocator)
    {
        lCount = m_pCRtpSourceAllocator->Release();
        if ( lCount > 0)
        {
            TraceRetail((
                    CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                    _T("%s: CRtpSourceAllocator ")
                    _T("unexpected RefCount:%d > 0"),
                    _fname, lCount
                ));
        }
        
        m_pCRtpSourceAllocator = (CRtpSourceAllocator *)NULL;
    }

    FlushFormatMappings();
    
    RtpDeleteCriticalSection(&m_OutPinsCritSect);

#if USE_DYNGRAPH > 0
    if (m_hStopEvent)
    {
        CloseHandle(m_hStopEvent);
        m_hStopEvent = NULL;
    }
#endif
}

void *CRtpSourceFilter::operator new(size_t size)
{
    void            *pVoid;
    
    TraceFunctionName("CRtpSourceFilter::operator new");

    MSRtpInit2();
    
    pVoid = RtpHeapAlloc(g_pRtpSourceHeap, size);

    if (pVoid)
    {
        ZeroMemory(pVoid, size);
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                _T("%s: failed to allocate memory:%u"),
                _fname, size
            ));

        /* On low memory failure, the destructor will not be called,
         * so decrese the reference count that was increased above */
        MSRtpDelete2(); 
    }
    
    return(pVoid);
}

void CRtpSourceFilter::operator delete(void *pVoid)
{
    if (pVoid)
    {
        RtpHeapFree(g_pRtpSourceHeap, pVoid);
        
        /* Reduce the reference count only for objects that got
         * memory, those that failed to obtain memory do not increase
         * the counter */
        MSRtpDelete2();
    }
}

/*
 * Create a CRtpSourceFiltern instance (for active movie class factory)
 * */
CUnknown *CRtpSourceFilterCreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    /* Test for NULL pointers, do not test pUnk which may be NULL */
    if (!phr)
    {
        return((CUnknown *)NULL);
    }

    *phr = NOERROR;
   
    /* On failure during the constructor, the caller is responsible to
     * delete the object (that is consistent with DShow) */
    CRtpSourceFilter *pCRtpSourceFilter = new CRtpSourceFilter(pUnk, phr);

    if (!pCRtpSourceFilter)
    {
        *phr = RTPERR_MEMORY;
    }
        
    return(pCRtpSourceFilter);
}

/**************************************************
 * CBaseFilter overrided methods
 **************************************************/

/*
 * Get the number of output pins
 * */
int CRtpSourceFilter::GetPinCount()
{
    long                 lCount;
    BOOL                 bOk;

    lCount = 0;
    
    /* Lock pins queue */
    bOk = RtpEnterCriticalSection(&m_OutPinsCritSect);

    if (bOk)
    {
        lCount = GetQueueSize(&m_OutPinsQ);

        RtpLeaveCriticalSection(&m_OutPinsCritSect);
    }
    
    return((int)lCount);
}

/*
 * Get a reference to the nth pin
 * */
CBasePin *CRtpSourceFilter::GetPin(int n)
{
    BOOL                 bOk;
    CRtpOutputPin       *pCRtpOutputPin;
    RtpQueueItem_t      *pRtpQueueItem;

    pCRtpOutputPin = (CRtpOutputPin *)NULL;
    
    /* Lock pins queue */
    bOk = RtpEnterCriticalSection(&m_OutPinsCritSect);

    if (bOk)
    {
        /* TODO scan list and retrieve the nth element, check there
         * exist at least that many pins */
        if (n >= GetQueueSize(&m_OutPinsQ))
        {
            RtpLeaveCriticalSection(&m_OutPinsCritSect); 
            return((CBasePin *)NULL);
        }

        /* Get to the nth item */
        for(pRtpQueueItem = m_OutPinsQ.pFirst;
            n > 0;
            pRtpQueueItem = pRtpQueueItem->pNext, n--)
        {
            /* Empty body */;
        }

        pCRtpOutputPin =
            CONTAINING_RECORD(pRtpQueueItem, CRtpOutputPin, m_OutputPinQItem);

        RtpLeaveCriticalSection(&m_OutPinsCritSect); 
    }
    
    return(pCRtpOutputPin);
}

/* override GetState to report that we don't send any data when
 * paused, so renderers won't starve expecting that */
STDMETHODIMP CRtpSourceFilter::GetState(DWORD dwMSecs, FILTER_STATE *State)
{
    UNREFERENCED_PARAMETER(dwMSecs);

    CheckPointer(State, E_POINTER);

    ValidateReadWritePtr(State, sizeof(FILTER_STATE));

    *State = m_State;
    
    if (m_State == State_Paused)
    {
        return(VFW_S_CANT_CUE);
    }

    return(NOERROR);
}

/* Creates and start the worker thread */
STDMETHODIMP CRtpSourceFilter::Run(REFERENCE_TIME tStart)
{
    HRESULT          hr;
    RtpSess_t       *pRtpSess;
    RtpAddr_t       *pRtpAddr;
    WSABUF           WSABuf;
    IMediaSample    *pIMediaSample;
    DWORD            dwNumBuffs;
    DWORD            i;
    ALLOCATOR_PROPERTIES CurrentProps;

    TraceFunctionName("CRtpSourceFilter::Run");

    if (m_RtpFilterState == State_Running)
    {
        /* Alredy running, do nothing but call base class */
        hr = CBaseFilter::Run(tStart);

        return(hr);
    }
    
    hr = NOERROR;
    
    if (!m_pCIRtpSession->FlagTest(FGADDR_IRTP_INITDONE))
    {
        return(RTPERR_NOTINIT);
    }
    
    /* MAYDO when we have multiple addresses, there should be a way to
     * assign to each pin an address */

    pRtpSess = m_pCIRtpSession->GetpRtpSess();
    pRtpAddr = m_pCIRtpSession->GetpRtpAddr();

    if (pRtpSess && pRtpAddr)
    {
        /* Register buffers to use for asynchronous I/O, only if we
         * have a valid session and the receiver is not already
         * running. If we are using persistent sockets, the receiver
         * may be already running, in that case, do not attempt to
         * register more reception buffers because we may block */
    
        if(!RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_RUNRECV))
        {
            RTPASSERT(pRtpAddr->pRtpSess == pRtpSess);
        
            /* Get buffers and register them, they will be used later to
             * start asynchronous reception. After each packet is received
             * and delivered, a new asynchronous reception will be started. */

            /* Get current properties */
            m_pCRtpSourceAllocator->GetProperties(&CurrentProps);

            m_lPrefix = CurrentProps.cbPrefix;
        
            if (CurrentProps.cBuffers == 0)
            {
                TraceRetail((
                        CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                        _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                        _T("CurrentProps.cBuffers = 0"),
                        _fname, pRtpSess, pRtpAddr
                    ));

                CurrentProps.cBuffers = RTPDEFAULT_SAMPLE_NUM;
            }

            /* Register with RTP the completion function */
            RtpRegisterRecvCallback(pRtpAddr, DsRecvCompletionFunc);

            /* Set the number of buffers to keep */
            dwNumBuffs = CurrentProps.cBuffers;

            for(i = 0; i < dwNumBuffs; i++)
            {
                /* GetDeliveryBuffer AddRef pIMediaSample */
                hr = m_pCRtpSourceAllocator->
                    GetBuffer(&pIMediaSample, NULL, NULL, 0);

                /* the allocator might be decommited if the graph has
                 * changed dynamically. */
                if (hr == VFW_E_NOT_COMMITTED)
                {
                    hr = m_pCRtpSourceAllocator->Commit();
                    if (SUCCEEDED(hr))
                    {
                        hr = m_pCRtpSourceAllocator->
                            GetBuffer(&pIMediaSample, NULL, NULL, 0);
                    }
                }

                if (FAILED(hr))
                {
                    TraceRetail((
                            CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                            _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                            _T("GetBuffer failed: %u (0x%X)"),
                            _fname, pRtpSess, pRtpAddr,
                            hr, hr
                        ));
                
                    break;
                }
            
                WSABuf.len = pIMediaSample->GetSize();
                pIMediaSample->GetPointer((unsigned char **)&WSABuf.buf);

                /* register buffers for asynchronous I/O */
                hr = RtpRecvFrom(pRtpAddr,
                                 &WSABuf,
                                 this,           /* pvUserInfo1 */
                                 pIMediaSample); /* pvUserInfo2 */
            
                if (FAILED(hr))
                {
                    TraceRetail((
                            CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                            _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                            _T("RtpRecvFrom failed: %u (0x%X)"),
                            _fname, pRtpSess, pRtpAddr,
                            hr, hr
                        ));

                    pIMediaSample->Release();
                }
            }

            if (i > 0)
            {
                hr = NOERROR; /* succeeds with at least 1 buffer */
            
                TraceDebug((
                        CLASS_INFO, GROUP_DSHOW, S_DSHOW_SOURCE,
                        _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                        _T("overlapped I/O started:%d"),
                        _fname, pRtpSess, pRtpAddr,
                        i
                    ));
            }
        }
    }
    else
    {
        hr = RTPERR_INVALIDSTATE;
        
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("null session or address"),
                _fname, pRtpSess, pRtpAddr
            ));
    }
    
    /* Call base class */
    if (SUCCEEDED(hr))
    {
        hr = CBaseFilter::Run(tStart);

        /* This negative value will make the time just obtained be
         * used, it might be < 0, so zero is not accpetable here */
        m_StartTime = -999999999;
        
        /* Initialize sockets and start worker thread */
        if (SUCCEEDED(hr))
        {
            hr = RtpStart(pRtpSess, RtpBitPar(FGADDR_ISRECV));

            if (SUCCEEDED(hr))
            {
                m_RtpFilterState = State_Running;
            }
        }
    }
    
    return(hr);
}

/* Do per filter de-initialization */
STDMETHODIMP CRtpSourceFilter::Stop()
{
    HRESULT    hr;
    HRESULT    hr2;
    RtpSess_t *pRtpSess;

    if (m_RtpFilterState == State_Stopped)
    {
        /* Alredy stopped, do nothing but call base class */
        hr2 = CBaseFilter::Stop();
        
        return(hr2);
    }
    
    if (!m_pCIRtpSession->FlagTest(FGADDR_IRTP_INITDONE))
    {
        hr = RTPERR_NOTINIT;

        goto end;
    }
    
    pRtpSess = m_pCIRtpSession->GetpRtpSess();
    
    if (pRtpSess)
    {
        hr = RtpStop(pRtpSess, RtpBitPar(FGADDR_ISRECV));
    }
    else
    {
        hr = RTPERR_INVALIDSTATE;
    }

 end:
    /* Call base class */
    hr2 = CBaseFilter::Stop(); /* will decommit */

    if (SUCCEEDED(hr))
    {
        hr = hr2;
    }

    m_RtpFilterState = State_Stopped;
    
    return(hr);
}

#if USE_DYNGRAPH > 0

BOOL CRtpSourceFilter::ConfigurePins(
    IN IGraphConfig* pGraphConfig,
    IN HANDLE hEvent
    )
{
    BOOL                bOk;
    long                i;
    CRtpOutputPin       *pCRtpOutputPin;
    RtpQueueItem_t      *pRtpQueueItem;
    
    /* Lock pins queue */
    bOk = RtpEnterCriticalSection(&m_OutPinsCritSect);

    if (bOk)
    {
        for(i = 0, pRtpQueueItem = m_OutPinsQ.pFirst;
            i < GetQueueSize(&m_OutPinsQ);
            i++, pRtpQueueItem = pRtpQueueItem->pNext)
        {
            pCRtpOutputPin =
                CONTAINING_RECORD(pRtpQueueItem,
                                  CRtpOutputPin,
                                  m_OutputPinQItem);
            
            pCRtpOutputPin->SetConfigInfo( pGraphConfig, hEvent );
        }

        RtpLeaveCriticalSection(&m_OutPinsCritSect); 
    }

    return bOk;
}

// override JoinFilterGraph for dynamic filter graph change.
STDMETHODIMP CRtpSourceFilter::JoinFilterGraph( 
    IFilterGraph* pGraph, 
    LPCWSTR pName 
    )
{
    CAutoLock Lock( &m_cRtpSrcCritSec );

    HRESULT hr;
 
    // The filter is joining the filter graph.
    if( NULL != pGraph )
    {
        IGraphConfig* pGraphConfig = NULL;
 
        hr = pGraph->QueryInterface(&pGraphConfig);
        
        if( FAILED( hr ) )
        {
            /* TODO log error */
            return hr;
        }

        // we can't hold any refcount to the graph.
        pGraphConfig->Release();

        hr = CBaseFilter::JoinFilterGraph( pGraph, pName );
        if( FAILED( hr ) )
        {
            return hr;
        } 

        ConfigurePins(pGraphConfig, m_hStopEvent);
    }
    else
    {
        hr = CBaseFilter::JoinFilterGraph( pGraph, pName );
        if( FAILED( hr ) )
        {
            return hr;
        }

        // The filter is leaving the filter graph.
        ConfigurePins( NULL, NULL );
    }

    return S_OK;
}

#endif /* USE_DYNGRAPH */

/**************************************************
 * INonDelegatingUnknown implemented methods
 **************************************************/

/* obtain pointers to active movie and private interfaces */
STDMETHODIMP CRtpSourceFilter::NonDelegatingQueryInterface(
        REFIID riid,
        void **ppv
    )
{
    HRESULT hr;
    
    if (riid == __uuidof(IRtpMediaControl))
    {
        return GetInterface(static_cast<IRtpMediaControl *>(this), ppv);
    }
    else if (riid == __uuidof(IRtpDemux))
    {
        return GetInterface(static_cast<IRtpDemux *>(this), ppv);
    }
    else if (riid == __uuidof(IRtpSession))
    {
        return GetInterface(static_cast<IRtpSession *>(this), ppv);
    }
    else if (riid == __uuidof(IRtpRedundancy))
    {
        return GetInterface(static_cast<IRtpRedundancy *>(this), ppv);
    }
    else
    {
        hr = CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
    }

    return(hr);
}

/**************************************************
 * IRtpMediaControl implemented methods
 **************************************************/

/* set the mapping between RTP payload and DShow media types */
STDMETHODIMP CRtpSourceFilter::SetFormatMapping(
	    IN DWORD         dwRTPPayLoadType, 
        IN DWORD         dwFrequency,
        IN AM_MEDIA_TYPE *pMediaType
    )
{
    DWORD            dw;

    TraceFunctionName("CRtpSourceFilter::SetFormatMapping");

    ASSERT(!IsBadReadPtr(pMediaType, sizeof(AM_MEDIA_TYPE)));

    if (!pMediaType)
    {
        return(RTPERR_POINTER);
    }

    CAutoLock Lock( &m_cRtpSrcCritSec );
    
    for (dw = 0; dw < m_dwNumMediaTypeMappings; dw ++)
    {
        if (m_MediaTypeMappings[dw].dwRTPPayloadType == dwRTPPayLoadType)
        {
            // the RTP payload type is known, update the media type to be used.
            delete m_MediaTypeMappings[dw].pMediaType;
            m_MediaTypeMappings[dw].pMediaType = new CMediaType(*pMediaType);
            if (m_MediaTypeMappings[dw].pMediaType == NULL)
            {
                return RTPERR_MEMORY;
            }
            m_MediaTypeMappings[dw].dwFrequency = dwFrequency;

            AddPt2FrequencyMap(dwRTPPayLoadType, dwFrequency);
            
            return NOERROR;
        }
    }

    if (dw >= MAX_MEDIATYPE_MAPPINGS)
    {
        // we don't have space for more mappings.
        return RTPERR_RESOURCES;
    }

    // This is a new mapping. remember it.
    m_MediaTypeMappings[dw].pMediaType = new CMediaType(*pMediaType);
    if (m_MediaTypeMappings[dw].pMediaType == NULL)
    {
        return RTPERR_MEMORY;
    }
    m_MediaTypeMappings[dw].dwRTPPayloadType = dwRTPPayLoadType;
    m_MediaTypeMappings[dw].dwFrequency = dwFrequency;

    TraceRetail((
            CLASS_INFO, GROUP_DSHOW, S_DSHOW_SOURCE,
            _T("%s: CRtpSourceFilter[0x%p] New mapping[%u]: ")
            _T("PT:%u Frequency:%u"),
            _fname, this,
            m_dwNumMediaTypeMappings, dwRTPPayLoadType, dwFrequency
        ));
    
    AddPt2FrequencyMap(dwRTPPayLoadType, dwFrequency);
    
    m_dwNumMediaTypeMappings++;
    
    return NOERROR;
}

/* Empties the format mapping table */
STDMETHODIMP CRtpSourceFilter::FlushFormatMappings(void)
{
    DWORD            dw;
    
    CAutoLock Lock( &m_cRtpSrcCritSec );

    for (dw = 0; dw < m_dwNumMediaTypeMappings; dw ++)
    {
        if (m_MediaTypeMappings[dw].pMediaType)
        {
            delete m_MediaTypeMappings[dw].pMediaType;
            m_MediaTypeMappings[dw].pMediaType = NULL;
        }
    }

    m_dwNumMediaTypeMappings = 0;
    
    /* Now flush the RTP table */
    if (m_pRtpAddr)
    {
        RtpFlushPt2FrequencyMaps(m_pRtpAddr, RECV_IDX);
    }
    
    return(NOERROR);
}
    
/**************************************************
 * IRtpDemux implemented methods
 **************************************************/

/* Add a single pin, may return its position */
STDMETHODIMP CRtpSourceFilter::AddPin(
        IN  int          iOutMode,
        OUT int         *piPos
    )
{
    HRESULT          hr;
    DWORD            dwError;
    long             lCount;
    RtpOutput_t     *pRtpOutput;
    CRtpOutputPin   *pCRtpOutputPin;

    TraceFunctionName("CRtpSourceFilter::AddPin");

    hr = RTPERR_INVALIDSTATE;
    dwError = NOERROR;
    pRtpOutput = (RtpOutput_t *)NULL;
    pCRtpOutputPin = (CRtpOutputPin *)NULL;

    /* Create the DShow output pin */
    pCRtpOutputPin = (CRtpOutputPin *)
        new CRtpOutputPin(this,
                          m_pCIRtpSession,
                          &hr,
                          L"Capture");

    if (FAILED(hr))
    {
        goto bail;
    }

    if (!pCRtpOutputPin)
    {
        hr = RTPERR_MEMORY;
        
        goto bail;
    }

    lCount = GetQueueSize(&m_OutPinsQ);

    if (m_pCIRtpSession && m_pCIRtpSession->FlagTest(FGADDR_IRTP_INITDONE))
    {
        /* Add an RTP output, passes the DShow output pin it will be
         * associated with */
        pRtpOutput = RtpAddOutput(
                m_pCIRtpSession->GetpRtpSess(),
                iOutMode,
                (IPin *)pCRtpOutputPin,
                &dwError);

        if (dwError)
        {
            hr = dwError;

            goto bail;
        }

        pCRtpOutputPin->m_OutputPinQItem.dwKey = lCount;
    }
    else
    {
        if (iOutMode <= RTPDMXMODE_FIRST || iOutMode >= RTPDMXMODE_LAST)
        {
            hr = RTPERR_INVALIDARG;
            
            goto bail;
        }
        
        /* Encode in dwKey the OutMode and position. The DShow output
         * pins that are left here without a matching RTP output, will
         * get one when CRtpSourceFilter::MapPinsToOutputs is called in
         * CIRtpSession::Init */
        pCRtpOutputPin->m_OutputPinQItem.dwKey = (iOutMode << 16) | lCount;
    }

    if (piPos)
    {
        *piPos = lCount;
    }

    pCRtpOutputPin->SetOutput(pRtpOutput);

    enqueuel(&m_OutPinsQ,
             &m_OutPinsCritSect,
             &pCRtpOutputPin->m_OutputPinQItem);

    return(hr);
    
 bail:

    TraceRetail((
            CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
            _T("%s: failed: %u (0x%X)"),
            _fname, hr, hr
        ));
    
    if (pCRtpOutputPin)
    {
        delete pCRtpOutputPin;
    }

    return(hr);
}

/* Set the number of pins, can only be >= than current number of pins
 * */
STDMETHODIMP CRtpSourceFilter::SetPinCount(
        IN int           iCount,
        IN int           iOutMode
    )
{
    HRESULT          hr;
    int              i;

    TraceFunctionName("CRtpSourceFilter::SetPinCount");

    hr = NOERROR;

    /* MAYDO I need to be able to remove pins. Right now we can add
     * pins but right now we can not remove them */
    iCount -= GetPinCount();
    
    for(i = 0; i < iCount; i++)
    {
        hr = AddPin(iOutMode, NULL);

        if (FAILED(hr))
        {
            /* pass up the same returned error */
            break;
        }
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                _T("%s: failed: %u (0x%X)"),
                _fname, hr, hr
            ));
    }
    
    return(hr);
}

/* Set the pin mode (e.g. auto, manual, etc), if iPos >= 0 use it,
 * otherwise use pIPin */
STDMETHODIMP CRtpSourceFilter::SetPinMode(
        IN  int          iPos,
        IN  IPin        *pIPin,
        IN  int          iOutMode
    )
{
    HRESULT          hr;
    CRtpOutputPin   *pCRtpOutputPin;
    RtpOutput_t     *pRtpOutput;

    TraceFunctionName("CRtpSourceFilter::SetPinMode");

    hr = RTPERR_NOTINIT;
    
    if (m_pCIRtpSession && m_pCIRtpSession->FlagTest(FGADDR_IRTP_INITDONE))
    {
        pRtpOutput = (RtpOutput_t *)NULL;
    
        if (iPos < 0)
        {
            if (pIPin)
            {
                pCRtpOutputPin = FindIPin(pIPin);

                if (pCRtpOutputPin)
                {
                    pRtpOutput = pCRtpOutputPin->GetpRtpOutput();

                    if (!pRtpOutput)
                    {
                        /* The DShow pin doesn't have an RTP output
                         * associated */
                        hr = RTPERR_INVALIDSTATE;

                        goto end;
                    }
                }
                else
                {
                    hr = RTPERR_NOTFOUND;

                    goto end;
                }
            }
        }
        
        hr = RtpSetOutputMode(
                m_pCIRtpSession->GetpRtpSess(),
                iPos,
                pRtpOutput,
                iOutMode);
    }

 end:
    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                _T("%s: failed: %u (0x%X)"),
                _fname, hr, hr
            ));
    }

    return(hr);
}

/* Map/unmap pin i to/from user with SSRC, if iPos >= 0 use it,
 * otherwise use pIPin, when unmapping, only the pin or the SSRC is
 * required */
STDMETHODIMP CRtpSourceFilter::SetMappingState(
        IN  int          iPos,
        IN  IPin        *pIPin,
        IN  DWORD        dwSSRC,
        IN  BOOL         bMapped
    )
{
    HRESULT          hr;
    CRtpOutputPin   *pCRtpOutputPin;
    RtpOutput_t     *pRtpOutput;
    
    TraceFunctionName("CRtpSourceFilter::SetMappingState");

    hr = RTPERR_NOTINIT;

    if (m_pCIRtpSession && m_pCIRtpSession->FlagTest(FGADDR_IRTP_INITDONE))
    {
        pRtpOutput = (RtpOutput_t *)NULL;
        
        if (iPos < 0 && pIPin)
        {
            pCRtpOutputPin = FindIPin(pIPin);

            if (pCRtpOutputPin)
            {
                pRtpOutput = pCRtpOutputPin->GetpRtpOutput();

                if (!pRtpOutput)
                {
                    /* The DShow pin doesn't have an RTP output
                     * associated */
                    hr = RTPERR_INVALIDSTATE;
                    
                    goto end;
                }
            }
        }
        
        hr = RtpOutputState(
                m_pCIRtpSession->GetpRtpAddr(),
                iPos,
                pRtpOutput,
                dwSSRC,
                bMapped);
    }

 end:
    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                _T("%s: failed: %u (0x%X)"),
                _fname, hr, hr
            ));
    }

    return(hr);
}

/* Find the Pin assigned (if any) to the SSRC, return either position
 * or pin or both */
STDMETHODIMP CRtpSourceFilter::FindPin(
        IN  DWORD        dwSSRC,
        OUT int         *piPos,
        OUT IPin       **ppIPin
    )
{
    HRESULT          hr;
    void            *pvUserInfo;
    
    TraceFunctionName("CRtpSourceFilter::FindPin");

    hr = RTPERR_NOTINIT;

    if (m_pCIRtpSession && m_pCIRtpSession->FlagTest(FGADDR_IRTP_INITDONE))
    {
        hr = RtpFindOutput(m_pCIRtpSession->GetpRtpAddr(),
                           dwSSRC,
                           piPos,
                           &pvUserInfo);

        if (SUCCEEDED(hr))
        {
            if (ppIPin)
            {
                if (pvUserInfo)
                {
                    *ppIPin = static_cast<IPin *>(pvUserInfo);
                }
                else
                {
                    /* The SSRC not being mapped is not an error
                     * condition */
                    *ppIPin = (IPin *)NULL;
                }
            }
        }
    }
    
    return(hr);
}

/* Find the SSRC mapped to the Pin, if iPos >= 0 use it, otherwise use
 * pIPin */
STDMETHODIMP CRtpSourceFilter::FindSSRC(
        IN  int          iPos,
        IN  IPin        *pIPin,
        OUT DWORD       *pdwSSRC
    )
{
    HRESULT          hr;
    CRtpOutputPin   *pCRtpOutputPin;
    RtpOutput_t     *pRtpOutput;
    
    TraceFunctionName("CRtpSourceFilter::FindSSRC");

    hr = RTPERR_NOTINIT;

    if (m_pCIRtpSession && m_pCIRtpSession->FlagTest(FGADDR_IRTP_INITDONE))
    {
        pRtpOutput = (RtpOutput_t *)NULL;
        
        if (iPos < 0 && pIPin)
        {
            pCRtpOutputPin = FindIPin(pIPin);

            if (pCRtpOutputPin)
            {
                pRtpOutput = pCRtpOutputPin->GetpRtpOutput();

                if (!pRtpOutput)
                {
                    /* The DShow pin doesn't have an RTP output
                     * associated */
                    hr = RTPERR_INVALIDSTATE;

                    goto end;
                }
            }
        }
        
        hr = RtpFindSSRC(m_pCIRtpSession->GetpRtpAddr(),
                         iPos,
                         pRtpOutput,
                         pdwSSRC);
    }

 end:
    return(hr);
}

/**************************************************
 * Helper functions
 **************************************************/

HRESULT CRtpSourceFilter::GetMediaType(int iPosition, CMediaType *pCMediaType)
{
    if ((DWORD)iPosition >= m_dwNumMediaTypeMappings)
    {
        return VFW_S_NO_MORE_ITEMS;
    }

    *pCMediaType = *m_MediaTypeMappings[iPosition].pMediaType;
    //CopyMediaType(pCMediaType, m_MediaTypeMappings[iPosition].pMediaType);

    return S_OK;
}

void CRtpSourceFilter::SourceRecvCompletion(
        IMediaSample    *pIMediaSample,
        void            *pvUserInfo, /* pIPin of pCRtpOutputPin */
        RtpUser_t       *pRtpUser,
        double           dPlayTime,
        DWORD            dwError,
        long             lHdrSize,
        DWORD            dwTransfered,
        DWORD            dwFlags
    )
{
    HRESULT          hr;
    BOOL             bNewTalkSpurt;
    RtpAddr_t       *pRtpAddr;
    RtpNetRState_t  *pRtpNetRState;
    RtpHdr_t        *pRtpHdr;
    RtpPrefixHdr_t  *pRtpPrefixHdr;
    RtpQueueItem_t  *pRtpQueueItem;
    CRtpOutputPin   *pCRtpOutputPin;
    unsigned char   *buf;
    WSABUF           WSABuf;
    REFERENCE_TIME   StartTime; /* DShow reference time in 100ns units */
    REFERENCE_TIME   EndTime; /* DShow reference time in 100ns units */

    TraceFunctionName("CRtpSourceFilter::SourceRecvCompletion");

    pRtpAddr = m_pCIRtpSession->GetpRtpAddr();

    if ( (m_State == State_Running) &&
         !RtpBitTest2(dwFlags, FGRECV_ERROR, FGRECV_DROPPED) &&
         pRtpUser )
    {
        /* Try to deliver this sample to the right pin */
        
        pIMediaSample->SetActualDataLength(dwTransfered);
    
        pIMediaSample->GetPointer(&buf);

#if USE_RTPPREFIX_HDRSIZE > 0

        /* Fill RTP prefix header */

        if (m_lPrefix >= sizeof(RtpPrefixHdr_t))
        {
            pRtpPrefixHdr = (RtpPrefixHdr_t *) (buf - m_lPrefix);

            pRtpPrefixHdr->wPrefixID = RTPPREFIXID_HDRSIZE;

            pRtpPrefixHdr->wPrefixLen = sizeof(RtpPrefixHdr_t);

            pRtpPrefixHdr->lHdrSize = lHdrSize;
        }

        pRtpHdr = (RtpHdr_t *)buf;
#else
        pRtpHdr = (RtpHdr_t *)buf;
#endif

        /* Set play time */
        if (RtpBitTest(pRtpAddr->dwIRtpFlags, FGADDR_IRTP_USEPLAYOUT) &&
            m_pClock)
        {
            bNewTalkSpurt = RtpBitTest(dwFlags, FGRECV_MARKER)? 1:0;
            
            pRtpNetRState = &pRtpUser->RtpNetRState;

            if (bNewTalkSpurt)
            {
                /* First packet in a talkspurt */

                hr = m_pClock->GetTime(&StartTime);

                if (SUCCEEDED(hr))
                {
                    StartTime -= m_tStart;

#if 0
                    /* I may adjust StartTime with the time elapsed
                     * since the packet for this talkspurt was
                     * received, but I'm not doing it because after
                     * all, if I got a significat delay from the tume
                     * the packet was received and the time we get
                     * here, I prefer to apply the playout delay from
                     * the current moment and not to reduce it because
                     * of this adjustment */
                    StartTime -= (LONGLONG)
                        ( (RtpGetTimeOfDay((RtpTime_t *)NULL) -
                           pRtpNetRState->dBeginTalkspurtTime) * (1e9/100.0) );
#endif
                    if (StartTime < m_StartTime)
                    {
                        TraceRetail((
                                CLASS_WARNING, GROUP_DSHOW, S_DSHOW_SOURCE,
                                _T("%s: pRtpAddr[0x%p] Resyncing: ")
                                _T("StartTime:%I64d < m_StartTime:%I64d"),
                                _fname, pRtpAddr, StartTime, m_StartTime
                            ));
                        
                        StartTime = m_StartTime;
                    }
                    
                    pRtpNetRState->llBeginTalkspurt =
                        (LONGLONG)(StartTime + 5e-9);

                    RtpBitSet(pRtpNetRState->dwNetRStateFlags,
                              FGNETRS_TIMESET);
                }
                else
                {
                    pRtpNetRState->llBeginTalkspurt = 0;

                    RtpBitReset(pRtpNetRState->dwNetRStateFlags,
                              FGNETRS_TIMESET);

                    TraceRetail((
                            CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                            _T("%s: pRtpAddr[0x%p] GetTime failed: ")
                            _T("%u (0x%X)"),
                            _fname, pRtpAddr, hr, hr
                        ));
                }
            }

            if (RtpBitTest(pRtpNetRState->dwNetRStateFlags, FGNETRS_TIMESET))
            {
                /* Compute the start time (in units of 100ns) based on
                 * the play time */
                
                m_StartTime = pRtpNetRState->llBeginTalkspurt +
                    (LONGLONG) ((dPlayTime * (1e9/100.0)) + 5e-9);
                /* NOTE adding the 5e-9 to solve the problem of geting
                 * 699999.9999... when multiplying (0.07 * 1e7). Other
                 * multiplications also lead to same problem */

                /* Set End 1ms later (100ns units) */
                /* MAYDO if I have the samples per packet, I may also
                 * set the right end time */
                EndTime = m_StartTime + 10000;
                
                /* Set this sample's play time */
                hr = pIMediaSample->SetTime(&m_StartTime, &EndTime);

                if (FAILED(hr))
                {
                    TraceRetail((
                            CLASS_WARNING, GROUP_DSHOW, S_DSHOW_SOURCE,
                            _T("%s: pRtpAddr[0x%p] pIMediaSample[0x%p] ")
                            _T("SetTime failed: %u (0x%X)"),
                            _fname, pRtpAddr, pIMediaSample, hr, hr
                        ));
                }
#if 0
                else
                {
                    /* Print:

                       Start/s End/e llBeginTksprt dPlayTime  bNewTksprt
                    */
                    TraceRetail((
                            CLASS_INFO, GROUP_DSHOW, S_DSHOW_SOURCE,
                            _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] ")
                            _T("pIMediaSample[0x%p,%d] @")
                            _T("%I64u/%u %I64u/%u %I64d %0.3f %u"),
                            _fname, pRtpAddr, pRtpUser,
                            pIMediaSample,
                            pIMediaSample->GetActualDataLength(),
                            (LONGLONG)m_StartTime,
                            ((CRefTime *)&m_StartTime)->Millisecs(),
                            (LONGLONG)EndTime,
                            ((CRefTime *)&EndTime)->Millisecs(),
                            (LONGLONG)pRtpNetRState->llBeginTalkspurt,
                            dPlayTime, bNewTalkSpurt
                        ));
                }
#endif
                
                /* Set discontinuity depending on the talkspurt */
                pIMediaSample->SetDiscontinuity(bNewTalkSpurt);
            }
        }
        
        if (pvUserInfo)
        {
            pCRtpOutputPin = (CRtpOutputPin *)((IPin *)pvUserInfo);
        }
        else
        {
            pCRtpOutputPin = (CRtpOutputPin *)NULL;
        }

        if (pCRtpOutputPin)
        {
            /* Deliver only if a pin has been assigned (mapped) */

#if USE_DYNGRAPH > 0
            // The pin may be not be active if the chain is just added.
            // I hate to access members of other object but there is no method.
            if (!pCRtpOutputPin->m_bActive)
            {
                hr = pCRtpOutputPin->Active();
                if (SUCCEEDED(hr))
                {
                    pCRtpOutputPin->
                        OutPinRecvCompletion(pIMediaSample, (BYTE)pRtpHdr->pt);
                }
            }
            else
#endif
            {
                if (pCRtpOutputPin->IsConnected())
                {
                    /* Deliver only if there is a down stream chain of
                     * filters. This test is needed because the
                     * subgraph may have been removed */
                    pCRtpOutputPin->
                        OutPinRecvCompletion(pIMediaSample, (BYTE)pRtpHdr->pt);
                }
            }
        }
    }

    /* MAYDO repost as to keep at least a certain number, need to keep
     * track of outstanding buffers to avoid GetDeliveryBuffer from
     * blocking. If the initial choice of number of buffers is right,
     * and the maximum number of buffers held is bound, this would not
     * be needed as there would be at least one outstanding or ready
     * to post (to WS2) buffer */
    
    if (!RtpBitTest2(dwFlags, FGRECV_ISRED, FGRECV_HOLD))
    {
        /* Check if I can repost the same buffer */
        if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_RUNRECV))
        {
            /* repost same buffer */
        
            WSABuf.len = pIMediaSample->GetSize();
            pIMediaSample->GetPointer((unsigned char **)&WSABuf.buf);

            /* register buffer for asynchronous I/O */
            hr = RtpRecvFrom(pRtpAddr,
                             &WSABuf,
                             this,
                             pIMediaSample);
    
            if (FAILED(hr))
            {
                pIMediaSample->Release();
                
                TraceRetail((
                        CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                        _T("%s: pRtpAddr[0x%p] ")
                        _T("RtpRecvFrom failed: %u (0x%X)"),
                        _fname, pRtpAddr,
                        hr, hr
                    ));
            }
        }
        else
        {
            pIMediaSample->Release();
            
            TraceRetail((
                    CLASS_WARNING, GROUP_DSHOW, S_DSHOW_SOURCE,
                    _T("%s: pRtpAddr[0x%p] ")
                    _T("Buffer not reposted FGADDR_RUNRECV not set"),
                    _fname, pRtpAddr
                ));
        }
    }
    else
    {
        /* If this sample contains redundancy, or is a frame being
         * played twice, that means the same sample will be posted to
         * DShow again in the future, at that time the buffer will be
         * either reposted to WS2 or released, but right now do
         * nothing (besides delivering down stream) */
    }
}

#if USE_GRAPHEDT <= 0
HRESULT CRtpSourceFilter::PayloadTypeToMediaType(
        IN DWORD         dwRTPPayloadType, 
        IN CMediaType   *pCMediaType,
        OUT DWORD       *pdwFrequency
        )
{
    DWORD            dw;

    TraceFunctionName("CRtpSourceFilter::PayloadTypeToMediaType");

    if (m_dwNumMediaTypeMappings == 0)
    {
        /* The only failure case is when there is no mappings set */
        return(RTPERR_INVALIDSTATE);
    }

    CAutoLock Lock( &m_cRtpSrcCritSec );
    
    /* Search for a matching mapping, if none is found, use as the
     * default 0 */
    for (dw = 0; dw < m_dwNumMediaTypeMappings; dw ++)
    {
        if (m_MediaTypeMappings[dw].dwRTPPayloadType == dwRTPPayloadType)
        {
            break;
        }
    }

    if (dw >= m_dwNumMediaTypeMappings)
    {
        /* If not found, use the first one */
        dw = 0;
        
        TraceRetail((
                CLASS_WARNING, GROUP_DSHOW, S_DSHOW_SOURCE,
                _T("%s: CRtpSourceFilter[0x%p] ")
                _T("PT:%u not found, using default mapping: ")
                _T("PT:%u Frequency:%u"),
                _fname, this, dwRTPPayloadType,
                m_MediaTypeMappings[dw].dwRTPPayloadType,
                m_MediaTypeMappings[dw].dwFrequency
            ));
    }

    if (pCMediaType)
    {
        *pCMediaType = *m_MediaTypeMappings[dw].pMediaType;
        //CopyMediaType(pCMediaType, m_MediaTypeMappings[dw].pMediaType);
    }
            
    if (pdwFrequency)
    {
        *pdwFrequency = m_MediaTypeMappings[dw].dwFrequency;
    }
            
    return(NOERROR);
}
#endif

/* Find the CRtpOutputPin that has the interface IPin */
CRtpOutputPin *CRtpSourceFilter::FindIPin(IPin *pIPin)
{
    BOOL             bOk;
    RtpQueueItem_t  *pRtpQueueItem;
    CRtpOutputPin   *pCRtpOutputPin;
    long             lCount;

    TraceFunctionName("CRtpSourceFilter::FindIPin");

    if (m_pCIRtpSession && m_pCIRtpSession->FlagTest(FGADDR_IRTP_INITDONE))
    {
        pCRtpOutputPin = (CRtpOutputPin *)NULL;
        
        bOk = RtpEnterCriticalSection(&m_OutPinsCritSect);

        if (bOk)
        {
            for(lCount = GetQueueSize(&m_OutPinsQ),
                    pRtpQueueItem = m_OutPinsQ.pFirst;
                lCount > 0;
                lCount--, pRtpQueueItem = pRtpQueueItem->pNext)
            {
                pCRtpOutputPin =
                    CONTAINING_RECORD(pRtpQueueItem,
                                      CRtpOutputPin,
                                      m_OutputPinQItem);
            
                if (pIPin == static_cast<IPin *>(pCRtpOutputPin))
                {
                    break;
                }
            }

            if (!lCount)
            {
                TraceRetail((
                        CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                        _T("%s: pRtpAddr[0x%p] ")
                        _T("Interface IPin[0x%p] does not belong ")
                        _T("to any of the %u output pins"),
                        _fname, m_pCIRtpSession->GetpRtpAddr(),
                        pIPin, GetQueueSize(&m_OutPinsQ)
                    ));
            
                pCRtpOutputPin = (CRtpOutputPin *)NULL;
            }

            RtpLeaveCriticalSection(&m_OutPinsCritSect);
        }
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                _T("%s: Not initialized yet"),
                _fname
            ));
        
        pCRtpOutputPin = (CRtpOutputPin *)NULL;
    }
    
    return(pCRtpOutputPin);
}

/* Associates an RtpOutput to every DShow pin that doesn't have an
 * RtpOutput yet */
HRESULT CRtpSourceFilter::MapPinsToOutputs()
{
    HRESULT          hr;
    BOOL             bOk;
    DWORD            dwError;
    long             lCount;
    RtpQueueItem_t  *pRtpQueueItem;
    CRtpOutputPin   *pCRtpOutputPin;
    DWORD            i;

    TraceFunctionName("CRtpSourceFilter::MapPinsToOutputs");

    hr = RTPERR_CRITSECT;
    
    bOk = RtpEnterCriticalSection(&m_OutPinsCritSect);

    if (bOk)
    {
        hr = NOERROR;
        
        lCount = GetQueueSize(&m_OutPinsQ);

        if (lCount > 0)
        {
            for(pRtpQueueItem = m_OutPinsQ.pFirst;
                lCount > 0;
                pRtpQueueItem = pRtpQueueItem->pNext, lCount--)
            {
                pCRtpOutputPin = CONTAINING_RECORD(pRtpQueueItem,
                                                   CRtpOutputPin,
                                                   m_OutputPinQItem);

                if (!pCRtpOutputPin->m_pRtpOutput)
                {
                    pCRtpOutputPin->m_pRtpOutput =
                        RtpAddOutput(m_pCIRtpSession->GetpRtpSess(),
                                     (pRtpQueueItem->dwKey >> 16) & 0xffff,
                                     (IPin *)pCRtpOutputPin,
                                     &dwError);

                    if (dwError)
                    {
                        hr = dwError;

                        TraceRetail((
                                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                                _T("%s: Failed to assign an RTP output ")
                                _T("to Pin[0x%p]:%d: %u (0x%X)"),
                                _fname, pCRtpOutputPin,
                                pRtpQueueItem->dwKey & 0xffff,
                                dwError, dwError
                            ));

                        continue;
                    }

                    /* If the pin is connected, enable the RTP output */
                    if (pCRtpOutputPin->IsConnected())
                    {
                        RtpOutputEnable(pCRtpOutputPin->m_pRtpOutput, TRUE);
                    }
                    
                    /* Remove from dwKey the OutMode leaving position */
                    pRtpQueueItem->dwKey &= 0xffff;
                 }
            }
        }

        /* Now update the PT<->Frequency mappings in RtpAddr_t */
        for(i = 0; i < m_dwNumMediaTypeMappings; i++)
        {
            AddPt2FrequencyMap(m_MediaTypeMappings[i].dwRTPPayloadType,
                               m_MediaTypeMappings[i].dwFrequency);
        }

        RtpLeaveCriticalSection(&m_OutPinsCritSect);
    }

    return(hr);
}

/* Dis-associates the RtpOutput from every DShow pin and intialize the
 * pins in such a way that the next call to MapPinsToOutputs will find
 * the right information to do the same association again
 */
/*
  Fail if the filter is running
 */
HRESULT CRtpSourceFilter::UnmapPinsFromOutputs()
{
    HRESULT          hr;
    BOOL             bOk;
    DWORD            dwError;
    long             lCount;
    RtpQueueItem_t  *pRtpQueueItem;
    CRtpOutputPin   *pCRtpOutputPin;
    RtpOutput_t     *pRtpOutput;
    DWORD            i;

    TraceFunctionName("CRtpSourceFilter::UnmapPinsFromOutputs");

    if (IsActive())
    {
        /* Fail if the filter is still active */
        hr = RTPERR_INVALIDSTATE;

        goto end;
    }
    
    hr = RTPERR_CRITSECT;
    
    bOk = RtpEnterCriticalSection(&m_OutPinsCritSect);

    if (bOk)
    {
        hr = NOERROR;

        lCount = GetQueueSize(&m_OutPinsQ);

        if (lCount > 0)
        {
            for(pRtpQueueItem = m_OutPinsQ.pFirst->pPrev;
                lCount > 0;
                pRtpQueueItem = pRtpQueueItem->pPrev, lCount--)
            {
                pCRtpOutputPin = CONTAINING_RECORD(pRtpQueueItem,
                                                   CRtpOutputPin,
                                                   m_OutputPinQItem);

                pRtpOutput = pCRtpOutputPin->m_pRtpOutput;

                if (pRtpOutput)
                {
                    /* Leave encoded in the DShow pin the mode and
                     * position for the next call to MapPinsToOutputs
                     * */
                    pCRtpOutputPin->m_OutputPinQItem.dwKey =
                        (pRtpOutput->iOutMode << 16) |
                        pCRtpOutputPin->m_OutputPinQItem.dwKey;

                    pCRtpOutputPin->m_pRtpOutput = (RtpOutput_t *)NULL;

                    RtpDelOutput(m_pCIRtpSession->GetpRtpSess(), pRtpOutput);
                }
            }
        }

        RtpLeaveCriticalSection(&m_OutPinsCritSect);
    }

 end:
    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_SOURCE,
                _T("%s: CRtpSourceFilter[0x%p] failed: %s (0x%X)"),
                _fname, this, RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

    

                    
 
HRESULT CRtpSourceFilter::AddPt2FrequencyMap(
            DWORD        dwPt,
            DWORD        dwFrequency
    )
{
    HRESULT          hr;
    BOOL             bOk;
    RtpAddr_t       *pRtpAddr;
    
    hr = RTPERR_CRITSECT;
    
    bOk = RtpEnterCriticalSection(&m_OutPinsCritSect);

    if (bOk)
    {
        hr = NOERROR;

        /* Update only if already initialized */
        if (m_pRtpAddr)
        {
            hr = RtpAddPt2FrequencyMap(m_pRtpAddr,
                                       dwPt,
                                       dwFrequency,
                                       RECV_IDX);
        }
        
        RtpLeaveCriticalSection(&m_OutPinsCritSect);
    }

    return(hr);
}

/**************************************************
 * IRtpRedundancy implemented methods
 **************************************************/

/* Configures redundancy parameters */
STDMETHODIMP CRtpSourceFilter::SetRedParameters(
        DWORD            dwPT_Red, /* Payload type for redundant packets */
        DWORD            dwInitialRedDistance,/* Initial redundancy distance*/
        DWORD            dwMaxRedDistance /* default used when passing 0 */
    )
{
    HRESULT          hr;

    TraceFunctionName("CRtpSourceFilter::SetRedParameters");  

    hr = RTPERR_NOTINIT;
    
    if (m_pCIRtpSession->FlagTest(FGADDR_IRTP_INITDONE))
    {
        hr = RtpSetRedParameters(m_pRtpAddr,
                                 RtpBitPar(RECV_IDX),
                                 dwPT_Red,
                                 dwInitialRedDistance,
                                 dwMaxRedDistance);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_RENDER,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }
    
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\gtypes.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    gtypes.h
 *
 *  Abstract:
 *
 *    This file contains all the basic types used in RTP, either
 *    defined here, or included from other files. E.g. DWORD, BYTE,etc
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/18 created
 *
 **********************************************************************/

#ifndef _gtypes_h_
#define _gtypes_h_

#include <wtypes.h>
#include <windef.h>
#include <winbase.h>
#include <crtdbg.h>
#include <tchar.h>
#if !defined(UNICODE)
#include <stdio.h>
#endif
#include "rtptags.h"
#include "rtpdbg.h"
#include "rtperr.h"
#include "msrtp.h"

/* Relates to receiver or sender */
#define RECV_IDX          0
#define SEND_IDX          1
#define RECVSENDMASK    0x1

/* Relates to local or remote */
#define LOCAL_IDX         0
#define REMOTE_IDX        1
#define LOCALREMOTEMASK 0x1

/* Relates to RTP or RTCP */
#define RTP_IDX           0
#define RTCP_IDX          1
#define RTPRTCPMASK     0x1

/* Sockets */
#define SOCK_RECV_IDX     0
#define SOCK_SEND_IDX     1
#define SOCK_RTCP_IDX     2

/* Cryptography descriptors */
#define CRYPT_RECV_IDX    0
#define CRYPT_SEND_IDX    1
#define CRYPT_RTCP_IDX    2

/* Some functions receive a DWORD with flags, use this macro instead
 * of 0 when no flags are passed */
#define NO_FLAGS          0

/* Some functions receive a DWORD with a wait time, use this macro
 * instead of 0 when no wait is desired */
#define DO_NOT_WAIT        0
#define DO_NOT_SYNCHRONIZE_CMD 0

/* A DWORD value is not set */
#define NO_DW_VALUESET    ((DWORD)~0)
#define IsDWValueSet(dw)  ((dw) != NO_DW_VALUESET)

/* builds a mask of bit b */
#define RtpBitPar(b)            (1 << (b))
#define RtpBitPar2(b1, b2)      ((1 << (b1)) | (1 << (b2)))

/* test bit b in f */
#define RtpBitTest(f, b)        (f & (1 << (b)))
#define RtpBitTest2(f, b1, b2)  (f & RtpBitPar2(b1, b2))

/* set bit b in f */
#define RtpBitSet(f, b)         (f |= (1 << (b)))
#define RtpBitSet2(f, b1, b2)   (f |= RtpBitPar2(b1, b2))

/* reset bit b in f */
#define RtpBitReset(f, b)       (f &= ~(1 << (b)))
#define RtpBitReset2(f, b1, b2) (f &= ~RtpBitPar2(b1, b2))

#define RtpBuildIPAddr(a, b, c ,d) \
        (((a) << 24) | ((b) << 16) | ((c) << 8) | (d))

#define IS_MULTICAST(addr) (((long)(addr) & 0x000000f0) == 0x000000e0)
#define IS_UNICAST(addr)   (((long)(addr) & 0x000000f0) != 0x000000e0)

/* Returns a pointer-size aligned size */
#define RTP_ALIGNED_SIZE(_size) \
        (((_size) + sizeof(void *) - 1) & ~(sizeof(void *) - 1))

/* Returns a pointer-size aligned size of the size of a type */
#define RTP_ALIGNED_SIZEOF(_type) RTP_ALIGNED_SIZE(sizeof(_type))


typedef struct _RtpTime_t {
    DWORD            dwSecs;          /* seconds since Jan. 1, 1970 */
    DWORD            dwUSecs;         /* and microseconds */
} RtpTime_t;

typedef unsigned int  uint_t;        /* prefix variables with "ui" */
typedef unsigned long ulong_t;       /* prefix variables with "ul" */
typedef BOOL          bool_t;        /* prefix variables with "b" */
typedef TCHAR         tchar_t;       /* prefix variables with "t" */
typedef TCHAR         TCHAR_t;

/* Gets the offset to a field in a structure.
 *
 * E.g DWORD OffToDwAddrFlags = RTPSTRUCTOFFSET(RtpAddr_t, dwAddrFlags); */
#define RTPSTRUCTOFFSET(_struct_t, _field) \
        ((DWORD) ((ULONG_PTR) &((_struct_t *)0)->_field))

/* Gets a (DWORD *) from a structure pointer and an offset
 *
 * E.g. DWORD *pdw = RTPDWORDPTR(pRtpAddr, 64); */
#define RTPDWORDPTR(_pAny_t, _offset) \
        ((DWORD *) ((char *)_pAny_t + _offset))

const TCHAR_t *g_psRtpRecvSendStr[];

const TCHAR_t *g_psRtpStreamClass[];

const TCHAR_t *g_psGetSet[];

#define RTPRECVSENDSTR(_RecvSend) (g_psRtpRecvSendStr[_RecvSend & 0x1])

#define RTPSTREAMCLASS(_class)    (g_psRtpStreamClass[_class & 0x3])

#endif /* _gtypes_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\dsrtp\src\setmtype.cpp ===
#if USE_GRAPHEDT > 0

#include "classes.h"
#include "dsglob.h"
#include "dsrtpid.h"

#include <streams.h>
#include <ks.h>
#include <ksmedia.h>
#include "h26xinc.h"
#include <tapih26x.h>
#include <filterid.h>

#define MAX_FRAME_INTERVAL 10000000L
#define MIN_FRAME_INTERVAL 333333L

// RTP packetized H.263 Version 1 QCIF size
#define CIF_BUFFER_SIZE 32768
#define D_X_CIF 352
#define D_Y_CIF 288
const VIDEOINFOHEADER_H263 VIH_R263_CIF = 
{
    0,0,0,0,                                // RECT  rcSource; 
    0,0,0,0,                                // RECT  rcTarget; 
    CIF_BUFFER_SIZE * 30 * 8,               // DWORD dwBitRate;
    0L,                                     // DWORD dwBitErrorRate; 
    MIN_FRAME_INTERVAL,                     // REFERENCE_TIME  AvgTimePerFrame;   

    {
        sizeof (BITMAPINFOHEADER_H263),     // DWORD biSize;
        D_X_CIF,                            // LONG  biWidth;
        D_Y_CIF,                            // LONG  biHeight;
        1,                                  // WORD  biPlanes;
#ifdef USE_OLD_FORMAT_DEFINITION
        24,                                 // WORD  biBitCount;
#else
        0,                                  // WORD  biBitCount;
#endif
        FOURCC_R263,                        // DWORD biCompression;
        CIF_BUFFER_SIZE,                    // DWORD biSizeImage;
        0,                                  // LONG  biXPelsPerMeter;
        0,                                  // LONG  biYPelsPerMeter;
        0,                                  // DWORD biClrUsed;
        0,                                  // DWORD biClrImportant;

#ifndef USE_OLD_FORMAT_DEFINITION
        // H.263 specific fields
        CIF_BUFFER_SIZE * 30 * 8 / 100,     // dwMaxBitrate
        CIF_BUFFER_SIZE * 8 / 1024,         // dwBppMaxKb
        0,                                  // dwHRD_B

        //Options
        0,                                  // fUnrestrictedVector
        0,                                  // fArithmeticCoding
        0,                                  // fAdvancedPrediction
        0,                                  // fPBFrames
        0,                                  // fErrorCompensation
        0,                                  // fAdvancedIntraCodingMode
        0,                                  // fDeblockingFilterMode
        0,                                  // fImprovedPBFrameMode
        0,                                  // fUnlimitedMotionVectors
        0,                                  // fFullPictureFreeze
        0,                                  // fPartialPictureFreezeAndRelease
        0,                                  // fResizingPartPicFreezeAndRelease
        0,                                  // fFullPictureSnapshot
        0,                                  // fPartialPictureSnapshot
        0,                                  // fVideoSegmentTagging
        0,                                  // fProgressiveRefinement
        0,                                  // fDynamicPictureResizingByFour
        0,                                  // fDynamicPictureResizingSixteenthPel
        0,                                  // fDynamicWarpingHalfPel
        0,                                  // fDynamicWarpingSixteenthPel
        0,                                  // fIndependentSegmentDecoding
        0,                                  // fSlicesInOrder-NonRect
        0,                                  // fSlicesInOrder-Rect
        0,                                  // fSlicesNoOrder-NonRect
        0,                                  // fSlicesNoOrder-NonRect
        0,                                  // fAlternateInterVLCMode
        0,                                  // fModifiedQuantizationMode
        0,                                  // fReducedResolutionUpdate
        0,                                  // fReserved

        // Reserved
        0, 0, 0, 0                          // dwReserved[4]
#endif
    }
};

const AM_MEDIA_TYPE AMMT_R263_CIF = 
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,         // majortype
    STATIC_MEDIASUBTYPE_R263_V1,            // subtype
    FALSE,                                  // bFixedSizeSamples (all samples same size?)
    TRUE,                                   // bTemporalCompression (uses prediction?)
    0,                                      // lSampleSize => VBR
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,// formattype
    NULL,                                   // pUnk
    sizeof (VIH_R263_CIF),          // cbFormat
    (LPBYTE)&VIH_R263_CIF,          // pbFormat
};

// H.263 Version 1 QCIF size
#define QCIF_BUFFER_SIZE 8192
#define D_X_QCIF 176
#define D_Y_QCIF 144
const VIDEOINFOHEADER_H263 VIH_R263_QCIF = 
{
    0,0,0,0,                                // RECT  rcSource; 
    0,0,0,0,                                // RECT  rcTarget; 
    QCIF_BUFFER_SIZE * 30 * 8,              // DWORD dwBitRate;
    0L,                                     // DWORD dwBitErrorRate; 
    MIN_FRAME_INTERVAL,                     // REFERENCE_TIME  AvgTimePerFrame;   

    {
        sizeof (BITMAPINFOHEADER_H263),     // DWORD biSize;
        D_X_QCIF,                           // LONG  biWidth;
        D_Y_QCIF,                           // LONG  biHeight;
        1,                                  // WORD  biPlanes;
#ifdef USE_OLD_FORMAT_DEFINITION
        24,                                 // WORD  biBitCount;
#else
        0,                                  // WORD  biBitCount;
#endif
        FOURCC_R263,                        // DWORD biCompression;
        QCIF_BUFFER_SIZE,                   // DWORD biSizeImage;
        0,                                  // LONG  biXPelsPerMeter;
        0,                                  // LONG  biYPelsPerMeter;
        0,                                  // DWORD biClrUsed;
        0,                                  // DWORD biClrImportant;

#ifndef USE_OLD_FORMAT_DEFINITION
        // H.263 specific fields
        QCIF_BUFFER_SIZE * 30 * 8 / 100,    // dwMaxBitrate
        QCIF_BUFFER_SIZE * 8 / 1024,        // dwBppMaxKb
        0,                                  // dwHRD_B

        //Options
        0,                                  // fUnrestrictedVector
        0,                                  // fArithmeticCoding
        0,                                  // fAdvancedPrediction
        0,                                  // fPBFrames
        0,                                  // fErrorCompensation
        0,                                  // fAdvancedIntraCodingMode
        0,                                  // fDeblockingFilterMode
        0,                                  // fImprovedPBFrameMode
        0,                                  // fUnlimitedMotionVectors
        0,                                  // fFullPictureFreeze
        0,                                  // fPartialPictureFreezeAndRelease
        0,                                  // fResizingPartPicFreezeAndRelease
        0,                                  // fFullPictureSnapshot
        0,                                  // fPartialPictureSnapshot
        0,                                  // fVideoSegmentTagging
        0,                                  // fProgressiveRefinement
        0,                                  // fDynamicPictureResizingByFour
        0,                                  // fDynamicPictureResizingSixteenthPel
        0,                                  // fDynamicWarpingHalfPel
        0,                                  // fDynamicWarpingSixteenthPel
        0,                                  // fIndependentSegmentDecoding
        0,                                  // fSlicesInOrder-NonRect
        0,                                  // fSlicesInOrder-Rect
        0,                                  // fSlicesNoOrder-NonRect
        0,                                  // fSlicesNoOrder-NonRect
        0,                                  // fAlternateInterVLCMode
        0,                                  // fModifiedQuantizationMode
        0,                                  // fReducedResolutionUpdate
        0,                                  // fReserved

        // Reserved
        0, 0, 0, 0                          // dwReserved[4]
#endif
    }
};

const AM_MEDIA_TYPE AMMT_R263_QCIF = 
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,         // majortype
    STATIC_MEDIASUBTYPE_R263_V1,            // subtype
    FALSE,                                  // bFixedSizeSamples (all samples same size?)
    TRUE,                                   // bTemporalCompression (uses prediction?)
    0,                                      // lSampleSize => VBR
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,// formattype
    NULL,                                   // pUnk
    sizeof (VIH_R263_QCIF),         // cbFormat
    (LPBYTE)&VIH_R263_QCIF,         // pbFormat
};

// H.263 Versions 1 SQCIF size
#define SQCIF_BUFFER_SIZE 8192
#define D_X_SQCIF 128
#define D_Y_SQCIF 96
const VIDEOINFOHEADER_H263 VIH_R263_SQCIF = 
{
    0,0,0,0,                                // RECT  rcSource; 
    0,0,0,0,                                // RECT  rcTarget; 
    SQCIF_BUFFER_SIZE * 30 * 8,             // DWORD dwBitRate;
    0L,                                     // DWORD dwBitErrorRate; 
    MIN_FRAME_INTERVAL,                     // REFERENCE_TIME  AvgTimePerFrame;   

    {
        sizeof (BITMAPINFOHEADER_H263),     // DWORD biSize;
        D_X_SQCIF,                          // LONG  biWidth;
        D_Y_SQCIF,                          // LONG  biHeight;
        1,                                  // WORD  biPlanes;
#ifdef USE_OLD_FORMAT_DEFINITION
        24,                                 // WORD  biBitCount;
#else
        0,                                  // WORD  biBitCount;
#endif
        FOURCC_R263,                        // DWORD biCompression;
        SQCIF_BUFFER_SIZE,                  // DWORD biSizeImage;
        0,                                  // LONG  biXPelsPerMeter;
        0,                                  // LONG  biYPelsPerMeter;
        0,                                  // DWORD biClrUsed;
        0,                                  // DWORD biClrImportant;

#ifndef USE_OLD_FORMAT_DEFINITION
        // H.263 specific fields
        SQCIF_BUFFER_SIZE * 30 * 8 / 100,   // dwMaxBitrate
        SQCIF_BUFFER_SIZE * 8 / 1024,       // dwBppMaxKb
        0,                                  // dwHRD_B

        //Options
        0,                                  // fUnrestrictedVector
        0,                                  // fArithmeticCoding
        0,                                  // fAdvancedPrediction
        0,                                  // fPBFrames
        0,                                  // fErrorCompensation
        0,                                  // fAdvancedIntraCodingMode
        0,                                  // fDeblockingFilterMode
        0,                                  // fImprovedPBFrameMode
        0,                                  // fUnlimitedMotionVectors
        0,                                  // fFullPictureFreeze
        0,                                  // fPartialPictureFreezeAndRelease
        0,                                  // fResizingPartPicFreezeAndRelease
        0,                                  // fFullPictureSnapshot
        0,                                  // fPartialPictureSnapshot
        0,                                  // fVideoSegmentTagging
        0,                                  // fProgressiveRefinement
        0,                                  // fDynamicPictureResizingByFour
        0,                                  // fDynamicPictureResizingSixteenthPel
        0,                                  // fDynamicWarpingHalfPel
        0,                                  // fDynamicWarpingSixteenthPel
        0,                                  // fIndependentSegmentDecoding
        0,                                  // fSlicesInOrder-NonRect
        0,                                  // fSlicesInOrder-Rect
        0,                                  // fSlicesNoOrder-NonRect
        0,                                  // fSlicesNoOrder-NonRect
        0,                                  // fAlternateInterVLCMode
        0,                                  // fModifiedQuantizationMode
        0,                                  // fReducedResolutionUpdate
        0,                                  // fReserved

        // Reserved
        0, 0, 0, 0                          // dwReserved[4]
#endif
    }
};

const AM_MEDIA_TYPE AMMT_R263_SQCIF = 
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,         // majortype
    STATIC_MEDIASUBTYPE_R263_V1,            // subtype
    FALSE,                                  // bFixedSizeSamples (all samples same size?)
    TRUE,                                   // bTemporalCompression (uses prediction?)
    0,                                      // lSampleSize => VBR
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,// formattype
    NULL,                                   // pUnk
    sizeof (VIH_R263_SQCIF),        // cbFormat
    (LPBYTE)&VIH_R263_SQCIF,        // pbFormat
};

// RTP packetized H.261 CIF size
const VIDEOINFOHEADER_H261 VIH_R261_CIF = 
{
    0,0,0,0,                                // RECT  rcSource; 
    0,0,0,0,                                // RECT  rcTarget; 
    CIF_BUFFER_SIZE * 30 * 8,               // DWORD dwBitRate;
    0L,                                     // DWORD dwBitErrorRate; 
    MIN_FRAME_INTERVAL,                     // REFERENCE_TIME  AvgTimePerFrame;   

    {
        sizeof (BITMAPINFOHEADER_H261),     // DWORD biSize;
        D_X_CIF,                            // LONG  biWidth;
        D_Y_CIF,                            // LONG  biHeight;
        1,                                  // WORD  biPlanes;
#ifdef USE_OLD_FORMAT_DEFINITION
        24,                                 // WORD  biBitCount;
#else
        0,                                  // WORD  biBitCount;
#endif
        FOURCC_R261,                        // DWORD biCompression;
        CIF_BUFFER_SIZE,                    // DWORD biSizeImage;
        0,                                  // LONG  biXPelsPerMeter;
        0,                                  // LONG  biYPelsPerMeter;
        0,                                  // DWORD biClrUsed;
        0,                                  // DWORD biClrImportant;

#ifndef USE_OLD_FORMAT_DEFINITION
        // H.261 specific fields
        CIF_BUFFER_SIZE * 30 * 8 / 100,     // dwMaxBitrate
        0,                                  // fStillImageTransmission

        // Reserved
        0, 0, 0, 0                          // dwReserved[4]
#endif
    }
};

const AM_MEDIA_TYPE AMMT_R261_CIF = 
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,         // majortype
    STATIC_MEDIASUBTYPE_R261,               // subtype
    FALSE,                                  // bFixedSizeSamples (all samples same size?)
    TRUE,                                   // bTemporalCompression (uses prediction?)
    0,                                      // lSampleSize => VBR
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,// formattype
    NULL,                                   // pUnk
    sizeof (VIH_R261_CIF),          // cbFormat
    (LPBYTE)&VIH_R261_CIF,          // pbFormat
};

// RTP packetized H.261 QCIF size
const VIDEOINFOHEADER_H261 VIH_R261_QCIF = 
{
    0,0,0,0,                                // RECT  rcSource; 
    0,0,0,0,                                // RECT  rcTarget; 
    QCIF_BUFFER_SIZE * 30 * 8,              // DWORD dwBitRate;
    0L,                                     // DWORD dwBitErrorRate; 
    MIN_FRAME_INTERVAL,                     // REFERENCE_TIME  AvgTimePerFrame;   

    {
        sizeof (BITMAPINFOHEADER_H261),     // DWORD biSize;
        D_X_QCIF,                           // LONG  biWidth;
        D_Y_QCIF,                           // LONG  biHeight;
        1,                                  // WORD  biPlanes;
#ifdef USE_OLD_FORMAT_DEFINITION
        24,                                 // WORD  biBitCount;
#else
        0,                                  // WORD  biBitCount;
#endif
        FOURCC_R261,                        // DWORD biCompression;
        QCIF_BUFFER_SIZE,                   // DWORD biSizeImage;
        0,                                  // LONG  biXPelsPerMeter;
        0,                                  // LONG  biYPelsPerMeter;
        0,                                  // DWORD biClrUsed;
        0,                                  // DWORD biClrImportant;

#ifndef USE_OLD_FORMAT_DEFINITION
        // H.261 specific fields
        QCIF_BUFFER_SIZE * 30 * 8 / 100,    // dwMaxBitrate
        0,                                  // fStillImageTransmission

        // Reserved
        0, 0, 0, 0                          // dwReserved[4]
#endif
    }
};

const AM_MEDIA_TYPE AMMT_R261_QCIF = 
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,         // majortype
    STATIC_MEDIASUBTYPE_R261,               // subtype
    FALSE,                                  // bFixedSizeSamples (all samples same size?)
    TRUE,                                   // bTemporalCompression (uses prediction?)
    0,                                      // lSampleSize => VBR
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,// formattype
    NULL,                                   // pUnk
    sizeof (VIH_R261_QCIF),         // cbFormat
    (LPBYTE)&VIH_R261_QCIF,         // pbFormat
};

// Array of all formats
const AM_MEDIA_TYPE* const R26XFormats[] = 
{
    (AM_MEDIA_TYPE*) &AMMT_R263_QCIF,
    (AM_MEDIA_TYPE*) &AMMT_R263_CIF,
    (AM_MEDIA_TYPE*) &AMMT_R263_SQCIF,
    (AM_MEDIA_TYPE*) &AMMT_R261_QCIF,
    (AM_MEDIA_TYPE*) &AMMT_R261_CIF
};

#define NUM_OUTPUT_FORMATS 5

/****************************************************************************
 *  @doc INTERNAL COUTPINMETHOD
 *
 *  @mfunc HRESULT | CRtpOutputPin | GetMediaType | This method retrieves one
 *    of the media types supported by the pin, which is used by enumerators.
 *
 *  @parm int | iPosition | Specifies a position in the media type list.
 *
 *  @parm CMediaType* | pMediaType | Specifies a pointer to the media type at
 *    the <p iPosition> position in the list of supported media types.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag VFW_S_NO_MORE_ITEMS | End of the list of media types has been reached
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CRtpOutputPin::GetMediaType(IN int iPosition, OUT CMediaType *pMediaType)
{
    HRESULT Hr = NOERROR;

    // Validate input parameters
    ASSERT(iPosition >= 0);
    ASSERT(pMediaType);
    if (iPosition < 0)
    {
        Hr = E_INVALIDARG;
        goto MyExit;
    }
    if (iPosition >= (int)NUM_OUTPUT_FORMATS)
    {
        Hr = VFW_S_NO_MORE_ITEMS;
        goto MyExit;
    }
    if (!pMediaType)
    {
        Hr = E_POINTER;
        goto MyExit;
    }

    // Return our media type
    if (iPosition == 0L)
    {
        pMediaType->SetType(g_RtpOutputType.clsMajorType);
        pMediaType->SetSubtype(g_RtpOutputType.clsMinorType);
    }
    else if (iPosition == 1L)
    {
        if (m_iCurrFormat == -1L)
            *pMediaType = *R26XFormats[0];
        else
            *pMediaType = *R26XFormats[m_iCurrFormat];
    }
    else
    {
        Hr = VFW_S_NO_MORE_ITEMS;
    }

MyExit:
    return Hr;
}

/****************************************************************************
 *  @doc INTERNAL COUTPINMETHOD
 *
 *  @mfunc HRESULT | CRtpOutputPin | CheckMediaType | This method is used to
 *    determine if the pin can support a specific media type.
 *
 *  @parm CMediaType* | pMediaType | Specifies a pointer to the media type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag VFW_E_INVALIDMEDIATYPE | An invalid media type was specified
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CRtpOutputPin::CheckMediaType(IN const CMediaType *pMediaType)
{
    HRESULT Hr = NOERROR;
    BOOL fFormatMatch = FALSE;
    DWORD dwIndex;

    // Validate input parameters
    ASSERT(pMediaType);
    if (!pMediaType)
    {
        Hr = E_POINTER;
        goto MyExit;
    }

    // We support MEDIATYPE_RTP_Multiple_Stream and
    // MEDIASUBTYPE_RTP_Payload_Mixed
    if (*pMediaType->Type() == MEDIATYPE_RTP_Multiple_Stream &&
        *pMediaType->Subtype() == MEDIASUBTYPE_RTP_Payload_Mixed)
    {
        goto MyExit;
    }
    else
    {
        // We support MEDIATYPE_Video and FORMAT_VideoInfo
        if (!pMediaType->pbFormat)
        {
            Hr = E_POINTER;
            goto MyExit;
        }

        if (*pMediaType->Type() != MEDIATYPE_Video ||
            *pMediaType->FormatType() != FORMAT_VideoInfo)
        {
            Hr = VFW_E_INVALIDMEDIATYPE;
            goto MyExit;
        }

        // Quickly test to see if this is the current format (what we
        // provide in GetMediaType). We accept that
        if (m_mt == *pMediaType)
        {
            goto MyExit;
        }

        // Check the media subtype and image resolution
        for (dwIndex = 0;
             dwIndex < NUM_OUTPUT_FORMATS && !fFormatMatch;
             dwIndex++)
        {
            if ( (HEADER(pMediaType->pbFormat)->biCompression ==
                  HEADER(R26XFormats[dwIndex]->pbFormat)->biCompression) &&
                 (HEADER(pMediaType->pbFormat)->biWidth ==
                  HEADER(R26XFormats[dwIndex]->pbFormat)->biWidth) &&
                 (HEADER(pMediaType->pbFormat)->biHeight ==
                  HEADER(R26XFormats[dwIndex]->pbFormat)->biHeight) )
                fFormatMatch = TRUE;
        }

        if (!fFormatMatch)
            Hr = E_FAIL;
    }

MyExit:
    return Hr;
}

/****************************************************************************
 *  @doc INTERNAL COUTPINMETHOD
 *
 *  @mfunc HRESULT | CRtpOutputPin | SetMediaType | This method is used to
 *    set a specific media type on a pin.
 *
 *  @parm CMediaType* | pMediaType | Specifies a pointer to the media type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CRtpOutputPin::SetMediaType(IN CMediaType *pMediaType)
{
    HRESULT Hr = NOERROR;
    DWORD dwIndex;

    // Validate format
    if (FAILED(Hr = CheckMediaType(pMediaType)))
    {
        goto MyExit;
    }

    // Remember the format
    if (SUCCEEDED(Hr = CBasePin::SetMediaType(pMediaType)))
    {
        if (*pMediaType->Type() == MEDIATYPE_Video && *pMediaType->FormatType() == FORMAT_VideoInfo)
        {
            // Which one of our formats is this exactly?
            for (dwIndex=0; dwIndex < NUM_OUTPUT_FORMATS;  dwIndex++)
            {
                if ( (HEADER(pMediaType->pbFormat)->biCompression ==
                      HEADER(R26XFormats[dwIndex]->pbFormat)->biCompression) &&
                     (HEADER(pMediaType->pbFormat)->biWidth ==
                      HEADER(R26XFormats[dwIndex]->pbFormat)->biWidth) &&
                     (HEADER(pMediaType->pbFormat)->biHeight ==
                      HEADER(R26XFormats[dwIndex]->pbFormat)->biHeight) )
                    break;
            }

            if (dwIndex < NUM_OUTPUT_FORMATS)
            {
                // Update current format
                m_iCurrFormat = (int)dwIndex;
            }
            else
            {
                Hr = E_FAIL;
                goto MyExit;
            }
        }
    }

MyExit:
    return Hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\dsrtp\src\rtpcom.cpp ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpcom.cpp
 *
 *  Abstract:
 *
 *    Implements the IRtpSess interface
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/21 created
 *
 **********************************************************************/

#include "struct.h"
#include "classes.h"
#include "rtpsess.h"
#include "rtpaddr.h"
#include "rtpqos.h"
#include "rtpmask.h"
#include "rtpcrypt.h"
#include "rtpreg.h"
#include "rtcpsdes.h"
#include "rtppinfo.h"
#include "rtprtp.h"
#include "rtpred.h"
#include "msrtpapi.h"
#include "tapirtp.h"

#if USE_GRAPHEDT > 0
/* WARNING
 *
 * For AUTO mode and for testing purposes, use a global
 * variable to enabling sharing the same sessions for a
 * receiver and a sender */
HANDLE g_hSharedRtpAddr = NULL;
#endif

/**********************************************************************
 * Callback function to generate DShow events through
 * CBaseFilter::NotifyEvent()
 **********************************************************************/
void CALLBACK DsHandleNotifyEvent(
        void            *pvUserInfo,
        long             EventCode,
        LONG_PTR         EventParam1,
        LONG_PTR         EventParam2
    )
{
    CIRtpSession    *pCIRtpSession;

    pCIRtpSession = (CIRtpSession *)pvUserInfo;

    pCIRtpSession->
        CIRtpSessionNotifyEvent(EventCode, EventParam1, EventParam2);
}

CIRtpSession::CIRtpSession(
        LPUNKNOWN        pUnk,
        HRESULT         *phr,
        DWORD            dwFlags
    )
    //: CUnknown(_T("CIRtpSession"), pUnk, phr)
{
    HRESULT          hr;
    
    TraceFunctionName("CIRtpSession::CIRtpSession");  

    m_dwObjectID = OBJECTID_CIRTP;
    
    m_dwIRtpFlags = dwFlags;

    m_iMode = CIRTPMODE_NOTSET;

    m_RtpFilterState = State_Stopped;
    
    if (RtpBitTest(dwFlags, FGADDR_IRTP_ISSEND))
    {
        m_dwRecvSend = SEND_IDX;
    }
    else
    {
        m_dwRecvSend = RECV_IDX;
    }

    TraceRetail((
            CLASS_INFO, GROUP_DSHOW, S_DSHOW_INIT,
            _T("%s: pCIRtpSess[0x%p] created"),
            _fname, this
        ));
}

CIRtpSession::~CIRtpSession()
{
    TraceFunctionName("CIRtpSession::~CIRtpSession");  

    TraceRetail((
            CLASS_INFO, GROUP_DSHOW, S_DSHOW_INIT,
            _T("%s: pCIRtpSess[0x%p] pRtpSess[0x%p] pRtpAddr[0x%p] ")
            _T("being deleted"),
            _fname, this, m_pRtpSess, m_pRtpAddr
        ));
    
    Cleanup();

    INVALIDATE_OBJECTID(m_dwObjectID);
}

STDMETHODIMP CIRtpSession::Control(
        DWORD            dwControl,
        DWORD_PTR        dwPar1,
        DWORD_PTR        dwPar2
    )
{
    return(E_FAIL);
}

STDMETHODIMP CIRtpSession::GetLastError(
        DWORD           *pdwError
    )
{
    return(E_FAIL);
}

/* When receiver and sender share the same session, Init() is called
 * twice, once by the receiver and once by the sender.
 *
 * The first call will set the mode (either automatic, used in
 * graphedt where no body calls Init(), or manual initialization,
 * normally used by the MSP or other application), and will create the
 * RtpSess_t and RtpAddr_t structures.
 *
 * */

const TCHAR_t *g_sCIRtpSessionMode[] = {
    _T("Invalid"),
    _T("AUTO"),
    _T("MANUAL"),
    _T("Invalid")
};

/* Init is the first method to call after an RTP source or render
 * filter is created, using a cookie allows the same RTP session
 * to be shared by a source and a render. The first call will have
 * the coockie initialized to NULL, the next call will use the
 * returned cookie to lookup the same RTP session. dwFlags can be
 * RTPINIT_QOS to create QOS enabled sockets, you can find out the
 * complete list of flags that can be used in file msrtp.h */
STDMETHODIMP CIRtpSession::Init(
        HANDLE              *phCookie,
        DWORD                dwFlags
    )
{
    HRESULT          hr;
    long             lRefCount;
    RtpAddr_t       *pRtpAddr;
    CRtpSourceFilter *pCRtpSourceFilter;

    TraceFunctionName("CIRtpSession::Init");

    hr = NOERROR;

#if USE_GRAPHEDT > 0
    /* WARNING
     *
     * For AUTO mode and for testing purposes, use a global variable
     * to enable sharing the same session for a receiver and a
     * sender. This means exactly 1 receiver and 1 sender at most, and
     * no more */
    phCookie = &g_hSharedRtpAddr;
#else
    if (!phCookie)
    {
        return(RTPERR_POINTER);
    }
#endif
    
    dwFlags &= RTPINIT_MASK;

    /* Map user flags passed (enum of RTPINITFG_* defined in msrtp.h)
     * to internal flags (enum of FGADDR_IRTP_* defined in struct.h)
     * */
    dwFlags <<= (FGADDR_IRTP_AUTO - RTPINITFG_AUTO);
    
    TraceRetail((
            CLASS_INFO, GROUP_DSHOW, S_DSHOW_INIT,
            _T("%s: CIRtpSession[0x%p] Cookie:0x%p Flags:0x%X"),
            _fname, this, *phCookie, dwFlags
        ));

    if (m_iMode == CIRTPMODE_NOTSET)
    {
        /* Set mode */
        if (RtpBitTest(dwFlags, FGADDR_IRTP_AUTO))
        {
            m_iMode = CIRTPMODE_AUTO;
        }
        else
        {
            m_iMode = CIRTPMODE_MANUAL;
        }
    }
    else
    {
        /* Verify mode matches */
        if (RtpBitTest(dwFlags, FGADDR_IRTP_AUTO) &&
            m_iMode != CIRTPMODE_AUTO)
        {
            /* Fail */

            TraceRetail((
                    CLASS_ERROR, GROUP_DSHOW, S_DSHOW_INIT,
                    _T("%s: CIRtpSession[0x%p] pRtpSess[0x%p] pRtpAddr[0x%p]")
                    _T(" failed: Already initialized ")
                    _T("as %s, trying to set unmatched mode"),
                    _fname, this, m_pRtpSess, m_pRtpAddr,
                    g_sCIRtpSessionMode[m_iMode]
                ));

            return(RTPERR_INVALIDARG);
        }
    }
    
    /* TODO when multiple address are going to be supported, we will
     * not be able to use a member variable for the address
     * (i.e. m_pRtpAddr), but will have to lookup the address in the
     * session's addresses list */
    
    if (!*phCookie)
    {
        /* No session and address assigned, create new one */

        if (m_pRtpSess || m_pRtpAddr)
        {
            hr = RTPERR_INVALIDSTATE;
            goto bail;
        }

        /*
         * Create RTP session
         * */
        hr = GetRtpSess(&m_pRtpSess);
    
        if (FAILED(hr))
        {
            /* pass up the same returned error */
            goto bail;
        }

        /* first filter added to session */
        m_pRtpSess->lSessRefCount[m_dwRecvSend] = 1;

        /* Function to be used to pass up events (to the DShow graph) */
        m_pRtpSess->pHandleNotifyEvent = DsHandleNotifyEvent;
        
        /*
         * Create first address
         * */

        /* Create RtpAddr_t first */
        /* TODO call Control(m_pRtpSess, ...) */
        hr = GetRtpAddr(m_pRtpSess, &m_pRtpAddr, dwFlags);

        if (FAILED(hr))
        {
            goto bail;
        }

        /* I need to early check if QOS is disabled */
        if ( IsRegValueSet(g_RtpReg.dwQosEnable) &&
             ((g_RtpReg.dwQosEnable & 0x3) == 0x2) )
        {
            /* disable QOS */
            RtpBitSet(m_pRtpAddr->dwAddrFlagsQ, FGADDRQ_REGQOSDISABLE);
        }

        /* Now update cookie */
        *phCookie = (HANDLE)m_pRtpAddr;
    }
    else
    {
        /* Session and address were already assigned, verify */
        pRtpAddr = (RtpAddr_t *)*phCookie;

        if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
        {
            hr = RTPERR_INVALIDRTPADDR;
            goto bail;
        }

        m_pRtpAddr = pRtpAddr;

        m_pRtpSess = pRtpAddr->pRtpSess;
        
        if (m_pRtpSess)
        {
            lRefCount =
                InterlockedIncrement(&m_pRtpSess->lSessRefCount[m_dwRecvSend]);

            if (lRefCount > 1)
            {
                InterlockedDecrement(&m_pRtpSess->lSessRefCount[m_dwRecvSend]);
                
                /* This is invalid, there can be at the most 1
                 * receiver and 1 sender for a total RefCount equal 2
                 * */
                m_pRtpAddr = (RtpAddr_t *)NULL;
                m_pRtpSess = (RtpSess_t *)NULL;
                
                hr = RTPERR_REFCOUNT;

                goto bail;
            }
        }
        else
        {
            m_pRtpAddr = (RtpAddr_t *)NULL;
            
            hr = RTPERR_INVALIDSTATE;

            TraceRetail((
                    CLASS_ERROR, GROUP_DSHOW, S_DSHOW_INIT,
                    _T("%s: CIRtpSession[0x%p] pRtpSess[0x%p] pRtpAddr[0x%p]")
                    _T(" failed: %s (0x%X)"),
                    _fname, this, m_pRtpSess, m_pRtpAddr,
                    RTPERR_TEXT(hr), hr
                ));
            
            goto bail;
        }
    }

    /* update flags */
    m_dwIRtpFlags |= (dwFlags & FGADDR_IRTP_MASK);

    /* Update RtpAddr flags indicating if QOS is going to be used and
     * if was auto initialized */
    m_pRtpAddr->dwIRtpFlags |= (dwFlags & FGADDR_IRTP_MASK);

    /* This address will receive and/or send, but here we are adding
     * either a receiver or a sender */
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_ISRECV))
    {
        RtpBitSet(m_pRtpAddr->dwAddrFlags, FGADDR_ISRECV);

        /* Save the pointer to CIRtpSession (that contains a pointer
         * to m_pCBaseFilter aka CRtpSourceFilter) */
        m_pRtpSess->pvSessUser[RECV_IDX] = (void *)this;

        /* Is QOS going to be used ? */
        if (RtpBitTest(dwFlags, FGADDR_IRTP_QOS))
        {
            /* will enable QOS for receiver (will make reservation) */
            RtpBitSet(m_pRtpAddr->dwAddrFlags, FGADDR_QOSRECV);
        }
        
        /* If we already have (DShow) output pins, map them to the RTP
         * outputs */
        pCRtpSourceFilter = static_cast<CRtpSourceFilter *>(m_pCBaseFilter);

        pCRtpSourceFilter->MapPinsToOutputs();

        if (RtpGetClass(m_pRtpAddr->dwIRtpFlags) == RTPCLASS_AUDIO)
        {
            RtpBitSet(m_pRtpAddr->dwIRtpFlags, FGADDR_IRTP_USEPLAYOUT);

            if ( IsRegValueSet(g_RtpReg.dwRedEnable) &&
                 ((g_RtpReg.dwRedEnable & 0x03) == 0x03) )
            {
                RtpSetRedParameters(m_pRtpAddr,
                                    RtpBitPar(RECV_IDX),
                                    g_RtpReg.dwRedPT,
                                    g_RtpReg.dwInitialRedDistance,
                                    g_RtpReg.dwMaxRedDistance);
            }
        }
    }
    else if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_ISSEND))
    {
        RtpBitSet(m_pRtpAddr->dwAddrFlags, FGADDR_ISSEND);

        /* Save the pointer to CIRtpSession (that contains a pointer
         * to m_pCBaseFilter aka CRtpRenderFilter) */
        m_pRtpSess->pvSessUser[SEND_IDX] = (void *)this;

        /* Is QOS going to be used ? */
        if (RtpBitTest(dwFlags, FGADDR_IRTP_QOS))
        {
            /* will enable QOS for sender (will send PATH messages) */
            RtpBitSet(m_pRtpAddr->dwAddrFlags, FGADDR_QOSSEND);
        }

        if (RtpGetClass(m_pRtpAddr->dwIRtpFlags) == RTPCLASS_AUDIO)
        {
            if ( IsRegValueSet(g_RtpReg.dwRedEnable) &&
                 ((g_RtpReg.dwRedEnable & 0x30) == 0x30) )
            {
                RtpSetRedParameters(m_pRtpAddr,
                                    RtpBitPar(SEND_IDX),
                                    g_RtpReg.dwRedPT,
                                    g_RtpReg.dwInitialRedDistance,
                                    g_RtpReg.dwMaxRedDistance);
            }
        }
    }
    else
    {
        /* Unexpected situation */
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_INIT,
                _T("%s: CIRtpSession[0x%p] pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("Cookie:0x%p Flags:0x%X not receiver nor sender"),
                _fname, this, m_pRtpSess, m_pRtpAddr,
                *phCookie, dwFlags
            ));

        hr = RTPERR_UNEXPECTED;

        goto bail;
    }

    /* Inidicate that initialization was done */
    RtpBitSet(m_dwIRtpFlags, FGADDR_IRTP_INITDONE);

    TraceRetail((
            CLASS_INFO, GROUP_DSHOW, S_DSHOW_INIT,
            _T("%s: CIRtpSession[0x%p] pRtpSess[0x%p] pRtpAddr[0x%p] ")
            _T("Cookie:0x%p Flags:0x%X"),
            _fname, this, m_pRtpSess, m_pRtpAddr,
            *phCookie, dwFlags
        ));

    return(hr);
    
 bail:
    TraceRetail((
            CLASS_ERROR, GROUP_DSHOW, S_DSHOW_INIT,
            _T("%s: CIRtpSession[0x%p] pRtpSess[0x%p] pRtpAddr[0x%p] ")
            _T("Cookie:0x%p Flags:0x%X failed: %u (0x%X)"),
            _fname, this, m_pRtpSess, m_pRtpAddr,
            *phCookie, dwFlags, hr, hr
        ));

    Cleanup();
    
    return(hr);
}

/* Deinit is a method used to take the filter back to a state on
 * which a new Init() can and must be done if the filter is to be
 * started again, also note that just after Init(), a filter needs
 * to be configured, that holds also when you use Deinit() taking
 * the filter to its initial state */
STDMETHODIMP CIRtpSession::Deinit(void)
{
    HRESULT          hr;
    CRtpSourceFilter *pCRtpSourceFilter;

    TraceFunctionName("CIRtpSession::Deinit");

    hr = NOERROR;
    
    if (!RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        /* Do nothing if the filter is not initialized yet */
        TraceRetail((
                CLASS_WARNING, GROUP_DSHOW, S_DSHOW_INIT,
                _T("%s: CIRtpSession[0x%p] pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("Not initialized yet, nothing to do"),
                _fname, this, m_pRtpSess, m_pRtpAddr
            ));
        
        return(hr);
    }

    if (m_pCBaseFilter->IsActive())
    {
        /* Fail if the filter is still active */
        hr = RTPERR_INVALIDSTATE;

        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_INIT,
                _T("%s: CIRtpSession[0x%p] pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: filter is still active: %s (0x%X)"),
                _fname, this, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }
    else
    {
        /* OK to deinit */

        /* Make sure the session is stoppped */
        if (RtpBitTest(m_pRtpAddr->dwIRtpFlags, FGADDR_IRTP_PERSISTSOCKETS))
        {
            /* If FGADDR_IRTP_PERSISTSOCKETS is set, the session may
             * be still running in a muted state regardless DShow Stop
             * has been called, to force a real stop, MUST use the
             * flag provided for that */
            if (m_dwRecvSend == RECV_IDX)
            {
                RtpStop(m_pRtpSess,
                        RtpBitPar2(FGADDR_ISRECV, FGADDR_FORCESTOP));
            }
            else
            {
                RtpStop(m_pRtpSess,
                        RtpBitPar2(FGADDR_ISSEND, FGADDR_FORCESTOP));
            }
        }

        if (m_dwRecvSend == RECV_IDX)
        {
            /* Diassociate DShow pins and RtpOutput */
            pCRtpSourceFilter =
                static_cast<CRtpSourceFilter *>(m_pCBaseFilter);

            pCRtpSourceFilter->UnmapPinsFromOutputs();
        }
        
        Cleanup();

        TraceRetail((
                CLASS_INFO, GROUP_DSHOW, S_DSHOW_INIT,
                _T("%s: CIRtpSession[0x%p] pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("Done"),
                _fname, this, m_pRtpSess, m_pRtpAddr
            ));
    }

    return(hr);
}

void CIRtpSession::Cleanup()
{
    long             lRefCount;
    DWORD            dwIndex;
    
    TraceFunctionName("CIRtpSession::Cleanup");

    TraceRetail((
            CLASS_INFO, GROUP_DSHOW, S_DSHOW_INIT,
            _T("%s: CIRtpSession[0x%p] pRtpSess[0x%p] pRtpAddr[0x%p]"),
            _fname, this, m_pRtpSess, m_pRtpAddr
        ));
    
    if (m_pRtpSess)
    {
        lRefCount =
            InterlockedDecrement(&m_pRtpSess->lSessRefCount[m_dwRecvSend]);

        /* Get the opposite index */
        if (m_dwRecvSend == RECV_IDX)
        {
            dwIndex = SEND_IDX;
        }
        else
        {
            dwIndex = RECV_IDX;
        }
        
        lRefCount +=
            InterlockedCompareExchange(&m_pRtpSess->lSessRefCount[dwIndex],
                                       0,
                                       0);

        if (lRefCount <= 0)
        {
            if (m_pRtpAddr)
            {
                DelRtpAddr(m_pRtpSess, m_pRtpAddr);
            }
    
            DelRtpSess(m_pRtpSess);

            if (m_iMode == CIRTPMODE_AUTO)
            {
                m_iMode = CIRTPMODE_NOTSET;
            }
#if USE_GRAPHEDT > 0
            g_hSharedRtpAddr = NULL;
#endif
        }

        m_pRtpAddr = (RtpAddr_t *)NULL;
        m_pRtpSess = (RtpSess_t *)NULL;

        RtpBitReset(m_dwIRtpFlags, FGADDR_IRTP_INITDONE);
    }
}

STDMETHODIMP CIRtpSession::GetPorts(
        WORD            *pwRtpLocalPort,
        WORD            *pwRtpRemotePort,
        WORD            *pwRtcpLocalPort,
        WORD            *pwRtcpRemotePort
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::GetPorts");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        hr = RtpGetPorts(m_pRtpAddr,
                         pwRtpLocalPort,
                         pwRtpRemotePort,
                         pwRtcpLocalPort,
                         pwRtcpRemotePort);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

STDMETHODIMP CIRtpSession::SetPorts(
        WORD             wRtpLocalPort,
        WORD             wRtpRemotePort,
        WORD             wRtcpLocalPort,
        WORD             wRtcpRemotePort
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::SetPorts");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        hr = RtpSetPorts(m_pRtpAddr,
                         wRtpLocalPort,
                         wRtpRemotePort,
                         wRtcpLocalPort,
                         wRtcpRemotePort);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/*
 * All parameters in NETWORK order */
STDMETHODIMP CIRtpSession::SetAddress(
        DWORD            dwLocalAddr,
        DWORD            dwRemoteAddr
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::SetAddress");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        hr = RtpSetAddress(m_pRtpAddr, dwLocalAddr, dwRemoteAddr);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/*
 * All parameters in NETWORK order */
STDMETHODIMP CIRtpSession::GetAddress(
        DWORD           *pdwLocalAddr,
        DWORD           *pdwRemoteAddr
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::GetAddress");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        hr = RtpGetAddress(m_pRtpAddr, pdwLocalAddr, pdwRemoteAddr);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/* The dwFlags parameter is used to determine if the scope is set for
 * RTP (0x1), RTCP (0x2), or both (0x3) */
STDMETHODIMP CIRtpSession::SetScope(
        DWORD            dwTTL,
        DWORD            dwFlags
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::SetScope");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        if (dwFlags & 1)
        { /* RTP */
            m_pRtpAddr->dwTTL[0] = dwTTL;
        }
        if (dwFlags & 2)
        { /* RTCP */
            m_pRtpAddr->dwTTL[1] = dwTTL;
        }
        
        hr = NOERROR;
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}
 
/* Set the multicast loopback mode (e.g. RTPMCAST_LOOPBACKMODE_NONE,
 * RTPMCAST_LOOPBACKMODE_PARTIAL, etc) */
STDMETHODIMP CIRtpSession::SetMcastLoopback(
        int              iMcastLoopbackMode,
        DWORD            dwFlags
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::SetMcastLoopback");  

    hr = RTPERR_NOTINIT;

    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        hr = RtpSetMcastLoopback(m_pRtpAddr, iMcastLoopbackMode, dwFlags);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/* Modify the mask specified by dwKind (e.g. RTPMASK_RECV_EVENTS,
 * RTPMASK_SDES_LOCMASK).
 *
 * dwMask is the mask of bits to be set or reset depending on dwValue
 * (reset if 0, set otherwise).
 *
 * pdwModifiedMask will return the resulting mask if the pointer is
 * not NULL. You can just query the current mask value by passing
 * dwMask=0 */
STDMETHODIMP CIRtpSession::ModifySessionMask(
        DWORD            dwKind,
        DWORD            dwEventMask,
        DWORD            dwValue,
        DWORD           *dwModifiedMask
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::ModifySessionMask");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        hr = RtpModifyMask(m_pRtpSess, dwKind, dwEventMask, dwValue,
                           dwModifiedMask);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/* Set the bandwidth limits. A value of -1 will make the parameter
 * to be left unchanged.
 *
 * All the parameters are in bits/sec */
STDMETHODIMP CIRtpSession::SetBandwidth(
        DWORD            dwInboundBw,
        DWORD            dwOutboundBw,
        DWORD            dwReceiversRtcpBw,
        DWORD            dwSendersRtcpBw
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::SetRtpBandwidth");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        hr = RtpSetBandwidth(m_pRtpAddr,
                             dwInboundBw,
                             dwOutboundBw,
                             dwReceiversRtcpBw,
                             dwSendersRtcpBw);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/* pdwSSRC points to an array of DWORDs where to copy the SSRCs,
 * pdwNumber contains the maximum entries to copy, and returns the
 * actual number of SSRCs copied. If pdwSSRC is NULL, pdwNumber
 * will return the current number of SSRCs (i.e. the current
 * number of participants) */
STDMETHODIMP CIRtpSession::EnumParticipants(
        DWORD           *pdwSSRC,
        DWORD           *pdwNumber
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::EnumParticipants");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        hr = RtpEnumParticipants(m_pRtpAddr, pdwSSRC, pdwNumber);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/* Get the participant state. dwSSRC specifies the
 * participant. piState will return the current participant's
 * state (e.g. RTPPARINFO_TALKING, RTPPARINFO_SILENT). */
STDMETHODIMP CIRtpSession::GetParticipantState(
        DWORD            dwSSRC,
        DWORD           *pdwState
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::GetParticipantState");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        hr = RtpMofifyParticipantInfo(m_pRtpAddr,
                                      dwSSRC,
                                      RTPUSER_GET_PARSTATE,
                                      pdwState);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/* Get the participant's mute state. dwSSRC specifies the
 * participant. pbMuted will return the participant's mute state
 * */
STDMETHODIMP CIRtpSession::GetMuteState(
        DWORD            dwSSRC,
        BOOL            *pbMuted
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::GetMuteState");  

    hr = RTPERR_NOTINIT;

    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        hr = RtpMofifyParticipantInfo(m_pRtpAddr,
                                      dwSSRC,
                                      RTPUSER_GET_MUTE,
                                      (DWORD *)pbMuted);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/* Set the participant's mute state. dwSSRC specifies the
 * participant. bMuted specifies the new state. Note that mute is
 * used to refer to the permission or not to pass packets received
 * up to the application, and it applies equally to audio or video
 * */
STDMETHODIMP CIRtpSession::SetMuteState(
        DWORD            dwSSRC,
        BOOL             bMuted
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::SetMuteState");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        hr = RtpMofifyParticipantInfo(m_pRtpAddr,
                                      dwSSRC,
                                      RTPUSER_SET_MUTE,
                                      (DWORD *)&bMuted);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/* Query the network metrics computation state for the specific SSRC */
STDMETHODIMP CIRtpSession::GetNetMetricsState(
        DWORD            dwSSRC,
        BOOL            *pbState
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::GetNetMetricsState");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        hr = RtpMofifyParticipantInfo(m_pRtpAddr,
                                      dwSSRC,
                                      RTPUSER_GET_NETEVENT,
                                      (DWORD *)pbState);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/* Enable or disable the computation of networks metrics, this is
 * mandatory in order of the corresponding event to be fired if
 * enabled. This is done for the specific SSRC or the first one
 * found if SSRC=-1, if SSRC=0, then the network metrics
 * computation will be performed for any and all the SSRCs */
STDMETHODIMP CIRtpSession::SetNetMetricsState(
        DWORD            dwSSRC,
        BOOL             bState
    )
{
    HRESULT          hr;
    DWORD            dwControl;
    
    TraceFunctionName("CIRtpSession::SetNetMetricsState");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        if (!dwSSRC)
        {
            /* Set it for any and all SSRCs */
            dwControl = RTPUSER_SET_NETEVENTALL;
        }
        else
        {
            /* Set it for only one SSRC */
            dwControl = RTPUSER_SET_NETEVENT;
        }

        hr = RtpMofifyParticipantInfo(m_pRtpAddr,
                                      dwSSRC,
                                      dwControl,
                                      (DWORD *)&bState);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}
    
/* Retrieves network information, if the network metric
 * computation is enabled for the specific SSRC, all the fields in
 * the structure will be meaningful, if not, only the average
 * values will contain valid data */
STDMETHODIMP CIRtpSession::GetNetworkInfo(
        DWORD            dwSSRC,
        RtpNetInfo_t    *pRtpNetInfo
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::GetNetworkInfo");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        hr = RtpMofifyParticipantInfo(m_pRtpAddr,
                                      dwSSRC,
                                      RTPUSER_GET_NETINFO,
                                      (DWORD *)pRtpNetInfo);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}


/* Set the local SDES information for item dwSdesItem (e.g
 * RTPSDES_CNAME, RTPSDES_EMAIL), psSdesData contains the UNICODE
 * NULL terminated string to be assigned to the item */
STDMETHODIMP CIRtpSession::SetSdesInfo(
        DWORD            dwSdesItem,
        WCHAR           *psSdesData
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::SetSdesInfo");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        hr = RtpSetSdesInfo(m_pRtpAddr, dwSdesItem, psSdesData);
    }
    
    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/* Get a local SDES item if dwSSRC=0, otherwise gets the SDES item
 * from the participant whose SSRC was specified.
 *
 * dwSdesItem is the item to get (e.g. RTPSDES_CNAME,
 * RTPSDES_EMAIL), psSdesData is the memory place where the item's
 * value will be copied, pdwSdesDataLen contains the initial size
 * in UNICODE chars, and returns the actual UNICODE chars copied
 * (including the NULL terminating char, if any), dwSSRC specify
 * which participant to retrieve the information from. If the SDES
 * item is not available, dwSdesDataLen is set to 0 and the call
 * doesn't fail */
STDMETHODIMP CIRtpSession::GetSdesInfo(
        DWORD            dwSdesItem,
        WCHAR           *psSdesData,
        DWORD           *pdwSdesDataLen,
        DWORD            dwSSRC
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::GetSdesInfo");  

    hr = RTPERR_NOTINIT;

    if (!dwSSRC || RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        hr = RtpGetSdesInfo(m_pRtpAddr,
                            dwSdesItem,
                            psSdesData,
                            pdwSdesDataLen,
                            dwSSRC);
    }
    
    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/* Select a QOS template (flowspec) by passing its name in
 * psQosName, dwResvStyle specifies the RSVP style (e.g
 * RTPQOS_STYLE_WF, RTPQOS_STYLE_FF), dwMaxParticipants specifies
 * the max number of participants (1 for unicast, N for
 * multicast), this number is used to scale up the
 * flowspec. dwQosSendMode specifies the send mode (has to do with
 * allowed/not allowed to send) (e.g. RTPQOSSENDMODE_UNRESTRICTED,
 * RTPQOSSENDMODE_RESTRICTED1). dwMinFrameSize is the minimum
 * frame size (in ms), passing 0 makes this parameter be ignored
 * */
STDMETHODIMP CIRtpSession::SetQosByName(
        TCHAR           *psQosName,
        DWORD            dwResvStyle,
        DWORD            dwMaxParticipants,
        DWORD            dwQosSendMode,
        DWORD            dwMinFrameSize
    )
{
    HRESULT          hr;
    
    TraceFunctionName("CIRtpSession::SetQosByName");  

    hr = RTPERR_NOTINIT;

    TraceRetail((
            CLASS_INFO, GROUP_DSHOW, S_DSHOW_CIRTP,
            _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
            _T("QOS Name:%s Style:%d MaxParticipants:%d ")
            _T("SendMode:%d FrameSize:%d"),
            _fname, m_pRtpSess, m_pRtpAddr,
            psQosName, dwResvStyle, dwMaxParticipants,
            dwQosSendMode, dwMinFrameSize
        ));

    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        hr = RtpSetQosByNameOrPT(m_pRtpAddr,
                                 RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_ISRECV)?
                                 RECV_IDX : SEND_IDX,
                                 psQosName,
                                 NO_DW_VALUESET,
                                 dwResvStyle,
                                 dwMaxParticipants,
                                 dwQosSendMode,
                                 dwMinFrameSize,
                                 FALSE /* Not internal, i.e. from API */);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/* Not yet implemented, will have same functionality as
 * SetQosByName, except that instead of passing a name to use a
 * predefined flowspec, the caller will pass enough information in
 * the RtpQosSpec structure to obtain the customized flowspec to
 * use */
STDMETHODIMP CIRtpSession::SetQosParameters(
        RtpQosSpec_t    *pRtpQosSpec,
        DWORD            dwMaxParticipants,
        DWORD            dwQosSendMode
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::SetQosParameters");  

    hr = RTPERR_NOTIMPL;

#if 0
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        hr = RtpSetQosParameters(m_pRtpAddr,
                                 RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_ISRECV)?
                                 RECV_IDX : SEND_IDX,
                                 pRtpQosSpec,
                                 dwMaxParticipants,
                                 dwQosSendMode);
    }
#endif
    
    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/* If AppName is specified, replaces the default AppName, as well
 * as the APP field in the policy used, with the new UNICODE
 * string, if not, sets the binary image name as the default. If
 * psPolicyLocator is specified, append a comma and this whole
 * string to the default policy locator, if not, just sets the
 * default
 * */
STDMETHODIMP CIRtpSession::SetQosAppId(
        WCHAR           *psAppName,
        WCHAR           *psAppGUID,
        WCHAR           *psPolicyLocator
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::SetQosAppId");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        hr = RtpSetQosAppId(m_pRtpAddr, psAppName, psAppGUID, psPolicyLocator);
    }
    
    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/* Adds/removes a single SSRC to/from the shared explicit list of
 * participants who receive reservation (i.e. it is used when the
 * ResvStyle=RTPQOS_STYLE_SE). */
STDMETHODIMP CIRtpSession::SetQosState(
        DWORD            dwSSRC,
        BOOL             bEnable
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::SetQosState");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_ISSEND))
        {
            hr = NOERROR;
        }
        else
        {
            hr = RtpSetQosState(m_pRtpAddr, dwSSRC, bEnable);
        }
    }
    
    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/* Adds/removes a number of SSRCs to/from the shared explicit list
 * of participants who receive reservation (i.e. it is used when
 * the ResvStyle=RTPQOS_STYLE_SE). dwNumber is the number of SSRCs
 * to add/remove, and returns the actual number of SSRCs
 * added/removed */
STDMETHODIMP CIRtpSession::ModifyQosList(
        DWORD           *pdwSSRC,
        DWORD           *pdwNumber,
        DWORD            dwOperation
    )
{
    HRESULT          hr;
    
    TraceFunctionName("CIRtpSession::ModifyQosList");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_ISSEND))
        {
            hr = NOERROR;
        }
        else
        {
            hr = RtpModifyQosList(m_pRtpAddr, pdwSSRC, pdwNumber, dwOperation);
        }
    }
    
    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/* iMode defines what is going to be encrypted/decrypted,
 * e.g. RTPCRYPTMODE_PAYLOAD to encrypt/decrypt only RTP
 * payload. dwFlag can be RTPCRYPT_SAMEKEY to indicate that (if
 * applicable) the key used for RTCP is the same used for RTP */
STDMETHODIMP CIRtpSession::SetEncryptionMode(
        int              iMode,
        DWORD            dwFlags
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::SetEncryptionMode");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        if ( !(RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_ISRECV) &&
               RtpBitTest(m_pRtpAddr->dwAddrFlags, FGADDR_RUNRECV)) &&

             !(RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_ISSEND) &&
               RtpBitTest(m_pRtpAddr->dwAddrFlags, FGADDR_RUNSEND)) )
        {
            hr = RtpSetEncryptionMode(m_pRtpAddr, iMode, dwFlags);
        }
        else
        {
            hr = RTPERR_INVALIDSTATE;
        }
    }
    
    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/* Specifies the information needed to derive an
 * encryption/decryption key. PassPhrase is the (random) text used
 * to generate a key. HashAlg specifies the algorithm to use to
 * hash the pass phrase and generate a key. DataAlg is the
 * algorithm used to encrypt/decrypt the data. Default hash
 * algorithm is RTPCRYPT_MD5, default data algorithm is
 * RTPCRYPT_DES. If encryption is to be used, the PassPhrase is a
 * mandatory parameter to set */
STDMETHODIMP CIRtpSession::SetEncryptionKey(
        TCHAR           *psPassPhrase,
        TCHAR           *psHashAlg,
        TCHAR           *psDataAlg,
        BOOL            bRtcp
    )
{
    HRESULT          hr;
    DWORD            dwIndex;

    TraceFunctionName("CIRtpSession::SetEncryptionKey");  

    hr = RTPERR_NOTINIT;
    
    if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_INITDONE))
    {
        if ( !(RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_ISRECV) &&
               RtpBitTest(m_pRtpAddr->dwAddrFlags, FGADDR_RUNRECV)) &&

             !(RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_ISSEND) &&
               RtpBitTest(m_pRtpAddr->dwAddrFlags, FGADDR_RUNSEND)) )
        {
            if (bRtcp)
            {
                dwIndex = CRYPT_RTCP_IDX;
            }
            else
            {
                if (RtpBitTest(m_dwIRtpFlags, FGADDR_IRTP_ISRECV))
                {
                    dwIndex = CRYPT_RECV_IDX;
                }
                else
                {
                    dwIndex = CRYPT_SEND_IDX;
                }
            }
    
            hr = RtpSetEncryptionKey(m_pRtpAddr, psPassPhrase,
                                     psHashAlg, psDataAlg,
                                     dwIndex);
        }
        else
        {
            hr = RTPERR_INVALIDSTATE;
        }
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("failed: %s (0x%X)"),
                _fname, m_pRtpSess, m_pRtpAddr,
                RTPERR_TEXT(hr), hr
            ));
    }

    return(hr);
}

/**************************************************
 * Helper methods
 **************************************************/
    
HRESULT CIRtpSession::CIRtpSessionNotifyEvent(
        long             EventCode,
        LONG_PTR         EventParam1,
        LONG_PTR         EventParam2
    )
{
    HRESULT          hr;

    TraceFunctionName("CIRtpSession::CIRtpSessionNotifyEvent");
    
    hr = NOERROR;
    
    if (m_pCBaseFilter)
    {
        hr = m_pCBaseFilter->NotifyEvent(EventCode, EventParam1, EventParam2);
        if ( SUCCEEDED(hr) )
        {
            TraceRetailAdvanced((
                    0, GROUP_DSHOW,S_DSHOW_EVENT,
                    _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] Succeeded: ")
                    _T("Code:%u (0x%X) P1:0x%p P2:0x%p"),
                    _fname, m_pRtpSess, m_pRtpAddr,
                    EventCode, EventCode,
                    EventParam1, EventParam2
                ));
        }
        else
        {
            TraceRetail((
                    CLASS_ERROR, GROUP_DSHOW, S_DSHOW_EVENT,
                    _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] failed: ")
                    _T("%u (0x%X) !!! ")
                    _T("Code:%u (0x%X) P1:0x%p P2:0x%p"),
                    _fname, m_pRtpSess, m_pRtpAddr,
                    hr, hr,
                    EventCode, EventCode,
                    EventParam1, EventParam2
                ));
        }
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtcpband.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtcpband.h
 *
 *  Abstract:
 *
 *    Main data structures
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    2001/01/31 created
 *
 **********************************************************************/
#ifndef _rtcpband_h_
#define _rtcpband_h_

/* Bandwidth estimation */

/* The initial count is the number of reports that will use
 * MOD_INITIAL to decide if a probe packet is sent, after that
 * MOD_FINAL will be used. */
extern DWORD            g_dwRtcpBandEstInitialCount;

/* Number or valid reports received before the estimation is posted
 * for the first time */
extern DWORD            g_dwRtcpBandEstMinReports;

/* Initial modulo */
extern DWORD            g_dwRtcpBandEstModInitial;

/* Final modulo */
extern DWORD            g_dwRtcpBandEstModNormal;

/*
 * WARNING
 *
 * Make sure to keep the number of individual bins to be
 * RTCP_BANDESTIMATION_MAXBINS+1 (same thing in rtpreg.h and rtpreg.c)
 *
 * Boundaries for each bin (note there is 1 more than the number of
 * bins) */
extern double           g_dRtcpBandEstBin[];

/* Estimation is valid if updated within this time (seconds) */
extern double           g_dRtcpBandEstTTL;

/* An event is posted if no estimation is available within this
 * seconds after the first RB has been received */
extern double           g_dRtcpBandEstWait;

/* Maximum time gap between 2 consecutive RTCP SR reports to do
 * bandwidth estimation (seconds) */
extern double           g_dRtcpBandEstMaxGap;

#endif /* _rtcpband_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtcpint.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtcpint.h
 *
 *  Abstract:
 *
 *    Computes the RTCP report interval time
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/12/07 created
 *
 **********************************************************************/

#ifndef _rtcpint_h_
#define _rtcpint_h_

#include "struct.h"

double RtcpNextReportInterval(RtpAddr_t *pRtpAddr);

#endif /* _rtcpint_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtcpdec.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtcpdec.h
 *
 *  Abstract:
 *
 *    Decode RTCP packets
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/11/08 created
 *
 **********************************************************************/

#ifndef _rtcpdec_h_
#define _rtcpdec_h_

#include "struct.h"

DWORD RtcpProcessSR_RR(
        RtcpAddrDesc_t  *pRtcpAddrDesc,
        char            *hdr,
        int              packetsize,
        SOCKADDR_IN     *FromIn
    );

DWORD RtcpProcessSDES(
        RtcpAddrDesc_t  *pRtcpAddrDesc,
        char            *hdr
    );

DWORD RtcpProcessBYE(
        RtcpAddrDesc_t  *pRtcpAddrDesc,
        char            *hdr
    );

DWORD RtcpProcessAPP(
        RtcpAddrDesc_t  *pRtcpAddrDesc,
        char            *hdr
    );

DWORD RtcpProcessDefault(
        RtcpAddrDesc_t  *pRtcpAddrDesc,
        char            *hdr
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtcpsdes.h ===
/**********************************************************************
 *
 *  Copyright (C) 1999 Microsoft Corporation
 *
 *  File name:
 *
 *    rtcpsdes.h
 *
 *  Abstract:
 *
 *    SDES support functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/07/13 created
 *
 **********************************************************************/

#ifndef _rtcpsdes_h_
#define _rtcpsdes_h_

#if defined(__cplusplus)
extern "C" {
#endif  // (__cplusplus)
#if 0
}
#endif

#include "struct.h"

#define  RTPSDES_LOCAL_DEFAULT ( \
                                 (1 << RTPSDES_CNAME) | \
                                 (1 << RTPSDES_NAME)  | \
                                 (1 << RTPSDES_EMAIL) | \
                                 (1 << RTPSDES_PHONE) | \
                                 (1 << RTPSDES_LOC)   | \
                                 (1 << RTPSDES_TOOL)  | \
                                 (1 << RTPSDES_NOTE)  | \
                                 (1 << RTPSDES_PRIV)  | \
                                  0 )

#define  RTPSDES_REMOTE_DEFAULT ( \
                                 (1 << RTPSDES_CNAME) | \
                                 (1 << RTPSDES_NAME)  | \
                                 (1 << RTPSDES_EMAIL) | \
                                 (1 << RTPSDES_PHONE) | \
                                 (1 << RTPSDES_LOC)   | \
                                 (1 << RTPSDES_TOOL)  | \
                                 (1 << RTPSDES_NOTE)  | \
                                 (1 << RTPSDES_PRIV)  | \
                                  0 )

#define RTPSDES_EVENT_RECV_DEFAULT 0

#define RTPSDES_EVENT_SEND_DEFAULT 0

extern const TCHAR_t   *g_psSdesNames[];
extern RtpSdes_t        g_RtpSdesDefault;

/* Initialize to zero and compute the data pointers */
void RtcpSdesInit(RtpSdes_t *pRtpSdes);

/*
 * Sets a specific SDES item, expects a NULL terminated UNICODE string
 * no bigger than 255 bytes when converted to UTF-8 (including the
 * NULL terminating character). The string is converted to UTF-8 to be
 * stored and used in RTCP reports.
 *
 * Returns the mask of the item set or 0 if none
 * */
DWORD RtcpSdesSetItem(
        RtpSdes_t       *pRtpSdes,
        DWORD            dwItem,
        WCHAR           *pData
    );

/* Obtain default values for the RTCP SDES items. This function
 * assumes the structure was initialized, i.e. zeroed and the data
 * pointers properly initialized.
 *
 * Data is first read from the registry and then defaults are set for
 * some items that don't have value yet
 *
 * Return the mask of items that where set */
DWORD RtcpSdesSetDefault(RtpSdes_t *pRtpSdes);

/* Creates and initializes a RtpSdes_t structure */
RtpSdes_t *RtcpSdesAlloc(void);

/* Frees a RtpSdes_t structure */
void RtcpSdesFree(RtpSdes_t *pRtpSdes);

/* Set the local SDES info for item dwSdesItem (e.g RTPSDES_CNAME,
 * RTPSDES_EMAIL), psSdesData contains the NUL terminated UNICODE
 * string to be assigned to the item */
HRESULT RtpSetSdesInfo(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwSdesItem,
        WCHAR           *psSdesData
    );

/* Get a local SDES item if dwSSRC=0, otherwise gets the SDES item
 * from the participant whose SSRC was specified.
 *
 * dwSdesItem is the item to get (e.g. RTPSDES_CNAME, RTPSDES_EMAIL),
 * psSdesData is the memory place where the item's value will be
 * copied, pdwSdesDataLen contains the initial size in UNICODE chars,
 * and returns the actual UNICODE chars copied (including the NULL
 * terminating char), dwSSRC specify which participant to retrieve the
 * information from. If the SDES item is not available, dwSdesDataLen
 * is set to 0 and the call doesn't fail */
HRESULT RtpGetSdesInfo(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwSdesItem,
        WCHAR           *psSdesData,
        DWORD           *pdwSdesDataLen,
        DWORD            dwSSRC
    );

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif /* _rtcpsdes_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtcprecv.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtcprecv.h
 *
 *  Abstract:
 *
 *    Asynchronous RTCP packet reception
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/07/07 created
 *
 **********************************************************************/

#ifndef _rtcprecv_h_
#define _rtcprecv_h_

#include "struct.h"
#include "rtcpthrd.h"

HRESULT StartRtcpRecvFrom(
        RtcpContext_t   *pRtcpContext,
        RtcpAddrDesc_t  *pRtcpAddrDesc
    );

HRESULT ConsumeRtcpRecvFrom(
        RtcpContext_t   *pRtcpContext,
        RtcpAddrDesc_t  *pRtcpAddrDesc
    );

RtcpRecvIO_t *RtcpRecvIOAlloc(
        RtcpAddrDesc_t  *pRtcpAddrDesc
    );

void RtcpRecvIOFree(
        RtcpRecvIO_t    *pRtcpRecvIO
    );

#endif /* _rtcprecv_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtcpsend.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtcpsend.h
 *
 *  Abstract:
 *
 *    Format and send RTCP reports
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/07/10 created
 *
 **********************************************************************/

#ifndef _rtcpsend_h_
#define _rtcpsend_h_

#include "struct.h"

#define SDES_MOD_L1 2
#define SDES_MOD_L2 4
#define SDES_MOD_L3 2

HRESULT RtcpSendReport(RtcpAddrDesc_t *pRtcpAddrDesc);

HRESULT RtcpSendBye(RtcpAddrDesc_t *pRtcpAddrDesc);

RtcpSendIO_t *RtcpSendIOAlloc(RtcpAddrDesc_t *pRtcpAddrDesc);

void RtcpSendIOFree(RtcpSendIO_t *pRtcpSendIO);

double RtcpUpdateAvgPacketSize(RtpAddr_t *pRtpAddr, DWORD dwPacketSize);

#endif /* _rtcpsend_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtpcrit.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpcrit.h
 *
 *  Abstract:
 *
 *    Wrap for the Rtl critical sections
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/24 created
 *
 **********************************************************************/

#ifndef _rtpcrit_h_
#define _rtpcrit_h_

#include "gtypes.h"

#if defined(__cplusplus)
extern "C" {
#endif  // (__cplusplus)
#if 0
}
#endif

/* TODO (may be) add an object ID and test for it */
typedef struct _RtpCritSect_t {
    DWORD             dwObjectID; /* Object ID */
    void             *pvOwner; /* pointer to the owner */
    TCHAR            *pName;   /* Critical section's name */
    CRITICAL_SECTION  CritSect;/* critical section */
} RtpCritSect_t;

BOOL RtpInitializeCriticalSection(
        RtpCritSect_t   *pRtpCritSect,
        void            *pvOwner,
        TCHAR           *pName
    );

BOOL RtpDeleteCriticalSection(RtpCritSect_t *pRtpCritSect);

BOOL RtpEnterCriticalSection(RtpCritSect_t *pRtpCritSect);

BOOL RtpLeaveCriticalSection(RtpCritSect_t *pRtpCritSect);

#define IsRtpCritSectInitialized(pRtpCritSect) \
        ((pRtpCritSect)->dwObjectID == OBJECTID_RTPCRITSECT)

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif /* _rtpcrit_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtcpthrd.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtcpthrd.h
 *
 *  Abstract:
 *
 *    RTCP thread
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/07/07 created
 *
 **********************************************************************/

#ifndef _rtcpthrd_h_
#define _rtcpthrd_h_

#include "struct.h"
#include "rtpque.h"

/* Commands a RTCP worker thread accepts.
 *
 * WARNING
 *
 * This enum must match the entries in g_psRtcpThreadCommands in
 * rtcpthrd.c
 * */
typedef enum {
    RTCPTHRD_FIRST = 100,
    
    RTCPTHRD_ADDADDR,   /* Add 1 address */
    RTCPTHRD_DELADDR,   /* Remove 1 address */
    RTCPTHRD_RESERVE,   /* Do a QOS reservation */
    RTCPTHRD_UNRESERVE, /* Undo a QOS reservation */
    RTCPTHRD_SENDBYE,   /* Send RTCP BYE and may be Shutdown */
    RTCPTHRD_EXIT,      /* Exit thread */

    RTCPTHRD_LAST
} RTCPTHRD_e;

/**************************************************/
#if USE_RTCP_THREAD_POOL > 0

typedef enum {
    RTCPPOOL_FIRST = 200,

    RTCPPOOL_RTCPRECV,  /* RTCP packet received (RECV I/O completed) */
    RTCPPOOL_QOSNOTIFY, /* QOS notification (I/O completed) */

    RTCPPOOL_LAST
} RTCPOOL_e;

#define RTCP_HANDLE_OFFSET  2    /* number of handles for private use */
#define RTCP_HANDLE_SIZE    0    /* number of handles per session */
/* max number of sessions */
#define RTCP_MAX_DESC       512

#define RTCP_NUM_OF_HANDLES 2

/**************************************************/
#else /* USE_RTCP_THREAD_POOL > 0 */

/*
 * The Event handles vector for each RTCP thread is organized as
 * follows:
 *
 * 1. A number of handles for private use, e.g. to receive commands
 * (currently 1)
 *
 * 2. A set of per descriptor events (currently 2, RTCP recv, and QOS
 * notifications)
 *
 * Each descriptor has an index that positions it at vector
 * ppRtcpAddrDesc. I.e. index has values 0, 1, 2, ...
 * */

#define RTCP_HANDLE_OFFSET  1    /* number of handles for private use */
#define RTCP_HANDLE_SIZE    2    /* number of handles per session */
/* max number of sessions */
#define RTCP_MAX_DESC       ((MAXIMUM_WAIT_OBJECTS - RTCP_HANDLE_OFFSET) / \
                             RTCP_HANDLE_SIZE)

#define RTCP_NUM_OF_HANDLES \
              (RTCP_HANDLE_OFFSET + RTCP_MAX_DESC * RTCP_HANDLE_SIZE)

/**************************************************/
#endif /* USE_RTCP_THREAD_POOL > 0 */

typedef struct _RtcpContext_t {
    DWORD            dwObjectID;
    RtpCritSect_t    RtcpContextCritSect;
    
    /* RtcpAddrDesc items */
    RtpQueue_t       AddrDescFreeQ; /* Free AddrDesc items */
    RtpQueue_t       AddrDescBusyQ; /* In use AddrDesc items */
    RtpQueue_t       AddrDescStopQ; /* Those who are just waiting for
                                    * their I/O to complete to be moved
                                    * to FreeQ */
    /* QOS notifications */
    RtpQueue_t       QosStartQ;     /* To be started descriptors */
    RtpQueue_t       QosBusyQ;      /* Active descriptors */
    RtpQueue_t       QosStopQ;      /* Stopped descriptors */

    /* RTCP reports sending */
    RtpQueue_t       SendReportQ;   /* Ordered AddrDesc list (in use) */

    /* RTCP thread */
    HANDLE           hRtcpContextThread;
    DWORD            dwRtcpContextThreadID;
    long             lRtcpUsers;

    RtpChannel_t     RtcpThreadCmdChannel;
    
#if USE_RTCP_THREAD_POOL > 0
    RtpChannel_t     RtcpThreadIoChannel;
    /* Event handles and RTCP address descriptors */
    DWORD            dwMaxDesc;/* Number of next descriptor to add (or
                                * current number of descriptors), not
                                * handles */
    HANDLE           pHandle[RTCP_NUM_OF_HANDLES];
#else /* USE_RTCP_THREAD_POOL > 0 */
    /* Event handles and RTCP address descriptors */
    DWORD            dwMaxDesc;/* Number of next descriptor to add (or
                                * current number of descriptors), not
                                * handles */
    HANDLE           pHandle[RTCP_NUM_OF_HANDLES];
    RtcpAddrDesc_t  *ppRtcpAddrDesc[RTCP_MAX_DESC];
#endif /* USE_RTCP_THREAD_POOL > 0 */
} RtcpContext_t;

extern RtcpContext_t g_RtcpContext;

/*
 * Do minimal global initialization for RTCP
 * */
HRESULT RtcpInit(void);

/*
 * Do last global de-initialization for RTCP
 * */
HRESULT RtcpDelete(void);

/*
 * Start the RTCP thread
 * */
HRESULT RtcpStart(RtcpContext_t *pRtcpContext);

/*
 * Stop the RTCP thread
 * */
HRESULT RtcpStop(RtcpContext_t *pRtcpContext);

/*
 * Send a command to the RTCP thread
 * */
HRESULT RtcpThreadCmd(
        RtcpContext_t   *pRtcpContext,
        RtpAddr_t       *pRtpAddr,
        RTCPTHRD_e       eCommand,
        DWORD            dwParam,
        DWORD            dwWaitTime
    );

/*
 * Decide if we need to drop this packet or we have a collision
 * */
BOOL RtpDropCollision(
        RtpAddr_t       *pRtpAddr,
        SOCKADDR_IN     *pSockAddrIn,
        BOOL             bRtp
    );

#endif /* _rtcpthrd_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtpaddr.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpaddr.h
 *
 *  Abstract:
 *
 *    Implements the Address family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/01 created
 *
 **********************************************************************/

#ifndef _rtpaddr_h_
#define _rtpaddr_h_

#include "rtpfwrap.h"

/***********************************************************************
 *
 * Address functions family
 *
 **********************************************************************/

enum {
    RTPADDR_FIRST,
    RTPADDR_CREATE,     /* Create/Delete */
    RTPADDR_DEFAULT,    /* Default address */
    RTPADDR_RTP,        /* RTP address/port */
    RTPADDR_RTCP,       /* RTCP address/port */
    RTPADDR_TTL,        /* Time To Live */
    RTPADDR_MULTICAST_LOOPBACK, /* Multicast loopback */
    RTPADDR_LAST
};

#if defined(__cplusplus)
extern "C" {
#endif  /* (__cplusplus) */
#if 0
}
#endif

HRESULT ControlRtpAddr(RtpControlStruct_t *pRtpControlStruct);

HRESULT RtpGetPorts(
        RtpAddr_t       *pRtpAddr,
        WORD            *pwRtpLocalPort,
        WORD            *pwRtpRemotePort,
        WORD            *pwRtcpLocalPort,
        WORD            *pwRtcpRemotePort
    );

HRESULT RtpSetPorts(
        RtpAddr_t       *pRtpAddr,
        WORD             wRtpLocalPort,
        WORD             wRtpRemotePort,
        WORD             wRtcpLocalPort,
        WORD             wRtcpRemotePort
    );

HRESULT RtpSetAddress(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwLocalAddr,
        DWORD            dwRemoteAddr
    );
    
HRESULT RtpGetAddress(
        RtpAddr_t       *pRtpAddr,
        DWORD           *pdwLocalAddr,
        DWORD           *pdwRemoteAddr
    );

HRESULT RtpGetSockets(RtpAddr_t *pRtpAddr);

HRESULT RtpDelSockets(RtpAddr_t *pRtpAddr);

void RtpSetSockOptions(RtpAddr_t *pRtpAddr);

DWORD RtpSetRecvBuffSize(
        RtpAddr_t       *pRtpAddr,
        SOCKET           Socket,
        int              iBuffSize
    );

HRESULT RtpSetMcastLoopback(
        RtpAddr_t       *pRtpAddr,
        int              iMcastLoopbackMode,
        DWORD            dwFlags /* Not used now */
    );

HRESULT RtpNetMute(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwFlags
    );

HRESULT RtpNetUnmute(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwFlags
    );

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  /* (__cplusplus) */

#endif /* _rtpaddr_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtpchan.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpchan.h
 *
 *  Abstract:
 *
 *    Implements a communication channel between the RTCP thread
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/07/08 created
 *
 **********************************************************************/

#ifndef _rtpchan_h_
#define _rtpchan_h_

#include "gtypes.h"
#include "rtpque.h"
#include "rtpcrit.h"

/*
 * The steps to use a channel are:
 *
 * 1. Send command with RtpChannelSend()
 *
 * 2. The thread (that waited on the channel) is awakened and gets the
 * command with RtpChannelGetCmd()
 *
 * 4. The thread makes any use it wants of the command
 *
 * 5. The thread aknowledges the command with RtpChannelAck()
 *
 * NOTE: The RtPChannelCmd_t structures are allocated from a global
 * heap
 * */


/* Some flags in RtpChanCmd_t.dwFalsgs */
enum {
    FGCHAN_FIRST,
    FGCHAN_SYNC,   /* Synchronize response */
    FGCHAN_LAST
};

typedef struct _RtpChannel_t {
    RtpQueue_t     FreeQ;
    RtpQueue_t     CommandQ;
    RtpCritSect_t  ChannelCritSect;
    HANDLE         hWaitEvent;      /* Thread waits for commands on
                                     * this event */
} RtpChannel_t;

typedef struct _RtpChannelCmd_t {
    DWORD           dwObjectID;     /* Identifies structure */
    RtpQueueItem_t  QueueItem;
    HANDLE          hSyncEvent;     /* Synchronize sender when the
                                     * command is consummed */
    DWORD           dwCommand;
    DWORD_PTR       dwPar1;
    DWORD_PTR       dwPar2;
    DWORD           dwFlags;
    HRESULT         hr;
} RtpChannelCmd_t;

#define IsRtpChannelInitialized(pCh) \
(IsRtpCritSectInitialized(&(pCh)->ChannelCritSect))

#define RtpChannelGetWaitEvent(pCh) ((pCh)->hWaitEvent)

/*
 * Initialization
 * */

/* Initializes a channel */
HRESULT RtpChannelInit(
        RtpChannel_t    *pRtpChannel,
        void            *pvOwner
    );

/* De-initializes a channel */
HRESULT RtpChannelDelete(
        RtpChannel_t    *pRtpChannel
    );

/*
 * Usage
 * */

/* Send a command to the specified channel. Wait for completion if
 * requested. The HRESULT returned is either a local failure, or the
 * result passed back from the thread if synchronous (wait time > 0)
 * */
HRESULT RtpChannelSend(
        RtpChannel_t    *pRtpChannel,
        DWORD            dwCommand,
        DWORD_PTR        dwPar1,
        DWORD_PTR        dwPar2,
        DWORD            dwWaitTime
    );

/* Once a waiting thread is awakened, it get the sent comman(s) with
 * this function */
RtpChannelCmd_t *RtpChannelGetCmd(
        RtpChannel_t    *pRtpChannel
    );

/* Used by the consumer thread to acknowledge received commands */
HRESULT RtpChannelAck(
        RtpChannel_t    *pRtpChannel,
        RtpChannelCmd_t *pRtpChannelCmd,
        HRESULT          hr
    );

#endif /* _rtpchan_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtpcrypt.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpcrypt.h
 *
 *  Abstract:
 *
 *    Implements the Cryptography family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/07 created
 *
 **********************************************************************/

#ifndef _rtpcrypt_h_
#define _rtpcrypt_h_

#include "struct.h"

#include "rtpfwrap.h"

/***********************************************************************
 *
 * Cryptographic services family
 *
 **********************************************************************/

#if defined(__cplusplus)
extern "C" {
#endif  // (__cplusplus)
#if 0
}
#endif

/* TODO delete this (obsolete) */
enum {
    RTPCRYPT_FIRST,
    RTPCRYPT_KEY,
    RTPCRYPT_PROVIDER,
    RTPCRYPT_ALGORITHM,
    RTPCRYPT_PASS_PHRASE,
    RTPCRYPT_CRYPT_MASK,
    RTPCRYPT_TEST_CRYPT_MASK,
    RTPCRYPT_LAST
};

HRESULT ControlRtpCrypt(RtpControlStruct_t *pRtpControlStruct);

DWORD RtpCryptSetup(RtpAddr_t *pRtpAddr);
DWORD RtpCryptCleanup(RtpAddr_t *pRtpAddr);

DWORD RtpCryptInit(RtpAddr_t *pRtpAddr, RtpCrypt_t *pRtpCrypt);
DWORD RtpCryptDel(RtpAddr_t *pRtpAddr, RtpCrypt_t *pRtpCrypt);

DWORD RtpEncrypt(
        RtpAddr_t       *pRtpAddr,
        RtpCrypt_t      *pRtpCrypt,
        WSABUF          *pWSABuf,
        DWORD            dwWSABufCount,
        char            *pCryptBuffer,
        DWORD            dwCryptBufferLen
    );

DWORD RtpDecrypt(
        RtpAddr_t       *pRtpAddr,
        RtpCrypt_t      *pRtpCrypt,
        char            *pEncryptedData,
        DWORD           *pdwEncryptedDataLen
    );

DWORD RtpSetEncryptionMode(
        RtpAddr_t       *pRtpAddr,
        int              iMode,
        DWORD            dwFlags
        );

DWORD RtpSetEncryptionKey(
        RtpAddr_t       *pRtpAddr,
        TCHAR           *psPassPhrase,
        TCHAR           *psHashAlg,
        TCHAR           *psDataAlg,
        DWORD            dwIndex
    );

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif /* _rtpcrypt_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtpdbg.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpdbg.h
 *
 *  Abstract:
 *
 *    Debug support
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/07/07 created
 *
 **********************************************************************/

#ifndef _rtpdbg_h_
#define _rtpdbg_h_

#if defined(__cplusplus)
extern "C" {
#endif  // (__cplusplus)
#if 0
}
#endif

extern const TCHAR *g_psSockIdx[];

void MSRtpTraceDebug(
        IN DWORD         dwClass,
        IN DWORD         dwGroup,
        IN DWORD         dwSelection,
        IN TCHAR        *lpszFormat,
        IN               ...
    );

#define TraceFunctionName(_Name)      static TCHAR_t *_fname = _T(_Name)
#define TraceRetailGetError(error)    (error = GetLastError())
#define TraceRetailWSAGetError(error) (error = WSAGetLastError())
/* Trace support for free AND debug versions */
#define TraceRetail(arg)              MSRtpTraceDebug arg
#define TraceRetailAdvanced(arg)      if (IsAdvancedTracingUsed()) \
                                      {\
                                          MSRtpTraceDebug arg ;\
                                      }

#define IsAdvancedTracingUsed()       (g_RtpDbgReg.dwUseAdvancedTracing)

#if DBG > 0
/**********************************************************************
 * DEBUG BUILD ONLY macros
 **********************************************************************/
#define RTPASSERT(x)                  {if (!(x)) DebugBreak();}
#define TraceDebugGetError(error)     TraceRetailGetError(error)
#define TraceDebugWSAGetError(error)  TraceRetailWSAGetError(error)
#define TraceDebug(arg)               TraceRetail(arg)
#define TraceDebugAdvanced(arg)       TraceRetailAdvanced(arg)

#else   /* DBG > 0 */
/**********************************************************************
 * FREE BUILD ONLY macros
 **********************************************************************/
#define RTPASSERT(x)

#if USE_TRACE_DEBUG > 0
#define TraceDebugGetError(error)     TraceRetailGetError(error)
#define TraceDebugWSAGetError(error)  TraceRetailWSAGetError(error)
#define TraceDebug(arg)               TraceRetailAdvanced(arg)
#define TraceDebugAdvanced(arg)       TraceRetailAdvanced(arg)
#else /* USE_TRACE_DEBUG > 0 */
#define TraceDebugGetError(error)
#define TraceDebugWSAGetError(error)
#define TraceDebug(arg)
#define TraceDebugAdvanced(arg)
#endif /* USE_TRACE_DEBUG > 0 */

#endif /* DBG > 0 */


#define RTPDBG_MODULENAME      _T("dxmrtp_rtp")

HRESULT RtpDebugInit(TCHAR *psModuleName);

HRESULT RtpDebugDeinit(void);

/*
 * WARNING
 *
 * Modifying CLASSES needs to keep matched the enum CLASS_*
 * (rtpdbg.h), the variables in RtpDbgReg_t (rtpdbg.h), the class
 * items in g_psRtpDbgInfo (rtpdbg.c) and its respective entries
 * g_dwRtpDbgRegCtrl (rtpdbg.c), as well as the printed class name
 * g_psRtpDbgClass (rtpdbg.c)
 * */
/* Class */
#define CLASS_FIRST            0
#define CLASS_ERROR            1
#define CLASS_WARNING          2
#define CLASS_INFO             3
#define CLASS_INFO2            4
#define CLASS_INFO3            5
#define CLASS_LAST             6

/*
 * WARNING
 *
 * For each group, there MUST be a variable in RtpDbgReg_t, and a name
 * (in rtpdbg.c/g_psRtpDbgInfo) to read its value from the registry
 * */
#define GROUP_FIRST            0
#define GROUP_SETUP            1
#define GROUP_CRITSECT         2
#define GROUP_HEAP             3
#define GROUP_QUEUE            4
#define GROUP_RTP              5
#define GROUP_RTCP             6
#define GROUP_CHANNEL          7
#define GROUP_NETWORK          8
#define GROUP_ADDRDESC         9
#define GROUP_DEMUX            10
#define GROUP_USER             11
#define GROUP_DSHOW            12
#define GROUP_QOS              13
#define GROUP_CRYPTO           14
#define GROUP_LAST             15

/* Selections for each group */

#define S_SETUP_SESS           0x00000001
#define S_SETUP_ADDR           0x00000002
#define S_SETUP_GLOB           0x00000004

#define S_CRITSECT_INIT        0x00000001
#define S_CRITSECT_ENTER       0x00000002

#define S_HEAP_INIT            0x00000001
#define S_HEAP_ALLOC           0x00000002
#define S_HEAP_FREE            0x00000004

#define S_QUEUE_ENQUEUE        0x00000001
#define S_QUEUE_DEQUEUE        0x00000002
#define S_QUEUE_MOVE           0x00000004

#define S_RTP_INIT             0x00000001
#define S_RTP_TRACE            0x00000002
#define S_RTP_REG              0x00000004
#define S_RTP_START            0x00000008
#define S_RTP_RECV             0x00000010
#define S_RTP_SEND             0x00000020
#define S_RTP_EVENT            0x00000040
#define S_RTP_PLAYOUT          0x00000100
#define S_RTP_DTMF             0x00000200
#define S_RTP_THREAD           0x00000400
#define S_RTP_REDINIT          0x00000800
#define S_RTP_REDRECV          0x00001000
#define S_RTP_REDSEND          0x00002000
#define S_RTP_REDRECVPKT       0x00004000
#define S_RTP_REDSENDPKT       0x00008000
#define S_RTP_REDSENDPERPKT1   0x00010000
#define S_RTP_REDSENDPERPKT2   0x00020000
#define S_RTP_SETBANDWIDTH     0x00040000
#define S_RTP_PERPKTSTAT1      0x00100000
#define S_RTP_PERPKTSTAT2      0x00200000
#define S_RTP_PERPKTSTAT3      0x00400000
#define S_RTP_PERPKTSTAT4      0x00800000
#define S_RTP_PERPKTSTAT5      0x01000000
#define S_RTP_PERPKTSTAT6      0x02000000
#define S_RTP_PERPKTSTAT7      0x04000000
#define S_RTP_PERPKTSTAT8      0x08000000
#define S_RTP_PERPKTSTAT9      0x10000000

#define S_RTCP_INIT            0x00000001
#define S_RTCP_CHANNEL         0x00000002
#define S_RTCP_CMD             0x00000004
#define S_RTCP_OBJECT          0x00000008
#define S_RTCP_SI              0x00000010
#define S_RTCP_RB              0x00000020
#define S_RTCP_RECV            0x00000040
#define S_RTCP_SEND            0x00000080
#define S_RTCP_SDES            0x00000100
#define S_RTCP_BYE             0x00000200
#define S_RTCP_THREAD          0x00000400
#define S_RTCP_TIMEOUT         0x00000800
#define S_RTCP_ALLOC           0x00001000
#define S_RTCP_RAND            0x00002000
#define S_RTCP_RTT             0x00004000
#define S_RTCP_NTP             0x00008000
#define S_RTCP_LOSSES          0x00010000
#define S_RTCP_BANDESTIMATION  0x00020000
#define S_RTCP_NETQUALITY      0x00040000
#define S_RTCP_RRSR            0x00080000
#define S_RTCP_TIMING          0x00100000
#define S_RTCP_CALLBACK        0x00200000

#define S_CHANNEL_INIT         0x00000001
#define S_CHANNEL_CMD          0x00000002

#define S_NETWORK_ADDR         0x00000001
#define S_NETWORK_SOCK         0x00000002
#define S_NETWORK_HOST         0x00000004
#define S_NETWORK_TTL          0x00000008
#define S_NETWORK_MULTICAST    0x00000010

#define S_ADDRDESC_ALLOC       0x00000001

#define S_DEMUX_ALLOC          0x00000001
#define S_DEMUX_OUTS           0x00000002
#define S_DEMUX_MAP            0x00000004

#define S_USER_INIT            0x00000001
#define S_USER_EVENT           0x00000002
#define S_USER_LOOKUP          0x00000004
#define S_USER_STATE           0x00000008
#define S_USER_INFO            0x00000010
#define S_USER_ENUM            0x00000020

#define S_DSHOW_INIT           0x00000001
#define S_DSHOW_SOURCE         0x00000002
#define S_DSHOW_RENDER         0x00000004
#define S_DSHOW_CIRTP          0x00000008
#define S_DSHOW_REFCOUNT       0x00000010
#define S_DSHOW_EVENT          0x00000020

#define S_QOS_DUMPOBJ          0x00000001
#define S_QOS_FLOWSPEC         0x00000002
#define S_QOS_NOTIFY           0x00000004
#define S_QOS_EVENT            0x00000008
#define S_QOS_PROVIDER         0x00000010
#define S_QOS_RESERVE          0x00000020
#define S_QOS_LIST             0x00000040

#define S_CRYPTO_INIT          0x00000001
#define S_CRYPTO_ALLOC         0x00000002
#define S_CRYPTO_ENCRYPT       0x00000004
#define S_CRYPTO_DECRYPT       0x00000008
#define S_CRYPTO_RAND          0x00000010

/* Options in RtpDbgReg_t.dwOptions */

/* Print time as hh:mm:ss.ms instead of the default ddddd.ddd */
#define OPTDBG_SPLITTIME         0x00000001

/* Reverse selection (instead of enabling, disable those selected) */
#define OPTDBG_UNSELECT          0x00000002

/* Make heap free the memory to the real heap (call HeapFree) */
#define OPTDBG_FREEMEMORY        0x40000000

/* Generate a DebugBreak() when printing a classs ERROR message */
#define OPTDBG_BREAKONERROR      0x80000000

#define IsSetDebugOption(op)     (g_RtpDbgReg.dwAdvancedOptions & (op))

typedef struct _RtpDbgReg_t
{
    DWORD            dwAdvancedOptions;
    DWORD            dwEnableFileTracing;
    DWORD            dwEnableConsoleTracing;
    DWORD            dwEnableDebuggerTracing;
    DWORD            dwConsoleTracingMask;
    DWORD            dwFileTracingMask;
    DWORD            dwUseAdvancedTracing;
    
    DWORD            dwERROR;
    DWORD            dwWARNING;
    DWORD            dwINFO;
    DWORD            dwINFO2;
    DWORD            dwINFO3;
    DWORD            dwDisableClass;
    DWORD            dwDisableGroup;

    /*
     * WARNING
     *
     * The GroupArray isindexed by the group, so the order for the
     * individual variables (e.g. dwSetup, dwCritSect, etc) MUST match
     * the oder in the GROUP_* definitions
     * */
    union
    {
        DWORD            dwGroupArray[GROUP_LAST];
        
        struct {
            DWORD            dwDummy;
            DWORD            dwSetup;
            DWORD            dwCritSect;
            DWORD            dwHeap;
            DWORD            dwQueue;
            DWORD            dwRTP;
            DWORD            dwRTCP;
            DWORD            dwChannel;
            DWORD            dwNetwork;
            DWORD            dwAddrDesc;
            DWORD            dwDemux;
            DWORD            dwUser;
            DWORD            dwDShow;
            DWORD            dwQOS;
            DWORD            dwCrypto;
        };
    };

    /* Not read from the registry */
    DWORD            dwGroupArray2[GROUP_LAST];
} RtpDbgReg_t;

extern RtpDbgReg_t      g_RtpDbgReg;

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif /* _rtpdbg_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtpdejit.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpdejit.h
 *
 *  Abstract:
 *
 *    Compute delay, jitter and playout delay
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/12/03 created
 *
 **********************************************************************/

#ifndef _rtpdejit_h_
#define _rtpdejit_h_

#include "struct.h"

void RtpInitNetRState(RtpUser_t *pRtpUser, RtpHdr_t *pRtpHdr, double Ai);

void RtpOnFirstPacket(RtpUser_t *pRtpUser, RtpHdr_t *pRtpHdr, double Ai);

void RtpPrepareForMarker(RtpUser_t *pRtpUser, RtpHdr_t *pRtpHdr, double Ai);

void RtpPrepareForShortDelay(RtpUser_t *pRtpUser, long lCount);

DWORD RtpUpdateNetRState(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        RtpHdr_t        *pRtpHdr,
        RtpRecvIO_t     *pRtpRecvIO
    );

extern double           g_dMinPlayout;
extern double           g_dMaxPlayout;

#endif /* _rtpdejit_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtpdemux.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpdemux.h
 *
 *  Abstract:
 *
 *    Implements the Demultiplexing family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/07 created
 *
 **********************************************************************/

#ifndef _rtpdemux_h_
#define _rtpdemux_h_

#include "rtpfwrap.h"

/***********************************************************************
 *
 * Demultiplexing services family
 *
 **********************************************************************/

#if defined(__cplusplus)
extern "C" {
#endif  // (__cplusplus)
#if 0
}
#endif

/* functions */
enum {
    RTPDEMUX_FIRST,
    RTPDEMUX_LAST
};

HRESULT ControlRtpDemux(RtpControlStruct_t *pRtpControlStruct);

/**********************************************************************
 * Users <-> Outputs assignment
 **********************************************************************/

RtpOutput_t *RtpAddOutput(
        RtpSess_t       *pRtpSess,
        int              iOutMode,
        void            *pvUserInfo,
        DWORD           *pdwError
    );

DWORD RtpDelOutput(
        RtpSess_t       *pRtpSess,
        RtpOutput_t     *pRtpOutput
    );

DWORD RtpSetOutputMode(
        RtpSess_t       *pRtpSess,
        int              iPos,
        RtpOutput_t     *pRtpOutput,
        int              iOutMode
    );

DWORD RtpOutputState(
        RtpAddr_t       *pRtpAddr,
        int              iPos,
        RtpOutput_t     *pRtpOutput,
        DWORD            dwSSRC,
        BOOL             bAssigned
    );

DWORD RtpUnmapAllOuts(
        RtpSess_t       *pRtpSess
    );

DWORD RtpFindOutput(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwSSRC,
        int             *piPos,
        void           **ppvUserInfo
    );

DWORD RtpFindSSRC(
        RtpAddr_t       *pRtpAddr,
        int              iPos,
        RtpOutput_t     *pRtpOutput,
        DWORD           *pdwSSRC
    );

        
RtpOutput_t *RtpOutputAlloc(void);

RtpOutput_t *RtpOutputFree(RtpOutput_t *pRtpOutput);

RtpOutput_t *RtpGetOutput(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser
    );

DWORD RtpSetOutputMode_(
        RtpOutput_t     *pRtpOutput,
        int              iOutMode
    );

DWORD RtpOutputAssign(
        RtpSess_t       *pRtpSess,
        RtpUser_t       *pRtpUser,
        RtpOutput_t     *pRtpOutput
    );

DWORD RtpOutputUnassign(
        RtpSess_t       *pRtpSess,
        RtpUser_t       *pRtpUser,
        RtpOutput_t     *pRtpOutput
    );

DWORD RtpAddPt2FrequencyMap(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwPt,
        DWORD            dwFrequency,
        DWORD            dwRecvSend
    );

BOOL RtpLookupPT(
        RtpAddr_t       *pRtpAddr,
        BYTE             bPT
    );

DWORD RtpMapPt2Frequency(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        DWORD            dwPt,
        DWORD            dwRecvSend
    );

DWORD RtpFlushPt2FrequencyMaps(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwRecvSend
    );

DWORD RtpOutputEnable(
        RtpOutput_t     *pRtpOutput,
        BOOL             bEnable
    );

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif /* _rtpdemux_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtpdtmf.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpdtmf.h
 *
 *  Abstract:
 *
 *    Implements functionality to partially support rfc2833
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    2000/08/17 created
 *
 **********************************************************************/
#ifndef _rtpdtmf_h_
#define _rtpdtmf_h_

#if defined(__cplusplus)
extern "C" {
#endif  /* (__cplusplus) */
#if 0
}
#endif

/* Flags passed in RtpSendDtmfEvent() as dwDtmfFlags parameter */
enum {
    FGDTMF_FIRST,
    
    FGDTMF_END,    /* Set end flag to 1 */
    FGDTMF_MARKER, /* Force RTP marker bit to 1 on first packet of
                    * event */

    FGDTMF_LAST
};

/* Configures DTMF parameters */
DWORD RtpSetDtmfParameters(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwPT_Dtmf
    );

/* Directs an RTP render filter to send a packet formatted according
 * to rfc2833 containing the specified event, specified volume level,
 * duration in timestamp units, and some flags (including END flag) */
DWORD RtpSendDtmfEvent(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwTimeStamp,
        DWORD            dwEvent,
        DWORD            dwVolume,
        DWORD            dwDuration, /* timestamp units */
        DWORD            dwDtmfFlags
    );

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  /* (__cplusplus) */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtperr.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtperr.h
 *
 *  Abstract:
 *
 *    Error codes
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/01 created
 *
 **********************************************************************/

#ifndef _rtperr_h_
#define _rtperr_h_

#if defined(__cplusplus)
extern "C" {
#endif  /* (__cplusplus) */
#if 0
}
#endif

#include <apierror.h>

extern const TCHAR      *g_psRtpErr[];

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  /* (__cplusplus) */

#define RTPERR_SEVERITY 0x3

/* FACILITY_RTPRTCPCONTROL in skywalker\inc\apierror.h */
#define RTPERR_FACILITY FACILITY_RTPRTCPCONTROL

#define MAKERTPERR(_e) \
        ((RTPERR_SEVERITY << 30) | (RTPERR_FACILITY << 16) | (_e))

#define RTPERR_TEXT(_e) (g_psRtpErr[(_e) & 0xffff])

/*
 * WARNING
 *
 * The *_ENUM_* values in rtperr.h and the array g_psRtpErr in
 * rtperr.c MUST have their entries matched
 * */
#define RTPERR_ENUM_NOERROR            0x00  /*  0 */
#define RTPERR_ENUM_FAIL               0x01  /*  1 */
#define RTPERR_ENUM_MEMORY             0x02  /*  2 */
#define RTPERR_ENUM_POINTER            0x03  /*  3 */
#define RTPERR_ENUM_INVALIDRTPSESS     0x04  /*  4 */
#define RTPERR_ENUM_INVALIDRTPADDR     0x05  /*  5 */
#define RTPERR_ENUM_INVALIDRTPUSER     0x06  /*  6 */
#define RTPERR_ENUM_INVALIDRTPCONTEXT  0x07  /*  7 */
#define RTPERR_ENUM_INVALIDRTCPCONTEXT 0x08  /*  8 */
#define RTPERR_ENUM_INVALIDOBJ         0x09  /*  9 */
#define RTPERR_ENUM_INVALIDSTATE       0x0A  /* 10 */
#define RTPERR_ENUM_NOTINIT            0x0B  /* 11 */
#define RTPERR_ENUM_INVALIDARG         0x0C  /* 12 */
#define RTPERR_ENUM_INVALIDHDR         0x0D  /* 13 */
#define RTPERR_ENUM_INVALIDPT          0x0E  /* 14 */
#define RTPERR_ENUM_INVALIDVERSION     0x0F  /* 15 */
#define RTPERR_ENUM_INVALIDPAD         0x10  /* 16 */
#define RTPERR_ENUM_INVALIDRED         0x11  /* 17 */
#define RTPERR_ENUM_INVALIDSDES        0x12  /* 18 */
#define RTPERR_ENUM_INVALIDBYE         0x13  /* 19 */
#define RTPERR_ENUM_INVALIDUSRSTATE    0x14  /* 20 */
#define RTPERR_ENUM_INVALIDREQUEST     0x15  /* 21 */
#define RTPERR_ENUM_SIZE               0x16  /* 22 */
#define RTPERR_ENUM_MSGSIZE            0x17  /* 23 */
#define RTPERR_ENUM_OVERRUN            0x18  /* 24 */
#define RTPERR_ENUM_UNDERRUN           0x19  /* 25 */
#define RTPERR_ENUM_PACKETDROPPED      0x1A  /* 26 */
#define RTPERR_ENUM_CRYPTO             0x1B  /* 27 */
#define RTPERR_ENUM_ENCRYPT            0x1C  /* 28 */
#define RTPERR_ENUM_DECRYPT            0x1D  /* 29 */
#define RTPERR_ENUM_CRITSECT           0x1E  /* 30 */
#define RTPERR_ENUM_EVENT              0x1F  /* 31 */
#define RTPERR_ENUM_WS2RECV            0x20  /* 32 */
#define RTPERR_ENUM_WS2SEND            0x21  /* 33 */
#define RTPERR_ENUM_NOTFOUND           0x22  /* 34 */
#define RTPERR_ENUM_UNEXPECTED         0x23  /* 35 */
#define RTPERR_ENUM_REFCOUNT           0x24  /* 36 */
#define RTPERR_ENUM_THREAD             0x25  /* 37 */
#define RTPERR_ENUM_HEAP               0x26  /* 38 */
#define RTPERR_ENUM_WAITTIMEOUT        0x27  /* 39 */
#define RTPERR_ENUM_CHANNEL            0x28  /* 40 */
#define RTPERR_ENUM_CHANNELCMD         0x29  /* 41 */
#define RTPERR_ENUM_RESOURCES          0x2A  /* 42 */
#define RTPERR_ENUM_QOS                0x2B  /* 43 */
#define RTPERR_ENUM_NOQOS              0x2C  /* 44 */
#define RTPERR_ENUM_QOSSE              0x2D  /* 45 */
#define RTPERR_ENUM_QUEUE              0x2E  /* 46 */
#define RTPERR_ENUM_NOTIMPL            0x2F  /* 47 */
#define RTPERR_ENUM_INVALIDFAMILY      0x30  /* 48 */
#define RTPERR_ENUM_LAST               0x31  /* 49 */


#define RTPERR_NOERROR                 MAKERTPERR(RTPERR_ENUM_NOERROR)
#define RTPERR_FAIL                    MAKERTPERR(RTPERR_ENUM_FAIL)
#define RTPERR_MEMORY                  MAKERTPERR(RTPERR_ENUM_MEMORY)
#define RTPERR_POINTER                 MAKERTPERR(RTPERR_ENUM_POINTER)
#define RTPERR_INVALIDRTPSESS          MAKERTPERR(RTPERR_ENUM_INVALIDRTPSESS)
#define RTPERR_INVALIDRTPADDR          MAKERTPERR(RTPERR_ENUM_INVALIDRTPADDR)
#define RTPERR_INVALIDRTPUSER          MAKERTPERR(RTPERR_ENUM_INVALIDRTPUSER)
#define RTPERR_INVALIDRTPCONTEXT       MAKERTPERR(RTPERR_ENUM_INVALIDRTPCONTEXT)
#define RTPERR_INVALIDRTCPCONTEXT      MAKERTPERR(RTPERR_ENUM_INVALIDRTCPCONTEXT)
#define RTPERR_INVALIDOBJ              MAKERTPERR(RTPERR_ENUM_INVALIDOBJ)
#define RTPERR_INVALIDSTATE            MAKERTPERR(RTPERR_ENUM_INVALIDSTATE)
#define RTPERR_NOTINIT                 MAKERTPERR(RTPERR_ENUM_NOTINIT)
#define RTPERR_INVALIDARG              MAKERTPERR(RTPERR_ENUM_INVALIDARG)
#define RTPERR_INVALIDHDR              MAKERTPERR(RTPERR_ENUM_INVALIDHDR)
#define RTPERR_INVALIDPT               MAKERTPERR(RTPERR_ENUM_INVALIDPT)
#define RTPERR_INVALIDVERSION          MAKERTPERR(RTPERR_ENUM_INVALIDVERSION)
#define RTPERR_INVALIDPAD              MAKERTPERR(RTPERR_ENUM_INVALIDPAD)
#define RTPERR_INVALIDRED              MAKERTPERR(RTPERR_ENUM_INVALIDRED)
#define RTPERR_INVALIDSDES             MAKERTPERR(RTPERR_ENUM_INVALIDSDES)
#define RTPERR_INVALIDBYE              MAKERTPERR(RTPERR_ENUM_INVALIDBYE)
#define RTPERR_INVALIDUSRSTATE         MAKERTPERR(RTPERR_ENUM_INVALIDUSRSTATE)
#define RTPERR_INVALIDREQUEST          MAKERTPERR(RTPERR_ENUM_INVALIDREQUEST)
#define RTPERR_SIZE                    MAKERTPERR(RTPERR_ENUM_SIZE)
#define RTPERR_MSGSIZE                 MAKERTPERR(RTPERR_ENUM_MSGSIZE)
#define RTPERR_OVERRUN                 MAKERTPERR(RTPERR_ENUM_OVERRUN)
#define RTPERR_UNDERRUN                MAKERTPERR(RTPERR_ENUM_UNDERRUN)
#define RTPERR_PACKETDROPPED           MAKERTPERR(RTPERR_ENUM_PACKETDROPPED)
#define RTPERR_CRYPTO                  MAKERTPERR(RTPERR_ENUM_CRYPTO)
#define RTPERR_ENCRYPT                 MAKERTPERR(RTPERR_ENUM_ENCRYPT)
#define RTPERR_DECRYPT                 MAKERTPERR(RTPERR_ENUM_DECRYPT)
#define RTPERR_CRITSECT                MAKERTPERR(RTPERR_ENUM_CRITSECT)
#define RTPERR_EVENT                   MAKERTPERR(RTPERR_ENUM_EVENT)
#define RTPERR_WS2RECV                 MAKERTPERR(RTPERR_ENUM_WS2RECV)
#define RTPERR_WS2SEND                 MAKERTPERR(RTPERR_ENUM_WS2SEND)
#define RTPERR_NOTFOUND                MAKERTPERR(RTPERR_ENUM_NOTFOUND)
#define RTPERR_UNEXPECTED              MAKERTPERR(RTPERR_ENUM_UNEXPECTED)
#define RTPERR_REFCOUNT                MAKERTPERR(RTPERR_ENUM_REFCOUNT)
#define RTPERR_THREAD                  MAKERTPERR(RTPERR_ENUM_THREAD)
#define RTPERR_HEAP                    MAKERTPERR(RTPERR_ENUM_HEAP)
#define RTPERR_WAITTIMEOUT             MAKERTPERR(RTPERR_ENUM_WAITTIMEOUT)
#define RTPERR_CHANNEL                 MAKERTPERR(RTPERR_ENUM_CHANNEL)
#define RTPERR_CHANNELCMD              MAKERTPERR(RTPERR_ENUM_CHANNELCMD)
#define RTPERR_RESOURCES               MAKERTPERR(RTPERR_ENUM_RESOURCES)
#define RTPERR_QOS                     MAKERTPERR(RTPERR_ENUM_QOS)
#define RTPERR_NOQOS                   MAKERTPERR(RTPERR_ENUM_NOQOS)
#define RTPERR_QOSSE                   MAKERTPERR(RTPERR_ENUM_QOSSE)
#define RTPERR_QUEUE                   MAKERTPERR(RTPERR_ENUM_QUEUE)
#define RTPERR_NOTIMPL                 MAKERTPERR(RTPERR_ENUM_NOTIMPL)
#define RTPERR_INVALIDFAMILY           MAKERTPERR(RTPERR_ENUM_INVALIDFAMILY)


/* Below this point these codes may become obsolete */

#define RTPERR_INVALIDCONTROL   E_FAIL
#define RTPERR_INVALIDFUNCTION  E_FAIL
#define RTPERR_INVALIDFLAGS     E_FAIL
#define RTPERR_INVALIDDIRECTION E_FAIL

#define RTPERR_ZEROPAR1         E_FAIL
#define RTPERR_RDPTRPAR1        E_FAIL
#define RTPERR_WRPTRPAR1        E_FAIL
#define RTPERR_ZEROPAR2         E_FAIL
#define RTPERR_RDPTRPAR2        E_FAIL
#define RTPERR_WRPTRPAR2        E_FAIL

#endif /* _rtperr_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtpevent.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpevent.h
 *
 *  Abstract:
 *
 *    Post RTP/RTCP specific events
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/11/29 created
 *
 **********************************************************************/
#ifndef _rtpevent_h_
#define _rtpevent_h_

#include "struct.h"

BOOL RtpPostEvent(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        DWORD            dwEventKind,
        DWORD            dwEvent,
        DWORD_PTR        dwPar1,
        DWORD_PTR        dwPar2
    );

extern const TCHAR_t *g_psRtpRtpEvents[];
extern const TCHAR_t *g_psRtpPInfoEvents[];
extern const TCHAR_t *g_psRtpQosEvents[];
extern const TCHAR_t *g_psRtpSdesEvents[];

#endif /* _rtpevent_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtpglob.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpglob.h
 *
 *  Abstract:
 *
 *    Implements the Global services family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/01 created
 *
 **********************************************************************/

#ifndef _rtpglob_h_
#define _rtpglob_h_

#include "rtpfwrap.h"

/***********************************************************************
 *
 * Global services family
 *
 **********************************************************************/

enum {
    RTPGLOB_FIRST,
    RTPGLOB_FLAGS_MASK,
    RTPGLOB_TEST_FLAGS_MASK,
    RTPGLOB_CLASS_PRIORITY,
    RTPGLOB_VERSION,
    RTPGLOB_LAST
};

HRESULT ControlRtpGlob(RtpControlStruct_t *pRtpControlStruct);

#endif /* _rtpglob_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtpglobs.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpglobs.h
 *
 *  Abstract:
 *
 *     Global heaps, etc.
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/25 created
 *
 **********************************************************************/

#ifndef _rtpglobs_h_
#define _rtpglobs_h_

#if defined(__cplusplus)
extern "C" {
#endif  // (__cplusplus)
#if 0
}
#endif

#include "gtypes.h"
#include "struct.h"
#include "rtpheap.h"

#define MIN_ASYNC_RECVBUF 4

/* Global heaps */

/* Heap used to allocate objects for a source */
extern RtpHeap_t *g_pRtpSourceHeap;

/* Heap used to allocate media sample objects for a source */
extern RtpHeap_t *g_pRtpSampleHeap;

/* Heap used to allocate objects for a render */
extern RtpHeap_t *g_pRtpRenderHeap;

/* Heap used to obtain RtpSess_t structures */
extern RtpHeap_t *g_pRtpSessHeap;

/* Heap used to obtain RtpAddr_t structures */
extern RtpHeap_t *g_pRtpAddrHeap;

/* Heap used to obtain RtpUser_t structures */
extern RtpHeap_t *g_pRtpUserHeap;

/* Heap used to obtain RtpSdes_t structures */
extern RtpHeap_t *g_pRtpSdesHeap;

/* Heap used to obtain RtpNetCount_t structures */
extern RtpHeap_t *g_pRtpNetCountHeap;

/* Heap used to obtain RtpRecvIO_t structures */
extern RtpHeap_t *g_pRtpRecvIOHeap;

/* Heap used to obtain RtpChannelCmd_t structures */
extern RtpHeap_t *g_pRtpChannelCmdHeap;

/* Heap used to obtain RtcpAddrDesc_t structures */
extern RtpHeap_t *g_pRtcpAddrDescHeap;

/* Heap used to obtain RtcpRecvIO_t structures */
extern RtpHeap_t *g_pRtcpRecvIOHeap;

/* Heap used to obtain RtcpSendIO_t structures */
extern RtpHeap_t *g_pRtcpSendIOHeap;

/* Heap used to obtain RtpQosReserve_t structures */
extern RtpHeap_t *g_pRtpQosReserveHeap;

/* Heap used to obtain RtpQosNotify_t structures */
extern RtpHeap_t *g_pRtpQosNotifyHeap;

/* Heap used to obtain buffers used by QOS/RSVPSP */
extern RtpHeap_t *g_pRtpQosBufferHeap;

/* Heap used to obtain RtpCrypt_t structures */
extern RtpHeap_t *g_pRtpCryptHeap;

/* Heap used to obtain variable size structures structures */
extern RtpHeap_t *g_pRtpGlobalHeap;

/* Contains some general information */
extern RtpContext_t g_RtpContext;

HRESULT RtpInit(void);

HRESULT RtpDelete(void);

/*
 * Creates all the global heaps */
BOOL RtpCreateGlobHeaps(void);

/*
 * Destroys all the global heaps */
BOOL RtpDestroyGlobHeaps(void);

/* Init reference time */
void RtpInitReferenceTime(void);

/* RTP's reference time */
LONGLONG RtpGetTime(void);

/* RTP's time in seconds since midnight (00:00:00), January 1, 1970,
 * coordinated universal time (UTC) contained in structure RtpTime_t,
 * returns same time also as a double
 * */
double RtpGetTimeOfDay(RtpTime_t *pRtpTime);

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif /* _rtpglobs_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtpheap.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpheap.h
 *
 *  Abstract:
 *
 *    Implements the private heaps handling
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/24 created
 *
 **********************************************************************/

#ifndef _rtpheap_h_
#define _rtpheap_h_

#include "gtypes.h"
#include "rtpque.h"
#include "rtpcrit.h"

//#include <winbase.h>

/*
  Every block obtained from a private heap, will have the following
  layout:

  +-----------------+
  RtpHeapBlockBegin_t
  RtpQueueItem_t
  Data
  RtpHeapBlockEnd_t
  +-----------------+

  Data is variable size and DWORD aligned, the caller receives a
  pointer to the Data block and it frees the block by passing the same
  pointer.

*/

/*
 * Every item obtained from a private heap, will have this structure
 * at the begining */
typedef struct _RtpHeapBlockBegin_t {
    DWORD      InvBeginSig;
    DWORD      BeginSig;
    long       lSize;
    DWORD      dwFlag;
} RtpHeapBlockBegin_t;

/*
 * Every item obtained from a private heap, will have this structure
 * at the end */
typedef struct _RtpHeapBlockEnd_t {
    DWORD      EndSig;
    DWORD      InvEndSig;
} RtpHeapBlockEnd_t;

/*
 * Holds a private heap, this structure hides the */
typedef struct _RtpHeap_t {
    DWORD          dwObjectID;/* the tag for this kind of object */
    RtpQueueItem_t QueueItem; /* keep all heaps together */
    BYTE           bTag;      /* what kind of items will be obtained */
    BYTE           dummy1;    /* not used */
    BYTE           dummy2;    /* not used */
    BYTE           dummy3;    /* not used */
    long           lSize;     /* each block requested has this size */
    HANDLE         hHeap;     /* real heap */
    RtpQueue_t     FreeQ;     /* free items */
    RtpQueue_t     BusyQ;     /* busy items */
    RtpCritSect_t  RtpHeapCritSect; /* critical section to lock access
                                       to queues */
} RtpHeap_t;

/*
 * CAUTION: RtpCreateMasterHeap and RtpDestroyMasterHeap require the caller
 * to call these functions multi-thread safe.
 */

/*
 * The master heap must be created before any private RTP heap can be
 * created */
BOOL RtpCreateMasterHeap(void);

/*
 * The master heap is deleted when none of the memory allocated from
 * any private heap is in use. It is expected that when this function
 * is called, there will not be any heap left in the busy queue. */
BOOL RtpDestroyMasterHeap(void);

/*
 * Creates a private heap from the master heap. The structure is
 * obtained from the master heap, the real heap is created, the
 * critical section initialized, and the other fileds properly
 * initialized. */
RtpHeap_t *RtpHeapCreate(BYTE bTag, long lSize);

/*
 * Destroys a private heap. The structure is returned to the master
 * heap, the real heap is destroyed and the critical section
 * deleted. It is expected that the busy queue be empty. */
BOOL RtpHeapDestroy(RtpHeap_t *pRtpHeap);

/*
 * If the size requested is the same as the heap's initially set, then
 * look first in the free list then create a new block. If the size is
 * different, just create a new block. In both cases the block will be
 * left in the busy queue. */
void *RtpHeapAlloc(RtpHeap_t *pRtpHeap, long lSize);

/*
 * If the block is the same size as the heap's initially set, put it
 * in the free queue, otherwise destroy it. */
BOOL RtpHeapFree(RtpHeap_t *pRtpHeap, void *pvMem);

#endif /* _rtpheap_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtpfwrap.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpfwrap.h
 *
 *  Abstract:
 *
 *    RTP functions wrapper. Defines the control word passed in
 *    RtpControl and the format of the test word.
 *
 *    When RtpControl is called, the following steps are followed:
 *
 *    1. validate the control word
 *
 *    2. look up another control word, the test word, that defines
 *    what are the tests to perform, validates the function and
 *    defines what flags are valid
 *
 *    3. call the proper function to do the real job
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/01 created
 *
 **********************************************************************/

#ifndef _rtpfwrap_h_
#define _rtpfwrap_h_

/*

  Control word
  ------------
  
  The control word (actually a DWORD) is one of the parameter passed
  by an application when invoking the RTP services. That dword has the
  following format:

      3                   2                   1                 
    1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    Tag      | |       |       |    unused     |     Flags     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                  v \--v--/ \--v--/
                  |    |       |
                  |    |       Function in family (14)
                  |    |
                  |    Family of functions (14)
                  |
                  Direction (SET/GET)

  Test word
  ---------               
                  
  The test word defines if:

  1. the function is enabled (set/get)

  2. each of the parameters must be tested for write pointer, read
  pointer and zero value (zero value is exclusive with read/write
  pointer tests)

  3. the lock needs to be obtained

  The control word has the following format:
  
      3                   2                   1                 
    1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | |w r z| |w r z|               | |z r z| |w r z|               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    v \-v-/ v \-v-/ \------v------/ v \-v-/ v \-v-/ \------v------/
    |   |   |   |          |        |   |   |   |          |
    |   |   |   |          |        |   |   |   |          |
    |   |   |   |          Flags    |   |   |   |          Flags
    |   |   |   |                   |   |   |   |
    |   |   |   Par 1               |   |   |   Par 1
    |   |   |                       |   |   |
    |   |   Lock                    |   |  Lock
    |   |                           |   |
    |   Par 2                       |   Par 2
    |                               |
    Enable set                      Enable get
   \--------------SET--------------/\-------------GET-------------/

   Each of the 3 bits in the parameters (set/get par1 and par2) are:

    2 1 0 
   +-+-+-+
   | Par |
   +-+-+-+
    v v v
    | | |
    | | Test for ZERO value
    | | 
    | Test for Read pointer (test performed over 1 DWORD)
    |
    Test for Write pointer (test performed over 1 DWORD)

    There exist an array of this words for each family, the function
    in family is then used as an index.
    
    TODO: (may be) another constant array could be defined with the
    memory size to test. This of course can be used only when that
    size if fixed (i.e. specific functions expect specific size
    structures), when a variable length user buffer is passed, that
    must be tested by the specific function in family, the number of
    these cases is expected to be small, otherwise the benefit of
    having a single place were the tests are performed is lost

*/

/* Forward declaration */
typedef struct _RtpControlStruct_t RtpControlStruct_t;

/*
 * Prototype for the functions implementing all the features */
typedef HRESULT (* RtpFamily_f)(RtpControlStruct_t *pRtpControlStruct);

/*
 * This structure is used to save the split control word */
typedef struct _RtpControlStruct_t {
    DWORD       dwFamily;        /* family of functions */
    DWORD       dwFunction;      /* function in family */
    DWORD       dwDirection;     /* direction, get/set */
    DWORD       dwControlWord;   /* control word */
    RtpSess_t  *pRtpSess;        /* RTP session */
    DWORD_PTR   dwPar1;          /* user parameter 1 passed */
    DWORD_PTR   dwPar2;          /* user parameter 2 passed */
    RtpFamily_f RtpFamilyFunc;   /* function used */
} RtpControlStruct_t;

/*
 * Validates the control word, parameters, and if all the tests
 * succeed, call the proper function that does the work */
HRESULT RtpValidateAndExecute(RtpControlStruct_t *pRtpControlStruct);

/* Act upon the direction specific control WORD (16 bits) */
#define RTPCTRL_ENABLED(ControlW)   (ControlW & 0x8000)
#define RTPCTRL_LOCK(ControlW)      (ControlW & 0x0800)
#define RTPCTRL_TEST(ControlW, bit) (ControlW & (1<<bit))

#define PAR1_ZERO  8
#define PAR1_RDPTR 9
#define PAR1_WRPTR 10

#define PAR2_ZERO  12
#define PAR2_RDPTR 13
#define PAR2_WRPTR 14


/***********************************************************************
 *
 * RTP basic enumerated types
 *
 **********************************************************************/

/* All the family functions */
enum {
    RTPF_FIRST,
    RTPF_ADDR,     /* Address */
    RTPF_GLOB,     /* Global */
    RTPF_RTP,      /* RTP specific */

    RTPF_DEMUX,    /* Demultiplexing */
    RTPF_PH,       /* Payload handling */
    RTPF_PARINFO,  /* Participants */
    RTPF_QOS,      /* QOS */

    RTPF_CRYPT,    /* Cryptogtaphy */
    RTPF_STATS,    /* Statistics */
    RTPF_LAST
};

/*
 * details on the functions for each family are in separate include
 * files */

#endif /* _rtpfwrap_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtpmask.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpmask.h
 *
 *  Abstract:
 *
 *    Used to modify or test the different masks in a RtpSess_t
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/11/29 created
 *
 **********************************************************************/

#ifndef _rtpmask_h_
#define _rtpmask_h_

#include "struct.h"

#if defined(__cplusplus)
extern "C" {
#endif  // (__cplusplus)
#if 0
}
#endif

HRESULT RtpModifyMask(
        RtpSess_t       *pRtpSess,
        DWORD            dwKind,
        DWORD            dwMask,
        DWORD            dwValue,
        DWORD           *dwModifiedMask
    );

extern const DWORD g_dwRtpSessionMask[];

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif /* _rtpmask_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtpqos.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpqos.h
 *
 *  Abstract:
 *
 *    Implements the Quality of Service family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/07 created
 *
 **********************************************************************/

#ifndef _rtpqos_h_
#define _rtpqos_h_

#include "rtpfwrap.h"
#include "rtcpthrd.h"

/***********************************************************************
 *
 * Quality of Service family
 *
 **********************************************************************/
#if defined(__cplusplus)
extern "C" {
#endif  // (__cplusplus)
#if 0
}
#endif


/* flags */
#define RTPQOS_FG_RECV 1 /* TODO */
#define RTPQOS_FG_SEND 1 /* TODO */

#if USE_GRAPHEDT > 0
#define RTPQOS_MASK_RECV_DEFAULT ( (1 << RTPQOS_SENDERS) | \
                                   (1 << RTPQOS_NO_SENDERS) | \
                                   (1 << RTPQOS_REQUEST_CONFIRMED) )

#define RTPQOS_MASK_SEND_DEFAULT ( (1 << RTPQOS_RECEIVERS) | \
                                   (1 << RTPQOS_NO_RECEIVERS) | \
                                   (1 << RTPQOS_NOT_ALLOWEDTOSEND) | \
                                   (1 << RTPQOS_ALLOWEDTOSEND) )
#else
#define RTPQOS_MASK_RECV_DEFAULT 0
#define RTPQOS_MASK_SEND_DEFAULT 0
#endif

/* Global flags for the QOS family of functions */
typedef enum {
    RTPQOS_FLAG_FIRST = 0,
    
	/* Is the RTP session QOS enabled */
    RTPQOS_FLAG_QOS_STATE = 0,

	/* Ask for permission to send */
    RTPQOS_FLAG_ASK_PERMISSION,

	/* Send only if permission is granted */
    RTPQOS_FLAG_SEND_IF_ALLOWED,

	/* Send only if there are receivers */
    RTPQOS_FLAG_SEND_IF_RECEIVERS,

	/* There are receivers (state) */
    RTPQOS_FLAG_RECEIVERS,

	/* Has been allowed to send (state) */
    RTPQOS_FLAG_ALLOWED_TO_SEND,
    
    RTPQOS_FLAG_LAST
};

/* Minimum size passed in the provider specific buffer when requesting
 * notifications */
#define QOS_BUFFER_SIZE     512

#define QOS_MAX_BUFFER_SIZE 32000

#define MAX_QOS_CLASS       8     /* Class AUDIO, VIDEO, UNKNOWN */

HRESULT ControlRtpQos(RtpControlStruct_t *pRtpControlStruct);

DWORD RtpSetQosFlowSpec(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwRecvSend
    );

HRESULT RtpSetQosByNameOrPT(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwRecvSend,
        TCHAR_t         *psQosName,
        DWORD            dwPT,
        DWORD            dwResvStyle,
        DWORD            dwMaxParticipants,
        DWORD            dwQosSendMode,
        DWORD            dwMinFrameSize,
        BOOL             bInternal
    );

HRESULT RtpSetQosParameters(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwRecvSend,
        RtpQosSpec_t    *pRtpQosSpec,
        DWORD            dwMaxParticipants,
        DWORD            dwQosSendMode
    );

HRESULT RtpSetQosAppId(
        RtpAddr_t       *pRtpAddr, 
        TCHAR_t         *psAppName,
        TCHAR_t         *psAppGUID,
        TCHAR_t         *psPolicyLocator
    );

HRESULT RtpSetQosState(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwSSRC,
        BOOL             bEnable
    );

HRESULT RtpModifyQosList(
        RtpAddr_t       *pRtpAddr,
        DWORD           *pdwSSRC,
        DWORD           *pdwNumber,
        DWORD            dwOperation
    );

HRESULT RtpReserve(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwRecvSend
    );

HRESULT RtpUnreserve(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwRecvSend
    );

RtpQosReserve_t *RtpQosReserveAlloc(
        RtpAddr_t       *pRtpAddr
    );

RtpQosReserve_t *RtpQosReserveFree(
        RtpQosReserve_t *pRtpQosReserve
    );

HRESULT RtpGetQosEnabledProtocol(
        WSAPROTOCOL_INFO *pProtoInfo
    );

BOOL ReallocateQosBuffer(
        RtpQosNotify_t  *pRtpQosNotify
    );

RtpQosNotify_t *RtpQosNotifyAlloc(
        RtcpAddrDesc_t  *pRtcpAddrDesc
    );

RtpQosNotify_t *RtpQosNotifyFree(
        RtpQosNotify_t  *pRtpQosNotify
    );

HRESULT StartRtcpQosNotify(
        RtcpContext_t   *pRtcpContext,
        RtcpAddrDesc_t  *pRtcpAddrDesc
    );

HRESULT ConsumeRtcpQosNotify(
        RtcpContext_t   *pRtcpContext,
        RtcpAddrDesc_t  *pRtcpAddrDesc
    );

BOOL RtcpUpdateSendState(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwEvent
    );

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif /* _rtpqos_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtppt.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtppt.h
 *
 *  Abstract:
 *
 *    Specify the payload types for the AV profile
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/28 created
 *
 **********************************************************************/

#ifndef _rtppt_h_
#define _rtppt_h_

/*
  Quoted from:
  
  Internet Engineering Task Force                                   AVT WG
  Internet Draft                                               Schulzrinne
  ietf-avt-profile-new-05.txt                                  Columbia U.
  February 26, 1999
  Expires: August 26, 1999
  

        PT     encoding      media type    clock rate    channels
               name                        (Hz)
        ___________________________________________________________
        0      PCMU          A             8000          1
        1      1016          A             8000          1
        2      G726-32       A             8000          1
        3      GSM           A             8000          1
        4      G723          A             8000          1
        5      DVI4          A             8000          1
        6      DVI4          A             16000         1
        7      LPC           A             8000          1
        8      PCMA          A             8000          1
        9      G722          A             16000         1
        10     L16           A             44100         2
        11     L16           A             44100         1
        12     QCELP         A             8000          1
        13     unassigned    A
        14     MPA           A             90000         (see text)
        15     G728          A             8000          1
        16     DVI4          A             11025         1
        17     DVI4          A             22050         1
        18     G729          A             8000          1
        19     CN            A             8000          1
        20     unassigned    A
        21     unassigned    A
        22     unassigned    A
        23     unassigned    A
        dyn    GSM-HR        A             8000          1
        dyn    GSM-EFR       A             8000          1
        dyn    RED           A


   Table 4: Payload types (PT) for audio encodings


           PT        encoding      media type    clock rate
                     name                        (Hz)
           ____________________________________________________
           24        unassigned    V
           25        CelB          V             90000
           26        JPEG          V             90000
           27        unassigned    V
           28        nv            V             90000
           29        unassigned    V
           30        unassigned    V
           31        H261          V             90000
           32        MPV           V             90000
           33        MP2T          AV            90000
           34        H263          V             90000
           35-71     unassigned    ?
           72-76     reserved      N/A           N/A
           77-95     unassigned    ?
           96-127    dynamic       ?
           dyn       BT656         V             90000
           dyn       H263-1998     V             90000
           dyn       MP1S          V             90000
           dyn       MP2P          V             90000
           dyn       BMPEG         V             90000
*/


#define RTPPT_PCMU       0
#define RTPPT_1016       1
#define RTPPT_G726_32    2
#define RTPPT_GSM        3
#define RTPPT_G723       4
#define RTPPT_DVI4_8000  5
#define RTPPT_DVI4_16000 6
#define RTPPT_LPC        7
#define RTPPT_PCMA       8
#define RTPPT_G722       9
#define RTPPT_L16_44100  10
#define RTPPT_L16_8000   11
#define RTPPT_QCELP      12
#define RTPPT_MPA        14
#define RTPPT_G728       15
#define RTPPT_DVI4_11025 16
#define RTPPT_DVI4_22050 17
#define RTPPT_G729       18
#define RTPPT_H261       31
#define RTPPT_H263       34


#endif /* _rtppt_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtppinfo.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtppinfo.h
 *
 *  Abstract:
 *
 *    Implements the Participant Information family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/07 created
 *
 **********************************************************************/

#ifndef _rtppinfo_h_
#define _rtppinfo_h_

#include "rtpfwrap.h"

/***********************************************************************
 *
 * Participants information family
 *
 **********************************************************************/

/* common flags */
#define RTPPARINFO_FG_LOCAL
#define RTPPARINFO_FG_REMOTE

#if defined(__cplusplus)
extern "C" {
#endif  // (__cplusplus)
#if 0
}
#endif

/* state can be... */
#define RTPPARINFO_STATE_MUTE
#define RTPPARINFO_STATE_QOS
#define RTPPARINFO_STATE_TRAFFIC

/* User events that produce transitions, i.e. may entice a state
 * change */
enum {
    USER_EVENT_FIRST,

    /* A RTP packet was received */
    USER_EVENT_RTP_PACKET,

    /* A RTCP packet was received */
    USER_EVENT_RTCP_PACKET,

    /* A RTCP BYE packet was received */
    USER_EVENT_BYE,

    /* The current timer expired */
    USER_EVENT_TIMEOUT,

    /* Participant context is about to be deleted */
    USER_EVENT_DEL,

    USER_EVENT_LAST
};

/*
 * Timers definition
 * */

/* Time to pass from TALKING to WAS_TALING */
#define RTPPARINFO_TIMER1  3

/* Time to pass from WAS_TALKING to SILENT, 2 the RTCP interval report */
#define RTPPARINFO_TIMER2  0

/* Time to pass to STALL, 5 times the RTCP interval report */
#define RTPPARINFO_TIMER3  0

/* Time to pass from STALL or BYE to DEL, 10 times the RTCP interval */
#define RTPPARINFO_TIMER4  20*1000

/**********************************************************************
 * Control word structure (used to direct the participant's state
 * machine)
 **********************************************************************

      3                   2                   1                 
    1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |E|X| Tmr | Move| State | Event |    Source     |  Destination  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    v v \-v-/ \-v-/ \--v--/ \--v--/ \------v------/ \------v------/
    | |   |     |      |       |           |               |
    | |   |     |      |       |           |    Destination Queue (8)
    | |   |     |      |       |           | 
    | |   |     |      |       |     Source Queue (8)
    | |   |     |      |       |
    | |   |     |      |       Event to generate (4)
    | |   |     |      |
    | |   |     |      Next state (4)
    | |   |     |
    | |   |     Type of move in queues (3)
    | |   |
    | |   Timer to use (3)
    | |
    | Need to do extra processing (1)
    |
    Enable this word (1)

 **********************************************************************
 * Participant's states machine:
 *
 *   \_ user events: RTP, RTCP, BYE, Timeout, DEL
 *     \_  
 *       \_
 * states  \   RTP             RTCP           BYE            Timeout(T)
 *-------------------------------------------------------------------------
 * CREATED     TALKING         SILENT         X              X
 *             AliveQ->Cache1Q       
 *             T1->T           T2->T
 *             EVENT_CREATED   EVENT_CREATED
 *-------------------------------------------------------------------------
 * SILENT      TALKING                        BYE            T3:STALL
 *             AliveQ->Cache1Q AliveQ         AliveQ->ByeQ   AliveQ->ByeQ
 *             T1->T           T3->T          T4->T          T4->T
 *             EVENT_TALKING                  EVENT_BYE      EVENT_STALL
 *-------------------------------------------------------------------------
 * TALKING                                    BYE            T1:WAS_TKING
 *             Cache1Q                        Cache1Q->ByeQ  Cache1Q->Cache2Q
 *             T1->T                          T4->T          T2->T
 *                                            EVENT_BYE      EVENT_WAS_TKING
 *-------------------------------------------------------------------------
 * WAS_TKING   TALKING                        BYE            T2:SILENT
 *             Cache2Q->Cache1Q               Cache2Q->ByeQ  Cache2Q->AliveQ
 *             T1->T                          T4->T          T3->T
 *             EVENT_TALKING                  EVENT_BYE      EVENT_SILENT
 *-------------------------------------------------------------------------
 * STALL       TALKING         SILENT         BYE            T4:DEL
 *             ByeQ->Cache1Q   ByeQ->AliveQ                  ByeQ->
 *                                                           Hash->
 *             T1->T           T3->T          T4->T
 *             EVENT_TALKING   EVENT_SILENT   EVENT_BYE      EVENT_DEL
 *-------------------------------------------------------------------------
 * BYE         ---             ---            ---            T4:DEL
 *                                                           ByeQ->
 *                                                           Hash->
 *                                                           EVENT_DEL
 *-------------------------------------------------------------------------
 * DEL         ---             ---            ---            ---
 *-------------------------------------------------------------------------
 *
 * NOTE On event DEL (that event is not displayed in the chart
 * above. Don't be confused with the state DEL) for all the states,
 * remove user from Cache1Q, Cache2Q, AliveQ or ByeQ, as well as
 * removing it from Hash
 *
 * Cache1Q->AliveQ - move from Cache1Q to AliveQ
 * ByeQ->          - remove from ByeQ
 * Cache1Q         - move to head of Cache1Q
 * T1->T           - set timer to T1
 * X               - invalid
 * ---             - ignore user event
 *
 * */

/* flags mask */
#define RTPPARINFO_FLAG_START_MUTED

/*
 * !!! WARNING !!!
 *
 * The offset to Cache1Q, ..., ByeQ MUST NOT be bigger than 1023 and
 * MUST be DWORD aligned (the offset value is stored as number of
 * DWORDS in rtppinfo.c using 8 bits)
 * */
#define CACHE1Q     RTPSTRUCTOFFSET(RtpAddr_t, Cache1Q)
#define CACHE2Q     RTPSTRUCTOFFSET(RtpAddr_t, Cache2Q)
#define ALIVEQ      RTPSTRUCTOFFSET(RtpAddr_t, AliveQ)
#define BYEQ        RTPSTRUCTOFFSET(RtpAddr_t, ByeQ)

#if USE_GRAPHEDT > 0
#define RTPPARINFO_MASK_RECV_DEFAULT ( (1 << RTPPARINFO_CREATED) | \
                                     (1 << RTPPARINFO_BYE) )

#define RTPPARINFO_MASK_SEND_DEFAULT ( (1 << RTPPARINFO_CREATED) | \
                                     (1 << RTPPARINFO_BYE) )
#else
#define RTPPARINFO_MASK_RECV_DEFAULT 0
#define RTPPARINFO_MASK_SEND_DEFAULT 0
#endif

HRESULT ControlRtpParInfo(RtpControlStruct_t *pRtpControlStruct);

DWORD RtpUpdateUserState(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        DWORD            dwUserEvent
    );

/* Enum the SSRCs upto the available size (in DWORDs), if pdwSSRC is
 * NULL, return the current number of SSRCs in *pdwNumber */
HRESULT RtpEnumParticipants(
        RtpAddr_t       *pRtpAddr,
        DWORD           *pdwSSRC,
        DWORD           *pdwNumber
    );

/* Access the states machine to obtain the next state based on the
 * current state and the user event */
DWORD RtpGetNextUserState(
        DWORD            dwCurrentState,
        DWORD            dwUserEvent
    );


/*********************************************************************
 * Control word definition to set/query bits or values in a RtpUser_t
 *
 * The idea is to use a control word to define the type of operation
 * to perform in a bit of a DWORD inside a structure, or a sequence of
 * bytes inside that same structure, so a single function can be used
 * to set/query a bit/dword/structure (dword is a sequence of 4 bytes
 * and a structure is a sequence of N bytes) inside any structure.
 *
 * WARNING:
 *
 * note that the maximum bytes that can be queried/set is limited to
 * 255 bytes, and the offset is limited to 1023 bytes
 *********************************************************************

      3                   2                   1                 
    1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |S|             |s|q|F|     |    bit/size   |      offset       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    v               v v v       \------v------/ \--------v---------/
    |               | | |              |                 |
    |               | | |              |           bytes offset (10)
    |               | | |              |   
    |               | | | bit if F is set,number of bytes otherwise (8)
    |               | | |
    |               | | Select Flag or bytes (1)
    |               | |
    |               | Query is enabled (1) (not used)
    |               |
    |               Set is enabled (1) (not used)
    |
    Select Set or Query (1)

 */

/*******
 * Bit S
 *******/
 
/* Position of S in the control dword */
#define RTPUSER_BIT_SET           31

/* Builds the mask to encode the S bit as query (get) */
#define RTPUSER_INFO_QUERY        (0 << RTPUSER_BIT_SET)

/* Builds the mask to encode the S bit as set */
#define RTPUSER_INFO_SET          (1 << RTPUSER_BIT_SET)

/* Test if this is a set operation (otherwise is a query) */
#define RTPUSER_IsSetting(_dwControl) \
                                  (RtpBitTest(_dwControl, RTPUSER_BIT_SET))

/*******
 * Bit F
 *******/

/* Position of F in the control dword */
#define RTPUSER_BIT_FLAG          21

/* Builds the mask to encode the F bit as flag */
#define RTPUSER_INFO_BYTES        (0 << RTPUSER_BIT_FLAG)

/* Builds the mask to encode the F bit as flag */
#define RTPUSER_INFO_FLAG         (1 << RTPUSER_BIT_FLAG)

/* Test if this operation is on a flag (otherwise is on a DWORD) */
#define RTPUSER_IsFlag(_ctrl)     (RtpBitTest(_ctrl, RTPUSER_BIT_FLAG))


/**********
 * Bit/size
 **********/

/* Builds the mask to encode the bit into the control dword */
#define RTPUSER_PAR_BIT(_bit)     (((_bit) & 0x1f) << 10)

/* Retrives the bits from the control dword */
#define RTPUSER_GET_BIT(_ctrl)    (((_ctrl) >> 10) & 0x1f)

/* Builds the mask to encode the number of bytes into the control
 * dword */
#define RTPUSER_PAR_SIZE(_size)   (((_size) & 0xff) << 10)

/* Retrives the number of bytes from the control dword */
#define RTPUSER_GET_SIZE(_ctrl)   (((_ctrl) >> 10) & 0xff)

/********
 * Offset
 ********/

/* Builds the mask to encode the offset into the control dword */
#define RTPUSER_PAR_OFF(_offset)  ((_offset) & 0x3ff))

/* Retrives the offset from the control dword */
#define RTPUSER_GET_OFF(_ctrl)    ((_ctrl) & 0x3ff)

/* Define some offsets to use */
#define RTPUSER_STATE_OFFSET      RTPSTRUCTOFFSET(RtpUser_t, dwUserState)
#define RTPUSER_FLAGS_OFFSET      RTPSTRUCTOFFSET(RtpUser_t, dwUserFlags2)
#define RTPUSER_NETINFO_OFFSET    RTPSTRUCTOFFSET(RtpUser_t, RtpNetInfo)
#define RTPADDR_FLAGS_OFFSET      RTPSTRUCTOFFSET(RtpAddr_t, dwAddrFlags)

/*
 * The following control dwords are used in RtpMofifyParticipantInfo
 * as the dwControl parameter to encode the action to take. The
 * actions include query or set flags (e.g. mute state), query or set
 * values (e.g. user state)
 *
 * The flags are defined in struct.h for the RtpUser_t structure, the
 * DWORD values are also fields inthe RtpUser_t structure, also in
 * struct.h */

/* Get the user state (e.g SILENT, TALKING) as a DWORD  */
#define RTPUSER_GET_PARSTATE    ( RTPUSER_INFO_QUERY | \
                                  RTPUSER_INFO_BYTES | \
                                  RTPUSER_PAR_SIZE(sizeof(DWORD)) | \
                                  RTPUSER_STATE_OFFSET )

/* Get the mute state */
#define RTPUSER_GET_MUTE        ( RTPUSER_INFO_QUERY | \
                                  RTPUSER_INFO_FLAG  | \
                                  RTPUSER_PAR_BIT(FGUSER2_MUTED) | \
                                  RTPUSER_FLAGS_OFFSET )

/* Set the mute state */
#define RTPUSER_SET_MUTE        ( RTPUSER_INFO_SET   | \
                                  RTPUSER_INFO_FLAG  | \
                                  RTPUSER_PAR_BIT(FGUSER2_MUTED) | \
                                  RTPUSER_FLAGS_OFFSET )


/* Get the network event state */
#define RTPUSER_GET_NETEVENT    ( RTPUSER_INFO_QUERY | \
                                  RTPUSER_INFO_FLAG  | \
                                  RTPUSER_PAR_BIT(FGUSER2_NETEVENTS) | \
                                  RTPUSER_FLAGS_OFFSET )

/* Set the network event state */
#define RTPUSER_SET_NETEVENT    ( RTPUSER_INFO_SET   | \
                                  RTPUSER_INFO_FLAG  | \
                                  RTPUSER_PAR_BIT(FGUSER2_NETEVENTS) | \
                                  RTPUSER_FLAGS_OFFSET )

/* Set the network event state for any and all SSRCs*/
#define RTPUSER_SET_NETEVENTALL ( RTPUSER_INFO_SET   | \
                                  RTPUSER_INFO_FLAG  | \
                                  RTPUSER_PAR_BIT(FGADDR_NETMETRIC) | \
                                  RTPADDR_FLAGS_OFFSET )

/* Get the network information as an RtpNetInfo_t structure */
#define RTPUSER_GET_NETINFO     ( RTPUSER_INFO_QUERY | \
                                  RTPUSER_INFO_BYTES | \
                                  RTPUSER_PAR_SIZE(sizeof(RtpNetInfo_t)) | \
                                  RTPUSER_NETINFO_OFFSET )


HRESULT RtpMofifyParticipantInfo(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwSSRC,
        DWORD            dwControl,
        DWORD           *pdwValue
    );

extern const TCHAR_t        **g_psRtpUserStates;

extern const DWORD            g_dwTimesRtcpInterval[];

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif /* _rtppinfo_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtpmisc.h ===
/**********************************************************************
 *
 *  Copyright (C) 1999 Microsoft Corporation
 *
 *  File name:
 *
 *    rtpmisc.h
 *
 *  Abstract:
 *
 *    Some networking miscellaneous functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/07/13 created
 *
 **********************************************************************/

#ifndef _rtpmisc_h_
#define _rtpmisc_h_

#include "gtypes.h"

const TCHAR *RtpRecvSendStr(DWORD dwFlags);

const TCHAR *RtpRecvSendStrIdx(DWORD dwIdx);

const TCHAR *RtpStreamClass(DWORD dwFlags);

BOOL RtpGetUserName(TCHAR_t *pUser, DWORD dwSize);

BOOL RtpGetHostName(TCHAR_t *pHost, DWORD dwSize);

BOOL RtpGetPlatform(TCHAR_t *pPlatform);

BOOL RtpGetImageName(TCHAR_t *pImageName, DWORD *pdwSize);

TCHAR_t *RtpNtoA(DWORD dwAddr, TCHAR_t *sAddr);

DWORD RtpAtoN(TCHAR_t *sAddr);

BOOL RtpMemCmp(BYTE *pbMem0, BYTE *pbMem1, long lMemSize);

extern const TCHAR_t *g_psRtpRecvSendStr[];

extern const TCHAR_t *g_psRtpStreamClass[];

#endif /* _rtpmisc_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtpph.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpph.h
 *
 *  Abstract:
 *
 *    Implements the Payload handling family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/07 created
 *
 **********************************************************************/

#ifndef _rtpph_h_
#define _rtpph_h_

#include "rtpfwrap.h"

/***********************************************************************
 *
 * Payload handling family
 *
 **********************************************************************/

/* functions */
#define RTPPH_PLAYOUT_DELAY

/* functions */
/* TODO add the functions */
enum {
    RTPPH_FIRST,
    RTPPH_LAST
};

HRESULT ControlRtpPh(RtpControlStruct_t *pRtpControlStruct);

#endif /* _rtpph_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtpncnt.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpncnt.h
 *
 *  Abstract:
 *
 *    Implements the Statistics family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/07 created
 *
 **********************************************************************/

#ifndef _rtpncnt_h_
#define _rtpncnt_h_

#include "rtpfwrap.h"

/***********************************************************************
 *
 * Statistics family
 *
 **********************************************************************/

/* functions */
enum {
    RTPSTATS_FIRST,
    RTPSTATS_RTPSTATS_GLOBAL_STATS,
    RTPSTATS_PARTICIPANT_RECV,
    RTPSTATS_STATS_MASK,
    RTPSTATS_TEST_STATS_MASK,
    RTPSTATS_LAST
};
 
HRESULT ControlRtpStats(RtpControlStruct_t *pRtpControlStruct);

/* Helper function to update counters */
BOOL RtpUpdateNetCount(
        RtpNetCount_t   *pRtpNetCount,/* structure where to update */
        RtpCritSect_t   *pRtpCritSect,/* lock to use */
        DWORD            dwRtpRtcp,/* 0=RTP or 1=RTCP stats */
        DWORD            dwBytes,  /* bytes to update */
        DWORD            dwFlags,  /* Flags, e.g. a dropped or error packet */
        double           dTime     /* time packet recv/send */
    );

void RtpResetNetCount(
        RtpNetCount_t   *pRtpNetCount,
        RtpCritSect_t   *pRtpCritSect
        );

void RtpGetRandomInit(RtpAddr_t *pRtpAddr);

void RtpResetNetSState(
        RtpNetSState_t  *pRtpNetSState,
        RtpCritSect_t   *pRtpCritSect
    );

#if 0
/* Creates and initializes a RtpNetCount_t structure */
RtpNetCount_t *RtpNetCountAlloc(void);

/* Frees a RtpNetCount_t structure */
void RtpNetCountFree(RtpNetCount_t *pRtpNetCount);
#endif

#endif /* _rtpncnt_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtpque.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpque.h
 *
 *  Abstract:
 *
 *    Queues and Hash implementation
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/21 created
 *
 **********************************************************************/

#ifndef _rtpque_h_
#define _rtpque_h_

#include "rtpcrit.h"

#if defined(__cplusplus)
extern "C" {
#endif  // (__cplusplus)
#if 0
}
#endif

/*
 * The queue/hash support uses the same structure to keep items in a
 * queue or a hash.
 *
 * A queue is just a circular double linked list.
 *
 * A hash includes a hash table, and each entry is either the head of
 * another hash table or a queue's head. Items in a hash will end
 * always in a queue. A queue will become a new hash when a size of
 * MAX_QUEUE2HASH_ITEMS is reached. A hash will be destroyed (become a
 * queue) once it is emptied.
 *
 * All the functions return either a pointer to the item
 * enqueud/inserted or the item just dequeued/removed. If an error
 * condition is detected, NULL is returned.
 *
 * */

#define HASH_TABLE_SIZE      32 /* entries in a hash table must be 2^n */
#define MAX_QUEUE2HASH_ITEMS 32 /* threshold size to change queue into hash */

/* Forward declarations */
typedef struct _RtpQueueItem_t RtpQueueItem_t;
typedef struct _RtpQueue_t     RtpQueue_t;
typedef struct _RtpQueueHash_t RtpQueueHash_t;

/*
 * Every object maintained in a queue or a queue/hash will include
 * this structure */
typedef struct _RtpQueueItem_t {
    struct _RtpQueueItem_t *pNext; /* next item */
    struct _RtpQueueItem_t *pPrev; /* previous item */
    struct _RtpQueue_t     *pHead; /* used for robustness, points to
                                    * queue's head */
    /* The next field is used at the programer's discretion. Can be
     * used to point back to the parent object, or as a key during
     * searches, it is the programer's responsibility to set this
     * value, it is not used by the queue/hash functions (except
     * the "Ordered queue insertion" functions) */
    union {
        void  *pvOther;        /* may be used as a general purpose ptr */
        double dKey;           /* may be used as a double key for searches */
        DWORD  dwKey;          /* may be used as DWORD key for searches */
    };
} RtpQueueItem_t;

/*
 * !!! WARNING !!!
 *
 * RtpQueue_t and RtpQueueHash can be casted to each other.
 *
 * A negative count indicates pFirst (or indeed pvTable) is a hash
 * table. This is safe because a hash is destroyed when it has zero
 * elements (becoming a regular queue) and won't be expanded to a hash
 * again but until MAX_QUEUE2HASH_ITEMS items are enqueued */

/*
 * The owner of a queue will include this structure */
typedef struct _RtpQueue_t {
    RtpQueueItem_t      *pFirst;   /* points to first item */
    long                 lCount;   /* number of items in queue (positive) */
} RtpQueue_t;

/*
 * The owner of a queue/hash will include this structure */
typedef struct _RtpQueueHash_t {
    union {
        RtpQueueItem_t  *pFirst;   /* points to first item */
        void            *pvTable;  /* points to the hash table */
    };
    long                 lCount;   /* number of items in queue
                                      (positive)/hash (negative) */
} RtpQueueHash_t;

/* Is item in a queue? */
#define InQueue(pI)      ((pI)->pHead)

/* Is queue empty? */
#define IsQueueEmpty(pQ) ((pQ)->lCount == 0)

/* Obtain queue's current size */
#define GetQueueSize(pQ) ((pQ)->lCount)

/* TODO when a hash become really a hash (currently is the same as a
 * queue), this macro must be modified accordingly */
#define GetHashCount(pH) ((pH)->lCount)

/*
 * Queue functions
 */

/* enqueue after pPos item */
RtpQueueItem_t *enqueuea(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem,
        RtpQueueItem_t  *pPos
    );

/* enqueue before pPos item */
RtpQueueItem_t *enqueueb(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem,
        RtpQueueItem_t  *pPos
    );

/* enqueue as first */
RtpQueueItem_t *enqueuef(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem
    );

/* enqueue at the end */
RtpQueueItem_t *enqueuel(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem
    );

/* dequeue item pItem */
RtpQueueItem_t *dequeue(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem
    );

/* dequeue first item */
RtpQueueItem_t *dequeuef(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect
    );

/* dequeue last item */
RtpQueueItem_t *dequeuel(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect
    );

/* move item so it becomes the first one in the queue */
RtpQueueItem_t *move2first(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem
    );

/* move item so it becomes the last one in the queue */
RtpQueueItem_t *move2last(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem
    );

/* move item from FromQ to the beginning of ToQ */
RtpQueueItem_t *move2qf(
        RtpQueue_t      *pToQ,
        RtpQueue_t      *pFromQ,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem
    );

/* move item from FromQ to the end of ToQ */
RtpQueueItem_t *move2ql(
        RtpQueue_t      *pToQ,
        RtpQueue_t      *pFromQ,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem
    );


/* find first item that matches the pvOther parameter */
RtpQueueItem_t *findQO(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        void            *pvOther
    );

/* find first item that matches the dwKey parameter */
RtpQueueItem_t *findQdwK(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        DWORD            dwKey
    );

/* find first item that matches the dKey parameter */
RtpQueueItem_t *findQdK(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        double          dKey
    );

/* find the Nth item in the queue (items are counted 0,1,2,...) */
RtpQueueItem_t *findQN(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        long             lNth
    );


/*
 * Ordered Queue insertion
 */

/* enqueue in ascending key order */
RtpQueueItem_t *enqueuedwK(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem,
        DWORD            dwKey
    );

/* enqueue in ascending key order */
RtpQueueItem_t *enqueuedK(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem,
        double          dKey
    );

/*
 * Queue/Hash functions
 */

/* insert in hash using key */
RtpQueueItem_t *insertHdwK(
        RtpQueueHash_t  *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem,
        DWORD            dwKey
    );

/* remove from hash first item matching dwKey */
RtpQueueItem_t *removeHdwK(
        RtpQueueHash_t  *pHead,
        RtpCritSect_t   *pRtpCritSect,
        DWORD            dwKey
    );

/* remove item from hash */
RtpQueueItem_t *removeH(
        RtpQueueHash_t  *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem
    );

/* remove "first" item from hash */
RtpQueueItem_t *removefH(
        RtpQueueHash_t  *pHead,
        RtpCritSect_t   *pRtpCritSect
    );

/* find first item whose key matches dwKey */
RtpQueueItem_t *findHdwK(
        RtpQueueHash_t  *pHead,
        RtpCritSect_t   *pRtpCritSect,
        DWORD            dwKey
    );

/* Peek the "first" item from hash */
RtpQueueItem_t *peekH(
        RtpQueueHash_t  *pHead,
        RtpCritSect_t   *pRtpCritSect
    );
      
#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif /* _rtpque_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtpsend.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpsend.h
 *
 *  Abstract:
 *
 *    RTP send
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/24 created
 *
 **********************************************************************/
#ifndef _rtpsend_h_
#define _rtpsend_h_

HRESULT RtpSendTo_(
        RtpAddr_t *pRtpAddr,
        WSABUF    *pWSABuf,
        DWORD      dwWSABufCount,
        DWORD      dwTimeStamp,
        DWORD      dwSendFlags
    );

#endif /* _rtpsend_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtprand.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtprand.h
 *
 *  Abstract:
 *
 *    Random number generation using CAPI
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    2000/09/12 created
 *
 **********************************************************************/

#ifndef _rtprand_h_
#define _rtprand_h_

HRESULT RtpRandInit(void);

HRESULT RtpRandDeinit(void);

/* Generate a 32bits random number */
DWORD RtpRandom32(DWORD_PTR type);

/* Generate dwLen bytes of random data */
DWORD RtpRandomData(char *pBuffer, DWORD dwLen);

#endif /* _rtprand_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtpreg.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 2000
 *
 *  File name:
 *
 *    rtpreg.h
 *
 *  Abstract:
 *
 *    Registry initialization and configuration
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    2000/01/21 created
 *
 **********************************************************************/

#ifndef _rtpreg_h_
#define _rtpreg_h_

#include "gtypes.h"

#if defined(__cplusplus)
extern "C" {
#endif  // (__cplusplus)
#if 0
}
#endif

/* Flags in RtpReg_t.dwQosFlags */
enum {
    FGREGQOS_FIRST,

    /* Used to force the result of queries to allowed to send */
    FGREGQOS_FORCE_ALLOWEDTOSEND_RESULT,
    FGREGQOS_FORCE_ALLOWEDTOSEND,
    FGREGQOS_DONOTSET_BORROWMODE,
    
    FGREGQOS_LAST
};

typedef struct _RtpReg_t {
    /* Default address and port */
    TCHAR           *psDefaultIPAddress;
    DWORD            dwDefaultLocalPort;
    DWORD            dwDefaultRemotePort;
    DWORD            dwMcastLoopbackMode;
    
    /* QOS */
    DWORD            dwQosEnable; /* 10B=disable, 11B=enable */
    DWORD            dwQosFlags;
    DWORD            dwQosRsvpStyle;
    DWORD            dwQosMaxParticipants;
    DWORD            dwQosSendMode;
    TCHAR           *psQosPayloadType;

    TCHAR           *psQosAppName;
    TCHAR           *psQosAppGUID;
    TCHAR           *psQosPolicyLocator;
    
    /* Default SDES information */
    DWORD            dwSdesEnable;
    TCHAR           *psCNAME;
    TCHAR           *psNAME;
    TCHAR           *psEMAIL;
    TCHAR           *psPHONE;
    TCHAR           *psLOC;
    TCHAR           *psTOOL;
    TCHAR           *psNOTE;
    TCHAR           *psPRIV;
    TCHAR           *psBYE;

    /* Default Encryption */
    DWORD            dwCryptEnable;
    DWORD            dwCryptMode;
    TCHAR           *psCryptHashAlg;
    TCHAR           *psCryptDataAlg;
    TCHAR           *psCryptPassPhrase;

    /* Events */
    DWORD            dwEventsReceiver; /* 2=disable, 3=enable */
    DWORD            dwEventsSender;   /* 2=disable, 3=enable */
    DWORD            dwEventsRtp;
    DWORD            dwEventsPInfo;
    DWORD            dwEventsQos;
    DWORD            dwEventsSdes;

    /* Playout delay */
    DWORD            dwPlayoutEnable;
    DWORD            dwMinPlayout; /* millisecs */
    DWORD            dwMaxPlayout; /* millisecs */
    
    /* Redundancy */
    DWORD            dwRedEnable;
    /* b13,b12 enable/disable redundancy thresholds (3=enable,2=disable)
     * b9,b8   enable/disable updating the sender's redundancy distance
     * b5,b4   enable/disable redundancy for sender
     * b1,b0   enable/disable redundancy for receiver
     */
    DWORD            dwRedPT;
    DWORD            dwInitialRedDistance;
    DWORD            dwMaxRedDistance;
    DWORD            dwRedEarlyTimeout; /* ms */
    DWORD            dwRedEarlyPost;    /* ms */
    DWORD            dwLossRateThresh0; /* 16 msbits=high, 16 lsbits=low */
    DWORD            dwLossRateThresh1; /* 16 msbits=high, 16 lsbits=low */
    DWORD            dwLossRateThresh2; /* 16 msbits=high, 16 lsbits=low */
    DWORD            dwLossRateThresh3; /* 16 msbits=high, 16 lsbits=low */
    
    /* GenLosses */
    DWORD            dwGenLossEnable;
    DWORD            dwRecvLossRate;
    DWORD            dwSendLossRate;

    /* Bandwidth estimation */
    DWORD            dwBandEstEnable; /* 2=disable, 3=enable */
    DWORD            dwBandEstModulo;
    /* b24-b31 (8) Receiver's min reports
     * b23-b16 (8) Sender's initial count
     * b15-b8 (8)  Initial modulo
     * b7-b0 (8)   Normal modulo
     */
    DWORD            dwBandEstTTL; /* Estimation is reported while no
                                    * older than this (seconds) */
    DWORD            dwBandEstWait;/* An event is posted if no estimation
                                    * is available within this (seconds) */
    DWORD            dwBandEstMaxGap;/* Maximum time (milliseconds)
                                      * gap to use 2 consecutive RTCP
                                      * SR reports for bandwidth
                                      * estimation */
    union {
        DWORD            dwBandEstBin[RTCP_BANDESTIMATION_MAXBINS + 1];
        
        struct {
            /*
             * WARNING
             *
             * Make sure to keep the number of individual bins to be
             * RTCP_BANDESTIMATION_MAXBINS+1, same thing in rtpreg.c
             * and rtcpsend.c */
            DWORD        dwBandEstBin0;
            DWORD        dwBandEstBin1;
            DWORD        dwBandEstBin2;
            DWORD        dwBandEstBin3;
            DWORD        dwBandEstBin4;
        };
    };

    /* Network quality */
    DWORD            dwNetQualityEnable;
    /* b1,b0   enable/disable computing network quality */
} RtpReg_t;

#define RTPREG_NOVALUESET NO_DW_VALUESET
#define IsRegValueSet(dw) IsDWValueSet(dw)

extern RtpReg_t         g_RtpReg;

void RtpRegistryInit(RtpReg_t *pRtpReg);

void RtpRegistryDel(RtpReg_t *pRtpReg);

/* Prototype to functions that initialize some global variables that
 * depend on the registry readings. These functions are called from
 * inside RtpRegistryInit() */
void RtpSetRedParametersFromRegistry(void);
void RtpSetMinMaxPlayoutFromRegistry(void);
void RtpSetBandEstFromRegistry(void);

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif /* _rtpreg_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtprtp.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtprtp.h
 *
 *  Abstract:
 *
 *    Implements the RTP Specific family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/07 created
 *
 **********************************************************************/

#ifndef _rtprtp_h_
#define _rtprtp_h_

#include "rtpfwrap.h"

#if defined(__cplusplus)
extern "C" {
#endif  /* (__cplusplus) */
#if 0
}
#endif

/***********************************************************************
 *
 * RTP Specific functions family
 *
 **********************************************************************/
#if 0
enum {
    RTPRTP_FIRST,
    RTPRTP_EVENT_MASK,
    RTPRTP_TEST_EVENT_MASK,
    RTPRTP_FEATURE_MASK,
    RTPRTP_TEST_FEATURE_MASK,
    RTPRTP_DATACLOCK,
    RTPRTP_LAST
};


/* feature bits */
enum {
    RTPRTP_E_FIRST,
    RTPRTP_E_FEAT_PORT_ODDEVEN,
    RTPRTP_E_FEAT_PORT_SEQUENCE,
    RTPRTP_E_FEAT_RTCPENABLED,
    RTPRTP_E_LAST
};
    
/* feature masks */
#define RTPRTP_FEAT_PORT_ODDEVEN   fg_par(RTPRTP_E_FEAT_PORT_ODDEVEN)
#define RTPRTP_FEAT_PORT_SEQUENCE  fg_par(RTPRTP_E_FEAT_PORT_SEQUENCE)
#define RTPRTP_FEAT_RTCPENABLED    fg_par(RTPRTP_E_FEAT_RTCPENABLED)
#endif

#define RTPRTP_EVENT_RECV_DEFAULT 0
#define RTPRTP_EVENT_SEND_DEFAULT 0

HRESULT ControlRtpRtp(RtpControlStruct_t *pRtpControlStruct);

DWORD RtpSetBandwidth(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwInboundBw,
        DWORD            dwOutboundBw,
        DWORD            dwReceiversRtcpBw,
        DWORD            dwSendersRtcpBw
    );

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  /* (__cplusplus) */

#endif /* _rtprtp_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtprecv.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtprecv.h
 *
 *  Abstract:
 *
 *    Implements overalapped RTP reception
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/07/01 created
 *
 **********************************************************************/

#ifndef _rtprecv_h_
#define _rtprecv_h_

#include "struct.h"

#if defined(__cplusplus)
extern "C" {
#endif  /* (__cplusplus) */
#if 0
}
#endif

HRESULT RtpRecvFrom_(
        RtpAddr_t *pRtpAddr,
        WSABUF    *pWSABuf,
        void      *pvUserInfo1,
        void      *pvUserInfo2
    );

DWORD StartRtpRecvFrom(RtpAddr_t *pRtpAddr);

DWORD ConsumeRtpRecvFrom(RtpAddr_t *pRtpAddr);

DWORD RtpCheckReadyToPostOnTimeout(
        RtpAddr_t       *pRtpAddr
    );

DWORD RtpCheckReadyToPostOnRecv(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser
    );

DWORD FlushRtpRecvFrom(RtpAddr_t *pRtpAddr);

DWORD FlushRtpRecvUser(RtpAddr_t *pRtpAddr, RtpUser_t *pRtpUser);

void RtpRecvIOFreeAll(RtpAddr_t *pRtpAddr);

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  /* (__cplusplus) */

#endif /* _rtprecv_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtpred.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpred.h
 *
 *  Abstract:
 *
 *    Implements functionality to support redundant encoding (rfc2198)
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    2000/10/20 created
 *
 **********************************************************************/

#ifndef _rtpred_h_
#define _rtpred_h_

#if defined(__cplusplus)
extern "C" {
#endif  /* (__cplusplus) */
#if 0
}
#endif

DWORD RtpSetRedParameters(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwFlags,
        DWORD            dwPT_Red,
        DWORD            dwInitialRedDistance,
        DWORD            dwMaxRedDistance
    );

DWORD RtpUpdatePlayoutBounds(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        RtpRecvIO_t     *pRtpRecvIO
    );

DWORD RtpAdjustSendRedundancyLevel(RtpAddr_t *pRtpAddr);

DWORD RtpAddRedundantBuff(
        RtpAddr_t       *pRtpAddr,
        WSABUF          *pWSABuf,
        DWORD            dwTimeStamp
    );

DWORD RtpClearRedundantBuffs(RtpAddr_t *pRtpAddr);

DWORD RtpRedAllocBuffs(RtpAddr_t *pRtpAddr);

DWORD RtpRedFreeBuffs(RtpAddr_t *pRtpAddr);

int RtpUpdateLossRate(
        int              iAvgLossRate,
        int              iCurLossRate
    );

extern double           g_dRtpRedEarlyTimeout;
extern double           g_dRtpRedEarlyPost;

#if USE_GEN_LOSSES > 0
BOOL RtpRandomLoss(DWORD dwRecvSend);
#endif /* USE_GEN_LOSSES > 0 */

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  /* (__cplusplus) */

#endif/* _rtpred_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtpsess.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpsess.h
 *
 *  Abstract:
 *
 *    Get, Initialize and Delete RTP sessions (RtpSess_t)
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/02 created
 *
 **********************************************************************/

#ifndef _rtpsess_h_
#define _rtpsess_h_

#if defined(__cplusplus)
extern "C" {
#endif  // (__cplusplus)
#if 0
}
#endif

HRESULT GetRtpSess(
        RtpSess_t **ppRtpSess
    );

HRESULT DelRtpSess(
        RtpSess_t *pRtpSess
    );

HRESULT GetRtpAddr(
        RtpSess_t  *pRtpSess,
        RtpAddr_t **ppRtpAddr,
        DWORD       dwFlags
    );

HRESULT DelRtpAddr(
        RtpSess_t *pRtpSess,
        RtpAddr_t *pRtpAddr
    );

#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif /* _rtpsess_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtpstart.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpstart.h
 *
 *  Abstract:
 *
 *    Start/Stop RTP session (and allits addresses)
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/24 created
 *
 **********************************************************************/
#ifndef _rtpstart_h_
#define _rtpstart_h_

HRESULT RtpStart_(
        RtpSess_t *pRtpSess,
        DWORD      dwFlags
    );

HRESULT RtpStop_(
        RtpSess_t *pRtpSess,
        DWORD      dwFlags
    );

#endif /* _rtpstart_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtpstats.h ===
/**********************************************************************
 *
 *  Copyright (c) 1999 Microsoft Corporation
 *
 *  File name:
 *
 *    rtpstats.h
 *
 *  Abstract:
 *
 *    Implements the Statistics family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/07 created
 *
 **********************************************************************/

#ifndef _rtpstats_h_
#define _rtpstats_h_

#include "rtpfwrap.h"

/***********************************************************************
 *
 * Statistics family
 *
 **********************************************************************/

/* functions */
enum {
    RTPSTATS_FIRST,
    RTPSTATS_RTPSTATS_GLOBAL_STATS,
    RTPSTATS_PARTICIPANT_RECV,
    RTPSTATS_STATS_MASK,
    RTPSTATS_TEST_STATS_MASK,
    RTPSTATS_LAST
};
 
/* flags */
#define RTPSTATS_FG_RECV
#define RTPSTATS_FG_SEND


#define SESS_FG_IS_JOINED
#define SESS_FG_MULTICAST_LOOPBACK
#define SESS_FG_RTCP_ENABLED
#define SESS_FG_ALLOWED_TO_SEND
#define SESS_FG_RECEIVERS
#define SESS_FG_QOS_STATE
#define SESS_FG_SHARED_STYLE
#define SESS_FG_FAIL_IF_NO_QOS
#define SESS_FG_IS_MULTICAST

HRESULT ControlRtpStats(RtpControlStruct_t *pRtpControlStruct);

/* Helper function to update counters */
BOOL UpdateRtpStat(RtpStat_t *pRtpStat,/* structure where to update */
                   DWORD      dwRtpRtcp, /* 0=RTP or 1=RTCP stats */
                   DWORD      dwBytes, /* bytes to update */
                   DWORD      dwTime); /* time packet recv/send */
#if 0
/* Creates and initializes a RtpStat_t structure */
RtpStat_t *RtpStatAlloc(void);

/* Frees a RtpStat_t structure */
void RtpStatFree(RtpStat_t *pRtpStat);
#endif

#endif /* _rtpstats_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtptags.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtptags.h
 *
 *  Abstract:
 *
 *    Defines the thags and object IDs for all structures/objects
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/25 created
 *
 **********************************************************************/

#ifndef _rtptags_h_
#define _rtptags_h_

#include <tchar.h>

/*
 * Each memory allocated from a private heap, will be tagged, 3 bytes
 * will be a string, and the fourth byte will be an index for which an
 * object description can be obtained.
 *
 * The following strings are used as the first 3 bytes of the tag */
#define TAGHEAP_BSY 'PTR' /* RTP */
#define TAGHEAP_END 'DNE' /* END */
#define TAGHEAP_FRE 'ERF' /* FRE */

/*
 * WARNING
 *
 * When modifying the tags, each enum TAGHEAP_* in rtptags.h MUST have
 * its own name in g_psRtpTags[], defined in rtptags.c
 * */

/*
 * Each memory allocated from a private heap, will be tagged, 3 bytes
 * will be a string, and 1 byte (byte 3) will be an index for which an
 * object description can be obtained.
 *
 * The following values are those used by byte 3 in the tag (the index
 * byte), and the byte 0 and byte 3 in the object IDs
 * */
#define TAGHEAP_FIRST          0x00  /*  0 */
#define TAGHEAP_CIRTP          0x01  /*  1 */
#define TAGHEAP_RTPOPIN        0x02  /*  2 */
#define TAGHEAP_RTPALLOCATOR   0x03  /*  3 */
#define TAGHEAP_RTPSAMPLE      0x04  /*  4 */
#define TAGHEAP_RTPSOURCE      0x05  /*  5 */
#define TAGHEAP_RTPIPIN        0x06  /*  6 */
#define TAGHEAP_RTPRENDER      0x07  /*  7 */
#define TAGHEAP_RTPHEAP        0x08  /*  8 */
#define TAGHEAP_RTPSESS        0x09  /*  9 */
#define TAGHEAP_RTPADDR        0x0A  /* 10 */
#define TAGHEAP_RTPUSER        0x0B  /* 11 */
#define TAGHEAP_RTPOUTPUT      0x0C  /* 12 */
#define TAGHEAP_RTPNETCOUNT    0x0D  /* 13 */
#define TAGHEAP_RTPSDES        0x0E  /* 14 */
#define TAGHEAP_RTPCHANNEL     0x0F  /* 15 */
#define TAGHEAP_RTPCHANCMD     0x10  /* 16 */
#define TAGHEAP_RTPCRITSECT    0x11  /* 17 */
#define TAGHEAP_RTPRESERVE     0x12  /* 18 */
#define TAGHEAP_RTPNOTIFY      0x13  /* 19 */
#define TAGHEAP_RTPQOSBUFFER   0x14  /* 20 */
#define TAGHEAP_RTPCRYPT       0x15  /* 21 */
#define TAGHEAP_RTPCONTEXT     0x16  /* 22 */
#define TAGHEAP_RTCPCONTEXT    0x17  /* 23 */
#define TAGHEAP_RTCPADDRDESC   0x18  /* 24 */
#define TAGHEAP_RTPRECVIO      0x19  /* 25 */
#define TAGHEAP_RTPSENDIO      0x1A  /* 26 */
#define TAGHEAP_RTCPRECVIO     0x1B  /* 27 */
#define TAGHEAP_RTCPSENDIO     0x1C  /* 28 */
#define TAGHEAP_RTPGLOBAL      0x1D  /* 29 */
#define TAGHEAP_LAST           0x1E  /* 30 */

/*
 * Each object will have as its first field a DWORD which is a unique
 * ID used for that kind of object, byte 2 and 3 are a unique number,
 * byte 0 and byte 3 are the TAGHEAP, an invalidated object has byte 0
 * set to 0
 * */
#define OBJECTID_B2B1       0x005aa500

#define BUILD_OBJECTID(t)       (((t) << 24) | OBJECTID_B2B1 | t)
#define INVALIDATE_OBJECTID(oi) (oi &= ~0xff)

#define OBJECTID_CIRTP         BUILD_OBJECTID(TAGHEAP_CIRTP)
#define OBJECTID_RTPOPIN       BUILD_OBJECTID(TAGHEAP_RTPOPIN)
#define OBJECTID_RTPALLOCATOR  BUILD_OBJECTID(TAGHEAP_RTPALLOCATOR)
#define OBJECTID_RTPSAMPLE     BUILD_OBJECTID(TAGHEAP_RTPSAMPLE)
#define OBJECTID_RTPSOURCE     BUILD_OBJECTID(TAGHEAP_RTPSOURCE)
#define OBJECTID_RTPIPIN       BUILD_OBJECTID(TAGHEAP_RTPIPIN)
#define OBJECTID_RTPRENDER     BUILD_OBJECTID(TAGHEAP_RTPRENDER)
#define OBJECTID_RTPHEAP       BUILD_OBJECTID(TAGHEAP_RTPHEAP)
#define OBJECTID_RTPSESS       BUILD_OBJECTID(TAGHEAP_RTPSESS)
#define OBJECTID_RTPADDR       BUILD_OBJECTID(TAGHEAP_RTPADDR)
#define OBJECTID_RTPUSER       BUILD_OBJECTID(TAGHEAP_RTPUSER)
#define OBJECTID_RTPOUTPUT     BUILD_OBJECTID(TAGHEAP_RTPOUTPUT)
#define OBJECTID_RTPNETCOUNT   BUILD_OBJECTID(TAGHEAP_RTPNETCOUNT)
#define OBJECTID_RTPSDES       BUILD_OBJECTID(TAGHEAP_RTPSDES)
#define OBJECTID_RTPCHANNEL    BUILD_OBJECTID(TAGHEAP_RTPCHANNEL)
#define OBJECTID_RTPCHANCMD    BUILD_OBJECTID(TAGHEAP_RTPCHANCMD)
#define OBJECTID_RTPCRITSECT   BUILD_OBJECTID(TAGHEAP_RTPCRITSECT)
#define OBJECTID_RTPRESERVE    BUILD_OBJECTID(TAGHEAP_RTPRESERVE)
#define OBJECTID_RTPNOTIFY     BUILD_OBJECTID(TAGHEAP_RTPNOTIFY)
#define OBJECTID_RTPQOSBUFFER  BUILD_OBJECTID(TAGHEAP_RTPQOSBUFFER)
#define OBJECTID_RTPCRYPT      BUILD_OBJECTID(TAGHEAP_RTPCRYPT)
#define OBJECTID_RTPCONTEXT    BUILD_OBJECTID(TAGHEAP_RTPCONTEXT)
#define OBJECTID_RTCPCONTEXT   BUILD_OBJECTID(TAGHEAP_RTCPCONTEXT)
#define OBJECTID_RTCPADDRDESC  BUILD_OBJECTID(TAGHEAP_RTCPADDRDESC)
#define OBJECTID_RTPRECVIO     BUILD_OBJECTID(TAGHEAP_RTPRECVIO)
#define OBJECTID_RTPSENDIO     BUILD_OBJECTID(TAGHEAP_RTPSENDIO)
#define OBJECTID_RTCPRECVIO    BUILD_OBJECTID(TAGHEAP_RTCPRECVIO)
#define OBJECTID_RTCPSENDIO    BUILD_OBJECTID(TAGHEAP_RTCPSENDIO)
#define OBJECTID_RTPGLOBAL     BUILD_OBJECTID(TAGHEAP_RTPGLOBAL)

extern const TCHAR *g_psRtpTags[];

#endif /* _rtptags_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtpuser.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpuser.h
 *
 *  Abstract:
 *
 *    Creates/initializes/deletes a RtpUser_t structure
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/10/02 created
 *
 **********************************************************************/

#ifndef _rtpuser_h_
#define _rtpuser_h_

#include "gtypes.h"
#include "struct.h"

#if defined(__cplusplus)
extern "C" {
#endif  // (__cplusplus)
#if 0
}
#endif

HRESULT GetRtpUser(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t      **ppRtpUser,
        DWORD            dwFlags
    );

HRESULT DelRtpUser(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser
    );

DWORD DelAllRtpUser(
        RtpAddr_t       *pRtpAddr
    );

DWORD ResetAllRtpUser(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwFlags   /* Recv, Send */
    );
       
#if 0
{
#endif
#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif /* _rtpuser_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\rtpthrd.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpthrd.h
 *
 *  Abstract:
 *
 *    Implement the RTP reception working thread
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/30 created
 *
 **********************************************************************/

#ifndef _rtpthrd_h_
#define _rtpthrd_h_

#include "gtypes.h"
#include "struct.h"

/* Commands a RTP source worker thread accepts */
enum {
    RTPTHRD_FIRST,
    RTPTHRD_START, /* Starts generating data */
    RTPTHRD_STOP,  /* Stops generating data and exit */
    RTPTHRD_FLUSHUSER, /* Flush all waiting IO from a user */
    RTPTHRD_LAST
};

/* Create a RTP reception thread, and initialize the communication
 * channel */
HRESULT RtpCreateRecvThread(RtpAddr_t *pRtpAddr);

/* Shut down a RTP reception thread and deletes the communication
 * channel */
HRESULT RtpDeleteRecvThread(RtpAddr_t *pRtpAddr);

/* Send a command to the RTP thread to flush all the waiting IOs
 * belonging to the specified RtpUser_t */
HRESULT RtpThreadFlushUser(RtpAddr_t *pRtpAddr, RtpUser_t *pRtpUser);

#endif /* _rtpthrd_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\msrtp\funcs\rtpaddr.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpaddr.c
 *
 *  Abstract:
 *
 *    Implement the RTP Address family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/01 created
 *
 **********************************************************************/

#include "struct.h"

#include <ws2tcpip.h>

#include "rtpmisc.h"
#include "rtpqos.h"
#include "rtpreg.h"
#include "rtpncnt.h"
#include "rtpdemux.h"
#include "rtpglobs.h"
#include "rtprand.h"

#include "rtpaddr.h"

DWORD   RtpGetLocalIPAddress(DWORD dwRemoteAddr);
HRESULT RtpGetSockets(RtpAddr_t *pRtpAddr);
HRESULT RtpDelSockets(RtpAddr_t *pRtpAddr);
SOCKET  RtpSocket(
        RtpAddr_t       *pRtpAddr,
        WSAPROTOCOL_INFO *pProtoInfo,
        DWORD            dwRtpRtcp
    );
BOOL RtpSetTTL(SOCKET Socket, DWORD dwTTL, BOOL bMcast);
BOOL RtpSetMcastSendIF(SOCKET Socket, DWORD dwAddr);
BOOL RtpSetWinSockLoopback(SOCKET Socket, BOOL bEnabled);
BOOL RtpJoinLeaf(SOCKET Socket, DWORD dwAddr, WORD wPort);


HRESULT ControlRtpAddr(RtpControlStruct_t *pRtpControlStruct)
{

    return(NOERROR);
}

/* Obtain the local and remote ports used.
 *
 * WARNING: Must be called after SetAddress
 * */
HRESULT RtpGetPorts(
        RtpAddr_t       *pRtpAddr,
        WORD            *pwRtpLocalPort,
        WORD            *pwRtpRemotePort,
        WORD            *pwRtcpLocalPort,
        WORD            *pwRtcpRemotePort
    )
{
    HRESULT          hr;
    
    TraceFunctionName("RtpGetPorts");

    if (!pRtpAddr)
    {
        hr = RTPERR_INVALIDSTATE;
        goto bail;
    }

    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        hr = RTPERR_INVALIDRTPADDR;

        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_SOCK,
                _T("%s: pRtpAddr[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpAddr,
                pRtpAddr->dwObjectID, OBJECTID_RTPADDR
            ));

        goto bail;
    }

    if (!pwRtpLocalPort  &&
        !pwRtpRemotePort &&
        !pwRtcpLocalPort &&
        !pwRtcpRemotePort)
    {
        hr = RTPERR_POINTER;
        goto bail;
    }

    if ( (pwRtpLocalPort  && !pRtpAddr->wRtpPort[LOCAL_IDX]) ||
         (pwRtcpLocalPort && !pRtpAddr->wRtcpPort[LOCAL_IDX]) )
    {
        /* In order to get local ports I must have the sockets created
         * and have a local address to use */
        
        if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_LADDR))
        {
            hr = RtpGetSockets(pRtpAddr);

            if (FAILED(hr))
            {
                goto bail;
            }
        }
        else
        {
            hr = RTPERR_INVALIDSTATE;
            goto bail;
        }
    }

    if (pwRtpLocalPort)
    {
        *pwRtpLocalPort   = pRtpAddr->wRtpPort[LOCAL_IDX];
    }

    if (pwRtpRemotePort)
    {
        *pwRtpRemotePort  = pRtpAddr->wRtpPort[REMOTE_IDX];
    }

    if (pwRtcpLocalPort)
    {
        *pwRtcpLocalPort  = pRtpAddr->wRtcpPort[LOCAL_IDX];
    }

    if (pwRtcpRemotePort)
    {
        *pwRtcpRemotePort = pRtpAddr->wRtcpPort[REMOTE_IDX];
    }

    hr = NOERROR;

    TraceRetail((
            CLASS_INFO, GROUP_NETWORK, S_NETWORK_SOCK,
            _T("%s: pRtpAddr[0x%p] RTP(L:%u, R:%u) RTCP(L:%u, R:%u)"),
            _fname, pRtpAddr,
            ntohs(pRtpAddr->wRtpPort[LOCAL_IDX]),
            ntohs(pRtpAddr->wRtpPort[REMOTE_IDX]),
            ntohs(pRtpAddr->wRtcpPort[LOCAL_IDX]),
            ntohs(pRtpAddr->wRtcpPort[REMOTE_IDX])
        ));

 bail:

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_SOCK,
                _T("%s: pRtpAddr[0x%p] failed: 0x%X"),
                _fname, pRtpAddr, hr
            ));
    }

    return(hr);
}

/*
 * Set the local and remote ports.
 *
 * Do nothing if passing -1, otherwise assign value (including 0)
 * */
HRESULT RtpSetPorts(
        RtpAddr_t       *pRtpAddr,
        WORD             wRtpLocalPort,
        WORD             wRtpRemotePort,
        WORD             wRtcpLocalPort,
        WORD             wRtcpRemotePort
    )
{
    HRESULT          hr;
    
    TraceFunctionName("RtpSetPorts");

    if (!pRtpAddr)
    {
        hr = RTPERR_INVALIDSTATE;
        goto bail;
    }

    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        hr = RTPERR_INVALIDRTPADDR;

        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_SOCK,
                _T("%s: pRtpAddr[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpAddr,
                pRtpAddr->dwObjectID, OBJECTID_RTPADDR
            ));
        
        goto bail;
    }

    /* RTP local port */
    if ((wRtpLocalPort != (WORD)-1) &&
        pRtpAddr->wRtpPort[LOCAL_IDX] &&
        (pRtpAddr->wRtpPort[LOCAL_IDX] != wRtpLocalPort))
    {
        hr = RTPERR_INVALIDSTATE;
        goto bail;
    }
    
    if (wRtpLocalPort != (WORD)-1)
    {
        pRtpAddr->wRtpPort[LOCAL_IDX] = wRtpLocalPort;
    }

    /* RTP remote port */
    if (wRtpRemotePort != (WORD)-1)
    {
        pRtpAddr->wRtpPort[REMOTE_IDX] = wRtpRemotePort;
    }

    /* RTCP local port */
    if ((wRtcpLocalPort != (WORD)-1) &&
        pRtpAddr->wRtcpPort[LOCAL_IDX] &&
        (pRtpAddr->wRtcpPort[LOCAL_IDX] != wRtcpLocalPort))
    {
        hr = RTPERR_INVALIDSTATE;
        goto bail;
    }
    
    if (wRtcpLocalPort != (WORD)-1)
    {
        pRtpAddr->wRtcpPort[LOCAL_IDX] = wRtcpLocalPort;
    }

    /* RTCP remote port */
    if (wRtcpRemotePort != (WORD)-1)
    {
        pRtpAddr->wRtcpPort[REMOTE_IDX] = wRtcpRemotePort;
    }

    TraceRetail((
            CLASS_INFO, GROUP_NETWORK, S_NETWORK_ADDR,
            _T("%s: RTP(L:%u, R:%u) RTCP(L:%u, R:%u)"),
            _fname, 
            ntohs(pRtpAddr->wRtpPort[LOCAL_IDX]),
            ntohs(pRtpAddr->wRtpPort[REMOTE_IDX]),
            ntohs(pRtpAddr->wRtcpPort[LOCAL_IDX]),
            ntohs(pRtpAddr->wRtcpPort[REMOTE_IDX])
        ));
    
    hr = NOERROR;
    
 bail:
    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_ADDR,
                _T("%s: failed: 0x%X"),
                _fname, hr
            ));
    }

    return(hr);
}

HRESULT RtpGetAddress(
        RtpAddr_t       *pRtpAddr,
        DWORD           *pdwLocalAddr,
        DWORD           *pdwRemoteAddr
    )
{
    HRESULT          hr;

    TraceFunctionName("RtpGetAddress");

    if (!pRtpAddr)
    {
        return(RTPERR_INVALIDSTATE);
    }

    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        hr = RTPERR_INVALIDRTPADDR;

        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_ADDR,
                _T("%s: pRtpAddr[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpAddr,
                pRtpAddr->dwObjectID, OBJECTID_RTPADDR
            ));
        
        goto bail;
    }

    if (!pdwLocalAddr && !pdwRemoteAddr)
    {
        hr = RTPERR_POINTER;
        
        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_ADDR,
                _T("%s: pRtpAddr[0x%p] local or remote address not provided"),
                _fname, pRtpAddr
            ));
        
        goto bail;
    }
    
    hr = RTPERR_INVALIDSTATE;
    
    if (pdwLocalAddr)
    {
        *pdwLocalAddr = pRtpAddr->dwAddr[LOCAL_IDX];

        if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_LADDR))
        {
            hr = NOERROR;
        }
    }

    if (pdwRemoteAddr)
    {
        *pdwRemoteAddr = pRtpAddr->dwAddr[REMOTE_IDX];        

        if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_RADDR))
        {
            hr = NOERROR;
        }
    }
        
bail:
    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_ADDR,
                _T("%s: pRtpAddr[0x%p] failed: 0x%X"),
                _fname, pRtpAddr, hr
            ));
    }

    return(hr);
}

/*
 * If dwLocalAddr is 0, a default local address is asigned if non has
 * been assigned before. If dwRemoteAddr is 0 no error occurs. At
 * least 1 address must be set */
HRESULT RtpSetAddress(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwLocalAddr,
        DWORD            dwRemoteAddr
    )
{
    HRESULT          hr;
    struct in_addr   iaLocalAddr;
    struct in_addr   iaRemoteAddr;
    TCHAR_t          sLocal[16];
    TCHAR_t          sRemote[16];
    
    TraceFunctionName("RtpSetAddress");

    if (!pRtpAddr)
    {
        hr = RTPERR_INVALIDSTATE;
        goto bail;
    }

    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        hr = RTPERR_INVALIDRTPADDR;

        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_ADDR,
                _T("%s: pRtpAddr[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpAddr,
                pRtpAddr->dwObjectID, OBJECTID_RTPADDR
            ));
        
        goto bail;
    }

    /* Fail if both addresses are 0 */
    if (!dwLocalAddr && !dwRemoteAddr)
    {
        hr = RTPERR_INVALIDARG;
        goto bail;
    }
    
    hr = NOERROR;

    /*
     * Remote address
     */
#if 0  /* the address can be set again. */
    if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_RADDR))
    {
         /* If addresses were already set, verify the new setting is
          * the same */
        if (dwRemoteAddr &&
            (dwRemoteAddr != pRtpAddr->dwAddr[REMOTE_IDX]))
        {
            hr = RTPERR_INVALIDARG;
            goto bail;
        }
    }
    else
#endif
    {
        /* Remote address hasn't been set yet */
        if (dwRemoteAddr)
        {
            pRtpAddr->dwAddr[REMOTE_IDX] = dwRemoteAddr;
            
            if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_RADDR) &&
                RtpBitTest(pRtpAddr->dwIRtpFlags,
                           FGADDR_IRTP_RADDRRESETDEMUX) &&
                dwRemoteAddr != pRtpAddr->dwAddr[REMOTE_IDX])
            {
                /* If the remote address is set, and a new and
                 * different remote address is being set, and the
                 * FGADDR_IRTP_RADDRRESETDEMUX flag is set, unmap all
                 * outputs */
                RtpUnmapAllOuts(pRtpAddr->pRtpSess);
            }
    
            RtpBitSet(pRtpAddr->dwAddrFlags, FGADDR_RADDR);

            if (IS_MULTICAST(dwRemoteAddr))
            {
                RtpBitSet(pRtpAddr->dwAddrFlags, FGADDR_ISMCAST);
            }
            else
            {
                RtpBitReset(pRtpAddr->dwAddrFlags, FGADDR_ISMCAST);
            }
        }
    }

    /*
     * Local address
     */
#if 0  /* the address can be set again. */
    if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_LADDR))
    {
        /* If addresses were already set, verify the new setting is
         * the same */
        if (dwLocalAddr &&
            (dwLocalAddr != pRtpAddr->dwAddr[LOCAL_IDX]))
        {
            hr = RTPERR_INVALIDARG;
            goto bail;
        }
    }
    else
#endif
    {
        /* Local address hasn't been set yet */
        if (dwLocalAddr)
        {
            /* TODO might verify the address is really a local address */
            pRtpAddr->dwAddr[LOCAL_IDX] = dwLocalAddr;
        }
        else
        {
            pRtpAddr->dwAddr[LOCAL_IDX] =
                RtpGetLocalIPAddress(pRtpAddr->dwAddr[REMOTE_IDX]);

            if (!pRtpAddr->dwAddr[LOCAL_IDX])
            {
                /* Failed */
                hr = RTPERR_INVALIDARG;
                goto bail;
            }
        }

        RtpBitSet(pRtpAddr->dwAddrFlags, FGADDR_LADDR);
    }
    
    TraceRetail((
            CLASS_INFO, GROUP_NETWORK, S_NETWORK_ADDR,
            _T("%s: pRtpAddr[0x%p] Local:%s Remote:%s"),
            _fname, pRtpAddr,
            RtpNtoA(pRtpAddr->dwAddr[LOCAL_IDX], sLocal),
            RtpNtoA(pRtpAddr->dwAddr[REMOTE_IDX], sRemote)
        ));
    
 bail:
    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_ADDR,
                _T("%s: pRtpAddr[0x%p] failed: 0x%X"),
                _fname, pRtpAddr, hr
            ));
    }
    
    return(hr);
}

/* Obtain the local IP address to use based on the destination address */
DWORD RtpGetLocalIPAddress(DWORD dwRemoteAddr)
{
    DWORD            dwStatus;
    DWORD            dwError;
    DWORD            dwLocalAddr;
    SOCKADDR_IN      sRemoteAddr;
    SOCKADDR_IN      sLocalAddr;
    DWORD            dwNumBytesReturned;
    TCHAR_t          sLocalAddress[16];
    TCHAR_t          sRemoteAddress[16];
    
    TraceFunctionName("RtpGetLocalIPAddress");

    dwNumBytesReturned = 0;
    
    sRemoteAddr.sin_family = AF_INET;
    sRemoteAddr.sin_addr =  *(struct in_addr *) &dwRemoteAddr;
    sRemoteAddr.sin_port = ntohs(0);

    dwLocalAddr = INADDR_ANY;

    if (g_RtpContext.RtpQuerySocket != INVALID_SOCKET)
    {
        if ((dwStatus = WSAIoctl(
                g_RtpContext.RtpQuerySocket, // SOCKET s
                SIO_ROUTING_INTERFACE_QUERY, // DWORD dwIoControlCode
                &sRemoteAddr,        // LPVOID  lpvInBuffer
                sizeof(sRemoteAddr), // DWORD   cbInBuffer
                &sLocalAddr,         // LPVOID  lpvOUTBuffer
                sizeof(sLocalAddr),  // DWORD   cbOUTBuffer
                &dwNumBytesReturned, // LPDWORD lpcbBytesReturned
                NULL, // LPWSAOVERLAPPED lpOverlapped
                NULL  // LPWSAOVERLAPPED_COMPLETION_ROUTINE lpComplROUTINE
            )) == SOCKET_ERROR)
        {
            TraceRetailWSAGetError(dwError);
            
            TraceRetail((
                    CLASS_ERROR, GROUP_NETWORK, S_NETWORK_ADDR,
                    _T("%s: WSAIoctl(SIO_ROUTING_INTERFACE_QUERY) ")
                    _T("failed: %u (0x%X)"),
                    _fname, dwError, dwError
                ));
        }
        else
        {
            dwLocalAddr = *(DWORD *)&sLocalAddr.sin_addr; 
        }
    }
    
    TraceRetail((
            CLASS_INFO, GROUP_NETWORK, S_NETWORK_ADDR,
            _T("%s: Local IP address:%s to reach:%s"),
            _fname, RtpNtoA(dwLocalAddr, sLocalAddress),
            RtpNtoA(dwRemoteAddr, sRemoteAddress)
        ));
    
    return(dwLocalAddr);
}

/* Obtain a pair of sockets and select port to use if they haven't
 * been specified. If a local port is not specified, but the
 * destination address is multicast and we have a remote port, assign
 * the remote port to the local port */
HRESULT RtpGetSockets(RtpAddr_t *pRtpAddr)
{
    HRESULT          hr;
    BOOL             bOk;
    BOOL             bGotPorts;
    DWORD            dwError;
    BOOL             bAutoPort;
    DWORD            i;
    DWORD            j;
    DWORD            dwMaxAttempts;
    DWORD            dwRandom;
    WORD             wPort;
    WORD             wOldRtcpPort;
    RtpQueueItem_t  *pRtpQueueItem;
    WSAPROTOCOL_INFO ProtoInfo;
    WSAPROTOCOL_INFO *pProtoInfo;

    TraceFunctionName("RtpGetSockets");

    hr = NOERROR;

    if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_SOCKET))
    {
        /* Sockets already created */
        TraceRetail((
                CLASS_WARNING, GROUP_NETWORK, S_NETWORK_SOCK,
                _T("%s: pRtpAddr[0x%p] Sockets already created"),
                _fname, pRtpAddr
            ));
        
        return(hr);
    }

    /* Prepare protocol info if QOS is enabled */
    pProtoInfo = (WSAPROTOCOL_INFO *)NULL;
    
    if (RtpBitTest(pRtpAddr->dwIRtpFlags, FGADDR_IRTP_QOS) &&
        !RtpBitTest2(pRtpAddr->dwAddrFlagsQ,
                     FGADDRQ_REGQOSDISABLE, FGADDRQ_QOSNOTALLOWED))
    {
        hr = RtpGetQosEnabledProtocol(&ProtoInfo);

        if (SUCCEEDED(hr))
        {
            pProtoInfo = &ProtoInfo;
        }
    }
    
    bAutoPort = FALSE;
    
    if (!pRtpAddr->wRtpPort[LOCAL_IDX])
    {
        if (IS_MULTICAST(pRtpAddr->dwAddr[REMOTE_IDX]) &&
            pRtpAddr->wRtpPort[REMOTE_IDX])
        {
            /* Assign same port as remote */
            pRtpAddr->wRtpPort[LOCAL_IDX] = pRtpAddr->wRtpPort[REMOTE_IDX];
        }
        else
        {
            /* If local RTP port hasn't been specified, enable auto
             * ports allocation */
            bAutoPort = TRUE;
        }
    }

    if (!pRtpAddr->wRtcpPort[LOCAL_IDX])
    {
        if (IS_MULTICAST(pRtpAddr->dwAddr[REMOTE_IDX]) &&
            pRtpAddr->wRtcpPort[REMOTE_IDX])
        {
            /* Assign same port as remote */
            pRtpAddr->wRtcpPort[LOCAL_IDX] = pRtpAddr->wRtcpPort[REMOTE_IDX];
        }
        else
        {
            /* If RTCP port hasn't been assigned, either, let the
             * system assign it if the RTP port was already assigned,
             * otherwise, auto assign both ports */
        }
    }

    wOldRtcpPort = pRtpAddr->wRtcpPort[LOCAL_IDX];

    bOk = FALSE;
    
    dwMaxAttempts = 1;
    
    if (bAutoPort)
    {
        dwMaxAttempts = 16;
    }

    bOk = RtpEnterCriticalSection(&g_RtpContext.RtpPortsCritSect);

    if (!bOk)
    {
        /* Failed to grab the lock, make sure auto ports allocation is
         * disabled */
        bAutoPort = FALSE;
    }
    
    for(i = 0; i < dwMaxAttempts; i++)
    {
        bGotPorts = FALSE;
        
        for(j = 0; bAutoPort && (j < 64); j++)
        {
            /* Get an even random port */
            dwRandom = RtpRandom32((DWORD_PTR)&dwRandom) & 0xffff;

            if (dwRandom < RTPPORT_LOWER)
            {
                /* Don't want to use a modulo to give all ports the
                 * same chance (the range is not power of 2) */
                continue;
            }
            
            wPort = (WORD) (dwRandom & ~0x1);

            pRtpAddr->wRtpPort[LOCAL_IDX] = htons(wPort);

            if (wOldRtcpPort)
            {
                /* If the RTCP port was specified, do not override it */;
            }
            else
            {
                pRtpAddr->wRtcpPort[LOCAL_IDX] = htons(wPort + 1);
            }

            /* Find out if this RTP port hasn't been allocated */
            pRtpQueueItem = findHdwK(&g_RtpContext.RtpPortsH,
                                     NULL,
                                     (DWORD)wPort);

            if (!pRtpQueueItem)
            {
                /* Port not in use yet by RTP */

                TraceRetail((
                        CLASS_INFO, GROUP_NETWORK, S_NETWORK_SOCK,
                        _T("%s: pRtpAddr[0x%p] Local ports allocated: ")
                        _T("RTP:%u, RTCP:%u"),
                        _fname, pRtpAddr,
                        (DWORD)ntohs(pRtpAddr->wRtpPort[LOCAL_IDX]),
                        (DWORD)ntohs(pRtpAddr->wRtcpPort[LOCAL_IDX])
                    ));
                
                bGotPorts = TRUE;
                
                break;
            }
        }

        if (bAutoPort && !bGotPorts)
        {
            /* If I couldn't get proper port numbers, let the system
             * assign them */
            pRtpAddr->wRtpPort[LOCAL_IDX] = 0;

            if (!wOldRtcpPort)
            {
                pRtpAddr->wRtcpPort[LOCAL_IDX] = 0;
            }
        }
        
        /* RTP socket */
        pRtpAddr->Socket[SOCK_RECV_IDX] = RtpSocket(
                pRtpAddr,
                pProtoInfo,
                RTP_IDX);
    
        pRtpAddr->Socket[SOCK_SEND_IDX] = pRtpAddr->Socket[SOCK_RECV_IDX];

        if (pRtpAddr->Socket[SOCK_RECV_IDX] == INVALID_SOCKET)
        {
            hr = RTPERR_RESOURCES;
            goto end;
        }

        /* At least one socket created, set this flag to allow
         * deletion in case of failure */
        RtpBitSet(pRtpAddr->dwAddrFlags, FGADDR_SOCKET);

        /* RTCP socket */
        pRtpAddr->Socket[SOCK_RTCP_IDX] = RtpSocket(
                pRtpAddr,
                (WSAPROTOCOL_INFO *)NULL,
                RTCP_IDX);

        if (pRtpAddr->Socket[SOCK_RTCP_IDX] == INVALID_SOCKET)
        {
            hr = RTPERR_RESOURCES;
            goto end;
        }

        if (bOk)
        {
            /* Update list of ports, the port used as key is either
             * the one allocated by RTP, the one assigned trhough the
             * API, or the one assigned by the system */
            insertHdwK(&g_RtpContext.RtpPortsH,
                       NULL,
                       &pRtpAddr->PortsQItem,
                       pRtpAddr->wRtpPort[LOCAL_IDX]);

            RtpLeaveCriticalSection(&g_RtpContext.RtpPortsCritSect);

            bOk = FALSE;
        }
        
        TraceRetail((
                CLASS_INFO, GROUP_NETWORK, S_NETWORK_SOCK,
                _T("%s: pRtpAddr[0x%p] Created sockets: %u, %u, %u"),
                _fname, pRtpAddr,
                pRtpAddr->Socket[SOCK_RECV_IDX],
                pRtpAddr->Socket[SOCK_SEND_IDX],
                pRtpAddr->Socket[SOCK_RTCP_IDX]
            ));

        break;
        
    end:
        RtpDelSockets(pRtpAddr);

        TraceRetailWSAGetError(dwError);
    
        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_SOCK,
                _T("%s: pRtpAddr[0x%p] failed to create sockets: %u (0x%X)"),
                _fname, pRtpAddr, dwError, dwError
            ));
    }

    if (bOk)
    {
        /* If none of the attemps to create sockets succeed, I would
         * still have the critical section here, release it */
        RtpLeaveCriticalSection(&g_RtpContext.RtpPortsCritSect);
    }
    
    return(hr);
}

HRESULT RtpDelSockets(RtpAddr_t *pRtpAddr)
{
    DWORD            dwError;
    
    TraceFunctionName("RtpDelSockets");

    /* destroy sockets */

    if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_SOCKET))
    {
        /* sockets already created */

        TraceRetail((
                CLASS_INFO, GROUP_NETWORK, S_NETWORK_SOCK,
                _T("%s: pRtpAddr[0x%p] Deleting sockets: %u, %u, %u"),
                _fname, pRtpAddr,
                pRtpAddr->Socket[SOCK_RECV_IDX],
                pRtpAddr->Socket[SOCK_SEND_IDX],
                pRtpAddr->Socket[SOCK_RTCP_IDX]
            ));
 
        /* RTP */
        if (pRtpAddr->Socket[SOCK_RECV_IDX] != INVALID_SOCKET)
        {
            dwError = closesocket(pRtpAddr->Socket[SOCK_RECV_IDX]);

            if (dwError)
            {
                TraceRetailWSAGetError(dwError);
                
                TraceRetail((
                        CLASS_ERROR, GROUP_NETWORK, S_NETWORK_SOCK,
                        _T("%s: pRtpAddr[0x%p] closesocket(RTP:%u) ")
                        _T("failed: %u (0x%X)"),
                        _fname, pRtpAddr, pRtpAddr->Socket[SOCK_RECV_IDX],
                        dwError, dwError
                    ));
            }

            pRtpAddr->Socket[SOCK_RECV_IDX] = INVALID_SOCKET;
            pRtpAddr->Socket[SOCK_SEND_IDX] = pRtpAddr->Socket[SOCK_RECV_IDX];
        }
        
        /* RTCP */
        if (pRtpAddr->Socket[SOCK_RTCP_IDX] != INVALID_SOCKET)
        {
            dwError = closesocket(pRtpAddr->Socket[SOCK_RTCP_IDX]);
        
            if (dwError)
            {
                TraceRetailWSAGetError(dwError);
                
                TraceRetail((
                        CLASS_ERROR, GROUP_NETWORK, S_NETWORK_SOCK,
                        _T("%s: pRtpAddr[0x%p] closesocket(RTCP:%u) ")
                        _T("failed: %u (0x%X)"),
                        _fname, pRtpAddr, pRtpAddr->Socket[SOCK_RTCP_IDX],
                        dwError, dwError
                    ));
            }
            
            pRtpAddr->Socket[SOCK_RTCP_IDX] = INVALID_SOCKET;
        }

        /* Address might not be in a queue if we are comming here from
         * a failure in RtpGetSockets, this would generate another
         * error in the log */
        removeH(&g_RtpContext.RtpPortsH,
                &g_RtpContext.RtpPortsCritSect,
                &pRtpAddr->PortsQItem);
        
        RtpBitReset(pRtpAddr->dwAddrFlags, FGADDR_SOCKET);
        RtpBitReset(pRtpAddr->dwAddrFlags, FGADDR_SOCKOPT);
    }

    return(NOERROR);
}    

SOCKET RtpSocket(
        RtpAddr_t       *pRtpAddr,
        WSAPROTOCOL_INFO *pProtoInfo,
        DWORD            dwRtpRtcp
    )
{
    DWORD            i;
    SOCKET           Socket;
    int              iSockFlags;
    DWORD            dwPar;
    DWORD            dwError;
    WORD            *pwPort;
    SOCKADDR_IN      LocalAddr;
    int              LocalAddrLen;
    TCHAR_t          sLocalAddr[16];
    
    TraceFunctionName("RtpSocket");

    iSockFlags = WSA_FLAG_OVERLAPPED;

    if (IS_MULTICAST(pRtpAddr->dwAddr[REMOTE_IDX]))
    {
        iSockFlags |=
            (WSA_FLAG_MULTIPOINT_C_LEAF |
             WSA_FLAG_MULTIPOINT_D_LEAF);
    }

    for(i = 0; i < 2; i++)
    {
        Socket = WSASocket(
                AF_INET,    /* int af */
                SOCK_DGRAM, /* int type */
                IPPROTO_IP, /* int protocol */
                pProtoInfo, /* LPWSAPROTOCOL_INFO lpProtocolInfo */
                0,          /* GROUP g */
                iSockFlags  /* DWORD dwFlags */
            );
        
        if (Socket == INVALID_SOCKET)
        {
            TraceRetailWSAGetError(dwError);

            TraceRetail((
                    CLASS_ERROR, GROUP_NETWORK, S_NETWORK_SOCK,
                    _T("%s: pRtpAddr[0x%p] pProtoInfo[0x%p] failed: %u (0x%X)"),
                    _fname, pRtpAddr, pProtoInfo, dwError, dwError
            ));

            if (pProtoInfo && (dwError == WSASYSNOTREADY))
            {
                /* The user credentials do not allow him to start
                 * RSVP, so I get this specific error and need to
                 * disable QOS */
                TraceRetail((
                        CLASS_WARNING, GROUP_NETWORK, S_NETWORK_SOCK,
                        _T("%s: pRtpAddr[0x%p] try again with QOS disabled"),
                        _fname, pRtpAddr
                    ));

                /* Disable QOS */
                pProtoInfo = (WSAPROTOCOL_INFO *)NULL;

                RtpBitSet(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSNOTALLOWED);
            }
        }
        else
        {
            break;
        }
    }

    if (Socket == INVALID_SOCKET)
    {
        return(Socket);
    }

    /* Need to do this before binding, otherwise it may fail if the
     * address is already in use.
     *
     * WARNING Note that option SO_REUSEADDR is used regardless of the
     * destination address (multicast or unicast). Who receives data
     * in a unicast session is unpredicted when multiple (more than 1)
     * sockets are bound to the same address and port
     * */
            
    dwPar = 1; /* Reuse */

    /* Reuse address/port */
    dwError = setsockopt(
            Socket,
            SOL_SOCKET,
            SO_REUSEADDR,
            (PCHAR)&dwPar,
            sizeof(dwPar)
        );
        
    if (dwError == SOCKET_ERROR)
    {
        TraceRetailWSAGetError(dwError);
        
        TraceRetail((
                CLASS_WARNING, GROUP_NETWORK, S_NETWORK_SOCK,
                _T("%s: pRtpAddr[0x%p] setsockoption(SO_REUSEADDR) ")
                _T("failed: %u (0x%X)"),
                _fname, pRtpAddr, dwError, dwError
            ));
    }

    if (dwRtpRtcp == RTP_IDX)
    {
        /* Set receiver buffer size to zero for RTP socket */
        RtpSetRecvBuffSize(pRtpAddr, Socket, 0);

        pwPort = &pRtpAddr->wRtpPort[0];
    }
    else
    {
        pwPort = &pRtpAddr->wRtcpPort[0];
    }
    
    /* bind socket */
    ZeroMemory(&LocalAddr, sizeof(LocalAddr));

    LocalAddr.sin_family = AF_INET;
    LocalAddr.sin_addr = *(struct in_addr *) &pRtpAddr->dwAddr[LOCAL_IDX];
    LocalAddr.sin_port = pwPort[LOCAL_IDX];
            
    /* bind rtp socket to the local address specified */
    dwError = bind(Socket, (SOCKADDR *)&LocalAddr, sizeof(LocalAddr));

    if (dwError == 0)
    {
        /* Get the port */
        LocalAddrLen = sizeof(LocalAddr);
        dwError =
            getsockname(Socket, (struct sockaddr *)&LocalAddr, &LocalAddrLen);

        if (dwError == 0)
        {
            pwPort[LOCAL_IDX] = LocalAddr.sin_port;
            
            TraceDebug((
                    CLASS_INFO, GROUP_NETWORK, S_NETWORK_SOCK,
                    _T("%s: getsockname: %u:%u/%s/%u"),
                    _fname, Socket,
                    LocalAddr.sin_family,
                    RtpNtoA(LocalAddr.sin_addr.s_addr, sLocalAddr),
                    ntohs(LocalAddr.sin_port)
                ));
        }
        else
        {
            TraceRetailWSAGetError(dwError);
        
            TraceRetail((
                    CLASS_ERROR, GROUP_NETWORK, S_NETWORK_SOCK,
                    _T("%s: getsockname socket:%u failed: %u (0x%X)"),
                    _fname, Socket, dwError, dwError
                ));
        
            closesocket(Socket);

            return(INVALID_SOCKET);
        }
    }
    else
    {
        TraceRetailWSAGetError(dwError);
        
        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_SOCK,
                _T("%s: bind socket:%u to port:%u failed: %u (0x%X)"),
                _fname, Socket,
                ntohs(LocalAddr.sin_port), dwError, dwError
            ));
        
        closesocket(Socket);

        return(INVALID_SOCKET);
    }


    return(Socket);
}

BOOL RtpSetTTL(SOCKET Socket, DWORD dwTTL, BOOL bMcast)
{
    DWORD            dwStatus;
    DWORD            dwError;
    DWORD            bOK;

    TraceFunctionName("RtpSetTTL");

    dwStatus = setsockopt( 
            Socket,
            IPPROTO_IP, 
            bMcast? IP_MULTICAST_TTL : IP_TTL,
            (PCHAR)&dwTTL,
            sizeof(dwTTL)
        );

    if (dwStatus == SOCKET_ERROR)
    {
        bOK = FALSE;

        TraceRetailWSAGetError(dwError);
            
        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_TTL,
                _T("%s: Socket:%u TTL:%d failed: %u (0x%X)"),
                _fname, Socket, dwTTL, dwError, dwError
            ));
    }
    else
    {
        bOK = TRUE;

        TraceRetail((
                CLASS_INFO, GROUP_NETWORK, S_NETWORK_TTL,
                _T("%s: Socket:%u TTL:%d"),
                _fname, Socket, dwTTL
            ));
    }
    
    return(bOK);
}

BOOL RtpSetMcastSendIF(SOCKET Socket, DWORD dwAddr)
{
    DWORD            dwStatus;
    DWORD            dwError;
    DWORD            bOK;
    TCHAR_t          sAddr[16];
    
    TraceFunctionName("RtpSetMcastSendIF");

    dwStatus = setsockopt( 
            Socket,
            IPPROTO_IP, 
            IP_MULTICAST_IF,
            (char *)&dwAddr,
            sizeof(dwAddr)
        );

    if (dwStatus == SOCKET_ERROR)
    {
        bOK = FALSE;

        TraceRetailWSAGetError(dwError);
            
        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_MULTICAST,
                _T("%s: Socket:%u IP_MULTICAST_IF(%s) failed: %u (0x%X)"),
                _fname, Socket, RtpNtoA(dwAddr, sAddr),
                dwError, dwError
            ));
    }
    else
    {
        bOK = TRUE;

        TraceRetail((
                CLASS_INFO, GROUP_NETWORK, S_NETWORK_MULTICAST,
                _T("%s: Socket:%u using:%s"),
                _fname, Socket, RtpNtoA(dwAddr, sAddr)
            ));
    }
    
    return(bOK);
}

BOOL RtpSetWinSockLoopback(SOCKET Socket, BOOL bEnabled)
{
    DWORD            dwStatus;
    DWORD            dwPar;
    DWORD            dwError;
    DWORD            bOK;

    TraceFunctionName("RtpSetWinSockLoopback");
    
    dwPar = bEnabled? 1:0;
    
    /* Allow own packets to come back */
    dwStatus = setsockopt(
            Socket,
            IPPROTO_IP,
            IP_MULTICAST_LOOP,
            (PCHAR)&dwPar,
            sizeof(dwPar)
        );
        
    if (dwStatus == SOCKET_ERROR)
    {
        bOK = FALSE;
        
        TraceRetailWSAGetError(dwError);
            
        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_MULTICAST,
                _T("%s: Socket:%u Loopback:%d failed: %u (0x%X)"),
                _fname, Socket, dwPar, dwError, dwError
            ));
    }
    else
    {
        bOK = TRUE;

        TraceRetail((
                CLASS_INFO, GROUP_NETWORK, S_NETWORK_MULTICAST,
                _T("%s: Socket:%u Loopback:%d"),
                _fname, Socket, dwPar
            ));
    }
    
    return(bOK);
}

BOOL RtpJoinLeaf(SOCKET Socket, DWORD dwAddr, WORD wPort)
{
    BOOL             bOk;
    DWORD            dwError;
    SOCKADDR_IN      JoinAddr;
    DWORD            dwJoinDirection;
    SOCKET           TmpSocket;
    TCHAR_t          sAddr[16];
                    
    TraceFunctionName("RtpJoinLeaf");

    ZeroMemory(&JoinAddr, sizeof(JoinAddr));
        
    JoinAddr.sin_family = AF_INET;
    JoinAddr.sin_addr = *(struct in_addr *) &dwAddr;
    JoinAddr.sin_port = wPort;

    /* Join in both directions */
    dwJoinDirection = JL_RECEIVER_ONLY | JL_SENDER_ONLY;
            
    TmpSocket = WSAJoinLeaf(Socket,
                            (const struct sockaddr *)&JoinAddr,
                            sizeof(JoinAddr),
                            NULL, NULL, NULL, NULL,
                            dwJoinDirection);

    if (TmpSocket == INVALID_SOCKET) {

        TraceRetailWSAGetError(dwError);
                
        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_MULTICAST,
                _T("%s: WSAJoinLeaf failed: %u:%s/%u %u (0x%X)"),
                _fname,
                Socket, RtpNtoA(dwAddr, sAddr), ntohs(wPort),
                dwError, dwError
            ));

        bOk = FALSE;
    }
    else
    {
        TraceRetail((
                CLASS_INFO, GROUP_NETWORK, S_NETWORK_MULTICAST,
                _T("%s: WSAJoinLeaf: %u:%s/%u"),
                _fname,
                Socket, RtpNtoA(dwAddr, sAddr), ntohs(wPort)
            ));

        bOk = TRUE;
    }

    return(bOk);
}

void RtpSetSockOptions(RtpAddr_t *pRtpAddr)
{
    TraceFunctionName("RtpSetSockOptions");

    if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_SOCKOPT))
    {
        TraceRetail((
                CLASS_WARNING, GROUP_NETWORK, S_NETWORK_SOCK,
                _T("%s: Socket options already set"),
                _fname
            ));
        
        return;
    }
    
    if (IS_MULTICAST(pRtpAddr->dwAddr[REMOTE_IDX]))
    {
        /* Set TTL  */
        if (!pRtpAddr->dwTTL[0])
        {
            pRtpAddr->dwTTL[0] = DEFAULT_MCAST_TTL;
        }
        if (!pRtpAddr->dwTTL[1])
        {
            pRtpAddr->dwTTL[1] = DEFAULT_MCAST_TTL;
        }

        RtpSetTTL(pRtpAddr->Socket[SOCK_SEND_IDX], pRtpAddr->dwTTL[0], TRUE);
        
        RtpSetTTL(pRtpAddr->Socket[SOCK_RTCP_IDX], pRtpAddr->dwTTL[1], TRUE);

        /* Set multicast sending interface */
        RtpSetMcastSendIF(pRtpAddr->Socket[SOCK_SEND_IDX],
                          pRtpAddr->dwAddr[LOCAL_IDX]);

        RtpSetMcastSendIF(pRtpAddr->Socket[SOCK_RTCP_IDX],
                          pRtpAddr->dwAddr[LOCAL_IDX]);
        
        /* Set Mcast loopback */
        RtpSetWinSockLoopback(pRtpAddr->Socket[SOCK_RECV_IDX],
                              RtpBitTest(pRtpAddr->dwAddrFlags,
                                         FGADDR_LOOPBACK_WS2));
        
        RtpSetWinSockLoopback(pRtpAddr->Socket[SOCK_RTCP_IDX],
                              RtpBitTest(pRtpAddr->dwAddrFlags,
                                         FGADDR_LOOPBACK_WS2));
        
        /* Join leaf */
        RtpJoinLeaf(pRtpAddr->Socket[SOCK_RECV_IDX],
                    pRtpAddr->dwAddr[REMOTE_IDX],
                    pRtpAddr->wRtpPort[REMOTE_IDX]);

        RtpJoinLeaf(pRtpAddr->Socket[SOCK_RTCP_IDX],
                    pRtpAddr->dwAddr[REMOTE_IDX],
                    pRtpAddr->wRtcpPort[REMOTE_IDX]);
    }
    else
    {
        /* Set TTL  */
        if (!pRtpAddr->dwTTL[0])
        {
            pRtpAddr->dwTTL[0] = DEFAULT_UCAST_TTL;
        }
        if (!pRtpAddr->dwTTL[1])
        {
            pRtpAddr->dwTTL[1] = DEFAULT_UCAST_TTL;
        }

        RtpSetTTL(pRtpAddr->Socket[SOCK_RECV_IDX], pRtpAddr->dwTTL[0], FALSE);

        RtpSetTTL(pRtpAddr->Socket[SOCK_RTCP_IDX], pRtpAddr->dwTTL[1], FALSE);
    }

    RtpBitSet(pRtpAddr->dwAddrFlags, FGADDR_SOCKOPT);
}

/* Sets the recv buffer size */
DWORD RtpSetRecvBuffSize(
        RtpAddr_t       *pRtpAddr,
        SOCKET           Socket,
        int              iBuffSize
    )
{
    DWORD            dwError;
    
    TraceFunctionName("RtpSetRecvBuffSize");
    
    /* Set buffer size */
    dwError = setsockopt(Socket,
                         SOL_SOCKET,
                         SO_RCVBUF,
                         (char *)&iBuffSize,
                         sizeof(iBuffSize));

    if (dwError)
    {
        TraceRetailWSAGetError(dwError);

        TraceRetail((
                CLASS_WARNING, GROUP_NETWORK, S_NETWORK_SOCK,
                _T("%s: pRtpAddr[0x%p] setsockopt(%u, SO_RCVBUF, %d) ")
                _T("failed: %u (0x%X)"),
                _fname, pRtpAddr, Socket, iBuffSize, dwError, dwError
            ));

        return(RTPERR_WS2RECV);
    }

    TraceRetail((
            CLASS_INFO, GROUP_NETWORK, S_NETWORK_SOCK,
            _T("%s: pRtpAddr[0x%p] setsockopt(%u, SO_RCVBUF, %d)"),
            _fname, pRtpAddr, Socket, iBuffSize
        ));

    return(NOERROR);
}
        
/* Set the multicast loopback mode (e.g. RTPMCAST_LOOPBACKMODE_NONE,
 * RTPMCAST_LOOPBACKMODE_PARTIAL, etc) */
HRESULT RtpSetMcastLoopback(
        RtpAddr_t       *pRtpAddr,
        int              iMcastLoopbackMode,
        DWORD            dwFlags /* Not used now */
    )
{
    HRESULT          hr;

    TraceFunctionName("RtpSetMcastLoopback");

    if (!pRtpAddr)
    {
        /* Having this as a NULL pointer means Init hasn't been
         * called, return this error instead of RTPERR_POINTER to be
         * consistent */
        hr = RTPERR_INVALIDSTATE;

        goto end;
    }
    
    if (!iMcastLoopbackMode ||
        iMcastLoopbackMode >= RTPMCAST_LOOPBACKMODE_LAST)
    {
        hr = RTPERR_INVALIDARG;

        goto end;
    }

    hr = NOERROR;

    if (IsRegValueSet(g_RtpReg.dwMcastLoopbackMode) &&
        g_RtpReg.dwMcastLoopbackMode != (DWORD)iMcastLoopbackMode)
    {
        /* If I set multicast loopback mode in the registry, USE IT!  */

        TraceRetail((
                CLASS_WARNING, GROUP_NETWORK, S_NETWORK_MULTICAST,
                _T("%s: Multicast mode:%d ignored, using the registry:%d"),
                _fname, iMcastLoopbackMode, g_RtpReg.dwMcastLoopbackMode
            ));
        
        return(hr);
    }
    
    switch(iMcastLoopbackMode)
    {
    case RTPMCAST_LOOPBACKMODE_NONE:
        RtpBitReset(pRtpAddr->dwAddrFlags, FGADDR_LOOPBACK_WS2);
        RtpBitSet  (pRtpAddr->dwAddrFlags, FGADDR_LOOPBACK_SFT);
        RtpBitSet  (pRtpAddr->dwAddrFlags, FGADDR_COLLISION);
        break;
    case RTPMCAST_LOOPBACKMODE_PARTIAL:
        RtpBitSet  (pRtpAddr->dwAddrFlags, FGADDR_LOOPBACK_WS2);
        RtpBitReset(pRtpAddr->dwAddrFlags, FGADDR_LOOPBACK_SFT);
        RtpBitSet  (pRtpAddr->dwAddrFlags, FGADDR_COLLISION);
        break;
    case RTPMCAST_LOOPBACKMODE_FULL:
        RtpBitSet  (pRtpAddr->dwAddrFlags, FGADDR_LOOPBACK_WS2);
        RtpBitSet  (pRtpAddr->dwAddrFlags, FGADDR_LOOPBACK_SFT);
        RtpBitReset(pRtpAddr->dwAddrFlags, FGADDR_COLLISION);
        break;
    }

 end:
    if (SUCCEEDED(hr))
    {
        TraceRetail((
                CLASS_INFO, GROUP_NETWORK, S_NETWORK_MULTICAST,
                _T("%s: Multicast mode:%d"),
                _fname, iMcastLoopbackMode
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_MULTICAST,
                _T("%s: settting mode %d failed: %u (0x%X)"),
                _fname, iMcastLoopbackMode, hr, hr
            ));
    }
    
    return(hr);
}

HRESULT RtpNetMute(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwFlags
    )
{
    RtpSess_t       *pRtpSess;

    TraceFunctionName("RtpNetMute");

    pRtpSess = pRtpAddr->pRtpSess;
    
    if (dwFlags & pRtpAddr->dwAddrFlags & RtpBitPar(FGADDR_ISRECV))
    {
        /* Discard all RTP packets received from now on */
        RtpBitSet(pRtpAddr->dwAddrFlags, FGADDR_MUTERTPRECV);
        
        /* Don't want more events */
        RtpBitReset(pRtpSess->dwSessFlags, FGSESS_EVENTRECV);

        if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_QOSRECVON))
        {
            /* Unreserve QOS */
            RtcpThreadCmd(&g_RtcpContext,
                          pRtpAddr,
                          RTCPTHRD_UNRESERVE,
                          RECV_IDX,
                          0);

            RtpBitReset(pRtpAddr->dwAddrFlags, FGADDR_QOSRECVON);
        }

        TraceRetail((
                CLASS_INFO, GROUP_NETWORK, S_NETWORK_ADDR,
                _T("%s: pRtpAddr[0x%p] RECV muted"),
                _fname, pRtpAddr
            ));
    }

    if (dwFlags & pRtpAddr->dwAddrFlags & RtpBitPar(FGADDR_ISSEND))
    {
        /* Don't send any more RTP packets */
        RtpBitSet(pRtpAddr->dwAddrFlags, FGADDR_MUTERTPSEND);
        
        /* Don't want more events */
        RtpBitReset(pRtpSess->dwSessFlags, FGSESS_EVENTSEND);

        if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_QOSSENDON))
        {
            /* Unreserve QOS (stop sending PATH messages) */
            RtcpThreadCmd(&g_RtcpContext,
                          pRtpAddr,
                          RTCPTHRD_UNRESERVE,
                          SEND_IDX,
                          DO_NOT_WAIT);

            RtpBitReset(pRtpAddr->dwAddrFlags, FGADDR_QOSSENDON);
        }
        
        TraceRetail((
                CLASS_INFO, GROUP_NETWORK, S_NETWORK_ADDR,
                _T("%s: pRtpAddr[0x%p] SEND muted"),
                _fname, pRtpAddr
            ));
    }

    return(NOERROR);
}

HRESULT RtpNetUnmute(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwFlags
    )
{
    HRESULT          hr;
    RtpSess_t       *pRtpSess;
    
    TraceFunctionName("RtpNetUnmute");

    pRtpSess = pRtpAddr->pRtpSess;

    if (dwFlags & pRtpAddr->dwAddrFlags & RtpBitPar(FGADDR_ISRECV))
    {
        /* Reset counters */
        RtpResetNetCount(&pRtpAddr->RtpAddrCount[RECV_IDX],
                         &pRtpAddr->NetSCritSect);

        if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_QOSRECV) &&
            RtpBitTest(pRtpAddr->dwAddrFlagsQ, FGADDRQ_RECVFSPEC_DEFINED) &&
            !RtpBitTest2(pRtpAddr->dwAddrFlagsQ,
                         FGADDRQ_REGQOSDISABLE, FGADDRQ_QOSNOTALLOWED))
        {
            /* NOTE: the test above is also done in RtpRealStart */
            
            /* Make a QOS reservation */
            hr = RtcpThreadCmd(&g_RtcpContext,
                               pRtpAddr,
                               RTCPTHRD_RESERVE,
                               RECV_IDX,
                               DO_NOT_WAIT);

            if (SUCCEEDED(hr))
            {
                RtpBitSet(pRtpAddr->dwAddrFlags, FGADDR_QOSRECVON);
            }
        }

        /* Re-enable events (provided the mask has some events
         * enabled) */
        RtpBitSet(pRtpSess->dwSessFlags, FGSESS_EVENTRECV);

        /* Continue processing RTP packets received */
        RtpBitReset(pRtpAddr->dwAddrFlags, FGADDR_MUTERTPRECV);

        TraceRetail((
                CLASS_INFO, GROUP_NETWORK, S_NETWORK_ADDR,
                _T("%s: pRtpAddr[0x%p] RECV unmuted"),
                _fname, pRtpAddr
            ));
    }

    if (dwFlags & pRtpAddr->dwAddrFlags & RtpBitPar(FGADDR_ISSEND))
    {
        /* Reset counters */
        RtpResetNetCount(&pRtpAddr->RtpAddrCount[SEND_IDX],
                         &pRtpAddr->NetSCritSect);

        /* Reset sender's network state */
        RtpResetNetSState(&pRtpAddr->RtpNetSState,
                          &pRtpAddr->NetSCritSect);
        
        if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_QOSSEND) &&
            RtpBitTest(pRtpAddr->dwAddrFlagsQ, FGADDRQ_SENDFSPEC_DEFINED) &&
            !RtpBitTest2(pRtpAddr->dwAddrFlagsQ,
                         FGADDRQ_REGQOSDISABLE, FGADDRQ_QOSNOTALLOWED))
        {
            /* NOTE: the test above is also done in RtpRealStart */
            
            /* Make a QOS reservation */
            hr = RtcpThreadCmd(&g_RtcpContext,
                               pRtpAddr,
                               RTCPTHRD_RESERVE,
                               SEND_IDX,
                               DO_NOT_WAIT);
            
            if (SUCCEEDED(hr))
            {
                RtpBitSet(pRtpAddr->dwAddrFlags, FGADDR_QOSSENDON);
            }
        }

        /* Re-enable events (provided the mask has some events
         * enabled) */
        RtpBitSet(pRtpSess->dwSessFlags, FGSESS_EVENTSEND);

        /* Continue processing RTP packets received */
        RtpBitReset(pRtpAddr->dwAddrFlags, FGADDR_MUTERTPSEND);
        
        TraceRetail((
                CLASS_INFO, GROUP_NETWORK, S_NETWORK_ADDR,
                _T("%s: pRtpAddr[0x%p] SEND unmuted"),
                _fname, pRtpAddr
            ));
    }

    return(NOERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\msrtp\funcs\rtpcrypt.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpcrypt.c
 *
 *  Abstract:
 *
 *    Implements the Cryptography family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/07 created
 *
 **********************************************************************/

#include "rtpglobs.h"

#include "rtpcrypt.h"

RtpCrypt_t *RtpCryptAlloc(
        RtpAddr_t       *pRtpAddr
    );

void RtpCryptFree(RtpCrypt_t *pRtpCrypt);

DWORD RtpSetEncryptionKey_(
        RtpAddr_t       *pRtpAddr,
        RtpCrypt_t      *pRtpCrypt,
        TCHAR           *psPassPhrase,
        TCHAR           *psHashAlg,
        TCHAR           *psDataAlg
    );

ALG_ID RtpCryptAlgLookup(TCHAR *psAlgName);

TCHAR *RtpCryptAlgName(ALG_ID aiAlgId);

DWORD RtpTestCrypt(
        RtpAddr_t       *pRtpAddr,
        RtpCrypt_t      *pRtpCrypt
    );

HRESULT ControlRtpCrypt(RtpControlStruct_t *pRtpControlStruct)
{

    return(NOERROR);
}

typedef struct _RtpAlgId_t {
    TCHAR           *AlgName;
    ALG_ID           aiAlgId;
} RtpAlgId_t;

#define INVALID_ALGID      ((ALG_ID)-1)

const RtpAlgId_t g_RtpAlgId[] = {
   { _T("Unknown"),            -1},
   { _T("MD2"),                CALG_MD2},
   { _T("MD4"),                CALG_MD4},
   { _T("MD5"),                CALG_MD5},
   { _T("SHA"),                CALG_SHA},
   { _T("SHA1"),               CALG_SHA1},
   { _T("MAC"),                CALG_MAC},
   { _T("RSA_SIGN"),           CALG_RSA_SIGN},
   { _T("DSS_SIGN"),           CALG_DSS_SIGN},
   { _T("RSA_KEYX"),           CALG_RSA_KEYX},
   { _T("DES"),                CALG_DES},
   { _T("3DES_112"),           CALG_3DES_112},
   { _T("3DES"),               CALG_3DES},
   { _T("DESX"),               CALG_DESX},
   { _T("RC2"),                CALG_RC2},
   { _T("RC4"),                CALG_RC4},
   { _T("SEAL"),               CALG_SEAL},
   { _T("DH_SF"),              CALG_DH_SF},
   { _T("DH_EPHEM"),           CALG_DH_EPHEM},
   { _T("AGREEDKEY_ANY"),      CALG_AGREEDKEY_ANY},
   { _T("KEA_KEYX"),           CALG_KEA_KEYX},
   { _T("HUGHES_MD5"),         CALG_HUGHES_MD5},
   { _T("SKIPJACK"),           CALG_SKIPJACK},
   { _T("TEK"),                CALG_TEK},
   { _T("CYLINK_MEK"),         CALG_CYLINK_MEK},
   { _T("SSL3_SHAMD5"),        CALG_SSL3_SHAMD5},
   { _T("SSL3_MASTER"),        CALG_SSL3_MASTER},
   { _T("SCHANNEL_MASTER_HASH"),CALG_SCHANNEL_MASTER_HASH},
   { _T("SCHANNEL_MAC_KEY"),   CALG_SCHANNEL_MAC_KEY},
   { _T("SCHANNEL_ENC_KEY"),   CALG_SCHANNEL_ENC_KEY},
   { _T("PCT1_MASTER"),        CALG_PCT1_MASTER},
   { _T("SSL2_MASTER"),        CALG_SSL2_MASTER},
   { _T("TLS1_MASTER"),        CALG_TLS1_MASTER},
   { _T("RC5"),                CALG_RC5},
   { _T("HMAC"),               CALG_HMAC},
   { _T("TLS1PRF"),            CALG_TLS1PRF},
   {NULL,                      0}
};

/* Creates and initializes a ready to use RtpCrypt_t structure */
RtpCrypt_t *RtpCryptAlloc(
        RtpAddr_t       *pRtpAddr
    )
{
    DWORD            dwError;
    RtpCrypt_t      *pRtpCrypt;

    TraceFunctionName("RtpCryptAlloc");

    pRtpCrypt = RtpHeapAlloc(g_pRtpCryptHeap, sizeof(RtpCrypt_t));

    if (!pRtpCrypt)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_ALLOC,
                _T("%s: pRtpAddr[0x%p] failed to allocate memory"),
                _fname, pRtpAddr
            ));

        goto bail;
    }

    ZeroMemory(pRtpCrypt, sizeof(RtpCrypt_t));
        
    pRtpCrypt->dwObjectID = OBJECTID_RTPCRYPT;

    pRtpCrypt->pRtpAddr = pRtpAddr;
    
    /* Set default provider type */
    pRtpCrypt->dwProviderType = PROV_RSA_FULL;

    /* Set default hashing algorithm */
    pRtpCrypt->aiHashAlgId = CALG_MD5;

    /* Set default data encryption algorithm */
    pRtpCrypt->aiDataAlgId = CALG_DES;

 bail:
    return(pRtpCrypt);
}

void RtpCryptFree(RtpCrypt_t *pRtpCrypt)
{
    long             lRefCount;
    
    TraceFunctionName("RtpCryptFree");

    if (!pRtpCrypt)
    {
        /* TODO may be log */
        return;
    }

    if (pRtpCrypt->dwObjectID != OBJECTID_RTPCRYPT)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_ALLOC,
                _T("%s: pRtpCrypt[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpCrypt,
                pRtpCrypt->dwObjectID, OBJECTID_RTPCRYPT
            ));

        return;
    }

    if (pRtpCrypt->lCryptRefCount != 0)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_ALLOC,
                _T("%s: pRtpCrypt[0x%p] Invalid RefCount:%d"),
                _fname, pRtpCrypt,
                pRtpCrypt->lCryptRefCount
            ));
    }
    
    /* Invalidate object */
    INVALIDATE_OBJECTID(pRtpCrypt->dwObjectID);
    
    /* Release when count reaches 0 */
    RtpHeapFree(g_pRtpCryptHeap, pRtpCrypt);

    TraceDebug((
            CLASS_INFO, GROUP_CRYPTO, S_CRYPTO_ALLOC,
            _T("%s: pRtpCrypt[0x%p] released"),
            _fname, pRtpCrypt
        ));
}

DWORD RtpCryptInit(
        RtpAddr_t       *pRtpAddr,
        RtpCrypt_t      *pRtpCrypt
    )
{
    BOOL             bOk;
    DWORD            dwError;
    DWORD            dwFlags;
    long             lRefCount;

    TraceFunctionName("RtpCryptInit");

    dwFlags = 0;
    dwError = NOERROR;

    lRefCount = InterlockedIncrement(&pRtpCrypt->lCryptRefCount);

    if (lRefCount > 1)
    {
        /* Initialize only once */
        goto bail;
    }

    /* Verify a pass phrase has been set */
    if (!RtpBitTest(pRtpCrypt->dwCryptFlags, FGCRYPT_KEY))
    {
        dwError = RTPERR_INVALIDSTATE;
        
        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                _T("No pass phrase has been set"),
                _fname, pRtpAddr, pRtpCrypt
            ));

        goto bail;
    }
    
    /*
     * Acquire context
     * */
    do {
        bOk = CryptAcquireContext(
                &pRtpCrypt->hProv, /* HCRYPTPROV *phProv */
                NULL,              /* LPCTSTR pszContainer */
                NULL,              /* LPCTSTR pszProvider */
                pRtpCrypt->dwProviderType,/* DWORD dwProvType */
                dwFlags            /* DWORD dwFlags */
            );
        
        if (bOk)
        {
            break;
        }
        else
        {
            if (GetLastError() == NTE_BAD_KEYSET)
            {
                /* If key doesn't exist, create it */
                dwFlags = CRYPT_NEWKEYSET;
            }
            else
            {
                /* Failed */
                TraceRetailGetError(dwError);

                TraceRetail((
                        CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                        _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                        _T("CryptAcquireContext failed: %u (0x%X)"),
                        _fname, pRtpAddr, pRtpCrypt,
                        dwError, dwError
                    ));

                goto bail;
            }
        }
    } while(dwFlags);

    /*
     * Create hash
     * */

    /* Create a hash object */
    bOk = CryptCreateHash(
            pRtpCrypt->hProv,       /* HCRYPTPROV hProv */
            pRtpCrypt->aiHashAlgId, /* ALG_ID Algid */  
            0,                      /* HCRYPTKEY hKey */
            0,                      /* DWORD dwFlags */
            &pRtpCrypt->hHash       /* HCRYPTHASH *phHash */
        );

    if (!bOk)
    {
        TraceRetailGetError(dwError);

        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                _T("CryptCreateHash failed: %u (0x%X)"),
                _fname, pRtpAddr, pRtpCrypt,
                dwError, dwError
            ));
        
        goto bail;
    }
    
    /*
     * Hash the password string *
     * */
    bOk = CryptHashData(
            pRtpCrypt->hHash,       /* HCRYPTHASH hHash */
            pRtpCrypt->psPassPhrase,/* BYTE *pbData */
            pRtpCrypt->iKeySize,    /* DWORD dwDataLen */
            0                       /* DWORD dwFlags */
        );
            
    if (!bOk)
    {
        TraceRetailGetError(dwError);

        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                _T("CryptHashData failed: %u (0x%X)"),
                _fname, pRtpAddr, pRtpCrypt,
                dwError, dwError
            ));
        
        goto bail;
    }

    /*
     * Create data key
     * */

    bOk = CryptDeriveKey(
            pRtpCrypt->hProv,       /* HCRYPTPROV hProv */
            pRtpCrypt->aiDataAlgId, /* ALG_ID Algid */
            pRtpCrypt->hHash,       /* HCRYPTHASH hBaseData */
            CRYPT_EXPORTABLE,       /* DWORD dwFlags */
            &pRtpCrypt->hDataKey    /* HCRYPTKEY *phKey */
        );

    if (!bOk)
    {
        TraceRetailGetError(dwError);

        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                _T("CryptDeriveKey failed: %u (0x%X)"),
                _fname, pRtpAddr, pRtpCrypt,
                dwError, dwError
            ));

        goto bail;
    }

    RtpBitSet(pRtpCrypt->dwCryptFlags, FGCRYPT_INIT);
    
 bail:
    if (dwError == NOERROR)
    {
        TraceDebug((
                CLASS_INFO, GROUP_CRYPTO, S_CRYPTO_INIT,
                _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                _T("Cryptographic context initialized %d"),
                _fname, pRtpAddr, pRtpCrypt,
                lRefCount - 1
            ));
    }
    else
    {
        RtpCryptDel(pRtpAddr, pRtpCrypt);

        dwError = RTPERR_CRYPTO;
    }
    
    return(dwError);
}

DWORD RtpCryptDel(RtpAddr_t *pRtpAddr, RtpCrypt_t *pRtpCrypt)
{
    long             lRefCount;

    TraceFunctionName("RtpCryptDel");

    lRefCount = InterlockedDecrement(&pRtpCrypt->lCryptRefCount);

    if (lRefCount > 0)
    {
        /* If there are still references to this context, do not
         * de-initialize */
        goto bail;
    }
    
    RtpBitReset(pRtpCrypt->dwCryptFlags, FGCRYPT_INIT);
    
    /* Destroy the session key */
    if(pRtpCrypt->hDataKey)
    {
        CryptDestroyKey(pRtpCrypt->hDataKey);

        pRtpCrypt->hDataKey = 0;
    }

    /* Destroy the hash object */
    if (pRtpCrypt->hHash)
    {
        CryptDestroyHash(pRtpCrypt->hHash);

        pRtpCrypt->hHash = 0;
    }
    
    /* Release the provider handle */
    if(pRtpCrypt->hProv)
    {
        CryptReleaseContext(pRtpCrypt->hProv, 0);

        pRtpCrypt->hProv = 0;
    }

 bail:
    TraceDebug((
            CLASS_INFO, GROUP_CRYPTO, S_CRYPTO_INIT,
            _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
            _T("Cryptographic context de-initialized %d"),
            _fname, pRtpAddr, pRtpCrypt,
            lRefCount
        ));
    
   return(NOERROR);
}

/* This function copies all the buffers into 1 before encrypting on
 * the same memory, I don't want to modify the original data as it
 * might be used somewhere else */
DWORD RtpEncrypt(
        RtpAddr_t       *pRtpAddr,
        RtpCrypt_t      *pRtpCrypt,
        WSABUF          *pWSABuf,
        DWORD            dwWSABufCount,
        char            *pCryptBuffer,
        DWORD            dwCryptBufferLen
    )
{
    BOOL             bOk;
    DWORD            dwError;
    WSABUF          *pWSABuf0;
    DWORD            i;
    char            *ptr;
    DWORD            dwBufLen;
    DWORD            dwDataLen;

    TraceFunctionName("RtpEncrypt");

    dwError = RTPERR_OVERRUN;

    pWSABuf0 = pWSABuf;
    ptr = pCryptBuffer;
    dwBufLen = dwCryptBufferLen;

    for(; dwWSABufCount > 0; dwWSABufCount--)
    {
        if (pWSABuf->len > dwBufLen)
        {
            break;
        }
        
        CopyMemory(ptr, pWSABuf->buf, pWSABuf->len);

        ptr += pWSABuf->len;
        dwBufLen -= pWSABuf->len;
        pWSABuf++;
    }

    if (!dwWSABufCount)
    {
        dwError = NOERROR;
    
        dwDataLen = (DWORD) (ptr - pCryptBuffer);

        /* As build 2195 CryptEncrypt AVs with a key=0 */
#if 1
        bOk = CryptEncrypt(
                pRtpCrypt->hDataKey,           /* HCRYPTKEY hKey */
                0,                             /* HCRYPTHASH hHash */
                TRUE,                          /* BOOL Final */
                0,                             /* DWORD dwFlags */
                (BYTE *)pCryptBuffer,          /* BYTE *pbData */
                &dwDataLen,                    /* DWORD *pdwDataLen */
                dwCryptBufferLen               /* DWORD dwBufLen */
            );
#else
        dwDataLen += 31;
        bOk = TRUE;
#endif
        if (bOk)
        {
            pWSABuf0->buf = pCryptBuffer;
            pWSABuf0->len = dwDataLen;
        }
        else
        {
            TraceRetailGetError(dwError);
            
            pRtpCrypt->dwCryptLastError = dwError;

            TraceRetail((
                    CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_ENCRYPT,
                    _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                    _T("Encryption failed: %u (0x%X)"),
                    _fname, pRtpAddr, pRtpCrypt,
                    dwError, dwError
                ));

            dwError = RTPERR_ENCRYPT;
        }
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_ENCRYPT,
                _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                _T("Overrun error: %u > %u"),
                _fname, pRtpAddr, pRtpCrypt,
                pWSABuf->len, dwBufLen
            ));
    }

    return(dwError);
}

/* Decrypt data on same buffer, decrypted buffer will be shorter or
 * equal the encrypted one */
DWORD RtpDecrypt(
        RtpAddr_t       *pRtpAddr,
        RtpCrypt_t      *pRtpCrypt,
        char            *pEncryptedData,
        DWORD           *pdwEncryptedDataLen
    )
{
    DWORD            dwError;
    BOOL             bOk;

    TraceFunctionName("RtpDecrypt");

    dwError = NOERROR;
#if 1
    bOk = CryptDecrypt(
            pRtpCrypt->hDataKey,   /* HCRYPTKEY hKey */
            0,                     /* HCRYPTHASH hHash */
            TRUE,                  /* BOOL Final */
            0,                     /* DWORD dwFlags */
            (BYTE *)pEncryptedData,/* BYTE *pbData */
            pdwEncryptedDataLen    /* DWORD *pdwDataLen */
        );
#else
    *pdwEncryptedDataLen -= 31;
    bOk = TRUE;
#endif
    if (!bOk)
    {
        TraceRetailGetError(dwError);

        pRtpCrypt->dwCryptLastError = dwError;
  
        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_DECRYPT,
                _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                _T("Decryption failed: %u (0x%X)"),
                _fname, pRtpAddr, pRtpCrypt,
                dwError, dwError
            ));

        dwError = RTPERR_DECRYPT;
    }

    return(dwError);
}

DWORD RtpCryptSetup(RtpAddr_t *pRtpAddr)
{
    DWORD            dwError;
    DWORD            last;
    DWORD            i;
    int              iMode;
    RtpCrypt_t      *pRtpCrypt;
    
    TraceFunctionName("RtpCryptSetup");

    dwError = NOERROR;

    iMode = pRtpAddr->dwCryptMode & 0xffff;
    
        
    if (iMode < RTPCRYPTMODE_ALL)
    {
        /* Create contexts for RECV and SEND */
        last = CRYPT_SEND_IDX;
    }
    else
    {
        /* Create contexts for RECV, SEND and RTCP */
        last = CRYPT_RTCP_IDX;
    }

    /* Create as many cryptographic contexts as requested */
    for(i = CRYPT_RECV_IDX; i <= last; i++)
    {
        pRtpCrypt = RtpCryptAlloc(pRtpAddr);

        if (!pRtpCrypt)
        {
            TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                _T("%s: pRtpAddr[0x%p] failed"),
                _fname, pRtpAddr
            ));

            dwError = RTPERR_MEMORY;
            
            goto bail;
        }

        pRtpAddr->pRtpCrypt[i] = pRtpCrypt;
    }

    /* Allocate memory for encryption buffers */

    for(i = 0; i < 2; i++)
    {
        if (!i || (iMode == RTPCRYPTMODE_ALL))
        {
            pRtpAddr->CryptBuffer[i] =
                RtpHeapAlloc(g_pRtpCryptHeap, RTCP_SENDDATA_BUFFER);

            if (!pRtpAddr->CryptBuffer[i])
            {
                dwError = RTPERR_MEMORY;
                goto bail;
            }

            pRtpAddr->dwCryptBufferLen[i] = RTCP_SENDDATA_BUFFER;
        }
    }

    return(dwError);

 bail:
    for(i = CRYPT_RECV_IDX; i <= last; i++)
    {
        if (pRtpAddr->pRtpCrypt[i])
        {
            RtpCryptFree(pRtpAddr->pRtpCrypt[i]);
            pRtpAddr->pRtpCrypt[i] = NULL;
        }
    }
    
    for(i = 0; i < 2; i++)
    {
        if (pRtpAddr->CryptBuffer[i])
        {
            RtpHeapFree(g_pRtpCryptHeap, pRtpAddr->CryptBuffer[i]);
        }

        pRtpAddr->CryptBuffer[i] = NULL;
        pRtpAddr->dwCryptBufferLen[i] = 0;
    }
    
    return(dwError);
}

/* Release all memory */
DWORD RtpCryptCleanup(RtpAddr_t *pRtpAddr)
{
    DWORD            i;
    RtpCrypt_t      *pRtpCrypt;
    
    TraceFunctionName("RtpCryptCleanup");

    for(i = 0; i <= CRYPT_RTCP_IDX; i++)
    {
        pRtpCrypt = pRtpAddr->pRtpCrypt[i];

        if (pRtpCrypt)
        {
            RtpCryptFree(pRtpCrypt);

            pRtpAddr->pRtpCrypt[i] = NULL;
        }
    }

    for(i = 0; i < 2; i++)
    {
        if (pRtpAddr->CryptBuffer[i])
        {
            RtpHeapFree(g_pRtpCryptHeap, pRtpAddr->CryptBuffer[i]);

            pRtpAddr->CryptBuffer[i] = NULL;
        }

        pRtpAddr->dwCryptBufferLen[i] = 0;
    }
    
    return(NOERROR);
}

/* iMode defines what is going to be encrypted/decrypted,
 * e.g. RTPCRYPTMODE_PAYLOAD to encrypt/decrypt only RTP
 * payload. dwFlag can be RTPCRYPT_SAMEKEY to indicate that (if
 * applicable) the key used for RTCP is the same used for RTP */
DWORD RtpSetEncryptionMode(
        RtpAddr_t       *pRtpAddr,
        int              iMode,
        DWORD            dwFlags
    )
{
    DWORD            dwError;
    
    TraceFunctionName("RtpSetEncryptionMode");

    dwError = NOERROR;
    
    if (!pRtpAddr)
    {
        /* Having this as a NULL pointer means Init hasn't been
         * called, return this error instead of RTPERR_POINTER to be
         * consistent */
        dwError = RTPERR_INVALIDSTATE;

        goto bail;
    }
    
    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                _T("%s: pRtpAddr[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpAddr,
                pRtpAddr->dwObjectID, OBJECTID_RTPADDR
            ));

        dwError = RTPERR_INVALIDRTPADDR;
        goto bail;
    }

    if (iMode && (iMode > RTPCRYPTMODE_ALL))
    {
        dwError = RTPERR_INVALIDARG;

        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                _T("%s: pRtpAddr[0x%p] Invalid mode:0x%X"),
                _fname, pRtpAddr,
                iMode
            ));
        
        goto bail;
    }

    if ((dwFlags & 0xffff0000) != dwFlags)
    {
        dwError = RTPERR_INVALIDARG;
        
        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                _T("%s: pRtpAddr[0x%p] Invalid flags:0x%X"),
                _fname, pRtpAddr,
                dwFlags
            ));
        
        goto bail;
    }
        
    iMode |= dwFlags;
    
    /* If mode already set, verify the mode set is the default (0) or
     * the same */
    if (pRtpAddr->dwCryptMode)
    {
        if (!iMode || ((DWORD)iMode == pRtpAddr->dwCryptMode))
        {
            /* Same mode, do nothing */

            goto bail;
        }
        else
        {
            /* Once the mode is set, it can not be changed */

            dwError = RTPERR_INVALIDSTATE;

            TraceRetail((
                    CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                    _T("%s: pRtpAddr[0x%p] mode already set 0x%X != 0x%X"),
                    _fname, pRtpAddr,
                    pRtpAddr->dwCryptMode, iMode
                ));
            
            goto bail;
        }
    }

    /* Mode hasn't been set, set it and create cryptographic
     * context(s) */

    if (!iMode)
    {
        /* Set default mode */
        iMode = RTPCRYPTMODE_ALL;
        iMode |= RtpBitPar(RTPCRYPTFG_SAMEKEY);
    }

    pRtpAddr->dwCryptMode = (DWORD)iMode;

    TraceDebug((
            CLASS_INFO, GROUP_CRYPTO, S_CRYPTO_INIT,
            _T("%s: pRtpAddr[0x%p] Encryption mode set: 0x%X"),
            _fname, pRtpAddr,
            iMode
        ));

    /* Note that Setup is called from a method available to the user,
     * but Cleanup is called when the RtpAddr object is been clened up
     * */
    dwError = RtpCryptSetup(pRtpAddr);

 bail:
    if (dwError != NOERROR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                _T("%s: pRtpAddr[0x%p] ")
                _T("mode:0x%X flags:0x%X failed: %u (0x%X)"),
                _fname, pRtpAddr,
                iMode, dwFlags, dwError, dwError
            ));
    }
    
    return(dwError);
}

DWORD RtpSetEncryptionKey(
        RtpAddr_t       *pRtpAddr,
        TCHAR           *psPassPhrase,
        TCHAR           *psHashAlg,
        TCHAR           *psDataAlg,
        DWORD            dwIndex
    )
{
    DWORD            dwError;
    DWORD            i;
    RtpCrypt_t      *pRtpCrypt;
    RtpCrypt_t      *pRtpCryptTest;
    
    TraceFunctionName("RtpSetEncryptionKey");

    dwError = NOERROR;

    if (!pRtpAddr)
    {
        /* Having this as a NULL pointer means Init hasn't been
         * called, return this error instead of RTPERR_POINTER to be
         * consistent */
        dwError = RTPERR_INVALIDSTATE;

        goto bail;
    }
    
    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                _T("%s: pRtpAddr[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpAddr,
                pRtpAddr->dwObjectID, OBJECTID_RTPADDR
            ));

        dwError = RTPERR_INVALIDRTPADDR;
        goto bail;
    }

    if (dwIndex > CRYPT_RTCP_IDX)
    {
        dwError = RTPERR_INVALIDARG;

        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                _T("%s: pRtpAddr[0x%p] Invalid channel %s"),
                _fname, pRtpAddr,
                dwIndex
            ));
        
        goto bail;
    }

    pRtpCrypt = pRtpAddr->pRtpCrypt[dwIndex];

    if (!pRtpCrypt)
    {
        dwError = RTPERR_INVALIDSTATE;
        
        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                _T("%s: pRtpAddr[0x%p] Mode 0x%X doesn't support channel %s"),
                _fname, pRtpAddr,
                pRtpAddr->dwCryptMode, g_psSockIdx[dwIndex]
            ));

        goto bail;
    }
    
    pRtpCryptTest = NULL;
    
    dwError = NOERROR;
    
    if (RtpBitTest(pRtpAddr->dwCryptMode, RTPCRYPTFG_SAMEKEY))
    {
        for(i = CRYPT_RECV_IDX; i <= CRYPT_RTCP_IDX; i++)
        {
            pRtpCrypt = pRtpAddr->pRtpCrypt[i];
            
            if (pRtpCrypt)
            {
                dwError = RtpSetEncryptionKey_(pRtpAddr,
                                               pRtpCrypt,
                                               psPassPhrase,
                                               psHashAlg,
                                               psDataAlg);

                if (dwError != NOERROR)
                {
                    break;
                }

                if (!pRtpCryptTest)
                {
                    /* Will test on first crypto context */
                    pRtpCryptTest = pRtpCrypt; 
                }
            }
        }
    }
    else
    {
        pRtpCryptTest = pRtpCrypt;
        
        dwError = RtpSetEncryptionKey_(pRtpAddr,
                                       pRtpCrypt,
                                       psPassPhrase,
                                       psHashAlg,
                                       psDataAlg);
    }

 bail:
    if (dwError == NOERROR)
    {
        /* So far no error, test current parameters */
        dwError = RtpTestCrypt(pRtpAddr, pRtpCryptTest);
    }
    
    return(dwError);
}    

DWORD RtpSetEncryptionKey_(
        RtpAddr_t       *pRtpAddr,
        RtpCrypt_t      *pRtpCrypt,
        TCHAR           *psPassPhrase,
        TCHAR           *psHashAlg,
        TCHAR           *psDataAlg
    )
{
    DWORD            dwError;
    DWORD            len;
    ALG_ID           aiAlgId;

    TraceFunctionName("RtpSetEncryptionKey_");

    if (!psPassPhrase && !psHashAlg && !psDataAlg)
    {
        return(RTPERR_POINTER);
    }
    
    dwError = NOERROR;
    
    if (psPassPhrase)
    {
        len = lstrlen(psPassPhrase);

        if (len == 0)
        {
            dwError = RTPERR_INVALIDARG;
            
            TraceRetail((
                    CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                    _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                    _T("Invalid pass phrase length: %u"),
                    _fname, pRtpAddr, pRtpCrypt,
                    len
                ));

            goto bail;
        }
        else if (len > (sizeof(pRtpCrypt->psPassPhrase) - 1))
        {
            dwError = RTPERR_INVALIDARG;
            
            TraceRetail((
                    CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                    _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                    _T("Pass phrase too long: %u > %u"),
                    _fname, pRtpAddr, pRtpCrypt,
                    len,
                    sizeof(pRtpCrypt->psPassPhrase) - 1
                ));

            goto bail;
        }
        else
        {
#if defined(UNICODE)
            /* Convert UNICODE to UTF-8 */
            len = WideCharToMultiByte(
                    CP_UTF8, /* UINT code page */
                    0,       /* DWORD performance and mapping flags */
                    psPassPhrase,/*LPCWSTR address of wide-character string */
                    -1,      /* int number of characters in string */
                    pRtpCrypt->psPassPhrase,
                    /* LPSTR address of buffer for new string */
                    sizeof(pRtpCrypt->psPassPhrase),
                    /* int size of buffer */
                    NULL,    /* LPCSTR lpDefaultChar */
                    NULL     /* LPBOOL lpUsedDefaultChar */
                );
            
            if (len > 0)
            {
                /* Remove from the phrase's length the null
                 * terminating character */
                len--;
            }
            else
            {
                TraceRetailGetError(dwError);
                
                TraceRetail((
                        CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                        _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                        _T("WideCharToMultiByte failed: %u (0x%X)"),
                        _fname, pRtpAddr, pRtpCrypt,
                        dwError, dwError
                    ));

                goto bail;
            }
#else
            /* Copy pass phrase */
            strcpy(pRtpCrypt->sPassPhrase, psPassPhrase);
#endif
            if (len > 0)
            {
                pRtpCrypt->iKeySize = len;
            
                RtpBitSet(pRtpCrypt->dwCryptFlags, FGCRYPT_KEY);
            }
        }
    }

    /* Set the hashing algorithm */
    if (psHashAlg)
    {
        aiAlgId = RtpCryptAlgLookup(psHashAlg);

        if (aiAlgId == INVALID_ALGID)
        {
            dwError = RTPERR_INVALIDARG;
            
            TraceRetail((
                    CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                    _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                    _T("Invalid hashing algorithm:%s"),
                    _fname, pRtpAddr, pRtpCrypt,
                    psHashAlg
                ));

            goto bail;
        }

        pRtpCrypt->aiHashAlgId = aiAlgId;
    }
    
    /* Set the data encryption algorithm */
    if (psDataAlg)
    {
        aiAlgId = RtpCryptAlgLookup(psDataAlg);

        if (aiAlgId == INVALID_ALGID)
        {
            dwError = RTPERR_INVALIDARG;
            
            TraceRetail((
                    CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                    _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                    _T("Invalid data algorithm:%s"),
                    _fname, pRtpAddr, pRtpCrypt,
                    psDataAlg
                ));

            goto bail;
        }

        pRtpCrypt->aiDataAlgId = aiAlgId;
    }

    TraceRetail((
            CLASS_INFO, GROUP_CRYPTO, S_CRYPTO_INIT,
            _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
            _T("Hash:%s Data:%s Key:{%u chars} succeeded"),
            _fname, pRtpAddr, pRtpCrypt,
            RtpCryptAlgName(pRtpCrypt->aiHashAlgId),
            RtpCryptAlgName(pRtpCrypt->aiDataAlgId),
            len
        ));

 bail:
    return(dwError);
}

ALG_ID RtpCryptAlgLookup(TCHAR *psAlgName)
{
    DWORD            i;
    ALG_ID           aiAlgId;

    for(i = 0;
        g_RtpAlgId[i].AlgName && lstrcmp(g_RtpAlgId[i].AlgName, psAlgName);
        i++);
    
    if (g_RtpAlgId[i].AlgName)
    {
        aiAlgId = g_RtpAlgId[i].aiAlgId;
    }
    else
    {
        aiAlgId = INVALID_ALGID;
    }
    
    return(aiAlgId);
}

TCHAR *RtpCryptAlgName(ALG_ID aiAlgId)
{
    DWORD            i;
    TCHAR           *psAlgName;

    psAlgName = g_RtpAlgId[0].AlgName;;
    
    for(i = 0;
        g_RtpAlgId[i].AlgName && (g_RtpAlgId[i].aiAlgId != aiAlgId);
        i++);
    
    if (g_RtpAlgId[i].AlgName)
    {
        psAlgName = g_RtpAlgId[i].AlgName;
    }

    return(psAlgName);
}

/* This function tests if cryptography will succeed for the current
 * parameters set so far, it will be called every time
 * RtpSetEncryptionKey is called to validate those parameters,
 * otherwise an error would be detected only later when RTP starts
 * streaming */
DWORD RtpTestCrypt(
        RtpAddr_t       *pRtpAddr,
        RtpCrypt_t      *pRtpCrypt
    )
{
    BOOL             bOk;
    DWORD            dwError;
    DWORD            dwFlags;

    HCRYPTPROV       hProv;           /* Cryptographic Service Provider */
    HCRYPTHASH       hHash;           /* Hash handle */
    HCRYPTKEY        hDataKey;        /* Cryptographic key */ 

    TraceFunctionName("RtpTestCrypt");

    dwFlags  = 0;
    dwError  = NOERROR;
    hProv    = 0;
    hHash    = 0;
    hDataKey = 0;

    RTPASSERT(pRtpCrypt);
    
    /* Verify a pass phrase has been set */
    if (!RtpBitTest(pRtpCrypt->dwCryptFlags, FGCRYPT_KEY))
    {
        dwError = RTPERR_INVALIDSTATE;
        
        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                _T("No pass phrase has been set"),
                _fname, pRtpAddr, pRtpCrypt
            ));

        goto bail;
    }

    /*
     * Acquire context
     * */
    do {
        bOk = CryptAcquireContext(
                &hProv,            /* HCRYPTPROV *phProv */
                NULL,              /* LPCTSTR pszContainer */
                NULL,              /* LPCTSTR pszProvider */
                pRtpCrypt->dwProviderType,/* DWORD dwProvType */
                dwFlags            /* DWORD dwFlags */
            );
        
        if (bOk)
        {
            break;
        }
        else
        {
            if (GetLastError() == NTE_BAD_KEYSET)
            {
                /* If key doesn't exist, create it */
                dwFlags = CRYPT_NEWKEYSET;
            }
            else
            {
                /* Failed */
                TraceRetailGetError(dwError);

                TraceRetail((
                        CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                        _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                        _T("CryptAcquireContext failed: %u (0x%X)"),
                        _fname, pRtpAddr, pRtpCrypt,
                        dwError, dwError
                    ));

                goto bail;
            }
        }
    } while(dwFlags);

    /*
     * Create hash
     * */

    /* Create a hash object */
    bOk = CryptCreateHash(
            hProv,                  /* HCRYPTPROV hProv */
            pRtpCrypt->aiHashAlgId, /* ALG_ID Algid */  
            0,                      /* HCRYPTKEY hKey */
            0,                      /* DWORD dwFlags */
            &hHash                  /* HCRYPTHASH *phHash */
        );

    if (!bOk)
    {
        TraceRetailGetError(dwError);

        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                _T("CryptCreateHash failed: %u (0x%X)"),
                _fname, pRtpAddr, pRtpCrypt,
                dwError, dwError
            ));
        
        goto bail;
    }
    
    /*
     * Hash the password string *
     * */
    bOk = CryptHashData(
            hHash,                  /* HCRYPTHASH hHash */
            pRtpCrypt->psPassPhrase,/* BYTE *pbData */
            pRtpCrypt->iKeySize,    /* DWORD dwDataLen */
            0                       /* DWORD dwFlags */
        );
            
    if (!bOk)
    {
        TraceRetailGetError(dwError);

        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                _T("CryptHashData failed: %u (0x%X)"),
                _fname, pRtpAddr, pRtpCrypt,
                dwError, dwError
            ));
        
        goto bail;
    }

    /*
     * Create data key
     * */

    bOk = CryptDeriveKey(
            hProv,                  /* HCRYPTPROV hProv */
            pRtpCrypt->aiDataAlgId, /* ALG_ID Algid */
            hHash,                  /* HCRYPTHASH hBaseData */
            CRYPT_EXPORTABLE,       /* DWORD dwFlags */
            &hDataKey               /* HCRYPTKEY *phKey */
        );

    if (!bOk)
    {
        TraceRetailGetError(dwError);

        TraceRetail((
                CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_INIT,
                _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                _T("CryptDeriveKey failed: %u (0x%X)"),
                _fname, pRtpAddr, pRtpCrypt,
                dwError, dwError
            ));

        goto bail;
    }

 bail:
    if (dwError == NOERROR)
    {
        TraceRetail((
                CLASS_INFO, GROUP_CRYPTO, S_CRYPTO_INIT,
                _T("%s: pRtpAddr[0x%p] pRtpCrypt[0x%p] ")
                _T("Cryptographic test passed"),
                _fname, pRtpAddr, pRtpCrypt
            ));
    }
    else
    {
        dwError = RTPERR_CRYPTO;
    }
    
    /* Destroy the session key */
    if(hDataKey)
    {
        CryptDestroyKey(hDataKey);
    }

    /* Destroy the hash object */
    if (hHash)
    {
        CryptDestroyHash(hHash);
    }
    
    /* Release the provider handle */
    if(hProv)
    {
        CryptReleaseContext(hProv, 0);
    }

    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\inc\struct.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    struct.h
 *
 *  Abstract:
 *
 *    Main data structures
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/18 created
 *
 **********************************************************************/

#ifndef _struct_h_
#define _struct_h_

#include <winsock2.h>
#include <wincrypt.h>

#include "gtypes.h"
#include "rtphdr.h"
#include "rtpque.h"
#include "rtpcrit.h"
#include "rtpchan.h"

#include <qossp.h>

/*
 * Forward declarations. */
typedef struct _RtpSdesSched_t  RtpSdesSched_t;
typedef struct _RtpNetCount_t   RtpNetCount_t;
typedef struct _RtpSess_t       RtpSess_t;
typedef struct _RtpAddr_t       RtpAddr_t;
typedef struct _RtpNetRState_t  RtpNetRState_t;
typedef struct _RtpNetSState_t  RtpNetSState_t;
typedef struct _RtpUser_t       RtpUser_t;
typedef struct _RtpOutput_t     RtpOutput_t;
typedef struct _RtpSdesItem_t   RtpSdesItem_t;
typedef struct _RtpSdes_t       RtpSdes_t;
typedef struct _RtpQosNotify_t  RtpQosNotify_t;
typedef struct _RtpQosReserve_t RtpQosReserve_t;
typedef struct _RtpCrypt_t      RtpCrypt_t;
typedef struct _RtpRecvIO_t     RtpRecvIO_t;
typedef struct _RtpSendIO_t     RtpSendIO_t;
typedef struct _RtcpRecvIO_t    RtcpRecvIO_t;
typedef struct _RtcpSendIO_t    RtcpSendIO_t;
typedef struct _RtcpAddrDesc_t  RtcpAddrDesc_t;
typedef struct _RtpContext_t    RtpContext_t;
typedef struct _RtpRedEntry_t   RtpRedEntry_t;

/* Default bandwidth allocated per session (used to compute RTCP
 * bandwidth)
 * bits/sec (200 Kbits/sec) */
#define DEFAULT_SESSBW          (300 * 1000)

/* 75% out of the 5% for RTCP (bits/sec) */
#define DEFAULT_BWRECEIVERS     (DEFAULT_SESSBW * (5 * 75) / 10000)

/* 25% out of the 5% for RTCP (bits/sec) */
#define DEFAULT_BWSENDERS       (DEFAULT_SESSBW * (5 * 25) / 10000)

#define DEFAULT_RTCP_MIN_INTERVAL 5.0 /* secs */

#define SIZEOF_UDP_IP_HDR       (8+20)

#define BIG_TIME (1e12)

#define DEFAULT_ALPHA           (0.998002)
#define MIN_PLAYOUT             10          /* Milliseconds */
#define MAX_PLAYOUT             500         /* Milliseconds */
#define GAPFORTALKSPURT         200         /* Milliseconds */
#define DEFAULT_SAMPLING_FREQ   8000        /* Hz */
#define MINTIMEBETWEENMARKERBIT (0.5)       /* Seconds */

#define RELATIVE_DELAY          1.0         /* Seconds */
#define SHORTDELAYCOUNT         8

/* Receiver and sender buffer size */
#define RTCP_RECVDATA_BUFFER    1500
#define RTCP_SENDDATA_BUFFER    1500

/* Boundaries for RTP ports allocated */
#define RTPPORT_LOWER           5004

#define MAX_DROPOUT             3000
#define MAX_MISORDER            100
#define MIN_SEQUENTIAL          3


/* Redundancy */
#define RTP_RED_DEFAULTPT       97  /* Default payload */
#define RTP_RED_MAXRED          1   /* Number of redundant blocks */
#define RTP_RED_MAXDISTANCE     3   /* Maximum redundancy distance, i.e. i-3 */
#define RTP_RED_INITIALDISTANCE 0   /* Initial redundancy distance */

/* The timeout used when scheduling a received packet to be posted at
 * a later time will be decreased by this value */
#define RTP_RED_EARLY_TIMEOUT   (5e-3)
/* Will post immediatly (instead of scheduling for later) if the due
 * time is at least this close. This value can not be smaller than the
 * early timeout */
#define RTP_RED_EARLY_POST      (RTP_RED_EARLY_TIMEOUT+5e-3)

/* Multiply loss rate by this factor and do integer arithmetic */
#define LOSS_RATE_FACTOR        1000

/* Redundancy loss rate low and high thresholds for each distance
   0:   0,  5
   1:   4,  10
   2:   9,  15
   3:  14,  20
 */
#define RED_LT_0                ( 0 * LOSS_RATE_FACTOR)
#define RED_HT_0                ( 5 * LOSS_RATE_FACTOR)
#define RED_LT_1                ( 4 * LOSS_RATE_FACTOR)
#define RED_HT_1                (10 * LOSS_RATE_FACTOR)
#define RED_LT_2                ( 9 * LOSS_RATE_FACTOR)
#define RED_HT_2                (15 * LOSS_RATE_FACTOR)
#define RED_LT_3                (14 * LOSS_RATE_FACTOR)
#define RED_HT_3                (20 * LOSS_RATE_FACTOR)

/* Factor to grow the average loss rate */
#define LOSS_RATE_ALPHA_UP      2
/* Factor to decrease the average loss rate */
#define LOSS_RATE_ALPHA_DN      4


/**********************************************************************
 * Bandwidth estimation
 **********************************************************************/
/* The initial count is the number of reports that will use
 * MOD_INITIAL to decide if a probe packet is sent, after that
 * MOD_FINAL will be used. */
#define RTCP_BANDESTIMATION_INITIAL_COUNT  8

/* Number or valid reports received before the estimation is posted
 * for the first time */
#define RTCP_BANDESTIMATION_MINREPORTS     5

/* When doing bandwidth estimation, send an RTCP SR probe packet this
 * modulo (note that a probe packet also counts for the module, so
 * mod=2 means send a probe packet every RTCP SR sent; mod=5 means
 * send a probe every fourth RTCP SR sent). */
#define RTCP_BANDESTIMATION_MOD_INITIAL    2
#define RTCP_BANDESTIMATION_MOD_FINAL      5

/* Number of bins to keep */
#define RTCP_BANDESTIMATION_MAXBINS        4

/* Boundaries for each bin (note there is 1 more than the number of
 * bins) */
#define RTCP_BANDESTIMATION_BIN0       15000  /* bps */
#define RTCP_BANDESTIMATION_BIN1       70000  /* bps */
#define RTCP_BANDESTIMATION_BIN2      200000  /* bps */
#define RTCP_BANDESTIMATION_BIN3     1000000  /* bps */
#define RTCP_BANDESTIMATION_BIN4   100000000  /* bps */

/* Life time span of the bandwidth estimation validity */
#define RTCP_BANDESTIMATION_TTL         30.0 /* Seconds */

/* Time to wait after the first RB has been received to declare that
 * bandwidth estimation is not supported by the remote end and hence a
 * notification issued to the upper layer */
#define RTCP_BANDESTIMATION_WAIT        30.0 /* Seconds */

/* Maximum time gap between the sending time of two consecutive SR
 * reports to do bandwidth estimation (queueing latency) */
#define RTCP_BANDESTIMATION_MAXGAP      0.090 /* Seconds */

#define RTCP_BANDESTIMATION_NOBIN       ((DWORD)-1)

/**********************************************************************
 * Network quality metric
 **********************************************************************/
/* Minimum network quality metric change (percentage) to consider it
 * worth an update */
#define RTPNET_MINNETWORKCHANGE         10

/* Generic factor to smooth some parameters */
#define RTP_GENERIC_ALPHA               0.75

/* Maximum audio frame size allowed to use packet duplication
 * technique to recover single losses */
#define RTP_MAXFRAMESIZE_PACKETDUP      0.050    /* Seconds */

/* The following macros define the minimum and maximum values to
 * evaluate network quality, e.g. below the minimum RTT that parameter
 * is excelent, above that is the worst, in between we obtain a 0 -
 * 100 quality level */

/* Class audio */
#define NETQA_RTT_MIN                    (0.040)  /* seconds */
#define NETQA_RTT_MAX                    (0.400)  /* seconds */
#define NETQA_JITTER_MIN                 (0.015)  /* seconds */
#define NETQA_JITTER_MAX                 (0.200)  /* seconds */
#define NETQA_LOSSES_MIN                 (5.0)    /* percentage */
#define NETQA_LOSSES_MAX                 (30.0)   /* percentage */

/* Class video */
#define NETQV_RTT_MIN                    (0.040)  /* seconds */
#define NETQV_RTT_MAX                    (0.400)  /* seconds */
#define NETQV_JITTER_MIN                 (0.015)  /* seconds */
#define NETQV_JITTER_MAX                 (5.000)  /* seconds */
#define NETQV_LOSSES_MIN                 (5.0)    /* percentage */
#define NETQV_LOSSES_MAX                 (30.0)   /* percentage */


/**********************************************************************
 * SDES sending schedule
 **********************************************************************/
typedef struct _RtpSdesSched_t {
    DWORD             L1;
    DWORD             L2;
    DWORD             L3;
    DWORD             L4;
} RtpSdesSched_t;

/**********************************************************************
 * Holds the receiver/sender network counters (MAYDO would be nice
 * to have it shared memory).
 **********************************************************************/
typedef struct _RtpNetCount_t {
    /* +++ RTP +++ */
    DWORD            dwRTPBytes;      /* Number of bytes */
    DWORD            dwRTPPackets;    /* Number of packets */
    DWORD            dwRTPBadPackets; /* Number of bad packets */
    DWORD            dwRTPDrpPackets; /* Number of good packets dropped */
    double           dRTPLastTime;    /* Last time a packet was recv/send */

    /* +++ RTCP +++ */
    DWORD            dwRTCPBytes;     /* Number of bytes */
    DWORD            dwRTCPPackets;   /* Number of packets */
    DWORD            dwRTCPBadPackets;/* Number of bad packets */
    DWORD            dwRTCPDrpPackets;/* Number of good packets dropped */
    double           dRTCPLastTime;   /* Last time a packet was recv/send */
} RtpNetCount_t;

/**********************************************************************
 * Callback function to generate DShow events through
 * CBaseFilter::NotifyEvent()
 **********************************************************************/
typedef void (CALLBACK *PDSHANDLENOTIFYEVENTFUNC)(
        void            *pvUserInfo,/* pCRtpSourceFilte or pCRtpRenderFilter */
        long             EventCode,
        LONG_PTR         EventParam1,
        LONG_PTR         EventParam2
    );

/**********************************************************************
 * RTP reception callback function pass by the application (DShow)
 **********************************************************************/
typedef void (CALLBACK *PRTP_RECVCOMPLETIONFUNC)(
        void            *pvUserInfo1,
        void            *pvUserInfo2,
        void            *pvUserInfo3,
        RtpUser_t       *pRtpUser,
        double           dPlayTime,
        DWORD            dwError,
        long             lHdrSize,
        DWORD            dwTransfered,
        DWORD            dwFlags
    );

/**********************************************************************
 * RTCP reception callback function
 **********************************************************************/
typedef void (CALLBACK *PRTCP_RECVCOMPLETIONFUNC)(
        void            *pvUserInfo1,
        void            *pvUserInfo2,
        DWORD            dwError,
        DWORD            dwTransfered,
        DWORD            dwFlags
    );

/**********************************************************************
 * A full duplex RTP session which can have one or more addresses
 * either unicast or multicast. Obtained from g_pRtpSessHeap.
 **********************************************************************/

/* Some flags in RtpSess_t.dwSessFlags */
enum {
    FGSESS_FIRST,

    FGSESS_EVENTRECV,   /* Enable events as receiver */
    FGSESS_EVENTSEND,   /* Enable events as sender */

    FGSESS_LAST
};

typedef struct _RtpSess_t {
    DWORD            dwObjectID;      /* Identifies structure */
    RtpQueueItem_t   SessQItem;       /* Sessions in g_RtpContext.RtpSessQ */
    long             lSessRefCount[2];/* Sessions are shared */
    RtpCritSect_t    SessCritSect;    /* Lock */
    RtpQueue_t       RtpAddrQ;        /* Addresses queue */
    DWORD            dwSessFlags;     /* RtpSess_t flags */
    void            *pvSessUser[2];   /* Pointers to users' session */
    PDSHANDLENOTIFYEVENTFUNC pHandleNotifyEvent;

    RtpQueue_t       OutputQ;         /* Outputs queue */
    RtpCritSect_t    OutputCritSect;  /* Lock to access RtpOutQ */

    /* Masks */
    DWORD            dwFeatureMask;   /* Features mask */
    DWORD            dwEventMask[2];  /* Recv/Send RTP/RTCP event mask */
    DWORD            dwPartEventMask[2];/* Recv/Send participant events mask */
    DWORD            dwQosEventMask[2];/* Recv/Send QOS event mask */
    DWORD            dwSdesEventMask[2];/* Recv/Send remote SDES event mask */
    DWORD            dwSdesMask[2];   /* 0:What SDES sent if
                                       * available, 1:What SDES stored
                                       * when received */
    /* SDES control */
    DWORD            dwSdesPresent;   /* What items are already stored */
    RtpSdes_t       *pRtpSdes;        /* local SDES information */
    RtpSdesSched_t   RtpSdesSched;    /* SDES scheduling */
    
    /* Network counters */
    RtpNetCount_t    RtpSessCount[2]; /* Recv/Send network counters */
} RtpSess_t;

/**********************************************************************
 * Per sender network state information, keeps sequence number
 * extended sequence number, as well as other counters used to compute
 * losses and jitter
 **********************************************************************/

/* Some flags used in RtpNetSState_t.dwNetSFlags */
enum {
    FGNETS_FIRST,

    FGNETS_RTCPRECVBWSET, /* The RTCP bandwidth for receivers has been set */
    FGNETS_RTCPSENDBWSET, /* The RTCP bandwidth for senders has been set */

    FGNETS_DUMMY3,
    
    FGNETS_1STBANDPOSTED, /* First bandwidth estimation posted */
    FGNETS_NOBANDPOSTED,  /* No bandwidth estimation available posted */

    FGNETS_DONOTSENDPROBE,/* Direct RTCP not to send probing packets */

    FGNETS_LAST
};

typedef struct NetSFlags_f {
    DWORD            Dummy0:1;
    /* The RTCP bandwidth for receivers has been set */
    DWORD            RtcpRecvBWSet:1;
    /* The RTCP bandwidth for senders has been set */
    DWORD            RtcpSendBWSet:1;
    DWORD            Dummy3:1;
    /* First bandwidth estimation posted */
    DWORD            FirstBandEstPosted:1;
    /* "No bandwidth estimation available" event posted */
    DWORD            NoBandEstEventPosted:1;
} NetSFlags_f;

typedef struct _RtpNetSState_t {
    /* Flags */
    union {
        DWORD            dwNetSFlags;
        NetSFlags_f      NetSFlags;
    };
    
    /* RTP Sender */
    union {
        struct {
            WORD             wSeq:16; /* Sending sequence number */
            WORD             wSeqH:16;/* High part for the sequence number */
        };
        DWORD            dwSeq;       /* 32bits sequence number */
    };
        
    BYTE             bPT;           /* Payload type used on each packet sent */
    BYTE             bPT_Dtmf;      /* Payload type in DTMF packets */
    BYTE             bPT_RedSend;   /* Payload type to send redun. encoding */
    BYTE             bMarker;       /* marker bit for next packet sent */
    DWORD            dwSendSSRC;    /* NETWORK ORDER: Packets sent
                                     * have this SSRC */
    DWORD            dwSendSamplingFreq;/* Payload's sampling frequency */

    /* Redundancy control */
    DWORD            dwSendSamplesPerPacket;/* Samples in each packet */
    DWORD            dwInitialRedDistance;/* Initial redundancy distance */
    DWORD            dwCurRedDistance;  /* Current redundancy distance */
    DWORD            dwNxtRedDistance;  /* Next redundancy distance */
    DWORD            dwMaxRedDistance;  /* Max redundancy distance */
    int              iLastLossRateS;    /* Last loss rate reported */
    int              iAvgLossRateS;     /* Average loss rate
                                         * (percent * LOSS_RATE_FACTOR) */
    DWORD            dwRedIndex;        /* Next entry where to save a frame */
    DWORD            dwRedEntries;      /* number of entries */
    RtpRedEntry_t   *pRtpRedEntry;      /* Points to array of red entries */
    
    DWORD            dwSendTimeStamp;  /* Current timestamp */
    DWORD            dwPreviousTimeStamp;
    DWORD            dwTimeStampOffset;/* Random offset to the timestamp */
    double           dTimeLastRtpSent; /* Time last RTP packet was sent */

    double           avg_rtcp_size; /* Average RTCP packet size sent (bits) */
    DWORD            dwInboundBandwidth; /* bits/second */
    DWORD            dwOutboundBandwidth;/* bits/second */
    DWORD            dwRtcpBwReceivers;  /* bits/sec */
    DWORD            dwRtcpBwSenders;  /* bits/sec */
    double           dRtcpMinInterval; /* Min interval report (secs) */
    double           dRtcpInterval;    /* Last RTCP interval report (secs) */
    BOOL             bWeSent;          /* Are we sending? */

    /* Bandwidth estimation */
    DWORD            dwBandEstMod;
    double           dwBandEstCount;
    double           dLastTimeEstimationPosted;
} RtpNetSState_t;

/**********************************************************************
 * Each address in an RTP session. Obtained from g_pRtpAddrHeap.
 **********************************************************************/

/* Some flags in RtpAddr_t.dwIRtpFlags (CIRtpSession flags) */
/*
 * WARNING
 *
 * Be aware that the RTPINITFG_* flags defined in msrtp.h, are mapped
 * to the FGADDR_IRTP_* flags below
 * */
enum {
    FGADDR_IRTP_FIRST,

    FGADDR_IRTP_INITDONE,/* Initialization done */
    FGADDR_IRTP_ISRECV,  /* Is receiver */
    FGADDR_IRTP_ISSEND,  /* Is sender */

    FGADDR_IRTP_USEPLAYOUT,
    FGADDR_IRTP_DUMMY5,
    FGADDR_IRTP_DUMMY6,
    FGADDR_IRTP_DUMMY7,
    
    FGADDR_IRTP_AUTO,    /* Auto initialize */
    FGADDR_IRTP_QOS,     /* QOS enabled session */
    FGADDR_IRTP_PERSISTSSRC,    /* Persistent SSRC */
    FGADDR_IRTP_PERSISTSOCKETS, /* Persistent sockets */

    /* Class 0,1,2 are used to define the media class */
    FGADDR_IRTP_CLASS0,
    FGADDR_IRTP_CLASS1,
    FGADDR_IRTP_CLASS2,
    FGADDR_IRTP_DUMMY15,

    FGADDR_IRTP_MATCHRADDR, /* Discard packets not comming from the
                             * remote address */
    FGADDR_IRTP_RADDRRESETDEMUX,/* Reset the demux (unmap all outputs)
                                 * when a new remote address is set */

    FGADDR_IRTP_LAST
};

typedef struct _IRtpFlags_f {
    DWORD           Dummy0:1;
    DWORD           INITDONE:1;
    DWORD           ISRECV:1;
    DWORD           ISSEND:1;
    DWORD           USEPLAYOUT:1;
    DWORD           DUMMY5:3;
    DWORD           AUTO:1;
    DWORD           QOS:1;
    DWORD           PERSISTSSRC:1;
    DWORD           PERSISTSOCKETS:1;
    DWORD           CLASS:3;
    DWORD           Dummy15:1;
    DWORD           MATCHRADDR:1;
} IRtpFlags_f;

#define RtpGetClass(dw)  ((dw >> FGADDR_IRTP_CLASS0) & 0x7)

#define FGADDR_IRTP_MASK ( RtpBitPar(FGADDR_IRTP_AUTO)   | \
                           RtpBitPar(FGADDR_IRTP_QOS)    | \
                           RtpBitPar(FGADDR_IRTP_PERSISTSSRC)   | \
                           RtpBitPar(FGADDR_IRTP_PERSISTSOCKETS)| \
                           RtpBitPar(FGADDR_IRTP_CLASS0) | \
                           RtpBitPar(FGADDR_IRTP_CLASS1) | \
                           RtpBitPar(FGADDR_IRTP_CLASS2) | \
                           RtpBitPar(FGADDR_IRTP_MATCHRADDR)      | \
                           RtpBitPar(FGADDR_IRTP_RADDRRESETDEMUX) | \
                           0 \
                         )

#define RtpGetClass(dw) ((dw >> FGADDR_IRTP_CLASS0) & 0x7)

/* Some flags in RtpAddr_t.dwAddrFlags */
enum {
    FGADDR_FIRST,
    FGADDR_RANDOMINIT,  /* Random initialization done */

    /* RtpAddr flags */
    FGADDR_ISRECV,
    FGADDR_ISSEND,
    
    FGADDR_RUNRECV,      /* RECV running */
    FGADDR_RUNSEND,      /* SEND running */
    FGADDR_RTPTHREAD,    /* RTP reception thread already started */
    FGADDR_RTCPTHREAD,   /* RTCP thread already started */

    FGADDR_QOSRECV,      /* QOS required */
    FGADDR_QOSSEND,      /* QOS required */
    FGADDR_QOSRECVON,    /* QOS enabled */
    FGADDR_QOSSENDON,    /* QOS enabled */
    
    FGADDR_LADDR,        /* Local address already set */
    FGADDR_RADDR,        /* Remote address already set */
    FGADDR_ADDED,        /* Address added to RTCP */
    FGADDR_DUMMY15,
    
    FGADDR_SOCKET,       /* Sockets are created */
    FGADDR_SOCKOPT,      /* Socket options already set */
    FGADDR_FORCESTOP,    /* Bypass persistent sockets and really stop */
    FGADDR_DUMMY19,
    
    FGADDR_LOOPBACK_WS2, /* Winsock Mcast loopback enabled */
    FGADDR_LOOPBACK_SFT, /* RTP Mcast loopback enabled */
    FGADDR_COLLISION,    /* Collision detection enabled */
    FGADDR_ISMCAST,      /* Is a multicast session */

    FGADDR_MUTERTPRECV,  /* Mute RTP network reception */
    FGADDR_MUTERTPSEND,  /* Mute RTP network sending */
    FGADDR_REGUSEDRECV,  /* Read some registry settings for receiver */
    FGADDR_REGUSEDSEND,  /* Read some registry settings for sender */

    FGADDR_REDRECV,     /* Enable receiving redundant encoding */
    FGADDR_REDSEND,     /* Enable sending redundant encoding */
    FGADDR_NETMETRIC,   /* Compute net metrics for every body */
    
    FGADDR_LAST
};

typedef struct _AddrFlags_t {
    DWORD           Dummy0:1;
    DWORD           RANDOMINIT:1;
    DWORD           ISRECV:1;
    DWORD           ISSEND:1;
    DWORD           RUNRECV:1;
    DWORD           RUNSEND:1;
    DWORD           RTPTHREAD:1;
    DWORD           RTCPTHREAD:1;
    DWORD           QOSRECV:1;
    DWORD           QOSSEND:1;
    DWORD           QOSRECVON:1;
    DWORD           QOSSENDON:1;
    DWORD           LADDR:1;
    DWORD           RADDR:1;
    DWORD           ADDED:1;
    DWORD           Dummy15:1;
    DWORD           SOCKET:1;
    DWORD           SOCKOPT:1;
    DWORD           FORCESTOP:1;
    DWORD           Dummy19,:1;
    DWORD           LOOPBACK_WS2:1;
    DWORD           LOOPBACK_SFT:1;
    DWORD           COLLISION:1;
    DWORD           ISMCAST:1;
    DWORD           MUTERTPRECV:1;
    DWORD           MUTERTPSEND:1;
    DWORD           REGUSEDRECV:1;
    DWORD           REGUSEDSEND:1;
    DWORD           REDRECV:1;
    DWORD           REDSEND:1;
    DWORD           NETMETRIC:1;
} AddrFlags_f;

/* Some flags in RtpAddr_t.dwAddrFlagsQ (QOS) */
enum {
    FGADDRQ_FIRST,
    
    FGADDRQ_QOSRECVON,    /* Recv QOS session started */
    FGADDRQ_QOSSENDON,    /* send QOS session started */
    FGADDRQ_DUMMY3,

    FGADDRQ_CHKQOSSEND,  /* Check for allowed to send */
    FGADDRQ_QOSUNCONDSEND,/* Inconditional send */
    FGADDRQ_QOSCONDSEND, /* Conditional send */
    FGADDRQ_DUMMY7,
    
    FGADDRQ_QOSSEND,     /* Allows to send */
    FGADDRQ_QOSEVENTPOSTED,/* Not allowed to send event posted */
    FGADDRQ_RECVFSPEC_DEFINED,
    FGADDRQ_SENDFSPEC_DEFINED,

    FGADDRQ_QOSREDRECVON,/* Unused: Recv QOS with redundancy is on */
    FGADDRQ_QOSREDSENDON,/* Send QOS with redundancy is on */
    FGADDRQ_DUMMY14,
    FGADDRQ_DUMMY15,
    
    FGADDRQ_REGQOSDISABLE,/* QOS disabled from registry */
    FGADDRQ_QOSNOTALLOWED,/* QOS not allowed for this user */

    FGADDRQ_LAST
};

typedef struct _AddrFlagsQ_f {
    DWORD           Dummy0:1;
    DWORD           QOSRECVON:1;
    DWORD           QOSSENDON:1;
    DWORD           Dummy3:1;
    DWORD           CHKQOSSEND:1;
    DWORD           QOSUNCONDSEND:1;
    DWORD           QOSCONDSEND:1;
    DWORD           Dummy7:1;
    DWORD           QOSSEND:1;
    DWORD           QOSEVENTPOSTED:1;
    DWORD           RECVFSPEC_DEFINED:1;
    DWORD           SENDFSPEC_DEFINED:1;
    DWORD           QOSREDRECVON:1;
    DWORD           QOSREDSENDON:1;
    DWORD           FGADDRQ_DUMMY14:1;
    DWORD           FGADDRQ_DUMMY15:1;
    DWORD           REGQOSDISABLE:1;
    DWORD           QOSNOTALLOWED:1;  
} AddrFlagsQ_f;

/* Some flags in RtpAddr_t.dwAddrFlagsC (Cryptography) */
enum {
    FGADDRC_FIRST,
    
    FGADDRC_CRYPTRECVON, /* Crypt RECV initialized */
    FGADDRC_CRYPTSENDON, /* Crypt SEND initialized */
    FGADDRC_CRYPTRTCPON, /* Crypt RTCP initialized */
    
    FGADDRC_DUMMY4,
    FGADDRC_CRYPTRECV,   /* Decrypt RTP reception */
    FGADDRC_CRYPTSEND,   /* Encrypt RTP send */
    FGADDRC_CRYPTRTCP,   /* Encrypt/Decrypt RTCP */

    FGADDRC_LAST
};

typedef struct _AddrFlagsC_f {
    DWORD           Dummy0:1;
    DWORD           CRYPTRECVON:1;
    DWORD           CRYPTSENDON:1;
    DWORD           CRYPTRTCPON:1;
    DWORD           Dummy4:1;
    DWORD           CRYPTRECV:1;
    DWORD           CRYPTSEND:1;
    DWORD           CRYPTRTCP:1;
} AddrFlagsC_f;

/* Some flags in RtpAddr_t.dwAddrFlagsR (Receiver thread) */
enum {
    FGADDRR_FIRST,

    FGADDRR_QOSREDRECV,  /* Recv QOS with redundancy was requested */
    FGADDRR_UPDATEQOS,   /* QOS reservation needs to be updated for
                          * the current PT */
    FGADDRR_RESYNCDI,    /* Resync mean delay Di */

    FGADDRR_LAST
};

typedef struct _AddrFlagsR_f {
    DWORD           Dummy0:1;
    DWORD           QOSREDRECV:1;
    DWORD           UPDATEQOS:1;
    DWORD           RESYNCDI:1; 
} AddrFlagsR_f;

/* Some flags in RtpAddr_t.dwAddrFlagsS (Sender thread) */
enum {
    FGADDRS_FIRST,

    FGADDRS_FIRSTSENT,   /* First packet sent */
    FGADDRS_FRAMESIZE,   /* Frame size was learned */
    FGADDRS_QOSREDSEND,  /* Unused: Send QOS with redundancy was requested */
    
    FGADDRS_LAST
};

typedef struct _AddrFlagsS_f {
    DWORD           Dummy0:1;
    DWORD           FIRSTSENT:1;
    DWORD           FRAMESIZE:1;
    DWORD           QOSREDSEND:1;
} AddrFlagsS_f;

/* Some flags in RtpAddr_t.dwAddrRegFlags (registry) */
enum {
    FGADDRREG_FIRST,
    
    FGADDRREG_NETQFORCEDVALUE,
    FGADDRREG_NETQFORCED,

    FGADDRREG_LAST
};

typedef struct _AddrRegFlags_f {
    DWORD           Dummy0:1;
    DWORD           NETQFORCEDVALUE:1;
    DWORD           NETQFORCED:1;
} AddrRegFlags_f;

#define MAX_PTMAP 16

typedef struct _RtpPtMap_t {
    DWORD            dwPt;
    DWORD            dwFrequency;
} RtpPtMap_t;

/*
 * !!! WARNING !!!
 *
 * The offset to Cache1Q, ..., ByeQ MUST NOT be bigger than 1023 and
 * MUST be DWORD aligned (the offset value is stored as number of
 * DWORDS in rtppinfo.c using 8 bits)
 * */

typedef struct _RtpAddr_t {
    DWORD            dwObjectID;    /* Identifies structure */
    RtpQueueItem_t   AddrQItem;     /* Addresses are in RtpSess_t.RtpAddrQ */
    RtpSess_t       *pRtpSess;      /* Session owning this address */
    RtpCritSect_t    AddrCritSect;  /* Lock */

    /* Some flags for CIRtpSession */
    union {
        DWORD            dwIRtpFlags;
        IRtpFlags_f      IRtpFlags;
    };

    /* Some flags and state information */
    union {
        DWORD            dwAddrFlags;
        AddrFlags_f      AddrFlags;
    };

    /* Some flags for QOS */
    union {
        DWORD            dwAddrFlagsQ;
        AddrFlagsQ_f     AddrFlagsQ;
    };

    /* Some flags for cryptography */
    union {
        DWORD            dwAddrFlagsC;
        AddrFlagsC_f     AddrFlagsC;
    };

    /* Some flags for the receiver thread*/
    union {
        DWORD            dwAddrFlagsR;
        AddrFlagsR_f     AddrFlagsR;
    };

    /* Some flags for the sender thread */
    union {
        DWORD            dwAddrFlagsS;
        AddrFlagsS_f     AddrFlagsS;
    };
    
    /* Some flags derived from the registry */
    union {
        DWORD            dwAddrRegFlags;
        AddrRegFlags_f   AddrRegFlags;
    };
    
    /* Participants (SSRCs) */
    RtpCritSect_t    PartCritSect;  /* Lock for participants queues */
    RtpQueue_t       Cache1Q;       /* Only current senders are here */
    RtpQueue_t       Cache2Q;       /* Only recent senders are here */
    RtpQueue_t       AliveQ;        /* All "alive" participants are here */
    RtpQueue_t       ByeQ;          /* Stalled or left participants */
    RtpQueueHash_t   Hash;          /* Same as alive but with hash table */
    long             lInvalid;      /* Not yet validated participants */
    double           dAlpha;        /* Weighting factor for delay/jitter */

    /* RTP Receiver */
    RtpChannel_t     RtpRecvThreadChan;
    HANDLE           hRtpRecvThread;
    DWORD            dwRtpRecvThreadID;

    /* Overlapped reception */
    RtpCritSect_t    RecvQueueCritSect;/* Lock for Free/Busy queues */
    RtpQueue_t       RecvIOFreeQ;     /* Pool of RtpRecvIO_t structures */
    RtpQueue_t       RecvIOReadyQ;    /* Buffers ready for overlapped I/O */
    RtpQueue_t       RecvIOPendingQ;  /* Buffers pending for completion */
    RtpQueue_t       RecvIOWaitRedQ;  /* Buffers waiting for redundancy */
    HANDLE           hRecvCompletedEvent;/* Signal I/O completed */
    PRTP_RECVCOMPLETIONFUNC pRtpRecvCompletionFunc;
    
    /* Network/Sockets information */
    RtpQueueItem_t   PortsQItem;    /* To keep track of ports */
    SOCKET           Socket[3];     /* RTP Recv, RTP Send, RTCP Recv/Send */
    DWORD            dwAddr[2];     /* NETWORK order: Local and Remote IP
                                     * address */
    WORD             wRtpPort[2];   /* NETWORK order: Local and Remote
                                     * RTP port */
    WORD             wRtcpPort[2];  /* NETWORK order: Local and Remote
                                     * RTCP port */
    DWORD            dwTTL[2];      /* TTL - Time To Live, for RTP and RTCP */

    /* Private PT <-> Frequency mappings */
    RtpPtMap_t       RecvPtMap[MAX_PTMAP]; /* Reception PT ->
                                            * Frequency mapping */

    /* Redundancy control */
    BYTE             bPT_RedRecv;   /* PT to receive redundant encoding */
    
    /* RtpNetCount and RtpNetSState lock */
    RtpCritSect_t    NetSCritSect;
    
    /* Recv and Send network counters */
    RtpNetCount_t    RtpAddrCount[2];

    /* Network Sender state */
    RtpNetSState_t   RtpNetSState;

    /* QOS reservations */
    RtpQosReserve_t *pRtpQosReserve;
    
    /* Cryptography, Recv/Send encryption descriptor */
    DWORD            dwCryptMode;
    RtpCrypt_t      *pRtpCrypt[3];
    
    DWORD            dwCryptBufferLen[2];
    char            *CryptBuffer[2]; /* RTP, RTCP encryption buffer */
} RtpAddr_t;

/**********************************************************************
 * Per source (participant) network state information, keeps sequence
 * number, and extended sequence number, as well as other counters
 * used to compute losses and jitter
 **********************************************************************/

/* Flags used in RtpNetRState_t.dwNetRStateFlags. Currently only used
 * by the RTP thread while processing packets received */
enum {
    FGNETRS_FIRST,

    FGNETRS_TIMESET,  /* Time available, time can be derived */

    FGNETRS_LAST
};

/* Flags used in RtpNetRState_t.dwNetRStateFlags2. */
enum {
    FGNETRS2_FIRST,

    FGNETRS2_BANDWIDTHUNDEF, /* Last bandwidth estimation was undefined */
    FGNETRS2_BANDESTNOTREADY, /* In the process of getting first average */

    FGNETRS2_LAST
};

typedef struct _RtpNetRState_t {
    DWORD            dwNetRStateFlags;/* Some flags used by RTP thread */
    DWORD            dwNetRStateFlags2;/* Some flags used by RTCP thread */
    WORD             max_seq;        /* highest seq. number seen */
    DWORD            cycles;         /* shifted count of seq. number cycles */
    DWORD            base_seq;       /* base seq number */
    DWORD            bad_seq;        /* last 'bad' seq number + 1 */
    DWORD            probation;      /* sequ. packets till source is valid */
    DWORD            received;       /* packets received */
    DWORD            expected_prior; /* packets expected at last interval */
    DWORD            received_prior; /* packets received at last interval */
    long             transit;        /* relative trans time for prev pkt */
    DWORD            jitter;         /* estimated jitter */
    DWORD            timestamp_prior;/* Used to detect timestamp gaps */
    DWORD            dwLastPacketSize;/* Last packet's size */
    int              iAvgLossRateR;  /* Average of the loss rate being
                                      * reported */

    DWORD            red_max_seq;    /* extended seq. number seen, incl. red */
    DWORD            red_received;   /* main + redundancy (m+r) consumed */
    DWORD            red_expected_prior;/* packets expected at last interval */
    DWORD            red_received_prior;/* m+r received at last interval */
    int              iRedAvgLossRateR;/* Average of the loss rate
                                       * after packet reconstruction */
    
    long             lBigDelay;      /* Used to detect step delay changes */

    DWORD            dwPt;
    DWORD            dwRecvSamplingFreq; /* Payload's sampling frequency */
    DWORD            dwRecvSamplesPerPacket;/* Samples in each packet */
    /* Samples per packet detection  */
    DWORD            dwRecvMinSamplesPerPacket;
    DWORD            dwPreviousTimeStamp;
    
    /* Delay and jitter computation (all time values are in seconds)
     * except t_sr */

    RtpTime_t        TimeLastXRRecv; /* Time last SR/RR was received */
    RtpTime_t        TimeLastSRRecv; /* Time last SR was received,
                                      * used to compute DLSR when
                                      * sending a RBlock reporting
                                      * this participant */
    /* Used to do bandwidth estimation */
    double           dInterSRRecvGap;/* Gap between the last 2 SR sent
                                      * as seen by the receiver */
    double           dInterSRSendGap;/* Gap between the last 2 SR sent
                                      * as indicated in the NTP field */
    double           dLastTimeEstimation;
    double           dBinBandwidth[RTCP_BANDESTIMATION_MAXBINS];
    DWORD            dwBinFrequency[RTCP_BANDESTIMATION_MAXBINS];
    DWORD            dwBestBin;
    DWORD            dwBandEstRecvCount;

    /* Used to compute RTT */
    RtpTime_t        NTP_sr_rtt;     /* NTP time in last SR received, 
                                      * used to compute LSR when
                                      * sending a RBlock reporting
                                      * this participant */
    DWORD            t_sr_rtt;       /* Timestamp in last SR report */
    
    /* Used to compute playout delay, don't care about real delay */
    double           dNTP_ts0;       /* NTP time at RTP sample 0 */
    double           dDiN;           /* Accumulated delay for N packets */
    long             lDiMax;         /* Set the initial Ni's to compute Di */
    long             lDiCount;       /* Running counter for lDiMax */
    double           Ni;             /* Packet's i delay */
    double           Di;             /* Average delay */
    double           Vi;             /* Delay's standard deviation */
    double           ViPrev;         /* Delay's standard deviation */
    double           dPlayout;       /* Playout delay for current talkspurt */

    /* Used to compute the play time */
    double           dRedPlayout;   /* Playout delay needed for redundancy */
    double           dMinPlayout;   /* Minimum playout delay */
    double           dMaxPlayout;   /* Maximum playout delay */
    DWORD            dwBeginTalkspurtTs;/* RTP ts when the talkspurt began */
    double           dBeginTalkspurtTime;/* Time at last begin of talkspurt */
    double           dLastTimeMarkerBit;/* Last time we saw a marker bit set */
    LONGLONG         llBeginTalkspurt;/* DShow time at last begin of
                                       * talkspurt */

    DWORD            dwMaxTimeStampOffset;/* Max offset in redundant block */
    DWORD            dwRedCount;     /* How many packets with same distance */
    DWORD            dwNoRedCount;   /* How many packets without redundancy */
    
    /* ... */
    double           dCreateTime;    /* Time it was created */
    double           dByeTime;       /* Time BYE was received */
} RtpNetRState_t;

/**********************************************************************
 * Each remote participants has its structure (there may be a global
 * heap for all the unicast sessions, say g_RtpUserHeap, and the
 * multicast sessions could have its own separate heap, say
 * m_UserHeap).
 **********************************************************************/
/* Some flags in RtpUser_t.dwUserFlags */
enum {
    FGUSER_FIRST,

    FGUSER_FIRST_RTP,    /* First RTP packet has been received */
    FGUSER_SR_RECEIVED,  /* SR has been received */
    FGUSER_VALIDATED,    /* This user was validated by receiving N
                          * consecutive packets or a valid RTCP report */
    FGUSER_RTPADDR,      /* RTP source address and port are learned */
    FGUSER_RTCPADDR,     /* RTCP source address and port are learned */

    FGUSER_LAST
};

/* Some flags in RtpUser_t,dwUserFlags2 */
enum {
    FGUSER2_FIRST,
    
    FGUSER2_MUTED,        /* Mute state */
    FGUSER2_NETEVENTS,    /* Generate network quality events */

    FGUSER2_LAST
};
    

typedef struct _RtpUser_t {
    DWORD            dwObjectID;      /* Identifies structure */
    RtpQueueItem_t   UserQItem;       /* Shared with Cache1Q, Cache2Q,
                                       * AliveQ and ByeQ */
    DWORD            dwUserFlags;     /* User flags */
    long             lPendingPackets; /* Red or out of seq. packets */

    RtpQueueItem_t   ReportQItem;     /* To create a report list */
    RtpQueueItem_t   HashItem;        /* To be kept in Hash */
    
    RtpAddr_t       *pRtpAddr;        /* Address owning this participant */
    DWORD            dwSSRC;          /* NETWORK ORDER SSRC */
    DWORD            dwUserState;     /* Current user's state */
    DWORD            dwUserFlags2;    /* E.g. events, mute */
    RtpOutput_t     *pRtpOutput;      /* User info passed on RTP reception */
    
    RtpCritSect_t    UserCritSect;    /* Participant's lock */
    RtpNetCount_t    RtpUserCount;    /* Receiving network counters */
    RtpNetRState_t   RtpNetRState;    /* This user/SSRC's network state */
    RtpNetInfo_t     RtpNetInfo;      /* Avg RTT, jitter, losses */

    DWORD            dwSdesPresent;   /* What items are already stored */
    RtpSdes_t       *pRtpSdes;        /* Participant's SDES info */

    DWORD            dwAddr[2];       /* RTP/RTCP source addr NETWORK ORDER */
    WORD             wPort[2];        /* RTP/RTCP source port NETWORK ORDER */

    
} RtpUser_t;

/**********************************************************************
 * A receiver can have several outputs. Outputs can be assigned to
 * active senders in different ways.
 **********************************************************************/

/* Flags in RtpOutput_t.dwOutputFlags */
enum {
    RTPOUTFG_FIRST,

    /* Output is not assigned */
    RTPOUTFG_FREE,
    
    /* Can only be explicitly assigned/unassigned */
    RTPOUTFG_MANUAL,
    
    /* Can be automatically assigned */
    RTPOUTFG_AUTO,

    /* If output timeouts, it is unassigned */
    RTPOUTFG_ENTIMEOUT,   

    /* This output can be used */
    RTPOUTFG_ENABLED,
    
    RTPOUTFG_LAST
};

typedef struct _RtpOutput_t {
    DWORD            dwObjectID;      /* Identifies structure */
    RtpQueueItem_t   OutputQItem;     /* RtpOutQ */
    int              iOutMode;        /* Output mode */
    DWORD            dwOutputFlags;   /* Output flags */
    RtpUser_t       *pRtpUser;        /* This output owner */
    void            *pvUserInfo;      /* Info to pass up, e.g. a DShow
                                       * pin */
} RtpOutput_t;

/**********************************************************************
 * Each participant has this structure to hold the SDES data (there
 * may be a global heap for all the unicast sessions, say,
 * g_RtpSdesHeap, and the multicast sessions could have its own
 * separate heap, say m_SDESHeap, to hold the participants SDES
 * data).
 **********************************************************************/
typedef struct _RtpSdesItem_t {
    DWORD            dwBfrLen;        /* Total buffer size  (bytes) */
    DWORD            dwDataLen;       /* Actual data length (bytes) */
    TCHAR_t         *pBuffer;         /* Pointer to buffer  */
} RtpSdesItem_t;

/*
 * TODO right now I'm assigning a static array, but for scalability,
 * this need to be changed to a dynamic mechanism where I can allocate
 * 32, 64, 128 or 256 buffer sizes */
typedef struct _RtpSdes_t {
    DWORD            dwObjectID;      /* Identifies structure */
    RtpSdesItem_t    RtpSdesItem[RTCP_NUM_SDES + 1]; /* Include END:0 */
    /* TODO the following field will be removed when I change to a
     * dynamic memory allocation with different buffer sizes */
    char             SDESData[RTCP_MAX_SDES_SIZE * RTCP_NUM_SDES];
} RtpSdes_t;


/**********************************************************************
 * Each address has this structure to manage the QOS notifications.
 **********************************************************************/
typedef struct _RtpQosNotify_t {
    DWORD            dwObjectID;      /* Identifies structure */
    RtcpAddrDesc_t  *pRtcpAddrDesc;   /* Owner */
    
    double           dNextStart;      /* Scheduled to try at this time */
    
    HANDLE           hQosNotifyEvent; /* Signal QOS notification */
    
    DWORD            dwError;
    DWORD            dwTransfered;
    DWORD            dwNotifyFlags;
    WSAOVERLAPPED    Overlapped;

    DWORD            dwProviderLen;
    char            *ProviderInfo;
} RtpQosNotify_t;

/**********************************************************************
 * Each address has this structure to manage the QOS reservations.
 **********************************************************************/

#define MAX_QOS_NAME 16

typedef struct _QosInfo_t {
    TCHAR_t         *pName;
    DWORD            dwQosExtraInfo;
    FLOWSPEC         FlowSpec;
} QosInfo_t;

/* Some flags used in RtpQosReserve_t.dwReserveFlags */
typedef struct _ReserveFlags_f {
    DWORD            RecvFrameSizeValid:1;   /* Frame size is valid */
    DWORD            RecvFrameSizeWaiting:1; /* Waiting for valid frame size */
} ReserveFlags_f;
    
typedef struct _RtpQosReserve_t {
    DWORD            dwObjectID;      /* Identifies structure */
    RtpAddr_t       *pRtpAddr;        /* Owner */
    DWORD            dwStyle;
    ReserveFlags_f   ReserveFlags;
    const QosInfo_t *pQosInfo[2];
    DWORD            dwFrameSizeMS[2];
  

    /* Qos App ID */
    TCHAR_t         *psAppName;
    TCHAR_t         *psAppGUID;
    TCHAR_t         *psPolicyLocator;

    /* Lower bit rate sending */
    double           dLastAddition;
    DWORD            dwTokens;
    
    /* Used for Shared Explicit style - SE */
    DWORD            dwNumFilters;
    DWORD            dwMaxFilters;
    DWORD           *pdwRsvpSSRC;     /* SSRCs in filters */
    RSVP_FILTERSPEC *pRsvpFilterSpec; /* SE Filters */
    
    QOS              qos;
} RtpQosReserve_t;

/**********************************************************************
 * Maintain the encryption/decryption information 
 **********************************************************************/

enum {
    FGCRYPT_FIRST,

    FGCRYPT_INIT, /* Initialized, enable cryptography in this context */
    FGCRYPT_KEY,  /* Key has been set */
    FGCRYPT_DUMMY3,

    FGCRYPT_DECRYPTERROR, /* Prevent multiple times issuing the same error */
    FGCRYPT_ENCRYPTERROR, /* Prevent multiple times issuing the same error */
    
    FGCRYPT_LAST,
};

typedef struct _CryptFlags_f {
    DWORD            Dummy0:1;
    DWORD            KeySet:1;
    DWORD            Dummy3:1;
    DWORD            DecryptionError:1;
    DWORD            EncryptionError:1;
} CryptFlags_f;

typedef struct _RtpCrypt_t {
    DWORD            dwObjectID;      /* Identifies structure */
    RtpAddr_t       *pRtpAddr;        /* Owner */
    union {
        DWORD            dwCryptFlags;
        CryptFlags_f     CryptFlags;
    };
    long             lCryptRefCount;  /* Init/Del */

    DWORD            dwCryptLastError;
    
    /* MAYDO should I add a list of keys ? */
    DWORD            dwStyle;         /* Encryption style */
    int              iKeySize;        /* Key's size in bytes */
    /* Pass phrase to derive key */
    char             psPassPhrase[RTPCRYPT_PASSPHRASEBUFFSIZE];

    /* CryptoAPI */
    DWORD            dwProviderType;  /* Provider type */
    HCRYPTPROV       hProv;           /* Cryptographic Service Provider */

    ALG_ID           aiHashAlgId;     /* Hashing algorithm ID */
    HCRYPTHASH       hHash;           /* Hash handle */

    ALG_ID           aiDataAlgId;     /* Data algorithm ID */
    HCRYPTKEY        hDataKey;        /* Cryptographic key */ 
} RtpCrypt_t;


/**********************************************************************
 * Information needed for RTP asynchronous I/O (receive or send).
 **********************************************************************/

/* RtpIO_t, SendIo_t, RecvIo_t */
typedef struct _RtpRecvIO_t {
    DWORD            dwObjectID;      /* Identifies structure */
    RtpQueueItem_t   RtpRecvIOQItem;  /* Link */

    WSABUF           WSABuf;
    RtpUser_t       *pRtpUser;

    DWORD            dwWSError;
    DWORD            dwError;

    long             lHdrSize;
    /* Redundancy control */
    long             lRedHdrSize;
    long             lRedDataSize;

    DWORD            dwWSTransfered;
    DWORD            dwTransfered;

    DWORD            dwRtpWSFlags;
    DWORD            dwRtpIOFlags;

    SOCKADDR         From;
    int              Fromlen;

    double           dRtpRecvTime;   /* Time this packet was received */

    void            *pvUserInfo1;
    void            *pvUserInfo2;

    double           dPlayTime;      /* Relative time (to first sample
                                      * in the talkspurt) at which to
                                      * play the frame */
    /* Redundancy control */
    double           dPostTime;
    DWORD            dwTimeStamp;
    DWORD            dwMaxTimeStampOffset;
    WORD             wSeq;
    DWORD            dwExtSeq;
    BYTE             bPT_Block;
    
    WSAOVERLAPPED    Overlapped;
} RtpRecvIO_t;

typedef struct _RtpSendIO_t {
    DWORD            dwObjectID;      /* Identifies structure */
    WSABUF           WSABuf;
} RtpSendIO_t;

/**********************************************************************
 * Information needed for RTCP asynchronous I/O (receive or send).
 **********************************************************************/


typedef struct _RtcpRecvIO_t {
    DWORD            dwObjectID;      /* Identifies structure */
    RtcpAddrDesc_t   *pRtcpAddrDesc;   /* Owner */

    SOCKADDR         From;
    int              Fromlen;

    double           dRtcpRecvTime;  /* Time this packet was received */
    RtpTime_t        RtcpRecvTime;
    
    HANDLE           hRtcpCompletedEvent;/* Signal Recv I/O completed */

    WSABUF           WSABuf;
    DWORD            dwError;
    DWORD            dwTransfered;
    DWORD            dwRecvIOFlags;
    WSAOVERLAPPED    Overlapped;
    
    char             RecvBuffer[RTCP_RECVDATA_BUFFER];
} RtcpRecvIO_t;

typedef struct _RtcpSendIO_t {
    DWORD            dwObjectID;      /* Identifies structure */
    RtcpAddrDesc_t   *pRtcpAddrDesc;   /* Owner */
    char             SendBuffer[RTCP_SENDDATA_BUFFER];
} RtcpSendIO_t;

/**********************************************************************
 * RtcpAddrDesc_t contains the information that the RTCP thread needs
 * to receive/send RTCP reports, as well as receive asynchronous QOS
 * notifications
 **********************************************************************/
/* Some flags in RtcpAddrDesc_t.dwFlags */
enum {
    FGADDRD_FIRST,
    
    FGADDRD_RECVPENDING,            /* Asynchronous reception pending */
    FGADDRD_NOTIFYPENDING,          /* A notification is pending */
    FGADDRD_NOTIFYBUSY,             /* Normal notifications, in QosBusyQ */

    /* Sockets are closed after FGADDRD_SHUTDOWN1 is set, but before
     * FGADDRD_SHUTDOWN2 is set */
    FGADDRD_SHUTDOWN1,              /* Address about to shut down */
    FGADDRD_SHUTDOWN2,              /* Address shutting down */
    FGADDRD_DUMMY6,
    FGADDRD_DUMMY7,
    
    FGADDRD_INVECTORRECV,           /* In the events vector */
    FGADDRD_INVECTORQOS,            /* In the events vector */
    
    FGADDRD_LAST
};

typedef struct _AddrDescFlags_f {
    DWORD           Dummy0:1;
    DWORD           RECVPENDING:1;
    DWORD           NOTIFYPENDING:1;
    DWORD           NOTIFYBUSY:1;
    DWORD           FGADDRD_SHUTDOWN1:1;
    DWORD           FGADDRD_SHUTDOWN2:1;
    DWORD           Dummy6:1;
    DWORD           Dummy7:1;
    DWORD           INVECTORRECV:1;
    DWORD           INVECTORQOS:1; 
} AddrDescFlags_f;

typedef struct _RtcpAddrDesc_t {
    DWORD            dwObjectID;      /* Identifies structure */
    RtpQueueItem_t   AddrDescQItem;   /* RtcpContext queues:
                                       * AddrDescFreeQ, AddrDescBusyQ,
                                       * AddrDescStopQ */
    RtpAddr_t       *pRtpAddr;        /* Owner address */

    /* Some flags */
    union {
        DWORD            dwAddrDescFlags;
        AddrDescFlags_f  AddrDescFlags;
    };
    
    long             lRtcpPending;    /* Number of RTCP pending I/Os */
    long             lQosPending;     /* Number of QOS notifications pending */
    DWORD            dwDescIndex;     /* Position in descriptors vector */
    SOCKET           Socket[3];       /* Same as RtpAddr_t.Socket[3] */

    /* QOS notifications */
    RtpQueueItem_t   QosQItem;        /* RtcpContext queues:
                                       * QosStartQ, QosBusyQ, QosStopQ */
    RtpQosNotify_t  *pRtpQosNotify;  /* QOS notifications */

    /* Receive */
    RtpQueueItem_t   RecvQItem;       /* Link for all receivers NOT USED */
    RtcpRecvIO_t    *pRtcpRecvIO;     /* RTCP reception buffer */
    
    /* Send */
    RtpQueueItem_t   SendQItem;       /* Link for all senders */
    RtcpSendIO_t    *pRtcpSendIO;     /* RTCP sending buffer */

#if USE_RTCP_THREAD_POOL > 0
    HANDLE           hRecvWaitObject;  /* RTCP reception wait object */
    HANDLE           hQosWaitObject;   /* QOS notifications wait object */
#endif /* USE_RTCP_THREAD_POOL > 0 */
} RtcpAddrDesc_t;

/**********************************************************************
 * RtpContext_t contains some general information
 **********************************************************************/
typedef struct _RtpContext_t
{
    DWORD            dwObjectID;      /* Identifies structure */
    
    RtpQueue_t       RtpSessQ;
    RtpCritSect_t    RtpContextCritSect;

    /* Memory currently allocated by all private heaps */
    long             lMemAllocated;
    /* Maximum memory ever allocated by all private heaps */
    long             lMaxMemAllocated;

    /* Performance counter frequency (if available) */
    LONGLONG         lPerfFrequency;
    
    union {
        /* RTP's reference time in ms, initialized once and then left
         * as it is */
        DWORD            dwRtpRefTime;
        /* Another version of the same time */
        LONGLONG         lRtpRefTime;
    };

    union {
        /* Remembers last known time, used only when debugging, time
         * is relative to the reference time in ms (elapsed time) */
        DWORD            dwRtpCurTime;
        /* Another version of the same time */
        LONGLONG         lRtpCurTime;
    };
        
    /* RTP's reference time in seconds since midnight (00:00:00),
     * January 1, 1970, coordinated universal time (UTC) */
    double           dRtpRefTime;

    long             lNumSourceFilter;
    long             lMaxNumSourceFilter;
    long             lNumRenderFilter;
    long             lMaxNumRenderFilter;
    
    long             lNumRtpSessions;
    long             lMaxNumRtpSessions;
    
    long             lNumRecvRunning;
    long             lNumSendRunning;

    /* Winsock2 */
    RtpCritSect_t    RtpWS2CritSect;
    long             lRtpWS2Users;
    SOCKET           RtpQuerySocket;

    /* Ports allocation */
    RtpQueueHash_t   RtpPortsH;
    RtpCritSect_t    RtpPortsCritSect;

} RtpContext_t;

/**********************************************************************
 * RtpRedEntry_t information about a redundant frame
 **********************************************************************/
typedef struct _RtpRedEntry_t
{
    BOOL             bValid;      /* This frame can be used */
    BYTE             bRedPT;      /* Redundant block's payload type */
    /* This buffer's original seq number */
    union {
        struct {
            WORD             wSeq:16; /* Sending sequence number */
            WORD             wSeqH:16;/* High part for the sequence number */
        };
        DWORD            dwSeq;       /* 32bits sequence number */
    };
    DWORD            dwTimeStamp; /* First sample's timestamp */
    WSABUF           WSABuf;      /* Buffer description */
} RtpRedEntry_t;

/**********************************************************************
 * Some flags used in other places
 **********************************************************************/

/* Flags that can be used in parameter dwSendFlags of RtpSendTo */
enum {
    FGSEND_FIRST,
    
    FGSEND_DTMF,    /* Use DTMF payload type */
    FGSEND_USERED,  /* Use redundant data */
    FGSEND_FORCEMARKER, /* Used with first DTMF packet */
    
    FGSEND_LAST
};

/* Flags used in pRtpRecvIO->dwRtpIOFlags, also passed in
 * RtpRecvCompletionFunc when a packet is received or used during RTCP
 * reception in an analog way as used in pRtpRecvIO->dwRtpIOFlags */
enum {
    FGRECV_FIRST,
    
    FGRECV_ERROR,   /* WS2 error or invalid, reason is in dwError */
    FGRECV_DROPPED, /* Valid but need to drop it, reason is in dwError */
    FGRECV_DUMMY3,
    
    FGRECV_MUTED,   /* Packet dropped because in mute state */
    FGRECV_INVALID, /* Packet dropped because invalid */
    FGRECV_LOOP,    /* Packet dropped because loopback discard */
    FGRECV_MISMATCH,/* Packet dropped because mismatched source address */

    FGRECV_NOTFOUND,/* Packet dropped because user not found */
    FGRECV_CRITSECT,/* Packet dropped because failure to enter critsect */
    FGRECV_SHUTDOWN,/* Packet dropped because we are Shuting down */
    FGRECV_PREPROC, /* Packet dropped because pre-process failed */

    FGRECV_OBSOLETE,/* Packet dropped because it is a dup or an old one */
    FGRECV_FAILSCHED,/* Packet dropped because couldn't be scheduled */
    FGRECV_BADPT,   /* Packet dropped because an unknown PT was received */
    FGRECV_RANDLOSS,/* Packet dropped simulating random losses */

    FGRECV_USERGONE,/* User is deleted so its pending IO is dropped */
    FGRECV_DUMMY17,
    FGRECV_DUMMY18,
    FGRECV_DUMMY19,
    
    FGRECV_WS2,     /* Packet dropped because a WS2 error */
    FGRECV_DUMMY21,
    FGRECV_DUMMY22,
    FGRECV_DUMMY23,
    
    FGRECV_MAIN,    /* Contains main data, as opossed to redundant data */
    FGRECV_HASRED,  /* This (main) buffer contains redundancy */
    FGRECV_DUMMY26,
    FGRECV_MARKER,  /* Marker bit value in main packet */
    
    FGRECV_ISRED,   /* This buffer is a redundant block */
    FGRECV_HOLD,    /* Process this buffer but leave unchanged for
                     * further use */
    
    FGRECV_LAST
};

#endif /* _struct_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\msrtp\dsapi\dsrtpapi.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    msrtpapi.c, dsrtpapi.c
 *
 *  Abstract:
 *
 *    Contains the raw RTP implementation API, can be linked as a
 *    library (rtp.lib), linked into a DLL (msrtp.dll), or linked into
 *    a DShow DLL (dsrtp.dll).
 *
 *    This file is edited as msrtpapi.c and duplicated as dsrtpapi.c,
 *    each version is compiled with different flags
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/18 created
 *
 **********************************************************************/

#include <winsock2.h>

#include "gtypes.h"
#include "struct.h"
#include "rtphdr.h"
#include "rtpheap.h"
#include "rtprand.h"
#include "rtpglobs.h"
#include "rtpreg.h"
#include "rtcpsdes.h"

#include "rtpfwrap.h"
#include "rtpsess.h"

#include "rtpstart.h"
#include "rtprecv.h"
#include "rtpsend.h"

#include "rtcpthrd.h"

#include "rtpaddr.h"

#include "msrtpapi.h"

RTPSTDAPI CreateRtpSess(
        RtpSess_t **ppRtpSess
    )
{
    HRESULT hr;
    
    hr = GetRtpSess(ppRtpSess);

    return(hr);
}

RTPSTDAPI DeleteRtpSess(
        RtpSess_t *pRtpSess
    )
{
    HRESULT hr;
    
    hr = DelRtpSess(pRtpSess);

    return(hr);
}

/* TODO this two shouldn't be exposed, but I need them before I can
   use Control */

RTPSTDAPI CreateRtpAddr(
        RtpSess_t  *pRtpSess,
        RtpAddr_t **ppRtpAddr,
        DWORD       dwFlags
    )
{
    HRESULT hr;

    hr = GetRtpAddr(pRtpSess, ppRtpAddr, dwFlags);

    return(hr);
}

RTPSTDAPI DeleteRtpAddr(
        RtpSess_t *pRtpSess,
        RtpAddr_t *pRtpAddr
    )
{
    HRESULT hr;

    hr = DelRtpAddr(pRtpSess, pRtpAddr);

    return(hr);
}


RTPSTDAPI RtpControl(RtpSess_t *pRtpSess,
                     DWORD      dwControl,
                     DWORD_PTR  dwPar1,
                     DWORD_PTR  dwPar2)
{
    RtpControlStruct_t RtpControlStruct;
    
    if (!pRtpSess)
    {
        return(RTPERR_POINTER);
    }

    /*
     * TODO (may be) validate RtpSess by verifying that the memory
     * block is an item in the BusyQ in the g_pRtpSessHeap */
    if (pRtpSess->dwObjectID != OBJECTID_RTPSESS)
    {
        return(RTPERR_INVALIDRTPSESS);
    }

    /* Initialize Control structure */
    ZeroMemory(&RtpControlStruct, sizeof(RtpControlStruct_t));
    RtpControlStruct.pRtpSess = pRtpSess;
    RtpControlStruct.dwControlWord = dwControl;
    RtpControlStruct.dwPar1 = dwPar1;
    RtpControlStruct.dwPar2 = dwPar2;

    return( RtpValidateAndExecute(&RtpControlStruct) );
}

RTPSTDAPI RtpGetLastError(RtpSess_t *pRtpSess)
{
    return(NOERROR);
}
        
RTPSTDAPI RtpRegisterRecvCallback(
        RtpAddr_t       *pRtpAddr,
        PRTP_RECVCOMPLETIONFUNC pRtpRecvCompletionFunc
    )
{
    if (!pRtpAddr)
    {
        return(RTPERR_POINTER);
    }
    
    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        return(RTPERR_INVALIDRTPSESS);
    }

    pRtpAddr->pRtpRecvCompletionFunc = pRtpRecvCompletionFunc;

    return(NOERROR);
}

RTPSTDAPI RtpRecvFrom(
        RtpAddr_t *pRtpAddr,
        WSABUF    *pWSABuf,
        void      *pvUserInfo1,
        void      *pvUserInfo2
    )
{
    HRESULT hr;
    
    hr = RtpRecvFrom_(pRtpAddr,
                      pWSABuf,
                      pvUserInfo1,
                      pvUserInfo2
        );

    return(hr);
}


RTPSTDAPI RtpSendTo(
        RtpAddr_t *pRtpAddr,
        WSABUF    *pWSABuf,
        DWORD      dwWSABufCount,
        DWORD      dwTimeStamp,
        DWORD      dwSendFlags
    )
{
    HRESULT hr;
    
    hr = RtpSendTo_(pRtpAddr, pWSABuf, dwWSABufCount, dwTimeStamp,dwSendFlags);

    return(hr);
}

RTPSTDAPI RtpStart(
        RtpSess_t *pRtpSess,
        DWORD      dwFlags
    )
{
    HRESULT hr;

    hr = RtpStart_(pRtpSess, dwFlags);

    return(hr);
}

RTPSTDAPI RtpStop(
        RtpSess_t *pRtpSess,
        DWORD      dwFlags
    )
{
    HRESULT hr;

    hr = RtpStop_(pRtpSess, dwFlags);

    return(hr);
}

/*
 * Initializes all the modules that require initialization. This
 * function can be called from DllMain(PROCESS_ATTACH) if linked as a
 * DLL, or explicitly from an application initializing the RTP stack
 * if linked as a library. */
RTPSTDAPI MSRtpInit1(HINSTANCE hInstance)
{
    HRESULT          hr1;
    HRESULT          hr2;
    BOOL             bOk1;
    BOOL             bOk2;
    BOOL             bOk3;
    BOOL             bOk4;

    /* One time operation that doesn't need de-init */
    /* NOTE this function will zero g_RtpContext */
    RtpInitReferenceTime();
    
    hr1 = RtpInit();
    
    /* initialize heaps */
    bOk1 = RtpCreateMasterHeap();
    bOk2 = RtpCreateGlobHeaps();
    
    bOk3 = RtpInitializeCriticalSection(&g_RtpContext.RtpWS2CritSect,
                                        &g_RtpContext,
                                        _T("g_RtpContext.RtpWS2CritSect"));

    bOk4 = RtpInitializeCriticalSection(&g_RtpContext.RtpPortsCritSect,
                                        &g_RtpContext,
                                        _T("g_RtpContext.RtpPortsCritSect"));


    hr2 = RtcpInit();

    if (!bOk1 || !bOk2 || !bOk3 || !bOk4 ||
        (hr1 != NOERROR) || (hr2 != NOERROR))
    {
        MSRtpDelete1();
        return(RTPERR_FAIL);
    }

    return(NOERROR);
}

/*
 * This function does initialization not allowed during process
 * attach, e.g. initialize winsock2 */
RTPSTDAPI MSRtpInit2(void)
{
    HRESULT          hr;
    BOOL             bOk;
    DWORD            dwError;
    WSADATA          WSAData;
    WORD             VersionRequested;
    

    hr = RTPERR_FAIL;

    /* Critical section was initialized during process attach by
     * MSRtpInit1 */
    bOk = RtpEnterCriticalSection(&g_RtpContext.RtpWS2CritSect);

    if (bOk)
    {
        if (g_RtpContext.lRtpWS2Users <= 0)
        {
            /* Initialize some debug variables */
            hr = RtpDebugInit(RTPDBG_MODULENAME);

            /* initialize winsock */
            VersionRequested = MAKEWORD(2,0);
            
            dwError = WSAStartup(VersionRequested, &WSAData);

            if (dwError == 0)
            {
                /* socket used to query destination address */
                g_RtpContext.RtpQuerySocket = WSASocket(
                        AF_INET,    /* int af */
                        SOCK_DGRAM, /* int type */
                        IPPROTO_IP, /* int protocol */
                        NULL,       /* LPWSAPROTOCOL_INFO lpProtocolInfo */
                        0,          /* GROUP g */
                        NO_FLAGS    /* DWORD dwFlags */
                    );
        
                if (g_RtpContext.RtpQuerySocket == INVALID_SOCKET)
                {
                    WSACleanup();
                }
                else
                {
                    RtpRegistryInit(&g_RtpReg);

                    /* Needs to be called after RtpRegistryInit so the
                     * possible registry defaults are already read */
                    RtcpSdesInit(&g_RtpSdesDefault);
                    RtcpSdesSetDefault(&g_RtpSdesDefault);

                    RtpRandInit();
                    
                    g_RtpContext.lRtpWS2Users = 1;

                    hr = NOERROR;
                }
            }
        }
        else
        {
            g_RtpContext.lRtpWS2Users++;

            hr = NOERROR;
        }

        RtpLeaveCriticalSection(&g_RtpContext.RtpWS2CritSect);
    }

    return(hr);
}

            
/*
 * Complementary function of MSRtpInit(). Can be called from
 * DllMain(PROCESS_DETACH) if linked as a DLL, or explicitly from an
 * application de-initializing the RTP stack if linked as a
 * library. */
RTPSTDAPI MSRtpDelete1(void)
{
    HRESULT          hr1;
    HRESULT          hr2;
    BOOL             bOk1;
    BOOL             bOk2;
    BOOL             bOk3;
    BOOL             bOk4;

    hr1 = RtpDelete();
    hr2 = RtcpDelete();

    bOk1 = RtpDestroyGlobHeaps();
    bOk2 = RtpDestroyMasterHeap();

    bOk3 = RtpDeleteCriticalSection(&g_RtpContext.RtpWS2CritSect);

    bOk4 = RtpDeleteCriticalSection(&g_RtpContext.RtpPortsCritSect);
    
    if ((hr1 != NOERROR) || (hr2 != NOERROR) ||
        !bOk1 || !bOk2 || !bOk3 || !bOk4)
    {
        return(RTPERR_FAIL);
    }
    else
    {
        return(NOERROR);
    }
}

/*
 * Complementary function of MSRtpInit2(). */
RTPSTDAPI MSRtpDelete2(void)
{
    HRESULT          hr;
    DWORD            dwError;
    BOOL             bOk;

    dwError = NOERROR;
    
    /* Critical section was initialized during process attach by
     * MSRtpInit1 */
    bOk = RtpEnterCriticalSection(&g_RtpContext.RtpWS2CritSect);

    if (bOk)
    {
        g_RtpContext.lRtpWS2Users--;

        if (g_RtpContext.lRtpWS2Users <= 0)
        {
            if (g_RtpContext.RtpQuerySocket != INVALID_SOCKET)
            {
                closesocket(g_RtpContext.RtpQuerySocket);
                g_RtpContext.RtpQuerySocket = INVALID_SOCKET;
            }
        
            dwError = WSACleanup();

            RtpRandDeinit();

            RtpRegistryDel(&g_RtpReg);

            RtpDebugDeinit();
        }

        RtpLeaveCriticalSection(&g_RtpContext.RtpWS2CritSect);
    }

    if ((bOk == FALSE) || (dwError != NOERROR))
    {
        return(RTPERR_FAIL);
    }
    else
    {
        return(NOERROR);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\msrtp\funcs\rtpglob.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpglob.c
 *
 *  Abstract:
 *
 *    Implements the RTP Global family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/02 created
 *
 **********************************************************************/

#include "struct.h"
#include "rtpglob.h"

HRESULT ControlRtpGlob(RtpControlStruct_t *pRtpControlStruct)
{

    return(NOERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\msrtp\funcs\rtpdejit.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpdejit.c
 *
 *  Abstract:
 *
 *    Compute delay, jitter and playout delay
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/12/03 created
 *
 **********************************************************************/

#include "rtpglobs.h"
#include "rtpreg.h"

#include "rtpdejit.h"

BOOL RtpDetectTalkspurt(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        RtpHdr_t        *pRtpHdr,
        double           dTime
    );

double RtpPlayout(RtpAddr_t *pRtpAddr, RtpUser_t *pRtpUser);

double           g_dMinPlayout = MIN_PLAYOUT / 1000.0;
double           g_dMaxPlayout = MAX_PLAYOUT / 1000.0;

/*
 * Ai = Arrival time for packet i
 * Ti = Transmit time for packet i
 * Ni = Delay (transit time) for packet i, Ni = Ai - Ti
 * ti = time stamp for packet i 
 * NTP_sr = converted NTP time correponding to t_sr, sent in last SR report
 * t_sr = RTP timestamp matching NTP time sent in last SR report
 * */
 
DWORD RtpUpdateNetRState(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        RtpHdr_t        *pRtpHdr,
        RtpRecvIO_t     *pRtpRecvIO
    )
{
    BOOL             bOk;
    BOOL             bNewTalkSpurt;
    DWORD            ti;      /* RTP timestamp */
    double           Ai;      /* Arrival time (s) */
    double           Ti;      /* Transmit time (s) */
    double           Ni;      /* Delay (s) */
    double           dDiff;
    DWORD            dwDelta;
    long             lTransit;
    RtpNetRState_t  *pRtpNetRState;

    TraceFunctionName("RtpUpdateNetRState");

    Ai = pRtpRecvIO->dRtpRecvTime;
    
    /*
     * Update variables needed to compute the playout delay
     */
    
    pRtpNetRState = &pRtpUser->RtpNetRState;

    bOk = RtpEnterCriticalSection(&pRtpUser->UserCritSect);

    /* Don't want to get inconsistent values if a SR report arrives
     * and these variables are being modified */

    if (bOk == FALSE)
    {
        return(RTPERR_CRITSECT);
    }

    if (!pRtpNetRState->dwRecvSamplingFreq)
    {
        /* Can not update these statistical variables if I don't know
         * the sampling frequency */
        RtpLeaveCriticalSection(&pRtpUser->UserCritSect);

        TraceRetail((
                CLASS_WARNING, GROUP_RTP, S_RTP_PLAYOUT,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] ")
                _T("No sampling frequency, skip jitter stats"),
                _fname, pRtpAddr, pRtpUser
            ));
       
        return(NOERROR);
    }

    /* This sample RTP timestamp */
    ti = ntohl(pRtpHdr->ts);

    /* Obtain transmit time at source (using source's time) */
    Ti = pRtpNetRState->dNTP_ts0 +
        ((double)ti / pRtpNetRState->dwRecvSamplingFreq);

    /* Compute delay */
    pRtpNetRState->Ni = Ai - Ti;

    /* Process the initial delay average for first N packets if needed */
    if (pRtpNetRState->lDiMax)
    {
        pRtpNetRState->lDiCount++;

        pRtpNetRState->dDiN += pRtpNetRState->Ni;
        
        if (pRtpNetRState->lDiCount >= pRtpNetRState->lDiMax)
        {
            TraceDebugAdvanced((
                    0, GROUP_RTP, S_RTP_PLAYOUT,
                    _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                    _T("Begin resyncing: Ni:%0.3f Di:%0.3f Vi:%0.3f ")
                    _T("sum(Ni)/%u:%0.3f"),
                    _fname, pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC),
                    pRtpNetRState->Ni, pRtpNetRState->Di, pRtpNetRState->Vi,
                    pRtpNetRState->lDiCount,
                    pRtpNetRState->dDiN / pRtpNetRState->lDiCount
                ));
            
            RtpInitNetRState(pRtpUser, pRtpHdr, Ai);

            TraceDebugAdvanced((
                    0, GROUP_RTP, S_RTP_PLAYOUT,
                    _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                    _T("Done  resyncing: Ni:%0.3f Di:%0.3f Vi:%0.3f"),
                    _fname, pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC),
                    pRtpNetRState->Ni, pRtpNetRState->Di, pRtpNetRState->Vi
                ));

            /* Allow the big delay detection to happen again if we had
             * been consistently with a big delay. I adjust once when
             * the big delay count is reached, but not with next
             * packets with big delay. If big delay persists, then the
             * only way to attempt another resync is by reseting to 0
             * this counter */
            pRtpNetRState->lBigDelay = 0;
        }
    }

    if (pRtpNetRState->Ni > 7200.0)
    {
        /* The RTP timestamp just had a wrap around or was reset */
        TraceRetail((
                CLASS_WARNING, GROUP_RTP, S_RTP_PLAYOUT,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] ")
                _T("RTP timestamp just wrap around Ni:%0.3f ts:%u"),
                _fname, pRtpAddr, pRtpUser, pRtpNetRState->Ni, ti
            ));

        /* Resync Ni and Di to the relative delay */
        RtpOnFirstPacket(pRtpUser, pRtpHdr, Ai);

        /* Update hypothetical transmit time */
        Ti = pRtpNetRState->dNTP_ts0 +
            ((double)ti / pRtpNetRState->dwRecvSamplingFreq);

        /* Ni should be the relative delay */
        pRtpNetRState->Ni = RELATIVE_DELAY;
    }
    
    /* Compute average delay */
    pRtpNetRState->Di = pRtpAddr->dAlpha * pRtpNetRState->Di +
        (1.0 - pRtpAddr->dAlpha) * pRtpNetRState->Ni;

    /* Compute standard deviation */
    dDiff = pRtpNetRState->Di - pRtpNetRState->Ni;
    
    if (dDiff < 0)
    {
        dDiff = -dDiff;
    }

    /*
     * TOIMPROVE The algorithm used here to compute delay and
     * variance, DO NOT follow well sudden big changes in the delay
     * (those changes can occur when a machine adjusts its local time
     * by a big step). In order to adjust to those changes, I need a
     * mechanism that detect those step changes but still filters
     * random spikes */
    /* TODO this is a temporary solution to detect the jumps in the
     * delay and quickly converge the average delay to that new
     * delay. It is not that this mechanism is a bad solution but is a
     * specialized solution to deal with a specific case, the
     * improvement I'm refering to above, is a more generalized
     * algorithm that would protect against this and other anomalies
     * */
    if (dDiff > (g_dMaxPlayout / 4 ))
    {
        pRtpNetRState->lBigDelay++;

        if (pRtpNetRState->lBigDelay == 1)
        {
            /* First time the big delay is detected, save the current
             * delay variance so it can be restored later if this
             * happens to be a delay jump */
            if (!pRtpNetRState->ViPrev ||
                pRtpNetRState->Vi < pRtpNetRState->ViPrev)
            {
                pRtpNetRState->ViPrev = pRtpNetRState->Vi;
            }
        }
        else if ((pRtpNetRState->lBigDelay == SHORTDELAYCOUNT))
        {
            /* Mean delay and current delay are too far apart, start
             * the resync process. */
            /* NOTE that resyncing for big delay jumps happens after
             * twice SHORTDELAYCOUNT, once to validate the big jump,
             * second to resync to the short average */
            RtpPrepareForShortDelay(pRtpUser, SHORTDELAYCOUNT);
        }
    }
    else
    {
        pRtpNetRState->lBigDelay = 0; 
    }
    
    /* Compute delay variance */
    pRtpNetRState->Vi = pRtpAddr->dAlpha * pRtpNetRState->Vi +
        (1.0 - pRtpAddr->dAlpha) * dDiff;

    if (!(ntohs(pRtpHdr->seq) & 0x7))
    {
        TraceDebugAdvanced((
                0, GROUP_RTP, S_RTP_PERPKTSTAT1,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                _T("Ai:%0.3f Ti:%0.3f ti:%u Ni:%0.3f Di:%0.3f Vi:%0.3f "),
                _fname, pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC),
                Ai, Ti, ti,
                pRtpNetRState->Ni, pRtpNetRState->Di, pRtpNetRState->Vi
            ));
    }

    if (pRtpNetRState->Ni > 5.0 || pRtpNetRState->Ni < -5.0)
    {
        TraceDebugAdvanced((
                0, GROUP_RTP, S_RTP_PERPKTSTAT2,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                _T("Ai:%0.3f Ti:%0.3f ti:%u Ni:%0.3f Di:%0.3f Vi:%0.3f "),
                _fname, pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC),
                Ai, Ti, ti,
                pRtpNetRState->Ni, pRtpNetRState->Di, pRtpNetRState->Vi
            ));
    }

    /*
     * Compute playout delay if we have a new talkspurt and playout
     * delay use is enabled
     */
    if (RtpBitTest(pRtpAddr->dwIRtpFlags, FGADDR_IRTP_USEPLAYOUT))
    {
        bNewTalkSpurt = RtpDetectTalkspurt(pRtpAddr, pRtpUser, pRtpHdr, Ai);

        /* MARKER flag might need to be set to a different value than
         * it had when the packet was received */
        if (bNewTalkSpurt)
        {
            pRtpNetRState->dPlayout = RtpPlayout(pRtpAddr, pRtpUser);
            pRtpNetRState->dwBeginTalkspurtTs = ti;
            pRtpNetRState->dBeginTalkspurtTime = Ai;

            pRtpRecvIO->dPlayTime = pRtpNetRState->dPlayout;
            RtpBitSet(pRtpRecvIO->dwRtpIOFlags, FGRECV_MARKER);

            /* On each new talkspurt update reference time used to
             * compute playout delay (delay, variance). This variables
             * will be needed only on the next talkspurt */
            RtpPrepareForShortDelay(pRtpUser, SHORTDELAYCOUNT);
        }
        else
        {
            dwDelta = ti - pRtpNetRState->dwBeginTalkspurtTs;
            
            pRtpRecvIO->dPlayTime = pRtpNetRState->dPlayout +
                ((double)dwDelta / pRtpNetRState->dwRecvSamplingFreq);
            RtpBitReset(pRtpRecvIO->dwRtpIOFlags, FGRECV_MARKER);
        }

        /* This TraceDebug useful only to debug problems */
        /* Ai seq  size ts Ni  Di  Vi  Jit Playtime marker sampling_freq */
        TraceDebugAdvanced((
                0, GROUP_RTP, S_RTP_PERPKTSTAT3,
                _T("%s: pRtpUser[0x%p] SSRC:0x%X ")
                _T("@ %0.3f %u 0 %u %0.3f %0.3f %0.3f %0.3f %0.3f %u %u"),
                _fname, pRtpUser, ntohl(pRtpUser->dwSSRC),
                Ai, pRtpRecvIO->dwExtSeq, ti, pRtpNetRState->Ni,
                pRtpNetRState->Di, pRtpNetRState->Vi,
                (double)pRtpNetRState->jitter/
                pRtpNetRState->dwRecvSamplingFreq,
                pRtpRecvIO->dPlayTime,
                bNewTalkSpurt,
                pRtpNetRState->dwRecvSamplingFreq/1000
            ));
    }
    
    /*
     * Compute jitter to be used in RR reports
     */

    /* The transit time may be negative */
    lTransit = (long) (pRtpNetRState->Ni * pRtpNetRState->dwRecvSamplingFreq);

    /* Current delay difference (i.e. packet i and packet i-1) */
    if (!pRtpNetRState->transit)
    {
        /* Initialize previous transit time to be equal to current */
        pRtpNetRState->transit = lTransit;
    }

    /* Conversion: (double) (DW1 - DW2) gives a wrong big positive
     * number if DW2 > DW1 */
    if (lTransit >= pRtpNetRState->transit)
    {
        dDiff = lTransit - pRtpNetRState->transit;
    }
    else
    {
        dDiff = pRtpNetRState->transit - lTransit;
    }
    
    pRtpNetRState->transit = lTransit;
    
    pRtpNetRState->jitter +=
        (int) ((1.0/16.0) * (dDiff - pRtpNetRState->jitter));

    /* This TraceDebug useful only to debug problems */
    TraceDebugAdvanced((
            0, GROUP_RTP, S_RTP_PERPKTSTAT4,
            _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
            _T("Ai:%0.3f ti:%u transit:%d diff:%0.0f ")
            _T("jitter:%u (%0.3f)"),
            _fname, pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC),
            Ai, ti, lTransit, dDiff,
            pRtpNetRState->jitter,
            (double)pRtpNetRState->jitter/
            pRtpNetRState->dwRecvSamplingFreq
        ));
    
    RtpLeaveCriticalSection(&pRtpUser->UserCritSect);
    
    return(NOERROR);
}

/* This is done once per RtpUser_t, and the structure is initially
 * zeroed */
void RtpInitNetRState(RtpUser_t *pRtpUser, RtpHdr_t *pRtpHdr, double Ai)
{
    RtpNetRState_t  *pRtpNetRState;
    DWORD            dwRecvSamplingFreq;
    DWORD            ts;

    TraceFunctionName("RtpInitNetRState");

    pRtpNetRState = &pRtpUser->RtpNetRState;
    
    ts = ntohl(pRtpHdr->ts);

    dwRecvSamplingFreq = pRtpNetRState->dwRecvSamplingFreq;

    if (!dwRecvSamplingFreq)
    {
        dwRecvSamplingFreq = DEFAULT_SAMPLING_FREQ;

        TraceRetail((
                CLASS_WARNING, GROUP_RTP, S_RTP_PLAYOUT,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] ")
                _T("sampling frequency unknown, using default:%u"),
                _fname, pRtpUser->pRtpAddr, pRtpUser, dwRecvSamplingFreq
            ));
    }

    /* Compute average delay for last N packets to be used in
     * computing the reference time */
    pRtpNetRState->Di = pRtpNetRState->dDiN / pRtpNetRState->lDiCount;
    
    /* Arbitrarily set delay to be 1s, what we really care is the
     * delay variations, so this shouldn't matter for delay jitter and
     * delay variance computations. When sending RR's RBlock (LSR,
     * DLSR), need to use NTP_sr_rtt. dNTP_ts0 is the time at RTP
     * sample 0. I don't want to use the real arrival time but the one
     * that would generate Ni = Di, because otherwise, the current
     * packet delay might be above or below the mean delay value (for
     * the last N packets) and hence establish a reference time based
     * on that exception packet */
    pRtpNetRState->dNTP_ts0 =
        (Ai - (pRtpNetRState->Ni - pRtpNetRState->Di)) -
        ((double)ts / dwRecvSamplingFreq) -
        RELATIVE_DELAY;

    /* Now update current Ni giving the new reference time */
    pRtpNetRState->Ni = pRtpNetRState->Ni - pRtpNetRState->Di + RELATIVE_DELAY;
    
    /* Now set Di to its resync'ed value which is the relative delay */
    pRtpNetRState->Di = RELATIVE_DELAY;

    /* Keep the smallest variance value */
    if (pRtpNetRState->ViPrev < pRtpNetRState->Vi)
    {
        pRtpNetRState->Vi = pRtpNetRState->ViPrev;
    }
    
    pRtpNetRState->ViPrev = 0;
    
    /* We just went through the resync process, reset this variable
     * until this computation is needed again */
    pRtpNetRState->lDiMax = 0;  
}

/* Do some initialization required only when the first RTP packet is
 * received. Init reference time, Di  */
void RtpOnFirstPacket(RtpUser_t *pRtpUser, RtpHdr_t *pRtpHdr, double Ai)
{
    RtpNetRState_t  *pRtpNetRState;
    DWORD            dwRecvSamplingFreq;
    DWORD            ts;

    TraceFunctionName("RtpOnFirstPacket");

    pRtpNetRState = &pRtpUser->RtpNetRState;
    
    ts = ntohl(pRtpHdr->ts);

    dwRecvSamplingFreq = pRtpNetRState->dwRecvSamplingFreq;

    if (!dwRecvSamplingFreq)
    {
        dwRecvSamplingFreq = DEFAULT_SAMPLING_FREQ;

        TraceRetail((
                CLASS_WARNING, GROUP_RTP, S_RTP_PLAYOUT,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] ")
                _T("sampling frequency unknown, using default:%u"),
                _fname, pRtpUser->pRtpAddr, pRtpUser, dwRecvSamplingFreq
            ));
    }

    /* Arbitrarily set delay to be 1s, what we really care is the
     * delay variations, so this shouldn't matter for delay and delay
     * variance computations. When sending RR's RBlock (LSR, DLSR),
     * need to use NTP_sr_rtt. dNTP_ts0 is the time at RTP sample 0
     * */
    pRtpNetRState->dNTP_ts0 =
        Ai - ((double)ts / dwRecvSamplingFreq) - RELATIVE_DELAY;

    /* Set Di to be the relative delay */
    pRtpNetRState->Di = RELATIVE_DELAY;
}

/* Modify some variables so a marker bit will be generated regardless
 * of the marker bit in the original packet */
void RtpPrepareForMarker(RtpUser_t *pRtpUser, RtpHdr_t *pRtpHdr, double Ai)
{
    DWORD            dwRecvSamplingFreq;
    
    dwRecvSamplingFreq = pRtpUser->RtpNetRState.dwRecvSamplingFreq;

    if (!dwRecvSamplingFreq)
    {
        dwRecvSamplingFreq = DEFAULT_SAMPLING_FREQ;
    }
    
    /* Make sure that if the first packet received doesn't have
     * the marker bit set, we will generate it */
    pRtpUser->RtpNetRState.dLastTimeMarkerBit =
        Ai - 2 * MINTIMEBETWEENMARKERBIT;
    
    pRtpUser->RtpNetRState.timestamp_prior = ntohl(pRtpHdr->ts) -
        (GAPFORTALKSPURT * dwRecvSamplingFreq / 1000);
}

/* Prepare for the short term average delay, i.e. that computed for
 * the first N packets after the ocurrence of some events, e.g. a
 * delay jump.
 *
 * This is needed in the following conditions: 1. Packet size change;
 * 2. Sampling frequency change; 3. Begin of talkspurt; 4. Delay jumps
 * */
void RtpPrepareForShortDelay(RtpUser_t *pRtpUser, long lCount)
{
    /* A new of this process can be started again before the old one
     * has completed, in this case remeber the smallest variance */
    if (!pRtpUser->RtpNetRState.ViPrev ||
        pRtpUser->RtpNetRState.Vi < pRtpUser->RtpNetRState.ViPrev)
    {
        pRtpUser->RtpNetRState.ViPrev = pRtpUser->RtpNetRState.Vi;
    }

    pRtpUser->RtpNetRState.lDiMax = lCount;
    pRtpUser->RtpNetRState.lDiCount = 0;
    pRtpUser->RtpNetRState.dDiN = 0.0;
}

/* Detect a talkspurt, i.e. the begining of a sequence of packets
 * after a silence */
BOOL RtpDetectTalkspurt(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        RtpHdr_t        *pRtpHdr,
        double           dTime
    )
{
    DWORD            dwTimestamp;
    DWORD            dwGap; /* timestamp gap */
    DWORD            dwRecvSamplingFreq;
    RtpNetRState_t  *pRtpNetRState;

    TraceFunctionName("RtpDetectTalkspurt");

    pRtpNetRState = &pRtpUser->RtpNetRState;

    dwTimestamp = ntohl(pRtpHdr->ts);

    dwRecvSamplingFreq = pRtpNetRState->dwRecvSamplingFreq;
    
    if (!dwRecvSamplingFreq)
    {
        dwRecvSamplingFreq = DEFAULT_SAMPLING_FREQ;
    }

    /* Gap in RTP timestamp units */
    dwGap = dwTimestamp - pRtpNetRState->timestamp_prior;

    /* Update previous timestamp */
    pRtpNetRState->timestamp_prior = dwTimestamp;

    /* Gap in millisecs */
    dwGap = (dwGap * 1000) / dwRecvSamplingFreq;

    if (!pRtpHdr->m && (dwGap >= GAPFORTALKSPURT))
    {
        /* New talkspurt when explicitly indicated by the marker bit,
         * or when there is a big enough gap in the timestamps. */
        TraceRetail((
                CLASS_WARNING, GROUP_RTP, S_RTP_PLAYOUT,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] Seq:%u ")
                _T("marker bit, set, timestamp gap:%u ms"),
                _fname, pRtpAddr, pRtpUser, ntohs(pRtpHdr->seq),
                dwGap
            ));
        
        pRtpHdr->m = 1;
    }

    /* Check if we have a valid marker bit */
    if ( pRtpHdr->m &&
         ( (dTime - pRtpNetRState->dLastTimeMarkerBit) <
           MINTIMEBETWEENMARKERBIT ) )
    {
        /* We don't want the marker bit to happen too ofetn, if it
         * does, then that is indeed a sender's bug, remove marker
         * bits generated within MINTIMEBETWEENMARKERBIT (2) seconds
         * */
        TraceRetail((
                CLASS_WARNING, GROUP_RTP, S_RTP_PLAYOUT,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] Seq:%u ")
                _T("marker bit, reset,     elapsed:%0.3f secs"),
                _fname, pRtpAddr, pRtpUser, ntohs(pRtpHdr->seq),
                dTime - pRtpNetRState->dLastTimeMarkerBit
            ));
        
        pRtpHdr->m = 0;
    }
    
    if (pRtpHdr->m)
    {
        /* Update last time we saw a marker bit */
        pRtpNetRState->dLastTimeMarkerBit = dTime;

        return(TRUE);
    }

    return(FALSE);
}

/* Compute the playout delay in seconds. The playout time is relative
 * to the present moment */
double RtpPlayout(RtpAddr_t *pRtpAddr, RtpUser_t *pRtpUser)
{
    double           dPlayout;
    double           dPlayoutCompensated;
    RtpNetRState_t  *pRtpNetRState;
    
    TraceFunctionName("RtpPlayout");

    pRtpNetRState = &pRtpUser->RtpNetRState;

    dPlayout = 4 * pRtpNetRState->Vi + pRtpNetRState->dRedPlayout;

    if (dPlayout < pRtpNetRState->dMinPlayout)
    {
        dPlayout = pRtpNetRState->dMinPlayout;
    }
    else if (dPlayout > pRtpNetRState->dMaxPlayout)
    {
        dPlayout = pRtpNetRState->dMaxPlayout;
    }

    if (pRtpNetRState->lBigDelay == 0)
    {
        /* Add compensation for the time at which this packet was
         * received, if it arrived late, may be it will have to be played
         * rigth away. There is a chance for dPlayout to be zero if the
         * difference of mean delay and current delay (for a late packet)
         * equals the playout delay (computed from variance), in this case
         * dPlayout would remain zero for the whole talkspurt, but the
         * start time will also be later than it should be, in other
         * words, the playout dalay is in dPlayout when the first packet
         * had the mean delay, or dPlayout may be zero and the playout
         * delay is implicit in the late start of talkspurt time,
         * i.e. dBeginTalkspurtTime */
        dPlayoutCompensated = dPlayout + pRtpNetRState->Di - pRtpNetRState->Ni;

        TraceRetailAdvanced((
                0, GROUP_RTP, S_RTP_PLAYOUT,
                _T("%s: pRtpAddr[0x%p] SSRC:0x%X ")
                _T("Di:%0.3fs Ni:%0.3fs Vi:%0.3fs compensated ")
                _T("Playout:%0.1fms (%0.1fms)"),
                _fname, pRtpAddr, ntohl(pRtpUser->dwSSRC),
                pRtpNetRState->Di, pRtpNetRState->Ni, pRtpNetRState->Vi,
                 dPlayoutCompensated * 1000, dPlayout * 1000
            ));
    }
    else
    {
        /* If we had a big delay, do not compensate but apply playout
         * delay after the arrival time */
        dPlayoutCompensated = dPlayout;

        TraceRetail((
                CLASS_WARNING, GROUP_RTP, S_RTP_PLAYOUT,
                _T("%s: pRtpAddr[0x%p] SSRC:0x%X ")
                _T("Di:%0.3fs Ni:%0.3fs Vi:%0.3fs non compensated ")
                _T("Playout:%0.1fms"),
                _fname, pRtpAddr, ntohl(pRtpUser->dwSSRC),
                pRtpNetRState->Di, pRtpNetRState->Ni, pRtpNetRState->Vi,
                dPlayout * 1000
            ));
    }
    
    return(dPlayoutCompensated);
}

void RtpSetMinMaxPlayoutFromRegistry(void)
{
    if (IsRegValueSet(g_RtpReg.dwPlayoutEnable) &&
        ((g_RtpReg.dwPlayoutEnable & 0x3) == 0x3))
    {
        if (IsRegValueSet(g_RtpReg.dwMinPlayout))
        {
            g_dMinPlayout = (double)g_RtpReg.dwMinPlayout / 1000;
        }
        if (IsRegValueSet(g_RtpReg.dwMaxPlayout))
        {
            g_dMaxPlayout = (double)g_RtpReg.dwMaxPlayout / 1000;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\msrtp\funcs\rtpph.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpph.c
 *
 *  Abstract:
 *
 *    Implements the Payload Handling family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/07 created
 *
 **********************************************************************/

#include "struct.h"
#include "rtpph.h"

HRESULT ControlRtpPh(RtpControlStruct_t *pRtpControlStruct)
{

    return(NOERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\msrtp\funcs\rtppinfo.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtppinfo.c
 *
 *  Abstract:
 *
 *    Implements the Participants Information family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/07 created
 *
 **********************************************************************/

#include "struct.h"
#include "rtpuser.h"
#include "rtpevent.h"
#include "rtpdemux.h"
#include "lookup.h"
#include "rtpglobs.h"

#include "rtppinfo.h"

HRESULT ControlRtpParInfo(RtpControlStruct_t *pRtpControlStruct)
{

    return(NOERROR);
}

/* Some local definitions of longer names */
#define CREATED           RTPPARINFO_CREATED
#define SILENT            RTPPARINFO_SILENT
#define TALKING           RTPPARINFO_TALKING
#define WAS_TKING         RTPPARINFO_WAS_TALKING
#define STALL             RTPPARINFO_STALL
#define BYE               RTPPARINFO_BYE
#define DEL               RTPPARINFO_DEL

#define EVENT_CREATED     RTPPARINFO_CREATED
#define EVENT_SILENT      RTPPARINFO_SILENT
#define EVENT_TALKING     RTPPARINFO_TALKING
#define EVENT_WAS_TKING   RTPPARINFO_WAS_TALKING
#define EVENT_STALL       RTPPARINFO_STALL
#define EVENT_BYE         RTPPARINFO_BYE
#define EVENT_DEL         RTPPARINFO_DEL

#define NOQ        0
#define NO_EVENT   0

/**********************************************************************
 * Control word structure (used to direct the participant's state
 * machine)
 **********************************************************************

      3                   2                   1                 
    1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |E|X| Tmr | Move| State | Event |    Source     |  Destination  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    v v \-v-/ \-v-/ \--v--/ \--v--/ \------v------/ \------v------/
    | |   |     |      |       |           |               |
    | |   |     |      |       |           |    Destination Queue (8)
    | |   |     |      |       |           | 
    | |   |     |      |       |     Source Queue (8)
    | |   |     |      |       |
    | |   |     |      |       Event to generate (4)
    | |   |     |      |
    | |   |     |      Next state (4)
    | |   |     |
    | |   |     Type of move in queues (3)
    | |   |
    | |   Timer to use (3)
    | |
    | Need to do eXtra processing (1)
    |
    Enable this word (1)

 **********************************************************************
 * Participant's states machine:
 *
 *   \_ user events: RTP, RTCP, BYE, Timeout, DEL
 *     \_  
 *       \_
 * states  \   RTP             RTCP           BYE            Timeout(T)
 *-------------------------------------------------------------------------
 * CREATED     TALKING         SILENT         X              X
 *             AliveQ->Cache1Q       
 *             T1->T           T2->T
 *             EVENT_CREATED   EVENT_CREATED
 *-------------------------------------------------------------------------
 * SILENT      TALKING                        BYE            T3:STALL
 *             AliveQ->Cache1Q AliveQ         AliveQ->ByeQ   AliveQ->ByeQ
 *             T1->T           T3->T          T4->T          T4->T
 *             EVENT_TALKING                  EVENT_BYE      EVENT_STALL
 *-------------------------------------------------------------------------
 * TALKING                                    BYE            T1:WAS_TKING
 *             Cache1Q                        Cache1Q->ByeQ  Cache1Q->Cache2Q
 *             T1->T                          T4->T          T2->T
 *                                            EVENT_BYE      EVENT_WAS_TKING
 *-------------------------------------------------------------------------
 * WAS_TKING   TALKING                        BYE            T2:SILENT
 *             Cache2Q->Cache1Q               Cache2Q->ByeQ  Cache2Q->AliveQ
 *             T1->T                          T4->T          T3->T
 *             EVENT_TALKING                  EVENT_BYE      EVENT_SILENT
 *-------------------------------------------------------------------------
 * STALL       TALKING         SILENT         BYE            T4:DEL
 *             ByeQ->Cache1Q   ByeQ->AliveQ                  ByeQ->
 *                                                           Hash->
 *             T1->T           T3->T          T4->T
 *             EVENT_TALKING   EVENT_SILENT   EVENT_BYE      EVENT_DEL
 *-------------------------------------------------------------------------
 * BYE         ---             ---            ---            T4:DEL
 *                                                           ByeQ->
 *                                                           Hash->
 *                                                           EVENT_DEL
 *-------------------------------------------------------------------------
 * DEL         ---             ---            ---            ---
 *-------------------------------------------------------------------------
 *
 * NOTE On event DEL (that event is not displayed in the chart
 * above. Don't be confused with the state DEL) for all the states,
 * remove user from Cache1Q, Cache2Q, AliveQ or ByeQ, as well as
 * removing it from Hash
 *
 * Cache1Q->AliveQ - move from Cache1Q to AliveQ
 * ByeQ->          - remove from ByeQ
 * Cache1Q         - move to head of Cache1Q
 * T1->T           - set timer to T1
 * X               - invalid
 * ---             - ignore user event
 *
 * */

/*
 * en   - enable this word
 * x    - extra processing
 * ns   - next state
 * move - type of move in queues (1:to head;2:src->dst;3:remove)
 * src  - source queue
 * dst  - destination queue
 * ev   - event to generate
 * tmr  - timer to use */

/*
 * !!! WARNING !!!
 *
 * The offset to Cache1Q, ..., ByeQ MUST NOT be bigger than 1023 and
 * MUST be DWORD aligned (the offset value is stored as number of
 * DWORDS in rtppinfo.c using 8 bits)
 * */
#define TR(en, x, ns, move,  src, dst,  ev, tmr) \
        ((en << 31) | (x << 30) | (ns << 20) | (move << 24) | \
        (((src >> 2) & 0xff) << 8) | ((dst >> 2) & 0xff) | \
        (ev << 16) | (tmr << 27))

#define IsEnabled(dw)   (dw & (1<<31))
#define HasExtra(dw)    (dw & (1<<30))
#define GetTimer(dw)    ((dw >> 27) & 0x7)
#define MoveType(dw)    ((dw >> 24) & 0x7)
#define NextState(dw)   ((dw >> 20) & 0xf)
#define Event(dw)       ((dw >> 16) & 0xf)
#define SrcQ(_addr, dw) \
        ((RtpQueue_t *) ((char *)_addr + (((dw >> 8) & 0xff) << 2)))
#define DstQ(_addr, dw) \
        ((RtpQueue_t *) ((char *)_addr + ((dw & 0xff) << 2)))

const DWORD            g_dwRtpUserTransition[][6] = {
    /*                  en,x,ns,    move, src,    dst,    event,       tmr */
    {
        /*         */ TR(0,0, 0,       0, NOQ,    NOQ,    NO_EVENT,      0),
        /* RTP     */ TR(0,0, 0,       0, NOQ,    NOQ,    NO_EVENT,      0),
        /* RTCP    */ TR(0,0, 0,       0, NOQ,    NOQ,    NO_EVENT,      0),
        /* BYE     */ TR(0,0, 0,       0, NOQ,    NOQ,    NO_EVENT,      0),
        /* TIMEOUT */ TR(0,0, 0,       0, NOQ,    NOQ,    NO_EVENT,      0),
        /* DEL     */ TR(0,0, 0,       0, NOQ,    NOQ,    NO_EVENT,      0)
    },

    /* CREATED */
    {
        /*         */ TR(0,0, 0,       0, NOQ,    NOQ,    NO_EVENT,      0),
        /* RTP     */ TR(1,1, TALKING, 2, ALIVEQ, CACHE1Q,EVENT_CREATED, 0),
        /* RTCP    */ TR(1,0, SILENT,  0, NOQ,    NOQ,    EVENT_CREATED, 0),
        /* BYE     */ TR(0,0, 0,       0, NOQ,    NOQ,    NO_EVENT,      0),
        /* TIMEOUT */ TR(0,0, 0,       0, NOQ,    NOQ,    NO_EVENT,      0),
        /* DEL     */ TR(1,0, DEL,     3, ALIVEQ, NOQ,    NO_EVENT,      0)
    },
    
    /* SILENT */
    {
        /*         */ TR(0,0, 0,       0, NOQ,    NOQ,    NO_EVENT,      0),
        /* RTP     */ TR(1,0, TALKING, 2, ALIVEQ, CACHE1Q,EVENT_TALKING, 0),
        /* RTCP    */ TR(1,0, SILENT,  1, ALIVEQ, NOQ,    NO_EVENT,      0),
        /* BYE     */ TR(1,1, BYE,     2, ALIVEQ, BYEQ,   EVENT_BYE,     0),
        /* TIMEOUT */ TR(1,1, STALL,   2, ALIVEQ, BYEQ,   EVENT_STALL,   3),
        /* DEL     */ TR(1,0, DEL,     3, ALIVEQ, NOQ,    NO_EVENT,      0)
    },

    /* TALKING */
    {
        /*         */ TR(0,0, 0,       0, NOQ,    NOQ,    NO_EVENT,      0),
        /* RTP     */ TR(1,0, TALKING, 1, CACHE1Q,NOQ,    NO_EVENT,      0),
        /* RTCP    */ TR(1,0, TALKING, 0, NOQ,    NOQ,    NO_EVENT,      0),
        /* BYE     */ TR(1,1, BYE,     2, CACHE1Q,BYEQ,   EVENT_BYE,     0),
        /* TIMEOUT */ TR(1,0, WAS_TKING,2,CACHE1Q,CACHE2Q,EVENT_WAS_TKING,1),
        /* DEL     */ TR(1,0, DEL,     3, CACHE1Q,NOQ,    NO_EVENT,      0)
    },

    /* WAS_TKING */
    {
        /*         */ TR(0,0, 0,       0, NOQ,    NOQ,    NO_EVENT,      0),
        /* RTP     */ TR(1,0, TALKING, 2, CACHE2Q,CACHE1Q,EVENT_TALKING, 0),
        /* RTCP    */ TR(1,0, WAS_TKING,0,NOQ,    NOQ,    NO_EVENT,      0),
        /* BYE     */ TR(1,1, BYE,     2, CACHE2Q,BYEQ,   EVENT_BYE,     0),
        /* TIMEOUT */ TR(1,1, SILENT,  2, CACHE2Q,ALIVEQ, EVENT_SILENT,  2),
        /* DEL     */ TR(1,0, DEL,     3, CACHE2Q,NOQ,    NO_EVENT,      0)
    },

    /* STALL */
    {
        /*         */ TR(0,0, 0,       0, NOQ,    NOQ,    NO_EVENT,      0),
        /* RTP     */ TR(1,0, TALKING, 2, BYEQ,   CACHE1Q,EVENT_TALKING, 0),
        /* RTCP    */ TR(1,0, SILENT,  2, BYEQ,   ALIVEQ, EVENT_SILENT,  0),
        /* BYE     */ TR(1,1, BYE,     1, BYEQ,   NOQ,    EVENT_BYE,     0),
        /* TIMEOUT */ TR(1,0, DEL,     3, BYEQ,   NOQ,    EVENT_DEL,     4),
        /* DEL     */ TR(1,0, DEL,     3, BYEQ,   NOQ,    NO_EVENT,      0)
    },

    /* BYE */
    {
        /*         */ TR(0,0, 0,       0, NOQ,    NOQ,    NO_EVENT,      0),
        /* RTP     */ TR(1,0, BYE,     0, NOQ,    NOQ,    NO_EVENT,      0),
        /* RTCP    */ TR(1,0, BYE,     0, NOQ,    NOQ,    NO_EVENT,      0),
        /* BYE     */ TR(1,0, BYE,     0, NOQ,    NOQ,    NO_EVENT,      0),
        /* TIMEOUT */ TR(1,0, DEL,     3, BYEQ,   NOQ,    EVENT_DEL,     4),
        /* DEL     */ TR(1,0, DEL,     3, BYEQ,   NOQ,    NO_EVENT,      0)
    }
};

/* User states are the same as event names. An event may be generated
 * when going to each state, i.e. an event RTPPARINFO_EVENT_SILENT is
 * generated when going to the SILENT state */
const TCHAR_t        **g_psRtpUserStates = &g_psRtpPInfoEvents[0];

const TCHAR_t         *g_psRtpUserEvents[] = {
    _T("invalid"),
    _T("RTP"),
    _T("RTCP"),
    _T("BYE"),
    _T("TIMEOUT"),
    _T("DEL"),
    _T("invalid")
};

const TCHAR_t *g_psFlagValue[] = {
    _T("value"),
    _T("flag")
};


/*
 * WARNING
 *
 * This array is indexed by the user's state, not by the timer to use
 * */
const DWORD            g_dwTimesRtcpInterval[] = {
    /*    first     */  -1,
    /*    created   */  -1,
    /* T3 SILENT    */  5,
    /* T1 talking   */  1, /* Not suposed to be used */
    /* T2 WAS_TKING */  2,
    /* T4 STALL     */  10,
    /* T4 BYE       */  10,
    /*    del       */  -1
};

/* Access the states machine to obtain the next state based on the
 * current state and the user event */
DWORD RtpGetNextUserState(
        DWORD            dwCurrentState,
        DWORD            dwUserEvent
    )
{
    DWORD            dwControl;
    
    dwControl = g_dwRtpUserTransition[dwCurrentState][dwUserEvent];

    return(NextState(dwControl));
}

/*
 * This function can be called from:
 *      1. The thread starting/stoping a session
 *      2. The RTP (reception) thread
 *      3. The RTCP thread
 * */
DWORD RtpUpdateUserState(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        /* The user event is one of RTP, RTCP, BYE, Timeout, DEL */
        DWORD            dwUserEvent
    )
{
    BOOL             bOk1;
    BOOL             bOk2;
    BOOL             bDelUser;
    DWORD            dwError;
    DWORD            i;
    DWORD            dwControl;
    DWORD            dwCurrentState;
    /* The event is one of SILENT, TALKING, etc. */
    DWORD            dwEvent;
    DWORD            dwMoveType;
    DWORD_PTR        dwPar2;
    RtpSess_t       *pRtpSess;
    RtpQueue_t      *pSrcQ;
    RtpQueue_t      *pDstQ;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpOutput_t     *pRtpOutput;

    TraceFunctionName("RtpUpdateUserState");

    bDelUser = FALSE;
    
    bOk1 = RtpEnterCriticalSection(&pRtpAddr->PartCritSect);
    
    bOk2 = RtpEnterCriticalSection(&pRtpUser->UserCritSect);

    if (bOk1 && bOk2)
    {
        dwError = NOERROR;
        dwCurrentState = pRtpUser->dwUserState;

        dwControl = g_dwRtpUserTransition[dwCurrentState][dwUserEvent];

        if (IsEnabled(dwControl))
        {
            dwError = NOERROR;
            pSrcQ = SrcQ(pRtpAddr, dwControl);
            pDstQ = DstQ(pRtpAddr, dwControl);
            dwEvent = Event(dwControl);
            dwMoveType = MoveType(dwControl);
            
            pRtpUser->dwUserState = NextState(dwControl);
        
            switch(dwMoveType)
            {
            case 1:
                /* Move to first place */
                pRtpQueueItem = move2first(pSrcQ,
                                           NULL,
                                           &pRtpUser->UserQItem);
                
                if (!pRtpQueueItem)
                {
                    /* Error */
                    TraceRetail((
                            CLASS_ERROR, GROUP_USER, S_USER_STATE,
                            _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X")
                            _T("move2first failed"),
                            _fname, pRtpAddr, pRtpUser,
                            ntohl(pRtpUser->dwSSRC)
                        ));
                    
                    dwError = RTPERR_QUEUE;
                }
                
                break;
                
            case 2:
                /* Move from pSrcQ to pDstQ */
                pRtpQueueItem = move2ql(pDstQ,
                                        pSrcQ,
                                        NULL,
                                        &pRtpUser->UserQItem);
                
                if (!pRtpQueueItem)
                {
                    /* Error */
                    TraceRetail((
                            CLASS_ERROR, GROUP_USER, S_USER_STATE,
                            _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X")
                            _T("move2ql failed"),
                            _fname, pRtpAddr, pRtpUser, pRtpUser->dwSSRC
                        ));
                    
                    dwError = RTPERR_QUEUE;
                }
                
                break;
                
            case 3:
                /* Remove from pSrcQ (Cache1Q, Cache2Q, ActiveQ or
                 * ByeQ) and Hash */

                /* Remove from Queue ... */
                pRtpQueueItem = dequeue(pSrcQ, NULL, &pRtpUser->UserQItem);
                    
                if (pRtpQueueItem)
                {
                    /* ... then remove from Hash */
                    pRtpQueueItem =
                        removeHdwK(&pRtpAddr->Hash, NULL, pRtpUser->dwSSRC);
                        
                    if (&pRtpUser->HashItem == pRtpQueueItem)
                    {
                        /* This user has to be deleted */
                        bDelUser = TRUE;
                    }
                    else
                    {
                        /* Error */
                        TraceRetail((
                                CLASS_ERROR, GROUP_USER, S_USER_STATE,
                                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] ")
                                _T("SSRC:0x%X removeHK failed"),
                                _fname,
                                pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC)
                            ));

                        dwError = RTPERR_QUEUE;
                    }
                }
                else
                {
                    /* Error */
                    TraceRetail((
                            CLASS_ERROR, GROUP_USER, S_USER_STATE,
                            _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] ")
                            _T("SSRC:0x%X dequeue failed"),
                            _fname, pRtpAddr, pRtpUser,
                            ntohl(pRtpUser->dwSSRC)
                        ));
                    
                    dwError = RTPERR_QUEUE;
                }
                    
                break;
            } /* switch(dwMoveType) */

            if (dwEvent)
            {
                /* Post event */
                pRtpSess = pRtpAddr->pRtpSess;
                
                TraceRetailAdvanced((
                        0, GROUP_USER, S_USER_EVENT,
                        _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] ")
                        _T("SSRC:0x%X %+7s,%u:%s->%s Event:%s"),
                        _fname,
                        pRtpAddr, pRtpUser,
                        ntohl(pRtpUser->dwSSRC),
                        g_psRtpUserEvents[dwUserEvent],
                        dwMoveType,
                        g_psRtpUserStates[dwCurrentState],
                        g_psRtpUserStates[pRtpUser->dwUserState],
                        g_psRtpUserStates[dwEvent]
                    ));

                dwPar2 = 0;
                
                if (dwEvent == USER_EVENT_RTP_PACKET)
                {
                    /* When event is due to an RTP packet received,
                     * pass the payload type encoded in parameter 2,
                     * can not pass just zero as it is a valid payload
                     * type value */
                    dwPar2 = (DWORD_PTR)
                        pRtpUser->RtpNetRState.dwPt | 0x80010000;
                }
                
                RtpPostEvent(pRtpAddr,
                             pRtpUser,
                             RTPEVENTKIND_PINFO,
                             dwEvent,
                             pRtpUser->dwSSRC, /* dwPar1 */
                             dwPar2            /* dwPar2 */ );

                if (HasExtra(dwControl))
                {
                    if (dwCurrentState == RTPPARINFO_CREATED)
                    {
                        if (dwUserEvent == USER_EVENT_RTP_PACKET)
                        {
                            /* In addition to event CREATED, I also
                             * need to post TALKING */
                            RtpPostEvent(pRtpAddr,
                                         pRtpUser,
                                         RTPEVENTKIND_PINFO,
                                         RTPPARINFO_TALKING,
                                         pRtpUser->dwSSRC, /* dwPar1 */
                                         dwPar2            /* dwPar2 */ );
                        }
                    }
                    else
                    {
                        /* Check if we need to test if the user has to
                         * release its output (if it has one assigned)
                         * */
                        pRtpOutput = pRtpUser->pRtpOutput;
                    
                        if (pRtpOutput)
                        {
                            /* Unmap if enabled, OR any time we receive
                             * BYE event, OR if the previous state was
                             * silent (we got timeout) */
                            if (RtpBitTest(pRtpOutput->dwOutputFlags,
                                           RTPOUTFG_ENTIMEOUT) ||
                                dwEvent == EVENT_BYE           ||
                                dwCurrentState == SILENT)
                            {
                                /* Unassign output */
                                RtpOutputUnassign(pRtpSess,
                                                  pRtpUser,
                                                  pRtpOutput);
                            }
                        }
                    }
                }
            }
        }
        else
        {
            TraceRetail((
                    CLASS_ERROR, GROUP_USER, S_USER_STATE,
                    _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] 0x%X ")
                    _T("Invalid transition %+7s,0:%s->???? Event:NONE"),
                    _fname, pRtpAddr, pRtpUser,
                    ntohl(pRtpUser->dwSSRC),
                    g_psRtpUserEvents[dwUserEvent],
                    g_psRtpUserStates[dwCurrentState]
                ));
            
            dwError = RTPERR_INVALIDUSRSTATE;
        }
    }
    else
    {
        dwError = RTPERR_CRITSECT;
    }

    if (bOk2)
    {
        RtpLeaveCriticalSection(&pRtpUser->UserCritSect);
    }

    if (bOk1)
    {
        RtpLeaveCriticalSection(&pRtpAddr->PartCritSect);
    }

    if (bDelUser)
    {
        DelRtpUser(pRtpAddr, pRtpUser);
    }
     
    return(dwError);
}

/* pdwSSRC points to an array of DWORDs where to copy the SSRCs,
 * pdwNumber contains the maximum entries to copy, and returns the
 * actual number of SSRCs copied. If pdwSSRC is NULL, pdwNumber
 * will return the current number of SSRCs (i.e. the current
 * number of participants) */
HRESULT RtpEnumParticipants(
        RtpAddr_t       *pRtpAddr,
        DWORD           *pdwSSRC,
        DWORD           *pdwNumber
    )
{
    HRESULT          hr;
    BOOL             bOk;
    DWORD            dwMax;
    DWORD            i;
    RtpQueueItem_t  *pRtpQueueItem;

    TraceFunctionName("RtpEnumParticipants");

    if (!pRtpAddr)
    {
        /* Having this as a NULL pointer means Init hasn't been
         * called, return this error instead of RTPERR_POINTER to be
         * consistent */
        hr = RTPERR_INVALIDSTATE;

        goto end;
    }

    if (!pdwSSRC && !pdwNumber)
    {
        hr = RTPERR_POINTER;

        goto end;
    }
    
    /* verify object ID */
    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_USER, S_USER_ENUM,
                _T("%s: pRtpAddr[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpAddr,
                pRtpAddr->dwObjectID, OBJECTID_RTPADDR
            ));

        hr = RTPERR_INVALIDRTPADDR;

        goto end;
    }

    hr = NOERROR;
    
    if (!pdwSSRC)
    {
        /* Just want to know how many participants we have */
        *pdwNumber = GetHashCount(&pRtpAddr->Hash);
    }
    else
    {
        /* Copy as many SSRCs as they fit */
        bOk = RtpEnterCriticalSection(&pRtpAddr->PartCritSect);

        if (bOk)
        {
            dwMax = GetHashCount(&pRtpAddr->Hash);

            if (dwMax > *pdwNumber)
            {
                dwMax = *pdwNumber;
            }
            
            for(i = 0, pRtpQueueItem = pRtpAddr->Hash.pFirst;
                i < dwMax;
                i++, pRtpQueueItem = pRtpQueueItem->pNext)
            {
                pdwSSRC[i] = pRtpQueueItem->dwKey;
            }
            
            RtpLeaveCriticalSection(&pRtpAddr->PartCritSect);

            *pdwNumber = dwMax;
        }
        else
        {
            hr = RTPERR_CRITSECT;
        }
    }
    
 end:
    if (SUCCEEDED(hr))
    {
        TraceDebug((
                CLASS_INFO, GROUP_USER, S_USER_ENUM,
                _T("%s: pRtpAddr[0x%p] Number of SSRCs: %u"),
                _fname, pRtpAddr,
                *pdwNumber
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_USER, S_USER_ENUM,
                _T("%s: pRtpAddr[0x%p] Enumeration failed: %u (0x%X)"),
                _fname, pRtpAddr,
                hr, hr
            ));
    }
    
    return(hr);
}

/* Get the participant state and/or get or set its mute state. piState
 * if not NULL, will return the participant's state (e.g. TALKING,
 * SILENT). If piMuted is not NULL, and < 0, will query the mute
 * state, otherwise will set it (= 0 unmute, > 0 mute) */
HRESULT RtpMofifyParticipantInfo(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwSSRC,
        DWORD            dwControl,
        DWORD           *pdwValue
    )
{
    HRESULT          hr;
    BOOL             bOk;
    BOOL             bCreate;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpUser_t       *pRtpUser;

    DWORD            dwBit;
    DWORD            dwSize;
    DWORD           *pDWORD;

    double dCurTime;
    
    TraceFunctionName("RtpMofifyParticipantInfo");

    pRtpUser = (RtpUser_t *)NULL;
    
    /* Get bit to act uppon (if needed) */
    dwBit = RTPUSER_GET_BIT(dwControl);

    /* Get size of bytes to act upon */
    dwSize = RTPUSER_GET_SIZE(dwControl);
    
    if (!pRtpAddr)
    {
        /* Having this as a NULL pointer means Init hasn't been
         * called, return this error instead of RTPERR_POINTER to be
         * consistent */
        hr = RTPERR_INVALIDSTATE;
    }
    
    /* verify object ID */
    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_USER, S_USER_INFO,
                _T("%s: pRtpAddr[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpAddr,
                pRtpAddr->dwObjectID, OBJECTID_RTPADDR
            ));

        hr = RTPERR_INVALIDRTPADDR;

        goto end;
    }

    if (!pdwValue)
    {
        hr = RTPERR_POINTER;

        goto end;
    }

    bOk = RtpEnterCriticalSection(&pRtpAddr->PartCritSect);

    if (!bOk)
    {
        hr = RTPERR_CRITSECT;

        goto end;
    }

    hr = NOERROR;

    if (dwSSRC == 0)
    {
        /* If SSRC==0, it means the caller wants to enable this
         * for any and all SSRCs */

        /* Get DWORD to act upon */
        pDWORD = RTPDWORDPTR(pRtpAddr, RTPUSER_GET_OFF(dwControl));
        
        if (*pdwValue)
        {
            /* Set flag */
            RtpBitSet(*pDWORD, dwBit);
        }
        else
        {
            /* Reset flag */
            RtpBitReset(*pDWORD, dwBit);
        }

        TraceRetail((
                CLASS_INFO, GROUP_USER, S_USER_INFO,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                _T("%s %s bit:%u value:%u (0x%X)"),
                _fname, pRtpAddr, pRtpUser, dwSSRC,
                g_psGetSet[(dwControl >> RTPUSER_BIT_SET) & 0x1],
                g_psFlagValue[(dwControl >> RTPUSER_BIT_FLAG) & 0x1],
                dwBit, *pdwValue, *pdwValue
            ));
    }
    else if (dwSSRC == NO_DW_VALUESET)
    {
        /* With SSRC=-1, choose the first participant */

        /* Try first the most recently talking */
        pRtpQueueItem = pRtpAddr->Cache1Q.pFirst;

        if (!pRtpQueueItem)
        {
            /* If none, try second level cache */
            pRtpQueueItem = pRtpAddr->Cache2Q.pFirst;

            if (!pRtpQueueItem)
            {
                /* If none, try just the first one */
                pRtpQueueItem = pRtpAddr->AliveQ.pFirst;
            }
        }

        if (pRtpQueueItem)
        {
            pRtpUser = CONTAINING_RECORD(pRtpQueueItem, RtpUser_t, UserQItem);
        }
        else
        {
            pRtpUser = (RtpUser_t *)NULL;
        }
    }
    else
    {
        /* Look up the participant */
        bCreate = FALSE;
        pRtpUser = LookupSSRC(pRtpAddr, dwSSRC, &bCreate);
    }

    if (pRtpUser)
    {
        bOk = RtpEnterCriticalSection(&pRtpUser->UserCritSect);

        if (bOk)
        {
            /* Decide if this is a set or query */

            /* Get DWORD to act upon */
            pDWORD = RTPDWORDPTR(pRtpUser, RTPUSER_GET_OFF(dwControl));
            
            if (RTPUSER_IsSetting(dwControl))
            {
                /*
                 * Setting a new flag or DWORD
                 */
                
                if (RTPUSER_IsFlag(dwControl))
                {
                    /* Setting a flag */
                    
                    if (*pdwValue)
                    {
                        /* Set flag */
                        RtpBitSet(*pDWORD, dwBit);
                    }
                    else
                    {
                        /* Reset flag */
                        RtpBitReset(*pDWORD, dwBit);
                    }
                }
                else
                {
                    /* Setting bytes */
                    CopyMemory(pDWORD, (BYTE *)pdwValue, dwSize);
                }
            }
            else
            {
                /*
                 * Querying current value
                 */
                
                if (RTPUSER_IsFlag(dwControl))
                {
                    /* Querying a flag */

                    *pdwValue = RtpBitTest(*pDWORD, dwBit)? TRUE : FALSE;
                }
                else
                {
                    /* Querying a DWORD */
                    CopyMemory((BYTE *)pdwValue, pDWORD, dwSize);
                }

                if (dwControl == RTPUSER_GET_NETINFO)
                {
                    dCurTime = RtpGetTimeOfDay(NULL);

                    /* The stored time is that of the last update,
                     * transform that so it is rather its age */
                    ((RtpNetInfo_t *)pdwValue)->dMetricAge =
                        dCurTime - ((RtpNetInfo_t *)pdwValue)->dLastUpdate;
                }
            }

            RtpLeaveCriticalSection(&pRtpUser->UserCritSect);

            TraceRetail((
                    CLASS_INFO, GROUP_USER, S_USER_INFO,
                    _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                    _T("%s %s bit:%u value:%u (0x%X)"),
                    _fname, pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC),
                    g_psGetSet[(dwControl >> RTPUSER_BIT_SET) & 0x1],
                    g_psFlagValue[(dwControl >> RTPUSER_BIT_FLAG) & 0x1],
                    dwBit, *pdwValue, *pdwValue
                ));
        }
        else
        {
            hr = RTPERR_CRITSECT;
        }
    }
    else if (dwSSRC)
    {
        hr = RTPERR_NOTFOUND;
        
        TraceRetail((
                CLASS_WARNING, GROUP_USER, S_USER_INFO,
                _T("%s: pRtpAddr[0x%p] SSRC:0x%X not found"),
                _fname, pRtpAddr, ntohl(dwSSRC)
            ));
    }
    
    RtpLeaveCriticalSection(&pRtpAddr->PartCritSect);

end:
    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_USER, S_USER_INFO,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                _T("%s %s bit:%u value:%u (0x%X) ")
                _T("failed: %u (0x%X)"),
                _fname, pRtpAddr, pRtpUser, ntohl(dwSSRC),
                g_psGetSet[(dwControl >> RTPUSER_BIT_SET) & 0x1],
                g_psFlagValue[(dwControl >> RTPUSER_BIT_FLAG) & 0x1],
                dwBit, *pdwValue, *pdwValue,
                hr, hr
            ));
    }
    
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\msrtp\funcs\rtpncnt.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpncnt.c
 *
 *  Abstract:
 *
 *    Implements the Statistics family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/07 created
 *
 **********************************************************************/

#include "struct.h"
#include "rtpheap.h"
#include "rtpglobs.h"
#include "rtprand.h"

#include "rtpncnt.h"

HRESULT ControlRtpStats(RtpControlStruct_t *pRtpControlStruct)
{

    return(NOERROR);
}

/* Helper function to update counters */
BOOL RtpUpdateNetCount(
        RtpNetCount_t   *pRtpNetCount,/* structure where to update */
        RtpCritSect_t   *pRtpCritSect,/* lock to use */
        DWORD            dwRtpRtcp,/* 0=RTP or 1=RTCP stats */
        DWORD            dwBytes,  /* bytes toupdate */
        DWORD            dwFlags,  /* Flags, e.g. a dropped or error packet */
        double           dTime     /* time packet recv/send */
    )
{
    BOOL             bOk;

    bOk = TRUE;
    
    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }

    if (bOk)
    {
        if (pRtpNetCount)
        {
            if (!dwRtpRtcp)
            {
                /* RTP */
                pRtpNetCount->dwRTPBytes += dwBytes;
                pRtpNetCount->dwRTPPackets++;
                if (RtpBitTest(dwFlags, FGRECV_ERROR))
                {
                    pRtpNetCount->dwRTPBadPackets++;
                }
                else if (RtpBitTest(dwFlags, FGRECV_DROPPED))
                {
                    pRtpNetCount->dwRTPDrpPackets++;
                }
                pRtpNetCount->dRTPLastTime = dTime;
            }
            else
            {
                /* RTCP */
                pRtpNetCount->dwRTCPBytes += dwBytes;
                pRtpNetCount->dwRTCPPackets++;
                if (RtpBitTest(dwFlags, FGRECV_ERROR))
                {
                    pRtpNetCount->dwRTCPBadPackets++;
                }
                else if (RtpBitTest(dwFlags, FGRECV_DROPPED))
                {
                    pRtpNetCount->dwRTCPDrpPackets++;
                }
                pRtpNetCount->dRTCPLastTime = dTime;
            }
        }

        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }
    }

    return(pRtpNetCount != NULL);
}

void RtpResetNetCount(
        RtpNetCount_t   *pRtpNetCount,
        RtpCritSect_t   *pRtpCritSect
        )
{
    BOOL             bOk;

    /* It may have worse consequences not to reset than the minimal
     * chance of getting a value partially zeroed, so zero memory even
     * if the critical section is not obtained */

    bOk = FALSE;

    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }
    
    ZeroMemory((char *)pRtpNetCount, sizeof(RtpNetCount_t));

    if (bOk)
    {
        RtpLeaveCriticalSection(pRtpCritSect) ;
    }
}

void RtpGetRandomInit(RtpAddr_t *pRtpAddr)
{
    RtpNetSState_t  *pRtpNetSState;

    pRtpNetSState = &pRtpAddr->RtpNetSState;

    /* SSRC */
    if (!pRtpNetSState->dwSendSSRC ||
        !RtpBitTest(pRtpAddr->dwIRtpFlags, FGADDR_IRTP_PERSISTSSRC))
    {
        /* Update the SSRC only if the SSRC hasn't been set yet, or if
         * it was set, we are not using the Init option for persistent
         * SSRC */
        pRtpNetSState->dwSendSSRC = RtpRandom32((DWORD_PTR)pRtpAddr);
    }

    /* sequence number */
    pRtpNetSState->wSeq = (WORD)RtpRandom32((DWORD_PTR)pRtpNetSState);

    /* timestamp offset */
    pRtpNetSState->dwTimeStampOffset =
        RtpRandom32((DWORD_PTR)GetCurrentThreadId());
}

void RtpResetNetSState(
        RtpNetSState_t  *pRtpNetSState,
        RtpCritSect_t   *pRtpCritSect
    )
{
    BOOL             bOk;
    
    bOk = FALSE;

    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }
    
    pRtpNetSState->dTimeLastRtpSent = 0;
    pRtpNetSState->avg_rtcp_size = 0;

    if (bOk)
    {
        RtpLeaveCriticalSection(pRtpCritSect);
    }
}


#if 0
/* Creates and initializes a RtpNetCount_t structure */
RtpNetCount_t *RtpNetCountAlloc(void)
{
    RtpNetCount_t *pRtpNetCount;

    pRtpNetCount = (RtpNetCount_t *)
        RtpHeapAlloc(g_pRtpNetCountHeap, sizeof(RtpNetCount_t));

    if (pRtpNetCount) {
        
        ZeroMemory(pRtpNetCount, sizeof(RtpNetCount_t));

        pRtpNetCount->dwObjectID = OBJECTID_RTPSTAT;
    }
    
    return(pRtpNetCount);
}

/* Frees a RtpNetCount_t structure */
void RtpNetCountFree(RtpNetCount_t *pRtpNetCount)
{
    if (pRtpNetCount->dwObjectID != OBJECTID_RTPSTAT) {
        /* TODO log error */
        return;
    }
    
    RtpHeapFree(g_pRtpNetCountHeap, pRtpNetCount);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\msrtp\funcs\rtpdemux.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpcrypt.c
 *
 *  Abstract:
 *
 *    Implements the Demultiplexing family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/07 created
 *
 **********************************************************************/

#include "struct.h"
#include "rtpglobs.h"
#include "rtpheap.h"
#include "rtpevent.h"
#include "rtpmisc.h"
#include "lookup.h"

#include "rtpdemux.h"

/*
 * WARNING
 *
 * The entries in this array MUST match the entries in the enum
 * RTPDMXMODE_* defined in msrtp.h */
const TCHAR_t *g_psRtpDmxMode[] = {
    _T("invalid"),
    _T("MANUAL"),
    _T("AUTO"),
    _T("AUTO_MANUAL"),
    NULL
};

HRESULT ControlRtpDemux(RtpControlStruct_t *pRtpControlStruct)
{

    return(NOERROR);
}

/**********************************************************************
 * Users <-> Outputs assignment
 **********************************************************************/

/* Creates and add an RtpOutput at the end of the list of outputs,
 * keeps a user information which is currently used to keep the 1:1
 * association with the DShow output pins */
RtpOutput_t *RtpAddOutput(
        RtpSess_t       *pRtpSess,
        int              iOutMode,
        void            *pvUserInfo,
        DWORD           *pdwError
    )
{
    DWORD            dwError;
    RtpOutput_t     *pRtpOutput;
    
    TraceFunctionName("RtpAddOutput");

    dwError = NOERROR;
    pRtpOutput = (RtpOutput_t *)NULL;
    
    if (iOutMode <= RTPDMXMODE_FIRST || iOutMode >= RTPDMXMODE_LAST)
    {
        dwError = RTPERR_INVALIDARG;
            
        goto end;
    }

    if (!pRtpSess)
    {
        /* Having this as a NULL pointer means Init hasn't been
         * called, return this error instead of RTPERR_POINTER to be
         * consistent */
        dwError = RTPERR_INVALIDSTATE;

        goto end;
    }

    /* verify object ID in RtpSess_t */
    if (pRtpSess->dwObjectID != OBJECTID_RTPSESS)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpSess[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpSess,
                pRtpSess->dwObjectID, OBJECTID_RTPSESS
            ));

        dwError = RTPERR_INVALIDRTPSESS;

        goto end;
    }

    /* Obtain new RtpOutput_t structure */
    pRtpOutput = RtpOutputAlloc();

    if (!pRtpOutput)
    {
        dwError = RTPERR_MEMORY;

        goto end;
    }

    /* Initialize output */

    /* The output, after being created is marked as free but is
     * disabled */
    pRtpOutput->dwOutputFlags = RtpBitPar(RTPOUTFG_FREE);

    RtpSetOutputMode_(pRtpOutput, iOutMode);

    pRtpOutput->pvUserInfo = pvUserInfo;

    /* Position in the queue is counted as 0,1,2,... */
    pRtpOutput->OutputQItem.dwKey = (DWORD)GetQueueSize(&pRtpSess->OutputQ);
    
    enqueuel(&pRtpSess->OutputQ,
             &pRtpSess->OutputCritSect,
             &pRtpOutput->OutputQItem);

 end:
    if (dwError == NOERROR)
    {
        TraceDebug((
                CLASS_INFO, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpOutput[0x%p] pvUserInfo[0x%p] ")
                _T("Output added"),
                _fname, pRtpOutput, pvUserInfo
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpOutput[0x%p] pvUserInfo[0x%p] failed: %u (0x%X)"),
                _fname, pRtpOutput, pvUserInfo,
                dwError, dwError
            ));
    }

    if (pdwError)
    {
        *pdwError = dwError;
    }
    
    return(pRtpOutput);
}

/* Deletes an output, assumes outputs are unmapped and the session is
 * stopped. Update the index for the outputs that are left after the
 * one being removed */
DWORD RtpDelOutput(
        RtpSess_t       *pRtpSess,
        RtpOutput_t     *pRtpOutput
    )
{
    BOOL             bOk;
    DWORD            dwError;
    long             lCount;
    RtpQueueItem_t  *pRtpQueueItem;

    TraceFunctionName("RtpDelOutput");

    dwError = NOERROR;

    bOk = FALSE;
    
    if (!pRtpSess)
    {
        /* Having pRtpSess as a NULL pointer means Init hasn't been
         * called, return this error instead of RTPERR_POINTER to be
         * consistent */
        dwError = RTPERR_INVALIDSTATE;

        TraceRetail((
                CLASS_ERROR, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpOutput[0x%p] failed: %s (0x%X)"),
                _fname, pRtpOutput,
                RTPERR_TEXT(dwError), dwError
            ));
        
        return(dwError);
    }

    if (!pRtpOutput)
    {
        dwError = RTPERR_POINTER;

        goto end;
    }
    
    bOk = RtpEnterCriticalSection(&pRtpSess->OutputCritSect);

    if (!bOk)
    {
        goto end;
    }

    /* Shift the index from the next output (if any) and upto the last
     * one */
    for(pRtpQueueItem = pRtpOutput->OutputQItem.pNext;
        pRtpSess->OutputQ.pFirst != pRtpQueueItem;
        pRtpQueueItem = pRtpQueueItem->pNext)
    {
        pRtpQueueItem->dwKey--;
    }

    /* Now remove output from the session */
    pRtpQueueItem =
        dequeue(&pRtpSess->OutputQ, NULL, &pRtpOutput->OutputQItem);

    /* We can now free the object */
    RtpOutputFree(pRtpOutput);
    
    if (!pRtpQueueItem)
    {
        dwError = RTPERR_UNEXPECTED;
    }

 end:
    if (bOk)
    {
        RtpLeaveCriticalSection(&pRtpSess->OutputCritSect);
    }

    if (dwError != NOERROR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpOutput[0x%p] failed: %s (0x%X)"),
                _fname, pRtpOutput,
                RTPERR_TEXT(dwError), dwError
            ));
    }

    return(dwError);
}

DWORD RtpSetOutputMode(
        RtpSess_t       *pRtpSess,
        int              iPos,
        RtpOutput_t     *pRtpOutput,
        int              iOutMode
    )
{
    DWORD            dwError;
    RtpQueueItem_t  *pRtpQueueItem;

    TraceFunctionName("RtpSetOutputMode");

    if (iOutMode <= RTPDMXMODE_FIRST || iOutMode >= RTPDMXMODE_LAST)
    {
        dwError = RTPERR_INVALIDARG;
            
        goto end;
    }

    if (!pRtpSess)
    {
        dwError = RTPERR_INVALIDSTATE;

        goto end;
    }

    /* verify object ID in RtpSess_t */
    if (pRtpSess->dwObjectID != OBJECTID_RTPSESS)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpSess[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpSess,
                pRtpSess->dwObjectID, OBJECTID_RTPSESS
            ));

        dwError = RTPERR_INVALIDRTPSESS;

        goto end;
    }

    if (iPos >= 0)
    {
        pRtpQueueItem = findQN(&pRtpSess->OutputQ,
                               &pRtpSess->OutputCritSect,
                               iPos);

        if (!pRtpQueueItem)
        {
            dwError = RTPERR_INVALIDARG;

            goto end;
        }

        pRtpOutput =
            CONTAINING_RECORD(pRtpQueueItem, RtpOutput_t, OutputQItem);
    }
    else if (!pRtpOutput)
    {
        dwError = RTPERR_POINTER;

        goto end;
    }

    /* Set mode */

    dwError = NOERROR;

    RtpSetOutputMode_(pRtpOutput, iOutMode);
    
 end:
    if (dwError == NOERROR)
    {
        TraceDebug((
                CLASS_INFO, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpSess[0x%p] Out:%d Mode:%s"),
                _fname, pRtpSess, iPos, g_psRtpDmxMode[iOutMode]
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpSess[0x%p] failed: %u (0x%X)"),
                _fname, pRtpSess,
                dwError, dwError
            ));
    }
    
    return(dwError);
}

DWORD RtpOutputState(
        RtpAddr_t       *pRtpAddr,
        int              iPos,
        RtpOutput_t     *pRtpOutput,
        DWORD            dwSSRC,
        BOOL             bAssigned
    )
{
    BOOL             bOk;
    DWORD            dwError;
    BOOL             bCreate;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpSess_t       *pRtpSess;
    RtpUser_t       *pRtpUser;
    
    TraceFunctionName("RtpOutputState");

    if (!pRtpAddr)
    {
        dwError = RTPERR_INVALIDSTATE;

        goto end;
    }

    /* verify object ID in RtpSess_t */
    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpAddr[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpAddr,
                pRtpAddr->dwObjectID, OBJECTID_RTPADDR
            ));

        dwError = RTPERR_INVALIDRTPADDR;

        goto end;
    }

    pRtpSess = pRtpAddr->pRtpSess;

    /*
     * Find RtpOutput
     */

    if (iPos >= 0)
    {
        /* Find RtpOutput by position */
        pRtpQueueItem = findQN(&pRtpSess->OutputQ,
                               &pRtpSess->OutputCritSect,
                               iPos);

        if (pRtpQueueItem)
        {
            pRtpOutput =
                CONTAINING_RECORD(pRtpQueueItem, RtpOutput_t, OutputQItem);
        }
        else
        {
            dwError = RTPERR_INVALIDARG;

            goto end;
        }
    }

    pRtpUser = (RtpUser_t *)NULL;
    
    /* If an SSRC is passed locate the user who owns it */
    if (dwSSRC)
    {
        bCreate = FALSE;
        pRtpUser = LookupSSRC(pRtpAddr, dwSSRC, &bCreate);

        if (!pRtpUser)
        {
            dwError = RTPERR_NOTFOUND;

            goto end;
        }
    }

    bOk = RtpEnterCriticalSection(&pRtpSess->OutputCritSect);

    if (!bOk)
    {
        dwError = RTPERR_CRITSECT;
        
        goto end;
    }

    /* Set the output state */
    if (bAssigned)
    {
        /*
         * Assigned
         */
        
        if (!pRtpUser || !pRtpOutput)
        {
            dwError = RTPERR_INVALIDARG;

            goto end;
        }
        
        /* Associate output to user */
        dwError = RtpOutputAssign(pRtpSess, pRtpUser, pRtpOutput);
    }
    else
    {
        /*
         * Unassigned
         */

        if (!pRtpUser && !pRtpOutput)
        {
            dwError = RTPERR_INVALIDARG;

            goto end;
        }
        
        dwError = RTPERR_INVALIDSTATE;

        if (!pRtpUser)
        {
            pRtpUser = pRtpOutput->pRtpUser;

            if (!pRtpUser)
            {
                goto end;
            }
        }
        else if (!pRtpOutput)
        {
            pRtpOutput = pRtpUser->pRtpOutput;

            if (!pRtpOutput)
            {
                goto end;
            }
        }
        
        /* Unassociate output from user */
        dwError = RtpOutputUnassign(pRtpSess, pRtpUser, pRtpOutput);
    }
    
 end:
    if (bOk)
    {
        RtpLeaveCriticalSection(&pRtpSess->OutputCritSect);
    }

    if (dwError == NOERROR)
    {
        TraceRetail((
                CLASS_INFO, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpSess[0x%p] pRtpOutput[0x%p]:%u ")
                _T("SSRC:0x%X output %s"),
                _fname, pRtpSess, pRtpOutput, pRtpOutput->OutputQItem.dwKey,
                ntohl(dwSSRC), bAssigned? _T("assigned") : _T("unassigned")
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpSess[0x%p] pRtpOutput[0x%p]:%u ")
                _T("SSRC:0x%X output %s failed: %u (0x%X)"),
                _fname, pRtpSess, pRtpOutput, pRtpOutput->OutputQItem.dwKey,
                ntohl(dwSSRC), bAssigned? _T("assigned") : _T("unassigned"),
                dwError, dwError
            ));
    }

    return(dwError);
}

DWORD RtpUnmapAllOuts(
        RtpSess_t       *pRtpSess
    )
{
    BOOL             bOk;
    DWORD            dwError;
    long             lCount;
    DWORD            dwUnmapped;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpOutput_t     *pRtpOutput;

    TraceFunctionName("RtpUnmapAllOuts");

    pRtpOutput = (RtpOutput_t *)NULL;

    dwUnmapped = 0;

    dwError = RTPERR_CRITSECT;
    
    bOk = RtpEnterCriticalSection(&pRtpSess->OutputCritSect);

    if (!bOk)
    {
        goto end;
    }

    pRtpQueueItem = pRtpSess->OutputQ.pFirst;
        
    for(lCount = GetQueueSize(&pRtpSess->OutputQ);
        lCount > 0;
        lCount--, pRtpQueueItem = pRtpQueueItem->pNext)
    {
        pRtpOutput =
            CONTAINING_RECORD(pRtpQueueItem, RtpOutput_t, OutputQItem);

        if (pRtpOutput->pRtpUser)
        {
            RtpOutputUnassign(pRtpSess, pRtpOutput->pRtpUser, pRtpOutput);

            dwUnmapped++;
        }
    }

    RtpLeaveCriticalSection(&pRtpSess->OutputCritSect);

    dwError = NOERROR;
    
 end:
    if (dwError)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpSess[0x%p] failed: %u (0x%X)"),
                _fname, pRtpSess, dwError, dwError
            ));
    }
    else
    {
        TraceRetail((
                CLASS_INFO, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpSess[0x%p] unmapped %u outputs"),
                _fname, pRtpSess, dwUnmapped
            ));
    }

    return(dwUnmapped);
}

/* Find the output assigned (if any) to the SSRC, return either
 * position or user info or both */
DWORD RtpFindOutput(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwSSRC,
        int             *piPos,
        void           **ppvUserInfo
    )
{
    DWORD            dwError;
    BOOL             bCreate;
    int              iPos;
    void            *pvUserInfo;
    RtpOutput_t     *pRtpOutput;
    RtpUser_t       *pRtpUser;
    
    TraceFunctionName("RtpFindOutput");

    if (!pRtpAddr)
    {
        dwError = RTPERR_INVALIDSTATE;

        goto end;
    }

    /* verify object ID in RtpSess_t */
    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpAddr[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpAddr,
                pRtpAddr->dwObjectID, OBJECTID_RTPADDR
            ));

        dwError = RTPERR_INVALIDRTPADDR;

        goto end;
    }

    if (!piPos && !ppvUserInfo)
    {
        dwError = RTPERR_POINTER;

        goto end;
    }

    dwError = NOERROR;
    
    bCreate = FALSE;
    pRtpUser = LookupSSRC(pRtpAddr, dwSSRC, &bCreate);

    /* By default assume SSRC doesn't have an output assigned */
    iPos = -1;
    pvUserInfo = NULL;
    
    if (pRtpUser)
    {
        pRtpOutput = pRtpUser->pRtpOutput;
        
        if (pRtpOutput)
        {
            /* SSRC has this output assigned */
        
            iPos = (int)pRtpOutput->OutputQItem.dwKey;
            
            pvUserInfo = pRtpOutput->pvUserInfo;
        }
    }
    else
    {
        TraceRetail((
                CLASS_WARNING, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpAddr[0x%p] No user found with SSRC:0x%X"),
                _fname, pRtpAddr, ntohl(dwSSRC)
            ));
    }

    if (piPos)
    {
        *piPos = iPos;
    }

    if (ppvUserInfo)
    {
        *ppvUserInfo = pvUserInfo;
    }

 end:
    if (dwError)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpAddr[0x%p] failed: %u (0x%X)"),
                _fname, pRtpAddr, dwError, dwError
            ));
    }
    else
    {
        TraceRetail((
                CLASS_INFO, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpAddr[0x%p] SSRC:0x%X has pRtpOutput[0x%p]:%d"),
                _fname, pRtpAddr,
                ntohl(dwSSRC), pRtpOutput, iPos
            ));
    }
    
    return(dwError);
}

/* Find the SSRC mapped to the ooutput, if iPos >= 0 use it, otherwise
 * use pRtpOutput */
DWORD RtpFindSSRC(
        RtpAddr_t       *pRtpAddr,
        int              iPos,
        RtpOutput_t     *pRtpOutput,
        DWORD           *pdwSSRC
    )
{
    DWORD            dwError;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpSess_t       *pRtpSess;
    RtpUser_t       *pRtpUser;
    
    TraceFunctionName("RtpFindSSRC");

    if (!pRtpAddr)
    {
        dwError = RTPERR_INVALIDSTATE;

        goto end;
    }

    if (!pdwSSRC)
    {
        dwError = RTPERR_POINTER;

        goto end;
    }

    /* verify object ID in RtpSess_t */
    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpAddr[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpAddr,
                pRtpAddr->dwObjectID, OBJECTID_RTPADDR
            ));

        dwError = RTPERR_INVALIDRTPADDR;

        goto end;
    }

    if (iPos < 0 && !pRtpOutput)
    {
        dwError = RTPERR_INVALIDARG;

        goto end;
    }

    dwError = NOERROR;

    pRtpSess = pRtpAddr->pRtpSess;

    if (iPos >= 0)
    {
        /* Find RtpOutput by position */
        pRtpQueueItem = findQN(&pRtpSess->OutputQ,
                               &pRtpSess->OutputCritSect,
                               iPos);

        if (pRtpQueueItem)
        {
            pRtpOutput =
                CONTAINING_RECORD(pRtpQueueItem, RtpOutput_t, OutputQItem);
        }
        else
        {
            dwError = RTPERR_INVALIDARG;

            goto end;
        }
    }
    else if (!pRtpOutput)
    {
        dwError = RTPERR_POINTER;

        goto end;
    }

    pRtpUser = pRtpOutput->pRtpUser;

    if (pRtpUser)
    {
        /* This output is assigned */
        *pdwSSRC = pRtpUser->dwSSRC;
    }
    else
    {
        *pdwSSRC = 0;
    }
    
 end:
    if (dwError)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpAddr[0x%p] failed: %u (0x%X)"),
                _fname, pRtpAddr, dwError, dwError
            ));
    }
    else
    {
        TraceRetail((
                CLASS_INFO, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpAddr[0x%p] pRtpOutput[0x%p]:%d has SSRC:0x%X"),
                _fname, pRtpAddr,
                pRtpOutput, iPos, ntohl(*pdwSSRC)
            ));
    }
    
    return(dwError);
}

RtpOutput_t *RtpOutputAlloc(void)
{
    RtpOutput_t     *pRtpOutput;

    TraceFunctionName("RtpOutputAlloc");

    pRtpOutput = RtpHeapAlloc(g_pRtpGlobalHeap, sizeof(RtpOutput_t));

    if (pRtpOutput)
    {
        ZeroMemory(pRtpOutput, sizeof(RtpOutput_t));

        pRtpOutput->dwObjectID = OBJECTID_RTPOUTPUT;
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DEMUX, S_DEMUX_ALLOC,
                _T("%s: pRtpOutput[0x%p] failed"),
                _fname, pRtpOutput
            ));
    }
    
    return(pRtpOutput);
}

RtpOutput_t *RtpOutputFree(RtpOutput_t *pRtpOutput)
{
    TraceFunctionName("RtpOutputFree");

    if (!pRtpOutput)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DEMUX, S_DEMUX_ALLOC,
                _T("%s: pRtpOutput[0x%p] NULL pointer"),
                _fname, pRtpOutput
            ));
        
        return(pRtpOutput);
    }

    /* verify object ID in RtpOutput_t */
    if (pRtpOutput->dwObjectID != OBJECTID_RTPOUTPUT)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DEMUX, S_DEMUX_ALLOC,
                _T("%s: pRtpOutput[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpOutput,
                pRtpOutput->dwObjectID, OBJECTID_RTPOUTPUT
            ));

        return((RtpOutput_t *)NULL);
    }

    /* Invalidate object */
    INVALIDATE_OBJECTID(pRtpOutput->dwObjectID);
    
    RtpHeapFree(g_pRtpGlobalHeap, pRtpOutput);

    return(pRtpOutput);
}

/* Try to find and output for this user, assumes no output has been
 * assigned yet */
RtpOutput_t *RtpGetOutput(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser
    )
{
    BOOL             bOk;
    long             lCount;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpOutput_t     *pRtpOutput;
    RtpSess_t       *pRtpSess;

    TraceFunctionName("RtpGetOutput");
    
    /* Note that this function assumes no output is assigned yet */
    
    bOk = FALSE;

    pRtpSess = pRtpAddr->pRtpSess;

    pRtpOutput = (RtpOutput_t *)NULL;
    
    bOk = RtpEnterCriticalSection(&pRtpSess->OutputCritSect);

    if (!bOk)
    {
        goto end;
    }

    pRtpQueueItem = pRtpSess->OutputQ.pFirst;
        
    for(lCount = GetQueueSize(&pRtpSess->OutputQ);
        lCount > 0;
        lCount--, pRtpQueueItem = pRtpQueueItem->pNext)
    {
        pRtpOutput =
            CONTAINING_RECORD(pRtpQueueItem, RtpOutput_t, OutputQItem);

        if ( RtpBitTest(pRtpOutput->dwOutputFlags, RTPOUTFG_ENABLED)
             &&
             (RtpBitTest2(pRtpOutput->dwOutputFlags,
                          RTPOUTFG_FREE, RTPOUTFG_AUTO) ==
              RtpBitPar2(RTPOUTFG_FREE, RTPOUTFG_AUTO)) )
        {
            /* This output is enabled, is free and can be used for
             * automatic assignment */

            RtpOutputAssign(pRtpSess, pRtpUser, pRtpOutput);

            break;
        }
    }

    RtpLeaveCriticalSection(&pRtpSess->OutputCritSect);

    if (!lCount)
    {
        pRtpOutput = (RtpOutput_t *)NULL; 
    }

 end:
    if (pRtpOutput)
    {
        TraceRetail((
                CLASS_INFO, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] got pRtpOutput[0x%p]"),
                _fname, pRtpAddr, pRtpUser, pRtpOutput
            ));
    }
    
    return(pRtpOutput);
}

DWORD RtpSetOutputMode_(
        RtpOutput_t     *pRtpOutput,
        int              iOutMode
    )
{
    pRtpOutput->iOutMode = iOutMode;
    
    switch(iOutMode)
    {
    case RTPDMXMODE_MANUAL:
        RtpBitSet  (pRtpOutput->dwOutputFlags, RTPOUTFG_MANUAL);
        RtpBitReset(pRtpOutput->dwOutputFlags, RTPOUTFG_AUTO);
        RtpBitReset(pRtpOutput->dwOutputFlags, RTPOUTFG_ENTIMEOUT);
        break;
    case RTPDMXMODE_AUTO:
        RtpBitReset(pRtpOutput->dwOutputFlags, RTPOUTFG_MANUAL);
        RtpBitSet  (pRtpOutput->dwOutputFlags, RTPOUTFG_AUTO);
        RtpBitSet  (pRtpOutput->dwOutputFlags, RTPOUTFG_ENTIMEOUT);
        break;
    case RTPDMXMODE_AUTO_MANUAL:
        RtpBitReset(pRtpOutput->dwOutputFlags, RTPOUTFG_MANUAL);
        RtpBitSet  (pRtpOutput->dwOutputFlags, RTPOUTFG_AUTO);
        RtpBitReset(pRtpOutput->dwOutputFlags, RTPOUTFG_ENTIMEOUT);
        break;
    }

    return(pRtpOutput->dwOutputFlags);
}       

DWORD RtpOutputAssign(
        RtpSess_t       *pRtpSess,
        RtpUser_t       *pRtpUser,
        RtpOutput_t     *pRtpOutput
    )
{
    BOOL             bOk;
    DWORD            dwError;

    TraceFunctionName("RtpOutputAssign");

    bOk = RtpEnterCriticalSection(&pRtpSess->OutputCritSect);
    
    /* If the critical section fails I don't have any other choice but
     * proceed */

    dwError = RTPERR_INVALIDSTATE;

    if (!RtpBitTest(pRtpOutput->dwOutputFlags, RTPOUTFG_ENABLED))
    {
        /* This output is disabled and can not be used */
        goto end;
    }
    
    if (!RtpBitTest(pRtpOutput->dwOutputFlags, RTPOUTFG_FREE))
    {
        if ( (pRtpOutput->pRtpUser == pRtpUser) &&
             (pRtpUser->pRtpOutput == pRtpOutput) )
        {
            dwError = NOERROR;

            TraceRetail((
                    CLASS_WARNING, GROUP_DEMUX, S_DEMUX_OUTS,
                    _T("%s: pRtpSess[0x%p] pRtpUser[0x%p] pRtpOutput[0x%p] ")
                    _T("already assigned, nothing else to do"),
                    _fname, pRtpSess, pRtpUser, pRtpOutput
                ));
            
            goto end;
        }
        else
        {
            /* Output is already assigned to a different user */
            TraceRetail((
                    CLASS_WARNING, GROUP_DEMUX, S_DEMUX_OUTS,
                    _T("%s: pRtpSess[0x%p] pRtpUser[0x%p] pRtpOutput[0x%p] ")
                    _T("failed: Output already assigned to pRtpUser[0x%p] ")
                    _T("%s (0x%X) unassign requested output"),
                    _fname, pRtpSess, pRtpUser, pRtpOutput,
                    pRtpOutput->pRtpUser,
                    RTPERR_TEXT(dwError), dwError
                ));

            /* Freeing the requested output */
            RtpOutputUnassign(pRtpSess, pRtpOutput->pRtpUser, pRtpOutput);
        }
    }

    if (pRtpUser->pRtpOutput)
    {
        /* User already has an output */
        TraceRetail((
                CLASS_WARNING, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpSess[0x%p] pRtpUser[0x%p] pRtpOutput[0x%p] ")
                _T("failed: User already has an pRtpOutput[0x%p] ")
                _T("%s (0x%X) unassign current output"),
                _fname, pRtpSess, pRtpUser, pRtpOutput,
                pRtpUser->pRtpOutput,
                RTPERR_TEXT(dwError), dwError
            ));

        /* Unassig it */
        RtpOutputUnassign(pRtpSess, pRtpUser, pRtpUser->pRtpOutput);
    }

    dwError = NOERROR;
    
    /* Assign this output to this user */
    pRtpOutput->pRtpUser = pRtpUser;
                
    pRtpUser->pRtpOutput = pRtpOutput;

    /* Output is in use */
    RtpBitReset(pRtpOutput->dwOutputFlags, RTPOUTFG_FREE);

    TraceRetail((
            CLASS_INFO, GROUP_DEMUX, S_DEMUX_OUTS,
            _T("%s: pRtpSess[0x%p] pRtpUser[0x%p] pRtpOutput[0x%p] Out:%u %s ")
            _T("Output assigned to user"),
            _fname, pRtpSess, pRtpUser, pRtpOutput,
            pRtpOutput->OutputQItem.dwKey, RTPRECVSENDSTR(RECV_IDX)
        ));
    
    RtpPostEvent(pRtpUser->pRtpAddr,
                 pRtpUser,
                 RTPEVENTKIND_PINFO,
                 RTPPARINFO_MAPPED,
                 pRtpUser->dwSSRC,
                 (DWORD_PTR)pRtpOutput->pvUserInfo /* Pin */);

 end:
    if (bOk)
    {
        bOk = RtpLeaveCriticalSection(&pRtpSess->OutputCritSect);
    }

    return(dwError);
}

DWORD RtpOutputUnassign(
        RtpSess_t       *pRtpSess,
        RtpUser_t       *pRtpUser,
        RtpOutput_t     *pRtpOutput
    )
{
    BOOL             bOk;
    DWORD            dwError;
    
    TraceFunctionName("RtpOutputUnassign");

    bOk = RtpEnterCriticalSection(&pRtpSess->OutputCritSect);

    if (pRtpUser->pRtpOutput != pRtpOutput ||
        pRtpOutput->pRtpUser != pRtpUser)
    {
        dwError = RTPERR_INVALIDSTATE;

        goto end;
    }

    dwError = NOERROR;
    
    pRtpUser->pRtpOutput = (RtpOutput_t *)NULL;

    pRtpOutput->pRtpUser = (RtpUser_t *)NULL;
    
    RtpBitSet(pRtpOutput->dwOutputFlags, RTPOUTFG_FREE);
    
    /* If the critical section fails I don't have any other choice but
     * proceed */

    RtpPostEvent(pRtpUser->pRtpAddr,
                 pRtpUser,
                 RTPEVENTKIND_PINFO,
                 RTPPARINFO_UNMAPPED,
                 pRtpUser->dwSSRC,
                 (DWORD_PTR)pRtpOutput->pvUserInfo /* Pin */);

 end:
    if (bOk)
    {
        RtpLeaveCriticalSection(&pRtpSess->OutputCritSect);
    }

    if (dwError == NOERROR)
    {
        TraceRetail((
                CLASS_INFO, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpSess[0x%p] pRtpUser[0x%p] pRtpOutput[0x%p] ")
                _T("Out:%u %s Output unassigned from user"),
                _fname, pRtpSess, pRtpUser, pRtpOutput,
                pRtpOutput->OutputQItem.dwKey, RTPRECVSENDSTR(RECV_IDX)
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpSess[0x%p] pRtpUser[0x%p] pRtpOutput[0x%p] ")
                _T("Out:%u %s failed: %u (0x%X)"),
                _fname, pRtpSess, pRtpUser, pRtpOutput,
                pRtpOutput->OutputQItem.dwKey, RTPRECVSENDSTR(RECV_IDX),
                dwError, dwError
            ));
    }
  
    return(dwError);
}

DWORD RtpAddPt2FrequencyMap(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwPt,
        DWORD            dwFrequency,
        DWORD            dwRecvSend
    )
{
    DWORD            dwError;
    DWORD            i;
    RtpPtMap_t      *pRecvPtMap;

    TraceFunctionName("RtpAddPt2FrequencyMap");

    dwError = NOERROR;
    
    if (dwRecvSend == RECV_IDX)
    {
        pRecvPtMap = &pRtpAddr->RecvPtMap[0];
        
        /* Find out if the PT already exists */
        for(i = 0;
            pRecvPtMap[i].dwPt != -1 &&
                pRecvPtMap[i].dwPt != dwPt &&
                i < MAX_PTMAP;
            i++)
        {
            /* Empty body */;
        }

        if (i >= MAX_PTMAP)
        {
            dwError = RTPERR_RESOURCES;
            
            TraceRetail((
                    CLASS_ERROR, GROUP_DEMUX, S_DEMUX_OUTS,
                    _T("%s: pRtpAddr[0x%p] RECV ")
                    _T("PT:%u Frequency:%u failed: %s (0x%X)"),
                    _fname, pRtpAddr, dwPt, dwFrequency,
                    RTPERR_TEXT(dwError), dwError
                ));
        }
        else
        {
            /* New PT -or- Update existing PT */
            pRecvPtMap[i].dwPt = dwPt;
            pRecvPtMap[i].dwFrequency = dwFrequency;

            TraceRetail((
                    CLASS_INFO, GROUP_DEMUX, S_DEMUX_OUTS,
                    _T("%s: pRtpAddr[0x%p] RECV map[%u] ")
                    _T("PT:%u Frequency:%u"),
                    _fname, pRtpAddr, i, dwPt, dwFrequency
                ));
         }
    }

    return(dwError);
}

BOOL RtpLookupPT(
        RtpAddr_t       *pRtpAddr,
        BYTE             bPT
    )
{
    BOOL             bFound;
    DWORD            i;
    RtpPtMap_t      *pRecvPtMap;

    pRecvPtMap = &pRtpAddr->RecvPtMap[0];
    bFound = FALSE;
    
    /* Find out if the PT already exists */
    for(i = 0; pRecvPtMap[i].dwPt != -1 && i < MAX_PTMAP; i++)
    {
        if (pRecvPtMap[i].dwPt == bPT)
        {
            bFound = TRUE;

            break;
        }
    }

    return(bFound);
}

/* NOTE Assume the mapping doesn't have gaps, i.e. it never happens to
 * have a non assigned entry (PT=-1) between 2 valid mappings */
DWORD RtpMapPt2Frequency(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        DWORD            dwPt,
        DWORD            dwRecvSend
    )
{
    DWORD            dwError;
    DWORD            i;
    RtpPtMap_t      *pRecvPtMap;
    RtpNetRState_t  *pRtpNetRState;

    TraceFunctionName("RtpMapPt2Frequency");

    dwError = NOERROR;

    if (dwRecvSend != RECV_IDX)
    {
        return(dwError);
    }

    pRecvPtMap = &pRtpAddr->RecvPtMap[0];
    pRtpNetRState = &pRtpUser->RtpNetRState;
        
    /* Find out if the PT already exists */
    for(i = 0; pRecvPtMap[i].dwPt != -1 && i < MAX_PTMAP; i++)
    {
        if (pRecvPtMap[i].dwPt == dwPt)
        {
            /* Found it */
            pRtpNetRState->dwPt = dwPt;

            pRtpNetRState->dwRecvSamplingFreq = pRecvPtMap[i].dwFrequency;

            return(dwError);
        }
    }

    TraceRetail((
            CLASS_WARNING, GROUP_DEMUX, S_DEMUX_OUTS,
            _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
            _T("Pt:%u not found"),
            _fname, pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC),
            dwPt
        ));

    /* Report an error so this packet is dropped */
    dwError = RTPERR_NOTFOUND;

    return(dwError);
}
  
DWORD RtpFlushPt2FrequencyMaps(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwRecvSend
    )
{
    DWORD            i;

    if (dwRecvSend == RECV_IDX)
    {
        for(i = 0; i < MAX_PTMAP; i++)
        {
            pRtpAddr->RecvPtMap[i].dwPt = -1;
            pRtpAddr->RecvPtMap[i].dwFrequency = 0;
        }
    }

    return(NOERROR);
}

/* Set the output state to enabled or disabled. An output that is
 * enabled can be assigned to a user; an output that is disabled is
 * just skipped */
DWORD RtpOutputEnable(
        RtpOutput_t     *pRtpOutput,
        BOOL             bEnable
    )
{
    DWORD            dwError;

    TraceFunctionName("RtpOutputEnable");
    
    dwError = RTPERR_INVALIDSTATE;
    
    if (pRtpOutput)
    {
        if (bEnable)
        {
            RtpBitSet(pRtpOutput->dwOutputFlags, RTPOUTFG_ENABLED);
        }
        else
        {
            RtpBitReset(pRtpOutput->dwOutputFlags, RTPOUTFG_ENABLED);
        }

        dwError = NOERROR;
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_DEMUX, S_DEMUX_OUTS,
                _T("%s: pRtpOutput[0x%p] Enable:%u"),
                _fname, pRtpOutput, bEnable
            ));
    }

    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\msrtp\funcs\rtpfwrap.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpfwrap.c
 *
 *  Abstract:
 *
 *    Implements the RTP function wrapper.
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/01 created
 *
 **********************************************************************/

#include "struct.h"
#include "rtperr.h"

#include "rtpfwrap.h"

#include "rtpaddr.h"
#include "rtpglob.h"
#include "rtprtp.h"
#include "rtpdemux.h"
#include "rtpph.h"
#include "rtppinfo.h"
#include "rtpqos.h"
#include "rtpcrypt.h"
#include "rtpncnt.h"

/**********************************************************************
 *
 * Helper macros to build the validation mask for all the family of
 * functions
 *
 **********************************************************************/
#define _P1(_wr, _rd, _Zero) \
    ((_wr << 10) | (_rd << 9)  | (_Zero << 8))

#define _P2(_wr, _rd, _Zero) \
    ((_wr << 14) | (_rd << 13) | (_Zero << 12))

#define _S(_en,_p2,_lk,_p1,_fg) \
    (((_en<<15)|(_p2<<12)|(_lk<<11)|(_p1<<8)|(_fg))<<16)

#define _G(_en,_p2,_lk,_p1,_fg) \
    ((_en<<15)|(_p2<<12)|(_lk<<11)|(_p1<<8)|(_fg))

#define _FGS(b7,b6,b5,b4,b3,b2,b1,b0) \
    ((b7<<7)|(b6<<6)|(b5<<5)|(b4<<4)|(b3<<3)|(b2<<2)|(b1<<1)|b0)


/**********************************************************************
 *
 * Validation masks for all the family of functions
 *
 **********************************************************************/
                                                                       
/*
 * Control word validation mask for:
 * RTPF_ADDR - RTP Adress family of functions */
const DWORD g_dwControlRtpAddr[] = {
    /*---------------------------------------------------------------*/
    /* Enable Par 2     Lock   Par 1          Flags                  */
    /* |      |-----|   |      |-----|        |--------------------+ */
    /* |      w  r  z   |      w  r  z        |  |  |  |  |  |  |  | */
    /* 1      1  1  1   1      1  0  0        0  0  0  0  0  0  0  0 */
    /* 5      4  3  2   1      0  9  8        7  6  5  4  3  2  1  0 */
    /* |      |  |  |   |      |  |  |        |  |  |  |  |  |  |  | */
    /* v      v  v  v   v      v  v  v        v  v  v  v  v  v  v  v */
    _S(0, _P2(0, 0, 0), 0, _P1(0, 0, 0), _FGS(0, 0, 0, 0, 0, 0, 0, 0)) |
    _G(0, _P2(0, 0, 0), 0, _P1(0, 0, 0), _FGS(0, 0, 0, 0, 0, 0, 0, 0)),

    /* RTPADDR_CREATE */
    _S(1, _P2(1, 0, 1), 1, _P1(1, 1, 1), _FGS(0, 0, 0, 1, 1, 1, 1, 1)) |
    _G(1, _P2(1, 0, 1), 1, _P1(1, 1, 1), _FGS(0, 0, 0, 1, 1, 1, 1, 1))
    
};

/*
 * Control word validation mask for:
 * RTPF_GLOB - RTP Global family of functions */
const DWORD g_dwControlRtpGlob[] = {
    /*---------------------------------------------------------------*/
    /* Enable Par 2     Lock   Par 1          Flags                  */
    /* |      |-----|   |      |-----|        |--------------------+ */
    /* |      w  r  z   |      w  r  z        |  |  |  |  |  |  |  | */
    /* 1      1  1  1   1      1  0  0        0  0  0  0  0  0  0  0 */
    /* 5      4  3  2   1      0  9  8        7  6  5  4  3  2  1  0 */
    /* |      |  |  |   |      |  |  |        |  |  |  |  |  |  |  | */
    /* v      v  v  v   v      v  v  v        v  v  v  v  v  v  v  v */
    _S(0, _P2(0, 0, 0), 0, _P1(0, 0, 0), _FGS(0, 0, 0, 0, 0, 0, 0, 0)) |
    _G(0, _P2(0, 0, 0), 0, _P1(0, 0, 0), _FGS(0, 0, 0, 0, 0, 0, 0, 0)),
    
    _S(1, _P2(1, 0, 1), 1, _P1(1, 1, 1), _FGS(0, 0, 0, 1, 1, 1, 1, 1)) |
    _G(1, _P2(1, 0, 1), 1, _P1(1, 1, 1), _FGS(0, 0, 0, 1, 1, 1, 1, 1))
    
    
};

/*
 * Control word validation mask for:
 * RTPF_RTP - RTP specific family of functions */
/* TODO fill in the right values */
const DWORD g_dwControlRtpRtp[] = {
    /*---------------------------------------------------------------*/
    /* Enable Par 2     Lock   Par 1          Flags                  */
    /* |      |-----|   |      |-----|        |--------------------+ */
    /* |      w  r  z   |      w  r  z        |  |  |  |  |  |  |  | */
    /* 1      1  1  1   1      1  0  0        0  0  0  0  0  0  0  0 */
    /* 5      4  3  2   1      0  9  8        7  6  5  4  3  2  1  0 */
    /* |      |  |  |   |      |  |  |        |  |  |  |  |  |  |  | */
    /* v      v  v  v   v      v  v  v        v  v  v  v  v  v  v  v */
    _S(0, _P2(0, 0, 0), 0, _P1(0, 0, 0), _FGS(0, 0, 0, 0, 0, 0, 0, 0)) |
    _G(0, _P2(0, 0, 0), 0, _P1(0, 0, 0), _FGS(0, 0, 0, 0, 0, 0, 0, 0)),
    
    _S(1, _P2(1, 0, 1), 1, _P1(1, 1, 1), _FGS(0, 0, 0, 1, 1, 1, 1, 1)) |
    _G(1, _P2(1, 0, 1), 1, _P1(1, 1, 1), _FGS(0, 0, 0, 1, 1, 1, 1, 1))
    
    
};

/*
 * Control word validation mask for:
 * RTPF_DEMUX - Demultiplexing family of functions */
/* TODO fill in the right values */
const DWORD g_dwControlRtpDemux[] = {
    /*---------------------------------------------------------------*/
    /* Enable Par 2     Lock   Par 1          Flags                  */
    /* |      |-----|   |      |-----|        |--------------------+ */
    /* |      w  r  z   |      w  r  z        |  |  |  |  |  |  |  | */
    /* 1      1  1  1   1      1  0  0        0  0  0  0  0  0  0  0 */
    /* 5      4  3  2   1      0  9  8        7  6  5  4  3  2  1  0 */
    /* |      |  |  |   |      |  |  |        |  |  |  |  |  |  |  | */
    /* v      v  v  v   v      v  v  v        v  v  v  v  v  v  v  v */
    _S(0, _P2(0, 0, 0), 0, _P1(0, 0, 0), _FGS(0, 0, 0, 0, 0, 0, 0, 0)) |
    _G(0, _P2(0, 0, 0), 0, _P1(0, 0, 0), _FGS(0, 0, 0, 0, 0, 0, 0, 0)),
    
    _S(1, _P2(1, 0, 1), 1, _P1(1, 1, 1), _FGS(0, 0, 0, 1, 1, 1, 1, 1)) |
    _G(1, _P2(1, 0, 1), 1, _P1(1, 1, 1), _FGS(0, 0, 0, 1, 1, 1, 1, 1))
    
    
};

/*
 * Control word validation mask for:
 * RTPF_PH - Payload Handling family of functions */
/* TODO fill in the right values */
const DWORD g_dwControlRtpPh[] = {
    /*---------------------------------------------------------------*/
    /* Enable Par 2     Lock   Par 1          Flags                  */
    /* |      |-----|   |      |-----|        |--------------------+ */
    /* |      w  r  z   |      w  r  z        |  |  |  |  |  |  |  | */
    /* 1      1  1  1   1      1  0  0        0  0  0  0  0  0  0  0 */
    /* 5      4  3  2   1      0  9  8        7  6  5  4  3  2  1  0 */
    /* |      |  |  |   |      |  |  |        |  |  |  |  |  |  |  | */
    /* v      v  v  v   v      v  v  v        v  v  v  v  v  v  v  v */
    _S(0, _P2(0, 0, 0), 0, _P1(0, 0, 0), _FGS(0, 0, 0, 0, 0, 0, 0, 0)) |
    _G(0, _P2(0, 0, 0), 0, _P1(0, 0, 0), _FGS(0, 0, 0, 0, 0, 0, 0, 0)),
    
    _S(1, _P2(1, 0, 1), 1, _P1(1, 1, 1), _FGS(0, 0, 0, 1, 1, 1, 1, 1)) |
    _G(1, _P2(1, 0, 1), 1, _P1(1, 1, 1), _FGS(0, 0, 0, 1, 1, 1, 1, 1))
    
    
};

/*
 * Control word validation mask for:
 * RTPF_PARINFO - Participants Info family of functions */
/* TODO fill in the right values */
const DWORD g_dwControlRtpParInfo[] = {
    /*---------------------------------------------------------------*/
    /* Enable Par 2     Lock   Par 1          Flags                  */
    /* |      |-----|   |      |-----|        |--------------------+ */
    /* |      w  r  z   |      w  r  z        |  |  |  |  |  |  |  | */
    /* 1      1  1  1   1      1  0  0        0  0  0  0  0  0  0  0 */
    /* 5      4  3  2   1      0  9  8        7  6  5  4  3  2  1  0 */
    /* |      |  |  |   |      |  |  |        |  |  |  |  |  |  |  | */
    /* v      v  v  v   v      v  v  v        v  v  v  v  v  v  v  v */
    _S(0, _P2(0, 0, 0), 0, _P1(0, 0, 0), _FGS(0, 0, 0, 0, 0, 0, 0, 0)) |
    _G(0, _P2(0, 0, 0), 0, _P1(0, 0, 0), _FGS(0, 0, 0, 0, 0, 0, 0, 0)),
    
    _S(1, _P2(1, 0, 1), 1, _P1(1, 1, 1), _FGS(0, 0, 0, 1, 1, 1, 1, 1)) |
    _G(1, _P2(1, 0, 1), 1, _P1(1, 1, 1), _FGS(0, 0, 0, 1, 1, 1, 1, 1))
    
    
};

/*
 * Control word validation mask for:
 * RTPF_QOS - Quality of Service family of functions */
/* TODO fill in the right values */
const DWORD g_dwControlRtpQos[] = {
    /*---------------------------------------------------------------*/
    /* Enable Par 2     Lock   Par 1          Flags                  */
    /* |      |-----|   |      |-----|        |--------------------+ */
    /* |      w  r  z   |      w  r  z        |  |  |  |  |  |  |  | */
    /* 1      1  1  1   1      1  0  0        0  0  0  0  0  0  0  0 */
    /* 5      4  3  2   1      0  9  8        7  6  5  4  3  2  1  0 */
    /* |      |  |  |   |      |  |  |        |  |  |  |  |  |  |  | */
    /* v      v  v  v   v      v  v  v        v  v  v  v  v  v  v  v */
    _S(0, _P2(0, 0, 0), 0, _P1(0, 0, 0), _FGS(0, 0, 0, 0, 0, 0, 0, 0)) |
    _G(0, _P2(0, 0, 0), 0, _P1(0, 0, 0), _FGS(0, 0, 0, 0, 0, 0, 0, 0)),
    
    _S(1, _P2(1, 0, 1), 1, _P1(1, 1, 1), _FGS(0, 0, 0, 1, 1, 1, 1, 1)) |
    _G(1, _P2(1, 0, 1), 1, _P1(1, 1, 1), _FGS(0, 0, 0, 1, 1, 1, 1, 1))
    
    
};

/*
 * Control word validation mask for:
 * RTPF_CRYPT - Cryptography family of functions */
/* TODO fill in the right values */
const DWORD g_dwControlRtpCrypt[] = {
    /*---------------------------------------------------------------*/
    /* Enable Par 2     Lock   Par 1          Flags                  */
    /* |      |-----|   |      |-----|        |--------------------+ */
    /* |      w  r  z   |      w  r  z        |  |  |  |  |  |  |  | */
    /* 1      1  1  1   1      1  0  0        0  0  0  0  0  0  0  0 */
    /* 5      4  3  2   1      0  9  8        7  6  5  4  3  2  1  0 */
    /* |      |  |  |   |      |  |  |        |  |  |  |  |  |  |  | */
    /* v      v  v  v   v      v  v  v        v  v  v  v  v  v  v  v */
    _S(0, _P2(0, 0, 0), 0, _P1(0, 0, 0), _FGS(0, 0, 0, 0, 0, 0, 0, 0)) |
    _G(0, _P2(0, 0, 0), 0, _P1(0, 0, 0), _FGS(0, 0, 0, 0, 0, 0, 0, 0)),
    
    _S(1, _P2(1, 0, 1), 1, _P1(1, 1, 1), _FGS(0, 0, 0, 1, 1, 1, 1, 1)) |
    _G(1, _P2(1, 0, 1), 1, _P1(1, 1, 1), _FGS(0, 0, 0, 1, 1, 1, 1, 1))
    
    
};

/*
 * Control word validation mask for:
 * RTPF_STATS - Statistics family of functions */
/* TODO fill in the right values */
const DWORD g_dwControlRtpStats[] = {
    /*---------------------------------------------------------------*/
    /* Enable Par 2     Lock   Par 1          Flags                  */
    /* |      |-----|   |      |-----|        |--------------------+ */
    /* |      w  r  z   |      w  r  z        |  |  |  |  |  |  |  | */
    /* 1      1  1  1   1      1  0  0        0  0  0  0  0  0  0  0 */
    /* 5      4  3  2   1      0  9  8        7  6  5  4  3  2  1  0 */
    /* |      |  |  |   |      |  |  |        |  |  |  |  |  |  |  | */
    /* v      v  v  v   v      v  v  v        v  v  v  v  v  v  v  v */
    _S(0, _P2(0, 0, 0), 0, _P1(0, 0, 0), _FGS(0, 0, 0, 0, 0, 0, 0, 0)) |
    _G(0, _P2(0, 0, 0), 0, _P1(0, 0, 0), _FGS(0, 0, 0, 0, 0, 0, 0, 0)),
    
    _S(1, _P2(1, 0, 1), 1, _P1(1, 1, 1), _FGS(0, 0, 0, 1, 1, 1, 1, 1)) |
    _G(1, _P2(1, 0, 1), 1, _P1(1, 1, 1), _FGS(0, 0, 0, 1, 1, 1, 1, 1))
    
    
};

/**********************************************************************
 *
 * Put together all the per family entries, i.e. on each of the next
 * global arrays, there are as many entries as families exist plus 1
 * (the zero/NULL first entry)
 *
 **********************************************************************/

/*
 * Control words
 *
 * All the array of control words are held together here */
const DWORD *g_pdwControlWords[] = {
    (DWORD *)NULL,
    g_dwControlRtpAddr,
    g_dwControlRtpGlob,
    g_dwControlRtpRtp,
    g_dwControlRtpDemux,
    g_dwControlRtpPh,
    g_dwControlRtpParInfo,
    g_dwControlRtpQos,
    g_dwControlRtpCrypt,
    g_dwControlRtpStats
    
};

/*
 * Family functions
 *
 * Array of pointers to the functions that serve every family of
 * functions */
const RtpFamily_f g_fRtpFamilyFunc[] = {
    (RtpFamily_f)NULL,
    ControlRtpAddr,
    ControlRtpGlob,
    ControlRtpRtp,
    ControlRtpDemux,
    ControlRtpPh,
    ControlRtpParInfo,
    ControlRtpQos,
    ControlRtpCrypt,
    ControlRtpStats
};

/*
 * Number of functions on each family
 *
 * Arrays of DWORD containing the number of functions each family has
 * */
const DWORD g_dwLastFunction[] = {
    0,
    RTPADDR_LAST,
    RTPGLOB_LAST,
    RTPRTP_LAST,
    RTPDEMUX_LAST,
    RTPPH_LAST,
    RTPPARINFO_LAST,
    RTPQOS_LAST,
    RTPCRYPT_LAST,
    RTPSTATS_LAST
};

/**********************************************************************
 **********************************************************************/

/* Act upon the input control DWORD */
#define GETFAMILY(Control)   ((Control >> 20) & 0xf)
#define GETFUNCTION(Control) ((Control >> 16) & 0xf)
#define GETDIR(Control)      (Control & 0x01000000)

/*
 * Validates the control word, parameters, and if all the tests
 * succeed, call the proper function that does the work */
HRESULT RtpValidateAndExecute(RtpControlStruct_t *pRtpControlStruct)
{
    DWORD        dwControl;  /* control DWORD passed by the user */
    DWORD        dwCtrlWord; /* control WORD word looked up */
    DWORD        dwFamily;   /* Family of functions */
    DWORD        dwFunction; /* Function in family */
    DWORD_PTR    dwPar;
    
    dwControl = pRtpControlStruct->dwControlWord;
    
    /* Validate family */
    dwFamily = GETFAMILY(dwControl);
    pRtpControlStruct->dwFamily = dwFamily;
    
    if (!dwFamily || (dwFamily >= RTPF_LAST)) {
        return(RTPERR_INVALIDFAMILY);
    }

    /* Validate function range in family */
    dwFunction = GETFUNCTION(dwControl);
    pRtpControlStruct->dwFunction = dwFunction;
    
    if (!dwFunction || dwFunction >= g_dwLastFunction[dwFamily]) {
        return(RTPERR_INVALIDFUNCTION);
    }

    /* Obtain control word */
    dwCtrlWord = *(g_pdwControlWords[dwFamily] + dwFunction);

    /* Get direction */
    pRtpControlStruct->dwDirection = 0;

    if (GETDIR(dwControl)) {
        dwCtrlWord >>= 16;
        pRtpControlStruct->dwDirection = 0;
    }

    /* Get the real control WORD for the specific direction */
    dwCtrlWord &= 0xffff;
    pRtpControlStruct->dwControlWord = dwCtrlWord;

    /* Check if function is allowed for this direction */
    if (!RTPCTRL_ENABLED(dwCtrlWord)) {
        return(RTPERR_INVALIDDIRECTION);
    }
    
    /* Validate flags */
    if ((dwControl & 0xff & dwCtrlWord) != (dwControl & 0xff)) {
        return(RTPERR_INVALIDFLAGS);
    }

    /*************************************/
    /* Validate parameters Par1 and Par2 */
    /*************************************/

    /* Validate parameter 1 */
    dwPar = pRtpControlStruct->dwPar1;
    
    if (RTPCTRL_TEST(dwCtrlWord, PAR1_ZERO)) {
        if (!dwPar) {
            /* set error RTP_E_ZERO */
            return(RTPERR_ZEROPAR1);
        }
    } else {
        if (RTPCTRL_TEST(dwCtrlWord, PAR1_RDPTR)) {
            if (IsBadReadPtr((void *)dwPar, sizeof(DWORD))) {
                return(RTPERR_RDPTRPAR1);
            }
        }

        if (RTPCTRL_TEST(dwCtrlWord, PAR1_WRPTR)) {
            if (IsBadWritePtr((void *)dwPar, sizeof(DWORD))) {
                return(RTPERR_WRPTRPAR1);
            }
        }
    }
    
    /* Validate parameter 2 */
    dwPar = pRtpControlStruct->dwPar2;
    
    if (RTPCTRL_TEST(dwCtrlWord, PAR2_ZERO)) {
        if (!dwPar) {
            /* set error RTP_E_ZERO */
            return(RTPERR_ZEROPAR2);
        }
    } else {
        if (RTPCTRL_TEST(dwCtrlWord, PAR2_RDPTR)) {
            if (IsBadReadPtr((void *)dwPar, sizeof(DWORD))) {
                return(RTPERR_RDPTRPAR2);
            }
        }

        if (RTPCTRL_TEST(dwCtrlWord, PAR2_WRPTR)) {
            if (IsBadWritePtr((void *)dwPar, sizeof(DWORD))) {
                return(RTPERR_WRPTRPAR2);
            }
        }
    }
    

    
    /* All tests passed, update and call function */
    pRtpControlStruct->RtpFamilyFunc = g_fRtpFamilyFunc[dwFamily];

    return( g_fRtpFamilyFunc[dwFamily](pRtpControlStruct) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\msrtp\funcs\rtprand.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtprand.c
 *
 *  Abstract:
 *
 *    Random number generation using CAPI
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    2000/09/12 created
 *
 **********************************************************************/

#include "gtypes.h"
#include "rtpglobs.h"

#include <wincrypt.h>
#include <time.h>        /* clock() */

#include "rtprand.h"

HCRYPTPROV           g_hRtpRandCryptProvider = (HCRYPTPROV)0;

/*
 * WARNING

 * The call to RtpRandInit and RtpRandDeinit MUST be protected by a
 * critical section in the caller function */


HRESULT RtpRandInit(void)
{
    BOOL             bOk;
    DWORD            dwError;

    TraceFunctionName("RtpRandInit");

    if (!g_hRtpRandCryptProvider)
    {
        bOk = CryptAcquireContext(
                &g_hRtpRandCryptProvider,/* HCRYPTPROV *phProv */
                NULL,              /* LPCTSTR pszContainer */
                NULL,              /* LPCTSTR pszProvider */
                PROV_RSA_FULL,     /* DWORD dwProvType */
                CRYPT_VERIFYCONTEXT/* DWORD dwFlags */
            );
        
        if (!bOk)
        {
            g_hRtpRandCryptProvider = (HCRYPTPROV)0;
            
            TraceRetailGetError(dwError);

            TraceRetail((
                    CLASS_ERROR, GROUP_CRYPTO, S_CRYPTO_RAND,
                    _T("%s: CryptAcquireContext(PROV_RSA_FULL, ")
                    _T("CRYPT_VERIFYCONTEXT) failed: %u (0x%X)"),
                    _fname, dwError, dwError
                ));
        
            return(RTPERR_CRYPTO);
        }
    }

    return(NOERROR);
}

HRESULT RtpRandDeinit(void)
{
    if (g_hRtpRandCryptProvider)
    {
        CryptReleaseContext(g_hRtpRandCryptProvider, 0);

        g_hRtpRandCryptProvider = (HCRYPTPROV)0;
    }

    return(NOERROR);
}

/*
 * Return random unsigned 32-bit quantity. Use 'type' argument if you
 * need to generate several different values in close succession.
 */
DWORD RtpRandom32(DWORD_PTR type)
{
    BOOL             bOk;
    DWORD           *pdw;
    DWORD            i;
    DWORD            dwError;
    
    struct {
        DWORD_PTR       type;
        RtpTime_t       RtpTime;
        clock_t         cpu;
        DWORD           pid;
        LONGLONG        ms;
    } s;

    TraceFunctionName("RtpRandom32");

    s.type = type;
    RtpGetTimeOfDay(&s.RtpTime);
    s.cpu  = clock();
    s.pid  = GetCurrentProcessId();
    s.ms   = RtpGetTime();

    pdw = (DWORD *)&s;

    bOk = FALSE;
    
    if (g_hRtpRandCryptProvider)
    {
        bOk = CryptGenRandom(g_hRtpRandCryptProvider, sizeof(s), (char *)&s);
    }

    if (!bOk)
    {
        TraceRetailGetError(dwError);

        TraceRetail((
                CLASS_WARNING, GROUP_CRYPTO, S_CRYPTO_RAND,
                _T("%s: CryptGenRandom failed: %u (0x%X)"),
                _fname, dwError, dwError
            ));
        
        /* Generate a pseudo random number */
        srand((unsigned int)pdw[0]);
        
        for(i = 1; i < (sizeof(s)/sizeof(DWORD)); i++)
        {
            pdw[0] ^= (pdw[i] ^ rand());
        }
    }

    return(pdw[0]);
}

/* Generate dwLen bytes of random data */
DWORD RtpRandomData(char *pBuffer, DWORD dwLen)
{
    BOOL             bOk;
    DWORD           *pdw;
    DWORD            i;
    DWORD            dwLen2;
    DWORD            dwError;

    struct {
        RtpTime_t       RtpTime;
        clock_t         cpu;
        DWORD           pid;
        LONGLONG        ms;
    } s;

    TraceFunctionName("RtpRandomData");

    if (!pBuffer || !dwLen)
    {
        return(RTPERR_FAIL);
    }
        
    RtpGetTimeOfDay(&s.RtpTime);
    s.cpu  = clock();
    s.pid  = GetCurrentProcessId();
    s.ms   = RtpGetTime();

    dwLen2 = dwLen;

    if (dwLen2 > sizeof(s))
    {
        dwLen2 = sizeof(s);
    }

    CopyMemory(pBuffer, (char *)&s, dwLen2);
        
    bOk = FALSE;

    if (g_hRtpRandCryptProvider)
    {
        bOk = CryptGenRandom(g_hRtpRandCryptProvider, dwLen, pBuffer);
    }

    if (!bOk)
    {
        TraceRetailGetError(dwError);

        TraceRetail((
                CLASS_WARNING, GROUP_CRYPTO, S_CRYPTO_RAND,
                _T("%s: CryptGenRandom failed: %u (0x%X)"),
                _fname, dwError, dwError
            ));

        /* Generate pseudo random numbers */
        srand(*(unsigned int *)&s);

        pdw = (DWORD *)pBuffer;
        
        for(i = 0, dwLen2 = dwLen / sizeof(DWORD); i < dwLen2; i++)
        {
            pdw[i] ^= rand();
        }
    }

    return(NOERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\msrtp\funcs\rtpqos.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpqos.c
 *
 *  Abstract:
 *
 *    Implements the Quality Of Service family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/07 created
 *
 **********************************************************************/

#include "struct.h"
#include "rtpheap.h"
#include "rtpglobs.h"
#include "rtpque.h"
#include "lookup.h"
#include "rtpevent.h"
#include "rtpmisc.h"
#include "rtpreg.h"
#include "rtppt.h"

#include <winsock2.h>
#include <mmsystem.h> /* timeGetTime() */
#include <qos.h>
#include <qossp.h>
#include <qospol.h>
#include <stdio.h> /* sprintf() */

#include "rtpqos.h"

void RtpSetQosSendMode(RtpAddr_t *pRtpAddr, DWORD dwQosSendMode);

HRESULT RtpScaleFlowSpec(
        FLOWSPEC *pFlowSpec,
        DWORD     dwNumParticipants,
        DWORD     dwMaxParticipants,
        DWORD     dwBandwidth
    );

DWORD RtcpOnReceiveQosNotify(RtcpAddrDesc_t *pRtcpAddrDesc);

DWORD RtpValidateQosNotification(RtpQosNotify_t *pRtpQosNotify);

DWORD RtpSetMaxParticipants(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwMaxParticipants
    );

DWORD RtpAddDeleteSSRC(
        RtpAddr_t       *pRtpAddr,
        RtpQosReserve_t *pRtpQosReserve,
        DWORD            dwSSRC,
        BOOL             bAddDel
    );

BOOL RtpIsAllowedToSend(RtpAddr_t *pRtpAddr);

#if DBG > 0
void dumpFlowSpec(TCHAR_t *str, FLOWSPEC *pFlowSpec);
void dumpQOS(const TCHAR_t *msg, QOS *pQOS);
void dumpObjectType(const TCHAR_t *msg, char *ptr, unsigned int len);
#endif

HRESULT ControlRtpQos(RtpControlStruct_t *pRtpControlStruct)
{

    return(NOERROR);
}

DWORD AddQosAppID(
        IN OUT  char       *pAppIdBuf,
        IN      TCHAR_t    *psAppName,
        IN      TCHAR_t    *psAppGUID,
        IN      TCHAR_t    *psClass,
        IN      TCHAR_t    *psQosName,
        IN      TCHAR_t    *psPolicyLocator
    );

/* Qos App ID defaults */
const WCHAR *g_sAppGUID =
             L"www.microsoft.com";
const WCHAR *g_sPolicyLocator =
             L",SAPP=MICROSOFT REAL-TIME COMMUNICATIONS,VER=1.0,SAPP=";

const TCHAR_t *g_psRsvpStyle[] = {
    _T("DEFAULT"),
    _T("WF"),
    _T("FF"),
    _T("SE")
};

DWORD GetRegistryQosSetting(
        DWORD           *pEnabled,
        char            *pName,
        DWORD            NameLen,
        DWORD           *pdwDisableFlags,
        DWORD           *pdwEnableFlags
    );


#define RTP_HDR         12
#define RTP_UDP_IP_HDR  40

/**********************************************************************
 * Miscelaneous: QOS templates, registry
 **********************************************************************/

/*
 * The extra information is used when a frame size (in milliseconds)
 * is provided to RtpSetQosByName, to derive several flowspec
 * parameters to be closer to what is really needed, currently this
 * information is enabled ONLY for audio
  
      3                   2                   1                 
    1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |E| |Basic time | Basic frame |    PT       | eXtra 2 | eXtra 1 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    v v \----v----/ \-----v-----/ \-----v-----/ \---v---/ \---v---/
    | |      |            |             |           |         |
    | |      |            |             |           |         Extra1 (5)
    | |      |            |             |           |
    | |      |            |             |           Extra2 (5)
    | |      |            |             |
    | |      |            |             Payload type (7)
    | |      |            |
    | |      |            Basic Frame (7)
    | |      | 
    | |      Basic Time (6)
    | |
    | Reserved (1)
    |
    Enabled (1)

 */

#define QOS_EI(e, bt, bf, pt, x2, x1)  \
        (((e  & 0x01) << 31) | \
         ((bt & 0x3f) << 24) | \
         ((bf & 0x7f) << 17) | \
         ((pt & 0x7f) << 10) | \
         ((x2 & 0x1f) <<  5) | \
         ((x1 & 0x1f)))


#define QOS_USEINFO(_pQosInfo)    \
        (((_pQosInfo)->dwQosExtraInfo >> 31) & 0x01)

#define QOS_BASICTIME(_pQosInfo)  \
        (((_pQosInfo)->dwQosExtraInfo >> 24) & 0x3f)  /* in millisecs */

#define QOS_BASICFRAME(_pQosInfo) \
        (((_pQosInfo)->dwQosExtraInfo >> 17) & 0x7f)  /* in bytes */

#define QOS_PT(_pQosInfo) \
        (((_pQosInfo)->dwQosExtraInfo >> 10) & 0x7f)

#define QOS_EXTRA2(_pQosInfo)   \
        (((_pQosInfo)->dwQosExtraInfo >> 5) & 0x1f)

#define QOS_EXTRA1(_pQosInfo)   \
        (((_pQosInfo)->dwQosExtraInfo) & 0x1f)

#define QOS_ADD_MIN(_pQosInfo) QOS_EXTRA1(_pQosInfo)
#define QOS_ADD_MAX(_pQosInfo) QOS_EXTRA2(_pQosInfo)

#if 0
typedef struct _flowspec {
    /* Flowspec */
    ULONG            TokenRate;              /* In Bytes/sec */
    ULONG            TokenBucketSize;        /* In Bytes */
    ULONG            PeakBandwidth;          /* In Bytes/sec */
    ULONG            Latency;                /* In microseconds */
    ULONG            DelayVariation;         /* In microseconds */
    SERVICETYPE      ServiceType;
    ULONG            MaxSduSize;             /* In Bytes */
    ULONG            MinimumPolicedSize;     /* In Bytes */
} FLOWSPEC;
#endif

/* NOTE TokenRate is computed as 103% of the nominal byterate
 * including RTP/UP/IP headers. The TokenBucketSize is computed to be
 * enough big to hold 6 packets while using the maximum number of
 * frames a packet may have (MaxSduSize) also including RTP/UDP/IP
 * headers */
const QosInfo_t g_QosInfo[] = {
    {
        RTPQOSNAME_G711,
        QOS_EI(1, 1, 8, RTPPT_PCMU, 0, 0),
        {
            10000,         /* Assume 20ms */
            (80*9+RTP_UDP_IP_HDR)*6,
            10000*17/10,
            QOS_NOT_SPECIFIED,
            QOS_NOT_SPECIFIED,
            SERVICETYPE_GUARANTEED,
            80*10+RTP_HDR, /* 100 ms */
            80*2+RTP_HDR   /* 20 ms */
        }
    },
    {
        RTPQOSNAME_G711,
        QOS_EI(1, 1, 8, RTPPT_PCMA, 0, 0),
        {
            10000,         /* Assume 20ms */
            (80*9+RTP_UDP_IP_HDR)*6,
            10000*17/10,
            QOS_NOT_SPECIFIED,
            QOS_NOT_SPECIFIED,
            SERVICETYPE_GUARANTEED,
            80*10+RTP_HDR, /* 100 ms */
            80*2+RTP_HDR   /* 20 ms */
        }
    },
    {
        RTPQOSNAME_G723_1,
        QOS_EI(1, 30, 20, RTPPT_G723, 4, 0),
        {
            2198,          /* Assume 30ms */
            (24*3+RTP_UDP_IP_HDR)*6,
            2198*17/10,
            QOS_NOT_SPECIFIED,
            QOS_NOT_SPECIFIED,
            SERVICETYPE_GUARANTEED,
            24*3+RTP_HDR,  /* 90 ms */
            20+RTP_HDR     /* 30 ms */
        }
    },
    {
        RTPQOSNAME_GSM6_10,
        QOS_EI(1, 40, 66, RTPPT_GSM, 1, 0),
        {
            2729,          /* Assume 40ms */
            (66*3+RTP_UDP_IP_HDR)*6,
            2729*17/10,
            QOS_NOT_SPECIFIED,
            QOS_NOT_SPECIFIED,
            SERVICETYPE_GUARANTEED,
            66*3+RTP_HDR,  /* 120 ms */
            65+RTP_HDR     /* 40 ms */
        }
    },
    {
        RTPQOSNAME_DVI4_8,
        QOS_EI(1, 10, 40, RTPPT_DVI4_8000, 4, 4),
        {
            6386,          /* Assume 20ms */
            (40*9+RTP_UDP_IP_HDR)*6,
            6386*17/10,
            QOS_NOT_SPECIFIED,
            QOS_NOT_SPECIFIED,
            SERVICETYPE_GUARANTEED,
            40*10+4+RTP_HDR,/* 100 ms */
            40*1+RTP_HDR    /* 10 ms */
        }
    },
    {
        RTPQOSNAME_DVI4_16,
        QOS_EI(1, 10, 80, RTPPT_DVI4_16000, 4, 4),
        {
            10506,         /* Assume 20ms */
            (80*9+RTP_UDP_IP_HDR)*6,
            10506*17/10,
            QOS_NOT_SPECIFIED,
            QOS_NOT_SPECIFIED,
            SERVICETYPE_GUARANTEED,
            80*10+4+RTP_HDR,/* 100 ms */
            80*2+RTP_HDR    /* 20 ms */
        }
    },
    {
        RTPQOSNAME_SIREN,
        QOS_EI(1, 20, 40, 111, 0, 0),
        {
            4120,          /* Assume 20ms */
            (40*5+RTP_UDP_IP_HDR)*6,
            4120*17/10,
            QOS_NOT_SPECIFIED,
            QOS_NOT_SPECIFIED,
            SERVICETYPE_GUARANTEED,
            40*5+RTP_HDR,  /* 100 ms */
            40*1+RTP_HDR   /* 20 ms */
        }
    },
    {
        RTPQOSNAME_G722_1,
        QOS_EI(1, 20, 60, 112, 0, 0),
        {
            5150,          /* Assume 20ms */
            (60*5+RTP_UDP_IP_HDR)*6,
            5150*17/10,
            QOS_NOT_SPECIFIED,
            QOS_NOT_SPECIFIED,
            SERVICETYPE_GUARANTEED,
            60*5+RTP_HDR,  /* 100 ms */
            60+RTP_HDR     /* 20 ms */
        }
    },
    {
        RTPQOSNAME_MSAUDIO,
        QOS_EI(1, 32, 64, 113, 0, 0),
        {
            3348,          /* Assume 32ms */
            (64*3+RTP_UDP_IP_HDR)*6,
            3348*17/10,
            QOS_NOT_SPECIFIED,
            QOS_NOT_SPECIFIED,
            SERVICETYPE_GUARANTEED,
            64*3+RTP_HDR,  /* 96 ms */
            64*1+RTP_HDR   /* 32 ms */
        }
    },
    {
        RTPQOSNAME_H263QCIF,
        QOS_EI(0, 0, 0, RTPPT_H263, 0, 0),
        {
            16000,
            1500*4,
            QOS_NOT_SPECIFIED,
            QOS_NOT_SPECIFIED,
            QOS_NOT_SPECIFIED,
            SERVICETYPE_CONTROLLEDLOAD,
            1500,
            64
        }
    },
    {
        RTPQOSNAME_H263CIF,
        QOS_EI(0, 0, 0, RTPPT_H263, 0, 0),
        {
            32000,
            1500*4,
            QOS_NOT_SPECIFIED,
            QOS_NOT_SPECIFIED,
            QOS_NOT_SPECIFIED,
            SERVICETYPE_CONTROLLEDLOAD,
            1500,
            64
        }
    },
    {
        RTPQOSNAME_H261QCIF,
        QOS_EI(0, 0, 0, RTPPT_H261, 0, 0),
        {
            16000,
            1500*4,
            QOS_NOT_SPECIFIED,
            QOS_NOT_SPECIFIED,
            QOS_NOT_SPECIFIED,
            SERVICETYPE_CONTROLLEDLOAD,
            1500,
            64
        }
    },
    {
        RTPQOSNAME_H261CIF,
        QOS_EI(0, 0, 0, RTPPT_H261, 0, 0),
        {
            32000,
            1500*4,
            QOS_NOT_SPECIFIED,
            QOS_NOT_SPECIFIED,
            QOS_NOT_SPECIFIED,
            SERVICETYPE_CONTROLLEDLOAD,
            1500,
            64
        }
    }
};

#define QOS_NAMES (sizeof(g_QosInfo)/sizeof(g_QosInfo[0]))

const QosInfo_t *RtpGetQosInfoByName(
        TCHAR_t         *psQosName
    )
{
    DWORD            i;
    const QosInfo_t *pQosInfo;
    
    for(i = 0, pQosInfo = (QosInfo_t *)NULL; i < QOS_NAMES; i++)
    {
        if (!lstrcmp(psQosName, g_QosInfo[i].pName))
        {
            pQosInfo = &g_QosInfo[i];
            
            break;
        }
    }

    return(pQosInfo);
}

const QosInfo_t *RtpGetQosInfoByPT(
        DWORD           dwPT
    )
{
    DWORD            i;
    const QosInfo_t *pQosInfo;
    
    for(i = 0, pQosInfo = (QosInfo_t *)NULL; i < QOS_NAMES; i++)
    {
        if (dwPT == QOS_PT(&g_QosInfo[i]))
        {
            pQosInfo = &g_QosInfo[i];
            
            break;
        }
    }

    return(pQosInfo);
}


/**********************************************************************
 * QOS reservations
 **********************************************************************/

/* NOTE assumes that redundancy is added as a duplicate of the main
 * data, and only one redundancy */
void RtpAdjustQosFlowSpec(
        FLOWSPEC        *pFlowSpec,
        const QosInfo_t *pQosInfo,
        DWORD            dwFrameSize, /* in milliseconds */
        BOOL             bUseRed
    )
{
    DWORD            dwFrameSizeBytes;
    DWORD            dwMaxSduSize;
    DWORD            dwMinimumPolicedSize;
#if DBG > 0
    TCHAR_t          str[256];
#endif
    
    TraceFunctionName("RtpAdjustQosFlowSpec");
    
    dwFrameSizeBytes =
        (dwFrameSize / QOS_BASICTIME(pQosInfo)) * QOS_BASICFRAME(pQosInfo);

    if (bUseRed)
    {
        dwFrameSizeBytes = (dwFrameSizeBytes * 2) + sizeof(RtpRedHdr_t) + 1;
    }

    /* TokenRate uses the RTP, UDP, IP headers and adds 3% to the
     * estimated value */
    pFlowSpec->TokenRate =
        dwFrameSizeBytes + QOS_ADD_MAX(pQosInfo) + RTP_UDP_IP_HDR;

    pFlowSpec->TokenRate =
        ((pFlowSpec->TokenRate * 1000 / dwFrameSize) * 103) / 100;

    /* TokenBucketSize uses the RTP, UDP, IP headers and gives a
     * tolerance of 6 times the computed amount */
    pFlowSpec->TokenBucketSize =
        (dwFrameSizeBytes + QOS_ADD_MAX(pQosInfo) + RTP_UDP_IP_HDR) * 6;

    /* PeakBandwidth is estimated as 17/10 of the TokenRate */
    pFlowSpec->PeakBandwidth = (pFlowSpec->TokenRate * 17) / 10;

    /* MaxSduSize uses the second extra data, and gives a tolerance of
     * 2 times the computed amount */
    dwMaxSduSize =
        ((dwFrameSizeBytes + QOS_ADD_MAX(pQosInfo)) * 2) + RTP_HDR;

    /* MinimumPolicedSize uses the first extra data */
    dwMinimumPolicedSize =
        dwFrameSizeBytes + QOS_ADD_MIN(pQosInfo) + RTP_HDR;

#if 0
    pFlowSpec->MaxSduSize = dwMaxSduSize;

    pFlowSpec->MinimumPolicedSize = dwMinimumPolicedSize;
#else
    /* Use always the maximum value for MaxSduSize, and the minimum
     * value for MinimumPolicedSize */
    if (dwMaxSduSize > pFlowSpec->MaxSduSize)
    {
        pFlowSpec->MaxSduSize = dwMaxSduSize;
    }

    if (dwMinimumPolicedSize < pFlowSpec->MinimumPolicedSize)
    {
        pFlowSpec->MinimumPolicedSize = dwMinimumPolicedSize;
    }
#endif

#if DBG > 0
    dumpFlowSpec(str, pFlowSpec);

    TraceDebug((
            CLASS_INFO, GROUP_QOS, S_QOS_RESERVE,
            _T("%s: flowspec(%s)"),
            _fname, str
        ));
#endif
}

DWORD RtpSetQosFlowSpec(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwRecvSend
    )
{
    DWORD            dwFrameSize;
    DWORD            dwFrameSizeBytes;
    BOOL             bUseRed;
    FLOWSPEC        *pFlowSpec;
    const QosInfo_t *pQosInfo;
    RtpQosReserve_t *pRtpQosReserve;

    bUseRed = FALSE;
    
    pRtpQosReserve = pRtpAddr->pRtpQosReserve;
    
    if (dwRecvSend == RECV_IDX)
    {
        dwFrameSize = pRtpQosReserve->dwFrameSizeMS[RECV_IDX];

        pFlowSpec = &pRtpQosReserve->qos.ReceivingFlowspec;

        pQosInfo = pRtpQosReserve->pQosInfo[RECV_IDX];

        if (RtpBitTest(pRtpAddr->dwAddrFlagsR, FGADDRR_QOSREDRECV))
        {
            bUseRed = TRUE;
        }
    }
    else
    {
        dwFrameSize = pRtpQosReserve->dwFrameSizeMS[SEND_IDX];

        pFlowSpec = &pRtpQosReserve->qos.SendingFlowspec;

        pQosInfo = pRtpQosReserve->pQosInfo[SEND_IDX];

        if (RtpBitTest(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSREDSENDON))
        {
            bUseRed = TRUE;
        }

        /* Save the basic frame information if available */
        if (dwFrameSize && pRtpAddr->RtpNetSState.dwSendSamplingFreq)
        {
            pRtpAddr->RtpNetSState.dwSendSamplesPerPacket =
                pRtpAddr->RtpNetSState.dwSendSamplingFreq * dwFrameSize /
                1000;
        }
    }

    /* Copy basic flowspec */
    CopyMemory(pFlowSpec, &pQosInfo->FlowSpec, sizeof(FLOWSPEC));

    if (dwFrameSize && QOS_USEINFO(pQosInfo))
    {
        /* Adjust the flowspec only if we have a value for the frame
         * size, and the QOS info is valid */
        RtpAdjustQosFlowSpec(pFlowSpec, pQosInfo, dwFrameSize, bUseRed);
    }

    return(NOERROR);
}

/* Select a QOS template (flowspec) by passing its name in psQosName,
 * dwResvStyle specifies the RSVP style (e.g RTPQOS_STYLE_WF,
 * RTPQOS_STYLE_FF), dwMaxParticipants specifies the max number of
 * participants (1 for unicast, N for multicast), this number is used
 * to scale up the flowspec. dwQosSendMode specifies the send mode
 * (has to do with allowed/not allowed to send)
 * (e.g. RTPQOSSENDMODE_UNRESTRICTED,
 * RTPQOSSENDMODE_RESTRICTED1). dwFrameSize is the frame size (in ms),
 * used to derive several flowspec parameters, 0 makes this parameter
 * be ignored. bInternal indicates if this function was called
 * internally or from the API.
 * */
HRESULT RtpSetQosByNameOrPT(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwRecvSend,
        TCHAR_t         *psQosName,
        DWORD            dwPT,
        DWORD            dwResvStyle,
        DWORD            dwMaxParticipants,
        DWORD            dwQosSendMode,
        DWORD            dwFrameSize,
        BOOL             bInternal
    )
{
    HRESULT          hr;
    DWORD            i;
    DWORD            dwQosOnFlag;
    QOS             *pqos;
    RtpQosReserve_t *pRtpQosReserve;
    const QosInfo_t *pQosInfo;
    
    TraceFunctionName("RtpSetQosByNameOrPT");

    if (!pRtpAddr)
    {
        /* Having this as a NULL pointer means Init hasn't been
         * called, return this error instead of RTPERR_POINTER to be
         * consistent */
        hr = RTPERR_NOTINIT;
        goto end;
    }

    if (!psQosName && !IsDWValueSet(dwPT))
    {
        hr = RTPERR_INVALIDARG;
        goto end;
    }

    /* verify object ID in RtpAddr_t */
    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QOS, S_QOS_PROVIDER,
                _T("%s: pRtpAddr[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpAddr,
                pRtpAddr->dwObjectID, OBJECTID_RTPADDR
            ));

        return(RTPERR_INVALIDRTPADDR);
    }

    if (!RtpBitTest(pRtpAddr->dwIRtpFlags, FGADDR_IRTP_QOS))
    {
        /* Report error if this is not a QOS enabled session */
        hr = RTPERR_INVALIDSTATE;
        goto end;
    }
    
    if (psQosName && !lstrlen(psQosName))
    {
        hr = RTPERR_INVALIDARG;
        goto end;
    }

    pRtpQosReserve = pRtpAddr->pRtpQosReserve;
    
    if (!pRtpQosReserve)
    {
        hr = RTPERR_NOQOS;
        goto end;
    }

    if ( IsDWValueSet(dwResvStyle) && (dwResvStyle >= RTPQOS_STYLE_LAST) )
    {
        return(RTPERR_INVALIDARG);
    }

    if (dwRecvSend == SEND_IDX)
    {
        if ( IsDWValueSet(dwQosSendMode) &&
             (!dwQosSendMode || dwQosSendMode >= RTPQOSSENDMODE_LAST) )
        {
            hr = RTPERR_INVALIDARG;
            goto end;
       }
    }

    if (IsDWValueSet(dwResvStyle))
    {
        pRtpQosReserve->dwStyle = dwResvStyle;
    }
    else
    {
        dwResvStyle = pRtpQosReserve->dwStyle;
    }

    if (IsDWValueSet(dwMaxParticipants) && dwMaxParticipants)
    {
        RtpSetMaxParticipants(pRtpAddr, dwMaxParticipants);
    }

    /* Lookup flowspec to use */
    if (psQosName)
    {
        pQosInfo = RtpGetQosInfoByName(psQosName);
    }
    else
    {
        pQosInfo = RtpGetQosInfoByPT(dwPT);
        psQosName = _T("NONE");
    }
    
    TraceRetail((
            CLASS_INFO, GROUP_QOS, S_QOS_PROVIDER,
            _T("%s: pRtpAddr[0x%p] %s QOS Name:%s PT:%d Style:%s ")
            _T("Max:%d SendMode:%d FrameSize:%d ms"),
            _fname, pRtpAddr,
            RTPRECVSENDSTR(dwRecvSend),
            psQosName, dwPT, g_psRsvpStyle[dwResvStyle],
            dwMaxParticipants,
            dwQosSendMode,
            dwFrameSize
        ));

    if (!pQosInfo)
    {
        hr = RTPERR_INVALIDARG;
    }
    else
    {
        hr = NOERROR;

        dwRecvSend &= RECVSENDMASK;
        
        pqos = &pRtpQosReserve->qos;

        /* Set the flowspec to use */
        if (dwRecvSend == RECV_IDX)
        {
            /* Receiver */

            pRtpQosReserve->pQosInfo[RECV_IDX] = pQosInfo;

            /* Ignore the frame size, will be computed while receiving
             * packets */

            if (!bInternal)
            {
                /* If internal, the flowspec will be set when the time
                 * comes to redo the reservation, i.e. when the frame
                 * size was computed again, otherwise update now, as
                 * the reservation will be done by the end of this
                 * function */
                RtpSetQosFlowSpec(pRtpAddr, RECV_IDX);
            }
            
            RtpBitSet(pRtpAddr->dwAddrFlagsQ, FGADDRQ_RECVFSPEC_DEFINED);

            dwQosOnFlag = FGADDR_QOSRECVON;
        }
        else
        {
            /* Sender */
            
            pRtpQosReserve->pQosInfo[SEND_IDX] = pQosInfo;

            if (IsDWValueSet(dwFrameSize) && dwFrameSize)
            {
                pRtpQosReserve->dwFrameSizeMS[SEND_IDX] = dwFrameSize;
            }

            /* Set the QOS send mode */
            if (IsDWValueSet(dwFrameSize))
            {
                RtpSetQosSendMode(pRtpAddr, dwQosSendMode);
            }

            /* Currently this function is not called internally for
             * SEND, only via API, so I don't need to do the same test
             * as for RECV */
            RtpSetQosFlowSpec(pRtpAddr, SEND_IDX);
            
            RtpBitSet(pRtpAddr->dwAddrFlagsQ, FGADDRQ_SENDFSPEC_DEFINED);

            dwQosOnFlag = FGADDR_QOSSENDON;
        }
        
        TraceRetail((
                CLASS_INFO, GROUP_QOS, S_QOS_PROVIDER,
                _T("%s: pRtpAddr[0x%p] %s QOS Name:%s PT:%d Style:%s ")
                _T("Max:%d FrameSize:%d ms"),
                _fname, pRtpAddr,
                RTPRECVSENDSTR(dwRecvSend),
                pRtpQosReserve->pQosInfo[dwRecvSend]->pName,
                QOS_PT(pRtpQosReserve->pQosInfo[dwRecvSend]),
                g_psRsvpStyle[pRtpQosReserve->dwStyle],
                pRtpQosReserve->dwMaxFilters,
                pRtpQosReserve->dwFrameSizeMS[dwRecvSend]
            ));

        /* Now direct the RTCP thread to issue a reservation if this
         * was called from the API and the session has been started
         * and QOS is ON */
        if (!bInternal && RtpBitTest(pRtpAddr->dwAddrFlags, dwQosOnFlag))
        {
            RtcpThreadCmd(&g_RtcpContext,
                          pRtpAddr,
                          RTCPTHRD_RESERVE,
                          dwRecvSend,
                          DO_NOT_WAIT);
        }
    }

 end:
    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QOS, S_QOS_PROVIDER,
                _T("%s: pRtpAddr[0x%p] failed: %s (0x%X)"),
                _fname, pRtpAddr, RTPERR_TEXT(hr), hr
            ));
    }
    
    return(hr);
}

void RtpSetQosSendMode(RtpAddr_t *pRtpAddr, DWORD dwQosSendMode)
{
    switch(dwQosSendMode)
    {
    case RTPQOSSENDMODE_UNRESTRICTED:
        /* Send no matter what */
        RtpBitReset(pRtpAddr->dwAddrFlagsQ, FGADDRQ_CHKQOSSEND);
        RtpBitSet  (pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSUNCONDSEND);
        RtpBitReset(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSCONDSEND);
        break;
    case RTPQOSSENDMODE_REDUCED_RATE:
        /* Ask permission to send, if denied, keep sending at a
         * reduced rate */
        RtpBitSet  (pRtpAddr->dwAddrFlagsQ, FGADDRQ_CHKQOSSEND);
        RtpBitReset(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSUNCONDSEND);
        RtpBitSet  (pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSCONDSEND);
        break;
    case RTPQOSSENDMODE_DONT_SEND:
        /* Ask permission to send, if denied, DON'T SEND at all */
        RtpBitSet  (pRtpAddr->dwAddrFlagsQ, FGADDRQ_CHKQOSSEND);
        RtpBitReset(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSUNCONDSEND);
        RtpBitReset(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSCONDSEND);
        break;
    case RTPQOSSENDMODE_ASK_BUT_SEND:
        /* Ask permission to send, send at normal rate no matter what,
         * the application is supposed to stop passing data to RTP or
         * to pass the very minimum (this is the mode that should be
         * used) */
        RtpBitSet  (pRtpAddr->dwAddrFlagsQ, FGADDRQ_CHKQOSSEND);
        RtpBitSet  (pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSUNCONDSEND);
        RtpBitReset(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSCONDSEND);
        break;
    }
}
 
/* Not implemented yet, will have same functionality as
 * SetQosByName, except that instead of passing a name to use a
 * predefined flowspec, the caller will pass enough information in
 * the RtpQosSpec structure to obtain the customized flowspec to
 * use */
HRESULT RtpSetQosParameters(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwRecvSend,
        RtpQosSpec_t    *pRtpQosSpec,
        DWORD            dwMaxParticipants,
        DWORD            dwQosSendMode
    )
{
    return(RTPERR_NOTIMPL);
}

/* If AppName is specified, it will replace the default AppName with
 * the new UNICODE string. If psPolicyLocator is specified, it will be
 * appended to the base policy locator */
HRESULT RtpSetQosAppId(
        RtpAddr_t   *pRtpAddr,
        WCHAR       *psAppName,
        WCHAR       *psAppGUID,
        WCHAR       *psPolicyLocator
    )
{
    int              len;
    RtpQosReserve_t *pRtpQosReserve;

    TraceFunctionName("RtpSetQosAppId");

    if (!pRtpAddr)
    {
        /* Having this as a NULL pointer means Init hasn't been
         * called, return this error instead of RTPERR_POINTER to be
         * consistent */
        return(RTPERR_INVALIDSTATE);
    }

    /* verify object ID in RtpAddr_t */
    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QOS, S_QOS_PROVIDER,
                _T("%s: pRtpAddr[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpAddr,
                pRtpAddr->dwObjectID, OBJECTID_RTPADDR
            ));

        return(RTPERR_INVALIDRTPADDR);
    }

    if (!psAppName && !psAppGUID && !psPolicyLocator)
    {
        return(RTPERR_POINTER);
    }

    pRtpQosReserve = pRtpAddr->pRtpQosReserve;
    
    if (!pRtpQosReserve)
    {
        return(RTPERR_INVALIDSTATE);
    }

    /* Application name */
    if (pRtpQosReserve->psAppName)
    {
        RtpHeapFree(g_pRtpQosBufferHeap, pRtpQosReserve->psAppName);

        pRtpQosReserve->psAppName = NULL;
    }
    
    if (psAppName)
    {
        len = lstrlen(psAppName);

        if (len <= 0)
        {
            return(RTPERR_INVALIDARG);
        }

        if (len > MAX_QOS_APPID)
        {
            return(RTPERR_SIZE);
        }
        
        /* Acount for the NULL terminating character */
        len += 1;

        pRtpQosReserve->psAppName =
            RtpHeapAlloc(g_pRtpQosBufferHeap, len * sizeof(TCHAR_t));
    
        if (!pRtpQosReserve->psAppName)
        {
            return(RTPERR_MEMORY);
        }

        lstrcpy(pRtpQosReserve->psAppName, psAppName);
    }

    /* Application GUID */
    if (pRtpQosReserve->psAppGUID)
    {
        RtpHeapFree(g_pRtpQosBufferHeap, pRtpQosReserve->psAppGUID);

        pRtpQosReserve->psAppGUID = NULL;
    }

    if (psAppGUID)
    {
        len = lstrlen(psAppGUID);

        if (len <= 0)
        {
            return(RTPERR_INVALIDARG);
        }

        if (len > MAX_QOS_APPID)
        {
            return(RTPERR_SIZE);
        }
        
        /* Acount for the NULL terminating character */
        len += 1;

        pRtpQosReserve->psAppGUID =
            RtpHeapAlloc(g_pRtpQosBufferHeap, len * sizeof(TCHAR_t));
    
        if (!pRtpQosReserve->psAppGUID)
        {
            return(RTPERR_MEMORY);
        }

        lstrcpy(pRtpQosReserve->psAppGUID, psAppGUID);
    }
    
    /* Policy locator */
    if (pRtpQosReserve->psPolicyLocator)
    {
        /* Release previous buffer */
        RtpHeapFree(g_pRtpQosBufferHeap, pRtpQosReserve->psPolicyLocator);

        pRtpQosReserve->psPolicyLocator = NULL;
    }
    
    if (psPolicyLocator)
    {
        len = lstrlen(psPolicyLocator);
        
        if (len <= 0)
        {
            return(RTPERR_INVALIDARG);
        }

        if (len > MAX_QOS_POLICY)
        {
            return(RTPERR_SIZE);
        }
        
        /* Account for the NULL terminating character */
        len += 1;

        /* Find out the size for the default part (base + ',' + qos
           name + ',') */
        len +=
            lstrlen(g_sPolicyLocator) +
            lstrlen(_T(",SAPP=")) + MAX_QOS_NAME +
            1;
        
        pRtpQosReserve->psPolicyLocator =
            RtpHeapAlloc(g_pRtpQosBufferHeap, len * sizeof(TCHAR_t));

        if (!pRtpQosReserve->psPolicyLocator)
        {
            return(RTPERR_MEMORY);
        }

        /* Copy policy */
        lstrcpy((TCHAR *)pRtpQosReserve->psPolicyLocator, psPolicyLocator);
    }

    return(NOERROR);
}

/* Adds/removes a single SSRC to/from the shared explicit list of
 * participants who receive reservation (i.e. it is used when the
 * ResvStyle=RTPQOS_STYLE_SE). */
HRESULT RtpSetQosState(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwSSRC,
        BOOL             bEnable
    )
{
    HRESULT          hr;
    DWORD            dwNumber;
    DWORD            dwOperation;

    dwNumber = 1;

    if (bEnable)
    {
        dwOperation = RtpBitPar2(RTPQOS_QOSLIST_ENABLE, RTPQOS_QOSLIST_ADD);
    }
    else
    {
        dwOperation = RtpBitPar(RTPQOS_QOSLIST_ENABLE);
    }

    hr = RtpModifyQosList(pRtpAddr, &dwSSRC, &dwNumber, dwOperation);
    
    return(hr);
}

/* Adds/removes a number of SSRCs to/from the shared explicit list
 * of participants who receive reservation (i.e. it is used when
 * the ResvStyle=RTPQOS_STYLE_SE). dwNumber is the number of SSRCs
 * to add/remove, and returns the actual number of SSRCs
 * added/removed */
HRESULT RtpModifyQosList(
        RtpAddr_t       *pRtpAddr,
        DWORD           *pdwSSRC,
        DWORD           *pdwNumber,
        DWORD            dwOperation
    )
{
    HRESULT          hr;
    DWORD            dwNumber;
    DWORD            i;
    BOOL             bAddDel;
    RtpQosReserve_t *pRtpQosReserve;
    
    TraceFunctionName("RtpModifyQosList");

    if (!pRtpAddr)
    {
        /* Having this as a NULL pointer means Init hasn't been
         * called, return this error instead of RTPERR_POINTER to be
         * consistent */
        hr = RTPERR_INVALIDSTATE;

        goto bail;
    }

    if (!pdwNumber)
    {
        hr = RTPERR_POINTER;

        goto bail;
    }
    
    /* verify object ID in RtpAddr_t */
    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QOS, S_QOS_LIST,
                _T("%s: pRtpAddr[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpAddr,
                pRtpAddr->dwObjectID, OBJECTID_RTPADDR
            ));

        hr = RTPERR_INVALIDRTPADDR;

        goto bail;
    }

    if (RtpBitTest2(pRtpAddr->dwAddrFlagsQ,
                    FGADDRQ_REGQOSDISABLE, FGADDRQ_QOSNOTALLOWED))
    {
        /* If QOS is forced disabled in the registry, or was disabled
         * because the user doesn't have the right to start RSVP do
         * nothing but succeed the call */
        hr = NOERROR;

        goto bail;
    }
    
    if (!RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_QOSRECVON))
    {
        hr = RTPERR_NOQOS;
        
        goto bail;
    }

    pRtpQosReserve = pRtpAddr->pRtpQosReserve;

    if (!pRtpQosReserve)
    {
        hr = RTPERR_INVALIDSTATE;

        goto bail;
    }

    if (pRtpQosReserve->dwStyle != RTPQOS_STYLE_SE)
    {
        hr = RTPERR_INVALIDSTATE;

        goto bail;
    }
    
    hr = NOERROR;
    
    if (RtpBitTest(dwOperation, RTPQOS_QOSLIST_FLUSH))
    {
        /* Empty the current list */
        pRtpQosReserve->dwNumFilters = 0;
    }

    if (RtpBitTest(dwOperation, RTPQOS_QOSLIST_ENABLE))
    {
        /* Add or Delete SSRCs */
        bAddDel = RtpBitTest(dwOperation, RTPQOS_QOSLIST_ADD)? 1:0;
        dwNumber = *pdwNumber;
        *pdwNumber = 0;
        
        for(i = 0; i < dwNumber; i++)
        {
            /* SSRCs ire handled in NETWORK order */
            *pdwNumber += RtpAddDeleteSSRC(pRtpAddr,
                                           pRtpQosReserve,
                                           pdwSSRC[i],
                                           bAddDel);
        }

        if (*pdwNumber == 0)
        {
            hr = RTPERR_QOS;
        }
        else
        {
            RtcpThreadCmd(&g_RtcpContext,
                          pRtpAddr,
                          RTCPTHRD_RESERVE,
                          RECV_IDX,
                          DO_NOT_WAIT);
        }
    }
    
 bail:
    return(hr);
}

/* Initialize to not specified a flowspec */
void InitializeFlowSpec(
        FLOWSPEC        *pFlowSpec,
        SERVICETYPE      ServiceType
	)
{
    pFlowSpec->TokenRate          = QOS_NOT_SPECIFIED;
    pFlowSpec->TokenBucketSize    = QOS_NOT_SPECIFIED;
    pFlowSpec->PeakBandwidth      = QOS_NOT_SPECIFIED;
    pFlowSpec->Latency            = QOS_NOT_SPECIFIED;
    pFlowSpec->DelayVariation     = QOS_NOT_SPECIFIED;
    pFlowSpec->ServiceType        = ServiceType;
    pFlowSpec->MaxSduSize         = QOS_NOT_SPECIFIED;
    pFlowSpec->MinimumPolicedSize = QOS_NOT_SPECIFIED;
}

/* Allocates a RtpQosReserve_t structure */
RtpQosReserve_t *RtpQosReserveAlloc(
        RtpAddr_t       *pRtpAddr
    )
{
    RtpQosReserve_t *pRtpQosReserve;
    
    pRtpQosReserve = (RtpQosReserve_t *)
        RtpHeapAlloc(g_pRtpQosReserveHeap, sizeof(RtpQosReserve_t));

    if (!pRtpQosReserve)
    {
        /* TODO log error */
        return((RtpQosReserve_t *)NULL);
    }

    ZeroMemory(pRtpQosReserve, sizeof(RtpQosReserve_t));
    
    pRtpQosReserve->dwObjectID = OBJECTID_RTPRESERVE;

    pRtpQosReserve->pRtpAddr = pRtpAddr;
    
    InitializeFlowSpec(&pRtpQosReserve->qos.ReceivingFlowspec,
                       SERVICETYPE_NOTRAFFIC);
    
    InitializeFlowSpec(&pRtpQosReserve->qos.SendingFlowspec,
                       SERVICETYPE_NOTRAFFIC);

    pRtpQosReserve->dwMaxFilters = 1;

    return(pRtpQosReserve);
}

/* Frees a RtpQosReserve_t structure */
RtpQosReserve_t *RtpQosReserveFree(RtpQosReserve_t *pRtpQosReserve)
{
    TraceFunctionName("RtpQosReserveFree");

    if (!pRtpQosReserve)
    {
        return(pRtpQosReserve);
    }
    
    if (pRtpQosReserve->dwObjectID != OBJECTID_RTPRESERVE)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QOS, S_QOS_RESERVE,
                _T("%s: pRtpQosReserve[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpQosReserve,
                pRtpQosReserve->dwObjectID, OBJECTID_RTPRESERVE
            ));

        return(NULL);
    }

    if (pRtpQosReserve->psAppName)
    {
        RtpHeapFree(g_pRtpQosBufferHeap, pRtpQosReserve->psAppName);
        pRtpQosReserve->psAppName = NULL;
    }

    if (pRtpQosReserve->psAppGUID)
    {
        RtpHeapFree(g_pRtpQosBufferHeap, pRtpQosReserve->psAppGUID);
        pRtpQosReserve->psAppGUID = NULL;
    }

    if (pRtpQosReserve->psPolicyLocator)
    {
        RtpHeapFree(g_pRtpQosBufferHeap, pRtpQosReserve->psPolicyLocator);
        pRtpQosReserve->psPolicyLocator = NULL;
    }

    if (pRtpQosReserve->pdwRsvpSSRC)
    {
        RtpHeapFree(g_pRtpQosReserveHeap, pRtpQosReserve->pdwRsvpSSRC);

        pRtpQosReserve->pdwRsvpSSRC = NULL;
    }

    if (pRtpQosReserve->pRsvpFilterSpec)
    {
        RtpHeapFree(g_pRtpQosReserveHeap, pRtpQosReserve->pRsvpFilterSpec);

        pRtpQosReserve->pRsvpFilterSpec = NULL;
    }
    
    /* Invalidate object */
    INVALIDATE_OBJECTID(pRtpQosReserve->dwObjectID);
    
    RtpHeapFree(g_pRtpQosReserveHeap, pRtpQosReserve);

    return(pRtpQosReserve);
}

/* Find the protocol info for a QOS enabled protocol */
HRESULT RtpGetQosEnabledProtocol(WSAPROTOCOL_INFO *pProtoInfo)
{
    HRESULT          hr;
    DWORD            dwSize;
    DWORD            dwError;
    DWORD            dwStatus;
    DWORD            dwIndex;
    int              Protocols[2];
    WSAPROTOCOL_INFO *pAllProtoInfo;

    TraceFunctionName("RtpGetQosEnabledProtocol");
    
    if (!pProtoInfo) {
        return(RTPERR_POINTER);
    }

    dwSize = sizeof(WSAPROTOCOL_INFO) * 16;
    
    pAllProtoInfo = (WSAPROTOCOL_INFO *)
        RtpHeapAlloc(g_pRtpQosBufferHeap, dwSize);

    if (!pAllProtoInfo)
    {
        return(RTPERR_MEMORY);
    }
    
    hr = RTPERR_QOS;

    Protocols[0] = IPPROTO_UDP;
    Protocols[1] = 0;
    
    ZeroMemory((char *)pAllProtoInfo, dwSize);
        
    dwStatus = WSAEnumProtocols(Protocols, pAllProtoInfo, &dwSize);

    if (dwStatus == SOCKET_ERROR) {
        
        TraceRetailWSAGetError(dwError);
        
        TraceRetail((
                CLASS_ERROR, GROUP_QOS, S_QOS_PROVIDER,
                _T("%s: WSAEnumProtocols ")
                _T("failed: %u (0x%X)\n"),
                _fname, dwError, dwError
            ));
        
    } else {
            
        for(dwIndex = 0; dwIndex < dwStatus; dwIndex++) {

            if (pAllProtoInfo[dwIndex].dwServiceFlags1 & XP1_QOS_SUPPORTED)
                break;
        }
            
        if (dwIndex >= dwStatus) {
            
            TraceRetail((
                    CLASS_ERROR, GROUP_QOS, S_QOS_PROVIDER,
                    _T("%s: WSAEnumProtocols ")
                    _T("failed: Unable to find QOS capable protocol"),
                    _fname
                ));
        } else {
            
            TraceDebug((
                    CLASS_INFO, GROUP_QOS, S_QOS_PROVIDER,
                    _T("%s: WSAEnumProtocols: QOS capable protocol found"),
                    _fname
                ));

            CopyMemory(pProtoInfo,
                       &pAllProtoInfo[dwIndex],
                       sizeof(WSAPROTOCOL_INFO));

            hr = NOERROR;
        }
    }
    
    RtpHeapFree(g_pRtpQosBufferHeap, pAllProtoInfo);
    
    return(hr);
}
            
/*
 * Make a reservation if a receiver (RESV messages), specify the
 * flowspec for a sender (PATH messages)
 * */
HRESULT RtpReserve(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwRecvSend
    )
{
    HRESULT            hr;
    DWORD              dwStatus;
    DWORD              dwError;
    
    int                len;
    DWORD              dwBufferSize;
    DWORD              dwImageNameSize;
    TCHAR_t           *psAppGUID;
    TCHAR_t           *psQosName;
    TCHAR_t           *psClass;
    
    QOS               *pQos;
    char              *ptr;
    RtpQosReserve_t   *pRtpQosReserve;

    /* Sender */
    QOS_DESTADDR      *pQosDestAddr;
    SOCKADDR_IN       *pSockAddrIn;
    QOS_SD_MODE       *pQosSdMode;
    
    /* Receiver */
    RSVP_RESERVE_INFO *pRsvpReserveInfo;
    FLOWDESCRIPTOR    *pFlowDescriptor;
    RSVP_FILTERSPEC   *pRsvpFilterspec;
    DWORD              dwStyle;
    DWORD              dwMaxBandwidth;

    DWORD              dwOutBufSize;

    TCHAR_t            sAddr[16];
    
    TraceFunctionName("RtpReserve");

    pRtpQosReserve = pRtpAddr->pRtpQosReserve;

    if (!pRtpQosReserve)
    {
        return(RTPERR_INVALIDSTATE);
    }

    dwRecvSend &= RECVSENDMASK;
    
    /* Decide buffer size to allocate */

    if (dwRecvSend == SEND_IDX)
    {
        dwMaxBandwidth = pRtpAddr->RtpNetSState.dwOutboundBandwidth;
        
        dwBufferSize =
            sizeof(QOS) +
            sizeof(QOS_DESTADDR) +
            sizeof(QOS_SD_MODE) +
            sizeof(SOCKADDR_IN) +
            sizeof(RSVP_RESERVE_INFO);
    }
    else
    {
        dwMaxBandwidth = pRtpAddr->RtpNetSState.dwInboundBandwidth;
        
        dwBufferSize =
            sizeof(QOS) +
            sizeof(RSVP_RESERVE_INFO) +
            sizeof(FLOWDESCRIPTOR) +
            sizeof(RSVP_FILTERSPEC) * pRtpQosReserve->dwMaxFilters;
    }

    if (pRtpQosReserve->psAppName)
    {
        dwImageNameSize = lstrlen(pRtpQosReserve->psAppName);
    }
    else
    {
        /* If we don't have an app name, generate a default from the
         * binary name */
        dwImageNameSize = 0;
        
        RtpGetImageName(NULL, &dwImageNameSize);

        dwImageNameSize++;
        
        pRtpQosReserve->psAppName =
            RtpHeapAlloc(g_pRtpQosBufferHeap,
                         dwImageNameSize  * sizeof(TCHAR_t));

        /* RtpGetImageName tests for NULL passed */
        RtpGetImageName(pRtpQosReserve->psAppName, &dwImageNameSize);
    }

    /*
     * Will compose a policy locator with a format similar to this:
     *     GUID=WWW.USERDOMAIN.COM,APP=RTCAPP.EXE,\
     *     SAPP=MICROSOFT REAL-TIME COMMUNICATIONS,VER=1.0,\
     *     SAPP=AUDIO,SAPP=G723.1,SAPP=THE USER STRING
     *
     * And an application name with a format similar to:
     *     RTCAPP.EXE
     */

    dwBufferSize +=
        sizeof(RSVP_POLICY_INFO) -
        sizeof(RSVP_POLICY) +
        RSVP_POLICY_HDR_LEN +
            
        RSVP_BYTE_MULTIPLE(IDPE_ATTR_HDR_LEN +
                           ((4 /* sizeof(_T("APP="))/sizeof(TCHAR) */ +
                             dwImageNameSize +
                             lstrlen(g_sPolicyLocator) +
                             MAX_QOS_CLASS +
                             6 /* sizeof(_T(",SAPP="))/sizeof(TCHAR) */ +
                             MAX_QOS_NAME +
                             1 +
                             MAX_QOS_APPGUID +
                             1 +
                             MAX_QOS_POLICY +
                             1) * sizeof(TCHAR_t))) +
        RSVP_BYTE_MULTIPLE(IDPE_ATTR_HDR_LEN +
                           ((dwImageNameSize + 1) * sizeof(TCHAR_t)));

    /* Allocate buffer */
    pQos = (QOS *) RtpHeapAlloc(g_pRtpQosBufferHeap, dwBufferSize);

    if (!pQos)
    {
        return(RTPERR_MEMORY);
    }

    CopyMemory(pQos, &pRtpQosReserve->qos, sizeof(QOS));

    /* Set as default No provider specific information */
    pQos->ProviderSpecific.len = 0;
    pQos->ProviderSpecific.buf = NULL;
    ptr = (char *)(pQos + 1);

    if (dwRecvSend == SEND_IDX)
    {
        TraceRetail((
                CLASS_INFO, GROUP_QOS, S_QOS_RESERVE,
                _T("%s: pRtpAddr[0x%p] SEND"),
                _fname, pRtpAddr
            ));
            
        /* Init the destination object if unicast */
        if (IS_UNICAST(pRtpAddr->dwAddr[REMOTE_IDX]))
        {
            if (pRtpAddr->dwAddr[REMOTE_IDX] && pRtpAddr->wRtpPort[REMOTE_IDX])
            {
                /* Initialize destination adddress */
                ZeroMemory(ptr, sizeof(QOS_DESTADDR) + sizeof(SOCKADDR_IN));

                pQosDestAddr = (QOS_DESTADDR *)ptr;
                pSockAddrIn = (SOCKADDR_IN *)(pQosDestAddr + 1);
                ptr += sizeof(QOS_DESTADDR) + sizeof(SOCKADDR_IN);

                /* Initialize QOS_DESTADDR */
                pQosDestAddr->ObjectHdr.ObjectType = QOS_OBJECT_DESTADDR;
                pQosDestAddr->ObjectHdr.ObjectLength =
                    sizeof(QOS_DESTADDR) +
                    sizeof(SOCKADDR_IN);
                pQosDestAddr->SocketAddress = (SOCKADDR *)pSockAddrIn;
                pQosDestAddr->SocketAddressLength = sizeof(SOCKADDR_IN);

                /* Initialize SOCKADDR_IN */
                pSockAddrIn->sin_family = AF_INET;
                pSockAddrIn->sin_addr.s_addr = pRtpAddr->dwAddr[REMOTE_IDX];
                pSockAddrIn->sin_port = pRtpAddr->wRtpPort[REMOTE_IDX];
            }
            else
            {
                TraceRetail((
                        CLASS_WARNING, GROUP_QOS, S_QOS_RESERVE,
                        _T("%s: pRtpAddr[0x%p] QOS_DESTADDR not added %s/%u"),
                        _fname, pRtpAddr,
                        RtpNtoA(pRtpAddr->dwAddr[REMOTE_IDX], sAddr),
                        ntohs(pRtpAddr->wRtpPort[REMOTE_IDX])
                    ));
            }
        }

        /* Init the ShapeDiscard structure if class AUDIO */
        if ( (RtpGetClass(pRtpAddr->dwIRtpFlags) == RTPCLASS_AUDIO) &&
             
             ( !IsRegValueSet(g_RtpReg.dwQosFlags) ||
               !RtpBitTest(g_RtpReg.dwQosFlags,
                           FGREGQOS_DONOTSET_BORROWMODE) ) )
        {
            pQosSdMode = (QOS_SD_MODE *)ptr;
            ptr += RTP_ALIGNED_SIZEOF(QOS_SD_MODE);
           
            /* Select borrow mode */
            pQosSdMode->ObjectHdr.ObjectType = QOS_OBJECT_SD_MODE;
            pQosSdMode->ObjectHdr.ObjectLength =
                RTP_ALIGNED_SIZEOF(QOS_SD_MODE);
            pQosSdMode->ShapeDiscardMode = TC_NONCONF_BORROW;
        }
        
        pRsvpReserveInfo = (RSVP_RESERVE_INFO *)ptr;
        
        /* Do not change the receiver */
        pQos->ReceivingFlowspec.ServiceType = SERVICETYPE_NOCHANGE;

        /* Scale the flow spec for the sender (if needed) */
        RtpScaleFlowSpec(&pQos->SendingFlowspec,
                         1,
                         1,
                         dwMaxBandwidth);

        /* Partially Init RSVP_RESERVE_INFO */
        ZeroMemory(pRsvpReserveInfo, sizeof(RSVP_RESERVE_INFO));
        pRsvpReserveInfo->ObjectHdr.ObjectType = RSVP_OBJECT_RESERVE_INFO;
        /* TODO expose a way to select confirmation, right now always
         * ask for confirmation */
        pRsvpReserveInfo->ConfirmRequest = 1;

        dwStyle = pRtpQosReserve->dwStyle;

        switch(dwStyle)
        {
        case RTPQOS_STYLE_DEFAULT:
            pRsvpReserveInfo->Style = RSVP_DEFAULT_STYLE;
            break;
        case RTPQOS_STYLE_WF:
            pRsvpReserveInfo->Style = RSVP_WILDCARD_STYLE;
            break;
        case RTPQOS_STYLE_FF:
            pRsvpReserveInfo->Style = RSVP_FIXED_FILTER_STYLE;
            break;
        case RTPQOS_STYLE_SE:
            pRsvpReserveInfo->Style = RSVP_SHARED_EXPLICIT_STYLE;
            break;
        default:
            pRsvpReserveInfo->Style = RSVP_DEFAULT_STYLE;
        }
        
        ptr += sizeof(RSVP_RESERVE_INFO);

        /*
         * Add QOS app ID later at ptr
         */
    }
    else
    {
        pRsvpReserveInfo = (RSVP_RESERVE_INFO *)ptr;

        /* Do not change the sender */
        pQos->SendingFlowspec.ServiceType = SERVICETYPE_NOCHANGE;

        /* Partially initialize RSVP_RESERVE_INFO */
        ZeroMemory(pRsvpReserveInfo, sizeof(RSVP_RESERVE_INFO));
        pRsvpReserveInfo->ObjectHdr.ObjectType = RSVP_OBJECT_RESERVE_INFO;
        /* MAYDO expose a way to select confirmation, right now always
         * ask for confirmation */
        pRsvpReserveInfo->ConfirmRequest = 1;

        dwStyle = pRtpQosReserve->dwStyle;

        if (dwStyle == RTPQOS_STYLE_SE)
        {
            /* Shared Explicit filter -- SE */

            if (pRtpQosReserve->pRsvpFilterSpec &&
                pRtpQosReserve->dwNumFilters > 0)
            {
                pRsvpReserveInfo->Style = RSVP_SHARED_EXPLICIT_STYLE;
                
                /* We have some filters */
                TraceRetail((
                        CLASS_INFO, GROUP_QOS, S_QOS_RESERVE,
                        _T("%s: pRtpAddr[0x%p] RECV ")
                        _T("Multicast(SE, %d)"),
                        _fname, pRtpAddr,
                        pRtpQosReserve->dwNumFilters
                    ));

                /* Scale the flow descriptor to dwNumFilters */
                RtpScaleFlowSpec(&pQos->ReceivingFlowspec,
                                 pRtpQosReserve->dwNumFilters,
                                 pRtpQosReserve->dwMaxFilters,
                                 dwMaxBandwidth);
                
                pFlowDescriptor = (FLOWDESCRIPTOR *)(pRsvpReserveInfo + 1);

                pRsvpFilterspec = (RSVP_FILTERSPEC *)(pFlowDescriptor + 1);

                /* Init RSVP_RESERVE_INFO */
                pRsvpReserveInfo->ObjectHdr.ObjectLength =
                    sizeof(RSVP_RESERVE_INFO) +
                    sizeof(FLOWDESCRIPTOR) +
                    (sizeof(RSVP_FILTERSPEC) * pRtpQosReserve->dwNumFilters);
                pRsvpReserveInfo->NumFlowDesc = 1;
                pRsvpReserveInfo->FlowDescList = pFlowDescriptor;
                    
                /* Init FLOWDESCRIPTOR */
                CopyMemory(&pFlowDescriptor->FlowSpec,
                           &pQos->ReceivingFlowspec,
                           sizeof(pQos->ReceivingFlowspec));
                pFlowDescriptor->NumFilters = pRtpQosReserve->dwNumFilters;
                pFlowDescriptor->FilterList = pRsvpFilterspec;

                /* Init RSVP_FILTERSPEC */
                CopyMemory(pRsvpFilterspec,
                           pRtpQosReserve->pRsvpFilterSpec,
                           pRtpQosReserve->dwNumFilters *
                           sizeof(RSVP_FILTERSPEC));

                /* Add QOS app ID later at ptr */
                ptr = (char *)pRsvpFilterspec +
                    pRtpQosReserve->dwNumFilters * sizeof(RSVP_FILTERSPEC);
            }
            else
            {
                /* No filters selected yet, use BEST_EFFORT */
                TraceRetail((
                        CLASS_INFO, GROUP_QOS, S_QOS_RESERVE,
                        _T("%s: pRtpAddr[0x%p] RECV ")
                        _T("Multicast(SE, %d) pass to BEST EFFORT"),
                        _fname, pRtpAddr,
                        pRtpQosReserve->dwNumFilters
                    ));

                pQos->ReceivingFlowspec.ServiceType = SERVICETYPE_BESTEFFORT;

                /* No pRsvpReserveInfo needed, hence do not add QOS
                 * app ID */
                pRsvpReserveInfo = (RSVP_RESERVE_INFO *)NULL;
            }
        }
        else if (dwStyle == RTPQOS_STYLE_WF)
        {
            /* Share N*FlowSpec -- WF */

            pRsvpReserveInfo->Style = RSVP_WILDCARD_STYLE;
            
            TraceRetail((
                    CLASS_INFO, GROUP_QOS, S_QOS_RESERVE,
                    _T("%s: pRtpAddr[0x%p] RECV Multicast(WF)"),
                    _fname, pRtpAddr
                ));

            /* Scale the flow spec to dwMaxFilters */
            RtpScaleFlowSpec(&pQos->ReceivingFlowspec,
                             pRtpQosReserve->dwMaxFilters,
                             pRtpQosReserve->dwMaxFilters,
                             dwMaxBandwidth);
            
            /* Init RSVP_RESERVE_INFO */
            pRsvpReserveInfo->ObjectHdr.ObjectLength =
                sizeof(RSVP_RESERVE_INFO);

            /* Add QOS app ID later at ptr */
            ptr = (char *)(pRsvpReserveInfo + 1);
        }
        else
        {
            /* RSVP_DEFAULT_STYLE || RSVP_FIXED_FILTER_STYLE */
            /* Unicast -- FF */

            pRsvpReserveInfo->Style = RSVP_DEFAULT_STYLE;
            
            TraceRetail((
                    CLASS_INFO, GROUP_QOS, S_QOS_RESERVE,
                    _T("%s: pRtpAddr[0x%p] RECV ")
                    _T("Unicast/Multicast(DEF STYLE)"),
                    _fname, pRtpAddr
                ));
            
            /* Scale the flow spec to dwMaxFilters */
            RtpScaleFlowSpec(&pQos->ReceivingFlowspec,
                             pRtpQosReserve->dwMaxFilters,
                             pRtpQosReserve->dwMaxFilters,
                             dwMaxBandwidth);
            
            /* Add QOS app ID later at ptr */
            ptr = (char *)(pRsvpReserveInfo + 1);
       }
    }

    /* Add QOS APP ID if reserve info was defined */
    if (pRsvpReserveInfo)
    {
        psAppGUID = pRtpQosReserve->psAppGUID;

        if (!psAppGUID)
        {
            /* Use default */
            psAppGUID = (TCHAR_t *)g_sAppGUID;
        }
        
        psQosName = NULL;

        if (pRtpQosReserve->pQosInfo[dwRecvSend])
        {
            psQosName = pRtpQosReserve->pQosInfo[dwRecvSend]->pName;
        }

        psClass = (TCHAR_t *)
            g_psRtpStreamClass[RtpGetClass(pRtpAddr->dwIRtpFlags)];

        len = AddQosAppID(ptr,
                          pRtpQosReserve->psAppName,
                          psAppGUID,
                          psClass,
                          psQosName,
                          pRtpQosReserve->psPolicyLocator);

        if (len > 0)
        {
            pRsvpReserveInfo->PolicyElementList = (RSVP_POLICY_INFO *)ptr;
            ptr += len;
        }

        pRsvpReserveInfo->ObjectHdr.ObjectLength = (DWORD)
            (ptr - (char *)pRsvpReserveInfo);
            
        /* Init ProviderSpecific */
        pQos->ProviderSpecific.len = (DWORD)(ptr - (char *)(pQos + 1));
        pQos->ProviderSpecific.buf = (char *)(pQos + 1);
    }

    hr = NOERROR;
    dwOutBufSize = 0;

    dwStatus = WSAIoctl(pRtpAddr->Socket[dwRecvSend],
                        SIO_SET_QOS,
                        pQos,
                        sizeof(QOS),
                        NULL,
                        0,
                        &dwOutBufSize,
                        NULL,
                        NULL);

    if (dwStatus)
    {
        hr = RTPERR_QOS;

        TraceRetailWSAGetError(dwError);
        
        TraceRetail((
                CLASS_ERROR, GROUP_QOS, S_QOS_RESERVE,
                _T("%s: pRtpAddr[0x%p] %s WSAIoctl(%u, SIO_SET_QOS) ")
                _T("failed: %u (0x%X)"),
                _fname, pRtpAddr,
                RTPRECVSENDSTR(dwRecvSend),
                pRtpAddr->Socket[dwRecvSend],
                dwError, dwError
            ));
    }
    else
    {
        TraceRetail((
                CLASS_INFO, GROUP_QOS, S_QOS_RESERVE,
                _T("%s: pRtpAddr[0x%p] %s WSAIoctl(%u, SIO_SET_QOS) ")
                _T("succeeded"),
                _fname, pRtpAddr,
                RTPRECVSENDSTR(dwRecvSend),
                pRtpAddr->Socket[dwRecvSend]
            ));
    }
    
    RtpHeapFree(g_pRtpQosBufferHeap, pQos);
    
    return(hr);
}

/*
 * Set to no traffic a receiver or sender leaving the other unchanged
 * */
HRESULT RtpUnreserve(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwRecvSend
    )
{

    HRESULT            hr;
    DWORD              dwStatus;
    DWORD              dwError;
    
    QOS                qos;
    RtpQosReserve_t   *pRtpQosReserve;

    DWORD              dwOutBufSize ;
    
    TraceFunctionName("RtpUnreserve");

    pRtpQosReserve = pRtpAddr->pRtpQosReserve;

    if (!pRtpQosReserve) {
        return(RTPERR_INVALIDSTATE);
    }

    dwRecvSend &= RECVSENDMASK;
    
    CopyMemory(&qos, &pRtpQosReserve->qos, sizeof(qos));
    
    qos.ProviderSpecific.len = 0;
    qos.ProviderSpecific.buf = NULL;
    
    if (dwRecvSend) {
        qos.SendingFlowspec.ServiceType   = SERVICETYPE_NOTRAFFIC;
        qos.ReceivingFlowspec.ServiceType = SERVICETYPE_NOCHANGE;
    } else {
        qos.SendingFlowspec.ServiceType   = SERVICETYPE_NOCHANGE;
        qos.ReceivingFlowspec.ServiceType = SERVICETYPE_NOTRAFFIC;
    }

    hr = NOERROR;
    dwOutBufSize = 0;

    dwStatus = WSAIoctl(pRtpAddr->Socket[dwRecvSend],
                        SIO_SET_QOS,
                        (LPVOID)&qos,
                        sizeof(qos),
                        NULL,
                        0,
                        &dwOutBufSize,
                        NULL,
                        NULL);

    if (dwStatus)
    {
        hr = RTPERR_QOS;

        TraceRetailWSAGetError(dwError);
        
        TraceRetail((
                CLASS_ERROR, GROUP_QOS, S_QOS_RESERVE,
                _T("%s: pRtpAddr[0x%p] %s WSAIoctl(%u, SIO_SET_QOS) ")
                _T("failed: %u (0x%X)"),
                _fname, pRtpAddr,
                RTPRECVSENDSTR(dwRecvSend),
                pRtpAddr->Socket[dwRecvSend],
                dwError, dwError
            ));
    }
    else
    {
        TraceRetail((
                CLASS_INFO, GROUP_QOS, S_QOS_RESERVE,
                _T("%s: pRtpAddr[0x%p] %s WSAIoctl(%u, SIO_SET_QOS) ")
                _T("succeeded"),
                _fname, pRtpAddr,
                RTPRECVSENDSTR(dwRecvSend),
                pRtpAddr->Socket[dwRecvSend]
            ));
    }

    return(hr);
}

/* Scales the flowspec based on the max bandwidth to be used, the
 * maximum number of participants that will share the bandwidth, and
 * the current number of participants sharing the bandwidth. In
 * multicast, the bandwidth allocated is always proportional to the
 * maximum number of participants, i.e. for max participants = 5, and
 * max bandwidth = 100k, 2 participants will receive 20k, 3 will
 * receive 30k, and not the max of 100k. This is so to maintain a
 * consistent resource allocation for each participant independent of
 * the current number */
HRESULT RtpScaleFlowSpec(
        FLOWSPEC        *pFlowSpec,
        DWORD            dwNumParticipants,
        DWORD            dwMaxParticipants,
        DWORD            dwBandwidth
    )
{
    DWORD            dwOverallBW;
    DWORD            factor1;
    DWORD            factor2;
    DWORD            RSVPTokenRate;
    DWORD            RSVPPeakBandwidth;

    TraceFunctionName("RtpScaleFlowSpec");

    dwBandwidth /= 8;  /* flowspec is in bytes/sec */
    dwOverallBW = pFlowSpec->TokenRate * dwMaxParticipants;

    TraceRetail((
            CLASS_INFO, GROUP_QOS, S_QOS_FLOWSPEC,
            _T("%s: NumPars:%u, MaxPars:%u, Bandwidth:%u b/s)"),
            _fname, dwNumParticipants, dwMaxParticipants, dwBandwidth*8
        ));            
    TraceRetail((
            CLASS_INFO, GROUP_QOS, S_QOS_FLOWSPEC,
            _T("%s: Initial flowspec(TokenRate:%6u, TokenBucketSize:%u, ")
            _T("PeakBandW:%6u, ServiceType:%u, ")
            _T("MaxSDU:%u MinSize:%u)"),
            _fname,
            pFlowSpec->TokenRate, pFlowSpec->TokenBucketSize,
            pFlowSpec->PeakBandwidth, pFlowSpec->ServiceType,
            pFlowSpec->MaxSduSize, pFlowSpec->MinimumPolicedSize
        ));

    if (!dwBandwidth || !dwOverallBW)
    {
        return(RTPERR_INVALIDARG);
    }
    
    if (dwOverallBW <= dwBandwidth)
    {
        /* use as it is, scale up to dwNumParticipants */
        pFlowSpec->TokenRate *= dwNumParticipants;
        pFlowSpec->TokenBucketSize *= dwNumParticipants;
        if (pFlowSpec->PeakBandwidth != QOS_NOT_SPECIFIED)
        {
            pFlowSpec->PeakBandwidth *= dwNumParticipants;
        }
    }
    else
    {
        /* don't have all we need, scale according to number of
         * participants */
        
        if (dwNumParticipants == dwMaxParticipants)
        {
            /* use all the bandwidth available */

            /* TokenRate = Bw
             * TokenRate = Bw * 1
             * TokenRate = Bw * [ TokenRate1 / TokenRate ]
             * TokenRate = TokenRate * [ Bw / TokenRate ]
             * TokenRate = TokenRate * [ factor1 / factor2 ]
             * */

            factor1 = dwBandwidth;
            factor2 = pFlowSpec->TokenRate;
        }
        else
        {
            /* use the bandwidth according to number of participants */
            
            /* TokenRate = Bw * (Num / Max)
             * TokenRate = [ Bw * (Num / Max) ] * 1
             * TokenRate = [ Bw * (Num / Max) ] * [ TokenRate / TokenRate ]
             * TokenRate = TokenRate * [ Bw * (Num / Max) ] / TokenRate
             * TokenRate = TokenRate * [ Bw * Num ] / [ Max * TokenRate ]
             * TokenRate = TokenRate * factor1 / factor2
             * */
            
            factor1 = dwBandwidth * dwNumParticipants;
            factor2 = pFlowSpec->TokenRate * dwMaxParticipants;
        }

        /* scale TokenRate up or down */
        pFlowSpec->TokenRate =
            (pFlowSpec->TokenRate * factor1) / factor2;
            
        if (factor1 > factor2)
        {
            /* can still scale up the other parameters */
                
            pFlowSpec->TokenBucketSize =
                ((pFlowSpec->TokenBucketSize * factor1) / factor2);

            if (pFlowSpec->PeakBandwidth != QOS_NOT_SPECIFIED)
            {
                pFlowSpec->PeakBandwidth =
                    ((pFlowSpec->PeakBandwidth * factor1) / factor2);
            }
        }
    }

    /* The bandwidth we request includes RTP/UDP/IP headers overhead,
     * but RSVP also scales up to consider headers overhead, to ovoid
     * requesting more bandwidth than we intend, pass to RSVP a
     * smaller value such that the final one RSVP comes up with would
     * be the original value we requested.
     *
     * UDP+IP = 28 bytes
     * RSVPSP Applies the following scale up:
     *
     * NewTokenRate = TokenRate * [ (MinPolizedSize + 28) / MinPolizedSize ]
     *
     * So we do here the reverse scale down to cancel the scale up:
     *
     * NewTokenRate = TokenRate * [ MinPolizedSize / (MinPolizedSize + 28) ]
     */

    if (pFlowSpec->MinimumPolicedSize > 0)
    {
        RSVPTokenRate =
            (pFlowSpec->TokenRate * 1000) /
            (1000 + 28000/pFlowSpec->MinimumPolicedSize);
    }

    RSVPPeakBandwidth = pFlowSpec->PeakBandwidth;

    if (RSVPPeakBandwidth != QOS_NOT_SPECIFIED)
    {
        RSVPPeakBandwidth =
            (pFlowSpec->PeakBandwidth * 1000) /
            (1000 + 28000/pFlowSpec->MinimumPolicedSize);
    }

    TraceRetail((
            CLASS_INFO, GROUP_QOS, S_QOS_FLOWSPEC,
            _T("%s: Scaled  flowspec(TokenRate:%6u, TokenBucketSize:%u, ")
            _T("PeakBandW:%6u, ServiceType:%u, ")
            _T("MaxSDU:%u MinSize:%u)"),
            _fname,
            pFlowSpec->TokenRate, pFlowSpec->TokenBucketSize,
            pFlowSpec->PeakBandwidth, pFlowSpec->ServiceType,
            pFlowSpec->MaxSduSize, pFlowSpec->MinimumPolicedSize
        ));
    
    TraceRetail((
            CLASS_INFO, GROUP_QOS, S_QOS_FLOWSPEC,
            _T("%s: Applied flowspec(TokenRate:%6u, TokenBucketSize:%u, ")
            _T("PeakBandW:%6u, ServiceType:%u, ")
            _T("MaxSDU:%u MinSize:%u)"),
            _fname,
            RSVPTokenRate, pFlowSpec->TokenBucketSize,
            RSVPPeakBandwidth, pFlowSpec->ServiceType,
            pFlowSpec->MaxSduSize, pFlowSpec->MinimumPolicedSize
        ));
    
    pFlowSpec->TokenRate = RSVPTokenRate;
    pFlowSpec->PeakBandwidth = RSVPPeakBandwidth;

    return(NOERROR);
}

/**********************************************************************
 * QOS notifications
 **********************************************************************/
HRESULT StartRtcpQosNotify(
        RtcpContext_t  *pRtcpContext,
        RtcpAddrDesc_t *pRtcpAddrDesc
    )
{
    HRESULT         hr;
    DWORD           dwStatus;
    DWORD           dwError;
    DWORD           dwMaxTry;
    BOOL            bPending;
    RtpQosNotify_t *pRtpQosNotify;
    RtpAddr_t      *pRtpAddr;

    TraceFunctionName("StartRtcpQosNotify");

    if (RtpBitTest(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_NOTIFYPENDING))
    {
        /* Already started, do nothhing */
        return(NOERROR);
    }
        
    pRtpQosNotify = pRtcpAddrDesc->pRtpQosNotify;
    pRtpAddr = pRtcpAddrDesc->pRtpAddr;
    
    /* Overlapped structure */
    pRtpQosNotify->Overlapped.hEvent = pRtpQosNotify->hQosNotifyEvent;

    bPending = FALSE;
    
    for(dwError = WSAENOBUFS, dwMaxTry = 3;
        (dwError == WSAENOBUFS) && dwMaxTry;
        dwMaxTry--)
    {
        TraceDebug((
                CLASS_INFO, GROUP_QOS, S_QOS_NOTIFY,
                _T("%s: pRtcpAddrDesc[0x%p]: pBuffer[0x%p] Size: %u"),
                _fname, pRtcpAddrDesc,
                pRtpQosNotify->ProviderInfo,
                pRtpQosNotify->dwProviderLen
            ));
        
        if (pRtpQosNotify->ProviderInfo)
        {
            /* post request for asynchronous QOS notification */
            dwStatus = WSAIoctl(
                    pRtpAddr->Socket[SOCK_RECV_IDX],
                    SIO_GET_QOS,
                    NULL,
                    0, 
                    pRtpQosNotify->ProviderInfo,
                    pRtpQosNotify->dwProviderLen,
                    &pRtpQosNotify->dwTransfered,
                    &pRtpQosNotify->Overlapped,
                    NULL);
        }
        else
        {
            /* no buffer yet, allocate one */
            ReallocateQosBuffer(pRtpQosNotify);
            continue;
        }
        
        if (!dwStatus)
        {
            /* Operation succeeded */
            dwError = 0;

            /* I/O will complete later */
            bPending = TRUE;
            
            TraceDebug((
                    0, GROUP_QOS, S_QOS_NOTIFY,
                    _T("%s: pRtcpAddrDesc[0x%p]: ")
                    _T("Status: 0 (0x0) I/O will complete later"),
                    _fname, pRtcpAddrDesc
                ));
        }
        else
        {
            TraceRetailWSAGetError(dwError);
            
            if (dwError == WSA_IO_PENDING)
            {
                /* I/O will complete later */
                TraceDebug((
                        CLASS_INFO, GROUP_QOS, S_QOS_NOTIFY,
                        _T("%s: pRtcpAddrDesc[0x%p]: ")
                        _T("Status: %u (0x%X), Error: %u (0x%X)"),
                        _fname, pRtcpAddrDesc,
                        dwStatus, dwStatus, dwError, dwError
                    ));

                bPending = TRUE;
            }
            else if (dwError == WSAENOBUFS)
            {
                /* Reallocate a bigger buffer */
                TraceRetail((
                        CLASS_WARNING, GROUP_QOS, S_QOS_NOTIFY,
                        _T("%s: pRtcpAddrDesc[0x%p]: ")
                        _T("Buffer too small"),
                        _fname, pRtcpAddrDesc
                    ));
                
                ReallocateQosBuffer(pRtpQosNotify);
                
            }
            else if (dwError == WSAEOPNOTSUPP)
            {
                TraceRetail((
                        CLASS_WARNING, GROUP_QOS, S_QOS_NOTIFY,
                        _T("%s: pRtcpAddrDesc[0x%p]: ")
                        _T("Notifications not supported: %u (0x%X)"),
                        _fname, pRtcpAddrDesc,
                        dwError, dwError
                    ));
            }
            else
            {
                TraceRetail((
                        CLASS_ERROR, GROUP_QOS, S_QOS_NOTIFY,
                        _T("%s: pRtcpAddrDesc[0x%p]: ")
                        _T("overlapped notification ")
                        _T("failed to start: %u (0x%X)"),
                        _fname, pRtcpAddrDesc,
                        dwError, dwError
                    ));
                /*
                 * !!! WARNING !!!
                 *
                 * Unexpected error, try to start notifications later
                 *
                 * May notify (send event) about this.
                 * */
            }
        }
    }

    if (bPending)
    {
        hr = NOERROR;
        
        RtpBitSet(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_NOTIFYPENDING);
            
        pRtcpAddrDesc->lQosPending = 1;

        if (!RtpBitTest(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_NOTIFYBUSY)) {

            /* Currently in StartQ, move to BusyQ */
            move2ql(&pRtcpContext->QosBusyQ,
                    &pRtcpContext->QosStartQ,
                    NULL,
                    &pRtcpAddrDesc->QosQItem);

            RtpBitSet(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_NOTIFYBUSY);
        }
    }
    else
    {
        /* Failed to start, schedule for later */
        hr = RTPERR_QOS;

        RtpBitReset(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_NOTIFYPENDING);
        
        /* MAYDO Be able to schedule failed notifications later and
         * define time somewhere else rather than defining a hardcoded
         * value.
         *
         * Currently the RTCP thread doesn't do a periodic checking
         * for failed notifications that need another "try", I'm not
         * shure if that is even needed, so far failure to start
         * notifications other than because we are currently using
         * best-effort, will also continue to fail later. Some part of
         * the code (e.g. this one) behave (with no bad side effect)
         * as if future scheduling were in place.  Currently,
         * notifications, once failed, will not be attempted later,
         * the exception is when using SE, but in that case they will
         * be explicitly re-started. */

        pRtpQosNotify->dNextStart = RtpGetTimeOfDay((RtpTime_t *)NULL) + 1;

        /* If was in BusyQ, move back to StartQ */
        if (RtpBitTest(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_NOTIFYBUSY))
        {
            /* Currently in BusyQ, move back to StartQ */
            dequeue(&pRtcpContext->QosBusyQ,
                    NULL,
                    &pRtcpAddrDesc->QosQItem);

            RtpBitReset(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_NOTIFYBUSY);
        }
        else
        {
            /* Currently in StartQ, remove from there */
            dequeue(&pRtcpContext->QosStartQ,
                    NULL,
                    &pRtcpAddrDesc->QosQItem);
        }

        /* Enqueue in order */
        enqueuedK(&pRtcpContext->QosStartQ,
                  NULL,
                  &pRtcpAddrDesc->QosQItem,
                  pRtpQosNotify->dNextStart);
    }
     
    return(hr);
}

HRESULT ConsumeRtcpQosNotify(
        RtcpContext_t  *pRtcpContext,
        RtcpAddrDesc_t *pRtcpAddrDesc
    )
{
    HRESULT         hr;
    BOOL            bStatus;
    DWORD           dwError;
    BOOL            bRestart;
    char            str[256];
    
    RtpQosNotify_t *pRtpQosNotify;
    RtpAddr_t      *pRtpAddr;

    TraceFunctionName("ConsumeRtcpQosNotify");
    
    pRtpQosNotify = pRtcpAddrDesc->pRtpQosNotify;
    pRtpAddr = pRtcpAddrDesc->pRtpAddr;

    hr       = NOERROR;
    bRestart = FALSE;
    dwError  = NOERROR;
    
    bStatus = WSAGetOverlappedResult(
            pRtcpAddrDesc->Socket[SOCK_RECV_IDX], /* SOCKET s */
            &pRtpQosNotify->Overlapped,  /* LPWSAOVERLAPPED lpOverlapped */
            &pRtpQosNotify->dwTransfered,/* LPDWORD lpcbTransfer */
            FALSE,                       /* BOOL fWait */
            &pRtpQosNotify->dwNotifyFlags /* LPDWORD lpdwFlags */
        );
            
    if (!bStatus)
    {
        TraceRetailWSAGetError(dwError);

        if (dwError == WSA_OPERATION_ABORTED ||
            dwError == WSAEINTR ||
            dwError == WSAENOBUFS ||
            dwError == WSAEMSGSIZE)
        {
            TraceRetail((
                    CLASS_WARNING, GROUP_QOS, S_QOS_NOTIFY,
                    _T("%s: pRtcpAddrDesc[0x%p] Transfered:%u ")
                    _T("Error: %u (0x%X)"),
                    _fname, pRtcpAddrDesc, pRtpQosNotify->dwTransfered,
                    dwError, dwError
                ));
        }
        else
        {
            /* If sockets were closed I will get error WSAENOTSOCK */
            if (dwError == WSAENOTSOCK &&
                RtpBitTest(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_SHUTDOWN1))
            {
                /* Use FGADDRD_SHUTDOWN1 because FGADDRD_SHUTDOWN2 is
                 * set after the sockets were closed. */
                TraceRetail((
                        CLASS_WARNING, GROUP_QOS, S_QOS_NOTIFY,
                        _T("%s: pRtcpAddrDesc[0x%p] Transfered:%u ")
                        _T("Error: %u (0x%X) shutting down"),
                        _fname, pRtcpAddrDesc, pRtpQosNotify->dwTransfered,
                        dwError, dwError
                    ));
            }
            else
            {
                TraceRetail((
                        CLASS_ERROR, GROUP_QOS, S_QOS_NOTIFY,
                        _T("%s: pRtcpAddrDesc[0x%p] Transfered:%u ")
                        _T("Error: %u (0x%X)"),
                        _fname, pRtcpAddrDesc, pRtpQosNotify->dwTransfered,
                        dwError, dwError
                    ));
            }
        }

        if (dwError == WSA_IO_INCOMPLETE)
        {
            /* I/O hasn't completed yet */
        }
        else if ( (dwError == WSA_OPERATION_ABORTED) ||
                  (dwError == WSAEINTR) )
        {
            /* Socket closed, I/O completed */
            RtpBitReset(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_NOTIFYPENDING);

            pRtcpAddrDesc->lQosPending = 0;
        }
        else if (dwError == WSAENOBUFS)
        {
            /* ProviderSpecific buffer not enough big, reallocate a
             * big one */

            /* Buffer not enough big, I/O completed */
            RtpBitReset(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_NOTIFYPENDING);
            
            pRtcpAddrDesc->lQosPending = 0;
            
            TraceRetail((
                    CLASS_WARNING, GROUP_QOS, S_QOS_NOTIFY,
                    _T("%s: pRtcpAddrDesc[0x%p] Buffer too small: %u"),
                    _fname, pRtcpAddrDesc, pRtpQosNotify->dwProviderLen
                ));
            
            ReallocateQosBuffer(pRtpQosNotify);

            bRestart = TRUE;
        }
        else
        {
            /* Error, I/O completed */
            RtpBitReset(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_NOTIFYPENDING);

            pRtcpAddrDesc->lQosPending = 0;

            /* On any other error, including WSAECONNRESET and
             * WSAEMSGSIZE, re-start I/O */
            bRestart = TRUE;
        }

        pRtpQosNotify->dwError = dwError;
    }
    else
    {
        /* I/O completed normally */
        pRtpQosNotify->dwError = dwError;
        
        RtpBitReset(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_NOTIFYPENDING);

        pRtcpAddrDesc->lQosPending = 0;

        if (pRtpQosNotify->dwTransfered > 0)
        {
            TraceRetail((
                    CLASS_INFO, GROUP_QOS, S_QOS_NOTIFY,
                    _T("%s: pRtcpAddrDesc[0x%p] I/O completed fine, ")
                    _T("Transfered:%u"),
                    _fname, pRtcpAddrDesc, pRtpQosNotify->dwTransfered
                ));
            
            bRestart = TRUE;
        
            /* packet received, scan header */
            RtcpOnReceiveQosNotify(pRtcpAddrDesc);
        }
        else
        {
            /* Something is wrong as there are zero transfered
             * bytes. QOS notifications will stop */
            TraceRetail((
                    CLASS_ERROR, GROUP_QOS, S_QOS_NOTIFY,
                    _T("%s: pRtcpAddrDesc[0x%p] I/O completed fine, ")
                    _T("but Transfered=%u, QOS notifications will stop"),
                    _fname, pRtcpAddrDesc, pRtpQosNotify->dwTransfered
                ));
        }
    }

    if (RtpBitTest(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_SHUTDOWN2))
    {
        /* Shutting down, we were waiting for this completion to
         * happen, remove from QosStopQ. No need to move it to a free
         * list as the pRtcpAddrDesc lives also in other lists on
         * which there is a free list like AddrDescFreeQ */
        dequeue(&pRtcpContext->QosStopQ,
                NULL,
                &pRtcpAddrDesc->QosQItem);
    }
    else
    {
        if (bRestart &&
            !RtpBitTest(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_SHUTDOWN1))
        {
            hr = StartRtcpQosNotify(pRtcpContext, pRtcpAddrDesc); 
        }
        else
        {
            /* Item is left in QosBusyQ, it will be removed by
             * RtcpAddrDescDel (if the I/O is not pending) */
            /* Empty body */
        }
    }

    return(hr);
}

DWORD RtcpOnReceiveQosNotify(RtcpAddrDesc_t *pRtcpAddrDesc)
{
    DWORD            dwError;
    RtpAddr_t       *pRtpAddr;
    RtpQosNotify_t  *pRtpQosNotify;
    QOS             *pQos;
    DWORD            dwEvent;
    DWORD            i;

    TraceFunctionName("RtcpOnReceiveQosNotify");

    pRtpQosNotify = pRtcpAddrDesc->pRtpQosNotify;
    
    /* If notification is valid, pRtpQosNotify->dwError contains the
     * status code (aka the QOS notification) */
    dwError = RtpValidateQosNotification(pRtpQosNotify);

    if (dwError == NOERROR)
    {
        pRtpAddr = pRtcpAddrDesc->pRtpAddr;
        
        pQos = (QOS *)pRtpQosNotify->ProviderInfo;

        /* Obtain the QOS notification */
        dwEvent = pRtpQosNotify->dwError;

        TraceRetail((
                CLASS_INFO, GROUP_QOS, S_QOS_NOTIFY,
                _T("%s: pRtcpAddrDesc[0x%p] pRtpAddr[0x%p] ")
                _T("processing QOS notification: %u"),
                _fname, pRtcpAddrDesc, pRtpAddr, dwEvent
            ));
        
        if (dwEvent >= WSA_QOS_RECEIVERS &&
            dwEvent <= WSA_QOS_RESERVED_PETYPE)
        {
            /* Known QOS notification */
            
            dwEvent -= (WSA_QOS_RECEIVERS - RTPQOS_RECEIVERS);

            /* Update state if needed */
            RtcpUpdateSendState(pRtpAddr, dwEvent);
            
            /* Post event if allowed */
            RtpPostEvent(pRtpAddr,
                         NULL,
                         RTPEVENTKIND_QOS,
                         dwEvent,
                         0,
                         0);

#if DBG > 0
            dumpQOS(_fname, pQos);

            if (pQos->ProviderSpecific.len > 0)
            {
            
                dumpObjectType(_fname,
                               pQos->ProviderSpecific.buf,
                               pQos->ProviderSpecific.len);
            }
#endif
        }
        else
        {
            /* Unknown QOS notification */
            
            TraceRetail((
                    CLASS_ERROR, GROUP_QOS, S_QOS_NOTIFY,
                    _T("%s: pRtcpAddrDesc[0x%p] ")
                    _T("QOS notification out of range: %u (0x%X)"),
                    _fname, pRtcpAddrDesc, dwEvent, dwEvent
                ));
        }
    }
    else
    {
        /* Bad constructed QOS notification */
        TraceRetail((
                CLASS_WARNING, GROUP_QOS, S_QOS_NOTIFY,
                _T("%s: pRtcpAddrDesc[0x%p] ")
                _T("Invalid QOS notification: %s (0x%X)"),
                _fname, pRtcpAddrDesc, RTPERR_TEXT(dwError), dwError
            ));
    }

    return(dwError);
}

/* Buffer is not enough big, obtain one big enough, return TRUE if
 * buffer is available, FALSE otherwise */
BOOL ReallocateQosBuffer(RtpQosNotify_t *pRtpQosNotify)
{
    DWORD            dwNewSize;
    
    TraceFunctionName("ReallocateQosBuffer");

    dwNewSize = 0;
    
    /* Buffer not enough big */
    if (pRtpQosNotify->ProviderInfo)
    {
        dwNewSize = *(DWORD *)pRtpQosNotify->ProviderInfo;

        TraceRetail((
                CLASS_WARNING, GROUP_QOS, S_QOS_NOTIFY,
                _T("%s: pRtpQosNotify[0x%p]: ")
                _T("Buffer not enough big 0x%p/%u, requested: %u"),
                _fname, pRtpQosNotify,
                pRtpQosNotify->ProviderInfo, pRtpQosNotify->dwProviderLen,
                dwNewSize
            ));
    }
                
    if (dwNewSize < QOS_BUFFER_SIZE)
    {
        dwNewSize = QOS_BUFFER_SIZE;
    }
                
    if (dwNewSize > QOS_MAX_BUFFER_SIZE)
    {
        dwNewSize = QOS_MAX_BUFFER_SIZE;
    }
                
    if (dwNewSize > pRtpQosNotify->dwProviderLen)
    {
        /* Free old buffer */
        if (pRtpQosNotify->ProviderInfo)
        {
            RtpHeapFree(g_pRtpQosBufferHeap, pRtpQosNotify->ProviderInfo);
            
            pRtpQosNotify->dwProviderLen = 0;
        }
                    
        /* Allocate new buffer */
        pRtpQosNotify->ProviderInfo = (char *)
            RtpHeapAlloc(g_pRtpQosBufferHeap, dwNewSize);
                    
        if (pRtpQosNotify->ProviderInfo)
        {
            pRtpQosNotify->dwProviderLen = dwNewSize;

            TraceRetail((
                    CLASS_INFO, GROUP_QOS, S_QOS_NOTIFY,
                    _T("%s: pRtpQosNotify[0x%p]: New buffer 0x%p/%u"),
                    _fname, pRtpQosNotify,
                    pRtpQosNotify->ProviderInfo, pRtpQosNotify->dwProviderLen
                ));
            
            return(TRUE);
        }
    }

    return(FALSE);
}

/*
 * Creates and initialize a RtpQosNotify_t structure
 * */
RtpQosNotify_t *RtpQosNotifyAlloc(
        RtcpAddrDesc_t  *pRtcpAddrDesc
    )
{
    DWORD            dwError;
    RtpQosNotify_t  *pRtpQosNotify;
    TCHAR            Name[128];
    
    TraceFunctionName("RtpQosNotifyAlloc");
  
    pRtpQosNotify = RtpHeapAlloc(g_pRtpQosNotifyHeap, sizeof(RtpQosNotify_t));

    if (!pRtpQosNotify) {

        TraceRetail((
                CLASS_ERROR, GROUP_QOS, S_QOS_NOTIFY,
                _T("%s: pRtcpAddrDesc[0x%p failed to allocate memory"),
                _fname, pRtcpAddrDesc
            ));
 
        goto bail;
    }
    
    ZeroMemory(pRtpQosNotify, sizeof(RtpQosNotify_t));

    pRtpQosNotify->dwObjectID = OBJECTID_RTPNOTIFY;

    pRtpQosNotify->pRtcpAddrDesc = pRtcpAddrDesc;
    
    /* Create a named event for overlapped completion */
    _stprintf(Name, _T("%X:pRtpQosNotify[0x%p]->hQosNotifyEvent"),
              GetCurrentProcessId(), pRtpQosNotify);

    pRtpQosNotify->hQosNotifyEvent = CreateEvent(
            NULL,  /* LPSECURITY_ATTRIBUTES lpEventAttributes */
            FALSE, /* BOOL bManualReset */
            FALSE, /* BOOL bInitialState */
            Name   /* LPCTSTR lpName */
        );
    
    if (!pRtpQosNotify->hQosNotifyEvent)
    {
        TraceRetailGetError(dwError);
        
        TraceRetail((
                CLASS_ERROR, GROUP_QOS, S_QOS_NOTIFY,
                _T("%s: pRtcpAddrDesc[0x%p] failed to create ")
                _T("hQosNotifyEvent %u (0x%X)"),
                _fname, pRtcpAddrDesc, dwError, dwError
            ));
        
        goto bail;
    }

    /* Create initial Provider buffer */
    ReallocateQosBuffer(pRtpQosNotify);
    
    return(pRtpQosNotify);

 bail:
    if (pRtpQosNotify)
    {
        RtpQosNotifyFree(pRtpQosNotify);
    }

    return((RtpQosNotify_t *)NULL);
}

/*
 * Deinitilize and frees a RtpQosNotify_t structure
 * */
RtpQosNotify_t *RtpQosNotifyFree(RtpQosNotify_t *pRtpQosNotify)
{
    TraceFunctionName("RtpQosNotifyFree");

    if (!pRtpQosNotify)
    {
        /* TODO may be log */
        return(pRtpQosNotify);
    }
    
    if (pRtpQosNotify->dwObjectID != OBJECTID_RTPNOTIFY)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QOS, S_QOS_NOTIFY,
                _T("%s: pRtpQosNotify[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpQosNotify,
                pRtpQosNotify->dwObjectID, OBJECTID_RTPNOTIFY
            ));

        return(NULL);
    }

    /* Close event for asynchronous QOS notifications */
    if (pRtpQosNotify->hQosNotifyEvent)
    {
        CloseHandle(pRtpQosNotify->hQosNotifyEvent);
        pRtpQosNotify->hQosNotifyEvent = NULL;
    }

    /* Release provider buffer */
    if (pRtpQosNotify->ProviderInfo)
    {
        RtpHeapFree(g_pRtpQosBufferHeap, pRtpQosNotify->ProviderInfo);
        
        pRtpQosNotify->ProviderInfo = NULL;
        
        pRtpQosNotify->dwProviderLen = 0;
    }

    /* Invalidate object */
    INVALIDATE_OBJECTID(pRtpQosNotify->dwObjectID);
    
    /* Release main block */
    RtpHeapFree(g_pRtpQosNotifyHeap, pRtpQosNotify);

    return(pRtpQosNotify);
}

/*+++

  Description:

        This routine generates the application identity PE given the
        name and policy locator strings for the application.

        szAppName is used to construct the CREDENTIAL attribute of the
        Identity PE. Its subtype is set to ASCII_ID.

        szPolicyLocator is used to construct the POLICY_LOCATOR
        attribute of the Identity PE. Its subtype is set to ASCII_DN.

        Refer to draft-ietf-rap-rsvp-identity-03.txt and
        draft-bernet-appid-00.txt for details on the Identity Policy
        Elements.  Also draft-bernet-appid-00.txt conatins some
        examples for arguments szPolicyLocator and szAppName.

        The PE is generated in the supplied buffer. If the length of
        the buffer is not enough, zero is returned.

    Parameters:  szAppName          app name, string, caller supply
                 szPolicyLocator    Policy Locator string, caller supply
                 wBufLen            length of caller allocated buffer
                 pAppIdBuf          pointer to caller allocated buffer

    Return Values:
        Number of bytes used from buffer
---*/
DWORD AddQosAppID(
        IN OUT  char       *pAppIdBuf,
        IN      TCHAR_t    *psAppName,
        IN      TCHAR_t    *psAppGUID,
        IN      TCHAR_t    *psClass,
        IN      TCHAR_t    *psQosName,
        IN      TCHAR_t    *psPolicyLocator
    )
{
    int              len;
    RSVP_POLICY_INFO *pPolicyInfo;
    RSVP_POLICY     *pPolicy;
    IDPE_ATTR       *pAttr;
    TCHAR_t         *ptr;
    USHORT           nAppIdAttrLen;
    USHORT           nPolicyLocatorAttrLen;
    USHORT           nTotalPaddedLen;

    TraceFunctionName("AddQosAppID");

    /* Set the RSVP_POLICY_INFO header */
    pPolicyInfo = (RSVP_POLICY_INFO *)pAppIdBuf;
    
    /* Now set up RSVP_POLICY object header */
    pPolicy = pPolicyInfo->PolicyElement;

    /* The first application id attribute is the policy locator string */
    pAttr = ( IDPE_ATTR * )( (char *)pPolicy + RSVP_POLICY_HDR_LEN );

    /*
     * Policy locator = GUID + App name + Default policy + class + codec name
     *                  [+ Append]
     */

    /* Fill up the attribute policy locator */
    ptr = (TCHAR_t *)pAttr->PeAttribValue;
    len = 0;

    if (psAppGUID)
    {
        len = _stprintf(ptr, _T("GUID=%s,"), psAppGUID);
        ptr += len;
    }
    
    len = _stprintf(ptr, _T("APP=%s%s%s,SAPP=%s"),
                    psAppName, g_sPolicyLocator, psClass, psQosName);
    ptr += len;

    if (psPolicyLocator)
    {
        _stprintf(ptr, _T(",%s"), psPolicyLocator);
    }
    
    nPolicyLocatorAttrLen = (USHORT)
        (lstrlen((TCHAR_t *)pAttr->PeAttribValue) + 1) * sizeof(TCHAR_t);

    nPolicyLocatorAttrLen += IDPE_ATTR_HDR_LEN;

    /* Attribute length must be in network order. */
    pAttr->PeAttribType     = PE_ATTRIB_TYPE_POLICY_LOCATOR;
    pAttr->PeAttribSubType  = POLICY_LOCATOR_SUB_TYPE_UNICODE_DN;
    pAttr->PeAttribLength   = htons(nPolicyLocatorAttrLen);

    TraceRetail((
            CLASS_INFO, GROUP_QOS, S_QOS_RESERVE,
            _T("%s: Setting policy to:[%s]"),
            _fname, (TCHAR_t *)pAttr->PeAttribValue
        ));

    /*
     * Application name = default | psAppName
     */
  
    pAttr = ( IDPE_ATTR * )( (char *)pAttr +
                             RSVP_BYTE_MULTIPLE( nPolicyLocatorAttrLen ) );

    lstrcpy((TCHAR_t *)pAttr->PeAttribValue, psAppName);

    nAppIdAttrLen = (SHORT) ((lstrlen(psAppName) + 1) * sizeof(TCHAR_t));

    nAppIdAttrLen += IDPE_ATTR_HDR_LEN;

    pAttr->PeAttribType     = PE_ATTRIB_TYPE_CREDENTIAL;
    pAttr->PeAttribSubType  = CREDENTIAL_SUB_TYPE_UNICODE_ID;
    pAttr->PeAttribLength   = htons(nAppIdAttrLen);
    
    TraceRetail((
            CLASS_INFO, GROUP_QOS, S_QOS_RESERVE,
            _T("%s: Setting app ID to:[%s]"),
            _fname, (TCHAR_t *)pAttr->PeAttribValue
        ));

    /*
     * Fill up QOS headers
     */
    nTotalPaddedLen =
        sizeof(RSVP_POLICY_INFO) -
        sizeof(RSVP_POLICY) +
        RSVP_POLICY_HDR_LEN +
        RSVP_BYTE_MULTIPLE( nAppIdAttrLen ) +
        RSVP_BYTE_MULTIPLE( nPolicyLocatorAttrLen );

    pPolicyInfo->ObjectHdr.ObjectType = RSVP_OBJECT_POLICY_INFO;
    pPolicyInfo->ObjectHdr.ObjectLength = nTotalPaddedLen;
    pPolicyInfo->NumPolicyElement = 1;

    pPolicy->Type = PE_TYPE_APPID;
    pPolicy->Len =
        RSVP_POLICY_HDR_LEN + 
        RSVP_BYTE_MULTIPLE( nAppIdAttrLen ) +
        RSVP_BYTE_MULTIPLE( nPolicyLocatorAttrLen );

    return(nTotalPaddedLen);
}

/**********************************************************************
 * Validate QOS buffer
 **********************************************************************/
DWORD RtpValidateQosNotification(RtpQosNotify_t *pRtpQosNotify)
{
    DWORD            dwError;
    QOS_OBJECT_HDR  *pObjHdr;
    QOS             *pQos;
    RSVP_STATUS_INFO *pRsvpStatusInfo;
    int              len;

    TraceFunctionName("RtpValidateQosNotification");

    dwError = RTPERR_UNDERRUN;

    len = (int)pRtpQosNotify->dwTransfered;
    
    if (len == 0)
    {
        /* Underrun error, a non empty buffer was expected */

        TraceRetail((
                CLASS_WARNING, GROUP_QOS, S_QOS_NOTIFY,
                _T("%s: pRtpQosNotify[0x%p] failed: ")
                _T("notification with size:%u"),
                _fname, pRtpQosNotify, pRtpQosNotify->dwTransfered
            ));
        
        goto end;
    }
    
    if (len > (int)pRtpQosNotify->dwProviderLen)
    {
        /* Overrun error, transfered more than the buffer size ! */
        dwError = RTPERR_OVERRUN;

        TraceRetail((
                CLASS_WARNING, GROUP_QOS, S_QOS_NOTIFY,
                _T("%s: pRtpQosNotify[0x%p] failed: transfered more ")
                _T("than the provider size: %u > %u"),
                _fname, pRtpQosNotify, len, pRtpQosNotify->dwTransfered
            ));
        
        goto end;
    }
    
    len -= sizeof(QOS);

    if (len < 0)
    {
        /* Underrun error, size not enough to contain the expected QOS
         * structure at the begining of buffer */

        TraceRetail((
                CLASS_WARNING, GROUP_QOS, S_QOS_NOTIFY,
                _T("%s: pRtpQosNotify[0x%p] failed: ")
                _T("not enough data for a QOS structure: %u < %u"),
                _fname, pRtpQosNotify, pRtpQosNotify->dwTransfered, sizeof(QOS)
            ));
        
        goto end;
    }

    pQos = (QOS *)pRtpQosNotify->ProviderInfo;
    
    if ((pQos->ProviderSpecific.len == 0) || !pQos->ProviderSpecific.buf)
    {
        /* No provider buffer, finish */
        dwError = NOERROR;
        goto end;
    }
    
    if (len < (int)pQos->ProviderSpecific.len)
    {
        /* Underrun error, transfered data is not enough to contain
         * what the provider specific claims */

        TraceRetail((
                CLASS_WARNING, GROUP_QOS, S_QOS_NOTIFY,
                _T("%s: pRtpQosNotify[0x%p] ")
                _T("failed: invalid provider len: %u > %u"),
                _fname, pRtpQosNotify, pQos->ProviderSpecific.len, len
            ));
        
        goto end;
    }

    pObjHdr = (QOS_OBJECT_HDR *)(pQos + 1);
    
    while(len >= (int)sizeof(QOS_OBJECT_HDR))
    {
        len -= pObjHdr->ObjectLength;

        if (len >= 0)
        {
            if (pObjHdr->ObjectLength == 0)
            {
                /* Safety exit */
                break;
            }
            
            if (pObjHdr->ObjectType == QOS_OBJECT_END_OF_LIST)
            {
                /* Finish */
                break;
            }
            else if (pObjHdr->ObjectType == RSVP_OBJECT_STATUS_INFO)
            {
                /* Update pRtpQosNotify->dwError with the status code
                 * (aka the QOS notification) */
                pRsvpStatusInfo = (RSVP_STATUS_INFO *)pObjHdr;

                pRtpQosNotify->dwError = pRsvpStatusInfo->StatusCode;
            }

            pObjHdr = (QOS_OBJECT_HDR *)
                ((char *)pObjHdr + pObjHdr->ObjectLength);
        }
        else
        {
            /* Underrun error, remaining data is not enough to contain
             * what the QOS object header indicates */
            TraceRetail((
                    CLASS_WARNING, GROUP_QOS, S_QOS_NOTIFY,
                    _T("%s: pRtpQosNotify[0x%p] ")
                    _T("failed: invalid object size: %u > %u"),
                    _fname, pRtpQosNotify, pObjHdr->ObjectLength,
                    pObjHdr->ObjectLength + len
                ));
        }
    }

    if (len >= 0)
    {
        dwError = NOERROR;
    }

 end:
    
    return(dwError);
}

DWORD RtpSetMaxParticipants(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwMaxParticipants
    )
{
    DWORD            dwError;
    RtpQosReserve_t *pRtpQosReserve;

    TraceFunctionName("RtpSetMaxParticipants");

    dwError = NOERROR;
    
    pRtpQosReserve = pRtpAddr->pRtpQosReserve;

    if (pRtpQosReserve->dwMaxFilters == dwMaxParticipants)
    {
        /* Number of filters hasn't changed */
        goto bail;
    }

    /* MAYDO check for a number of participants too big */

    if (pRtpQosReserve->dwStyle == RTPQOS_STYLE_SE)
    {
        /* This ONLY used in SE style */
        
        /* If have previously allocated memory, free it */
        if (pRtpQosReserve->pdwRsvpSSRC)
        {
            RtpHeapFree(g_pRtpQosReserveHeap, pRtpQosReserve->pdwRsvpSSRC);
        
            RtpHeapFree(g_pRtpQosReserveHeap, pRtpQosReserve->pRsvpFilterSpec);
        }

        pRtpQosReserve->pdwRsvpSSRC = (DWORD *)
            RtpHeapAlloc(g_pRtpQosReserveHeap,
                         dwMaxParticipants * sizeof(DWORD));

        pRtpQosReserve->pRsvpFilterSpec = (RSVP_FILTERSPEC *)
            RtpHeapAlloc(g_pRtpQosReserveHeap,
                         dwMaxParticipants * sizeof(RSVP_FILTERSPEC));

        if (!pRtpQosReserve->pdwRsvpSSRC || !pRtpQosReserve->pRsvpFilterSpec)
        {
            if (pRtpQosReserve->pdwRsvpSSRC)
            {
                RtpHeapFree(g_pRtpQosReserveHeap, pRtpQosReserve->pdwRsvpSSRC);

                pRtpQosReserve->pdwRsvpSSRC = NULL;
            }

            if (pRtpQosReserve->pRsvpFilterSpec)
            {
                RtpHeapFree(g_pRtpQosReserveHeap,
                            pRtpQosReserve->pRsvpFilterSpec);

                pRtpQosReserve->pRsvpFilterSpec = NULL;
            }
        
            pRtpQosReserve->dwMaxFilters = 0;

            dwError = RTPERR_MEMORY;

            goto bail;
        }
    }

    pRtpQosReserve->dwMaxFilters = dwMaxParticipants;

    TraceRetail((
            CLASS_INFO, GROUP_QOS, S_QOS_RESERVE,
            _T("%s: pRtpQosReserve[0x%p] Max filters:%u"),
            _fname, pRtpQosReserve,
            dwMaxParticipants
        ));
    
 bail:
    if (dwError != NOERROR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QOS, S_QOS_RESERVE,
                _T("%s: pRtpQosReserve[0x%p] failed: %u (0x%X)"),
                _fname, pRtpQosReserve,
                dwError, dwError
            ));
    }
    
    return(dwError);
}

/* Add/Delete one SSRC (participant) to the Shared Explicit Filter
 * (SEF) list 0==delete; other==add */
DWORD RtpAddDeleteSSRC(
        RtpAddr_t       *pRtpAddr,
        RtpQosReserve_t *pRtpQosReserve,
        DWORD            dwSSRC,
        BOOL             bAddDel
    )
{
    DWORD            dwNumber;
    DWORD            i;
    DWORD           *pdwRsvpSSRC;
    RSVP_FILTERSPEC *pRsvpFilterSpec;

    DWORD           *dwSSRC1;
    DWORD           *dwSSRC2;
    RSVP_FILTERSPEC *pRsvp1;
    RSVP_FILTERSPEC *pRsvp2;

    RtpUser_t       *pRtpUser;
    BOOL             bCreate;
    
    TraceFunctionName("RtpAddDeleteSSRC");

    dwNumber = 1;
    
    /* Lookup the SSRC and find out if it is already in the priority
     * list */

    pdwRsvpSSRC = pRtpQosReserve->pdwRsvpSSRC;
    pRsvpFilterSpec = pRtpQosReserve->pRsvpFilterSpec;
    
    for(i = 0;
        (i < pRtpQosReserve->dwNumFilters) && (dwSSRC != pdwRsvpSSRC[i]);
        i++)
    {
        ;
    }

    if (i < pRtpQosReserve->dwNumFilters)
    {
        /* SSRC is in list */

        if (bAddDel)
        {
            /*
             * ******* ADD *******
             */
            
            /* do nothing, already in list */
            TraceDebug((
                    CLASS_INFO, GROUP_QOS, S_QOS_RESERVE,
                    _T("%s: pRtpAddr[0x%p] pRtpReserve[0x%p] ")
                    _T("ADD SSRC:0x%X ")
                    _T("Already in priority list"),
                    _fname, pRtpAddr, pRtpQosReserve,
                    ntohl(dwSSRC)
                ));
        }
        else
        {
            /*
             * ******* DELETE *******
             */

            /* remove from list */
            pRsvp1 = &pRsvpFilterSpec[i];
            pRsvp2 = pRsvp1 + 1;

            dwSSRC1 = &pdwRsvpSSRC[i];
            dwSSRC2 = dwSSRC1 + 1;
                
            for(pRtpQosReserve->dwNumFilters--;
                i < pRtpQosReserve->dwNumFilters;
                pRsvp1++, pRsvp2++, dwSSRC1++, dwSSRC2++, i++)
            {
                MoveMemory(pRsvp1, pRsvp2, sizeof(*pRsvp1));
                *dwSSRC1 = *dwSSRC2;
            }

            TraceDebug((
                    CLASS_INFO, GROUP_QOS, S_QOS_RESERVE,
                    _T("%s: pRtpAddr[0x%p] pRtpReserve[0x%p] ")
                    _T("DEL SSRC:0x%X ")
                    _T("Deleted from priority list"),
                    _fname, pRtpAddr, pRtpQosReserve,
                    ntohl(dwSSRC)
                ));
        }
    }
    else
    {
        /* SSRC not in list */

        if (bAddDel)
        {
            /*
             * ******* ADD *******
             */
 
            /* add to the list */

            dwNumber = 0;
            
            /* Check if we can add 1 more SSRC to the list */
            if (pRtpQosReserve->dwNumFilters < pRtpQosReserve->dwMaxFilters)
            {
                bCreate = FALSE;
                
                pRtpUser = LookupSSRC(pRtpAddr, dwSSRC, &bCreate);

                if (pRtpUser)
                {
                    if (RtpBitTest(pRtpUser->dwUserFlags, FGUSER_RTPADDR))
                    {
                        pRsvp1 =
                            &pRsvpFilterSpec[pRtpQosReserve->dwNumFilters];

                        ZeroMemory(pRsvp1, sizeof(*pRsvp1));
                        
                        pRsvp1->Type = FILTERSPECV4;

                        pRsvp1->FilterSpecV4.Address.Addr =
                            pRtpUser->dwAddr[RTP_IDX];

                        pRsvp1->FilterSpecV4.Port =
                            pRtpUser->wPort[RTP_IDX];

                        pdwRsvpSSRC[pRtpQosReserve->dwNumFilters] = dwSSRC;
                            
                        pRtpQosReserve->dwNumFilters++;

                        TraceDebug((
                                CLASS_INFO, GROUP_QOS, S_QOS_RESERVE,
                                _T("%s: pRtpAddr[0x%p] pRtpReserve[0x%p] ")
                                _T("ADD SSRC:0x%X ")
                                _T("Added to the priority list"),
                                _fname, pRtpAddr, pRtpQosReserve,
                                ntohl(dwSSRC)
                            ));
                        
                        dwNumber = 1;
                    }
                    else
                    {
                        TraceRetail((
                                CLASS_WARNING, GROUP_QOS, S_QOS_RESERVE,
                                _T("%s: pRtpAddr[0x%p] pRtpReserve[0x%p] ")
                                _T("ADD SSRC:0x%X ")
                                _T("No address available yet"),
                                _fname, pRtpAddr, pRtpQosReserve,
                                ntohl(dwSSRC)
                            ));
                    }
                }
                else
                {
                    TraceRetail((
                            CLASS_WARNING, GROUP_QOS, S_QOS_RESERVE,
                            _T("%s: pRtpAddr[0x%p] pRtpReserve[0x%p] ")
                            _T("ADD SSRC:0x%X ")
                            _T("Unknown SSRC"),
                            _fname, pRtpAddr, pRtpQosReserve,
                            ntohl(dwSSRC)
                        ));
                }
            }
        }
        else
        {
            /*
             * ******* DELETE *******
             */

            /* do nothing, not in list */
            TraceDebug((
                    CLASS_INFO, GROUP_QOS, S_QOS_RESERVE,
                    _T("%s: pRtpAddr[0x%p] pRtpReserve[0x%p] ")
                    _T("DEL SSRC:0x%X ")
                    _T("Not in priority list"),
                    _fname, pRtpAddr, pRtpQosReserve,
                    ntohl(dwSSRC)
                ));
        }
    } /* not in list */

    return(dwNumber);
}

BOOL RtcpUpdateSendState(
        RtpAddr_t   *pRtpAddr,
        DWORD        dwEvent
    )
{
    BOOL             bSendState;

    bSendState = TRUE;
    
    if (!RtpBitTest(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSSENDON) ||
        !RtpBitTest(pRtpAddr->dwAddrFlagsQ, FGADDRQ_CHKQOSSEND))
    {
        /* If QOS is not set yet for senders, or we are not asked to
         * check for allowed to send, just return */
        goto end;
    }
    
    if (dwEvent == RTPQOS_RECEIVERS)
    {
        /* Enable sending at full rate */
        RtpBitSet(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSSEND);

        if (RtpBitTest(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSEVENTPOSTED))
        {
            /* Post allowed to send only if not allowed to send was
             * posted before */
            RtpPostEvent(pRtpAddr,
                         NULL,
                         RTPEVENTKIND_QOS,
                         RTPQOS_ALLOWEDTOSEND,
                         0,
                         0);

            RtpBitReset(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSEVENTPOSTED);
        }
    }
    else if (dwEvent == RTPQOS_NO_RECEIVERS)
    {
        /* Check for permission to send again */
        bSendState = RtpIsAllowedToSend(pRtpAddr);

        if (bSendState)
        {
            RtpBitSet(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSSEND); 
        }
        else
        {
            if (!RtpBitTest(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSEVENTPOSTED))
            {
                /* Post allowed to send only if not allowed to send
                 * was posted before */
                RtpPostEvent(pRtpAddr,
                             NULL,
                             RTPEVENTKIND_QOS,
                             RTPQOS_NOT_ALLOWEDTOSEND,
                             0,
                             0);

                RtpBitSet(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSEVENTPOSTED);
            }

            RtpBitReset(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSSEND);
        }
    }
    else
    {
        bSendState = RtpBitTest(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSSEND)?
            TRUE : FALSE;
    }

 end:
    return(bSendState);
}

BOOL RtpIsAllowedToSend(RtpAddr_t *pRtpAddr)
{
    bool_t           bFail;
    bool_t           bAllowedToSend;
    DWORD            dwError;
    DWORD            dwRequest;
    DWORD            dwResult;
    DWORD            dwBytesReturned;

    TraceFunctionName("RtpIsAllowedToSend");

    dwRequest = ALLOWED_TO_SEND_DATA;
    dwBytesReturned = 0;

    if (IsRegValueSet(g_RtpReg.dwQosFlags) &&
        RtpBitTest(g_RtpReg.dwQosFlags, FGREGQOS_FORCE_ALLOWEDTOSEND))
    {
        /* Force the result of the query to be a certain value */
        bFail = 0;
        dwResult = RtpBitTest(g_RtpReg.dwQosFlags,
                              FGREGQOS_FORCE_ALLOWEDTOSEND_RESULT);

        TraceRetail((
                CLASS_WARNING, GROUP_QOS, S_QOS_RESERVE,
                _T("%s: pRtpAddr[0x%p] ")
                _T("Result being forced from the registry"),
                _fname, pRtpAddr
            ));
    }
    else
    {
        /* Really query RSVPSP */
        bFail = WSAIoctl(pRtpAddr->Socket[SOCK_SEND_IDX],
                         SIO_CHK_QOS,
                         (LPVOID)&dwRequest,
                         sizeof(dwRequest),
                         (LPVOID)&dwResult,
                         sizeof(dwResult),
                         &dwBytesReturned,
                         NULL,
                         NULL);
    }

    if (bFail)
    {
        TraceRetailWSAGetError(dwError);

        TraceRetail((
                CLASS_WARNING, GROUP_QOS, S_QOS_RESERVE,
                _T("%s: pRtpAddr[0x%p] ")
                _T("WSAIoctl(%u, SIO_CHK_QOS) failed: %u (0x%X)"),
                _fname, pRtpAddr,
                pRtpAddr->Socket[SOCK_SEND_IDX],
                dwError, dwError
            ));
        
        /* For safety, on failure say allowed */
        bAllowedToSend = TRUE;
    }
    else
    {
        bAllowedToSend = dwResult? TRUE : FALSE;
    }

    TraceRetail((
            CLASS_INFO, GROUP_QOS, S_QOS_RESERVE,
            _T("%s: pRtpAddr[0x%p] ")
            _T("Allowed to send:%s"),
            _fname, pRtpAddr, bAllowedToSend? _T("YES") : _T("NO")
        ));

    return(bAllowedToSend);
}

/**********************************************************************
 * Dump QOS structures
 **********************************************************************/
#if DBG > 0
void dumpFlowSpec(TCHAR_t *str, FLOWSPEC *pFlowSpec)
{
    _stprintf(str,
              _T("TokenRate:%d, ")
              _T("TokenBucketSize:%d, ")
              _T("PeakBandwidth:%d, ")
              _T("ServiceType:%d ")
              _T("MaxSduSize:%d ")
              _T("MinPolicedSize:%d"),
              pFlowSpec->TokenRate,
              pFlowSpec->TokenBucketSize,
              pFlowSpec->PeakBandwidth,
              pFlowSpec->ServiceType,
              pFlowSpec->MaxSduSize,
              pFlowSpec->MinimumPolicedSize
        );
}

void dumpQOS(const TCHAR_t *msg, QOS *pQOS)
{
    TCHAR_t          str[256];
    
    dumpFlowSpec(str, &pQOS->SendingFlowspec);
    TraceDebug((
            CLASS_INFO, GROUP_QOS, S_QOS_DUMPOBJ,
            _T("%s: SendingFlowspec:   %s"),
            msg, str
        ));

    dumpFlowSpec(str, &pQOS->ReceivingFlowspec);
    TraceDebug((
            CLASS_INFO, GROUP_QOS, S_QOS_DUMPOBJ,
            _T("%s: ReceivingFlowspec: %s"),
            msg, str
        ));
}

void dumpSTATUS_INFO(const TCHAR_t *msg, RSVP_STATUS_INFO *object)
{
    DWORD            dwIndex;

    dwIndex = object->StatusCode - WSA_QOS_RECEIVERS + RTPQOS_RECEIVERS;
    
    if (dwIndex >= RTPQOS_LAST)
    {
        dwIndex = 0;
    }
        
    TraceDebug((
            CLASS_INFO, GROUP_QOS, S_QOS_DUMPOBJ,
            _T("%s: RSVP_STATUS_INFO: ")
            _T("StatusCode: %d %s, ")
            _T("ExStatus1: %d, ")
            _T("ExStatus2: %d"),
            msg, object->StatusCode, g_psRtpQosEvents[dwIndex],
            object->ExtendedStatus1, 
            object->ExtendedStatus2
        ));
}

void dumpRESERVE_INFO(const TCHAR_t *msg, RSVP_RESERVE_INFO *object)
{
    TraceDebug((
            CLASS_INFO, GROUP_QOS, S_QOS_DUMPOBJ,
            _T("%s: RSVP_RESERVE_INFO: ")
            _T("Style: %d, ")
            _T("ConfirmRequest: %d, ")
            _T("PolicyElementList: %s, ")
            _T("NumFlowDesc: %d"),
            msg, object->Style,
            object->ConfirmRequest,
            (object->PolicyElementList)? _T("Yes") : _T("No"),
            object->NumFlowDesc
        ));
}

#define MAX_SERVICES 8

void dumpADSPEC(const TCHAR_t *msg, RSVP_ADSPEC *object)
{
    TCHAR_t          str[256];
    DWORD            i;

    TraceDebug((
            CLASS_INFO, GROUP_QOS, S_QOS_DUMPOBJ,
            _T("%s: RSVP_ADSPEC: %d Service(s)"),
            msg, object->NumberOfServices
        ));

    str[0] = _T('\0');
    
    for(i = 0; i < object->NumberOfServices && i < MAX_SERVICES; i++)
    {
        _stprintf(str,
                  _T("Service[%d]: %d, Guaranteed: ")
                  _T("CTotal: %d, ")
                  _T("DTotal: %d, ")
                  _T("CSum: %d, ")
                  _T("DSum: %d"),
                i,
                object->Services[i].Service,
                object->Services[i].Guaranteed.CTotal,
                object->Services[i].Guaranteed.DTotal,
                object->Services[i].Guaranteed.CSum,
                object->Services[i].Guaranteed.DSum);

        TraceDebug((
                CLASS_INFO, GROUP_QOS, S_QOS_DUMPOBJ,
                _T("%s: %s"),
                msg, str
            ));
    }
}

void dumpPE_ATTR(const TCHAR_t *msg, IDPE_ATTR *pIdpeAttr, DWORD len)
{
    TCHAR_t          str[1024];
    USHORT           slen;
    TCHAR_t         *psFormat;

    while(len >= sizeof(IDPE_ATTR))
    {
        if (pIdpeAttr->PeAttribSubType == POLICY_LOCATOR_SUB_TYPE_UNICODE_DN)
        {
            psFormat =
                _T("IDPE_ATTR: ")
                _T("PeAttribLength:%u PeAttribType:%u ")
                _T("PeAttribSubType:%u PeAttribValue[%ls]");
        }
        else
        {
            psFormat =
                _T("IDPE_ATTR: ")
                _T("PeAttribLength:%u PeAttribType:%u ")
                _T("PeAttribSubType:%u PeAttribValue[%hs]");
        }

        _stprintf(str, psFormat,
                  (DWORD)ntohs(pIdpeAttr->PeAttribLength),
                  (DWORD)pIdpeAttr->PeAttribType,
                  (DWORD)pIdpeAttr->PeAttribSubType,
                  pIdpeAttr->PeAttribValue);
        
        TraceDebug((
                CLASS_INFO, GROUP_QOS, S_QOS_DUMPOBJ,
                _T("%s: %s"),
                msg, str
            ));
        
        slen = ntohs(pIdpeAttr->PeAttribLength);
        
        slen = RSVP_BYTE_MULTIPLE(slen);

        if (!slen || slen > (USHORT)len)
        {
            break;  /* Safety exit */
        }
        
        len -= slen;
        
        pIdpeAttr = (IDPE_ATTR *) ((char *)pIdpeAttr + slen);
    }
  
}

void dumpPOLICY(const TCHAR_t *msg, RSVP_POLICY *pRsvpPolicy)
{
    TCHAR_t          str[256];
    DWORD            len;
    IDPE_ATTR       *pIdpeAttr;
    
    _stprintf(str,
              _T("RSVP_POLICY: Len:%u Type:%u"),
              (DWORD)pRsvpPolicy->Len, (DWORD)pRsvpPolicy->Type);

    TraceDebug((
            CLASS_INFO, GROUP_QOS, S_QOS_DUMPOBJ,
            _T("%s: %s"),
            msg, str
        ));

    len = pRsvpPolicy->Len - RSVP_POLICY_HDR_LEN;
    
    pIdpeAttr = (IDPE_ATTR *)
        ((char *)pRsvpPolicy + RSVP_POLICY_HDR_LEN);
    
    dumpPE_ATTR(msg, pIdpeAttr, len);
}

void dumpPOLICY_INFO(const TCHAR_t *msg, RSVP_POLICY_INFO *object)
{
    TCHAR_t         str[256];
    char            *ptr;
    DWORD            i;
    int              len;
    RSVP_POLICY     *pRsvpPolicy;

    TraceDebug((
            CLASS_INFO, GROUP_QOS, S_QOS_DUMPOBJ,
            _T("%s: RSVP_POLICY_INFO: NumPolicyElement: %u"),
            msg, object->NumPolicyElement
        ));

    ptr = (char *)&object->PolicyElement[0];

    len = object->ObjectHdr.ObjectLength;
    
    len -= (PtrToUlong(ptr) - PtrToUlong(object));

    for(i = object->NumPolicyElement;
        (i > 0) && (len >= sizeof(RSVP_POLICY));
        i--)
    {
        pRsvpPolicy = (RSVP_POLICY *)ptr;

        if (len < pRsvpPolicy->Len)
        {
            /* Unexpected condition */
            TraceDebug((
                    CLASS_ERROR, GROUP_QOS, S_QOS_DUMPOBJ,
                    _T("%s: UNDERRUN error found by dumpPOLICY_INFO"),
                    msg
                ));
            /* Usually all the ERROR logs are retail, but this
             * function is availiable only in debug builds, that's why
             * I have the above TraceDebug sending an ERROR message */
            return;
        }
        
        dumpPOLICY(msg, pRsvpPolicy);

        ptr += pRsvpPolicy->Len;

        len -= pRsvpPolicy->Len;
    }
}

void dumpObjectType(const TCHAR_t *msg, char *ptr, unsigned int len)
{
    QOS_OBJECT_HDR  *pObjHdr;
        
    while(len >= sizeof(QOS_OBJECT_HDR))
    {
        pObjHdr = (QOS_OBJECT_HDR *)ptr;

        if (len >= pObjHdr->ObjectLength)
        {
            switch(pObjHdr->ObjectType) {
            case RSVP_OBJECT_STATUS_INFO:
                dumpSTATUS_INFO(msg, (RSVP_STATUS_INFO *)pObjHdr);
                break;
            case RSVP_OBJECT_RESERVE_INFO:
                dumpRESERVE_INFO(msg, (RSVP_RESERVE_INFO *)pObjHdr);
                break;
            case RSVP_OBJECT_ADSPEC:
                dumpADSPEC(msg, (RSVP_ADSPEC *)pObjHdr);
                break;
            case RSVP_OBJECT_POLICY_INFO:
                dumpPOLICY_INFO(msg, (RSVP_POLICY_INFO *)pObjHdr);
                break;
            case QOS_OBJECT_END_OF_LIST:
                len = pObjHdr->ObjectLength; // Finish
                break;
            default:
                // don't have code to decode this, skip it
                break;
            }

            ptr += pObjHdr->ObjectLength;

            if (!pObjHdr->ObjectLength || pObjHdr->ObjectLength > len)
            {
                break; /* Safety exit */
            }
            
            len -= pObjHdr->ObjectLength;
        }
        else
        {
            // Error
            len = 0;
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\msrtp\funcs\rtprtp.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtprtp.c
 *
 *  Abstract:
 *
 *    Implements the RTP specific family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/07 created
 *
 **********************************************************************/

#include "struct.h"
#include "rtprtp.h"
#include "rtcpthrd.h"

HRESULT ControlRtpRtp(RtpControlStruct_t *pRtpControlStruct)
{

    return(NOERROR);
}

/* Set the bandwidth limits. A value of -1 will make the parameter
 * to be ignored.
 *
 * All the parameters are in bits/sec */
DWORD RtpSetBandwidth(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwInboundBw,
        DWORD            dwOutboundBw,
        DWORD            dwReceiversRtcpBw,
        DWORD            dwSendersRtcpBw
    )
{
    RtpNetSState_t  *pRtpNetSState;
    DWORD            dwOverallBw;
    
    TraceFunctionName("RtpSetBandwidth");
    
    pRtpNetSState = &pRtpAddr->RtpNetSState;
    
    if (IsDWValueSet(dwInboundBw))
    {
        if (pRtpNetSState->dwInboundBandwidth != dwInboundBw)
        {
            pRtpNetSState->dwInboundBandwidth = dwInboundBw;

            /* Need to update reservations if receiver has QOS ON */
            if (RtpBitTest(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSRECVON))
            {
                /* Make a new QOS reservation */
                RtcpThreadCmd(&g_RtcpContext,
                              pRtpAddr,
                              RTCPTHRD_RESERVE,
                              RECV_IDX,
                              DO_NOT_WAIT);
            }
        }
    }

    if (IsDWValueSet(dwOutboundBw))
    {
        if (pRtpNetSState->dwOutboundBandwidth != dwOutboundBw)
        {
            pRtpNetSState->dwOutboundBandwidth = dwOutboundBw;

            /* Need to update the sender flowspec if sender has QOS ON */
            if (RtpBitTest(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSSENDON))
            {
                /* Modify the flowspec sent in PATH messages */
                RtcpThreadCmd(&g_RtcpContext,
                              pRtpAddr,
                              RTCPTHRD_RESERVE,
                              SEND_IDX,
                              DO_NOT_WAIT);
            }
        }
    }

    dwOverallBw =
        pRtpNetSState->dwInboundBandwidth + pRtpNetSState->dwOutboundBandwidth;
    
    if (IsDWValueSet(dwReceiversRtcpBw))
    {
        if (pRtpNetSState->dwRtcpBwReceivers != dwReceiversRtcpBw)
        {
            pRtpNetSState->dwRtcpBwReceivers = dwReceiversRtcpBw;

            RtpBitSet(pRtpNetSState->dwNetSFlags, FGNETS_RTCPRECVBWSET);
        }
    }
    else
    {
        /* Compute a default value if none has been set */
        if (!RtpBitTest(pRtpNetSState->dwNetSFlags, FGNETS_RTCPRECVBWSET))
        {
            /* Give to receivers 25% out of the 5% used for RTCP */
            pRtpNetSState->dwRtcpBwReceivers =
                dwOverallBw * (25 * 5) / 10000;  
        }
    }

    if (IsDWValueSet(dwSendersRtcpBw))
    {
        if (pRtpNetSState->dwRtcpBwSenders != dwSendersRtcpBw)
        {
            pRtpNetSState->dwRtcpBwSenders = dwSendersRtcpBw;

            RtpBitSet(pRtpNetSState->dwNetSFlags, FGNETS_RTCPSENDBWSET);
        }
    }
    else
    {
        /* Compute a default value if none has been set */
        if (!RtpBitTest(pRtpNetSState->dwNetSFlags, FGNETS_RTCPSENDBWSET))
        {
            /* Give to senders 75% out of the 5% used for RTCP */
            pRtpNetSState->dwRtcpBwReceivers =
                dwOverallBw * (75 * 5) / 10000;  
        }
    }

    TraceRetail((
            CLASS_INFO, GROUP_RTP, S_RTP_SETBANDWIDTH,
            _T("%s: pRtpAddr[0x%p] ")
            _T("Inbound:%d/%d Outbound:%d/%d ")
            _T("RTCP Receivers:%d/%d RTCP Senders:%d/%d"),
            _fname, pRtpAddr,
            dwInboundBw, pRtpNetSState->dwInboundBandwidth,
            dwOutboundBw, pRtpNetSState->dwOutboundBandwidth,
            dwReceiversRtcpBw, pRtpNetSState->dwRtcpBwReceivers,
            dwSendersRtcpBw, pRtpNetSState->dwRtcpBwSenders
        ));
    
    return(NOERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\msrtp\funcs\rtpstats.c ===
/**********************************************************************
 *
 *  Copyright (c) 1999 Microsoft Corporation
 *
 *  File name:
 *
 *    rtpstats.c
 *
 *  Abstract:
 *
 *    Implements the Statistics family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/07 created
 *
 **********************************************************************/

#include "struct.h"
#include "rtpheap.h"
#include "rtpglobs.h"

#include "rtpstats.h"

HRESULT ControlRtpStats(RtpControlStruct_t *pRtpControlStruct)
{

    return(NOERROR);
}

/* Helper function to update counters */
BOOL UpdateRtpStat(RtpStat_t *pRtpStat,/* structure where to update */
                   DWORD      dwRtpRtcp, /* 0=RTP or 1=RTCP stats */
                   DWORD      dwBytes, /* bytes toupdate */
                   DWORD      dwTime)  /* time packet recv/send */
{
    if (pRtpStat) {
        if (!dwRtpRtcp) { /* RTP */
            pRtpStat->dwRTPBytes += dwBytes;
            pRtpStat->dwRTPPackets++;
            pRtpStat->dwRTPLastTime = dwTime;
        } else {          /* RTCP */
            pRtpStat->dwRTCPBytes += dwBytes;
            pRtpStat->dwRTCPPackets++;
            pRtpStat->dwRTCPLastTime = dwTime;
        }
    }

    return(pRtpStat != NULL);
}

#if 0
/* Creates and initializes a RtpStat_t structure */
RtpStat_t *RtpStatAlloc(void)
{
    RtpStat_t *pRtpStat;

    pRtpStat = (RtpStat_t *)
        RtpHeapAlloc(g_pRtpStatHeap, sizeof(RtpStat_t));

    if (pRtpStat) {
        
        ZeroMemory(pRtpStat, sizeof(RtpStat_t));

        pRtpStat->dwObjectID = OBJECTID_RTPSTAT;
    }
    
    return(pRtpStat);
}

/* Frees a RtpStat_t structure */
void RtpStatFree(RtpStat_t *pRtpStat)
{
    if (pRtpStat->dwObjectID != OBJECTID_RTPSTAT) {
        /* TODO log error */
        return;
    }
    
    RtpHeapFree(g_pRtpStatHeap, pRtpStat);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\msrtp\glob\rtpglobs.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpglobs.c
 *
 *  Abstract:
 *
 *    Global heaps, etc.
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/25 created
 *
 **********************************************************************/

#include "rtptags.h"
#include "struct.h"
#include "rtpglobs.h"

#include <mmsystem.h> /* timeGetTime() */
#include <sys/timeb.h> /* void _ftime( struct _timeb *timeptr ); */

/* Global heaps */

/* Heap used to allocate objects for a source */
RtpHeap_t *g_pRtpSourceHeap = NULL;

/* Heap used to allocate media sample objects for a source */
RtpHeap_t *g_pRtpSampleHeap = NULL;

/* Heap used to allocate objects for a render */
RtpHeap_t *g_pRtpRenderHeap = NULL;

/* Heap used to obtain RtpSess_t structures */
RtpHeap_t *g_pRtpSessHeap = NULL;

/* Heap used to obtain RtpAddr_t structures */
RtpHeap_t *g_pRtpAddrHeap = NULL;

/* Heap used to obtain RtpUser_t structures */
RtpHeap_t *g_pRtpUserHeap = NULL;

/* Heap used to obtain RtpSdes_t structures */
RtpHeap_t *g_pRtpSdesHeap = NULL;

/* Heap used to obtain RtpNetCount_t structures */
RtpHeap_t *g_pRtpNetCountHeap = NULL;

/* Heap used to obtain RtpRecvIO_t structures */
RtpHeap_t *g_pRtpRecvIOHeap = NULL;

/* Heap used to obtain RtpChannelCmd_t structures */
RtpHeap_t *g_pRtpChannelCmdHeap = NULL;

/* Heap used to obtain RtcpAddrDesc_t structures */
RtpHeap_t *g_pRtcpAddrDescHeap = NULL;

/* Heap used to obtain RtcpRecvIO_t structures */
RtpHeap_t *g_pRtcpRecvIOHeap = NULL;

/* Heap used to obtain RtcpSendIO_t structures */
RtpHeap_t *g_pRtcpSendIOHeap = NULL;

/* Heap used to obtain RtpQosReserve_t structures */
RtpHeap_t *g_pRtpQosReserveHeap = NULL;

/* Heap used to obtain RtpQosNotify_t structures */
RtpHeap_t *g_pRtpQosNotifyHeap = NULL;

/* Heap used to obtain buffers used by QOS/RSVPSP */
RtpHeap_t *g_pRtpQosBufferHeap = NULL;

/* Heap used to obtain RtpCrypt_t structures */
RtpHeap_t *g_pRtpCryptHeap = NULL;

/* Heap used to obtain variable size structures structures */
RtpHeap_t *g_pRtpGlobalHeap = NULL;

/* Contains some general information */
RtpContext_t g_RtpContext;

typedef struct _RtpGlobalheapArray_t
{
    RtpHeap_t      **ppRtpHeap;
    BYTE             bTag;
    DWORD            dwSize;
} RtpGlobalHeapArray_t;

const RtpGlobalHeapArray_t g_RtpGlobalHeapArray[] =
{
    {&g_pRtpSourceHeap,     TAGHEAP_RTPSOURCE,    0},
    {&g_pRtpSampleHeap,     TAGHEAP_RTPSAMPLE,    0},
    {&g_pRtpRenderHeap,     TAGHEAP_RTPRENDER,    0},
    {&g_pRtpSessHeap,       TAGHEAP_RTPSESS,      sizeof(RtpSess_t)},
    {&g_pRtpAddrHeap,       TAGHEAP_RTPADDR,      sizeof(RtpAddr_t)},
    {&g_pRtpUserHeap,       TAGHEAP_RTPUSER,      sizeof(RtpUser_t)},
    {&g_pRtpSdesHeap,       TAGHEAP_RTPSDES,      sizeof(RtpSdes_t)},
    {&g_pRtpNetCountHeap,   TAGHEAP_RTPNETCOUNT,  sizeof(RtpNetCount_t)},
    {&g_pRtpRecvIOHeap,     TAGHEAP_RTPRECVIO,    sizeof(RtpRecvIO_t)},
    {&g_pRtpChannelCmdHeap, TAGHEAP_RTPCHANCMD,   sizeof(RtpChannelCmd_t)},
    {&g_pRtcpAddrDescHeap,  TAGHEAP_RTCPADDRDESC, sizeof(RtcpAddrDesc_t)},
    {&g_pRtcpRecvIOHeap,    TAGHEAP_RTCPRECVIO,   sizeof(RtcpRecvIO_t)},
    {&g_pRtcpSendIOHeap,    TAGHEAP_RTCPSENDIO,   sizeof(RtcpSendIO_t)},
    {&g_pRtpQosReserveHeap, TAGHEAP_RTPRESERVE,   sizeof(RtpQosReserve_t)},
    {&g_pRtpQosNotifyHeap,  TAGHEAP_RTPNOTIFY,    sizeof(RtpQosNotify_t)},
    {&g_pRtpQosBufferHeap,  TAGHEAP_RTPQOSBUFFER, 0},
    {&g_pRtpCryptHeap,      TAGHEAP_RTPCRYPT,     sizeof(RtpCrypt_t)},
    {&g_pRtpGlobalHeap,     TAGHEAP_RTPGLOBAL,    0},
    {NULL,                  0,                    0}
};

/*
 * Creates all the global heaps
 *
 * Return TRUE on success, and destroy all created heaps and return
 * FALSE on failure */
BOOL RtpCreateGlobHeaps(void)
{
    int              i;
    
    TraceFunctionName("RtpCreateGlobHeaps");

    for(i = 0; g_RtpGlobalHeapArray[i].ppRtpHeap; i++)
    {
        if (*g_RtpGlobalHeapArray[i].ppRtpHeap)
        {
            TraceRetail((
                    CLASS_ERROR, GROUP_RTP, S_RTP_INIT,
                    _T("%s: pRtpHeap[0x%p] %s appears to be initialized"),
                    _fname, *g_RtpGlobalHeapArray[i].ppRtpHeap, g_psRtpTags[i]
                ));

            /* Heap appears to be already initialized, destroy it */
            RtpHeapDestroy(*g_RtpGlobalHeapArray[i].ppRtpHeap);
        }

        /* Create heap */
        *g_RtpGlobalHeapArray[i].ppRtpHeap = 
            RtpHeapCreate(g_RtpGlobalHeapArray[i].bTag,
                          g_RtpGlobalHeapArray[i].dwSize);

        if (!*g_RtpGlobalHeapArray[i].ppRtpHeap)
        {
            goto bail;
        }
    }

    return(TRUE);

 bail:
    RtpDestroyGlobHeaps();
    
    return(FALSE);
}

/*
 * Destroys all the global heaps */
BOOL RtpDestroyGlobHeaps(void)
{
    int              i;
    
    for(i = 0; g_RtpGlobalHeapArray[i].ppRtpHeap; i++)
    {
        if (*g_RtpGlobalHeapArray[i].ppRtpHeap)
        {
            RtpHeapDestroy(*g_RtpGlobalHeapArray[i].ppRtpHeap);
            
            *g_RtpGlobalHeapArray[i].ppRtpHeap = NULL;
        }
    }
    
    return(TRUE);
}

HRESULT RtpInit(void)
{
    BOOL             bStatus;
    HRESULT          hr;

    TraceFunctionName("RtpInit");

    g_RtpContext.dwObjectID = OBJECTID_RTPCONTEXT;
    
    bStatus =
        RtpInitializeCriticalSection(&g_RtpContext.RtpContextCritSect,
                                     (void *)&g_RtpContext,
                                     _T("RtpContextCritSect"));

    hr = NOERROR;
    
    if (!bStatus)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTP, S_RTP_INIT,
                _T("%s: pRtpContext[0x%p] critical section ")
                _T("failed to initialize"),
                _fname, &g_RtpContext
            ));

        hr = RTPERR_CRITSECT;
    }

    return(hr);
}

HRESULT RtpDelete(void)
{
    HRESULT          hr;

    TraceFunctionName("RtpDelete");

    hr = NOERROR;

    /* RtpContext de-initialization */
    RtpDeleteCriticalSection(&g_RtpContext.RtpContextCritSect);

    INVALIDATE_OBJECTID(g_RtpContext.dwObjectID);
        
    return(hr);
}

/* Init reference time */
void RtpInitReferenceTime(void)
{
    struct _timeb    timeb;
    SYSTEM_INFO      si;
    
    /* NOTE This should be in RtpInit(), but RtpInit needs the
     * debugger to be already initialized and the latter in turn needs
     * the reference time also to be already initialized, which will
     * use variables from g_RtpContex, and to avoid adding one more
     * function just to zero that structure, I moved the zeroing here
     * */
    /* Initialize RtpContext */
    ZeroMemory(&g_RtpContext, sizeof(g_RtpContext));

    GetSystemInfo(&si);
    
    if (si.dwNumberOfProcessors == 1)
    {
        /* NOTE The fact that having multiprocessor makes the
         * performance counter to be unreliable (in some machines)
         * unless I set the processor affinity, which I can not
         * because any thread can request the time, so use it only on
         * uniprocessor machines */
        /* MAYDO Would be nice to enable this also in multiprocessor
         * machines, if I could specify what procesor's performance
         * counter to read or if I had a processor independent
         * performance counter */
        QueryPerformanceFrequency((LARGE_INTEGER *)&
                                  g_RtpContext.lPerfFrequency);
    }

    _ftime(&timeb);
    
    if (g_RtpContext.lPerfFrequency)
    {
        QueryPerformanceCounter((LARGE_INTEGER *)&g_RtpContext.lRtpRefTime);
    }
    else
    {
        g_RtpContext.dwRtpRefTime = timeGetTime();
    }
    
    g_RtpContext.dRtpRefTime = timeb.time + (double)timeb.millitm/1000.0;
}

LONGLONG RtpGetTime(void)
{
    DWORD            dwCurTime;
    LONGLONG         lCurTime;
    LONGLONG         lTime;

    if (g_RtpContext.lPerfFrequency)
    {
        QueryPerformanceCounter((LARGE_INTEGER *)&lTime);

        lCurTime =  lTime - g_RtpContext.lRtpRefTime;
        
        /* NOTE: There is a chance for this variable to be corrupted, but
         * it is not used but kept only to know, while debugging, what was
         * the last time this function was called */
        g_RtpContext.lRtpCurTime = lCurTime;
    }
    else
    {
        dwCurTime = timeGetTime() - g_RtpContext.dwRtpRefTime;
        
        /* NOTE: There is a chance for this variable to be corrupted, but
         * it is not used but kept only to know, while debugging, what was
         * the last time this function was called */
        g_RtpContext.dwRtpCurTime = dwCurTime;

        lCurTime = dwCurTime;
    }

    return(lCurTime);
}

double RtpGetTimeOfDay(RtpTime_t *pRtpTime)
{
    DWORD            dwCurTime;
    LONGLONG         lCurTime;
    double           dTime;
    LONGLONG         lTime;

    if (g_RtpContext.lPerfFrequency)
    {
        QueryPerformanceCounter((LARGE_INTEGER *)&lTime);

        lCurTime = lTime - g_RtpContext.lRtpRefTime;

        dTime = g_RtpContext.dRtpRefTime +
            (double) lCurTime / g_RtpContext.lPerfFrequency;

        g_RtpContext.lRtpCurTime = lCurTime;
    }
    else
    {
        dwCurTime = timeGetTime() - g_RtpContext.dwRtpRefTime;
        
        dTime = g_RtpContext.dRtpRefTime +
            (double) dwCurTime / 1000.0;
        
        g_RtpContext.dwRtpCurTime = dwCurTime;
    }

    if (pRtpTime)
    {
        /* Seconds */
        pRtpTime->dwSecs = (DWORD)dTime;

        /* Micro seconds */
        pRtpTime->dwUSecs = (DWORD)
            ( (dTime - (double)pRtpTime->dwSecs) * 1000000.0 );
    }

    return(dTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\msrtp\glob\rtpsess.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpsess.c
 *
 *  Abstract:
 *
 *    Get, Initialize and Delete RTP session (RtpSess_t), RTP address
 *    (RtpAddr_t)
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/02 created
 *
 **********************************************************************/

#include "gtypes.h"
#include "rtpheap.h"
#include "rtpglobs.h"
#include "struct.h"
#include "rtpcrit.h"

#include "rtprtp.h"
#include "rtpqos.h"
#include "rtppinfo.h"
#include "rtcpsdes.h"
#include "rtpncnt.h"
#include "rtpuser.h"
#include "rtpcrypt.h"
#include "rtpaddr.h"
#include "rtpdemux.h"
#include "rtprecv.h"
#include "rtpred.h"

#include "rtpsess.h"

/*
 * Create an RTP session
 * */
HRESULT GetRtpSess(RtpSess_t **ppRtpSess)
{
    HRESULT          hr;
    BOOL             bOk1;
    BOOL             bOk2;
    RtpSess_t       *pRtpSess;
    DWORD            i;
    long             lNumSess;

    TraceFunctionName("GetRtpSess");

    bOk1 = FALSE;
    bOk2 = FALSE;
    pRtpSess = (RtpSess_t *)NULL;
    
    if (!ppRtpSess)
    {
        hr = RTPERR_POINTER;

        goto bail;
    }
    
    *ppRtpSess = (RtpSess_t *)NULL;

    pRtpSess = RtpHeapAlloc(g_pRtpSessHeap, sizeof(RtpSess_t));

    if (!pRtpSess)
    {
        hr = RTPERR_MEMORY;

        goto bail;
    }

    ZeroMemory(pRtpSess, sizeof(RtpSess_t));

    pRtpSess->dwObjectID = OBJECTID_RTPSESS;

    bOk1 = RtpInitializeCriticalSection(&pRtpSess->SessCritSect,
                                        pRtpSess,
                                        _T("SessCritSect"));

    bOk2 = RtpInitializeCriticalSection(&pRtpSess->OutputCritSect,
                                        pRtpSess,
                                        _T("OutputCritSect"));

    if (!bOk1 || !bOk2)
    {
        hr = RTPERR_CRITSECT;
        
        goto bail;
    }

    hr = NOERROR;
    
    /*
     * Create SDES block for this address
     */
    pRtpSess->pRtpSdes = RtcpSdesAlloc();

    if (pRtpSess->pRtpSdes)
    {
        /* Set defaultSDES items */
        pRtpSess->dwSdesPresent = RtcpSdesSetDefault(pRtpSess->pRtpSdes);
    }

    /*
     * Create statistics containers
     * Makes sense if there several addresses per session
     *
    for(i = 0; i < 2; i++) {
        pRtpSess->pRtpSessStat[i] = RtpNetCountAlloc();
    }
    */

    /* Set default features mask */
    pRtpSess->dwFeatureMask = 0; /* NONE YET */

    /* Set default event mask */
    pRtpSess->dwEventMask[RECV_IDX] = RTPRTP_EVENT_RECV_DEFAULT;
    pRtpSess->dwEventMask[SEND_IDX] = RTPRTP_EVENT_SEND_DEFAULT;

    /* Set the default participant events mask */
    pRtpSess->dwPartEventMask[RECV_IDX] = RTPPARINFO_MASK_RECV_DEFAULT;
    pRtpSess->dwPartEventMask[SEND_IDX] = RTPPARINFO_MASK_SEND_DEFAULT;
    
    /* Set default QOS event mask */
    pRtpSess->dwQosEventMask[RECV_IDX] = RTPQOS_MASK_RECV_DEFAULT;
    pRtpSess->dwQosEventMask[SEND_IDX] = RTPQOS_MASK_SEND_DEFAULT;

    /* Set the default SDES events mask */
    pRtpSess->dwSdesEventMask[RECV_IDX] = RTPSDES_EVENT_RECV_DEFAULT;
    pRtpSess->dwSdesEventMask[SEND_IDX] = RTPSDES_EVENT_SEND_DEFAULT;
    
    /* Set default SDES mask */
    pRtpSess->dwSdesMask[LOCAL_IDX]  = RTPSDES_LOCAL_DEFAULT;
    pRtpSess->dwSdesMask[REMOTE_IDX] = RTPSDES_REMOTE_DEFAULT;

    enqueuel(&g_RtpContext.RtpSessQ,
             &g_RtpContext.RtpContextCritSect,
             &pRtpSess->SessQItem);

    lNumSess = InterlockedIncrement(&g_RtpContext.lNumRtpSessions);
    if (lNumSess > g_RtpContext.lMaxNumRtpSessions)
    {
        g_RtpContext.lMaxNumRtpSessions = lNumSess;
    }
    
    /*
     * TODO replace this static single address by a dynamic mechanism
     * where addresses can be added at any time */
    
    /* update returned session */
    *ppRtpSess = pRtpSess;

    TraceRetail((
            CLASS_INFO, GROUP_SETUP, S_SETUP_SESS,
            _T("%s: pRtpSess[0x%p] created"),
            _fname, pRtpSess
        ));

    return(hr);
    
 bail:

    if (bOk1)
    {
        RtpDeleteCriticalSection(&pRtpSess->SessCritSect);
    }

    if (bOk2)
    {
        RtpDeleteCriticalSection(&pRtpSess->OutputCritSect);
    }

    if (pRtpSess)
    {
        RtpHeapFree(g_pRtpSessHeap, pRtpSess);
    }

    TraceRetail((
            CLASS_ERROR, GROUP_SETUP, S_SETUP_SESS,
            _T("%s: failed: %u (0x%X)"),
            _fname, hr, hr
        ));
    
    return(hr);
}

/*
 * Delete an RTP session
 * */
HRESULT DelRtpSess(RtpSess_t *pRtpSess)
{
    DWORD            i;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpOutput_t     *pRtpOutput;
    
    TraceFunctionName("DelRtpSess");

    /* check NULL pointer */
    if (!pRtpSess)
    {
        return(RTPERR_POINTER);
    }

    /* verify object ID */
    if (pRtpSess->dwObjectID != OBJECTID_RTPSESS)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_SETUP, S_SETUP_SESS,
                _T("%s: pRtpSess[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpSess,
                pRtpSess->dwObjectID, OBJECTID_RTPSESS
            ));

        return(RTPERR_INVALIDRTPSESS);
    }

    /* Invalidate object */
    INVALIDATE_OBJECTID(pRtpSess->dwObjectID);
    
    if (pRtpSess->pRtpSdes)
    {
        RtcpSdesFree(pRtpSess->pRtpSdes);
        pRtpSess->pRtpSdes = (RtpSdes_t *)NULL;
    }

    /*
     * Delete session's stats
     * Makes sense if there are several addresses per session
    for(i = 0; i < 2; i++) {
        if (pRtpSess->pRtpSessStat[i]) {
            RtpNetCountFree(pRtpSess->pRtpSessStat[i]);
            pRtpSess->pRtpSessStat[i] = (RtpNetCount_t *)NULL;
        }
    }
    */

    /* Remove all the Outputs */
    do
    {
        pRtpQueueItem = dequeuef(&pRtpSess->OutputQ, NULL);

        if (pRtpQueueItem)
        {
            pRtpOutput =
                CONTAINING_RECORD(pRtpQueueItem, RtpOutput_t, OutputQItem);

            RtpOutputFree(pRtpOutput);
        }
        
    } while(pRtpQueueItem);

    RtpDeleteCriticalSection(&pRtpSess->OutputCritSect);
    
    RtpDeleteCriticalSection(&pRtpSess->SessCritSect);

    dequeue(&g_RtpContext.RtpSessQ,
            &g_RtpContext.RtpContextCritSect,
            &pRtpSess->SessQItem);

    InterlockedDecrement(&g_RtpContext.lNumRtpSessions);
    
    RtpHeapFree(g_pRtpSessHeap, (void *)pRtpSess);
    
    TraceRetail((
            CLASS_INFO, GROUP_SETUP, S_SETUP_SESS,
            _T("%s: pRtpSess[0x%p] deleted"),
            _fname, pRtpSess
        ));
    
    return(NOERROR);
}

/*
 * Create a new RTP address for an existing RtpSess_t
 *
 * Parameter checking is not required as this function is only called
 * internally */
HRESULT GetRtpAddr(
        RtpSess_t  *pRtpSess,
        RtpAddr_t **ppRtpAddr,
        DWORD       dwFlags
    )
{
    HRESULT          hr;
    DWORD            i;
    RtpAddr_t       *pRtpAddr;
    BOOL             bOk1;
    BOOL             bOk2;
    BOOL             bOk3;
    BOOL             bOk4;
    RtpNetSState_t  *pRtpNetSState;
    TCHAR            Name[128];

    TraceFunctionName("GetRtpAddr");

    if (!pRtpSess || !ppRtpAddr)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_SETUP, S_SETUP_ADDR,
                _T("%s: Null pointer"),
                _fname
            ));

        return(E_POINTER);
    }

    /* verify object ID in RtpSess_t */
    if (pRtpSess->dwObjectID != OBJECTID_RTPSESS)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_SETUP, S_SETUP_SESS,
                _T("%s: pRtpSess[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpSess,
                pRtpSess->dwObjectID, OBJECTID_RTPSESS
            ));

        return(RTPERR_INVALIDRTPSESS);
    }
    
    *ppRtpAddr = (RtpAddr_t *)NULL;
    
    pRtpAddr = (RtpAddr_t *) RtpHeapAlloc(g_pRtpAddrHeap, sizeof(RtpAddr_t));

    if (!pRtpAddr)
    {
        /* TODO log error */
        return(E_OUTOFMEMORY);
    }

    ZeroMemory(pRtpAddr, sizeof(RtpAddr_t));
    
    /*
     * Initialize new RtpAddr_t structure
     * */

    hr = NOERROR;
    
    pRtpAddr->dwObjectID = OBJECTID_RTPADDR;
    
    /* RtpAddr_t critical section */
    bOk1 = RtpInitializeCriticalSection(&pRtpAddr->AddrCritSect,
                                        pRtpAddr,
                                        _T("AddrCritSect"));
    
    /* Participants handling critical section */
    bOk2 = RtpInitializeCriticalSection(&pRtpAddr->PartCritSect,
                                        pRtpAddr,
                                        _T("PartCritSect"));
        
    /* Initialize section for Ready/Pending queues */
    bOk3 = RtpInitializeCriticalSection(&pRtpAddr->RecvQueueCritSect,
                                        pRtpAddr,
                                        _T("RecvQueueCritSect"));

    /* Initialize section for RtpNetSState structure */
    bOk4 = RtpInitializeCriticalSection(&pRtpAddr->NetSCritSect,
                                        pRtpAddr,
                                        _T("NetSCritSect"));

    if (!bOk1 || !bOk2 || !bOk3 || !bOk4)
    {
        hr = RTPERR_CRITSECT;
        goto bail;
    }

    /*
     * Create statistics containers (global receiver/sender
     * statistics)
     */
    /*
    for(i = 0; i < 2; i++) {
        pRtpAddr->pRtpAddrStat[i] = RtpNetCountAlloc();
    }
    */
    
    /*
     * Begin Reception only initialization
     */

    /* Create a named event for asynchronous receive completion */
    _stprintf(Name, _T("%X:pRtpAddr[0x%p]->hRecvCompletedEvent"),
              GetCurrentProcessId(), pRtpAddr);
    
    pRtpAddr->hRecvCompletedEvent = CreateEvent(
            NULL,  /* LPSECURITY_ATTRIBUTES lpEventAttributes */
            TRUE,  /* BOOL bManualReset */
            FALSE, /* BOOL bInitialState */
            Name   /* LPCTSTR lpName */
        );

    if (!pRtpAddr->hRecvCompletedEvent)
    {
        hr = RTPERR_EVENT; /* TODO log error */
        goto bail;
    }
    
    /*
     * End Reception only initialization
     */

    /* Allocate RtpQosReserve_t structure if needed */
    if (RtpBitTest(dwFlags, FGADDR_IRTP_QOS))
    {
        pRtpAddr->pRtpQosReserve = RtpQosReserveAlloc(pRtpAddr);

        /* TODO can not have QOS if this allocation fails, report or
         * fail all, right now just continue */
    }

    pRtpAddr->pRtpSess = pRtpSess; /* Set what session owns this address */

    /* Add this address to the session's list of addresses */
    enqueuel(&pRtpSess->RtpAddrQ,
             &pRtpSess->SessCritSect,
             &pRtpAddr->AddrQItem);

    /* Some defaults */

    /* MCast loopback */
    RtpSetMcastLoopback(pRtpAddr, DEFAULT_MCAST_LOOPBACK, NO_FLAGS);
    
    pRtpNetSState = &pRtpAddr->RtpNetSState;
    
    /* Bandwidth */
    pRtpNetSState->dwOutboundBandwidth = DEFAULT_SESSBW / 2;
    pRtpNetSState->dwInboundBandwidth = DEFAULT_SESSBW / 2;
    pRtpNetSState->dwRtcpBwReceivers = DEFAULT_BWRECEIVERS;
    pRtpNetSState->dwRtcpBwSenders = DEFAULT_BWSENDERS;

    /* Minimum RTCP interval report */
    pRtpNetSState->dRtcpMinInterval = DEFAULT_RTCP_MIN_INTERVAL;

    /* Set an invalid payload type */
    pRtpNetSState->bPT = NO_PAYLOADTYPE;
    pRtpNetSState->bPT_Dtmf = NO_PAYLOADTYPE;
    pRtpNetSState->bPT_RedSend = NO_PAYLOADTYPE;
    pRtpAddr->bPT_RedRecv = NO_PAYLOADTYPE;
    
    /* Default weighting factor */
    pRtpAddr->dAlpha = DEFAULT_ALPHA;

    /* Initialize to empty the PT -> Frequency mapping table */
    RtpFlushPt2FrequencyMaps(pRtpAddr, RECV_IDX);

    /* Initialize sockets */
    for(i = 0; i <= SOCK_RTCP_IDX; i++)
    {
        pRtpAddr->Socket[i] = INVALID_SOCKET;
    }
    
    *ppRtpAddr = pRtpAddr;

    TraceRetail((
            CLASS_INFO, GROUP_SETUP, S_SETUP_ADDR,
            _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] created"),
            _fname, pRtpSess, pRtpAddr
        ));
    
    return(hr);

 bail:
    /* fail */
    TraceRetail((
            CLASS_ERROR, GROUP_SETUP, S_SETUP_ADDR,
            _T("%s: pRtpSess[0x%p] failed: %u (0x%X)"),
            _fname, pRtpSess,
            hr, hr
        ));

    DelRtpAddr(pRtpSess, pRtpAddr);
    
    return(hr);
}

/*
 * Delete a RTP address from an existing RtpSess_t
 */
HRESULT DelRtpAddr(
        RtpSess_t *pRtpSess,
        RtpAddr_t *pRtpAddr
    )
{
    RtpQueueItem_t  *pRtpQueueItem;
    RtpRecvIO_t     *pRtpRecvIO;
    DWORD            i;

    TraceFunctionName("DelRtpAddr");

    if (!pRtpSess || !pRtpAddr)
    {
        /* TODO log error */
        return(RTPERR_POINTER);
    }

    /* verify object ID in RtpSess_t */
    if (pRtpSess->dwObjectID != OBJECTID_RTPSESS)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_SETUP, S_SETUP_SESS,
                _T("%s: pRtpSess[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpSess,
                pRtpSess->dwObjectID, OBJECTID_RTPSESS
            ));

        return(RTPERR_INVALIDRTPSESS);
    }
    
    /* verify object ID in RtpAddr_t */
    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_SETUP, S_SETUP_SESS,
                _T("%s: pRtpAddr[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpAddr,
                pRtpAddr->dwObjectID, OBJECTID_RTPADDR
            ));

        return(RTPERR_INVALIDRTPADDR);
    }

    /* Address may not be in queue if we are comming here from a
     * failure in GetRtpAddr(), this would generate another error in
     * the log, but that is OK */
    dequeue(&pRtpSess->RtpAddrQ,
            &pRtpSess->SessCritSect,
            &pRtpAddr->AddrQItem);

    /* The RtpAddr_t might have never been started, and yet the
     * sockets might have been created if the application queried for
     * local ports. By the same token the address will not be stopped,
     * so I need to call RtpDelSockets here. The function will check
     * if sockets really need to be deleted */
    /* destroy sockets */
    RtpDelSockets(pRtpAddr);

    RtpRecvIOFreeAll(pRtpAddr);

    /* Close event to signal reception completed */
    if (pRtpAddr->hRecvCompletedEvent)
    {
        CloseHandle(pRtpAddr->hRecvCompletedEvent);
        pRtpAddr->hRecvCompletedEvent = NULL;
    }

    /* Free statistics containers */
    /*
    for(i = 0; i < 2; i++) {
        if (pRtpAddr->pRtpAddrStat[i]) {
            RtpNetCountFree(pRtpAddr->pRtpAddrStat[i]);
            pRtpAddr->pRtpAddrStat[i] = (RtpNetCount_t *)NULL;
        }
    }
    */
    
    /* QOS */
    if (pRtpAddr->pRtpQosReserve)
    {
        RtpQosReserveFree(pRtpAddr->pRtpQosReserve);
        pRtpAddr->pRtpQosReserve = (RtpQosReserve_t *)NULL;
    }

    /* Cryptography */
    if (pRtpAddr->dwCryptMode)
    {
        RtpCryptCleanup(pRtpAddr);
    }
    
    /* Delete all participants (there shouldn't be any left) */
    DelAllRtpUser(pRtpAddr);

    /* Release redundancy buffers if they were allocated */
    RtpRedFreeBuffs(pRtpAddr);
    
    RtpDeleteCriticalSection(&pRtpAddr->RecvQueueCritSect);

    RtpDeleteCriticalSection(&pRtpAddr->PartCritSect);

    RtpDeleteCriticalSection(&pRtpAddr->AddrCritSect);

    RtpDeleteCriticalSection(&pRtpAddr->NetSCritSect);
    
    /* Invalidate object */
    INVALIDATE_OBJECTID(pRtpAddr->dwObjectID);
    
    RtpHeapFree(g_pRtpAddrHeap, pRtpAddr);

    TraceRetail((
            CLASS_INFO, GROUP_SETUP, S_SETUP_ADDR,
            _T("%s: pRtpSess[0x%p], pRtpAddr[0x%p] deleted"),
            _fname, pRtpSess, pRtpAddr
        ));

    return(NOERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\msrtp\funcs\rtpred.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpred.c
 *
 *  Abstract:
 *
 *    Implements functionality to support redundant encoding (rfc2198)
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    2000/10/19 created
 *
 **********************************************************************/

#include "gtypes.h"
#include "rtphdr.h"
#include "struct.h"
#include "rtpglobs.h"
#include "rtprand.h"
#include "rtpreg.h"
#include "rtpdejit.h"
#include "rtpqos.h"
#include "rtcpthrd.h"

#include "rtpred.h"

typedef struct _RtpLossRateThresh_t {
    int              LossRateLowThresh;
    int              LossRateHigThresh;
} RtpLossRateThresh_t;

RtpLossRateThresh_t g_RtpLossRateThresh[] =
{
    /* 0 */ { RED_LT_0, RED_HT_0},
    /* 1 */ { RED_LT_1, RED_HT_1},
    /* 2 */ { RED_LT_2, RED_HT_2},
    /* 3 */ { RED_LT_3, RED_HT_3},
    /*   */ {       -1, -1}
};

/* The timeout used when scheduling a received packet to be posted at
 * a later time will be decreased by this value */
double           g_dRtpRedEarlyTimeout = RTP_RED_EARLY_TIMEOUT;
/* Will post immediatly (instead of scheduling for later) if the due
 * time is at least this close. This value can not be smaller than the
 * early timeout */
double           g_dRtpRedEarlyPost = RTP_RED_EARLY_POST;


/* Configures redundancy. For a receiver only parameter dwPT_Red
 * is used (the other are ignored) and may be set to -1 to ignore
 * it if it was already set or to assign the default. For a
 * sender, parameters dwPT_Red, dwInitialRedDistance, and
 * dwMaxRedDistance can be set to -1 to ignore the parameter if it
 * was already set or to assign the default value */
DWORD RtpSetRedParameters(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwFlags,
        DWORD            dwPT_Red,
        DWORD            dwInitialRedDistance,
        DWORD            dwMaxRedDistance
    )
{
    DWORD            dwError;
    RtpNetSState_t  *pRtpNetSState;
    
    TraceFunctionName("RtpSetRedParameters");  

    /* Validate parameters */
    dwError = RTPERR_INVALIDARG;
    
    if (IsDWValueSet(dwPT_Red) && ((dwPT_Red & 0x7f) != dwPT_Red))
    {
        goto end;
    }

    /* This is only valid for audio */
    if (RtpGetClass(pRtpAddr->dwIRtpFlags) != RTPCLASS_AUDIO)
    {
        dwError = RTPERR_INVALIDSTATE;
        
        goto end;
    }
    
    
    if (RtpBitTest(dwFlags, RECV_IDX))
    {
        /* Receiver parameters */

        if ( IsRegValueSet(g_RtpReg.dwRedEnable) &&
             ((g_RtpReg.dwRedEnable & 0x03) == 0x02) )
        {
            /* Redundancy at the receiver is forced disabled */

            dwError = NOERROR;

            TraceRetail((
                    CLASS_WARNING, GROUP_RTP, S_RTP_REDINIT,
                    _T("%s: pRtpAddr[0x%p] RECV redundancy ")
                    _T("being forced disabled from the regisrty"),
                    _fname, pRtpAddr
                ));

            goto end;
        }
        
        if (IsDWValueSet(dwPT_Red))
        {
            pRtpAddr->bPT_RedRecv = (BYTE)dwPT_Red;
        }
        else if (pRtpAddr->bPT_RedRecv == NO_PAYLOADTYPE)
        {
            pRtpAddr->bPT_RedRecv = RTP_RED_DEFAULTPT;
        }

        dwError = NOERROR;
        
        RtpBitSet(pRtpAddr->dwAddrFlags, FGADDR_REDRECV);

        TraceRetail((
                CLASS_INFO, GROUP_RTP, S_RTP_REDINIT,
                _T("%s: pRtpAddr[0x%p] RECV PT:%u"),
                _fname, pRtpAddr, pRtpAddr->bPT_RedRecv
            ));
    }

    if (RtpBitTest(dwFlags, SEND_IDX))
    {
        /* Sender parameters */

        if ( (IsDWValueSet(dwMaxRedDistance) &&
              (dwMaxRedDistance > RTP_RED_MAXDISTANCE)) ||
             (IsDWValueSet(dwInitialRedDistance) &&
              (dwInitialRedDistance > RTP_RED_MAXDISTANCE)) )
        {
            goto end;
        }

        if ( IsRegValueSet(g_RtpReg.dwRedEnable) &&
             ((g_RtpReg.dwRedEnable & 0x30) == 0x20) )
        {
            /* Redundancy at the sender is forced disabled */

            dwError = NOERROR;

            TraceRetail((
                    CLASS_WARNING, GROUP_RTP, S_RTP_REDINIT,
                    _T("%s: pRtpAddr[0x%p] SEND redundancy ")
                    _T("being forced disabled from the regisrty"),
                    _fname, pRtpAddr
                ));

            goto end;
        }
        
        pRtpNetSState = &pRtpAddr->RtpNetSState;

        if (IsDWValueSet(dwPT_Red))
        {
            pRtpNetSState->bPT_RedSend = (BYTE)dwPT_Red;
        }
        else if (pRtpNetSState->bPT_RedSend == NO_PAYLOADTYPE)
        {
            pRtpNetSState->bPT_RedSend = RTP_RED_DEFAULTPT;
        }

        if (IsDWValueSet(dwInitialRedDistance))
        {
            pRtpNetSState->dwInitialRedDistance = dwInitialRedDistance;
        }
        else if (!pRtpNetSState->dwInitialRedDistance)
        {
            pRtpNetSState->dwInitialRedDistance = RTP_RED_INITIALDISTANCE;
        }
            
        if (IsDWValueSet(dwMaxRedDistance))
        {
            pRtpNetSState->dwMaxRedDistance = dwMaxRedDistance;
        }
        else if (!pRtpNetSState->dwMaxRedDistance)
        {
            pRtpNetSState->dwMaxRedDistance = RTP_RED_MAXDISTANCE;
        }

        dwError = NOERROR;
        
        if (pRtpNetSState->dwMaxRedDistance > 0)
        {
            if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_REDSEND))
            {
                /* Redundancy descriptors were already allocated */
            }
            else
            {
                /* Allocate redundancy structures only the first time the
                 * function is called */
                dwError = RtpRedAllocBuffs(pRtpAddr);
        
                if (pRtpNetSState->bPT_RedSend != NO_PAYLOADTYPE &&
                    dwError == NOERROR)
                {
                    /* This flag (FGADDR_REDSEND) will enable use of
                     * redundancy for sending, the actual redundancy will
                     * be sent or not depending on the current value of
                     * flag FGSEND_USERED
                     * */
                    RtpBitSet(pRtpAddr->dwAddrFlags, FGADDR_REDSEND);
                }
            }
        }
        else
        {
            /* dwMaxRedDistance == 0 means NO redundancy */
            RtpBitReset(pRtpAddr->dwAddrFlags, FGADDR_REDSEND);
        }

        if (dwError == NOERROR)
        {
            TraceRetail((
                    CLASS_INFO, GROUP_RTP, S_RTP_REDINIT,
                    _T("%s: pRtpAddr[0x%p] SEND PT:%u Distance:%u/%u"),
                    _fname, pRtpAddr,
                    pRtpNetSState->bPT_RedSend,
                    pRtpNetSState->dwInitialRedDistance,
                    pRtpNetSState->dwMaxRedDistance
                ));
        }
    }

 end:
    if (dwError != NOERROR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTP, S_RTP_REDINIT,
                _T("%s: pRtpAddr[0x%p] failed PT:%u ")
                _T("Distance:%u/%u %u (0x%X)"),
                _fname, pRtpAddr,
                dwPT_Red, dwInitialRedDistance,
                dwMaxRedDistance,
                dwError, dwError
            ));
    }

    return(dwError);
}

/* Determine if the playout bounds need to be updated */
DWORD RtpUpdatePlayoutBounds(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        RtpRecvIO_t     *pRtpRecvIO
    )
{
    RtpNetRState_t  *pRtpNetRState;
    
    TraceFunctionName("RtpUpdatePlayoutBounds");  

    if ( RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_REDRECV) &&
         (pRtpUser->RtpNetRState.iAvgLossRateR >= RED_LT_1) )
    {
        pRtpNetRState = &pRtpUser->RtpNetRState;
            
        if (pRtpRecvIO->lRedHdrSize)
        {
            /* Had redundancy */
            
            pRtpNetRState->dwNoRedCount = 0;

            /* Update the minimum playout if needed */
            
            if (pRtpRecvIO->dwMaxTimeStampOffset ==
                pRtpNetRState->dwMaxTimeStampOffset)
            {
                pRtpNetRState->dwRedCount = 0;
            }
            else
            {
                pRtpNetRState->dwRedCount++;
                
                if ( (pRtpRecvIO->dwMaxTimeStampOffset >
                      pRtpNetRState->dwMaxTimeStampOffset) ||
                     (pRtpNetRState->dwRedCount >= RTP_RED_MAXDISTANCE * 4) )
                {
                    /* Update playout bounds immediatly if the
                     * distance has grown, or if we have seen at least
                     * a certian number of packets with the new
                     * shorter distance */
                    pRtpNetRState->dwMaxTimeStampOffset =
                        pRtpRecvIO->dwMaxTimeStampOffset;

                    pRtpNetRState->dRedPlayout =
                        (double)pRtpRecvIO->dwMaxTimeStampOffset /
                        pRtpNetRState->dwRecvSamplingFreq;
                
                    pRtpNetRState->dMinPlayout =
                        pRtpNetRState->dRedPlayout + g_dMinPlayout;
                    
                    if (pRtpNetRState->dMaxPlayout <
                        pRtpNetRState->dMinPlayout)
                    {
                        pRtpNetRState->dMaxPlayout =
                            pRtpNetRState->dMinPlayout + g_dMaxPlayout/4;
                    }

                    pRtpNetRState->dwRedCount = 0;

                    TraceRetail((
                        CLASS_INFO, GROUP_RTP, S_RTP_REDRECV,
                        _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                        _T("receive new red distance:%u (%0.3f) ")
                        _T("playout(%0.3f,%0.3f)"),
                        _fname, pRtpAddr, pRtpUser,
                        ntohl(pRtpUser->dwSSRC),
                        (pRtpNetRState->dwRecvSamplesPerPacket > 0)?
                        pRtpNetRState->dwMaxTimeStampOffset/
                        pRtpNetRState->dwRecvSamplesPerPacket:7,
                        pRtpNetRState->dRedPlayout,
                        pRtpNetRState->dMinPlayout,
                        pRtpNetRState->dMaxPlayout
                    ));
                }
            }
        }
        else if (pRtpNetRState->dwMaxTimeStampOffset)
        {
            /* Didn't have redundancy */

            pRtpNetRState->dwNoRedCount++;

            if (pRtpNetRState->dwNoRedCount >= RTP_RED_MAXDISTANCE * 4)
            {
                pRtpNetRState->dwRedCount = 0;
                
                pRtpNetRState->dRedPlayout = 0;

                pRtpNetRState->dMinPlayout = g_dMinPlayout;

                pRtpNetRState->dMaxPlayout = g_dMaxPlayout;
                
                pRtpNetRState->dwMaxTimeStampOffset = 0;

                TraceRetail((
                        CLASS_INFO, GROUP_RTP, S_RTP_REDRECV,
                        _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                        _T("stopped receiving redundancy"),
                        _fname, pRtpAddr, pRtpUser,
                        ntohl(pRtpUser->dwSSRC)
                    ));
            }
        }
    }

    return(NOERROR);
}

/* Adjust redundancy level at the sender */
DWORD RtpAdjustSendRedundancyLevel(RtpAddr_t *pRtpAddr)
{
    RtpNetSState_t  *pRtpNetSState;
    DWORD            dwCurRedDistance;
    DWORD            dwNewRedDistance;
    DWORD            i;
    BOOL             bUpdateQOS;

    TraceFunctionName("RtpAdjustSendRedundancyLevel");  

    bUpdateQOS = FALSE;
    pRtpNetSState = &pRtpAddr->RtpNetSState;
    dwNewRedDistance = pRtpNetSState->dwNxtRedDistance;

    if (pRtpNetSState->iAvgLossRateS >
        g_RtpLossRateThresh[dwNewRedDistance].LossRateHigThresh)
    {
        /* High loss rate, increase the redundancy level to match the
         * current loss rate if possible */
        if (dwNewRedDistance < pRtpNetSState->dwMaxRedDistance)
        {
            for(;
                dwNewRedDistance < pRtpNetSState->dwMaxRedDistance;
                dwNewRedDistance++)
            {
                if (pRtpNetSState->iAvgLossRateS <
                    g_RtpLossRateThresh[dwNewRedDistance].LossRateHigThresh)
                {
                    break;
                }
            }

            if (RtpBitTest(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSSENDON) &&
                !RtpBitTest(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSREDSENDON))
            {
                /* QOS in the sender is enabled but we haven't updated the
                 * reservation to include the redundancy, update it
                 * now. Set the following flag first as it is used to let
                 * QOS know that redundancy is used and the flowspec needs
                 * to be set accordingly */
                RtpBitSet(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSREDSENDON);

                bUpdateQOS = TRUE;
            }
        }
    }
    else if (pRtpNetSState->iAvgLossRateS <
             g_RtpLossRateThresh[dwNewRedDistance].LossRateLowThresh)
    {
        if (dwNewRedDistance > 0)
        {
            /* Decrease the redundancy level */
            dwNewRedDistance--;

            if (!dwNewRedDistance)
            {
                /* Not using redundancy at all */

                if (RtpBitTest(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSSENDON) &&
                    RtpBitTest(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSREDSENDON))
                {
                    /* QOS in the sender is enabled but we haven't updated
                     * the reservation to include the redundancy, update
                     * it now. Reset the following flag first as it is
                     * used to let QOS know that redundancy is not used
                     * and the flowspec needs to be set accordingly */
                    RtpBitReset(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSREDSENDON);

                    bUpdateQOS = TRUE;
                }
            }
        }
    }

    if (dwNewRedDistance != pRtpNetSState->dwNxtRedDistance)
    {
        if ( IsRegValueSet(g_RtpReg.dwRedEnable) &&
             ((g_RtpReg.dwRedEnable & 0x0300) == 0x0200) )
        {
            /* Updating sender's redundancy distance is disabled from
             * the registry */
            TraceRetail((
                    CLASS_WARNING, GROUP_RTP, S_RTP_REDSEND,
                    _T("%s: pRtpAddr[0x%p] New redundancy distance %u ")
                    _T("required but forced fix to %u from the registry"),
                    _fname, pRtpAddr,
                    dwNewRedDistance, pRtpNetSState->dwNxtRedDistance
                ));
        }
        else
        {
            TraceRetail((
                    CLASS_INFO, GROUP_RTP, S_RTP_REDSEND,
                    _T("%s: pRtpAddr[0x%p] New (%c) redundancy distance:%u ")
                    _T("average send loss rate:%0.2f%%"),
                    _fname, pRtpAddr,
                    (dwNewRedDistance > pRtpNetSState->dwNxtRedDistance)?
                    _T('+'):_T('-'),
                    dwNewRedDistance,
                    (double)pRtpNetSState->iAvgLossRateS/LOSS_RATE_FACTOR
                ));

            /* Update new redundancy distance */
            pRtpNetSState->dwNxtRedDistance = dwNewRedDistance;

            if (!pRtpNetSState->dwNxtRedDistance)
            {
                /* If redundancy is not needed any more, update
                 * current value right away */
                pRtpNetSState->dwCurRedDistance =
                    pRtpNetSState->dwNxtRedDistance;
            }
            
            if (bUpdateQOS)
            {
                /* Update the flowspec... */
                RtpSetQosFlowSpec(pRtpAddr, SEND_IDX);
                
                /* ...and do a new reservation */
                RtcpThreadCmd(&g_RtcpContext,
                              pRtpAddr,
                              RTCPTHRD_RESERVE,
                              SEND_IDX,
                              DO_NOT_WAIT);
            }
        }
    }

    return(NOERROR);
}

/* Add a buffer for the sender to use as redundancy.
 *
 * NOTE that the dwTimeStamp passed doesn't have yet the random offset
 * added */
DWORD RtpAddRedundantBuff(
        RtpAddr_t       *pRtpAddr,
        WSABUF          *pWSABuf,
        DWORD            dwTimeStamp
    )
{
    DWORD            dwIndex;
    RtpNetSState_t  *pRtpNetSState;
    RtpRedEntry_t   *pRtpRedEntry;

    TraceFunctionName("RtpAddRedundantBuff");  

    pRtpNetSState = &pRtpAddr->RtpNetSState;

    dwIndex = pRtpNetSState->dwRedIndex;
    pRtpRedEntry = &pRtpNetSState->pRtpRedEntry[dwIndex];

    dwTimeStamp += pRtpNetSState->dwTimeStampOffset;
    
    pRtpRedEntry->bValid = TRUE;
    pRtpRedEntry->bRedPT = pRtpNetSState->bPT;
    /* At this point the sequence number was already incremented in
     * UpdateRtpRedHdr */
    pRtpRedEntry->dwSeq  = pRtpNetSState->dwSeq - 1;
    pRtpRedEntry->dwTimeStamp = dwTimeStamp;
    pRtpRedEntry->WSABuf.buf = pWSABuf->buf;
    pRtpRedEntry->WSABuf.len = pWSABuf->len;

    pRtpNetSState->dwRedIndex = (dwIndex + 1) % RTP_RED_MAXDISTANCE;

    TraceDebugAdvanced((
            0, GROUP_RTP, S_RTP_REDSENDPKT,
            _T("%s: pRtpAddr[0x%p] Store Red[%u] PT:%u seq:%u ts:%u len:%u"),
            _fname, pRtpAddr,
            dwIndex, pRtpRedEntry->bRedPT,
            pRtpRedEntry->dwSeq,
            pRtpRedEntry->dwTimeStamp,
            pRtpRedEntry->WSABuf.len
        ));
    
    return(NOERROR);
}

/* Clear all the sender's redundant buffers */
DWORD RtpClearRedundantBuffs(RtpAddr_t *pRtpAddr)
{
    DWORD            i;
    RtpNetSState_t  *pRtpNetSState;
    RtpRedEntry_t   *pRtpRedEntry;
    
    TraceFunctionName("RtpClearRedundantBuffs");  

    pRtpNetSState = &pRtpAddr->RtpNetSState;
    pRtpRedEntry = pRtpNetSState->pRtpRedEntry;
    
    if (pRtpRedEntry)
    {
        for(i = 0; i < pRtpNetSState->dwRedEntries; i++)
        {
            pRtpRedEntry[i].bValid = FALSE;
            pRtpRedEntry[i].bRedPT = NO_PAYLOADTYPE;
            pRtpRedEntry[i].WSABuf.len = 0;
            pRtpRedEntry[i].WSABuf.buf = NULL;
        }

        TraceDebugAdvanced((
                0, GROUP_RTP, S_RTP_REDSEND,
                _T("%s: pRtpAddr[0x%p] All redundancy has been invalidated"),
                _fname, pRtpAddr
            ));
    }

    pRtpNetSState->dwRedIndex = 0;
    
    return(NOERROR);
}

/* Allocte the buffer descriptors for the sender to use redundancy */
DWORD RtpRedAllocBuffs(RtpAddr_t *pRtpAddr)
{
    DWORD            dwError;
    RtpNetSState_t  *pRtpNetSState;
    
    TraceFunctionName("RtpRedAllocBuffs");  

    pRtpNetSState = &pRtpAddr->RtpNetSState;
    
    if (pRtpNetSState->pRtpRedEntry)
    {
        RtpRedFreeBuffs(pRtpAddr);
    }

    dwError = RTPERR_MEMORY;
    
    pRtpNetSState->pRtpRedEntry =
        RtpHeapAlloc(g_pRtpAddrHeap,
                     sizeof(RtpRedEntry_t) * RTP_RED_MAXDISTANCE);

    if (pRtpNetSState->pRtpRedEntry)
    {
        pRtpNetSState->dwRedEntries = RTP_RED_MAXDISTANCE;

        pRtpNetSState->dwRedIndex = 0;
        
        dwError = NOERROR;
    }

    if (dwError == NOERROR)
    {
        TraceRetail((
                CLASS_INFO, GROUP_RTP, S_RTP_REDINIT,
                _T("%s: pRtpAddr[0x%p] allocated %d redundancy entries"),
                _fname, pRtpAddr, pRtpNetSState->dwRedEntries
            ));
    }
    else
    {
         TraceRetail((
                CLASS_ERROR, GROUP_RTP, S_RTP_REDINIT,
                _T("%s: pRtpAddr[0x%p] failed to allocate entries: ")
                _T("%s (0x%X)"),
                _fname, pRtpAddr, RTPERR_TEXT(dwError), dwError
             ));
    }
    
    return(dwError);
}

/* Free the buffer descriptors used by the sender for redundancy */
DWORD RtpRedFreeBuffs(RtpAddr_t *pRtpAddr)
{
    DWORD            dwError;
    DWORD            dwRedEntries;
    RtpNetSState_t  *pRtpNetSState;
    
    TraceFunctionName("RtpRedFreeBuffs");  

    pRtpNetSState = &pRtpAddr->RtpNetSState;
    dwRedEntries = pRtpNetSState->dwRedEntries;
    
    if (pRtpNetSState->pRtpRedEntry)
    {
        RtpHeapFree(g_pRtpAddrHeap, pRtpNetSState->pRtpRedEntry);

        pRtpNetSState->pRtpRedEntry = (RtpRedEntry_t *)NULL;

        pRtpNetSState->dwRedEntries = 0;
    }
    
    TraceRetail((
            CLASS_INFO, GROUP_RTP, S_RTP_REDINIT,
            _T("%s: pRtpAddr[0x%p] freed  %d redundancy entries"),
            _fname, pRtpAddr, dwRedEntries
        ));
    
    return(NOERROR);
}    

int RtpUpdateLossRate(
        int              iAvgLossRate,
        int              iCurLossRate
    )
{
    /* Smooth the loss rate */

    if (iAvgLossRate > iCurLossRate)
    {
        iAvgLossRate += ((iCurLossRate - iAvgLossRate) / LOSS_RATE_ALPHA_UP);
    }
    else
    {
        iAvgLossRate += ((iCurLossRate - iAvgLossRate) / LOSS_RATE_ALPHA_DN);
    }

    return(iAvgLossRate);
}

#if USE_GEN_LOSSES > 0
BOOL RtpRandomLoss(DWORD dwRecvSend)
{
    BOOL             bLossIt;
    DWORD            dwRand;

    bLossIt = FALSE;

    if (IsRegValueSet(g_RtpReg.dwGenLossEnable))
    {
        if (!dwRecvSend)
        {
            /* Receiver */
            if (IsRegValueSet(g_RtpReg.dwRecvLossRate) &&
                ((g_RtpReg.dwGenLossEnable & 0x03) == 0x03))
            {
                dwRand = RtpRandom32((DWORD_PTR)&bLossIt) & 0xFFFFFF;

                if ((dwRand * 100 / 0xFFFFFF) <= g_RtpReg.dwRecvLossRate)
                {
                    bLossIt = TRUE; 
                }
            }
        }
        else
        {
            /* Sender */
            if (IsRegValueSet(g_RtpReg.dwSendLossRate) &&
                ((g_RtpReg.dwGenLossEnable & 0x30) == 0x30))
            {
                dwRand = RtpRandom32((DWORD_PTR)&bLossIt) & 0xFFFFFF;

                if ((dwRand * 100 / 0xFFFFFF) <= g_RtpReg.dwSendLossRate)
                {
                    bLossIt = TRUE; 
                }
            }
        }
    }

    return(bLossIt);
}
#endif /* USE_GEN_LOSSES > 0 */

void RtpSetRedParametersFromRegistry(void)
{
    DWORD           *dwPtr;
    DWORD            i;
    int              thresh;

    /* Redundancy thresholds */
    if (IsRegValueSet(g_RtpReg.dwRedEnable) &&
        ((g_RtpReg.dwRedEnable & 0x3000) == 0x3000))
    {
        for(dwPtr = &g_RtpReg.dwLossRateThresh0, i = 0;
            i <= RTP_RED_MAXDISTANCE;
            dwPtr++, i++)
        {
            if (IsRegValueSet(*dwPtr))
            {
                /* Low threshold */
                thresh = (int)(*dwPtr & 0xffff);
                if (thresh > 100)
                {
                    thresh = 100;
                }
                g_RtpLossRateThresh[i].LossRateLowThresh =
                    thresh * LOSS_RATE_FACTOR;

                /* High threshold */
                thresh = (int)((*dwPtr >> 16) & 0xffff);
                if (thresh > 100)
                {
                    thresh = 100;
                }
                g_RtpLossRateThresh[i].LossRateHigThresh =
                    thresh * LOSS_RATE_FACTOR;
            }
        }
    }

    /* Early timeout and early post times */
    if (IsRegValueSet(g_RtpReg.dwRedEarlyTimeout) &&
        g_RtpReg.dwRedEarlyTimeout != 0)
    {
        g_dRtpRedEarlyTimeout = (double)g_RtpReg.dwRedEarlyTimeout / 1000;
    }
    if (IsRegValueSet(g_RtpReg.dwRedEarlyPost) &&
        g_RtpReg.dwRedEarlyPost != 0)
    {
        g_dRtpRedEarlyPost = (double)g_RtpReg.dwRedEarlyPost / 1000;
    }

    if (g_dRtpRedEarlyTimeout >= g_dRtpRedEarlyPost)
    {
        g_dRtpRedEarlyPost = g_dRtpRedEarlyTimeout + 5e-3;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\msrtp\glob\rtpuser.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpuser.c
 *
 *  Abstract:
 *
 *    Creates/initializes/deletes a RtpUser_t structure
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/10/02 created
 *
 **********************************************************************/

#include "rtpglobs.h"
#include "lookup.h"
#include "rtcpsdes.h"
#include "rtpncnt.h"
#include "rtppinfo.h"
#include "struct.h"
#include "rtpdejit.h"
#include "rtprecv.h"
#include "rtpthrd.h"

#include "rtpuser.h"

/*
 * TODO add time this was created, times we last received RTP data and
 * RTCP, time it stalled, time it left */
HRESULT GetRtpUser(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t      **ppRtpUser,
        DWORD            dwFlags
    )
{
    HRESULT          hr;
    BOOL             bError1;
    double           dTime;
    RtpUser_t       *pRtpUser;

    TraceFunctionName("GetRtpUser");
    
    if (!pRtpAddr || !ppRtpUser)
    {
        /* TODO log error */
        return(RTPERR_POINTER);
    }

    *ppRtpUser = (RtpUser_t *)NULL;

    /* verify object ID in RtpAddr_t */
    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_USER, S_USER_INIT,
                _T("%s: pRtpAddr[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpAddr,
                pRtpAddr->dwObjectID, OBJECTID_RTPADDR
            ));

        return(RTPERR_INVALIDRTPADDR);
    }

    /* TODO a separate heap to be used by multicast conferences, and a
     * common heap (this one) for all unicast calls. Right now using
     * the common users heap */
    pRtpUser = (RtpUser_t *) RtpHeapAlloc(g_pRtpUserHeap, sizeof(RtpUser_t));

    if (!pRtpUser)
    {
        /* TODO log error */
        return(RTPERR_MEMORY);
    }

    ZeroMemory(pRtpUser, sizeof(RtpUser_t));
    /*
     * Initialize new RtpUser_t structure
     * */

    hr = NOERROR;
    
    pRtpUser->dwObjectID = OBJECTID_RTPUSER;
    
    /* RtpUser_t critical section */
    bError1 = RtpInitializeCriticalSection(&pRtpUser->UserCritSect,
                                           pRtpUser,
                                           _T("UserCritSect"));

    if (!bError1)
    {
        hr = RTPERR_CRITSECT;
        goto bail;
    }

    /* Time this RtpUser was created */
    dTime = RtpGetTimeOfDay((RtpTime_t *)NULL);
    
    pRtpUser->RtpNetRState.dCreateTime = dTime;
    
    pRtpUser->RtpNetRState.dwPt = NO_PAYLOADTYPE;
    
    /* Add SDES information container */
    /* Do not fail if container can not be allocated */
    pRtpUser->pRtpSdes = RtcpSdesAlloc();

    /* Allocate reception statistics container */
    /* Do not fail if container can not be allocated */
    /*
    pRtpUser->pRtpUserStat = RtpNetCountAlloc();

    if (pRtpUser->pRtpUserStat)
    {
        pRtpUser->pRtpUserStat->dRTCPLastTime = dTime;
    }
    */
    pRtpUser->RtpUserCount.dRTCPLastTime = dTime;
    
    /* Set owner address */
    pRtpUser->pRtpAddr = pRtpAddr;

    /* Set initial state to CREATED, in this state the RtpUser_t
     * structure will be immediatly put in AliveQ and Hash (later
     * during the lookup that produced this creation)
     * */
    pRtpUser->dwUserState = RTPPARINFO_CREATED;

    pRtpUser->RtpNetRState.dMinPlayout = g_dMinPlayout;
    pRtpUser->RtpNetRState.dMaxPlayout = g_dMaxPlayout;

    *ppRtpUser = pRtpUser;
    
    TraceDebug((
            CLASS_INFO,
            GROUP_USER,
            S_USER_LOOKUP,
            _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] New user"),
            _fname, pRtpAddr, pRtpUser
        ));
    
    return(hr);

 bail:

    DelRtpUser(pRtpAddr, pRtpUser);

    return(hr);
}

HRESULT DelRtpUser(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser
    )
{
    HRESULT          hr;
    RtpQueueItem_t  *pRtpQueueItem;

    TraceFunctionName("DelRtpUser");
    
    if (!pRtpAddr || !pRtpUser)
    {
        /* TODO log error */
        return(RTPERR_POINTER);
    }

    /* verify object ID in RtpAddr_t */
    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_USER, S_USER_INIT,
                _T("%s: pRtpAddr[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpAddr,
                pRtpAddr->dwObjectID, OBJECTID_RTPADDR
            ));

        return(RTPERR_INVALIDRTPADDR);
    }
    
    /* verify object ID in RtpUser_t */
    if (pRtpUser->dwObjectID != OBJECTID_RTPUSER)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_USER, S_USER_INIT,
                _T("%s: pRtpUser[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpUser,
                pRtpUser->dwObjectID, OBJECTID_RTPUSER
            ));

        return(RTPERR_INVALIDRTPUSER);
    }

    /* If there is pending IO (items in RecvIOWaitRedQ associated to
     * this user) flush them. This can only happen if we are still
     * receiving, i.e. the RTP reception thread is still running,
     * otherwise we would have already called FlushRtpRecvFrom, and
     * any pending packets had been flushed (i.e. posted with an error
     * code) and hence have ZERO pending packets */
    if (pRtpUser->lPendingPackets > 0)
    {
        RtpThreadFlushUser(pRtpAddr, pRtpUser);
    }
    
    RtpDeleteCriticalSection(&pRtpUser->UserCritSect);

    /* Free SDES information */
    if (pRtpUser->pRtpSdes)
    {
        RtcpSdesFree(pRtpUser->pRtpSdes);

        pRtpUser->pRtpSdes = (RtpSdes_t *)NULL;
    }

    /* Free reception statistics */
    /*
    if (pRtpUser->pRtpUserStat)
    {
        RtpNetCountFree(pRtpUser->pRtpUserStat);

        pRtpUser->pRtpUserStat = (RtpNetCount_t *)NULL;
    }
    */

    /* Invalidate object */
    INVALIDATE_OBJECTID(pRtpUser->dwObjectID);
    
    TraceDebug((
            CLASS_INFO, GROUP_USER, S_USER_INIT,
            _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X Del user"),
            _fname, pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC)
        ));
    
    RtpHeapFree(g_pRtpUserHeap, pRtpUser);
    
    return(NOERROR);
}

/* Delete All RTP users, this happens when the RTP session is
 * terminated (RtpRealStop) */
DWORD DelAllRtpUser(RtpAddr_t *pRtpAddr)
{
    BOOL             bOk;
    DWORD            dwCount;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpUser_t       *pRtpUser;

    dwCount = 0;
    
    bOk = RtpEnterCriticalSection(&pRtpAddr->PartCritSect);

    if (bOk)
    {
        /* Remove participants from Cache1Q, Cache2Q, AliveQ, ByeQ and
           Hash */
        do
        {
            pRtpQueueItem = peekH(&pRtpAddr->Hash, NULL);
            
            if (pRtpQueueItem)
            {
                pRtpUser =
                    CONTAINING_RECORD(pRtpQueueItem, RtpUser_t, HashItem);

                /* This function with event DEL will remove the user
                 * from Cache1Q, Cache2Q, AliveQ or ByeQ, and will
                 * also remove it from Hash. After that, will call
                 * DelRtpUser()
                 * */
                RtpUpdateUserState(pRtpAddr, pRtpUser, USER_EVENT_DEL);
                
                dwCount++;
            }
        } while(pRtpQueueItem);

        RtpLeaveCriticalSection(&pRtpAddr->PartCritSect); 
    }

    return(dwCount);
}

/* Makes all the participants appear as if the next packet that will
 * be received were the very first packet ever received, or ever sent
 * */
DWORD ResetAllRtpUser(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwFlags   /* Recv, Send */
    )
{
    BOOL             bOk;
    long             lUsers;
    DWORD            dwCountR;
    DWORD            dwCountS;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpUser_t       *pRtpUser;

    dwCountR = 0;
    dwCountS = 0;
    
    bOk = RtpEnterCriticalSection(&pRtpAddr->PartCritSect);

    if (bOk)
    {
        for(lUsers = GetQueueSize(&pRtpAddr->AliveQ),
                pRtpQueueItem = pRtpAddr->AliveQ.pFirst;
            lUsers > 0 && pRtpQueueItem;
            lUsers--, pRtpQueueItem = pRtpQueueItem->pNext)
        {
            pRtpUser =
                CONTAINING_RECORD(pRtpQueueItem, RtpUser_t, UserQItem);
            
            if (RtpBitTest(dwFlags, RECV_IDX))
            {
                /* Reset receiver. The reset consist in preparing the
                 * participants so when new data arrives, they behave as
                 * if that were the first packet received */

                pRtpUser->RtpNetRState.dwPt = NO_PAYLOADTYPE;
                
                RtpBitReset(pRtpUser->dwUserFlags, FGUSER_FIRST_RTP);
                
                dwCountR++;
            }

            if (RtpBitTest(dwFlags, SEND_IDX))
            {
                /* Reset sender */
                /* NOTHING FOR NOW */
            }
        }

        RtpLeaveCriticalSection(&pRtpAddr->PartCritSect); 
    }

    return( ((dwCountS & 0xffff) << 16) | (dwCountR & 0xffff) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\msrtp\misc\lookup.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    lookup.c
 *
 *  Abstract:
 *
 *    Helper functions to look up SSRCs
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/17 created
 *
 **********************************************************************/

#include "lookup.h"
#include "rtpuser.h"
/*
 * Looks up an SSRC in RtpAddr_t
 *
 * Look first in Cache1Q, if Cache1Q size is bigger than
 * MAX_QUEUE2HASH_ITEMS, then look up directly from Hash, if not found
 * there, check ByeQ, if the item is there, the packet must be
 * discarded as it belongs to a left or stalled participant, if the
 * the participant is indeed alive, it will be created again once its
 * descriptor expires and is removed from ByeQ */
RtpUser_t *LookupSSRC(RtpAddr_t *pRtpAddr, DWORD dwSSRC, BOOL *pbCreate)
{
    HRESULT          hr;
    BOOL             bOk;
    BOOL             bCreate;
    long             lCount;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpUser_t       *pRtpUser;
    
    TraceFunctionName("LookupSSRC");

    pRtpQueueItem = (RtpQueueItem_t *)NULL;
    pRtpUser = (RtpUser_t *)NULL;

    bCreate = *pbCreate;

    *pbCreate = FALSE;
    
    bOk = RtpEnterCriticalSection(&pRtpAddr->PartCritSect);

    if (bOk)
    {
        if (pRtpAddr->Cache1Q.lCount <= MAX_QUEUE2HASH_ITEMS) {
            /* look in Cache1Q */
            pRtpQueueItem = findQdwK(&pRtpAddr->Cache1Q, NULL, dwSSRC);

            if (pRtpQueueItem)
            {
                pRtpUser =
                    CONTAINING_RECORD(pRtpQueueItem, RtpUser_t, UserQItem);
                
                goto end;
            }
        }

        if (!pRtpQueueItem)
        {
            /* look up in ByeQ */
            pRtpQueueItem = findQdwK(&pRtpAddr->ByeQ, NULL, dwSSRC);

            if (pRtpQueueItem)
            {
                /* If in ByeQ, return saying we didn't find it */
                goto end;
            }

            /* look in hash */
            pRtpQueueItem = findHdwK(&pRtpAddr->Hash, NULL, dwSSRC);

            if (pRtpQueueItem)
            {
                pRtpUser =
                    CONTAINING_RECORD(pRtpQueueItem, RtpUser_t, HashItem);

                goto end;
            }
        }

        if (!pRtpQueueItem && bCreate == TRUE)
        {
            /* SSRC not found, create a new one */
            hr = GetRtpUser(pRtpAddr, &pRtpUser, 0);

            if (SUCCEEDED(hr))
            {
                pRtpUser->dwSSRC = dwSSRC;
                pRtpUser->UserQItem.dwKey = dwSSRC;
                pRtpUser->HashItem.dwKey = dwSSRC;

                /* When a user has been created, it is in the CREATED
                 * state (the state initialized during creation), then
                 * it has to be put in the AliveQ and Hash */

                /* Insert in head of AliveQ */
                enqueuef(&pRtpAddr->AliveQ,
                         NULL,
                         &pRtpUser->UserQItem);

                /* Insert in Hash according to its SSRC */
                insertHdwK(&pRtpAddr->Hash,
                           NULL,
                           &pRtpUser->HashItem,
                           dwSSRC);

                /* A new participant is created */
                *pbCreate = TRUE;
                
                TraceDebug((
                        CLASS_INFO,
                        GROUP_USER,
                        S_USER_LOOKUP,
                        _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X"),
                        _fname, pRtpAddr, pRtpUser, ntohl(dwSSRC)
                    ));

                goto end;
            }
        }
    }

 end:
    if (bOk)
    {
        RtpLeaveCriticalSection(&pRtpAddr->PartCritSect);
    }

    return(pRtpUser);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\msrtp\misc\gtypes.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    gtypes.c
 *
 *  Abstract:
 *
 *    Some global strings
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    2001/03/09 created
 *
 **********************************************************************/

#include "gtypes.h"

const TCHAR_t *g_psRtpRecvSendStr[] = {
    _T("RECV"),
    _T("SEND")
};

const TCHAR_t *g_psRtpStreamClass[] = {
    _T("UNKNOWN"),
    _T("AUDIO"),
    _T("VIDEO"),
    _T("UNKNOWN"),
    _T("UNKNOWN"),
    _T("UNKNOWN"),
    _T("UNKNOWN"),
    _T("UNKNOWN")
};

const TCHAR_t *g_psGetSet[] = {
    _T("GET"),
    _T("SET")
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\msrtp\misc\rtperr.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 2000
 *
 *  File name:
 *
 *    rtperr.c
 *
 *  Abstract:
 *
 *    Error codes
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    2000/03/21 created
 *
 **********************************************************************/

#include "gtypes.h"

/*
 * WARNING
 *
 * The *_ENUM_* values in rtperr.h and the array g_psRtpErr in
 * rtperr.c MUST have their entries matched
 * */
const TCHAR      *g_psRtpErr[] =
{
    _T("NOERROR"),
    _T("FAIL"),
    _T("MEMORY"),
    _T("POINTER"),
    _T("INVALIDRTPSESS"),
    _T("INVALIDRTPADDR"),
    _T("INVALIDRTPUSER"),
    _T("INVALIDRTPCONTEXT"),
    _T("INVALIDRTCPCONTEXT"),
    _T("INVALIDOBJ"),
    _T("INVALIDSTATE"),
    _T("NOTINIT"),
    _T("INVALIDARG"),
    _T("INVALIDHDR"),
    _T("INVALIDPT"),
    _T("INVALIDVERSION"),
    _T("INVALIDPAD"),
    _T("INVALIDRED"),
    _T("INVALIDSDES"),
    _T("INVALIDBYE"),
    _T("INVALIDUSRSTATE"),
    _T("INVALIDREQUEST"),
    _T("SIZE"),
    _T("MSGSIZE"),
    _T("OVERRUN"),
    _T("UNDERRUN"),
    _T("PACKETDROPPED"),
    _T("CRYPTO"),
    _T("ENCRYPT"),
    _T("DECRYPT"),
    _T("CRITSECT"),
    _T("EVENT"),
    _T("WS2RECV"),
    _T("WS2SEND"),
    _T("NOTFOUND"),
    _T("UNEXPECTED"),
    _T("REFCOUNT"),
    _T("THREAD"),
    _T("HEAP"),
    _T("WAITTIMEOUT"),
    _T("CHANNEL"),
    _T("CHANNELCMD"),
    _T("RESOURCES"),
    _T("QOS"),
    _T("NOQOS"),
    _T("QOSSE"),
    _T("QUEUE"),
    _T("NOTIMPL"),
    _T("INVALIDFAMILY"),
    _T("LAST")
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\msrtp\misc\rtpdbg.c ===
#include "gtypes.h"

#include <stdarg.h>
#include <rtutils.h>
#include <stdio.h>
#include <stdlib.h>

#include "rtpglobs.h"

#define USE_TRACING_FILE 0

#if DBG > 0
const char          *rcs_rtpdbg="RTC RTP/RTCP stack chk 2001/08/09";
const BOOL           g_bRtpIsDbg = TRUE;
#else
const char          *rcs_rtpdbg="RTC RTP/RTCP stack fre 2001/08/09";
const BOOL           g_bRtpIsDbg = FALSE;
#endif

void RtpDebugReadRegistry(RtpDbgReg_t *pRtpDbgReg);

void MSRtpTrace(
        TCHAR           *lpszFormat,
                         ...
    );

void MSRtpTraceInternal(
        TCHAR           *psClass,
        DWORD            dwMask,
        TCHAR           *lpszFormat,
        va_list          arglist
    );

#if USE_TRACING_FILE > 0
FILE            *g_dwRtpDbgTraceID = NULL;
#else
DWORD            g_dwRtpDbgTraceID = INVALID_TRACEID;
#endif

#define MAXDEBUGSTRINGLENGTH   512
#define RTPDBG_ROOTKEY         HKEY_LOCAL_MACHINE
#define RTPDBG_ROOTPATH        _T("SOFTWARE\\Microsoft\\Tracing\\")
#define RTPDBG_OPENKEYFLAGS    KEY_ALL_ACCESS
#define RTPDBG_OPENREADONLY    KEY_READ

/*
      3                   2                   1                 
    1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |O|C|           | Path  |   |Class|E|   |       Offset          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    v v \----v----/ \--v--/ \v/ \-v-/ v \v/ \----------v----------/
    | |      |         |     |    |   |  |             |
    | |      |         |     |    |   |  |            Offset (12)
    | |      |         |     |    |   |  |
    | |      |         |     |    |   |  Unused (2)
    | |      |         |     |    |   |
    | |      |         |     |    |   This is a class (1)
    | |      |         |     |    |
    | |      |         |     |   Class (3)
    | |      |         |     |
    | |      |         |    Unused (2) 
    | |      |         |
    | |      |        Registry path index (4)
    | |      |
    | |     Unused (6)
    | |
    | Registry Close flag (1)
    |
    Registry Open flag (1)
*/
/*
 * Encoding macros
 */
/* Offset to field */
#define OFF(_f) ( (DWORD) ((ULONG_PTR) &((RtpDbgReg_t *)0)->_f) )

/* REG(RegOpen flag, key path, RegClose flag) */
#define REG(_fo, _p, _fc) (((_fo) << 31) | ((_fc) << 30) | ((_p) << 20))

/* CLASS(Class, Enable) */
#define CLASS(_C, _E)     (((_C) << 15) | ((_E) << 14))

/* ENTRY(REG, Class, Offset) */
#define ENTRY(_r, _c, _o) ((_r) | (_c) | (_o))
/*
 * Decoding macros
 * */
#define REGOPEN(_ctrl)    (RtpBitTest(_ctrl, 31))
#define REGCLOSE(_ctrl)   (RtpBitTest(_ctrl, 30))
#define REGPATH(_ctrl)    g_psRtpDbgRegPath[((_ctrl >> 20) & 0xf)]
#define REGOFFSET(_ctrl)  (_ctrl & 0xfff)
#define REGISCLASS(_ctrl) (RtpBitTest(_ctrl, 14))
#define REGCLASS(_ctrl)   (((_ctrl) >> 15) & 0x7)

#define PDW(_ptr, _ctrl)  ((DWORD  *) ((char *)_ptr + REGOFFSET(_ctrl)))

/* Class name as printed in log */
const TCHAR_t   *g_psRtpDbgClass[] = {
    _T("NONE "),
    _T("ERROR"),
    _T("WARN "),
    _T("INFO "),
    _T("INFO2"),
    _T("INFO3"),
    NULL
};

/* Sockets' name */
const TCHAR_t   *g_psSockIdx[] = {
    _T("RTP RECV"),
    _T("RTP SEND"),
    _T("RTCP")
};

/* Module name, e.g. dxmrtp.dll */
TCHAR            g_sRtpDbgModule[16];

/* Registry module name, e.g. dxmrtp */
TCHAR            g_sRtpDbgModuleNameID[16];

/* Complementary path (added to base path+ModuleNameID */
const TCHAR     *g_psRtpDbgRegPath[] =
{
    _T(""),
    _T("\\AdvancedTracing"),
    _T("\\AdvancedTracing\\Group"),
    NULL
};

/*
 * WARNING
 *
 * Modifying CLASSES needs to keep matched the enum CLASS_*
 * (rtpdbg.h), the variables in RtpDbgReg_t (rtpdbg.h), the class
 * items in g_psRtpDbgInfo (rtpdbg.c) and its respective entries
 * g_dwRtpDbgRegCtrl (rtpdbg.c), as well as the printed class name
 * g_psRtpDbgClass (rtpdbg.c).
 *
 * For each entry in g_psRtpDbgInfo, there MUST be an entry in
 * g_dwRtpDbgRegCtrl in the same position.
 * */

/* DWORD values read that are stored */
const TCHAR     *g_psRtpDbgInfo[] =
{
    _T("AdvancedOptions"),
    _T("EnableFileTracing"),
    _T("EnableConsoleTracing"),
    _T("EnableDebuggerTracing"),
    _T("ConsoleTracingMask"),
    _T("FileTracingMask"),   
    _T("UseAdvancedTracing"),

    _T("ERROR"),
    _T("WARNING"),
    _T("INFO"),
    _T("INFO2"),
    _T("INFO3"),

    _T("DisableClass"),
    _T("DisableGroup"),

    _T("Setup"),
    _T("CritSect"),
    _T("Heap"),
    _T("Queue"),
    _T("RTP"),
    _T("RTCP"),
    _T("Channel"),
    _T("Network"),
    _T("AddrDesc"),
    _T("Demux"),
    _T("User"),
    _T("DShow"),
    _T("QOS"),
    _T("Crypto"),
    
    NULL
};

/* Control words */
const DWORD g_dwRtpDbgRegCtrl[] =
{
    /* ENTRY(REG(Open,Path,Close), CLASS(Class,Enable), Offset) */
    
    /* ...\Tracing\dxmrtp */
    ENTRY(REG(1,0,0), CLASS(0            , 0), OFF(dwAdvancedOptions)),
    ENTRY(REG(0,0,0), CLASS(0            , 0), OFF(dwEnableFileTracing)),
    ENTRY(REG(0,0,0), CLASS(0            , 0), OFF(dwEnableConsoleTracing)),
    ENTRY(REG(0,0,0), CLASS(0            , 0), OFF(dwEnableDebuggerTracing)),
    ENTRY(REG(0,0,0), CLASS(0            , 0), OFF(dwConsoleTracingMask)),
    ENTRY(REG(0,0,0), CLASS(0            , 0), OFF(dwFileTracingMask)),
    ENTRY(REG(0,0,1), CLASS(0            , 0), OFF(dwUseAdvancedTracing)),

    /* ...\Tracing\dxmrtp\AdvancedTracing */
    ENTRY(REG(1,1,0), CLASS(CLASS_ERROR  , 1), OFF(dwERROR)),
    ENTRY(REG(1,0,0), CLASS(CLASS_WARNING, 1), OFF(dwWARNING)),
    ENTRY(REG(1,0,0), CLASS(CLASS_INFO   , 1), OFF(dwINFO)),
    ENTRY(REG(1,0,0), CLASS(CLASS_INFO2  , 1), OFF(dwINFO2)),
    ENTRY(REG(1,0,0), CLASS(CLASS_INFO3  , 1), OFF(dwINFO3)),
    ENTRY(REG(1,0,0), CLASS(0            , 0), OFF(dwDisableClass)),
    ENTRY(REG(1,0,1), CLASS(0            , 0), OFF(dwDisableGroup)),

    /* ...\Tracing\dxmrtp\AdvancedTracing\Group */
    ENTRY(REG(1,2,0), CLASS(0            , 0), OFF(dwSetup)),
    ENTRY(REG(0,0,0), CLASS(0            , 0), OFF(dwCritSect)),
    ENTRY(REG(0,0,0), CLASS(0            , 0), OFF(dwHeap)),
    ENTRY(REG(0,0,0), CLASS(0            , 0), OFF(dwQueue)),
    ENTRY(REG(0,0,0), CLASS(0            , 0), OFF(dwRTP)),
    ENTRY(REG(0,0,0), CLASS(0            , 0), OFF(dwRTCP)),
    ENTRY(REG(0,0,0), CLASS(0            , 0), OFF(dwChannel)),
    ENTRY(REG(0,0,0), CLASS(0            , 0), OFF(dwNetwork)),
    ENTRY(REG(0,0,0), CLASS(0            , 0), OFF(dwAddrDesc)),
    ENTRY(REG(0,0,0), CLASS(0            , 0), OFF(dwDemux)),
    ENTRY(REG(0,0,0), CLASS(0            , 0), OFF(dwUser)),
    ENTRY(REG(0,0,0), CLASS(0            , 0), OFF(dwDShow)),
    ENTRY(REG(0,0,0), CLASS(0            , 0), OFF(dwQOS)),
    ENTRY(REG(0,0,1), CLASS(0            , 0), OFF(dwCrypto)),

    /* End */
    0
};

RtpDbgReg_t      g_RtpDbgReg;

void MSRtpTraceDebug(
        IN DWORD         dwClass,
        IN DWORD         dwGroup,
        IN DWORD         dwSelection,
        IN TCHAR        *lpszFormat,
        IN               ...
    )
{
    BOOL             bOk;
    DWORD            dwMask;
    va_list          arglist;

    /* Allow the class not be specified (e.g. when we want to enable
     * log only based on group and selection) */
    if (dwClass >= CLASS_LAST)
    {
        return;
    }

    /* If the group is not specified, only the class will be take
     * effect (i.e. the selection will be ignored when the group is
     * not specified , i.e. group=0) */
    if (dwGroup >= GROUP_LAST)
    {
        return;
    }

#if USE_TRACING_FILE > 0
    if ((!g_dwRtpDbgTraceID) &&
        !g_RtpDbgReg.dwEnableDebuggerTracing)
    {
        /* FileTracing could be enabled but TraceRegister failed, so
         * for file I check against the TraceID instead */
        goto end;
    }
#else
    if ((g_dwRtpDbgTraceID == INVALID_TRACEID) &&
        !g_RtpDbgReg.dwEnableDebuggerTracing)
    {
        /* FileTracing could be enabled but TraceRegister failed, so
         * for file I check against the TraceID instead */
        goto end;
    }
#endif
    
    /* Decide if debug output is going to be generated */

    if (IsAdvancedTracingUsed())
    {
        /* Ignore current tracing registry masks */

        if (g_RtpDbgReg.dwGroupArray2[dwGroup] & dwSelection & 0x00ffffff)
        {
            /* Exclude this from tracing */
            goto end;
        }
        
        if (g_RtpDbgReg.dwGroupArray[dwGroup] &
            ( (1 << (dwClass + 24)) | (dwSelection & 0x00ffffff) ) )
        {
            dwMask = TRACE_NO_STDINFO;
        }
        else
        {
            goto end;
        }
    }
    else
    {
        /* Control is done by using ONLY the class, mapping them to
         * bits 16 to 23 (up to 7 classes) in the mask passed,
         * e.g. CLASS_ERROR goes to bit 17 */
        if (dwClass > CLASS_FIRST)
        {
            dwMask = 1 << (dwClass + 16);
            
            if (dwMask & g_RtpDbgReg.dwFileTracingMask)
            {
                dwMask |= TRACE_NO_STDINFO | TRACE_USE_MASK;
            }
            else
            {
                goto end;
            }
        }
        else
        {
            goto end;
        }
    }

    va_start(arglist, lpszFormat);

    MSRtpTraceInternal((TCHAR *)g_psRtpDbgClass[dwClass],
                       dwMask,
                       lpszFormat,
                       arglist);

    va_end(arglist);

 end:
    if ((dwClass == CLASS_ERROR) &&
        (IsSetDebugOption(OPTDBG_BREAKONERROR)))
    {
        DebugBreak();
    }
}

/* This debug output will be controlled only by the
 * EnableFileTracing and EnableDebuggerTracing flags. */
void MSRtpTrace(
        TCHAR           *lpszFormat,
                         ...
    )
{
    va_list          arglist;

    va_start(arglist, lpszFormat);

    MSRtpTraceInternal((TCHAR *)g_psRtpDbgClass[CLASS_FIRST],
                       0xffff0000 | TRACE_NO_STDINFO ,
                       lpszFormat,
                       arglist);
    
    va_end(arglist);
}


void MSRtpTraceInternal(
        TCHAR           *psClass,
        DWORD            dwMask,
        TCHAR           *lpszFormat,
        va_list          arglist
    )
{
    SYSTEMTIME       SystemTime;
    char             sRtpDbgBuff[MAXDEBUGSTRINGLENGTH];
    TCHAR            sFormat[MAXDEBUGSTRINGLENGTH];
    int              len;

    double           dBeginTrace;
    
    TraceFunctionName("MSRtpTraceInternal");  
   
    if (IsSetDebugOption(OPTDBG_SPLITTIME))
    {
        /* retrieve local time */
        GetLocalTime(&SystemTime);

        len = sprintf(sRtpDbgBuff, "%02u:%02u:%02u.%03u ",
                      SystemTime.wHour,
                      SystemTime.wMinute,
                      SystemTime.wSecond,
                      SystemTime.wMilliseconds);
    }
    else
    {
        len = sprintf(sRtpDbgBuff,"%0.6f ",RtpGetTimeOfDay((RtpTime_t *)NULL));
    }

    _vsntprintf(sFormat, MAXDEBUGSTRINGLENGTH, lpszFormat, arglist);

    /* The output to file needs CR, LF (0xd, 0xa), otherwise notepad
     * will display a single long line, all the other editors are fine
     * with just LF */
    
#if defined(UNICODE)
    sprintf(&sRtpDbgBuff[len],
            "%ls %3X %3X %ls %ls%c%c",
            (char *)g_sRtpDbgModuleNameID,
            GetCurrentProcessId(),
            GetCurrentThreadId(),
            psClass,
            sFormat,
            0xd, 0xa);
#else
    sprintf(&sRtpDbgBuff[len],
            "%s %3X %3X %s %s%c%c",
            g_sRtpDbgModuleNameID,
            GetCurrentProcessId(),
            GetCurrentThreadId(),
            psClass,
            sFormat,
            0xd, 0xa);
#endif

    if (g_RtpDbgReg.dwEnableDebuggerTracing)
    {
        OutputDebugStringA(sRtpDbgBuff);
    }

#if USE_TRACING_FILE > 0
    if(g_dwRtpDbgTraceID)
    {
        dBeginTrace = RtpGetTimeOfDay(NULL);

        fputs(sRtpDbgBuff, g_dwRtpDbgTraceID);

        dBeginTrace = RtpGetTimeOfDay(NULL) - dBeginTrace;

        if (dBeginTrace > 0.1)
        {
            TraceRetail((
                    CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                    _T("%s: fputs took %0.3f seconds for: %hs"),
                    _fname, dBeginTrace, sRtpDbgBuff
                ));
        }
    }
#else
    if (g_dwRtpDbgTraceID != INVALID_TRACEID)
    {
        dBeginTrace = RtpGetTimeOfDay(NULL);

        /* Actually either file OR console tracing */
        TracePutsExA(g_dwRtpDbgTraceID, dwMask, sRtpDbgBuff);

        dBeginTrace = RtpGetTimeOfDay(NULL) - dBeginTrace;

        if (dBeginTrace > 0.1)
        {
            TraceDebug((
                    CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                    _T("%s: TracePutsExA took %0.3f seconds for: %hs"),
                    _fname, dBeginTrace, sRtpDbgBuff
                ));
        }
    }
#endif
}

HRESULT RtpDebugInit(TCHAR *psModuleName)
{
    BOOL             bOk;
    DWORD            dwMask;
    DWORD            dwError;
    TCHAR            sRtpDbgBuff[MAXDEBUGSTRINGLENGTH];

    /* Copy module name */
    lstrcpyn(g_sRtpDbgModuleNameID,
             psModuleName,
             sizeof(g_sRtpDbgModuleNameID)/sizeof(TCHAR));

    /* Read Advanced registry entries */
    RtpDebugReadRegistry(&g_RtpDbgReg);
    
    if (!g_RtpDbgReg.dwEnableFileTracing &&
        !g_RtpDbgReg.dwEnableDebuggerTracing)
    {
        /* If tracing is not enabled, don't even bother with more
         * initialization */
        return(NOERROR);
    }

    /* Register tracing using a modified name, e.g. dxmrtp_rtp */
    if (g_RtpDbgReg.dwEnableFileTracing)
    {
#if USE_TRACING_FILE > 0
        g_dwRtpDbgTraceID = fopen("c:\\tracing\\dxmrtp_rtp.log", "a+");
        
        if (!g_dwRtpDbgTraceID)
        {
            dwError = GetLastError();

            if (!g_RtpDbgReg.dwEnableDebuggerTracing)
            {
                return(RTPERR_FAIL);
            }
            else
            {
                /* Otherwise continue as debugger output is enabled */
            }
        }
#else
        g_dwRtpDbgTraceID = TraceRegister(g_sRtpDbgModuleNameID);

        if (g_dwRtpDbgTraceID == INVALID_TRACEID)
        {
            dwError = GetLastError();

            
            if (!g_RtpDbgReg.dwEnableDebuggerTracing)
            {
                return(RTPERR_FAIL);
            }
            else
            {
                /* Otherwise continue as debugger output is enabled */
            }
        }
#endif
    }
    
    /* This debug output will be controlled only by the
     * EnableFileTracing and EnableDebuggerTracing flags. */
    if (IsAdvancedTracingUsed())
    {
        dwMask = (g_RtpDbgReg.dwSetup >> 24) & 0xff;
    }
    else
    {
        dwMask = (g_RtpDbgReg.dwFileTracingMask >> 16) & 0xffff;
    }

    MSRtpTrace(_T("+=+=+=+=+=+=+= Initialize ")
               _T("0x%04X 0x%08X %u %hs ")
               _T("=+=+=+=+=+=+=+"),
               dwMask,
               g_RtpDbgReg.dwAdvancedOptions,
               g_RtpDbgReg.dwUseAdvancedTracing,
               rcs_rtpdbg
        );

    return(NOERROR);
}

HRESULT RtpDebugDeinit(void)
{
#if USE_TRACING_FILE > 0
    if (g_dwRtpDbgTraceID)
    {
        fclose(g_dwRtpDbgTraceID);
    }
#else
    /* Deregister tracing */
    if (g_dwRtpDbgTraceID != INVALID_TRACEID)
    {
        /* This will be a one time leak, which is of no consequence
         * when we are about to unload the DLL */
        TraceDeregister(g_dwRtpDbgTraceID);
        g_dwRtpDbgTraceID = INVALID_TRACEID;
    }
#endif
    return(NOERROR);
}

void RtpDebugReadRegistry(RtpDbgReg_t *pRtpDbgReg)
{
    DWORD            dwError;
    HKEY             hk;
    unsigned long    hkDataType;
    BYTE             hkData[64*sizeof(TCHAR_t)];
    TCHAR            sPath[64];
    unsigned long    hkDataSize;
    DWORD            i;
    DWORD            dwControl;
    DWORD            dwClassMask;

    /* Initialize structure */
    ZeroMemory(&g_RtpDbgReg, sizeof(g_RtpDbgReg));

    dwClassMask = 0;
    
    /* Read registry and assign values to g_RtpDbgReg */
    for(i = 0; g_dwRtpDbgRegCtrl[i]; i++)
    {
        dwControl = g_dwRtpDbgRegCtrl[i];

        if (REGOPEN(dwControl))
        {
            /* Build path */
            lstrcpy(sPath, RTPDBG_ROOTPATH);
            lstrcat(sPath, g_sRtpDbgModuleNameID);
            lstrcat(sPath, REGPATH(dwControl));
            
            /* Open root key, try read only first */
            dwError = RegOpenKeyEx(RTPDBG_ROOTKEY,
                                   sPath,
                                   0,
                                   RTPDBG_OPENREADONLY,
                                   &hk);
            
            /* if key doesn't exist try to create it */
            if (dwError !=  ERROR_SUCCESS)
            {
                dwError = RegCreateKeyEx(RTPDBG_ROOTKEY,
                                         sPath,
                                         0,
                                         NULL,
                                         0,
                                         RTPDBG_OPENKEYFLAGS,
                                         NULL,
                                         &hk,
                                         NULL);
            }
            
            if (dwError !=  ERROR_SUCCESS)
            {
                /* Move forward to next close */
                while(!REGCLOSE(dwControl))
                {
                    i++;
                    dwControl = g_dwRtpDbgRegCtrl[i];
                }

                continue;
            }
        }

        /* Read each key value in group */
        while(1)
        {
            /* Read key */
            hkDataSize = sizeof(hkData);
            dwError = RegQueryValueEx(hk,
                                      g_psRtpDbgInfo[i],
                                      0,
                                      &hkDataType,
                                      hkData,
                                      &hkDataSize);
            
            if ((dwError != ERROR_SUCCESS) || (hkDataType != REG_DWORD))
            {
                /* Try to create entry and set it to 0 */
                *(DWORD *)hkData = 0;
                
                RegSetValueEx(hk,
                              g_psRtpDbgInfo[i],
                              0,
                              REG_DWORD,
                              hkData,
                              sizeof(DWORD));

                /* Can not report errors yet */
                /* If this fails, assume the value is 0 */
            }

            *PDW(pRtpDbgReg, dwControl) = *(DWORD *)hkData;

            if (REGISCLASS(dwControl) && *PDW(pRtpDbgReg, dwControl))
            {
                /* Update the class mask for the entries that define a
                 * class and its registry value is non zero */
                RtpBitSet(dwClassMask, REGCLASS(dwControl) + 24);
            }
            
            if (REGCLOSE(dwControl))
            {
                break;
            }

            i++;
            dwControl = g_dwRtpDbgRegCtrl[i];
        }

        RegCloseKey(hk);
    }

    /* The following settings assume advanced tracing is enabled */
    if (pRtpDbgReg->dwDisableGroup)
    {
        /* If group is not used, reset bits */
        ZeroMemory(pRtpDbgReg->dwGroupArray,
                   sizeof(pRtpDbgReg->dwGroupArray));
        ZeroMemory(pRtpDbgReg->dwGroupArray2,
                   sizeof(pRtpDbgReg->dwGroupArray2));
    }
    else
    {
        if (IsSetDebugOption(OPTDBG_UNSELECT))
        {
            for(i = GROUP_FIRST + 1; i < GROUP_LAST; i++)
            {
                pRtpDbgReg->dwGroupArray2[i] =
                    pRtpDbgReg->dwGroupArray[i] & 0x00ffffff;

                pRtpDbgReg->dwGroupArray[i] = 0;
            }
        }
    }
    
    if (!pRtpDbgReg->dwDisableClass)
    {
        /* If class is not disabled, update it. Include group 0 for
         * the cases where group is not specified */
        for(i = GROUP_FIRST; i < GROUP_LAST; i++)
        {
            pRtpDbgReg->dwGroupArray[i] |= dwClassMask;
        }
    }

    if (pRtpDbgReg->dwEnableFileTracing || pRtpDbgReg->dwEnableConsoleTracing)
    {
        pRtpDbgReg->dwEnableFileTracing = 1;
    }

    /* I will use only one merged mask */
    pRtpDbgReg->dwFileTracingMask |= pRtpDbgReg->dwConsoleTracingMask;

    pRtpDbgReg->dwFileTracingMask &= 0xffff0000;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\msrtp\misc\rtpevent.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpevent.c
 *
 *  Abstract:
 *
 *    Post RTP/RTCP specific events
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/11/29 created
 *
 **********************************************************************/

#include "rtpmisc.h"

#include "rtpevent.h"
/*
      3                   2                   1                 
    1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Last event   |       |  Adj  |            Offset             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    \------v------/ \--v--/ \--v--/ \--------------v--------------/
           |           |       |                   |
           |           |       |                Offset (16)
           |           |       |
           |           |  Adjustment to the event (4)
           |           |
           |        Unused (4)
           |
      Last event (8)
*/
/*
 * Encoding macros
 */
#define CTRL(_last, _adj, _off) (((_last) << 24) | ((_adj) << 16) | (_off))
/* Offset to field */
#define OFF(_f)    ((DWORD) (((ULONG_PTR) &((RtpSess_t *)0)->_f) & 0xffff))

/*
 * Decoding macros
 * */
#define LAST(_ctrl)         (((_ctrl) >> 24) & 0xff)
#define ADJ(_ctrl)          (((_ctrl) >> 16) & 0xf)
#define OFFSET(_ctrl)       ((_ctrl) & 0xffff)
#define PDW(_sess,_ctrl)    ((DWORD *) ((char *)_sess + OFFSET(_ctrl)))

/*
 * WARNING
 *
 * The Adjustment is only a convinience to match the WSA QOS error to
 * the respective QOS event.
 * */
const DWORD g_dwEventControl[] = {
    CTRL(RTPRTP_LAST,     0,           OFF(dwEventMask)),    /* RTP */
    CTRL(RTPPARINFO_LAST, 0,           OFF(dwPartEventMask)),/* Participants */
    CTRL(RTPQOS_LAST,    RTPQOS_ADJUST,OFF(dwQosEventMask)), /* QOS */
    CTRL(RTPSDES_LAST,    0,           OFF(dwSdesEventMask)),/* SDES info */
    0
};

/*
 * WARNING
 *
 * The order in the following global arrays MUST be matched with the
 * entries in the enumerations in the public file msrtp.h
 * */

const TCHAR_t *g_psEventControlName[] = {
    _T("RTP"),
    _T("PINFO"),
    _T("QOS"),
    _T("SDES")
};

const TCHAR_t *g_psRtpRtpEvents[] = {
    _T("invalid"),
    _T("RR_RECEIVED"),
    _T("SR_RECEIVED"),
    _T("LOCAL_COLLISION"),
    _T("WS_RECV_ERROR"),
    _T("WS_SEND_ERROR"),
    _T("WS_NET_FAILURE"),
    _T("RECV_LOSSRATE"),
    _T("SEND_LOSSRATE"),
    _T("BANDESTIMATION"),
    _T("CRYPT_RECV_ERROR"),
    _T("CRYPT_SEND_ERROR"),
    _T("invalid")
};

const TCHAR_t *g_psRtpPInfoEvents[] = {
    _T("invalid"),
    _T("CREATED"),
    _T("SILENT"),
    _T("TALKING"),
    _T("WAS_TALKING"),
    _T("STALL"),
    _T("BYE"),
    _T("DEL"),
    _T("MAPPED"),
    _T("UNMAPPED"),
    _T("NETWORKCONDITION"),
    _T("invalid")
};

const TCHAR_t *g_psRtpQosEvents[] = {
    _T("invalid"),
    _T("NOQOS"),
    _T("RECEIVERS"),
    _T("SENDERS"),
    _T("NO_SENDERS"),
    _T("NO_RECEIVERS"),
    _T("REQUEST_CONFIRMED"),
    _T("ADMISSION_FAILURE"),
    _T("POLICY_FAILURE"),
    _T("BAD_STYLE"),
    _T("BAD_OBJECT"),
    _T("TRAFFIC_CTRL_ERROR"),
    _T("GENERIC_ERROR"),
    _T("ESERVICETYPE"),
    _T("EFLOWSPEC"),
    _T("EPROVSPECBUF"),
    _T("EFILTERSTYLE"),
    _T("EFILTERTYPE"),
    _T("EFILTERCOUNT"),
    _T("EOBJLENGTH"),
    _T("EFLOWCOUNT"),
    _T("EUNKOWNPSOBJ"),
    _T("EPOLICYOBJ"),
    _T("EFLOWDESC"),
    _T("EPSFLOWSPEC"),
    _T("EPSFILTERSPEC"),
    _T("ESDMODEOBJ"),
    _T("ESHAPERATEOBJ"),
    _T("RESERVED_PETYPE"),
    _T("NOT_ALLOWEDTOSEND"),
    _T("ALLOWEDTOSEND"),
    _T("invalid")
};

const TCHAR_t *g_psRtpSdesEvents[] = {
    _T("END"),
    _T("CNAME"),
    _T("NAME"),
    _T("EMAIL"),
    _T("PHONE"),
    _T("LOC"),
    _T("TOOL"),
    _T("NOTE"),
    _T("PRIV"),
    _T("ANY"),
    _T("invalid")
};

const TCHAR_t **g_ppsEventNames[] = {
    g_psRtpRtpEvents,
    g_psRtpPInfoEvents,
    g_psRtpQosEvents,
    g_psRtpSdesEvents
};
  
BOOL RtpPostEvent(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        DWORD            dwEventKind,
        DWORD            dwEvent,
        DWORD_PTR        dwPar1,
        DWORD_PTR        dwPar2
    )
{
    BOOL             bPosted;
    RtpSess_t       *pRtpSess;
    DWORD           *pdwEventMask;
    DWORD            dwControl;
    DWORD            dwSSRC;
    DWORD            i;

    TraceFunctionName("RtpPostEvent");

    if (dwEventKind >= RTPEVENTKIND_LAST)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTP, S_RTP_EVENT,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] ")
                _T("Invalid Kind:%u Event:%u Par1:0x%p Par2:0x%p"),
                _fname, pRtpAddr, pRtpUser,
                dwEventKind, dwEvent,
                dwPar1, dwPar2
            ));
  
        return(FALSE);
    }

    dwControl = g_dwEventControl[dwEventKind];

    if ((dwEvent < 1) || (dwEvent >= LAST(dwControl)))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTP, S_RTP_EVENT,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] ")
                _T("Kind:%s Invalid Event:%u Par1:0x%p Par2:0x%p"),
                _fname, pRtpAddr, pRtpUser,
                g_psEventControlName[dwEventKind], dwEvent,
                dwPar1, dwPar2
            ));
  
        return(FALSE);
    }
    
    pRtpSess = pRtpAddr->pRtpSess;

    if (pRtpUser)
    {
        dwSSRC = pRtpUser->dwSSRC;
    }
    else
    {
        dwSSRC = 0;
    }

    /* Event mask are in RtpSess_t */
    pdwEventMask = PDW(pRtpSess, dwControl);

    bPosted = FALSE;
    
    for(i = 0; i < 2; i++)
    {
        if (RtpBitTest(pRtpSess->dwSessFlags, FGSESS_EVENTRECV + i) &&
            RtpBitTest(pdwEventMask[i], dwEvent))
        {
            TraceDebug((
                    CLASS_INFO, GROUP_RTP, S_RTP_EVENT,
                    _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                    _T("%s Kind:%s Event:%s Par1:0x%p Par2:0x%p"),
                    _fname, pRtpAddr, pRtpUser, ntohl(dwSSRC),
                    RTPRECVSENDSTR(i),
                    g_psEventControlName[dwEventKind],
                    *(g_ppsEventNames[dwEventKind] + dwEvent),
                    dwPar1, dwPar2
                ));
            
            pRtpSess->pHandleNotifyEvent(
                    pRtpSess->pvSessUser[i],
                    RTPEVENTBASE +
                    RTPEVNTRANGE * dwEventKind +
                    ADJ(dwControl) + dwEvent,
                    dwPar1,
                    dwPar2);

            bPosted = TRUE;
        }
        else
        {
            TraceDebugAdvanced((
                    0, GROUP_RTP, S_RTP_EVENT,
                    _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                    _T("%s Kind:%s Unposted Event:%s Par1:0x%p Par2:0x%p"),
                    _fname, pRtpAddr, pRtpUser, ntohl(dwSSRC),
                    RTPRECVSENDSTR(i),
                    g_psEventControlName[dwEventKind],
                    *(g_ppsEventNames[dwEventKind] + dwEvent),
                    dwPar1, dwPar2
                ));
        }
    }

    return(bPosted);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\msrtp\misc\rtpcrit.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpcrit.c
 *
 *  Abstract:
 *
 *    Wrap for the Rtl critical sections
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/25 created
 *
 **********************************************************************/

#include "gtypes.h"

#include "rtpcrit.h"

BOOL RtpInitializeCriticalSection(
        RtpCritSect_t   *pRtpCritSect,
        void            *pvOwner,
        TCHAR           *pName
    )
{
    DWORD            SpinCount;
    
    TraceFunctionName("RtpInitializeCriticalSection");

    if (pvOwner &&
        pRtpCritSect->dwObjectID != OBJECTID_RTPCRITSECT)
    {
        pRtpCritSect->pvOwner = pvOwner;

        pRtpCritSect->pName = pName;

        /* Set bit 31 to 1 to preallocate the event object, and set
         * the spin count that is used in multiprocessor environments
         * */
        SpinCount = 0x80000000 | 1000;
        
        if (!InitializeCriticalSectionAndSpinCount(&pRtpCritSect->CritSect,
                                                   SpinCount))
        {
            /* if the initialization fails, set pvOwner to NULL */
            pRtpCritSect->pvOwner = NULL;

            return (FALSE);
        }

        pRtpCritSect->dwObjectID = OBJECTID_RTPCRITSECT;
        
        return(TRUE);
    }
    else
    {
        if (!pvOwner)
        {
            TraceRetail((
                    CLASS_ERROR, GROUP_CRITSECT, S_CRITSECT_INIT,
                    _T("%s: pRtpCritSect[0x%p] Invalid argument"),
                    _fname, pRtpCritSect
                ));
        }

        if (pRtpCritSect->dwObjectID == OBJECTID_RTPCRITSECT)
        {
            TraceRetail((
                    CLASS_ERROR, GROUP_CRITSECT, S_CRITSECT_INIT,
                    _T("%s: pRtpCritSect[0x%p] seems to be initialized"),
                    _fname, pRtpCritSect
                ));
        }
    }
    
    return(FALSE);
}

BOOL RtpDeleteCriticalSection(RtpCritSect_t *pRtpCritSect)
{
    TraceFunctionName("RtpDeleteCriticalSection");

    if (pRtpCritSect->pvOwner &&
        pRtpCritSect->dwObjectID == OBJECTID_RTPCRITSECT)
    {
        /* Invalidate object */
        INVALIDATE_OBJECTID(pRtpCritSect->dwObjectID);

        DeleteCriticalSection(&pRtpCritSect->CritSect);
    }
    else
    {
        if (!pRtpCritSect->pvOwner)
        {
            TraceRetail((
                    CLASS_ERROR, GROUP_CRITSECT, S_CRITSECT_INIT,
                    _T("%s: pRtpCritSect[0x%p] not initialized"),
                    _fname, pRtpCritSect
                ));
        }

        if (pRtpCritSect->dwObjectID != OBJECTID_RTPCRITSECT)
        {
            TraceRetail((
                    CLASS_ERROR, GROUP_CRITSECT, S_CRITSECT_INIT,
                    _T("%s: pRtpCritSect[0x%p] Invalid object ID 0x%X != 0x%X"),
                    _fname, pRtpCritSect,
                    pRtpCritSect->dwObjectID, OBJECTID_RTPCRITSECT
                ));
        }

        return(FALSE);
    }

    return(TRUE);
}

BOOL RtpEnterCriticalSection(RtpCritSect_t *pRtpCritSect)
{
    BOOL             bOk;
    
    TraceFunctionName("RtpEnterCriticalSection");

    if (pRtpCritSect->pvOwner &&
        pRtpCritSect->dwObjectID == OBJECTID_RTPCRITSECT)
    {
        EnterCriticalSection(&pRtpCritSect->CritSect);

        bOk = TRUE;
    }
    else
    {
        bOk = FALSE;

        if (!pRtpCritSect->pvOwner)
        {
            TraceRetail((
                    CLASS_ERROR, GROUP_CRITSECT, S_CRITSECT_ENTER,
                    _T("%s: pRtpCritSect[0x%p] not initialized"),
                    _fname, pRtpCritSect
                ));
        }

        if (pRtpCritSect->dwObjectID != OBJECTID_RTPCRITSECT)
        {
            TraceRetail((
                    CLASS_ERROR, GROUP_CRITSECT, S_CRITSECT_ENTER,
                    _T("%s: pRtpCritSect[0x%p] Invalid object ID 0x%X != 0x%X"),
                    _fname, pRtpCritSect,
                    pRtpCritSect->dwObjectID, OBJECTID_RTPCRITSECT
                ));
        }
    }

    return(bOk);
}

BOOL RtpLeaveCriticalSection(RtpCritSect_t *pRtpCritSect)
{
    BOOL             bOk;

    TraceFunctionName("RtpLeaveCriticalSection");

    if (pRtpCritSect->pvOwner &&
        pRtpCritSect->dwObjectID == OBJECTID_RTPCRITSECT)
    {
        LeaveCriticalSection(&pRtpCritSect->CritSect);

        bOk = TRUE;
    }
    else
    {
        bOk = FALSE;

        if (!pRtpCritSect->pvOwner)
        {
            TraceRetail((
                    CLASS_ERROR, GROUP_CRITSECT, S_CRITSECT_ENTER,
                    _T("%s: pRtpCritSect[0x%p] not initialized"),
                    _fname, pRtpCritSect
                ));
        }

        if (pRtpCritSect->dwObjectID != OBJECTID_RTPCRITSECT)
        {
            TraceRetail((
                    CLASS_ERROR, GROUP_CRITSECT, S_CRITSECT_ENTER,
                    _T("%s: pRtpCritSect[0x%p] Invalid object ID 0x%X != 0x%X"),
                    _fname, pRtpCritSect,
                    pRtpCritSect->dwObjectID, OBJECTID_RTPCRITSECT
                ));
        }
    }

    return(bOk);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\msrtp\misc\rtpmask.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpmask.c
 *
 *  Abstract:
 *
 *    Used to modify or test the different masks in a RtpSess_t
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/11/24 created
 *
 **********************************************************************/

#include "rtpmask.h"

#define SESSOFFSET(_f) ((DWORD) ((ULONG_PTR) &((RtpSess_t *)0)->_f))

/* Features mask */
#define FEATURE   SESSOFFSET(dwFeatureMask)

/* RTP events masks */
#define RTPEVENTR SESSOFFSET(dwEventMask[0])
#define RTPEVENTS SESSOFFSET(dwEventMask[1])

/* Participant events mask */
#define PARTEVENTR SESSOFFSET(dwPartEventMask[0])
#define PARTEVENTS SESSOFFSET(dwPartEventMask[1])

/* QOS events masks */
#define QOSEVENTR SESSOFFSET(dwQosEventMask[0])
#define QOSEVENTS SESSOFFSET(dwQosEventMask[1])

/* SDES events mask */
#define SDESEVENTR SESSOFFSET(dwSdesEventMask[0])
#define SDESEVENTS SESSOFFSET(dwSdesEventMask[1])

/* SDES information masks */
#define SDESMASKL SESSOFFSET(dwSdesMask[0])
#define SDESMASKR SESSOFFSET(dwSdesMask[1])

#define PDWORDMASK(_sess, _off) RTPDWORDPTR(_sess, _off)

/*
 * !!! WARNING !!!
 *
 * Order in the enumeration in public file msrtp.h (RTPMASK_FIRST,
 * RTPMASK_FEATURES_MASK, RTPMASK_RECV_EVENTS, etc) MUST match the
 * offsets in global array g_dwRtpSessionMask (rtpmask.c)
 * */
const DWORD g_dwRtpSessionMask[] =
{
    -1,

    /* Features mask */
    FEATURE,

    /* RTP events masks */
    RTPEVENTR,
    RTPEVENTS,

    /* Participant events mask */
    PARTEVENTR,
    PARTEVENTS,

    /* QOS events masks */
    QOSEVENTR,
    QOSEVENTS,

    /* SDES events mask */
    SDESEVENTR,
    SDESEVENTS,
    
    /* SDES information masks */
    SDESMASKL,
    SDESMASKR,
    
    -1
};

const TCHAR *g_sRtpMaskName[] =
{
    _T("invalid"),
    
    _T("FEATURES_MASK"),
    
    _T("RECV_EVENTS"),
    _T("SEND_EVENTS"),
    
    _T("PINFOR_EVENTS"),
    _T("PINFOS_EVENTS"),
    
    _T("QOSRECV_EVENTS"),
    _T("QOSSEND_EVENTS"),
    
    _T("SDESRECV_EVENTS"),
    _T("SDESSEND_EVENTS"),
    
    _T("SDESLOCAL_MASK"),
    _T("SDESREMOTE_MASK"),

    _T("invalid")
};

/* Modify the mask specified by dwKind (e.g. RTPMASK_RECV_EVENTS,
 * RTPMASK_SDES_LOCMASK).
 *
 * dwMask is the mask of bits to be set or reset depending on dwValue
 * (reset if 0, set otherwise).
 *
 * pdwModifiedMask will return the resulting mask if the pointer is
 * not NULL. You can just query the current mask value by passing
 * dwMask=0 */
HRESULT RtpModifyMask(
        RtpSess_t       *pRtpSess,
        DWORD            dwKind,
        DWORD            dwMask,
        DWORD            dwValue,
        DWORD           *pdwModifiedMask
    )
{
    HRESULT          hr;
    BOOL             bOk;
    DWORD            dwError;
    DWORD           *pdwMask;

    TraceFunctionName("RtpModifyMask");

    if (!pRtpSess)
    {
        /* Having this as a NULL pointer means Init hasn't been
         * called, return this error instead of RTPERR_POINTER to be
         * consistent */
        hr = RTPERR_INVALIDSTATE;

        goto end;
    }

    if (pRtpSess->dwObjectID != OBJECTID_RTPSESS)
    {
        hr = RTPERR_INVALIDRTPSESS;

        TraceRetail((
                CLASS_ERROR, GROUP_SETUP, S_SETUP_GLOB,
                _T("%s: pRtpSess[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpSess,
                pRtpSess->dwObjectID, OBJECTID_RTPSESS
            ));

        goto end;
    }

    if (dwKind <= RTPMASK_FIRST || dwKind >= RTPMASK_LAST)
    {
        hr = RTPERR_INVALIDARG;
        
        TraceRetail((
                CLASS_ERROR, GROUP_SETUP, S_SETUP_GLOB,
                _T("%s: pRtpSess[0x%p] Invalid mask kind: %u"),
                _fname, pRtpSess,
                dwKind
            ));
        goto end;
    }

    bOk = RtpEnterCriticalSection(&pRtpSess->SessCritSect);

    if (!bOk)
    {
        hr = RTPERR_CRITSECT;

        TraceRetail((
                CLASS_ERROR, GROUP_SETUP, S_SETUP_GLOB,
                _T("%s: pRtpSess[0x%p] Critical section failed"),
                _fname, pRtpSess
            ));

        goto end;
    }

    hr = NOERROR;
    
    pdwMask = PDWORDMASK(pRtpSess, g_dwRtpSessionMask[dwKind]);

    if (dwValue)
    {
        /* Set */
        *pdwMask |= dwMask;

        dwValue = 1;
        
        TraceDebug((
                CLASS_INFO, GROUP_SETUP, S_SETUP_GLOB,
                _T("%s: pRtpSess[0x%p] Set bits in %s: 0x%X ")
                _T("(0x%X)"),
                _fname, pRtpSess,
                g_sRtpMaskName[dwKind],
                dwMask,
                *pdwMask
            ));
    }
    else
    {
        /* Reset */
        *pdwMask &= ~dwMask;

        TraceDebug((
                CLASS_INFO, GROUP_SETUP, S_SETUP_GLOB,
                _T("%s: pRtpSess[0x%p] Reset bits in %s: 0x%X ")
                _T("(0x%X)"),
                _fname, pRtpSess,
                g_sRtpMaskName[dwKind],
                dwMask,
                *pdwMask
            ));
    }

    if (pdwModifiedMask)
    {
        /* Query */
        *pdwModifiedMask = *pdwMask;
    }

    TraceRetailAdvanced((
            CLASS_INFO, GROUP_SETUP, S_SETUP_GLOB,
            _T("%s: pRtpSess[0x%p] Current %s:0x%X mask:0x%X/%u"),
            _fname, pRtpSess,
            g_sRtpMaskName[dwKind], *pdwMask,
            dwMask, dwValue
        ));
    
    RtpLeaveCriticalSection(&pRtpSess->SessCritSect);

 end:
    
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\msrtp\misc\rtpheap.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpheap.c
 *
 *  Abstract:
 *
 *    Implements the private heaps handling
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/24 created
 *
 **********************************************************************/

#include "rtpque.h"
#include "rtpcrit.h"
#include "rtpdbg.h"
#include "rtpglobs.h"

#include "rtpheap.h"

/*
 * The master heap is used to create unique global RTP heaps, all the
 * heaps created are kept together in the free and busy queues */
RtpHeap_t      g_RtpHeapMaster;
RtpHeap_t     *g_pRtpHeapMaster = NULL;
RtpQueue_t     g_RtpHeapsQ;
RtpCritSect_t  g_RtpHeapsCritSect;

/* Forward declaration of helper functions */
BOOL RtpHeapInit(RtpHeap_t *pRtpHeap, BYTE bTag, long lSize, void *pvOwner);
BOOL RtpHeapDelete(RtpHeap_t *pRtpHeap);
BOOL RtpHeapVerifySignatures(
        RtpHeap_t       *pRtpHeap,
        RtpHeapBlockBegin_t *pBlockBegin,
        DWORD            dwSignature /* BSY | FRE */
    );

/*
 * Helper function for RtpHeapCreate.
 *
 * Initializes a RTP heap. The real heap is created, the critical
 * section initialized, and the other fields properly initialized. */
BOOL RtpHeapInit(RtpHeap_t *pRtpHeap, BYTE bTag, long lSize, void *pvOwner)
{
    ZeroMemory(pRtpHeap, sizeof(RtpHeap_t));

    /* set object ID */
    pRtpHeap->dwObjectID = OBJECTID_RTPHEAP;

    /* save tag to apply to each block allocated */
    pRtpHeap->bTag = bTag;

    if (lSize > 0)
    {
        lSize = (lSize + sizeof(DWORD) - 1) & ~(sizeof(DWORD) - 1);
    
        pRtpHeap->lSize = lSize;
    }

    /* create real heap, initial size of 1 will be rounded up to the
     * page size */
    if ( !(pRtpHeap->hHeap = HeapCreate(HEAP_NO_SERIALIZE, 1, 0)) )
    {
        /* TODO log error */
        goto bail;
    }

    /* initialize critical section */
    if ( !(RtpInitializeCriticalSection(&pRtpHeap->RtpHeapCritSect,
                                        pvOwner,
                                        _T("RtpHeapCritSect"))) )
    {
        /* TODO log error */
        goto bail;
    }

    enqueuef(&g_RtpHeapsQ,
             &g_RtpHeapsCritSect,
             &pRtpHeap->QueueItem);
            
    return(TRUE);
    
 bail:
    if (pRtpHeap->hHeap) {
        
        HeapDestroy(pRtpHeap->hHeap);
    }

    pRtpHeap->hHeap = NULL;
    
    RtpDeleteCriticalSection(&pRtpHeap->RtpHeapCritSect);

    return(FALSE);
}

/*
 * Helper function for RtpHeapDestroy.
 *
 * Destroys real heap and deletes critical section. Testing the object
 * is not necessary, this function is not exposed, instead, test in
 * RtpHeapDestroy */
BOOL RtpHeapDelete(RtpHeap_t *pRtpHeap)
{
    DWORD            bTag;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpHeapBlockBegin_t *pBlockBegin;
    
    TraceFunctionName("RtpHeapDelete");

    dequeue(&g_RtpHeapsQ,
            &g_RtpHeapsCritSect,
            &pRtpHeap->QueueItem);
    
    /* Check if BusyQ is empty */
    if ( !IsQueueEmpty(&pRtpHeap->BusyQ) )
    {
        bTag = 0;

        if (pRtpHeap->bTag < TAGHEAP_LAST)
        {
            bTag = pRtpHeap->bTag;
        }
        
        TraceRetail((
                CLASS_ERROR, GROUP_HEAP, S_HEAP_INIT,
                _T("%s: Heap[0x%p] tag:0x%X:%s ")
                _T("Busy queue is not empty:%d"),
                _fname, pRtpHeap,
                bTag, g_psRtpTags[bTag], GetQueueSize(&pRtpHeap->BusyQ)
            ));

        /* In debug builds dump the objects */
        while( (pRtpQueueItem = dequeuef(&pRtpHeap->BusyQ,
                                         &pRtpHeap->RtpHeapCritSect)) )
        {
            pBlockBegin = (RtpHeapBlockBegin_t *)
                ( (char *)pRtpQueueItem -
                  sizeof(RtpHeapBlockBegin_t) );
                
            TraceRetailAdvanced((
                    CLASS_INFO, GROUP_HEAP, S_HEAP_INIT,
                    _T("%s: Heap[0x%p] block[0x%p:%u] ")
                    _T("0x%X 0x%X 0x%X 0x%X"),
                    _fname, pRtpHeap, pBlockBegin, pBlockBegin->lSize,
                    ((DWORD *)(pRtpQueueItem + 1))[0],
                    ((DWORD *)(pRtpQueueItem + 1))[1],
                    ((DWORD *)(pRtpQueueItem + 1))[2],
                    ((DWORD *)(pRtpQueueItem + 1))[3]
                ));
        }
    }

    /* Invalidate object ID */
    INVALIDATE_OBJECTID(pRtpHeap->dwObjectID);

    /* Make segments inaccessible */
    ZeroMemory(&pRtpHeap->FreeQ, sizeof(RtpQueue_t));

    ZeroMemory(&pRtpHeap->BusyQ, sizeof(RtpQueue_t));

    if (pRtpHeap->hHeap)
    {
        HeapDestroy(pRtpHeap->hHeap);
    }

    pRtpHeap->hHeap = NULL;
    
    RtpDeleteCriticalSection(&pRtpHeap->RtpHeapCritSect);

    return(TRUE);
}

/*
 * The master heap must be created before any private RTP heap can be
 * created */
BOOL RtpCreateMasterHeap(void)
{
    BOOL bStatus;
    
    if (g_pRtpHeapMaster)
    {
        /* TODO log error */
        return(FALSE);
    }

    bStatus = RtpInitializeCriticalSection(&g_RtpHeapsCritSect,
                                           (void *)&g_pRtpHeapMaster,
                                           _T("g_RtpHeapsCritSect"));

    if (bStatus)
    {
        ZeroMemory(&g_RtpHeapsQ, sizeof(g_RtpHeapsQ));
    
        bStatus = RtpHeapInit(&g_RtpHeapMaster, TAGHEAP_RTPHEAP,
                              sizeof(RtpHeap_t), &g_RtpHeapMaster);

        if (bStatus)
        {
            g_pRtpHeapMaster = &g_RtpHeapMaster;
            
            return(TRUE);
        }
    }

    return(FALSE);
}

/*
 * The master heap is deleted when none of the memory allocated from
 * any private heap is in use. It is expected that when this function
 * is called, there will not be any heap left in the busy queue. */
BOOL RtpDestroyMasterHeap(void)
{
    if (!g_pRtpHeapMaster)
    {
        /* TODO log error */
        return(FALSE);
    }

    RtpHeapDelete(g_pRtpHeapMaster);
    
    RtpDeleteCriticalSection(&g_RtpHeapsCritSect);
    
    g_pRtpHeapMaster = NULL;

    return(TRUE);
}

/*
 * Creates a private heap from the master heap. The structure is
 * obtained from the master heap, the real heap is created, the
 * critical section initialized, and the other fields properly
 * initialized. */
RtpHeap_t *RtpHeapCreate(BYTE bTag, long lSize)
{
    BOOL       bStatus;
    RtpHeap_t *pNewHeap;
    long       lNewSize;
    
    if (!g_pRtpHeapMaster)
    {
        /* TODO log error */
        return(NULL);
    }
    
    if ( (pNewHeap = (RtpHeap_t *)
          RtpHeapAlloc(g_pRtpHeapMaster, sizeof(RtpHeap_t))) ) {
        /* initialize heap */

        bStatus = RtpHeapInit(pNewHeap, bTag, lSize, g_pRtpHeapMaster);

        if (bStatus)
        {
            return(pNewHeap);
        }
    }

    /* failure */
    if (pNewHeap)
    {
        RtpHeapFree(g_pRtpHeapMaster, (void *)pNewHeap);
        pNewHeap = NULL;
    }

    /* TODO log error */
    return(pNewHeap);
}

/*
 * Destroys a private heap. The structure is returned to the master
 * heap, the real heap is destroyed and the critical section
 * deleted. It is expected that the busy queue be empty.
 * */
BOOL RtpHeapDestroy(RtpHeap_t *pRtpHeap)
{
    BOOL       bStatus;
    
    TraceFunctionName("RtpHeapDestroy");

    if (!pRtpHeap || !g_pRtpHeapMaster)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_HEAP, S_HEAP_INIT,
                _T("%s: Heap[0x%p] Master[0x%p] Null pointer"),
                _fname, pRtpHeap, g_pRtpHeapMaster
            ));

        return(FALSE);
    }

    /* verify object ID */
    if (pRtpHeap->dwObjectID != OBJECTID_RTPHEAP)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_HEAP, S_HEAP_INIT,
                _T("%s: Heap[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpHeap,
                pRtpHeap->dwObjectID, OBJECTID_RTPHEAP
            ));

        return(FALSE);
    }

    bStatus = RtpHeapDelete(pRtpHeap);

    if (bStatus)
    {
        bStatus = RtpHeapFree(g_pRtpHeapMaster, (void *)pRtpHeap);
        
        if (bStatus) {
            return(TRUE);
        }
    }

    /* TODO log error */
    return(FALSE);
}

/*
 * If the size requested is the same as the heap's initially set, then
 * look first in the free list then create a new block. If the size is
 * different, just create a new block. In both cases the block will be
 * left in the busy queue. */
void *RtpHeapAlloc(RtpHeap_t *pRtpHeap, long lSize)
{
    BOOL                 bSigOk;
    long                 lNewSize;
    long                 lTotalSize;
    RtpHeapBlockBegin_t *pBlockBegin;
    RtpHeapBlockEnd_t   *pBlockEnd;
    DWORD                bTag;
    long                 lMaxMem;
    
    char            *pcNew;
    char            *ptr;
    DWORD           dwSignature;
    
    TraceFunctionName("RtpHeapAlloc");
    
    if (!pRtpHeap)
    {
        /* TODO log error */
        return(NULL);
    }

    /* verify object ID */
    if (pRtpHeap->dwObjectID != OBJECTID_RTPHEAP)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_HEAP, S_HEAP_ALLOC,
                _T("%s: Heap[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpHeap,
                pRtpHeap->dwObjectID, OBJECTID_RTPHEAP
            ));

        return(NULL);
    }
    
    pcNew = NULL;
    lNewSize = RTP_ALIGNED_SIZE(lSize);
    lTotalSize =
        lNewSize +
        sizeof(RtpHeapBlockBegin_t) +
        sizeof(RtpQueueItem_t) +
        sizeof(RtpHeapBlockEnd_t);

    if (!RtpEnterCriticalSection(&pRtpHeap->RtpHeapCritSect))
    {
        /* TODO log error */
        return(NULL);
    }

    if (!pRtpHeap->lSize)
    {
        /* Heap was initialized to size 0, keep objects allocated that
         * are the size of the first object allocated */
        pRtpHeap->lSize = lNewSize;
    }
   
    if (lNewSize == pRtpHeap->lSize && pRtpHeap->FreeQ.lCount > 0)
    {
        /* get from free queue */
        ptr = (char *)dequeuef(&pRtpHeap->FreeQ, NULL);

        /* move pointer back to begining of block */
        pBlockBegin = (RtpHeapBlockBegin_t *)
            (ptr - sizeof(RtpHeapBlockBegin_t));

        /* Verify that signatures are fine, i.e. buffer must be marked
         * as free */
        bSigOk = RtpHeapVerifySignatures(pRtpHeap, pBlockBegin, TAGHEAP_FRE);

        if (!bSigOk)
        {
            goto bail;
        }
    }
    else
    {
        /* get a new block from real heap */
        /* TODO obtain 1 memory page and insert in FreeQ as many
           objects as can be obtained from that page */
        pBlockBegin = (RtpHeapBlockBegin_t *)
            HeapAlloc(pRtpHeap->hHeap, 0, lTotalSize);

        if (pBlockBegin)
        {
            lMaxMem = InterlockedExchangeAdd(&g_RtpContext.lMemAllocated,
                                             lTotalSize);

            if (lMaxMem > g_RtpContext.lMaxMemAllocated)
            {
                g_RtpContext.lMaxMemAllocated = lMaxMem;
            }
        }
    }

    if (pBlockBegin)
    {
        /* initialize block */

        /* begin signature */
        dwSignature = TAGHEAP_BSY; /* RTP */
        dwSignature |= (pRtpHeap->bTag << 24);
        pBlockBegin->BeginSig = dwSignature;
        pBlockBegin->InvBeginSig = ~dwSignature;

        /* initialize other fields of block */
        pBlockBegin->lSize = lNewSize;
        pBlockBegin->dwFlag = 0;
        
        /* insert item into busy queue */
        ptr = (char *) (pBlockBegin + 1);
        ZeroMemory(ptr, sizeof(RtpQueueItem_t));
        enqueuel(&pRtpHeap->BusyQ, NULL, (RtpQueueItem_t *)ptr);
        ptr += sizeof(RtpQueueItem_t);

        /* set begining of buffer returned */
        pcNew = ptr;

        /* set end signature */
        pBlockEnd = (RtpHeapBlockEnd_t *)(ptr + lNewSize);
        dwSignature = TAGHEAP_END; /* END */
        dwSignature |= (pRtpHeap->bTag << 24);
        pBlockEnd->EndSig = dwSignature;
        pBlockEnd->InvEndSig = ~dwSignature;

        TraceDebugAdvanced((
                0, GROUP_HEAP, S_HEAP_ALLOC,
                _T("%s: Heap[0x%p] %s/%d Begin[0x%p] Data[0x%p] Size:%d/%d"),
                _fname, pRtpHeap, g_psRtpTags[pRtpHeap->bTag], pRtpHeap->lSize,
                pBlockBegin, pcNew, lTotalSize, lNewSize
            ));
    }
    else
    {
        bTag = 0;

        if (pRtpHeap->bTag < TAGHEAP_LAST)
        {
            bTag = pRtpHeap->bTag;
        }

        TraceRetail((
                CLASS_ERROR, GROUP_HEAP, S_HEAP_ALLOC,
                _T("%s: Heap[0x%p] tag:0x%X:%s ")
                _T("failed to allocate memory: %d/%d/%d"),
                _fname, pRtpHeap, bTag, g_psRtpTags[bTag],
                lSize, lNewSize, lTotalSize
            ));
    }

 bail:
    RtpLeaveCriticalSection(&pRtpHeap->RtpHeapCritSect);

    return((void *)pcNew);
}

/*
 * If the block is the same size as the heap's initially set, put it
 * in the free queue, otherwise destroy it. */
BOOL RtpHeapFree(RtpHeap_t *pRtpHeap, void *pvMem)
{
    BOOL                 bSigOk;
    DWORD                dwSignature;
    RtpQueueItem_t      *pRtpQueueItem;
    RtpHeapBlockBegin_t *pBlockBegin;
    RtpHeapBlockEnd_t   *pBlockEnd;
    DWORD                bTag;
    long                 lTotalSize;

    TraceFunctionName("RtpHeapFree");

    if (!pRtpHeap || !pvMem)
    {
        /* TODO log error */
        return(FALSE);
    }

    /* verify object ID */
    if (pRtpHeap->dwObjectID != OBJECTID_RTPHEAP)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_HEAP, S_HEAP_FREE,
                _T("%s: Heap[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpHeap,
                pRtpHeap->dwObjectID, OBJECTID_RTPHEAP
            ));
        
        return(FALSE);
    }
    
    pBlockBegin = (RtpHeapBlockBegin_t *)
        ( (char *)pvMem -
          sizeof(RtpQueueItem_t) -
          sizeof(RtpHeapBlockBegin_t) );

    if (!RtpEnterCriticalSection(&pRtpHeap->RtpHeapCritSect))
    {
        /* TODO log error */
        return(FALSE);
    }

    /* move from busy to free, dequeue and enqueue */

    pRtpQueueItem = dequeue(&pRtpHeap->BusyQ,
                            NULL,
                            (RtpQueueItem_t *)(pBlockBegin + 1));

    /* If the block was not in BusyQ, fail */
    if (!pRtpQueueItem)
    {
        bTag = 0;

        if (pRtpHeap->bTag < TAGHEAP_LAST)
        {
            bTag = pRtpHeap->bTag;
        }
        
        TraceRetail((
                CLASS_ERROR, GROUP_HEAP, S_HEAP_FREE,
                _T("%s: Heap[0x%p] tag:0x%X:%s ")
                _T("block[0x%p] was not in busy queue"),
                _fname, pRtpHeap,
                bTag, g_psRtpTags[bTag], pBlockBegin
            ));
        
        goto bail;
    }

    /* Verify signatures are valid (must be busy) */
    bSigOk = RtpHeapVerifySignatures(pRtpHeap, pBlockBegin, TAGHEAP_BSY);

    if (!bSigOk)
    {
        goto bail;
    }
                                     
    /* modify begin signature */
    dwSignature = TAGHEAP_FRE; /* FREE */
    dwSignature |= (pRtpHeap->bTag << 24);
    pBlockBegin->BeginSig = dwSignature;
    pBlockBegin->InvBeginSig = ~dwSignature;

    /* Total size that was allocated */
    lTotalSize = pBlockBegin->lSize + (sizeof(RtpHeapBlockBegin_t) +
                                       sizeof(RtpQueueItem_t) +
                                       sizeof(RtpHeapBlockEnd_t));

    TraceDebugAdvanced((
            0, GROUP_HEAP, S_HEAP_FREE,
            _T("%s: Heap[0x%p] %s/%d Begin[0x%p] Data[0x%p] Size:%d/%d"),
            _fname, pRtpHeap, g_psRtpTags[pRtpHeap->bTag], pRtpHeap->lSize,
            pBlockBegin, pvMem, lTotalSize, pBlockBegin->lSize
        ));
    
    if (pRtpHeap->lSize == pBlockBegin->lSize &&
        !IsSetDebugOption(OPTDBG_FREEMEMORY))
    {
        /* If same size, save in FreeQ for reuse */
        
        enqueuef(&pRtpHeap->FreeQ,
                 NULL,
                 pRtpQueueItem);
    }
    else
    {
        /* Otherwise release block to real heap */

        HeapFree(pRtpHeap->hHeap, 0, (void *)pBlockBegin);

        InterlockedExchangeAdd(&g_RtpContext.lMemAllocated, -lTotalSize);
    }
    
    RtpLeaveCriticalSection(&pRtpHeap->RtpHeapCritSect);

    return(TRUE);

 bail:
    RtpLeaveCriticalSection(&pRtpHeap->RtpHeapCritSect);

    return(FALSE);
}

BOOL RtpHeapVerifySignatures(
        RtpHeap_t       *pRtpHeap,
        RtpHeapBlockBegin_t *pBlockBegin,
        DWORD            dwSignature /* BSY | FRE */
    )
{
    BOOL             bSigOk;
    DWORD            bTag;
    DWORD            dwDbgSelection;
    RtpHeapBlockEnd_t *pBlockEnd;
    TCHAR_t          *_fname;

    bSigOk = TRUE;

    if (dwSignature == TAGHEAP_BSY)
    {
        /* Called from RtpHeapFree */
        dwDbgSelection = S_HEAP_FREE;
        _fname = _T("RtpHeapFree");
    }
    else /* dwSignature == TAGHEAP_FRE */
    {
        /* Called from RtpHeapAlloc */
        dwDbgSelection = S_HEAP_ALLOC;
        _fname = _T("RtpHeapAlloc");
    }
    
    /* Verify if begin signature is valid  */
    
    dwSignature |= (pRtpHeap->bTag << 24);

    if ( (pBlockBegin->BeginSig != dwSignature) ||
         (pBlockBegin->InvBeginSig != ~dwSignature) )
    {
        bTag = 0;

        if (pRtpHeap->bTag < TAGHEAP_LAST)
        {
            bTag = pRtpHeap->bTag;
        }
        
        TraceRetail((
                CLASS_ERROR, GROUP_HEAP, dwDbgSelection,
                _T("%s: Heap[0x%p] tag:0x%X:%s ")
                _T("block[0x%p:%u] has invalid begin signature 0x%X != 0x%X"),
                _fname, pRtpHeap, pBlockBegin->lSize,
                bTag, g_psRtpTags[bTag],
                pBlockBegin, pBlockBegin->BeginSig, dwSignature
            ));

        bSigOk = FALSE;
        
        goto end;
    }

    /* Verify if ending signature is valid  */

    pBlockEnd = (RtpHeapBlockEnd_t *)
        ((char *)(pBlockBegin + 1) +
         sizeof(RtpQueueItem_t) +
         pBlockBegin->lSize);

    dwSignature = TAGHEAP_END; /* END */
    dwSignature |= (pRtpHeap->bTag << 24);

    if ( (pBlockEnd->EndSig != dwSignature) ||
         (pBlockEnd->InvEndSig != ~dwSignature) )
    {
        bTag = 0;

        if (pRtpHeap->bTag < TAGHEAP_LAST)
        {
            bTag = pRtpHeap->bTag;
        }

        TraceRetail((
                CLASS_ERROR, GROUP_HEAP, dwDbgSelection,
                _T("%s: Heap[0x%p] tag:0x%X:%s ")
                _T("block[0x%p/0x%p:%u] has invalid end signature 0x%X != 0x%X"),
                _fname, pRtpHeap,
                bTag, g_psRtpTags[bTag],
                pBlockBegin, pBlockEnd, pBlockBegin->lSize,
                pBlockEnd->EndSig, dwSignature
            ));

        bSigOk = FALSE;
        
        goto end;
    }

 end:
    return(bSigOk);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\msrtp\misc\rtpmisc.c ===
/**********************************************************************
 *
 *  Copyright (C) 1999 Microsoft Corporation
 *
 *  File name:
 *
 *    rtpmisc.c
 *
 *  Abstract:
 *
 *    Some networking miscellaneous functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/07/13 created
 *
 **********************************************************************/

#include <winsock2.h>
#include <psapi.h>

#include "rtpglobs.h"

#include "rtpmisc.h"

/* Used to cache some user and system information */
#define RTPMASUSERNAME  256
#define RTPMAXHOSTNAME  256
#define RTPMAXPLATFORM  256
#define RTPMAXIMAGENAME 256

TCHAR_t g_sRtpUserName[RTPMASUSERNAME];
TCHAR_t g_sRtpHostName[RTPMAXHOSTNAME];
TCHAR_t g_sRtpPlatform[RTPMAXPLATFORM];
TCHAR_t g_sRtpImageName[RTPMAXIMAGENAME];

DWORD   g_dwRtpUserSysInfo = 0;

enum {
    RTPINFO_FIRST,
    
    RTPINFO_USERNAME,
    RTPINFO_HOSTNAME,
    RTPINFO_PLATFORM,
    RTPINFO_IMAGENAME,
    
    RTPINFO_LAST
};

/*
 * WARNING
 *
 * In the following functions, dwSize is in TCHARs
 * */

BOOL RtpGetUserName(TCHAR_t *pUser, DWORD dwSize)
{
    BOOL            bOk;
    DWORD           dwError;
    unsigned long   strLen;

    TraceFunctionName("RtpGetUserName");

    bOk = FALSE;

    if (RtpBitTest(g_dwRtpUserSysInfo, RTPINFO_USERNAME))
    {
        bOk = TRUE;

        goto end;
    }

    strLen = sizeof(g_sRtpUserName)/sizeof(TCHAR_t);
        
    if (GetUserName(g_sRtpUserName, &strLen) > 0)
    {
        bOk = TRUE;

        RtpBitSet(g_dwRtpUserSysInfo, RTPINFO_USERNAME);

        TraceDebug((
                CLASS_INFO, GROUP_NETWORK, S_NETWORK_HOST,
                _T("%s: %s"),
                _fname, g_sRtpUserName
            ));
    }
    else
    {
        TraceRetailGetError(dwError);
        
        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_HOST,
                _T("%s: GetUserName failed: %u (0x%X)"),
                _fname, dwError, dwError
            ));
        
        *pUser = _T('\0');
    }

 end:
    if (bOk)
    {
        _tcsncpy(pUser, g_sRtpUserName, dwSize);
    }
    
    return(bOk);
}

BOOL RtpGetHostName(TCHAR_t *pHost, DWORD dwSize)
{
    BOOL            bOk;
    DWORD           dwError;
    char           *sHostName;
    struct hostent *he;

    TraceFunctionName("RtpGetHostName");
    
    bOk = FALSE;

    /* Get host name */
    if (RtpBitTest(g_dwRtpUserSysInfo, RTPINFO_HOSTNAME))
    {
        bOk = TRUE;
        
        goto done;
    }
    
    sHostName = RtpHeapAlloc(g_pRtpGlobalHeap, dwSize);

    if (!sHostName)
    {
        return(bOk);
    }
    
    if (gethostname(sHostName, dwSize))
    {
        TraceRetailWSAGetError(dwError);
        
        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_HOST,
                _T("%s: gethostname failed: %u (0x%X)"),
                _fname, dwError, dwError
            ));
        
        sHostName[0] = '\0';
    }
    else
    {
        bOk = TRUE;

        TraceDebug((
                CLASS_INFO, GROUP_NETWORK, S_NETWORK_HOST,
                _T("%s: gethostname %hs"),
                _fname, sHostName
            ));
        
        if ( !(he = gethostbyname(sHostName)) )
        {
            TraceRetailWSAGetError(dwError);
        
            TraceRetail((
                    CLASS_ERROR, GROUP_NETWORK, S_NETWORK_HOST,
                    _T("%s: gethostbyname failed: %u (0x%X)"),
                    _fname, dwError, dwError
             ));
        }
        else
        {
            strncpy(sHostName, he->h_name, dwSize);
        }

#if defined(UNICODE)
        /* Convert ASCII to UNICODE */
        MultiByteToWideChar(CP_ACP,
                            0,
                            sHostName,
                            -1,
                            g_sRtpHostName,
                            sizeof(g_sRtpHostName)/sizeof(TCHAR_t));
#else
        strncpy(g_sRtpHostName, sHostName, sizeof(g_sRtpHostName));
#endif

        RtpBitSet(g_dwRtpUserSysInfo, RTPINFO_HOSTNAME);
        
        TraceDebug((
                CLASS_INFO, GROUP_NETWORK, S_NETWORK_HOST,
                _T("%s: gethostbyname: %s"),
                _fname, g_sRtpHostName
            ));
    }

    RtpHeapFree(g_pRtpGlobalHeap, sHostName);
    
 done:

    if (bOk)
    {
        _tcsncpy(pHost, g_sRtpHostName, dwSize);
    }
    
    return(bOk);
}

BOOL RtpGetPlatform(TCHAR_t *pPlatform)
{
    OSVERSIONINFO  os;
    BOOL           bOk;
    DWORD          dwError;

    TraceFunctionName("RtpGetPlatform");

    bOk = FALSE;

    if (RtpBitTest(g_dwRtpUserSysInfo, RTPINFO_PLATFORM))
    {
        bOk = TRUE;

        goto done;
    }
    
    os.dwOSVersionInfoSize = sizeof(os);
    
    if (GetVersionEx(&os))
    {
        _stprintf(g_sRtpPlatform,
#if defined(_X86_) 
                  _T("Windows%s-x86-%u.%u.%u"),
#elif defined(_IA64_)
                  _T("Windows%s-ia64-%u.%u.%u"),
#else
                  _T("Windows%s-%u.%u.%u"),
#endif               
                  (os.dwPlatformId == VER_PLATFORM_WIN32_NT)?
                  ((os.dwBuildNumber <= 2200)? _T("2000"):_T("XP")):_T("9x"),
                  os.dwMajorVersion,
                  os.dwMinorVersion,
                  os.dwBuildNumber);
        
        bOk = TRUE;

        RtpBitSet(g_dwRtpUserSysInfo, RTPINFO_PLATFORM);

        TraceDebug((
                CLASS_INFO, GROUP_NETWORK, S_NETWORK_HOST,
                _T("%s: %s"),
                _fname, g_sRtpPlatform
            ));
    }
    else
    {
        TraceRetailGetError(dwError);
        
        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_HOST,
                _T("%s: GetVersionEx failed: %u (0x%X)"),
                _fname, dwError, dwError
            ));
    }

 done:
    if (bOk)
    {
        lstrcpy(pPlatform, g_sRtpPlatform);   
    }
    
    return(bOk);
}

BOOL RtpGetImageName(TCHAR_t *pImageName, DWORD *pdwSize)
{
    BOOL            bOk;
    DWORD           dwLen;
    TCHAR_t         psWholeName[RTPMAXIMAGENAME];
    TCHAR_t        *psName;

    bOk = FALSE;
    
    if (RtpBitTest(g_dwRtpUserSysInfo, RTPINFO_IMAGENAME))
    {
        bOk = TRUE;

        goto end;
    }

    dwLen = GetModuleFileNameEx(GetCurrentProcess(),
                                0,
                                psWholeName,
                                RTPMAXIMAGENAME);

    if (dwLen)
    {
        bOk = TRUE;
        
        psName = _tcsrchr(psWholeName, _T('\\'));

        if (psName)
        {
            psName++;
        }
        else
        {
            psName = psWholeName;
        }

        lstrcpy(g_sRtpImageName, psName);
        
        RtpBitSet(g_dwRtpUserSysInfo, RTPINFO_IMAGENAME);
    }

 end:
    if (bOk)
    {
        if (pdwSize)
        {
            if (pImageName)
            {
                _tcsncpy(pImageName, g_sRtpImageName, *pdwSize);
            }

            *pdwSize = lstrlen(g_sRtpImageName);
        }
    }

    return(bOk);
}

/* Converts an IP v4 address (NETWORK ORDER) to its dot form */
TCHAR_t *RtpNtoA(DWORD dwAddr, TCHAR_t *sAddr)
{
    _stprintf(sAddr, _T("%u.%u.%u.%u"),
              (dwAddr & 0xff),
              (dwAddr >> 8) & 0xff,
              (dwAddr >> 16) & 0xff,
              (dwAddr >> 24) & 0xff);
            
    return(sAddr);
}

/* Converts an IP v4 address in dot form to a 4bytes word (NETWORK
 * ORDER) */
DWORD RtpAtoN(TCHAR_t *sAddr)
{
    int              iStatus;
    DWORD            dwB0;
    DWORD            dwB1;
    DWORD            dwB2;
    DWORD            dwB3;
    DWORD            dwAddr;
    
    iStatus = _stscanf(sAddr, _T("%u.%u.%u.%u"), &dwB0, &dwB1, &dwB2, &dwB3);

    if (iStatus == 4)
    {
        dwAddr =
            ((dwB3 & 0xff) << 24) |
            ((dwB2 & 0xff) << 16) |
            ((dwB1 & 0xff) <<  8) |
            (dwB0  & 0xff);
    }
    else
    {
        dwAddr = 0;
    }

    return(dwAddr);
}

/* Compare memory */
BOOL RtpMemCmp(BYTE *pbMem0, BYTE *pbMem1, long lMemSize)
{
    BOOL             bResult;

    if (lMemSize <= 0 || !pbMem0 || !pbMem1)
    {
        return(FALSE);
    }

    bResult = TRUE;
    
    for(; lMemSize > 0; lMemSize--, pbMem0++, pbMem1++)
    {
        if (*pbMem0 != *pbMem1)
        {
            bResult = FALSE;
            
            break;
        }
    }

    return(bResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\msrtp\misc\rtptags.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtptags.c
 *
 *  Abstract:
 *
 *    Strings used for each tagged object, when debugging, display the
 *    object name by using 1 byte in the tag
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/25 created
 *
 **********************************************************************/

#include "rtptags.h"

/*
 * WARNING
 *
 * When modifying the tags, each enum TAGHEAP_* in rtptags.h MUST have
 * its own name in g_psRtpTags[], defined in rtptags.c
 * */
 
const TCHAR *g_psRtpTags[] = {
    _T("unknown"),
    
    _T("CIRTP"),
    _T("RTPOPIN"),
    _T("RTPALLOCATOR"),
    _T("RTPSAMPLE"),
    _T("RTPSOURCE"),
    _T("RTPIPIN"),
    _T("RTPRENDER"),
    
    _T("RTPHEAP"),
    
    _T("RTPSESS"),
    _T("RTPADDR"),
    _T("RTPUSER"),
    _T("RTPOUTPUT"),
    _T("RTPNETCOUNT"),
    
    _T("RTPSDES"),
    _T("RTPCHANNEL"),
    _T("RTPCHANCMD"),
    _T("RTPCRITSECT"),
    
    _T("RTPRESERVE"),
    _T("RTPNOTIFY"),
    _T("RTPQOSBUFFER"),

    _T("RTPCRYPT"),
    
    _T("RTPCONTEXT"),    
    _T("RTCPCONTEXT"),
    _T("RTCPADDRDESC"),
    
    _T("RTPRECVIO"),
    _T("RTPSENDIO"),
    
    _T("RTCPRECVIO"),
    _T("RTCPSENDIO"),
    
    _T("RTPGLOBAL"),
    
    NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\msrtp\misc\rtpque.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpque.h
 *
 *  Abstract:
 *
 *    Queues and Hash implementation
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/24 created
 *
 **********************************************************************/

#include "gtypes.h"
#include "rtpque.h"

/*
 * The queue/hash support uses the same structure to keep items in a
 * queue or a hash.
 *
 * A queue is just a circular double linked list.
 *
 * A hash includes a hash table, and each entry is either the head of
 * another hash table or a queue's head. Items in a hash will end
 * always in a queue. A queue will become a new hash when a size of
 * MAX_QUEUE2HASH_ITEMS is reached. A hash will be destroyed (become a
 * queue) once it is emptied.
 *
 * All the functions return either a pointer to the item
 * enqueud/inserted or the item just dequeued/removed. If an error
 * condition is detected, NULL is returned. */

/*
 * Queue functions
 */

/* enqueue after pPos item */
RtpQueueItem_t *enqueuea(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem,
        RtpQueueItem_t  *pPos
    )
{
    BOOL             bOk;
    DWORD            dwError;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpQueue_t      *pPospHead;
    RtpQueue_t      *pItempHead;

    TraceFunctionName("enqueuea");  

    dwError = NOERROR;
    pRtpQueueItem = (RtpQueueItem_t *)NULL;
    pPospHead = (RtpQueue_t *)NULL;
    pItempHead = (RtpQueue_t *)NULL;
    bOk = TRUE;
    
    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }
    
    if (bOk)
    {
        if (!pHead || !pHead->pFirst || !pItem || !pPos)
        {
            dwError = RTPERR_POINTER;
            goto error;
        }

        if (pPos->pHead != pHead || pItem->pHead)
        {
            pPospHead = pPos->pHead;
            pItempHead = pItem->pHead;
            dwError = RTPERR_INVALIDSTATE;
            goto error;
        }

        pItem->pNext = pPos->pNext;
        pItem->pPrev = pPos;
        pPos->pNext->pPrev = pItem;
        pPos->pNext = pItem;
        pHead->lCount++;

        pItem->pHead = pHead;

        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }

        pRtpQueueItem = pItem;
    }
    
    return(pRtpQueueItem);

 error:
    if (pRtpCritSect)
    {
        RtpLeaveCriticalSection(pRtpCritSect);
    }
    
    if (dwError == RTPERR_INVALIDSTATE)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_ENQUEUE,
                _T("%s: failed: pPos->pHead[0x%p] != pHead[0x%p] || ")
                _T("pItem->pHead[0x%p]"),
                _fname, pPospHead, pHead, pItempHead
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_ENQUEUE,
                _T("%s: pHead[0x%p] failed: %s (0x%X"),
                _fname, pHead, RTPERR_TEXT(dwError), dwError
            ));
    }
    
    return(pRtpQueueItem);
}

/* enqueue before pPos item */
RtpQueueItem_t *enqueueb(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem,
        RtpQueueItem_t  *pPos
    )
{
    BOOL             bOk;
    DWORD            dwError;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpQueue_t      *pPospHead;
    RtpQueue_t      *pItempHead;
    
    TraceFunctionName("enqueueb");  

    dwError = NOERROR;
    pRtpQueueItem = (RtpQueueItem_t *)NULL;
    pPospHead = (RtpQueue_t *)NULL;
    pItempHead = (RtpQueue_t *)NULL;
    bOk = TRUE;
    
    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }

    if (bOk)
    {
        if (!pHead || !pHead->pFirst || !pItem || !pPos)
        {
            dwError = RTPERR_POINTER;
            goto error;
        }

        if (pPos->pHead != pHead || pItem->pHead)
        {
            pPospHead = pPos->pHead;
            pItempHead = pItem->pHead;
            dwError = RTPERR_INVALIDSTATE;
            goto error;
        }

        pItem->pNext = pPos;
        pItem->pPrev = pPos->pPrev;
        pPos->pPrev->pNext = pItem;
        pPos->pPrev = pItem;
        pHead->lCount++;

        pItem->pHead = pHead;

        if (pHead->pFirst == pPos)
        {
            /* update first item */
            pHead->pFirst = pItem;
        }

        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }

        pRtpQueueItem = pItem;
    }
    
    return(pRtpQueueItem);

 error:
    if (pRtpCritSect)
    {
        RtpLeaveCriticalSection(pRtpCritSect);
    }
    
    if (dwError == RTPERR_INVALIDSTATE)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_ENQUEUE,
                _T("%s: failed: pPos->pHead[0x%p] != pHead[0x%p] || ")
                _T("pItem->pHead[0x%p]"),
                _fname, pPospHead, pHead, pItempHead
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_ENQUEUE,
                _T("%s: pHead[0x%p] failed: %s (0x%X"),
                _fname, pHead, RTPERR_TEXT(dwError), dwError
            ));
    }
    
    return(pRtpQueueItem);
}

/* enqueue as first */
RtpQueueItem_t *enqueuef(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem
    )
{
    BOOL             bOk;
    DWORD            dwError;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpQueue_t      *pItempHead;

    TraceFunctionName("enqueuef");  

    dwError = NOERROR;
    pRtpQueueItem = (RtpQueueItem_t *)NULL;
    pItempHead = (RtpQueue_t *)NULL;
    bOk = TRUE;

    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }

    if (bOk)
    {
        if (!pHead || !pItem)
        {
            dwError = RTPERR_POINTER;
            goto error;
        }
    
        if (pItem->pHead)
        {
            pItempHead = pItem->pHead;
            dwError = RTPERR_INVALIDSTATE;
            goto error;
        }

        if (pHead->pFirst)
        {
            /* not empty */
            pItem->pNext = pHead->pFirst;
            pItem->pPrev = pHead->pFirst->pPrev;
            pItem->pPrev->pNext = pItem;
            pItem->pNext->pPrev = pItem;
            pHead->pFirst = pItem;
            pHead->lCount++;
        }
        else
        {
            /* empty */
            pHead->lCount = 1;
            pHead->pFirst = pItem;
            pItem->pNext  = pItem;
            pItem->pPrev  = pItem;
        }

        pItem->pHead = pHead;
    
        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }

        pRtpQueueItem = pItem;
    }
    
    return(pRtpQueueItem);

 error:
    if (pRtpCritSect)
    {
        RtpLeaveCriticalSection(pRtpCritSect);
    }
    
    if (dwError == RTPERR_INVALIDSTATE)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_ENQUEUE,
                _T("%s: failed: pItem->pHead[0x%p]"),
                _fname, pItempHead
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_ENQUEUE,
                _T("%s: pHead[0x%p] failed: %s (0x%X"),
                _fname, pHead, RTPERR_TEXT(dwError), dwError
            ));
    }

    return(pRtpQueueItem);
}

/* enqueue at the end */
RtpQueueItem_t *enqueuel(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem
    )
{
    BOOL             bOk;
    DWORD            dwError;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpQueue_t      *pItempHead;

    TraceFunctionName("enqueuel");  

    dwError = NOERROR;
    pRtpQueueItem = (RtpQueueItem_t *)NULL;
    pItempHead = (RtpQueue_t *)NULL;
    bOk = TRUE;
    
    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }
    
    if (bOk)
    {
        if (!pHead || !pItem)
        {
            dwError = RTPERR_POINTER;
            goto error;
        }

        if (pItem->pHead)
        {
            pItempHead = pItem->pHead;
            dwError = RTPERR_INVALIDSTATE;
            goto error;
        }
    
        if (pHead->pFirst)
        {
            /* not empty */
            pItem->pNext = pHead->pFirst;
            pItem->pPrev = pHead->pFirst->pPrev;
            pItem->pPrev->pNext = pItem;
            pItem->pNext->pPrev = pItem;
            pHead->lCount++;
        }
        else
        {
            /* empty */
            pHead->lCount = 1;
            pHead->pFirst = pItem;
            pItem->pNext  = pItem;
            pItem->pPrev  = pItem;
        }

        pItem->pHead = pHead;
    
        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }

        pRtpQueueItem = pItem;
    }
    
    return(pRtpQueueItem);

 error:
    if (pRtpCritSect)
    {
        RtpLeaveCriticalSection(pRtpCritSect);
    }
    
    if (dwError == RTPERR_INVALIDSTATE)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_ENQUEUE,
                _T("%s: failed: pItem->pHead[0x%p]"),
                _fname, pItempHead
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_ENQUEUE,
                _T("%s: pHead[0x%p] failed: %s (0x%X"),
                _fname, pHead, RTPERR_TEXT(dwError), dwError
            ));
    }

    return(pRtpQueueItem);
}

/* dequeue item pItem */
RtpQueueItem_t *dequeue(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem
    )
{
    BOOL             bOk;
    DWORD            dwError;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpQueue_t      *pItempHead;

    TraceFunctionName("dequeue");  

    dwError = NOERROR;
    pRtpQueueItem = (RtpQueueItem_t *)NULL;
    pItempHead = (RtpQueue_t *)NULL;
    bOk = TRUE;
    
    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }
    
    if (bOk)
    {
        if (!pHead || !pItem)
        {
            dwError = RTPERR_POINTER;
            goto error;
        }
        
        if (pItem->pHead != pHead)
        {
            pItempHead = pItem->pHead;
            dwError = RTPERR_INVALIDSTATE;
            goto error;
        }

        if (pHead->lCount > 1)
        {
            /* 2 or more items */
            if (pHead->pFirst == pItem)
            {
                pHead->pFirst = pItem->pNext;
            }
            pItem->pPrev->pNext = pItem->pNext;
            pItem->pNext->pPrev = pItem->pPrev;
            pHead->lCount--;
        }
        else
        {
            /* just 1 item */
            pHead->pFirst = (RtpQueueItem_t *)NULL;
            pHead->lCount = 0;
        }

        pItem->pNext = (RtpQueueItem_t *)NULL;
        pItem->pPrev = (RtpQueueItem_t *)NULL;
        pItem->pHead = NULL;

        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }
    
        pRtpQueueItem = pItem;
    }
    
    return(pRtpQueueItem);

 error:
    if (pRtpCritSect)
    {
        RtpLeaveCriticalSection(pRtpCritSect);
    }
    
    if (dwError == RTPERR_INVALIDSTATE)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_DEQUEUE,
                _T("%s: failed: pHead[0x%p] != pItem->pHead[0x%p]"),
                _fname, pHead, pItempHead
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_DEQUEUE,
                _T("%s: pHead[0x%p] failed: %s (0x%X"),
                _fname, pHead, RTPERR_TEXT(dwError), dwError
            ));
    }

    return(pRtpQueueItem);
}

/* dequeue first item */
RtpQueueItem_t *dequeuef(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect
    )
{
    BOOL             bOk;
    DWORD            dwError;
    RtpQueueItem_t  *pItem;
    RtpQueueItem_t  *pRtpQueueItem;

    TraceFunctionName("dequeuef");  

    dwError = NOERROR;
    pRtpQueueItem = (RtpQueueItem_t *)NULL;
    bOk = TRUE;
    
    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }
    
    if (bOk)
    {
        if (!pHead)
        {
            dwError = RTPERR_POINTER;
            goto error;
        }
    
        pItem = pHead->pFirst;
    
        if (!pItem)
        {
            goto error;
        }
            
        if (pHead->lCount > 1)
        {
            /* 2 or more items */
            pHead->pFirst = pItem->pNext;
            pItem->pPrev->pNext = pItem->pNext;
            pItem->pNext->pPrev = pItem->pPrev;
            pHead->lCount--;
        }
        else
        {
            /* just 1 item */
            pHead->pFirst = (RtpQueueItem_t *)NULL;
            pHead->lCount = 0;
        }

        pItem->pNext = (RtpQueueItem_t *)NULL;
        pItem->pPrev = (RtpQueueItem_t *)NULL;
        pItem->pHead = NULL;

        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }
    
        pRtpQueueItem = pItem;
    }
    
    return(pRtpQueueItem);

 error:
    if (pRtpCritSect)
    {
        RtpLeaveCriticalSection(pRtpCritSect);
    }
   
    if (dwError == NOERROR)
    {
        TraceRetail((
                CLASS_WARNING, GROUP_QUEUE, S_QUEUE_DEQUEUE,
                _T("%s: pHead[0x%p] failed: empty"),
                _fname, pHead
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_DEQUEUE,
                _T("%s: pHead[0x%p] failed: %s (0x%X"),
                _fname, pHead, RTPERR_TEXT(dwError), dwError
            ));
    }

    return(pRtpQueueItem);
}

/* dequeue last item */
RtpQueueItem_t *dequeuel(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect
    )
{
    BOOL             bOk;
    DWORD            dwError;
    RtpQueueItem_t  *pItem;
    RtpQueueItem_t  *pRtpQueueItem;

    TraceFunctionName("dequeuel");  

    dwError = NOERROR;
    pRtpQueueItem = (RtpQueueItem_t *)NULL;
    bOk = TRUE;
    
    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }
    
    if (bOk)
    {
        if (!pHead)
        {
            dwError = RTPERR_POINTER;
            goto error;
        }

        if (!pHead->pFirst)
        {
            goto error;
        }

        pItem = pHead->pFirst->pPrev;
    
        if (pHead->lCount > 1)
        {
            /* 2 or more items */
            pItem->pPrev->pNext = pItem->pNext;
            pItem->pNext->pPrev = pItem->pPrev;
            pHead->lCount--;
        }
        else
        {
            /* just 1 item */
            pHead->pFirst = (RtpQueueItem_t *)NULL;
            pHead->lCount = 0;
        }

        pItem->pNext = (RtpQueueItem_t *)NULL;
        pItem->pPrev = (RtpQueueItem_t *)NULL;
        pItem->pHead = NULL;

        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }
    
        pRtpQueueItem = pItem;
    }
    
    return(pRtpQueueItem);
    
 error:
    if (pRtpCritSect)
    {
        RtpLeaveCriticalSection(pRtpCritSect);
    }
   
    if (dwError == NOERROR)
    {
        TraceRetail((
                CLASS_WARNING, GROUP_QUEUE, S_QUEUE_DEQUEUE,
                _T("%s: pHead[0x%p] failed: empty"),
                _fname, pHead
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_DEQUEUE,
                _T("%s: pHead[0x%p] failed: %s (0x%X"),
                _fname, pHead, RTPERR_TEXT(dwError), dwError
            ));
    }

    return(pRtpQueueItem);
}

/* move item so it becomes the first one in the queue */
RtpQueueItem_t *move2first(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem
    )
{
    BOOL             bOk;
    DWORD            dwError;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpQueue_t      *pItempHead;
    
    TraceFunctionName("move2first");  

    dwError = NOERROR;
    pRtpQueueItem = (RtpQueueItem_t *)NULL;
    pItempHead = (RtpQueue_t *)NULL;
    bOk = TRUE;
    
    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }
    
    if (bOk)
    {
        if (!pHead || !pItem)
        {
            dwError = RTPERR_POINTER;
            goto error;
        }

        if (pItem->pHead != pHead)
        {
            pItempHead = pItem->pHead;
            dwError = RTPERR_INVALIDSTATE;
            goto error;
        }

        if (pHead->pFirst->pPrev == pItem)
        {
            /* Item is last one, just move pFirst 1 place */
            pHead->pFirst = pHead->pFirst->pPrev;
        }
        else if (pHead->pFirst != pItem)
        {
            /* Item is not already the first one */
            
            /* dequeue */
            pItem->pPrev->pNext = pItem->pNext;
            pItem->pNext->pPrev = pItem->pPrev;

            /* enqueue as first */
            pItem->pNext = pHead->pFirst;
            pItem->pPrev = pHead->pFirst->pPrev;
            pItem->pPrev->pNext = pItem;
            pItem->pNext->pPrev = pItem;
            pHead->pFirst = pItem;
        }

        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }

        pRtpQueueItem = pItem;
    }
    
    return(pRtpQueueItem);

 error:
    if (pRtpCritSect)
    {
        RtpLeaveCriticalSection(pRtpCritSect);
    }
    
    if (dwError == RTPERR_INVALIDSTATE)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_MOVE,
                _T("%s: failed: pHead[0x%p] != pItem->pHead[0x%p]"),
                _fname, pHead, pItempHead
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_MOVE,
                _T("%s: pHead[0x%p] failed: %s (0x%X"),
                _fname, pHead, RTPERR_TEXT(dwError), dwError
            ));
    }

    return(pRtpQueueItem);
}

/* move item so it becomes the last one in the queue */
RtpQueueItem_t *move2last(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem
    )
{
    BOOL             bOk;
    DWORD            dwError;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpQueue_t      *pItempHead;

    TraceFunctionName("move2last");  

    dwError = NOERROR;
    pRtpQueueItem = (RtpQueueItem_t *)NULL;
    pItempHead = (RtpQueue_t *)NULL;
    bOk = TRUE;
    
    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }
    
    if (bOk)
    {
        if (!pHead || !pItem)
        {
            dwError = RTPERR_POINTER;
            goto error;
        }

        if (pItem->pHead != pHead)
        {
            pItempHead = pItem->pHead;
            dwError = RTPERR_INVALIDSTATE;
            goto error;
        }

        if (pHead->pFirst == pItem)
        {
            /* Item is first one, just move pFirst 1 place */
            pHead->pFirst = pHead->pFirst->pNext;
        }
        else if (pHead->pFirst->pPrev != pItem)
        {
            /* Item is not already the last one */
            
            /* dequeue */
            pItem->pPrev->pNext = pItem->pNext;
            pItem->pNext->pPrev = pItem->pPrev;

            /* enqueue as last */
            pItem->pNext = pHead->pFirst;
            pItem->pPrev = pHead->pFirst->pPrev;
            pItem->pPrev->pNext = pItem;
            pItem->pNext->pPrev = pItem;
        }

        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }

        pRtpQueueItem = pItem;
    }
    
    return(pRtpQueueItem);

 error:
    if (pRtpCritSect)
    {
        RtpLeaveCriticalSection(pRtpCritSect);
    }
    
    if (dwError == RTPERR_INVALIDSTATE)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_MOVE,
                _T("%s: failed: pHead[0x%p] != pItem->pHead[0x%p]"),
                _fname, pHead, pItempHead
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_MOVE,
                _T("%s: pHead[0x%p] failed: %s (0x%X"),
                _fname, pHead, RTPERR_TEXT(dwError), dwError
            ));
    }

    return(pRtpQueueItem);
}

/* move item from FromQ to the beginning of ToQ */
RtpQueueItem_t *move2qf(
        RtpQueue_t      *pToQ,
        RtpQueue_t      *pFromQ,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem
    )
{
    BOOL             bOk;
    DWORD            dwError;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpQueue_t      *pItempHead;

    TraceFunctionName("move2qf");  

    dwError = NOERROR;
    pRtpQueueItem = (RtpQueueItem_t *)NULL;
    pItempHead = (RtpQueue_t *)NULL;
    bOk = TRUE;
    
    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }

    if (bOk)
    {
        if (!pToQ || !pFromQ || !pItem)
        {
            dwError = RTPERR_POINTER;
            goto error;
        }

        if (pItem->pHead != pFromQ)
        {
            pItempHead = pItem->pHead;
            dwError = RTPERR_INVALIDSTATE;
            goto error;
        }

        /* Remove from FromQ */
        if (pFromQ->lCount > 1)
        {
            /* 2 or more items */
            if (pFromQ->pFirst == pItem)
            {
                pFromQ->pFirst = pItem->pNext;
            }
            pItem->pPrev->pNext = pItem->pNext;
            pItem->pNext->pPrev = pItem->pPrev;
            pFromQ->lCount--;
        }
        else
        {
            /* just 1 item */
            pFromQ->pFirst = (RtpQueueItem_t *)NULL;
            pFromQ->lCount = 0;
        }

        /* Add to the beginning of ToQ */
        if (pToQ->pFirst)
        {
            /* not empty */
            pItem->pNext = pToQ->pFirst;
            pItem->pPrev = pToQ->pFirst->pPrev;
            pItem->pPrev->pNext = pItem;
            pItem->pNext->pPrev = pItem;
            pToQ->pFirst = pItem;
            pToQ->lCount++;
        }
        else
        {
            /* empty */
            pToQ->lCount = 1;
            pToQ->pFirst = pItem;
            pItem->pNext  = pItem;
            pItem->pPrev  = pItem;
        }

        pItem->pHead = pToQ;

        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }

        pRtpQueueItem = pItem;
    }
    
    return(pRtpQueueItem);

 error:
    if (pRtpCritSect)
    {
        RtpLeaveCriticalSection(pRtpCritSect);
    }
    
    if (dwError == RTPERR_INVALIDSTATE)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_MOVE,
                _T("%s: failed: pFromQ[0x%p] != pItem->pHead[0x%p]"),
                _fname, pFromQ, pItempHead
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_MOVE,
                _T("%s: pToQ[0x%p] pFromQ[0x%p] failed: %s (0x%X"),
                _fname, pToQ, pFromQ, RTPERR_TEXT(dwError), dwError
            ));
    }

    return(pRtpQueueItem);
}

/* move item from FromQ to the end of ToQ */
RtpQueueItem_t *move2ql(
        RtpQueue_t      *pToQ,
        RtpQueue_t      *pFromQ,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem
    )
{
    BOOL             bOk;
    DWORD            dwError;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpQueue_t      *pItempHead;

    TraceFunctionName("move2ql");  

    dwError = NOERROR;
    pRtpQueueItem = (RtpQueueItem_t *)NULL;
    pItempHead = (RtpQueue_t *)NULL;
    bOk = TRUE;
    
    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }

    if (bOk)
    {
        if (!pToQ || !pFromQ || !pItem)
        {
            dwError = RTPERR_POINTER;
            goto error;
        }

        if (pItem->pHead != pFromQ)
        {
            pItempHead = pItem->pHead;
            dwError = RTPERR_INVALIDSTATE;
            goto error;
        }

        /* Remove from FromQ */
        if (pFromQ->lCount > 1)
        {
            /* 2 or more items */
            if (pFromQ->pFirst == pItem)
            {
                pFromQ->pFirst = pItem->pNext;
            }
            pItem->pPrev->pNext = pItem->pNext;
            pItem->pNext->pPrev = pItem->pPrev;
            pFromQ->lCount--;
        }
        else
        {
            /* just 1 item */
            pFromQ->pFirst = (RtpQueueItem_t *)NULL;
            pFromQ->lCount = 0;
        }

        /* Add to the end of ToQ */
        if (pToQ->pFirst)
        {
            /* not empty */
            pItem->pNext = pToQ->pFirst;
            pItem->pPrev = pToQ->pFirst->pPrev;
            pItem->pPrev->pNext = pItem;
            pItem->pNext->pPrev = pItem;
            pToQ->lCount++;
        }
        else
        {
            /* empty */
            pToQ->lCount = 1;
            pToQ->pFirst = pItem;
            pItem->pNext  = pItem;
            pItem->pPrev  = pItem;
        }

        pItem->pHead = pToQ;

        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }

        pRtpQueueItem = pItem;
    }
    
    return(pRtpQueueItem);

 error:
    if (pRtpCritSect)
    {
        RtpLeaveCriticalSection(pRtpCritSect);
    }
    
    if (dwError == RTPERR_INVALIDSTATE)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_MOVE,
                _T("%s: failed: pFromQ[0x%p] != pItem->pHead[0x%p]"),
                _fname, pFromQ, pItempHead
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_MOVE,
                _T("%s: pToQ[0x%p] pFromQ[0x%p] failed: %s (0x%X"),
                _fname, pToQ, pFromQ, RTPERR_TEXT(dwError), dwError
            ));
    }

    return(pRtpQueueItem);
}


/* find first item that matches the pvOther parameter */
RtpQueueItem_t *findQO(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        void            *pvOther
    )
{
    BOOL             bOk;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpQueueItem_t  *pRtpQueueItem2;
    long             lCount;

    TraceFunctionName("findQO");  

    pRtpQueueItem2 = (RtpQueueItem_t *)NULL;

    if (!pHead)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_MOVE,
                _T("%s: NULL pointer"),
                _fname
            ));
        
        return(pRtpQueueItem2);
    }

    bOk = TRUE;
    
    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }
    
    if (bOk)
    {
        for(pRtpQueueItem = pHead->pFirst, lCount = pHead->lCount;
            lCount > 0;
            pRtpQueueItem = pRtpQueueItem->pNext, lCount--)
        {

            if (pRtpQueueItem->pvOther == pvOther)
            {
                pRtpQueueItem2 = pRtpQueueItem;
                break;
            }
        }

        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }
    }
    
    return(pRtpQueueItem2);
}

/* find first item that matches the dwKey parameter */
RtpQueueItem_t *findQdwK(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        DWORD            dwKey
    )
{
    BOOL             bOk;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpQueueItem_t  *pRtpQueueItem2;
    long             lCount;

    TraceFunctionName("findQdwK");  

    pRtpQueueItem2 = (RtpQueueItem_t *)NULL;

    if (!pHead)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_MOVE,
                _T("%s: NULL pointer"),
                _fname
            ));
        
        return(pRtpQueueItem2);
    }
    
    bOk = TRUE;
    
    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }
    
    if (bOk)
    {
        for(pRtpQueueItem = pHead->pFirst, lCount = pHead->lCount;
            lCount > 0;
            pRtpQueueItem = pRtpQueueItem->pNext, lCount--)
        {
            if (pRtpQueueItem->dwKey == dwKey)
            {
                pRtpQueueItem2 = pRtpQueueItem;
                break;
            }
        }

        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }
    }
    
    return(pRtpQueueItem2);
}

/* find first item that matches the dKey parameter */
RtpQueueItem_t *findQdK(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        double           dKey
    )
{
    BOOL             bOk;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpQueueItem_t  *pRtpQueueItem2;
    long             lCount;

    TraceFunctionName("findQdK");  

    pRtpQueueItem2 = (RtpQueueItem_t *)NULL;

    if (!pHead)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_MOVE,
                _T("%s: NULL pointer"),
                _fname
            ));
        
        return(pRtpQueueItem2);
    }
    
    bOk = TRUE;
    
    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }
    
    if (bOk)
    {
        for(pRtpQueueItem = pHead->pFirst, lCount = pHead->lCount;
            lCount > 0;
            pRtpQueueItem = pRtpQueueItem->pNext, lCount--)
        {
            if (pRtpQueueItem->dKey == dKey)
            {
                pRtpQueueItem2 = pRtpQueueItem;
                break;
            }
        }

        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }
    }
    
    return(pRtpQueueItem2);
}

/* find the Nth item in the queue (items are counted 0,1,2,...) */
RtpQueueItem_t *findQN(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        long             lNth
    )
{
    BOOL             bOk;
    RtpQueueItem_t  *pRtpQueueItem;

    TraceFunctionName("findQN");  

    bOk = TRUE;
    pRtpQueueItem = (RtpQueueItem_t *)NULL;
    
    if (!pHead)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_MOVE,
                _T("%s: NULL pointer"),
                _fname
            ));
        
        return(pRtpQueueItem);
    }
   
    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }

    if (bOk)
    {
        if (GetQueueSize(pHead) > lNth)
        {
            for(pRtpQueueItem = pHead->pFirst;
                lNth > 0;
                lNth--, pRtpQueueItem = pRtpQueueItem->pNext)
            {
                /* Empty body */;
            }
        }

        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }
    }

    return(pRtpQueueItem);
}


/*
 * Ordered Queue insertion
 */

/* enqueue in ascending key order */
RtpQueueItem_t *enqueuedwK(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem,
        DWORD            dwKey
    )
{
    BOOL             bOk;
    DWORD            dwError;
    long             lCount;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpQueue_t      *pItempHead;

    TraceFunctionName("enqueuedwK");  

    dwError = NOERROR;
    pRtpQueueItem = (RtpQueueItem_t *)NULL;
    pItempHead = (RtpQueue_t *)NULL;
    bOk = TRUE;
    
    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }

    if (bOk)
    {
        if (!pHead || !pItem)
        {
            dwError = RTPERR_POINTER;
            goto error;
        }

        if (pItem->pHead)
        {
            pItempHead = pItem->pHead;
            dwError = RTPERR_INVALIDSTATE;
            goto error;
        }

        pItem->dwKey = dwKey;

        for(pRtpQueueItem = pHead->pFirst, lCount = pHead->lCount;
            lCount && (dwKey >= pRtpQueueItem->dwKey);
            pRtpQueueItem = pRtpQueueItem->pNext, lCount--)
        {
            /* Empty body */ ;
        }

        if (!lCount)
        {
            enqueuel(pHead, NULL, pItem);
        }
        else
        {
            enqueueb(pHead, NULL, pItem, pRtpQueueItem);
        }
    
        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }

        pRtpQueueItem = pItem;
    }
    
    return(pRtpQueueItem);

 error:
    if (pRtpCritSect)
    {
        RtpLeaveCriticalSection(pRtpCritSect);
    }
    
    if (dwError == RTPERR_INVALIDSTATE)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_ENQUEUE,
                _T("%s: failed: pItem->pHead[0x%p]"),
                _fname, pItempHead
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_ENQUEUE,
                _T("%s: pHead[0x%p] failed: %s (0x%X"),
                _fname, pHead, RTPERR_TEXT(dwError), dwError
            ));
    }

    return(pRtpQueueItem);
}

/* enqueue in ascending key order */
RtpQueueItem_t *enqueuedK(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem,
        double           dKey
    )
{
    BOOL             bOk;
    DWORD            dwError;
    long             lCount;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpQueue_t      *pItempHead;

    TraceFunctionName("enqueuedK");  

    dwError = NOERROR;
    pRtpQueueItem = (RtpQueueItem_t *)NULL;
    pItempHead = (RtpQueue_t *)NULL;
    bOk = TRUE;
    
    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }

    if (bOk)
    {
        if (!pHead || !pItem)
        {
            dwError = RTPERR_POINTER;
            goto error;
        }

        if (pItem->pHead)
        {
            pItempHead = pItem->pHead;
            dwError = RTPERR_INVALIDSTATE;
            goto error;
        }

        pItem->dKey = dKey;

        for(pRtpQueueItem = pHead->pFirst, lCount = pHead->lCount;
            lCount && (dKey >= pRtpQueueItem->dKey);
            pRtpQueueItem = pRtpQueueItem->pNext, lCount--)
        {
            /* Empty body */ ;
        }

        if (!lCount)
        {
            enqueuel(pHead, NULL, pItem);
        }
        else
        {
            enqueueb(pHead, NULL, pItem, pRtpQueueItem);
        }
    
        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }

        pRtpQueueItem = pItem;
    }
    
    return(pRtpQueueItem);

 error:
    if (pRtpCritSect)
    {
        RtpLeaveCriticalSection(pRtpCritSect);
    }
    
    if (dwError == RTPERR_INVALIDSTATE)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_ENQUEUE,
                _T("%s: failed: pItem->pHead[0x%p]"),
                _fname, pItempHead
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_ENQUEUE,
                _T("%s: pHead[0x%p] failed: %s (0x%X"),
                _fname, pHead, RTPERR_TEXT(dwError), dwError
            ));
    }

    return(pRtpQueueItem);
}

/*
 * Queue/Hash functions
 */

/* TODO a real hash implementation is needed, right now just use
   queues */

/* insert in hash using key */
RtpQueueItem_t *insertHdwK(
        RtpQueueHash_t   *pHead,
        RtpCritSect_t    *pRtpCritSect,
        RtpQueueItem_t   *pItem,
        DWORD             dwKey
    )
{
    return(enqueuedwK((RtpQueue_t *)pHead, pRtpCritSect, pItem, dwKey));
}

/* remove from hash first item matching dwKey */
RtpQueueItem_t *removeHdwK(
        RtpQueueHash_t  *pHead,
        RtpCritSect_t   *pRtpCritSect,
        DWORD            dwKey
    )
{
    BOOL             bOK;
    RtpQueueItem_t  *pRtpQueueItem;

    pRtpQueueItem = (RtpQueueItem_t *)NULL;
    bOK = TRUE;
    
    if (pRtpCritSect)
    {
        bOK = RtpEnterCriticalSection(pRtpCritSect);
    }

    if (bOK)
    {
        pRtpQueueItem = findQdwK((RtpQueue_t *)pHead, NULL, dwKey);

        if (pRtpQueueItem)
        {
            dequeue((RtpQueue_t *)pHead, NULL, pRtpQueueItem);
        }

        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }
    }
    
    return(pRtpQueueItem);
}

/* remove item from hash */
RtpQueueItem_t *removeH(
        RtpQueueHash_t  *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem
    )
{
    return(dequeue((RtpQueue_t *)pHead, pRtpCritSect, pItem));
}

/* remove "first" item from hash */
RtpQueueItem_t *removefH(
        RtpQueueHash_t  *pHead,
        RtpCritSect_t   *pRtpCritSect
    )
{
    return(dequeuef((RtpQueue_t *)pHead, pRtpCritSect));
}

/* find first item whose key matches dwKey */
RtpQueueItem_t *findHdwK(
        RtpQueueHash_t  *pHead,
        RtpCritSect_t   *pRtpCritSect,
        DWORD            dwKey
    )
{
    return(findQdwK((RtpQueue_t *)pHead, pRtpCritSect, dwKey));
}

/* Peek the "first" item from hash */
RtpQueueItem_t *peekH(
        RtpQueueHash_t  *pHead,
        RtpCritSect_t   *pRtpCritSect
    )
{
    BOOL             bOK;
    RtpQueueItem_t  *pRtpQueueItem;

    TraceFunctionName("peekH");  

    pRtpQueueItem = (RtpQueueItem_t *)NULL;
    bOK = TRUE;

    if (!pHead)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_DEQUEUE,
                _T("%s: NULL pointer"),
                _fname
            ));
        
        return(pRtpQueueItem);
    }

    if (pRtpCritSect)
    {
        bOK = RtpEnterCriticalSection(pRtpCritSect);
    }

    if (bOK)
    {
        pRtpQueueItem = pHead->pFirst;

        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }
    }
    
    return(pRtpQueueItem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\msrtp\misc\rtpreg.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 2000
 *
 *  File name:
 *
 *    rtpreg.c
 *
 *  Abstract:
 *
 *    Registry initialization and configuration
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    2000/01/21 created
 *
 **********************************************************************/

#include "rtpmisc.h"
#include "rtphdr.h"
#include "rtcpsdes.h"
#include "rtpheap.h"
#include "rtpglobs.h"

#include "rtpreg.h"

RtpReg_t         g_RtpReg;
RtpReg_t        *g_pRtpReg = (RtpReg_t *)NULL;

/*
 * WARNING
 *
 * Note that arrays have ORDER which is to be matched with the fields
 * in RtpReg_t. ENTRY macro below describes each field in RtpReg_t
 * RESPECTING the ORDER
 * */

#define RTP_KEY_OPEN_FLAGS (KEY_QUERY_VALUE|KEY_ENUMERATE_SUB_KEYS)

/*
      3                   2                   1                 
    1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |O|C| Max Size  | Path  |             |W|       Offset          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    v v \----v----/ \--v--/ \-----v-----/ v \----------v----------/
    | |      |         |          |       |            |
    | |      |         |          |       |        Offset (12)
    | |      |         |          |       | 
    | |      |         |          |     DWORD/TCHAR* flag (1)
    | |      |         |          |
    | |      |         |       Unused (7)
    | |      |         |
    | |      |      Key and Registry path index (4)
    | |      |
    | |   Maximum size in 16 bytes blocks (6)
    | |
    | Registry Close flag (1)
    |     
    Registry Open flag (1)
*/
/*
 * Encoding macros
 */
/* Offset to field */
#define OFF(_f) ( (DWORD) ((ULONG_PTR) &((RtpReg_t *)0)->_f) )

/* REG(RegOpen flag, key path, RegClose flag, max size in TCHARs) */
#define SIZ(_s) ((((_s) * sizeof(TCHAR)) >> 4) << 24)
#define REG(_fo, _p, _fc, _s) \
        (((_fo) << 31) | ((_fc) << 30) | ((_p) << 20) | SIZ(_s))

/* ENTRY(REG, DWORD/TCHAR, Offset) */
#define ENTRY(_r, _w, _o) ((_r) | ((_w) << 12) | (_o))
/*
 * Decoding macros
 * */
#define REGOPEN(_ctrl)    (RtpBitTest(_ctrl, 31))
#define REGCLOSE(_ctrl)   (RtpBitTest(_ctrl, 30))
#define REGDWORD(_ctrl)   (RtpBitTest(_ctrl, 12))
#define REGMAXSIZE(_ctrl) ((_ctrl >> 20) & 0x3f0)
#define REGKEY(_ctrl)     g_hRtpKey[((_ctrl >> 20) & 0xf)]
#define REGPATH(_ctrl)    g_psRtpRegPath[((_ctrl >> 20) & 0xf)]
#define REGOFFSET(_ctrl)  (_ctrl & 0xfff)

#define PDW(_ptr, _ctrl)  ((DWORD  *) ((char *)_ptr + REGOFFSET(_ctrl)))       
#define PTC(_ptr, _ctrl)  ((TCHAR **) ((char *)_ptr + REGOFFSET(_ctrl)))       

/* Key for each group */
const HKEY             g_hRtpKey[] =
{
    /* Address     */ HKEY_CURRENT_USER,
    /* QOS         */ HKEY_CURRENT_USER,
    /* SdesInfo    */ HKEY_CURRENT_USER,
    /* Crypto      */ HKEY_CURRENT_USER,
    /* Events      */ HKEY_CURRENT_USER,
    /* Playout     */ HKEY_CURRENT_USER,
    /* Red         */ HKEY_CURRENT_USER,
    /* Losses      */ HKEY_CURRENT_USER,
    /* Band est    */ HKEY_CURRENT_USER,
    /* Net quality */ HKEY_CURRENT_USER,
    /*             */ (HKEY)NULL
};

/* Registry path name for each group */
const TCHAR           *g_psRtpRegPath[] =
{
    _T("RTP\\Generic"),  /* Default IP address and port */
    _T("RTP\\QOS"),      /* QOS enable/disable */
    _T("RTP\\SdesInfo"), /* SDES information */
    _T("RTP\\Crypto"),   /* Crypto information */
    _T("RTP\\Events"),   /* Events */
    _T("RTP\\Playout"),  /* Playout */
    _T("RTP\\Red"),      /* Redundancy */
    _T("RTP\\GenLosses"),/* Losses */
    _T("RTP\\BandEstimation"),/* Bandwidth estimation */
    _T("RTP\\NetQuality"),/*  Network quality */
    NULL
};

/* Registry key names for all groups.
 *
 * WARNING
 *
 * Each name in g_psRtpRegFields MUST match an ENTRY in
 * g_dwRegistryControl
 * */
const TCHAR           *g_psRtpRegFields[] =
{
    /* Generic */
    _T("DefaultIPAddress"),
    _T("DefaultLocalPort"),
    _T("DefaultRemotePort"),
    _T("LoopbackMode"),

    /* QOS */
    _T("Enable"),
    _T("Flags"),
    _T("RsvpStyle"),
    _T("MaxParticipants"),
    _T("SendMode"),
    _T("PayloadType"),
    _T("AppName"),
    _T("AppGUID"),
    _T("PolicyLocator"),
    
    /* SDES */
    _T("Enable"),
    _T("CNAME"),
    _T("NAME"),
    _T("EMAIL"),
    _T("PHONE"),
    _T("LOC"),
    _T("TOOL"),
    _T("NOTE"),
    _T("PRIV"),
    _T("BYE"),
    
    /* Crypto */
    _T("Enable"),
    _T("Mode"),
    _T("HashAlg"),
    _T("DataAlg"),
    _T("PassPhrase"),

    /* Events */
    _T("Receiver"),
    _T("Sender"),
    _T("Rtp"),
    _T("PInfo"),
    _T("Qos"),
    _T("Sdes"),

    /* Playout */
    _T("Enable"),
    _T("MinPlayout"),
    _T("MaxPlayout"),
    
    /* Redundancy */
    _T("Enable"),
    _T("PT"),
    _T("InitialDistance"),
    _T("MaxDistance"),
    _T("EarlyTimeout"),
    _T("EarlyPost"),
    _T("Threshold0"),
    _T("Threshold1"),
    _T("Threshold2"),
    _T("Threshold3"),

    /* Losses */
    _T("Enable"),
    _T("RecvLossRate"),
    _T("SendLossRate"),

    /* Bandwidth estimation */
    _T("Enable"),
    _T("Modulo"),
    _T("TTL"),
    _T("WaitEstimation"),
    _T("MaxGap"),
    _T("Bin0"),
    _T("Bin1"),
    _T("Bin2"),
    _T("Bin3"),
    _T("Bin4"),

    /* Network quality */
    _T("Enable"),
    
    NULL
};

#define DW      1   /* DWORD   */
#define TC      0   /* TCHAR * */

/* Registry Entries
 *
 * WARNING
 *
 * Each name in g_psRtpRegFields (above) MUST match an ENTRY in
 * g_dwRegistryControl
 * */
const DWORD g_dwRegistryControl[] =
{
    /* ENTRY(REG(Open,Path,Close,Size), DWORD/TCHAR, Offset) */
    /* Address */
    ENTRY(REG(1,0,0, 16), TC,  OFF(psDefaultIPAddress)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwDefaultLocalPort)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwDefaultRemotePort)),
    ENTRY(REG(0,0,1,  0), DW,  OFF(dwMcastLoopbackMode)),

    /* QOS */
    ENTRY(REG(1,1,0,  0), DW,  OFF(dwQosEnable)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwQosFlags)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwQosRsvpStyle)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwQosMaxParticipants)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwQosSendMode)),
    ENTRY(REG(0,0,0, 16), TC,  OFF(psQosPayloadType)),
    ENTRY(REG(0,0,0,128), TC,  OFF(psQosAppName)),
    ENTRY(REG(0,0,0,128), TC,  OFF(psQosAppGUID)),
    ENTRY(REG(0,0,1,128), TC,  OFF(psQosPolicyLocator)),

    /* SDES */
    ENTRY(REG(1,2,0,  0), DW,  OFF(dwSdesEnable)),
    ENTRY(REG(0,0,0,256), TC,  OFF(psCNAME)),
    ENTRY(REG(0,0,0,256), TC,  OFF(psNAME)),
    ENTRY(REG(0,0,0,256), TC,  OFF(psEMAIL)),
    ENTRY(REG(0,0,0,256), TC,  OFF(psPHONE)),
    ENTRY(REG(0,0,0,256), TC,  OFF(psLOC)),
    ENTRY(REG(0,0,0,256), TC,  OFF(psTOOL)),
    ENTRY(REG(0,0,0,256), TC,  OFF(psNOTE)),
    ENTRY(REG(0,0,0,256), TC,  OFF(psPRIV)),
    ENTRY(REG(0,0,1,256), TC,  OFF(psBYE)),

    /* Crypto */
    ENTRY(REG(1,3,0,  0), DW,  OFF(dwCryptEnable)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwCryptMode)),
    ENTRY(REG(0,0,0, 16), TC,  OFF(psCryptHashAlg)),
    ENTRY(REG(0,0,0, 16), TC,  OFF(psCryptDataAlg)),
    ENTRY(REG(0,0,1,256), TC,  OFF(psCryptPassPhrase)),

    /* Events */
    ENTRY(REG(1,4,0,  0), DW,  OFF(dwEventsReceiver)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwEventsSender)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwEventsRtp)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwEventsPInfo)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwEventsQos)),
    ENTRY(REG(0,0,1,  0), DW,  OFF(dwEventsSdes)),

    /* Playout delay */
    ENTRY(REG(1,5,0,  0), DW,  OFF(dwPlayoutEnable)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwMinPlayout)),
    ENTRY(REG(0,0,1,  0), DW,  OFF(dwMaxPlayout)),
    
    /* Redundancy */
    ENTRY(REG(1,6,0,  0), DW,  OFF(dwRedEnable)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwRedPT)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwInitialRedDistance)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwMaxRedDistance)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwRedEarlyTimeout)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwRedEarlyPost)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwLossRateThresh0)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwLossRateThresh1)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwLossRateThresh2)),
    ENTRY(REG(0,0,1,  0), DW,  OFF(dwLossRateThresh3)),

    /* GenLosses */
    ENTRY(REG(1,7,0,  0), DW,  OFF(dwGenLossEnable)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwRecvLossRate)),
    ENTRY(REG(0,0,1,  0), DW,  OFF(dwSendLossRate)),
  
    /* Bandwidth estimation */
    ENTRY(REG(1,8,0,  0), DW,  OFF(dwBandEstEnable)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwBandEstModulo)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwBandEstTTL)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwBandEstWait)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwBandEstMaxGap)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwBandEstBin0)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwBandEstBin1)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwBandEstBin2)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwBandEstBin3)),
    ENTRY(REG(0,0,1,  0), DW,  OFF(dwBandEstBin4)),

    /* Network quality */
    ENTRY(REG(1,9,1,  0), DW,  OFF(dwNetQualityEnable)),
    
    /* End */
    0
};

void *RtpRegCopy(TCHAR **dst, TCHAR *src, DWORD dwSize);

void RtpRegSetDefaults(RtpReg_t *pRrtpReg);

void RtpRegistryInit(RtpReg_t *pRtpReg)
{
    DWORD            dwError;
    HKEY             hk;
    unsigned long    hkDataType;
    BYTE             hkData[128*sizeof(TCHAR_t)];
    unsigned long    hkDataSize;
    DWORD            dwVal;
    DWORD            i;
    DWORD            dwControl;

    /* Initialize structure */
    for(i = 0; g_dwRegistryControl[i]; i++)
    {
        dwControl = g_dwRegistryControl[i];
        if (REGDWORD(dwControl))
        {
            *PDW(pRtpReg, dwControl) = RTPREG_NOVALUESET;
        }
        else
        {
            *PTC(pRtpReg, dwControl) = (TCHAR *)NULL;
        }
    }

    /* Assign defaults */
    RtpRegSetDefaults(pRtpReg);

    /* Read registry and assign values to g_RtpReg */
    for(i = 0; g_dwRegistryControl[i]; i++)
    {
        dwControl = g_dwRegistryControl[i];

        if (REGOPEN(dwControl))
        {
            /* Open root key (Group, i.e. addr, qos, sdes, etc)) */
            dwError = RegOpenKeyEx(REGKEY(dwControl),
                                   REGPATH(dwControl),
                                   0,
                                   RTP_KEY_OPEN_FLAGS,
                                   &hk);
    
            if (dwError !=  ERROR_SUCCESS)
            {
                /* Move forward to next close */
                while(!REGCLOSE(dwControl))
                {
                    i++;
                    dwControl = g_dwRegistryControl[i];
                }

                continue;
            }
        }

        /* Read each key value in group */
        while(1)
        {
            /* Read key */
            hkDataSize = sizeof(hkData);
            dwError = RegQueryValueEx(hk,
                                      g_psRtpRegFields[i],
                                      0,
                                      &hkDataType,
                                      hkData,
                                      &hkDataSize);
            
            if (dwError == ERROR_SUCCESS)
            {
                /* Set read value in RtpReg_t */
                if (REGDWORD(dwControl))
                {
                    *PDW(pRtpReg, dwControl) = *(DWORD *)hkData;
                }
                else
                {
                    if ( (hkDataSize > sizeof(TCHAR)) &&
                         (hkDataSize <= REGMAXSIZE(dwControl)) )
                    {
                        RtpRegCopy(PTC(pRtpReg, dwControl),
                                   (TCHAR *)hkData,
                                   hkDataSize);
                    }
                }
            }

            if (REGCLOSE(dwControl))
            {
                break;
            }

            i++;
            dwControl = g_dwRegistryControl[i];
        }

        RegCloseKey(hk);
    }

    /* Initialize some global variables that depend on the registry
     * readings */
    RtpSetRedParametersFromRegistry();
    RtpSetMinMaxPlayoutFromRegistry();
    RtpSetBandEstFromRegistry();
}

/* Release the memory for al the TCHAR* type fields */
void RtpRegistryDel(RtpReg_t *pRtpReg)
{
    DWORD            i;
    DWORD            dwControl;
    TCHAR          **ppTCHAR;

    for(i = 0; g_dwRegistryControl[i]; i++)
    {
        dwControl = g_dwRegistryControl[i];

        if (!REGDWORD(dwControl))
        {
            ppTCHAR = PTC(pRtpReg, dwControl);

            if (*ppTCHAR)
            {
                RtpHeapFree(g_pRtpGlobalHeap, *ppTCHAR);

                *ppTCHAR = (TCHAR *)NULL;
            }
        }
    }
}

void RtpRegSetDefaults(RtpReg_t *pRtpReg)
{
    /*
     * Default address and port
     * */
    /* 224.5.5.0/10000 */
    RtpRegCopy(&pRtpReg->psDefaultIPAddress,
               _T("224.5.5.3"),
               0);
    pRtpReg->dwDefaultLocalPort  = 10000;
    pRtpReg->dwDefaultRemotePort = 10000;
}

void *RtpRegCopy(TCHAR **dst, TCHAR *src, DWORD dwSize)
{
    if (*dst)
    {
        RtpHeapFree(g_pRtpGlobalHeap, *dst);
    }

    if (!dwSize)
    {
        /* Get the size in bytes (including the NULL terminating
         * character) */
        dwSize = (lstrlen(src) + 1) * sizeof(TCHAR);
    }
    
    *dst = RtpHeapAlloc(g_pRtpGlobalHeap, dwSize);

    if (*dst)
    {
        CopyMemory(*dst, src, dwSize);
    }

    return(*dst);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\msrtp\msrtp\msrtp.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    msrtp.c
 *
 *  Abstract:
 *
 *    MS RTP entry point
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/26 created
 *
 **********************************************************************/

#include <winsock2.h>

#include "msrtpapi.h"

/**********************************************************************
 *
 * Public procedures
 *
 **********************************************************************/

BOOL WINAPI DllMain(
        HINSTANCE hInstance, 
        ULONG     ulReason, 
        LPVOID    pv)
{
    BOOL error = TRUE;
    
    switch(ulReason) {
    case DLL_PROCESS_ATTACH:
        /* RTP global initialization */
        /* TODO check for return error */
        MSRtpInit1(hInstance);
        break;
    case DLL_PROCESS_DETACH:
        /* RTP global de-initialization */
        /* TODO check for return error */
        MSRtpDelete1();
        break;
    default:
        error = FALSE;
    }

    return(error);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\msrtp\rtcp\rtcpdec.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtcpdec.c
 *
 *  Abstract:
 *
 *    Decode RTCP packets
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/11/08 created
 *
 **********************************************************************/

#include "lookup.h"
#include "rtppinfo.h"
#include "rtpglobs.h"
#include "rtpncnt.h"
#include "rtpevent.h"
#include "rtpred.h"
#include "rtcpband.h"

#include "rtcpdec.h"

DWORD RtcpProcessSInfo(
        RtpUser_t       *pRtpUser,
        RtcpSInfo_t     *pRtcpSInfo,
        int              iPacketSize
    );

DWORD RtcpProcessRBlock(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        RtcpRBlock_t    *pRtcpRBlock
    );

DWORD RtcpProcessProfileExt(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        char            *hdr,
        int              len
    );

DWORD RtcpValidateSdes(
        RtcpCommon_t    *pRtcpCommon
    );

DWORD RtcpValidateBYE(
        RtcpCommon_t    *pRtcpCommon
    );

BOOL RtcpUpdateSdesItem(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        RtcpSdesItem_t  *pRtcpSdesItem
    );

typedef struct _RtpNetMetric_t {
    double           dLow;
    double           dHigh;
} RtpNetMetric_t;

DWORD RtpComputNetworkMetrics(
        RtpUser_t       *pRtpUser,
        const RtpNetMetric_t  *pRtpNetMetric
    );

DWORD RtcpSelectBin(double dBandwidth);

DWORD RtcpBestBin(RtpNetRState_t *pRtpNetRState);

const RtpNetMetric_t g_RtpNetMetric[][3] =
{                 /* values defined in struct.h */
    {   /* ================= Audio ================= */
        /* RTT    */  {NETQA_RTT_MIN,    NETQA_RTT_MAX},
        /* Jitter */  {NETQA_JITTER_MIN, NETQA_JITTER_MAX},
        /* Losess */  {NETQA_LOSSES_MIN, NETQA_LOSSES_MAX}
    },
    {   /* ================= Video ================= */
        /* RTT    */  {NETQV_RTT_MIN,    NETQV_RTT_MAX},
        /* Jitter */  {NETQV_JITTER_MIN, NETQV_JITTER_MAX},
        /* Losess */  {NETQV_LOSSES_MIN, NETQV_LOSSES_MAX}
    }
};

/* Sdes names are the same as the Sdes event names */
const TCHAR_t        **g_psSdesNames = &g_psRtpSdesEvents[0];

/* Process AND validates SR and RR packets */
DWORD RtcpProcessSR_RR(
        RtcpAddrDesc_t  *pRtcpAddrDesc,
        char            *hdr,
        int              iPacketSize,
        SOCKADDR_IN     *FromIn
    )
{
    BOOL             bOk;
    BOOL             bCreate;
    DWORD            dwError;
    DWORD            dwSSRC;
    double           dTime;
    
    RtcpCommon_t    *pRtcpCommon;
    RtpAddr_t       *pRtpAddr;
    RtpUser_t       *pRtpUser;

    DWORD            dwCount;
    int              len;
    int              iPcktSize;
    int              iRemaining;
    BOOL             isSR;
    RtpTime_t       *pRtpTime;
    RtpTime_t       *pRtpTimePrev;

    TraceFunctionName("RtcpProcessSR_RR");
    
    pRtcpCommon = (RtcpCommon_t *)hdr;
    hdr += sizeof(RtcpCommon_t);
    len = (int) (ntohs(pRtcpCommon->length) + 1) * sizeof(DWORD);

    dTime = pRtcpAddrDesc->pRtcpRecvIO->dRtcpRecvTime;
    pRtpTime = &pRtcpAddrDesc->pRtcpRecvIO->RtcpRecvTime;
    
    /*
     * Validate RTCP SR/RR packet size
     * */
    
    /* RTCP common header + SSRC */
    iPcktSize = sizeof(RtcpCommon_t) + sizeof(DWORD);

    isSR = (pRtcpCommon->pt == RTCP_SR);

    /* Sender info */
    if (isSR)
    {
        iPcktSize += sizeof(RtcpSInfo_t);
    }

    /* Report blocks */
    dwCount = pRtcpCommon->count;
    iPcktSize += (dwCount * sizeof(RtcpRBlock_t));

    /* Check size is valid */
    if (iPcktSize > len)
    {
        dwError = RTPERR_INVALIDHDR;

        goto bail;
    }

    /*
     * Packet is valid
     * */
    
    dwSSRC = *(DWORD *)hdr;
    pRtpAddr = pRtcpAddrDesc->pRtpAddr;
    hdr += sizeof(DWORD);
    
    /*
     * Look up SSRC, create new one if not exist yet
     * */
    bCreate = TRUE;
    pRtpUser = LookupSSRC(pRtpAddr, dwSSRC, &bCreate);

    if (pRtpUser)
    {
        bOk = RtpEnterCriticalSection(&pRtpUser->UserCritSect);

        if (bOk)
        {
            if (bCreate)
            {
                /* Increase the number of not yet validated
                 * participants, the bit FGUSER_VALIDATED is reset
                 * when the RtpUser_t structure is just created */
                InterlockedIncrement(&pRtpAddr->lInvalid);

                TraceDebug((
                        CLASS_INFO, GROUP_RTCP, S_RTCP_RECV,
                        _T("%s: pRtpAddr[0x%p] ")
                        _T("SSRC:0x%X new user"),
                        _fname, pRtpAddr,
                        ntohl(pRtpUser->dwSSRC)
                    ));
            }

            /* Store the RTCP source address/port */
            if (!RtpBitTest(pRtpUser->dwUserFlags, FGUSER_RTCPADDR))
            {
                pRtpUser->dwAddr[RTCP_IDX] = (DWORD) FromIn->sin_addr.s_addr;
                                
                pRtpUser->wPort[RTCP_IDX] = FromIn->sin_port;

                RtpBitSet(pRtpUser->dwUserFlags, FGUSER_RTCPADDR);
            }

            /* Check if need to make participant valid */
            if (!RtpBitTest(pRtpUser->dwUserFlags, FGUSER_VALIDATED))
            {
                /* The participant has been validated and was invalid */
                InterlockedDecrement(&pRtpAddr->lInvalid);
                RtpBitSet(pRtpUser->dwUserFlags, FGUSER_VALIDATED);
            }

            RtpLeaveCriticalSection(&pRtpUser->UserCritSect);
        }
        
        TraceDebugAdvanced((
                0, GROUP_RTCP, S_RTCP_RRSR,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                _T("CC:%u RTCP %s packet received at %0.3f"),
                _fname, pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC),
                dwCount, isSR? _T("SR") : _T("RR"),
                pRtpTime->dwSecs + (double)pRtpTime->dwUSecs/1000000.0
            ));
        
        /* Update time this SR/RR report was received */
        pRtpUser->RtpNetRState.TimeLastXRRecv = *pRtpTime;

        if (isSR)
        {
            /* Compute the gap between the reception time of this and
             * the previous SR packet received */
            pRtpTimePrev = &pRtpUser->RtpNetRState.TimeLastSRRecv;
            
            pRtpUser->RtpNetRState.dInterSRRecvGap =
                (double) (pRtpTime->dwSecs - pRtpTimePrev->dwSecs) +
                (double) (pRtpTime->dwUSecs - pRtpTimePrev->dwUSecs) /
                1000000.0;
            
            /* Update time this SR report was received */
            pRtpUser->RtpNetRState.TimeLastSRRecv = *pRtpTime;
            
            /* Process sender info */
            RtcpProcessSInfo(pRtpUser, (RtcpSInfo_t *)hdr, iPacketSize);
        }
        
        RtpUpdateNetCount(&pRtpUser->RtpUserCount,
                          &pRtpUser->UserCritSect,
                          RTCP_IDX,
                          iPacketSize,
                          NO_FLAGS,
                          dTime);
        
        /* If created, add this user to AliveQ and Hash,
         * if already existed, move it to AliveQ */
        RtpUpdateUserState(pRtpAddr,
                           pRtpUser,
                           USER_EVENT_RTCP_PACKET);
    }

    if (isSR)
    {
        hdr += sizeof(RtcpSInfo_t);
    }

    /* Process report blocks */
    for(; dwCount > 0; dwCount--, hdr += sizeof(RtcpRBlock_t))
    {
        RtcpProcessRBlock(pRtpAddr, pRtpUser, (RtcpRBlock_t *)hdr);
    }

    iRemaining = len - iPcktSize;

    if (iRemaining > 0)
    {
        /* Process the profile-specific extension */
        RtcpProcessProfileExt(pRtpAddr, pRtpUser, hdr, iRemaining);
    }

    /* Post event if allowed */
    RtpPostEvent(pRtpAddr,
                 pRtpUser,
                 RTPEVENTKIND_RTP,
                 isSR? RTPRTP_SR_RECEIVED : RTPRTP_RR_RECEIVED,
                 dwSSRC,
                 0);

    dwError = NOERROR;

 bail:

    if (dwError != NOERROR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTCP, S_RTCP_RECV,
                _T("%s: Invalid packet"),
                _fname
            ));
    }
    
    return(dwError);
}

DWORD RtcpProcessSDES(
        RtcpAddrDesc_t  *pRtcpAddrDesc,
        char            *hdr
    )
{
    BOOL             bCreate;
    DWORD            dwError;
    DWORD            dwSSRC;
    RtcpCommon_t    *pRtcpCommon;
    RtpAddr_t       *pRtpAddr;
    RtpUser_t       *pRtpUser;
    RtcpSdesItem_t  *pRtcpSdesItem;
    DWORD            dwCount;
    BOOL             bNewChunk; /* TRUE when begining a chunk */
    int              pad;

    pRtpAddr = pRtcpAddrDesc->pRtpAddr;

    if (RtpBitTest2(pRtpAddr->dwAddrFlags,
                    FGADDR_MUTERTPRECV, FGADDR_MUTERTPSEND))
    {
        /* If either the receiver or sender or both are muted, stop
         * processing SDES data. This is needed because in the mute
         * state, events generation is disabled, hence the application
         * would not be informed when new SDES data arrives, and it
         * may happen that while in the mute state, all the SDES data
         * that was going to be received actually arrives, then the
         * app wil not ever be notified about the existence of new
         * SDES data, unless the app explicitly queries for that */
        
        return(NOERROR);
    }
        
    /*
     * WARNING
     * 
     * RtcpValidateSdes() and RtcpProcessSDES() use the same structure
     * to validate and update the SDES items (i.e. the body of both
     * functions are identical but differ only in that one contains
     * validation predicates but no actions are taken, in the other
     * one, the validation predicates are assumed true, and only the
     * actions are executed), they MUST maintain that relationship
     * */

    pRtcpCommon = (RtcpCommon_t *)hdr;
    
    /* Validate SDES chunks */
    dwError = RtcpValidateSdes(pRtcpCommon);

    if (dwError == NOERROR)
    {
        /*
         * Update SDES items
         * */

        dwCount = pRtcpCommon->count;
        
        /* Move pointer to first chunk (a chunk starts with a SSRC) */
        hdr = (char *)(pRtcpCommon + 1);
    
        bNewChunk = TRUE;
    
        while(dwCount > 0)
        {
            if (bNewChunk)
            {
                dwSSRC = *(DWORD *)hdr;
                /* Look up SSRC, DO NOT create if not exist yet */
                bCreate = FALSE;
                pRtpUser = LookupSSRC(pRtpAddr, dwSSRC, &bCreate);

                /* Move hdr to first item (i.e. skip SSRC) */
                hdr += sizeof(DWORD);
                bNewChunk = FALSE;
            }

            /* Set pointer to current item */
            pRtcpSdesItem = (RtcpSdesItem_t *)hdr;
        
            if (pRtcpSdesItem->type == RTCP_SDES_END)
            {
                /* END item, i.e. end of chunk, advance pointer to
                 * next 32-bits boundary */
                pad = sizeof(DWORD) - (DWORD) ((ULONG_PTR)hdr & 0x3);
                hdr += pad;
                dwCount--;
                bNewChunk = TRUE;
            }
            else
            {
                /* Item */
                if (pRtpUser && (pRtcpSdesItem->length > 0))
                {
                    RtcpUpdateSdesItem(pRtpAddr, pRtpUser, pRtcpSdesItem);
                }
                
                /* Move pointer to next item */
                hdr += (sizeof(RtcpSdesItem_t) + pRtcpSdesItem->length);
            }
        }
    }

    return(dwError);
}

/* Validate the SDES chunks in a RTCP SDES packet
 *
 * NOTE that a zero length item is valid but useless */
DWORD RtcpValidateSdes(
        RtcpCommon_t    *pRtcpCommon
    )
{
    DWORD            dwError;
    char            *hdr;
    RtcpSdesItem_t  *pRtcpSdesItem;
    DWORD            dwCount;
    BOOL             bNewChunk; /* TRUE when begining a chunk */
    int              len;
    int              pad;

    TraceFunctionName("RtcpValidateSdes");
  
    /*
     * WARNING
     * 
     * RtcpValidateSdes() and RtcpProcessSDES() use the same structure
     * to validate and update the SDES items, they MUST maintain that
     * relationship
     * */
    
    dwCount = pRtcpCommon->count;
        
    /* Move pointer to first chunk (a chunk starts with a SSRC) */
    hdr = (char *)(pRtcpCommon + 1);
    len = (int) ((ntohs(pRtcpCommon->length) + 1) * sizeof(DWORD)) -
        sizeof(RtcpCommon_t);

    bNewChunk = TRUE;
    
    while(dwCount > 0 && len > 0)
    {
        if (bNewChunk)
        {
            if (len < (sizeof(DWORD) * 2))
            {
                len -= (sizeof(DWORD) * 2);
                /* There must have been at least the SSRC and the 4
                 * bytes length item(s) (to the next 32-bits word
                 * boundary) on which at least the last byte must have
                 * been the END item */
                break;
            }
            
            /* Move hdr to first item (i.e. skip SSRC) */
            hdr += sizeof(DWORD);
            len -= sizeof(DWORD);
            bNewChunk = FALSE;
        }

        /* Set pointer to current item */
        pRtcpSdesItem = (RtcpSdesItem_t *)hdr;
        
        if (pRtcpSdesItem->type == RTCP_SDES_END)
        {
            /* END item, i.e. end of chunk, advance pointer to next
             * 32-bits boundary */
            pad = sizeof(DWORD) - (DWORD) ((ULONG_PTR)hdr & 0x3);
            hdr += pad;
            len -= pad;
            dwCount--;
            bNewChunk = TRUE;
        }
        else
        {
            /* Item */
            /* Move pointer to data */
            hdr += sizeof(RtcpSdesItem_t);
            len -= sizeof(RtcpSdesItem_t);
                
            if ( len >= (sizeof(DWORD) - sizeof(RtcpSdesItem_t)) )
            {
                hdr += pRtcpSdesItem->length;
                len -= pRtcpSdesItem->length;

                if (len < 0)
                {
                    /* Went past the buffer */
                    break;
                }
            }
            else
            {
                len -= (sizeof(DWORD) - sizeof(RtcpSdesItem_t));
                /* There must have been at least the 2 bytes padding
                 * to the next 32-bits word boundary, at least the
                 * last one must have been the END item
                 * */
                break;
            }
        }
    }
    
    if (dwCount > 0 || len < 0)
    {
        /* NOTE accept as valid a packet having not used data at the
         * end, i.e. len > 0 */
        
        /* dwCount > 0   == Underrun error */
        /* len < 0       == Overrun error */
        dwError = RTPERR_INVALIDSDES;
    }
    else
    {
        dwError = NOERROR;
    }

    return(dwError);
}

BOOL RtcpUpdateSdesItem(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        RtcpSdesItem_t  *pRtcpSdesItem
    )
{
    /* NOTE that RtpSdesItem_t is different from RtcpSdesItem_t */
    RtpSdesItem_t   *pRtpSdesItem;
    DWORD            dwType;
    DWORD            dwLen;
    char            *sSdesData;
    DWORD            dwSdesMask;

    TraceFunctionName("RtcpUpdateSdesItem");
    
    /* What we allow to store */
    dwSdesMask = pRtpAddr->pRtpSess->dwSdesMask[REMOTE_IDX];
    dwType = pRtcpSdesItem->type;

    if (dwType <= RTCP_SDES_FIRST || dwType >= RTCP_SDES_LAST)
    {
        /* Ignore non recognized SDES items */
        return(FALSE);
    }
    
    if (RtpBitPar(dwType) & dwSdesMask & ~pRtpUser->dwSdesPresent)
    {
        if (pRtpUser->pRtpSdes)
        {
            dwLen = pRtcpSdesItem->length;
            sSdesData = (char *)pRtcpSdesItem + sizeof(RtcpSdesItem_t);

            pRtpSdesItem = &pRtpUser->pRtpSdes->RtpSdesItem[dwType];

            if (pRtpSdesItem->dwBfrLen < dwLen)
            {
                /* Save only what fits in our buffer */
                dwLen = pRtpSdesItem->dwBfrLen;
            }

            if (pRtpSdesItem->pBuffer)
            {
                CopyMemory(pRtpSdesItem->pBuffer,
                           (char *)pRtcpSdesItem + sizeof(RtcpSdesItem_t),
                           dwLen);

                if (sSdesData[dwLen - 1] && (dwLen < pRtpSdesItem->dwBfrLen))
                {
                    /* Last byte is not a NULL, and we still have room
                     * for it, add it! */
                    pRtpSdesItem->pBuffer[dwLen] = 0;
                    dwLen++;
                }

                pRtpSdesItem->dwDataLen = dwLen;
                
                RtpBitSet(pRtpUser->dwSdesPresent, dwType);
                
                TraceDebug((
                        CLASS_INFO, GROUP_RTCP, S_RTCP_SDES,
                        _T("%s: pRtpAddr[0x%p] ")
                        _T("pRtpUser[0x%p] SSRC:0x%X SDES[%5s] [%hs]"),
                        _fname, pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC),
                        g_psSdesNames[dwType], pRtpSdesItem->pBuffer
                    ));

                /* Generate event, attempt to post with any first,
                 * then attempt to post with the particular SDES
                 * event. It is up to the application to enable ANY, a
                 * specific one, or both
                 * */
                RtpPostEvent(pRtpAddr,
                             pRtpUser,
                             RTPEVENTKIND_SDES,
                             RTPSDES_ANY,
                             pRtpUser->dwSSRC,
                             dwType);

                RtpPostEvent(pRtpAddr,
                             pRtpUser,
                             RTPEVENTKIND_SDES,
                             dwType,
                             pRtpUser->dwSSRC,
                             dwType);
                                  
                return(TRUE);
            }
        }
    }
    
    return(FALSE);
}

DWORD RtcpProcessBYE(
        RtcpAddrDesc_t  *pRtcpAddrDesc,
        char            *hdr
    )
{
    BOOL             bCreate;
    DWORD            dwError;
    DWORD            dwSSRC;
    RtcpCommon_t    *pRtcpCommon;
    RtpAddr_t       *pRtpAddr;
    RtpUser_t       *pRtpUser;
    int              len;
   
    TraceFunctionName("RtcpProcessBYE");
    
    pRtcpCommon = (RtcpCommon_t *)hdr;
    
    /* Validate BYE packet */
    dwError = RtcpValidateBYE(pRtcpCommon);

    if (dwError == NOERROR)
    {
        if (pRtcpCommon->count > 0)
        {
            /* Can only do something if I have at least 1 SSRC */
            hdr = (char *)(pRtcpCommon + 1);
            len = (int) (ntohs(pRtcpCommon->length) + 1) * sizeof(DWORD);

            dwSSRC = *(DWORD *)hdr;
            hdr += (pRtcpCommon->count * sizeof(DWORD));
            len -= (sizeof(RtcpCommon_t) + pRtcpCommon->count * sizeof(DWORD));
            
            pRtpAddr = pRtcpAddrDesc->pRtpAddr;
            
            /* Look up participant leaving */
            bCreate = FALSE;
            pRtpUser = LookupSSRC(pRtpAddr, dwSSRC, &bCreate);

            if (len > 0)
            {
                /* We have a reason field */
                len = *hdr;
                hdr++;
            }
            
            if (pRtpUser)
            {
                if (len > 0)
                {
                    /* TODO save in RTCP_SDES_BYE the reason */
                }
                
                TraceDebug((
                        CLASS_INFO, GROUP_RTCP, S_RTCP_BYE,
                        _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                        _T("BYE received, reason:[%hs]"),
                        _fname, pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC),
                        (len > 0)? hdr : "NONE"
                    ));
                /* TODO convert the reason from UTF-8 to UNICODE then
                 * pass it to the TraceDebug */

                pRtpUser->RtpNetRState.dByeTime = RtpGetTimeOfDay(NULL);
                
                RtpUpdateUserState(pRtpAddr, pRtpUser, USER_EVENT_BYE);
            }
            else
            {
                TraceRetail((
                        CLASS_WARNING, GROUP_RTCP, S_RTCP_BYE,
                        _T("%s: pRtpAddr[0x%p] anonimous ")
                        _T("BYE received, reason:[%hs]"),
                        _fname, pRtpAddr,
                        (len > 0)? hdr : "NONE"
                    ));
            }
        }
        else
        {
        }
    }
    
    return(dwError);
}

/* Validate the SDES chunks in a RTCP SDES packet */
DWORD RtcpValidateBYE(
        RtcpCommon_t    *pRtcpCommon
    )
{
    DWORD            dwError;
    char            *hdr;
    DWORD            dwCount;
    int              len;

    TraceFunctionName("RtcpValidateBYE");
    
    dwCount = pRtcpCommon->count;
    
    /* Move pointer to first SSRC/CSRC */
    hdr = (char *)(pRtcpCommon + 1);
    len = (int) ((ntohs(pRtcpCommon->length) + 1) * sizeof(DWORD)) -
        sizeof(RtcpCommon_t);

    /* Account for the SSRC/CSRCs included */
    hdr += (pRtcpCommon->count * sizeof(DWORD));
    len -= (pRtcpCommon->count * sizeof(DWORD));

    dwError = NOERROR;
    
    if (len < 0)
    {
         dwError = RTPERR_INVALIDBYE;
    }
    else
    {
        if (len > 0)
        {
            /* We have a reason field */
            len -= *hdr;
            len--;

            if (len < 0)
            {
                dwError = RTPERR_INVALIDBYE;
            }
        }
    }

    return(dwError);
}

DWORD RtcpProcessAPP(
        RtcpAddrDesc_t  *pRtcpAddrDesc,
        char            *hdr
    )
{
    return(0);
}

DWORD RtcpProcessDefault(
        RtcpAddrDesc_t  *pRtcpAddrDesc,
        char            *hdr
    )
{
    return(0);
}

DWORD RtcpProcessSInfo(
        RtpUser_t       *pRtpUser,
        RtcpSInfo_t     *pRtcpSInfo,
        int              iPacketSize
    )
{
    BOOL             bOk;
    DWORD            dwError;
    double           dBandwidth;
    double           dGap;
    DWORD            dwBin;
    DWORD            dwFreq;
    DWORD            dwBestBin;
    DWORD            dwBestFrequency;
    RtpNetRState_t  *pRtpNetRState;

    TraceFunctionName("RtcpProcessSInfo");

    pRtpNetRState = &pRtpUser->RtpNetRState;

    dwError = RTPERR_CRITSECT;
    
    bOk = RtpEnterCriticalSection(&pRtpUser->UserCritSect);

    if (bOk == TRUE)
    {
        if (pRtcpSInfo->ntp_sec)
        {
            /* Update the NTP/ts pair only if we have received a valid
             * NTP time */
            
            /* Save the send time in the last SR packet received */
            pRtpNetRState->dInterSRSendGap =
                (double) pRtpNetRState->NTP_sr_rtt.dwSecs +
                (double) pRtpNetRState->NTP_sr_rtt.dwUSecs / 1000000.0;

            /* Now update the send time for this SR packet */
            pRtpNetRState->NTP_sr_rtt.dwSecs = ntohl(pRtcpSInfo->ntp_sec);
        
            pRtpNetRState->NTP_sr_rtt.dwUSecs = (DWORD)
                ( ( (double) ntohl(pRtcpSInfo->ntp_frac) / 4294967296.0 ) *
                  1000000.0 );
        
            pRtpNetRState->t_sr_rtt = ntohl(pRtcpSInfo->rtp_ts);

            /* Compute the gap between the sending time of this and
             * the previous SR packet received */
            pRtpNetRState->dInterSRSendGap =
                (double) pRtpNetRState->NTP_sr_rtt.dwSecs +
                ((double) pRtpNetRState->NTP_sr_rtt.dwUSecs / 1000000.0) -
                pRtpNetRState->dInterSRSendGap;

            if (pRtpNetRState->dInterSRSendGap <= g_dRtcpBandEstMaxGap)
            {
                /* Do bandwidth estimation only when we have small
                 * gaps between 2 consecutive SR reports */

                dGap = pRtpNetRState->dInterSRRecvGap -
                    pRtpNetRState->dInterSRSendGap;

                if (dGap <= 0)
                {
                    /* Discard this reading */
                    dBandwidth =
                        g_dRtcpBandEstBin[RTCP_BANDESTIMATION_MAXBINS];

                    dwBin = RTCP_BANDESTIMATION_NOBIN;
                }
                else
                {
                    /* Compute current bandwidth estimation */
                    dBandwidth =
                        (double) ((iPacketSize + SIZEOF_UDP_IP_HDR) * 8) /
                        dGap;

                    /* Select bin */
                    dwBin = RtcpSelectBin(dBandwidth);
                }

                if (dwBin != RTCP_BANDESTIMATION_NOBIN)
                {
                    /* Update bin */
                    pRtpNetRState->dwBinFrequency[dwBin]++;

                    dwFreq = pRtpNetRState->dwBinFrequency[dwBin];

                    pRtpNetRState->dBinBandwidth[dwBin] += dBandwidth;

                    /* Increase count of valid estimations done */
                    pRtpNetRState->dwBandEstRecvCount++;
                
                    if (pRtpNetRState->dwBandEstRecvCount <=
                        g_dwRtcpBandEstMinReports)
                    {
                        if (pRtpNetRState->dwBandEstRecvCount ==
                            g_dwRtcpBandEstMinReports)
                        {
                            /* We reached the initial count, select
                             * highest frequency bin */

                            pRtpNetRState->dwBestBin =
                                RtcpBestBin(pRtpNetRState);

                            dwBestBin = pRtpNetRState->dwBestBin;
                            
                            RtpBitReset(pRtpNetRState->dwNetRStateFlags2,
                                        FGNETRS2_BANDESTNOTREADY);
                        }
                        else
                        {
                            dwBestBin = dwBin;
                            
                            /* Report BANDESTNOTREADY while we are doing
                             * the initial average */
                            RtpBitSet(pRtpNetRState->dwNetRStateFlags2,
                                      FGNETRS2_BANDESTNOTREADY);
                        }
                    }
                    else
                    {
                        /* Update the best bin if different */
                        if (dwBin != pRtpNetRState->dwBestBin)
                        {
                            if (pRtpNetRState->dwBinFrequency[dwBin] >
                                pRtpNetRState->
                                dwBinFrequency[pRtpNetRState->dwBestBin])
                            {
                                pRtpNetRState->dwBestBin = dwBin;
                            }
                            else if (pRtpNetRState->dwBinFrequency[dwBin] ==
                                     pRtpNetRState->
                                     dwBinFrequency[pRtpNetRState->dwBestBin])
                            {
                                /* If same frequency, keep the smaller */
                                if (dwBin < pRtpNetRState->dwBestBin)
                                {
                                    pRtpNetRState->dwBestBin = dwBin;
                                }
                            }
                        }

                        dwBestBin = pRtpNetRState->dwBestBin;
                        
                        RtpBitReset(pRtpNetRState->dwNetRStateFlags2,
                                    FGNETRS2_BANDWIDTHUNDEF);
                    }

                    dwBestFrequency = pRtpNetRState->dwBinFrequency[dwBestBin];
                }
                else
                {
                    /* If this estimation is undefined, i.e. the gap
                     * between the 2 consecutive packets is 0 or
                     * negative, will report RTP_BANDWIDTH_UNDEFINED
                     * as the estimated bandwidth if best frequency is 0 or 1 */

                    dwFreq = (DWORD)-1;
                    
                    dwBestBin = pRtpNetRState->dwBestBin;
                    dwBestFrequency = pRtpNetRState->dwBinFrequency[dwBestBin];

                    // Need to return the best bin instead of -1
                    if (dwBestFrequency < 2)
                    {
                        /* Just to avoid zero div exception if logging */
                        dwBestFrequency = 1;

                        RtpBitSet(pRtpNetRState->dwNetRStateFlags2,
                                  FGNETRS2_BANDWIDTHUNDEF);
                    }
                    else
                    {
                        RtpBitReset(pRtpNetRState->dwNetRStateFlags2,
                                  FGNETRS2_BANDWIDTHUNDEF);
                    }
                }

                pRtpNetRState->dLastTimeEstimation = RtpGetTimeOfDay(NULL);

                
                TraceRetailAdvanced((
                        0, GROUP_RTCP, S_RTCP_BANDESTIMATION,
                        _T("%s: pRtpUser[0x%p] SSRC:0x%X ")
                        _T("Bandwidth: cur:%d/%d/%0.3fKbps ")
                        _T("best:%u/%u/%0.3fKbps"),
                        _fname, pRtpUser, ntohl(pRtpUser->dwSSRC),
                        dwBin, dwFreq, dBandwidth/1000.0,
                        dwBestBin, dwBestFrequency, 
                        pRtpNetRState->dBinBandwidth[dwBestBin] /
                        (dwBestFrequency * 1000.0)
                    ));
             }
            
            if (!RtpBitTest(pRtpUser->dwUserFlags, FGUSER_SR_RECEIVED))
            {
                /* Very first SR received */
                RtpBitSet(pRtpUser->dwUserFlags, FGUSER_SR_RECEIVED);
            }
        }

        RtpLeaveCriticalSection(&pRtpUser->UserCritSect);

        TraceRetailAdvanced((
                0, GROUP_RTCP, S_RTCP_NTP,
                _T("%s: pRtpUser[0x%p] SSRC:0x%X ")
                _T("SInfo: %sNTP:%0.3f/ts:%u packets:%u bytes:%u"),
                _fname, pRtpUser, ntohl(pRtpUser->dwSSRC),
                pRtcpSInfo->ntp_sec? _T("") : _T("X"),
                (double)pRtpNetRState->NTP_sr_rtt.dwSecs +
                (double)pRtpNetRState->NTP_sr_rtt.dwUSecs/1000000.0,
                pRtpNetRState->t_sr_rtt,
                ntohl(pRtcpSInfo->psent),
                ntohl(pRtcpSInfo->bsent)
            ));
        
        dwError = NOERROR;
    }

    return(dwError);
}

/* WARNING The pRtpUser may be NULL as we could have received a report
 * from a participant that is in the ByeQ, in that case, the lookup
 * will not create a new participant as the participant indeed existed
 * but has stalled or sent already a BYE packet */
DWORD RtcpProcessRBlock(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        RtcpRBlock_t    *pRtcpRBlock
    )
{
    DWORD            dwError;
    
    DWORD            dwLSR;
    DWORD            dwDLSR;
    double           LSR;
    double           DLSR;
    double           TimeLastRR;
    DWORD            frac_cumlost;
    DWORD            frac_lost;      /* Last fraction lost reported */
    int              cum_lost;       /* Last cumulative lost reported */
    DWORD            dwNetMetrics;
    int              iNetChange;
    double           dCurTime;
    double           dRTT;
    double           dJitter;
    double           dLossRate;
    DWORD            dwValue;
    BOOL             bEnableNetQuality;
    int              iClass;         /* Audio, Video, ... */
    
    RtpNetSState_t  *pRtpNetSState;
    RtpNetRState_t  *pRtpNetRState;
    RtpNetInfo_t    *pRtpNetInfo;

    TraceFunctionName("RtcpProcessRBlock");
    
    dwError = NOERROR;

    pRtpNetSState = &pRtpAddr->RtpNetSState;
    
    if (pRtpUser && pRtpNetSState->dwSendSSRC == pRtcpRBlock->ssrc)
    {
        /*
         * This participant is reporting about us and is a valid
         * participant (i.e. we have a context for it)
         * */

        pRtpNetRState = &pRtpUser->RtpNetRState;
        pRtpNetInfo = &pRtpUser->RtpNetInfo;

        LSR = 0.0;

        DLSR = 0.0;
        
        if (pRtcpRBlock->lsr && pRtcpRBlock->dlsr)
        {
            /* Compute the RTT only if we have a LSR and DLSR. This
             * report's sender must have had received a SR (SInfo)
             * from us in order to be able to send back in a RBlock
             * valid values for LSR and DLSR */
            
            dwLSR = ntohl(pRtcpRBlock->lsr);

            LSR = (double) ((dwLSR >> 16) & 0xffff);

            LSR += (double) (dwLSR & 0xffff) / 65536.0;
        
            dwDLSR = ntohl(pRtcpRBlock->dlsr);

            DLSR = (double) ((dwDLSR >> 16) & 0xffff);

            DLSR += (double) (dwDLSR & 0xffff) / 65536.0;

            TimeLastRR =
                (double) (pRtpNetRState->TimeLastXRRecv.dwSecs & 0xffff);

            TimeLastRR +=
                (double) pRtpNetRState->TimeLastXRRecv.dwUSecs / 1000000.0;
            
            dRTT = TimeLastRR - DLSR - LSR;

            if (dRTT < 0)
            {
                /* A negative value is possible because of clock
                 * differences when the RTT is very small */
                dRTT = 0;
            }
            
            /* Compute average RTT */
            pRtpNetInfo->dAvg[NETQ_RTT_IDX] +=
                (1.0 - RTP_GENERIC_ALPHA) *
                (dRTT - pRtpNetInfo->dAvg[NETQ_RTT_IDX]);
        }

        frac_cumlost = ntohl(pRtcpRBlock->frac_cumlost);

        /* Obtain the cumulative lost */
        if (frac_cumlost & 0x800000)
        {
            /* extend the sign */
            cum_lost = (int) ((-1 & ~0x7fffff) | (frac_cumlost & 0x7fffff));
        }
        else
        {
            cum_lost = (int) (frac_cumlost & 0x7fffff);
        }

        /* Obtain the fraction lost (in 1/256th units) */
        frac_lost = frac_cumlost >> 24;

        pRtpNetSState->iLastLossRateS =
            (frac_lost * 100 * LOSS_RATE_FACTOR) / 256;
    
        /* Update our average lost rate to control redundancy */
        pRtpNetSState->iAvgLossRateS =
            RtpUpdateLossRate(pRtpNetSState->iAvgLossRateS,
                              pRtpNetSState->iLastLossRateS);

        /* Loss rate in 0 - 100 scale */
        dLossRate = (double) pRtpNetSState->iLastLossRateS / LOSS_RATE_FACTOR;
        
        /* ... and the average loss rate for network metrics */
        pRtpNetInfo->dAvg[NETQ_LOSSRATE_IDX] +=
            (1.0 - RTP_GENERIC_ALPHA) *
            (dLossRate - pRtpNetInfo->dAvg[NETQ_LOSSRATE_IDX]);

        /* Update the redundancy level if needed */
        if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_REDSEND))
        {
            RtpAdjustSendRedundancyLevel(pRtpAddr);
        }
        
        /* Obtain jitter in seconds */
        dJitter =
            (double) ntohl(pRtcpRBlock->jitter) /
            pRtpNetSState->dwSendSamplingFreq;

        /* Compute average jitter */
        pRtpNetInfo->dAvg[NETQ_JITTER_IDX] +=
            (1.0 - RTP_GENERIC_ALPHA) *
            (dJitter - pRtpNetInfo->dAvg[NETQ_JITTER_IDX]);
        
        TraceRetailAdvanced((
                0, GROUP_RTCP, S_RTCP_RTT,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                _T("RTT:%0.3f (LRR:%0.3f,DLSR:%0.3f,LSR:%0.3f)"),
                _fname, pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC),
                dRTT, TimeLastRR, DLSR, LSR
            ));
        
        TraceRetailAdvanced((
                0, GROUP_RTCP, S_RTCP_LOSSES,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                _T("Losses: avg:%0.2f%% cum:%d fraction:%u%% ")
                _T("Jitter:%u bytes (%0.3f secs)"),
                _fname, pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC),
                pRtpNetInfo->dAvg[NETQ_LOSSRATE_IDX],
                cum_lost, (frac_lost * 100) / 256,
                (DWORD) (dJitter * pRtpNetSState->dwSendSamplingFreq),
                dJitter
            ));

        /* Post loss rate as an event */
        RtpPostEvent(pRtpAddr,
                     pRtpUser,
                     RTPEVENTKIND_RTP,
                     RTPRTP_SEND_LOSSRATE,
                     pRtpUser->dwSSRC,
                     pRtpNetSState->iAvgLossRateS);

        dCurTime = RtpGetTimeOfDay((RtpTime_t *)NULL);

        /* NOTE that the estimation is *global* for all the
         * participants, once we really support multicast (I mean RTC)
         * this scheme might be better implemented on a per receiver
         * basis, then come up with a global metric, may be a
         * percentil */
        if (!pRtpNetSState->dLastTimeEstimationPosted)
        {
            /* First time initialize to the time the first RB is
             * received, there is no point in doing that before as
             * that means that even if we are sending, no body is
             * listening */
            pRtpNetSState->dLastTimeEstimationPosted = dCurTime;
        }
        else if (!RtpBitTest(pRtpNetSState->dwNetSFlags, FGNETS_NOBANDPOSTED))
        {
            if (RtpBitTest(pRtpNetSState->dwNetSFlags, FGNETS_1STBANDPOSTED))
            {
                /* If I had at least one estimation, prevent the
                 * posting of event RTP_BANDWIDTH_NOTESTIMATED */
                RtpBitSet(pRtpNetSState->dwNetSFlags, FGNETS_NOBANDPOSTED);
            }
            else if ( ((dCurTime - pRtpNetSState->dLastTimeEstimationPosted) >=
                       g_dRtcpBandEstWait) )
            {
                /* If I haven't received bandwidth estimation, I need to
                 * generate an event to let the upper layer know that the
                 * bandwidth is undetermined so that layer can use another
                 * mechanism to come up with the bandwidth to use. */
                RtpBitSet2(pRtpNetSState->dwNetSFlags,
                           FGNETS_NOBANDPOSTED, FGNETS_DONOTSENDPROBE);

                /* Post bandwidth estimation event */
                RtpPostEvent(pRtpAddr,
                             pRtpUser,
                             RTPEVENTKIND_RTP,
                             RTPRTP_BANDESTIMATION,
                             pRtpNetSState->dwSendSSRC, /* My own SSRC */
                             RTP_BANDWIDTH_NOTESTIMATED);
            }
        }

        /* Decide if network condition updates event is being reported
         * for this SSRC */
        if (RtpBitTest(pRtpAddr->dwAddrRegFlags, FGADDRREG_NETQFORCED))
        {
            /* Force enabled/disabled from the registry */
            bEnableNetQuality =
                RtpBitTest(pRtpAddr->dwAddrRegFlags,FGADDRREG_NETQFORCEDVALUE);
        }
        else
        {
            /* Use the per user settings or the global setting */
            bEnableNetQuality =
                RtpBitTest(pRtpUser->dwUserFlags2, FGUSER2_NETEVENTS)
                ||
                RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_NETMETRIC);
        }
        
        if (bEnableNetQuality)
        {
            pRtpUser->RtpNetInfo.dLastUpdate = dCurTime;

            iClass = (int)RtpGetClass(pRtpAddr->dwIRtpFlags) - 1;

            if (iClass < 0 || iClass > 1)
            {
                iClass = 0;
            }
            
            dwNetMetrics = RtpComputNetworkMetrics(pRtpUser,
                                                   &g_RtpNetMetric[iClass][0]);

            iNetChange = (int)dwNetMetrics - pRtpNetInfo->dwNetMetrics;

            if (iNetChange < 0)
            {
                iNetChange = -iNetChange;
            }
            
            /* Decide if the network conditions have changed to
             * justify an update */
            if (iNetChange >= RTPNET_MINNETWORKCHANGE)
            {
                /* Update new metric */
                pRtpNetInfo->dwNetMetrics = dwNetMetrics;
                
                /* Encode all the metrics in a single DWORD */
                /* The global metric is a 0 - 100 value */
                dwNetMetrics &= 0xff;

                /* RTT is encoded as 10's of milliseconds */
                dwValue = (DWORD) (pRtpNetInfo->dAvg[NETQ_RTT_IDX] * 100);
                if (dwValue > 0xff)
                {
                    dwValue = 0xff;
                }
                dwNetMetrics |= (dwValue << 8);
                
                /* Jitter is encoded in milliseconds */
                dwValue = (DWORD) (pRtpNetInfo->dAvg[NETQ_JITTER_IDX] * 1000);
                if (dwValue > 0xff)
                {
                    dwValue = 0xff; 
                }
                dwNetMetrics |= (dwValue << 16);

                /* Loss rate is encoded in 1/256 units */
                dwValue = (DWORD)
                    ((pRtpNetInfo->dAvg[NETQ_LOSSRATE_IDX] * 256) / 100);
                dwValue &= 0xff;
                dwNetMetrics |= (dwValue << 24);

                TraceRetail((
                        CLASS_INFO, GROUP_RTCP, S_RTCP_NETQUALITY,
                        _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                        _T("Global:%u RTT:%0.3f/%1.0f Jitter:%0.3f/%1.0f ")
                        _T("Losses:%1.0f/%1.0f"),
                        _fname, pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC),
                        pRtpNetInfo->dwNetMetrics,
                        pRtpNetInfo->dAvg[NETQ_RTT_IDX],
                        pRtpNetInfo->dHowGood[NETQ_RTT_IDX],
                        pRtpNetInfo->dAvg[NETQ_JITTER_IDX],
                        pRtpNetInfo->dHowGood[NETQ_JITTER_IDX],
                        pRtpNetInfo->dAvg[NETQ_LOSSRATE_IDX],
                        pRtpNetInfo->dHowGood[NETQ_LOSSRATE_IDX]
                    ));
                
                /* Post event */
                RtpPostEvent(pRtpAddr,
                             pRtpUser,
                             RTPEVENTKIND_PINFO,
                             RTPPARINFO_NETWORKCONDITION,
                             pRtpUser->dwSSRC,
                             dwNetMetrics);

            }
        }
    }
    else
    {
        TraceDebugAdvanced((
                0, GROUP_RTCP, S_RTCP_RRSR,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] ")
                _T("RBlock SSRC:0x%X ignored"),
                _fname, pRtpAddr, pRtpUser, ntohl(pRtcpRBlock->ssrc)
            ));
    }

    return(dwError);
}

DWORD RtcpProcessProfileExt(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        char            *hdr,
        int              len
    )
{
    DWORD            dwError;
    int              len0;
    char            *ptr;
    DWORD            dwType;
    DWORD            dwLen;
    DWORD            dwSSRC;
    DWORD            dwBandwidth;
    RtpPEHdr_t      *pRtpPEHdr;
    RtpBandEst_t    *pRtpBandEst;

    dwError = NOERROR;
    len0 = len;
    ptr = hdr;

    /* Validate extensions */
    while(len >= sizeof(RtpPEHdr_t))
    {
        pRtpPEHdr = (RtpPEHdr_t *)hdr;

        dwLen = ntohs(pRtpPEHdr->len);
        len -= dwLen;
        ptr += dwLen;

        if (len < 0)
        {
            dwError = RTPERR_OVERRUN;
            goto end;
        }

        switch(ntohs(pRtpPEHdr->type))
        {
        case RTPPE_BANDESTIMATION:
            if (dwLen != sizeof(RtpBandEst_t))
            {
                dwError = RTPERR_INVALIDHDR;
                goto end;
            }
            break;
        }
    }
    
    len = len0; 
    while(len >= sizeof(RtpPEHdr_t))
    {
        pRtpPEHdr = (RtpPEHdr_t *)hdr;
        
        dwType = ntohs(pRtpPEHdr->type);
        dwLen = ntohs(pRtpPEHdr->len);
        
        switch(dwType)
        {
        case RTPPE_BANDESTIMATION:
            pRtpBandEst = (RtpBandEst_t *)pRtpPEHdr;
            
            /* dwSendSSRC is already in NETWORK order */
            if (pRtpAddr->RtpNetSState.dwSendSSRC == pRtpBandEst->dwSSRC)
            {
                dwBandwidth = ntohl(pRtpBandEst->dwBandwidth);
                
                /* This report concers us */
                /* Post bandwidth estimation event */
                RtpPostEvent(pRtpAddr,
                             pRtpUser,
                             RTPEVENTKIND_RTP,
                             RTPRTP_BANDESTIMATION,
                             pRtpBandEst->dwSSRC,
                             dwBandwidth);

                pRtpAddr->RtpNetSState.dLastTimeEstimationPosted =
                    RtpGetTimeOfDay((RtpTime_t *)NULL);

                /* Indicate we have valid estimation and hence prevent
                 * the posting of the RTP_BANDWIDTH_NOTESTIMATED event */
                RtpBitSet(pRtpAddr->RtpNetSState.dwNetSFlags,
                          FGNETS_1STBANDPOSTED);
            }
            break;
        }

        hdr += dwLen;
        len -= dwLen;
    }

 end:
    return(dwError);
}

/* Using the average of the RTT, jitter and losses, compute a network
 * quality metric given in a [0 - 100] scale */
DWORD RtpComputNetworkMetrics(
        RtpUser_t       *pRtpUser,
        const RtpNetMetric_t  *pRtpNetMetric
    )
{
    DWORD            i;
    double           dHowBad[3];
    double           dVal;
    double           dAllBad;
    double           dTotalBad;
    RtpNetInfo_t    *pRtpNetInfo;

    pRtpNetInfo = &pRtpUser->RtpNetInfo;

    dAllBad = 0;
    dTotalBad = 0;
    
    for(i = 0; i < NETQ_LAST_IDX; i++)
    {
        if (pRtpNetInfo->dAvg[i])
        {
            if (pRtpNetInfo->dAvg[i] < pRtpNetMetric[i].dLow)
            {
                dHowBad[i] = 0;
            }
            else if (pRtpNetInfo->dAvg[i] > pRtpNetMetric[i].dHigh)
            {
                dHowBad[i] = 100;
            }
            else
            {
                dHowBad[i] =
                    (pRtpNetInfo->dAvg[i] - pRtpNetMetric[i].dLow) * 100 /
                    (pRtpNetMetric[i].dHigh - pRtpNetMetric[i].dLow);
            }

            dAllBad += dHowBad[i];
        }
        else
        {
            dHowBad[i] = 0;
        }

        pRtpNetInfo->dHowGood[i] = 100 - dHowBad[i];
    }

    if (dAllBad > 0)
    {
        for(i = 0; i < NETQ_LAST_IDX; i++)
        {
            if (pRtpNetInfo->dAvg[i])
            {
                dTotalBad += (dHowBad[i] * dHowBad[i]) / dAllBad;
            }
        }
    }
    
    return(100 - (DWORD)dTotalBad);
}

/* Helper functions for bandwidth estimation */

/* Given a bandwidth, select the corresponding bin */
DWORD RtcpSelectBin(double dBandwidth)
{
    DWORD            i;

    for(i = 0; i < RTCP_BANDESTIMATION_MAXBINS; i++)
    {
        if (dBandwidth > g_dRtcpBandEstBin[i] &&
            dBandwidth <= g_dRtcpBandEstBin[i + 1])
        {
            return(i);
        }
    }

    return(RTCP_BANDESTIMATION_NOBIN);
}

/* Select bin with highest frequency */
DWORD RtcpBestBin(RtpNetRState_t *pRtpNetRState)
{
    DWORD            dwBestBin;
    DWORD            i;

    for(i = 0, dwBestBin = 0; i < RTCP_BANDESTIMATION_MAXBINS; i++)
    {
        if (pRtpNetRState->dwBinFrequency[i] > 
            pRtpNetRState->dwBinFrequency[dwBestBin])
        {
            dwBestBin = i;
        }
    }

    return(dwBestBin);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\msrtp\msrtp\msrtpapi.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    msrtpapi.c, dsrtpapi.c
 *
 *  Abstract:
 *
 *    Contains the raw RTP implementation API, can be linked as a
 *    library (rtp.lib), linked into a DLL (msrtp.dll), or linked into
 *    a DShow DLL (dsrtp.dll).
 *
 *    This file is edited as msrtpapi.c and duplicated as dsrtpapi.c,
 *    each version is compiled with different flags
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/18 created
 *
 **********************************************************************/

#include <winsock2.h>

#include "gtypes.h"
#include "struct.h"
#include "rtphdr.h"
#include "rtpheap.h"
#include "rtprand.h"
#include "rtpglobs.h"
#include "rtpreg.h"
#include "rtcpsdes.h"

#include "rtpfwrap.h"
#include "rtpsess.h"

#include "rtpstart.h"
#include "rtprecv.h"
#include "rtpsend.h"

#include "rtcpthrd.h"

#include "rtpaddr.h"

#include "msrtpapi.h"

RTPSTDAPI CreateRtpSess(
        RtpSess_t **ppRtpSess
    )
{
    HRESULT hr;
    
    hr = GetRtpSess(ppRtpSess);

    return(hr);
}

RTPSTDAPI DeleteRtpSess(
        RtpSess_t *pRtpSess
    )
{
    HRESULT hr;
    
    hr = DelRtpSess(pRtpSess);

    return(hr);
}

/* TODO this two shouldn't be exposed, but I need them before I can
   use Control */

RTPSTDAPI CreateRtpAddr(
        RtpSess_t  *pRtpSess,
        RtpAddr_t **ppRtpAddr,
        DWORD       dwFlags
    )
{
    HRESULT hr;

    hr = GetRtpAddr(pRtpSess, ppRtpAddr, dwFlags);

    return(hr);
}

RTPSTDAPI DeleteRtpAddr(
        RtpSess_t *pRtpSess,
        RtpAddr_t *pRtpAddr
    )
{
    HRESULT hr;

    hr = DelRtpAddr(pRtpSess, pRtpAddr);

    return(hr);
}


RTPSTDAPI RtpControl(RtpSess_t *pRtpSess,
                     DWORD      dwControl,
                     DWORD_PTR  dwPar1,
                     DWORD_PTR  dwPar2)
{
    RtpControlStruct_t RtpControlStruct;
    
    if (!pRtpSess)
    {
        return(RTPERR_POINTER);
    }

    /*
     * TODO (may be) validate RtpSess by verifying that the memory
     * block is an item in the BusyQ in the g_pRtpSessHeap */
    if (pRtpSess->dwObjectID != OBJECTID_RTPSESS)
    {
        return(RTPERR_INVALIDRTPSESS);
    }

    /* Initialize Control structure */
    ZeroMemory(&RtpControlStruct, sizeof(RtpControlStruct_t));
    RtpControlStruct.pRtpSess = pRtpSess;
    RtpControlStruct.dwControlWord = dwControl;
    RtpControlStruct.dwPar1 = dwPar1;
    RtpControlStruct.dwPar2 = dwPar2;

    return( RtpValidateAndExecute(&RtpControlStruct) );
}

RTPSTDAPI RtpGetLastError(RtpSess_t *pRtpSess)
{
    return(NOERROR);
}
        
RTPSTDAPI RtpRegisterRecvCallback(
        RtpAddr_t       *pRtpAddr,
        PRTP_RECVCOMPLETIONFUNC pRtpRecvCompletionFunc
    )
{
    if (!pRtpAddr)
    {
        return(RTPERR_POINTER);
    }
    
    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        return(RTPERR_INVALIDRTPSESS);
    }

    pRtpAddr->pRtpRecvCompletionFunc = pRtpRecvCompletionFunc;

    return(NOERROR);
}

RTPSTDAPI RtpRecvFrom(
        RtpAddr_t *pRtpAddr,
        WSABUF    *pWSABuf,
        void      *pvUserInfo1,
        void      *pvUserInfo2
    )
{
    HRESULT hr;
    
    hr = RtpRecvFrom_(pRtpAddr,
                      pWSABuf,
                      pvUserInfo1,
                      pvUserInfo2
        );

    return(hr);
}


RTPSTDAPI RtpSendTo(
        RtpAddr_t *pRtpAddr,
        WSABUF    *pWSABuf,
        DWORD      dwWSABufCount,
        DWORD      dwTimeStamp,
        DWORD      dwSendFlags
    )
{
    HRESULT hr;
    
    hr = RtpSendTo_(pRtpAddr, pWSABuf, dwWSABufCount, dwTimeStamp,dwSendFlags);

    return(hr);
}

RTPSTDAPI RtpStart(
        RtpSess_t *pRtpSess,
        DWORD      dwFlags
    )
{
    HRESULT hr;

    hr = RtpStart_(pRtpSess, dwFlags);

    return(hr);
}

RTPSTDAPI RtpStop(
        RtpSess_t *pRtpSess,
        DWORD      dwFlags
    )
{
    HRESULT hr;

    hr = RtpStop_(pRtpSess, dwFlags);

    return(hr);
}

/*
 * Initializes all the modules that require initialization. This
 * function can be called from DllMain(PROCESS_ATTACH) if linked as a
 * DLL, or explicitly from an application initializing the RTP stack
 * if linked as a library. */
RTPSTDAPI MSRtpInit1(HINSTANCE hInstance)
{
    HRESULT          hr1;
    HRESULT          hr2;
    BOOL             bOk1;
    BOOL             bOk2;
    BOOL             bOk3;
    BOOL             bOk4;

    /* One time operation that doesn't need de-init */
    /* NOTE this function will zero g_RtpContext */
    RtpInitReferenceTime();
    
    hr1 = RtpInit();
    
    /* initialize heaps */
    bOk1 = RtpCreateMasterHeap();
    bOk2 = RtpCreateGlobHeaps();
    
    bOk3 = RtpInitializeCriticalSection(&g_RtpContext.RtpWS2CritSect,
                                        &g_RtpContext,
                                        _T("g_RtpContext.RtpWS2CritSect"));

    bOk4 = RtpInitializeCriticalSection(&g_RtpContext.RtpPortsCritSect,
                                        &g_RtpContext,
                                        _T("g_RtpContext.RtpPortsCritSect"));


    hr2 = RtcpInit();

    if (!bOk1 || !bOk2 || !bOk3 || !bOk4 ||
        (hr1 != NOERROR) || (hr2 != NOERROR))
    {
        MSRtpDelete1();
        return(RTPERR_FAIL);
    }

    return(NOERROR);
}

/*
 * This function does initialization not allowed during process
 * attach, e.g. initialize winsock2 */
RTPSTDAPI MSRtpInit2(void)
{
    HRESULT          hr;
    BOOL             bOk;
    DWORD            dwError;
    WSADATA          WSAData;
    WORD             VersionRequested;
    

    hr = RTPERR_FAIL;

    /* Critical section was initialized during process attach by
     * MSRtpInit1 */
    bOk = RtpEnterCriticalSection(&g_RtpContext.RtpWS2CritSect);

    if (bOk)
    {
        if (g_RtpContext.lRtpWS2Users <= 0)
        {
            /* Initialize some debug variables */
            hr = RtpDebugInit(RTPDBG_MODULENAME);

            /* initialize winsock */
            VersionRequested = MAKEWORD(2,0);
            
            dwError = WSAStartup(VersionRequested, &WSAData);

            if (dwError == 0)
            {
                /* socket used to query destination address */
                g_RtpContext.RtpQuerySocket = WSASocket(
                        AF_INET,    /* int af */
                        SOCK_DGRAM, /* int type */
                        IPPROTO_IP, /* int protocol */
                        NULL,       /* LPWSAPROTOCOL_INFO lpProtocolInfo */
                        0,          /* GROUP g */
                        NO_FLAGS    /* DWORD dwFlags */
                    );
        
                if (g_RtpContext.RtpQuerySocket == INVALID_SOCKET)
                {
                    WSACleanup();
                }
                else
                {
                    RtpRegistryInit(&g_RtpReg);

                    /* Needs to be called after RtpRegistryInit so the
                     * possible registry defaults are already read */
                    RtcpSdesInit(&g_RtpSdesDefault);
                    RtcpSdesSetDefault(&g_RtpSdesDefault);

                    RtpRandInit();
                    
                    g_RtpContext.lRtpWS2Users = 1;

                    hr = NOERROR;
                }
            }
        }
        else
        {
            g_RtpContext.lRtpWS2Users++;

            hr = NOERROR;
        }

        RtpLeaveCriticalSection(&g_RtpContext.RtpWS2CritSect);
    }

    return(hr);
}

            
/*
 * Complementary function of MSRtpInit(). Can be called from
 * DllMain(PROCESS_DETACH) if linked as a DLL, or explicitly from an
 * application de-initializing the RTP stack if linked as a
 * library. */
RTPSTDAPI MSRtpDelete1(void)
{
    HRESULT          hr1;
    HRESULT          hr2;
    BOOL             bOk1;
    BOOL             bOk2;
    BOOL             bOk3;
    BOOL             bOk4;

    hr1 = RtpDelete();
    hr2 = RtcpDelete();

    bOk1 = RtpDestroyGlobHeaps();
    bOk2 = RtpDestroyMasterHeap();

    bOk3 = RtpDeleteCriticalSection(&g_RtpContext.RtpWS2CritSect);

    bOk4 = RtpDeleteCriticalSection(&g_RtpContext.RtpPortsCritSect);
    
    if ((hr1 != NOERROR) || (hr2 != NOERROR) ||
        !bOk1 || !bOk2 || !bOk3 || !bOk4)
    {
        return(RTPERR_FAIL);
    }
    else
    {
        return(NOERROR);
    }
}

/*
 * Complementary function of MSRtpInit2(). */
RTPSTDAPI MSRtpDelete2(void)
{
    HRESULT          hr;
    DWORD            dwError;
    BOOL             bOk;

    dwError = NOERROR;
    
    /* Critical section was initialized during process attach by
     * MSRtpInit1 */
    bOk = RtpEnterCriticalSection(&g_RtpContext.RtpWS2CritSect);

    if (bOk)
    {
        g_RtpContext.lRtpWS2Users--;

        if (g_RtpContext.lRtpWS2Users <= 0)
        {
            if (g_RtpContext.RtpQuerySocket != INVALID_SOCKET)
            {
                closesocket(g_RtpContext.RtpQuerySocket);
                g_RtpContext.RtpQuerySocket = INVALID_SOCKET;
            }
        
            dwError = WSACleanup();

            RtpRandDeinit();

            RtpRegistryDel(&g_RtpReg);

            RtpDebugDeinit();
        }

        RtpLeaveCriticalSection(&g_RtpContext.RtpWS2CritSect);
    }

    if ((bOk == FALSE) || (dwError != NOERROR))
    {
        return(RTPERR_FAIL);
    }
    else
    {
        return(NOERROR);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\msrtp\rtcp\rtcprecv.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtcprecv.c
 *
 *  Abstract:
 *
 *    Asynchronous RTCP packet reception
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/07/07 created
 *
 **********************************************************************/

#include "struct.h"
#include "rtpglobs.h"
#include "rtpheap.h"
#include "rtpncnt.h"
#include "rtcpdec.h"
#include "rtcpsend.h"
#include "rtpcrypt.h"
#include "rtpevent.h"

#include "rtcprecv.h"

DWORD RtcpValidatePacket(
        RtcpAddrDesc_t  *pRtcpAddrDesc,
        RtcpRecvIO_t    *pRtcpRecvIO
    );

DWORD RtcpProcessPacket(
        RtcpAddrDesc_t  *pRtcpAddrDesc,
        RtcpRecvIO_t    *pRtcpRecvIO
    );

HRESULT StartRtcpRecvFrom(
        RtcpContext_t   *pRtcpContext,
        RtcpAddrDesc_t  *pRtcpAddrDesc
    )
{
    HRESULT          hr;
    DWORD            dwStatus;
    DWORD            dwError;
    RtcpRecvIO_t    *pRtcpRecvIO;
    RtpAddr_t       *pRtpAddr;

    TraceFunctionName("StartRtcpRecvFrom");
    
    pRtcpRecvIO = pRtcpAddrDesc->pRtcpRecvIO;
    pRtpAddr = pRtcpAddrDesc->pRtpAddr;
    
    /* Overlapped structure */
    pRtcpRecvIO->Overlapped.hEvent = pRtcpRecvIO->hRtcpCompletedEvent;

    do {
        dwError = NOERROR;
        
        pRtcpRecvIO->Overlapped.Internal = 0;
            
        pRtcpRecvIO->Fromlen = sizeof(pRtcpRecvIO->From);
        
        pRtcpRecvIO->WSABuf.len = sizeof(pRtcpRecvIO->RecvBuffer);
        pRtcpRecvIO->WSABuf.buf = pRtcpRecvIO->RecvBuffer;
            
        dwStatus = WSARecvFrom(
                pRtpAddr->Socket[SOCK_RTCP_IDX], /* SOCKET s */
                &pRtcpRecvIO->WSABuf,   /* LPWSABUF lpBuffers */
                1,                      /* DWORD dwBufferCount */
                &pRtcpRecvIO->dwTransfered,/*LPDWORD lpNumberOfBytesRecvd*/
                &pRtcpRecvIO->dwRecvIOFlags,/* LPDWORD lpFlags */
                &pRtcpRecvIO->From,      /* struct sockaddr FAR *lpFrom */
                &pRtcpRecvIO->Fromlen,   /* LPINT lpFromlen */
                &pRtcpRecvIO->Overlapped,/* LPWSAOVERLAPPED lpOverlapped */
                NULL              /* LPWSAOVERLAPPED_COMPLETION_ROUTINE */
            );
            
        if (dwStatus)
        {
            dwError = WSAGetLastError();
        }
    } while(dwStatus &&
            ( (dwError == WSAECONNRESET) ||
              (dwError == WSAEMSGSIZE) )   );

    if (!dwStatus || (dwError == WSA_IO_PENDING))
    {
        RtpBitSet(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_RECVPENDING);

        pRtcpAddrDesc->lRtcpPending = 1;

        hr = NOERROR;
        
    }
    else
    {
        /* TODO I may put this AddrDesc in a queue and attempt to
         * start async I/O again later, or visit all the descriptors
         * periodically and start asynchronous reception in those that
         * failed the first time */

        RtpBitReset(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_RECVPENDING);

        hr = RTPERR_WS2RECV;
        
        TraceRetail((
                CLASS_ERROR, GROUP_RTCP, S_RTCP_RECV,
                _T("%s: overlaped reception ")
                _T("failed to start: %u (0x%X)"),
                _fname, dwError, dwError
            ));

        RtpPostEvent(pRtpAddr,
                     NULL,
                     RTPEVENTKIND_RTP,
                     RTPRTP_WS_RECV_ERROR,
                     RTCP_IDX,
                     dwError);
    }

    return(hr);
}

HRESULT ConsumeRtcpRecvFrom(
        RtcpContext_t   *pRtcpContext,
        RtcpAddrDesc_t  *pRtcpAddrDesc
    )
{
    HRESULT          hr;
    BOOL             bStatus;
    DWORD            dwError;
    BOOL             bRestart;
    DWORD            dwTransfered;
    DWORD            dwSSRC;
    DWORD            dwSendSSRC;
    DWORD            dwFlags;
    
    RtcpRecvIO_t    *pRtcpRecvIO;
    RtpAddr_t       *pRtpAddr;
    SOCKADDR_IN     *pFromIn;

    TraceFunctionName("ConsumeRtcpRecvFrom");

    pRtcpRecvIO = pRtcpAddrDesc->pRtcpRecvIO;
    pRtpAddr = pRtcpAddrDesc->pRtpAddr;

    hr       = NOERROR;
    bRestart = FALSE;
    dwError  = NOERROR;
    
    bStatus = WSAGetOverlappedResult(
            pRtcpAddrDesc->Socket[SOCK_RTCP_IDX],    /* SOCKET s */
            &pRtcpRecvIO->Overlapped,  /* LPWSAOVERLAPPED lpOverlapped */
            &pRtcpRecvIO->dwTransfered,/* LPDWORD lpcbTransfer */
            FALSE,                     /* BOOL fWait */
            &pRtcpRecvIO->dwRecvIOFlags /* LPDWORD lpdwFlags */
        );
            
    if (!bStatus)
    {
        /* I/O error */
        
        dwError = WSAGetLastError();
                
        if (dwError == WSA_IO_INCOMPLETE)
        {
            /* I/O hasn't completed yet */
            /* TODO log error UNEXPECTED condition */
        }
        else if ( (dwError == WSA_OPERATION_ABORTED) ||
                  (dwError == WSAEINTR) )
        {
            /* Socket closed, I/O completed */
            RtpBitReset(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_RECVPENDING);

            pRtcpAddrDesc->lRtcpPending = 0;
        }
        else
        {
            /* On any other error, including WSAECONNRESET and
             * WSAEMSGSIZE, re-start I/O */
            bRestart = TRUE;

            /* Error, I/O completed */
            RtpBitReset(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_RECVPENDING);

            pRtcpAddrDesc->lRtcpPending = 0;
        }
    }
    else
    {
        /* I/O completed normally */

        pRtcpRecvIO->dRtcpRecvTime =
            RtpGetTimeOfDay(&pRtcpRecvIO->RtcpRecvTime);
        
        /* Save original value of dwTransfered to be used later as it
         * may be modified in RtcpValidatePacket if packet is
         * decrypted */
        dwTransfered = pRtcpRecvIO->dwTransfered;
        
        RtpBitReset(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_RECVPENDING);

        pRtcpAddrDesc->lRtcpPending = 0;

        bRestart = TRUE;
        
        pRtcpRecvIO->dwError = dwError;

        dwFlags = 0;
        
        /* Validate packet */
        dwError = RtcpValidatePacket(pRtcpAddrDesc, pRtcpRecvIO);

        if (dwError == NOERROR)
        {
            pFromIn = (SOCKADDR_IN *)&pRtcpRecvIO->From;
            
            /* Filter explicitly loopback packets if needed */
            /* Decide if we need to detect collisions */
            if ( RtpBitTest2(pRtpAddr->dwAddrFlags,
                             FGADDR_COLLISION, FGADDR_ISMCAST) ==
                 RtpBitPar2(FGADDR_COLLISION, FGADDR_ISMCAST) )
            {
                dwSSRC = * (DWORD *)
                    (pRtcpRecvIO->WSABuf.buf + sizeof(RtcpCommon_t));

                dwSendSSRC = pRtpAddr->RtpNetSState.dwSendSSRC;
                
                if (dwSSRC == dwSendSSRC)
                {
                    if (RtpDropCollision(pRtpAddr, pFromIn, FALSE))
                    {
                        dwFlags = RtpBitPar2(FGRECV_DROPPED, FGRECV_LOOP);
                    }
                }
            }

            if (RtpBitTest(pRtpAddr->dwIRtpFlags, FGADDR_IRTP_MATCHRADDR))
            {
                if (pFromIn->sin_addr.s_addr != pRtpAddr->dwAddr[REMOTE_IDX])
                {
                    dwFlags = RtpBitPar2(FGRECV_DROPPED, FGRECV_MISMATCH);
                }
            }

            /* Process packet */
            if (!RtpBitTest(dwFlags, FGRECV_DROPPED))
            {
                RtcpProcessPacket(pRtcpAddrDesc, pRtcpRecvIO);
            }
        }

        /* NOTE should I update counters and compute average size only
         * if the packet was processed (not discarded)? */
        
        /* Update RTCP reception counters */
        RtpUpdateNetCount(&pRtcpAddrDesc->pRtpAddr->RtpAddrCount[RECV_IDX],
                          NULL,
                          RTCP_IDX,
                          dwTransfered,
                          dwFlags,
                          pRtcpRecvIO->dRtcpRecvTime);

        /* Update average RTCP packet size */
        RtcpUpdateAvgPacketSize(pRtcpAddrDesc->pRtpAddr, dwTransfered);
    }

    if (RtpBitTest(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_SHUTDOWN2))
    {
        TraceDebug((
                CLASS_INFO, GROUP_RTCP, S_RTCP_RECV,
                _T("%s: pRtcpAddrDesc[0x%p] pRtpAddr[0x%p] ")
                _T("I/O:%d AddrDescStopQ->"),
                _fname, pRtcpAddrDesc, pRtpAddr,
                pRtcpAddrDesc->lRtcpPending
            ));

        /* Shutting down, remove from AddrDescStopQ, it will be moved
         * to AddrDescFreeQ in RtcpRemoveFromVector() */
        dequeue(&pRtcpContext->AddrDescStopQ,
                NULL,
                &pRtcpAddrDesc->AddrDescQItem);

        pRtcpAddrDesc->AddrDescQItem.pvOther = NULL;
    }
    else
    {
        if (bRestart &&
            !RtpBitTest(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_SHUTDOWN1))
        {
            hr = StartRtcpRecvFrom(pRtcpContext, pRtcpAddrDesc); 
        }
    }

    return(hr);
}

DWORD RtcpValidatePacket(
        RtcpAddrDesc_t  *pRtcpAddrDesc,
        RtcpRecvIO_t    *pRtcpRecvIO
    )
{
    RtpAddr_t       *pRtpAddr;
    RtpCrypt_t      *pRtpCrypt;
    RtcpCommon_t    *pRtcpCommon;
    char            *hdr;
    char            *end;
    int              len;
    WORD             len2;

    TraceFunctionName("RtcpValidatePacket");

    pRtpAddr = pRtcpAddrDesc->pRtpAddr;
    pRtpCrypt = pRtpAddr->pRtpCrypt[CRYPT_RTCP_IDX];
    
    if ( pRtpCrypt &&
         (RtpBitTest2(pRtpCrypt->dwCryptFlags, FGCRYPT_INIT, FGCRYPT_KEY) ==
          RtpBitPar2(FGCRYPT_INIT, FGCRYPT_KEY)) )
    {
        if ((pRtpAddr->dwCryptMode & 0xffff) == RTPCRYPTMODE_ALL)
        {
            /* Decrypt whole RTCP packet */

            pRtcpRecvIO->dwError = RtpDecrypt(
                    pRtpAddr,
                    pRtpCrypt,
                    pRtcpRecvIO->WSABuf.buf,
                    &pRtcpRecvIO->dwTransfered
                );

            if (pRtcpRecvIO->dwError == NOERROR)
            {
                /* remove random 32bits number */
                pRtcpRecvIO->WSABuf.buf += sizeof(DWORD);
                pRtcpRecvIO->WSABuf.len -= sizeof(DWORD);
                pRtcpRecvIO->dwTransfered -= sizeof(DWORD);
            }
            else
            {
                if (!pRtpCrypt->CryptFlags.DecryptionError)
                {
                    /* Post an event only the first time */
                    pRtpCrypt->CryptFlags.DecryptionError = 1;
                
                    RtpPostEvent(pRtpAddr,
                                 NULL,
                                 RTPEVENTKIND_RTP,
                                 RTPRTP_CRYPT_RECV_ERROR,
                                 RTCP_IDX,
                                 pRtpCrypt->dwCryptLastError);
                }

                goto bail;
            }
        }
    }
    
    len = (int)pRtcpRecvIO->dwTransfered;

    /*
     * Check minimal size
     * */
    if (len < (sizeof(RtcpCommon_t) + sizeof(DWORD)))
    {
        /* packet too short */

        pRtcpRecvIO->dwError = RTPERR_MSGSIZE;

        TraceRetail((
                CLASS_WARNING, GROUP_RTCP, S_RTCP_RECV,
                _T("%s: Packet too short: %d"),
                _fname, len
            ));
        
        goto bail;
    }

    hdr = pRtcpRecvIO->WSABuf.buf;

    end = NULL;

    while(len > sizeof(RtcpCommon_t))
    {
        pRtcpCommon = (RtcpCommon_t *)hdr;
        
        if (!end)
        {
            /* Set the end of the buffer */
            end = hdr + len;
            
            /* Test version (must be RTP_VERSION), padding (must be 0)
             * and payload type (must be SR or RR) */
            if ( (*(DWORD *)hdr & RTCP_VALID_MASK) != RTCP_VALID_VALUE )
            {
                /* invalid packet */

                pRtcpRecvIO->dwError = RTPERR_INVALIDHDR;
        
                TraceRetail((
                        CLASS_WARNING, GROUP_RTCP, S_RTCP_RECV,
                        _T("%s: Invalid mask 0x%X != 0x%X"),
                        _fname,
                        (*(DWORD *)hdr & RTCP_VALID_MASK),
                        RTCP_VALID_VALUE
                    ));
                
                goto bail;
            }
        }
        else
        {
            /* Only test version */
            if (pRtcpCommon->version != RTP_VERSION)
            {
                pRtcpRecvIO->dwError = RTPERR_INVALIDVERSION;
        
                TraceRetail((
                        CLASS_WARNING, GROUP_RTCP, S_RTCP_RECV,
                        _T("%s: Invalid version: %u"),
                        _fname, pRtcpCommon->version
                    ));
                
                goto bail;
            }
        }
        
        len2 = pRtcpCommon->length;
        
        len2 = (ntohs(len2) + 1) * sizeof(DWORD);

        hdr += len2;
        
        if (hdr > end)
        {
            /* Overrun error */
            pRtcpRecvIO->dwError = RTPERR_INVALIDHDR;
            
            TraceRetail((
                    CLASS_WARNING, GROUP_RTCP, S_RTCP_RECV,
                    _T("%s: Overrun error: +%u"),
                    _fname, (DWORD)(hdr-end)
                ));
            
            goto bail;
        }

        len -= len2;
    }

    /* NOTE, at this point, if we have extra bytes, i.e. len!=0,
     * either the sender included provider specific extensions, or we
     * have a bad formed packet */

    pRtcpRecvIO->dwError = NOERROR;

 bail:
    if (pRtcpRecvIO->dwError != NOERROR)
    {
        TraceRetail((
                CLASS_WARNING, GROUP_RTCP, S_RTCP_RECV,
                _T("%s: pRtcpAddrDesc[0x%p] pRtcpRecvIO[0x%p] ")
                _T("Invalid packet: %u (0x%X)"),
                _fname, pRtcpAddrDesc, pRtcpRecvIO,
                pRtcpRecvIO->dwError, pRtcpRecvIO->dwError
            ));
    }
    
    return(pRtcpRecvIO->dwError);
}

DWORD RtcpProcessPacket(
        RtcpAddrDesc_t  *pRtcpAddrDesc,
        RtcpRecvIO_t    *pRtcpRecvIO
    )
{
    RtcpCommon_t    *pRtcpCommon;
    char            *hdr;
    char            *end;
    int              len;
    short            len2;

    /* NOTE Compound packet was already validated, yet individual
     * packets (e.g. SR, RR, SDES) may need more validation and will
     * be ignored if errors were found */
    
    len = (int)pRtcpRecvIO->dwTransfered;

    hdr = pRtcpRecvIO->WSABuf.buf;

    end = hdr + len;

    while(len > sizeof(RtcpCommon_t))
    {
        pRtcpCommon = (RtcpCommon_t *)hdr;

        switch(pRtcpCommon->pt)
        {
        case RTCP_SR:
        case RTCP_RR:
            RtcpProcessSR_RR(pRtcpAddrDesc, hdr, len,
                             (SOCKADDR_IN *)&pRtcpRecvIO->From);
            break;
            
        case RTCP_SDES:
            RtcpProcessSDES(pRtcpAddrDesc, hdr);
            break;
            
        case RTCP_BYE:
            RtcpProcessBYE(pRtcpAddrDesc, hdr);
            break;
            
         case RTCP_APP:
            RtcpProcessAPP(pRtcpAddrDesc, hdr);
            break;

        default:
            RtcpProcessDefault(pRtcpAddrDesc, hdr);
        }
        
        len2 = pRtcpCommon->length;
        
        len2 = (ntohs(len2) + 1) * sizeof(DWORD);

        hdr += len2;
        
        len -= len2;
    }
    
    return(NOERROR);
}

/*
 * Creates and initialize a RtcpRecvIO_t structure
 * */
RtcpRecvIO_t *RtcpRecvIOAlloc(
        RtcpAddrDesc_t  *pRtcpAddrDesc
    )
{
    DWORD            dwError;
    RtcpRecvIO_t    *pRtcpRecvIO;
    TCHAR            Name[128];
    
    TraceFunctionName("RtcpRecvIOAlloc");

    pRtcpRecvIO = (RtcpRecvIO_t *)
        RtpHeapAlloc(g_pRtcpRecvIOHeap, sizeof(RtcpRecvIO_t));

    if (!pRtcpRecvIO) {
        
        TraceRetail((
                CLASS_ERROR, GROUP_RTCP, S_RTCP_ALLOC,
                _T("%s: pRtcpAddrDesc[0x%p] failed to allocate memory"),
                _fname, pRtcpAddrDesc
            ));

        goto bail;
    }

    ZeroMemory(pRtcpRecvIO, sizeof(RtcpRecvIO_t) - RTCP_RECVDATA_BUFFER);

    pRtcpRecvIO->dwObjectID = OBJECTID_RTCPRECVIO;

    pRtcpRecvIO->pRtcpAddrDesc = pRtcpAddrDesc;

    /* Create a named event for overlapped completion */
    _stprintf(Name, _T("%X:pRtcpAddrDesc[0x%p] pRtcpRecvIO->hQosNotifyEvent"),
              GetCurrentProcessId(), pRtcpAddrDesc);
    
    pRtcpRecvIO->hRtcpCompletedEvent = CreateEvent(
            NULL,  /* LPSECURITY_ATTRIBUTES lpEventAttributes */
            FALSE, /* BOOL bManualReset */
            FALSE, /* BOOL bInitialState */
            Name   /* LPCTSTR lpName */
        );

    if (!pRtcpRecvIO->hRtcpCompletedEvent) {

        TraceRetailGetError(dwError);
        
        TraceRetail((
                CLASS_ERROR, GROUP_RTCP, S_RTCP_RECV,
                _T("%s: failed to create hRtcpCompletedEvent %u (0x%X)"),
                _fname, dwError, dwError
            ));

        goto bail;
    }

    return(pRtcpRecvIO);

 bail:
    RtcpRecvIOFree(pRtcpRecvIO);

    return((RtcpRecvIO_t *)NULL);
}

/*
 * Deinitilize and frees a RtcpRecvIO_t structure
 * */
void RtcpRecvIOFree(RtcpRecvIO_t *pRtcpRecvIO)
{
    TraceFunctionName("RtcpRecvIOFree");
    
    if (!pRtcpRecvIO)
    {
        /* TODO may be log */
        return;
    }
    
    if (pRtcpRecvIO->dwObjectID != OBJECTID_RTCPRECVIO)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTCP, S_RTCP_ALLOC,
                _T("%s: pRtcpRecvIO[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtcpRecvIO,
                pRtcpRecvIO->dwObjectID, OBJECTID_RTCPRECVIO
            ));

        return;
    }

    /* Close event for asynchronous RTCP reception */
    if (pRtcpRecvIO->hRtcpCompletedEvent)
    {
        CloseHandle(pRtcpRecvIO->hRtcpCompletedEvent);
        pRtcpRecvIO->hRtcpCompletedEvent = NULL;
    }

    /* Invalidate object */
    INVALIDATE_OBJECTID(pRtcpRecvIO->dwObjectID);

    RtpHeapFree(g_pRtcpRecvIOHeap, pRtcpRecvIO);  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\filters\rtp\msrtp\rtcp\rtcpsend.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtcpsend.c
 *
 *  Abstract:
 *
 *    Format and send RTCP reports
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/07/10 created
 *
 **********************************************************************/

#include <winsock2.h>

#include "struct.h"
#include "rtpheap.h"
#include "rtpglobs.h"
#include "rtpncnt.h"
#include "rtprand.h"
#include "rtpcrypt.h"
#include "rtpevent.h"
#include "rtpmisc.h"
#include "rtpred.h"
#include "rtpreg.h"
#include "rtcpband.h"

#include "rtcpsend.h"

/*
 * Forward declaration of helper functions
 * */

HRESULT RtcpXmitPacket(RtpAddr_t *pRtpAddr, WSABUF *pWSABuf);

DWORD RtcpFillXRReport(RtpAddr_t *pRtpAddr, char *pBuffer, DWORD len);

DWORD RtcpFillProbe(RtpAddr_t *pRtpAddr, char *pBuffer, DWORD len);

void RtcpFillCommon(
        RtcpCommon_t    *pRtcpCommon,
        long             lCount,
        DWORD            dwPad,
        BYTE             bPT,
        DWORD            dwLen
    );

DWORD RtcpFillSInfo(RtpAddr_t *pRtpAddr, char *pBuffer, DWORD len);

DWORD RtcpFillReportBlocks(
        RtpAddr_t       *pRtpAddr,
        char            *pBuffer,
        DWORD            len,
        long            *plCount
    );

DWORD RtcpFillRBlock(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        char            *pBuffer
    );

DWORD RtcpFillSdesInfo(RtpAddr_t *pRtpAddr, char *pBuffer, DWORD len);

DWORD RtcpFillSdesItem(
        RtpSdes_t       *pRtpSdes,
        char            *pBuffer,
        DWORD            len,
        DWORD            dwItem);

DWORD ScheduleSdes(RtpSess_t *pRtpSess);

DWORD RtcpFillBye(RtpAddr_t *pRtpAddr, char *pBuffer, DWORD len);

DWORD RtcpFillPEBand(RtpAddr_t *pRtpAddr, char *pBuffer, DWORD len);

/*
 * Bandwidth estimation
 */
/* The initial count is the number of reports that will use
 * MOD_INITIAL to decide if a probe packet is sent, after that
 * MOD_FINAL will be used. */
DWORD            g_dwRtcpBandEstInitialCount =
                                RTCP_BANDESTIMATION_INITIAL_COUNT;

/* Number or valid reports received before the estimation is posted
 * for the first time */
DWORD            g_dwRtcpBandEstMinReports =
                                RTCP_BANDESTIMATION_MINREPORTS;
/* Initial modulo */
DWORD            g_dwRtcpBandEstModInitial = RTCP_BANDESTIMATION_MOD_INITIAL;

/* Final modulo */
DWORD            g_dwRtcpBandEstModNormal = RTCP_BANDESTIMATION_MOD_FINAL;

/*
 * WARNING
 *
 * Make sure to keep the number of individual bins to be
 * RTCP_BANDESTIMATION_MAXBINS+1 (same thing in rtpreg.h and rtpreg.c)
 *
 * Boundaries for each bin (note there is 1 more than the number of
 * bins) */
double           g_dRtcpBandEstBin[RTCP_BANDESTIMATION_MAXBINS + 1] =
{
    RTCP_BANDESTIMATION_BIN0,
    RTCP_BANDESTIMATION_BIN1,
    RTCP_BANDESTIMATION_BIN2,
    RTCP_BANDESTIMATION_BIN3,
    RTCP_BANDESTIMATION_BIN4
};

/* Estimation is valid if updated within this time (seconds) */
double           g_dRtcpBandEstTTL = RTCP_BANDESTIMATION_TTL;

/* An event is posted if no estimation is available within this
 * seconds after the first RB has been received */
double           g_dRtcpBandEstWait = RTCP_BANDESTIMATION_WAIT;

/* Maximum time gap between 2 consecutive RTCP SR reports to do
 * bandwidth estimation (seconds) */
double           g_dRtcpBandEstMaxGap = RTCP_BANDESTIMATION_MAXGAP;

/************************/

/**********************************************************************
 * Functions implementation
 **********************************************************************/

HRESULT RtcpSendReport(RtcpAddrDesc_t *pRtcpAddrDesc)
{
    char            *ptr;
    double           dRTCPLastTime;
    DWORD            used;
    DWORD            len;
    HRESULT          hr;
    WSABUF           WSABuf;
    DWORD            dwPacketSize;
    RtpAddr_t       *pRtpAddr;

    TraceFunctionName("RtcpSendReport");
    
    pRtpAddr = pRtcpAddrDesc->pRtpAddr;

    /* NOTE Reserve space for the 32bits random number used for
     * encryption, reserve it no matter we are actually encrypting or
     * not */
    
    ptr = pRtcpAddrDesc->pRtcpSendIO->SendBuffer + sizeof(DWORD);
    WSABuf.buf = ptr;
    len = sizeof(pRtcpAddrDesc->pRtcpSendIO->SendBuffer) - sizeof(DWORD);

    /* Bandwidth estimation is performed only when we are sending, it
     * hasn't been disabled because the other end is responding, it is
     * enabled, and the class is defined as audio */
    if (pRtpAddr->RtpNetSState.bWeSent
        &&
        !RtpBitTest(pRtpAddr->RtpNetSState.dwNetSFlags, FGNETS_DONOTSENDPROBE)
        &&
        RtpBitTest(pRtpAddr->pRtpSess->dwFeatureMask, RTPFEAT_BANDESTIMATION)
        &&
        (RtpGetClass(pRtpAddr->dwIRtpFlags) == RTPCLASS_AUDIO)
        )
    {
        /* If doing bandwidth estimation, decide if a probe packet
         * needs to be sent now */
        if ( !(pRtpAddr->RtpAddrCount[SEND_IDX].dwRTCPPackets %
               pRtpAddr->RtpNetSState.dwBandEstMod) )
        {
            /* Send a bandwidth probe RTCP SR packet */
            used = RtcpFillProbe(pRtpAddr, ptr, len);

            WSABuf.len = used;

            /* Update average RTCP report */
            RtcpUpdateAvgPacketSize(pRtpAddr, WSABuf.len);

            /* Save the time last RTCP was sent. I must use that one
             * to decide what participants (if any) will be included
             * in the report blocks in the legitimate RTCP report
             * (this been the probe RTCP report). If I don't, then
             * that time will be updated when this probe packet is
             * sent in RtcpXmitPacket and there is a good chance that
             * during a few milliseconds after that, enough to send
             * the ligitimate RTCP report, I would have not received
             * any more RTP packets hence preventing the inclusion of
             * that partipant in the report blocks which otherwise
             * would have been included */
            dRTCPLastTime = pRtpAddr->RtpAddrCount[SEND_IDX].dRTCPLastTime;
            
            hr = RtcpXmitPacket(pRtpAddr, &WSABuf);

            /* Restore the saved time */
            pRtpAddr->RtpAddrCount[SEND_IDX].dRTCPLastTime = dRTCPLastTime;
            
            pRtpAddr->RtpNetSState.dwBandEstCount++;
            
            TraceDebugAdvanced((
                    0, GROUP_RTCP, S_RTCP_RRSR,
                    _T("%s:  pRtpAddr[0x%p] RTCP SR probe packet sent ")
                    _T("at %0.3f"),
                    _fname, pRtpAddr, RtpGetTimeOfDay((RtpTime_t *)NULL)
                ));

            /* Now decide if the modulo needs to be updated */
#if 0
            /* Removing this code makes the probing packet to be sent
             * on every SR report sent if the initial modulo is kept
             * as 2 */
            if (pRtpAddr->RtpNetSState.dwBandEstCount ==
                g_dwRtcpBandEstInitialCount)
            {
                pRtpAddr->RtpNetSState.dwBandEstMod = g_dwRtcpBandEstModNormal;
            }
#endif       
            /* Restore ptr and len before going ahead to send next packet */
            ptr = WSABuf.buf;
            len =
                sizeof(pRtcpAddrDesc->pRtcpSendIO->SendBuffer) - sizeof(DWORD);
        }
    }
    
    /* Fill RR or SR */
    used = RtcpFillXRReport(pRtpAddr, ptr, len);
    ptr += used;
    len -= used;
    
    /* Fill SDES (new RTCP packet, same compound packet) */
    used = RtcpFillSdesInfo(pRtpAddr, ptr, len);
    ptr += used;
    
    WSABuf.len = (DWORD) (ptr - WSABuf.buf);

    /* Update average RTCP report */
    RtcpUpdateAvgPacketSize(pRtpAddr, WSABuf.len);

    hr = RtcpXmitPacket(pRtpAddr, &WSABuf);
    
    TraceDebug((
            0, GROUP_RTCP, S_RTCP_RRSR,
            _T("%s:  pRtpAddr[0x%p] RTCP packet sent at %0.3f"),
            _fname, pRtpAddr, RtpGetTimeOfDay((RtpTime_t *)NULL)
        ));

    return(hr);
}

/* TODO implement section 6.3.7 (Transmitting a BYE packet) from
 * draft-ietf-avt-rtp-new-05 that applies when sessions have more than
 * 50 participants and the sending of BYE is delayed */
HRESULT RtcpSendBye(RtcpAddrDesc_t *pRtcpAddrDesc)
{
    char          *ptr;
    DWORD          used;
    DWORD          len;
    HRESULT        hr;
    WSABUF         WSABuf;
    RtpAddr_t     *pRtpAddr;

    TraceFunctionName("RtcpSendBye");

    pRtpAddr = pRtcpAddrDesc->pRtpAddr;

    /* NOTE Reserve space for the 32bits random number used for
     * encryption, reserve it no matter we are actually encrypting or
     * not */
    
    ptr = pRtcpAddrDesc->pRtcpSendIO->SendBuffer + sizeof(DWORD);
    WSABuf.buf = ptr;
    len = sizeof(pRtcpAddrDesc->pRtcpSendIO->SendBuffer) - sizeof(DWORD);

    /* Fill RR or SR */
    used = RtcpFillXRReport(pRtpAddr, ptr, len);
    ptr += used;
    len -= used;
    
    /* Fill BYE (new RTCP packet, same compound packet) */
    used = RtcpFillBye(pRtpAddr, ptr, len);
    ptr += used;

    WSABuf.len = (DWORD) (ptr - WSABuf.buf);

    hr = RtcpXmitPacket(pRtpAddr, &WSABuf);
    
    TraceDebug((
            0, GROUP_RTCP, S_RTCP_RRSR,
            _T("%s:  pRtpAddr[0x%p] RTCP packet sent at %0.3f"),
            _fname, pRtpAddr, RtpGetTimeOfDay((RtpTime_t *)NULL)
        ));

    return(hr);
}


HRESULT RtcpXmitPacket(RtpAddr_t *pRtpAddr, WSABUF *pWSABuf)
{
    DWORD            dwEvent;
    RtpCrypt_t      *pRtpCrypt;
    SOCKADDR_IN      saddr;
    DWORD            dwStatus;
    DWORD            dwError;
    DWORD            dwNumBytesSent;
    double           dTime;
    TCHAR_t          sAddr[16];

    TraceFunctionName("RtcpXmitPacket");

    saddr.sin_family = AF_INET;
    saddr.sin_addr.s_addr = pRtpAddr->dwAddr[REMOTE_IDX];
    saddr.sin_port = pRtpAddr->wRtcpPort[REMOTE_IDX];

    dwError = NOERROR;
        
    if (!RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_RADDR) ||
        !pRtpAddr->wRtcpPort[REMOTE_IDX])
    {
        /* Do not send packet if remote address is not specified or
         * remote port is zero */
        TraceRetail((
                CLASS_WARNING, GROUP_RTCP, S_RTCP_SEND,
                _T("%s: pRtpAddr[0x%p] WSASendTo(len:%u, %s/%u) ")
                _T("failed: no destination address/port"), 
                _fname, pRtpAddr, pWSABuf->len,
                RtpNtoA(saddr.sin_addr.s_addr, sAddr),
                (DWORD)(ntohs(saddr.sin_port))
            ));
        
        goto end;
    }

    pRtpCrypt = pRtpAddr->pRtpCrypt[CRYPT_RTCP_IDX];
    
    if ( pRtpCrypt &&
         (RtpBitTest2(pRtpCrypt->dwCryptFlags, FGCRYPT_INIT, FGCRYPT_KEY) ==
          RtpBitPar2(FGCRYPT_INIT, FGCRYPT_KEY)) )
    {

        /* If using encryption, insert the random 32bits word at the
         * bigining of buffer */
        pWSABuf->buf -= sizeof(DWORD);
        pWSABuf->len += sizeof(DWORD);

        *(DWORD *)pWSABuf->buf = RtpRandom32((DWORD_PTR)pWSABuf);
        
        dwError = RtpEncrypt(
                pRtpAddr,
                pRtpAddr->pRtpCrypt[CRYPT_RTCP_IDX],
                pWSABuf,
                1,
                pRtpAddr->CryptBuffer[RTCP_IDX],
                pRtpAddr->dwCryptBufferLen[RTCP_IDX]
            );

        if (dwError)
        {
            if (!pRtpCrypt->CryptFlags.EncryptionError)
            {
                /* Post an event only the first time */
                pRtpCrypt->CryptFlags.EncryptionError = 1;
            
                RtpPostEvent(pRtpAddr,
                             NULL,
                             RTPEVENTKIND_RTP,
                             RTPRTP_CRYPT_SEND_ERROR,
                             RTCP_IDX,
                             pRtpCrypt->dwCryptLastError);
            }

            goto end;
        }
    }

    dwStatus = WSASendTo(
            pRtpAddr->Socket[SOCK_RTCP_IDX],/* SOCKET    s */
            pWSABuf,             /* LPWSABUF  lpBuffers */
            1,                   /* DWORD dwBufferCount */    
            &dwNumBytesSent,     /* LPDWORD lpNumberOfBytesSent */    
            0,                   /* DWORD dwFlags*/    
            (SOCKADDR *)&saddr,  /* const struct sockaddr FAR *lpTo */
            sizeof(saddr),       /* int iToLen*/
            NULL,                /* LPWSAOVERLAPPED lpOverlapped */
            NULL /* LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionROUTINE */
        );

    dTime = RtpGetTimeOfDay((RtpTime_t *)NULL);
    
    if (dwStatus)
    {
        TraceRetailWSAGetError(dwError);

        dwEvent = RTPRTP_WS_SEND_ERROR;
        
        if (dwError == WSAEADDRNOTAVAIL)
        {
            dwEvent = RTPRTP_WS_NET_FAILURE;
        }

        TraceRetail((
                CLASS_ERROR, GROUP_RTCP, S_RTCP_SEND,
                _T("%s: pRtpAddr[0x%p] WSASendTo(len:%u, %s/%u) ")
                _T("failed: %u (0x%X)"), 
                _fname, pRtpAddr, pWSABuf->len,
                RtpNtoA(saddr.sin_addr.s_addr, sAddr),
                (DWORD)(ntohs(saddr.sin_port)),
                dwError, dwError
            ));
        
        RtpPostEvent(pRtpAddr,
                     NULL,
                     RTPEVENTKIND_RTP,
                     dwEvent,
                     RTCP_IDX,
                     dwError);
        
        dwError = RTPERR_WS2SEND;
    }
    else
    {
        RtpUpdateNetCount(&pRtpAddr->RtpAddrCount[SEND_IDX],
                          NULL,
                          RTCP_IDX,
                          dwNumBytesSent,
                          NO_FLAGS,
                          dTime);
    }

 end:
    return(dwError);
}

DWORD RtcpFillXRReport(RtpAddr_t *pRtpAddr, char *pBuffer, DWORD len)
{
    DWORD          len2;
    DWORD          used;
    RtcpCommon_t  *pRtcpCommon;
    long           lCount;
    BYTE           bPT;
    
    TraceFunctionName("RtcpFillXRReport");

    /* Decide if SR or RR */
    bPT = pRtpAddr->RtpNetSState.bWeSent ? RTCP_SR : RTCP_RR;
    
    /* Fill up RTCP common header later */
    pRtcpCommon = (RtcpCommon_t *)pBuffer;
    
    pBuffer += sizeof(RtcpCommon_t);
    len -= sizeof(RtcpCommon_t);

    /* Set SSRC */
    *(DWORD *)pBuffer = pRtpAddr->RtpNetSState.dwSendSSRC;
    pBuffer += sizeof(DWORD);
    len -= sizeof(DWORD);

    /* Add sender info (if applicable) */
    if (bPT == RTCP_SR)
    {
        used = RtcpFillSInfo(pRtpAddr, pBuffer, len);
        pBuffer += used;
        len -= used;
    }

    /* Add report blocks */

    /* TODO when there is a large number of sender, send report blocks
     * for them in several packets (actually an open issue if I send a
     * burts of those packets, or schedule who is reported on which
     * packet) */
    used = RtcpFillReportBlocks(pRtpAddr, pBuffer, len, &lCount);
    pBuffer += used;
    len -= used;

    /* Add bandwidth estimation if available */
    used = RtcpFillPEBand(pRtpAddr, pBuffer, len);
    pBuffer += used;

    len = (DWORD) (pBuffer - (char *)pRtcpCommon);

    /* Finish initialization of first packet in the compound RTCP packet */
    RtcpFillCommon(pRtcpCommon, lCount, 0, bPT, len);

    TraceDebugAdvanced((
            0, GROUP_RTCP, S_RTCP_RRSR,
            _T("%s: pRtpAddr[0x%p] CC:%d RTCP %s packet prepared"),
            _fname, pRtpAddr, lCount, (bPT == RTCP_SR)? _T("SR") : _T("RR")
        ));
   
    return(len);
}

DWORD RtcpFillProbe(RtpAddr_t *pRtpAddr, char *pBuffer, DWORD len)
{
    DWORD          used;
    RtcpCommon_t  *pRtcpCommon;
    
    TraceFunctionName("RtcpFillProbe");

    /* Fill up RTCP common header later */
    pRtcpCommon = (RtcpCommon_t *)pBuffer;
    
    pBuffer += sizeof(RtcpCommon_t);
    len -= sizeof(RtcpCommon_t);
    
    /* Set SSRC */
    *(DWORD *)pBuffer = pRtpAddr->RtpNetSState.dwSendSSRC;
    pBuffer += sizeof(DWORD);
    len -= sizeof(DWORD);

    /* Add sender info */
    used = RtcpFillSInfo(pRtpAddr, pBuffer, len);
    pBuffer += used;

    len = (DWORD) (pBuffer - (char *)pRtcpCommon);

    /* Finish initialization of the only packet in the RTCP SR probe
     * packet */
    RtcpFillCommon(pRtcpCommon, 0, 0, RTCP_SR, len);

    TraceDebugAdvanced((
            0, GROUP_RTCP, S_RTCP_RRSR,
            _T("%s: pRtpAddr[0x%p] RTCP SR probe packet prepared"),
            _fname, pRtpAddr
        ));
   
    return(len);
}

void RtcpFillCommon(
        RtcpCommon_t *pRtcpCommon,
        long          lCount,
        DWORD         dwPad,
        BYTE          bPT,
        DWORD         dwLen
    )
{
    pRtcpCommon->count = (BYTE)lCount;
    pRtcpCommon->p = (BYTE)(dwPad & 1);
    pRtcpCommon->version = RTP_VERSION;
    pRtcpCommon->pt = bPT;
    dwLen = (dwLen >> 2) - 1;
    pRtcpCommon->length = htons((WORD)dwLen);
}

DWORD RtcpFillSInfo(RtpAddr_t *pRtpAddr, char *pBuffer, DWORD len)
{
    DWORD            used;
    RtcpSInfo_t     *pRtcpSInfo;
    RtpNetCount_t   *pRtpNetCount;
    RtpNetSState_t  *pRtpNetSState;
    double           dTime;
    double           TimeLastRtpSent;
    DWORD            dwSendTimeStamp;
    DWORD            dwSamplingFreq;

    TraceFunctionName("RtcpFillSInfo");

    pRtpNetCount  = &pRtpAddr->RtpAddrCount[SEND_IDX];
    pRtpNetSState = &pRtpAddr->RtpNetSState;
    
    used = 0;
    
    if (pRtpNetCount && len >= sizeof(RtcpSInfo_t)) {
        /* Insert Sender Info */

        pRtcpSInfo = (RtcpSInfo_t *)pBuffer;

        /* Obtain latest NTP/timestamp pair */
        if (RtpEnterCriticalSection(&pRtpAddr->NetSCritSect))
        {
            dTime = RtpGetTimeOfDay((RtpTime_t *)NULL);

            dwSendTimeStamp = pRtpNetSState->dwSendTimeStamp;
            
            TimeLastRtpSent = pRtpNetSState->dTimeLastRtpSent;
            
            dwSamplingFreq = pRtpNetSState->dwSendSamplingFreq;
            /*
             * We can now early release the critical section
             * */
            RtpLeaveCriticalSection(&pRtpAddr->NetSCritSect);

            /* pRtpNetSState->dTimeLastRtpSent and
             * pRtpNetSState->dwSendTimeStamp are updated in UpdateRtpHdr()
             * */

            /* NOTE
             *
             * The time the last RTP packet was sent may not
             * correspond to the current time, so, in order to the SR
             * to contain the current time, and the timestamp to match
             * that time, the timestamp is computed rather than taken
             * from the last RTP packet sent */

            pRtcpSInfo->ntp_sec = (DWORD)dTime;
        
            pRtcpSInfo->ntp_frac = (DWORD)
                ( (dTime - (double) pRtcpSInfo->ntp_sec) * 4294967296.0 );

            /* NOTE This assumes (as expected) that dTime >=
             * TimeLastRtpSent */
            pRtcpSInfo->rtp_ts =
                dwSendTimeStamp + (DWORD)
                (((dTime - TimeLastRtpSent) * (double)dwSamplingFreq) + 5e-9);

            TraceRetailAdvanced((
                    0, GROUP_RTCP, S_RTCP_NTP,
                    _T("%s: pRtpAddr[0x%p] NTP:%0.3f/%u ntp:%04X:%04X ")
                    _T("ts:%u (+%u) elapsed:%0.3fs"),
                    _fname, pRtpAddr, dTime, pRtcpSInfo->rtp_ts,
                    pRtcpSInfo->ntp_sec & 0xffff,
                    pRtcpSInfo->ntp_frac >> 16,
                    dwSendTimeStamp, pRtcpSInfo->rtp_ts-dwSendTimeStamp,
                    dTime - TimeLastRtpSent
                ));
            
            pRtcpSInfo->ntp_sec = htonl(pRtcpSInfo->ntp_sec);

            pRtcpSInfo->ntp_frac = htonl(pRtcpSInfo->ntp_frac);
        
            pRtcpSInfo->rtp_ts = htonl(pRtcpSInfo->rtp_ts);
            
            pRtcpSInfo->psent = htonl(pRtpNetCount->dwRTPPackets);
                                     
            pRtcpSInfo->bsent = htonl(pRtpNetCount->dwRTPBytes);

        }
        else
        {
            ZeroMemory(pBuffer, sizeof(RtcpSInfo_t));
        }

        used = sizeof(RtcpSInfo_t);
    }
    
    return(used);
}

/* Include (somehow) all the participants that have sent since the
 * last RTCP report we sent */
DWORD RtcpFillReportBlocks(
        RtpAddr_t       *pRtpAddr,
        char            *pBuffer,
        DWORD            len,
        long             *plCount
    )
{
    BOOL             bOk;
    DWORD            used;
    long             lCount;
    long             lMax;
    RtpQueue_t       ToReportQ;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpUser_t       *pRtpUser;

    TraceFunctionName("RtcpFillReportBlocks");

    used = 0;
    *plCount = 0;

    /* Determine what is the maximum number of report blocks we can
     * include */
    lMax = len / sizeof(RtcpRBlock_t);

    if (lMax > MAX_RTCP_RBLOCKS)
    {
        lMax = MAX_RTCP_RBLOCKS;
    }
    else if (!lMax)
    {
        /* We don't have room for any RB */
        return(used);
    }
    
    ZeroMemory((char *)&ToReportQ, sizeof(RtpQueue_t));
    
    bOk = RtpEnterCriticalSection(&pRtpAddr->PartCritSect);

    if (bOk)
    {
        lCount =
            GetQueueSize(&pRtpAddr->Cache1Q) +
            GetQueueSize(&pRtpAddr->Cache2Q);

        if (lCount <= lMax)
        {
            /* We can report all the senders */

            /* Add to report list participants in Cache1Q */
            lCount = GetQueueSize(&pRtpAddr->Cache1Q);
            pRtpQueueItem = pRtpAddr->Cache1Q.pFirst;
            
            for(; lCount > 0; lCount--)
            {
                pRtpUser =
                    CONTAINING_RECORD(pRtpQueueItem, RtpUser_t, UserQItem);

                enqueuel(&ToReportQ, NULL, &pRtpUser->ReportQItem);
                
                pRtpQueueItem = pRtpQueueItem->pNext;
            }
            
            /* Add to report list participants in Cache2Q */
            lCount = GetQueueSize(&pRtpAddr->Cache2Q);
            pRtpQueueItem = pRtpAddr->Cache2Q.pFirst;
            
            for(; lCount > 0; lCount--)
            {
                pRtpUser =
                    CONTAINING_RECORD(pRtpQueueItem, RtpUser_t, UserQItem);

                enqueuel(&ToReportQ, NULL, &pRtpUser->ReportQItem);
                
                pRtpQueueItem = pRtpQueueItem->pNext;
            }
        }
        else
        {
            /* We need to select a random subset of all the senders to
             * be included in the report rather than sending multiple
             * RTCP packets to report every body */

            /* TODO right now don't send any report, the mechanism
             * used to select the senders reported is independent of
             * the use of a sampling algorithm. */

            /* A possibility to guide the choice is to report only
             * those senders that are of interest to the user,
             * e.g. those that are mapped in a DShow graph */

            TraceRetail((
                    CLASS_WARNING, GROUP_RTCP, S_RTCP_RRSR,
                    _T("%s: pRtpAddr[0x%p] Too many RBlocks:%d ")
                    _T("not reporting them"),
                    _fname, pRtpAddr, lCount
                ));
        }

        RtpLeaveCriticalSection(&pRtpAddr->PartCritSect);

        /* Add the report blocks to the packet */
        lCount = GetQueueSize(&ToReportQ);

        if (!lCount)
        {
            TraceRetail((
                    CLASS_WARNING, GROUP_RTCP, S_RTCP_RRSR,
                    _T("%s: pRtpAddr[0x%p] No RBlocks added"),
                    _fname, pRtpAddr
                ));
        }
        else
        {
            while(lCount > 0)
            {
                pRtpQueueItem = dequeuef(&ToReportQ, NULL);

                pRtpUser =
                    CONTAINING_RECORD(pRtpQueueItem, RtpUser_t, ReportQItem);
            
                len = RtcpFillRBlock(pRtpAddr, pRtpUser, pBuffer);

                used += len;
                pBuffer += len;

                lCount--;
            }
        }

        *plCount = (used / sizeof(RtcpRBlock_t));
    }
        
    return(used);
}

/* Fills a single report block */
DWORD RtcpFillRBlock(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        char            *pBuffer
    )
{
    BOOL             bOk;
    DWORD            used;
    DWORD            extended_max;
    int              lost;
    DWORD            expected;
    DWORD            expected_interval;
    DWORD            received_interval;
    int              lost_interval;
    int              lost_rate;
    DWORD            red_expected_interval;
    DWORD            red_received_interval;
    int              red_lost_interval;
    int              red_lost_rate;
    DWORD            fraction;
    DWORD            dwSecs;
    double           dLSR;
    double           dDLSR;
    double           dCurrentTime;
    RtcpRBlock_t    *pRtcpRBlock;
    RtpNetRState_t  *pRtpNetRState;

    TraceFunctionName("RtcpFillRBlock");

    pRtcpRBlock = (RtcpRBlock_t *)pBuffer;
    
    pRtpNetRState = &pRtpUser->RtpNetRState;

    used = 0;
    
    bOk = RtpEnterCriticalSection(&pRtpUser->UserCritSect);

    if (bOk)
    {
        /* Check if we have received since last report sent */
        if (pRtpUser->RtpUserCount.dRTPLastTime <
            pRtpAddr->RtpAddrCount[SEND_IDX].dRTCPLastTime)
        {
            /* We haven't received RTP packets recently so don't
             * report this sender */
            RtpLeaveCriticalSection(&pRtpUser->UserCritSect);

            TraceDebugAdvanced((
                    0, GROUP_RTCP, S_RTCP_RRSR,
                    _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                    _T("Not including this RBlock, ")
                    _T("RTP(%0.3f) < RTCP(%0.3f)"),
                    _fname, pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC),
                    pRtpUser->RtpUserCount.dRTPLastTime,
                    pRtpAddr->RtpAddrCount[SEND_IDX].dRTCPLastTime
                ));
            
            return(used);
        }

        /* SSRC kept in NETWORK order */
        pRtcpRBlock->ssrc = pRtpUser->dwSSRC;

        /*
         * Cumulative losses
         * */
        extended_max = pRtpNetRState->cycles + pRtpNetRState->max_seq;

        /* expected is always positive as extended_max keeps growing
         * but base_seq ramains the same */
        expected = extended_max - pRtpNetRState->base_seq + 1;

        /* lost can be negative if we have duplicates */
        lost = expected - pRtpNetRState->received;

        /* NOTE in draft-ietf-avt-rtp-new-05 it says "clamp at
         * 0x7fffff for positive loss or 0xffffff for negative loss"
         * which seems to imply the representaion for negative numbers
         * is not 2s complemet on which the biggest negative number
         * would be 0x800000, below I'm using the biggest negative
         * number represented on any computer (i.e. using 2s
         * complement) */

        /* clamp to a 24bits signed number */
        if (lost > 8388607)
        {
            lost = 8388607;
        }
        else if (lost < -8388608)
        {
            lost = -8388608;
        }

        /* >>>> Test lost */
        /* lost = -5717; */
        
        /*
         * Fraction lost
         * */
        /* expected_interval must always be positive as expected is,
         * also, expected is always >= expected_prior */
        expected_interval = expected - pRtpNetRState->expected_prior;
        
        pRtpNetRState->expected_prior = expected;

        /* received_interval is always positive, it can only grow,
         * i.e. received >= received_prior */
        received_interval =
            pRtpNetRState->received - pRtpNetRState->received_prior;
        
        pRtpNetRState->received_prior = pRtpNetRState->received;
        
        lost_interval = expected_interval - received_interval;
        
        if (expected_interval == 0 || lost_interval <= 0)
        {
            fraction = 0;
            lost_rate = 0;
        }
        else
        {
            fraction = (lost_interval << 8) / expected_interval;
            lost_rate =
                (lost_interval * 100 * LOSS_RATE_FACTOR) / expected_interval;
        }

        pRtpNetRState->iAvgLossRateR =
            RtpUpdateLossRate(pRtpNetRState->iAvgLossRateR, lost_rate);
        
        /* Compute the fraction lost after packet reconstruction
         * (using redundancy) */
        expected = pRtpNetRState->red_max_seq - pRtpNetRState->base_seq + 1;

        red_expected_interval = expected - pRtpNetRState->red_expected_prior;
        
        pRtpNetRState->red_expected_prior = expected;
        
        red_received_interval =
            pRtpNetRState->red_received - pRtpNetRState->red_received_prior;

        pRtpNetRState->red_received_prior = pRtpNetRState->red_received;
        
        red_lost_interval = red_expected_interval - red_received_interval;

        if (red_expected_interval == 0 || red_lost_interval <= 0)
        {
            red_lost_rate = 0;
        }
        else
        {
            red_lost_rate =
                (red_lost_interval * 100 * LOSS_RATE_FACTOR) /
                red_expected_interval;
        }

        pRtpNetRState->iRedAvgLossRateR =
            RtpUpdateLossRate(pRtpNetRState->iRedAvgLossRateR, red_lost_rate);

        TraceRetailAdvanced((
                0, GROUP_RTCP, S_RTCP_LOSSES,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                _T("reporting recv loss rate:%5.2f%%/%0.2f%% ")
                _T("avg:%5.2f%%/%0.2f%% jitter:%0.3fs"),
                _fname, pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC),
                (double)lost_rate / LOSS_RATE_FACTOR,
                (double)red_lost_rate / LOSS_RATE_FACTOR,
                (double)pRtpNetRState->iAvgLossRateR / LOSS_RATE_FACTOR,
                (double)pRtpNetRState->iRedAvgLossRateR / LOSS_RATE_FACTOR,
                (double)pRtpNetRState->jitter/pRtpNetRState->dwRecvSamplingFreq
            ));

        /* Post loss rate as an event */
        RtpPostEvent(pRtpAddr,
                     pRtpUser,
                     RTPEVENTKIND_RTP,
                     RTPRTP_RECV_LOSSRATE,
                     pRtpUser->dwSSRC,
                     pRtpNetRState->iRedAvgLossRateR);
        
        /* >>>> Test fraction */
        /* fraction = (17 * 256) / 100; */
        
        /* Compose DWORD containing fraction lost (8) and cumulative
         * lost (24) */
        pRtcpRBlock->frac_cumlost =
            ((fraction & 0xff) << 24) | (lost & 0xffffff);

        /* Extended last sequence number received */
        pRtcpRBlock->last_seq = extended_max;

        /* Interarrival jitter */
        pRtcpRBlock->jitter = pRtpNetRState->jitter;

        /*
         * We can now early release the critical section
         */
        RtpLeaveCriticalSection(&pRtpUser->UserCritSect);

        if (RtpBitTest(pRtpUser->dwUserFlags, FGUSER_SR_RECEIVED))
        {
            /* Set values for LSR and DLSR only if we have already
             * received a SR */

            /* Time from last SR */
            pRtcpRBlock->lsr =
                (pRtpNetRState->NTP_sr_rtt.dwSecs & 0xffff) << 16;

            pRtcpRBlock->lsr |= (DWORD)
                ( ( ((double)pRtpNetRState->NTP_sr_rtt.dwUSecs / 1000000.0) *
                    65536.0 ) + 5e-9);

            dLSR = (double)pRtpNetRState->NTP_sr_rtt.dwSecs +
                (double)pRtpNetRState->NTP_sr_rtt.dwUSecs / 1000000.0;

            /* Delay since last SR was received */
            dCurrentTime = RtpGetTimeOfDay((RtpTime_t *)NULL);
        
            dDLSR =
                dCurrentTime -
                (double)pRtpNetRState->TimeLastSRRecv.dwSecs -
                (double)pRtpNetRState->TimeLastSRRecv.dwUSecs / 1000000.0;

            dwSecs = (DWORD)dDLSR;
            
            pRtcpRBlock->dlsr = (dwSecs & 0xffff) << 16;

            pRtcpRBlock->dlsr |= (DWORD)
                ( ( (dDLSR - (double)dwSecs) * 65536.0 ) + 5e-9);
        }
        else
        {
            dLSR = 0.0;
            
            dDLSR = 0.0;
            
            pRtcpRBlock->lsr = 0;
            
            pRtcpRBlock->dlsr = 0;
        }

        TraceRetailAdvanced((
                0, GROUP_RTCP, S_RTCP_RRSR,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                _T("LSR:%0.3f DLSR:%0.3f"),
                _fname, pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC),
                dLSR, dDLSR
            ));
  
        /* Put in NETWORK order */
        pRtcpRBlock->frac_cumlost = htonl(pRtcpRBlock->frac_cumlost);

        pRtcpRBlock->last_seq = htonl(extended_max);

        pRtcpRBlock->jitter = htonl(pRtcpRBlock->jitter);
        
        pRtcpRBlock->lsr = htonl(pRtcpRBlock->lsr);
        
        pRtcpRBlock->dlsr = htonl(pRtcpRBlock->dlsr);

        used = sizeof(RtcpRBlock_t);
    }
    
    return(used);
}

DWORD RtcpFillSdesInfo(RtpAddr_t *pRtpAddr, char *pBuffer, DWORD len)
{
    DWORD            used;
    DWORD            len2;
    DWORD            dwItemsToSend;
    DWORD            dwItem;
    DWORD            pad;
    RtcpCommon_t    *pRtcpCommon;
    RtpSdes_t       *pRtpSdes;
    RtpNetCount_t   *pRtpNetCount;

    used = 0;

    pRtpSdes = pRtpAddr->pRtpSess->pRtpSdes;
    
    if (pRtpSdes)
    {
        pRtcpCommon = (RtcpCommon_t *)pBuffer;

        /* TODO find out if the len passed is enough for first SDES item
         * (CNAME), second, third */
        pBuffer += sizeof(RtcpCommon_t);
        len -= sizeof(RtcpCommon_t);

        *(DWORD *)pBuffer = pRtpAddr->RtpNetSState.dwSendSSRC;
        pBuffer += sizeof(DWORD);
        len -= sizeof(DWORD);

        /* Schedule items to send */
        dwItemsToSend = ScheduleSdes(pRtpAddr->pRtpSess);

        for(dwItem = RTCP_SDES_CNAME, len2 = 0;
            dwItem < RTCP_SDES_LAST;
            dwItem++) {

            if (RtpBitTest(dwItemsToSend, dwItem)) {

                used = RtcpFillSdesItem(pRtpSdes, pBuffer, len, dwItem);

                if (!used) {
                    /* buffer not enough big */
                    break;
                }
                
                pBuffer += used;
                len2 += used;
                len -= used;
            }
        }

        if (len2 > 0) {

            pad = (DWORD) ((DWORD_PTR)pBuffer & 0x3);
            
            /* insert 1 or more END items to pad to a 32 bits boundary
             *
             * Note that this padding is separate from that indicated
             * by the P bit in the RTCP header */
            pad = 4 - pad;

            ZeroMemory(pBuffer, pad);
            pBuffer += pad;
            
            /* total size */
            used = (DWORD) (pBuffer - (char *)pRtcpCommon);

            /* Finish initialization of SDES header */
            RtcpFillCommon(pRtcpCommon, 1, 0, RTCP_SDES, used);
 
        } else {
            used = 0;
        }
    }
    
    return(used);
}

DWORD RtcpFillSdesItem(
        RtpSdes_t       *pRtpSdes,
        char            *pBuffer,
        DWORD            len,
        DWORD            dwItem
    )
{
    DWORD            used;
    DWORD            dwItemLen;
    RtcpSdesItem_t  *pRtcpSdesItem;

    used = 0;
    dwItemLen = pRtpSdes->RtpSdesItem[dwItem].dwDataLen;
    
    if (dwItemLen > 0 && (dwItemLen + sizeof(RtcpSdesItem_t)) <= len ) {

        pRtcpSdesItem = (RtcpSdesItem_t *)pBuffer;
        pBuffer += sizeof(RtcpSdesItem_t);
        len -= sizeof(RtcpSdesItem_t);
        
        CopyMemory(pBuffer,
                   pRtpSdes->RtpSdesItem[dwItem].pBuffer,
                   pRtpSdes->RtpSdesItem[dwItem].dwDataLen);

        pBuffer += pRtpSdes->RtpSdesItem[dwItem].dwDataLen;

        pRtcpSdesItem->type = (BYTE)dwItem;
        pRtcpSdesItem->length = (BYTE)pRtpSdes->RtpSdesItem[dwItem].dwDataLen;
        
        used = (DWORD) (pBuffer - (char *)pRtcpSdesItem);
    }

    return(used);
}

/* TODO, should be able to set a user defined reason */
DWORD RtcpFillBye(RtpAddr_t *pRtpAddr, char *pBuffer, DWORD len)
{
    DWORD            pad;
    DWORD            slen;
    RtcpCommon_t    *pRtcpCommon;
    RtpSdes_t       *pRtpSdes;

    pRtcpCommon = (RtcpCommon_t *)pBuffer;

    pBuffer += sizeof(RtcpCommon_t);
    len -= sizeof(RtcpCommon_t);

    /* Set SSRC */
    *(DWORD *)pBuffer = pRtpAddr->RtpNetSState.dwSendSSRC;
    pBuffer += sizeof(DWORD);
    len -= sizeof(DWORD);

    /* Set reason (if available) */
    if (RtpBitTest(pRtpAddr->pRtpSess->dwSdesPresent, RTCP_SDES_BYE))
    {
        pRtpSdes = pRtpAddr->pRtpSess->pRtpSdes;
        
        slen = pRtpSdes->RtpSdesItem[RTCP_SDES_BYE].dwDataLen;

        if (len < (slen + 1))
        {
            /* If buffer is not enough big, truncate the bye reason */
            slen = ((len - 1)/sizeof(TCHAR_t)) * sizeof(TCHAR_t);
        }
        
        *pBuffer = (char)slen;
        pBuffer++;
        len--;

        CopyMemory(pBuffer,
                   pRtpSdes->RtpSdesItem[RTCP_SDES_BYE].pBuffer, slen);
    
        pBuffer += slen;
    }

    pad = (DWORD) ((DWORD_PTR)pBuffer & 0x3);

    /* insert 1 or more  NULL chars to pad to a 32 bits boundary
     *
     * Note that this padding is separate from that indicated
     * by the P bit in the RTCP header */
    pad = 4 - pad;

    ZeroMemory(pBuffer, pad);
    pBuffer += pad;

    /* Get total packet's length */
    len = (DWORD) (pBuffer - (char *)pRtcpCommon);

    /* Finish initialization of SDES header */
    RtcpFillCommon(pRtcpCommon, 1, 0, RTCP_BYE, len);
    
    return(len);
}

DWORD RtcpFillPEBand(RtpAddr_t *pRtpAddr, char *pBuffer, DWORD len)
{
    BOOL             bOk;
    DWORD            used;
    DWORD            dwBin;
    double           dTime;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpUser_t       *pRtpUser;
    RtpNetRState_t  *pRtpNetRState;
    RtpBandEst_t    *pRtpBandEst;
    
    used = 0;

    if (len < sizeof(RtpBandEst_t))
    {
        return(used);
    }
    
    bOk = RtpEnterCriticalSection(&pRtpAddr->PartCritSect);
    
    if (bOk)
    {
        pRtpQueueItem = pRtpAddr->Cache1Q.pFirst;

        RtpLeaveCriticalSection(&pRtpAddr->PartCritSect);

        if (pRtpQueueItem)
        {
            pRtpUser =
                CONTAINING_RECORD(pRtpQueueItem, RtpUser_t, UserQItem);

            pRtpNetRState = &pRtpUser->RtpNetRState;

            dTime = RtpGetTimeOfDay(NULL);
            
            /* Determine if we have bandwidth estimation to report */
            if ( (dTime - pRtpNetRState->dLastTimeEstimation) <
                 g_dRtcpBandEstTTL )
            {
                used = sizeof(RtpBandEst_t);

                pRtpBandEst = (RtpBandEst_t *)pBuffer;

                pRtpBandEst->type = htons((WORD)RTPPE_BANDESTIMATION);
                pRtpBandEst->len = htons((WORD)used);

                /* Already NETWORK order */
                pRtpBandEst->dwSSRC = pRtpUser->dwSSRC;

                if (!RtpBitTest(pRtpNetRState->dwNetRStateFlags2,
                                FGNETRS2_BANDESTNOTREADY))
                {
                    if (!RtpBitTest(pRtpNetRState->dwNetRStateFlags2,
                                    FGNETRS2_BANDWIDTHUNDEF))
                    {
                        dwBin = pRtpNetRState->dwBestBin;
                        
                        pRtpBandEst->dwBandwidth = (DWORD)
                            (pRtpNetRState->dBinBandwidth[dwBin] /
                             pRtpNetRState->dwBinFrequency[dwBin]);

                        pRtpBandEst->dwBandwidth =
                            htonl(pRtpBandEst->dwBandwidth);
                    }
                    else
                    {
                        /* If last estimation was undefined, i.e. the gap
                         * between the 2 consecutive packets was 0 or
                         * negative, report RTP_BANDWIDTH_UNDEFINED as the
                         * estimated bandwidth */
                        pRtpBandEst->dwBandwidth =
                            htonl(RTP_BANDWIDTH_UNDEFINED);
                    }
                }
                else
                {
                    pRtpBandEst->dwBandwidth =
                        htonl(RTP_BANDWIDTH_BANDESTNOTREADY);
                }
            }
        }
    }

    return(used);
}

/*
 * The scheduler will send a CNAME on every report, then, every L1
 * reports will send a second SDES item.
 *
 * The second SDES item will be NAME, and every L2 reports, it will be
 * OTHER SDES item.
 *
 * The OTHER SDES item will be EMAIL, and every L3 reports, it will be
 * OTHER2 SDES item.
 *
 * The OTHER2 SDES item will be different on each time it is included,
 * and will start from PHONE to PRIV to go back to PHONE
 *
 * If all the SDES items are available and enabled to be sent, and the
 * reports are sent every 5 secs, all of the SDES items will be sent
 * in: 5secs * (5 * L3 * L2 * L1) = 400 secs ~= 7 min */
DWORD ScheduleSdes(RtpSess_t *pRtpSess)
{
    RtpSdesSched_t *pRtpSdesSched;
    DWORD           dwItemsToSend;
    DWORD           dwMask;

    dwItemsToSend = 0;
    pRtpSdesSched = &pRtpSess->RtpSdesSched;
    dwMask        = pRtpSess->dwSdesPresent & pRtpSess->dwSdesMask[LOCAL_IDX];

    /* CNAME */
    if (RtpBitTest(pRtpSess->dwSdesPresent, RTCP_SDES_CNAME)) {
        
        RtpBitSet(dwItemsToSend, RTCP_SDES_CNAME);
    }

    pRtpSdesSched->L1++;

    if ( !(pRtpSdesSched->L1 % SDES_MOD_L1)) {

        pRtpSdesSched->L2++;

        if ((pRtpSdesSched->L2 % SDES_MOD_L2) &&
            RtpBitTest(dwMask, RTCP_SDES_NAME)) {

            /* NAME */
            RtpBitSet(dwItemsToSend, RTCP_SDES_NAME);
            
        } else {

            pRtpSdesSched->L3++;

            if ((pRtpSdesSched->L3 % SDES_MOD_L3) &&
                RtpBitTest(dwMask, RTCP_SDES_EMAIL)) {

                /* EMAIL */
                RtpBitSet(dwItemsToSend, RTCP_SDES_EMAIL);
                
            } else {

                /* Others */
                if (RtpBitTest(dwMask, pRtpSdesSched->L4 + RTCP_SDES_PHONE)) {
                    RtpBitSet(dwItemsToSend,
                              pRtpSdesSched->L4 + RTCP_SDES_PHONE);
                }

                pRtpSdesSched->L4++;

                if (pRtpSdesSched->L4 >= (RTCP_SDES_LAST-RTCP_SDES_PHONE-1)) {
                    pRtpSdesSched->L4 = 0;
                }
            }
        }
    }

    return(dwItemsToSend);
}

/*
 * Creates and initialize a RtcpSendIO_t structure
 * */
RtcpSendIO_t *RtcpSendIOAlloc(RtcpAddrDesc_t *pRtcpAddrDesc)
{
    RtcpSendIO_t    *pRtcpSendIO;
    
    TraceFunctionName("RtcpSendIOAlloc");

    pRtcpSendIO = RtpHeapAlloc(g_pRtcpSendIOHeap, sizeof(RtcpSendIO_t));

    if (!pRtcpSendIO)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTCP, S_RTCP_ALLOC,
                _T("%s: pRtcpAddrDesc[0x%p] failed to allocate memory"),
                _fname, pRtcpAddrDesc
            ));

        goto bail;
    }

    pRtcpSendIO->dwObjectID = OBJECTID_RTCPSENDIO;

    pRtcpSendIO->pRtcpAddrDesc = pRtcpAddrDesc;
    
    return(pRtcpS