use HID
    // devices that declare themselves as HID_USAGE_GENERIC_MOUSE.)
    //
    BOOLEAN             UseOnlyMice;
    BOOLEAN             Reserved[1];

    //
    // Pointer to this driver's null-terminated registry path.
    //
    UNICODE_STRING      RegistryPath;

    //
    // Unit ID given to the keyboard class driver
    //
    ULONG               UnitId;

} GLOBALS;

extern GLOBALS Globals;

typedef struct _DEVICE_EXTENSION
{
    //
    // Pointer back to the this extension's device object.
    //
    PDEVICE_OBJECT      Self;

    //
    // The top of the stack before this filter was added.  AKA the location
    // to which all IRPS should be directed.
    //
    PDEVICE_OBJECT      TopOfStack;

    //
    // "THE PDO"  (ejected by Hidclass)
    //
    PDEVICE_OBJECT      PDO;

    //
    // Flag indicating permission to send callbacks to the mouse class driver.
    //
    LONG                EnableCount;

    //
    // Read interlock value to protect us from running out of stack space
    //
    ULONG               ReadInterlock;

    //
    // Has the device been taken out from under us?
    // Has it been started?
    //
    BOOLEAN             Started;
    BOOLEAN             ShuttingDown;
    BOOLEAN             Initialized;
    USHORT              UnitId;

    // Should the polarity of the wheel be backwards.
    BOOLEAN             FlipFlop;
    BOOLEAN             Reserved[3];
    ULONG               WheelScalingFactor;

    //
    // Write and Feature Irps get passed straight down, but read Irps do not.
    // For this reason we keep around a read Irp, which we created.
    //
    PIRP                 ReadIrp;

    //
    // Flags indicating problems with the mouse HID device (such as bad
    // absolute X-Y axes, bad physical minimum and maximum).
    //
    ULONG               ProblemFlags;

    //
    // A file pointer to be used for reading
    //
    PFILE_OBJECT        ReadFile;

    //
    // Event used to synchronize the completion of the read irp and the close irp
    //
    KEVENT              ReadCompleteEvent;

    //
    // Event used to indicate that a read irp has been sent and is now cancelable.
    //
    KEVENT              ReadSentEvent;

    //
    // A pointer to the HID extension.
    //
    struct _HID_EXTENSION * HidExtension;

    //
    // Pointer to the mouse class device object and callback routine
    // above us, Used as the first parameter and the  MouseClassCallback().
    // routine itself.
    //
    CONNECT_DATA        ConnectData;

    //
    // Remove Lock object to project IRP_MN_REMOVE_DEVICE
    //
    IO_REMOVE_LOCK    RemoveLock;

    //
    // A fast mutex to prevent Create from trouncing close, as one starts the
    // read loop and the other shuts it down.
    //
    FAST_MUTEX          CreateCloseMutex;

    //
    // An event to halt the deletion of a device until it is ready to go.
    //
    KEVENT              StartEvent;

    //
    // Buffer for a single mouse data packet so that we might hand it to
    // the mouse class driver.
    //
    MOUSE_INPUT_DATA     InputData;

    //
    // Buffer for the mouse attributes.
    //
    MOUSE_ATTRIBUTES     Attributes;
    USHORT               AttributesAllignmentProblem; // 

    //
    // An attachment point for the global list o devices
    //
    LIST_ENTRY          Link;

    //
    // WMI Information
    //
    WMILIB_CONTEXT         WmiLibInfo;

} DEVICE_EXTENSION, * PDEVICE_EXTENSION;

typedef struct _HID_EXTENSION {

    //
    // Indicates the bit size of each X,Y,Z usage value. This information is
    // used should the usage's physical minimum/maximum limits be invalid (a
    // common problem).
    //
    struct {
       USHORT X;
       USHORT Y;
       USHORT Z;
       USHORT Reserved;
    } BitSize;

    //
    // The maximum allowed values of X and Y.
    //
    LONG                 MaxX;
    LONG                 MaxY;

    //
    // Should this mouse be treated as an absolute device.
    //
    BOOLEAN              IsAbsolute;

    //
    // Flag indicating whether or not a wheel usage (Z axis) exists.
    //
    BOOLEAN              HasNoWheelUsage;

    //
    // Flag indicating whether or not a z axis exists on this mouse;
    //
    BOOLEAN              HasNoZUsage;
    BOOLEAN              Reserved;

    //
    // The maximum number of usages that can be returned from a single read
    // report.
    USHORT               MaxUsages;
    USHORT               Reserved2;

    //
    // The preparsed data associated with this hid device.
    //
    PHIDP_PREPARSED_DATA Ppd;

    //
    // The capabilities of this hid device
    //
    HIDP_CAPS           Caps;

    //
    // Pointers into the buffer at the end of this structure (dynamic size).
    //
    PCHAR               InputBuffer;
    PUSAGE              CurrentUsageList;
    PUSAGE              PreviousUsageList;
    PUSAGE              BreakUsageList;
    PUSAGE              MakeUsageList;

    //
    // MDLs describing the buffer at the end of this structure (dynamic size).
    //
    PMDL                InputMdl;

    //
    // Buffer of dynamic size, allocated at run-time.  It is used to hold one
    // input report and 4 x .MaxUsageList usages (4 = previous, current, make,
    // and break usages).
    //
    CHAR                Buffer[];
} HID_EXTENSION, * PHID_EXTENSION;

//
// Prototypes.
//
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
MouHid_AddDevice (
   IN PDRIVER_OBJECT    MouHidDriver, // The kbd Driver object.
   IN PDEVICE_OBJECT    PDO
   );

NTSTATUS
MouHid_Close (
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    );

NTSTATUS
MouHid_Create (
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    );

NTSTATUS
MouHid_CallHidClass(
    IN PDEVICE_EXTENSION    Data,
    IN ULONG          Ioctl,
    PVOID             InputBuffer,
    ULONG             InputBufferLength,
    PVOID             OutputBuffer,
    ULONG             OutputBufferLength
    );

VOID
MouHid_UpdateRegistryProblemFlags (
    IN PDEVICE_EXTENSION Data
    );

VOID
MouHid_UpdateRegistryProblemFlagsCallback (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_WORKITEM Item 
    );

VOID
MouHid_LogError(
   IN PDRIVER_OBJECT DriverObject,
   IN NTSTATUS       ErrorCode,
   IN PWSTR          ErrorInsertionString OPTIONAL
   );

NTSTATUS
MouHid_StartDevice (
    IN PDEVICE_EXTENSION    Data
    );

NTSTATUS
MouHid_StartRead (
    IN PDEVICE_EXTENSION    Data
    );

NTSTATUS
MouHid_PnP (
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    );

NTSTATUS
MouHid_Power (
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    );

NTSTATUS
MouHid_Power (
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    );

NTSTATUS
MouHid_PnPComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
MouHid_GetRegistryParameters ();

VOID
MouHid_Unload(
   IN PDRIVER_OBJECT Driver
   );

NTSTATUS
MouHid_IOCTL (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
MouHid_Flush (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
KbdHid_Power (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MouHid_PassThrough (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
);

NTSTATUS
MouHid_SystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
MouHid_SetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
MouHid_SetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
MouHid_QueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );

NTSTATUS
MouHid_QueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    );

extern WMIGUIDREGINFO MouHid_WmiGuidList[1];

#endif //_MOUHID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\hidport\mouhid\read.c ===
/*++

Copyright (c) 1997    Microsoft Corporation

Module Name:

    read.c

Abstract:

    This module contains the code for translating HID input reports to mouse
    reports, and read initiation and completion code for requests sent to the
    HID class driver.  This module is part of the HID Mouse Filter Driver.

Environment:

    Kernel mode only.

Revision History:

    Jan-1997 :  Initial writing, Dan Markarian

--*/

#include "mouhid.h"


//
// Private definitions.
//
#define MAX_MOUSE_BUTTONS 5

USHORT HidP_TranslateUsageToUpFlag[MAX_MOUSE_BUTTONS+1] = { 0,
                                         MOUSE_BUTTON_1_UP,
                                         MOUSE_BUTTON_2_UP,
                                         MOUSE_BUTTON_3_UP,
                                         MOUSE_BUTTON_4_UP,
                                         MOUSE_BUTTON_5_UP };

USHORT HidP_TranslateUsageToDownFlag[MAX_MOUSE_BUTTONS+1] = { 0,
                                         MOUSE_BUTTON_1_DOWN,
                                         MOUSE_BUTTON_2_DOWN,
                                         MOUSE_BUTTON_3_DOWN,
                                         MOUSE_BUTTON_4_DOWN,
                                         MOUSE_BUTTON_5_DOWN };

NTSTATUS
MouHid_ReadComplete (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PDEVICE_EXTENSION    Data  // (PVOID Context)
    )
/*++

Routine Description:

    This routine is the read IRP completion routine.  It is called when the
    HIDCLASS driver satisfies (or rejects) the IRP request we sent it.  The
    read report is analysed, and a MOUSE_INPUT_DATA structure is built
    and sent to the mouse class driver via a callback routine.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

    Context - Pointer to the device context structure describing the HID device.


Return Value:

    NTSTATUS result code.

--*/
{
    LONG            axisMotion;
    ULONG           i;
    ULONG           inputDataConsumed;
    PHID_EXTENSION  hid;
    ULONG           numUsages;
    KIRQL           oldIrql;
    BOOLEAN         returnToIdleState  = FALSE;
    NTSTATUS        status;
    PUSAGE          usageList;
    BOOLEAN         updateProblemFlags = FALSE;
    ULONGLONG       scratch;
    BOOLEAN         startRead;

    Print (DBG_READ_TRACE, ("ReadComplete: Enter."));

    //
    // Obtain the current status of the IRP.
    //
    status = Irp->IoStatus.Status;

    //
    // Get a pointer to the device extension.
    //
    hid = Data->HidExtension;

    //
    // If ReadInterlock is == START_READ, this func has been completed
    // synchronously.  Place IMMEDIATE_READ into the interlock to signify this
    // situation; this will notify StartRead to loop when IoCallDriver returns.
    // Otherwise, we have been completed async and it is safe to call StartRead()
    //
    startRead =
       (MOUHID_START_READ !=
        InterlockedCompareExchange(&Data->ReadInterlock,
                                   MOUHID_IMMEDIATE_READ,
                                   MOUHID_START_READ));

    if (Data->EnableCount == 0) {
        goto SetEventAndBreak;
    }

    //
    // Determine if the IRP request was successful.
    //
    switch (status) {
    case STATUS_SUCCESS:
        //
        // The buffer of the context now contains a single HID packet read
        // from the device.  Verify this.
        //
        ASSERT (Irp->IoStatus.Information == hid->Caps.InputReportByteLength);

        //
        // Clear previous button state (data / flags).
        //
        Data->InputData.ButtonData  = 0;
        Data->InputData.ButtonFlags = 0;

        //
        // Clear last X,Y motion, in case a call to Hidp_GetUsageValue or
        // Hidp_GetScaledUsageValue fails.
        //
        Data->InputData.LastX = 0;
        Data->InputData.LastY = 0;

        //
        // Obtain the current button usages.
        //
        numUsages = hid->MaxUsages;

        if (NT_SUCCESS(HidP_GetUsages (
                           HidP_Input,
                           HID_USAGE_PAGE_BUTTON,
                           0,          // link collection irrelevant
                           hid->CurrentUsageList,
                           &numUsages, // max usages in, num usages out
                           hid->Ppd,
                           hid->InputBuffer,
                           hid->Caps.InputReportByteLength))) {
            //
            // Determine the differences between the current and the previous
            // usages.  The very first previous usage list buffer is properly
            // initialized at creation (all zeros).
            //
            if (NT_SUCCESS(HidP_UsageListDifference (hid->PreviousUsageList,
                                                     hid->CurrentUsageList,
                                                     hid->BreakUsageList,
                                                     hid->MakeUsageList,
                                                     hid->MaxUsages))) {
                //
                // Determine which buttons went down and set the appropriate
                // flags in the mouse report.
                //
                usageList = hid->MakeUsageList;
                for ( i = 0;
                      i < hid->MaxUsages && *usageList;
                      i++, usageList++ ) {

                    if (*usageList <= MAX_MOUSE_BUTTONS) {
                        Data->InputData.ButtonFlags |=
                            HidP_TranslateUsageToDownFlag[*usageList];
                    }
                    //
                    // else there are more buttons on this mouse then we have
                    // translation flags for the Raw input user thread
                    //
                }

                //
                // Determine which buttons went up and set the appropriate
                // flags in the mouse report.
                //
                usageList = hid->BreakUsageList;
                for ( i = 0;
                      i < hid->MaxUsages && *usageList;
                      i++, usageList++ ) {

                    if (*usageList <= MAX_MOUSE_BUTTONS) {
                        Data->InputData.ButtonFlags |=
                                     HidP_TranslateUsageToUpFlag[*usageList];
                    }
                }

                //
                // Swap the previous usage list pointer with the current.
                //
                usageList = hid->PreviousUsageList;
                hid->PreviousUsageList = hid->CurrentUsageList;
                hid->CurrentUsageList  = usageList;
            }
        }

        //
        // Type of processing for X,Y,Z values depends on whether these values
        // have a bad physical minimum or maximum. If they do, we use routines
        // that do not depend on physical min/max.
        //

        //
        // Determine the current X position and save it in the mouse report.
        //
        if (!(Data->ProblemFlags & PROBLEM_BAD_PHYSICAL_MIN_MAX_X)) {
            status = HidP_GetScaledUsageValue(
                         HidP_Input,
                         HID_USAGE_PAGE_GENERIC,
                         0,
                         HID_USAGE_GENERIC_X,
                         &Data->InputData.LastX,
                         hid->Ppd,
                         hid->InputBuffer,
                         hid->Caps.InputReportByteLength);

            //
            // Bad physical minimum/maximum detected, set flag so that we
            // process usage value differently in the future.
            //
            if (status == HIDP_STATUS_BAD_LOG_PHY_VALUES) {
                Data->ProblemFlags |= PROBLEM_BAD_PHYSICAL_MIN_MAX_X;
                updateProblemFlags = TRUE;
                //
                // Correct the MaxX value;
                //
                hid->MaxX = (1 << (hid->BitSize.X - 1)) - 1;
            }
        }

        if (Data->ProblemFlags & PROBLEM_BAD_PHYSICAL_MIN_MAX_X) {

            axisMotion = 0;

            HidP_GetUsageValue(HidP_Input,
                               HID_USAGE_PAGE_GENERIC,
                               0,
                               HID_USAGE_GENERIC_X,
                               (PULONG) &axisMotion,
                               hid->Ppd,
                               hid->InputBuffer,
                               hid->Caps.InputReportByteLength);

            // Sign extend the value manually.
            Data->InputData.LastX
               = axisMotion | ((axisMotion & (hid->MaxX + 1)) ? (~hid->MaxX)
                                                              : 0);
        }

        if (hid->IsAbsolute) {
            //
            // We need to scale this value from the physical max
            //
            scratch = ((LONGLONG)(Data->InputData.LastX) *
                       MOUHID_RIUT_ABSOLUTE_POINTER_MAX) /
                       hid->MaxX;
            Data->InputData.LastX = (LONG) scratch;
        }

        //
        // Determine the current Y position and save it in the mouse report.
        //
        if (!(Data->ProblemFlags & PROBLEM_BAD_PHYSICAL_MIN_MAX_Y)) {
           status = HidP_GetScaledUsageValue(
                     HidP_Input,
                     HID_USAGE_PAGE_GENERIC,
                     0,
                     HID_USAGE_GENERIC_Y,
                     &Data->InputData.LastY,
                     hid->Ppd,
                     hid->InputBuffer,
                     hid->Caps.InputReportByteLength);
           //
           // Bad physical minimum/maximum detected, set flag so that we
           // process usage value differently in the future.
           //
           if (status == HIDP_STATUS_BAD_LOG_PHY_VALUES) {
               Data->ProblemFlags |= PROBLEM_BAD_PHYSICAL_MIN_MAX_Y;
               updateProblemFlags = TRUE;
               //
               // Correct the MaxY value;
               //
               hid->MaxY = (1 << (hid->BitSize.Y - 1)) - 1;
           }
        }

        if (Data->ProblemFlags & PROBLEM_BAD_PHYSICAL_MIN_MAX_Y) {

           axisMotion = 0;

           HidP_GetUsageValue(HidP_Input,
                              HID_USAGE_PAGE_GENERIC,
                              0,
                              HID_USAGE_GENERIC_Y,
                              &axisMotion,
                              hid->Ppd,
                              hid->InputBuffer,
                              hid->Caps.InputReportByteLength);

           // Sign extend the value manually.
           Data->InputData.LastY
              = axisMotion | ((axisMotion & (hid->MaxY + 1)) ? (~hid->MaxY)
                                                             :  0);
        }

        if (hid->IsAbsolute) {
            //
            // We need to scale this value from the physical max
            //
            scratch = ((LONGLONG)(Data->InputData.LastY) *
                       MOUHID_RIUT_ABSOLUTE_POINTER_MAX) /
                       hid->MaxY;

            Data->InputData.LastY = (LONG) scratch;
        }

        //
        // Determine the current Z position (wheel).
        //
        if (FALSE == hid->HasNoWheelUsage) {

            axisMotion = 0;

            if (!(Data->ProblemFlags & PROBLEM_BAD_PHYSICAL_MIN_MAX_Z)) {
               status = HidP_GetScaledUsageValue(
                         HidP_Input,
                         HID_USAGE_PAGE_GENERIC,
                         0,
                         HID_USAGE_GENERIC_WHEEL,
                         &axisMotion,
                         hid->Ppd,
                         hid->InputBuffer,
                         hid->Caps.InputReportByteLength);

               //
               // If wheel usage not detected, set flag so that we do not
               // process wheel usages in the future.
               //
               if (HIDP_STATUS_USAGE_NOT_FOUND == status) {
                   hid->HasNoWheelUsage = TRUE;
               }

               //
               // If bad physical minimum/maximum detected, set flag so that
               // we process usage value differently in the future.
               //
               if (status == HIDP_STATUS_BAD_LOG_PHY_VALUES) {
                   Data->ProblemFlags |= PROBLEM_BAD_PHYSICAL_MIN_MAX_Z;
                   updateProblemFlags = TRUE;
               }
            }

            if (Data->ProblemFlags & PROBLEM_BAD_PHYSICAL_MIN_MAX_Z) {
                HidP_GetUsageValue(HidP_Input,
                                   HID_USAGE_PAGE_GENERIC,
                                   0,
                                   HID_USAGE_GENERIC_WHEEL,
                                   &axisMotion,
                                   hid->Ppd,
                                   hid->InputBuffer,
                                   hid->Caps.InputReportByteLength);

                // Sign extend the value manually.
                axisMotion
                    = axisMotion
                    | (axisMotion & (1 << (hid->BitSize.Z - 1))
                       ? (0L - (1 << (hid->BitSize.Z - 1)))
                       : 0);
            }

            //
            // Encode the Z position information into the MOUSE_INPUT_DATA
            // structure same way that the Magellan wheel mouse does.
            //
            if (0 == axisMotion) {
                Data->InputData.ButtonData = 0;
            } else {

                //
                // Unlike PS/2 wheel mice, we don't need to sign flip the wheel
                // data (unless it is an early prototype non spec compliant
                // device)
                //
                axisMotion *= Data->WheelScalingFactor; 
                Data->InputData.ButtonData = Data->FlipFlop ? 
                    (USHORT) -axisMotion : (USHORT) axisMotion;
                Data->InputData.ButtonFlags |= MOUSE_WHEEL;
            }

        } else if (FALSE == hid->HasNoZUsage) {
            //
            // If there is no Wheel usage then there might be a "z" usage on
            // this mouse.  Check that.
            //

            axisMotion = 0;

            if (!(Data->ProblemFlags & PROBLEM_BAD_PHYSICAL_MIN_MAX_Z)) {
               status = HidP_GetScaledUsageValue(
                         HidP_Input,
                         HID_USAGE_PAGE_GENERIC,
                         0,
                         HID_USAGE_GENERIC_Z,
                         &axisMotion,
                         hid->Ppd,
                         hid->InputBuffer,
                         hid->Caps.InputReportByteLength);

               //
               // If wheel usage not detected, set flag so that we do not
               // process wheel usages in the future.
               //
               if (HIDP_STATUS_USAGE_NOT_FOUND == status) {
                   hid->HasNoZUsage = TRUE;
               }

               //
               // If bad physical minimum/maximum detected, set flag so that
               // we process usage value differently in the future.
               //
               if (status == HIDP_STATUS_BAD_LOG_PHY_VALUES) {
                   Data->ProblemFlags |= PROBLEM_BAD_PHYSICAL_MIN_MAX_Z;
                   updateProblemFlags = TRUE;
               }
            }

            if (Data->ProblemFlags & PROBLEM_BAD_PHYSICAL_MIN_MAX_Z) {
                HidP_GetUsageValue(HidP_Input,
                                   HID_USAGE_PAGE_GENERIC,
                                   0,
                                   HID_USAGE_GENERIC_Z,
                                   &axisMotion,
                                   hid->Ppd,
                                   hid->InputBuffer,
                                   hid->Caps.InputReportByteLength);

                // Sign extend the value manually.
                axisMotion
                    = axisMotion
                    | (axisMotion & (1 << (hid->BitSize.Z - 1))
                       ? (0L - (1 << (hid->BitSize.Z - 1)))
                       : 0);
            }

            //
            // Encode the Z position information into the MOUSE_INPUT_DATA
            // structure the same way that the Magellan wheel mouse does.
            //
            if (0 == axisMotion) {
                Data->InputData.ButtonData = 0;
            } else {

                //
                // Unlike PS/2 wheel mice, we don't need to sign flip the wheel
                // data (unless it is an early prototype non spec compliant
                // device)
                //
                axisMotion *= Data->WheelScalingFactor; 
                Data->InputData.ButtonData = Data->FlipFlop ? 
                    (USHORT) -axisMotion : (USHORT) axisMotion;
                Data->InputData.ButtonFlags |= MOUSE_WHEEL;
            }

        }

        //
        // Leave the remaining mouse input data fields as they were
        // initialized (on the device's creation).  This includes:
        //  o  UnitID       o  RawButtons
        //  o  Flags        o  ExtraInformation
        //
        // Now send the data up to the mouse class driver via our callback.
        //
        if (Data->EnableCount)
        {
            //
            // Synchronization issue -  it's not a big deal if .Enabled is set
            // FALSE after the condition above, but before the callback below,
            // so long as the .MouClassCallback field is not nulled.   This is
            // guaranteed since the disconnect IOCTL is not implemented yet.
            //
            // Mouse class callback assumes we are running at DISPATCH level,
            // however this IoCompletion routine can be running <= DISPATCH.
            // Raise the IRQL before calling the callback. [13.1]
            //
            KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);

            //
            // Call the callback.
            //
            (*(PSERVICE_CALLBACK_ROUTINE)
             Data->ConnectData.ClassService) (
                            Data->ConnectData.ClassDeviceObject,
                            &Data->InputData,
                            &Data->InputData + 1,  // (one data element)
                            &inputDataConsumed);

            //
            // Restore the previous IRQL right away.
            //
            KeLowerIrql(oldIrql);

            ASSERT (1 == inputDataConsumed);
        }

        //
        // Update ProblemFlags value in registry and log error on bad physical
        // minimum/maximum.
        //
        if (updateProblemFlags) {
            MouHid_UpdateRegistryProblemFlags (Data);

            MouHid_LogError(Data->Self->DriverObject,
                            MOUHID_INVALID_PHYSICAL_MIN_MAX,
                            NULL);
        }
        
        //
        // If MouHid_StartRead() fails,  it will be handled appropriately
        // in the completion routine.  Exit this routine without touching
        // HidDeviceContext.
        //

        break;

    case STATUS_PRIVILEGE_NOT_HELD:
        //
        // The create didn't succeed
        //
    case STATUS_CANCELLED:
        //
        // The read IRP was cancelled.  Do not send any more read IRPs.
        //

    case STATUS_DELETE_PENDING:
    case STATUS_DEVICE_NOT_CONNECTED:
        //
        // The HID class device object is being deleted.  We will soon
        // receive Plug 'n Play notification of this device's removal,
        // if we have not received it already.
        //
SetEventAndBreak:
        KeSetEvent (&Data->ReadCompleteEvent, 0, FALSE);
        IoReleaseRemoveLock (&Data->RemoveLock, Data->ReadIrp);
        startRead = FALSE;
        break;

    default:
        //
        // We don't expect any other error codes.
        //
        TRAP();

    }

    //
    // Initiate the next read request to the HID class driver.
    //
    if (startRead) {
        Print(DBG_READ_TRACE, ("calling StartRead directly\n"));
        MouHid_StartRead (Data);
    } else {
        Print(DBG_READ_TRACE, ("StartRead will loop\n"));
    }
    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
MouHid_StartRead (
    IN PDEVICE_EXTENSION Data
    )
/*++

Routine Description:

    Initiates a read to the HID class driver.

    Note that the routine does not verify that the device context is in the
    OperationPending state, but simply assumes it.

    Note the IoCount must be incremented before entering into this read loop.
    
Arguments:

    HidDeviceContext - Device context structure describing the HID device.

Return Value:

    NTSTATUS result code from IoCallDriver().

--*/
{
    PIRP                irp;
    NTSTATUS           status = STATUS_SUCCESS;
    PIO_STACK_LOCATION  stack;
    PHID_EXTENSION      hid;
    LONG                oldInterlock;

    Print (DBG_READ_TRACE, ("Start Read: Ente\n"));

    hid = Data->HidExtension;

    //
    // start this read.
    //

    irp = Data->ReadIrp;

    while (1) {
        oldInterlock = InterlockedExchange(&Data->ReadInterlock,
                                           MOUHID_START_READ);
    
        //
        // END_READ should be the only value here!!!  If not, the state machine
        // of the interlock has been broken
        //
        ASSERT(oldInterlock == MOUHID_END_READ);
    
        //
        // Set the stack location for the Hid stack.
        // Remember to get the file pointer correct.
        // NOTE: we do not have any of the cool thread stuff set.
        //       therefore we need to make sure that we cut this IRP off
        //       at the knees when it returns. (STATUS_MORE_PROCESSING_REQUIRED)
        //
        // Note also that Hid class does direct IO.
        //
    
        IoReuseIrp (irp, STATUS_SUCCESS);
    
        irp->MdlAddress = hid->InputMdl;
    
        ASSERT (NULL != Data->ReadFile);
    
        stack = IoGetNextIrpStackLocation (irp);
        stack->Parameters.Read.Length = hid->Caps.InputReportByteLength;
        stack->Parameters.Read.Key = 0;
        stack->Parameters.Read.ByteOffset.QuadPart = 0;
        stack->MajorFunction = IRP_MJ_READ;
        stack->FileObject = Data->ReadFile;
        
        //
        // Hook a completion routine for when the device completes.
        //
        IoSetCompletionRoutine (irp,
                                MouHid_ReadComplete,
                                Data,
                                TRUE,
                                TRUE,
                                TRUE);
        
        //
        // Unset the fact that the read has been sent. Synchoronizing 
        // with remove and close code. Remove portion (data->Shuttingdown) 
        // only really relevant on 9X.
        //
        KeResetEvent(&Data->ReadSentEvent);
    
        if (!Data->EnableCount || Data->ShuttingDown) {
            IoReleaseRemoveLock (&Data->RemoveLock, Data->ReadIrp);
            status = Data->ShuttingDown ? STATUS_DELETE_PENDING : STATUS_UNSUCCESSFUL;
            KeSetEvent (&Data->ReadSentEvent, 0, FALSE);
            break;
        } else {
            status = IoCallDriver (Data->TopOfStack, irp);
        }
        KeSetEvent (&Data->ReadSentEvent, 0, FALSE);

        if (MOUHID_IMMEDIATE_READ != InterlockedExchange(&Data->ReadInterlock,
                                                         MOUHID_END_READ)) {
            //
            // The read is asynch, will call SerialMouseStartRead from the
            // completion routine
            //
            Print(DBG_READ_TRACE, ("read is pending\n"));
            break;
        } else {
            //
            // The read was synchronous (probably bytes in the buffer).  The
            // completion routine will not call SerialMouseStartRead, so we 
            // just loop here.  This is to prevent us from running out of stack
            // space if always call StartRead from the completion routine
            //
            Print(DBG_READ_TRACE, ("read is looping\n"));
        }
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\hidport\mouhid\pnp.c ===
/*++

Copyright (c) 1997    Microsoft Corporation

Module Name:

    pnp.c

Abstract:

    This module contains plug & play code for the HID Mouse Filter Driver,
    including code for the creation and removal of HID mouse device contexts.

Environment:

    Kernel & user mode.

Revision History:

    Jan-1997 :  Initial writing, Dan Markarian

--*/

//
// For this module only we set the INITGUID macro before including wdm.h and
// hidclass.h.   This not only declares the GUIDs but also initializes them.
//

#include "mouhid.h"
#include "hidclass.h"
#include <initguid.h>
#include <wdmguid.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,MouHid_CallHidClass)
#pragma alloc_text(PAGE,MouHid_AddDevice)
#pragma alloc_text(PAGE,MouHid_StartDevice)
#pragma alloc_text(PAGE,MouHid_PnP)
#endif

NTSTATUS
MouHid_CallHidClass(
    IN     PDEVICE_EXTENSION    Data,
    IN     ULONG        Ioctl,
    IN     PVOID        InputBuffer,
    IN     ULONG        InputBufferLength,
    IN OUT PVOID        OutputBuffer,
    IN     ULONG        OutputBufferLength
    )
/*++

Routine Description:

   Make a *synchronous* request of the HID class driver

Arguments:

    Ioctl              - Value of the IOCTL request.

    InputBuffer        - Buffer to be sent to the HID class driver.

    InputBufferLength  - Size of buffer to be sent to the HID class driver.

    OutputBuffer       - Buffer for received data from the HID class driver.

    OutputBufferLength - Size of receive buffer from the HID class.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    KEVENT             event;
    IO_STATUS_BLOCK    ioStatus;
    PIRP               irp;
    PIO_STACK_LOCATION nextStack;
    NTSTATUS           status = STATUS_SUCCESS;

    PAGED_CODE ();

    Print (DBG_PNP_TRACE, ("PNP-CallHidClass: Enter." ));

    //
    // Prepare to issue a synchronous request.
    //
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest (
                            Ioctl,
                            Data->TopOfStack,
                            InputBuffer,
                            InputBufferLength,
                            OutputBuffer,
                            OutputBufferLength,
                            FALSE,              // external IOCTL
                            &event,
                            &ioStatus);

    if (irp == NULL) {
       return STATUS_UNSUCCESSFUL;
    }

    //
    // Call the class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);

    status = IoCallDriver(Data->TopOfStack, irp);

    if (status == STATUS_PENDING) {

       status = KeWaitForSingleObject(
                     &event,
                     Executive,    // wait reason
                     KernelMode,
                     FALSE,        // not alertable
                     NULL);        // no time out
    }

    if (NT_SUCCESS (status)) {
        status = ioStatus.Status;
    }

    Print (DBG_PNP_TRACE, ("PNP-CallHidClass: Enter." ));
    return status;
}


NTSTATUS
MouHid_QueryDeviceKey (
    IN  HANDLE  Handle,
    IN  PWCHAR  ValueNameString,
    OUT PVOID   Data,
    IN  ULONG   DataLength
    )
{
    NTSTATUS        status;
    UNICODE_STRING  valueName;
    ULONG           length;
    PKEY_VALUE_FULL_INFORMATION fullInfo;

    RtlInitUnicodeString (&valueName, ValueNameString);

    length = sizeof (KEY_VALUE_FULL_INFORMATION)
           + valueName.MaximumLength
           + DataLength;

    fullInfo = ExAllocatePool (PagedPool, length);

    if (fullInfo) {
        status = ZwQueryValueKey (Handle,
                                  &valueName,
                                  KeyValueFullInformation,
                                  fullInfo,
                                  length,
                                  &length);

        if (NT_SUCCESS (status)) {
            ASSERT (DataLength == fullInfo->DataLength);
            RtlCopyMemory (Data,
                           ((PUCHAR) fullInfo) + fullInfo->DataOffset,
                           fullInfo->DataLength);
        }

        ExFreePool (fullInfo);
    } else {
        status = STATUS_NO_MEMORY;
    }

    return status;
}



NTSTATUS
MouHid_AddDevice (
    IN PDRIVER_OBJECT   Driver,
    IN PDEVICE_OBJECT   PDO
    )
/*++

Routine Description:


Arguments:


Return Value:

    NTSTATUS result code.

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   data;
    PDEVICE_OBJECT      device;
    HANDLE              devInstRegKey;
    ULONG               tmp = 0;
    POWER_STATE         state;

    PAGED_CODE ();


    Print (DBG_PNP_TRACE, ("enter Add Device \n"));

    status = IoCreateDevice(Driver,
                            sizeof(DEVICE_EXTENSION),
                            NULL, // no name for this Filter DO
                            FILE_DEVICE_MOUSE,
                            0,
                            FALSE,
                            &device);

    if (!NT_SUCCESS (status)) {
        return( status );
    }

    data = (PDEVICE_EXTENSION) device->DeviceExtension;

    //
    // Initialize the fields.
    //
    data->TopOfStack = IoAttachDeviceToDeviceStack (device, PDO);
    if (data->TopOfStack == NULL) {
        PIO_ERROR_LOG_PACKET errorLogEntry;

        //
        // Not good; in only extreme cases will this fail
        //
        errorLogEntry = (PIO_ERROR_LOG_PACKET)
            IoAllocateErrorLogEntry(Driver,
                                    (UCHAR) sizeof(IO_ERROR_LOG_PACKET));

        if (errorLogEntry) {
            errorLogEntry->ErrorCode = MOUHID_ATTACH_DEVICE_FAILED;
            errorLogEntry->DumpDataSize = 0;
            errorLogEntry->SequenceNumber = 0;
            errorLogEntry->MajorFunctionCode = 0;
            errorLogEntry->IoControlCode = 0;
            errorLogEntry->RetryCount = 0;
            errorLogEntry->UniqueErrorValue = 0;
            errorLogEntry->FinalStatus =  STATUS_DEVICE_NOT_CONNECTED;

            IoWriteErrorLogEntry(errorLogEntry);
        }

        IoDeleteDevice(device);
        return STATUS_DEVICE_NOT_CONNECTED; 
    }
    
    ASSERT (data->TopOfStack);

    data->Self = device;
    data->Started = FALSE;
    data->Initialized = FALSE;
    data->UnitId = (USHORT) InterlockedIncrement (&Globals.UnitId);
    data->PDO = PDO;
    data->ReadIrp = IoAllocateIrp (data->TopOfStack->StackSize, FALSE);
    // Initializiation happens automatically.
    if (NULL == data->ReadIrp) {
        IoDetachDevice (data->TopOfStack);
        IoDeleteDevice (device);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeEvent (&data->ReadCompleteEvent, SynchronizationEvent, FALSE);
    KeInitializeEvent (&data->ReadSentEvent, NotificationEvent, TRUE);
    IoInitializeRemoveLock (&data->RemoveLock, MOUHID_POOL_TAG, 1, 10);
    data->ReadFile = NULL;
    ExInitializeFastMutex (&data->CreateCloseMutex);

    data->InputData.UnitId = data->UnitId;

    //
    // Initialize the mouse attributes.
    //
    data->Attributes.MouseIdentifier = MOUSE_HID_HARDWARE;
    data->Attributes.SampleRate      = 0;
    data->Attributes.InputDataQueueLength = 2;

    //
    // Find device specific parameters for this hid mouse device.
    //

    if (NT_SUCCESS (status)) {
        status = IoOpenDeviceRegistryKey (PDO,
                                          PLUGPLAY_REGKEY_DEVICE,
                                          STANDARD_RIGHTS_ALL,
                                          &devInstRegKey);

        data->FlipFlop = FALSE;

        if (NT_SUCCESS (status)) {
            status = MouHid_QueryDeviceKey (devInstRegKey,
                                            FLIP_FLOP_WHEEL,
                                            &tmp,
                                            sizeof (tmp));
            if (NT_SUCCESS (status)) {
                data->FlipFlop = (BOOLEAN) tmp;
            }
            status = MouHid_QueryDeviceKey (devInstRegKey,
                                            SCALING_FACTOR_WHEEL,
                                            &tmp,
                                            sizeof (tmp));
            if (NT_SUCCESS (status)) {
                data->WheelScalingFactor = (ULONG) tmp;
            } else {
                data->WheelScalingFactor = 120;
            }
            ZwClose (devInstRegKey);
        }
        status = STATUS_SUCCESS;
    }

    state.DeviceState = PowerDeviceD0;
    PoSetPowerState (device, DevicePowerState, state);

    data->WmiLibInfo.GuidCount = sizeof (MouHid_WmiGuidList) /
                                 sizeof (WMIGUIDREGINFO);
    ASSERT (1 == data->WmiLibInfo.GuidCount);
    data->WmiLibInfo.GuidList = MouHid_WmiGuidList;
    data->WmiLibInfo.QueryWmiRegInfo = MouHid_QueryWmiRegInfo;
    data->WmiLibInfo.QueryWmiDataBlock = MouHid_QueryWmiDataBlock;
    data->WmiLibInfo.SetWmiDataBlock = MouHid_SetWmiDataBlock;
    data->WmiLibInfo.SetWmiDataItem = MouHid_SetWmiDataItem;
    data->WmiLibInfo.ExecuteWmiMethod = NULL;
    data->WmiLibInfo.WmiFunctionControl = NULL;

    device->Flags |= DO_POWER_PAGABLE;
    device->Flags &= ~DO_DEVICE_INITIALIZING;

    return status;
}

NTSTATUS
MouHid_StartDevice (
    IN PDEVICE_EXTENSION    Data
    )
/*++

Routine Description:


Arguments:


Return Value:

    NTSTATUS result code.

--*/
{
    HIDP_CAPS                  caps; // the capabilities of the found hid device
    HID_COLLECTION_INFORMATION info;
    NTSTATUS                   status = STATUS_SUCCESS;
    PHIDP_PREPARSED_DATA       preparsedData = NULL;
    PHID_EXTENSION             hid = NULL;
    ULONG                      length, inputBufferLength, usageListLength;
    USHORT                     maxUsages;
    PCHAR                      buffer;
    USHORT                     slength;
    HIDP_VALUE_CAPS            valueCaps;

    PAGED_CODE ();

    Print (DBG_PNP_TRACE, ("enter START Device \n"));

    //
    // Retrieve the capabilities of this hid device
    // IOCTL_HID_GET_COLLECTION_INFORMATION fills in HID_COLLECTION_INFORMATION.
    // we are interested in the Descriptor Size, which tells us how big a
    // buffer to allocate for the preparsed data.
    //
    if (!NT_SUCCESS (status = MouHid_CallHidClass (
                                        Data,
                                        IOCTL_HID_GET_COLLECTION_INFORMATION,
                                        0, 0, // no input
                                        &info, sizeof (info)))) {
        goto MouHid_StartDeviceReject;
    }

    //
    // Allocate memory to hold the preparsed data.
    //
    preparsedData = (PHIDP_PREPARSED_DATA)
                    ExAllocatePool (NonPagedPool, info.DescriptorSize);

    if (!preparsedData) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto MouHid_StartDeviceReject;
    }

    //
    // Retrieve that information.
    //

    if (!NT_SUCCESS (status = MouHid_CallHidClass (
                                       Data,
                                       IOCTL_HID_GET_COLLECTION_DESCRIPTOR,
                                       0, 0, // no input
                                       preparsedData, info.DescriptorSize))) {
        goto MouHid_StartDeviceReject;
    }

    //
    // Call the parser to determine the capabilites of this HID device.
    //

    if (!NT_SUCCESS (status = HidP_GetCaps (preparsedData, &caps))) {
        goto MouHid_StartDeviceReject;
    }

    //
    // Is this the thing we want?
    //
    // In this particular case we are looking for a keyboard.
    //
    if (    (HID_USAGE_PAGE_GENERIC  == caps.UsagePage) &&
            (   (HID_USAGE_GENERIC_MOUSE == caps.Usage) ||
                (   (HID_USAGE_GENERIC_POINTER == caps.Usage) &&
                    (!Globals.UseOnlyMice)))) {
        ;

    } else {
        //
        // Someone made an INF blunder!
        //
        ASSERT (    (HID_USAGE_PAGE_GENERIC  == caps.UsagePage) &&
                    (   (HID_USAGE_GENERIC_MOUSE == caps.Usage) ||
                        (   (HID_USAGE_GENERIC_POINTER == caps.Usage) &&
                            (!Globals.UseOnlyMice))));

        status = STATUS_UNSUCCESSFUL;

        goto MouHid_StartDeviceReject;
    }

    //
    // Note: here we might also want to check the button and value capabilities
    // of the device as well.
    //
    // Then let's use it.
    //

    //
    // a buffer length to allow an Input buffer, output buffer, feature buffer,
    // and the total number of usages that can be returned from a read packet.
    //

    maxUsages = (USHORT)  HidP_MaxUsageListLength (HidP_Input,
                                                   HID_USAGE_PAGE_BUTTON,
                                                   preparsedData);

    //
    // Create space in the device extension for the buffer storage when working
    // with this HID device.
    //
    // We need four buffers to hold the button codes (length returned from
    // HidP_MaxUsageListLength) this will hold the current list of usages,
    // the previous list of usages, the ``Make'' and the ``Break'' lists.
    // We also need a place to put the input, output, and feature report
    // buffers.
    //

    usageListLength = ALIGNPTRLEN(maxUsages * sizeof (USAGE));
    inputBufferLength = ALIGNPTRLEN(caps.InputReportByteLength);
    
    length = (4 * usageListLength)
           + inputBufferLength
           + sizeof (HID_EXTENSION);

    Data->HidExtension = hid = ExAllocatePool (NonPagedPool, length);

    if (!hid) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto MouHid_StartDeviceReject;
    }

    RtlZeroMemory (hid, length);

    //
    // Initialize the fields.
    //
    hid->Ppd = preparsedData;
    hid->Caps = caps;
    hid->MaxUsages = maxUsages;

    Data->Attributes.NumberOfButtons = (USHORT) maxUsages;


    hid->InputBuffer = buffer = hid->Buffer;
    hid->PreviousUsageList =  (PUSAGE) (buffer += inputBufferLength);
    hid->CurrentUsageList = (PUSAGE) (buffer += usageListLength);
    hid->BreakUsageList = (PUSAGE) (buffer += usageListLength);
    hid->MakeUsageList = (PUSAGE) (buffer + usageListLength);

    //
    // Create the MDLs
    // HidClass uses direct IO so you need MDLs
    //

    hid->InputMdl = IoAllocateMdl (hid->InputBuffer,   // The virtual address
                                   caps.InputReportByteLength, // length
                                   FALSE,  // No associated IRP => not secondary
                                   FALSE,  // No quota charge
                                   0);     // No associated IRP
    if (NULL == hid->InputMdl) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto MouHid_StartDeviceReject;
    }
    MmBuildMdlForNonPagedPool (hid->InputMdl);  // Build this MDL.

    //
    // Determine if X,Y,Z values are absolute or relative for this device.
    // Only check X axis (assume Y,Z are the same -- we have no choice but
    // to make this assumption since the MOUSE_INPUT_DATA structure does
    // not accomodate mixed absolute/relative position fields).
    //
    slength = 1;
    if (!NT_SUCCESS (status = HidP_GetSpecificValueCaps(
                                       HidP_Input,
                                       HID_USAGE_PAGE_GENERIC,
                                       0,
                                       HID_USAGE_GENERIC_X,
                                       &valueCaps,
                                       &slength,
                                       preparsedData) ) ) {
        goto MouHid_StartDeviceReject;
    }

    ASSERT (1 == slength);

    if (valueCaps.IsAbsolute) {
        if ((HID_USAGE_GENERIC_POINTER == caps.Usage) &&
            (Globals.TreatAbsolutePointerAsAbsolute)) {
            //
            // All pointers that declare themselfs as Absolute should be
            // treated as such, regardless of the TreatAbsoluteAsRelative flag
            //
            Data->InputData.Flags = MOUSE_MOVE_ABSOLUTE;
            hid->IsAbsolute = TRUE;

        } else if (Globals.TreatAbsoluteAsRelative) {
            //
            // Here we have overriden the HID descriptors absolute flag.
            // We will treat this as a relative device even though it claims
            // to be an absolute device.
            //
            Data->InputData.Flags = MOUSE_MOVE_RELATIVE;
            hid->IsAbsolute = FALSE;

            //
            // Report the problem with this mouse's report descriptor and
            // report it to the user.
            //
            Data->ProblemFlags |= PROBLEM_BAD_ABSOLUTE_FLAG_X_Y;

            MouHid_LogError(Data->Self->DriverObject,
                            MOUHID_INVALID_ABSOLUTE_AXES,
                            NULL);
        } else {
            //
            // No switches with which to play.  Do what seems natural
            //
            Data->InputData.Flags = MOUSE_MOVE_ABSOLUTE;
            hid->IsAbsolute = TRUE;
        }

    } else {
        Data->InputData.Flags = MOUSE_MOVE_RELATIVE;
        hid->IsAbsolute = FALSE;
    }

    //
    // Determine X axis usage value's bit size.
    //
    hid->BitSize.X = valueCaps.BitSize;
    hid->MaxX = valueCaps.PhysicalMax;
    hid->MaxX = (hid->MaxX) ? (hid->MaxX) : ((1 << (hid->BitSize.X - 1)) - 1);


    //
    // Determine Y axis usage value's bit size.
    //
    slength = 1;
    if (!NT_SUCCESS (status = HidP_GetSpecificValueCaps(
                                       HidP_Input,
                                       HID_USAGE_PAGE_GENERIC,
                                       0,
                                       HID_USAGE_GENERIC_Y,
                                       &valueCaps,
                                       &slength,
                                       preparsedData) ) ) {
        goto MouHid_StartDeviceReject;
    }
    ASSERT (1 == slength);

    hid->BitSize.Y = valueCaps.BitSize;
    hid->MaxY = valueCaps.PhysicalMax;
    hid->MaxY = (hid->MaxY) ? (hid->MaxY) : ((1 << (hid->BitSize.Y - 1)) - 1);

    //
    // Initialize wheel usage not-detected flag to false (determined later).
    //
    hid->HasNoWheelUsage = FALSE;
    hid->HasNoZUsage = FALSE;

    //
    // Determine Z axis usage value's bit size (if this is a wheel mouse).
    // Note that a Z axis may not exist, so we handle this case differently.
    //

    slength = 1;
    if (NT_SUCCESS (HidP_GetSpecificValueCaps(
                                       HidP_Input,
                                       HID_USAGE_PAGE_GENERIC,
                                       0,
                                       HID_USAGE_GENERIC_WHEEL,
                                       &valueCaps,
                                       &slength,
                                       preparsedData) ) && slength == 1) {
        hid->BitSize.Z = valueCaps.BitSize;
        Data->Attributes.MouseIdentifier = WHEELMOUSE_HID_HARDWARE;
    } else {
        // hid->HasNoWheelUsage = TRUE;

        slength = 1;
        if (NT_SUCCESS (HidP_GetSpecificValueCaps(
                                           HidP_Input,
                                           HID_USAGE_PAGE_GENERIC,
                                           0,
                                           HID_USAGE_GENERIC_Z,
                                           &valueCaps,
                                           &slength,
                                           preparsedData) ) && slength == 1) {
            hid->BitSize.Z = valueCaps.BitSize;
            Data->Attributes.MouseIdentifier = WHEELMOUSE_HID_HARDWARE;
        } else {
            // hid->HasNoZUsage = TRUE;
            hid->BitSize.Z = 0;
        }
    }

    //
    // We are done.  Return peacefully.
    //
    return status;

MouHid_StartDeviceReject:
    if (preparsedData) {
        // no need to set hid->Ppd to NULL becuase we will be freeing it as well
        ExFreePool (preparsedData);
    }
    if (hid) {
        if (hid->InputMdl) {
            IoFreeMdl (hid->InputMdl);
        }
        ExFreePool (hid);
        Data->HidExtension = NULL;
    }
    return status;
}

NTSTATUS
MouHid_PnP (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    The plug and play dispatch routines.

    Most of these this filter driver will completely ignore.
    In all cases it must pass on the IRP to the lower driver.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PDEVICE_EXTENSION   data;
    PHID_EXTENSION      hid;
    PIO_STACK_LOCATION  stack;
    NTSTATUS            status;
    ULONG               i, j;
    LONG                ioCount;
    PDEVICE_EXTENSION * classDataList;

    PAGED_CODE ();

    data = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation (Irp);
    hid = data->HidExtension;

    status = IoAcquireRemoveLock (&data->RemoveLock, Irp);
    if (!NT_SUCCESS (status)) {
        //
        // Someone gave us a pnp irp after a remove.  Unthinkable!
        //
        ASSERT (FALSE);
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    Print(DBG_PNP_TRACE, ("PNP: Minor code = %x.", stack->MinorFunction));
    
    switch (stack->MinorFunction) {
    case IRP_MN_START_DEVICE:

        if (data->Started) {
            Print(DBG_PNP_INFO, ("PNP: Device already started." ));
            status = STATUS_SUCCESS;
            Irp->IoStatus.Status = status;
            IoCompleteRequest (Irp, IO_NO_INCREMENT);
            break;
        }

        //
        // The device is starting.
        //
        // We cannot touch the device (send it any non pnp irps) until a
        // start device has been passed down to the lower drivers.
        //
        IoCopyCurrentIrpStackLocationToNext (Irp);
        KeInitializeEvent(&data->StartEvent, NotificationEvent, FALSE);
        IoSetCompletionRoutine (Irp,
                                MouHid_PnPComplete,
                                data,
                                TRUE,
                                TRUE,
                                TRUE); // No need for Cancel

        Irp->IoStatus.Status = STATUS_SUCCESS;
        status = IoCallDriver (data->TopOfStack, Irp);
        if (STATUS_PENDING == status) {
            KeWaitForSingleObject(
               &data->StartEvent,
               Executive, // Waiting for reason of a driver
               KernelMode, // Waiting in kernel mode
               FALSE, // No allert
               NULL); // No timeout
        }

        if (NT_SUCCESS (status) && NT_SUCCESS (Irp->IoStatus.Status)) {
            //
            // As we are successfully now back from our start device
            // we can do work.
            //
            if (!data->Initialized) {
                status = MouHid_StartDevice (data);
                if (NT_SUCCESS (status)) {
                    IoWMIRegistrationControl(DeviceObject,
                                             WMIREG_ACTION_REGISTER
                                             );
                
                    data->Started = TRUE;
                    data->Initialized = TRUE;
                }
            } else {
                data->Started = TRUE;
            }                        
        }

        //
        // We must now complete the IRP, since we stopped it in the
        // completetion routine with MORE_PROCESSING_REQUIRED.
        //
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        break;

    case IRP_MN_STOP_DEVICE:
        //
        // After the start IRP has been sent to the lower driver object, the
        // bus may NOT send any more IRPS down ``touch'' until another START
        // has occured.
        // What ever access is required must be done before the Irp is passed
        // on.
        //

        if (data->Started) {
            //
            // Do what ever
            //
        }

        //
        // We don't need a completion routine so fire and forget.
        //
        // Set the current stack location to the next stack location and
        // call the next device object.
        //

        //
        // Stop Device touching the hardware MouStopDevice(data, TRUE);
        //
        data->Started = FALSE;
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (data->TopOfStack, Irp);
        break;

    case IRP_MN_REMOVE_DEVICE:
        //
        // The PlugPlay system has dictacted the removal of this device.  We
        // have no choise but to detach and delete the device objecct.
        // (If we wanted to express and interest in preventing this removal,
        // we should have filtered the query remove and query stop routines.)
        //
        // Note! we might receive a remove WITHOUT first receiving a stop.
        // ASSERT (!usbData->Removed);
        Print (DBG_PNP_TRACE, ("enter RemoveDevice \n"));

        IoWMIRegistrationControl(data->Self,
                                 WMIREG_ACTION_DEREGISTER
                                 );

        if (data->Started) {
            // Stop the device without touching the hardware.
            // MouStopDevice(data, FALSE);
        }

        //
        // Here if we had any outstanding requests in a personal queue we should
        // complete them all now.
        //
        // Note, the device could be GONE so we cannot send it any non-
        // PNP IRPS.
        //


        //
        // Cancel our read IRP.  [DAN]
        // Note - waiting is only really necessary on 98, where pnp doesn't 
        // make sure all handles are closed before sending the remove.
        //
        data->ShuttingDown = TRUE;
        KeWaitForSingleObject (&data->ReadSentEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL
                               );
        IoCancelIrp(data->ReadIrp);

        //
        // Send on the remove IRP
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (data->TopOfStack, Irp);

        //
        // Wait for the remove lock to free.
        //
        IoReleaseRemoveLockAndWait (&data->RemoveLock, Irp);

        //
        // Free the associated memory.
        //
        IoFreeIrp (data->ReadIrp);

        if (hid) {
            //
            // If we are removed without being started then we will have
            // no hid extension
            //
            ExFreePool (hid->Ppd);
            IoFreeMdl (hid->InputMdl);
            ExFreePool (hid);
        }

        IoDetachDevice (data->TopOfStack);
        IoDeleteDevice (data->Self);
        return status;

    case IRP_MN_SURPRISE_REMOVAL:
    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_CANCEL_REMOVE_DEVICE:
    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_CANCEL_STOP_DEVICE:
        //
        // These IRPs have to have their status changed from 
        // STATUS_NOT_SUPPORTED b4 passing them down.
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;
    
    case IRP_MN_QUERY_DEVICE_RELATIONS:
    case IRP_MN_QUERY_INTERFACE:
    case IRP_MN_QUERY_CAPABILITIES:
    case IRP_MN_QUERY_RESOURCES:
    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
    case IRP_MN_READ_CONFIG:
    case IRP_MN_WRITE_CONFIG:
    case IRP_MN_EJECT:
    case IRP_MN_SET_LOCK:
    case IRP_MN_QUERY_ID:
    case IRP_MN_QUERY_PNP_DEVICE_STATE:
    default:
        //
        // Here the filter driver might modify the behavior of these IRPS
        // Please see PlugPlay documentation for use of these IRPs.
        //
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (data->TopOfStack, Irp);
        break;
    }

    IoReleaseRemoveLock (&data->RemoveLock, Irp);

    return status;
}


NTSTATUS
MouHid_PnPComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:
    The pnp IRP is in the process of completing.
    signal

Arguments:
    Context set to the device object in question.

--*/
{
    PIO_STACK_LOCATION  stack;
    PDEVICE_EXTENSION   data;
    NTSTATUS            status;

    UNREFERENCED_PARAMETER (DeviceObject);

    status = STATUS_SUCCESS;
    data = (PDEVICE_EXTENSION) Context;
    stack = IoGetCurrentIrpStackLocation (Irp);

    if (Irp->PendingReturned) {
        IoMarkIrpPending( Irp );
    }

    switch (stack->MajorFunction) {
    case IRP_MJ_PNP:

        switch (stack->MinorFunction) {
        case IRP_MN_START_DEVICE:

            KeSetEvent (&data->StartEvent, 0, FALSE);

            //
            // Take the IRP back so that we can continue using it during
            // the IRP_MN_START_DEVICE dispatch routine.
            // NB: we will have to call IoCompleteRequest
            //
            return STATUS_MORE_PROCESSING_REQUIRED;

        default:
            break;
        }
        break;

    case IRP_MJ_POWER:
    default:
        break;
    }
    return status;
}

NTSTATUS
MouHid_Power (
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    )
{
    PIO_STACK_LOCATION  stack;
    NTSTATUS            status;
    PDEVICE_EXTENSION   data;
    POWER_STATE         powerState;
    POWER_STATE_TYPE    powerType;

    Print(DBG_POWER_TRACE, ("Power Enter." ));

    data = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation (Irp);
    powerType = stack->Parameters.Power.Type;
    powerState = stack->Parameters.Power.State;

    status = IoAcquireRemoveLock (&data->RemoveLock, Irp);

    if (!NT_SUCCESS (status)) {
        PoStartNextPowerIrp (Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    switch (stack->MinorFunction) {
    case IRP_MN_SET_POWER:
        Print(DBG_POWER_INFO, ("Power Setting %s state to %d\n",
                               ((powerType == SystemPowerState) ? "System"
                                                                : "Device"),
                               powerState.SystemState));
        break;

    case IRP_MN_QUERY_POWER:
        Print (DBG_POWER_INFO, ("Power query %s status to %d\n",
                                ((powerType == SystemPowerState) ? "System"
                                                                 : "Device"),
                                powerState.SystemState));
        break;

    default:
        Print (DBG_POWER_ERROR, ("Power minor (0x%x) no known\n",
                                 stack->MinorFunction));
    }

    PoStartNextPowerIrp (Irp);
    IoSkipCurrentIrpStackLocation (Irp);
    status = PoCallDriver (data->TopOfStack, Irp);
    IoReleaseRemoveLock (&data->RemoveLock, Irp);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\hidport\mouhid\mouhid.c ===
/*++

Copyright (c) 1997    Microsoft Corporation

Module Name:

    mouhid.c

Abstract:

    This module contains the code for the DriverEntry, Unload, IRP_MJ_FLUSH,
    and IRP_MJ_INTERNAL_DEVICE_CONTROL dispatch functions for the HID Mouse
    Filter Driver.

    Note: This is NOT a WDM driver, since it cannot run as a HID mapper on
    Memphis (Memphis requires that the mouse to HID mapper be a VXD) and since
    it uses EVent logs, which are not part of WDM 1.0.

Environment:

    Kernel mode only.

Revision History:

    Jan-1997 :  Initial writing, Dan Markarian
    May-1197 :  Kenneth D. Ray : Rewritten as PnP filter for Mouse Class

Notes:

    - IOCTL_INTERNAL_MOUSE_DISCONNECT has not been implemented.  It's not
      needed until the class unload routine is implemented. Right now,
      we don't want to allow the mouse class driver to unload.

    - Powerfail not implemented.

--*/

#include "mouhid.h"
#include "hidclass.h"

//
// Use the alloc_text pragma to specify the driver initialization routines
// (they can be paged out).
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(INIT,MouHid_GetRegistryParameters)
#pragma alloc_text(PAGE,MouHid_UpdateRegistryProblemFlagsCallback)
#pragma alloc_text(PAGE,MouHid_Unload)
#endif

GLOBALS Globals;

NTSTATUS
DriverEntry(
   IN PDRIVER_OBJECT DriverObject,
   IN PUNICODE_STRING RegistryPath
   )
/*++

Routine Description:

    This routine initializes the HID mouse filter driver.

Arguments:

    DriverObject - Pointer to driver object created by system.

    RegistryPath - Pointer to the Unicode name of the registry path for this
        driver.

Return Value:

    The function value is the final status from the initialization operation.

--*/
{
    NTSTATUS        status       = STATUS_SUCCESS;
    PUNICODE_STRING registryPath = &Globals.RegistryPath;

    Print (DBG_SS_TRACE, ("entering DriverEntry\n"));
    Print (DBG_SS_INFO, ("Mouse to hid mapper\n"));

    RtlZeroMemory (&Globals, sizeof (GLOBALS));

    //
    // Need to ensure that the registry path is null-terminated.
    // Allocate pool to hold a null-terminated copy of the path.
    // Safe in paged pool since all registry routines execute at
    // PASSIVE_LEVEL.
    //
    registryPath->MaximumLength = RegistryPath->Length + sizeof(UNICODE_NULL);
    registryPath->Length = RegistryPath->Length;
    registryPath->Buffer = ExAllocatePool(
                              PagedPool,
                              registryPath->MaximumLength
                              );

    if (!registryPath->Buffer) {

        Print (DBG_SS_ERROR,
               ("Initialize: Couldn't allocate pool for registry path."));

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto DriverEntryReject;
    }

    RtlZeroMemory (registryPath->Buffer, registryPath->MaximumLength);

    RtlMoveMemory (registryPath->Buffer,
                   RegistryPath->Buffer,
                   RegistryPath->Length);

    //
    // Obtain configuration information for this driver.
    //
    status = MouHid_GetRegistryParameters();
    if (!NT_SUCCESS (status)) {
        goto DriverEntryReject;
    }

    //
    // Set up the device driver entry points.
    //
    DriverObject->MajorFunction[IRP_MJ_CREATE]              = MouHid_Create;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]               = MouHid_Close;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL]=MouHid_IOCTL;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]      = MouHid_PassThrough;
    DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS]       = MouHid_Flush;
    DriverObject->MajorFunction[IRP_MJ_PNP]                 = MouHid_PnP;
    DriverObject->MajorFunction[IRP_MJ_POWER]               = MouHid_Power;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]      = MouHid_SystemControl;
    DriverObject->DriverUnload                              = MouHid_Unload;
    DriverObject->DriverExtension->AddDevice                = MouHid_AddDevice;

    Print (DBG_SS_TRACE, ("exit DriverEntry (0x%x) \n", status));

    return status;

DriverEntryReject:

    if (registryPath->Buffer) {
        ExFreePool (registryPath->Buffer);
    }
    return status;
}

NTSTATUS
MouHid_PassThrough (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
)
/*++

Routine Description:
    Pass the irp on through


--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   data;

    data = DeviceObject->DeviceExtension;

    status = IoAcquireRemoveLock (&data->RemoveLock, Irp);
    if (!NT_SUCCESS (status)) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    IoSkipCurrentIrpStackLocation (Irp);
    status = IoCallDriver (data->TopOfStack, Irp);
    IoReleaseRemoveLock (&data->RemoveLock, Irp);
    return status;
}


VOID
MouHid_Unload(
   IN PDRIVER_OBJECT Driver
   )
/*++

Routine Description:

   Free all the allocated resources associated with this driver.

Arguments:

   DriverObject - Pointer to the driver object.

Return Value:

   None.

--*/
{
    PAGED_CODE ();

    ASSERT (NULL == Driver->DeviceObject);

    Print (DBG_SS_INFO, ("Unload \n"));

    //
    // Free resources in device extension.
    //
    ExFreePool (Globals.RegistryPath.Buffer);

    return;
}

NTSTATUS
MouHid_Flush (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    Respond to flush requests from the mouse class driver.  Currently does
    nothing but pass IRP down to next lower driver.   This routine expects
    the current IRQL to be < DISPATCH_LEVEL.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    NT status code.

--*/
{
    PDEVICE_EXTENSION  data;
    NTSTATUS           status;
    PIO_STACK_LOCATION stack;

    Print (DBG_CALL_INFO, ("Flush \n"));

    TRAP();

    //
    // Get a pointer to the device extension.
    //
    data = DeviceObject->DeviceExtension;

    status = IoAcquireRemoveLock (&data->RemoveLock, Irp);
    if (!NT_SUCCESS (status)) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    //
    // Send the flush request down to the HID class driver, one for each
    // of our mouse device context structures.
    //

    IoCopyCurrentIrpStackLocationToNext (Irp);
    stack = IoGetNextIrpStackLocation (Irp);

    stack->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    stack->Parameters.DeviceIoControl.IoControlCode = IOCTL_HID_FLUSH_QUEUE;

    //
    // Fire and forget
    //
    status = IoCallDriver (data->TopOfStack, Irp);
    IoReleaseRemoveLock (&data->RemoveLock, Irp);

    return status;
}

NTSTATUS
MouHid_IOCTL (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

    Respond to queries from the mouse class driver.

    The IOCTLs for DISABLE, ENABLE, and QUERY_ATTRIBUTES, expect the current
    IRQL to be < DISPATCH_LEVEL.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    NT status code.

--*/
{
    PIO_STACK_LOCATION      stack;
    NTSTATUS                status = STATUS_SUCCESS;
    PDEVICE_EXTENSION       data;
    BOOLEAN                 completeIt = TRUE;



    data = DeviceObject->DeviceExtension;

    Irp->IoStatus.Information = 0;
    stack = IoGetCurrentIrpStackLocation (Irp);

    status = IoAcquireRemoveLock (&data->RemoveLock, Irp);
    if (!NT_SUCCESS (status)) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    ASSERT (data->Started ||
            (IOCTL_INTERNAL_MOUSE_CONNECT ==
             stack->Parameters.DeviceIoControl.IoControlCode));

    switch (stack->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_INTERNAL_MOUSE_CONNECT:
        //
        // Connect the mouse class device driver to the port driver.
        //

        Print (DBG_IOCTL_TRACE, ("enter Connect \n"));

        //
        // Connect a mouse class device driver to the filter driver.
        // Only allow one connection.
        //
        if (NULL != data->ConnectData.ClassService) {

            Print (DBG_IOCTL_ERROR, ("ERROR: Multiple connects \n"));
            TRAP();
            status = STATUS_SHARING_VIOLATION;
            break;

        } else if (stack->Parameters.DeviceIoControl.InputBufferLength <
                   sizeof(CONNECT_DATA)) {

            Print (DBG_IOCTL_ERROR, ("ERROR: Invalid connect parameter size. \n"));
            TRAP();
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // Copy the connection parameters to the device extension.
        //
        data->ConnectData = *(PCONNECT_DATA)
                      stack->Parameters.DeviceIoControl.Type3InputBuffer;

        status = STATUS_SUCCESS;
        break;

    case IOCTL_INTERNAL_MOUSE_DISCONNECT:
        //
        // Disconnect a keyboard class device driver from the port driver.
        //
        Print (DBG_IOCTL_TRACE, ("Disconnect \n"));
        TRAP();

        //
        // Not implemented.
        //
        // To implement, code the following:
        // ---------------------------------
        // o ENSURE that we are NOT enabled (mouHidDeviceExt->EnableCount);
        //   o If we are, then (a) return STATUS_UNSUCCESSFUL, or
        //                     (b) disable all devices immediately; see
        //                         DISABLE IOCTL call for necessary code.
        // o SYNCHRONIZE with the mouse read completion routine (must
        //   protect the callback pointer from being dereferenced when
        //   it becomes null).  Note that no mechanism currently exists
        //   for this.
        // o CLEAR the connection parameters in the device extension;
        //   ie. mouHidDeviceExt->MouClassObject   = NULL;
        //       mouHidDeviceExt->MouClassCallback = NULL;
        // o RELEASE the synchronizing lock.
        // o RETURN STATUS_SUCCESS.
        //

        status = STATUS_NOT_IMPLEMENTED;
        break;

    case IOCTL_INTERNAL_MOUSE_ENABLE:
        //
        // Enable keyboard interrupts which really means start the ping pong
        // down to hid class.
        //
        Print (DBG_IOCTL_ERROR, ("ERROR: PnP => use create not enable! \n"));
        status = STATUS_NOT_SUPPORTED;

        break;

    case IOCTL_INTERNAL_MOUSE_DISABLE:
        //
        // Disable Mouse interrupts which really means stop the ping pongs
        // down to hid class.
        //
        Print (DBG_IOCTL_ERROR, ("ERROR: PnP => use close not Disable! \n"));
        status = STATUS_NOT_SUPPORTED;

        break;

    case IOCTL_MOUSE_QUERY_ATTRIBUTES:
        //
        // Query the mouse attributes.  First check for adequate buffer
        // length.  Then, copy the mouse attributes from the device
        // extension to the output buffer.
        //
        Print (DBG_IOCTL_TRACE, ("Query Attributes \n"));

        if (stack->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(MOUSE_ATTRIBUTES)) {

            Print (DBG_IOCTL_ERROR, ("ERROR: Query Attr buffer too small \n"));
            TRAP();
            status = STATUS_BUFFER_TOO_SMALL;
        } else {

            //
            // Copy the mouse attributes to the buffer.
            //

            *(PMOUSE_ATTRIBUTES) Irp->AssociatedIrp.SystemBuffer =
                data->Attributes;

            Irp->IoStatus.Information = sizeof(MOUSE_ATTRIBUTES);
            status = STATUS_SUCCESS;
        }

        break;

    default:
        Print (DBG_IOCTL_ERROR,
               ("ERROR: unknown IOCTL: 0x%x \n",
                stack->Parameters.DeviceIoControl.IoControlCode));
        TRAP();
        status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    if (completeIt) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    IoReleaseRemoveLock (&data->RemoveLock, Irp);

    Print (DBG_IOCTL_TRACE, ("IOCTL exit (%x)\n", status));
    return status;
}

NTSTATUS
MouHid_GetRegistryParameters()
/*++

Routine Description:

    This routine retrieves this driver's parameters from the registry,
    including it's base device name.

Return Value:

--*/
{
    PRTL_QUERY_REGISTRY_TABLE parameters     = NULL;
    UNICODE_STRING            parametersPath = {0,0,0};
    PWSTR                     path           = NULL;
    USHORT                    queriesPlus1   = 4;
    NTSTATUS                  status         = STATUS_SUCCESS;
    ULONG                     useOnlyMice;
    ULONG                     treatAbsoluteAsRelative;
    ULONG                     treatAbsolutePointerAsAbsolute;

    PAGED_CODE ();

    parametersPath.Buffer = NULL;

    //
    // Registry path is already null-terminated, so just use it as a string.
    //
    path = Globals.RegistryPath.Buffer;

    //
    // Allocate the Rtl query table.
    //
    parameters = ExAllocatePool(
                     PagedPool,
                     sizeof(RTL_QUERY_REGISTRY_TABLE) * queriesPlus1);

    if (!parameters) {

        Print (DBG_SS_ERROR,
               ("Initialize: Couldn't allocate table for Rtl query to parameters for %ws.",
                path));

        status = STATUS_UNSUCCESSFUL;
        goto MouHid_GetRegistryParametersExit;
    }

    RtlZeroMemory(parameters, sizeof(RTL_QUERY_REGISTRY_TABLE) * queriesPlus1);

    //
    // Form a path to this driver's Parameters subkey.
    //
    parametersPath.MaximumLength = Globals.RegistryPath.Length
                                 + sizeof(L"\\Parameters");

    parametersPath.Buffer = ExAllocatePool(PagedPool,
                                           parametersPath.MaximumLength);

    if (!parametersPath.Buffer) {

        Print (DBG_SS_ERROR,
               ("Initialize: Couldn't allocate string for path to parameters for %ws.",
                path));

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto MouHid_GetRegistryParametersExit;
    }

    //
    // Form the parameters path.
    //
    RtlZeroMemory(parametersPath.Buffer, parametersPath.MaximumLength);
    RtlAppendUnicodeToString(&parametersPath, path);
    RtlAppendUnicodeToString(&parametersPath, L"\\Parameters");

    //
    // Gather all of the "user specified" information from
    // the registry.
    //
    useOnlyMice = Globals.UseOnlyMice;
    parameters[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    parameters[0].Name = L"UseOnlyMice";
    parameters[0].EntryContext = &useOnlyMice;
    parameters[0].DefaultType = REG_DWORD;
    parameters[0].DefaultData = &useOnlyMice;
    parameters[0].DefaultLength = sizeof(ULONG);
    Globals.UseOnlyMice = (BOOLEAN) useOnlyMice;

    treatAbsoluteAsRelative = Globals.TreatAbsoluteAsRelative;
    parameters[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
    parameters[1].Name = L"TreatAbsoluteAsRelative";
    parameters[1].EntryContext = &treatAbsoluteAsRelative;
    parameters[1].DefaultType = REG_DWORD;
    parameters[1].DefaultData = &treatAbsoluteAsRelative;
    parameters[1].DefaultLength = sizeof(ULONG);
    Globals.TreatAbsoluteAsRelative = (BOOLEAN) treatAbsoluteAsRelative;

    treatAbsolutePointerAsAbsolute = Globals.TreatAbsolutePointerAsAbsolute;
    parameters[2].Flags = RTL_QUERY_REGISTRY_DIRECT;
    parameters[2].Name = L"TreatAbsolutePointerAsAbsolute";
    parameters[2].EntryContext = &treatAbsolutePointerAsAbsolute;
    parameters[2].DefaultType = REG_DWORD;
    parameters[2].DefaultData = &treatAbsolutePointerAsAbsolute;
    parameters[2].DefaultLength = sizeof(ULONG);
    Globals.TreatAbsolutePointerAsAbsolute = (BOOLEAN) treatAbsolutePointerAsAbsolute;

    status = RtlQueryRegistryValues (RTL_REGISTRY_ABSOLUTE,
                                     parametersPath.Buffer,
                                     parameters,
                                     NULL,
                                     NULL);
    if (!NT_SUCCESS(status)) {

        Print (DBG_SS_ERROR,
               ("ERROR: Initialize: RtlQueryRegistryValues (0x%x).", status));

        Globals.UseOnlyMice =
            Globals.TreatAbsoluteAsRelative =
            Globals.TreatAbsolutePointerAsAbsolute = 0;

        status = STATUS_SUCCESS;
    }

    ASSERT (!Globals.TreatAbsoluteAsRelative);
    ASSERT (!Globals.TreatAbsolutePointerAsAbsolute);
    ASSERT (!Globals.UseOnlyMice);

MouHid_GetRegistryParametersExit:
    //
    // Free the allocated memory before returning.
    //
    if (parametersPath.Buffer)
        ExFreePool(parametersPath.Buffer);
    if (parameters)
        ExFreePool(parameters);

    return status;
}


VOID
MouHid_UpdateRegistryProblemFlags(
    IN PDEVICE_EXTENSION    Data
    )
/*++



Routine Description:

    This routine stores the OR'd ProblemFlags value into the registry.
    It will queue the write to the registry if this routine is not run
    at PASSIVE_LEVEL.

Arguments:

    MouHidDeviceExt - HID Mouse Filter Driver device extension.

Return Value:

    None.

--*/

{
    PIO_WORKITEM   item;
    NTSTATUS       status;

    status = IoAcquireRemoveLock (&Data->RemoveLock, MouHid_UpdateRegistryProblemFlags);
    if (!NT_SUCCESS (status)) {
        //
        // Device has gone away, just silently exit
        //
        return;
    }

    item = IoAllocateWorkItem (Data->Self);
    if (item) {
        if (KeGetCurrentIrql() == PASSIVE_LEVEL) {
            //
            // We are safely at PASSIVE_LEVEL, call callback directly to perform
            // this operation immediately.
            //
            MouHid_UpdateRegistryProblemFlagsCallback (Data->Self, item);
    
        } else {
            //
            // We are not at PASSIVE_LEVEL, so queue a workitem to handle this
            // at a later time.
            //
            IoQueueWorkItem (item,
                             MouHid_UpdateRegistryProblemFlagsCallback,
                             DelayedWorkQueue,
                             item);
        }
    } 
    else {
        IoReleaseRemoveLock (&Data->RemoveLock, MouHid_UpdateRegistryProblemFlags);
    }
}

VOID
MouHid_UpdateRegistryProblemFlagsCallback (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_WORKITEM Item 
    )
/*++



Routine Description:

    This routine stores the OR'd ProblemFlags value into the registry.  This
    routine must execute at PASSIVE_LEVEL.

Arguments:

    MouHidDeviceExt - HID Mouse Filter Driver device extension.

Return Value:

    None.

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   data;
    HANDLE              hDevNode;
    UNICODE_STRING      strProblemFlags;

    PAGED_CODE ();

    data = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension; 

    status = IoOpenDeviceRegistryKey (data->PDO,
                                      PLUGPLAY_REGKEY_DEVICE,
                                      STANDARD_RIGHTS_ALL,
                                      &hDevNode);

    if (NT_SUCCESS(status)) {
        RtlInitUnicodeString (&strProblemFlags, L"ProblemFlags");

        ZwSetValueKey (hDevNode,
                       &strProblemFlags,
                       0,
                       REG_DWORD,
                       &data->ProblemFlags,
                       sizeof(data->ProblemFlags));

        ZwClose(hDevNode);
    }
    else {
        Print(DBG_SS_ERROR,
                   ("UpdateRegistryProblemFlags: failed (%x).\n", status));
    }

    IoReleaseRemoveLock (&data->RemoveLock, MouHid_UpdateRegistryProblemFlags);
    IoFreeWorkItem (Item);
}

VOID
MouHid_LogError(
   IN PDRIVER_OBJECT DriverObject,
   IN NTSTATUS       ErrorCode,
   IN PWSTR          ErrorInsertionString OPTIONAL)
/*++

[DAN]

Routine Description:

    Logs an error to the system.

Arguments:

    DriverObject - Pointer to driver object reporting the error.

    ErrorCode    - Indicates the type of error, system or driver-defined.

    ErrorInsertionString - Null-terminated Unicode string inserted into error
                           description, as defined by error code.  Must be no
                           no longer than 50 characters.

Return Value:

    None.

--*/
{
   ULONG                errorInsertionStringSize = 0;
   PIO_ERROR_LOG_PACKET errorLogEntry;
   ULONG                errorLogEntrySize;                  // [including null]
   PWCHAR               pWChar;

   if (ErrorInsertionString) {
      for (pWChar = ErrorInsertionString; *pWChar; pWChar++) {
         errorInsertionStringSize += sizeof(WCHAR);
      }
      errorInsertionStringSize += sizeof(UNICODE_NULL);
   }

   errorLogEntrySize = sizeof(IO_ERROR_LOG_PACKET) + errorInsertionStringSize;

   //
   // Log an error.
   //
   if (errorLogEntrySize <= ERROR_LOG_MAXIMUM_SIZE) {

      errorLogEntry = IoAllocateErrorLogEntry(DriverObject,
                                              (UCHAR)errorLogEntrySize);

      if (errorLogEntry != NULL) {

         RtlZeroMemory(errorLogEntry, errorLogEntrySize);

         errorLogEntry->ErrorCode       = ErrorCode;
         errorLogEntry->FinalStatus     = ErrorCode;
         errorLogEntry->NumberOfStrings = (ErrorInsertionString) ? 1 : 0;

         if (ErrorInsertionString) {
           RtlCopyMemory(errorLogEntry->DumpData,
                         ErrorInsertionString,
                         errorInsertionStringSize);
         }

         IoWriteErrorLogEntry(errorLogEntry);
      }
   }

   return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\hidport\mouhid\wmi.c ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    WMI.C

Abstract:

    This module contains the init code for the i8042 to hid converter.

Environment:

    Kernel mode

Revision History:

    Jan-98 : created by Kenneth D. Ray

--*/


#include "mouhid.h"
#include <wmistr.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,MouHid_SystemControl)
#pragma alloc_text(PAGE,MouHid_SetWmiDataItem)
#pragma alloc_text(PAGE,MouHid_SetWmiDataBlock)
#pragma alloc_text(PAGE,MouHid_QueryWmiDataBlock)
#pragma alloc_text(PAGE,MouHid_QueryWmiRegInfo)
#endif

#define WMI_PORT_DRIVER_INFORMATION 0

GUID MouHid_PointerPortGuid = POINTER_PORT_WMI_STD_DATA_GUID;

WMIGUIDREGINFO MouHid_WmiGuidList[1] =
{
    {
        &MouHid_PointerPortGuid, 1, 0 // Pointer Port driver information
    }
};

NTSTATUS
MouHid_SystemControl (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++
Routine Description

    We have just received a System Control IRP.

    Assume that this is a WMI IRP and
    call into the WMI system library and let it handle this IRP for us.

--*/
{
    PDEVICE_EXTENSION       deviceExtension;
    SYSCTL_IRP_DISPOSITION disposition;
    NTSTATUS status;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    status = WmiSystemControl(&deviceExtension->WmiLibInfo, 
                                 DeviceObject, 
                                 Irp,
                                 &disposition);
    switch(disposition)
    {
        case IrpProcessed:
        {
            //
            // This irp has been processed and may be completed or pending.
            break;
        }
        
        case IrpNotCompleted:
        {
            //
            // This irp has not been completed, but has been fully processed.
            // we will complete it now
            IoCompleteRequest(Irp, IO_NO_INCREMENT);                
            break;
        }
        
        case IrpForward:
        case IrpNotWmi:
        {
            //
            // This irp is either not a WMI irp or is a WMI irp targetted
            // at a device lower in the stack.
            IoSkipCurrentIrpStackLocation (Irp);
            status = IoCallDriver (deviceExtension->TopOfStack, Irp);
            break;
        }
                                    
        default:
        {
            //
            // We really should never get here, but if we do just forward....
            ASSERT(FALSE);
            IoSkipCurrentIrpStackLocation (Irp);
            status = IoCallDriver (deviceExtension->TopOfStack, Irp);
            break;
        }        
    }
    
    return(status);
}

//
// WMI System Call back functions
//

NTSTATUS
MouHid_SetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION    deviceExtension;
    NTSTATUS status;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    switch(GuidIndex) {
    case WMI_PORT_DRIVER_INFORMATION:

        status = STATUS_WMI_READ_ONLY;
        break;

    default:

        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest(  DeviceObject,
                                  Irp,
                                  status,
                                  0,
                                  IO_NO_INCREMENT);

    return status;
}

NTSTATUS
MouHid_SetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION   deviceExtension;
    NTSTATUS status;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    switch(GuidIndex) {
    case WMI_PORT_DRIVER_INFORMATION:

        status = STATUS_WMI_READ_ONLY;
        break;

    default:

        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest(  DeviceObject,
                                  Irp,
                                  status,
                                  0,
                                  IO_NO_INCREMENT);

    return(status);
}

NTSTATUS
MouHid_QueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG OutBufferSize,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    InstanceCount is the number of instnaces expected to be returned for
        the data block.
            
    InstanceLengthArray is a pointer to an array of ULONG that returns the 
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.        
            
    BufferAvail on has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION          deviceExtension;
    POINTER_PORT_WMI_STD_DATA  data;
    NTSTATUS    status;
    ULONG       size = 0;

    //
    // Only ever registers 1 instance per guid
    ASSERT((InstanceIndex == 0) &&
           (InstanceCount == 1));
    
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    switch (GuidIndex) {
    case WMI_PORT_DRIVER_INFORMATION:

        size = sizeof (data);

        if (OutBufferSize < size) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        RtlZeroMemory(&data,
                      size
                      );
                     
        data.ConnectorType = POINTER_PORT_WMI_STD_USB;
        data.DataQueueSize = deviceExtension->Attributes.InputDataQueueLength;
        data.ErrorCount = 0;
        data.Buttons = deviceExtension->Attributes.NumberOfButtons;

        * (PPOINTER_PORT_WMI_STD_DATA) Buffer = data;
        *InstanceLengthArray = size;
        status = STATUS_SUCCESS;

        break;

    default:

        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest(  DeviceObject,
                                  Irp,
                                  status,
                                  size,
                                  IO_NO_INCREMENT);
    return status;
}

NTSTATUS
MouHid_QueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo     
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve the list of
    guids or data blocks that the driver wants to register with WMI. This
    routine may not pend or block. Driver should NOT call
    ClassWmiCompleteRequest.

Arguments:

    DeviceObject is the device whose data block is being queried

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver

    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.
        
    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in 
        *RegFlags.

Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    
    deviceExtension = DeviceObject->DeviceExtension;
    
    *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
    *RegistryPath = &Globals.RegistryPath;
    *Pdo = deviceExtension->PDO;
    
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\inport\sources.inc ===
MAJORCOMP=ntos
MINORCOMP=dd

TARGETNAME=inport
TARGETPATH=obj
TARGETTYPE=DRIVER

INCLUDES=..\inc;..\..\inc

SOURCES=..\inplog.mc

C_DEFINES=-DWINDOWS_FE -I.. -I..\i386
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\inport\i386\inpcfg.h ===
/*++

Copyright (c) 1989, 1990, 1991, 1992, 1993  Microsoft Corporation

Module Name:

    inpcfg.h

Abstract:

    These are the machine-dependent configuration constants that are used in 
    the Microsoft InPort mouse port driver.

Revision History:

--*/

#ifndef _INPCFG_
#define _INPCFG_

//
// Define the interrupt-related configuration constants.
//

#ifdef i386
#define INPORT_INTERFACE_TYPE      Isa
#define INPORT_INTERRUPT_MODE      Latched
#define INPORT_INTERRUPT_SHARE     FALSE
#else
#define INPORT_INTERFACE_TYPE      Isa
#define INPORT_INTERRUPT_MODE      LevelSensitive
#define INPORT_INTERRUPT_SHARE     TRUE
#endif

#define INPORT_BUS_NUMBER       0

#ifdef i386
#define INPORT_FLOATING_SAVE FALSE
#else
#define INPORT_FLOATING_SAVE TRUE
#endif

#if defined(NEC_98)
#define MOUSE_VECTOR            13
#define MOUSE_IRQL              MOUSE_VECTOR
#define INPORT_PHYSICAL_BASE    0x7fd9
#else // defined(NEC_98)
#define MOUSE_VECTOR            9
#define MOUSE_IRQL              MOUSE_VECTOR
#define INPORT_PHYSICAL_BASE    0x23C
#endif // defined(NEC_98)
#define INPORT_REGISTER_LENGTH  4
#define INPORT_REGISTER_SHARE   FALSE
#define INPORT_PORT_TYPE        CM_RESOURCE_PORT_IO

//
// Define the default number of entries in the input data queue.
//

#define DATA_QUEUE_SIZE    100

#endif // _INPCFG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\inport\i386\inport.h ===
/*++

Copyright (c) 1989, 1990, 1991, 1992, 1993  Microsoft Corporation

Module Name:

    inport.h

Abstract:

    These are the structures and defines that are used in the
    Microsoft Inport mouse port driver.

Revision History:

--*/

#ifndef _INPORT_
#define _INPORT_

#include "ntddk.h"
#include <ntddmou.h>
#include "kbdmou.h"
#include "inpcfg.h"
#include "wmilib.h"


#define INP_POOL_TAG (ULONG) 'tpnI'  // will get reversed
#undef ExAllocatePool
#define ExAllocatePool(type, size) \
            ExAllocatePoolWithTag (type, size, INP_POOL_TAG)

//
// Default number of buttons and sample rate for the Inport mouse.
//

#if defined(NEC_98)
#define MOUSE_NUMBER_OF_BUTTONS            2
#define PC98_MOUSE_SAMPLE_RATE_120HZ     120
#else // defined(NEC_98)
#define MOUSE_NUMBER_OF_BUTTONS     2
#define MOUSE_SAMPLE_RATE_50HZ      50
#endif // defined(NEC_98)

//
// Define the Inport chip reset value.
//

#define INPORT_RESET 0x80

//
// Define the data registers (pointed to by the Inport address register).
//

#define INPORT_DATA_REGISTER_1 1
#define INPORT_DATA_REGISTER_2 2

//
// Define the Inport identification register and the chip code.
//

#define INPORT_ID_REGISTER 2
#define INPORT_ID_CODE     0xDE

//
// Define the Inport mouse status register and the status bits.
//

#if defined(NEC_98)
#define INPORT_STATUS_BUTTON3         0x20 // Right Button
#define INPORT_STATUS_BUTTON1         0x80 // Left Button
#else // defined(NEC_98)
#define INPORT_STATUS_REGISTER         0
#define INPORT_STATUS_BUTTON3          0x01
#define INPORT_STATUS_BUTTON2          0x02
#define INPORT_STATUS_BUTTON1          0x04
#define INPORT_STATUS_MOVEMENT         0x40
#endif // defined(NEC_98)

//
// Define the Inport mouse mode register and mode bits.
//

#define INPORT_MODE_REGISTER           7
#define INPORT_MODE_0                  0x00 // 0 HZ - INTR = 0
#if defined(NEC_98)
#define PC98_MODE_15HZ                 0x03
#define PC98_MODE_30HZ                 0x02
#define PC98_MODE_60HZ                 0x01
#define PC98_MODE_120HZ                0x00
#define PC98_EVENT_MODE_60HZ           0x03
#define PC98_EVENT_MODE_120HZ          0x02
#define PC98_EVENT_MODE_240HZ          0x01
#define PC98_EVENT_MODE_400HZ          0x00
#define INPORT_MODE_1                  0x06 // 0 HZ - INTR = 1
#define INPORT_DATA_INTERRUPT_ENABLE   0x08
#define INPORT_TIMER_INTERRUPT_ENABLE  0x10
#define INPORT_MODE_HOLD               0x20
#define INPORT_MODE_QUADRATURE         0x00
#else // defined(NEC_98)
#define INPORT_MODE_30HZ               0x01
#define INPORT_MODE_50HZ               0x02
#define INPORT_MODE_100HZ              0x03
#define INPORT_MODE_200HZ              0x04
#define INPORT_MODE_1                  0x06 // 0 HZ - INTR = 1
#define INPORT_DATA_INTERRUPT_ENABLE   0x08
#define INPORT_TIMER_INTERRUPT_ENABLE  0x10
#define INPORT_MODE_HOLD               0x20
#define INPORT_MODE_QUADRATURE         0x00

#endif // defined(NEC_98)
#if defined(NEC_98)
#define PC98_EOI                       0x20
#define PC98_WriteModePort             0x06
#define PC98_WritePortC1               0x06
#define PC98_WritePortC2               0x04
#define PC98_ReadPortB                 0x02
#define PC98_ReadPortA                 0x00

#define PC98_WriteTimerPort            0xBFDB

#define PC98_PicMasterPort             0x02
#define PC98_PicSlavePort              0x0A
#define PC98_AckMasterPort             0x00
#define PC98_AckSlavePort              0x08
#define PC98_PicMask_INT2              0x40        //0100 0000B
#define PC98_PicMask_INT6              0x20        //0010 0000B
#define PC98_VectorINT2                0x06
#define PC98_VectorINT6                0x13

#define PC98_X_ReadCommandLow          0x90
#define PC98_X_ReadCommandHi           0xB0
#define PC98_Y_ReadCommandLow          0xD0
#define PC98_Y_ReadCommandHi           0xF0
#define PC98_TimerIntDisable           0x10
#define PC98_TimerIntEnable            0x80
#define PC98_MouseEnable               0x08
#define PC98_MouseDisable              0x09
#define PC98_InitializeCommand         0x93
#define PC98_MOUSE_RIGHT_BUTTON        0x20
#define PC98_MOUSE_LEFT_BUTTON         0x80

#define PC98_MOUSE_INT_SHARE_CHECK_PORT 0x869
#define PC98_MOUSE_INT_SERVICE          0x80

#define PC98_ConfigurationPort         0x0411
#define PC98_ConfigurationDataPort     0x0413
#define PC98_EventIntPort              0x63
#define PC98_EventIntMode              0x01

typedef struct _CONFIG_ROM_FLAG5{
    UCHAR Reserved    : 5;
    UCHAR EventMouse  : 1;
    UCHAR Reserved1   : 2;
} ROM_FLAG5, *PROM_FLAG5;

typedef struct _CONFIGURATION_DATA{
    UCHAR Reserved[40];
    UCHAR SystemInfo[512];
    UCHAR COM_ID[2];
    UCHAR Reserved1[15];
    ROM_FLAG5 EventMouseID;
    UCHAR Reserved2[110];
} CONFIGURATION_DATA, *PCONFIGURATION_DATA;

#endif // defined(NEC_98)
//
// Inport mouse configuration information.
//

typedef struct _INPORT_CONFIGURATION_INFORMATION {

    //
    // Bus interface type.
    //

    INTERFACE_TYPE InterfaceType;

    //
    // Bus Number.
    //

    ULONG BusNumber;

    //
    // The port/register resources used by this device.
    //

#if defined(NEC_98)
    CM_PARTIAL_RESOURCE_DESCRIPTOR PortList[8];
#else // defined(NEC_98)
    CM_PARTIAL_RESOURCE_DESCRIPTOR PortList[1];
#endif // defined(NEC_98)
    ULONG PortListCount;

    //
    // Interrupt resources.
    //

    CM_PARTIAL_RESOURCE_DESCRIPTOR MouseInterrupt;

    //
    // The mapped address for the set of this device's registers.
    //

    PUCHAR DeviceRegisters[1];

    //
    // Set at intialization to indicate that the base register
    // address must be unmapped when the driver is unloaded.
    //

    BOOLEAN UnmapRegistersRequired;

    //
    // Flag that indicates whether floating point context should be saved.
    //

    BOOLEAN FloatingSave;

    //
    // Mouse attributes.
    //

    MOUSE_ATTRIBUTES MouseAttributes;

    //
    // Inport mode register Hz specifier for mouse interrupts.
    //

    UCHAR HzMode;

} INPORT_CONFIGURATION_INFORMATION, *PINPORT_CONFIGURATION_INFORMATION;

//
// Port device extension.
//

typedef struct _DEVICE_EXTENSION {

    //
    // Port configuration information.
    //
    INPORT_CONFIGURATION_INFORMATION Configuration;

    //
    // Remove Lock object to protect IRP_MN_REMOVE_DEVICE
    //
    IO_REMOVE_LOCK RemoveLock;

    //
    // Reference count for number of mouse enables.
    //
    LONG MouseEnableCount;

    //
    // Pointer to the device object.
    //
    PDEVICE_OBJECT Self;

    //
    // Pointer the PDO of this stack
    //
    PDEVICE_OBJECT PDO;

    //
    // Pointer to the device object directly below inport
    //
    PDEVICE_OBJECT TopOfStack;

    //
    // WMI lib info
    //
    WMILIB_CONTEXT WmiLibInfo;

    //
    // Mouse class connection data.
    //
    CONNECT_DATA ConnectData;

    //
    // Number of input data items currently in the mouse InputData queue.
    //
    ULONG InputCount;

    //
    // Start of the port mouse input data queue (really a circular buffer).
    //
    PMOUSE_INPUT_DATA InputData;

    //
    // Insertion pointer for mouse InputData.
    //
    PMOUSE_INPUT_DATA DataIn;

    //
    // Removal pointer for mouse InputData.
    //
    PMOUSE_INPUT_DATA DataOut;

    //
    // Points one input packet past the end of the InputData buffer.
    //
    PMOUSE_INPUT_DATA DataEnd;

    //
    // Current mouse input packet.
    //
    MOUSE_INPUT_DATA CurrentInput;

    //
    // Previous mouse button state.
    //
    UCHAR PreviousButtons;

    //
    // Pointer to interrupt object.
    //
    PKINTERRUPT InterruptObject;

    //
    // Mouse ISR DPC queue.
    //
    KDPC IsrDpc;

    //
    // Mouse ISR DPC recall queue.
    //
    KDPC IsrDpcRetry;

    //
    // Used by the ISR and the ISR DPC (in InpDpcVariableOperation calls)
    // to control processing by the ISR DPC.
    //
    LONG DpcInterlockVariable;

    //
    // Spinlock used to protect the DPC interlock variable.
    //
    KSPIN_LOCK SpinLock;

    //
    // Timer used to retry the ISR DPC routine when the class
    // driver is unable to consume all the port driver's data.
    //
    KTIMER DataConsumptionTimer;

    //
    // DPC queue for logging overrun and internal driver errors.
    //

    KDPC ErrorLogDpc;

    //
    // Request sequence number (used for error logging).
    //

    ULONG SequenceNumber;

    //
    // Indicates which pointer port device this driver created (UnitId
    // is the suffix appended to the pointer port basename for the
    // call to IoCreateDevice).
    //
    USHORT UnitId;

    //
    // Indicates whether it is okay to log overflow errors.
    //
    BOOLEAN OkayToLogOverflow;

    //
    // PnP State of the device
    //
    BOOLEAN Started, Removed, Stopped;

#if defined(NEC_98)
    //
    // Currect power state that the device is in
    //
    DEVICE_POWER_STATE PowerState;

#endif // defined(NEC_98)
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

typedef struct _GLOBALS {
    UNICODE_STRING RegistryPath;
#if defined(NEC_98)
    PDEVICE_OBJECT DeviceObject;
#endif // defined(NEC_98)
} GLOBALS;
extern GLOBALS Globals;

//
// Define the port Get/SetDataQueuePointer context structures.
//

typedef struct _GET_DATA_POINTER_CONTEXT {
    IN PDEVICE_EXTENSION DeviceExtension;
    OUT PVOID DataIn;
    OUT PVOID DataOut;
    OUT ULONG InputCount;
} GET_DATA_POINTER_CONTEXT, *PGET_DATA_POINTER_CONTEXT;

typedef struct _SET_DATA_POINTER_CONTEXT {
    IN PDEVICE_EXTENSION DeviceExtension;
    IN ULONG InputCount;
    IN PVOID DataOut;
} SET_DATA_POINTER_CONTEXT, *PSET_DATA_POINTER_CONTEXT;

//
// Define the context structure and operations for InpDpcVariableOperation.
//

typedef enum _OPERATION_TYPE {
        IncrementOperation,
        DecrementOperation,
        WriteOperation,
        ReadOperation
} OPERATION_TYPE;

typedef struct _VARIABLE_OPERATION_CONTEXT {
    IN PLONG VariableAddress;
    IN OPERATION_TYPE Operation;
    IN OUT PLONG NewValue;
} VARIABLE_OPERATION_CONTEXT, *PVARIABLE_OPERATION_CONTEXT;

//
// Function prototypes.
//


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
InportAddDevice (
    IN PDRIVER_OBJECT   Driver,
    IN PDEVICE_OBJECT   PDO
    );

VOID
InportErrorLogDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
InportFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
InportInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
InportInterruptService(
    IN PKINTERRUPT Interrupt,
    IN PVOID Context
    );

VOID
InportIsrDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
InpStartDevice(
    IN OUT PDEVICE_EXTENSION DeviceExtension,
    IN PCM_RESOURCE_LIST ResourceList
    );

NTSTATUS
InportPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
InportPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
InportCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
InportClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
InportStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
InportSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
InportSetWmiDataItem(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            DataItemId,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    );

NTSTATUS
InportSetWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    );

NTSTATUS
InportQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );

NTSTATUS
InportQueryWmiRegInfo(
    IN PDEVICE_OBJECT   DeviceObject,
    OUT PULONG          RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    );

extern WMIGUIDREGINFO WmiGuidList[1];

VOID
InportUnload(
    IN PDRIVER_OBJECT DriverObject
    );

#if DBG
VOID
InpDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );
#define InpPrint(x) InpDebugPrint x
extern ULONG InportDebug;
#else
#define InpPrint(x)
#endif

VOID
InpDisableInterrupts(
    IN PVOID Context
    );

VOID
InpDpcVariableOperation(
    IN  PVOID Context
    );

VOID
InpEnableInterrupts(
    IN PVOID Context
    );

VOID
InpGetDataQueuePointer(
    IN PVOID Context
    );

VOID
InpInitializeDataQueue(
    IN PVOID Context
    );

NTSTATUS
InpInitializeHardware(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
InpServiceParameters(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PUNICODE_STRING RegistryPath
    );

VOID
InpSetDataQueuePointer(
    IN PVOID Context
    );

BOOLEAN
InpWriteDataToQueue(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PMOUSE_INPUT_DATA InputData
    );

VOID
InpLogError(
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS ErrorCode,
    IN ULONG UniqueErrorValue,
    IN NTSTATUS FinalStatus,
    IN PULONG DumpData,
    IN ULONG DumpCount
    );

NTSTATUS
InpSendIrpSynchronously (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#if defined(NEC_98)
BOOLEAN
InportInterruptServiceDummy(
    IN PKINTERRUPT Interrupt,
    IN PDEVICE_OBJECT DeviceObject
    );
ULONG
QueryEventMode(
    IN OUT VOID
    );

// Hibenation
NTSTATUS
InportPowerUpToD0Complete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
InportReinitializeHardware(
    PWORK_QUEUE_ITEM Item
    );
#else

//
// Default values for hardware
//
#define INP_DEF_PORT		0x023c //0x0378
#define INP_DEF_PORT_SPAN	4 
#define INP_DEF_IRQ			5 // Jumper dependent!!!!
#define INP_DEF_VECTOR		5 // Jumper dependent!!!!

VOID
InpFilterResourceRequirements(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
InpFindResourcesCallout(
    IN PVOID                        Context,
    IN PUNICODE_STRING              PathName,
    IN INTERFACE_TYPE               BusType,
    IN ULONG                        BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE           ControllerType,
    IN ULONG                        ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE           PeripheralType,
    IN ULONG                        PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    );

#endif // defined(NEC_98)
#endif // _INPORT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\inport\i386\inpcmn.c ===
#if defined(i386)

/*++

Copyright (c) 1989, 1990, 1991, 1992, 1993  Microsoft Corporation

Module Name:

    inpcmn.c

Abstract:

    The common portions of the Microsoft InPort mouse port driver.
    This file should not require modification to support new mice 
    that are similar to the InPort mouse.

Environment:

    Kernel mode only.

Notes:

    NOTES:  (Future/outstanding issues)

    - Powerfail not implemented.

    - IOCTL_INTERNAL_MOUSE_DISCONNECT has not been implemented.  It's not
      needed until the class unload routine is implemented. Right now, 
      we don't want to allow the mouse class driver to unload.

    - Consolidate duplicate code, where possible and appropriate.

Revision History:

--*/

#include "stdarg.h"
#include "stdio.h"
#include "string.h"
#include "ntddk.h"
#include "inport.h"
#include "inplog.h"

//
// Declare the global debug flag for this driver.
//

#if DBG
ULONG InportDebug = 2;
#endif


VOID
InportErrorLogDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL to log errors that are
    discovered at IRQL > DISPATCH_LEVEL (e.g., in the ISR routine or
    in a routine that is executed via KeSynchronizeExecution).  There
    is not necessarily a current request associated with this condition.

Arguments:

    Dpc - Pointer to the DPC object.

    DeviceObject - Pointer to the device object.

    Irp - Not used.

    Context - Indicates type of error to log.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION deviceExtension;
    PIO_ERROR_LOG_PACKET errorLogEntry;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(Irp);

    InpPrint((2, "INPORT-InportErrorLogDpc: enter\n"));
   
    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Log an error packet.
    //

    errorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
                                              DeviceObject,
                                              sizeof(IO_ERROR_LOG_PACKET)
                                              + (2 * sizeof(ULONG))
                                              );
    if (errorLogEntry != NULL) {

        errorLogEntry->DumpDataSize = 2 * sizeof(ULONG);

        if ((ULONG) Context == INPORT_MOU_BUFFER_OVERFLOW) {
            errorLogEntry->UniqueErrorValue = INPORT_ERROR_VALUE_BASE + 210;
            errorLogEntry->DumpData[0] = sizeof(MOUSE_INPUT_DATA);
            errorLogEntry->DumpData[1] = 
                deviceExtension->Configuration.MouseAttributes.InputDataQueueLength;
        } else {
            errorLogEntry->UniqueErrorValue = INPORT_ERROR_VALUE_BASE + 220;
            errorLogEntry->DumpData[0] = 0;
            errorLogEntry->DumpData[1] = 0;
        }

        errorLogEntry->ErrorCode = (ULONG) Context;
        errorLogEntry->SequenceNumber = 0;
        errorLogEntry->MajorFunctionCode = 0;
        errorLogEntry->IoControlCode = 0;
        errorLogEntry->RetryCount = 0;
        errorLogEntry->FinalStatus = 0;

        IoWriteErrorLogEntry(errorLogEntry);
    }

    InpPrint((2, "INPORT-InportErrorLogDpc: exit\n"));

}

NTSTATUS
InportFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(Irp);

    InpPrint((2,"INPORT-InportFlush: enter\n"));
    InpPrint((2,"INPORT-InportFlush: exit\n"));

    return(STATUS_NOT_IMPLEMENTED);
}

NTSTATUS
InportInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for internal device control requests.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{

    PIO_STACK_LOCATION irpSp;
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS status;

    InpPrint((2,"INPORT-InportInternalDeviceControl: enter\n"));

    //
    // Get a pointer to the device extension.
    //

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Initialize the returned Information field.
    //

    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Case on the device control subfunction that is being performed by the
    // requestor.
    //

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {

        //
        // Connect a mouse class device driver to the port driver.
        //

        case IOCTL_INTERNAL_MOUSE_CONNECT:

            InpPrint((
                2,
                "INPORT-InportInternalDeviceControl: mouse connect\n"
                ));

            //
            // Only allow one connection.
            //
            //
            if (deviceExtension->ConnectData.ClassService != NULL) {

                InpPrint((
                    2,
                    "INPORT-InportInternalDeviceControl: error - already connected\n"
                    ));

                status = STATUS_SHARING_VIOLATION;
                break;

            }
            else if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
                    sizeof(CONNECT_DATA)) {

                InpPrint((
                    2,
                    "INPORT-InportInternalDeviceControl: error - invalid buffer length\n"
                    ));

                status = STATUS_INVALID_PARAMETER;
                break;
            }

            //
            // Copy the connection parameters to the device extension.
            //
            deviceExtension->ConnectData =
                *((PCONNECT_DATA) (irpSp->Parameters.DeviceIoControl.Type3InputBuffer));

            //
            // Set the completion status.
            //
            status = STATUS_SUCCESS;
            break;

        //
        // Disconnect a mouse class device driver from the port driver.
        //
        // NOTE: Not implemented.
        //

        case IOCTL_INTERNAL_MOUSE_DISCONNECT:

            InpPrint((
                2,
                "INPORT-InportInternalDeviceControl: mouse disconnect\n"
                ));

            //
            // Perform a mouse interrupt disable call.
            //

            //
            // Clear the connection parameters in the device extension.
            // NOTE:  Must synchronize this with the mouse ISR.
            //
            //
            //deviceExtension->ConnectData.ClassDeviceObject =
            //    Null;
            //deviceExtension->ConnectData.ClassService =
            //    Null;

            //
            // Set the completion status.
            //

            status = STATUS_NOT_IMPLEMENTED;
            break;

// obsolete ioctls
#if 0
        //
        // Enable mouse interrupts (mark the request pending and handle
        // it in StartIo).
        //
        case IOCTL_INTERNAL_MOUSE_ENABLE:

            InpPrint((
                2,
                "INPORT-InportInternalDeviceControl: mouse enable\n"
                ));

            status = STATUS_PENDING;
            break;

        //
        // Disable mouse interrupts (mark the request pending and handle
        // it in StartIo).
        //

        case IOCTL_INTERNAL_MOUSE_DISABLE:

            InpPrint((
                2,
                "INPORT-InportInternalDeviceControl: mouse disable\n"
                ));

            status = STATUS_PENDING;
            break;
#endif

        //
        // Query the mouse attributes.  First check for adequate buffer 
        // length.  Then, copy the mouse attributes from the device 
        // extension to the output buffer. 
        //

        case IOCTL_MOUSE_QUERY_ATTRIBUTES:

            InpPrint((
                2,
                "INPORT-InportInternalDeviceControl: mouse query attributes\n"
                ));

            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(MOUSE_ATTRIBUTES)) {
                status = STATUS_BUFFER_TOO_SMALL;
            } else {

                //
                // Copy the attributes from the DeviceExtension to the
                // buffer.
                //

                *(PMOUSE_ATTRIBUTES) Irp->AssociatedIrp.SystemBuffer =
                    deviceExtension->Configuration.MouseAttributes;

                Irp->IoStatus.Information = sizeof(MOUSE_ATTRIBUTES);
                status = STATUS_SUCCESS;
            }

            break;

        default:

            InpPrint((
                2,
                "INPORT-InportInternalDeviceControl: INVALID REQUEST\n"
                ));

            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    Irp->IoStatus.Status = status;
    if (status == STATUS_PENDING) {
        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject, Irp, (PULONG)NULL, NULL);
    } else {
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    InpPrint((2,"INPORT-InportInternalDeviceControl: exit\n"));

    return(status);
}

VOID
InportIsrDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL to finish processing
    mouse interrupts.  It is queued in the mouse ISR.  The real
    work is done via a callback to the connected mouse class driver.

Arguments:

    Dpc - Pointer to the DPC object.

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the Irp.

    Context - Not used.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION deviceExtension;
    GET_DATA_POINTER_CONTEXT getPointerContext;
    SET_DATA_POINTER_CONTEXT setPointerContext;
    VARIABLE_OPERATION_CONTEXT operationContext;
    PVOID classService;
    PVOID classDeviceObject;
    LONG interlockedResult;
    BOOLEAN moreDpcProcessing;
    ULONG dataNotConsumed = 0;
    ULONG inputDataConsumed = 0; 
    LARGE_INTEGER deltaTime;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(Irp);
    UNREFERENCED_PARAMETER(Context);

    InpPrint((3, "INPORT-InportIsrDpc: enter\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // Use DpcInterlockVariable to determine whether the DPC is running
    // concurrently on another processor.  We only want one instantiation
    // of the DPC to actually do any work.  DpcInterlockVariable is -1
    // when no DPC is executing.  We increment it, and if the result is
    // zero then the current instantiation is the only one executing, and it
    // is okay to proceed.  Otherwise, we just return.
    //
    //

    operationContext.VariableAddress = 
        &deviceExtension->DpcInterlockVariable;
    operationContext.Operation = IncrementOperation;
    operationContext.NewValue = &interlockedResult;

    KeSynchronizeExecution(
            deviceExtension->InterruptObject,
            (PKSYNCHRONIZE_ROUTINE) InpDpcVariableOperation,
            (PVOID) &operationContext
            );

    moreDpcProcessing = (interlockedResult == 0)? TRUE:FALSE;

    while (moreDpcProcessing) {

        dataNotConsumed = 0;
        inputDataConsumed = 0;

        //
        // Get the port InputData queue pointers synchronously.
        //
    
        getPointerContext.DeviceExtension = deviceExtension;
        setPointerContext.DeviceExtension = deviceExtension;
        setPointerContext.InputCount = 0;
    
        KeSynchronizeExecution(
            deviceExtension->InterruptObject,
            (PKSYNCHRONIZE_ROUTINE) InpGetDataQueuePointer,
            (PVOID) &getPointerContext
            );
    
        if (getPointerContext.InputCount != 0) {
        
            //
            // Call the connected class driver's callback ISR with the
            // port InputData queue pointers.  If we have to wrap the queue,
            // break the operation into two pieces, and call the class callback
            // ISR once for each piece.
            //
        
            classDeviceObject =
                deviceExtension->ConnectData.ClassDeviceObject;
            classService =
                deviceExtension->ConnectData.ClassService;
            ASSERT(classService != NULL);
        
            if (getPointerContext.DataOut >= getPointerContext.DataIn) {
        
                //
                // We'll have to wrap the InputData circular buffer.  Call
                // the class callback ISR with the chunk of data starting at 
                // DataOut and ending at the end of the queue.
                //
        
                InpPrint((
                    3, 
                    "INPORT-InportIsrDpc: calling class callback\n"
                    ));
                InpPrint((
                    3,
                    "INPORT-InportIsrDpc: with Start 0x%x and End 0x%x\n",
                    getPointerContext.DataOut,
                    deviceExtension->DataEnd
                    ));
        
                (*(PSERVICE_CALLBACK_ROUTINE) classService)(
                      classDeviceObject,
                      getPointerContext.DataOut,
                      deviceExtension->DataEnd,
                      &inputDataConsumed
                      );
        
                dataNotConsumed = (((PUCHAR)
                    deviceExtension->DataEnd -
                    (PUCHAR) getPointerContext.DataOut) 
                    / sizeof(MOUSE_INPUT_DATA)) - inputDataConsumed;

                InpPrint((
                    3,
                    "INPORT-InportIsrDpc: (Wrap) Call callback consumed %d items, left %d\n",
                    inputDataConsumed,
                    dataNotConsumed
                    ));

                setPointerContext.InputCount += inputDataConsumed;
        
                if (dataNotConsumed) {
                    setPointerContext.DataOut = 
                        ((PUCHAR)getPointerContext.DataOut) + 
                        (inputDataConsumed * sizeof(MOUSE_INPUT_DATA));
                } else {
                    setPointerContext.DataOut =
                        deviceExtension->InputData;
                    getPointerContext.DataOut = setPointerContext.DataOut;
                }
            }
        
            //
            // Call the class callback ISR with data remaining in the queue.
            //
        
            if ((dataNotConsumed == 0) &&
                (inputDataConsumed < getPointerContext.InputCount)){
                InpPrint((
                    3, 
                    "INPORT-InportIsrDpc: calling class callback\n"
                    ));
                InpPrint((
                    3,
                    "INPORT-InportIsrDpc: with Start 0x%x and End 0x%x\n",
                    getPointerContext.DataOut,
                    getPointerContext.DataIn
                    ));
        
                (*(PSERVICE_CALLBACK_ROUTINE) classService)(
                      classDeviceObject,
                      getPointerContext.DataOut,
                      getPointerContext.DataIn,
                      &inputDataConsumed
                      );

                dataNotConsumed = (((PUCHAR) getPointerContext.DataIn - 
                      (PUCHAR) getPointerContext.DataOut)
                      / sizeof(MOUSE_INPUT_DATA)) - inputDataConsumed;
        
                InpPrint((
                    3,
                    "INPORT-InportIsrDpc: Call callback consumed %d items, left %d\n",
                    inputDataConsumed,
                    dataNotConsumed
                    ));

                setPointerContext.DataOut = 
                    ((PUCHAR)getPointerContext.DataOut) +
                    (inputDataConsumed * sizeof(MOUSE_INPUT_DATA));
                setPointerContext.InputCount += inputDataConsumed;

            }
        
            //
            // Update the port InputData queue DataOut pointer and InputCount
            // synchronously.
            //
        
            KeSynchronizeExecution(
                deviceExtension->InterruptObject,
                (PKSYNCHRONIZE_ROUTINE) InpSetDataQueuePointer,
                (PVOID) &setPointerContext
                );
        
        }
        
        if (dataNotConsumed) {

            //
            // The class driver was unable to consume all the data.  
            // Reset the interlocked variable to -1.  We do not want
            // to attempt to move more data to the class driver at this
            // point, because it is already overloaded.  Need to wait a
            // while to give the Raw Input Thread a chance to read some
            // of the data out of the class driver's queue.  We accomplish
            // this "wait" via a timer.
            // 

            InpPrint((3, "INPORT-InportIsrDpc: set timer in DPC\n"));

            operationContext.Operation = WriteOperation;
            interlockedResult = -1;
            operationContext.NewValue = &interlockedResult;
        
            KeSynchronizeExecution(
                    deviceExtension->InterruptObject,
                    (PKSYNCHRONIZE_ROUTINE) InpDpcVariableOperation,
                    (PVOID) &operationContext
                    );

            deltaTime.LowPart = (ULONG)(-10 * 1000 * 1000);
            deltaTime.HighPart = -1;

            (VOID) KeSetTimer(
                       &deviceExtension->DataConsumptionTimer,
                       deltaTime,
                       &deviceExtension->IsrDpcRetry
                       );

            moreDpcProcessing = FALSE; 

        } else {
    
            //
            // Decrement DpcInterlockVariable.  If the result goes negative,
            // then we're all finished processing the DPC.  Otherwise, either
            // the ISR incremented DpcInterlockVariable because it has more
            // work for the ISR DPC to do, or a concurrent DPC executed on 
            // some processor while the current DPC was running (the 
            // concurrent DPC wouldn't have done any work).  Make sure that 
            // the current DPC handles any extra work that is ready to be
            // done.
            //

            operationContext.Operation = DecrementOperation;
            operationContext.NewValue = &interlockedResult;
        
            KeSynchronizeExecution(
                    deviceExtension->InterruptObject,
                    (PKSYNCHRONIZE_ROUTINE) InpDpcVariableOperation,
                    (PVOID) &operationContext
                    );

            if (interlockedResult != -1) {

                //
                // The interlocked variable is still greater than or equal to
                // zero. Reset it to zero, so that we execute the loop one
                // more time (assuming no more DPCs execute and bump the
                // variable up again).
                //

                operationContext.Operation = WriteOperation;
                interlockedResult = 0;
                operationContext.NewValue = &interlockedResult;
        
                KeSynchronizeExecution(
                    deviceExtension->InterruptObject,
                    (PKSYNCHRONIZE_ROUTINE) InpDpcVariableOperation,
                    (PVOID) &operationContext
                    );

                InpPrint((3, "INPORT-InportIsrDpc: loop in DPC\n"));
            } else {
                moreDpcProcessing = FALSE;
            }
        }
    }

    InpPrint((3, "INPORT-InportIsrDpc: exit\n"));

}

NTSTATUS
InportCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    NTSTATUS            status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension;

    InpPrint((2, "INPORT-InportCreate: enter\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    if (NULL == deviceExtension->ConnectData.ClassService) {
        //
        // No Connection yet.  How can we be enabled?
        //
        InpPrint((3,"INPORT-InportCreate: not enabled!\n"));
        status = STATUS_INVALID_DEVICE_STATE;
    }
    else {
        InpEnableInterrupts(deviceExtension);
    }

    //
    // No need to call the lower driver (the root bus) because it only handles
    // Power and PnP Irps
    //
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    InpPrint((2, "INPORT-InportCreate: exit\n"));

    return status;
}

NTSTATUS
InportClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for create/open and close requests.
    These requests complete successfully.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    UNREFERENCED_PARAMETER(DeviceObject);

    InpPrint((2,"INPORT-InportClose: enter\n"));

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    InpPrint((2,"INPORT-InportClose: exit\n"));

    return STATUS_SUCCESS;
} 

VOID
InportStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine starts an I/O operation for the device.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION deviceExtension;
    PIO_STACK_LOCATION irpSp;

    InpPrint((2, "INPORT-InportStartIo: enter\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Bump the error log sequence number.
    //

    deviceExtension->SequenceNumber += 1;

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // We know we got here with an internal device control request.  Switch
    // on IoControlCode.
    //

    switch(irpSp->Parameters.DeviceIoControl.IoControlCode) {

        //
        // Enable mouse interrupts, by calling InpEnableInterrupts
        // synchronously.
        //

        case IOCTL_INTERNAL_MOUSE_ENABLE:

            KeSynchronizeExecution(
                deviceExtension->InterruptObject,
                (PKSYNCHRONIZE_ROUTINE) InpEnableInterrupts,
                (PVOID) deviceExtension
                );

            InpPrint((
                2, 
                "INPORT-InportStartIo: mouse enable (count %d)\n",
                deviceExtension->MouseEnableCount
                ));

            Irp->IoStatus.Status = STATUS_SUCCESS;

            //
            // Complete the request.
            //

            IoStartNextPacket(DeviceObject, FALSE);
            IoCompleteRequest(Irp, IO_MOUSE_INCREMENT);

            break;

        //
        // Disable mouse interrupts, by calling InpDisableInterrupts
        // synchronously.
        //

        case IOCTL_INTERNAL_MOUSE_DISABLE:

            InpPrint((2, "INPORT-InportStartIo: mouse disable"));

            if (deviceExtension->MouseEnableCount == 0) {

                //
                // Mouse already disabled.
                //

                InpPrint((2, " - error\n"));

                Irp->IoStatus.Status = STATUS_DEVICE_DATA_ERROR;

            } else {

                //
                // Disable mouse by calling InpDisableInterrupts.
                //

                KeSynchronizeExecution(
                    deviceExtension->InterruptObject,
                    (PKSYNCHRONIZE_ROUTINE) InpDisableInterrupts,
                    (PVOID) deviceExtension
                    );

                InpPrint((
                    2, 
                    " (count %d)\n",
                    deviceExtension->MouseEnableCount
                    ));

                Irp->IoStatus.Status = STATUS_SUCCESS;
            }

            //
            // Complete the request.
            //

            IoStartNextPacket(DeviceObject, FALSE);
            IoCompleteRequest(Irp, IO_MOUSE_INCREMENT);

            break;

        default:

            InpPrint((2, "INPORT-InportStartIo: INVALID REQUEST\n"));

            //
            // Log an internal error.  Note that we're calling the
            // error log DPC routine directly, rather than duplicating
            // code.
            //

            InportErrorLogDpc(
                (PKDPC) NULL,
                DeviceObject,
                Irp,
                (PVOID) (ULONG) INPORT_INVALID_STARTIO_REQUEST
                );

            ASSERT(FALSE);
            break;
    }

    InpPrint((2, "INPORT-InportStartIo: exit\n"));

    return;
}

#if DBG
VOID
InpDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print routine.

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None.

--*/

{
    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= InportDebug) {

        char buffer[128];

        (VOID) vsprintf(buffer, DebugMessage, ap);

        DbgPrint(buffer);
    }

    va_end(ap);

}
#endif

VOID
InpDpcVariableOperation(
    IN  PVOID Context
    )

/*++

Routine Description:

    This routine is called synchronously by the ISR DPC to perform an 
    operation on the InterlockedDpcVariable.  The operations that can be 
    performed include increment, decrement, write, and read.  The ISR 
    itself reads and writes the InterlockedDpcVariable without calling this 
    routine.  

Arguments:

    Context - Pointer to a structure containing the address of the variable
        to be operated on, the operation to perform, and the address at
        which to copy the resulting value of the variable (the latter is also
        used to pass in the value to write to the variable, on a write
        operation).

Return Value:

    None.

--*/

{
    PVARIABLE_OPERATION_CONTEXT operationContext = Context;

    InpPrint((3,"INPORT-InpDpcVariableOperation: enter\n"));
    InpPrint((
        3,
        "\tPerforming %s at 0x%x (current value 0x%x)\n",
        (operationContext->Operation == IncrementOperation)? "increment":
        (operationContext->Operation == DecrementOperation)? "decrement":
        (operationContext->Operation == WriteOperation)?     "write":
        (operationContext->Operation == ReadOperation)?      "read":"",
        operationContext->VariableAddress,
        *(operationContext->VariableAddress)
        ));

    //
    // Perform the specified operation at the specified address.
    //

    switch(operationContext->Operation) {
        case IncrementOperation:
            *(operationContext->VariableAddress) += 1;
            break;
        case DecrementOperation:
            *(operationContext->VariableAddress) -= 1;
            break;
        case ReadOperation:
            break;
        case WriteOperation:
            InpPrint((
                3,
                "\tWriting 0x%x\n",
                *(operationContext->NewValue)
                ));
            *(operationContext->VariableAddress) = 
                *(operationContext->NewValue);
            break;
        default:
            ASSERT(FALSE);
            break;
    }

    *(operationContext->NewValue) = *(operationContext->VariableAddress);

    InpPrint((
        3,
        "INPORT-InpDpcVariableOperation: exit with value 0x%x\n",
        *(operationContext->NewValue)
        ));
}

VOID
InpGetDataQueuePointer(
    IN  PVOID Context
    )

/*++

Routine Description:

    This routine is called synchronously to get the current DataIn and DataOut
    pointers for the port InputData queue.

Arguments:

    Context - Pointer to a structure containing the device extension,
        address at which to store the current DataIn pointer, and the
        address at which to store the current DataOut pointer.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION deviceExtension;

    InpPrint((3,"INPORT-InpGetDataQueuePointer: enter\n"));

    //
    // Get address of device extension.
    //

    deviceExtension = (PDEVICE_EXTENSION)
                      ((PGET_DATA_POINTER_CONTEXT) Context)->DeviceExtension;

    //
    // Get the DataIn and DataOut pointers.
    //

    InpPrint((
        3,
        "INPORT-InpGetDataQueuePointer: DataIn 0x%x, DataOut 0x%x\n",
        deviceExtension->DataIn,
        deviceExtension->DataOut
        ));
    ((PGET_DATA_POINTER_CONTEXT) Context)->DataIn = deviceExtension->DataIn;
    ((PGET_DATA_POINTER_CONTEXT) Context)->DataOut = deviceExtension->DataOut;
    ((PGET_DATA_POINTER_CONTEXT) Context)->InputCount = 
        deviceExtension->InputCount;

    InpPrint((3,"INPORT-InpGetDataQueuePointer: exit\n"));
}

VOID
InpInitializeDataQueue (
    IN PVOID Context
    )

/*++

Routine Description:

    This routine initializes the input data queue.  It is called
    via KeSynchronization, except when called from the initialization routine.

Arguments:

    Context - Pointer to the device extension.

Return Value:

    None.

--*/

{

    PDEVICE_EXTENSION deviceExtension;

    InpPrint((3,"INPORT-InpInitializeDataQueue: enter\n"));

    //
    // Get address of device extension.
    //

    deviceExtension = (PDEVICE_EXTENSION) Context;

    //
    // Initialize the input data queue.
    //

    deviceExtension->InputCount = 0;
    deviceExtension->DataIn = deviceExtension->InputData;
    deviceExtension->DataOut = deviceExtension->InputData;

    deviceExtension->OkayToLogOverflow = TRUE;

    InpPrint((3,"INPORT-InpInitializeDataQueue: exit\n"));

}

VOID
InpSetDataQueuePointer(
    IN  PVOID Context
    )

/*++

Routine Description:

    This routine is called synchronously to set the DataOut pointer
    and InputCount for the port InputData queue.

Arguments:

    Context - Pointer to a structure containing the device extension
        and the new DataOut value for the port InputData queue.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION deviceExtension;

    InpPrint((3,"INPORT-InpSetDataQueuePointer: enter\n"));

    //
    // Get address of device extension.
    //

    deviceExtension = (PDEVICE_EXTENSION)
                      ((PSET_DATA_POINTER_CONTEXT) Context)->DeviceExtension;

    //
    // Set the DataOut pointer.
    //

    InpPrint((
        3,
        "INPORT-InpSetDataQueuePointer: old mouse DataOut 0x%x, InputCount %d\n",
        deviceExtension->DataOut,
        deviceExtension->InputCount
        ));
    deviceExtension->DataOut = ((PSET_DATA_POINTER_CONTEXT) Context)->DataOut;
    deviceExtension->InputCount -=
        ((PSET_DATA_POINTER_CONTEXT) Context)->InputCount;

    if (deviceExtension->InputCount == 0) {

        //
        // Reset the flag that determines whether it is time to log
        // queue overflow errors.  We don't want to log errors too often.
        // Instead, log an error on the first overflow that occurs after
        // the ring buffer has been emptied, and then stop logging errors
        // until it gets cleared out and overflows again.
        //

        InpPrint((
            4,
            "INPORT-InpSetDataQueuePointer: Okay to log overflow\n"
            ));
        deviceExtension->OkayToLogOverflow = TRUE;
    }

    InpPrint((
        3,
        "INPORT-InpSetDataQueuePointer: new mouse DataOut 0x%x, InputCount %d\n",
        deviceExtension->DataOut,
        deviceExtension->InputCount
        ));

    InpPrint((3,"INPORT-InpSetDataQueuePointer: exit\n"));
}

BOOLEAN
InpWriteDataToQueue(
    PDEVICE_EXTENSION DeviceExtension,
    IN PMOUSE_INPUT_DATA InputData
    )

/*++

Routine Description:

    This routine adds input data from the mouse to the InputData queue.

Arguments:

    DeviceExtension - Pointer to the device extension.

    InputData - Pointer to the data to add to the InputData queue.

Return Value:

    Returns TRUE if the data was added, otherwise FALSE.

--*/

{

    InpPrint((3,"INPORT-InpWriteDataToQueue: enter\n"));
    InpPrint((
        3,
        "INPORT-InpWriteDataToQueue: DataIn 0x%x, DataOut 0x%x\n",
        DeviceExtension->DataIn,
        DeviceExtension->DataOut
        ));
    InpPrint((
        3,
        "INPORT-InpWriteDataToQueue: InputCount %d\n",
        DeviceExtension->InputCount
        ));

    //
    // Check for full input data queue.
    //

    if ((DeviceExtension->DataIn == DeviceExtension->DataOut) &&
        (DeviceExtension->InputCount != 0)) {

        //
        // The input data queue is full.  Intentionally ignore
        // the new data.
        //

        InpPrint((1,"INPORT-InpWriteDataToQueue: OVERFLOW\n"));
        return(FALSE);

    } else {
        *(DeviceExtension->DataIn) = *InputData;
        DeviceExtension->InputCount += 1;
        DeviceExtension->DataIn++;
        InpPrint((
            3,
            "INPORT-InpWriteDataToQueue: new InputCount %d\n",
            DeviceExtension->InputCount
            ));
        if (DeviceExtension->DataIn ==
            DeviceExtension->DataEnd) {
            InpPrint((3,"INPORT-InpWriteDataToQueue: wrap buffer\n"));
            DeviceExtension->DataIn = DeviceExtension->InputData;
        }
    }

    InpPrint((3,"INPORT-InpWriteDataToQueue: exit\n"));

    return(TRUE);
}

VOID
InpLogError(
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS ErrorCode,
    IN ULONG UniqueErrorValue,
    IN NTSTATUS FinalStatus,
    IN PULONG DumpData,
    IN ULONG DumpCount
    )

/*++

Routine Description:

    This routine contains common code to write an error log entry.  It is
    called from other routines, to avoid
    duplication of code.  Note that some routines continue to have their
    own error logging code (especially in the case where the error logging
    can be localized and/or the routine has more data because there is
    and IRP).

Arguments:

    DeviceObject - Pointer to the device object.

    ErrorCode - The error code for the error log packet.

    UniqueErrorValue - The unique error value for the error log packet.

    FinalStatus - The final status of the operation for the error log packet.

    DumpData - Pointer to an array of dump data for the error log packet.

    DumpCount - The number of entries in the dump data array.


Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;
    ULONG i;

    errorLogEntry = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry(
                                               DeviceObject,
                                               (UCHAR)
                                               (sizeof(IO_ERROR_LOG_PACKET)
                                               + (DumpCount * sizeof(ULONG)))
                                               );

    if (errorLogEntry != NULL) {

        errorLogEntry->ErrorCode = ErrorCode;
        errorLogEntry->DumpDataSize = (USHORT) (DumpCount * sizeof(ULONG));
        errorLogEntry->SequenceNumber = 0;
        errorLogEntry->MajorFunctionCode = 0;
        errorLogEntry->IoControlCode = 0;
        errorLogEntry->RetryCount = 0;
        errorLogEntry->UniqueErrorValue = UniqueErrorValue;
        errorLogEntry->FinalStatus = FinalStatus;
        for (i = 0; i < DumpCount; i++)
            errorLogEntry->DumpData[i] = DumpData[i];

        IoWriteErrorLogEntry(errorLogEntry);
    }

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\inport\i386\pnppower.c ===
/*++

Copyright (c) 1997    Microsoft Corporation

Module Name:

    pnp.c

Abstract:

    This module contains plug & play code for the inport mouse

Environment:

    Kernel & user mode.

Revision History:

    Feb-1998 :  Initial writing, Doron Holan

--*/

#include "inport.h"
#include "inplog.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, InportAddDevice)
#pragma alloc_text(PAGE, InportPnP)
#endif

NTSTATUS
InportAddDevice (
    IN PDRIVER_OBJECT   Driver,
    IN PDEVICE_OBJECT   PDO
    )
/*++

Routine Description:


Arguments:


Return Value:

    NTSTATUS result code.

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension;
    PDEVICE_OBJECT      device;

    PAGED_CODE();

    status = IoCreateDevice(Driver,
                            sizeof(DEVICE_EXTENSION),
                            NULL, // no name for this Filter DO
                            FILE_DEVICE_INPORT_PORT,
                            0,
                            FALSE,
                            &device);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    deviceExtension = (PDEVICE_EXTENSION) device->DeviceExtension;

    //
    // Initialize the fields.
    //
    RtlZeroMemory(deviceExtension, sizeof(DEVICE_EXTENSION));

    deviceExtension->TopOfStack = IoAttachDeviceToDeviceStack(device, PDO);
    if (deviceExtension->TopOfStack == NULL) {
        PIO_ERROR_LOG_PACKET errorLogEntry;

        //
        // Not good; in only extreme cases will this fail
        //
        errorLogEntry = (PIO_ERROR_LOG_PACKET)
            IoAllocateErrorLogEntry(Driver,
                                    (UCHAR) sizeof(IO_ERROR_LOG_PACKET));

        if (errorLogEntry) {
            errorLogEntry->ErrorCode = INPORT_ATTACH_DEVICE_FAILED;
            errorLogEntry->DumpDataSize = 0;
            errorLogEntry->SequenceNumber = 0;
            errorLogEntry->MajorFunctionCode = 0;
            errorLogEntry->IoControlCode = 0;
            errorLogEntry->RetryCount = 0;
            errorLogEntry->UniqueErrorValue = 0;
            errorLogEntry->FinalStatus =  STATUS_DEVICE_NOT_CONNECTED;

            IoWriteErrorLogEntry(errorLogEntry);
        }

        IoDeleteDevice(device);
        return STATUS_DEVICE_NOT_CONNECTED; 
    }

    ASSERT(deviceExtension->TopOfStack);

    deviceExtension->Self = device;
    deviceExtension->Removed = FALSE;
    deviceExtension->Started = FALSE;
    deviceExtension->UnitId = 0;

    IoInitializeRemoveLock (&deviceExtension->RemoveLock, INP_POOL_TAG, 1, 10);
#if defined(NEC_98)
    deviceExtension->PowerState = PowerDeviceD0;

#endif // defined(NEC_98)
    //
    // Initialize WMI
    //
    deviceExtension->WmiLibInfo.GuidCount = sizeof(WmiGuidList) /
                                            sizeof(WMIGUIDREGINFO);
    deviceExtension->WmiLibInfo.GuidList = WmiGuidList;
    deviceExtension->WmiLibInfo.QueryWmiRegInfo = InportQueryWmiRegInfo;
    deviceExtension->WmiLibInfo.QueryWmiDataBlock = InportQueryWmiDataBlock;
    deviceExtension->WmiLibInfo.SetWmiDataBlock = InportSetWmiDataBlock;
    deviceExtension->WmiLibInfo.SetWmiDataItem = InportSetWmiDataItem;
    deviceExtension->WmiLibInfo.ExecuteWmiMethod = NULL;
    deviceExtension->WmiLibInfo.WmiFunctionControl = NULL;

    IoWMIRegistrationControl(deviceExtension->Self,
                             WMIREG_ACTION_REGISTER
                             );

    deviceExtension->PDO = PDO;

    device->Flags &= ~DO_DEVICE_INITIALIZING;
    device->Flags |= DO_BUFFERED_IO | DO_POWER_PAGABLE;

    return status;
}

BOOLEAN
InpReleaseResourcesEx(
    PVOID Context
    )
{
    PDEVICE_EXTENSION deviceExtension = Context;

    KeRemoveQueueDpc(&deviceExtension->IsrDpc);
    KeRemoveQueueDpc(&deviceExtension->IsrDpcRetry);
    KeRemoveQueueDpc(&deviceExtension->ErrorLogDpc);

//    KeCancelTimer(&deviceExtension->DataConsumptionTimer);

    if (deviceExtension->Configuration.UnmapRegistersRequired) {
        MmUnmapIoSpace(deviceExtension->Configuration.DeviceRegisters[0],
                       deviceExtension->Configuration.PortList[0].u.Port.Length);
    }

    //
    // Clear out the config info.  If we get started again, than it will be filled
    // in again.  If is from a remove, then it is essentially a no-op
    //
    RtlZeroMemory(&deviceExtension->Configuration,
                  sizeof(INPORT_CONFIGURATION_INFORMATION));

    return TRUE;
}

VOID
InpReleaseResources(
    PDEVICE_EXTENSION DeviceExtension
    )
{
    InpPrint((2, "INPORT-InpReleaseResources: Enter\n"));

    if (DeviceExtension->InterruptObject) {
        KeSynchronizeExecution(
            DeviceExtension->InterruptObject,
            InpReleaseResourcesEx,
            (PVOID) DeviceExtension);

        IoDisconnectInterrupt(DeviceExtension->InterruptObject);
        DeviceExtension->InterruptObject = NULL;
    }
    else {
        InpReleaseResourcesEx((PVOID) DeviceExtension);
    }

    InpPrint((2, "INPORT-InpReleaseResources: Exit\n"));
}

NTSTATUS
InpPnPComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
/*++

Routine Description:
    The pnp IRP is in the process of completing.
    signal

Arguments:
    Context set to the device object in question.

--*/
{
    PIO_STACK_LOCATION  stack;
    NTSTATUS            status;
    PKEVENT             event;

    InpPrint((2, "INPORT-InpPnPComplete: Enter\n"));

    status = STATUS_SUCCESS;
    event = (PKEVENT) Context;
    stack = IoGetCurrentIrpStackLocation(Irp);

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    KeSetEvent(event,
               0,
               FALSE);

    InpPrint((2, "INPORT-InpPnPComplete: Exit\n"));
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
InportPnP (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    The plug and play dispatch routines.

    Most of these this filter driver will completely ignore.
    In all cases it must pass on the IRP to the lower driver.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  stack;
    NTSTATUS            status;
    KEVENT              event;

    PAGED_CODE();

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation(Irp);

    status = IoAcquireRemoveLock(&deviceExtension->RemoveLock, Irp);
    if (!NT_SUCCESS(status)) {
        //
        // Someone gave us a pnp irp after a remove.  Unthinkable!
        //
        ASSERT(FALSE);
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    InpPrint((2, "INPORT-InportPnP: Enter (min func=0x%x)\n", stack->MinorFunction));

    switch (stack->MinorFunction) {
    case IRP_MN_START_DEVICE:

#if defined(NEC_98)
        Globals.DeviceObject = (PDEVICE_OBJECT)DeviceObject;
#endif // defined(NEC_98)
        //
        // If we have been started (and not stopped), then just ignore this start
        //
        if (deviceExtension->Started) {
            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver(deviceExtension->TopOfStack, Irp);
            break;
        }

        //
        // Not allowed to touch the hardware until all of the lower DO's have
        // had a chance to look at it
        //
        IoCopyCurrentIrpStackLocationToNext(Irp);
        KeInitializeEvent(&event,
                          NotificationEvent,
                          FALSE
                          );

        IoSetCompletionRoutine(Irp,
                               (PIO_COMPLETION_ROUTINE) InpPnPComplete,
                               &event,
                               TRUE,
                               TRUE,
                               TRUE);

        status = IoCallDriver(deviceExtension->TopOfStack, Irp);
        if (STATUS_PENDING == status) {
            KeWaitForSingleObject(
               &event,
               Executive,   // Waiting for reason of a driver
               KernelMode,  // Waiting in kernel mode
               FALSE,       // No alert
               NULL);       // No timeout
        }

        if (NT_SUCCESS (status) && NT_SUCCESS (Irp->IoStatus.Status)) {
            status = InpStartDevice(
                DeviceObject->DeviceExtension,
                stack->Parameters.StartDevice.AllocatedResourcesTranslated);
            if (NT_SUCCESS(status)) {
                deviceExtension->Started = TRUE;
            }
        }

        //
        // We must now complete the IRP, since we stopped it in the
        // completetion routine with MORE_PROCESSING_REQUIRED.
        //
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        break;

    //
    // PnP rules dictate we send the IRP down to the PDO first
    //
    case IRP_MN_CANCEL_REMOVE_DEVICE:
    case IRP_MN_CANCEL_STOP_DEVICE:
        status = InpSendIrpSynchronously(deviceExtension->TopOfStack, Irp);

        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;    
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        break;

    case IRP_MN_REMOVE_DEVICE:
        //
        // The PlugPlay system has dictacted the removal of this device.  We
        // have no choise but to detach and delete the device objecct.
        // (If we wanted to express and interest in preventing this removal,
        // we should have filtered the query remove and query stop routines.)
        //
        // Note! we might receive a remove WITHOUT first receiving a stop.
        //
        InpPrint((2, "INPORT-InportPnP: remove device \n"));

        deviceExtension->Removed = TRUE;

        //
        // Here if we had any outstanding requests in a personal queue we should
        // complete them all now.
        //
        // Note, the device could be GONE so we cannot send it any non-
        // PNP IRPS.
        //
        InpReleaseResources(deviceExtension);

        //
        // Perform specific operations for a remove
        //
        IoWMIRegistrationControl(deviceExtension->Self,
                                 WMIREG_ACTION_DEREGISTER
                                 );

        //
        // Send on the remove IRP
        //
        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(deviceExtension->TopOfStack, Irp);

        //
        // Wait for the remove lock to free.
        //
        IoReleaseRemoveLockAndWait(&deviceExtension->RemoveLock, Irp);

        IoDetachDevice(deviceExtension->TopOfStack);
        IoDeleteDevice(deviceExtension->Self);

        InpPrint((2, "INPORT-InportPnP: exit (%x)\n", STATUS_SUCCESS));
        return STATUS_SUCCESS;

    // NOTE:
    // handle this case if you want to add/remove resources that will be given
    // during start device.  Add resources before passing the irp down.
    // Remove resources when the irp is coming back up
    // See dd\input\pnpi8042\pnp.c, I8xFilterResourceRequirements for an example
    case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
#if !defined(NEC_98)

        status = InpSendIrpSynchronously(deviceExtension->TopOfStack, Irp);

        //
        // If the lower filter does not support this Irp, this is
        // OK, we can ignore this error
        //
        if (status == STATUS_NOT_SUPPORTED) {
            status = STATUS_SUCCESS;
        }

        InpFilterResourceRequirements(DeviceObject, Irp);

        if (!NT_SUCCESS(status)) {
           InpPrint((2, "error pending filter res req event (0x%x)\n", status));
        }
   
        //
        // Irp->IoStatus.Information will contain the new i/o resource 
        // requirements list so leave it alone
        //
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        break;
#else
        InpPrint((2, "INPORT-InportPnP: IRP_MN_FILTER_RESOURCE_REQUIREMENTS\n"));
#endif

     case IRP_MN_QUERY_REMOVE_DEVICE:
     case IRP_MN_QUERY_STOP_DEVICE:
#if defined(NEC_98)
    //
    // Don't let either of the requests succeed, otherwise the mouse might be rendered useless.
    //
        status = STATUS_UNSUCCESSFUL;

        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;    
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        break;
#endif
    case IRP_MN_STOP_DEVICE:
    case IRP_MN_QUERY_DEVICE_RELATIONS:
    case IRP_MN_QUERY_INTERFACE:
    case IRP_MN_QUERY_CAPABILITIES:
    case IRP_MN_QUERY_DEVICE_TEXT:
    case IRP_MN_QUERY_RESOURCES:
    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
    case IRP_MN_READ_CONFIG:
    case IRP_MN_WRITE_CONFIG:
    case IRP_MN_EJECT:
    case IRP_MN_SET_LOCK:
    case IRP_MN_QUERY_ID:
    case IRP_MN_QUERY_PNP_DEVICE_STATE:
    default:
        //
        // Here the filter driver might modify the behavior of these IRPS
        // Please see PlugPlay documentation for use of these IRPs.
        //
        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(deviceExtension->TopOfStack, Irp);
        break;
    }

    IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

    InpPrint((2, "INPORT-InportPnP: exit (%x)\n", status));
    return status;
}

NTSTATUS
InportPower (
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    )
/*++
NOTE:
    You must write power code!!!

    System power irps can be ignored.
    Device power irps will be sent by mouclass.  The transition from D0 to some
    lower usually involves doing nothing (maybe power down h/w if you have control
    over this).  The transition from a lower power state to D0 must be handled by
    reinitializing the device.

    Please read http://titanic for Power documentation (especially on the use
    of PoCallDriver and PoStartNextPowerIrp)

 --*/
{
    PIO_STACK_LOCATION  stack;
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;
    POWER_STATE         powerState;
    POWER_STATE_TYPE    powerType;

    InpPrint((2, "INPORT-InportPower: Enter\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation(Irp);
    powerType = stack->Parameters.Power.Type;
    powerState = stack->Parameters.Power.State;

    status = IoAcquireRemoveLock(&deviceExtension->RemoveLock, Irp);

    if (!NT_SUCCESS(status)) {
        PoStartNextPowerIrp(Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    switch (stack->MinorFunction) {
    case IRP_MN_SET_POWER:
        InpPrint((2, "INPORT-InportPower: Power Setting %s state to %d\n",
              ((powerType == SystemPowerState) ? "System"
                                               : "Device"),
              powerState.SystemState));
#if defined(NEC_98)
        //
        // Don't handle anything but DevicePowerState changes
        //
        if (stack->Parameters.Power.Type != DevicePowerState) {
            InpPrint((2,"INPORT-InportPower: not a device power irp\n"));
            break;
        }

        //
        // Check for no change in state, and if none, do nothing
        //
        if (stack->Parameters.Power.State.DeviceState ==
            deviceExtension->PowerState) {
            InpPrint((2,"INPORT-InportPower: no change in state (PowerDeviceD%d)\n",
                  deviceExtension->PowerState-1
                  ));
            break;
        }

        switch (stack->Parameters.Power.State.DeviceState) {
        case PowerDeviceD0:
            InpPrint((2,"INPORT-InportPower: Powering up to PowerDeviceD0\n"));

            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine(Irp,
                                   InportPowerUpToD0Complete,
                                   NULL,
                                   TRUE,                // on success
                                   TRUE,                // on error
                                   TRUE                 // on cancel
                                   );

            //
            // PoStartNextPowerIrp() gets called in InportPowerUpToD0Complete
            //
            return PoCallDriver(deviceExtension->TopOfStack, Irp);

        case PowerDeviceD1:
        case PowerDeviceD2:
        case PowerDeviceD3:
            InpPrint((
                    2,"INPORT-InportPower: Powering down to PowerDeviceD%d\n",
                    stack->Parameters.Power.State.DeviceState-1
                    ));

            PoSetPowerState(DeviceObject,
                            stack->Parameters.Power.Type,
                            stack->Parameters.Power.State
                            );
            deviceExtension->PowerState = stack->Parameters.Power.State.DeviceState;

            //
            // For what we are doing, we don't need a completion routine
            // since we don't race on the power requests.
            //
            Irp->IoStatus.Status = STATUS_SUCCESS;
            IoCopyCurrentIrpStackLocationToNext(Irp);

            PoStartNextPowerIrp(Irp);
            return  PoCallDriver(deviceExtension->TopOfStack, Irp);

        default:
            InpPrint((2,"INPORT-InportPower: unknown state\n"));
            break;
        }
        break;

#else  // defined(NEC_98)
        break;

#endif // defined(NEC_98)
    case IRP_MN_QUERY_POWER:
        InpPrint((2, "INPORT-InportPower: Power query %s status to %d\n",
              ((powerType == SystemPowerState) ? "System"
                                               : "Device"),
              powerState.SystemState));
        break;
    default:
        InpPrint((2, "INPORT-InportPower: Power minor (0x%x) no known\n", stack->MinorFunction));
    }

    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);
    PoCallDriver(deviceExtension->TopOfStack, Irp);

    IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

    InpPrint((2, "INPORT-InportPower: Exit\n"));
    return STATUS_SUCCESS;
}

#if !defined(NEC_98)
VOID
InpFilterResourceRequirements(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Iterates through the resource requirements list contained in the IRP and removes
    any duplicate requests for I/O ports.  (This is a common problem on the Alphas.)
    
    No removal is performed if more than one resource requirements list is present.
    
Arguments:

    DeviceObject - A pointer to the device object

    Irp - A pointer to the request packet which contains the resource req. list.


Return Value:

    None.
    
--*/
{
    NTSTATUS                        status;
    PDEVICE_EXTENSION               deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    PCM_RESOURCE_LIST               AllocatedResources;
    PIO_RESOURCE_REQUIREMENTS_LIST  pReqList = NULL,
                                    newReqList = NULL;
    PIO_RESOURCE_LIST               pResList = NULL,
                                    pNewResList = NULL;
    PIO_RESOURCE_DESCRIPTOR         pResDesc = NULL,
                                    pNewResDesc = NULL;
    ULONG                           i = 0, reqCount, size = 0;
    BOOLEAN                         foundInt = FALSE, foundPorts = FALSE;
    PIO_STACK_LOCATION                          stack;
    INTERFACE_TYPE                  interfaceType = Isa;
        ULONG                           busNumber = 0;
    CONFIGURATION_TYPE              controllerType = PointerController;
    CONFIGURATION_TYPE              peripheralType = PointerPeripheral;

    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(DeviceObject->DeviceExtension);

    InpPrint((1, "Received IRP_MN_FILTER_RESOURCE_REQUIREMENTS for Inport\n"));

    stack = IoGetCurrentIrpStackLocation(Irp);

    //
    // The list can be in either the information field, or in the current
    //  stack location.  The Information field has a higher precedence over
    //  the stack location.
    //
    if (Irp->IoStatus.Information == 0) {
        pReqList =
            stack->Parameters.FilterResourceRequirements.IoResourceRequirementList;
        Irp->IoStatus.Information = (ULONG_PTR) pReqList;
    }
    else {
        pReqList = (PIO_RESOURCE_REQUIREMENTS_LIST) Irp->IoStatus.Information;
    }

    if (!pReqList) {
        // 
        // Not much can be done here except return
        //
        InpPrint((1, "NULL resource list in InpFilterResourceRequirements\n"));
        return;
    }

    ASSERT(Irp->IoStatus.Information != 0);
    ASSERT(pReqList != 0);

    reqCount = pReqList->AlternativeLists;

    //
    // Only one AlternativeList is supported.  If there is more than one list,
    // then there is now way of knowing which list will be chosen.  Also, if
    // there are multiple lists, then chances are that a list with no i/o port
    // conflicts will be chosen.
    //
    if (reqCount > 1) {
        return;
    }

    pResList = &pReqList->List[0];

    for (i = 0; i < pResList->Count; i++) {
        pResDesc = &pResList->Descriptors[i];
        switch (pResDesc->Type) {
        case CmResourceTypePort:
            foundPorts = TRUE;
            break;

        case CmResourceTypeInterrupt:
            foundInt = TRUE;
            break;

        default:
            break;
        }
    }

    if (!foundPorts && !foundInt)
        size = pReqList->ListSize + 2 * sizeof(IO_RESOURCE_DESCRIPTOR);
    else if (!foundPorts || !foundInt)
        size = pReqList->ListSize + sizeof(IO_RESOURCE_DESCRIPTOR);
    else {
        //
        // Nothing to filter, just leave
        //
        ASSERT(foundPorts);
        ASSERT(foundInt);
        return;
    }

    ASSERT(size != 0);
    newReqList = (PIO_RESOURCE_REQUIREMENTS_LIST)
                    ExAllocatePool(
                        NonPagedPool,
                        size
                        );

    if (!newReqList) {
        return;
    }

    //
    // Clear out the newly allocated list
    //
    RtlZeroMemory(newReqList,
                  size
                  );

    //
    // Copy the entire old list
    //
    RtlCopyMemory(newReqList,
                  pReqList,
                  pReqList->ListSize
                  );

    pResList = &newReqList->List[0];
        if (!foundPorts) {
            pResDesc = &pResList->Descriptors[pResList->Count++];
                pResDesc->Type = CmResourceTypePort;
        }
        if (!foundInt) {
            pResDesc = &pResList->Descriptors[pResList->Count++];
                pResDesc->Type = CmResourceTypeInterrupt;
        }

    pResList = &newReqList->List[0];
    interfaceType = Isa;
    status = IoQueryDeviceDescription(
        &interfaceType,
        &busNumber,
        &controllerType,
        NULL,
        &peripheralType,
        NULL,
        InpFindResourcesCallout,
        (PVOID) pResList
        );

    if (!NT_SUCCESS(status)) {  // fill in with defaults
            PINPORT_CONFIGURATION_INFORMATION configuration = &deviceExtension->Configuration;
                ULONG InterruptLevel;
            InpPrint((1, "Failed IoQueryDeviceDescription, status = 0x%x\n...try the registry...\n", status));
            InpServiceParameters(deviceExtension,
                                 &Globals.RegistryPath);
                InterruptLevel = configuration->MouseInterrupt.u.Interrupt.Level;
            pResList = &newReqList->List[0];
            for (i = 0; i < pResList->Count; i++) {
                pResDesc = &pResList->Descriptors[i];
                switch (pResDesc->Type) {
                case CmResourceTypePort:
                            if (foundPorts) break;
                            pResDesc->Option = 0;  // fixed resources
                            pResDesc->ShareDisposition = INPORT_REGISTER_SHARE? CmResourceShareShared:CmResourceShareDeviceExclusive;
                            pResDesc->Flags = CM_RESOURCE_PORT_IO;
                                pResDesc->u.Port.Length = INP_DEF_PORT_SPAN;
                                pResDesc->u.Port.Alignment = 1;
                                pResDesc->u.Port.MinimumAddress.HighPart = 0;
                                pResDesc->u.Port.MinimumAddress.LowPart  = INP_DEF_PORT;
                                pResDesc->u.Port.MaximumAddress.HighPart = 0;
                                pResDesc->u.Port.MaximumAddress.LowPart  = INP_DEF_PORT+INP_DEF_PORT_SPAN-1;
                    break;

                case CmResourceTypeInterrupt:
                            if (foundInt) break;
                            pResDesc->Option = 0;  // fixed resources
                            pResDesc->ShareDisposition = INPORT_REGISTER_SHARE? CmResourceShareShared:CmResourceShareDeviceExclusive;
                            pResDesc->Flags = CM_RESOURCE_INTERRUPT_LATCHED; //Isa
                                pResDesc->u.Interrupt.MinimumVector = InterruptLevel; 
                                pResDesc->u.Interrupt.MaximumVector = InterruptLevel;
                    break;

                default:
                    break;
                }
            }
        }

    newReqList->ListSize = size;
    //
    // Free the old list and place the new one in its place
    //
    ExFreePool(pReqList);
    stack->Parameters.FilterResourceRequirements.IoResourceRequirementList =
        newReqList;
    Irp->IoStatus.Information = (ULONG_PTR) newReqList;
}

NTSTATUS
InpFindResourcesCallout(
    IN PVOID                        Context,
    IN PUNICODE_STRING              PathName,
    IN INTERFACE_TYPE               BusType,
    IN ULONG                        BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE           ControllerType,
    IN ULONG                        ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE           PeripheralType,
    IN ULONG                        PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    )
/*++

Routine Description:

    This is the callout routine sent as a parameter to
    IoQueryDeviceDescription.  It grabs the keyboard controller and
    peripheral configuration information.

Arguments:

    Context - Context parameter that was passed in by the routine
        that called IoQueryDeviceDescription.

    PathName - The full pathname for the registry key.

    BusType - Bus interface type (Isa, Eisa, Mca, etc.).

    BusNumber - The bus sub-key (0, 1, etc.).

    BusInformation - Pointer to the array of pointers to the full value
        information for the bus.

    ControllerType - The controller type (should be KeyboardController).

    ControllerNumber - The controller sub-key (0, 1, etc.).

    ControllerInformation - Pointer to the array of pointers to the full
        value information for the controller key.

    PeripheralType - The peripheral type (should be KeyboardPeripheral).

    PeripheralNumber - The peripheral sub-key.

    PeripheralInformation - Pointer to the array of pointers to the full
        value information for the peripheral key.


Return Value:

    None.  If successful, will have the following side-effects:

        - Sets DeviceObject->DeviceExtension->HardwarePresent.
        - Sets configuration fields in
          DeviceObject->DeviceExtension->Configuration.

--*/
{
    PUCHAR                          controllerData;
    NTSTATUS                        status = STATUS_UNSUCCESSFUL;
    ULONG                           i,
                                    listCount,
                                    portCount = 0;
    PIO_RESOURCE_LIST               pResList = (PIO_RESOURCE_LIST) Context;
    PIO_RESOURCE_DESCRIPTOR         pResDesc;
    PKEY_VALUE_FULL_INFORMATION     controllerInfo = NULL;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR resourceDescriptor, PortResDesc = NULL, IntResDesc = NULL;
    BOOLEAN                         foundInt = FALSE,
                                    foundPorts = FALSE;

    PAGED_CODE();

    UNREFERENCED_PARAMETER(PathName);
    UNREFERENCED_PARAMETER(BusType);
    UNREFERENCED_PARAMETER(BusNumber);
    UNREFERENCED_PARAMETER(BusInformation);
    UNREFERENCED_PARAMETER(ControllerType);
    UNREFERENCED_PARAMETER(ControllerNumber);
    UNREFERENCED_PARAMETER(PeripheralType);
    UNREFERENCED_PARAMETER(PeripheralNumber);
    UNREFERENCED_PARAMETER(PeripheralInformation);

    pResDesc = pResList->Descriptors + pResList->Count;
    controllerInfo = ControllerInformation[IoQueryDeviceConfigurationData];

    InpPrint((2, "InpFindPortCallout enter\n"));

    if (controllerInfo->DataLength != 0) {
        controllerData = ((PUCHAR) controllerInfo) + controllerInfo->DataOffset;
        controllerData += FIELD_OFFSET(CM_FULL_RESOURCE_DESCRIPTOR,
                                       PartialResourceList);

        listCount = ((PCM_PARTIAL_RESOURCE_LIST) controllerData)->Count;

        resourceDescriptor =
            ((PCM_PARTIAL_RESOURCE_LIST) controllerData)->PartialDescriptors;

        for (i = 0; i < listCount; i++, resourceDescriptor++) {
            switch(resourceDescriptor->Type) {
            case CmResourceTypePort:
                                PortResDesc = resourceDescriptor;
                break;

            case CmResourceTypeInterrupt:
                                IntResDesc = resourceDescriptor;
                                break;

            default:
                break;
            }
        }

    }

    for (i = 0; i < pResList->Count; i++) {
        pResDesc = &pResList->Descriptors[i];
        switch (pResDesc->Type) {
        case CmResourceTypePort:
                    if (PortResDesc) {
                                resourceDescriptor = PortResDesc;
                            pResDesc->Option = 0;  // fixed resources
                            pResDesc->ShareDisposition = INPORT_REGISTER_SHARE? CmResourceShareShared:CmResourceShareDeviceExclusive;
                pResDesc->Flags = CM_RESOURCE_PORT_IO;
                pResDesc->u.Port.Alignment = 1;
                pResDesc->u.Port.Length = INP_DEF_PORT_SPAN;
                pResDesc->u.Port.MinimumAddress.QuadPart =
                    resourceDescriptor->u.Port.Start.QuadPart;
                pResDesc->u.Port.MaximumAddress.QuadPart = 
                    pResDesc->u.Port.MinimumAddress.QuadPart +
                    pResDesc->u.Port.Length - 1;
                        }
            break;

        case CmResourceTypeInterrupt:
                    if (IntResDesc) {
                                resourceDescriptor = IntResDesc;
                            pResDesc->Option = 0;  // fixed resources
                            pResDesc->ShareDisposition = INPORT_REGISTER_SHARE? CmResourceShareShared:CmResourceShareDeviceExclusive;
                            pResDesc->Flags = CM_RESOURCE_INTERRUPT_LATCHED; //Isa
                                pResDesc->u.Interrupt.MinimumVector = resourceDescriptor->u.Interrupt.Level; 
                                pResDesc->u.Interrupt.MaximumVector = resourceDescriptor->u.Interrupt.Level;
                        }
            break;

        default:
            break;
        }
    }
        if (PortResDesc && IntResDesc)
                status = STATUS_SUCCESS;
        else
                status = STATUS_UNSUCCESSFUL;

    InpPrint((2, "InpFindPortCallout exit (0x%x)\n", status));
    return status;
}
#endif

NTSTATUS
InpSendIrpSynchronously (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    KEVENT   event;
    NTSTATUS status;

    PAGED_CODE();

    KeInitializeEvent(&event,
                      SynchronizationEvent,
                      FALSE
                      );

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(Irp,
                           InpPnPComplete,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE
                           );

    status = IoCallDriver(DeviceObject, Irp);

    //
    // Wait for lower drivers to be done with the Irp
    //
    if (status == STATUS_PENDING) {
       KeWaitForSingleObject(&event,
                             Executive,
                             KernelMode,
                             FALSE,
                             NULL
                             );
       status = Irp->IoStatus.Status;
    }

    return status;
}

#if defined(NEC_98)
NTSTATUS
InportPowerUpToD0Complete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    Reinitializes the Inport Mouse haardware after any type of hibernation/sleep.

Arguments:

    DeviceObject - Pointer to the device object

    Irp - Pointer to the request

    Context - Context passed in from the funciton that set the completion
              routine. UNUSED.


Return Value:

    STATUS_SUCCESSFUL if successful,
    an valid NTSTATUS error code otherwise

--*/
{
    NTSTATUS                status;
    PIO_STACK_LOCATION      stack;
    PDEVICE_EXTENSION       deviceExtension;
    PWORK_QUEUE_ITEM        item;

    UNREFERENCED_PARAMETER(Context);

    deviceExtension = DeviceObject->DeviceExtension;

    status = Irp->IoStatus.Status;
    stack = IoGetCurrentIrpStackLocation(Irp);

    if (NT_SUCCESS(status)) {

        //
        // Reset the power state to powered up
        //
        deviceExtension->PowerState = PowerDeviceD0;

        //
        // Everything has been powered up, let the system know about it
        //
        PoSetPowerState(DeviceObject,
                        stack->Parameters.Power.Type,
                        stack->Parameters.Power.State
                        );

            item = (PWORK_QUEUE_ITEM) ExAllocatePool(NonPagedPool,
                                                     sizeof(WORK_QUEUE_ITEM));
            if (!item) {
                //
                // must elaborate here
                //
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            ExInitializeWorkItem(item, InportReinitializeHardware, item);
            ExQueueWorkItem(item, DelayedWorkQueue);
    }

    InpPrint((2,"INPORT-InportPowerUpToD0Complete: PowerUpToD0Complete, exit\n"));

    PoStartNextPowerIrp(Irp);
    return status;
}

#endif // defined(NEC_98)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\inport\i386\wmi.c ===
/*++

Copyright (c) 1997, 98 Microsoft Corporation

Module Name:

    wmi.c

Abstract:

    This module contains the code that handles the wmi IRPs for the
    inport driver.

Author:

    Initial writing, Doron J. Holan, 09-Feb-1998

Environment:

    Kernel mode

Revision History :
--*/

#include "inport.h"
#include <wmistr.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, InportSystemControl)
#pragma alloc_text(PAGE, InportSetWmiDataItem)
#pragma alloc_text(PAGE, InportSetWmiDataBlock)
#pragma alloc_text(PAGE, InportQueryWmiDataBlock)
#pragma alloc_text(PAGE, InportQueryWmiRegInfo)
#endif

#define WMI_MOUSE_PORT_INFORMATION    0

GUID Inport_PointerPortGuid = POINTER_PORT_WMI_STD_DATA_GUID;

WMIGUIDREGINFO WmiGuidList[1] =
{
    { &Inport_PointerPortGuid,  1, 0 }  // Pointer Port driver information
};

NTSTATUS
InportSystemControl(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    )
/*++
Routine Description

    We have just received a System Control IRP.

    Assume that this is a WMI IRP and call into the WMI system library and let
    it handle this IRP for us.

--*/
{
    PDEVICE_EXTENSION       deviceExtension;
    SYSCTL_IRP_DISPOSITION disposition;
    NTSTATUS status;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    status = WmiSystemControl(&deviceExtension->WmiLibInfo, 
                                 DeviceObject, 
                                 Irp,
                                 &disposition);
    switch(disposition)
    {
        case IrpProcessed:
        {
            //
            // This irp has been processed and may be completed or pending.
            break;
        }
        
        case IrpNotCompleted:
        {
            //
            // This irp has not been completed, but has been fully processed.
            // we will complete it now
            IoCompleteRequest(Irp, IO_NO_INCREMENT);                
            break;
        }
        
        case IrpForward:
        case IrpNotWmi:
        {
            //
            // This irp is either not a WMI irp or is a WMI irp targetted
            // at a device lower in the stack.
            IoSkipCurrentIrpStackLocation (Irp);
            status = IoCallDriver (deviceExtension->TopOfStack, Irp);
            break;
        }
                                    
        default:
        {
            //
            // We really should never get here, but if we do just forward....
            ASSERT(FALSE);
            IoSkipCurrentIrpStackLocation (Irp);
            status = IoCallDriver (deviceExtension->TopOfStack, Irp);
            break;
        }        
    }
    
    return(status);

}

//
// WMI System Call back functions
//


NTSTATUS
InportSetWmiDataItem(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            DataItemId,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being set.
            
    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION    deviceExtension;
    NTSTATUS        status;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    switch(GuidIndex) {

    case WMI_MOUSE_PORT_INFORMATION:
        status = STATUS_WMI_READ_ONLY;
        break;

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
        break;
    }

    status = WmiCompleteRequest(DeviceObject,
                                  Irp,
                                  status,
                                  0,
                                  IO_NO_INCREMENT
                                  );

    return status;
}

NTSTATUS
InportSetWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being set.
            
    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION    deviceExtension;
    NTSTATUS        status;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    switch (GuidIndex) {

    case WMI_MOUSE_PORT_INFORMATION: 
        status = STATUS_WMI_READ_ONLY;
        break;

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest(DeviceObject,
                                  Irp,
                                  status,
                                  0,
                                  IO_NO_INCREMENT
                                  );

    return status;
}

NTSTATUS
InportQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    one or more instances of a data block. When the driver has finished 
    filling the 
    data block it must call WmiCompleteRequest to complete the irp. The 
    driver can return STATUS_PENDING if the irp cannot be completed 
    immediately.

    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    InstanceCount is the number of instnaces expected to be returned for
        the data block.
            
    InstanceLengthArray is a pointer to an array of ULONG that returns the 
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.        
            
    BufferAvail on entry has the maximum size available to write the data
        blocks. 

    Buffer on return is filled with the returned data blocks. Note that each
        instance of the data block must be aligned on a 8 byte boundry. If 
        this is NULL then there was not enough space in the output buffer 
	to fufill the request so the irp should be completed with the buffer 
        needed.


Return Value:

    status

--*/
{
    NTSTATUS                    status;
    ULONG                       size = sizeof(POINTER_PORT_WMI_STD_DATA);
    POINTER_PORT_WMI_STD_DATA   mouData;
    PDEVICE_EXTENSION           deviceExtension;
    PMOUSE_ATTRIBUTES           attributes;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension; 

    switch (GuidIndex) {
    case WMI_MOUSE_PORT_INFORMATION:

        attributes = &deviceExtension->Configuration.MouseAttributes;

        if (BufferAvail < size) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

	*InstanceLengthArray = size;
        RtlZeroMemory(&mouData,
                      size
                      );

        mouData.ConnectorType = POINTER_PORT_WMI_STD_I8042;
        mouData.DataQueueSize = attributes->InputDataQueueLength /
                                sizeof(MOUSE_INPUT_DATA);
        mouData.Buttons = attributes->NumberOfButtons;
        mouData.ErrorCount = 0;
        mouData.HardwareType = POINTER_PORT_WMI_STD_MOUSE;

        *(PPOINTER_PORT_WMI_STD_DATA) Buffer = mouData;
        status = STATUS_SUCCESS;

        break;

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
        break;
    }

    status = WmiCompleteRequest(DeviceObject,
                                  Irp,
                                  status,
                                  size,
                                  IO_NO_INCREMENT
                                  );

    return status;
}

NTSTATUS
InportQueryWmiRegInfo(
    IN PDEVICE_OBJECT   DeviceObject,
    OUT PULONG          RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *Pdo
    )
/*++


Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered. 
	    
    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe all of the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device. These flags are ORed into the flags specified
        by the GUIDREGINFO for each guid.		

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. This is 
        required
		
    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.
		
    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in 
        *RegFlags.

Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;
	
    deviceExtension = DeviceObject->DeviceExtension;
	
    *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
    *RegistryPath = &Globals.RegistryPath;
    *Pdo = deviceExtension->PDO;
    
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\inport\i386\inpdep.c ===
#if defined(i386)                                               

/*++

Copyright (c) 1989, 1990, 1991, 1992, 1993  Microsoft Corporation

Module Name:

    inpdep.c

Abstract:

    The initialization and hardware-dependent portions of
    the Microsoft InPort mouse port driver.  Modifications to
    support new mice similar to the InPort mouse should be
    localized to this file.

Environment:

    Kernel mode only.

Notes:

    NOTES:  (Future/outstanding issues)

    - Powerfail not implemented.

    - Consolidate duplicate code, where possible and appropriate.

Revision History:

--*/

#include "stdarg.h"
#include "stdio.h"
#include "string.h"
#include "ntddk.h"
#include "inport.h"
#include "inplog.h"

#if defined(NEC_98)
ULONG EventStatus = 0;
#endif // defined(NEC_98)

//
// Use the alloc_text pragma to specify the driver initialization routines
// (they can be paged out).
//
#ifdef ALLOC_PRAGMA
// #pragma alloc_text(INIT,InpConfiguration)
// #pragma alloc_text(INIT,InpPeripheralCallout)
// #pragma alloc_text(INIT,InpBuildResourceList)
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(PAGE,InpServiceParameters)
#pragma alloc_text(PAGE,InpInitializeHardware)
#if defined(NEC_98)
#pragma alloc_text(INIT,QueryEventMode)
#endif // defined(NEC_98)
#endif

GLOBALS Globals;

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine initializes the Inport mouse port driver.

Arguments:

    DriverObject - Pointer to driver object created by system.

    RegistryPath - Pointer to the Unicode name of the registry path
        for this driver.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_ERROR_LOG_PACKET errorLogEntry;
    NTSTATUS        errorCode;
    ULONG uniqueErrorValue, dumpCount;
#define NAME_MAX 256
    WCHAR nameBuffer[NAME_MAX];

    ULONG dumpData[4];


    InpPrint((1,"\n\nINPORT-InportDriverEntry: enter\n"));

    //
    // Need to ensure that the registry path is null-terminated.
    // Allocate pool to hold a null-terminated copy of the path.
    //
    Globals.RegistryPath.MaximumLength = 0;
    Globals.RegistryPath.Buffer = ExAllocatePool(
                              PagedPool,
                              RegistryPath->Length + sizeof(UNICODE_NULL)
                              );

    if (!Globals.RegistryPath.Buffer) {
        InpPrint((
            1,
            "INPORT-InportDriverEntry: Couldn't allocate pool for registry path\n"
            ));

        dumpData[0] = (ULONG) RegistryPath->Length + sizeof(UNICODE_NULL);
        dumpCount = 1;

        InpLogError(
            (PDEVICE_OBJECT)DriverObject,
            INPORT_INSUFFICIENT_RESOURCES,
            INPORT_ERROR_VALUE_BASE + 2,
            STATUS_UNSUCCESSFUL,
            dumpData,
            1
            );

    } else {

        Globals.RegistryPath.Length = RegistryPath->Length + sizeof(UNICODE_NULL);
        Globals.RegistryPath.MaximumLength = Globals.RegistryPath.Length;

        RtlZeroMemory(
            Globals.RegistryPath.Buffer,
            Globals.RegistryPath.Length
                );

        RtlMoveMemory(
            Globals.RegistryPath.Buffer,
            RegistryPath->Buffer,
            RegistryPath->Length
            );

    }

    //
    // Set up the device driver entry points.
    //
    DriverObject->DriverStartIo = InportStartIo;
    DriverObject->DriverExtension->AddDevice = InportAddDevice;
    DriverObject->MajorFunction[IRP_MJ_CREATE] = InportCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]  = InportClose;
    DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS]  =
                                             InportFlush;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] =
                                         InportInternalDeviceControl;

    DriverObject->MajorFunction[IRP_MJ_PNP]  = InportPnP;
    DriverObject->MajorFunction[IRP_MJ_POWER]  = InportPower;

    //
    // NOTE: Don't allow this driver to unload.  Otherwise, we would set
    // DriverObject->DriverUnload = InportUnload.
    //

#if defined(NEC_98)
    //
    // Is "Event Interrupt Mode" available on this machine?
    //
    QueryEventMode();
#endif // defined(NEC_98)

    InpPrint((1,"INPORT-InportDriverEntry: exit\n"));

    return(status);

}

BOOLEAN
InportInterruptService(
    IN PKINTERRUPT Interrupt,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the interrupt service routine for the mouse device.

Arguments:

    Interrupt - A pointer to the interrupt object for this interrupt.

    Context - A pointer to the device object.

Return Value:

    Returns TRUE if the interrupt was expected (and therefore processed);
    otherwise, FALSE is returned.

--*/

{
    PDEVICE_EXTENSION deviceExtension;
    PDEVICE_OBJECT deviceObject;
    PUCHAR port;
    UCHAR previousButtons;
    UCHAR mode;
    UCHAR status;
#if defined(NEC_98)
    PINPORT_CONFIGURATION_INFORMATION Configuration;
#endif // defined(NEC_98)

    UNREFERENCED_PARAMETER(Interrupt);

    InpPrint((3, "INPORT-InportInterruptService: enter\n"));

    //
    // Get the device extension.
    //

    deviceObject = (PDEVICE_OBJECT) Context;
    deviceExtension = (PDEVICE_EXTENSION) deviceObject->DeviceExtension;
#if defined(NEC_98)
    Configuration = &deviceExtension->Configuration;

    if (Configuration->MouseInterrupt.Flags == CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE) {
        if ((READ_PORT_UCHAR((PUCHAR)PC98_MOUSE_INT_SHARE_CHECK_PORT) & PC98_MOUSE_INT_SERVICE)
                 != PC98_MOUSE_INT_SERVICE) {
            InpPrint((1, "InportInterruptService: exit [NOT Mouse Service]\n"));
            return(FALSE);
        }
    }

    if (deviceExtension->ConnectData.ClassService == NULL) {
        InpPrint((1, "InportInterruptService: exit [not connected yet]\n"));
        return(TRUE);
    }
#endif // defined(NEC_98)

    //
    // Get the Inport mouse port address.
    //

    port = deviceExtension->Configuration.DeviceRegisters[0];

#if defined(NEC_98)
    WRITE_PORT_UCHAR(port + PC98_WritePortC2, PC98_TimerIntDisable);

    //
    // Read X Data.
    //
    WRITE_PORT_UCHAR(port + PC98_WritePortC2, PC98_X_ReadCommandHi);
    status = (UCHAR)(LONG)(SCHAR) READ_PORT_UCHAR((PUCHAR)(port + PC98_ReadPortA));
    deviceExtension->CurrentInput.LastX = status & 0x000f;

    WRITE_PORT_UCHAR(port + PC98_WritePortC2, PC98_X_ReadCommandLow);
    deviceExtension->CurrentInput.LastX =
       (LONG)(SCHAR) ((deviceExtension->CurrentInput.LastX << 4) |
       (READ_PORT_UCHAR(port + PC98_ReadPortA) & 0x000f));

    //
    // Read Y Data.
    //
    WRITE_PORT_UCHAR(port + PC98_WritePortC2, PC98_Y_ReadCommandHi);
    status = (UCHAR)(LONG)(SCHAR) READ_PORT_UCHAR((PUCHAR)(port + PC98_ReadPortA));
    deviceExtension->CurrentInput.LastY = status & 0x000f;

    WRITE_PORT_UCHAR(port + PC98_WritePortC2, PC98_Y_ReadCommandLow);
    deviceExtension->CurrentInput.LastY =
       (LONG)(SCHAR) ((deviceExtension->CurrentInput.LastY << 4) |
       (READ_PORT_UCHAR(port + PC98_ReadPortA) & 0x000f));

    //
    // Set Mouse Button Status.
    //
    status = ~status;
#else // defined(NEC_98)
    //
    // Note:  It would be nice to verify that the interrupt really
    // belongs to this driver, but it is currently not known how to
    // make that determination.
    //

    //
    // Set the Inport hold bit.  Note that there is a bug in the 1.1 version
    // of the Inport chip in DATA mode.  The interrupt signal doesn't get
    // cleared in some cases, thus effectively disabling the device.  The
    // workaround is to set the HOLD bit twice.
    //

    WRITE_PORT_UCHAR((PUCHAR) port, INPORT_MODE_REGISTER);
    mode = READ_PORT_UCHAR((PUCHAR) (port + INPORT_DATA_REGISTER_1));
    WRITE_PORT_UCHAR(
        (PUCHAR) (port + INPORT_DATA_REGISTER_1),
        (UCHAR) (mode | INPORT_MODE_HOLD)
        );
    WRITE_PORT_UCHAR(
        (PUCHAR) (port + INPORT_DATA_REGISTER_1),
        (UCHAR) (mode | INPORT_MODE_HOLD)
        );

    //
    // Read the Inport status register.  It contains the following information:
    //
    //          XXXXXXXX
    //           |   | |------  1 if button 3 is down (right button)
    //           |   |--------  1 if button 1 is down (left button)
    //           |------------  1 if the mouse has moved
    //

    WRITE_PORT_UCHAR((PUCHAR) port, INPORT_STATUS_REGISTER);
    status = READ_PORT_UCHAR((PUCHAR) (port + INPORT_DATA_REGISTER_1));

    InpPrint((3, "INPORT-InportInterruptService: status byte 0x%x\n", status));
#endif // defined(NEC_98)

    //
    // Update CurrentInput with button transition data.
    // I.e., set a button up/down bit in the Buttons field if
    // the state of a given button has changed since we
    // received the last packet.
    //

    previousButtons = 
        deviceExtension->PreviousButtons;

    deviceExtension->CurrentInput.Buttons = 0;

    if ((!(previousButtons & INPORT_STATUS_BUTTON1)) 
           &&  (status & INPORT_STATUS_BUTTON1)) {
        deviceExtension->CurrentInput.Buttons |=
            MOUSE_LEFT_BUTTON_DOWN;
    } else
    if ((previousButtons & INPORT_STATUS_BUTTON1) 
           &&  !(status & INPORT_STATUS_BUTTON1)) {
        deviceExtension->CurrentInput.Buttons |=
            MOUSE_LEFT_BUTTON_UP;
    }
    if ((!(previousButtons & INPORT_STATUS_BUTTON3)) 
           &&  (status & INPORT_STATUS_BUTTON3)) {
        deviceExtension->CurrentInput.Buttons |=
            MOUSE_RIGHT_BUTTON_DOWN;
    } else
    if ((previousButtons & INPORT_STATUS_BUTTON3) 
           &&  !(status & INPORT_STATUS_BUTTON3)) {
        deviceExtension->CurrentInput.Buttons |=
            MOUSE_RIGHT_BUTTON_UP;
    }
            
    //
    // If the button position changed or the mouse moved, continue to process
    // the interrupt.  Otherwise, just clear the hold bit and ignore this
    // interrupt's data.
    //

#if defined(NEC_98)
    if ((deviceExtension->PreviousButtons ^ deviceExtension->CurrentInput.Buttons)
           || (deviceExtension->CurrentInput.LastX | deviceExtension->CurrentInput.LastY)) {
#else // defined(NEC_98)
    if (deviceExtension->CurrentInput.Buttons
           || (status & INPORT_STATUS_MOVEMENT)) {

        deviceExtension->CurrentInput.UnitId = deviceExtension->UnitId;
#endif // defined(NEC_98)

        //
        // Keep track of the state of the mouse buttons for the next
        // interrupt.
        //

        deviceExtension->PreviousButtons =
            status & (INPORT_STATUS_BUTTON1 | INPORT_STATUS_BUTTON3);

#if defined(NEC_98)
        //
        // If mouse not movement was recorded, set the X and Y motion 0 data.
        //
        if (!(deviceExtension->CurrentInput.LastX | deviceExtension->CurrentInput.LastY)) {
            deviceExtension->CurrentInput.LastX = 0;
            deviceExtension->CurrentInput.LastY = 0;
        }
        WRITE_PORT_UCHAR(port + PC98_WritePortC2, PC98_TimerIntEnable);
#else // defined(NEC_98)
        //
        // If mouse movement was recorded, get the X and Y motion data.
        //

        if (status & INPORT_STATUS_MOVEMENT) {

            //
            // Select the Data1 register as the current data register, and
            // get the X motion byte.
            //

            WRITE_PORT_UCHAR((PUCHAR) port, INPORT_DATA_REGISTER_1);
            deviceExtension->CurrentInput.LastX =
                (LONG)(SCHAR) READ_PORT_UCHAR(
                                   (PUCHAR) (port + INPORT_DATA_REGISTER_1));

            //
            // Select the Data2 register as the current data register, and
            // get the Y motion byte.
            //

            WRITE_PORT_UCHAR((PUCHAR) port, INPORT_DATA_REGISTER_2);
            deviceExtension->CurrentInput.LastY =
                (LONG)(SCHAR) READ_PORT_UCHAR(
                                   (PUCHAR) (port + INPORT_DATA_REGISTER_1));
        } else {
            deviceExtension->CurrentInput.LastX = 0;
            deviceExtension->CurrentInput.LastY = 0;
        }

        //
        // Clear the Inport hold bit.
        //

        WRITE_PORT_UCHAR((PUCHAR) port, INPORT_MODE_REGISTER);
        mode = READ_PORT_UCHAR((PUCHAR) (port + INPORT_DATA_REGISTER_1));
        WRITE_PORT_UCHAR(
            (PUCHAR) (port + INPORT_DATA_REGISTER_1),
            (UCHAR) (mode & ~INPORT_MODE_HOLD)
            );
#endif // defined(NEC_98)

        //
        // Write the input data to the queue and request the ISR DPC to
        // finish processing the interrupt at DISPATCH_LEVEL.
        //

        if (!InpWriteDataToQueue(
                deviceExtension,
                &deviceExtension->CurrentInput
                )) {

            //
            // The mouse input data queue is full.  Just drop the
            // latest input on the floor.
            //
            // Queue a DPC to log an overrun error.
            //

            InpPrint((
                1,
                "INPORT-InportInterruptService: queue overflow\n"
                ));

            if (deviceExtension->OkayToLogOverflow) {
                KeInsertQueueDpc(
                    &deviceExtension->ErrorLogDpc,
                    (PIRP) NULL,
                    (PVOID) (ULONG) INPORT_MOU_BUFFER_OVERFLOW
                    );
                deviceExtension->OkayToLogOverflow = FALSE;
            }

        } else if (deviceExtension->DpcInterlockVariable >= 0) {
    
            //
            // The ISR DPC is already executing.  Tell the ISR DPC it has
            // more work to do by incrementing the DpcInterlockVariable.
            //
    
            deviceExtension->DpcInterlockVariable += 1;
    
        } else {
    
            //
            // Queue the ISR DPC.
            //
    
            KeInsertQueueDpc(
                &deviceExtension->IsrDpc,
                deviceObject->CurrentIrp,
                NULL
                );
    
        }

    } else {

        InpPrint((
            3,
            "INPORT-InportInterruptService: interrupt without button/motion change\n"
            ));


        //
        // Clear the Inport hold bit.
        //

#if defined(NEC_98)
        WRITE_PORT_UCHAR(port + PC98_WritePortC2, PC98_TimerIntEnable);
#else // defined(NEC_98)
        WRITE_PORT_UCHAR((PUCHAR) port, INPORT_MODE_REGISTER);
        mode = READ_PORT_UCHAR((PUCHAR) (port + INPORT_DATA_REGISTER_1));
        WRITE_PORT_UCHAR(
            (PUCHAR) (port + INPORT_DATA_REGISTER_1),
            (UCHAR) (mode & ~INPORT_MODE_HOLD)
            );
#endif // defined(NEC_98)

    }

    InpPrint((3, "INPORT-InportInterruptService: exit\n"));

    return(TRUE);
}

VOID
InportUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{
    UNREFERENCED_PARAMETER(DriverObject);

    InpPrint((2, "INPORT-InportUnload: enter\n"));

    ExFreePool(Globals.RegistryPath.Buffer);

    InpPrint((2, "INPORT-InportUnload: exit\n"));
}




#define DUMP_COUNT 4
NTSTATUS
InpConfigureDevice(
    IN OUT PDEVICE_EXTENSION DeviceExtension,
    IN PCM_RESOURCE_LIST ResourceList
    )
{
    PINPORT_CONFIGURATION_INFORMATION   configuration;
    NTSTATUS                            status = STATUS_SUCCESS;
    ULONG                               i, count;
    BOOLEAN                             defaultInterruptShare;
    KINTERRUPT_MODE                     defaultInterruptMode; 

    PCM_PARTIAL_RESOURCE_LIST           partialResList = NULL;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR     currentResDesc = NULL;
    PCM_FULL_RESOURCE_DESCRIPTOR        fullResDesc = NULL;

    configuration = &DeviceExtension->Configuration;

    if (!ResourceList) {
        InpPrint((1, "INPORT-InpConfigureDevice: mouse with null resources\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    fullResDesc = ResourceList->List;
    if (!fullResDesc) {
        //
        // this should never happen
        //
        ASSERT(fullResDesc != NULL);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    partialResList = &fullResDesc->PartialResourceList;
    currentResDesc = partialResList->PartialDescriptors;
    count = partialResList->Count;
  
    configuration->BusNumber      = fullResDesc->BusNumber;
    configuration->InterfaceType  = fullResDesc->InterfaceType;

    configuration->FloatingSave = INPORT_FLOATING_SAVE;

    if (configuration->InterfaceType == MicroChannel) {
        defaultInterruptShare = TRUE;
        defaultInterruptMode = LevelSensitive;
    } else {
        defaultInterruptShare = INPORT_INTERRUPT_SHARE;
        defaultInterruptMode = INPORT_INTERRUPT_MODE;
    }

    DeviceExtension->Configuration.UnmapRegistersRequired = FALSE;

    //
    // Look through the resource list for interrupt and port
    // configuration information.
    //
    for (i = 0; i < count; i++, currentResDesc++) {
        switch(currentResDesc->Type) {
        case CmResourceTypePort:
    
#if defined(NEC_98)
            //
            // Copy the port information.  Note that we expect to
            // find more than one port ranges for the NEC98 Bus Mouse.
            //
            ASSERT(configuration->PortListCount < (sizeof(configuration->PortList) / sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)));
#else // defined(NEC_98)
            //
            // Copy the port information.  Note that we only expect to 
            // find one port range for the Inport mouse.
            //
            ASSERT(configuration->PortListCount == 0);
#endif // defined(NEC_98)
            configuration->PortList[configuration->PortListCount] =
                *currentResDesc;
            configuration->PortList[configuration->PortListCount].ShareDisposition =
                INPORT_REGISTER_SHARE? CmResourceShareShared:
                                       CmResourceShareDeviceExclusive;
            configuration->PortListCount += 1;
            if (currentResDesc->Flags == CM_RESOURCE_PORT_MEMORY) {
                DeviceExtension->Configuration.UnmapRegistersRequired = TRUE;
            }
             
            break;
        
        case CmResourceTypeInterrupt:
    
            //
            // Copy the interrupt information.
            //
    
            configuration->MouseInterrupt = *currentResDesc;
            configuration->MouseInterrupt.ShareDisposition = 
                defaultInterruptShare?  CmResourceShareShared : 
                                        CmResourceShareDeviceExclusive;
    
            break;

        default:
            break;
        }
    }
    
    if (!(configuration->MouseInterrupt.Type & CmResourceTypeInterrupt)) {
        return STATUS_UNSUCCESSFUL;
    }

#if defined(NEC_98)
    if (configuration->MouseInterrupt.Flags != CM_RESOURCE_INTERRUPT_LATCHED) {
        configuration->MouseInterrupt.ShareDisposition = CmResourceShareShared;
    }
#endif // defined(NEC_98)

    InpPrint((
        1,
        "INPORT-InpConfigureDevice: Mouse interrupt config --\n"
        ));
    InpPrint((
        1,
        "  %s, %s, Irq = %d\n",
        configuration->MouseInterrupt.ShareDisposition == CmResourceShareShared? 
            "Sharable" : "NonSharable",
        configuration->MouseInterrupt.Flags == CM_RESOURCE_INTERRUPT_LATCHED?
            "Latched" : "Level Sensitive",
        configuration->MouseInterrupt.u.Interrupt.Vector
        ));
    
//
// Again, if we must check for this condition in IRP_MN_FILTER_RESOURCE_REQUIREMENTS
//
#if 0
    //
    // If no port configuration information was found, use the
    // driver defaults.
    //
    if (configuration->PortListCount == 0) {
    
        //
        // No port configuration information was found, so use 
        // the driver defaults.
        //
    
        InpPrint((
            1,
            "INPORT-InpConfigureDevice: Using default port config\n"
            ));

        configuration->PortList[0].Type = CmResourceTypePort;
        configuration->PortList[0].Flags = INPORT_PORT_TYPE;
        configuration->PortList[0].Flags = CM_RESOURCE_PORT_IO;
        configuration->PortList[0].ShareDisposition = 
            INPORT_REGISTER_SHARE? CmResourceShareShared:
                                   CmResourceShareDeviceExclusive;
        configuration->PortList[0].u.Port.Start.LowPart = 
            INPORT_PHYSICAL_BASE;
        configuration->PortList[0].u.Port.Start.HighPart = 0;
        configuration->PortList[0].u.Port.Length = INPORT_REGISTER_LENGTH;
    
        configuration->PortListCount = 1;
    }
#else
    if (configuration->PortListCount == 0) {
        return STATUS_UNSUCCESSFUL;
    }
#endif

#if defined(NEC_98)
    configuration->PortList[0].u.Port.Length = 1;
#endif // defined(NEC_98)
    for (i = 0; i < configuration->PortListCount; i++) {

        InpPrint((
            1,
            "  %s, Ports 0x%x - 0x%x\n",
            configuration->PortList[i].ShareDisposition 
                == CmResourceShareShared?  "Sharable" : "NonSharable",
            configuration->PortList[i].u.Port.Start.LowPart,
            configuration->PortList[i].u.Port.Start.LowPart +
                configuration->PortList[i].u.Port.Length - 1
            ));
    }

    //
    // Set the DeviceRegister, mapping them if necessary
    //
    if (DeviceExtension->Configuration.DeviceRegisters[0] == NULL) {
        if (DeviceExtension->Configuration.UnmapRegistersRequired) {
            InpPrint((1, "INPORT-InpConfigureDevice:Mapping registers\n"));
            InpPrint((
                1,
                "INPORT-InpConfigureDevice: Start = 0x%x, Length = 0x%x\n",
                DeviceExtension->Configuration.PortList[0].u.Port.Start,
                DeviceExtension->Configuration.PortList[0].u.Port.Length
                ));
            DeviceExtension->Configuration.DeviceRegisters[0] = (PUCHAR)
                MmMapIoSpace(
                    DeviceExtension->Configuration.PortList[0].u.Port.Start,
                    DeviceExtension->Configuration.PortList[0].u.Port.Length,
                    MmNonCached
                    );
        } else {
            InpPrint((1, "INPORT-InpConfigureDevice:Not Mapping registers\n"));
            DeviceExtension->Configuration.DeviceRegisters[0] = (PUCHAR)
                DeviceExtension->Configuration.PortList[0].u.Port.Start.LowPart;
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
InpStartDevice(
    IN OUT PDEVICE_EXTENSION DeviceExtension,
    IN PCM_RESOURCE_LIST ResourceList
    )
{
    PINPORT_CONFIGURATION_INFORMATION   configuration;
    NTSTATUS        status;
    ULONG           dumpData[1],
                    dumpCount,
                    uniqueErrorValue,
                    errorCode;

    InpPrint((2, "INPORT-InpStartDevice: enter\n"));

    InpServiceParameters(DeviceExtension,
                         &Globals.RegistryPath);

    status = InpConfigureDevice(DeviceExtension,
                                ResourceList);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = InpInitializeHardware(DeviceExtension->Self);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Allocate the ring buffer for the mouse input data.
    //
    DeviceExtension->InputData = 
        ExAllocatePool(
            NonPagedPool,
            DeviceExtension->Configuration.MouseAttributes.InputDataQueueLength
            );

    if (!DeviceExtension->InputData) {
   
        //
        // Could not allocate memory for the mouse data queue.
        //

        InpPrint((
            1,
            "INPORT-InpStartDevice: Could not allocate mouse input data queue\n"
            ));

        //
        // Log an error.
        //

        dumpData[0] = 
            DeviceExtension->Configuration.MouseAttributes.InputDataQueueLength;
        dumpCount = 1;

        InpLogError(
            DeviceExtension->Self,
            INPORT_NO_BUFFER_ALLOCATED,
            INPORT_ERROR_VALUE_BASE + 30,
            STATUS_INSUFFICIENT_RESOURCES,
            dumpData,
            1
            );

    }

    DeviceExtension->DataEnd =
        (PMOUSE_INPUT_DATA)  ((PCHAR) (DeviceExtension->InputData) 
        + DeviceExtension->Configuration.MouseAttributes.InputDataQueueLength);

    //
    // Zero the mouse input data ring buffer.
    //

    RtlZeroMemory(
        DeviceExtension->InputData, 
        DeviceExtension->Configuration.MouseAttributes.InputDataQueueLength
        );

    //
    // Initialize the input data queue.
    //
    InpInitializeDataQueue((PVOID) DeviceExtension);

    //
    // Initialize the port ISR DPC.  The ISR DPC is responsible for
    // calling the connected class driver's callback routine to process
    // the input data queue.
    //

    DeviceExtension->DpcInterlockVariable = -1;

    KeInitializeSpinLock(&DeviceExtension->SpinLock);

    KeInitializeDpc(
        &DeviceExtension->IsrDpc,
        (PKDEFERRED_ROUTINE) InportIsrDpc,
        DeviceExtension->Self
        );

    KeInitializeDpc(
        &DeviceExtension->IsrDpcRetry,
        (PKDEFERRED_ROUTINE) InportIsrDpc,
        DeviceExtension->Self
        );

    //
    // Initialize the mouse data consumption timer.
    //
    KeInitializeTimer(&DeviceExtension->DataConsumptionTimer);

    //
    // Initialize the port DPC queue to log overrun and internal
    // driver errors.
    //
    KeInitializeDpc(
        &DeviceExtension->ErrorLogDpc,
        (PKDEFERRED_ROUTINE) InportErrorLogDpc,
        DeviceExtension->Self 
        );

    configuration = &DeviceExtension->Configuration;
    //
    // Initialize and connect the interrupt object for the mouse.
    //

    status = IoConnectInterrupt(
                 &(DeviceExtension->InterruptObject),
                 (PKSERVICE_ROUTINE) InportInterruptService,
                 (PVOID) DeviceExtension->Self,
                 (PKSPIN_LOCK) NULL,
                 configuration->MouseInterrupt.u.Interrupt.Vector,
                 (KIRQL) configuration->MouseInterrupt.u.Interrupt.Level,
                 (KIRQL) configuration->MouseInterrupt.u.Interrupt.Level,
                 configuration->MouseInterrupt.Flags 
                     == CM_RESOURCE_INTERRUPT_LATCHED ? Latched:LevelSensitive, 
                 (BOOLEAN) (configuration->MouseInterrupt.ShareDisposition
                    == CmResourceShareShared),
                 configuration->MouseInterrupt.u.Interrupt.Affinity,
                 configuration->FloatingSave
                 );


    InpPrint((2, "INPORT-InpStartDevice: exit (%x)\n", status));

    return status;
}
 
VOID
InpDisableInterrupts(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is called from StartIo synchronously.  It touches the
    hardware to  disable interrupts.

Arguments:

    Context - Pointer to the device extension.

Return Value:

    None.

--*/

{
    PUCHAR port;
    PLONG  enableCount;
    UCHAR  mode;

    InpPrint((2, "INPORT-InpDisableInterrupts: enter\n"));

    //
    // Decrement the reference count for device enables.
    //

    enableCount = &((PDEVICE_EXTENSION) Context)->MouseEnableCount;
    *enableCount = *enableCount - 1;

    if (*enableCount == 0) {

        //
        // Get the port register address.
        //
    
        port = ((PDEVICE_EXTENSION) Context)->Configuration.DeviceRegisters[0];
    
#if defined(NEC_98)
        //
        // Mouse Timer Intrrupt Enable
        //
        WRITE_PORT_UCHAR(port + PC98_WritePortC2, (UCHAR)PC98_TimerIntDisable);
#else // defined(NEC_98)
        //
        // Select the mode register as the current data register.
        //
    
        WRITE_PORT_UCHAR((PUCHAR) port, INPORT_MODE_REGISTER);
    
        //
        // Read the current mode.
        //
    
        mode = READ_PORT_UCHAR((PUCHAR) (port + INPORT_DATA_REGISTER_1));
    
        //
        // Rewrite the mode byte with the interrupt disabled.
        //
    
        WRITE_PORT_UCHAR(
            (PUCHAR) (port + INPORT_DATA_REGISTER_1),
            (UCHAR) (mode & ~INPORT_DATA_INTERRUPT_ENABLE)
            );
#endif // defined(NEC_98)
    }

    InpPrint((2, "INPORT-InpDisableInterrupts: exit\n"));

}

VOID
InpEnableInterrupts(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is called from StartIo synchronously.  It touches the
    hardware to enable interrupts.

Arguments:

    Context - Pointer to the device extension.

Return Value:

    None.

--*/

{
    PUCHAR port;
    PLONG  enableCount;
    UCHAR  mode;
#if defined(NEC_98)
    UCHAR  HzMode;
#endif // defined(NEC_98)

    InpPrint((2, "INPORT-InpEnableInterrupts: enter\n"));

    enableCount = &((PDEVICE_EXTENSION) Context)->MouseEnableCount;

    if (*enableCount == 0) {

        //
        // Get the port register address.
        //
    
        port = ((PDEVICE_EXTENSION) Context)->Configuration.DeviceRegisters[0];
    
#if defined(NEC_98)
    //
    // Switch to event interrupt mode.
    //
    if (EventStatus)  {
        _asm { cli }
        WRITE_PORT_UCHAR((PUCHAR)PC98_ConfigurationPort, PC98_EventIntPort);
        WRITE_PORT_UCHAR((PUCHAR)PC98_ConfigurationDataPort, PC98_EventIntMode);
        _asm { sti }
    }

    //
    // Reset the Inport chip, leaving interrupts off.
    //
    WRITE_PORT_UCHAR(port + PC98_WriteModePort, PC98_InitializeCommand);

    //
    // Select the mode register as the current data register.
    // Set the Inport mouse up for quadrature mode,
    // and set the sample rate (i.e., the interrupt Hz rate).
    // Leave interrupts disabled.
    //
    if (EventStatus) {
        HzMode = (((PDEVICE_EXTENSION) Context)->Configuration.HzMode == 0)?
                 (UCHAR)PC98_EVENT_MODE_120HZ : (UCHAR)PC98_EVENT_MODE_60HZ;
    } else {
        HzMode = ((PDEVICE_EXTENSION) Context)->Configuration.HzMode;
    }

    WRITE_PORT_UCHAR(
        (PUCHAR)PC98_WriteTimerPort,
        (UCHAR)(HzMode|INPORT_MODE_QUADRATURE)
        );

    //
    // Mouse Timer Intrrupt Enable.
    //
    WRITE_PORT_UCHAR(port + PC98_WritePortC2, (UCHAR)PC98_TimerIntEnable);
#else // defined(NEC_98)
        //
        // Select the mode register as the current data register.
        //
    
        WRITE_PORT_UCHAR((PUCHAR) port, INPORT_MODE_REGISTER);
    
        //
        // Read the current mode.
        //
    
        mode = READ_PORT_UCHAR((PUCHAR) (port + INPORT_DATA_REGISTER_1));
    
        //
        // Rewrite the mode byte with the interrupt enabled.
        //
    
        WRITE_PORT_UCHAR(
            (PUCHAR) (port + INPORT_DATA_REGISTER_1),
            (UCHAR) (mode | INPORT_DATA_INTERRUPT_ENABLE)
            );
#endif // defined(NEC_98)
    }

    //
    // Increment the reference count for device enables.
    //

    *enableCount = *enableCount + 1;

    InpPrint((2, "INPORT-InpEnableInterrupts: exit\n"));
}

NTSTATUS
InpInitializeHardware(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine initializes the Inport mouse.  Note that this routine is
    only called at initialization time, so synchronization is not required.

Arguments:

    DeviceObject - Pointer to the device object.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION deviceExtension;
    PUCHAR mousePort;
    NTSTATUS status = STATUS_SUCCESS;

    InpPrint((2, "INPORT-InpInitializeHardware: enter\n"));

    //
    // Grab useful configuration parameters from the device extension.
    //

    deviceExtension = DeviceObject->DeviceExtension;
    mousePort = deviceExtension->Configuration.DeviceRegisters[0];

#if defined(NEC_98)
    //
    // Interrupt Disable NEC mouse chip,
    // because mouse interrupt Enable at ROM bios started.
    //
    WRITE_PORT_UCHAR(mousePort + PC98_WriteModePort, PC98_MouseDisable);
#else // defined(NEC_98)
    //
    // Reset the Inport chip, leaving interrupts off.
    //

    WRITE_PORT_UCHAR((PUCHAR) mousePort, INPORT_RESET);

    //
    // Select the mode register as the current data register.  Set the
    // Inport mouse up for quadrature mode, and set the sample
    // rate (i.e., the interrupt Hz rate).  Leave interrupts disabled.
    //

    WRITE_PORT_UCHAR((PUCHAR) mousePort, INPORT_MODE_REGISTER);
    WRITE_PORT_UCHAR(
        (PUCHAR) ((ULONG)mousePort + INPORT_DATA_REGISTER_1),
        (UCHAR) (deviceExtension->Configuration.HzMode
                 | INPORT_MODE_QUADRATURE)
        );
#endif // defined(NEC_98)

    InpPrint((2, "INPORT-InpInitializeHardware: exit\n"));

    return(status);

}

VOID
InpServiceParameters(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine retrieves this driver's service parameters information 
    from the registry.

Arguments:

    DeviceExtension - Pointer to the device extension.

    RegistryPath - Pointer to the null-terminated Unicode name of the 
        registry path for this driver.

    DeviceName - Pointer to the Unicode string that will receive
        the port device name.

Return Value:

    None.  As a side-effect, sets fields in DeviceExtension->Configuration.

--*/

{
    PINPORT_CONFIGURATION_INFORMATION configuration;
    PRTL_QUERY_REGISTRY_TABLE parameters = NULL;
    UNICODE_STRING parametersPath;
    HANDLE keyHandle;
    ULONG defaultDataQueueSize = DATA_QUEUE_SIZE;
    ULONG numberOfButtons = MOUSE_NUMBER_OF_BUTTONS;
    USHORT defaultNumberOfButtons = MOUSE_NUMBER_OF_BUTTONS;
#if defined(NEC_98)
    ULONG sampleRate = PC98_MOUSE_SAMPLE_RATE_120HZ;
    USHORT defaultSampleRate = PC98_MOUSE_SAMPLE_RATE_120HZ;
    ULONG hzMode = PC98_MODE_120HZ;
    USHORT defaultHzMode = PC98_MODE_120HZ;
#else // defined(NEC_98)
    ULONG sampleRate = MOUSE_SAMPLE_RATE_50HZ;
    USHORT defaultSampleRate = MOUSE_SAMPLE_RATE_50HZ;
    ULONG hzMode = INPORT_MODE_50HZ;
    USHORT defaultHzMode = INPORT_MODE_50HZ;
#endif // defined(NEC_98)
    UNICODE_STRING defaultUnicodeName;
    NTSTATUS status = STATUS_SUCCESS;
    PWSTR path = NULL;
    USHORT queriesPlusOne = 6;
#if !defined(NEC_98)
	ULONG defaultInterrupt = INP_DEF_VECTOR, interruptOverride;
#endif

    configuration = &DeviceExtension->Configuration;
    parametersPath.Buffer = NULL;

    //
    // Registry path is already null-terminated, so just use it.
    //

    path = RegistryPath->Buffer;

    if (NT_SUCCESS(status)) {

        //
        // Allocate the Rtl query table.
        //
    
        parameters = ExAllocatePool(
                         PagedPool,
                         sizeof(RTL_QUERY_REGISTRY_TABLE) * queriesPlusOne
                         );
    
        if (!parameters) {
    
            InpPrint((
                1,
                "INPORT-InpServiceParameters: Couldn't allocate table for Rtl query to parameters for %ws\n",
                 path
                 ));
    
            status = STATUS_UNSUCCESSFUL;
    
        } else {
    
            RtlZeroMemory(
                parameters,
                sizeof(RTL_QUERY_REGISTRY_TABLE) * queriesPlusOne
                );
    
            //
            // Form a path to this driver's Parameters subkey.
            //
    
            RtlInitUnicodeString(
                &parametersPath,
                NULL
                );
    
            parametersPath.MaximumLength = RegistryPath->Length +
                                           sizeof(L"\\Parameters");
    
            parametersPath.Buffer = ExAllocatePool(
                                        PagedPool,
                                        parametersPath.MaximumLength
                                        );
    
            if (!parametersPath.Buffer) {
    
                InpPrint((
                    1,
                    "INPORT-InpServiceParameters: Couldn't allocate string for path to parameters for %ws\n",
                     path
                    ));
    
                status = STATUS_UNSUCCESSFUL;
    
            }
        }
    }

    if (NT_SUCCESS(status)) {

        //
        // Form the parameters path.
        //
    
        RtlZeroMemory(
            parametersPath.Buffer,
            parametersPath.MaximumLength
            );
        RtlAppendUnicodeToString(
            &parametersPath,
            path
            );
        RtlAppendUnicodeToString(
            &parametersPath,
            L"\\Parameters"
            );
    
        InpPrint((
            1,
            "INPORT-InpServiceParameters: parameters path is %ws\n",
             parametersPath.Buffer
            ));

        //
        // Form the default pointer port device name, in case it is not
        // specified in the registry.
        //

        RtlInitUnicodeString(
            &defaultUnicodeName,
            DD_POINTER_PORT_BASE_NAME_U
            );

        //
        // Gather all of the "user specified" information from
        // the registry.
        //

        parameters[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[0].Name = L"MouseDataQueueSize";
        parameters[0].EntryContext = 
            &configuration->MouseAttributes.InputDataQueueLength;
        parameters[0].DefaultType = REG_DWORD;
        parameters[0].DefaultData = &defaultDataQueueSize;
        parameters[0].DefaultLength = sizeof(ULONG);
    
        parameters[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[1].Name = L"NumberOfButtons";
        parameters[1].EntryContext = &numberOfButtons;
        parameters[1].DefaultType = REG_DWORD;
        parameters[1].DefaultData = &defaultNumberOfButtons;
        parameters[1].DefaultLength = sizeof(USHORT);
    
        parameters[2].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[2].Name = L"SampleRate";
        parameters[2].EntryContext = &sampleRate;
        parameters[2].DefaultType = REG_DWORD;
        parameters[2].DefaultData = &defaultSampleRate;
        parameters[2].DefaultLength = sizeof(USHORT);
    
        parameters[3].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[3].Name = L"HzMode";
        parameters[3].EntryContext = &hzMode;
        parameters[3].DefaultType = REG_DWORD;
        parameters[3].DefaultData = &defaultHzMode;
        parameters[3].DefaultLength = sizeof(USHORT);

#if 0
        parameters[4].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[4].Name = L"PointerDeviceBaseName";
        parameters[4].EntryContext = DeviceName;
        parameters[4].DefaultType = REG_SZ;
        parameters[4].DefaultData = defaultUnicodeName.Buffer;
        parameters[4].DefaultLength = 0;
#endif

#if !defined(NEC_98)
        parameters[4].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[4].Name = L"InterruptOverride";
        parameters[4].EntryContext = &configuration->MouseInterrupt.u.Interrupt.Level;
        parameters[4].DefaultType = REG_DWORD;
        parameters[4].DefaultData = &defaultInterrupt;
        parameters[4].DefaultLength = sizeof(ULONG);
#endif

        status = RtlQueryRegistryValues(
                     RTL_REGISTRY_ABSOLUTE,
                     parametersPath.Buffer,
                     parameters,
                     NULL,
                     NULL
                     );

        if (!NT_SUCCESS(status)) {
            InpPrint((
                1,
                "INPORT-InpServiceParameters: RtlQueryRegistryValues failed with 0x%x\n",
                status
                ));
        }
    }

    if (!NT_SUCCESS(status)) {

        //
        // Go ahead and assign driver defaults.
        //

        configuration->MouseAttributes.InputDataQueueLength = 
            defaultDataQueueSize;
        // RtlCopyUnicodeString(DeviceName, &defaultUnicodeName);
    }

    //
    // Gather all of the "user specified" information from
    // the registry (this time from the devnode)
    //

    status = IoOpenDeviceRegistryKey(DeviceExtension->PDO,
                                     PLUGPLAY_REGKEY_DEVICE, 
                                     STANDARD_RIGHTS_READ,
                                     &keyHandle
                                     );

    if (NT_SUCCESS(status)) {
        //
        // If the value is not present in devnode, then the default is the value
        // read in from the Services\inport\Parameters key
        //
        ULONG   prevDataQueueSize,
                prevNumberOfButtons,
                prevSampleRate,
                prevHzMode;
#if 0
        UNICODE_STRING prevUnicodeName;
#endif

        prevDataQueueSize =
            configuration->MouseAttributes.InputDataQueueLength;
        prevNumberOfButtons = numberOfButtons;
        prevSampleRate = sampleRate;
        prevHzMode = hzMode;
#if 0
        RtlCopyUnicodeString(prevUnicodeName, DeviceName);
#endif

        parameters[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[0].Name = L"MouseDataQueueSize";
        parameters[0].EntryContext = 
            &configuration->MouseAttributes.InputDataQueueLength;
        parameters[0].DefaultType = REG_DWORD;
        parameters[0].DefaultData = &prevDataQueueSize;
        parameters[0].DefaultLength = sizeof(ULONG);
    
        parameters[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[1].Name = L"NumberOfButtons";
        parameters[1].EntryContext = &numberOfButtons;
        parameters[1].DefaultType = REG_DWORD;
        parameters[1].DefaultData = &prevNumberOfButtons;
        parameters[1].DefaultLength = sizeof(USHORT);
    
        parameters[2].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[2].Name = L"SampleRate";
        parameters[2].EntryContext = &sampleRate;
        parameters[2].DefaultType = REG_DWORD;
        parameters[2].DefaultData = &prevSampleRate;
        parameters[2].DefaultLength = sizeof(USHORT);
    
        parameters[3].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[3].Name = L"HzMode";
        parameters[3].EntryContext = &hzMode;
        parameters[3].DefaultType = REG_DWORD;
        parameters[3].DefaultData = &prevHzMode;
        parameters[3].DefaultLength = sizeof(USHORT);

#if 0
        parameters[4].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[4].Name = L"PointerDeviceBaseName";
        parameters[4].EntryContext = DeviceName;
        parameters[4].DefaultType = REG_SZ;
        parameters[4].DefaultData = prevUnicodeName.Buffer;
        parameters[4].DefaultLength = 0;
#endif

#if !defined(NEC_98)
        parameters[4].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[4].Name = L"InterruptOverride";
        parameters[4].EntryContext = &configuration->MouseInterrupt.u.Interrupt.Level;
        parameters[4].DefaultType = REG_DWORD;
        parameters[4].DefaultData = &defaultInterrupt;
        parameters[4].DefaultLength = sizeof(ULONG);
#endif
    
        status = RtlQueryRegistryValues(
                    RTL_REGISTRY_HANDLE,
                    (PWSTR) keyHandle, 
                    parameters,
                    NULL,
                    NULL
                    );

        if (!NT_SUCCESS(status)) {
            InpPrint((
                1,
                "INPORT-InpServiceParameters: RtlQueryRegistryValues (via handle) failed (0x%x)\n",
                status
                ));
        }

        ZwClose(keyHandle);
    }
    else {
        InpPrint((
            1,
            "INPORT-InpServiceParameters: opening devnode handle failed (0x%x)\n",
            status
            ));
    }

#if 0
    InpPrint((
        1,
        "INPORT-InpServiceParameters: Pointer port base name = %ws\n",
        DeviceName->Buffer
        ));
#endif 0

    if (configuration->MouseAttributes.InputDataQueueLength == 0) {

        InpPrint((
            1,
            "INPORT-InpServiceParameters: overriding MouseInputDataQueueLength = 0x%x\n",
            configuration->MouseAttributes.InputDataQueueLength
            ));

        configuration->MouseAttributes.InputDataQueueLength = 
            defaultDataQueueSize;
    }

    configuration->MouseAttributes.InputDataQueueLength *= 
        sizeof(MOUSE_INPUT_DATA);

    InpPrint((
        1,
        "INPORT-InpServiceParameters: MouseInputDataQueueLength = 0x%x\n",
        configuration->MouseAttributes.InputDataQueueLength
        ));

    configuration->MouseAttributes.NumberOfButtons = (USHORT) numberOfButtons;
    InpPrint((
        1,
        "INPORT-InpServiceParameters: NumberOfButtons = %d\n",
        configuration->MouseAttributes.NumberOfButtons
        ));

    configuration->MouseAttributes.SampleRate = (USHORT) sampleRate;
    InpPrint((
        1,
        "INPORT-InpServiceParameters: SampleRate = %d\n",
        configuration->MouseAttributes.SampleRate
        ));

    configuration->HzMode = (UCHAR) hzMode;
    InpPrint((
        1,
        "INPORT-InpServiceParameters: HzMode = %d\n",
        configuration->HzMode
        ));

    //
    // Free the allocated memory before returning.
    //

    if (parametersPath.Buffer)
        ExFreePool(parametersPath.Buffer);
    if (parameters)
        ExFreePool(parameters);

}
#if defined(NEC_98)
#define ISA_BUS_NODE    "\\Registry\\MACHINE\\HARDWARE\\DESCRIPTION\\System\\MultifunctionAdapter\\%d"
ULONG
QueryEventMode(
    IN OUT VOID
    )
{
    ULONG   NodeNumber = 0;
    NTSTATUS Status;
    RTL_QUERY_REGISTRY_TABLE parameters[2];

    UNICODE_STRING invalidBusName;
    UNICODE_STRING targetBusName;
    UNICODE_STRING isaBusName;

    UCHAR Configuration_Data1[1192];
    ULONG Configuration;
    RTL_QUERY_REGISTRY_TABLE QueryTable[] =
    {
      {NULL,
       RTL_QUERY_REGISTRY_DIRECT,
       L"Configuration Data",
       Configuration_Data1,
       REG_DWORD,
       (PVOID) &Configuration,
       0},
       {NULL, 0, NULL, NULL, REG_NONE, NULL, 0}
    };

    InpPrint((2,"INPORT-QueryEventMode: enter\n"));

    //
    // Initialize invalid bus name.
    //
    RtlInitUnicodeString(&invalidBusName,L"BADBUS");

    //
    // Initialize "ISA" bus name.
    //
    RtlInitUnicodeString(&isaBusName,L"ISA");

    parameters[0].QueryRoutine = NULL;
    parameters[0].Flags = RTL_QUERY_REGISTRY_REQUIRED |
                          RTL_QUERY_REGISTRY_DIRECT;
    parameters[0].Name = L"Identifier";
    parameters[0].EntryContext = &targetBusName;
    parameters[0].DefaultType = REG_SZ;
    parameters[0].DefaultData = &invalidBusName;
    parameters[0].DefaultLength = 0;

    parameters[1].QueryRoutine = NULL;
    parameters[1].Flags = 0;
    parameters[1].Name = NULL;
    parameters[1].EntryContext = NULL;

    do {
        CHAR AnsiBuffer[512];

        ANSI_STRING AnsiString;
        UNICODE_STRING registryPath;

        //
        // Initialize receive buffer.
        //
        targetBusName.Buffer = NULL;

        //
        // Build path buffer...
        //
        sprintf(AnsiBuffer,ISA_BUS_NODE,NodeNumber);
        RtlInitAnsiString(&AnsiString,AnsiBuffer);
        Status = RtlAnsiStringToUnicodeString(&registryPath,&AnsiString,TRUE);

        if (!NT_SUCCESS(Status)) {
            //
            // Cannot get memory for registry path(query fails)
            //
            InpPrint((1,"INPORT-QueryEventMode: cannot get registryPath\n"));
            break;
        }

        //
        // Query it.
        //
        Status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                        registryPath.Buffer,
                                        parameters,
                                        NULL,
                                        NULL);

        if (!NT_SUCCESS(Status) || (targetBusName.Buffer == NULL)) {
            RtlFreeUnicodeString(&registryPath);
            break;
        }

        //
        // Is this "ISA" node ?
        //
        if (RtlCompareUnicodeString(&targetBusName,&isaBusName,TRUE) == 0) {

            //
            // Found.
            //
            ((PULONG)Configuration_Data1)[0] = 1192;
            RtlQueryRegistryValues(
                RTL_REGISTRY_ABSOLUTE,
                registryPath.Buffer,
                QueryTable,
                NULL,
                NULL);
            RtlFreeUnicodeString(&registryPath);

            if ((((PCONFIGURATION_DATA) Configuration_Data1)->COM_ID[0] == 0x98) &&
                (((PCONFIGURATION_DATA) Configuration_Data1)->COM_ID[1] == 0x21)) {
                EventStatus = ((PCONFIGURATION_DATA)Configuration_Data1)->EventMouseID.EventMouse;
            }
            break;
        }

        //
        // Can we find any node for this ??
        //
        if (RtlCompareUnicodeString(&targetBusName,&invalidBusName,TRUE) == 0) {
            //
            // Not found.
            //
            InpPrint((1, "INPORT-QueryEventMode: ISA not found"));
            RtlFreeUnicodeString(&registryPath);
            break;
        }

        RtlFreeUnicodeString(&targetBusName);

        //
        // Next node number..
        //
        NodeNumber++;

    } while (TRUE);
        
    if (targetBusName.Buffer) {
        RtlFreeUnicodeString(&targetBusName);
    }

    InpPrint((2, "INPORT-QueryEventMode: Event Interrupt mode is "));
    if (EventStatus) {
        InpPrint((2, "available\n"));
    } else {
        InpPrint((2, "not available\n"));
    }

    InpPrint((2,"INPORT-QueryEventMode: exit\n"));

    return EventStatus;
}

VOID
InportReinitializeHardware (
    PWORK_QUEUE_ITEM Item
    )
{
    NTSTATUS        status = STATUS_SUCCESS;
    PDEVICE_OBJECT  DeviceObject;
    PDEVICE_EXTENSION DeviceExtension;
    PUCHAR            port;
    UCHAR            HzMode;

    DeviceObject = Globals.DeviceObject;
    InpPrint((2,"INPORT-InportReinitializeHardware: enter\n"));

    status = InpInitializeHardware(DeviceObject);
    if (NT_SUCCESS(status)) {

        DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
        InpEnableInterrupts(DeviceExtension);

        //
        // Enable interrupt of hibernation/sleep for NEC_98.
        //
        //
        // Get the port register address.
        //
        port = DeviceExtension->Configuration.DeviceRegisters[0];

        //
        // Switch to event interrupt mode.
        //
        if (EventStatus)  {
            _asm { cli }
            WRITE_PORT_UCHAR((PUCHAR)PC98_ConfigurationPort, PC98_EventIntPort);
            WRITE_PORT_UCHAR((PUCHAR)PC98_ConfigurationDataPort, PC98_EventIntMode);
            _asm { sti }
        }

        //
        // Reset the Inport chip, leaving interrupts off.
        //
        WRITE_PORT_UCHAR(port + PC98_WriteModePort, PC98_InitializeCommand);

        //
        // Select the mode register as the current data register.
        // Set the Inport mouse up for quadrature mode,
        // and set the sample rate (i.e., the interrupt Hz rate).
        // Leave interrupts disabled.
        //
        if (EventStatus) {
            HzMode = (DeviceExtension->Configuration.HzMode == 0)?
                     (UCHAR)PC98_EVENT_MODE_120HZ : (UCHAR)PC98_EVENT_MODE_60HZ;
        } else {
            HzMode = (UCHAR)(DeviceExtension->Configuration.HzMode|INPORT_MODE_QUADRATURE);
        }

        WRITE_PORT_UCHAR(
            (PUCHAR)PC98_WriteTimerPort,
            (UCHAR)(HzMode|INPORT_MODE_QUADRATURE)
            );

        //
        // Mouse Timer Intrrupt Enable.
        //
        WRITE_PORT_UCHAR(port + PC98_WritePortC2, (UCHAR)PC98_TimerIntEnable);

    }
    else {
        InpPrint((1,"INPORT-InportReinitializeHardware: failed, 0x%x\n", status));
    }

    ExFreePool(Item);
    InpPrint((2,"INPORT-InportReinitializeHardware: exit\n"));

}

#endif // defined(NEC_98)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\joystick\anajoyst.c ===
#include <ntddk.h>
#include <windef.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <ntddjoy.h>

#define ANAJOYST_VERSION 10


// Device extension data
typedef struct {

    // JOYSTICKID0 or JOYDSTICKID1
    DWORD DeviceNumber;

    // Number of axes supported and configured for this device.
    DWORD NumberOfAxes;

    // TRUE if there are two joysticks installed
    BOOL bTwoSticks;

    // The I/O address of the device, usually 0x201
    PUCHAR DeviceAddress;

    // A Spinlock is used to synchronize access to this device. This is
    // a pointer to the actual spinlock data area
    PKSPIN_LOCK SpinLock;

    // Actual SpinLock data area
    KSPIN_LOCK SpinLockData;

}  JOY_EXTENSION, *PJOY_EXTENSION;


//  Debugging macros

#ifdef DEBUG
#define ENABLE_DEBUG_TRACE
#endif

#ifdef ENABLE_DEBUG_TRACE
#define DebugTrace(_x_)      \
    DbgPrint("Joystick: ");  \
    KdPrint(_x_);            \
    DbgPrint("\n");
#else
#define DebugTrace(_x_)
#endif


// Global values (mostly timing related)

JOY_STATISTICS JoyStatistics;   // Debugging and performance testing

// The high resolution system clock (from KeQueryPerformanceCounter) is updated at this frequency
DWORD Frequency;

// min number of KeQueryPerformanceCounter ticks between polls
// Used to prevent too-frequent polling of joystick
DWORD nMinTicksBetweenPolls;

//  Last good packet
BOOL bLastGoodPacket;                 // TRUE if there is a last good packet
JOY_DD_INPUT_DATA jjLastGoodPacket;   // data in last good packet

// time at which the joystick was last polled
LARGE_INTEGER liLastPoll;   // set whenever the joystick's polled

// The maximum duration of a polling cycle (expressed in ticks).
DWORD MaxTimeoutInTicks;

// The maximum duration of a polling cycle for use in quiesce wait
LONG nQuiesceLoop;

// The minimum resolution of a polling cycle. This is used to detect
// if we've been pre-empted or interrupted during a polling loop. If
// we have been, we can retry the operation.
DWORD ThresholdInTicks;

// End of Global Values


// Routine Prototypes

NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  pDriverObject,
    IN  PUNICODE_STRING RegistryPathName
);


NTSTATUS
AnajoystCreateDevice(
    PDRIVER_OBJECT pDriverObject,
    PWSTR DeviceNameBase,
    DWORD DeviceNumber,
    DWORD ExtensionSize,
    BOOLEAN  Exclusive,
    DWORD DeviceType,
    PDEVICE_OBJECT *DeviceObject
);


NTSTATUS
AnajoystDispatch(
    IN  PDEVICE_OBJECT pDO,
    IN  PIRP pIrp
);


NTSTATUS
AnajoystReadRegistryParameterDWORD(
    PUNICODE_STRING RegistryPathName,
    PWSTR  ParameterName,
    PDWORD ParameterValue
);


NTSTATUS
AnajoystMapDevice(
    DWORD PortBase,
    DWORD NumberOfPorts,
    PJOY_EXTENSION pJoyExtension
);


VOID
AnajoystUnload(
    PDRIVER_OBJECT pDriverObject
);


BOOL
AnajoystQuiesce(
    PUCHAR JoyPort,
    UCHAR  Mask
);


DWORD
TimeInMicroSeconds(
    DWORD dwTime
);


DWORD
TimeInTicks(
    DWORD dwTimeInMicroSeconds
);


int
lstrnicmpW(
    LPWSTR pszA,
    LPWSTR pszB,
    size_t cch
);


void
AnajoystGetConfig(
    LPJOYREGHWCONFIG pConfig,
    PJOY_EXTENSION pJoyExtension
);


NTSTATUS
AnajoystAnalogPoll(
    PDEVICE_OBJECT pDO,
    PIRP    pIrp
);

NTSTATUS
AnajoystPoll(
    IN  PDEVICE_OBJECT pDO,
    IN  PIRP pIrp
);


NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  pDriverObject,
    IN  PUNICODE_STRING RegistryPathName
)
/*++
Routine Description:
    This routine is called at system initialization time to initialize
    this driver.

Arguments:
    DriverObject    - Supplies the driver object.
    RegistryPath    - Supplies the registry path for this driver.

Return Value:
    STATUS_SUCCESS
    STATUS_DEVICE_CONFIGURATION_ERROR - Wrong number of axi in the registry
    or error status from NT itself

--*/
{
    NTSTATUS Status;
    PDEVICE_OBJECT pJoyDevice0;
    PDEVICE_OBJECT pJoyDevice1;
    DWORD NumberOfAxes;
    BOOL  bTwoSticks;
    DWORD DeviceAddress;

    PJOY_EXTENSION pext0, pext1;


    //DbgBreakPoint();
    JoyStatistics.Version = ANAJOYST_VERSION;
    DebugTrace(("Anajoyst %d", JoyStatistics.Version));

    // Read registry parameters.  These parameters are set up by the driver
    // installation program and can be modified by the control panel applets.

    // Number of axes
    Status = AnajoystReadRegistryParameterDWORD(
                RegistryPathName,
                JOY_DD_NAXES_U,
                &NumberOfAxes
                );
    DebugTrace(("Number of axes returned from registry: %d", NumberOfAxes));
    if (!NT_SUCCESS(Status))
    {
        AnajoystUnload(pDriverObject);
        return Status;
    }
    if (( NumberOfAxes < 2) || (NumberOfAxes > 4))
    {
        AnajoystUnload(pDriverObject);
        Status = STATUS_DEVICE_CONFIGURATION_ERROR;
        return Status;
    }

    // Device address (usually 0x201)
    Status = AnajoystReadRegistryParameterDWORD(
                RegistryPathName,
                JOY_DD_DEVICE_ADDRESS_U,
                &DeviceAddress
                );
    if (NT_SUCCESS(Status))
    {
        DebugTrace(("Registry specified device address of 0x%x", DeviceAddress));
    }
    else
    {
        DebugTrace(("Using default device address of 0x%x", JOY_IO_PORT_ADDRESS));
        DeviceAddress = JOY_IO_PORT_ADDRESS;
    }

    // Number of joysticks
    Status = AnajoystReadRegistryParameterDWORD(
                RegistryPathName,
                JOY_DD_TWOSTICKS_U,
                &bTwoSticks
                );
    bTwoSticks = !!bTwoSticks;
    DebugTrace(("bTwoSticks: %ld", bTwoSticks));
    if (!NT_SUCCESS(Status))
    {
        AnajoystUnload(pDriverObject);
        return Status;
    }

    // if two joysticks are installed, only support two axes per joystick
    if (bTwoSticks)
    {
        NumberOfAxes = 2;
    }

    // Calculate time thresholds for analog device
    {
        //DWORD Remainder;
        LARGE_INTEGER LargeFrequency;
        //DWORD ulStart, ulTemp, ulEnd;
        //DWORD dwTicks, dwTimems;
        //int i;
        //BYTE byteJoy, byteTmp;

        // Get the system timer resolution expressed in Hertz.
        KeQueryPerformanceCounter(&LargeFrequency);

        Frequency = LargeFrequency.LowPart;

        DebugTrace(("Frequency: %u", Frequency));
        
        //ThresholdInTicks = RtlExtendedLargeIntegerDivide(
        //                        RtlExtendedIntegerMultiply(
        //                            LargeFrequency,
        //                            ANALOG_POLL_RESOLUTION
        //                        ),
        //                        1000000L,
        //                        &Remainder).LowPart;
        //DebugTrace(("ThresholdInTicks: %u", ThresholdInTicks));

        ThresholdInTicks = (DWORD) (((__int64)Frequency * (__int64)ANALOG_POLL_RESOLUTION) / (__int64)1000000L);
        DebugTrace(("ThresholdInTicks: %u", ThresholdInTicks));

        //MaxTimeoutInTicks = RtlExtendedLargeIntegerDivide(
        //                        RtlExtendedIntegerMultiply(
        //                            LargeFrequency,
        //                            ANALOG_POLL_TIMEOUT
        //                        ),
        //                        1000000L,
        //                        &Remainder).LowPart;
        //DebugTrace(("MaxTimeoutInTicks: %u", MaxTimeoutInTicks));
        
        MaxTimeoutInTicks = (DWORD) (((__int64)Frequency * (__int64)ANALOG_POLL_TIMEOUT) / (__int64)1000000L);
        DebugTrace(("MaxTimeoutInTicks: %u", MaxTimeoutInTicks));
        
        // need latency for KeQueryPerformanceCounter.  While we're at it, let's
        // get min time for delay and stall execution


        //ulStart = KeQueryPerformanceCounter(NULL).LowPart;
        //for (i = 0; i < 1000; i++) {
        //    ulTemp = KeQueryPerformanceCounter(NULL).LowPart;
        //}
        //dwTicks = ulTemp - ulStart;
        //dwTimems = TimeInMicroSeconds (dwTicks);


    }


    // Create the device
    Status = AnajoystCreateDevice(
                pDriverObject,
                JOY_DD_DEVICE_NAME_U,    // device driver
                0,
                sizeof(JOY_EXTENSION),
                FALSE,                   // exclusive access
                FILE_DEVICE_UNKNOWN,
                &pJoyDevice0);

    if (!NT_SUCCESS(Status))
    {
        DebugTrace(("SwndrCreateDevice returned %x", Status));
        AnajoystUnload(pDriverObject);
        return Status;
    }

  //((PJOY_EXTENSION)pJoyDevice0->DeviceExtension)->DeviceNumber = JOYSTICKID1;
  //((PJOY_EXTENSION)pJoyDevice0->DeviceExtension)->NumberOfAxes = NumberOfAxes;
  //((PJOY_EXTENSION)pJoyDevice0->DeviceExtension)->DeviceAddress  = (PUCHAR) 0;
    pext0 = (PJOY_EXTENSION)pJoyDevice0->DeviceExtension;
    pext0->DeviceNumber = JOYSTICKID1;
    pext0->NumberOfAxes = NumberOfAxes;
    pext0->bTwoSticks = bTwoSticks;
    pext0->DeviceAddress  = (PUCHAR) 0;

    // Initialize the spinlock used to synchronize access to this device
//    KeInitializeSpinLock(&((PJOY_EXTENSION)pJoyDevice0->DeviceExtension)->SpinLockData);
//    ((PJOY_EXTENSION)pJoyDevice0->DeviceExtension)->SpinLock =
//            &((PJOY_EXTENSION)pJoyDevice0->DeviceExtension)->SpinLockData;
    KeInitializeSpinLock(&pext0->SpinLockData);
    pext0->SpinLock = &pext0->SpinLockData;

    // Get the device address into the device extension
    Status = AnajoystMapDevice(
                DeviceAddress,
                1,
                pext0);
//              (PJOY_EXTENSION)pJoyDevice0->DeviceExtension);


    // Calibrate nQuiesceLoop for spinning in read_port loops to timeout after 10ms
    {
        int i;
        PBYTE JoyPort;
        DWORD ulStart, ulEnd;
        BYTE byteJoy;
        int LoopTimeInMicroSeconds;

        JoyPort = ((PJOY_EXTENSION)pJoyDevice0->DeviceExtension)->DeviceAddress;

        ulStart = KeQueryPerformanceCounter(NULL).LowPart;
        for (i = 0; i < 1000; i++) {
            byteJoy = READ_PORT_UCHAR(JoyPort);
            if ((byteJoy & X_AXIS_BITMASK)) {
                ;
            }
        }
        ulEnd = KeQueryPerformanceCounter(NULL).LowPart;
        LoopTimeInMicroSeconds = TimeInMicroSeconds (ulEnd - ulStart);
        nQuiesceLoop = (DWORD) (((__int64)1000L * (__int64)ANALOG_POLL_TIMEOUT) / (__int64)LoopTimeInMicroSeconds);
        DebugTrace(("READ_PORT_UCHAR loop, 1000 interations: %u ticks", ulEnd - ulStart));
        DebugTrace(("nQuiesceLoop: %u", nQuiesceLoop));
    }

    // if 2 joysticks are installed, support a second device
    if (bTwoSticks)
    {
        Status = AnajoystCreateDevice(
                    pDriverObject,
                    JOY_DD_DEVICE_NAME_U,
                    1,                      // device number
                    sizeof (JOY_EXTENSION),
                    FALSE,                  // exclusive access
                    FILE_DEVICE_UNKNOWN,
                    &pJoyDevice1);

        if (!NT_SUCCESS(Status))
        {
            DebugTrace(("Create device for second device returned %x", Status));
            AnajoystUnload(pDriverObject);
            return Status;
        }

//        // Both devices share the same I/O address so just copy it from pJoyDevice0
//        ((PJOY_EXTENSION)pJoyDevice1->DeviceExtension)->DeviceAddress =
//            ((PJOY_EXTENSION)pJoyDevice0->DeviceExtension)->DeviceAddress;
//        ((PJOY_EXTENSION)pJoyDevice1->DeviceExtension)->DeviceNumber = JOYSTICKID2;
//        ((PJOY_EXTENSION)pJoyDevice1->DeviceExtension)->NumberOfAxes = NumberOfAxes;
//
//        // Initialize the spinlock used to synchronize access to this device
//        KeInitializeSpinLock(&((PJOY_EXTENSION)pJoyDevice1->DeviceExtension)->SpinLockData);
//        ((PJOY_EXTENSION)pJoyDevice1->DeviceExtension)->SpinLock =
//                &((PJOY_EXTENSION)pJoyDevice1->DeviceExtension)->SpinLockData;

        pext1 = (PJOY_EXTENSION)pJoyDevice1->DeviceExtension;
        // Both devices share the same I/O address so just copy it from pJoyDevice0
        pext1->DeviceAddress = pext0->DeviceAddress;
        pext1->DeviceNumber = JOYSTICKID2;
        pext1->NumberOfAxes = NumberOfAxes;
        pext1->bTwoSticks = bTwoSticks;	// (will be TRUE)

        // Initialize the spinlock used to synchronize access to this device
        KeInitializeSpinLock(&pext1->SpinLockData);
        pext1->SpinLock = &pext1->SpinLockData;
    
    }

    // Define entry points
    pDriverObject->DriverUnload                         = AnajoystUnload;
    pDriverObject->MajorFunction[IRP_MJ_CREATE]         = AnajoystDispatch;
    pDriverObject->MajorFunction[IRP_MJ_CLOSE]          = AnajoystDispatch;
    pDriverObject->MajorFunction[IRP_MJ_READ]           = AnajoystDispatch;
    pDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = AnajoystDispatch;

    // Zero statistics, set misc globals
    JoyStatistics.Polls         = 0;
    JoyStatistics.Timeouts      = 0;
    JoyStatistics.PolledTooSoon = 0;
    JoyStatistics.Redo          = 0;

    // allow max of 100 polls/s (min time  between polls 10ms), which reduces time spinning in the NT kernel
    nMinTicksBetweenPolls = TimeInTicks (10000);
    bLastGoodPacket = FALSE;
    liLastPoll = KeQueryPerformanceCounter (NULL);

    return STATUS_SUCCESS;

}


NTSTATUS
AnajoystCreateDevice(
    PDRIVER_OBJECT pDriverObject,
    PWSTR DeviceNameBase,
    DWORD DeviceNumber,
    DWORD ExtensionSize,
    BOOLEAN  Exclusive,
    DWORD DeviceType,
    PDEVICE_OBJECT *DeviceObject
)
/*++

Routine Description:
    This routine is called at driver initialization time to create
    the device. The device is created to use Buffered IO.

Arguments:
    pDriverObject   - Supplies the driver object.
    DeviceNameBase  - The base name of the device to which a number is appended
    DeviceNumber    - A number which will be appended to the device name
    ExtensionSize   - Size of the device extension area
    Exclusive       - True if exclusive access should be enforced
    DeviceType      - NT Device type this device is modeled after
    DeviceObject    - pointer to the device object

Return Value:
    STATUS_SUCCESS
    or error status from NT itself

--*/
{

    WCHAR DeviceName[100];
    WCHAR UnicodeDosDeviceName[200];

    UNICODE_STRING UnicodeDeviceName;
    NTSTATUS Status;
    int Length;

    (void) wcscpy(DeviceName, DeviceNameBase);
    Length = wcslen(DeviceName);
    DeviceName[Length + 1] = L'\0';
    DeviceName[Length] = (USHORT) (L'0' + DeviceNumber);

    (void) RtlInitUnicodeString(&UnicodeDeviceName, DeviceName);

    Status = IoCreateDevice(
                pDriverObject,
                ExtensionSize,
                &UnicodeDeviceName,
                DeviceType,
                0,
                (BOOLEAN) Exclusive,
                DeviceObject
                );

    if (!NT_SUCCESS(Status))
    {
        return Status;
    }


    // very crude hack here, do the right thing sometime
    if (DeviceNumber == 0) {
        RtlInitUnicodeString((PUNICODE_STRING) &UnicodeDosDeviceName, L"\\DosDevices\\Joy1");
    }
    else {
        RtlInitUnicodeString((PUNICODE_STRING) &UnicodeDosDeviceName, L"\\DosDevices\\Joy2");
    }

    Status = IoCreateSymbolicLink(
                (PUNICODE_STRING) &UnicodeDosDeviceName,
                (PUNICODE_STRING) &UnicodeDeviceName
                );

    if (!NT_SUCCESS(Status))
    {
        return Status;
    }




    // Set the flag signifying that we will do buffered I/O. This causes NT
    // to allocate a buffer on a ReadFile operation which will then be copied
    // back to the calling application by the I/O subsystem


    (*DeviceObject)->Flags |= DO_BUFFERED_IO;


    return Status;

}



NTSTATUS
AnajoystReadRegistryParameterDWORD(
    PUNICODE_STRING RegistryPathName,
    PWSTR  ParameterName,
    PDWORD ParameterValue
)
/*++

Routine Description:
    This routine reads registry values for the driver configuration

Arguments:
    RegistryPathName    -  Registry path containing the desired parameters
    ParameterName       -  The name of the parameter
    ParameterValue      -  Variable to receive the parameter value

Return Value:
    STATUS_SUCCESS                      --
    STATUS_NO_MORE_ENTRIES              --  Couldn't find any entries
    STATUS_INSUFFICIENT_RESOURCES       --  Couldn't allocate paged pool
    STATUS_DEVICE_CONFIGURATION_ERROR   --  Returned value wasn't a DWORD
    or error status from NT itself

-- */
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS Status;

    HANDLE ServiceKey;
    HANDLE DeviceKey;           // Key handle of service node
    UNICODE_STRING DeviceName;  // Key to parameter node
    DWORD KeyIndex;
    DWORD KeyValueLength;
    PBYTE KeyData;
    BOOL  ValueWasFound;
    PKEY_VALUE_FULL_INFORMATION KeyInfo;

    InitializeObjectAttributes( &ObjectAttributes,
                                RegistryPathName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                (PSECURITY_DESCRIPTOR) NULL);

    //
    // Open a key for our services node entry
    //

    Status = ZwOpenKey( &ServiceKey,
                        KEY_READ | KEY_WRITE,
                        &ObjectAttributes);

    if (!NT_SUCCESS(Status))
    {
        return Status;
    }


    //
    // Open the key to our device subkey
    //

    RtlInitUnicodeString(&DeviceName, L"Parameters");

    InitializeObjectAttributes( &ObjectAttributes,
                                &DeviceName,
                                OBJ_CASE_INSENSITIVE,
                                ServiceKey,
                                (PSECURITY_DESCRIPTOR) NULL);

    Status = ZwOpenKey (&DeviceKey,
                        KEY_READ | KEY_WRITE,
                        &ObjectAttributes);


    ZwClose(ServiceKey);


    if (!NT_SUCCESS(Status))
    {
        return Status;
    }

    //
    // Loop reading our key values
    //

    // TODO exit loop when value is found?
    ValueWasFound = FALSE;

    for (KeyIndex = 0; ; KeyIndex++)
    {
        KeyValueLength = 0;

        //
        // find out how much data we will get
        //

        Status = ZwEnumerateValueKey(
                    DeviceKey,
                    KeyIndex,
                    KeyValueFullInformation,
                    NULL,
                    0,
                    &KeyValueLength);

        if (STATUS_NO_MORE_ENTRIES == Status)
        {
            break;
        }

        if (0 == KeyValueLength)
        {
            return Status;
        }

        //
        // Read the data
        //

        KeyData = ExAllocatePool (PagedPool, KeyValueLength);

        if (NULL == KeyData)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }


        Status = ZwEnumerateValueKey(
                    DeviceKey,
                    KeyIndex,
                    KeyValueFullInformation,
                    KeyData,
                    KeyValueLength,
                    &KeyValueLength);

        if (!NT_SUCCESS(Status))
        {
            ExFreePool(KeyData);
            return Status;
        }

        KeyInfo = (PKEY_VALUE_FULL_INFORMATION) KeyData;

        if (0 == lstrnicmpW(KeyInfo->Name,
                            ParameterName,
                            KeyInfo->NameLength / sizeof(WCHAR)))
        {
            // check its a DWORD

            if (REG_DWORD != KeyInfo->Type)
            {
                ExFreePool(KeyData);
                return STATUS_DEVICE_CONFIGURATION_ERROR;
            }

            ValueWasFound = TRUE;

            *ParameterValue = *(PDWORD) (KeyData + KeyInfo->DataOffset);
        }

        ExFreePool(KeyData);

    }

    return (ValueWasFound) ? STATUS_SUCCESS : STATUS_DEVICE_CONFIGURATION_ERROR;

}


NTSTATUS
AnajoystDispatch(
    IN  PDEVICE_OBJECT pDO,
    IN  PIRP pIrp
)
/*++

Routine Description:
    Driver dispatch routine. Processes IRPs based on IRP MajorFunction

Arguments:
    pDO     -- pointer to the device object
    pIrp    -- pointer to the IRP to process

Return Value:
    Returns the value of the IRP IoStatus.Status

--*/
{
    PIO_STACK_LOCATION pIrpStack;
    KIRQL OldIrql;
    NTSTATUS  Status;
    DWORD     dwRetries = 0;

    //DbgBreakPoint();

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

    Status = STATUS_SUCCESS;
    pIrp->IoStatus.Status = Status;
    pIrp->IoStatus.Information = 0;

    switch (pIrpStack->MajorFunction)
    {
        case IRP_MJ_CREATE:

            //
            // perform synchronous I/O
            //

            //pIrpStack->FileObject->Flags |= FO_SYNCHRONOUS_IO;
            //NB This is bad code -- we are simply one thread wandering off through the computer -- we should be queuing up a DPC,
            //returning status_pending to the calling program, then finishing the job when the dpc goes.  This is possible given
            //the analog game port technology.

            // don't slam it into digital mode
            //Status = AnajoystReset (((PJOY_EXTENSION)pDO->DeviceExtension)->DeviceAddress);

            //((PJOY_EXTENSION)pDO->DeviceExtension)->CurrentDeviceMode = NULL;

            // KeDelayExecutionThread( KernelMode, FALSE, &LI10ms); //unnecessary since AnajoystReset has a delay in it?

            pIrp->IoStatus.Status = Status;
            break;

        case IRP_MJ_CLOSE:

            break;

        case IRP_MJ_READ:

            //
            // Find out which device we are and read, but first make sure
            // there is enough room
            //

            DebugTrace(("IRP_MJ_READ"));
            //DbgBreakPoint();


            if (pIrpStack->Parameters.Read.Length < sizeof(JOY_DD_INPUT_DATA))
            {
                Status = STATUS_BUFFER_TOO_SMALL;
                pIrp->IoStatus.Status = Status;
                break;
            }

            //
            // Serialize and get the current device values
            //

            KeAcquireSpinLock(((PJOY_EXTENSION) pDO->DeviceExtension)->SpinLock,
                                & OldIrql);


            Status = AnajoystPoll(pDO, pIrp);

            //
            // release the spinlock
            //

            KeReleaseSpinLock(((PJOY_EXTENSION)pDO->DeviceExtension)->SpinLock,
                              OldIrql);

            pIrp->IoStatus.Status = Status;
            pIrp->IoStatus.Information  = sizeof (JOY_DD_INPUT_DATA);
            break;


        case IRP_MJ_DEVICE_CONTROL:

            switch (pIrpStack->Parameters.DeviceIoControl.IoControlCode)
            {
                case IOCTL_JOY_GET_STATISTICS:

                    // report statistics
                    ((PJOY_STATISTICS)pIrp->AssociatedIrp.SystemBuffer)->Version       = JoyStatistics.Version;
                    ((PJOY_STATISTICS)pIrp->AssociatedIrp.SystemBuffer)->Polls         = JoyStatistics.Polls;
                    ((PJOY_STATISTICS)pIrp->AssociatedIrp.SystemBuffer)->Timeouts      = JoyStatistics.Timeouts;
                    ((PJOY_STATISTICS)pIrp->AssociatedIrp.SystemBuffer)->PolledTooSoon = JoyStatistics.PolledTooSoon;
                    ((PJOY_STATISTICS)pIrp->AssociatedIrp.SystemBuffer)->Redo          = JoyStatistics.Redo;

                    ((PJOY_STATISTICS)pIrp->AssociatedIrp.SystemBuffer)->nQuiesceLoop = nQuiesceLoop;
                    ((PJOY_STATISTICS)pIrp->AssociatedIrp.SystemBuffer)->Frequency    = Frequency;
                    ((PJOY_STATISTICS)pIrp->AssociatedIrp.SystemBuffer)->NumberOfAxes = ((PJOY_EXTENSION)pDO->DeviceExtension)->NumberOfAxes;
                    ((PJOY_STATISTICS)pIrp->AssociatedIrp.SystemBuffer)->bTwoSticks   = ((PJOY_EXTENSION)pDO->DeviceExtension)->bTwoSticks;

                    Status = STATUS_SUCCESS;
                    pIrp->IoStatus.Status = Status;
                    pIrp->IoStatus.Information = sizeof(JOY_STATISTICS);

                    // reset statistics
                    JoyStatistics.Polls         = 0;
                    JoyStatistics.Timeouts      = 0;
                    JoyStatistics.PolledTooSoon = 0;
                    JoyStatistics.Redo          = 0;

                    break;

                case IOCTL_JOY_GET_JOYREGHWCONFIG:

                    AnajoystGetConfig (
                           (LPJOYREGHWCONFIG)(pIrp->AssociatedIrp.SystemBuffer),
                           ((PJOY_EXTENSION)pDO->DeviceExtension)
                                      );

                    pIrp->IoStatus.Information = sizeof(JOYREGHWCONFIG);

                    break;

                default:
                        DebugTrace(("Unknown IoControlCode"));

                    break;

            } // end switch on IOCTL code
            break;



        default:

            DebugTrace(("Unknown IRP Major Function %d", pIrpStack->MajorFunction));


    } // end switch on IRP_MAJOR_XXXX

    // pIrp->IoStatus.Status must be set to Status by this point.
    // pIrp->IoStatus.Information must be set to the correct size by this point.
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    return Status;
}


VOID
AnajoystUnload(
    PDRIVER_OBJECT pDriverObject
)

/*++

Routine Description:

    Driver unload routine. Deletes the device objects

Arguments:

    pDriverObject     -- pointer to the driver object whose devices we
                         are about to delete.


Return Value:

    Returns     Nothing

--*/
{
    DWORD DeviceNumber;
    WCHAR UnicodeDosDeviceName[200];


    //
    // Delete all of our devices
    //

    while (pDriverObject->DeviceObject)
    {
        DeviceNumber =
            ((PJOY_EXTENSION)pDriverObject->DeviceObject->DeviceExtension)->
                  DeviceNumber;

        //
        // withdraw claims on hardware by reporting no resource utilization
        //

        if (pDriverObject->DeviceObject)
        {
            if (DeviceNumber == 0)
            {
                // This isn't really necessary since we never reported the usage in the first place.
                // There's some unused code in the original driver that may have once reported usage,
                // but it was never called in the version I received.  But this doesn't seem to hurt,
                // and "if it ain't broke, don't fix it," at least two weeks before RC1 target.
                DebugTrace(("ReportNull place"));
                //AnajoystReportNullResourceUsage(pDriverObject->DeviceObject);
            }
        }

        if (DeviceNumber == 0) {
            RtlInitUnicodeString((PUNICODE_STRING) &UnicodeDosDeviceName, L"\\DosDevices\\Joy1");
        }
        else {
            RtlInitUnicodeString((PUNICODE_STRING) &UnicodeDosDeviceName, L"\\DosDevices\\Joy2");
        }

        IoDeleteSymbolicLink((PUNICODE_STRING) &UnicodeDosDeviceName);



        DebugTrace(("Freeing device %d", DeviceNumber));

        IoDeleteDevice(pDriverObject->DeviceObject);
    }
}


NTSTATUS
AnajoystPoll(
    IN  PDEVICE_OBJECT pDO,
    IN  PIRP pIrp
)
/*++

Routine Description:

    Polls the device for position and button information. The polling method
    (analog, digital, enhanced) is selected by the CurrentDeviceMode variable
    in the device extension.

    Only enhanced digital allowed.  If other modes are necessary, cut and paste
    (and test!) the code from file analog3p.c

Arguments:

    pDO     -- pointer to the device object

    pIrp    -- pointer to the IRP to process
               if successful, data is put into the pIrp


Return Value:

    STATUS_SUCCESS   -- if the poll succeeded,
    STATUS_TIMEOUT   -- if the poll failed

--*/
{
    NTSTATUS Status;
    PJOY_DD_INPUT_DATA pInput;

    pInput  = (PJOY_DD_INPUT_DATA)pIrp->AssociatedIrp.SystemBuffer;

    Status = STATUS_TIMEOUT;
    pIrp->IoStatus.Status = Status;


    if (pInput != NULL)
    {
        pInput->Unplugged = TRUE; // until proven otherwise
    }


    if (KeQueryPerformanceCounter(NULL).QuadPart < liLastPoll.QuadPart + nMinTicksBetweenPolls) {
        // Don't poll too frequently, instead return last good packet
        JoyStatistics.PolledTooSoon++;
        if (bLastGoodPacket) {
            RtlCopyMemory (pInput, &jjLastGoodPacket, sizeof (JOY_DD_INPUT_DATA));
            Status = STATUS_SUCCESS;
        }
        else {
            // no last packet, too soon to poll, nothing we can do
            Status = STATUS_TIMEOUT; 
        }
    }
    else {
        // do the analog poll
        liLastPoll = KeQueryPerformanceCounter (NULL);
        ++JoyStatistics.Polls;
        Status = AnajoystAnalogPoll(pDO, pIrp);
        if (Status != STATUS_SUCCESS) ++JoyStatistics.Timeouts;
    }

    pIrp->IoStatus.Status = Status;
    return Status;
}


BOOL
AnajoystQuiesce(
    PUCHAR JoyPort,
    UCHAR Mask
)
/*++

Routine Description:
    This routine attempts to insure that the joystick is not still active as a
    result of an earlier operation. This is accomplished by repeatedly reading
    the device and checking that no bits are set in the supplied mask. The idea
    is to check that none of the analog bits (resistive bits) are in use.

Arguments:
    JoyPort         - the address of the port (as returned from hal)
    Mask            - the mask specifying which analog bits should be checked.

Return Value:
    TRUE            Quiesce operation succeeded
    FALSE           No quiesce within a reasonable period. This generally means
                    that the device is unplugged.

    NB This is not a reliable test for "joystick unplugged"
    This routine can return TRUE under some circumstances
    even when there is no joystick

--*/
{
    int i;
    UCHAR PortVal;

    // Wait for port to quiesce
    for (i = 0; i < nQuiesceLoop; i++) {
        PortVal = READ_PORT_UCHAR(JoyPort);
        if ((PortVal & Mask) == 0) return TRUE;
    }

    // If poll timed out we have an uplugged joystick or something's wrong
    DebugTrace(("AnajoystQuiesce failed!"));
    return FALSE;
}


NTSTATUS
AnajoystMapDevice(
    DWORD PortBase,
    DWORD NumberOfPorts,
    PJOY_EXTENSION pJoyExtension
)
{
    DWORD MemType;
    PHYSICAL_ADDRESS PortAddress;
    PHYSICAL_ADDRESS MappedAddress;


    MemType = 1;                 // IO space
    PortAddress.LowPart = PortBase;
    PortAddress.HighPart = 0;


    HalTranslateBusAddress(
                Isa,
                0,
                PortAddress,
                &MemType,
                &MappedAddress);

    if (MemType == 0) {
        //
        // Map memory type IO space into our address space
        //
        pJoyExtension->DeviceAddress = (PUCHAR) MmMapIoSpace(MappedAddress,
                                                             NumberOfPorts,
                                                             FALSE);
    }
    else
    {
        pJoyExtension->DeviceAddress  = (PUCHAR) MappedAddress.LowPart;
    }

    return STATUS_SUCCESS;

}


DWORD
TimeInMicroSeconds(
    DWORD dwTime
)
{
    DWORD Remainder;

    return RtlExtendedLargeIntegerDivide(
                RtlEnlargedUnsignedMultiply( dwTime, 1000000L),
                Frequency,
                &Remainder
           ).LowPart;
}

DWORD
TimeInTicks(
    DWORD dwTimeInMicroSeconds
)
{
    return (DWORD) (((__int64)dwTimeInMicroSeconds * (__int64)Frequency) / (__int64) 1000000L);
}





int lstrnicmpW (LPWSTR pszA, LPWSTR pszB, size_t cch)
{
    if (!pszA || !pszB)
    {
        return (!pszB) - (!pszA);   // A,!B:1, !A,B:-1, !A,!B:0
    }

//  while (cch--)
    for ( ; cch > 0; cch--, pszA++, pszB++) // previous version did not increment string pointers [SteveZ]
    {
        if (!*pszA || !*pszB)
        {
            return (!*pszB) - (!*pszA);    // A,!B:1, !A,B:-1, !A,!B:0
        }

        if (*pszA != *pszB)
        {
            return (int)(*pszA) - (int)(*pszB);   // -1:A<B, 0:A==B, 1:A>B
        }
    }

    return 0;  // no differences before told to stop comparing, so A==B
}


void
AnajoystGetConfig (
    LPJOYREGHWCONFIG pConfig,
    PJOY_EXTENSION pJoyExtension
)
/*++

Routine Description:
    This routine is called in response to the IOCTL_JOY_GET_JOYREGHWCONFIG
    query.  It fills out a JOYREGHWCONFIG structure with relevant information
    about the given joystick.

Arguments:
    pConfig - Specifies a JOYREGHWCONFIG structure, to be filled in
    pJoyExtension - Specifies the joystick to query

Return Value:
    void

--*/
{
    pConfig->hwv.jrvHardware.jpMin.dwX = 20;
    pConfig->hwv.jrvHardware.jpMin.dwY = 20;
    pConfig->hwv.jrvHardware.jpMin.dwZ = 20;
    pConfig->hwv.jrvHardware.jpMin.dwR = 20;
    pConfig->hwv.jrvHardware.jpMin.dwU = 20;
    pConfig->hwv.jrvHardware.jpMin.dwV = 20;

    pConfig->hwv.jrvHardware.jpMax.dwX = 1600;
    pConfig->hwv.jrvHardware.jpMax.dwY = 1600;
    pConfig->hwv.jrvHardware.jpMax.dwZ = 1600;
    pConfig->hwv.jrvHardware.jpMax.dwR = 1600;
    pConfig->hwv.jrvHardware.jpMax.dwU = 1600;
    pConfig->hwv.jrvHardware.jpMax.dwV = 1600;

    pConfig->hwv.jrvHardware.jpCenter.dwX = 790;
    pConfig->hwv.jrvHardware.jpCenter.dwY = 790;
    pConfig->hwv.jrvHardware.jpCenter.dwZ = 790;
    pConfig->hwv.jrvHardware.jpCenter.dwR = 790;
    pConfig->hwv.jrvHardware.jpCenter.dwU = 790;
    pConfig->hwv.jrvHardware.jpCenter.dwV = 790;

    pConfig->hwv.dwCalFlags = 0;

    pConfig->dwReserved = 0;

    pConfig->dwUsageSettings = JOY_US_PRESENT;

    switch( ((PJOY_EXTENSION)pJoyExtension)->NumberOfAxes )
    {
    case 2:
        pConfig->hws.dwFlags = 0;
        pConfig->hws.dwNumButtons = 2;
        pConfig->dwType = JOY_HW_2A_2B_GENERIC;
        break;

    case 3:
        pConfig->hws.dwFlags = JOY_HWS_HASR;
        pConfig->hws.dwNumButtons = 4;
        pConfig->dwType = JOY_HW_CUSTOM;
        break;

    case 4:
        pConfig->hws.dwFlags = JOY_HWS_HASU | JOY_HWS_HASR;
        pConfig->hws.dwNumButtons = 4;
        pConfig->dwType = JOY_HW_CUSTOM;
        break;
    }
}



NTSTATUS
AnajoystAnalogPoll(
    PDEVICE_OBJECT pDO,
    PIRP    pIrp
)

/*++
Do a good comment block here...
THIS MAY HANG UP IF NO JOYSTICK ATTACHED.  DON'T RELEASE THIS CODE WITH ANALOG
JOYSTICK SUPPORT WITHOUT CAREFULLY CHECKING THE CODE.

Routine Description:

    Polls the analog device for position and button information. The position
    information in analog devices is coveyed by the duration of a pulse width.
    Each axis occupies one bit position. The read operation is started by
    writing a value to the joystick io address. Immediately thereafter we
    begin examing the values returned and the elapsed time.

    This sort of device has a few limitations:

    First, button information is not latched by the device, so if a button press
    which occurrs in between polls will be lost. There is really no way to prevent
    this short of devoting the entire cpu to polling.

    Secondly, although we raise IRQL to DISPATCH_LEVEL, other interrupts will
    occur during the polling routines and this will have the effect of lengthening
    the pulse width (by delaying our polling loop) and thus there will be some
    fluctuation about the actual value.  It might be possible to try another IRQL
    to see if this helps, but ultimately, nothing short of disabling interrupts
    altogether will insure success. This is too much of a price to pay. The
    solution is a better device.

    Third, when circumstances cause a poll to last too long, we abort it and
    retry the operation. We have to do this to place an upper bound on the
    time we poll, and an upper bound on the time we spend at an elevated IRQL.

    But in this case both the position information and
    the button press information is lost. Note that there is an upper bound
    on the poll duration, beyond which we conclude that the device is disconnected.


Arguments:

    pDO     -- pointer to the device object
    pIrp    -- pointer to the requesing Irp


Return Value:

    STATUS_SUCCESS   -- if the poll succeeded,
    STATUS_TIMEOUT   -- if the poll failed (timeout), or the checksum was incorrect

--*/
{

    UCHAR  PortVal;
    PBYTE  JoyPort;
    DWORD  Id;
    DWORD  NumberOfAxes;
    BOOL   bTwoSticks;
    PJOY_DD_INPUT_DATA pInput;

    BOOL   Redo;
    UCHAR  Buttons;
    UCHAR  xMask, yMask, zMask, rMask;
    DWORD  xTime, yTime, zTime, rTime;
    int    MaxRedos;



    DebugTrace(("AnajoystAnalogPoll"));


    pInput  = (PJOY_DD_INPUT_DATA)pIrp->AssociatedIrp.SystemBuffer;

    // If we fail we assume it's because we're unplugged
    pInput->Unplugged = TRUE;

    // Find where our port and data area are, and related parameters
    JoyPort      = ((PJOY_EXTENSION)pDO->DeviceExtension)->DeviceAddress;
    Id           = ((PJOY_EXTENSION)pDO->DeviceExtension)->DeviceNumber;
    NumberOfAxes = ((PJOY_EXTENSION)pDO->DeviceExtension)->NumberOfAxes;
    bTwoSticks   = ((PJOY_EXTENSION)pDO->DeviceExtension)->bTwoSticks;

    // Read port state
    PortVal = READ_PORT_UCHAR(JoyPort);

    Buttons = 0;

    // Get current button states and build bitmasks for the resistive inputs
    if (Id == JOYSTICKID1)
    {
        switch (NumberOfAxes)
        {
            case 2:
                xMask      = JOYSTICK1_X_MASK;
                yMask      = JOYSTICK1_Y_MASK;
                zMask      = 0;
                rMask      = 0;

                if (!(PortVal & JOYSTICK1_BUTTON1))
                {
                    Buttons |= JOY_BUTTON1;
                }
                if (!(PortVal & JOYSTICK1_BUTTON2))
                {
                    Buttons |= JOY_BUTTON2;
                }

                if (!bTwoSticks)
                {
                    if (!(PortVal & JOYSTICK2_BUTTON1))
                    {
                        Buttons |= JOY_BUTTON3;
                    }
                    if (!(PortVal & JOYSTICK2_BUTTON2))
                    {
                        Buttons |= JOY_BUTTON4;
                    }
                }
                break;

            case 3:
                xMask      = JOYSTICK1_X_MASK;
                yMask      = JOYSTICK1_Y_MASK;
                zMask      = 0;
                rMask      = JOYSTICK1_R_MASK; // this is 0x08, typically the third axis on 3axis joysticks

                if (!(PortVal & JOYSTICK1_BUTTON1))
                {
                    Buttons |= JOY_BUTTON1;
                }
                if (!(PortVal & JOYSTICK1_BUTTON2))
                {
                    Buttons |= JOY_BUTTON2;
                }
                if (!(PortVal & JOYSTICK2_BUTTON1))
                {
                    Buttons |= JOY_BUTTON3;
                }
                if (!(PortVal & JOYSTICK2_BUTTON2))
                {
                    Buttons |= JOY_BUTTON4;
                }
                break;

            case 4:
                // Note that we read all axi because we don't know which
                // axis will be used by the joystick, and we read all the
                // buttons because no other joystick could use them

                xMask      = JOYSTICK1_X_MASK;
                yMask      = JOYSTICK1_Y_MASK;
                zMask      = JOYSTICK1_Z_MASK;
                rMask      = JOYSTICK1_R_MASK;

                if (!(PortVal & JOYSTICK1_BUTTON1))
                {
                    Buttons |= JOY_BUTTON1;
                }
                if (!(PortVal & JOYSTICK1_BUTTON2))
                {
                    Buttons |= JOY_BUTTON2;
                }
                if (!(PortVal & JOYSTICK2_BUTTON1))
                {
                    Buttons |= JOY_BUTTON3;
                }
                if (!(PortVal & JOYSTICK2_BUTTON2))
                {
                    Buttons |= JOY_BUTTON4;
                }
                break;

            default:
                break;
                // $TODO - report invalid number of axi
        }
    }
    else if ((Id == JOYSTICKID2) && (bTwoSticks))
    {
        xMask      = JOYSTICK2_X_MASK;
        yMask      = JOYSTICK2_Y_MASK;
        zMask      = 0;
        rMask      = 0;

        if (!(PortVal & JOYSTICK2_BUTTON1))
        {
            Buttons |= JOY_BUTTON1;
        }
        if (!(PortVal & JOYSTICK2_BUTTON2))
        {
            Buttons |= JOY_BUTTON2;
        }
    }
    else
    {
        // $TODO - report unsupported configuration
    }

    // Insure that the resistive inputs are currently reset before performing
    // the next read. If we find one or more hot inputs, wait briefly for
    // them to reset. If they don't, we assume that the joystick is unplugged

    if (!AnajoystQuiesce(JoyPort, (UCHAR) (xMask | yMask | zMask | rMask)))
    {
        DebugTrace(("AnajoystQuiesce: failed to quiesce resistive inputs"));
        return STATUS_TIMEOUT;
    }

    // Note that timing is EXTREMELY critical in the loop below.
    // Avoid calling complicated arithmetic (eg TimeInMicroSeconds)
    // or we will decrease our accuracy
    // Other problems with accuracy, probably larger than the delays caused
    // by arithmetic, are the latency in calls to KeQueryPerformanceCounter
    // (typically about 5 us), and delays that can occur on the bus when DMA
    // is taking place.

    // Now poll the device.  We wait until the status bit(s) set(s)
    // and note the time.  If the time since the last poll was
    // too great we ignore the answer and try again.

    // Loop until we get a decent reading or exceed the threshold

    for (Redo = TRUE, MaxRedos = 20; Redo && --MaxRedos != 0;)
    {
        ULONG StartTime;
        ULONG CurrentTime;
        ULONG PreviousTime;
        ULONG PreviousTimeButOne;
        UCHAR ResistiveInputMask;

        ResistiveInputMask = xMask | yMask | zMask | rMask;

        // Lock on to start time
        StartTime = KeQueryPerformanceCounter(NULL).LowPart;

        WRITE_PORT_UCHAR(JoyPort, JOY_START_TIMERS);

        CurrentTime = KeQueryPerformanceCounter(NULL).LowPart - StartTime;

        PortVal = READ_PORT_UCHAR(JoyPort);

        // Now wait until our end times for each coordinate

        PreviousTimeButOne = 0;
        PreviousTime = CurrentTime;

        for (Redo = FALSE;
             ResistiveInputMask;
             PreviousTimeButOne = PreviousTime,
             PreviousTime = CurrentTime,
             PortVal = READ_PORT_UCHAR(JoyPort)
            ) {

            PortVal = ResistiveInputMask & ~PortVal;
            CurrentTime = KeQueryPerformanceCounter(NULL).LowPart - StartTime;

            if (CurrentTime > MaxTimeoutInTicks) {

                DebugTrace(("Polling failed - ResistiveInputMask = %x, Time = %d",
                            (ULONG)ResistiveInputMask,
                            TimeInMicroSeconds(CurrentTime)));

                return STATUS_TIMEOUT;
            }

            if (PortVal & xMask) {
                ResistiveInputMask &= ~xMask;
                xTime = PreviousTime;
            }
            if (PortVal & yMask) {
                ResistiveInputMask &= ~yMask;
                yTime = PreviousTime;
            }
            if (PortVal & zMask) {
                ResistiveInputMask &= ~zMask;
                zTime = PreviousTime;
            }
            if (PortVal & rMask){
                ResistiveInputMask &= ~rMask;
                rTime = PreviousTime;
            }

            if (PortVal && CurrentTime - PreviousTimeButOne > ThresholdInTicks) {
                // Something (DMA or interrupts) delayed our read loop, start again.
                DebugTrace(("Too long a gap between polls - %u us", TimeInMicroSeconds(CurrentTime - PreviousTimeButOne)));
                JoyStatistics.Redo++;
                Redo = TRUE;
                break;
            }
        }
    }

    if (MaxRedos == 0)
    {
        DebugTrace(("Overran redos to get counters"));
        pInput->Unplugged = TRUE;
        return STATUS_TIMEOUT;
    }

    pInput->Unplugged = FALSE;
    pInput->Buttons = Buttons;
    pInput->XTime = TimeInMicroSeconds(xTime);
    pInput->YTime = TimeInMicroSeconds(yTime);
    pInput->ZTime = (zMask) ? TimeInMicroSeconds(zTime) : 0;
    pInput->TTime = (rMask) ? TimeInMicroSeconds(rTime) : 0;

    pInput->Axi = ((PJOY_EXTENSION)pDO->DeviceExtension)->NumberOfAxes;


    // everything worked, save this info as last good packet
    RtlCopyMemory (&jjLastGoodPacket, pInput, sizeof (JOY_DD_INPUT_DATA));
    bLastGoodPacket = TRUE;


    DebugTrace(("X = %x, Y = %x, Z = %x, R = %x, Buttons = %x",
                 pInput->XTime,
                 pInput->YTime,
                 pInput->ZTime,
                 pInput->TTime,
                 pInput->Buttons));

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\joyport\init.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    init.c

Abstract:

    This module contains code for the initialization phase of the
    Microsoft Sound System device driver.

Author:

    Noel Cross (NoelC) 16-Jul-1996

Environment:

    Kernel mode

Revision History:

--*/

#include <ntddk.h>
#include <stdio.h>
#include <stdarg.h>

NTSTATUS
DriverEntry(
    IN   PDRIVER_OBJECT pDriverObject,
    IN   PUNICODE_STRING RegistryPathName
)

/*++

Routine Description:

    This is the entry point for a kernel mode driver.

Arguments:

    pDriverObject - Pointer to a driver object.
    RegistryPathName - the path to our driver services node

Return Value:

    This dummy driver just returns STATUS_UNSUCCESSFUL.

--*/

{
    //
    //  We don't want to load a service for joyport.sys but we need
    //  a service associated with the joystick port PnP ID so that
    //  PNPISA can isolate the resources that we need to be able to
    //  start the joystick driver later.
    //
    return STATUS_UNSUCCESSFUL;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\joystick\joyread\joyread.c ===
#include "windows.h"
#include "stdio.h"
#include <winioctl.h>
#include <ntddjoy.h>


#define JOYREADVERSION "Analog JoyRead 7/596\n"
#define INSTRUCTIONS "\nCommands:\n" \
"\t?,h Display this message\n" \
"\t1 Read  joy1\n" \
"\t2 Read  joy2\n" \
"\tA Open  joy1\n" \
"\ta close joy1\n" \
"\tB Open  joy2\n" \
"\tb close joy2\n" \
"\tF fast read joy1\n" \
"\tS stats\n" \
"\tx exit\n"
#define PROMPT "Joy!>"


int __cdecl main(int argc, char **argv) {


    HANDLE hJoy1 = NULL;
    HANDLE hJoy2 = NULL;
    BOOL bDone = FALSE;
    BOOL bOK;
    DWORD dwBytesRead;
    JOY_DD_INPUT_DATA JoyData;
    JOY_STATISTICS jStats, *pjStats;

    char sz[256], cCode;
	int i;

    printf (JOYREADVERSION);
    printf (INSTRUCTIONS);

    while (!bDone) {
        printf (PROMPT);
        if (gets (sz) == NULL) {
            sz[0] = 'x';
            sz[1] = '\0';
        }
        cCode = sz[0];    // if user types a blank before the command, too bad

        switch (cCode) {
        case 'h':
        case '?':
            printf (INSTRUCTIONS);
            break;
        case 'A': // open joystick 1
            printf ("Open joy1\n");
            if (hJoy1 != NULL) {
                printf ("joy1 already open\n");
                break;
            }
            hJoy1 = CreateFile(
                         "\\\\.\\Joy1",
                         GENERIC_READ | GENERIC_WRITE,
                         0,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL);
            printf ("after CreateFile Joy1 0x%08x\n", hJoy1);
            if (hJoy1 == INVALID_HANDLE_VALUE) {
                printf ("couldn't open joy1\n");
                hJoy1 = NULL;
                break;
            }
            printf ("Got handle to Joy1\n");
            break;
        case 'B': // open joystick 2
            printf ("Open joy2\n");
            if (hJoy2 != NULL) {
                printf ("joy2 already open\n");
                break;
            }
            hJoy2 = CreateFile(
                         "\\\\.\\Joy2",
                         GENERIC_READ | GENERIC_WRITE,
                         0,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL);
            printf ("after CreateFile Joy2 0x%08x\n", hJoy1);
            if (hJoy2 == INVALID_HANDLE_VALUE) {
                printf ("couldn't open joy2\n");
                hJoy1 = NULL;
                break;
            }
            printf ("Got handle to Joy2\n");
            break;
        case 'a': // close joy1
            printf ("Close joy1\n");
            CloseHandle(hJoy1);
            printf ("closed joy1 0x%08x\n", hJoy1);
            hJoy1 = NULL;
            break;
        case 'b': // close joy2
            printf ("Close joy2\n");
            CloseHandle(hJoy2);
            printf ("closed joy2 0x%08x\n", hJoy2);
            hJoy2 = NULL;
            break;
        case '1': // read joy1
            printf ("Read joy1\n");
            if (hJoy1 == NULL) {
                printf ("Joy1 not open\n");
                break;
            }
            bOK = ReadFile (hJoy1, &JoyData, sizeof(JoyData), &dwBytesRead, NULL);
            if (!bOK) {
                printf ("Read failed\n");
                break;
            }
            printf ("%d bytes read\n", dwBytesRead);
            printf ("Unplugged %u\n", JoyData.Unplugged);

            printf ("Number of Axes %u\n", JoyData.Axi);
            printf ("Buttons 0x%04x\n", JoyData.Buttons);
            printf ("x, y, z, t axis times in us, %u %u %u %u\n", 
                JoyData.XTime,
                JoyData.YTime,
                JoyData.ZTime,
                JoyData.TTime);
            break;

        case '2': // read joy2
            printf ("Read joy2\n");
            if (hJoy2 == NULL) {
                printf ("Joy2 not open\n");
                break;
            }
            bOK = ReadFile (hJoy2, &JoyData, sizeof(JoyData), &dwBytesRead, NULL);
            if (!bOK) {
                printf ("Read failed\n");
                break;
            }
            printf ("%d bytes read\n", dwBytesRead);
            printf ("Unplugged %u\n", JoyData.Unplugged);
            printf ("Number of Axes %u\n", JoyData.Axi);
            printf ("Buttons 0x%04x\n", JoyData.Buttons);
            printf ("x, y, z, t axis times in us, %u %u %u %u\n", 
                JoyData.XTime,
                JoyData.YTime,
                JoyData.ZTime,
                JoyData.TTime);
            break;

        case 'F': // fast read joy1
            printf ("Fast read joy1\n");
            if (hJoy1 == NULL) {
                printf ("Joy1 not open\n");
                break;
            }
			for (i = 0; i < 15; i++) {
				bOK = ReadFile (hJoy1, &JoyData, sizeof(JoyData), &dwBytesRead, NULL);
			}
			printf ("Did 15 reads\n");
            if (!bOK) {
                printf ("Read failed\n");
                break;
            }
            printf ("%d bytes read\n", dwBytesRead);
            printf ("Unplugged %u\n", JoyData.Unplugged);

            printf ("Number of Axes %u\n", JoyData.Axi);
            printf ("Buttons 0x%04x\n", JoyData.Buttons);
            printf ("x, y, z, t axis times in us, %u %u %u %u\n", 
                JoyData.XTime,
                JoyData.YTime,
                JoyData.ZTime,
                JoyData.TTime);
            break;

        case 'S': // stats
            printf ("Stats joy1\n");
            if (hJoy1 == NULL) {
                printf ("Joy1 not open\n");
                break;
            }
            pjStats = &jStats;

		    DeviceIoControl (
			    hJoy1,
			    (DWORD) IOCTL_JOY_GET_STATISTICS,	// instruction to execute
			    pjStats, sizeof(JOY_STATISTICS),	// buffer and size of buffer
			    pjStats, sizeof(JOY_STATISTICS),	// buffer and size of buffer
			    &dwBytesRead, 0);
            printf ("Version       %d\n", pjStats->Version);
            printf ("NumberOfAxes  %d\n", pjStats->NumberOfAxes);
            printf ("Frequency     %d\n", pjStats->Frequency);
            printf ("dwQPCLatency  %d\n", pjStats->dwQPCLatency);
            printf ("nQuiesceLoop  %d\n", pjStats->nQuiesceLoop);
            printf ("PolledTooSoon %d\n", pjStats->PolledTooSoon);
            printf ("Polls         %d\n", pjStats->Polls);
            printf ("Timeouts      %d\n", pjStats->Timeouts);
            break;


        case 'x': // done
            bDone = TRUE;
            break;

        default:
            printf ("Huh? >%s<\n", sz);
            printf (INSTRUCTIONS);
            break;
        }
    }


    // Point proven.  Be a nice program and close up shop.
    if (hJoy1 != NULL) CloseHandle(hJoy1);
    if (hJoy2 != NULL) CloseHandle(hJoy2);
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\joystick\swndr3p.c ===
-------------------------------------------------------------------------------
                         THIS FILE IS NO LONGER USED!

It is being retained for historical purposes, in case we should need to refer
to previously-existing (and largely broken) analog joystick code.  It should
not be distributed to 3rd parties.
-------------------------------------------------------------------------------



//TODO check return and irp->status returns for all routines.  Trace 'em as far as necessary.

/*++ BUILD Version: 0001    // Increment this if a change has global effects


Copyright (c) 1995, 1996  Microsoft Corporation

Module Name:

    swndr3p.c

Abstract:

    Kernel mode device driver for Microsoft SideWinder 3p joystick device


Author:

    edbriggs 30-Nov-95


Revision History:

    stevez May 96
    removed unused code, including analog and 1-bit digital modes.
    See analog3p.c, .h for original version
    May need 1-bit digital mode for Aztec game cards, may want analog
    for future release.
    NB there is still a lot of unnecessary code left in this driver

    RtlLargeIntegerX calls are historical and can be replaced by __int64
    compiler supported arithmetic.

    6/10/96 registry variables now being used for port address
    6/10/96 resets enhanced digital mode if joystick goes to analog mode during
        use (for example if user toggles "emulation" switch)
    6/13/96 limits polling to 100/s by setting min time between polls to 10ms
    6/13/96 code structure revised in SidewndrPoll and subroutines


--*/


/*
 * $Header: /Joystick/Sidewinder/swndr3p.c 19    1/09/96 10:26p Edbriggs $
 */


#include <ntddk.h>
#include <windef.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <ntddjoy.h>
//#include "joylog.h"



//
// Device extension data
//

typedef struct {

    //
    // JOYSTICKID0 or JOYDSTICKID1
    //

    DWORD DeviceNumber;

    //
    // Number of axes supported and configured for this device. The
    // Sidewinder 3P supports a maximum of 4 axes
    //

    DWORD NumberOfAxes;

    //
    // Current operating mode of the device:
    // { Invalid | Analog | Digital | Enhanced | Maximum }
    //

    DWORD CurrentDeviceMode;

    //
    // The I/O address of the device. Note, this may be a memory mapped
    // address
    //

    PUCHAR DeviceAddress;

    //
    // Boolean denoting whether this address is mapped (TRUE) or not)
    //

    BOOL DeviceIsMapped;

    //
    // A Spinlock is used to synchronize access to this device. This is
    // a pointer to the actual spinlock data area
    //

    PKSPIN_LOCK SpinLock;

    //
    // Actual SpinLock data area
    //

    KSPIN_LOCK SpinLockData;


}  JOY_EXTENSION, *PJOY_EXTENSION;




//
//  Debugging macros
//

#ifdef DEBUG
#define ENABLE_DEBUG_TRACE
#endif

#ifdef ENABLE_DEBUG_TRACE
#define DebugTrace(_x_)         \
    DbgPrint("Joystick : ");    \
    KdPrint(_x_);               \
    DbgPrint("\n");
#else
#define DebugTrace(_x_)
#endif

//
// Condition Compilation Directives
//




//
// Global values used to speed up calculations in sampling loops
// Also calibration constants set in DriverEntry
// -------------------------------------------------------------
//

JOY_STATISTICS JoyStatistics;   // These are used for debugging and performance testing

//
// The high resolution system clock (from KeQueryPerformanceCounter)
// is updated at this frequency
//

DWORD Frequency;

//
// The latency in a call to KeQueryPerformanceCounter in microseconds
//

DWORD dwQPCLatency;

//
// After a write to the joystick port, we spin in a read-port loop, waiting
// for a bit to go high.
// This is the number of iterations to spin before timing out.  Set
// to timeout after about 2 milliseconds

LONG nReadLoopMax;

//
// Values for KeDelayExecutionThread
//

LARGE_INTEGER LI1ms;
LARGE_INTEGER LI2ms;
LARGE_INTEGER LI8ms;
LARGE_INTEGER LI10ms;

//
// number of KeQueryPerformanceCounter ticks in 1 millisecond
// (used to prevent too-frequent polling of joystick)
//

DWORD nMinTicksBetweenPolls;

//
//  Assembly area for digital packets
//

BYTE  NormalPacket[8];
BYTE  EnhancedPacket[21];

//
//  Last good packet
//

BOOL bLastGoodPacket;
JOY_DD_INPUT_DATA jjLastGoodPacket;

//
// time at which the joystick was last polled
//

LARGE_INTEGER liLastPoll;   // set whenever the joystick's polled


//
// End of Global Values
// ---------------------
//



//
// Routine Prototypes
//


NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  pDriverObject,
    IN  PUNICODE_STRING RegistryPathName
);


NTSTATUS
SidewndrCreateDevice(
    PDRIVER_OBJECT pDriverObject,
    PWSTR DeviceNameBase,
    DWORD DeviceNumber,
    DWORD ExtensionSize,
    BOOLEAN  Exclusive,
    DWORD DeviceType,
    PDEVICE_OBJECT *DeviceObject
);


NTSTATUS
SidewndrDispatch(
    IN  PDEVICE_OBJECT pDO,
    IN  PIRP pIrp
);


NTSTATUS
SidewndrReportNullResourceUsage(
    PDEVICE_OBJECT DeviceObject
);


NTSTATUS
SidewndrReadRegistryParameterDWORD(
    PUNICODE_STRING RegistryPathName,
    PWSTR  ParameterName,
    PDWORD ParameterValue
);


NTSTATUS
SidewndrMapDevice(
    DWORD PortBase,
    DWORD NumberOfPorts,
    PJOY_EXTENSION pJoyExtension
);


VOID
SidewndrUnload(
    PDRIVER_OBJECT pDriverObject
);


NTSTATUS
SidewndrPoll(
    IN  PDEVICE_OBJECT pDO,
    IN  PIRP pIrp
);


NTSTATUS
SidewndrEnhancedDigitalPoll(
    IN  PDEVICE_OBJECT pDO,
    IN  PIRP pIrp
);


BOOL
SidewndrQuiesce(
    PUCHAR JoyPort,
    UCHAR  Mask
);


DWORD
TimeInMicroSeconds(
    DWORD dwTime
);


DWORD
TimeInTicks(
    DWORD dwTimeInMicroSeconds
);


NTSTATUS
SidewndrWaitForClockEdge(
    DWORD  edge,
    BYTE   *pByte,
    PUCHAR JoyPort
);


NTSTATUS
SidewndrReset(
    PUCHAR JoyPort
);


NTSTATUS
SidewndrStartAnalogMode(
    PUCHAR JoyPort
);


NTSTATUS
SidewndrStartDigitalMode(
    PUCHAR JoyPort
);


NTSTATUS
SidewndrStartEnhancedMode(
    PUCHAR JoyPort
);


NTSTATUS
SidewndrGetEnhancedPacket(
    PUCHAR joyPort
);


NTSTATUS
SidewndrInterpretEnhancedPacket(
    PJOY_DD_INPUT_DATA pInput
);


int
lstrnicmpW(
    LPWSTR pszA,
    LPWSTR pszB,
    size_t cch
);


VOID
SidewndrWait (
    DWORD TotalWait // in uS
);


BOOL
SidewndrReadWait (
    PUCHAR JoyPort,
    UCHAR Mask
);


void
SidewndrGetConfig(
    LPJOYREGHWCONFIG pConfig,
    PJOY_EXTENSION pJoyExtension
);


NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  pDriverObject,
    IN  PUNICODE_STRING RegistryPathName
)
/*++

Routine Description:

    This routine is called at system initialization time to initialize
    this driver.

Arguments:

    DriverObject    - Supplies the driver object.

    RegistryPath    - Supplies the registry path for this driver.

Return Value:

    STATUS_SUCCESS
    STATUS_DEVICE_CONFIGURATION_ERROR - Wrong number of axi in the registry

    or error status from NT itself

--*/
{
    NTSTATUS Status;
    PDEVICE_OBJECT JoyDevice0;
    PDEVICE_OBJECT JoyDevice1;
    DWORD NumberOfAxes;
    DWORD DeviceAddress;
    DWORD DeviceType;


    //
    // See how many axes we have from the registry parameters. These parameters
    // are set up by the driver installation program, and can be modified by
    // control panel
    //

    //DbgBreakPoint();
    JoyStatistics.nVersion = 16;    // global, initialize it first thing so we for sure what we're running
    DebugTrace(("Sidewndr %d", JoyStatistics.nVersion));

    Status = SidewndrReadRegistryParameterDWORD(
                RegistryPathName,
                JOY_DD_NAXES_U,
                &NumberOfAxes
                );

    DebugTrace(("Number of axes returned from registry: %d", NumberOfAxes));


    if (!NT_SUCCESS(Status))
    {
        SidewndrUnload(pDriverObject);
        return Status;
    }


    if (( NumberOfAxes < 2) || (NumberOfAxes > 4))
    {
        SidewndrUnload(pDriverObject);
        Status = STATUS_DEVICE_CONFIGURATION_ERROR;
        return Status;
    }


    //
    // See if the registry contains a device address other than the
    // default of 0x201
    //

    Status = SidewndrReadRegistryParameterDWORD(
                RegistryPathName,
                JOY_DD_DEVICE_ADDRESS_U,
                &DeviceAddress
                );

    if (NT_SUCCESS(Status))
    {
        DebugTrace(("Registry specified device address of 0x%x", DeviceAddress));
    }
    else
    {
        DebugTrace(("Using default device address of 0x%x", JOY_IO_PORT_ADDRESS));
        DeviceAddress = JOY_IO_PORT_ADDRESS;
    }


    //
    // See if there is a device type specified in the registry
    //

    Status = SidewndrReadRegistryParameterDWORD(
                RegistryPathName,
                JOY_DD_DEVICE_TYPE_U,
                &DeviceType
                );

    if (!NT_SUCCESS(Status))
    {
        DebugTrace(("No device type entry for joystick"));
        SidewndrUnload(pDriverObject);
        Status = STATUS_DEVICE_CONFIGURATION_ERROR;
        return Status;
    }

    DebugTrace(("Joystick device type %d", DeviceType));

    // set global large_integers for KeDelayExecutionThread (negative numbers for relative time)
    // NB KeDelayExecutionThread calls typically take at least 10 milliseconds on the pentium75 I used for testing,
    // no matter how little time is requested
    LI1ms  = RtlConvertLongToLargeInteger(- 10000);
    LI2ms  = RtlConvertLongToLargeInteger(- 20000);
    LI8ms  = RtlConvertLongToLargeInteger(- 80000);
    LI10ms = RtlConvertLongToLargeInteger(-100000);

    //
    // Calculate time thresholds for analog device
    //

    {
        DWORD Remainder;
        LARGE_INTEGER LargeFrequency;
        DWORD ulStart, ulTemp, ulEnd;
        DWORD dwTicks, dwTimems;
        int i;
        BYTE byteJoy, byteTmp;

        //
        // Get the system timer resolution expressed in Hertz.
        //

        KeQueryPerformanceCounter(&LargeFrequency);

        Frequency = LargeFrequency.LowPart;

        DebugTrace(("Frequency: %u", Frequency));

        // need latency for KeQueryPerformanceCounter.  While we're at it, let's
        // get min time for delay and stall execution


        ulStart = KeQueryPerformanceCounter(NULL).LowPart;
        for (i = 0; i < 1000; i++) {
            ulTemp = KeQueryPerformanceCounter(NULL).LowPart;
        }
        dwTicks = ulTemp - ulStart;
        dwTimems = TimeInMicroSeconds (dwTicks);
        dwQPCLatency = (dwTimems / 1000) + 1;   // round up

        /* following code used only for testing timing of kernel timing routines
        ulStart = KeQueryPerformanceCounter(NULL).LowPart;
        KeDelayExecutionThread( KernelMode, FALSE, &LI2ms);
        ulEnd = KeQueryPerformanceCounter(NULL).LowPart;
        DebugTrace(("QPC latency in uS: %u, DET(2ms) in ticks: %u ticks",
            dwQPCLatency,
            ulEnd - ulStart));

        ulStart = KeQueryPerformanceCounter(NULL).LowPart;
        for (i = 0; i < 1000; i++) {
            KeStallExecutionProcessor(1);   // 1 microsecond (Hah!)
        }
        ulEnd = KeQueryPerformanceCounter(NULL).LowPart;
        DebugTrace(("KeStallExecutionProcessor(1) called 1000 times, in ticks: %u",
            ulEnd - ulStart));
        */

    }


    //
    // Attempt to create the device
    //

    Status = SidewndrCreateDevice(
                pDriverObject,
                JOY_DD_DEVICE_NAME_U,    // device driver
                0,
                sizeof(JOY_EXTENSION),
                FALSE,                   // exclusive access
                FILE_DEVICE_UNKNOWN,
                &JoyDevice0);

    if (!NT_SUCCESS(Status))
    {
        DebugTrace(("SwndrCreateDevice returned %x", Status));
        SidewndrUnload(pDriverObject);
        return Status;
    }

    ((PJOY_EXTENSION)JoyDevice0->DeviceExtension)->DeviceNumber = JOYSTICKID1;
    ((PJOY_EXTENSION)JoyDevice0->DeviceExtension)->NumberOfAxes = NumberOfAxes;
    ((PJOY_EXTENSION)JoyDevice0->DeviceExtension)->CurrentDeviceMode =
            SIDEWINDER3P_ANALOG_MODE;

    ((PJOY_EXTENSION)JoyDevice0->DeviceExtension)->DeviceIsMapped = FALSE;
    ((PJOY_EXTENSION)JoyDevice0->DeviceExtension)->DeviceAddress  = (PUCHAR) 0;

    //
    // Initialize the spinlock used to synchronize access to this device
    //

    KeInitializeSpinLock(&((PJOY_EXTENSION)JoyDevice0->DeviceExtension)->SpinLockData);

    ((PJOY_EXTENSION)JoyDevice0->DeviceExtension)->SpinLock =
            &((PJOY_EXTENSION)JoyDevice0->DeviceExtension)->SpinLockData;

    //
    // Get the device address into the device extension
    //

    Status = SidewndrMapDevice(
                DeviceAddress,
                1,
                (PJOY_EXTENSION)JoyDevice0->DeviceExtension);


    // Calibrate nReadLoopMax for spinning in read_port loops to timeout after 2ms
    {
        int i;
        PBYTE JoyPort;
        DWORD ulStart, ulEnd;
        BYTE byteJoy;
        int LoopTimeInMicroSeconds;

        i = 1000;
        JoyPort = ((PJOY_EXTENSION)JoyDevice0->DeviceExtension)->DeviceAddress;

        ulStart = KeQueryPerformanceCounter(NULL).LowPart;
        while (i--){
            byteJoy = READ_PORT_UCHAR(JoyPort);
            if ((byteJoy & X_AXIS_BITMASK)) {
                ;
            }
        }
        ulEnd = KeQueryPerformanceCounter(NULL).LowPart;
        LoopTimeInMicroSeconds = TimeInMicroSeconds (ulEnd - ulStart);
        nReadLoopMax = (1000 * 2000) / LoopTimeInMicroSeconds; // want 2 mS for nReadLoopMax iterations
        DebugTrace(("READ_PORT_UCHAR loop, 1000 interations: %u ticks", ulEnd - ulStart));
        DebugTrace(("nReadLoopMax: %u", nReadLoopMax));
   }
    //
    // if only 2 axes were requested, we can support a second device
    //

    // Number of axed should be 4 here, since we're only supporting sidewinder
    // in enhanced digital mode.  Leave this code in just for safety.

    if (2 == NumberOfAxes)
    {
        Status = SidewndrCreateDevice(
                    pDriverObject,
                    JOY_DD_DEVICE_NAME_U,
                    1,                      // device number
                    sizeof (JOY_EXTENSION),
                    FALSE,                  // exclusive access
                    FILE_DEVICE_UNKNOWN,
                    &JoyDevice1);

        if (!NT_SUCCESS(Status))
        {
            DebugTrace(("Create device for second device returned %x", Status));
            SidewndrUnload(pDriverObject);
            return Status;
        }

        //
        // In the analog world (which we are in if there are 2 devices, both
        // devices share the same I/O address so just copy it from JoyDevice0
        //

        ((PJOY_EXTENSION)JoyDevice1->DeviceExtension)->DeviceIsMapped =
            ((PJOY_EXTENSION)JoyDevice0->DeviceExtension)->DeviceIsMapped;

        ((PJOY_EXTENSION)JoyDevice1->DeviceExtension)->DeviceAddress =
            ((PJOY_EXTENSION)JoyDevice0->DeviceExtension)->DeviceAddress;

    }

    //
    // Place the enty points in our driver object
    //

    pDriverObject->DriverUnload                         = SidewndrUnload;
    pDriverObject->MajorFunction[IRP_MJ_CREATE]         = SidewndrDispatch;
    pDriverObject->MajorFunction[IRP_MJ_CLOSE]          = SidewndrDispatch;
    pDriverObject->MajorFunction[IRP_MJ_READ]           = SidewndrDispatch;
    pDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = SidewndrDispatch;

    //
    // Zero statistics, set misc globals
    //

    JoyStatistics.EnhancedPolls        = 0;
    JoyStatistics.EnhancedPollTimeouts = 0;
    JoyStatistics.EnhancedPollErrors   = 0;
    JoyStatistics.nPolledTooSoon       = 0;
    JoyStatistics.nReset               = 0;
    {
        int i;
        for (i = 0; i < MAX_ENHANCEDMODE_ATTEMPTS; i++) {
            JoyStatistics.Retries[i] = 0;
        }
    }

    bLastGoodPacket = FALSE;
    liLastPoll = KeQueryPerformanceCounter (NULL);
    // allow max of 100 polls/s (min time  between polls 10ms), which reduces time spinning in the NT kernel
    nMinTicksBetweenPolls = TimeInTicks (10000);

    return STATUS_SUCCESS;

}


NTSTATUS
SidewndrCreateDevice(
    PDRIVER_OBJECT pDriverObject,
    PWSTR DeviceNameBase,
    DWORD DeviceNumber,
    DWORD ExtensionSize,
    BOOLEAN  Exclusive,
    DWORD DeviceType,
    PDEVICE_OBJECT *DeviceObject
)
/*++

Routine Description:

    This routine is called at driver initialization time to create
    the device. The device is created to use Buffered IO.

Arguments:

    pDriverObject   - Supplies the driver object.

    DeviceNameBase  - The base name of the device to which a number is appended

    DeviceNumber    - A number which will be appended to the device name

    ExtensionSize   - Size of the device extension area

    Exclusive       - True if exclusive access should be enforced

    DeviceType      - NT Device type this device is modeled after

    DeviceObject    - pointer to the device object


Return Value:

    STATUS_SUCCESS
    or error status from NT itself

--*/
{

    WCHAR DeviceName[100];
    WCHAR UnicodeDosDeviceName[200];

    UNICODE_STRING UnicodeDeviceName;
    NTSTATUS Status;
    int Length;

    (void) wcscpy(DeviceName, DeviceNameBase);
    Length = wcslen(DeviceName);
    DeviceName[Length + 1] = L'\0';
    DeviceName[Length] = (USHORT) (L'0' + DeviceNumber);

    (void) RtlInitUnicodeString(&UnicodeDeviceName, DeviceName);

    Status = IoCreateDevice(
                pDriverObject,
                ExtensionSize,
                &UnicodeDeviceName,
                DeviceType,
                0,
                (BOOLEAN) Exclusive,
                DeviceObject
                );

    if (!NT_SUCCESS(Status))
    {
        return Status;
    }



    RtlInitUnicodeString((PUNICODE_STRING) &UnicodeDosDeviceName, L"\\DosDevices\\Joy1");

    Status = IoCreateSymbolicLink(
                (PUNICODE_STRING) &UnicodeDosDeviceName,
                (PUNICODE_STRING) &UnicodeDeviceName
                );

    if (!NT_SUCCESS(Status))
    {
        return Status;
    }




    // Set the flag signifying that we will do buffered I/O. This causes NT
    // to allocate a buffer on a ReadFile operation which will then be copied
    // back to the calling application by the I/O subsystem


    (*DeviceObject)->Flags |= DO_BUFFERED_IO;


    return Status;

}



NTSTATUS
SidewndrReadRegistryParameterDWORD(
    PUNICODE_STRING RegistryPathName,
    PWSTR  ParameterName,
    PDWORD ParameterValue
)
/*++

Routine Description:

    This routine reads registry values for the driver configuration

Arguments:

    RegistryPathName    -  Registry path containing the desired parameters

    ParameterName       -  The name of the parameter

    ParameterValue      -  Variable to receive the parameter value

Return Value:

    STATUS_SUCCESS                      --
    STATUS_NO_MORE_ENTRIES              --  Couldn't find any entries
    STATUS_INSUFFICIENT_RESOURCES       --  Couldn't allocate paged pool
    STATUS_DEVICE_CONFIGURATION_ERROR   --  Returned value wasn't a DWORD

    or error status from NT itself

--*/
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS Status;

    HANDLE ServiceKey;
    HANDLE DeviceKey;           // Key handle of service node
    UNICODE_STRING DeviceName;  // Key to parameter node
    DWORD KeyIndex;
    DWORD KeyValueLength;
    PBYTE KeyData;
    BOOL  ValueWasFound;
    PKEY_VALUE_FULL_INFORMATION KeyInfo;

    InitializeObjectAttributes( &ObjectAttributes,
                                RegistryPathName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                (PSECURITY_DESCRIPTOR) NULL);

    //
    // Open a key for our services node entry
    //

    Status = ZwOpenKey( &ServiceKey,
                        KEY_READ | KEY_WRITE,
                        &ObjectAttributes);

    if (!NT_SUCCESS(Status))
    {
        return Status;
    }


    //
    // Open the key to our device subkey
    //

    RtlInitUnicodeString(&DeviceName, L"Parameters");

    InitializeObjectAttributes( &ObjectAttributes,
                                &DeviceName,
                                OBJ_CASE_INSENSITIVE,
                                ServiceKey,
                                (PSECURITY_DESCRIPTOR) NULL);

    Status = ZwOpenKey (&DeviceKey,
                        KEY_READ | KEY_WRITE,
                        &ObjectAttributes);


    ZwClose(ServiceKey);


    if (!NT_SUCCESS(Status))
    {
        return Status;
    }

    //
    // Loop reading our key values
    //

    // TODO exit loop when value is found?
    ValueWasFound = FALSE;

    for (KeyIndex = 0; ; KeyIndex++)
    {
        KeyValueLength = 0;

        //
        // find out how much data we will get
        //

        Status = ZwEnumerateValueKey(
                    DeviceKey,
                    KeyIndex,
                    KeyValueFullInformation,
                    NULL,
                    0,
                    &KeyValueLength);

        if (STATUS_NO_MORE_ENTRIES == Status)
        {
            break;
        }

        if (0 == KeyValueLength)
        {
            return Status;
        }

        //
        // Read the data
        //

        KeyData = ExAllocatePool (PagedPool, KeyValueLength);

        if (NULL == KeyData)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }


        Status = ZwEnumerateValueKey(
                    DeviceKey,
                    KeyIndex,
                    KeyValueFullInformation,
                    KeyData,
                    KeyValueLength,
                    &KeyValueLength);

        if (!NT_SUCCESS(Status))
        {
            ExFreePool(KeyData);
            return Status;
        }

        KeyInfo = (PKEY_VALUE_FULL_INFORMATION) KeyData;

        if (0 == lstrnicmpW(KeyInfo->Name,
                            ParameterName,
                            KeyInfo->NameLength / sizeof(WCHAR)))
        {
            // check its a DWORD

            if (REG_DWORD != KeyInfo->Type)
            {
                ExFreePool(KeyData);
                return STATUS_DEVICE_CONFIGURATION_ERROR;
            }

            ValueWasFound = TRUE;

            *ParameterValue = *(PDWORD) (KeyData + KeyInfo->DataOffset);
        }

        ExFreePool(KeyData);

    }

    return (ValueWasFound) ? STATUS_SUCCESS : STATUS_DEVICE_CONFIGURATION_ERROR;

}


NTSTATUS
SidewndrDispatch(
    IN  PDEVICE_OBJECT pDO,
    IN  PIRP pIrp
)
/*++

Routine Description:

    Driver dispatch routine. Processes IRPs based on IRP MajorFunction

Arguments:

    pDO     -- pointer to the device object

    pIrp    -- pointer to the IRP to process


Return Value:

    Returns the value of the IRP IoStatus.Status

--*/
{
    PIO_STACK_LOCATION pIrpStack;
    KIRQL OldIrql;
    NTSTATUS  Status;
    DWORD     dwRetries = 0;

    //DbgBreakPoint();

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

    Status = STATUS_SUCCESS;
    pIrp->IoStatus.Status = Status;
    pIrp->IoStatus.Information = 0;

    switch (pIrpStack->MajorFunction)
    {
        case IRP_MJ_CREATE:

            //
            // perform synchronous I/O
            //

            //pIrpStack->FileObject->Flags |= FO_SYNCHRONOUS_IO;
            //NB This is bad code -- we are simply one thread wandering off through the computer -- we should be queuing up a DPC,
            //returning status_pending to the calling program, then finishing the job when the dpc goes.  This is possible given
            //the analog game port technology.

            Status = SidewndrReset (((PJOY_EXTENSION)pDO->DeviceExtension)->DeviceAddress);

            ((PJOY_EXTENSION)pDO->DeviceExtension)->CurrentDeviceMode =
                             SIDEWINDER3P_ENHANCED_DIGITAL_MODE;

            //KeDelayExecutionThread( KernelMode, FALSE, &LI10ms); //unnecessary since SidewndrReset has a delay in it?

            pIrp->IoStatus.Status = Status;
            break;

        case IRP_MJ_CLOSE:

            break;

        case IRP_MJ_READ:

            //
            // Find out which device we are and read, but first make sure
            // there is enough room
            //

            DebugTrace(("IRP_MJ_READ"));
            //DbgBreakPoint();


            if (pIrpStack->Parameters.Read.Length < sizeof(JOY_DD_INPUT_DATA))
            {
                Status = STATUS_BUFFER_TOO_SMALL;
                pIrp->IoStatus.Status = Status;
                break;
            }

            //
            // Serialize and get the current device values
            //

            KeAcquireSpinLock(((PJOY_EXTENSION) pDO->DeviceExtension)->SpinLock,
                                & OldIrql);


            Status = SidewndrPoll(pDO, pIrp);

            //
            // release the spinlock
            //

            KeReleaseSpinLock(((PJOY_EXTENSION)pDO->DeviceExtension)->SpinLock,
                              OldIrql);

            pIrp->IoStatus.Status = Status;
            pIrp->IoStatus.Information  = sizeof (JOY_DD_INPUT_DATA);
            break;


        case IRP_MJ_DEVICE_CONTROL:

            switch (pIrpStack->Parameters.DeviceIoControl.IoControlCode)
            {
                case IOCTL_JOY_GET_STATISTICS:

                    // report statistics
                    ((PJOY_STATISTICS)pIrp->AssociatedIrp.SystemBuffer)->nVersion             = JoyStatistics.nVersion;
                    ((PJOY_STATISTICS)pIrp->AssociatedIrp.SystemBuffer)->EnhancedPolls        = JoyStatistics.EnhancedPolls;
                    ((PJOY_STATISTICS)pIrp->AssociatedIrp.SystemBuffer)->EnhancedPollTimeouts = JoyStatistics.EnhancedPollTimeouts;
                    ((PJOY_STATISTICS)pIrp->AssociatedIrp.SystemBuffer)->EnhancedPollErrors   = JoyStatistics.EnhancedPollErrors;
                    ((PJOY_STATISTICS)pIrp->AssociatedIrp.SystemBuffer)->nPolledTooSoon       = JoyStatistics.nPolledTooSoon;
                    ((PJOY_STATISTICS)pIrp->AssociatedIrp.SystemBuffer)->nReset               = JoyStatistics.nReset;
                    {
                        int i;
                        for (i = 0; i < MAX_ENHANCEDMODE_ATTEMPTS; i++) {
                            ((PJOY_STATISTICS)pIrp->AssociatedIrp.SystemBuffer)->Retries[i] = JoyStatistics.Retries[i];
                        }
                    }

                    ((PJOY_STATISTICS)pIrp->AssociatedIrp.SystemBuffer)->dwQPCLatency         = dwQPCLatency;
                    ((PJOY_STATISTICS)pIrp->AssociatedIrp.SystemBuffer)->nReadLoopMax         = nReadLoopMax;
                    ((PJOY_STATISTICS)pIrp->AssociatedIrp.SystemBuffer)->Frequency            = Frequency;

                    Status = STATUS_SUCCESS;
                    pIrp->IoStatus.Status = Status;
                    pIrp->IoStatus.Information = sizeof(JOY_STATISTICS);

                    // reset statistics
                    JoyStatistics.EnhancedPolls        = 0;
                    JoyStatistics.EnhancedPollTimeouts = 0;
                    JoyStatistics.EnhancedPollErrors   = 0;
                    JoyStatistics.nPolledTooSoon       = 0;
                    JoyStatistics.nReset               = 0;
                    {
                        int i;
                        for (i = 0; i < MAX_ENHANCEDMODE_ATTEMPTS; i++) {
                            JoyStatistics.Retries[i] = 0;
                        }
                    }

                    break;

                case IOCTL_JOY_GET_JOYREGHWCONFIG:

                    SidewndrGetConfig (
                           (LPJOYREGHWCONFIG)(pIrp->AssociatedIrp.SystemBuffer),
                           ((PJOY_EXTENSION)pDO->DeviceExtension)
                                      );

                    pIrp->IoStatus.Information = sizeof(JOYREGHWCONFIG);

                    break;

                default:
                        DebugTrace(("Unknown IoControlCode"));

                    break;

            } // end switch on IOCTL code
            break;



        default:

            DebugTrace(("Unknown IRP Major Function %d", pIrpStack->MajorFunction));


    } // end switch on IRP_MAJOR_XXXX

    // pIrp->IoStatus.Status must be set to Status by this point.
    // pIrp->IoStatus.Information must be set to the correct size by this point.
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    return Status;
}


VOID
SidewndrUnload(
    PDRIVER_OBJECT pDriverObject
)

/*++

Routine Description:

    Driver unload routine. Deletes the device objects

Arguments:

    pDriverObject     -- pointer to the driver object whose devices we
                         are about to delete.


Return Value:

    Returns     Nothing

--*/
{
    DWORD DeviceNumber;
    WCHAR UnicodeDosDeviceName[200];


    //
    // Delete all of our devices
    //

    while (pDriverObject->DeviceObject)
    {
        DeviceNumber =
            ((PJOY_EXTENSION)pDriverObject->DeviceObject->DeviceExtension)->
                  DeviceNumber;

        //
        // withdraw claims on hardware by reporting no resource utilization
        //

        if (pDriverObject->DeviceObject)
        {
            if (DeviceNumber == 0)
            {
                SidewndrReportNullResourceUsage(pDriverObject->DeviceObject);
            }
        }



        RtlInitUnicodeString(
                    (PUNICODE_STRING) &UnicodeDosDeviceName,
                    L"\\DosDevices\\Joy1");

        IoDeleteSymbolicLink(
                    (PUNICODE_STRING) &UnicodeDosDeviceName);



        DebugTrace(("Freeing device %d", DeviceNumber));

        IoDeleteDevice(pDriverObject->DeviceObject);
    }
}


NTSTATUS
SidewndrPoll(
    IN  PDEVICE_OBJECT pDO,
    IN  PIRP pIrp
)
/*++

Routine Description:

    Polls the device for position and button information. The polling method
    (analog, digital, enhanced) is selected by the CurrentDeviceMode variable
    in the device extension.

    Only enhanced digital allowed.  If other modes are necessary, cut and paste
    (and test!) the code from file analog3p.c

Arguments:

    pDO     -- pointer to the device object

    pIrp    -- pointer to the IRP to process
               if successful, data is put into the pIrp


Return Value:

    STATUS_SUCCESS   -- if the poll succeeded,
    STATUS_TIMEOUT   -- if the poll failed

--*/
{
    NTSTATUS Status;
    PJOY_DD_INPUT_DATA pInput;

    pInput  = (PJOY_DD_INPUT_DATA)pIrp->AssociatedIrp.SystemBuffer;

    Status = STATUS_TIMEOUT;
    pIrp->IoStatus.Status = Status;


    if (pInput != NULL)
    {
        pInput->Unplugged = TRUE; // until proven otherwise
    }

    switch (((PJOY_EXTENSION)pDO->DeviceExtension)->CurrentDeviceMode)
    {
        case SIDEWINDER3P_INVALID_MODE:
            break;

        case SIDEWINDER3P_ANALOG_MODE:
            break;

        case SIDEWINDER3P_DIGITAL_MODE:
            break;

        case SIDEWINDER3P_ENHANCED_DIGITAL_MODE:

            // Don't poll too frequently, instead return last good packet
            if (KeQueryPerformanceCounter(NULL).QuadPart < liLastPoll.QuadPart + nMinTicksBetweenPolls) {
                JoyStatistics.nPolledTooSoon++;
                if (bLastGoodPacket) {
                    RtlCopyMemory (pInput, &jjLastGoodPacket, sizeof (JOY_DD_INPUT_DATA));
                    Status = STATUS_SUCCESS;
                }
                else {
                    // no last packet, too soon to poll, nothing we can do
                    Status = STATUS_TIMEOUT; 
                }
                break;
            }
            // Poll the joystick
            Status = SidewndrEnhancedDigitalPoll(pDO, pIrp);
            if (Status == STATUS_SUCCESS) {
                // Everything's fine
                break;
            }
            else {
                // timed out, maybe user switched to analog mode?
                Status = SidewndrReset ( (PUCHAR) ((PJOY_EXTENSION)pDO->DeviceExtension)->DeviceAddress);
                JoyStatistics.nReset++;
                if (Status != STATUS_SUCCESS) {
                    // won't go digital, maybe unplugged, nothing we can do
                    break;
                }
            }
            // Now in enhanced digital mode, try polling it again (if user switches joystick between prev lines and
            // this line, we'll time out, next query to the joystick will find and solve the problem)
            Status = SidewndrEnhancedDigitalPoll(pDO, pIrp);
            break;

        case SIDEWINDER3P_MAXIMUM_MODE:
            break;

        default:
            break;

    }
    pIrp->IoStatus.Status = Status;
    return Status;
}


NTSTATUS
SidewndrEnhancedDigitalPoll(
    IN  PDEVICE_OBJECT pDO,
    IN PIRP pIrp
)
{
    PUCHAR   joyPort;
    NTSTATUS PollStatus;
    NTSTATUS DecodeStatus;
    DWORD    MaxRetries;

    joyPort = ((PJOY_EXTENSION)pDO->DeviceExtension)->DeviceAddress;

    // Try to get a good enhanced mode packet up to MAX_ENHANCEDMODE_ATTEMPTS
    // If there is a timeout, or if the data are invalid (bad checksum or sync
    // bits) wait 1ms for the joystick to reset itself, and try again.
    //
    // Note that although this should eventually get a good packet, packets
    // discarded in the interim (because of errors) will cause button presses
    // to be lost.
    //
    // Although this loses data, it keeps bad data from reaching the caller,
    // which seem to be about the best we can do at this stage.
    //
    // We keep a count of all the errors so that we keep track of just
    // how bad the situation really is.
    //

    for( MaxRetries = 0; MaxRetries < MAX_ENHANCEDMODE_ATTEMPTS; MaxRetries++)
    {
        // try to read (poll) the device

        liLastPoll = KeQueryPerformanceCounter (NULL);
        PollStatus = SidewndrGetEnhancedPacket(joyPort);
        ++JoyStatistics.EnhancedPolls;

        if (PollStatus != STATUS_SUCCESS)
        {
            // There was a timeout of some sort on the device read.
            ++JoyStatistics.EnhancedPollTimeouts;
        }
        else
        {
            // The device read completed. Process the data and verify the checksum
            // and sync bits. The processed data will be in AssociatedIrp.SystemBuffer
            DecodeStatus = SidewndrInterpretEnhancedPacket(
                (PJOY_DD_INPUT_DATA)pIrp->AssociatedIrp.SystemBuffer);
            if (DecodeStatus != STATUS_SUCCESS)
            {
                // The data was bad, most likely because we missed some of the nibbles.
                ++JoyStatistics.EnhancedPollErrors;
            }
            else
            {
                // Everything worked as we had hoped. The data has already been
                // deposited in the AssociatedIrp.SystemBuffer.
                JoyStatistics.Retries[MaxRetries]++;
                return STATUS_SUCCESS;
            }
        }

        // We did not succeed in reading the packet.  Wait 1 ms for the device to 
        // stabilize before re-trying the read
        //KeDelayExecutionThread( KernelMode, FALSE, &LI1ms);  // cannot use KeDelayExecutionThread here
        //                                                      because we're at dispatch level, thanks
        //                                                      to the spin lock we hold
        // Mail from manolito says (64-48)*10us = 160us should be enough.  But I seem to recall reading 21 packets out of 66 sent.
        // Pending answer from manolito, set to 450us.
        SidewndrWait (450); // this is bad because it monopolizes the cpu, but since we're spinlocked anyway, what the heck, do it.

    }

    // We exceeded MAX_ENHANCEDMODE_ATTEMPTS. Something is pretty badly wrong;
    // in any case, a higher level caller will have to decide what to do
    return STATUS_TIMEOUT;
}


NTSTATUS
SidewndrReportNullResourceUsage(
    PDEVICE_OBJECT DeviceObject
)
{
    BOOLEAN ResourceConflict;
    CM_RESOURCE_LIST ResourceList;
    NTSTATUS Status;

    ResourceList.Count = 0;

    //
    // Report our usage and detect conflicts
    //

    Status = IoReportResourceUsage( NULL,
                                    DeviceObject->DriverObject,
                                    &ResourceList,
                                    sizeof(DWORD),
                                    DeviceObject,
                                    NULL,
                                    0,
                                    FALSE,
                                    &ResourceConflict);
    if (NT_SUCCESS(Status))
    {
        if (ResourceConflict)
        {
            return STATUS_DEVICE_CONFIGURATION_ERROR;
        }
        else
        {
            return STATUS_SUCCESS;
        }
    }
    else
    {
        return Status;
    }

}



BOOL
SidewndrQuiesce(
    PUCHAR JoyPort,
    UCHAR Mask
)
/*++

Routine Description:

    This routine attempts to insure that the joystick is not still active as a
    result of an earlier operation. This is accomplished by repeatedly reading
    the device and checking that no bits are set in the supplied mask. The idea
    is to check that none of the analog bits (resistive bits) are in use.

Arguments:

    JoyPort         - the address of the port (as returned from hal)

    Mask            - the mask specifying which analog bits should be checked.

Return Value:

    TRUE            Quiesce operation succeeded

    FALSE           No quiesce within a reasonable period. This generally means
                    that the device is unplugged.

    NB This is not a reliable test for "joystick unplugged"
    This routine can return TRUE under some circumstances
    even when there is no joystick

--*/
{
    int i;
    UCHAR PortVal;

    //
    // Wait for the stuff to quiesce
    //

    for (i = 0; i < ANALOG_POLL_TIMEOUT; i++) {

        PortVal = READ_PORT_UCHAR(JoyPort);
        if ((PortVal & Mask) == 0){
            return TRUE;
        } else {
            KeStallExecutionProcessor(1);
        }
    }

    //
    // If poll timed out we have an uplugged joystick
    //

    DebugTrace(("SidewndrQuiesce failed!"));

    return FALSE;
}


NTSTATUS
SidewndrMapDevice(
    DWORD PortBase,
    DWORD NumberOfPorts,
    PJOY_EXTENSION pJoyExtension
)
{
    DWORD MemType;
    PHYSICAL_ADDRESS PortAddress;
    PHYSICAL_ADDRESS MappedAddress;


    MemType = 1;                 // IO space
    PortAddress.LowPart = PortBase;
    PortAddress.HighPart = 0;


    HalTranslateBusAddress(
                Isa,
                0,
                PortAddress,
                &MemType,
                &MappedAddress);

    if (MemType == 0) {
        //
        // Map memory type IO space into our address space
        //
        pJoyExtension->DeviceAddress = (PUCHAR) MmMapIoSpace(MappedAddress,
                                                             NumberOfPorts,
                                                             FALSE);
        pJoyExtension->DeviceIsMapped = TRUE;
    }
    else
    {
        pJoyExtension->DeviceAddress  = (PUCHAR) MappedAddress.LowPart;
        pJoyExtension->DeviceIsMapped = FALSE;
    }

    return STATUS_SUCCESS;

}


DWORD
TimeInMicroSeconds(
    DWORD dwTime
)
{
    DWORD Remainder;

    return RtlExtendedLargeIntegerDivide(
                RtlEnlargedUnsignedMultiply( dwTime, 1000000L),
                Frequency,
                &Remainder
           ).LowPart;
}

DWORD
TimeInTicks(
    DWORD dwTimeInMicroSeconds
)
{
    return (DWORD) (((__int64)dwTimeInMicroSeconds * (__int64)Frequency) / (__int64) 1000000L);
}


NTSTATUS
SidewndrWaitForClockEdge(
    DWORD   edge,
    BYTE    *pByte,
    PUCHAR  JoyPort
)
/*++

Routine Description:

    Waits for the clock line to go high, or low depending on a the supplied
    parameter (edge).  If edge is CLOCK_RISING_EDGE, waits for rising edge,
    else if edge is CLOCK_FALLING_EDGE

    An upper bound for the wait duration is set at 1000 iterations.

    Arguments:

    edge    -- CLOCK_RISING_EDGE or CLOCK_FALLING Edge to specify what to await

    pByte   -- The contents of the device register are returned for other use


Return Value:

    STATUS_SUCCESS  --  the specified edge was detected before timeout

    STATUS_TIMEOUT  --  timeout before detecting specified edge.

--*/

{
    DWORD  maxTimeout;
    BYTE   joyByte;

    maxTimeout = nReadLoopMax;

    if (CLOCK_RISING_EDGE == edge)
    {
        while (maxTimeout--)
        {
            joyByte = READ_PORT_UCHAR(JoyPort);
            if (joyByte & CLOCK_BITMASK)
            {
                *pByte = joyByte;
                return STATUS_SUCCESS;
            }
        }
        *pByte = joyByte;
        return STATUS_TIMEOUT;
    }
    else
    {
        while (maxTimeout--)
        {
            joyByte = READ_PORT_UCHAR(JoyPort);
            if (!(joyByte & CLOCK_BITMASK))
            {
                *pByte = joyByte;
                return STATUS_SUCCESS;
            }
        }
        *pByte = joyByte;
        return STATUS_TIMEOUT;
    }
}


NTSTATUS
SidewndrReset(
    PUCHAR JoyPort
)
// This resets the joystick to enhanced digital mode.
{
    DWORD dwRetries;
    NTSTATUS Status;

    dwRetries = 0;

    do {
        ++dwRetries;

        Status = SidewndrStartAnalogMode(JoyPort);
        if (Status == STATUS_TIMEOUT) continue;
        //KeDelayExecutionThread( KernelMode, FALSE, &LI10ms);  //MarkSV thinks this is unnecessary

        Status = SidewndrStartDigitalMode(JoyPort);
        if (Status == STATUS_TIMEOUT) continue;
        //KeDelayExecutionThread( KernelMode, FALSE, &LI10ms);  //MarkSV thinks this is unnecessary

        Status = SidewndrStartEnhancedMode(JoyPort);

    } while ((Status == STATUS_TIMEOUT) && (dwRetries < 10) );

    // give the joystick time to stabilize  MarkSV thinks this is unnecessary
    //KeDelayExecutionThread( KernelMode, FALSE, &LI10ms);


    return Status;
}



NTSTATUS
SidewndrStartAnalogMode(
    PUCHAR JoyPort
)
{
    KIRQL   OldIrql;

    if(! SidewndrQuiesce(JoyPort, 0x01))
    {
        return STATUS_TIMEOUT;
    }

    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

    WRITE_PORT_UCHAR(JoyPort, JOY_START_TIMERS);
    if (!SidewndrReadWait(JoyPort, X_AXIS_BITMASK)) goto timeout;

    WRITE_PORT_UCHAR(JoyPort, JOY_START_TIMERS);
    if (!SidewndrReadWait(JoyPort, X_AXIS_BITMASK)) goto timeout;

    WRITE_PORT_UCHAR(JoyPort, JOY_START_TIMERS);

    KeLowerIrql(OldIrql);

    //
    // Wait 1ms to let port settle out
    //

    KeDelayExecutionThread( KernelMode, FALSE, &LI1ms); // MarkSV says 1 ms is enough, original code had 8 ms

    return STATUS_SUCCESS;

timeout:
    KeLowerIrql(OldIrql);
    return STATUS_TIMEOUT;

}


NTSTATUS
SidewndrStartDigitalMode(
    PUCHAR JoyPort
)
{
    KIRQL   OldIrql;
    DWORD dwStart, dwX0, dwX1, dwX2, dwX3;


    DebugTrace(("Sidewndr: Digital Mode Requested"));

    SidewndrQuiesce(JoyPort, 0x01);


    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);


    WRITE_PORT_UCHAR(JoyPort, JOY_START_TIMERS);
    if (!SidewndrReadWait(JoyPort, X_AXIS_BITMASK)) goto timeout;
    SidewndrWait (75);

    WRITE_PORT_UCHAR(JoyPort, JOY_START_TIMERS);
    if (!SidewndrReadWait(JoyPort, X_AXIS_BITMASK)) goto timeout;
    SidewndrWait (75 + 726);

    WRITE_PORT_UCHAR(JoyPort, JOY_START_TIMERS);
    if (!SidewndrReadWait(JoyPort, X_AXIS_BITMASK)) goto timeout;
    SidewndrWait (75 + 300);

    WRITE_PORT_UCHAR(JoyPort, JOY_START_TIMERS);
    if (!SidewndrReadWait(JoyPort, X_AXIS_BITMASK)) goto timeout;

    KeLowerIrql(OldIrql);

    SidewndrQuiesce(JoyPort, 0x01);

    return STATUS_SUCCESS;

timeout:
    KeLowerIrql(OldIrql);
    return STATUS_TIMEOUT;
}



NTSTATUS
SidewndrStartEnhancedMode(
    PUCHAR JoyPort
)
{
    DWORD     byteIndex;
    DWORD     bitIndex;
    BYTE     JoyByte;
    NTSTATUS Status;
    KIRQL    OldIrql;



    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

    WRITE_PORT_UCHAR(JoyPort, JOY_START_TIMERS);

    // Wait for serial clock to go high, probably already there.
    Status = SidewndrWaitForClockEdge(CLOCK_RISING_EDGE, &JoyByte, JoyPort);

    if (Status != STATUS_SUCCESS)
    {
        KeLowerIrql(OldIrql);
        DebugTrace(("SidewndrStartEnhancedMode: timeout in first spin"));
        return(STATUS_TIMEOUT);
    }

    for (byteIndex = 0; byteIndex < 6; byteIndex++)
    {
        for (bitIndex = 0; bitIndex < 8; bitIndex++)
        {
            // look for falling edge of serial clock.

            Status = SidewndrWaitForClockEdge(CLOCK_FALLING_EDGE, &JoyByte, JoyPort);
            if (Status != STATUS_SUCCESS)
            {
                KeLowerIrql(OldIrql);
                DebugTrace(("SidewndrStartEnhancedMode: timeout in second spin byteIndex %d bitIndex %d", byteIndex, bitIndex));
                return(STATUS_TIMEOUT);
            }

            // Wait for serial clock to go high.
            Status = SidewndrWaitForClockEdge(CLOCK_RISING_EDGE, &JoyByte, JoyPort);
            if (Status != STATUS_SUCCESS)
            {
                KeLowerIrql(OldIrql);
                DebugTrace(("SidewndrStartEnhancedMode: timeout in third spin"));
                return(STATUS_TIMEOUT);
            }

        }
    }

    // Interrupt the processor again, telling it to send an ID packet.
    // After getting the ID packet it knows to go into enhanced mode.
    // This does not affect the packet currently going.

    WRITE_PORT_UCHAR(JoyPort, JOY_START_TIMERS);


    // Wait out the rest of the packet so we can figure out how long this takes.
    for (byteIndex = 6; byteIndex < 8; byteIndex++)
    {
        for (bitIndex = 0; bitIndex < 8; bitIndex++)
        {
            // look for falling edge of serial clock.
            Status = SidewndrWaitForClockEdge(CLOCK_FALLING_EDGE, &JoyByte, JoyPort);

            if (Status != STATUS_SUCCESS)
            {
                KeLowerIrql(OldIrql);
                DebugTrace(("SidewndrStartEnhancedMode Timeout in 4th spin"));
                return(STATUS_TIMEOUT);
            }

            // Wait for serial clock to go high.

            Status = SidewndrWaitForClockEdge(CLOCK_RISING_EDGE, &JoyByte, JoyPort);
            if (Status != STATUS_SUCCESS)
            {
                KeLowerIrql(OldIrql);
                DebugTrace(("SidewndrStartEnhancedMode Timeout in 5th spin"));
                return(STATUS_TIMEOUT);
            }

        }
    }

    KeLowerIrql(OldIrql);

    //m_tmPacketTime = SystemTime() - tmStartTime;

    // The joystick ID comes across on 20 bytes and we just did 8 bytes,
    // so wait (with interrupts enabled) long enough for the ID packet to
    // complete.  After that we should be in enhanced mode.  Each nibble takes
    // about 10us, so 1ms should be plenty of time for everything.
    KeDelayExecutionThread( KernelMode, FALSE, &LI1ms);

    return(STATUS_SUCCESS);

}



/*++
*******************************************************************************
Routine:

    CSidewinder::GetEnhancedPacket

Description:

    If the joystick is in digital enhanced mode, you can call this to
    get a digital packet and store the data into the class' m_enhancedPacket
    member variable.  Call InterpretEnhancedPacket to turn the raw data into
    joystick info.

    Note that while you can get an enhanced packet in 1/3 the time of a normal
    packet (and can thus turn back on interrputs much sooner), you can not get
    enhanced packets any faster than you can get normal packets.  This function
    will check to make sure sufficient time has passed since the last time it
    was called and if it hasn't it will wait (with interrupts ENABLED) until
    that is true before asking for another packet.

    This assumes the joystick is in digital enhanced mode and there is no way
    to tell if this is not the case.  If the joystick is just in digital
    (non-enhanced) mode then this will return successfully.  However, the
    checksum and/or sync bits will not be correct.

Arguments:

    None.

Return Value:

    successful if it worked.
    not_digital_mode if the joystick is not in digital mode.

*******************************************************************************
--*/
NTSTATUS
SidewndrGetEnhancedPacket(
    PUCHAR JoyPort
)
{
    KIRQL    OldIrql;
    DWORD    byteIndex;
    BYTE     joyByte;
    BYTE     masks[8] = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80 };
    NTSTATUS Status;


    // While enhanced packets come across faster than normal packets,
    // they can not be called any more frequently.  This makes sure
    // we've let enough time since the last packet go by before calling
    // for another.


    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql); // This great and sensitive irql stuff is useless since the spinlock stuff WAY up high puts us a dispatch

    // Start the retrieval operation

    WRITE_PORT_UCHAR(JoyPort, 0);

    // Wait for serial clock to go high, probably already there.

    Status = SidewndrWaitForClockEdge(CLOCK_RISING_EDGE, &joyByte, JoyPort);

    if (Status != STATUS_SUCCESS)
    {
        KeLowerIrql(OldIrql);
        return(STATUS_TIMEOUT);
    }

    for (byteIndex = 0; byteIndex < 21; byteIndex++)
    {
        // look for falling edge of serial clock.
        Status = SidewndrWaitForClockEdge(CLOCK_FALLING_EDGE, &joyByte, JoyPort);
        if (Status != STATUS_SUCCESS)
        {
            KeLowerIrql(OldIrql);
            return(STATUS_TIMEOUT);
        }

        // Wait for serial clock to go high.
        Status = SidewndrWaitForClockEdge(CLOCK_RISING_EDGE, &joyByte, JoyPort);

        if (Status != STATUS_SUCCESS)
        {
            KeLowerIrql(OldIrql);
            return(STATUS_TIMEOUT);
        }

        EnhancedPacket[byteIndex] = (joyByte & ALLDATA_BITMASK) >> 5;
    }

    KeLowerIrql(OldIrql);
    // NB, the joystick will still send 66 packets even though we only needed the first
    // 21 of them.  Don't attempt to poll the joystick until it's finished.  This is another
    // reason to require a minimum time between polls. (About 500us will be enough.)

    return(STATUS_SUCCESS);
}





/*++
*******************************************************************************
Routine:

    CSidewinder::InterpretEnhancedPacket

Description:

    Call this after getting an enhanced packet.  It converts the raw data into
    normal joystick data, filling out the class' m_data structure.

    The encoding of the raw Data bits (D1-D3) is given below.

Data packet format for Enhanced Mode transmission (4 line)
 Byte   D3      D2      D1        D0
    0   Y9      Y8      Y7         SCLK
    1   X9      X8      X7         SCLK
    2   B0      1       H3         SCLK
    3   B3      B2      B1         SCLK
    4   B6      B5      B4         SCLK
    5   X1      X0      0         SCLK
    6   X4      X3      X2         SCLK
    7   0       X6      X5         SCLK
    8   Y2      Y1      Y0         SCLK
    9   Y5      Y4      Y3         SCLK
    10  T7      0       Y6         SCLK
    11  R7      T9      T8         SCLK
    12  B7      CH/TM   R8         SCLK
    13  R1      R0      0         SCLK
    14  R4      R3      R2         SCLK
    15  0       R6      R5         SCLK
    16  T2      T1      T0         SCLK
    17  T5      T4      T3         SCLK
    18  CHKSUM0 0       T6         SCLK
    19  CHKSUM3 CHKSUM2 CHKSUM1  SCLK
    20  H2      H1      H0         SCLK
    21  0       0       0         SCLK


Arguments:

    None.

Return Value:

    successful if the data was valid.
    bad_packet if either the checksum or sync bits were incorrect.


*******************************************************************************
--*/
NTSTATUS
SidewndrInterpretEnhancedPacket(
    PJOY_DD_INPUT_DATA pInput
)
{
    WORD    temp16;
    BYTE    temp8;
    BYTE    checksum;

    pInput->Unplugged = FALSE;
    pInput->Mode      = SIDEWINDER3P_ENHANCED_DIGITAL_MODE;

    //Get xOffset.
    temp16 = 0x0000;
    temp16 |= (EnhancedPacket[1]  & 0x07) << 7;
    temp16 |= (EnhancedPacket[7]  & 0x03) << 5;
    temp16 |= (EnhancedPacket[6]  & 0x07) << 2;
    temp16 |= (EnhancedPacket[5]  & 0x06) >> 1;
    pInput->u.DigitalData.XOffset = temp16;


    //Get yOffset.
    temp16 = 0x0000;
    temp16 |= (EnhancedPacket[0]  & 0x07) << 7;
    temp16 |= (EnhancedPacket[10] & 0x01) << 6;
    temp16 |= (EnhancedPacket[9]  & 0x07) << 3;
    temp16 |= (EnhancedPacket[5]  & 0x07);
    pInput->u.DigitalData.YOffset = temp16;


    //Get rzOffset: Only 9 bits (others are 10)
    temp16 = 0x0000;
    temp16 |= (EnhancedPacket[12] & 0x01) << 8;
    temp16 |= (EnhancedPacket[11] & 0x04) << 5;
    temp16 |= (EnhancedPacket[15] & 0x03) << 5;
    temp16 |= (EnhancedPacket[14] & 0x07) << 2;
    temp16 |= (EnhancedPacket[13] & 0x06) >> 1;
    pInput->u.DigitalData.RzOffset = temp16;

    //Get tOffset.
    temp16 = 0x0000;
    temp16 |= (EnhancedPacket[11] & 0x03) << 8;
    temp16 |= (EnhancedPacket[10] & 0x04) << 5;
    temp16 |= (EnhancedPacket[18] & 0x01) << 6;
    temp16 |= (EnhancedPacket[17] & 0x07) << 3;
    temp16 |= (EnhancedPacket[16] & 0x07);
    pInput->u.DigitalData.TOffset = temp16;


    //Get Hat
    temp8 = 0x00;
    temp8 |= (EnhancedPacket[2]  & 0x01) << 3;
    temp8 |= (EnhancedPacket[20] & 0x07);
    pInput->u.DigitalData.Hat = temp8;

    //Get Buttons
    temp8 = 0x00;
    temp8 |= (EnhancedPacket[2]  & 0x04) >> 2;
    temp8 |= (EnhancedPacket[3]  & 0x07) << 1;
    temp8 |= (EnhancedPacket[4]  & 0x07) << 4;
    temp8 |= (EnhancedPacket[12] & 0x04) << 5;
    temp8 = ~temp8;  // Buttons are 1 = off, 0 = on.  Want the opposite.
    pInput->u.DigitalData.Buttons = temp8;


    // Get CH/TM switch.
    pInput->u.DigitalData.Switch_CH_TM =
        ((EnhancedPacket[12] & 0x02) == 0) ? 1 : 2;


    // Get Checksum
    temp8 = 0x00;
    temp8 |= (EnhancedPacket[18] & 0x04) >> 2;
    temp8 |= (EnhancedPacket[19] & 0x07) << 1;
    pInput->u.DigitalData.Checksum = temp8;


    //
    // Check the checksum. Because the enhance mode retrieves the data packet
    // 3 bits at a time, the data is not in the same order that it arrives in
    // in the normal mode. Thus, calculating the checksum requires additional
    // manipulation.
    //

    checksum = pInput->u.DigitalData.Checksum;
    checksum += 0x08 | ((EnhancedPacket[2] & 0x01) << 2) |
        ((EnhancedPacket[1] & 0x06) >> 1);
    checksum += ((EnhancedPacket[1] & 0x01) << 3) |
        (EnhancedPacket[0] & 0x07);
    checksum += (EnhancedPacket[4] & 0x07);
    checksum += ((EnhancedPacket[3] & 0x07) << 1) |
        ((EnhancedPacket[2] & 0x04) >> 2);
    checksum += ((EnhancedPacket[7] & 0x03) << 1) |
        ((EnhancedPacket[6] & 0x04) >> 2);
    checksum += ((EnhancedPacket[6] & 0x03) << 2) |
        ((EnhancedPacket[5] & 0x06) >> 1);
    checksum += ((EnhancedPacket[10] & 0x01) << 2) |
        ((EnhancedPacket[9] & 0x06) >> 1);
    checksum += ((EnhancedPacket[9] & 0x01) << 3) |
        (EnhancedPacket[8] & 0x07);
    checksum += (EnhancedPacket[12] & 0x07);
    checksum += ((EnhancedPacket[11] & 0x07) << 1) |
        ((EnhancedPacket[10] & 0x04) >> 2);
    checksum += ((EnhancedPacket[15] & 0x03) << 1) |
        ((EnhancedPacket[14] & 0x04) >> 2);
    checksum += ((EnhancedPacket[14] & 0x03) << 2) |
        ((EnhancedPacket[13] & 0x06) >> 1);
    checksum += ((EnhancedPacket[18] & 0x01) << 2) |
        ((EnhancedPacket[17] & 0x06) >> 1);
    checksum += ((EnhancedPacket[17] & 0x01) << 3) |
        (EnhancedPacket[16] & 0x07);
    checksum += (EnhancedPacket[20] & 0x07);

    checksum &= 0x0F;
    if (checksum == 0)
    {
        pInput->u.DigitalData.fChecksumCorrect = TRUE;
    }
    else
    {
        pInput->u.DigitalData.fChecksumCorrect = FALSE;
        DebugTrace(("Enhanced packet checksum failed.\n"));
    }


    //
    // Check SyncBits
    //

    if ((EnhancedPacket[2] & 0x02) != 0)
    {
        checksum =
            (EnhancedPacket[5]  & 0x01) + (EnhancedPacket[7]  & 0x04) +
            (EnhancedPacket[10] & 0x02) + (EnhancedPacket[13] & 0x01) +
            (EnhancedPacket[15] & 0x04) + (EnhancedPacket[18] & 0x02);

        if (checksum == 0)
        {
            pInput->u.DigitalData.fSyncBitsCorrect = TRUE;
        }
        else
        {
            pInput->u.DigitalData.fSyncBitsCorrect = FALSE;
            DebugTrace(("Enhanced packet sync bits incorrect.\n"));
        }
    }
    else
    {
        pInput->u.DigitalData.fSyncBitsCorrect = FALSE;
    }

    if (pInput->u.DigitalData.fChecksumCorrect == TRUE &&
        pInput->u.DigitalData.fSyncBitsCorrect == TRUE)
    {
        // everything worked, save this info as last good packet
        RtlCopyMemory (&jjLastGoodPacket, pInput, sizeof (JOY_DD_INPUT_DATA));
        bLastGoodPacket = TRUE;
        return(STATUS_SUCCESS);
    }
    else
    {
        return(STATUS_TIMEOUT);
    }
}



int lstrnicmpW (LPWSTR pszA, LPWSTR pszB, size_t cch)
{
    if (!pszA || !pszB)
    {
        return (!pszB) - (!pszA);   // A,!B:1, !A,B:-1, !A,!B:0
    }

//  while (cch--)
    for ( ; cch > 0; cch--, pszA++, pszB++) // previous version did not increment string pointers [SteveZ]
    {
        if (!*pszA || !*pszB)
        {
            return (!*pszB) - (!*pszA);    // A,!B:1, !A,B:-1, !A,!B:0
        }

        if (*pszA != *pszB)
        {
            return (int)(*pszA) - (int)(*pszB);   // -1:A<B, 0:A==B, 1:A>B
        }
    }

    return 0;  // no differences before told to stop comparing, so A==B
}


VOID
SidewndrWait (
    DWORD TotalWait // in uS
)
/*++

Routine Description:

    This routine waits for the specified number of microseconds.  Tolerances for
    the joystick are smaller than NT typically provide, so all timing is isolated
    into this routine, where we can do crude things and play nasty hacks as
    necessary.  This routine locks up the cpu, so only use it for putting the joystick
    into digital mode.

Arguments:

    TotalWait - time to wait in microseconds

--*/
{
    DWORD ulStartTime, ulEndTime;
    int nTicks;
    
    // dwQPCLatency is the calibrated-for-this-machine latency for a call to KeQueryPerfomanceCounter (in uS).

    nTicks = TimeInTicks (TotalWait - dwQPCLatency);
    if (nTicks <= 0) return;

    ulStartTime = KeQueryPerformanceCounter(NULL).LowPart;
    ulEndTime = ulStartTime + nTicks;


    while (KeQueryPerformanceCounter(NULL).LowPart < ulEndTime) {
        ;
    }
}


BOOL
SidewndrReadWait (
    PUCHAR JoyPort,
    UCHAR Mask
)
{
/*++
read a port and wait until it gives correct answer based on mask.
timeout after nReadLoopMax iterations (about 2 mS).
--*/

    int i;
    for (i = 0; i < nReadLoopMax; i++) {
        if ( ! (READ_PORT_UCHAR(JoyPort) & Mask) )
            return TRUE; // port went high
    }
    return FALSE; // timed out
}


void
SidewndrGetConfig (
    LPJOYREGHWCONFIG pConfig,
    PJOY_EXTENSION pJoyExtension
)
/*++

Routine Description:

    This routine is called in response to the IOCTL_JOY_GET_JOYREGHWCONFIG
    query.  It fills out a JOYREGHWCONFIG structure with relevant information
    about the given joystick.

Arguments:

    pConfig - Specifies a JOYREGHWCONFIG structure, to be filled in

    pJoyExtension - Specifies the joystick to query

Return Value:

    void

--*/
{
    pConfig->hws.dwNumButtons = 4;

    switch (pJoyExtension->CurrentDeviceMode)
    {
        case SIDEWINDER3P_ANALOG_MODE:
        {
            pConfig->hws.dwFlags = JOY_HWS_HASPOV |
                                   JOY_HWS_POVISBUTTONCOMBOS |
                                   JOY_HWS_HASU |
                                   JOY_HWS_HASR;

            pConfig->dwUsageSettings = JOY_US_HASRUDDER |
                                       JOY_US_PRESENT |
                                       JOY_US_ISOEM;

            pConfig->hwv.jrvHardware.jpMin.dwX = 20;
            pConfig->hwv.jrvHardware.jpMin.dwY = 20;
            pConfig->hwv.jrvHardware.jpMin.dwZ = 0;
            pConfig->hwv.jrvHardware.jpMin.dwR = 20;
            pConfig->hwv.jrvHardware.jpMin.dwU = 20;
            pConfig->hwv.jrvHardware.jpMin.dwV = 0;

            pConfig->hwv.jrvHardware.jpMax.dwX = 1600;
            pConfig->hwv.jrvHardware.jpMax.dwY = 1600;
            pConfig->hwv.jrvHardware.jpMax.dwZ = 0;
            pConfig->hwv.jrvHardware.jpMax.dwR = 1600;
            pConfig->hwv.jrvHardware.jpMax.dwU = 1600;
            pConfig->hwv.jrvHardware.jpMax.dwV = 0;

            pConfig->hwv.jrvHardware.jpCenter.dwX = 790;
            pConfig->hwv.jrvHardware.jpCenter.dwY = 790;
            pConfig->hwv.jrvHardware.jpCenter.dwZ = 0;
            pConfig->hwv.jrvHardware.jpCenter.dwR = 790;
            pConfig->hwv.jrvHardware.jpCenter.dwU = 790;
            pConfig->hwv.jrvHardware.jpCenter.dwV = 0;

            break;
        }

        default:
        case SIDEWINDER3P_DIGITAL_MODE:
        case SIDEWINDER3P_ENHANCED_DIGITAL_MODE:
        {
            pConfig->hws.dwFlags = JOY_HWS_HASPOV |
                                   JOY_HWS_POVISBUTTONCOMBOS |
                                   JOY_HWS_HASU |
                                   JOY_HWS_HASR;

            pConfig->dwUsageSettings = JOY_US_HASRUDDER |
                                       JOY_US_PRESENT |
                                       JOY_US_ISOEM;

            pConfig->hwv.jrvHardware.jpMin.dwX = 0;
            pConfig->hwv.jrvHardware.jpMin.dwY = 0;
            pConfig->hwv.jrvHardware.jpMin.dwZ = 0;
            pConfig->hwv.jrvHardware.jpMin.dwR = 0;
            pConfig->hwv.jrvHardware.jpMin.dwU = 0;
            pConfig->hwv.jrvHardware.jpMin.dwV = 0;

            pConfig->hwv.jrvHardware.jpMax.dwX = 1024;
            pConfig->hwv.jrvHardware.jpMax.dwY = 1024;
            pConfig->hwv.jrvHardware.jpMax.dwZ = 0;
            pConfig->hwv.jrvHardware.jpMax.dwR = 512;
            pConfig->hwv.jrvHardware.jpMax.dwU = 1024;
            pConfig->hwv.jrvHardware.jpMax.dwV = 0;

            pConfig->hwv.jrvHardware.jpCenter.dwX = 512;
            pConfig->hwv.jrvHardware.jpCenter.dwY = 512;
            pConfig->hwv.jrvHardware.jpCenter.dwZ = 0;
            pConfig->hwv.jrvHardware.jpCenter.dwR = 256;
            pConfig->hwv.jrvHardware.jpCenter.dwU = 512;
            pConfig->hwv.jrvHardware.jpCenter.dwV = 0;

            break;
        }
    }

    pConfig->hwv.dwCalFlags = JOY_ISCAL_POV;

    pConfig->dwType = JOY_HW_3A_4B_GENERIC;

    pConfig->dwReserved = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\joystick\joystat\joystat.c ===
#include "windows.h"
#include "stdio.h"
#include <winioctl.h>
#include <ntddjoy.h>


#define JOYSTATVERSION "Analog JoyStat 7/5/96\n"

int __cdecl main(int argc, char **argv) {


    HANDLE hJoy;

	ULONG nBytes;

	BOOL bRet;

    JOY_STATISTICS jStats, *pjStats;

    float fTotalErrors;
    int i;

	printf (JOYSTATVERSION);

    if ((hJoy = CreateFile(
                     "\\\\.\\Joy1", // maybe this is right, from SidewndrCreateDevice
                     GENERIC_READ | GENERIC_WRITE,
                     0,
                     NULL,
                     OPEN_EXISTING,
                     FILE_ATTRIBUTE_NORMAL,
                     NULL
                     )) != ((HANDLE)-1)) {

        pjStats = &jStats;

		bRet = DeviceIoControl (
			hJoy,
			(DWORD) IOCTL_JOY_GET_STATISTICS,	// instruction to execute
			pjStats, sizeof(JOY_STATISTICS),	// buffer and size of buffer
			pjStats, sizeof(JOY_STATISTICS),	// buffer and size of buffer
			&nBytes, 0);
        printf ("Version       %d\n", pjStats->Version);
        printf ("NumberOfAxes  %d\n", pjStats->NumberOfAxes);
        printf ("Frequency     %d\n", pjStats->Frequency);
        printf ("dwQPCLatency  %d\n", pjStats->dwQPCLatency);
        printf ("nQuiesceLoop  %d\n", pjStats->nQuiesceLoop);
        printf ("PolledTooSoon %d\n", pjStats->PolledTooSoon);
        printf ("Polls         %d\n", pjStats->Polls);
        printf ("Timeouts      %d\n", pjStats->Timeouts);

        // Point proven.  Be a nice program and close up shop.
        CloseHandle(hJoy);

    } else {

        printf("Can't get a handle to joystick\n");

    }
    return 1;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\kbfiltr\kbfiltr.h ===
/*++
Copyright (c) 1997  Microsoft Corporation

Module Name:

    kbfilter.h

Abstract:

    This module contains the common private declarations for the keyboard
    packet filter

Environment:

    kernel mode only

Notes:


Revision History:


--*/

#ifndef KBFILTER_H
#define KBFILTER_H

#include "ntddk.h"
#include "kbdmou.h"
#include <ntddkbd.h>
#include <ntdd8042.h>

#define KBFILTER_POOL_TAG (ULONG) 'tlfK'
#undef ExAllocatePool
#define ExAllocatePool(type, size) \
            ExAllocatePoolWithTag (type, size, KBFILTER_POOL_TAG)

#if DBG

#define TRAP()                      DbgBreakPoint()
#define DbgRaiseIrql(_x_,_y_)       KeRaiseIrql(_x_,_y_)
#define DbgLowerIrql(_x_)           KeLowerIrql(_x_)

#define DebugPrint(_x_) DbgPrint _x_

#else   // DBG

#define TRAP()
#define DbgRaiseIrql(_x_,_y_)
#define DbgLowerIrql(_x_)

#define DebugPrint(_x_) 

#endif

#define MIN(_A_,_B_) (((_A_) < (_B_)) ? (_A_) : (_B_))

typedef struct _DEVICE_EXTENSION
{
    //
    // A backpointer to the device object for which this is the extension
    //
    PDEVICE_OBJECT  Self;

    //
    // "THE PDO"  (ejected by the root bus or ACPI)
    //
    PDEVICE_OBJECT  PDO;

    //
    // The top of the stack before this filter was added.  AKA the location
    // to which all IRPS should be directed.
    //
    PDEVICE_OBJECT  TopOfStack;

    //
    // Number of creates sent down
    //
    LONG EnableCount;

    //
    // The real connect data that this driver reports to
    //
    CONNECT_DATA UpperConnectData;

    //
    // Previous initialization and hook routines (and context)
    //                               
    PVOID UpperContext;
    PI8042_KEYBOARD_INITIALIZATION_ROUTINE UpperInitializationRoutine;
    PI8042_KEYBOARD_ISR UpperIsrHook;

    //
    // Write function from within KbFilter_IsrHook
    //
    IN PI8042_ISR_WRITE_PORT IsrWritePort;

    //
    // Queue the current packet (ie the one passed into KbFilter_IsrHook)
    //
    IN PI8042_QUEUE_PACKET QueueKeyboardPacket;

    //
    // Context for IsrWritePort, QueueKeyboardPacket
    //
    IN PVOID CallContext;

    //
    // current power state of the device
    //
    DEVICE_POWER_STATE  DeviceState;

    BOOLEAN         Started;
    BOOLEAN         SurpriseRemoved;
    BOOLEAN         Removed;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

//
// Prototypes
//

NTSTATUS
KbFilter_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT BusDeviceObject
    );

NTSTATUS
KbFilter_CreateClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
KbFilter_DispatchPassThrough(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        );
   
NTSTATUS
KbFilter_InternIoCtl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
KbFilter_IoCtl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
KbFilter_PnP (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
KbFilter_Power (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
KbFilter_InitializationRoutine(
    IN PDEVICE_OBJECT                 DeviceObject,    // InitializationContext
    IN PVOID                           SynchFuncContext,
    IN PI8042_SYNCH_READ_PORT          ReadPort,
    IN PI8042_SYNCH_WRITE_PORT         WritePort,
    OUT PBOOLEAN                       TurnTranslationOn
    );

BOOLEAN
KbFilter_IsrHook(
    PDEVICE_OBJECT         DeviceObject,               // IsrContext
    PKEYBOARD_INPUT_DATA   CurrentInput, 
    POUTPUT_PACKET         CurrentOutput,
    UCHAR                  StatusByte,
    PUCHAR                 DataByte,
    PBOOLEAN               ContinueProcessing,
    PKEYBOARD_SCAN_STATE   ScanState
    );

VOID
KbFilter_ServiceCallback(
    IN PDEVICE_OBJECT DeviceObject,
    IN PKEYBOARD_INPUT_DATA InputDataStart,
    IN PKEYBOARD_INPUT_DATA InputDataEnd,
    IN OUT PULONG InputDataConsumed
    );

VOID
KbFilter_Unload (
    IN PDRIVER_OBJECT DriverObject
    );

#endif  // KBFILTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\kbdclass\kbdclass.h ===
/*++

Copyright (c) 1990, 1991, 1992, 1993, 1994 - 1998  Microsoft Corporation

Module Name:

    kbdclass.h

Abstract:

    These are the structures and defines that are used in the
    keyboard class driver.

Revision History:

--*/

#ifndef _KBDCLASS_
#define _KBDCLASS_

#include <ntddkbd.h>

#include "wmilib.h"

#define KEYBOARD_POOL_TAG 'CdbK'
#undef ExAllocatePool
#define ExAllocatePool(Type, Bytes) ExAllocatePoolWithTag(Type, Bytes, KEYBOARD_POOL_TAG)

//
// Define the default number of elements in the class input data queue.
//

#define DATA_QUEUE_SIZE 100
#define MAXIMUM_PORTS_SERVICED 10
#define NAME_MAX 256
#define DUMP_COUNT 4
#define DEFAULT_DEBUG_LEVEL 0

#define MAX(a,b) (((a) < (b)) ? (b) : (a))

#if DBG
#define KbdPrint(x) KbdDebugPrint x
#else
#define KbdPrint(x)
#endif

#define KEYBOARD_POWER_LIGHT_TIME L"PowerLightTime"
#define KEYBOARD_WAIT_WAKE_ENABLE L"WaitWakeEnabled"
#define KEYBOARD_ALLOW_DISABLE L"AllowDisable"

#define IS_TRUSTED_FILE_FOR_READ(x) (&DriverEntry == (x)->FsContext2)
#define SET_TRUSTED_FILE_FOR_READ(x) ((x)->FsContext2 = &DriverEntry)
#define CLEAR_TRUSTED_FILE_FOR_READ(x) ((x)->FsContext2 = NULL)

#define ALLOW_OVERFLOW TRUE

//
// Port description
//
// Used only with the
// allforoneandoneforall turned off (AKA ConnectOneClassToOnePort
// turned on).  This is the file sent to the ports.
//
typedef struct _PORT {
    //
    // The file Pointer to the port;
    //
    PFILE_OBJECT    File;

    //
    // The port itself
    //
    struct _DEVICE_EXTENSION * Port;

    //
    // Port flags
    //
    BOOLEAN     Enabled;
    BOOLEAN     Reserved [2];
    BOOLEAN     Free;
} PORT, *PPORT;

#define PORT_WORKING(port) ((port)->Enabled && !(port)->Free)

//
// Class device extension.
//
typedef struct _DEVICE_EXTENSION {

    //
    // Back pointer to the Device Object created for this port.
    //
    PDEVICE_OBJECT  Self;

    //
    // Pointer to the active Class DeviceObject;
    // If the AFOAOFA (all for one and one for all) switch is on then this
    // points to the device object named as the first keyboard.
    //
    PDEVICE_OBJECT  TrueClassDevice;

    //
    // The Target port device Object to which all IRPs are sent.
    //
    PDEVICE_OBJECT  TopPort;

    //
    // The PDO if applicable.
    //
    PDEVICE_OBJECT  PDO;

    //
    // A remove lock to keep track of outstanding I/Os to prevent the device
    // object from leaving before such time as all I/O has been completed.
    //
    IO_REMOVE_LOCK  RemoveLock;

    //
    // If this port a Plug and Play port
    //
    BOOLEAN         PnP;
    BOOLEAN         Started;
    BOOLEAN         AllowDisable;

    KSPIN_LOCK WaitWakeSpinLock;

    //
    // Is the Trusted Subsystem Connected
    //
    ULONG TrustedSubsystemCount;

    //
    // Number of input data items currently in the InputData queue.
    //
    ULONG InputCount;

    //
    // A Unicode string pointing to the symbolic link for the Device Interface
    // of this device object.
    //
    UNICODE_STRING  SymbolicLinkName;

    //
    // Start of the class input data queue (really a circular buffer).
    //
    PKEYBOARD_INPUT_DATA InputData;

    //
    // Insertion pointer for InputData.
    //
    PKEYBOARD_INPUT_DATA DataIn;

    //
    // Removal pointer for InputData.
    //
    PKEYBOARD_INPUT_DATA DataOut;

    //
    // Keyboard attributes.
    //
    KEYBOARD_ATTRIBUTES  KeyboardAttributes;

    //
    // A saved state of indicator lights
    //
    KEYBOARD_INDICATOR_PARAMETERS   IndicatorParameters;

    //
    // Spinlock used to synchronize access to the input data queue and its
    // insertion/removal pointers.
    //
    KSPIN_LOCK SpinLock;

    //
    // Queue of pended read requests sent to this port.  Access to this queue is
    // guarded by SpinLock
    //
    LIST_ENTRY ReadQueue;

    //
    // Request sequence number (used for error logging).
    //
    ULONG SequenceNumber;

    //
    // The "D" and "S" states of the current device
    //
    DEVICE_POWER_STATE DeviceState;
    SYSTEM_POWER_STATE SystemState;

    ULONG UnitId;

    //
    // WMI Information
    //
    WMILIB_CONTEXT WmiLibInfo;

    //
    // Mapping of system to device states when a wait wake irp is active
    //
    DEVICE_POWER_STATE SystemToDeviceState[PowerSystemHibernate];

    //
    // Minimum amount of power needed to wake the device
    //
    DEVICE_POWER_STATE MinDeviceWakeState;

    //
    // Lowest system state that the machine can be in and have the device wake it up
    //
    SYSTEM_POWER_STATE MinSystemWakeState;

    //
    // Actual wait wake irp
    //
    PIRP WaitWakeIrp;

    //
    // Duplicate wait wake irp getting completed because another was queued.
    //
    PIRP ExtraWaitWakeIrp;

    //
    // Target Device Notification Handle
    //
    PVOID TargetNotifyHandle;

    //
    // Only used for a legacy port device
    //
    LIST_ENTRY Link;

    //
    // Used only for a legacy port device when grand master mode is off
    //
    PFILE_OBJECT File;

    //
    // Used for a legacy port device
    //
    BOOLEAN Enabled;

    //
    // Indicates whether it is okay to log overflow errors.
    //
    BOOLEAN OkayToLogOverflow;

    //
    // Indicates whether it is okay to send wait wake irps down the stack
    // (does NOT reflect if the bus can implement or not)
    //
    BOOLEAN WaitWakeEnabled;

    //
    // Indicates whether we have received a surprise removed irp
    //
    BOOLEAN SurpriseRemoved;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

//
// On some busses, we can power down the bus, but not the system, in this case
// we still need to allow the device to wake said bus, therefore
// waitwake-supported should not rely on systemstate.
//
// #define WAITWAKE_SUPPORTED(port) ((port)->MinDeviceWakeState > PowerDeviceUnspecified) && \
//                                  (port)->MinSystemWakeState > PowerSystemWorking)
#define WAITWAKE_SUPPORTED(port) ((port)->MinDeviceWakeState > PowerDeviceD0 && \
                                  (port)->MinSystemWakeState > PowerSystemWorking)

// #define WAITWAKE_ON(port)        ((port)->WaitWakeIrp != 0)
#define WAITWAKE_ON(port) \
       (InterlockedCompareExchangePointer(&(port)->WaitWakeIrp, NULL, NULL) != NULL)

#define SHOULD_SEND_WAITWAKE(port) (WAITWAKE_SUPPORTED(port) && \
                                    !WAITWAKE_ON(port)       && \
                                    KeyboardClassCheckWaitWakeEnabled(port))

//
// Global shared data
//

typedef struct _GLOBALS {
    //
    // Declare the global debug flag for this driver.
    //
    ULONG   Debug;

    //
    // If ConnectOneClassToOnePort is off aka we want "All for one and one for
    // all behavior" then we need to create the one Master DO to which all
    // the goods go.
    //
    PDEVICE_EXTENSION   GrandMaster;

    //
    // List of ClassDevices that associated with the same name
    // aka the all for one and one for all flag is set
    //
    PPORT       AssocClassList;
    ULONG       NumAssocClass;
    LONG        Opens;
    ULONG       NumberLegacyPorts;
    FAST_MUTEX  Mutex;

    //
    // Specifies the type of class-port connection to make.  A '1'
    // indicates a 1:1 relationship between class device objects and
    // port device objects.  A '0' indicates a 1:many relationship.
    //
    ULONG ConnectOneClassToOnePort;

    //
    // When kbdclass receives an output command (EG set LEDs) this flag
    // instructs it to transmit that command to all attached ports,
    // regardless of the unit ID which was specified.
    //
    ULONG SendOutputToAllPorts;

    //
    // Number of port drivers serviced by this class driver.
    //
    ULONG PortsServiced;

    //
    //
    // IntialDevice Extension
    //
    DEVICE_EXTENSION    InitExtension;

    //
    // A list of the registry path to the service parameters.
    //
    UNICODE_STRING      RegistryPath;

    //
    // The base name for all class objects created as mice.
    //
    UNICODE_STRING      BaseClassName;
    WCHAR               BaseClassBuffer[NAME_MAX];

    //
    // Linked list of all the legacy device objects that were created in
    // DriverEntry or FindMorePorts.  We maintain this list so we can delete
    // them when we unload.
    //
    LIST_ENTRY LegacyDeviceList;
} GLOBALS, *PGLOBALS;

typedef struct _KBD_CALL_ALL_PORTS {
    //
    // Number of ports to call
    //
    ULONG   Len;

    //
    // Current Called port;
    //
    ULONG   Current;

    //
    // Array of Ports to call
    //
    PORT    Port[];

} KBD_CALL_ALL_PORTS, *PKBD_CALL_ALL_PORTS;

//
// Keyboard configuration information.
//

typedef struct _KEYBOARD_CONFIGURATION_INFORMATION {

    //
    // Maximum size of class input data queue, in bytes.
    //

    ULONG  DataQueueSize;

} KEYBOARD_CONFIGURATION_INFORMATION, *PKEYBOARD_CONFIGURATION_INFORMATION;

typedef struct _KEYBOARD_WORK_ITEM_DATA {
    PIRP                Irp;
    PDEVICE_EXTENSION   Data;
    PIO_WORKITEM        Item;
    BOOLEAN             WaitWakeState;
} KEYBOARD_WORK_ITEM_DATA, *PKEYBOARD_WORK_ITEM_DATA;

#define KeyboardClassDeleteLegacyDevice(de)                 \
{                                                           \
    if (de->InputData) {                                    \
        ExFreePool (de->InputData);                         \
        de->InputData = de->DataIn = de->DataOut = NULL;    \
    }                                                       \
    IoDeleteDevice (de->Self);                              \
    de = NULL;                                              \
}

//
// Function Declarations
//

NTSTATUS
KeyboardAddDeviceEx(
    IN PDEVICE_EXTENSION NewDeviceObject,
    IN PWCHAR            FullClassName,
    IN PFILE_OBJECT      File
    );

NTSTATUS
KeyboardAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

void
KeyboardClassGetWaitWakeEnableState(
    IN PDEVICE_EXTENSION Data
    );

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
KeyboardClassPassThrough(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        );

VOID
KeyboardClassCancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
KeyboardClassCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
KeyboardClassDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
KeyboardClassFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
KeyboardClassCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS
KeyboardClassClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
KeyboardClassRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
KeyboardClassReadCopyData(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    );

PIRP
KeyboardClassDequeueRead(
    IN PDEVICE_EXTENSION DeviceExtension
    );

PIRP
KeyboardClassDequeueReadByFileObject(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PFILE_OBJECT FileObject
    );

BOOLEAN
KeyboardClassCheckWaitWakeEnabled(
    IN PDEVICE_EXTENSION Data
    );

BOOLEAN
KeyboardClassCreateWaitWakeIrp (
    IN PDEVICE_EXTENSION Data
    );

NTSTATUS
KeyboardClassPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
KeyboardSendIrpSynchronously (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN BOOLEAN          CopyToNext
    );

NTSTATUS
KeyboardPnP (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
KeyboardClassServiceCallback(
    IN PDEVICE_OBJECT DeviceObject,
    IN PKEYBOARD_INPUT_DATA InputDataStart,
    IN PKEYBOARD_INPUT_DATA InputDataEnd,
    IN OUT PULONG InputDataConsumed
    );

VOID
KeyboardClassStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
KeyboardClassUnload(
    IN PDRIVER_OBJECT DriverObject
    );

BOOLEAN
KbdCancelRequest(
    IN PVOID Context
    );

VOID
KbdConfiguration();

NTSTATUS
KbdCreateClassObject(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDEVICE_EXTENSION   TmpDeviceExtension,
    OUT PDEVICE_OBJECT    * ClassDeviceObject,
    OUT PWCHAR            * FullDeviceName,
    IN  BOOLEAN             Legacy
    );

VOID
KbdDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );

NTSTATUS
KbdDeterminePortsServiced(
    IN PUNICODE_STRING BasePortName,
    IN OUT PULONG NumberPortsServiced
    );

NTSTATUS
KbdDeviceMapQueryCallback(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
KbdEnableDisablePort(
    IN BOOLEAN EnableFlag,
    IN PIRP    Irp,
    IN PDEVICE_EXTENSION Port,
    IN PFILE_OBJECT * File
    );

NTSTATUS
KbdSendConnectRequest(
    IN PDEVICE_EXTENSION ClassData,
    IN PVOID ServiceCallback
    );

VOID
KbdInitializeDataQueue(
    IN PVOID Context
    );

NTSTATUS
KeyboardCallAllPorts (
   PDEVICE_OBJECT Device,
   PIRP           Irp,
   PVOID
   );

NTSTATUS
KeyboardClassEnableGlobalPort(
    IN PDEVICE_EXTENSION Port,
    IN BOOLEAN Enabled
    );

NTSTATUS
KeyboardClassPlugPlayNotification(
    IN PVOID NotificationStructure,
    IN PDEVICE_EXTENSION Port
    );

VOID
KeyboardClassLogError(
    PVOID Object,
    ULONG ErrorCode,
    ULONG UniqueErrorValue,
    NTSTATUS FinalStatus,
    ULONG DumpCount,
    ULONG *DumpData,
    UCHAR MajorFunction
    );

BOOLEAN
KeyboardClassCreateWaitWakeIrp (
    IN PDEVICE_EXTENSION Data
    );

void
KeyboardClassCreateWaitWakeIrpWorker (
    IN PDEVICE_OBJECT DeviceObject,
    IN PKEYBOARD_WORK_ITEM_DATA  ItemData
    );

NTSTATUS
KeyboardToggleWaitWake(
    PDEVICE_EXTENSION Data,
    BOOLEAN           WaitWakeState
    );

void
KeyboardToggleWaitWakeWorker (
    IN PDEVICE_OBJECT DeviceObject,
    PKEYBOARD_WORK_ITEM_DATA ItemData
    );

NTSTATUS
KeyboardQueryDeviceKey (
    IN  HANDLE  Handle,
    IN  PWCHAR  ValueNameString,
    OUT PVOID   Data,
    IN  ULONG   DataLength
    );

VOID
KeyboardClassFindMorePorts(
    PDRIVER_OBJECT  DriverObject,
    PVOID           Context,
    ULONG           Count
    );

NTSTATUS
KeyboardClassSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
KeyboardClassSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
KeyboardClassSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );


NTSTATUS
KeyboardClassQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );

NTSTATUS
KeyboardClassQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *Pdo
    );

#endif // _KBDCLASS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\kbfiltr\kbfiltr.c ===
/*--
Copyright (c) 1998. 1999  Microsoft Corporation

Module Name:

    kbfiltr.c

Abstract:

Environment:

    Kernel mode only.

Notes:


--*/

#include "kbfiltr.h"

NTSTATUS DriverEntry (PDRIVER_OBJECT, PUNICODE_STRING);

#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, DriverEntry)
#pragma alloc_text (PAGE, KbFilter_AddDevice)
#pragma alloc_text (PAGE, KbFilter_CreateClose)
#pragma alloc_text (PAGE, KbFilter_IoCtl)
#pragma alloc_text (PAGE, KbFilter_InternIoCtl)
#pragma alloc_text (PAGE, KbFilter_Unload)
#pragma alloc_text (PAGE, KbFilter_DispatchPassThrough)
#pragma alloc_text (PAGE, KbFilter_PnP)
#pragma alloc_text (PAGE, KbFilter_Power)
#endif

NTSTATUS
DriverEntry (
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    )
/*++
Routine Description:

    Initialize the entry points of the driver.

--*/
{
    ULONG i;

    UNREFERENCED_PARAMETER (RegistryPath);

    // 
    // Fill in all the dispatch entry points with the pass through function
    // and the explicitly fill in the functions we are going to intercept
    // 
    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = KbFilter_DispatchPassThrough;
    }

    DriverObject->MajorFunction [IRP_MJ_CREATE] =
    DriverObject->MajorFunction [IRP_MJ_CLOSE] =        KbFilter_CreateClose;
    DriverObject->MajorFunction [IRP_MJ_PNP] =          KbFilter_PnP;
    DriverObject->MajorFunction [IRP_MJ_POWER] =        KbFilter_Power;
    DriverObject->MajorFunction [IRP_MJ_INTERNAL_DEVICE_CONTROL] =
                                                        KbFilter_InternIoCtl;
    //
    // If you are planning on using this function, you must create another
    // device object to send the requests to.  Please see the considerations 
    // comments for KbFilter_DispatchPassThrough for implementation details.
    //
    // DriverObject->MajorFunction [IRP_MJ_DEVICE_CONTROL] = KbFilter_IoCtl;

    DriverObject->DriverUnload = KbFilter_Unload;
    DriverObject->DriverExtension->AddDevice = KbFilter_AddDevice;

    return STATUS_SUCCESS;
}

NTSTATUS
KbFilter_AddDevice(
    IN PDRIVER_OBJECT   Driver,
    IN PDEVICE_OBJECT   PDO
    )
{
    PDEVICE_EXTENSION        devExt;
    IO_ERROR_LOG_PACKET      errorLogEntry;
    PDEVICE_OBJECT           device;
    NTSTATUS                 status = STATUS_SUCCESS;

    PAGED_CODE();

    status = IoCreateDevice(Driver,                   
                            sizeof(DEVICE_EXTENSION), 
                            NULL,                    
                            FILE_DEVICE_KEYBOARD,   
                            0,                     
                            FALSE,                
                            &device              
                            );

    if (!NT_SUCCESS(status)) {
        return (status);
    }

    RtlZeroMemory(device->DeviceExtension, sizeof(DEVICE_EXTENSION));

    devExt = (PDEVICE_EXTENSION) device->DeviceExtension;
    devExt->TopOfStack = IoAttachDeviceToDeviceStack(device, PDO);

    if (devExt->TopOfStack == NULL) {
        IoDeleteDevice(device);
        return STATUS_DEVICE_NOT_CONNECTED; 
    }

    
    ASSERT(devExt->TopOfStack);

    devExt->Self =          device;
    devExt->PDO =           PDO;
    devExt->DeviceState =   PowerDeviceD0;

    devExt->SurpriseRemoved = FALSE;
    devExt->Removed =         FALSE;
    devExt->Started =         FALSE;

    device->Flags |= (DO_BUFFERED_IO | DO_POWER_PAGABLE);
    device->Flags &= ~DO_DEVICE_INITIALIZING;

    return status;
}

NTSTATUS
KbFilter_Complete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
/*++
Routine Description:

    Generic completion routine that allows the driver to send the irp down the 
    stack, catch it on the way up, and do more processing at the original IRQL.
    
--*/
{
    PKEVENT  event;

    event = (PKEVENT) Context;

    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(Irp);

    //
    // We could switch on the major and minor functions of the IRP to perform
    // different functions, but we know that Context is an event that needs
    // to be set.
    //
    KeSetEvent(event, 0, FALSE);

    //
    // Allows the caller to use the IRP after it is completed
    //
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
KbFilter_CreateClose (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++
Routine Description:

    Maintain a simple count of the creates and closes sent against this device
    
--*/
{
    PIO_STACK_LOCATION  irpStack;
    NTSTATUS            status;
    PDEVICE_EXTENSION   devExt;


    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    devExt = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    status = Irp->IoStatus.Status;

    switch (irpStack->MajorFunction) {
    case IRP_MJ_CREATE:
    
        if (NULL == devExt->UpperConnectData.ClassService) {
            //
            // No Connection yet.  How can we be enabled?
            //
            status = STATUS_INVALID_DEVICE_STATE;
        }
        else if ( 1 == InterlockedIncrement(&devExt->EnableCount)) {
            //
            // first time enable here
            //
        }
        else {
            //
            // More than one create was sent down
            //
        }
    
        break;

    case IRP_MJ_CLOSE:

        if (0 == InterlockedDecrement(&devExt->EnableCount)) {
            //
            // successfully closed the device, do any appropriate work here
            //
        }

        break;
    }

    Irp->IoStatus.Status = status;

    //
    // Pass on the create and the close
    //
    return KbFilter_DispatchPassThrough(DeviceObject, Irp);
}

NTSTATUS
KbFilter_DispatchPassThrough(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        )
/*++
Routine Description:

    Passes a request on to the lower driver.
     
Considerations:
     
    If you are creating another device object (to communicate with user mode
    via IOCTLs), then this function must act differently based on the intended 
    device object.  If the IRP is being sent to the solitary device object, then
    this function should just complete the IRP (becuase there is no more stack
    locations below it).  If the IRP is being sent to the PnP built stack, then
    the IRP should be passed down the stack. 
    
    These changes must also be propagated to all the other IRP_MJ dispatch
    functions (create, close, cleanup, etc) as well!

--*/
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Pass the IRP to the target
    //
    IoSkipCurrentIrpStackLocation(Irp);
        
    return IoCallDriver(((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->TopOfStack, Irp);
}           

NTSTATUS
KbFilter_InternIoCtl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is the dispatch routine for internal device control requests.
    There are two specific control codes that are of interest:
    
    IOCTL_INTERNAL_KEYBOARD_CONNECT:
        Store the old context and function pointer and replace it with our own.
        This makes life much simpler than intercepting IRPs sent by the RIT and
        modifying them on the way back up.
                                      
    IOCTL_INTERNAL_I8042_HOOK_KEYBOARD:
        Add in the necessary function pointers and context values so that we can
        alter how the ps/2 keyboard is initialized.  
                                            
    NOTE:  Handling IOCTL_INTERNAL_I8042_HOOK_KEYBOARD is *NOT* necessary if 
           all you want to do is filter KEYBOARD_INPUT_DATAs.  You can remove
           the handling code and all related device extension fields and 
           functions to conserve space.
                                         
Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    PIO_STACK_LOCATION              irpStack;
    PDEVICE_EXTENSION               devExt;
    PINTERNAL_I8042_HOOK_KEYBOARD   hookKeyboard; 
    KEVENT                          event;
    PCONNECT_DATA                   connectData;
    NTSTATUS                        status = STATUS_SUCCESS;

    devExt = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    Irp->IoStatus.Information = 0;
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {

    //
    // Connect a keyboard class device driver to the port driver.
    //
    case IOCTL_INTERNAL_KEYBOARD_CONNECT:
        //
        // Only allow one connection.
        //
        if (devExt->UpperConnectData.ClassService != NULL) {
            status = STATUS_SHARING_VIOLATION;
            break;
        }
        else if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CONNECT_DATA)) {
            //
            // invalid buffer
            //
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // Copy the connection parameters to the device extension.
        //
        connectData = ((PCONNECT_DATA)
            (irpStack->Parameters.DeviceIoControl.Type3InputBuffer));

        devExt->UpperConnectData = *connectData;

        //
        // Hook into the report chain.  Everytime a keyboard packet is reported
        // to the system, KbFilter_ServiceCallback will be called
        //
        connectData->ClassDeviceObject = devExt->Self;
        connectData->ClassService = KbFilter_ServiceCallback;

        break;

    //
    // Disconnect a keyboard class device driver from the port driver.
    //
    case IOCTL_INTERNAL_KEYBOARD_DISCONNECT:

        //
        // Clear the connection parameters in the device extension.
        //
        // devExt->UpperConnectData.ClassDeviceObject = NULL;
        // devExt->UpperConnectData.ClassService = NULL;

        status = STATUS_NOT_IMPLEMENTED;
        break;

    //
    // Attach this driver to the initialization and byte processing of the 
    // i8042 (ie PS/2) keyboard.  This is only necessary if you want to do PS/2
    // specific functions, otherwise hooking the CONNECT_DATA is sufficient
    //
    case IOCTL_INTERNAL_I8042_HOOK_KEYBOARD:
        DebugPrint(("hook keyboard received!\n")); 
        if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(INTERNAL_I8042_HOOK_KEYBOARD)) {
            DebugPrint(("InternalIoctl error - invalid buffer length\n"));

            status = STATUS_INVALID_PARAMETER;
            break;
        }
        hookKeyboard = (PINTERNAL_I8042_HOOK_KEYBOARD) 
            irpStack->Parameters.DeviceIoControl.Type3InputBuffer;
            
        //
        // Enter our own initialization routine and record any Init routine
        // that may be above us.  Repeat for the isr hook
        // 
        devExt->UpperContext = hookKeyboard->Context;

        //
        // replace old Context with our own
        //
        hookKeyboard->Context = (PVOID) DeviceObject;

        if (hookKeyboard->InitializationRoutine) {
            devExt->UpperInitializationRoutine =
                hookKeyboard->InitializationRoutine;
        }
        hookKeyboard->InitializationRoutine =
            (PI8042_KEYBOARD_INITIALIZATION_ROUTINE) 
            KbFilter_InitializationRoutine;

        if (hookKeyboard->IsrRoutine) {
            devExt->UpperIsrHook = hookKeyboard->IsrRoutine;
        }
        hookKeyboard->IsrRoutine = (PI8042_KEYBOARD_ISR) KbFilter_IsrHook; 

        //
        // Store all of the other important stuff
        //
        devExt->IsrWritePort = hookKeyboard->IsrWritePort;
        devExt->QueueKeyboardPacket = hookKeyboard->QueueKeyboardPacket;
        devExt->CallContext = hookKeyboard->CallContext;

        status = STATUS_SUCCESS;
        break;

    //
    // These internal ioctls are not supported by the new PnP model.
    //
#if 0       // obsolete
    case IOCTL_INTERNAL_KEYBOARD_ENABLE:
    case IOCTL_INTERNAL_KEYBOARD_DISABLE:
        status = STATUS_NOT_SUPPORTED;
        break;
#endif  // obsolete

    //
    // Might want to capture these in the future.  For now, then pass them down
    // the stack.  These queries must be successful for the RIT to communicate
    // with the keyboard.
    //
    case IOCTL_KEYBOARD_QUERY_ATTRIBUTES:
    case IOCTL_KEYBOARD_QUERY_INDICATOR_TRANSLATION:
    case IOCTL_KEYBOARD_QUERY_INDICATORS:
    case IOCTL_KEYBOARD_SET_INDICATORS:
    case IOCTL_KEYBOARD_QUERY_TYPEMATIC:
    case IOCTL_KEYBOARD_SET_TYPEMATIC:
        break;
    }

    if (!NT_SUCCESS(status)) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    return KbFilter_DispatchPassThrough(DeviceObject, Irp);
}

NTSTATUS
KbFilter_PnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is the dispatch routine for plug and play irps 

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    PDEVICE_EXTENSION           devExt; 
    PIO_STACK_LOCATION          irpStack;
    NTSTATUS                    status = STATUS_SUCCESS;
    KIRQL                       oldIrql;
    KEVENT                      event;        

    PAGED_CODE();

    devExt = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    switch (irpStack->MinorFunction) {
    case IRP_MN_START_DEVICE: {

        //
        // The device is starting.
        //
        // We cannot touch the device (send it any non pnp irps) until a
        // start device has been passed down to the lower drivers.
        //
        IoCopyCurrentIrpStackLocationToNext(Irp);
        KeInitializeEvent(&event,
                          NotificationEvent,
                          FALSE
                          );

        IoSetCompletionRoutine(Irp,
                               (PIO_COMPLETION_ROUTINE) KbFilter_Complete, 
                               &event,
                               TRUE,
                               TRUE,
                               TRUE); // No need for Cancel

        status = IoCallDriver(devExt->TopOfStack, Irp);

        if (STATUS_PENDING == status) {
            KeWaitForSingleObject(
               &event,
               Executive, // Waiting for reason of a driver
               KernelMode, // Waiting in kernel mode
               FALSE, // No allert
               NULL); // No timeout
        }

        if (NT_SUCCESS(status) && NT_SUCCESS(Irp->IoStatus.Status)) {
            //
            // As we are successfully now back from our start device
            // we can do work.
            //
            devExt->Started = TRUE;
            devExt->Removed = FALSE;
            devExt->SurpriseRemoved = FALSE;
        }

        //
        // We must now complete the IRP, since we stopped it in the
        // completetion routine with MORE_PROCESSING_REQUIRED.
        //
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        break;
    }

    case IRP_MN_SURPRISE_REMOVAL:
        //
        // Same as a remove device, but don't call IoDetach or IoDeleteDevice
        //
        devExt->SurpriseRemoved = TRUE;

        // Remove code here

        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(devExt->TopOfStack, Irp);
        break;

    case IRP_MN_REMOVE_DEVICE:
        
        devExt->Removed = TRUE;

        // remove code here
        Irp->IoStatus.Status = STATUS_SUCCESS;
        
        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(devExt->TopOfStack, Irp);

        IoDetachDevice(devExt->TopOfStack); 
        IoDeleteDevice(DeviceObject);

        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_CANCEL_REMOVE_DEVICE:
    case IRP_MN_CANCEL_STOP_DEVICE:
    case IRP_MN_FILTER_RESOURCE_REQUIREMENTS: 
    case IRP_MN_STOP_DEVICE:
    case IRP_MN_QUERY_DEVICE_RELATIONS:
    case IRP_MN_QUERY_INTERFACE:
    case IRP_MN_QUERY_CAPABILITIES:
    case IRP_MN_QUERY_DEVICE_TEXT:
    case IRP_MN_QUERY_RESOURCES:
    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
    case IRP_MN_READ_CONFIG:
    case IRP_MN_WRITE_CONFIG:
    case IRP_MN_EJECT:
    case IRP_MN_SET_LOCK:
    case IRP_MN_QUERY_ID:
    case IRP_MN_QUERY_PNP_DEVICE_STATE:
    default:
        //
        // Here the filter driver might modify the behavior of these IRPS
        // Please see PlugPlay documentation for use of these IRPs.
        //
        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(devExt->TopOfStack, Irp);
        break;
    }

    return status;
}

NTSTATUS
KbFilter_Power(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    )
/*++

Routine Description:

    This routine is the dispatch routine for power irps   Does nothing except
    record the state of the device.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    PIO_STACK_LOCATION  irpStack;
    PDEVICE_EXTENSION   devExt;
    POWER_STATE         powerState;
    POWER_STATE_TYPE    powerType;

    PAGED_CODE();

    devExt = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    powerType = irpStack->Parameters.Power.Type;
    powerState = irpStack->Parameters.Power.State;

    switch (irpStack->MinorFunction) {
    case IRP_MN_SET_POWER:
        if (powerType  == DevicePowerState) {
            devExt->DeviceState = powerState.DeviceState;
        }

    case IRP_MN_POWER_SEQUENCE:
    case IRP_MN_WAIT_WAKE:
    case IRP_MN_QUERY_POWER:
    default:
        break;
    }

    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);
    return PoCallDriver(devExt->TopOfStack, Irp);
}

NTSTATUS
KbFilter_InitializationRoutine(
    IN PDEVICE_OBJECT                  DeviceObject,    
    IN PVOID                           SynchFuncContext,
    IN PI8042_SYNCH_READ_PORT          ReadPort,
    IN PI8042_SYNCH_WRITE_PORT         WritePort,
    OUT PBOOLEAN                       TurnTranslationOn
    )
/*++

Routine Description:

    This routine gets called after the following has been performed on the kb
    1)  a reset
    2)  set the typematic
    3)  set the LEDs
    
    i8042prt specific code, if you are writing a packet only filter driver, you
    can remove this function
    
Arguments:

    DeviceObject - Context passed during IOCTL_INTERNAL_I8042_HOOK_KEYBOARD
    
    SynchFuncContext - Context to pass when calling Read/WritePort
    
    Read/WritePort - Functions to synchronoulsy read and write to the kb
    
    TurnTranslationOn - If TRUE when this function returns, i8042prt will not
                        turn on translation on the keyboard

Return Value:

    Status is returned.

--*/
{
    PDEVICE_EXTENSION  devExt;
    NTSTATUS            status = STATUS_SUCCESS;

    devExt = DeviceObject->DeviceExtension;

    //
    // Do any interesting processing here.  We just call any other drivers
    // in the chain if they exist.  Make Translation is turned on as well
    //
    if (devExt->UpperInitializationRoutine) {
        status = (*devExt->UpperInitializationRoutine) (
            devExt->UpperContext,
            SynchFuncContext,
            ReadPort,
            WritePort,
            TurnTranslationOn
            );

        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    *TurnTranslationOn = TRUE;
    return status;
}

BOOLEAN
KbFilter_IsrHook(
    PDEVICE_OBJECT         DeviceObject,               
    PKEYBOARD_INPUT_DATA   CurrentInput, 
    POUTPUT_PACKET         CurrentOutput,
    UCHAR                  StatusByte,
    PUCHAR                 DataByte,
    PBOOLEAN               ContinueProcessing,
    PKEYBOARD_SCAN_STATE   ScanState
    )
/*++

Routine Description:

    This routine gets called at the beginning of processing of the kb interrupt.
    
    i8042prt specific code, if you are writing a packet only filter driver, you
    can remove this function
    
Arguments:

    DeviceObject - Our context passed during IOCTL_INTERNAL_I8042_HOOK_KEYBOARD
    
    CurrentInput - Current input packet being formulated by processing all the
                    interrupts

    CurrentOutput - Current list of bytes being written to the keyboard or the
                    i8042 port.
                    
    StatusByte    - Byte read from I/O port 60 when the interrupt occurred                                            
    
    DataByte      - Byte read from I/O port 64 when the interrupt occurred. 
                    This value can be modified and i8042prt will use this value
                    if ContinueProcessing is TRUE

    ContinueProcessing - If TRUE, i8042prt will proceed with normal processing of
                         the interrupt.  If FALSE, i8042prt will return from the
                         interrupt after this function returns.  Also, if FALSE,
                         it is this functions responsibilityt to report the input
                         packet via the function provided in the hook IOCTL or via
                         queueing a DPC within this driver and calling the
                         service callback function acquired from the connect IOCTL
                                             
Return Value:

    Status is returned.

--*/
{
    PDEVICE_EXTENSION devExt;
    BOOLEAN           retVal = TRUE;

    devExt = DeviceObject->DeviceExtension;

    if (devExt->UpperIsrHook) {
        retVal = (*devExt->UpperIsrHook) (
            devExt->UpperContext,
            CurrentInput,
            CurrentOutput,
            StatusByte,
            DataByte,
            ContinueProcessing,
            ScanState
            );

        if (!retVal || !(*ContinueProcessing)) {
            return retVal;
        }
    }

    *ContinueProcessing = TRUE;
    return retVal;
}

VOID
KbFilter_ServiceCallback(
    IN PDEVICE_OBJECT DeviceObject,
    IN PKEYBOARD_INPUT_DATA InputDataStart,
    IN PKEYBOARD_INPUT_DATA InputDataEnd,
    IN OUT PULONG InputDataConsumed
    )
/*++

Routine Description:

    Called when there are keyboard packets to report to the RIT.  You can do 
    anything you like to the packets.  For instance:
    
    o Drop a packet altogether
    o Mutate the contents of a packet 
    o Insert packets into the stream 
                    
Arguments:

    DeviceObject - Context passed during the connect IOCTL
    
    InputDataStart - First packet to be reported
    
    InputDataEnd - One past the last packet to be reported.  Total number of
                   packets is equal to InputDataEnd - InputDataStart
    
    InputDataConsumed - Set to the total number of packets consumed by the RIT
                        (via the function pointer we replaced in the connect
                        IOCTL)

Return Value:

    Status is returned.

--*/
{
    PDEVICE_EXTENSION   devExt;

    devExt = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    (*(PSERVICE_CALLBACK_ROUTINE) devExt->UpperConnectData.ClassService)(
        devExt->UpperConnectData.ClassDeviceObject,
        InputDataStart,
        InputDataEnd,
        InputDataConsumed);
}

VOID
KbFilter_Unload(
   IN PDRIVER_OBJECT Driver
   )
/*++

Routine Description:

   Free all the allocated resources associated with this driver.

Arguments:

   DriverObject - Pointer to the driver object.

Return Value:

   None.

--*/

{
    PAGED_CODE();

    UNREFERENCED_PARAMETER(Driver);

    ASSERT(NULL == Driver->DeviceObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\kbdclass\kbdclass.c ===
/*++

Copyright (c) 1990, 1991, 1992, 1993, 1994 - 1998  Microsoft Corporation

Module Name:

    kbdclass.c

Abstract:

    Keyboard class driver.

Environment:

    Kernel mode only.

Notes:

    NOTES:  (Future/outstanding issues)

    - Consolidate common code into a function, where appropriate.

@@BEGIN_DDKSPLIT

Revision History:

    May 1997 Kenneth D. Ray: liberal additions of plug and play

@@END_DDKSPLIT
--*/

#include <stdarg.h>
#include <stdio.h>
#include <ntddk.h>
//@@BEGIN_DDKSPLIT
#include <ntpoapi.h>
//@@END_DDKSPLIT
#include <hidclass.h>

#include <initguid.h>
#include <kbdmou.h>
#include <kbdlog.h>
#include "kbdclass.h"
#include <poclass.h>
#include <wmistr.h>

#define INITGUID
#include "wdmguid.h"

GLOBALS Globals;

//@@BEGIN_DDKSPLIT
NTSYSAPI
NTSTATUS
NTAPI
ZwPowerInformation(
    IN POWER_INFORMATION_LEVEL InformationLevel,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );
//@@END_DDKSPLIT

//
// Use the alloc_text pragma to specify the driver initialization routines
// (they can be paged out).
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(INIT,KbdConfiguration)
#pragma alloc_text(PAGE,KeyboardClassPassThrough)
#pragma alloc_text(PAGE,KeyboardQueryDeviceKey)
#pragma alloc_text(PAGE,KbdDeterminePortsServiced)
#pragma alloc_text(PAGE,KbdDeviceMapQueryCallback)
#pragma alloc_text(PAGE,KbdSendConnectRequest)
#pragma alloc_text(PAGE,KeyboardAddDevice)
#pragma alloc_text(PAGE,KeyboardAddDeviceEx)
#pragma alloc_text(PAGE,KeyboardClassDeviceControl)
#pragma alloc_text(PAGE,KeyboardSendIrpSynchronously)
#pragma alloc_text(PAGE,KbdCreateClassObject)
#pragma alloc_text(PAGE,KeyboardClassFindMorePorts)
#pragma alloc_text(PAGE,KeyboardClassGetWaitWakeEnableState)
#pragma alloc_text(PAGE,KeyboardClassEnableGlobalPort)
#pragma alloc_text(PAGE,KeyboardClassPlugPlayNotification)
#pragma alloc_text(PAGE,KeyboardClassSystemControl)
#pragma alloc_text(PAGE,KeyboardClassSetWmiDataItem)
#pragma alloc_text(PAGE,KeyboardClassSetWmiDataBlock)
#pragma alloc_text(PAGE,KeyboardClassQueryWmiDataBlock)
#pragma alloc_text(PAGE,KeyboardClassQueryWmiRegInfo)

#pragma alloc_text(PAGE,KeyboardClassPower)
#pragma alloc_text(PAGE,KeyboardClassCreateWaitWakeIrpWorker)
#pragma alloc_text(PAGE,KeyboardClassCreateWaitWakeIrp)
// #pragma alloc_text(PAGE,KeyboardToggleWaitWakeWorker)
#pragma alloc_text(PAGE,KeyboardClassUnload)
#endif

#define WMI_CLASS_DRIVER_INFORMATION 0
#define WMI_WAIT_WAKE                1

GUID KeyboardClassGuid =  MSKeyboard_ClassInformationGuid;

WMIGUIDREGINFO KeyboardClassWmiGuidList[] =
{
    {
        &KeyboardClassGuid,
        1,
        0 // Keyboard class driver information
    },
    {
        &GUID_POWER_DEVICE_WAKE_ENABLE,
        1,
        0 // wait wake
    }
};


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine initializes the keyboard class driver.

Arguments:

    DriverObject - Pointer to driver object created by system.

    RegistryPath - Pointer to the Unicode name of the registry path
        for this driver.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    NTSTATUS                status = STATUS_SUCCESS;
    PDEVICE_EXTENSION       deviceExtension = NULL;
    PDEVICE_OBJECT          classDeviceObject = NULL;
    ULONG                   dumpCount = 0;
    ULONG                   dumpData[DUMP_COUNT];
    ULONG                   i;
    ULONG                   numPorts;
    ULONG                   uniqueErrorValue;
    UNICODE_STRING          basePortName;
    UNICODE_STRING          fullPortName;
    WCHAR                   basePortBuffer[NAME_MAX];
    PWCHAR                  fullClassName = NULL;
    PFILE_OBJECT            file;
    PLIST_ENTRY             entry;

    KbdPrint((1,"\n\nKBDCLASS-KeyboardClassInitialize: enter\n"));

    //
    // Zero-initialize various structures.
    //
    RtlZeroMemory(&Globals, sizeof(GLOBALS));

    Globals.Debug = DEFAULT_DEBUG_LEVEL;

    InitializeListHead (&Globals.LegacyDeviceList);

    fullPortName.MaximumLength = 0;

    ExInitializeFastMutex (&Globals.Mutex);
    Globals.BaseClassName.Buffer = Globals.BaseClassBuffer;
    Globals.BaseClassName.Length = 0;
    Globals.BaseClassName.MaximumLength = NAME_MAX * sizeof(WCHAR);

    RtlZeroMemory(basePortBuffer, NAME_MAX * sizeof(WCHAR));
    basePortName.Buffer = basePortBuffer;
    basePortName.Length = 0;
    basePortName.MaximumLength = NAME_MAX * sizeof(WCHAR);

    //
    // Need to ensure that the registry path is null-terminated.
    // Allocate pool to hold a null-terminated copy of the path.
    //

    Globals.RegistryPath.Length = RegistryPath->Length;
    Globals.RegistryPath.MaximumLength = RegistryPath->Length
                                       + sizeof (UNICODE_NULL);

    Globals.RegistryPath.Buffer = ExAllocatePool(
                                      NonPagedPool,
                                      Globals.RegistryPath.MaximumLength);

    if (!Globals.RegistryPath.Buffer) {
        KbdPrint((
            1,
            "KBDCLASS-KeyboardClassInitialize: Couldn't allocate pool for registry path\n"
            ));

        dumpData[0] = (ULONG) RegistryPath->Length + sizeof(UNICODE_NULL);

        KeyboardClassLogError (DriverObject,
                               KBDCLASS_INSUFFICIENT_RESOURCES,
                               KEYBOARD_ERROR_VALUE_BASE + 2,
                               STATUS_UNSUCCESSFUL,
                               1,
                               dumpData,
                               0);

        goto KeyboardClassInitializeExit;
    }

    RtlMoveMemory(Globals.RegistryPath.Buffer,
                  RegistryPath->Buffer,
                  RegistryPath->Length);
    Globals.RegistryPath.Buffer [RegistryPath->Length / sizeof (WCHAR)] = L'\0';

    //
    // Get the configuration information for this driver.
    //

    KbdConfiguration();

    //
    // If there is only one class device object then create it as the grand
    // master device object.  Otherwise let all the FDOs also double as the
    // class DO.
    //
    if (!Globals.ConnectOneClassToOnePort) {
        status = KbdCreateClassObject (DriverObject,
                                       &Globals.InitExtension,
                                       &classDeviceObject,
                                       &fullClassName,
                                       TRUE);
        if (!NT_SUCCESS (status)) {
            // ISSUE:  should log an error that we could not create a GM
            goto KeyboardClassInitializeExit;
        }

        deviceExtension = (PDEVICE_EXTENSION)classDeviceObject->DeviceExtension;
        Globals.GrandMaster = deviceExtension;
        deviceExtension->PnP = FALSE;
        KeyboardAddDeviceEx (deviceExtension, fullClassName, NULL);

        ASSERT (NULL != fullClassName);
        ExFreePool (fullClassName);
        fullClassName = NULL;

        classDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    }

    //
    // Set up the base device name for the associated port device.
    // It is the same as the base class name, with "Class" replaced
    // by "Port".
    //
    RtlCopyUnicodeString(&basePortName, &Globals.BaseClassName);
    basePortName.Length -= (sizeof(L"Class") - sizeof(UNICODE_NULL));
    RtlAppendUnicodeToString(&basePortName, L"Port");

    //
    // Determine how many (static) ports this class driver is to service.
    //
    //
    // If this returns zero, then all ports will be dynamically PnP added later
    //
    KbdDeterminePortsServiced(&basePortName, &numPorts);

    ASSERT (numPorts <= MAXIMUM_PORTS_SERVICED);

    KbdPrint((
        1,
        "KBDCLASS-KeyboardClassInitialize: Will service %d port devices\n",
        numPorts
        ));

    //
    // Set up space for the class's full device object name.
    //
    RtlInitUnicodeString(&fullPortName, NULL);

    fullPortName.MaximumLength = sizeof(L"\\Device\\")
                                + basePortName.Length
                                + sizeof (UNICODE_NULL);

    fullPortName.Buffer = ExAllocatePool(PagedPool,
                                         fullPortName.MaximumLength);

    if (!fullPortName.Buffer) {

        KbdPrint((
            1,
            "KBDCLASS-KeyboardClassInitialize: Couldn't allocate string for device object name\n"
            ));

        status = STATUS_UNSUCCESSFUL;
        dumpData[0] = (ULONG) fullPortName.MaximumLength;

        KeyboardClassLogError (DriverObject,
                               KBDCLASS_INSUFFICIENT_RESOURCES,
                               KEYBOARD_ERROR_VALUE_BASE + 6,
                               status,
                               1,
                               dumpData,
                               0);

        goto KeyboardClassInitializeExit;

    }

    RtlZeroMemory(fullPortName.Buffer, fullPortName.MaximumLength);
    RtlAppendUnicodeToString(&fullPortName, L"\\Device\\");
    RtlAppendUnicodeToString(&fullPortName, basePortName.Buffer);
    RtlAppendUnicodeToString(&fullPortName, L"0");

    //
    // Set up the class device object(s) to handle the associated
    // port devices.
    //
    for (i = 0; (i < Globals.PortsServiced) && (i < numPorts); i++) {

        //
        // Append the suffix to the device object name string.  E.g., turn
        // \Device\KeyboardClass into \Device\KeyboardClass0.  Then attempt
        // to create the device object.  If the device object already
        // exists increment the suffix and try again.
        //

        fullPortName.Buffer[(fullPortName.Length / sizeof(WCHAR)) - 1]
            = L'0' + (WCHAR) i;

        //
        // Create the class device object.
        //
        status = KbdCreateClassObject (DriverObject,
                                       &Globals.InitExtension,
                                       &classDeviceObject,
                                       &fullClassName,
                                       TRUE);

        if (!NT_SUCCESS(status)) {
            KeyboardClassLogError (DriverEntry,
                                   KBDCLASS_INSUFFICIENT_RESOURCES,
                                   KEYBOARD_ERROR_VALUE_BASE + 8,
                                   status,
                                   0,
                                   NULL,
                                   0);
            continue;
        }

        deviceExtension = (PDEVICE_EXTENSION)classDeviceObject->DeviceExtension;
        deviceExtension->PnP = FALSE;

        classDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

        //
        // Connect to the port device.
        //
        status = IoGetDeviceObjectPointer (&fullPortName,
                                           FILE_READ_ATTRIBUTES,
                                           &file,
                                           &deviceExtension->TopPort);

        //
        // In case of failure, just delete the device and continue
        //
        if (!NT_SUCCESS(status)) {
            // ISSUE: log error
            KeyboardClassDeleteLegacyDevice (deviceExtension);
            continue;
        }

        classDeviceObject->StackSize = 1 + deviceExtension->TopPort->StackSize;
        status = KeyboardAddDeviceEx (deviceExtension, fullClassName, file);

        if (fullClassName) {
            ExFreePool (fullClassName);
            fullClassName = NULL;
        }

        if (!NT_SUCCESS (status)) {
            if (Globals.GrandMaster == NULL) {
                if (deviceExtension->File) {
                    file = deviceExtension->File;
                    deviceExtension->File = NULL;
                }
            }
            else {
                PPORT port;

                ExAcquireFastMutex (&Globals.Mutex);

                file = Globals.AssocClassList[deviceExtension->UnitId].File;
                Globals.AssocClassList[deviceExtension->UnitId].File = NULL;
                Globals.AssocClassList[deviceExtension->UnitId].Free = TRUE;
                Globals.AssocClassList[deviceExtension->UnitId].Port = NULL;

                ExReleaseFastMutex (&Globals.Mutex);
            }

            if (file) {
                ObDereferenceObject (file);
            }

            KeyboardClassDeleteLegacyDevice (deviceExtension);
            continue;
        }

        //
        // Store this device object in a linked list regardless if we are in
        // grand master mode or not
        //
        InsertTailList (&Globals.LegacyDeviceList, &deviceExtension->Link);
    } // for

    //
    // If we had any failures creating legacy device objects, we must still
    // succeed b/c we need to service pnp ports later on
    //
    status = STATUS_SUCCESS;

    //
    // Count the number of legacy device ports we created
    //
    for (entry = Globals.LegacyDeviceList.Flink;
         entry != &Globals.LegacyDeviceList;
         entry = entry->Flink) {
        Globals.NumberLegacyPorts++;
    }

KeyboardClassInitializeExit:

    //
    // Free the unicode strings.
    //
    if (fullPortName.MaximumLength != 0){
        ExFreePool (fullPortName.Buffer);
    }

    if (fullClassName) {
        ExFreePool (fullClassName);
    }

    if (NT_SUCCESS (status)) {

        IoRegisterDriverReinitialization(DriverObject,
                                         KeyboardClassFindMorePorts,
                                         NULL);

        //
        // Set up the device driver entry points.
        //
        DriverObject->MajorFunction[IRP_MJ_CREATE]         = KeyboardClassCreate;
        DriverObject->MajorFunction[IRP_MJ_CLOSE]          = KeyboardClassClose;
        DriverObject->MajorFunction[IRP_MJ_READ]           = KeyboardClassRead;
        DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS]  = KeyboardClassFlush;
        DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = KeyboardClassDeviceControl;
        DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] =
                                                             KeyboardClassPassThrough;
        DriverObject->MajorFunction[IRP_MJ_CLEANUP]        = KeyboardClassCleanup;
        DriverObject->MajorFunction[IRP_MJ_PNP]            = KeyboardPnP;
        DriverObject->MajorFunction[IRP_MJ_POWER]          = KeyboardClassPower;
        DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = KeyboardClassSystemControl;
        DriverObject->DriverExtension->AddDevice           = KeyboardAddDevice;

        // DriverObject->DriverUnload = KeyboardClassUnload;

        status = STATUS_SUCCESS;

    } else {
        //
        // Clean up all the pool we created and delete the GM if it exists
        //
        if (Globals.RegistryPath.Buffer != NULL) {
            ExFreePool (Globals.RegistryPath.Buffer);
            Globals.RegistryPath.Buffer = NULL;
        }

        if (Globals.AssocClassList) {
            ExFreePool (Globals.AssocClassList);
            Globals.AssocClassList = NULL;
        }

        if (Globals.GrandMaster) {
            KeyboardClassDeleteLegacyDevice(Globals.GrandMaster);
            Globals.GrandMaster = NULL;
        }
    }

    KbdPrint((1,"KBDCLASS-KeyboardClassInitialize: exit\n"));

    return status;
}

NTSTATUS
KeyboardClassPassThrough(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        )
/*++
Routine Description:

        Passes a request on to the lower driver.

--*/
{
        //
        // Pass the IRP to the target
        //
    IoSkipCurrentIrpStackLocation (Irp);
        return IoCallDriver (
        ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->TopPort,
                Irp);
}


NTSTATUS
KeyboardQueryDeviceKey (
    IN  HANDLE  Handle,
    IN  PWCHAR  ValueNameString,
    OUT PVOID   Data,
    IN  ULONG   DataLength
    )
{
    NTSTATUS        status;
    UNICODE_STRING  valueName;
    ULONG           length;
    PKEY_VALUE_FULL_INFORMATION fullInfo;

    PAGED_CODE();

    RtlInitUnicodeString (&valueName, ValueNameString);

    length = sizeof (KEY_VALUE_FULL_INFORMATION)
           + valueName.MaximumLength
           + DataLength;

    fullInfo = ExAllocatePool (PagedPool, length);

    if (fullInfo) {
        status = ZwQueryValueKey (Handle,
                                  &valueName,
                                  KeyValueFullInformation,
                                  fullInfo,
                                  length,
                                  &length);

        if (NT_SUCCESS (status)) {
            ASSERT (DataLength == fullInfo->DataLength);
            RtlCopyMemory (Data,
                           ((PUCHAR) fullInfo) + fullInfo->DataOffset,
                           fullInfo->DataLength);
        }

        ExFreePool (fullInfo);
    } else {
        status = STATUS_NO_MEMORY;
    }

    return status;
}

NTSTATUS
KeyboardAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++
Description:
    The plug play entry point "AddDevice"

--*/
{
    NTSTATUS            status;
    PDEVICE_OBJECT      fdo;
    PDEVICE_EXTENSION   port;
    PWCHAR              fullClassName = NULL;
    POWER_STATE         state;
    HANDLE              hService, hParameters;
    ULONG               tmp;
    OBJECT_ATTRIBUTES   oa;

    PAGED_CODE ();

    status = KbdCreateClassObject (DriverObject,
                                   &Globals.InitExtension,
                                   &fdo,
                                   &fullClassName,
                                   FALSE);

    if (!NT_SUCCESS (status)) {
        return status;
    }

    port = (PDEVICE_EXTENSION) fdo->DeviceExtension;
    port->TopPort = IoAttachDeviceToDeviceStack (fdo, PhysicalDeviceObject);

    if (port->TopPort == NULL) {
        PIO_ERROR_LOG_PACKET errorLogEntry;

        //
        // Not good; in only extreme cases will this fail
        //
        errorLogEntry = (PIO_ERROR_LOG_PACKET)
            IoAllocateErrorLogEntry (DriverObject,
                                     (UCHAR) sizeof(IO_ERROR_LOG_PACKET));

        if (errorLogEntry) {
            errorLogEntry->ErrorCode = KBDCLASS_ATTACH_DEVICE_FAILED;
            errorLogEntry->DumpDataSize = 0;
            errorLogEntry->SequenceNumber = 0;
            errorLogEntry->MajorFunctionCode = 0;
            errorLogEntry->IoControlCode = 0;
            errorLogEntry->RetryCount = 0;
            errorLogEntry->UniqueErrorValue = 0;
            errorLogEntry->FinalStatus =  STATUS_DEVICE_NOT_CONNECTED;

            IoWriteErrorLogEntry (errorLogEntry);
        }

        IoDeleteDevice (fdo);
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    port->PDO = PhysicalDeviceObject;
    port->PnP = TRUE;
    port->Started = FALSE;
    port->DeviceState = PowerDeviceD0;
    port->SystemState = PowerSystemWorking;

    state.DeviceState = PowerDeviceD0;
    PoSetPowerState (fdo, DevicePowerState, state);

    port->MinDeviceWakeState = PowerDeviceUnspecified;
    port->MinSystemWakeState = PowerSystemUnspecified;
    port->WaitWakeEnabled = FALSE;
    port->AllowDisable  = FALSE;

    InitializeObjectAttributes (&oa,
                                &Globals.RegistryPath,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                (PSECURITY_DESCRIPTOR) NULL);

    status = ZwOpenKey (&hService, KEY_ALL_ACCESS, &oa);

    if (NT_SUCCESS (status)) {
        UNICODE_STRING parameters;

        RtlInitUnicodeString(&parameters, L"Parameters");
        InitializeObjectAttributes (&oa,
                                    &parameters,
                                    OBJ_CASE_INSENSITIVE,
                                    hService,
                                    (PSECURITY_DESCRIPTOR) NULL);

        status = ZwOpenKey (&hParameters, KEY_ALL_ACCESS, &oa);
        if (NT_SUCCESS (status)) {
            status = KeyboardQueryDeviceKey (hParameters,
                                             KEYBOARD_ALLOW_DISABLE,
                                             &tmp,
                                             sizeof (tmp));

            if (NT_SUCCESS (status)) {
                port->AllowDisable = (tmp ? TRUE : FALSE);
            }

            ZwClose (hParameters);
        }

        ZwClose (hService);
    }

    fdo->Flags |= DO_POWER_PAGABLE;
    fdo->Flags &= ~DO_DEVICE_INITIALIZING;

    status = IoRegisterDeviceInterface (PhysicalDeviceObject,
                                        (LPGUID)&GUID_CLASS_KEYBOARD,
                                        NULL,
                                        &port->SymbolicLinkName );

    if (!NT_SUCCESS (status)) {
        IoDetachDevice (port->TopPort);
        port->TopPort = NULL;
        IoDeleteDevice (fdo);
    } else {
        status = KeyboardAddDeviceEx (port, fullClassName, NULL);
    }

    if (fullClassName) {
        ExFreePool(fullClassName);
    }

    return status;
}

void
KeyboardClassGetWaitWakeEnableState(
    IN PDEVICE_EXTENSION Data
    )
{
    HANDLE hKey;
    NTSTATUS status;
    ULONG tmp;
    BOOLEAN wwEnableFound;

    hKey = NULL;
    wwEnableFound = FALSE;

    status = IoOpenDeviceRegistryKey (Data->PDO,
                                      PLUGPLAY_REGKEY_DEVICE,
                                      STANDARD_RIGHTS_ALL,
                                      &hKey);

    if (NT_SUCCESS (status)) {
        status = KeyboardQueryDeviceKey (hKey,
                                         KEYBOARD_WAIT_WAKE_ENABLE,
                                         &tmp,
                                         sizeof (tmp));
        if (NT_SUCCESS (status)) {
            wwEnableFound = TRUE;
            Data->WaitWakeEnabled = (tmp ? TRUE : FALSE);
        }
        ZwClose (hKey);
        hKey = NULL;
    }

//@@BEGIN_DDKSPLIT
    if (wwEnableFound == FALSE && Data->WaitWakeEnabled == FALSE) {
        RTL_OSVERSIONINFOEXW osVerInfo;
        ULONGLONG mask = 0;

        //
        // Only auto enable wait wake on workstation installs (pro and personal)
        //
        RtlZeroMemory(&osVerInfo, sizeof(osVerInfo));
        osVerInfo.dwOSVersionInfoSize = sizeof(osVerInfo);
        osVerInfo.wProductType = VER_NT_WORKSTATION;

        VER_SET_CONDITION(mask, VER_PRODUCT_TYPE, VER_EQUAL);

        if (NT_SUCCESS(RtlVerifyVersionInfo(&osVerInfo,
                                            VER_PRODUCT_TYPE,
                                            mask))) {
            SYSTEM_POWER_CAPABILITIES sysPowerCaps;

            RtlZeroMemory(&sysPowerCaps, sizeof(sysPowerCaps));

            status = ZwPowerInformation (SystemPowerCapabilities,
                                         NULL,
                                         0,
                                         &sysPowerCaps,
                                         sizeof(SYSTEM_POWER_CAPABILITIES));

            if (NT_SUCCESS (status)) {
                SYSTEM_POWER_STATE maxSysWake;

                //
                // Get the deepest sleep state the machine is capable of
                //
                if (sysPowerCaps.SystemS3) {
                    maxSysWake = PowerSystemSleeping3;
                }
                else if (sysPowerCaps.SystemS2) {
                    maxSysWake = PowerSystemSleeping2;
                }
                else if (sysPowerCaps.SystemS1) {
                    maxSysWake = PowerSystemSleeping1;
                }
                else {
                    maxSysWake = PowerSystemUnspecified;
                }

                //
                // See if the system wake state for the device is as deep (or
                // deeper) than the deepest system sleep state.  This will
                // prevent us from auto enabling wake and then only allowing the
                // machine to go into S1 instead of S3 (which is the case on a
                // lot of laptops).
                //
                if (Data->MinSystemWakeState >= maxSysWake) {
                    //
                    // Success!
                    //
                    Data->WaitWakeEnabled = TRUE;
                }
            }
        }
    }
//@@END_DDKSPLIT
}

NTSTATUS
KeyboardAddDeviceEx(
    IN PDEVICE_EXTENSION    ClassData,
    IN PWCHAR               FullClassName,
    IN PFILE_OBJECT         File
    )
 /*++ Description:
  *
  * Called whenever the Keyboard Class driver is loaded to control a device.
  *
  * Two possible reasons.
  * 1) Plug and Play found a PNP enumerated keyboard port.
  * 2) Driver Entry found this device via old crusty legacy reasons.
  *
  * Arguments:
  *
  *
  * Return:
  *
  * STATUS_SUCCESS - if successful STATUS_UNSUCCESSFUL - otherwise
  *
  * --*/
{
    NTSTATUS                errorCode = STATUS_SUCCESS;
    NTSTATUS                status = STATUS_SUCCESS;
    PDEVICE_EXTENSION       trueClassData;
    PPORT                   classDataList;
    ULONG                   uniqueErrorValue = 0;
    PIO_ERROR_LOG_PACKET    errorLogEntry;
    ULONG                   dumpCount = 0;
    ULONG                   dumpData[DUMP_COUNT];
    ULONG                   i;

    PAGED_CODE ();

    KeInitializeSpinLock (&ClassData->WaitWakeSpinLock);

    if (Globals.ConnectOneClassToOnePort) {

        ASSERT (NULL == Globals.GrandMaster);
        trueClassData = ClassData;

    } else {
        trueClassData = Globals.GrandMaster;
    }
    ClassData->TrueClassDevice = trueClassData->Self;

    if ((Globals.GrandMaster != ClassData) &&
        (Globals.GrandMaster == trueClassData)) {
        //
        // We have a grand master, and are adding a port device object.
        //

        //
        // Connect to port device.
        //
        status = KbdSendConnectRequest(ClassData, KeyboardClassServiceCallback);

        //
        // Link this class device object in the list of class devices object
        // associated with the true class device object
        //
        ExAcquireFastMutex (&Globals.Mutex);

        for (i=0; i < Globals.NumAssocClass; i++) {
            if (Globals.AssocClassList[i].Free) {
                Globals.AssocClassList[i].Free = FALSE;
                break;
            }
        }

        if (i == Globals.NumAssocClass) {
            classDataList = ExAllocatePool (
                                NonPagedPool,
                                (Globals.NumAssocClass + 1) * sizeof (PORT));

            if (NULL == classDataList) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                // ISSUE: log error

                ExReleaseFastMutex (&Globals.Mutex);

                goto KeyboardAddDeviceExReject;
            }

            RtlZeroMemory (classDataList,
                           (Globals.NumAssocClass + 1) * sizeof (PORT));

            if (0 != Globals.NumAssocClass) {
                RtlCopyMemory (classDataList,
                               Globals.AssocClassList,
                               Globals.NumAssocClass * sizeof (PORT));

                ExFreePool (Globals.AssocClassList);
            }
            Globals.AssocClassList = classDataList;
            Globals.NumAssocClass++;
        }

        ClassData->UnitId = i;
        Globals.AssocClassList [i].Port = ClassData;
        Globals.AssocClassList [i].File = File;

        trueClassData->Self->StackSize =
            MAX (trueClassData->Self->StackSize, ClassData->Self->StackSize);

        ExReleaseFastMutex (&Globals.Mutex);

    } else if ((Globals.GrandMaster != ClassData) &&
               (ClassData == trueClassData)) {

        //
        // Connect to port device.
        //
        status = KbdSendConnectRequest(ClassData, KeyboardClassServiceCallback);
        ASSERT (STATUS_SUCCESS == status);
    }

    if (ClassData == trueClassData) {

        ASSERT (NULL != FullClassName);

        //
        // Load the device map information into the registry so
        // that setup can determine which keyboard class driver is active.
        //

        status = RtlWriteRegistryValue(
                     RTL_REGISTRY_DEVICEMAP,
                     Globals.BaseClassName.Buffer, // key name
                     FullClassName, // value name
                     REG_SZ,
                     Globals.RegistryPath.Buffer, // The value
                     Globals.RegistryPath.Length + sizeof(UNICODE_NULL));

        if (!NT_SUCCESS(status)) {

            KbdPrint((
                1,
                "KBDCLASS-KeyboardClassInitialize: Could not store %ws in DeviceMap\n",
                FullClassName));

            KeyboardClassLogError (ClassData,
                                   KBDCLASS_NO_DEVICEMAP_CREATED,
                                   KEYBOARD_ERROR_VALUE_BASE + 14,
                                   status,
                                   0,
                                   NULL,
                                   0);
        } else {

            KbdPrint((
                1,
                "KBDCLASS-KeyboardClassInitialize: Stored %ws in DeviceMap\n",
                FullClassName));

        }
    }

    return status;

KeyboardAddDeviceExReject:

    //
    // Some part of the initialization failed.  Log an error, and
    // clean up the resources for the failed part of the initialization.
    //
    if (errorCode != STATUS_SUCCESS) {

        errorLogEntry = (PIO_ERROR_LOG_PACKET)
            IoAllocateErrorLogEntry(
                trueClassData->Self,
                (UCHAR) (sizeof(IO_ERROR_LOG_PACKET)
                         + (dumpCount * sizeof(ULONG)))
                );

        if (errorLogEntry != NULL) {

            errorLogEntry->ErrorCode = errorCode;
            errorLogEntry->DumpDataSize = (USHORT) (dumpCount * sizeof (ULONG));
            errorLogEntry->SequenceNumber = 0;
            errorLogEntry->MajorFunctionCode = 0;
            errorLogEntry->IoControlCode = 0;
            errorLogEntry->RetryCount = 0;
            errorLogEntry->UniqueErrorValue = uniqueErrorValue;
            errorLogEntry->FinalStatus = status;
            for (i = 0; i < dumpCount; i++)
                errorLogEntry->DumpData[i] = dumpData[i];

            IoWriteErrorLogEntry(errorLogEntry);
        }

    }

    return status;
}

VOID
KeyboardClassCancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the class cancellation routine.  It is
    called from the I/O system when a request is cancelled.  Read requests
    are currently the only cancellable requests.

    N.B.  The cancel spinlock is already held upon entry to this routine.
          Also, there is no ISR to synchronize with.

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet to be cancelled.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION deviceExtension;
    KIRQL irql;

    deviceExtension = DeviceObject->DeviceExtension;

    //
        //  Release the global cancel spinlock.
    //  Do this while not holding any other spinlocks so that we exit at the
    //  right IRQL.
    //
    IoReleaseCancelSpinLock (Irp->CancelIrql);

    //
    // Dequeue and complete the IRP.  The enqueue and dequeue functions
    // synchronize properly so that if this cancel routine is called,
    // the dequeue is safe and only the cancel routine will complete the IRP.
    //
    KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
        RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
        KeReleaseSpinLock(&deviceExtension->SpinLock, irql);

    //
        // Complete the IRP.  This is a call outside the driver, so all spinlocks
    // must be released by this point.
    //
    Irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    //
    // Remove the lock we took in the read handler
    //
    IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
}

VOID
KeyboardClassCleanupQueue (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PDEVICE_EXTENSION    DeviceExtension,
    IN PFILE_OBJECT         FileObject
    )
/*++
Routine Description:

    This does the work of MouseClassCleanup so that we can also do that work
    during remove device for when the grand master isn't enabled.


--*/
{
    PIRP irp;
    LIST_ENTRY listHead, *entry;
    KIRQL irql;

    InitializeListHead(&listHead);

    KeAcquireSpinLock(&DeviceExtension->SpinLock, &irql);

    do {
        irp = KeyboardClassDequeueReadByFileObject(DeviceExtension, FileObject);
        if (irp) {
            irp->IoStatus.Status = STATUS_CANCELLED;
            irp->IoStatus.Information = 0;

            InsertTailList (&listHead, &irp->Tail.Overlay.ListEntry);
        }
    } while (irp != NULL);

    KeReleaseSpinLock(&DeviceExtension->SpinLock, irql);

    //
    // Complete these irps outside of the spin lock
    //
    while (! IsListEmpty (&listHead)) {
        entry = RemoveHeadList (&listHead);
        irp = CONTAINING_RECORD (entry, IRP, Tail.Overlay.ListEntry);

        IoCompleteRequest (irp, IO_NO_INCREMENT);
        IoReleaseRemoveLock (&DeviceExtension->RemoveLock, irp);
    }
}



NTSTATUS
KeyboardClassCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for cleanup requests.
    All requests queued to the keyboard class device (on behalf of
    the thread for whom the cleanup request was generated) are
    completed with STATUS_CANCELLED.

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PDEVICE_EXTENSION deviceExtension;
    PIO_STACK_LOCATION irpSp;

    KbdPrint((2,"KBDCLASS-KeyboardClassCleanup: enter\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Get a pointer to the current stack location for this request.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // If the file object is the FileTrustedForRead, then the cleanup
    // request is being executed by the trusted subsystem.  Since the
    // trusted subsystem is the only one with sufficient privilege to make
    // Read requests to the driver, and since only Read requests get queued
    // to the device queue, a cleanup request from the trusted subsystem is
    // handled by cancelling all queued requests.
    //
    // If not, there is no cleanup work to perform
    // (only read requests can be cancelled).
    //

    if (IS_TRUSTED_FILE_FOR_READ (irpSp->FileObject)) {
        KeyboardClassCleanupQueue (DeviceObject, deviceExtension, irpSp->FileObject);
    }

    //
    // Complete the cleanup request with STATUS_SUCCESS.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    KbdPrint((2,"KBDCLASS-KeyboardClassCleanup: exit\n"));

    return(STATUS_SUCCESS);

}


NTSTATUS
KeyboardClassDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for device control requests.
    All device control subfunctions are passed, asynchronously, to the
    connected port driver for processing and completion.

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION stack;
    PDEVICE_EXTENSION deviceExtension;
    PDEVICE_EXTENSION port;
    BOOLEAN  loopit = FALSE;
    NTSTATUS status = STATUS_SUCCESS;
    PKEYBOARD_INDICATOR_PARAMETERS param;
    ULONG    unitId;
    ULONG    ioctl;
    ULONG    i;
    PKBD_CALL_ALL_PORTS callAll;

    PAGED_CODE ();

    KbdPrint((2,"KBDCLASS-KeyboardClassDeviceControl: enter\n"));

    //
    // Get a pointer to the device extension.
    //

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    stack = IoGetCurrentIrpStackLocation(Irp);

    status = IoAcquireRemoveLock (&deviceExtension->RemoveLock, Irp);
    if (!NT_SUCCESS (status)) {
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    //
    // Check for adequate input buffer length.  The input buffer
    // should, at a minimum, contain the unit ID specifying one of
    // the connected port devices.  If there is no input buffer (i.e.,
    // the input buffer length is zero), then we assume the unit ID
    // is zero (for backwards compatibility).
    //

    unitId = 0;
    switch (ioctl = stack->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_KEYBOARD_SET_INDICATORS:
        if (stack->Parameters.DeviceIoControl.InputBufferLength <
            sizeof (KEYBOARD_INDICATOR_PARAMETERS)) {

            status = STATUS_BUFFER_TOO_SMALL;
            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            goto KeyboardClassDeviceControlReject;
        }

        deviceExtension->IndicatorParameters
            = *(PKEYBOARD_INDICATOR_PARAMETERS)Irp->AssociatedIrp.SystemBuffer;
        // Fall through
    case IOCTL_KEYBOARD_SET_TYPEMATIC:
        if (Globals.SendOutputToAllPorts) {
            loopit = TRUE;
        }
        // Fall through
    case IOCTL_KEYBOARD_QUERY_ATTRIBUTES:
    case IOCTL_KEYBOARD_QUERY_INDICATOR_TRANSLATION:
    case IOCTL_KEYBOARD_QUERY_INDICATORS:
    case IOCTL_KEYBOARD_QUERY_TYPEMATIC:
    case IOCTL_KEYBOARD_QUERY_IME_STATUS:
    case IOCTL_KEYBOARD_SET_IME_STATUS:

        if (stack->Parameters.DeviceIoControl.InputBufferLength == 0) {
            unitId = 0;
        } else if (stack->Parameters.DeviceIoControl.InputBufferLength <
                      sizeof(KEYBOARD_UNIT_ID_PARAMETER)) {
            status = STATUS_BUFFER_TOO_SMALL;
            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            goto KeyboardClassDeviceControlReject;

        } else {
            unitId = ((PKEYBOARD_UNIT_ID_PARAMETER)
                         Irp->AssociatedIrp.SystemBuffer)->UnitId;
        }

        if (deviceExtension->Self != deviceExtension->TrueClassDevice) {
            status = STATUS_NOT_SUPPORTED;
            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            goto KeyboardClassDeviceControlReject;

        } else if (deviceExtension == Globals.GrandMaster) {
            ExAcquireFastMutex (&Globals.Mutex);
            if (Globals.NumAssocClass <= unitId) {

                ExReleaseFastMutex (&Globals.Mutex);
                status = STATUS_INVALID_PARAMETER;
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                goto KeyboardClassDeviceControlReject;
            }
            if (0 < Globals.NumAssocClass) {
                if (!PORT_WORKING (&Globals.AssocClassList [unitId])) {
                    unitId = 0;
                }
                while (Globals.NumAssocClass > unitId &&
                       !PORT_WORKING (&Globals.AssocClassList [unitId])) {
                    unitId++;
                }
            }
            if (Globals.NumAssocClass <= unitId) {
                ExReleaseFastMutex (&Globals.Mutex);
                status = STATUS_INVALID_PARAMETER;
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                goto KeyboardClassDeviceControlReject;
            }
            port = Globals.AssocClassList [unitId].Port;
            stack->FileObject = Globals.AssocClassList[unitId].File;

            ExReleaseFastMutex (&Globals.Mutex);
        } else {
            loopit = FALSE;
            port = deviceExtension;
        }

        //
        // Pass the device control request on to the port driver,
        // asynchronously.  Get the next IRP stack location and copy the
        // input parameters to the next stack location.  Change the major
        // function to internal device control.
        //

        IoCopyCurrentIrpStackLocationToNext (Irp);
        (IoGetNextIrpStackLocation (Irp))->MajorFunction =
            IRP_MJ_INTERNAL_DEVICE_CONTROL;

        if (loopit) {
            //
            // Inc the lock one more time until this looping is done.
            // Since we are allready holding this semiphore, it should not
            // have triggered on us.
            //
            status = IoAcquireRemoveLock (&deviceExtension->RemoveLock, Irp);
            ASSERT (NT_SUCCESS (status));

            //
            // Prepare to call multiple ports
            // Make a copy of the port array.
            //
            // If someone yanks the keyboard, while the caps lock is
            // going we could be in trouble.
            //
            // We should therefore take out remove locks on each and every
            // port device object so that it won't.
            //

            ExAcquireFastMutex (&Globals.Mutex);
            callAll = ExAllocatePool (NonPagedPool,
                                      sizeof (KBD_CALL_ALL_PORTS) +
                                      (sizeof (PORT) * Globals.NumAssocClass));

            if (callAll) {
                callAll->Len = Globals.NumAssocClass;
                callAll->Current = 0;
                for (i = 0; i < Globals.NumAssocClass; i++) {

                    callAll->Port[i] = Globals.AssocClassList[i];

                    if (PORT_WORKING (&callAll->Port[i])) {
                        status = IoAcquireRemoveLock (
                                     &(callAll->Port[i].Port)->RemoveLock,
                                    Irp);
                        ASSERT (NT_SUCCESS (status));
                    }
                }
                status = KeyboardCallAllPorts (DeviceObject, Irp, callAll);

            } else {
                status = STATUS_INSUFFICIENT_RESOURCES;
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                IoCompleteRequest (Irp, IO_NO_INCREMENT);
            }
            ExReleaseFastMutex (&Globals.Mutex);


        } else {
            status = IoCallDriver(port->TopPort, Irp);
        }
        break;

    case IOCTL_GET_SYS_BUTTON_CAPS:
    case IOCTL_GET_SYS_BUTTON_EVENT:
    case IOCTL_HID_GET_DRIVER_CONFIG:
    case IOCTL_HID_SET_DRIVER_CONFIG:
    case IOCTL_HID_GET_POLL_FREQUENCY_MSEC:
    case IOCTL_HID_SET_POLL_FREQUENCY_MSEC:
    case IOCTL_GET_NUM_DEVICE_INPUT_BUFFERS:
    case IOCTL_SET_NUM_DEVICE_INPUT_BUFFERS:
    case IOCTL_HID_GET_COLLECTION_INFORMATION:
    case IOCTL_HID_GET_COLLECTION_DESCRIPTOR:
    case IOCTL_HID_FLUSH_QUEUE:
    case IOCTL_HID_SET_FEATURE:
    case IOCTL_HID_GET_FEATURE:
    case IOCTL_GET_PHYSICAL_DESCRIPTOR:
    case IOCTL_HID_GET_HARDWARE_ID:
    case IOCTL_HID_GET_MANUFACTURER_STRING:
    case IOCTL_HID_GET_PRODUCT_STRING:
    case IOCTL_HID_GET_SERIALNUMBER_STRING:
    case IOCTL_HID_GET_INDEXED_STRING:
        if (deviceExtension->PnP && (deviceExtension != Globals.GrandMaster)) {
            IoSkipCurrentIrpStackLocation (Irp);
            status = IoCallDriver (deviceExtension->TopPort, Irp);
            break;
        }
    default:
        status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        break;
    }

KeyboardClassDeviceControlReject:

    IoReleaseRemoveLock (&deviceExtension->RemoveLock, Irp);

    KbdPrint((2,"KBDCLASS-KeyboardClassDeviceControl: exit\n"));

    return(status);

}

NTSTATUS
KeyboardCallAllPorts (
   PDEVICE_OBJECT       Device,
   PIRP                 Irp,
   PKBD_CALL_ALL_PORTS  CallAll
   )
/*++
Routine Description:
    Bounce this Irp to all the ports associated with the given device extension.

--*/
{
    PIO_STACK_LOCATION  nextSp;
    NTSTATUS            status;
    PDEVICE_EXTENSION   port;
    BOOLEAN             firstTime;

    firstTime = CallAll->Current == 0;

    ASSERT (Globals.GrandMaster->Self == Device);

    nextSp = IoGetNextIrpStackLocation (Irp);
    IoCopyCurrentIrpStackLocationToNext (Irp);
    nextSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    while ((CallAll->Current < CallAll->Len) &&
           (!PORT_WORKING (&CallAll->Port[CallAll->Current]))) {
        CallAll->Current++;
    }
    if (CallAll->Current < CallAll->Len) {

        port = CallAll->Port [CallAll->Current].Port;
        nextSp->FileObject = CallAll->Port [CallAll->Current].File;

        CallAll->Current++;

        IoSetCompletionRoutine (Irp,
                                &KeyboardCallAllPorts,
                                CallAll,
                                TRUE,
                                TRUE,
                                TRUE);

        status = IoCallDriver (port->TopPort, Irp);
        IoReleaseRemoveLock (&port->RemoveLock, Irp);

    } else {
        //
        // We are done so let this Irp complete normally
        //
        ASSERT (Globals.GrandMaster == Device->DeviceExtension);

        if (Irp->PendingReturned) {
            IoMarkIrpPending (Irp);
        }

        IoReleaseRemoveLock (&Globals.GrandMaster->RemoveLock, Irp);
        ExFreePool (CallAll);
        return STATUS_SUCCESS;
    }

    if (firstTime) {
        //
        // Here we are not completing an IRP but sending it down for the first
        // time.
        //
        return status;
    }

    //
    // Since we bounced the Irp another time we must stop the completion on
    // this particular trip.
    //
    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
KeyboardClassFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for flush requests.  The class
    input data queue is reinitialized.

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpSp;

    KbdPrint((2,"KBDCLASS-KeyboardClassFlush: enter\n"));

    deviceExtension = DeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation(Irp);

    if (deviceExtension->Self != deviceExtension->TrueClassDevice) {
        status = STATUS_NOT_SUPPORTED;

    } else if (!IS_TRUSTED_FILE_FOR_READ (irpSp->FileObject)) {
        status = STATUS_PRIVILEGE_NOT_HELD;
    }

    if (NT_SUCCESS (status)) {
        //
        // Initialize keyboard class input data queue.
        //
        KbdInitializeDataQueue((PVOID)deviceExtension);
    }

    //
    // Complete the request and return status.
    //
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    KbdPrint((2,"KBDCLASS-KeyboardClassFlush: exit\n"));

    return(status);

}

NTSTATUS
KbdSyncComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:
    The pnp IRP is in the process of completing.
    signal

Arguments:
    Context set to the device object in question.

--*/
{
    PIO_STACK_LOCATION  stack;

    UNREFERENCED_PARAMETER (DeviceObject);

    stack = IoGetCurrentIrpStackLocation (Irp);

    //
    // Since this completion routines sole purpose in life is to synchronize
    // Irp, we know that unless something else happens that the IoCallDriver
    // will unwind AFTER the we have complete this Irp.  Therefore we should
    // NOT buble up the pending bit.
    //
    //    if (Irp->PendingReturned) {
    //        IoMarkIrpPending( Irp );
    //    }
    //

    KeSetEvent ((PKEVENT) Context, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
KeyboardSendIrpSynchronously (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN BOOLEAN          CopyToNext
    )
{
    KEVENT      event;
    NTSTATUS    status;

    PAGED_CODE ();

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    if (CopyToNext) {
        IoCopyCurrentIrpStackLocationToNext(Irp);
    }

    IoSetCompletionRoutine(Irp,
                           KbdSyncComplete,
                           &event,
                           TRUE,                // on success
                           TRUE,                // on error
                           TRUE                 // on cancel
                           );

    IoCallDriver(DeviceObject, Irp);

    //
    // Wait for lower drivers to be done with the Irp
    //
    KeWaitForSingleObject(&event,
                         Executive,
                         KernelMode,
                         FALSE,
                         NULL
                         );
    status = Irp->IoStatus.Status;

    return status;
}


NTSTATUS
KeyboardClassCreate (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for create/open and close requests.
    Open/close requests are completed here.

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION   irpSp;
    PDEVICE_EXTENSION    deviceExtension;
    PPORT        port;
    KIRQL        oldIrql;
    NTSTATUS     status = STATUS_SUCCESS;
    ULONG        i;
    LUID         priv;
    KEVENT       event;
    BOOLEAN      someEnableDisableSucceeded = FALSE;
    BOOLEAN      enabled;

    KbdPrint((2,"KBDCLASS-KeyboardClassCreate: enter\n"));

    //
    // Get a pointer to the device extension.
    //

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    ASSERT (IRP_MJ_CREATE == irpSp->MajorFunction);

    //
    // We do not allow user mode opens for read.  This includes services (who
    // have the TCB privilege).
    //
    if (Irp->RequestorMode == UserMode &&
        (irpSp->Parameters.Create.SecurityContext->DesiredAccess & FILE_READ_DATA)
        //@@BEGIN_DDKSPLIT
        && ((irpSp->Parameters.Create.Options & FILE_DIRECTORY_FILE) == 0)
        //@@END_DDKSPLIT
        ) {
        status = STATUS_ACCESS_DENIED;
        goto KeyboardClassCreateEnd;
    }

    status = IoAcquireRemoveLock (&deviceExtension->RemoveLock, Irp);

    if (!NT_SUCCESS (status)) {
        goto KeyboardClassCreateEnd;
    }

    if ((deviceExtension->PnP) && (!deviceExtension->Started)) {
        KbdPrint((
            1,
            "KBDCLASS-Create: failed create because PnP and Not started\n"
             ));

        status = STATUS_UNSUCCESSFUL;
        IoReleaseRemoveLock (&deviceExtension->RemoveLock, Irp);
        goto KeyboardClassCreateEnd;
    }

    //@@BEGIN_DDKSPLIT
    //
    // Clear the FILE_DIRECTORY_FILE bit because the lower bus driver might
    // fail the open if it is set
    //
    irpSp->Parameters.Create.Options &= ~FILE_DIRECTORY_FILE;
    //@@END_DDKSPLIT

    //
    // For the create/open operation, send a KEYBOARD_ENABLE internal
    // device control request to the port driver to enable interrupts.
    //

    if (deviceExtension->Self == deviceExtension->TrueClassDevice) {
        //
        // The real keyboard is being opened.  This either represents the
        // Grand Master, if one exists, or the individual keyboards objects,
        // if all for one is not set.  (IE "KeyboardClassX")
        //
        // First, if the requestor is the trusted subsystem (the single
        // reader), reset the the cleanup indicator and place a pointer
        // to the file object which this class driver uses
        // to determine if the requestor has sufficient
        // privilege to perform the read operation).
        //

        priv = RtlConvertLongToLuid(SE_TCB_PRIVILEGE);

        if (SeSinglePrivilegeCheck(priv, Irp->RequestorMode)) {

            KeAcquireSpinLock(&deviceExtension->SpinLock, &oldIrql);

            ASSERT (!IS_TRUSTED_FILE_FOR_READ (irpSp->FileObject));
            SET_TRUSTED_FILE_FOR_READ (irpSp->FileObject);
            deviceExtension->TrustedSubsystemCount++;

            KeReleaseSpinLock(&deviceExtension->SpinLock, oldIrql);
        }
    }

    //
    // Pass on enables for opens to the true class device
    //
    ExAcquireFastMutex (&Globals.Mutex);
    if ((Globals.GrandMaster == deviceExtension) && (1 == ++Globals.Opens)) {

        for (i = 0; i < Globals.NumAssocClass; i++) {
            port = &Globals.AssocClassList[i];

            if (port->Free) {
                continue;
            }

            enabled = port->Enabled;
            port->Enabled = TRUE;
            ExReleaseFastMutex (&Globals.Mutex);

            if (!enabled) {
                status = KbdEnableDisablePort(TRUE,
                                              Irp,
                                              port->Port,
                                              &port->File);
            }

            if (!NT_SUCCESS(status)) {

                KbdPrint((0,
                          "KBDCLASS-KeyboardClassOpenClose: Could not enable/disable interrupts for port device object @ 0x%x\n",
                          port->Port->TopPort));

                KeyboardClassLogError (DeviceObject,
                                       KBDCLASS_PORT_INTERRUPTS_NOT_ENABLED,
                                       KEYBOARD_ERROR_VALUE_BASE + 120,
                                       status,
                                       0,
                                       NULL,
                                       irpSp->MajorFunction);

                port->Enabled = FALSE;
            }
            else {
                someEnableDisableSucceeded = TRUE;
            }
            ExAcquireFastMutex (&Globals.Mutex);
        }
        ExReleaseFastMutex (&Globals.Mutex);

    } else if (Globals.GrandMaster != deviceExtension) {
        ExReleaseFastMutex (&Globals.Mutex);

        if (deviceExtension->TrueClassDevice == DeviceObject) {
            //
            // An open to the true class Device => enable the one and only port
            //

            status = KbdEnableDisablePort (TRUE,
                                           Irp,
                                           deviceExtension,
                                           &irpSp->FileObject);

        } else {
            //
            // A subordinant FDO.  They are not their own TrueClassDeviceObject.
            // Therefore pass the create straight on through.
            //
            IoSkipCurrentIrpStackLocation (Irp);
            status = IoCallDriver (deviceExtension->TopPort, Irp);
            IoReleaseRemoveLock (&deviceExtension->RemoveLock, Irp);
            return status;
        }

        if (!NT_SUCCESS(status)) {

            KbdPrint((0,
                      "KBDCLASS-KeyboardClassOpenClose: Create failed (0x%x) port device object @ 0x%x\n",
                      status, deviceExtension->TopPort));
#if 0
            //
            // Log an error.
            //
            // Do not log an error for a failed open on a PNP device, esp HID
            // devices which can be easily opened from user mode
            //
            KeyboardClassLogError (DeviceObject,
                                   KBDCLASS_PORT_INTERRUPTS_NOT_ENABLED,
                                   KEYBOARD_ERROR_VALUE_BASE + 120,
                                   status,
                                   0,
                                   NULL,
                                   irpSp->MajorFunction);
#endif
        }
        else {
            someEnableDisableSucceeded = TRUE;
        }
    } else {
        ExReleaseFastMutex (&Globals.Mutex);
    }

    //
    // Complete the request and return status.
    //
    // NOTE: We complete the request successfully if any one of the
    //       connected port devices successfully handled the request.
    //       The RIT only knows about one pointing device.
    //

    if (someEnableDisableSucceeded) {
        status = STATUS_SUCCESS;
    }

    IoReleaseRemoveLock (&deviceExtension->RemoveLock, Irp);

KeyboardClassCreateEnd:
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    KbdPrint((2,"KBDCLASS-KeyboardClassOpenClose: exit\n"));
    return(status);
}

NTSTATUS
KeyboardClassClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for create/open and close requests.
    Open/close requests are completed here.

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION   irpSp;
    PDEVICE_EXTENSION    deviceExtension;
    PPORT        port;
    KIRQL        oldIrql;
    NTSTATUS     status = STATUS_SUCCESS;
    ULONG        i;
    LUID         priv;
    KEVENT       event;
    PFILE_OBJECT file;
    BOOLEAN      someEnableDisableSucceeded = FALSE;
    BOOLEAN      enabled;
    PVOID        notifyHandle;

    KbdPrint((2,"KBDCLASS-KeyboardClassClose: enter\n"));

    //
    // Get a pointer to the device extension.
    //

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Let the close go through even if the device is removed
    // AKA do not call KbdIncIoCount
    //

    //
    // For the create/open operation, send a KEYBOARD_ENABLE internal
    // device control request to the port driver to enable interrupts.
    //

    ASSERT (IRP_MJ_CLOSE == irpSp->MajorFunction);

    if (deviceExtension->Self == deviceExtension->TrueClassDevice) {

        KeAcquireSpinLock(&deviceExtension->SpinLock, &oldIrql);
        if (IS_TRUSTED_FILE_FOR_READ (irpSp->FileObject)) {
            ASSERT(0 < deviceExtension->TrustedSubsystemCount);
            deviceExtension->TrustedSubsystemCount--;
            CLEAR_TRUSTED_FILE_FOR_READ (irpSp->FileObject);
        }
        KeReleaseSpinLock(&deviceExtension->SpinLock, oldIrql);
    }

    //
    // Pass on enables for closes to the true class device
    //
    ExAcquireFastMutex (&Globals.Mutex);
    if ((Globals.GrandMaster == deviceExtension) && (0 == --Globals.Opens)) {

        for (i = 0; i < Globals.NumAssocClass; i++) {
            port = &Globals.AssocClassList[i];

            if (port->Free) {
                continue;
            }

            enabled = port->Enabled;
            port->Enabled = FALSE;
            ExReleaseFastMutex (&Globals.Mutex);

            if (enabled) {
                notifyHandle = InterlockedExchangePointer (
                                    &port->Port->TargetNotifyHandle,
                                    NULL);

                if (NULL != notifyHandle) {
                    IoUnregisterPlugPlayNotification (notifyHandle);
                }
                status = KbdEnableDisablePort(FALSE,
                                              Irp,
                                              port->Port,
                                              &port->File);
            } else {
                ASSERT (NULL == port->Port->TargetNotifyHandle);
            }

            if (!NT_SUCCESS(status)) {

                KbdPrint((0,
                          "KBDCLASS-KeyboardClassOpenClose: Could not enable/disable interrupts for port device object @ 0x%x\n",
                          port->Port->TopPort));

                //
                // Log an error.
                //
                KeyboardClassLogError (DeviceObject,
                                       KBDCLASS_PORT_INTERRUPTS_NOT_DISABLED,
                                       KEYBOARD_ERROR_VALUE_BASE + 120,
                                       status,
                                       0,
                                       NULL,
                                       0);
            }
            else {
                someEnableDisableSucceeded = TRUE;
            }
            ExAcquireFastMutex (&Globals.Mutex);
        }
        ExReleaseFastMutex (&Globals.Mutex);

    } else if (Globals.GrandMaster != deviceExtension) {
        ExReleaseFastMutex (&Globals.Mutex);

        if (deviceExtension->TrueClassDevice == DeviceObject) {
            //
            // A close to the true class Device => disable the one and only port
            //

            status = KbdEnableDisablePort (FALSE,
                                           Irp,
                                           deviceExtension,
                                           &irpSp->FileObject);

        } else {
            IoSkipCurrentIrpStackLocation (Irp);
            status = IoCallDriver (deviceExtension->TopPort, Irp);
            return status;
        }

        if (!NT_SUCCESS(status)) {

            KbdPrint((0,
                      "KBDCLASS-KeyboardClassOpenClose: Could not enable/disable interrupts for port device object @ 0x%x\n",
                      deviceExtension->TopPort));

            //
            // Log an error.
            //
            KeyboardClassLogError (DeviceObject,
                                   KBDCLASS_PORT_INTERRUPTS_NOT_DISABLED,
                                   KEYBOARD_ERROR_VALUE_BASE + 120,
                                   status,
                                   0,
                                   NULL,
                                   irpSp->MajorFunction);
        }
        else {
            someEnableDisableSucceeded = TRUE;
        }
    } else {
        ExReleaseFastMutex (&Globals.Mutex);
    }

    //
    // Complete the request and return status.
    //
    // NOTE: We complete the request successfully if any one of the
    //       connected port devices successfully handled the request.
    //       The RIT only knows about one pointing device.
    //

    if (someEnableDisableSucceeded) {
        status = STATUS_SUCCESS;
    }

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    KbdPrint((2,"KBDCLASS-KeyboardClassOpenClose: exit\n"));
    return(status);
}

NTSTATUS
KeyboardClassReadCopyData(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    )
/*++

Routine Description:
    Copies data as much from the internal queue to the irp as possible.

Assumptions:
    DeviceExtension->SpinLock is already held (so no further synch
    is required).

  --*/
{
    PIO_STACK_LOCATION irpSp;
    PCHAR destination;
    ULONG bytesInQueue;
    ULONG bytesToMove;
    ULONG moveSize;

    //
    // Bump the error log sequence number.
    //
    DeviceExtension->SequenceNumber += 1;

    ASSERT (DeviceExtension->InputCount != 0);

    //
    // Copy as much of the input data as possible from the class input
    // data queue to the SystemBuffer to satisfy the read.  It may be
    // necessary to copy the data in two chunks (i.e., if the circular
    // queue wraps).
    //
    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // BytesToMove <- MIN(Number of filled bytes in class input data queue,
    //                    Requested read length).
    //
    bytesInQueue = DeviceExtension->InputCount *
                       sizeof(KEYBOARD_INPUT_DATA);
    bytesToMove = irpSp->Parameters.Read.Length;

    KbdPrint((
        3,
        "KBDCLASS-KeyboardClassReadCopyData: queue size 0x%lx, read length 0x%lx\n",
        bytesInQueue,
        bytesToMove
        ));

    bytesToMove = (bytesInQueue < bytesToMove) ?
                                  bytesInQueue:bytesToMove;

    //
    // MoveSize <- MIN(Number of bytes to be moved from the class queue,
    //                 Number of bytes to end of class input data queue).
    //
    bytesInQueue = (ULONG)(((PCHAR) DeviceExtension->InputData +
                DeviceExtension->KeyboardAttributes.InputDataQueueLength) -
                (PCHAR) DeviceExtension->DataOut);
    moveSize = (bytesToMove < bytesInQueue) ?
                              bytesToMove:bytesInQueue;

    KbdPrint((
        3,
        "KBDCLASS-KeyboardClassReadCopyData: bytes to end of queue 0x%lx\n",
        bytesInQueue
        ));

    //
    // Move bytes from the class input data queue to SystemBuffer, until
    // the request is satisfied or we wrap the class input data buffer.
    //
    destination = Irp->AssociatedIrp.SystemBuffer;

    KbdPrint((
        3,
        "KBDCLASS-KeyboardClassReadCopyData: number of bytes in first move 0x%lx\n",
        moveSize
        ));
    KbdPrint((
        3,
        "KBDCLASS-KeyboardClassReadCopyData: move bytes from 0x%lx to 0x%lx\n",
        (PCHAR) DeviceExtension->DataOut,
        destination
        ));

    RtlMoveMemory(
        destination,
        (PCHAR) DeviceExtension->DataOut,
        moveSize
        );
    destination += moveSize;

    //
    // If the data wraps in the class input data buffer, copy the rest
    // of the data from the start of the input data queue
    // buffer through the end of the queued data.
    //
    if ((bytesToMove - moveSize) > 0) {
        //
        // MoveSize <- Remaining number bytes to move.
        //
        moveSize = bytesToMove - moveSize;

        //
        // Move the bytes from the class input data queue to SystemBuffer.
        //
        KbdPrint((
            3,
            "KBDCLASS-KeyboardClassReadCopyData: number of bytes in second move 0x%lx\n",
            moveSize
            ));
        KbdPrint((
            3,
            "KBDCLASS-KeyboardClassReadCopyData: move bytes from 0x%lx to 0x%lx\n",
            (PCHAR) DeviceExtension->InputData,
            destination
            ));

        RtlMoveMemory(
            destination,
            (PCHAR) DeviceExtension->InputData,
            moveSize
            );

        //
        // Update the class input data queue removal pointer.
        //
        DeviceExtension->DataOut = (PKEYBOARD_INPUT_DATA)
                         (((PCHAR) DeviceExtension->InputData) + moveSize);
    }
    else {
        //
        // Update the input data queue removal pointer.
        //
        DeviceExtension->DataOut = (PKEYBOARD_INPUT_DATA)
                         (((PCHAR) DeviceExtension->DataOut) + moveSize);
    }

    //
    // Update the class input data queue InputCount.
    //
    DeviceExtension->InputCount -=
        (bytesToMove / sizeof(KEYBOARD_INPUT_DATA));

    if (DeviceExtension->InputCount == 0) {
        //
        // Reset the flag that determines whether it is time to log
        // queue overflow errors.  We don't want to log errors too often.
        // Instead, log an error on the first overflow that occurs after
        // the ring buffer has been emptied, and then stop logging errors
        // until it gets cleared out and overflows again.
        //
        KbdPrint((
            1,
            "KBDCLASS-KeyboardClassCopyReadData: Okay to log overflow\n"
            ));

        DeviceExtension->OkayToLogOverflow = TRUE;
    }

    KbdPrint((
        3,
        "KBDCLASS-KeyboardClassCopyReadData: new DataIn 0x%lx, DataOut 0x%lx\n",
        DeviceExtension->DataIn,
        DeviceExtension->DataOut
        ));
    KbdPrint((
        3,
        "KBDCLASS-KeyboardClassCopyReadData: new InputCount %ld\n",
        DeviceExtension->InputCount
        ));

    //
    // Record how many bytes we have satisfied
    //
    Irp->IoStatus.Information = bytesToMove;
    irpSp->Parameters.Read.Length = bytesToMove;

    return STATUS_SUCCESS;
}

NTSTATUS
KeyboardClassHandleRead(
    PDEVICE_EXTENSION DeviceExtension,
    PIRP Irp
    )
/*++

Routine Description:

    If there is queued data, the Irp will be completed immediately.  If there is
    no data to report, queue the irp.

  --*/
{
    PDRIVER_CANCEL oldCancelRoutine;
    NTSTATUS status = STATUS_PENDING;
    KIRQL irql;
    BOOLEAN completeIrp = FALSE;

    KeAcquireSpinLock(&DeviceExtension->SpinLock, &irql);

    if (DeviceExtension->InputCount == 0) {
        //
        // Easy case to handle, just enqueue the irp
        //
        InsertTailList (&DeviceExtension->ReadQueue, &Irp->Tail.Overlay.ListEntry);
        IoMarkIrpPending (Irp);

        //
        //  Must set a cancel routine before checking the Cancel flag.
        //
        oldCancelRoutine = IoSetCancelRoutine (Irp, KeyboardClassCancel);
        ASSERT (!oldCancelRoutine);

        if (Irp->Cancel) {
            //
                // The IRP was cancelled.  Check whether or not the cancel
            // routine was called.
            //
            oldCancelRoutine = IoSetCancelRoutine (Irp, NULL);
            if (oldCancelRoutine) {
                //
                // The cancel routine was NOT called so dequeue the IRP now and
                // complete it after releasing the spinlock.
                //
                RemoveEntryList (&Irp->Tail.Overlay.ListEntry);
                            status = Irp->IoStatus.Status = STATUS_CANCELLED;
            }
            else {
                //
                    //  The cancel routine WAS called.
                //
                //  As soon as we drop the spinlock it will dequeue and complete
                //  the IRP. So leave the IRP in the queue and otherwise don't
                //  touch it. Return pending since we're not completing the IRP
                //  here.
                //
                ;
            }
        }

        if (status != STATUS_PENDING){
            completeIrp = TRUE;
        }
    }
    else {
        //
        // If we have outstanding input to report, our queue better be empty!
        //
        ASSERT (IsListEmpty (&DeviceExtension->ReadQueue));

        status = KeyboardClassReadCopyData (DeviceExtension, Irp);
        Irp->IoStatus.Status = status;
        completeIrp = TRUE;
    }

    KeReleaseSpinLock (&DeviceExtension->SpinLock, irql);

    if (completeIrp) {
        IoReleaseRemoveLock (&DeviceExtension->RemoveLock, Irp);
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    }

    return status;
}

NTSTATUS
KeyboardClassRead(
    IN PDEVICE_OBJECT Device,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for read requests.  Valid read
    requests are either marked pending if no data has been queued or completed
    immediatedly with available data.

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_EXTENSION  deviceExtension;

    KbdPrint((2,"KBDCLASS-KeyboardClassRead: enter\n"));

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Validate the read request parameters.  The read length should be an
    // integral number of KEYBOARD_INPUT_DATA structures.
    //

    deviceExtension = (PDEVICE_EXTENSION) Device->DeviceExtension;
    if (irpSp->Parameters.Read.Length == 0) {
        status = STATUS_SUCCESS;
    } else if (irpSp->Parameters.Read.Length % sizeof(KEYBOARD_INPUT_DATA)) {
        status = STATUS_BUFFER_TOO_SMALL;
    } else if (deviceExtension->SurpriseRemoved) {
        status = STATUS_DEVICE_NOT_CONNECTED;
    } else if (IS_TRUSTED_FILE_FOR_READ (irpSp->FileObject)) {
        //
        // If the file object's FsContext is non-null, then we've already
        // done the Read privilege check once before for this thread.  Skip
        // the privilege check.
        //

        status = IoAcquireRemoveLock (&deviceExtension->RemoveLock, Irp);

        if (NT_SUCCESS (status)) {
            status = STATUS_PENDING;
        }
    } else {
        //
        // We only allow a trusted subsystem with the appropriate privilege
        // level to execute a Read call.
        //

        status = STATUS_PRIVILEGE_NOT_HELD;
    }

    //
    // If status is pending, mark the packet pending and start the packet
    // in a cancellable state.  Otherwise, complete the request.
    //

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    if (status == STATUS_PENDING) {
        return KeyboardClassHandleRead(deviceExtension, Irp);
    }
    else {
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    KbdPrint((2,"KBDCLASS-KeyboardClassRead: exit\n"));

    return status;
}

PIRP
KeyboardClassDequeueRead(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:
    Dequeues the next available read irp regardless of FileObject

Assumptions:
    DeviceExtension->SpinLock is already held (so no further sync is required).

  --*/
{
    PIRP nextIrp = NULL;
    KIRQL oldIrql;

    while (!nextIrp && !IsListEmpty (&DeviceExtension->ReadQueue)){
        PDRIVER_CANCEL oldCancelRoutine;
        PLIST_ENTRY listEntry = RemoveHeadList (&DeviceExtension->ReadQueue);

        //
        // Get the next IRP off the queue and clear the cancel routine
        //
        nextIrp = CONTAINING_RECORD (listEntry, IRP, Tail.Overlay.ListEntry);
        oldCancelRoutine = IoSetCancelRoutine (nextIrp, NULL);

        //
        // IoCancelIrp() could have just been called on this IRP.
        // What we're interested in is not whether IoCancelIrp() was called
        // (ie, nextIrp->Cancel is set), but whether IoCancelIrp() called (or
        // is about to call) our cancel routine. To check that, check the result
        // of the test-and-set macro IoSetCancelRoutine.
        //
        if (oldCancelRoutine) {
            //
                //  Cancel routine not called for this IRP.  Return this IRP.
            //
                ASSERT (oldCancelRoutine == KeyboardClassCancel);
        }
        else {
            //
                // This IRP was just cancelled and the cancel routine was (or will
            // be) called. The cancel routine will complete this IRP as soon as
            // we drop the spinlock. So don't do anything with the IRP.
            //
                // Also, the cancel routine will try to dequeue the IRP, so make the
            // IRP's listEntry point to itself.
            //
            ASSERT (nextIrp->Cancel);
            InitializeListHead (&nextIrp->Tail.Overlay.ListEntry);
                nextIrp = NULL;
        }
    }

        return nextIrp;
}

PIRP
KeyboardClassDequeueReadByFileObject(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PFILE_OBJECT FileObject
    )
/*++

Routine Description:
    Dequeues the next available read with a matching FileObject

Assumptions:
    DeviceExtension->SpinLock is already held (so no further sync is required).

  --*/
{
    PIRP                irp = NULL;
    PLIST_ENTRY         entry;
    PIO_STACK_LOCATION  stack;
    PDRIVER_CANCEL      oldCancelRoutine;
    KIRQL oldIrql;

    if (FileObject == NULL) {
        return KeyboardClassDequeueRead (DeviceExtension);
    }

    for (entry = DeviceExtension->ReadQueue.Flink;
         entry != &DeviceExtension->ReadQueue;
         entry = entry->Flink) {

        irp = CONTAINING_RECORD (entry, IRP, Tail.Overlay.ListEntry);
        stack = IoGetCurrentIrpStackLocation (irp);
        if (stack->FileObject == FileObject) {
            RemoveEntryList (entry);

            oldCancelRoutine = IoSetCancelRoutine (irp, NULL);

            //
            // IoCancelIrp() could have just been called on this IRP.
            // What we're interested in is not whether IoCancelIrp() was called
            // (ie, nextIrp->Cancel is set), but whether IoCancelIrp() called (or
            // is about to call) our cancel routine. To check that, check the result
            // of the test-and-set macro IoSetCancelRoutine.
            //
            if (oldCancelRoutine) {
                //
                //  Cancel routine not called for this IRP.  Return this IRP.
                //
                return irp;
            }
            else {
                //
                // This IRP was just cancelled and the cancel routine was (or will
                // be) called. The cancel routine will complete this IRP as soon as
                // we drop the spinlock. So don't do anything with the IRP.
                //
                // Also, the cancel routine will try to dequeue the IRP, so make the
                // IRP's listEntry point to itself.
                //
                ASSERT (irp->Cancel);
                InitializeListHead (&irp->Tail.Overlay.ListEntry);
            }
        }
    }

    return NULL;
}

VOID
KeyboardClassServiceCallback(
    IN PDEVICE_OBJECT DeviceObject,
    IN PKEYBOARD_INPUT_DATA InputDataStart,
    IN PKEYBOARD_INPUT_DATA InputDataEnd,
    IN OUT PULONG InputDataConsumed
    )

/*++

Routine Description:

    This routine is the class service callback routine.  It is
    called from the port driver's interrupt service DPC.  If there is an
    outstanding read request, the request is satisfied from the port input
    data queue.  Unsolicited keyboard input is moved from the port input

    data queue to the class input data queue.

    N.B.  This routine is entered at DISPATCH_LEVEL IRQL from the port
          driver's ISR DPC routine.

Arguments:

    DeviceObject - Pointer to class device object.

    InputDataStart - Pointer to the start of the data in the port input
        data queue.

    InputDataEnd - Points one input data structure past the end of the
        valid port input data.

    InputDataConsumed - Pointer to storage in which the number of input
        data structures consumed by this call is returned.

    NOTE:  Could pull the duplicate code out into a called procedure.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION deviceExtension;
    PIO_STACK_LOCATION irpSp;
    LIST_ENTRY listHead;
    PIRP  irp;
    ULONG bytesInQueue;
    ULONG bytesToMove;
    ULONG moveSize;
    ULONG dumpData[2];
    BOOLEAN logOverflow;

    KbdPrint((2,"KBDCLASS-KeyboardClassServiceCallback: enter\n"));

    deviceExtension = DeviceObject->DeviceExtension;
    bytesInQueue = (ULONG)((PCHAR) InputDataEnd - (PCHAR) InputDataStart);
    moveSize = 0;
    *InputDataConsumed = 0;

    logOverflow = FALSE;

    //
    // Notify system that human input has occured
    //

    PoSetSystemState (ES_USER_PRESENT);

    //
    // N.B. We can use KeAcquireSpinLockAtDpcLevel, instead of
    //      KeAcquireSpinLock, because this routine is already running
    //      at DISPATCH_IRQL.
    //

    KeAcquireSpinLockAtDpcLevel (&deviceExtension->SpinLock);

    InitializeListHead (&listHead);
    irp = KeyboardClassDequeueRead (deviceExtension);
    if (irp) {
        //
        // An outstanding read request exists.
        //
        // Copy as much of the input data possible from the port input
        // data queue to the SystemBuffer to satisfy the read.
        //
        irpSp = IoGetCurrentIrpStackLocation (irp);
        bytesToMove = irpSp->Parameters.Read.Length;
        moveSize = (bytesInQueue < bytesToMove) ?
                                   bytesInQueue:bytesToMove;
        *InputDataConsumed += (moveSize / sizeof(KEYBOARD_INPUT_DATA));

        KbdPrint((
            3,
            "KBDCLASS-KeyboardClassServiceCallback: port queue length 0x%lx, read length 0x%lx\n",
            bytesInQueue,
            bytesToMove
            ));
        KbdPrint((
            3,
            "KBDCLASS-KeyboardClassServiceCallback: number of bytes to move from port to SystemBuffer 0x%lx\n",
            moveSize
            ));
        KbdPrint((
            3,
            "KBDCLASS-KeyboardClassServiceCallback: move bytes from 0x%lx to 0x%lx\n",
            (PCHAR) InputDataStart,
            irp->AssociatedIrp.SystemBuffer
            ));

        RtlMoveMemory(
            irp->AssociatedIrp.SystemBuffer,
            (PCHAR) InputDataStart,
            moveSize
            );

        //
        // Set the flag so that we start the next packet and complete
        // this read request (with STATUS_SUCCESS) prior to return.
        //

        irp->IoStatus.Status = STATUS_SUCCESS;
        irp->IoStatus.Information = moveSize;
        irpSp->Parameters.Read.Length = moveSize;

        InsertTailList (&listHead, &irp->Tail.Overlay.ListEntry);
    }

    //
    // If there is still data in the port input data queue, move it to the class
    // input data queue.
    //
    InputDataStart = (PKEYBOARD_INPUT_DATA) ((PCHAR) InputDataStart + moveSize);
    moveSize = bytesInQueue - moveSize;
    KbdPrint((
        3,
        "KBDCLASS-KeyboardClassServiceCallback: bytes remaining after move to SystemBuffer 0x%lx\n",
        moveSize
        ));

    if (moveSize > 0) {

        //
        // Move the remaining data from the port input data queue to
        // the class input data queue.  The move will happen in two
        // parts in the case where the class input data buffer wraps.
        //

        bytesInQueue =
            deviceExtension->KeyboardAttributes.InputDataQueueLength -
            (deviceExtension->InputCount * sizeof(KEYBOARD_INPUT_DATA));
        bytesToMove = moveSize;

        KbdPrint((
            3,
            "KBDCLASS-KeyboardClassServiceCallback: unused bytes in class queue 0x%lx, remaining bytes in port queue 0x%lx\n",
            bytesInQueue,
            bytesToMove
            ));

#if ALLOW_OVERFLOW
#else
        if (bytesInQueue == 0) {

            //
            // Refuse to move any bytes that would cause a class input data
            // queue overflow.  Just drop the bytes on the floor, and
            // log an overrun error.
            //

            KbdPrint((
                1,
                "KBDCLASS-KeyboardClassServiceCallback: Class input data queue OVERRUN\n"
                ));

            if (deviceExtension->OkayToLogOverflow) {
                //
                // Allocate and report the error log entry outside of any locks
                // we are currently holding
                //
                logOverflow = TRUE;
                dumpData[0] = bytesToMove;
                dumpData[1] =
                    deviceExtension->KeyboardAttributes.InputDataQueueLength;

                deviceExtension->OkayToLogOverflow = FALSE;
            }

        } else {
#endif

            //
            // There is room in the class input data queue, so move
            // the remaining port input data to it.
            //
            // BytesToMove <- MIN(Number of unused bytes in class input data
            //                    queue, Number of bytes remaining in port
            //                    input queue).
            // This is the total number of bytes that actually will move from
            // the port input data queue to the class input data queue.
            //

#if ALLOW_OVERFLOW
            bytesInQueue = deviceExtension->KeyboardAttributes.InputDataQueueLength;
#endif
            bytesToMove = (bytesInQueue < bytesToMove) ?
                                          bytesInQueue:bytesToMove;

            //
            // BytesInQueue <- Number of unused bytes from insertion pointer to
            // the end of the class input data queue (i.e., until the buffer
            // wraps).
            //

            bytesInQueue = (ULONG)(((PCHAR) deviceExtension->InputData +
                    deviceExtension->KeyboardAttributes.InputDataQueueLength) -
                    (PCHAR) deviceExtension->DataIn);

            KbdPrint((
                3,
                "KBDCLASS-KeyboardClassServiceCallback: total number of bytes to move to class queue 0x%lx\n",
                bytesToMove
                ));

            KbdPrint((
                3,
                "KBDCLASS-KeyboardClassServiceCallback: number of bytes to end of class buffer 0x%lx\n",
                bytesInQueue
                ));

            //
            // MoveSize <- Number of bytes to handle in the first move.
            //

            moveSize = (bytesToMove < bytesInQueue) ?
                                      bytesToMove:bytesInQueue;
            KbdPrint((
                3,
                "KBDCLASS-KeyboardClassServiceCallback: number of bytes in first move to class 0x%lx\n",
                moveSize
                ));

            //
            // Do the move from the port data queue to the class data queue.
            //

            KbdPrint((
                3,
                "KBDCLASS-KeyboardClassServiceCallback: move bytes from 0x%lx to 0x%lx\n",
                (PCHAR) InputDataStart,
                (PCHAR) deviceExtension->DataIn
                ));

            RtlMoveMemory(
                (PCHAR) deviceExtension->DataIn,
                (PCHAR) InputDataStart,
                moveSize
                );

            //
            // Increment the port data queue pointer and the class input
            // data queue insertion pointer.  Wrap the insertion pointer,
            // if necessary.
            //

            InputDataStart = (PKEYBOARD_INPUT_DATA)
                             (((PCHAR) InputDataStart) + moveSize);
            deviceExtension->DataIn = (PKEYBOARD_INPUT_DATA)
                                 (((PCHAR) deviceExtension->DataIn) + moveSize);
            if ((PCHAR) deviceExtension->DataIn >=
                ((PCHAR) deviceExtension->InputData +
                 deviceExtension->KeyboardAttributes.InputDataQueueLength)) {
                deviceExtension->DataIn = deviceExtension->InputData;
            }

            if ((bytesToMove - moveSize) > 0) {

                //
                // Special case.  The data must wrap in the class input data buffer.
                // Copy the rest of the port input data into the beginning of the
                // class input data queue.
                //

                //
                // MoveSize <- Number of bytes to handle in the second move.
                //

                moveSize = bytesToMove - moveSize;

                //
                // Do the move from the port data queue to the class data queue.
                //

                KbdPrint((
                    3,
                    "KBDCLASS-KeyboardClassServiceCallback: number of bytes in second move to class 0x%lx\n",
                    moveSize
                    ));
                KbdPrint((
                    3,
                    "KBDCLASS-KeyboardClassServiceCallback: move bytes from 0x%lx to 0x%lx\n",
                    (PCHAR) InputDataStart,
                    (PCHAR) deviceExtension->DataIn
                    ));

                RtlMoveMemory(
                    (PCHAR) deviceExtension->DataIn,
                    (PCHAR) InputDataStart,
                    moveSize
                    );

                //
                // Update the class input data queue insertion pointer.
                //

                deviceExtension->DataIn = (PKEYBOARD_INPUT_DATA)
                                 (((PCHAR) deviceExtension->DataIn) + moveSize);
            }

            //
            // Update the input data queue counter.
            //

            deviceExtension->InputCount +=
                    (bytesToMove / sizeof(KEYBOARD_INPUT_DATA));
            *InputDataConsumed += (bytesToMove / sizeof(KEYBOARD_INPUT_DATA));

            KbdPrint((
                3,
                "KBDCLASS-KeyboardClassServiceCallback: changed InputCount to %ld entries in the class queue\n",
                deviceExtension->InputCount
                ));
            KbdPrint((
                3,
                "KBDCLASS-KeyboardClassServiceCallback: DataIn 0x%lx, DataOut 0x%lx\n",
                deviceExtension->DataIn,
                deviceExtension->DataOut
                ));
            KbdPrint((
                3,
                "KBDCLASS-KeyboardClassServiceCallback: Input data items consumed = %d\n",
                *InputDataConsumed
                ));
#if ALLOW_OVERFLOW
#else
        }
#endif

    }

    //
    // If we still have data in our internal queue, fulfill any outstanding
    // reads now until either we run out of data or outstanding reads
    //
    while (deviceExtension->InputCount > 0 &&
           (irp = KeyboardClassDequeueRead (deviceExtension)) != NULL) {
        irp->IoStatus.Status = KeyboardClassReadCopyData (deviceExtension, irp);
        InsertTailList (&listHead, &irp->Tail.Overlay.ListEntry);
    }

    //
    // Release the class input data queue spinlock.
    //
    KeReleaseSpinLockFromDpcLevel (&deviceExtension->SpinLock);

    if (logOverflow) {
        KeyboardClassLogError (DeviceObject,
                               KBDCLASS_KBD_BUFFER_OVERFLOW,
                               KEYBOARD_ERROR_VALUE_BASE + 210,
                               0,
                               2,
                               dumpData,
                               0);
    }

    //
    // Complete all the read requests we have fulfilled outside of the spin lock
    //
    while (! IsListEmpty (&listHead)) {
        PLIST_ENTRY entry = RemoveHeadList (&listHead);

        irp = CONTAINING_RECORD (entry, IRP, Tail.Overlay.ListEntry);
        ASSERT (NT_SUCCESS (irp->IoStatus.Status) &&
                irp->IoStatus.Status != STATUS_PENDING);
        IoCompleteRequest (irp, IO_KEYBOARD_INCREMENT);

        IoReleaseRemoveLock (&deviceExtension->RemoveLock, irp);
    }

    KbdPrint((2,"KBDCLASS-KeyboardClassServiceCallback: exit\n"));
}

VOID
KeyboardClassUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine is the class driver unload routine.

    NOTE:  Not currently implemented.

Arguments:

    DeviceObject - Pointer to class device object.

Return Value:

    None.

--*/

{
    PLIST_ENTRY entry;
    PDEVICE_EXTENSION data;
    PPORT port;
    PIRP irp;

    UNREFERENCED_PARAMETER(DriverObject);

    PAGED_CODE ();

    KbdPrint((2,"KBDCLASS-KeyboardClassUnload: enter\n"));

    //
    // Delete all of our legacy devices
    //
    for (entry = Globals.LegacyDeviceList.Flink;
         entry != &Globals.LegacyDeviceList;
         /* advance to next before deleting the devobj */) {

        BOOLEAN enabled = FALSE;
        PFILE_OBJECT file = NULL;

        data = CONTAINING_RECORD (entry, DEVICE_EXTENSION, Link);
        ASSERT (data->PnP == FALSE);

        if (Globals.GrandMaster) {
            port = &Globals.AssocClassList[data->UnitId];
            ASSERT (port->Port == data);

            enabled = port->Enabled;
            file = port->File;

            port->Enabled = FALSE;
            port->File = NULL;
            port->Free = TRUE;
        }
        else {
            enabled = data->Enabled;
            file = data->File;
            ASSERT (data->File);
            data->Enabled = FALSE;
        }

        if (enabled) {
            irp = IoAllocateIrp(data->TopPort->StackSize+1, FALSE);
            if (irp) {
                KbdEnableDisablePort (FALSE, irp, data, &file);
                IoFreeIrp (irp);
            }
        }

        //
        // This file object represents the open we performed on the legacy
        // port device object.  It does NOT represent the open that the RIT
        // performed on our DO.
        //
        if (file) {
            ObDereferenceObject(file);
        }


        //
        // Clean out the queue only if there is no GM
        //
        if (Globals.GrandMaster == NULL) {
            KeyboardClassCleanupQueue (data->Self, data, NULL);
        }

        RemoveEntryList (&data->Link);
        entry = entry->Flink;

        KeyboardClassDeleteLegacyDevice (data);
    }

    //
    // Delete the grandmaster if it exists
    //
    if (Globals.GrandMaster) {
        data = Globals.GrandMaster;
        Globals.GrandMaster = NULL;

        KeyboardClassCleanupQueue (data->Self, data, NULL);
        KeyboardClassDeleteLegacyDevice (data);
    }

    ExFreePool(Globals.RegistryPath.Buffer);
    if (Globals.AssocClassList) {
#if DBG
        ULONG i;

        for (i = 0; i < Globals.NumAssocClass; i++) {
            ASSERT (Globals.AssocClassList[i].Free == TRUE);
            ASSERT (Globals.AssocClassList[i].Enabled == FALSE);
            ASSERT (Globals.AssocClassList[i].File == NULL);
        }
#endif

        ExFreePool(Globals.AssocClassList);
    }

    KbdPrint((2,"KBDCLASS-KeyboardClassUnload: exit\n"));
}

VOID
KbdConfiguration()

/*++

Routine Description:

    This routine stores the configuration information for this device.

Return Value:

    None.  As a side-effect, sets fields in
    DeviceExtension->KeyboardAttributes.

--*/

{
    PRTL_QUERY_REGISTRY_TABLE parameters = NULL;
    ULONG defaultDataQueueSize = DATA_QUEUE_SIZE;
    ULONG defaultMaximumPortsServiced = 1;
    ULONG defaultConnectMultiplePorts = 1;
    ULONG defaultSendOutputToAllPorts = 0;
    NTSTATUS status = STATUS_SUCCESS;
    UNICODE_STRING parametersPath;
    UNICODE_STRING defaultUnicodeName;
    PWSTR path = NULL;
    USHORT queriesPlusOne = 6;

    PAGED_CODE ();

    parametersPath.Buffer = NULL;

    //
    // Registry path is already null-terminated, so just use it.
    //

    path = Globals.RegistryPath.Buffer;

    //
    // Allocate the Rtl query table.
    //

    parameters = ExAllocatePool(
                     PagedPool,
                     sizeof(RTL_QUERY_REGISTRY_TABLE) * queriesPlusOne
                     );

    if (!parameters) {

        KbdPrint((
            1,
            "KBDCLASS-KbdConfiguration: Couldn't allocate table for Rtl query to parameters for %ws\n",
            path
            ));

        status = STATUS_UNSUCCESSFUL;

    } else {

        RtlZeroMemory(
            parameters,
            sizeof(RTL_QUERY_REGISTRY_TABLE) * queriesPlusOne
            );

        //
        // Form a path to this driver's Parameters subkey.
        //

        RtlInitUnicodeString(
            &parametersPath,
            NULL
            );

        parametersPath.MaximumLength = Globals.RegistryPath.Length +
                                       sizeof(L"\\Parameters");

        parametersPath.Buffer = ExAllocatePool(
                                    PagedPool,
                                    parametersPath.MaximumLength
                                    );

        if (!parametersPath.Buffer) {

            KbdPrint((
                1,
                "KBDCLASS-KbdConfiguration: Couldn't allocate string for path to parameters for %ws\n",
                path
                ));

            status = STATUS_UNSUCCESSFUL;

        }
    }

    if (NT_SUCCESS(status)) {

        //
        // Form the parameters path.
        //

        RtlZeroMemory(parametersPath.Buffer, parametersPath.MaximumLength);
        RtlAppendUnicodeToString(&parametersPath, path);
        RtlAppendUnicodeToString(&parametersPath, L"\\Parameters");

        KbdPrint((
            1,
            "KBDCLASS-KbdConfiguration: parameters path is %ws\n",
             parametersPath.Buffer
            ));

        //
        // Form the default keyboard class device name, in case it is not
        // specified in the registry.
        //

        RtlInitUnicodeString(
            &defaultUnicodeName,
            DD_KEYBOARD_CLASS_BASE_NAME_U
            );

        //
        // Gather all of the "user specified" information from
        // the registry.
        //

        parameters[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[0].Name = L"KeyboardDataQueueSize";
        parameters[0].EntryContext =
            &Globals.InitExtension.KeyboardAttributes.InputDataQueueLength;
        parameters[0].DefaultType = REG_DWORD;
        parameters[0].DefaultData = &defaultDataQueueSize;
        parameters[0].DefaultLength = sizeof(ULONG);

        parameters[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[1].Name = L"MaximumPortsServiced";
        parameters[1].EntryContext = &Globals.PortsServiced;
        parameters[1].DefaultType = REG_DWORD;
        parameters[1].DefaultData = &defaultMaximumPortsServiced;
        parameters[1].DefaultLength = sizeof(ULONG);

        parameters[2].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[2].Name = L"KeyboardDeviceBaseName";
        parameters[2].EntryContext = &Globals.BaseClassName;
        parameters[2].DefaultType = REG_SZ;
        parameters[2].DefaultData = defaultUnicodeName.Buffer;
        parameters[2].DefaultLength = 0;

        //
        // Using this parameter in an inverted fashion, registry key is
        // backwards from global variable.  (Note comment below).
        //
        parameters[3].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[3].Name = L"ConnectMultiplePorts";
        parameters[3].EntryContext = &Globals.ConnectOneClassToOnePort;
        parameters[3].DefaultType = REG_DWORD;
        parameters[3].DefaultData = &defaultConnectMultiplePorts;
        parameters[3].DefaultLength = sizeof(ULONG);

        parameters[4].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[4].Name = L"SendOutputToAllPorts";
        parameters[4].EntryContext =
            &Globals.SendOutputToAllPorts;
        parameters[4].DefaultType = REG_DWORD;
        parameters[4].DefaultData = &defaultSendOutputToAllPorts;
        parameters[4].DefaultLength = sizeof(ULONG);

        status = RtlQueryRegistryValues(
                     RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                     parametersPath.Buffer,
                     parameters,
                     NULL,
                     NULL
                     );

        if (!NT_SUCCESS(status)) {
            KbdPrint((
                1,
                "KBDCLASS-KbdConfiguration: RtlQueryRegistryValues failed with 0x%x\n",
                status
                ));
        }
    }

    if (!NT_SUCCESS(status)) {

        //
        // Go ahead and assign driver defaults.
        //

        Globals.InitExtension.KeyboardAttributes.InputDataQueueLength =
            defaultDataQueueSize;
        Globals.PortsServiced = defaultMaximumPortsServiced;
        Globals.ConnectOneClassToOnePort = defaultConnectMultiplePorts;
        Globals.SendOutputToAllPorts = defaultSendOutputToAllPorts;
        RtlCopyUnicodeString(&Globals.BaseClassName, &defaultUnicodeName);
    }

    KbdPrint((
        1,
        "KBDCLASS-KbdConfiguration: Keyboard class base name = %ws\n",
        Globals.BaseClassName.Buffer
        ));

    if (Globals.InitExtension.KeyboardAttributes.InputDataQueueLength == 0) {

        KbdPrint((
            1,
            "KBDCLASS-KbdConfiguration: overriding KeyboardInputDataQueueLength = 0x%x\n",
            Globals.InitExtension.KeyboardAttributes.InputDataQueueLength
            ));

        Globals.InitExtension.KeyboardAttributes.InputDataQueueLength =
            defaultDataQueueSize;
    }

    Globals.InitExtension.KeyboardAttributes.InputDataQueueLength *=
        sizeof(KEYBOARD_INPUT_DATA);

    KbdPrint((
        1,
        "KBDCLASS-KbdConfiguration: KeyboardInputDataQueueLength = 0x%x\n",
        Globals.InitExtension.KeyboardAttributes.InputDataQueueLength
        ));

    KbdPrint((
        1,
        "KBDCLASS-KbdConfiguration: MaximumPortsServiced = %d\n",
        Globals.PortsServiced
        ));

    //
    // Invert the flag that specifies the type of class/port connections.
    // We used it in the RtlQuery call in an inverted fashion.
    //

    Globals.ConnectOneClassToOnePort = !Globals.ConnectOneClassToOnePort;

    KbdPrint((
        1,
        "KBDCLASS-KbdConfiguration: Connection Type = %d\n",
        Globals.ConnectOneClassToOnePort
        ));

    //
    // Free the allocated memory before returning.
    //

    if (parametersPath.Buffer)
        ExFreePool(parametersPath.Buffer);
    if (parameters)
        ExFreePool(parameters);

}

NTSTATUS
KbdCreateClassObject(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDEVICE_EXTENSION   TmpDeviceExtension,
    OUT PDEVICE_OBJECT    * ClassDeviceObject,
    OUT PWCHAR            * FullDeviceName,
    IN  BOOLEAN             Legacy
    )

/*++

Routine Description:

    This routine creates the keyboard class device object.


Arguments:

    DriverObject - Pointer to driver object created by system.

    TmpDeviceExtension - Pointer to the template device extension.

    FullDeviceName - Pointer to the Unicode string that is the full path name
        for the class device object.

    ClassDeviceObject - Pointer to a pointer to the class device object.

Return Value:

    The function value is the final status from the operation.

--*/

{
    NTSTATUS            status;
    ULONG               uniqueErrorValue;
    PDEVICE_EXTENSION   deviceExtension = NULL;
    NTSTATUS            errorCode = STATUS_SUCCESS;
    UNICODE_STRING      fullClassName = {0,0,0};
    ULONG               dumpCount = 0;
    ULONG               dumpData[DUMP_COUNT];
    ULONG               i;
    WCHAR               nameIndex;

    PAGED_CODE ();

    KbdPrint((1,"\n\nKBDCLASS-KbdCreateClassObject: enter\n"));

    //
    // Create a non-exclusive device object for the keyboard class device.
    //

    ExAcquireFastMutex (&Globals.Mutex);

    //
    // Make sure ClassDeviceObject isn't pointing to a random pointer value
    //
    *ClassDeviceObject = NULL;

    if (NULL == Globals.GrandMaster) {
        //
        // Create a legacy name for this DO.
        //
        ExReleaseFastMutex (&Globals.Mutex);

        //
        // Set up space for the class's full device object name.
        //
        fullClassName.MaximumLength = sizeof(L"\\Device\\") +
                                    + Globals.BaseClassName.Length
                                    + sizeof(L"0");

        if (Globals.ConnectOneClassToOnePort && Legacy) {
            fullClassName.MaximumLength += sizeof(L"Legacy");
        }

        fullClassName.Buffer = ExAllocatePool(PagedPool,
                                              fullClassName.MaximumLength);

        if (!fullClassName.Buffer) {

            KbdPrint((
                1,
                "KbdCLASS-KeyboardClassInitialize: Couldn't allocate string for device object name\n"
                ));

            status = STATUS_UNSUCCESSFUL;
            errorCode = KBDCLASS_INSUFFICIENT_RESOURCES;
            uniqueErrorValue = KEYBOARD_ERROR_VALUE_BASE + 6;
            dumpData[0] = (ULONG) fullClassName.MaximumLength;
            dumpCount = 1;
            goto KbdCreateClassObjectExit;
        }

        RtlZeroMemory(fullClassName.Buffer, fullClassName.MaximumLength);
        RtlAppendUnicodeToString(&fullClassName, L"\\Device\\");
        RtlAppendUnicodeToString(&fullClassName, Globals.BaseClassName.Buffer);

        if (Globals.ConnectOneClassToOnePort && Legacy) {
            RtlAppendUnicodeToString(&fullClassName, L"Legacy");
        }

        RtlAppendUnicodeToString(&fullClassName, L"0");

        //
        // Using the base name start trying to create device names until
        // one succeeds.  Everytime start over at 0 to eliminate gaps.
        //
        nameIndex = 0;

        do {
            fullClassName.Buffer [ (fullClassName.Length / sizeof (WCHAR)) - 1]
                = L'0' + nameIndex++;

            KbdPrint((
                1,
                "KBDCLASS-KbdCreateClassObject: Creating device object named %ws\n",
                fullClassName.Buffer
                ));

            status = IoCreateDevice(DriverObject,
                                    sizeof (DEVICE_EXTENSION),
                                    &fullClassName,
                                    FILE_DEVICE_KEYBOARD,
                                    0,
                                    FALSE,
                                    ClassDeviceObject);

        } while (STATUS_OBJECT_NAME_COLLISION == status);

        *FullDeviceName = fullClassName.Buffer;

    } else {
        ExReleaseFastMutex (&Globals.Mutex);
        status = IoCreateDevice(DriverObject,
                                sizeof(DEVICE_EXTENSION),
                                NULL, // no name for this FDO
                                FILE_DEVICE_KEYBOARD,
                                0,
                                FALSE,
                                ClassDeviceObject);
        *FullDeviceName = NULL;
    }

    if (!NT_SUCCESS(status)) {
        KbdPrint((
            1,
            "KBDCLASS-KbdCreateClassObject: Could not create class device object = %ws\n",
            fullClassName.Buffer
            ));

        errorCode = KBDCLASS_COULD_NOT_CREATE_DEVICE;
        uniqueErrorValue = KEYBOARD_ERROR_VALUE_BASE + 6;
        dumpData[0] = (ULONG) fullClassName.MaximumLength;
        dumpCount = 1;
        goto KbdCreateClassObjectExit;
    }

    //
    // Do buffered I/O.  I.e., the I/O system will copy to/from user data
    // from/to a system buffer.
    //

    (*ClassDeviceObject)->Flags |= DO_BUFFERED_IO;
    deviceExtension =
        (PDEVICE_EXTENSION)(*ClassDeviceObject)->DeviceExtension;
    *deviceExtension = *TmpDeviceExtension;

    deviceExtension->Self = *ClassDeviceObject;
    IoInitializeRemoveLock (&deviceExtension->RemoveLock, KEYBOARD_POOL_TAG, 0, 0);

    //
    // Initialize spin lock for critical sections.
    //
    KeInitializeSpinLock (&deviceExtension->SpinLock);

    //
    // Initialize the read queue
    //
    InitializeListHead (&deviceExtension->ReadQueue);

    //
    // No trusted subsystem has sent us an open yet.
    //

    deviceExtension->TrustedSubsystemCount = 0;

    //
    // Allocate the ring buffer for the keyboard class input data.
    //

    deviceExtension->InputData =
        ExAllocatePool(
            NonPagedPool,
            deviceExtension->KeyboardAttributes.InputDataQueueLength
            );

    if (!deviceExtension->InputData) {

        //
        // Could not allocate memory for the keyboard class data queue.
        //

        KbdPrint((
            1,
            "KBDCLASS-KbdCreateClassObject: Could not allocate input data queue for %ws\n",
            FullDeviceName
            ));

        status = STATUS_INSUFFICIENT_RESOURCES;

        //
        // Log an error.
        //

        errorCode = KBDCLASS_NO_BUFFER_ALLOCATED;
        uniqueErrorValue = KEYBOARD_ERROR_VALUE_BASE + 20;
        goto KbdCreateClassObjectExit;
    }

    //
    // Initialize keyboard class input data queue.
    //

    KbdInitializeDataQueue((PVOID)deviceExtension);

KbdCreateClassObjectExit:

    if (status != STATUS_SUCCESS) {

        //
        // Some part of the initialization failed.  Log an error, and
        // clean up the resources for the failed part of the initialization.
        //
        RtlFreeUnicodeString (&fullClassName);
        *FullDeviceName = NULL;

        if (errorCode != STATUS_SUCCESS) {
            KeyboardClassLogError (
                (*ClassDeviceObject == NULL) ?
                    (PVOID) DriverObject : (PVOID) *ClassDeviceObject,
                errorCode,
                uniqueErrorValue,
                status,
                dumpCount,
                dumpData,
                0);
        }

        if ((deviceExtension) && (deviceExtension->InputData)) {
            ExFreePool (deviceExtension->InputData);
            deviceExtension->InputData = NULL;
        }
        if (*ClassDeviceObject) {
            IoDeleteDevice(*ClassDeviceObject);
            *ClassDeviceObject = NULL;
        }
    }

    KbdPrint((1,"KBDCLASS-KbdCreateClassObject: exit\n"));

    return(status);
}

#if DBG
VOID
KbdDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print routine.

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None.

--*/

{
    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= Globals.Debug) {

        char buffer[256];

        (VOID) vsprintf(buffer, DebugMessage, ap);

        DbgPrint(buffer);
    }

    va_end(ap);

}
#endif

NTSTATUS
KbdDeterminePortsServiced(
    IN PUNICODE_STRING BasePortName,
    IN OUT PULONG NumberPortsServiced
    )

/*++

Routine Description:

    This routine reads the DEVICEMAP portion of the registry to determine
    how many ports the class driver is to service.  Depending on the
    value of DeviceExtension->ConnectOneClassToOnePort, the class driver
    will eventually create one device object per port device serviced, or
    one class device object that connects to multiple port device objects.

    Assumptions:

        1.  If the base device name for the class driver is "KeyboardClass",
                                                                     ^^^^^
            then the port drivers it can service are found under the
            "KeyboardPort" subkey in the DEVICEMAP portion of the registry.
                     ^^^^

        2.  The port device objects are created with suffixes in strictly
            ascending order, starting with suffix 0.  E.g.,
            \Device\KeyboardPort0 indicates the first keyboard port device,
            \Device\KeyboardPort1 the second, and so on.  There are no gaps
            in the list.

        3.  If ConnectOneClassToOnePort is non-zero, there is a 1:1
            correspondence between class device objects and port device
            objects.  I.e., \Device\KeyboardClass0 will connect to
            \Device\KeyboardPort0, \Device\KeyboardClass1 to
            \Device\KeyboardPort1, and so on.

        4.  If ConnectOneClassToOnePort is zero, there is a 1:many
            correspondence between class device objects and port device
            objects.  I.e., \Device\KeyboardClass0 will connect to
            \Device\KeyboardPort0, and \Device\KeyboardPort1, and so on.


    Note that for Product 1, the Raw Input Thread (Windows USER) will
    only deign to open and read from one keyboard device.  Hence, it is
    safe to make simplifying assumptions because the driver is basically
    providing  much more functionality than the RIT will use.

Arguments:

    BasePortName - Pointer to the Unicode string that is the base path name
        for the port device.

    NumberPortsServiced - Pointer to storage that will receive the
        number of ports this class driver should service.

Return Value:

    The function value is the final status from the operation.

--*/

{

    NTSTATUS status;
    PRTL_QUERY_REGISTRY_TABLE registryTable = NULL;
    USHORT queriesPlusOne = 2;

    PAGED_CODE ();

    //
    // Initialize the result.
    //

    *NumberPortsServiced = 0;

    //
    // Allocate the Rtl query table.
    //

    registryTable = ExAllocatePool(
                        PagedPool,
                        sizeof(RTL_QUERY_REGISTRY_TABLE) * queriesPlusOne
                     );

    if (!registryTable) {

        KbdPrint((
            1,
            "KBDCLASS-KbdDeterminePortsServiced: Couldn't allocate table for Rtl query\n"
            ));

        status = STATUS_UNSUCCESSFUL;

    } else {

        RtlZeroMemory(
            registryTable,
            sizeof(RTL_QUERY_REGISTRY_TABLE) * queriesPlusOne
            );

        //
        // Set things up so that KbdDeviceMapQueryCallback will be
        // called once for every value in the keyboard port section
        // of the registry's hardware devicemap.
        //

        registryTable[0].QueryRoutine = KbdDeviceMapQueryCallback;
        registryTable[0].Name = NULL;

        status = RtlQueryRegistryValues(
                     RTL_REGISTRY_DEVICEMAP | RTL_REGISTRY_OPTIONAL,
                     BasePortName->Buffer,
                     registryTable,
                     NumberPortsServiced,
                     NULL
                     );

        if (!NT_SUCCESS(status)) {
            KbdPrint((
                1,
                "KBDCLASS-KbdDeterminePortsServiced: RtlQueryRegistryValues failed with 0x%x\n",
                status
                ));
        }

        ExFreePool(registryTable);
    }

    return(status);
}

NTSTATUS
KbdDeviceMapQueryCallback(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )

/*++

Routine Description:

    This is the callout routine specified in a call to
    RtlQueryRegistryValues.  It increments the value pointed
    to by the Context parameter.

Arguments:

    ValueName - Unused.

    ValueType - Unused.

    ValueData - Unused.

    ValueLength - Unused.

    Context - Pointer to a count of the number of times this
        routine has been called.  This is the number of ports
        the class driver needs to service.

    EntryContext - Unused.

Return Value:

    The function value is the final status from the operation.

--*/

{
    PAGED_CODE ();

    *(PULONG)Context += 1;

    return(STATUS_SUCCESS);
}

NTSTATUS
KbdEnableDisablePort(
    IN BOOLEAN EnableFlag,
    IN PIRP    Irp,
    IN PDEVICE_EXTENSION Port,
    IN PFILE_OBJECT * File
    )

/*++

Routine Description:

    This routine sends an enable or a disable request to the port driver.
    The legacy port drivers require an enable or disable ioctl, while the
    plug and play drivers require merely a create.

Arguments:

    DeviceObject - Pointer to class device object.

    EnableFlag - If TRUE, send an ENABLE request; otherwise, send DISABLE.

    PortIndex - Index into the PortDeviceObjectList[] for the current
        enable/disable request.

Return Value:

    Status is returned.

--*/

{
    IO_STATUS_BLOCK ioStatus;
    UNICODE_STRING  name = {0,0,0};
    PDEVICE_OBJECT  device = NULL;
    NTSTATUS    status = STATUS_SUCCESS;
    PWCHAR      buffer = NULL;
    ULONG       bufferLength = 0;
    PIO_STACK_LOCATION stack;

    PAGED_CODE ();

    KbdPrint((2,"KBDCLASS-KbdEnableDisablePort: enter\n"));

    //
    // Create notification event object to be used to signal the
    // request completion.
    //

    if ((Port->TrueClassDevice == Port->Self) && (Port->PnP)) {

        IoCopyCurrentIrpStackLocationToNext (Irp);
        stack = IoGetNextIrpStackLocation (Irp);

        if (EnableFlag) {
            //
            // Since there is no grand master there could not have been a
            // create file against the FDO before it was started.  Therefore
            // the only time we would enable is during a create and not a
            // start as we might with another FDO attached to an already open
            // grand master.
            //
            ASSERT (IRP_MJ_CREATE == stack->MajorFunction);

        } else {
            if (IRP_MJ_CLOSE != stack->MajorFunction) {
                //
                // We are disabling.  This could be because the device was
                // closed, or because the device was removed out from
                // underneath us.
                //
                ASSERT (IRP_MJ_PNP == stack->MajorFunction);
                ASSERT ((IRP_MN_REMOVE_DEVICE == stack->MinorFunction) ||
                        (IRP_MN_STOP_DEVICE == stack->MinorFunction));
                stack->MajorFunction = IRP_MJ_CLOSE;
            }
        }

        //
        // Either way we need only pass the Irp down without mucking with the
        // file object.
        //
        status = KeyboardSendIrpSynchronously (Port->TopPort, Irp, FALSE);

    } else if (!Port->PnP) {
        Port->Enabled = EnableFlag;

        //
        // We have here an old style Port Object.  Therefore we send it the
        // old style internal IOCTLs of ENABLE and DISABLE, and not the new
        // style of passing on a create and close.
        //
        IoCopyCurrentIrpStackLocationToNext (Irp);
        stack = IoGetNextIrpStackLocation (Irp);

        stack->Parameters.DeviceIoControl.OutputBufferLength = 0;
        stack->Parameters.DeviceIoControl.InputBufferLength = 0;
        stack->Parameters.DeviceIoControl.IoControlCode
            = EnableFlag ? IOCTL_INTERNAL_KEYBOARD_ENABLE
                         : IOCTL_INTERNAL_KEYBOARD_DISABLE;
        stack->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
        stack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

        status = KeyboardSendIrpSynchronously (Port->TopPort, Irp, FALSE);

    } else {
        //
        // We are dealing with a plug and play port and we have a Grand
        // Master.
        //
        ASSERT (Port->TrueClassDevice == Globals.GrandMaster->Self);

        //
        // Therefore we need to substitute the given file object for a new
        // one for use with each individual ports.
        // For enable, we need to create this file object against the given
        // port and then hand it back in the File parameter, or for disable,
        // deref the File parameter and free that file object.
        //
        // Of course, there must be storage for a file pointer pointed to by
        // the File parameter.
        //
        ASSERT (NULL != File);

        if (EnableFlag) {

            ASSERT (NULL == *File);

            //
            // The following long list of rigamaroll translates into
            // sending the lower driver a create file IRP and creating a
            // NEW file object disjoint from the one given us in our create
            // file routine.
            //
            // Normally we would just pass down the Create IRP we were
            // given, but since we do not have a one to one correspondance of
            // top device objects and port device objects.
            // This means we need more file objects: one for each of the
            // miriad of lower DOs.
            //

            bufferLength = 0;
            status = IoGetDeviceProperty (
                             Port->PDO,
                             DevicePropertyPhysicalDeviceObjectName,
                             bufferLength,
                             buffer,
                             &bufferLength);
            ASSERT (STATUS_BUFFER_TOO_SMALL == status);

            buffer = ExAllocatePool (PagedPool, bufferLength);

            if (NULL == buffer) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            status =  IoGetDeviceProperty (
                          Port->PDO,
                          DevicePropertyPhysicalDeviceObjectName,
                          bufferLength,
                          buffer,
                          &bufferLength);

            name.MaximumLength = (USHORT) bufferLength;
            name.Length = (USHORT) bufferLength - sizeof (UNICODE_NULL);
            name.Buffer = buffer;

            status = IoGetDeviceObjectPointer (&name,
                                               FILE_ALL_ACCESS,
                                               File,
                                               &device);
            ExFreePool (buffer);
            //
            // Note, that this create will first go to ourselves since we
            // are attached to this PDO stack.  Therefore two things are
            // noteworthy.  This driver will receive another Create IRP
            // (with a different file object) (not to the grand master but
            // to one of the subordenant FDO's).  The device object returned
            // will be the subordenant FDO, which in this case is the "self"
            // device object of this Port.
            //
            if (NT_SUCCESS (status)) {
                PVOID   tmpBuffer;

                ASSERT (device == Port->Self);

                if (NULL != Irp) {
                    //
                    // Set the indicators for this port device object.
                    // NB: The Grandmaster's device extension is initialized to
                    // zero, and the flags for indicator lights are flags, so
                    // this means that unless the RIUT has set the flags that
                    // IndicatorParameters will have no lights set.
                    //

                    IoCopyCurrentIrpStackLocationToNext (Irp);
                    stack = IoGetNextIrpStackLocation (Irp);

                    stack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
                    stack->Parameters.DeviceIoControl.OutputBufferLength = 0;
                    stack->Parameters.DeviceIoControl.InputBufferLength =
                        sizeof (KEYBOARD_INDICATOR_PARAMETERS);
                    stack->Parameters.DeviceIoControl.IoControlCode =
                        IOCTL_KEYBOARD_SET_INDICATORS;
                    stack->FileObject = *File;

                    tmpBuffer = Irp->AssociatedIrp.SystemBuffer;

                    Irp->AssociatedIrp.SystemBuffer =
                        & Globals.GrandMaster->IndicatorParameters;

                    status = KeyboardSendIrpSynchronously (Port->TopPort, Irp, FALSE);

                    Irp->AssociatedIrp.SystemBuffer = tmpBuffer;
                }

                //
                // Register for Target device removal events
                //
                ASSERT (NULL == Port->TargetNotifyHandle);
                status = IoRegisterPlugPlayNotification (
                             EventCategoryTargetDeviceChange,
                             0, // No flags
                             *File,
                             Port->Self->DriverObject,
                             KeyboardClassPlugPlayNotification,
                             Port,
                             &Port->TargetNotifyHandle);
            }

        } else {
            //
            // Getting rid of the handle is easy.  Just deref the file.
            //
            ObDereferenceObject (*File);
            *File = NULL;
        }

    }
    KbdPrint((2,"KBDCLASS-KbdEnableDisablePort: exit\n"));

    return (status);
}

VOID
KbdInitializeDataQueue (
    IN PVOID Context
    )

/*++

Routine Description:

    This routine initializes the input data queue.  IRQL is raised to
    DISPATCH_LEVEL to synchronize with StartIo, and the device object
    spinlock is acquired.

Arguments:

    Context - Supplies a pointer to the device extension.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;
    PDEVICE_EXTENSION deviceExtension;

    KbdPrint((3,"KBDCLASS-KbdInitializeDataQueue: enter\n"));

    //
    // Get address of device extension.
    //

    deviceExtension = (PDEVICE_EXTENSION)Context;

    //
    // Acquire the spinlock to protect the input data
    // queue and associated pointers.
    //

    KeAcquireSpinLock(&deviceExtension->SpinLock, &oldIrql);

    //
    // Initialize the input data queue.
    //

    deviceExtension->InputCount = 0;
    deviceExtension->DataIn = deviceExtension->InputData;
    deviceExtension->DataOut = deviceExtension->InputData;

    deviceExtension->OkayToLogOverflow = TRUE;

    //
    // Release the spinlock and lower IRQL.
    //

    KeReleaseSpinLock(&deviceExtension->SpinLock, oldIrql);

    KbdPrint((3,"KBDCLASS-KbdInitializeDataQueue: exit\n"));

}

NTSTATUS
KbdSendConnectRequest(
    IN PDEVICE_EXTENSION ClassData,
    IN PVOID ServiceCallback
    )

/*++

Routine Description:

    This routine sends a connect request to the port driver.

Arguments:

    DeviceObject - Pointer to class device object.

    ServiceCallback - Pointer to the class service callback routine.

    PortIndex - The index into the PortDeviceObjectList[] for the current
        connect request.

Return Value:

    Status is returned.

--*/

{
    PIRP irp;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS status;
    KEVENT event;
    CONNECT_DATA connectData;

    PAGED_CODE ();

    KbdPrint((2,"KBDCLASS-KbdSendConnectRequest: enter\n"));

    //
    // Create notification event object to be used to signal the
    // request completion.
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // Build the synchronous request to be sent to the port driver
    // to perform the request.  Allocate an IRP to issue the port internal
    // device control connect call.  The connect parameters are passed in
    // the input buffer, and the keyboard attributes are copied back
    // from the port driver directly into the class device extension.
    //

    connectData.ClassDeviceObject = ClassData->TrueClassDevice;
    connectData.ClassService = ServiceCallback;

    irp = IoBuildDeviceIoControlRequest(
            IOCTL_INTERNAL_KEYBOARD_CONNECT,
            ClassData->TopPort,
            &connectData,
            sizeof(CONNECT_DATA),
            NULL,
            0,
            TRUE,
            &event,
            &ioStatus
            );

    //
    // Call the port driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //

    status = IoCallDriver(ClassData->TopPort, irp);

    if (status == STATUS_PENDING) {
        (VOID) KeWaitForSingleObject(
                   &event,
                   Executive,
                   KernelMode,
                   FALSE,
                   NULL
                   );

        status = irp->IoStatus.Status;
    } else {

        //
        // Ensure that the proper status value gets picked up.
        //

        ioStatus.Status = status;
    }

    KbdPrint((2,"KBDCLASS-KbdSendConnectRequest: exit\n"));

    return(ioStatus.Status);

} // end KbdSendConnectRequest()

void
KeyboardClassRemoveDevice(
    IN PDEVICE_EXTENSION Data
    )
{
    PFILE_OBJECT *  file;
    PPORT           port;
    PIRP            waitWakeIrp;
    PVOID           notifyHandle;
    BOOLEAN         enabled;

    //
    // If this is a surprise remove or we got a remove w/out a surprise remove,
    // then we need to clean up
    //
    waitWakeIrp = (PIRP)
        InterlockedExchangePointer(&Data->WaitWakeIrp, NULL);

    if (waitWakeIrp) {
        IoCancelIrp(waitWakeIrp);
    }

    IoWMIRegistrationControl (Data->Self, WMIREG_ACTION_DEREGISTER);

    if (Data->Started) {
        //
        // Stop the device without touching the hardware.
        // MouStopDevice(Data, FALSE);
        //
        // NB sending down the enable disable does NOT touch the hardware
        // it instead sends down a close file.
        //
        ExAcquireFastMutex (&Globals.Mutex);
        if (Globals.GrandMaster) {
            if (0 < Globals.Opens) {
                port = &Globals.AssocClassList[Data->UnitId];
                ASSERT (port->Port == Data);
                file = &(port->File);
                enabled = port->Enabled;
                port->Enabled = FALSE;
                ExReleaseFastMutex (&Globals.Mutex);

                //
                // ASSERT (NULL == Data->notifyHandle);
                //
                // If we have a grand master, that means we did the
                // creation locally and registered for notification.
                // we should have closed the file during
                // TARGET_DEVICE_QUERY_REMOVE, but we will have not
                // gotten rid of the notify handle.
                //
                // Of course if we receive a surprise removal then
                // we should not have received the query cancel.
                // In which case we should have received a
                // TARGET_DEVICE_REMOVE_COMPLETE where we would have
                // both closed the file and removed cleared the
                // notify handle
                //
                // Either way the file should be closed by now.
                //
                ASSERT (!enabled);
                // if (enabled) {
                //     status = MouEnableDisablePort (FALSE, Irp, Data, file);
                //     ASSERTMSG ("Could not close open port", NT_SUCCESS(status));
                // }

                notifyHandle = InterlockedExchangePointer (
                                   &Data->TargetNotifyHandle,
                                   NULL);

                if (NULL != notifyHandle) {
                    IoUnregisterPlugPlayNotification (notifyHandle);
                }
            }
            else {
                ASSERT (!Globals.AssocClassList[Data->UnitId].Enabled);
                ExReleaseFastMutex (&Globals.Mutex);
            }
        }
        else {
            ExReleaseFastMutex (&Globals.Mutex);
            ASSERT (Data->TrueClassDevice == Data->Self);
            ASSERT (Globals.ConnectOneClassToOnePort);

            if (!Data->SurpriseRemoved) {
                //
                // If add device fails, then the buffer will be NULL
                //
                if (Data->SymbolicLinkName.Buffer != NULL) {
                    IoSetDeviceInterfaceState (&Data->SymbolicLinkName, FALSE);
                }
            }

        }
    }

    //
    // Always drain the queue, no matter if we have received both a surprise
    // remove and a remove
    //
    if (Data->PnP) {
        //
        // Empty the device I/O Queue
        //
        KeyboardClassCleanupQueue (Data->Self, Data, NULL);
    }
}

NTSTATUS
KeyboardPnP (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    The plug and play dispatch routines.

    Most of these this filter driver will completely ignore.
    In all cases it must pass on the IRP to the lower driver.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PDEVICE_EXTENSION   data;
    PDEVICE_EXTENSION   trueClassData;
    PIO_STACK_LOCATION  stack;
    NTSTATUS            status, startStatus;
    ULONG               i;
    PFILE_OBJECT      * file;
    UINT_PTR            startInformation;
    DEVICE_CAPABILITIES devCaps;
    BOOLEAN             enabled;
    PPORT               port;
    PVOID               notifyHandle;
    KIRQL               oldIrql;
    KIRQL               cancelIrql;

    data = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation (Irp);

    if(!data->PnP) {
        //
        // This irp was sent to the control device object, which knows not
        // how to deal with this IRP.  It is therefore an error.
        //
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return STATUS_NOT_SUPPORTED;

    }

    status = IoAcquireRemoveLock (&data->RemoveLock, Irp);
    if (!NT_SUCCESS (status)) {
        //
        // Someone gave us a pnp irp after a remove.  Unthinkable!
        //
        ASSERT (FALSE);
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    trueClassData = (PDEVICE_EXTENSION) data->TrueClassDevice->DeviceExtension;
    switch (stack->MinorFunction) {
    case IRP_MN_START_DEVICE:

        //
        // The device is starting.
        //
        // We cannot touch the device (send it any non pnp irps) until a
        // start device has been passed down to the lower drivers.
        //
        status = KeyboardSendIrpSynchronously (data->TopPort, Irp, TRUE);

        if (NT_SUCCESS (status) && NT_SUCCESS (Irp->IoStatus.Status)) {
            //
            // As we are successfully now back from our start device
            // we can do work.
            //
            // Get the caps of the device.  Save off pertinent information
            // before mucking about w/the irp
            //
            startStatus = Irp->IoStatus.Status;
            startInformation = Irp->IoStatus.Information;

            Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
            Irp->IoStatus.Information = 0;

            RtlZeroMemory(&devCaps, sizeof (DEVICE_CAPABILITIES));
            devCaps.Size = sizeof (DEVICE_CAPABILITIES);
            devCaps.Version = 1;
            devCaps.Address = devCaps.UINumber = (ULONG)-1;

            stack = IoGetNextIrpStackLocation (Irp);
            stack->MinorFunction = IRP_MN_QUERY_CAPABILITIES;
            stack->Parameters.DeviceCapabilities.Capabilities = &devCaps;

            status = KeyboardSendIrpSynchronously (data->TopPort, Irp, FALSE);

            if (NT_SUCCESS (status) && NT_SUCCESS (Irp->IoStatus.Status)) {
                data->MinDeviceWakeState = devCaps.DeviceWake;
                data->MinSystemWakeState = devCaps.SystemWake;

                RtlCopyMemory (data->SystemToDeviceState,
                               devCaps.DeviceState,
                               sizeof(DEVICE_POWER_STATE) * PowerSystemHibernate);
            } else {
                ASSERTMSG ("Get Device caps Failed!\n", status);
            }

            //
            // Set everything back to the way it was and continue with the start
            //
            status = STATUS_SUCCESS;
            Irp->IoStatus.Status = startStatus;
            Irp->IoStatus.Information = startInformation;

            data->Started = TRUE;

            if (WAITWAKE_SUPPORTED (data)) {
                //
                // register for the wait wake guid as well
                //
                data->WmiLibInfo.GuidCount = sizeof (KeyboardClassWmiGuidList) /
                                             sizeof (WMIGUIDREGINFO);
                ASSERT (2 == data->WmiLibInfo.GuidCount);

                //
                // See if the user has enabled wait wake for the device
                //
                KeyboardClassGetWaitWakeEnableState (data);
            }
            else {
                data->WmiLibInfo.GuidCount = (sizeof (KeyboardClassWmiGuidList) /
                                              sizeof (WMIGUIDREGINFO)) - 1;
                ASSERT (1 == data->WmiLibInfo.GuidCount);
            }
            data->WmiLibInfo.GuidList = KeyboardClassWmiGuidList;
            data->WmiLibInfo.QueryWmiRegInfo = KeyboardClassQueryWmiRegInfo;
            data->WmiLibInfo.QueryWmiDataBlock = KeyboardClassQueryWmiDataBlock;
            data->WmiLibInfo.SetWmiDataBlock = KeyboardClassSetWmiDataBlock;
            data->WmiLibInfo.SetWmiDataItem = KeyboardClassSetWmiDataItem;
            data->WmiLibInfo.ExecuteWmiMethod = NULL;
            data->WmiLibInfo.WmiFunctionControl = NULL;

            IoWMIRegistrationControl(data->Self,
                                     WMIREG_ACTION_REGISTER
                                     );

            ExAcquireFastMutex (&Globals.Mutex);
            if (Globals.GrandMaster) {
                if (0 < Globals.Opens) {
                    port = &Globals.AssocClassList[data->UnitId];
                    ASSERT (port->Port == data);
                    file = &port->File;
                    enabled = port->Enabled;
                    port->Enabled = TRUE;
                    ExReleaseFastMutex (&Globals.Mutex);

                    if (!enabled) {
                        status = KbdEnableDisablePort (TRUE, Irp, data, file);
                        if (!NT_SUCCESS (status)) {
                            port->Enabled = FALSE;
                            // ASSERT (Globals.AssocClassList[data->UnitId].Enabled);
                        } else {
                            //
                            // This is not the first kb to start, make sure its
                            // lights are set according to the indicators on the
                            // other kbs
                            //
                            PVOID startBuffer;

                            stack = IoGetNextIrpStackLocation (Irp);
                            stack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
                            stack->Parameters.DeviceIoControl.IoControlCode =
                                IOCTL_KEYBOARD_SET_INDICATORS;

                            stack->FileObject = *file;
                            stack->Parameters.DeviceIoControl.OutputBufferLength = 0;
                            stack->Parameters.DeviceIoControl.InputBufferLength =
                                sizeof (KEYBOARD_INDICATOR_PARAMETERS);

                            startStatus = Irp->IoStatus.Status;
                            startInformation = Irp->IoStatus.Information;
                            startBuffer = Irp->AssociatedIrp.SystemBuffer;

                            Irp->IoStatus.Information = 0;
                            Irp->AssociatedIrp.SystemBuffer =
                                &Globals.GrandMaster->IndicatorParameters;

                            status =
                                KeyboardSendIrpSynchronously (data->TopPort,
                                                              Irp,
                                                              FALSE);

                            //
                            // We don't care if we succeeded or not...
                            // set everything back to the way it was and
                            // continue with the start
                            //
                            status = STATUS_SUCCESS;
                            Irp->IoStatus.Status = startStatus;
                            Irp->IoStatus.Information = startInformation;
                            Irp->AssociatedIrp.SystemBuffer = startBuffer;
                        }
                    }
                } else {
                    ASSERT (!Globals.AssocClassList[data->UnitId].Enabled);
                    ExReleaseFastMutex (&Globals.Mutex);
                }
            } else {
                ExReleaseFastMutex (&Globals.Mutex);
                ASSERT (data->Self == data->TrueClassDevice);
                status=IoSetDeviceInterfaceState(&data->SymbolicLinkName, TRUE);
            }

            //
            // Start up the Wait Wake Engine if required.
            //
            if (SHOULD_SEND_WAITWAKE (data)) {
                KeyboardClassCreateWaitWakeIrp (data);
            }
        }

        //
        // We must now complete the IRP, since we stopped it in the
        // completetion routine with MORE_PROCESSING_REQUIRED.
        //
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        break;

    case IRP_MN_STOP_DEVICE:
        //
        // After the start IRP has been sent to the lower driver object, the
        // bus may NOT send any more IRPS down ``touch'' until another START
        // has occured.
        // What ever access is required must be done before the Irp is passed
        // on.
        //

        //
        // Do what ever
        //

        //
        // Stop Device touching the hardware KbdStopDevice(data, TRUE);
        //
        if (data->Started) {
            ExAcquireFastMutex (&Globals.Mutex);
            if (Globals.GrandMaster) {
                if (0 < Globals.Opens) {
                    port = &Globals.AssocClassList[data->UnitId];
                    ASSERT (port->Port == data);
                    file = &(port->File);
                    enabled = port->Enabled;
                    port->Enabled = FALSE;
                    ExReleaseFastMutex (&Globals.Mutex);

                    if (enabled) {
                        notifyHandle = InterlockedExchangePointer (
                                           &data->TargetNotifyHandle,
                                           NULL);

                        if (NULL != notifyHandle) {
                            IoUnregisterPlugPlayNotification (notifyHandle);
                        }

                        status = KbdEnableDisablePort (FALSE, Irp, data, file);
                        ASSERTMSG ("Could not close open port", NT_SUCCESS(status));
                    } else {
                        ASSERT (NULL == data->TargetNotifyHandle);
                    }
                } else {
                    ASSERT (!Globals.AssocClassList[data->UnitId].Enabled);
                    ExReleaseFastMutex (&Globals.Mutex);
                }
            } else {
                ExReleaseFastMutex (&Globals.Mutex);
            }
        }

        data->Started = FALSE;

        //
        // We don't need a completion routine so fire and forget.
        //
        // Set the current stack location to the next stack location and
        // call the next device object.
        //
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (data->TopPort, Irp);
        break;

    case IRP_MN_SURPRISE_REMOVAL:
        //
        // The PlugPlay system has dictacted the removal of this device.
        //
        data->SurpriseRemoved = TRUE;

        //
        // If add device fails, then the buffer will be NULL
        //
        if (data->SymbolicLinkName.Buffer != NULL) {
            IoSetDeviceInterfaceState (&data->SymbolicLinkName, FALSE);
        }

        //
        // We don't need a completion routine so fire and forget.
        //
        // Set the current stack location to the next stack location and
        // call the next device object.
        //
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (data->TopPort, Irp);
        break;

    case IRP_MN_REMOVE_DEVICE:
        //
        // The PlugPlay system has dictacted the removal of this device.  We
        // have no choise but to detach and delete the device objecct.
        // (If we wanted to express and interest in preventing this removal,
        // we should have filtered the query remove and query stop routines.)
        //
        KeyboardClassRemoveDevice (data);

        //
        // Here if we had any outstanding requests in a personal queue we should
        // complete them all now.
        //
        // Note, the device is guarenteed stopped, so we cannot send it any non-
        // PNP IRPS.
        //

        //
        // Send on the remove IRP
        //
        IoCopyCurrentIrpStackLocationToNext (Irp);
        status = IoCallDriver (data->TopPort, Irp);

        ExAcquireFastMutex (&Globals.Mutex);
        if (Globals.GrandMaster) {
            ASSERT (Globals.GrandMaster->Self == data->TrueClassDevice);
            //
            // We must remove ourself from the Assoc List
            //

            if (1 < Globals.NumAssocClass) {
                ASSERT (Globals.AssocClassList[data->UnitId].Port == data);

                Globals.AssocClassList[data->UnitId].Free = TRUE;
                Globals.AssocClassList[data->UnitId].File = NULL;
                Globals.AssocClassList[data->UnitId].Port = NULL;

            } else {
                ASSERT (1 == Globals.NumAssocClass);
                Globals.NumAssocClass = 0;
                ExFreePool (Globals.AssocClassList);
                Globals.AssocClassList = NULL;
            }
            ExReleaseFastMutex (&Globals.Mutex);

        } else {
            //
            // We are removing the one and only port associated with this class
            // device object.
            //
            ExReleaseFastMutex (&Globals.Mutex);
            ASSERT (data->TrueClassDevice == data->Self);
            ASSERT (Globals.ConnectOneClassToOnePort);
        }

        IoReleaseRemoveLockAndWait (&data->RemoveLock, Irp);

        IoDetachDevice (data->TopPort);

        //
        // Clean up memory
        //
        RtlFreeUnicodeString (&data->SymbolicLinkName);
        ExFreePool (data->InputData);
        IoDeleteDevice (data->Self);

        return status;

    case IRP_MN_QUERY_PNP_DEVICE_STATE:

        //
        // Set the not disableable bit on the way down so that the stack below
        // has a chance to clear it
        //
        if (data->AllowDisable == FALSE) {

            (PNP_DEVICE_STATE) Irp->IoStatus.Information |=
                PNP_DEVICE_NOT_DISABLEABLE;

            Irp->IoStatus.Status = STATUS_SUCCESS;

            //
            // drop through to the default case
            //              ||  ||
            //              \/  \/
            //
        }

    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_CANCEL_REMOVE_DEVICE:
    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_CANCEL_STOP_DEVICE:
    case IRP_MN_QUERY_DEVICE_RELATIONS:
    case IRP_MN_QUERY_INTERFACE:
    case IRP_MN_QUERY_CAPABILITIES:
    case IRP_MN_QUERY_RESOURCES:
    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
    case IRP_MN_READ_CONFIG:
    case IRP_MN_WRITE_CONFIG:
    case IRP_MN_EJECT:
    case IRP_MN_SET_LOCK:
    case IRP_MN_QUERY_ID:
    default:
        //
        // Here the filter driver might modify the behavior of these IRPS
        // Please see PlugPlay documentation for use of these IRPs.
        //

        IoCopyCurrentIrpStackLocationToNext (Irp);
        status = IoCallDriver (data->TopPort, Irp);
        break;
    }

    IoReleaseRemoveLock (&data->RemoveLock, Irp);

    return status;
}

VOID
KeyboardClassLogError(
    PVOID Object,
    ULONG ErrorCode,
    ULONG UniqueErrorValue,
    NTSTATUS FinalStatus,
    ULONG DumpCount,
    ULONG *DumpData,
    UCHAR MajorFunction
    )
{
    PIO_ERROR_LOG_PACKET errorLogEntry;
    ULONG i;

    errorLogEntry = (PIO_ERROR_LOG_PACKET)
        IoAllocateErrorLogEntry(
            Object,
            (UCHAR) (sizeof(IO_ERROR_LOG_PACKET) + (DumpCount * sizeof(ULONG)))
            );

    if (errorLogEntry != NULL) {

        errorLogEntry->ErrorCode = ErrorCode;
        errorLogEntry->DumpDataSize = (USHORT) (DumpCount * sizeof(ULONG));
        errorLogEntry->SequenceNumber = 0;
        errorLogEntry->MajorFunctionCode = MajorFunction;
        errorLogEntry->IoControlCode = 0;
        errorLogEntry->RetryCount = 0;
        errorLogEntry->UniqueErrorValue = UniqueErrorValue;
        errorLogEntry->FinalStatus = FinalStatus;
        for (i = 0; i < DumpCount; i++)
            errorLogEntry->DumpData[i] = DumpData[i];

        IoWriteErrorLogEntry(errorLogEntry);
    }
}

VOID
KeyboardClassFindMorePorts (
    PDRIVER_OBJECT  DriverObject,
    PVOID           Context,
    ULONG           Count
    )
/*++

Routine Description:

    This routine is called from
    serviced by the boot device drivers and then called again by the
    IO system to find disk devices serviced by nonboot device drivers.

Arguments:

    DriverObject
    Context -
    Count - Used to determine if this is the first or second time called.

Return Value:

    None

--*/

{
    NTSTATUS                status;
    PDEVICE_EXTENSION       deviceExtension = NULL;
    PDEVICE_OBJECT          classDeviceObject = NULL;
    ULONG                   dumpData[DUMP_COUNT];
    ULONG                   i;
    ULONG                   numPorts;
    ULONG                   successfulCreates;
    UNICODE_STRING          basePortName;
    UNICODE_STRING          fullPortName;
    WCHAR                   basePortBuffer[NAME_MAX];
    PWCHAR                  fullClassName = NULL;
    PFILE_OBJECT            file;

    PAGED_CODE ();

    fullPortName.MaximumLength = 0;

    RtlZeroMemory(basePortBuffer, NAME_MAX * sizeof(WCHAR));
    basePortName.Buffer = basePortBuffer;
    basePortName.Length = 0;
    basePortName.MaximumLength = NAME_MAX * sizeof(WCHAR);

    //
    // Set up the base device name for the associated port device.
    // It is the same as the base class name, with "Class" replaced
    // by "Port".
    //
    RtlCopyUnicodeString(&basePortName, &Globals.BaseClassName);
    basePortName.Length -= (sizeof(L"Class") - sizeof(UNICODE_NULL));
    RtlAppendUnicodeToString(&basePortName, L"Port");

    //
    // Set up space for the full device object name for the ports.
    //
    RtlInitUnicodeString(&fullPortName, NULL);

    fullPortName.MaximumLength = sizeof(L"\\Device\\")
                               + basePortName.Length
                               + sizeof (UNICODE_NULL);

    fullPortName.Buffer = ExAllocatePool(PagedPool,
                                         fullPortName.MaximumLength);

    if (!fullPortName.Buffer) {

        KbdPrint((
            1,
            "KBDCLASS-KeyboardClassInitialize: Couldn't allocate string for port device object name\n"
            ));

        dumpData[0] = (ULONG) fullPortName.MaximumLength;
        KeyboardClassLogError (DriverObject,
                               KBDCLASS_INSUFFICIENT_RESOURCES,
                               KEYBOARD_ERROR_VALUE_BASE + 8,
                               STATUS_UNSUCCESSFUL,
                               1,
                               dumpData,
                               0);

        goto KeyboardFindMorePortsExit;

    }

    RtlZeroMemory(fullPortName.Buffer, fullPortName.MaximumLength);
    RtlAppendUnicodeToString(&fullPortName, L"\\Device\\");
    RtlAppendUnicodeToString(&fullPortName, basePortName.Buffer);
    RtlAppendUnicodeToString(&fullPortName, L"0");

    KbdDeterminePortsServiced(&basePortName, &numPorts);

    //
    // Set up the class device object(s) to handle the associated
    // port devices.
    //

    for (i = Globals.NumberLegacyPorts, successfulCreates = 0;
         ((i < Globals.PortsServiced) && (i < numPorts));
         i++) {

        //
        // Append the suffix to the device object name string.  E.g., turn
        // \Device\PointerClass into \Device\PointerClass0.  Then attempt
        // to create the device object.  If the device object already
        // exists increment the suffix and try again.
        //

        fullPortName.Buffer[(fullPortName.Length / sizeof(WCHAR)) - 1]
            = L'0' + (WCHAR) i;

        //
        // Create the class device object.
        //
        status = KbdCreateClassObject (DriverObject,
                                       &Globals.InitExtension,
                                       &classDeviceObject,
                                       &fullClassName,
                                       TRUE);

        if (!NT_SUCCESS(status)) {
            KeyboardClassLogError (DriverObject,
                                   KBDCLASS_INSUFFICIENT_RESOURCES,
                                   KEYBOARD_ERROR_VALUE_BASE + 8,
                                   status,
                                   0,
                                   NULL,
                                   0);
            continue;
        }

        deviceExtension = (PDEVICE_EXTENSION)classDeviceObject->DeviceExtension;
        deviceExtension->PnP = FALSE;

        //
        // Connect to the port device.
        //
        status = IoGetDeviceObjectPointer (&fullPortName,
                                           FILE_READ_ATTRIBUTES,
                                           &file,
                                           &deviceExtension->TopPort);

        if (status != STATUS_SUCCESS) {
            // ISSUE: log error
            KeyboardClassDeleteLegacyDevice (deviceExtension);
            continue;
        }

        classDeviceObject->StackSize = 1 + deviceExtension->TopPort->StackSize;
        status = KeyboardAddDeviceEx (deviceExtension, fullClassName, file);
        classDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

        if (fullClassName) {
            ExFreePool (fullClassName);
            fullClassName = NULL;
        }

        if (!NT_SUCCESS (status)) {
            if (Globals.GrandMaster == NULL) {
                if (deviceExtension->File) {
                    file = deviceExtension->File;
                    deviceExtension->File = NULL;
                }
            }
            else {
                PPORT port;

                ExAcquireFastMutex (&Globals.Mutex);

                file = Globals.AssocClassList[deviceExtension->UnitId].File;
                Globals.AssocClassList[deviceExtension->UnitId].File = NULL;
                Globals.AssocClassList[deviceExtension->UnitId].Free = TRUE;
                Globals.AssocClassList[deviceExtension->UnitId].Port = NULL;

                ExReleaseFastMutex (&Globals.Mutex);
            }

            if (file) {
                ObDereferenceObject (file);
            }

            KeyboardClassDeleteLegacyDevice (deviceExtension);
            continue;
        }

        //
        // We want to only add it to our list if everything went alright
        //
        InsertTailList (&Globals.LegacyDeviceList, &deviceExtension->Link);
        successfulCreates++;
    } // for
    Globals.NumberLegacyPorts = i;

KeyboardFindMorePortsExit:

    //
    // Free the unicode strings.
    //

    if (fullPortName.MaximumLength != 0) {
        ExFreePool(fullPortName.Buffer);
    }

    if (fullClassName) {
        ExFreePool (fullClassName);
    }
}

NTSTATUS
KeyboardClassEnableGlobalPort(
    IN PDEVICE_EXTENSION Port,
    IN BOOLEAN Enabled
    )
{
    NTSTATUS    status = STATUS_SUCCESS;
    PPORT       globalPort = NULL;
    BOOLEAN     enabled, testVal;
    ULONG       i;

    PAGED_CODE ();

    ExAcquireFastMutex (&Globals.Mutex);
    if (0 < Globals.Opens) {
        for (i = 0; i < Globals.NumAssocClass; i++) {
            if (! Globals.AssocClassList [i].Free) {
                if (Globals.AssocClassList[i].Port == Port) {
                    globalPort = &Globals.AssocClassList [i];
                    break;
                }
            }
        }
        ASSERTMSG ("What shall I do now?\n", (NULL != globalPort));

        //
        // This should never happen, globalPort should be in our list
        //
        if (globalPort == NULL) {
            ExReleaseFastMutex (&Globals.Mutex);
            return STATUS_NO_SUCH_DEVICE;
        }

        enabled = globalPort->Enabled;
        globalPort->Enabled = Enabled;
        ExReleaseFastMutex (&Globals.Mutex);

        //
        // Check to see if the port should change state. If so, send the new state
        // down the stack
        //
        if (Enabled != enabled) {
            status = KbdEnableDisablePort (Enabled,
                                           NULL,
                                           Port,
                                           &globalPort->File);
        }
    } else {
        ExReleaseFastMutex (&Globals.Mutex);
    }

    return status;
}

NTSTATUS
KeyboardClassPlugPlayNotification(
    IN PTARGET_DEVICE_REMOVAL_NOTIFICATION NotificationStructure,
    IN PDEVICE_EXTENSION Port
    )
/*++

Routine Description:

    This routine is called as the result of recieving PlugPlay Notifications
    as registered by the previous call to IoRegisterPlugPlayNotification.

    Currently this should only occur for Target Device Notifications

Arguments:

    NotificationStructure - what happened.
    Port - The Fdo to which things happened.

Return Value:



--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    PVOID       notify = NULL;

    PAGED_CODE ();

    ASSERT (Globals.GrandMaster->Self == Port->TrueClassDevice);

    if (IsEqualGUID ((LPGUID) &(NotificationStructure->Event),
                     (LPGUID) &GUID_TARGET_DEVICE_QUERY_REMOVE)) {

        //
        // Our port device object will soon be receiving a query remove.
        // Before that query remove will actually be sent to the device object
        // stack itself the plug and play subsystem will send those registered
        // for target device notification the message first.
        //

        //
        // What we should do is now close the handle.
        // Because if we do not the query remove will fail before it ever
        // gets to the IRP_MJ_PNP IRP_MN_QUERY_REMOVE stage, as the PlugPlay
        // system fails before it is sent based on there being an open handle
        // to the device.
        //
        // DbgPrint ("Keyboard QUERY Remove\n");
        // DbgBreakPoint();

        status = KeyboardClassEnableGlobalPort (Port, FALSE);

    } else if(IsEqualGUID ((LPGUID)&(NotificationStructure->Event),
                           (LPGUID)&GUID_TARGET_DEVICE_REMOVE_COMPLETE)) {

        //
        // Here the device has disappeared.
        //
        // DbgPrint ("Keyboard Remove Complete\n");
        // DbgBreakPoint();

        notify = InterlockedExchangePointer (&Port->TargetNotifyHandle,
                                             NULL);

        if (NULL != notify) {
            //
            // Deregister
            //
            IoUnregisterPlugPlayNotification (notify);

            status = KeyboardClassEnableGlobalPort (Port, FALSE);
        }

    } else if(IsEqualGUID ((LPGUID)&(NotificationStructure->Event),
                           (LPGUID)&GUID_TARGET_DEVICE_REMOVE_CANCELLED)) {

        //
        // The query remove has been revoked.
        // Reopen the device.
        //
        // DbgPrint ("Keyboard Remove Complete\n");
        // DbgBreakPoint();

        notify = InterlockedExchangePointer (&Port->TargetNotifyHandle,
                                             NULL);

        if (NULL != notify) {
            //
            // Deregister
            //
            IoUnregisterPlugPlayNotification (notify);

            //
            // If the notify handle is no longer around then this device must
            // have been removed, so there is no point trying to create again.
            //
            status = KeyboardClassEnableGlobalPort (Port, TRUE);
        }
    }

    return status;
}

VOID
KeyboardClassPoRequestComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
KeyboardClassPowerComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
KeyboardClassWWPowerUpComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:
    Catch the Wait wake Irp on its way back.

Return Value:

--*/
{
    PDEVICE_EXTENSION       data = Context;
    POWER_STATE             powerState;
    NTSTATUS                status;
    PKEYBOARD_WORK_ITEM_DATA    itemData;

    ASSERT (MinorFunction == IRP_MN_SET_POWER);

    if (data->WaitWakeEnabled) {
        //
        // We cannot call CreateWaitWake from this completion routine,
        // as it is a paged function.
        //
        itemData = (PKEYBOARD_WORK_ITEM_DATA)
                ExAllocatePool (NonPagedPool, sizeof (KEYBOARD_WORK_ITEM_DATA));

        if (NULL != itemData) {
            itemData->Item = IoAllocateWorkItem(data->Self);
            if (itemData->Item == NULL) {
                ExFreePool(itemData);
                goto CreateWaitWakeWorkerError;
            }

            itemData->Data = data;
            itemData->Irp = NULL;
            status = IoAcquireRemoveLock (&data->RemoveLock, itemData);
            if (NT_SUCCESS(status)) {
                IoQueueWorkItem (itemData->Item,
                                 KeyboardClassCreateWaitWakeIrpWorker,
                                 DelayedWorkQueue,
                                 itemData);
            }
            else {
                //
                // The device has been removed
                //
                IoFreeWorkItem (itemData->Item);
                ExFreePool (itemData);
            }
        } else {
CreateWaitWakeWorkerError:
            //
            // Well, we dropped the WaitWake.
            //
            // Print a warning to the debugger, and log an error.
            //
            DbgPrint ("KbdClass: WARNING: Failed alloc pool -> no WW Irp\n");

            KeyboardClassLogError (data->Self,
                                   KBDCLASS_NO_RESOURCES_FOR_WAITWAKE,
                                   2,
                                   STATUS_INSUFFICIENT_RESOURCES,
                                   0,
                                   NULL,
                                   0);
        }
    }
}

VOID
KeyboardClassWaitWakeComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:
    Catch the Wait wake Irp on its way back.

Return Value:

--*/
{
    PDEVICE_EXTENSION       data = Context;
    POWER_STATE             powerState;
    NTSTATUS                status;
    PKEYBOARD_WORK_ITEM_DATA    itemData;

    ASSERT (MinorFunction == IRP_MN_WAIT_WAKE);
    //
    // PowerState.SystemState is undefined when the WW irp has been completed
    //
    // ASSERT (PowerState.SystemState == PowerSystemWorking);

    if (InterlockedExchangePointer(&data->ExtraWaitWakeIrp, NULL)) {
        ASSERT(IoStatus->Status == STATUS_INVALID_DEVICE_STATE);
    } else {
        InterlockedExchangePointer(&data->WaitWakeIrp, NULL);
    }

    switch (IoStatus->Status) {
    case STATUS_SUCCESS:
        KbdPrint((1, "KbdClass: Wake irp was completed succeSSfully.\n"));

        //
        //      We need to request a set power to power up the device.
        //
        powerState.DeviceState = PowerDeviceD0;
        status = PoRequestPowerIrp(
                    data->PDO,
                    IRP_MN_SET_POWER,
                    powerState,
                    KeyboardClassWWPowerUpComplete,
                    Context,
                    NULL);

        //
        // We do not notify the system that a user is present because:
        // 1  Win9x doesn't do this and we must maintain compatibility with it
        // 2  The USB PIX4 motherboards sends a wait wake event every time the
        //    machine wakes up, no matter if this device woke the machine or not
        //
        // If we incorrectly notify the system a user is present, the following
        // will occur:
        // 1  The monitor will be turned on
        // 2  We will prevent the machine from transitioning from standby
        //    (to PowerSystemWorking) to hibernate
        //
        // If a user is truly present, we will receive input in the service
        // callback and we will notify the system at that time.
        //
        // PoSetSystemState (ES_USER_PRESENT);

        // fall through to the break

    //
    // We get a remove.  We will not (obviously) send another wait wake
    //
    case STATUS_CANCELLED:

    //
    // This status code will be returned if the device is put into a power state
    // in which we cannot wake the machine (hibernate is a good example).  When
    // the device power state is returned to D0, we will attempt to rearm wait wake
    //
    case STATUS_POWER_STATE_INVALID:
    case STATUS_ACPI_POWER_REQUEST_FAILED:

    //
    // We failed the Irp because we already had one queued, or a lower driver in
    // the stack failed it.  Either way, don't do anything.
    //
    case STATUS_INVALID_DEVICE_STATE:

    //
    // Somehow someway we got two WWs down to the lower stack.
    // Let's just don't worry about it.
    //
    case STATUS_DEVICE_BUSY:
        break;

    default:
        //
        // Something went wrong, disable the wait wake.
        //
        KdPrint(("KBDCLASS:  wait wake irp failed with %x\n", IoStatus->Status));
        KeyboardToggleWaitWake (data, FALSE);
    }

}

BOOLEAN
KeyboardClassCheckWaitWakeEnabled(
    IN PDEVICE_EXTENSION Data
    )
{
    KIRQL irql;
    BOOLEAN enabled;

    KeAcquireSpinLock (&Data->WaitWakeSpinLock, &irql);
    enabled = Data->WaitWakeEnabled;
    KeReleaseSpinLock (&Data->WaitWakeSpinLock, irql);

    return enabled;
}

void
KeyboardClassCreateWaitWakeIrpWorker (
    IN PDEVICE_OBJECT DeviceObject,
    IN PKEYBOARD_WORK_ITEM_DATA  ItemData
    )
{
    PAGED_CODE ();

    KeyboardClassCreateWaitWakeIrp (ItemData->Data);
    IoReleaseRemoveLock (&ItemData->Data->RemoveLock, ItemData);
    IoFreeWorkItem(ItemData->Item);
    ExFreePool (ItemData);
}

BOOLEAN
KeyboardClassCreateWaitWakeIrp (
    IN PDEVICE_EXTENSION Data
    )
/*++

Routine Description:
    Catch the Wait wake Irp on its way back.

Return Value:

--*/
{
    POWER_STATE powerState;
    BOOLEAN     success = TRUE;
    NTSTATUS    status;
    PIRP        waitWakeIrp;

    PAGED_CODE ();

    powerState.SystemState = Data->MinSystemWakeState;
    status = PoRequestPowerIrp (Data->PDO,
                                IRP_MN_WAIT_WAKE,
                                powerState,
                                KeyboardClassWaitWakeComplete,
                                Data,
                                NULL);

    if (status != STATUS_PENDING) {
        success = FALSE;
    }

    return success;
}

VOID
KeyboardToggleWaitWakeWorker(
    IN PDEVICE_OBJECT DeviceObject,
    PKEYBOARD_WORK_ITEM_DATA ItemData
    )
/*++

Routine Description:

--*/
{
    PDEVICE_EXTENSION   data;
    PIRP                waitWakeIrp = NULL;
    KIRQL               irql;
    BOOLEAN             wwState = ItemData->WaitWakeState ? TRUE : FALSE;
    BOOLEAN             toggled = FALSE;

    //
    // Can't be paged b/c we are using spin locks
    //
    // PAGED_CODE ();

    data = ItemData->Data;

    KeAcquireSpinLock (&data->WaitWakeSpinLock, &irql);

    if (wwState != data->WaitWakeEnabled) {
        toggled = TRUE;
        if (data->WaitWakeEnabled) {
            waitWakeIrp = (PIRP)
                InterlockedExchangePointer (&data->WaitWakeIrp, NULL);
        }

        data->WaitWakeEnabled = wwState;
    }

    KeReleaseSpinLock (&data->WaitWakeSpinLock, irql);

    if (toggled) {
        UNICODE_STRING strEnable;
        HANDLE         devInstRegKey;
        ULONG          tmp = wwState;

        //
        // write the value out to the registry
        //
        if ((NT_SUCCESS(IoOpenDeviceRegistryKey (data->PDO,
                                                 PLUGPLAY_REGKEY_DEVICE,
                                                 STANDARD_RIGHTS_ALL,
                                                 &devInstRegKey)))) {
            RtlInitUnicodeString (&strEnable, KEYBOARD_WAIT_WAKE_ENABLE);

            ZwSetValueKey (devInstRegKey,
                           &strEnable,
                           0,
                           REG_DWORD,
                           &tmp,
                           sizeof(tmp));

            ZwClose (devInstRegKey);
        }
    }

    if (toggled && wwState) {
        //
        // wwState is our new state, so WW was just turned on
        //
        KeyboardClassCreateWaitWakeIrp (data);
    }

    //
    // If we have an IRP, then WW has been toggled off, otherwise, if toggled is
    // TRUE, we need to save this in the reg and, perhaps, send down a new WW irp
    //
    if (waitWakeIrp) {
        IoCancelIrp (waitWakeIrp);
    }

    IoReleaseRemoveLock (&data->RemoveLock, KeyboardToggleWaitWakeWorker);
    IoFreeWorkItem (ItemData->Item);
    ExFreePool (ItemData);
}

NTSTATUS
KeyboardToggleWaitWake(
    PDEVICE_EXTENSION Data,
    BOOLEAN           WaitWakeState
    )
{
    NTSTATUS       status;
    PKEYBOARD_WORK_ITEM_DATA itemData;

    status = IoAcquireRemoveLock (&Data->RemoveLock, KeyboardToggleWaitWakeWorker);
    if (!NT_SUCCESS (status)) {
        //
        // Device has gone away, just silently exit
        //
        return status;
    }

    itemData = (PKEYBOARD_WORK_ITEM_DATA)
        ExAllocatePool(NonPagedPool, sizeof(KEYBOARD_WORK_ITEM_DATA));
    if (itemData) {
        itemData->Item = IoAllocateWorkItem(Data->Self);
        if (itemData->Item == NULL) {
            IoReleaseRemoveLock (&Data->RemoveLock, KeyboardToggleWaitWakeWorker);
        }
        else {
            itemData->Data = Data;
            itemData->WaitWakeState = WaitWakeState;

            if (KeGetCurrentIrql() == PASSIVE_LEVEL) {
                //
                // We are safely at PASSIVE_LEVEL, call callback directly to perform
                // this operation immediately.
                //
                KeyboardToggleWaitWakeWorker (Data->Self, itemData);

            } else {
                //
                // We are not at PASSIVE_LEVEL, so queue a workitem to handle this
                // at a later time.
                //
                IoQueueWorkItem (itemData->Item,
                                 KeyboardToggleWaitWakeWorker,
                                 DelayedWorkQueue,
                                 itemData);
            }
        }
    }
    else {
        IoReleaseRemoveLock (&Data->RemoveLock, KeyboardToggleWaitWakeWorker);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
KeyboardClassPower (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    The power dispatch routine.

    In all cases it must call PoStartNextPowerIrp
    In all cases (except failure) it must pass on the IRP to the lower driver.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    POWER_STATE_TYPE        powerType;
    PIO_STACK_LOCATION      stack;
    PDEVICE_EXTENSION       data;
    NTSTATUS        status;
    POWER_STATE     powerState;
    BOOLEAN         hookit = FALSE;
    BOOLEAN         pendit = FALSE;

    PAGED_CODE ();

    data = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation (Irp);
    powerType = stack->Parameters.Power.Type;
    powerState = stack->Parameters.Power.State;

    if (data == Globals.GrandMaster) {
        //
        // We should never get a power irp to the grand master.
        //
        ASSERT (data != Globals.GrandMaster);
        PoStartNextPowerIrp (Irp);
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return STATUS_NOT_SUPPORTED;

    } else if (!data->PnP) {
        //
        // We should never get a power irp to a non PnP device object.
        //
        ASSERT (data->PnP);
        PoStartNextPowerIrp (Irp);
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return STATUS_NOT_SUPPORTED;
    }

    status = IoAcquireRemoveLock (&data->RemoveLock, Irp);

    if (!NT_SUCCESS (status)) {
        PoStartNextPowerIrp (Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    switch (stack->MinorFunction) {
    case IRP_MN_SET_POWER:
        KbdPrint((2,"KBDCLASS-PnP Setting %s state to %d\n",
                  ((powerType == SystemPowerState) ?  "System" : "Device"),
                  powerState.SystemState));

        switch (powerType) {
        case DevicePowerState:
            status = Irp->IoStatus.Status = STATUS_SUCCESS;
            if (data->DeviceState < powerState.DeviceState) {
                //
                // Powering down
                //
                PoSetPowerState (data->Self, powerType, powerState);
                data->DeviceState = powerState.DeviceState;
            }
            else if (powerState.DeviceState < data->DeviceState) {
                //
                // Powering Up
                //
                hookit = TRUE;
            } // else { no change }.
            break;

        case SystemPowerState:

            if (data->SystemState < powerState.SystemState) {
                //
                // Powering down
                //
                status = IoAcquireRemoveLock (&data->RemoveLock, Irp);
                if (!NT_SUCCESS(status)) {
                    //
                    // This should never happen b/c we successfully acquired
                    // the lock already, but we must handle this case
                    //
                    // The S irp will completed with the value in status
                    //
                    break;
                }

                if (WAITWAKE_ON (data) &&
                    powerState.SystemState < PowerSystemHibernate) {
                    ASSERT (powerState.SystemState >= PowerSystemWorking &&
                            powerState.SystemState < PowerSystemHibernate);

                    powerState.DeviceState =
                        data->SystemToDeviceState[powerState.SystemState];
                }
                else {
                    powerState.DeviceState = PowerDeviceD3;
                }

                IoMarkIrpPending(Irp);
                status  = PoRequestPowerIrp (data->Self,
                                             IRP_MN_SET_POWER,
                                             powerState,
                                             KeyboardClassPoRequestComplete,
                                             Irp,
                                             NULL);

                if (!NT_SUCCESS(status)) {
                    //
                    // Failure...release the inner reference we just took
                    //
                    IoReleaseRemoveLock (&data->RemoveLock, Irp);

                    //
                    // Propagate the failure back to the S irp
                    //
                    PoStartNextPowerIrp (Irp);
                    Irp->IoStatus.Status = status;
                    IoCompleteRequest(Irp, IO_NO_INCREMENT);

                    //
                    // Release the outer reference (top of the function)
                    //
                    IoReleaseRemoveLock (&data->RemoveLock, Irp);

                    //
                    // Must return status pending b/c we marked the irp pending
                    // so we special case the return here and avoid overly
                    // complex processing at the end of the function.
                    //
                    return STATUS_PENDING;
                }
                else {
                    pendit = TRUE;
                }
            }
            else if (powerState.SystemState < data->SystemState) {
                //
                // Powering Up
                //
                hookit = TRUE;
                status = Irp->IoStatus.Status = STATUS_SUCCESS;
            }
            else {
                //
                // No change, but we want to make sure a wait wake irp is sent.
                //
                if (powerState.SystemState == PowerSystemWorking &&
                    SHOULD_SEND_WAITWAKE (data)) {
                    KeyboardClassCreateWaitWakeIrp (data);
                }
                status = Irp->IoStatus.Status = STATUS_SUCCESS;
            }
            break;
        }

        break;

    case IRP_MN_QUERY_POWER:
        ASSERT (SystemPowerState == powerType);

        //
        // Fail the query if we can't wake the machine.  We do, however, want to
        // let hibernate succeed no matter what (besides, it is doubtful that a
        // keyboard can wait wake the machine out of S4).
        //
        if (powerState.SystemState < PowerSystemHibernate       &&
            powerState.SystemState > data->MinSystemWakeState   &&
            WAITWAKE_ON(data)) {
            status = STATUS_POWER_STATE_INVALID;
        }
        else {
            status = STATUS_SUCCESS;
        }

        Irp->IoStatus.Status = status;
        break;

    case IRP_MN_WAIT_WAKE:
        if (InterlockedCompareExchangePointer(&data->WaitWakeIrp,
                                              Irp,
                                              NULL) != NULL) {
            /*  When powering up with WW being completed at same time, there
                is a race condition between PoReq completion for S Irp and
                completion of WW irp. Steps to repro this:

                S irp completes and does PoReq of D irp with completion
                routine MouseClassPoRequestComplete
                WW Irp completion fires and the following happens:
                    set data->WaitWakeIrp to NULL
                    PoReq D irp with completion routine MouseClassWWPowerUpComplete

                MouseClassPoRequestComplete fires first and sees no WW queued,
                so it queues one.
                MouseClassWWPowerUpComplete fires second and tries to queue
                WW. When the WW arrives in mouclass, it sees there's one
                queued already, so it fails it with invalid device state.
                The completion routine, MouseClassWaitWakeComplete, fires
                and it deletes the irp from the device extension.

                This results in the appearance of wake being disabled,
                even though the first irp is still queued.
            */

            InterlockedExchangePointer(&data->ExtraWaitWakeIrp, Irp);
            status = STATUS_INVALID_DEVICE_STATE;
        }
        else {
            status = STATUS_SUCCESS;
        }
        break;

    default:
        break;
    }

    if (!NT_SUCCESS (status)) {
        Irp->IoStatus.Status = status;
        PoStartNextPowerIrp (Irp);
        IoCompleteRequest (Irp, IO_NO_INCREMENT);

    } else if (hookit) {
        status = IoAcquireRemoveLock (&data->RemoveLock, Irp);
        ASSERT (STATUS_SUCCESS == status);
        IoCopyCurrentIrpStackLocationToNext (Irp);

        IoSetCompletionRoutine (Irp,
                                KeyboardClassPowerComplete,
                                NULL,
                                TRUE,
                                TRUE,
                                TRUE);
        IoMarkIrpPending(Irp);
        PoCallDriver (data->TopPort, Irp);

        //
        // We are returning pending instead of the result from PoCallDriver because:
        // 1  we are changing the status in the completion routine
        // 2  we will not be completing this irp in the completion routine
        //
        status = STATUS_PENDING;
    }
    else if (pendit) {
        status = STATUS_PENDING;
    } else {
        PoStartNextPowerIrp (Irp);
        IoSkipCurrentIrpStackLocation (Irp);
        status = PoCallDriver (data->TopPort, Irp);
    }

    IoReleaseRemoveLock (&data->RemoveLock, Irp);
    return status;
}

VOID
KeyboardClassPoRequestComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE D_PowerState,
    IN PIRP S_Irp, // The S irp that caused us to request the power.
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PDEVICE_EXTENSION   data;
    PKEYBOARD_WORK_ITEM_DATA    itemData;

    data = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // If the S_Irp is present, we are powering down.  We do not pass the S_Irp
    // as a parameter to PoRequestPowerIrp when we are powering up
    //
    if (ARGUMENT_PRESENT(S_Irp)) {
        POWER_STATE powerState;

        //
        // Powering Down
        //
        powerState = IoGetCurrentIrpStackLocation(S_Irp)->Parameters.Power.State;
        PoSetPowerState (data->Self, SystemPowerState, powerState);
        data->SystemState = powerState.SystemState;

        PoStartNextPowerIrp (S_Irp);
        IoSkipCurrentIrpStackLocation (S_Irp);
        PoCallDriver (data->TopPort, S_Irp);

        //
        // Finally, release the lock we acquired based on this irp
        //
        IoReleaseRemoveLock (&data->RemoveLock, S_Irp);
    }
    else {
        //
        // Powering Up
        //

        //
        // We have come back to the PowerSystemWorking state and the device is
        // fully powered.  If we can (and should), send a wait wake irp down
        // the stack.  This is necessary because we might have gone into a power
        // state where the wait wake irp was invalid.
        //
        ASSERT(data->SystemState == PowerSystemWorking);

        if (SHOULD_SEND_WAITWAKE (data)) {
            //
            // We cannot call CreateWaitWake from this completion routine,
            // as it is a paged function.
            //
            itemData = (PKEYBOARD_WORK_ITEM_DATA)
                    ExAllocatePool (NonPagedPool, sizeof (KEYBOARD_WORK_ITEM_DATA));

            if (NULL != itemData) {
                NTSTATUS  status;

                itemData->Item = IoAllocateWorkItem (data->Self);
                if (itemData->Item == NULL) {
                    ExFreePool (itemData);
                    goto CreateWaitWakeWorkerError;
                }

                itemData->Data = data;
                itemData->Irp = NULL;
                status = IoAcquireRemoveLock (&data->RemoveLock, itemData);

                if (NT_SUCCESS(status)) {
                    IoQueueWorkItem (itemData->Item,
                                     KeyboardClassCreateWaitWakeIrpWorker,
                                     DelayedWorkQueue,
                                     itemData);
                }
                else {
                    IoFreeWorkItem (itemData->Item);
                    ExFreePool (itemData);
                    goto CreateWaitWakeWorkerError;
                }
            } else {
CreateWaitWakeWorkerError:
                //
                // Well, we dropped the WaitWake.
                //
                // Print a warning to the debugger, and log an error.
                //
                DbgPrint ("KbdClass: WARNING: Failed alloc pool -> no WW Irp\n");

                KeyboardClassLogError (data->Self,
                                       KBDCLASS_NO_RESOURCES_FOR_WAITWAKE,
                                       1,
                                       STATUS_INSUFFICIENT_RESOURCES,
                                       0,
                                       NULL,
                                       0);
            }
        }
    }
}

NTSTATUS
KeyboardClassSetLedsComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PDEVICE_EXTENSION   data;

    UNREFERENCED_PARAMETER (DeviceObject);

    data = (PDEVICE_EXTENSION) Context;

    IoReleaseRemoveLock (&data->RemoveLock, Irp);
    IoFreeIrp (Irp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
KeyboardClassPowerComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    NTSTATUS            status;
    POWER_STATE         powerState;
    POWER_STATE_TYPE    powerType;
    PIO_STACK_LOCATION  stack, next;
    PIRP                irpLeds;
    PDEVICE_EXTENSION   data;
    IO_STATUS_BLOCK     block;
    PFILE_OBJECT        file;
    PKEYBOARD_INDICATOR_PARAMETERS params;

    UNREFERENCED_PARAMETER (Context);

    data = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation (Irp);
    next = IoGetNextIrpStackLocation (Irp);
    powerType = stack->Parameters.Power.Type;
    powerState = stack->Parameters.Power.State;

    ASSERT (data != Globals.GrandMaster);
    ASSERT (data->PnP);

    switch (stack->MinorFunction) {
    case IRP_MN_SET_POWER:
        switch (powerType) {
        case DevicePowerState:
            ASSERT (powerState.DeviceState < data->DeviceState);
            //
            // Powering up
            //
            PoSetPowerState (data->Self, powerType, powerState);
            data->DeviceState = powerState.DeviceState;

            irpLeds = IoAllocateIrp(DeviceObject->StackSize, FALSE);
            if (irpLeds) {
                status = IoAcquireRemoveLock(&data->RemoveLock, irpLeds);

                if (NT_SUCCESS(status)) {
                    //
                    // Set the keyboard Indicators.
                    //
                    if (Globals.GrandMaster) {
                        params = &Globals.GrandMaster->IndicatorParameters;
                        file = Globals.AssocClassList[data->UnitId].File;
                    } else {
                        params = &data->IndicatorParameters;
                        file = stack->FileObject;
                    }

                    //
                    // This is a completion routine.  We could be at DISPATCH_LEVEL
                    // Therefore we must bounce the IRP
                    //
                    next = IoGetNextIrpStackLocation(irpLeds);

                    next->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
                    next->Parameters.DeviceIoControl.IoControlCode =
                        IOCTL_KEYBOARD_SET_INDICATORS;
                    next->Parameters.DeviceIoControl.InputBufferLength =
                        sizeof (KEYBOARD_INDICATOR_PARAMETERS);
                    next->Parameters.DeviceIoControl.OutputBufferLength = 0;
                    next->FileObject = file;

                    IoSetCompletionRoutine (irpLeds,
                                            KeyboardClassSetLedsComplete,
                                            data,
                                            TRUE,
                                            TRUE,
                                            TRUE);

                    irpLeds->AssociatedIrp.SystemBuffer = params;

                    IoCallDriver (data->TopPort, irpLeds);
                }
                else {
                    IoFreeIrp (irpLeds);
                }
            }

            break;

        case SystemPowerState:
            ASSERT (powerState.SystemState < data->SystemState);
            //
            // Powering up
            //
            // Save the system state before we overwrite it
            //
            PoSetPowerState (data->Self, powerType, powerState);
            data->SystemState = powerState.SystemState;
            powerState.DeviceState = PowerDeviceD0;

            status = PoRequestPowerIrp (data->Self,
                                        IRP_MN_SET_POWER,
                                        powerState,
                                        KeyboardClassPoRequestComplete,
                                        NULL,
                                        NULL);

            //
            // Propagate the error if one occurred
            //
            if (!NT_SUCCESS(status)) {
                Irp->IoStatus.Status = status;
            }

            break;
        }
        break;

    default:
        ASSERT (0xBADBAD == stack->MinorFunction);
        break;
    }

    PoStartNextPowerIrp (Irp);
    IoReleaseRemoveLock (&data->RemoveLock, Irp);

    return STATUS_SUCCESS;
}

//
// WMI System Call back functions
//
NTSTATUS
KeyboardClassSystemControl (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++
Routine Description

    We have just received a System Control IRP.

    Assume that this is a WMI IRP and
    call into the WMI system library and let it handle this IRP for us.

--*/
{
    PDEVICE_EXTENSION   deviceExtension;
    NTSTATUS            status;
    SYSCTL_IRP_DISPOSITION disposition;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    status = IoAcquireRemoveLock (&deviceExtension->RemoveLock, Irp);
    if (!NT_SUCCESS (status)) {
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    status = WmiSystemControl(&deviceExtension->WmiLibInfo,
                                 DeviceObject,
                                 Irp,
                                 &disposition);
    switch(disposition) {
    case IrpProcessed:
        //
        // This irp has been processed and may be completed or pending.
        //
        break;

    case IrpNotCompleted:
        //
        // This irp has not been completed, but has been fully processed.
        // we will complete it now
        //
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        break;

    case IrpForward:
    case IrpNotWmi:
        //
        // This irp is either not a WMI irp or is a WMI irp targetted
        // at a device lower in the stack.
        //
        status = KeyboardClassPassThrough(DeviceObject, Irp);
        break;

    default:
        //
        // We really should never get here, but if we do just forward....
        //
        ASSERT(FALSE);
        status = KeyboardClassPassThrough(DeviceObject, Irp);
        break;
    }

    IoReleaseRemoveLock (&deviceExtension->RemoveLock, Irp);
    return status;
}

NTSTATUS
KeyboardClassSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION   data;
    NTSTATUS            status;
    ULONG               size = 0;

    PAGED_CODE ();

    data = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    switch(GuidIndex) {
    case WMI_CLASS_DRIVER_INFORMATION:
        status = STATUS_WMI_READ_ONLY;
        break;

    case WMI_WAIT_WAKE:

        size = sizeof(BOOLEAN);

        if (BufferSize < size) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        } else if ((1 != DataItemId) || (0 != InstanceIndex)) {
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        status = KeyboardToggleWaitWake (data, *(PBOOLEAN) Buffer);
        break;

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest (DeviceObject,
                                 Irp,
                                 status,
                                 size,
                                 IO_NO_INCREMENT);

    return status;
}

NTSTATUS
KeyboardClassSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION data;
    NTSTATUS          status;
    ULONG             size = 0;

    PAGED_CODE ();

    data = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    switch(GuidIndex) {
    case WMI_CLASS_DRIVER_INFORMATION:
        status = STATUS_WMI_READ_ONLY;
        break;

    case WMI_WAIT_WAKE: {
        size = sizeof(BOOLEAN);

        if (BufferSize < size) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        } else if (0 != InstanceIndex) {
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        status = KeyboardToggleWaitWake (data, * (PBOOLEAN) Buffer);
        break;
    }

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest (DeviceObject,
                                 Irp,
                                 status,
                                 size,
                                 IO_NO_INCREMENT);

    return status;
}

NTSTATUS
KeyboardClassQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG OutBufferSize,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    InstanceCount is the number of instnaces expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION   data;
    NTSTATUS    status;
    ULONG       size = 0;
    PMSKeyboard_ClassInformation classInformation;

    PAGED_CODE ();

    data = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    switch (GuidIndex) {
    case WMI_CLASS_DRIVER_INFORMATION:
        //
        // Only registers 1 instance for this guid
        //
        if ((0 != InstanceIndex) || (1 != InstanceCount)) {
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }
        size = sizeof (MSKeyboard_ClassInformation);

        if (OutBufferSize < size) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        classInformation = (PMSKeyboard_ClassInformation)Buffer;
        classInformation->DeviceId = (ULONGLONG) DeviceObject;
        *InstanceLengthArray = size;
        status = STATUS_SUCCESS;

        break;

    case WMI_WAIT_WAKE:
        //
        // Only registers 1 instance for this guid
        //
        if ((0 != InstanceIndex) || (1 != InstanceCount)) {
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }
        size = sizeof(BOOLEAN);

        if (OutBufferSize < size) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        *(PBOOLEAN) Buffer = (WAITWAKE_ON (data) ? TRUE : FALSE );
        *InstanceLengthArray = size;
        status = STATUS_SUCCESS;
        break;

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest (DeviceObject,
                                 Irp,
                                 status,
                                 size,
                                 IO_NO_INCREMENT);

    return status;
}

NTSTATUS
KeyboardClassQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered.

    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe all of the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device. These flags are ORed into the flags specified
        by the GUIDREGINFO for each guid.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. This is
        required

    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in
        *RegFlags.

Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;

    PAGED_CODE ();

    deviceExtension = DeviceObject->DeviceExtension;

    *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
    *RegistryPath = &Globals.RegistryPath;
    *Pdo = deviceExtension->PDO;
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\mouclass\mouclass.h ===
/*++

Copyright (c) 1989, 1990, 1991, 1992, 1993, 1994 - 1998  Microsoft Corporation

Module Name:

    mouclass.h

Abstract:

    These are the structures and defines that are used in the
    mouse class driver.

Revision History:

--*/

#ifndef _MOUCLASS_
#define _MOUCLASS_

#include <ntddmou.h>

#include "wmilib.h"

#define MOUSE_POOL_TAG 'CouM'
#undef ExAllocatePool
#define ExAllocatePool(Type, Bytes) ExAllocatePoolWithTag(Type, Bytes, MOUSE_POOL_TAG)

//
// Define the default number of elements in the class input data queue.
//

#define DATA_QUEUE_SIZE 100
#define MAXIMUM_PORTS_SERVICED 10
#define NAME_MAX 256
#define DUMP_COUNT 4
#define DEFAULT_DEBUG_LEVEL 0

#define MAX(a,b) (((a) < (b)) ? (b) : (a))

#if DBG
#define MouPrint(x) MouDebugPrint x
#else
#define MouPrint(x)
#endif

#define MOUSE_WAIT_WAKE_ENABLE L"WaitWakeEnabled"

#define IS_TRUSTED_FILE_FOR_READ(x) (&DriverEntry == (x)->FsContext2)
#define SET_TRUSTED_FILE_FOR_READ(x) ((x)->FsContext2 = &DriverEntry)
#define CLEAR_TRUSTED_FILE_FOR_READ(x) ((x)->FsContext2 = NULL)

#define ALLOW_OVERFLOW TRUE

//
// Port description
//
// Used only with the
// allforoneandoneforall turned off (AKA ConnectOneClassToOnePort
// turned on).  This is the file sent to the ports.
//
typedef struct _PORT {
    //
    // The file Pointer to the port;
    //
    PFILE_OBJECT    File;

    //
    // The port itself
    //
    struct _DEVICE_EXTENSION * Port;

    //
    // Port flags
    //
    BOOLEAN     Enabled;
    BOOLEAN     Reserved[2];
    BOOLEAN     Free;

} PORT, *PPORT;

#define PORT_WORKING(port) ((port)->Enabled && !(port)->Free)

//
// Class device extension.
//
typedef struct _DEVICE_EXTENSION {

    //
    // Back pointer to the Device Object created for this port.
    //
    PDEVICE_OBJECT  Self;

    //
    // Pointer to the active Class DeviceObject;
    // If the AFOAOFA (all for one and one for all) switch is on then this
    // points to the device object named as the first keyboard.
    //
    PDEVICE_OBJECT  TrueClassDevice;

    //
    // The Target port device Object to which all mouse IRPs are sent.
    //
    PDEVICE_OBJECT  TopPort;

    //
    // The PDO if applicable.
    //
    PDEVICE_OBJECT  PDO;

    //
    // A remove lock to keep track of outstanding I/Os to prevent the device
    // object from leaving before such time as all I/O has been completed.
    //
    IO_REMOVE_LOCK  RemoveLock;

    //
    // It this port a Plug and Play port
    //
    BOOLEAN         PnP;
    BOOLEAN         Started;

    //
    // Indicates whether it is okay to log overflow errors.
    //
    BOOLEAN OkayToLogOverflow;

    KSPIN_LOCK WaitWakeSpinLock;

    //
    // Is the Trusted Subsystem Connected
    //
    ULONG TrustedSubsystemCount;

    //
    // Number of input data items currently in the InputData queue.
    //
    ULONG InputCount;

    //
    // A Unicode string pointing to the symbolic link for the Device Interface
    // of this device object.
    //
    UNICODE_STRING  SymbolicLinkName;

    //
    // Start of the class input data queue (really a circular buffer).
    //
    PMOUSE_INPUT_DATA InputData;

    //
    // Insertion pointer for InputData.
    //
    PMOUSE_INPUT_DATA DataIn;

    //
    // Removal pointer for InputData.
    //
    PMOUSE_INPUT_DATA DataOut;

    //
    // Mouse attributes.
    //
    MOUSE_ATTRIBUTES  MouseAttributes;

    //
    // Spinlock used to synchronize access to the input data queue and its
    // insertion/removal pointers.
    //
    KSPIN_LOCK SpinLock;

    //
    // Queue of pended read requests sent to this port.  Access to this queue is
    // guarded by SpinLock
    //
    LIST_ENTRY ReadQueue;

    //
    // Request sequence number (used for error logging).
    //
    ULONG SequenceNumber;

    //
    // The "D" and "S" states of the current device
    //
    DEVICE_POWER_STATE DeviceState;
    SYSTEM_POWER_STATE SystemState;

    ULONG UnitId;

    //
    // WMI Information
    //
    WMILIB_CONTEXT WmiLibInfo;

    //
    // Mapping of system to device states when a wait wake irp is active
    //
    DEVICE_POWER_STATE SystemToDeviceState[PowerSystemHibernate];

    //
    // Minimum amount of power needed to wake the device
    //
    DEVICE_POWER_STATE MinDeviceWakeState;

    //
    // Lowest system state that the machine can be in and have the device wake it up
    //
    SYSTEM_POWER_STATE MinSystemWakeState;

    //
    // Actual wait wake irp
    //
    PIRP WaitWakeIrp;

    //
    // Duplicate wait wake irp getting completed because another was queued.
    //
    PIRP ExtraWaitWakeIrp;

    //
    // Target Device Notification Handle
    //
    PVOID TargetNotifyHandle;

    //
    // Only used for a legacy port device
    //
    LIST_ENTRY Link;

    //
    // Used only for a legacy port device when grand master mode is off
    //
    PFILE_OBJECT File;

    //
    // Used for a legacy port device
    //
    BOOLEAN Enabled;

    //
    // Indicates whether it is okay to send wait wake irps down the stack
    // (does NOT reflect if the bus can implement or not)
    //
    BOOLEAN WaitWakeEnabled;

    //
    // Indicates whether we have received a surprise removed irp
    //
    BOOLEAN SurpriseRemoved;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


//
// On some busses, we can power down the bus, but not the system, in this case
// we still need to allow the device to wake said bus, therefore
// waitwake-supported should not rely on systemstate.
//
// #define WAITWAKE_SUPPORTED(port) ((port)->MinDeviceWakeState > PowerDeviceUnspecified) && \
//                                  (port)->MinSystemWakeState > PowerSystemWorking)
#define WAITWAKE_SUPPORTED(port) ((port)->MinDeviceWakeState > PowerDeviceD0 && \
                                  (port)->MinSystemWakeState > PowerSystemWorking)

// #define WAITWAKE_ON(port)        ((port)->WaitWakeIrp != 0)
#define WAITWAKE_ON(port) \
       (InterlockedCompareExchangePointer(&(port)->WaitWakeIrp, NULL, NULL) != NULL)

#define SHOULD_SEND_WAITWAKE(port) (WAITWAKE_SUPPORTED(port) && \
                                    !WAITWAKE_ON(port)       && \
                                    MouseClassCheckWaitWakeEnabled(port))

//
// Global shared data
//

typedef struct _GLOBALS {
    //
    // Declare the global debug flag for this driver.
    //
    ULONG   Debug;

    //
    // If ConnectOneClassToOnePort is off aka we want "All for one and one for
    // all behavior" then we need to create the one Master DO to which all
    // the goods go.
    //
    PDEVICE_EXTENSION   GrandMaster;

    //
    // List of ClassDevices that associated with the same name
    // aka the all for one and one for all flag is set
    //
    PPORT       AssocClassList;
    ULONG       NumAssocClass;
    LONG        Opens;
    ULONG       NumberLegacyPorts;
    FAST_MUTEX  Mutex;

    //
    // Specifies the type of class-port connection to make.  A '1'
    // indicates a 1:1 relationship between class device objects and
    // port device objects.  A '0' indicates a 1:many relationship.
    //
    ULONG ConnectOneClassToOnePort;

    //
    // Number of port drivers serviced by this class driver.
    //
    ULONG PortsServiced;

    //
    // IntialDevice Extension
    //
    DEVICE_EXTENSION    InitExtension;

    //
    // A list of the registry path to the service parameters.
    //
    UNICODE_STRING      RegistryPath;

    //
    // The base name for all class objects created as mice.
    //
    UNICODE_STRING      BaseClassName;
    WCHAR               BaseClassBuffer[NAME_MAX];

    //
    // Linked list of all the legacy device objects that were created in
    // DriverEntry or FindMorePorts.  We maintain this list so we can delete
    // them when we unload.
    //
    LIST_ENTRY LegacyDeviceList;
} GLOBALS, *PGLOBALS;

//
// Mouse configuration information.
//

typedef struct _MOUSE_CONFIGURATION_INFORMATION {

    //
    // Maximum size of class input data queue, in bytes.
    //

    ULONG  DataQueueSize;

} MOUSE_CONFIGURATION_INFORMATION, *PMOUSE_CONFIGURATION_INFORMATION;

typedef struct _MOUSE_WORK_ITEM_DATA {
    PIRP                Irp;
    PDEVICE_EXTENSION   Data;
    PIO_WORKITEM        Item;
    BOOLEAN             WaitWakeState;
} MOUSE_WORK_ITEM_DATA, *PMOUSE_WORK_ITEM_DATA;

#define MouseClassDeleteLegacyDevice(de)                    \
{                                                           \
    if (de->InputData) {                                    \
        ExFreePool (de->InputData);                         \
        de->InputData = de->DataIn = de->DataOut = NULL;    \
    }                                                       \
    IoDeleteDevice (de->Self);                              \
    de = NULL;                                              \
}

///
// Function Declairations
//

NTSTATUS
MouseAddDeviceEx(
    IN PDEVICE_EXTENSION NewDeviceObject,
    IN PWCHAR            FullClassName,
    IN PFILE_OBJECT      File
    );

NTSTATUS
MouseAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

void
MouseClassGetWaitWakeEnableState(
    IN PDEVICE_EXTENSION Data
    );

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
MouseClassPassThrough(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
MouseClassCancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MouseClassCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MouseClassDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MouseClassFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MouseClassCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MouseClassClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MouseClassRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MouseClassReadCopyData(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    );

PIRP
MouseClassDequeueRead(
    IN PDEVICE_EXTENSION DeviceExtension
    );

PIRP
MouseClassDequeueReadByFileObject(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PFILE_OBJECT FileObject
    );

BOOLEAN
MouseClassCheckWaitWakeEnabled (
    IN PDEVICE_EXTENSION Data
    );

BOOLEAN
MouseClassCreateWaitWakeIrp (
    IN PDEVICE_EXTENSION Data
    );

NTSTATUS
MouseSendIrpSynchronously (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN BOOLEAN          CopyToNext
    );

NTSTATUS
MousePnP (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
MouseClassServiceCallback(
    IN PDEVICE_OBJECT DeviceObject,
    IN PMOUSE_INPUT_DATA InputDataStart,
    IN PMOUSE_INPUT_DATA InputDataEnd,
    IN OUT PULONG InputDataConsumed
    );

NTSTATUS
MouseClassPower (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
MouseClassUnload(
    IN PDRIVER_OBJECT DriverObject
    );

VOID
MouConfiguration();

NTSTATUS
MouCreateClassObject(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDEVICE_EXTENSION   TmpDeviceExtension,
    OUT PDEVICE_OBJECT    * ClassDeviceObject,
    OUT PWCHAR            * FullDeviceName,
    IN  BOOLEAN             Legacy
    );

VOID
MouDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );

NTSTATUS
MouDeterminePortsServiced(
    IN PUNICODE_STRING BasePortName,
    IN OUT PULONG NumberPortsServiced
    );

NTSTATUS
MouDeviceMapQueryCallback(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
MouEnableDisablePort(
    IN BOOLEAN EnableFlag,
    IN PIRP    Irp,
    IN PDEVICE_EXTENSION Port,
    IN PFILE_OBJECT * File
    );

NTSTATUS
MouSendConnectRequest(
    IN PDEVICE_EXTENSION ClassData,
    IN PVOID ServiceCallback
    );

VOID
MouInitializeDataQueue(
    IN PVOID Context
    );

VOID
MouseClassFindMorePorts(
    PDRIVER_OBJECT  DriverObject,
    PVOID           Context,
    ULONG           Count
    );

NTSTATUS
MouseClassEnableGlobalPort(
    IN PDEVICE_EXTENSION Port,
    IN BOOLEAN Enabled
    );

NTSTATUS
MouseClassPlugPlayNotification(
    IN PVOID NotificationStructure,
    IN PDEVICE_EXTENSION Port
    );

void
MouseClassLogError(
    PVOID Object,
    ULONG ErrorCode,
    ULONG UniqueErrorValue,
    NTSTATUS FinalStatus,
    ULONG DumpCount,
    ULONG *DumpData,
    UCHAR MajorFunction
    );

BOOLEAN
MouseClassCreateWaitWakeIrp (
    IN PDEVICE_EXTENSION Data
    );

void
MouseClassCreateWaitWakeIrpWorker (
    IN PDEVICE_OBJECT DeviceObject,
    IN PMOUSE_WORK_ITEM_DATA  ItemData
    );

NTSTATUS
MouseToggleWaitWake(
    PDEVICE_EXTENSION Data,
    BOOLEAN           WaitWakeState
    );

VOID
MouseToggleWaitWakeWorker(
    IN PDEVICE_OBJECT DeviceObject,
    IN PMOUSE_WORK_ITEM_DATA ItemData
    );

NTSTATUS
MouseQueryDeviceKey (
    IN  HANDLE  Handle,
    IN  PWCHAR  ValueNameString,
    OUT PVOID   Data,
    IN  ULONG   DataLength
    );

NTSTATUS
MouseClassSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );


NTSTATUS
MouseClassSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
MouseClassSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
MouseClassQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );

NTSTATUS
MouseClassQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *Pdo
    );

#endif // _MOUCLASS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\mouclass\mouclass.c ===
/*++

Copyright (c) 1990, 1991, 1992, 1993, 1994 - 1998  Microsoft Corporation

Module Name:

    mouclass.c

Abstract:

    Mouse class driver.

Environment:

    Kernel mode only.

Notes:

    NOTES:  (Future/outstanding issues)

    - Powerfail not implemented.

    - Consolidate duplicate code, where possible and appropriate.

@@BEGIN_DDKSPLIT

Revision History:

    May 1997 Kenneth D. Ray: liberal additions of plug and play

@@END_DDKSPLIT
--*/

#include <stdarg.h>
#include <stdio.h>
#include <ntddk.h>
//@@BEGIN_DDKSPLIT
#include <ntpoapi.h>
//@@END_DDKSPLIT
#include <hidclass.h>

#include <initguid.h>
#include <kbdmou.h>
#include <moulog.h>
#include "mouclass.h"
#include <poclass.h>
#include <wmistr.h>

#define INITGUID
#include "wdmguid.h"

GLOBALS Globals;

//@@BEGIN_DDKSPLIT
NTSYSAPI
NTSTATUS
NTAPI
ZwPowerInformation(
    IN POWER_INFORMATION_LEVEL InformationLevel,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );
//@@END_DDKSPLIT

//
// Use the alloc_text pragma to specify the driver initialization routines
// (they can be paged out).
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(INIT,MouConfiguration)
#pragma alloc_text(PAGE,MouseClassPassThrough)
#pragma alloc_text(PAGE,MouseQueryDeviceKey)
#pragma alloc_text(PAGE,MouDeterminePortsServiced)
#pragma alloc_text(PAGE,MouDeviceMapQueryCallback)
#pragma alloc_text(PAGE,MouSendConnectRequest)
#pragma alloc_text(PAGE,MouseAddDevice)
#pragma alloc_text(PAGE,MouseAddDeviceEx)
#pragma alloc_text(PAGE,MouseClassDeviceControl)
#pragma alloc_text(PAGE,MouseSendIrpSynchronously)
#pragma alloc_text(PAGE,MouCreateClassObject)
#pragma alloc_text(PAGE,MouseClassFindMorePorts)
#pragma alloc_text(PAGE,MouseClassGetWaitWakeEnableState)
#pragma alloc_text(PAGE,MouseClassEnableGlobalPort)
#pragma alloc_text(PAGE,MouseClassPlugPlayNotification)
#pragma alloc_text(PAGE,MouseClassSystemControl)
#pragma alloc_text(PAGE,MouseClassSetWmiDataItem)
#pragma alloc_text(PAGE,MouseClassSetWmiDataBlock)
#pragma alloc_text(PAGE,MouseClassQueryWmiDataBlock)
#pragma alloc_text(PAGE,MouseClassQueryWmiRegInfo)

#pragma alloc_text(PAGE,MouseClassPower)
#pragma alloc_text(PAGE,MouseClassCreateWaitWakeIrpWorker)
#pragma alloc_text(PAGE,MouseClassCreateWaitWakeIrp)
// #pragma alloc_text(PAGE,MouseToggleWaitWakeWorker)
#pragma alloc_text(PAGE,MouseClassUnload)
#endif

#define WMI_CLASS_DRIVER_INFORMATION 0
#define WMI_WAIT_WAKE                1

GUID MouseClassGuid =     MSMouse_ClassInformationGuid;

WMIGUIDREGINFO MouseClassWmiGuidList[] =
{
    {
        &MouseClassGuid,
        1,
        0 // Mouse class driver information
    },
    {
        &GUID_POWER_DEVICE_WAKE_ENABLE,
        1,
        0
    }
};



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine initializes the mouse class driver.

Arguments:

    DriverObject - Pointer to driver object created by system.

    RegistryPath - Pointer to the Unicode name of the registry path
        for this driver.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    NTSTATUS                status = STATUS_SUCCESS;
    PDEVICE_EXTENSION       deviceExtension = NULL;
    PDEVICE_OBJECT          classDeviceObject = NULL;
    ULONG                   dumpCount = 0;
    ULONG                   dumpData[DUMP_COUNT];
    ULONG                   i;
    ULONG                   numPorts;
    ULONG                   uniqueErrorValue;
    UNICODE_STRING          basePortName;
    UNICODE_STRING          fullPortName;
    WCHAR                   basePortBuffer[NAME_MAX];
    PWCHAR                  fullClassName = NULL;
    PFILE_OBJECT            file;
    PLIST_ENTRY             entry;

    MouPrint((1,"\n\nMOUCLASS-MouseClassInitialize: enter\n"));

    //
    // Zero-initialize various structures.
    //
    RtlZeroMemory(&Globals, sizeof(GLOBALS));

    Globals.Debug = DEFAULT_DEBUG_LEVEL;

    InitializeListHead(&Globals.LegacyDeviceList);

    fullPortName.MaximumLength = 0;

    ExInitializeFastMutex (&Globals.Mutex);
    Globals.BaseClassName.Buffer = Globals.BaseClassBuffer;
    Globals.BaseClassName.Length = 0;
    Globals.BaseClassName.MaximumLength = NAME_MAX * sizeof(WCHAR);

    RtlZeroMemory(basePortBuffer, NAME_MAX * sizeof(WCHAR));
    basePortName.Buffer = basePortBuffer;
    basePortName.Length = 0;
    basePortName.MaximumLength = NAME_MAX * sizeof(WCHAR);

    //
    // Need to ensure that the registry path is null-terminated.
    // Allocate pool to hold a null-terminated copy of the path.
    //

    Globals.RegistryPath.Length = RegistryPath->Length;
    Globals.RegistryPath.MaximumLength = RegistryPath->Length
                                       + sizeof (UNICODE_NULL);

    Globals.RegistryPath.Buffer = ExAllocatePool(
                                      NonPagedPool,
                                      Globals.RegistryPath.MaximumLength);

    if (!Globals.RegistryPath.Buffer) {
        MouPrint((
            1,
            "MOUCLASS-MouseClassInitialize: Couldn't allocate pool for registry path\n"
            ));

        status = STATUS_UNSUCCESSFUL;
        dumpData[0] = (ULONG) RegistryPath->Length + sizeof(UNICODE_NULL);

        MouseClassLogError (DriverObject,
                            MOUCLASS_INSUFFICIENT_RESOURCES,
                            MOUSE_ERROR_VALUE_BASE + 2,
                            STATUS_UNSUCCESSFUL,
                            1,
                            dumpData,
                            0);

        goto MouseClassInitializeExit;

    }

    RtlMoveMemory(Globals.RegistryPath.Buffer,
                  RegistryPath->Buffer,
                  RegistryPath->Length);
    Globals.RegistryPath.Buffer [RegistryPath->Length / sizeof (WCHAR)] = L'\0';

    //
    // Get the configuration information for this driver.
    //

    MouConfiguration();

    //
    // If there is only one class device object then create it as the grand
    // master device object.  Otherwise let all the FDOs also double as the
    // class DO.
    //
    if (!Globals.ConnectOneClassToOnePort) {
        status = MouCreateClassObject (DriverObject,
                                       &Globals.InitExtension,
                                       &classDeviceObject,
                                       &fullClassName,
                                       TRUE);
        if (!NT_SUCCESS (status)) {
            // ISSUE:  should log an error that we could not create a GM
            goto MouseClassInitializeExit;
        }

        deviceExtension = (PDEVICE_EXTENSION)classDeviceObject->DeviceExtension;
        Globals.GrandMaster = deviceExtension;
        deviceExtension->PnP = FALSE;
        MouseAddDeviceEx (deviceExtension, fullClassName, NULL);

        ASSERT (NULL != fullClassName);
        ExFreePool (fullClassName);
        fullClassName = NULL;

        classDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    }

    //
    // Set up the base device name for the associated port device.
    // It is the same as the base class name, with "Class" replaced
    // by "Port".
    //
    RtlCopyUnicodeString(&basePortName, &Globals.BaseClassName);
    basePortName.Length -= (sizeof(L"Class") - sizeof(UNICODE_NULL));
    RtlAppendUnicodeToString(&basePortName, L"Port");

    //
    // Determine how many (static) ports this class driver is to service.
    //
    //
    // If this returns zero, then all ports will be dynamically PnP added later
    //
    MouDeterminePortsServiced(&basePortName, &numPorts);

    ASSERT (numPorts <= MAXIMUM_PORTS_SERVICED);

    MouPrint((
        1,
        "MOUCLASS-MouseClassInitialize: Will service %d port devices\n",
        numPorts
        ));

    //
    // Set up space for the full device object name for the ports.
    //
    RtlInitUnicodeString(&fullPortName, NULL);

    fullPortName.MaximumLength = sizeof(L"\\Device\\")
                               + basePortName.Length
                               + sizeof (UNICODE_NULL);

    fullPortName.Buffer = ExAllocatePool(PagedPool,
                                         fullPortName.MaximumLength);

    if (!fullPortName.Buffer) {

        MouPrint((
            1,
            "MOUCLASS-MouseClassInitialize: Couldn't allocate string for port device object name\n"
            ));

        status = STATUS_UNSUCCESSFUL;
        dumpData[0] = (ULONG) fullPortName.MaximumLength;
        MouseClassLogError (DriverObject,
                            MOUCLASS_INSUFFICIENT_RESOURCES,
                            MOUSE_ERROR_VALUE_BASE + 8,
                            status,
                            1,
                            dumpData,
                            0);

        goto MouseClassInitializeExit;

    }

    RtlZeroMemory(fullPortName.Buffer, fullPortName.MaximumLength);
    RtlAppendUnicodeToString(&fullPortName, L"\\Device\\");
    RtlAppendUnicodeToString(&fullPortName, basePortName.Buffer);
    RtlAppendUnicodeToString(&fullPortName, L"0");

    //
    // Set up the class device object(s) to handle the associated
    // port devices.
    //
    for (i = 0; (i < Globals.PortsServiced) && (i < numPorts); i++) {

        //
        // Append the suffix to the device object name string.  E.g., turn
        // \Device\PointerClass into \Device\PointerClass0.  Then attempt
        // to create the device object.  If the device object already
        // exists increment the suffix and try again.
        //

        fullPortName.Buffer[(fullPortName.Length / sizeof(WCHAR)) - 1]
            = L'0' + (WCHAR) i;

        //
        // Create the class device object.
        //
        status = MouCreateClassObject (DriverObject,
                                       &Globals.InitExtension,
                                       &classDeviceObject,
                                       &fullClassName,
                                       TRUE);

        if (!NT_SUCCESS(status)) {
            MouseClassLogError (DriverObject,
                                MOUCLASS_INSUFFICIENT_RESOURCES,
                                MOUSE_ERROR_VALUE_BASE + 8,
                                status,
                                0,
                                NULL,
                                0);
            continue;
        }

        deviceExtension = (PDEVICE_EXTENSION)classDeviceObject->DeviceExtension;
        deviceExtension->PnP = FALSE;

        classDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

        //
        // Connect to the port device.
        //
        status = IoGetDeviceObjectPointer (&fullPortName,
                                           FILE_READ_ATTRIBUTES,
                                           &file,
                                           &deviceExtension->TopPort);

        //
        // In case of failure, just delete the device and continue
        //
        if (status != STATUS_SUCCESS) {
            // ISSUE:  log error
            MouseClassDeleteLegacyDevice (deviceExtension);
            continue;
        }

        classDeviceObject->StackSize = 1 + deviceExtension->TopPort->StackSize;
        status = MouseAddDeviceEx (deviceExtension, fullClassName, file);

        if (Globals.GrandMaster == NULL) {
            deviceExtension->File = file;
        }
        if (fullClassName) {
            ExFreePool(fullClassName);
            fullClassName = NULL;
        }

        if (!NT_SUCCESS (status)) {
            if (Globals.GrandMaster == NULL) {
                if (deviceExtension->File) {
                    file = deviceExtension->File;
                    deviceExtension->File = NULL;
                }
            }
            else {
                PPORT port;

                ExAcquireFastMutex (&Globals.Mutex);

                file = Globals.AssocClassList[deviceExtension->UnitId].File;
                Globals.AssocClassList[deviceExtension->UnitId].File = NULL;
                Globals.AssocClassList[deviceExtension->UnitId].Free = TRUE;
                Globals.AssocClassList[deviceExtension->UnitId].Port = NULL;

                ExReleaseFastMutex (&Globals.Mutex);
            }

            if (file) {
                ObDereferenceObject (file);
            }

            MouseClassDeleteLegacyDevice (deviceExtension);
            continue;
        }

        //
        // Store this device object in a linked list regardless if we are in
        // grand master mode or not
        //
        InsertTailList (&Globals.LegacyDeviceList, &deviceExtension->Link);
    } // for

    //
    // If we had any failures creating legacy device objects, we must still
    // succeed b/c we need to service pnp ports later on
    //
    status = STATUS_SUCCESS;

    //
    // Count the number of legacy device ports we created
    //
    for (entry = Globals.LegacyDeviceList.Flink;
         entry != &Globals.LegacyDeviceList;
         entry = entry->Flink) {
        Globals.NumberLegacyPorts++;
    }

MouseClassInitializeExit:

    //
    // Free the unicode strings.
    //
    if (fullPortName.MaximumLength != 0) {
        ExFreePool(fullPortName.Buffer);
    }

    if (fullClassName) {
        ExFreePool(fullClassName);
    }

    if (NT_SUCCESS (status)) {

        IoRegisterDriverReinitialization(DriverObject,
                                         MouseClassFindMorePorts,
                                         NULL);

        //
        // Set up the device driver entry points.
        //

        DriverObject->MajorFunction[IRP_MJ_CREATE]         = MouseClassCreate;
        DriverObject->MajorFunction[IRP_MJ_CLOSE]          = MouseClassClose;
        DriverObject->MajorFunction[IRP_MJ_READ]           = MouseClassRead;
        DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS]  = MouseClassFlush;
        DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = MouseClassDeviceControl;
        DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] =
                                                             MouseClassPassThrough;
        DriverObject->MajorFunction[IRP_MJ_CLEANUP]        = MouseClassCleanup;
        DriverObject->MajorFunction[IRP_MJ_PNP]            = MousePnP;
        DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = MouseClassSystemControl;
        DriverObject->MajorFunction[IRP_MJ_POWER]          = MouseClassPower;
        DriverObject->DriverExtension->AddDevice           = MouseAddDevice;

        // DriverObject->DriverUnload = MouseClassUnload;

        status = STATUS_SUCCESS;

    } else {
        //
        // Clean up all the pool we created and delete the GM if it exists
        //
        if (Globals.RegistryPath.Buffer != NULL) {
            ExFreePool (Globals.RegistryPath.Buffer);
            Globals.RegistryPath.Buffer = NULL;
        }

        if (Globals.AssocClassList) {
            ExFreePool (Globals.AssocClassList);
            Globals.AssocClassList = NULL;
        }

        if (Globals.GrandMaster) {
            MouseClassDeleteLegacyDevice(Globals.GrandMaster);
            Globals.GrandMaster = NULL;
        }
    }

    MouPrint((1,"MOUCLASS-MouseClassInitialize: exit, 0x%x\n", status));

    return status;
}

NTSTATUS
MouseClassPassThrough(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        )
/*++
Routine Description:

        Passes a request on to the lower driver.

--*/
{
        //
        // Pass the IRP to the target
        //
    IoSkipCurrentIrpStackLocation (Irp);
        return IoCallDriver (
        ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->TopPort,
                Irp);
}


NTSTATUS
MouseQueryDeviceKey (
    IN  HANDLE  Handle,
    IN  PWCHAR  ValueNameString,
    OUT PVOID   Data,
    IN  ULONG   DataLength
    )
{
    NTSTATUS        status;
    UNICODE_STRING  valueName;
    ULONG           length;
    PKEY_VALUE_FULL_INFORMATION fullInfo;

    PAGED_CODE();

    RtlInitUnicodeString (&valueName, ValueNameString);

    length = sizeof (KEY_VALUE_FULL_INFORMATION)
           + valueName.MaximumLength
           + DataLength;

    fullInfo = ExAllocatePool (PagedPool, length);

    if (fullInfo) {
        status = ZwQueryValueKey (Handle,
                                  &valueName,
                                  KeyValueFullInformation,
                                  fullInfo,
                                  length,
                                  &length);

        if (NT_SUCCESS (status)) {
            ASSERT (DataLength == fullInfo->DataLength);
            RtlCopyMemory (Data,
                           ((PUCHAR) fullInfo) + fullInfo->DataOffset,
                           fullInfo->DataLength);
        }

        ExFreePool (fullInfo);
    } else {
        status = STATUS_NO_MEMORY;
    }

    return status;
}

NTSTATUS
MouseAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++
Description:
    The plug play entry point "AddDevice"

--*/
{
    NTSTATUS            status;
    PDEVICE_OBJECT      fdo;
    PDEVICE_EXTENSION   port;
    PWCHAR              fullClassName = NULL;
    POWER_STATE         state;

    PAGED_CODE ();

    status = MouCreateClassObject (DriverObject,
                                   &Globals.InitExtension,
                                   &fdo,
                                   &fullClassName,
                                   FALSE);

    if (!NT_SUCCESS (status)) {
        return status;
    }

    port = (PDEVICE_EXTENSION) fdo->DeviceExtension;
    port->TopPort = IoAttachDeviceToDeviceStack (fdo, PhysicalDeviceObject);

    if (port->TopPort == NULL) {
        PIO_ERROR_LOG_PACKET errorLogEntry;

        //
        // Not good; in only extreme cases will this fail
        //
        errorLogEntry = (PIO_ERROR_LOG_PACKET)
            IoAllocateErrorLogEntry (DriverObject,
                                     (UCHAR) sizeof(IO_ERROR_LOG_PACKET));

        if (errorLogEntry) {
            errorLogEntry->ErrorCode = MOUCLASS_ATTACH_DEVICE_FAILED;
            errorLogEntry->DumpDataSize = 0;
            errorLogEntry->SequenceNumber = 0;
            errorLogEntry->MajorFunctionCode = 0;
            errorLogEntry->IoControlCode = 0;
            errorLogEntry->RetryCount = 0;
            errorLogEntry->UniqueErrorValue = 0;
            errorLogEntry->FinalStatus =  STATUS_DEVICE_NOT_CONNECTED;

            IoWriteErrorLogEntry (errorLogEntry);
        }

        IoDeleteDevice (fdo);
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    port->PDO = PhysicalDeviceObject;
    port->PnP = TRUE;
    port->Started = FALSE;
    port->DeviceState = PowerDeviceD0;
    port->SystemState = PowerSystemWorking;

    state.DeviceState = PowerDeviceD0;
    PoSetPowerState (fdo, DevicePowerState, state);

    port->MinDeviceWakeState = PowerDeviceUnspecified;
    port->MinSystemWakeState = PowerSystemUnspecified;
    port->WaitWakeEnabled = FALSE;

    fdo->Flags |= DO_POWER_PAGABLE;
    fdo->Flags &= ~DO_DEVICE_INITIALIZING;

    status = IoRegisterDeviceInterface (PhysicalDeviceObject,
                                        (LPGUID)&GUID_CLASS_MOUSE,
                                        NULL,
                                        &port->SymbolicLinkName );

    if (!NT_SUCCESS (status)) {
        IoDetachDevice (port->TopPort);
        port->TopPort = NULL;
        IoDeleteDevice (fdo);
    } else {
        status = MouseAddDeviceEx (port, fullClassName, NULL);
    }

    if (fullClassName) {
        ExFreePool(fullClassName);
    }

    return status;
}

void
MouseClassGetWaitWakeEnableState(
    IN PDEVICE_EXTENSION Data
    )
{
    HANDLE hKey;
    NTSTATUS status;
    ULONG tmp;
    BOOLEAN wwEnableFound;

    PAGED_CODE();

    hKey = NULL;
    wwEnableFound = FALSE;

    status = IoOpenDeviceRegistryKey (Data->PDO,
                                      PLUGPLAY_REGKEY_DEVICE,
                                      STANDARD_RIGHTS_ALL,
                                      &hKey);

    if (NT_SUCCESS (status)) {
        status = MouseQueryDeviceKey (hKey,
                                      MOUSE_WAIT_WAKE_ENABLE,
                                      &tmp,
                                      sizeof (tmp));
        if (NT_SUCCESS (status)) {
            wwEnableFound = TRUE;
            Data->WaitWakeEnabled = (tmp ? TRUE : FALSE);
        }

        ZwClose (hKey);
        hKey = NULL;
    }

//@@BEGIN_DDKSPLIT
    if (wwEnableFound == FALSE && Data->WaitWakeEnabled == FALSE) {
        RTL_OSVERSIONINFOEXW osVerInfo;
        ULONGLONG mask = 0;

        //
        // Only auto enable wait wake on workstation installs (pro and personal)
        //
        RtlZeroMemory(&osVerInfo, sizeof(osVerInfo));
        osVerInfo.dwOSVersionInfoSize = sizeof(osVerInfo);
        osVerInfo.wProductType = VER_NT_WORKSTATION;

        VER_SET_CONDITION(mask, VER_PRODUCT_TYPE, VER_EQUAL);

        if (NT_SUCCESS(RtlVerifyVersionInfo(&osVerInfo,
                                            VER_PRODUCT_TYPE,
                                            mask))) {
            SYSTEM_POWER_CAPABILITIES sysPowerCaps;

            RtlZeroMemory(&sysPowerCaps, sizeof(sysPowerCaps));

            status = ZwPowerInformation (SystemPowerCapabilities,
                                         NULL,
                                         0,
                                         &sysPowerCaps,
                                         sizeof(SYSTEM_POWER_CAPABILITIES));

            if (NT_SUCCESS (status)) {
                SYSTEM_POWER_STATE maxSysWake;

                //
                // Get the deepest sleep state the machine is capable of
                //
                if (sysPowerCaps.SystemS3) {
                    maxSysWake = PowerSystemSleeping3;
                }
                else if (sysPowerCaps.SystemS2) {
                    maxSysWake = PowerSystemSleeping2;
                }
                else if (sysPowerCaps.SystemS1) {
                    maxSysWake = PowerSystemSleeping1;
                }
                else {
                    maxSysWake = PowerSystemUnspecified;
                }

                //
                // See if the system wake state for the device is as deep (or
                // deeper) than the deepest system sleep state.  This will
                // prevent us from auto enabling wake and then only allowing the
                // machine to go into S1 instead of S3 (which is the case on a
                // lot of laptops).
                //
                if (Data->MinSystemWakeState >= maxSysWake) {
                    //
                    // Success!
                    //
                    Data->WaitWakeEnabled = TRUE;
                }
            }
        }
    }
//@@END_DDKSPLIT

}

NTSTATUS
MouseAddDeviceEx(
    IN PDEVICE_EXTENSION    ClassData,
    IN PWCHAR               FullClassName,
    IN PFILE_OBJECT         File
    )
 /*++ Description:
  *
  * Called whenever the Mouse Class driver is loaded to control a device.
  *
  * Two possible reasons.
  * 1) Plug and Play found a PNP enumerated Mouse.
  * 2) Driver Entry found this device via old crusty legacy reasons.
  *
  * Arguments:
  *
  *
  * Return:
  *
  * STATUS_SUCCESS - if successful STATUS_UNSUCCESSFUL - otherwise
  *
  * --*/
{
    NTSTATUS                errorCode = STATUS_SUCCESS;
    NTSTATUS                status = STATUS_SUCCESS;
    PDEVICE_EXTENSION       trueClassData;
    PPORT                   classDataList;
    ULONG                   uniqueErrorValue = 0;
    PIO_ERROR_LOG_PACKET    errorLogEntry;
    ULONG                   dumpCount = 0;
    ULONG                   dumpData[DUMP_COUNT];
    ULONG                   i;

    PAGED_CODE ();

    KeInitializeSpinLock (&ClassData->WaitWakeSpinLock);

    if (Globals.ConnectOneClassToOnePort) {

        ASSERT (NULL == Globals.GrandMaster);
        trueClassData = ClassData;

    } else {
        trueClassData = Globals.GrandMaster;
    }
    ClassData->TrueClassDevice = trueClassData->Self;

    if ((Globals.GrandMaster != ClassData) &&
        (Globals.GrandMaster == trueClassData)) {
        //
        // We have a grand master, and are adding a port device object.
        //

        //
        // Connect to port device.
        //
        status = MouSendConnectRequest(ClassData, MouseClassServiceCallback);

        //
        // Link this class device object in the list of class devices object
        // associated with the true class device object
        //
        ExAcquireFastMutex (&Globals.Mutex);

        for (i=0; i < Globals.NumAssocClass; i++) {
            if (Globals.AssocClassList[i].Free) {
                Globals.AssocClassList[i].Free = FALSE;
                break;
            }
        }

        if (i == Globals.NumAssocClass) {
            classDataList = ExAllocatePool (
                               NonPagedPool,
                               (Globals.NumAssocClass + 1) * sizeof (PORT));

            if (NULL == classDataList) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                // ISSUE: log error

                ExReleaseFastMutex (&Globals.Mutex);

                goto MouseAddDeviceExReject;
            }

            RtlZeroMemory (classDataList,
                           (Globals.NumAssocClass + 1) * sizeof (PORT));

            if (0 != Globals.NumAssocClass) {
                RtlCopyMemory (classDataList,
                               Globals.AssocClassList,
                               Globals.NumAssocClass * sizeof (PORT));

                ExFreePool (Globals.AssocClassList);
            }
            Globals.AssocClassList = classDataList;
            Globals.NumAssocClass++;
        }

        ClassData->UnitId = i;
        Globals.AssocClassList [i].Port = ClassData;
        Globals.AssocClassList [i].File = File;

        trueClassData->Self->StackSize =
            MAX (trueClassData->Self->StackSize, ClassData->Self->StackSize);

        ExReleaseFastMutex (&Globals.Mutex);

    } else if ((Globals.GrandMaster != ClassData) &&
               (ClassData == trueClassData)) {

        //
        // Connect to port device.
        //
        status = MouSendConnectRequest(ClassData, MouseClassServiceCallback);
        ASSERT (STATUS_SUCCESS == status);
    }

    if (ClassData == trueClassData) {

        ASSERT (NULL != FullClassName);

        //
        // Load the device map information into the registry so
        // that setup can determine which mouse class driver is active.
        //
        status = RtlWriteRegistryValue(
                     RTL_REGISTRY_DEVICEMAP,
                     Globals.BaseClassName.Buffer, // key name
                     FullClassName, // value name
                     REG_SZ,
                     Globals.RegistryPath.Buffer, // The value
                     Globals.RegistryPath.Length + sizeof(UNICODE_NULL));

        if (!NT_SUCCESS(status)) {

            MouPrint((
                1,
                "MOUCLASS-MouseClassInitialize: Could not store %ws in DeviceMap\n",
                FullClassName));

            MouseClassLogError (ClassData,
                                MOUCLASS_NO_DEVICEMAP_CREATED,
                                MOUSE_ERROR_VALUE_BASE + 14,
                                status,
                                0,
                                NULL,
                                0);
        } else {

            MouPrint((
                1,
                "MOUCLASS-MouseClassInitialize: Stored %ws in DeviceMap\n",
                FullClassName));

        }
    }

    return status;

MouseAddDeviceExReject:

    //
    // Some part of the initialization failed.  Log an error, and
    // clean up the resources for the failed part of the initialization.
    //
    if (errorCode != STATUS_SUCCESS) {

        errorLogEntry = (PIO_ERROR_LOG_PACKET)
            IoAllocateErrorLogEntry(
                trueClassData->Self,
                (UCHAR) (sizeof(IO_ERROR_LOG_PACKET)
                         + (dumpCount * sizeof(ULONG)))
                );

        if (errorLogEntry != NULL) {

            errorLogEntry->ErrorCode = errorCode;
            errorLogEntry->DumpDataSize = (USHORT) (dumpCount * sizeof (ULONG));
            errorLogEntry->SequenceNumber = 0;
            errorLogEntry->MajorFunctionCode = 0;
            errorLogEntry->IoControlCode = 0;
            errorLogEntry->RetryCount = 0;
            errorLogEntry->UniqueErrorValue = uniqueErrorValue;
            errorLogEntry->FinalStatus = status;
            for (i = 0; i < dumpCount; i++)
                errorLogEntry->DumpData[i] = dumpData[i];

            IoWriteErrorLogEntry(errorLogEntry);
        }

    }

    return status;
}

VOID
MouseClassCancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the class cancellation routine.  It is
    called from the I/O system when a request is cancelled.  Read requests
    are currently the only cancellable requests.

    N.B.  The cancel spinlock is already held upon entry to this routine.


Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet to be cancelled.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION deviceExtension;
    KIRQL irql;

    deviceExtension = DeviceObject->DeviceExtension;

    //
    //  Release the global cancel spinlock.
    //  Do this while not holding any other spinlocks so that we exit at the
    //  right IRQL.
    //
    IoReleaseCancelSpinLock (Irp->CancelIrql);

    //
    // Dequeue and complete the IRP.  The enqueue and dequeue functions
    // synchronize properly so that if this cancel routine is called,
    // the dequeue is safe and only the cancel routine will complete the IRP.
    //
    KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
    KeReleaseSpinLock(&deviceExtension->SpinLock, irql);

    //
    // Complete the IRP.  This is a call outside the driver, so all spinlocks
    // must be released by this point.
    //
    Irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    //
    // Remove the lock we took in the read handler
    //
    IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
}

VOID
MouseClassCleanupQueue (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PDEVICE_EXTENSION    DeviceExtension,
    IN PFILE_OBJECT         FileObject
    )
/*++
Routine Description:

    This does the work of MouseClassCleanup so that we can also do that work
    during remove device for when the grand master isn't enabled.


--*/
{
    PIRP irp;
    LIST_ENTRY listHead, *entry;
    KIRQL irql;

    InitializeListHead (&listHead);

    KeAcquireSpinLock (&DeviceExtension->SpinLock, &irql);

    do {
        irp = MouseClassDequeueReadByFileObject (DeviceExtension, FileObject);
        if (irp) {
            irp->IoStatus.Status = STATUS_CANCELLED;
            irp->IoStatus.Information = 0;

            InsertTailList (&listHead, &irp->Tail.Overlay.ListEntry);
        }
    } while (irp != NULL);

    KeReleaseSpinLock(&DeviceExtension->SpinLock, irql);

    //
    // Complete these irps outside of the spin lock
    //
    while (! IsListEmpty (&listHead)) {
        entry = RemoveHeadList (&listHead);
        irp = CONTAINING_RECORD (entry, IRP, Tail.Overlay.ListEntry);

        IoCompleteRequest (irp, IO_NO_INCREMENT);
        IoReleaseRemoveLock (&DeviceExtension->RemoveLock, irp);
    }
}


NTSTATUS
MouseClassCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for cleanup requests.
    All requests queued to the mouse class device (on behalf of
    the thread for whom the cleanup request was generated) are
    completed with STATUS_CANCELLED.

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PDEVICE_EXTENSION deviceExtension;
    PIO_STACK_LOCATION irpSp;

    MouPrint((2,"MOUCLASS-MouseClassCleanup: enter\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Get a pointer to the current stack location for this request.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // If the file object is the FileTrustedForRead, then the cleanup
    // request is being executed by the trusted subsystem.  Since the
    // trusted subsystem is the only one with sufficient privilege to make
    // Read requests to the driver, and since only Read requests get queued
    // to the device queue, a cleanup request from the trusted subsystem is
    // handled by cancelling all queued requests.
    //
    // If not, there is no cleanup work to perform
    // (only read requests can be cancelled).
    //

    if (IS_TRUSTED_FILE_FOR_READ (irpSp->FileObject)) {

        MouseClassCleanupQueue (DeviceObject, deviceExtension, irpSp->FileObject);
    }

    //
    // Complete the cleanup request with STATUS_SUCCESS.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    MouPrint((2,"MOUCLASS-MouseClassCleanup: exit\n"));

    return(STATUS_SUCCESS);

}

NTSTATUS
MouseClassDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for device control requests.
    All device control subfunctions are passed, asynchronously, to the
    connected port driver for processing and completion.

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION stack;
    PDEVICE_EXTENSION deviceExtension;
    PDEVICE_EXTENSION port;
    NTSTATUS status = STATUS_SUCCESS;
    ULONG unitId;
    ULONG ioctl;

    PAGED_CODE ();

    MouPrint((2,"MOUCLASS-MouseClassDeviceControl: enter\n"));

    //
    // Get a pointer to the device extension.
    //

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    stack = IoGetCurrentIrpStackLocation(Irp);

    status = IoAcquireRemoveLock (&deviceExtension->RemoveLock, Irp);
    if (!NT_SUCCESS (status)) {
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    //
    // Check for adequate input buffer length.  The input buffer
    // should, at a minimum, contain the unit ID specifying one of
    // the connected port devices.  If there is no input buffer (i.e.,
    // the input buffer length is zero), then we assume the unit ID
    // is zero (for backwards compatibility).
    //

    unitId = 0;
    switch (ioctl = stack->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_MOUSE_QUERY_ATTRIBUTES:

        if (stack->Parameters.DeviceIoControl.InputBufferLength == 0) {
            unitId = 0;
        } else if (stack->Parameters.DeviceIoControl.InputBufferLength <
                   sizeof(MOUSE_UNIT_ID_PARAMETER)) {
            status = STATUS_BUFFER_TOO_SMALL;
            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            goto MouseClassDeviceControlReject;

        } else {
            unitId = ((PMOUSE_UNIT_ID_PARAMETER)
                      Irp->AssociatedIrp.SystemBuffer)->UnitId;
        }

        if (deviceExtension->Self != deviceExtension->TrueClassDevice) {
            status = STATUS_NOT_SUPPORTED;
            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            goto MouseClassDeviceControlReject;

        } else if (deviceExtension == Globals.GrandMaster) {
            ExAcquireFastMutex (&Globals.Mutex);
            if (Globals.NumAssocClass <= unitId) {

                ExReleaseFastMutex (&Globals.Mutex);
                status = STATUS_INVALID_PARAMETER;
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                goto MouseClassDeviceControlReject;
            }
            if (0 < Globals.NumAssocClass) {
                if (!PORT_WORKING (&Globals.AssocClassList[unitId])) {
                    unitId = 0;
                }
                while (!PORT_WORKING (&Globals.AssocClassList [unitId])) {
                    if (Globals.NumAssocClass <= unitId) {
                        break;
                    }
                    unitId++;
                }
            }
            if (Globals.NumAssocClass <= unitId) {

                ExReleaseFastMutex (&Globals.Mutex);
                status = STATUS_INVALID_PARAMETER;
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                goto MouseClassDeviceControlReject;
            }
            port = Globals.AssocClassList [unitId].Port;
            stack->FileObject = Globals.AssocClassList[unitId].File;

            ExReleaseFastMutex (&Globals.Mutex);
        } else {
            port = deviceExtension;

        }

        //
        // Pass the device control request on to the port driver,
        // asynchronously.  Get the next IRP stack location and copy the
        // input parameters to the next stack location.  Change the major
        // function to internal device control.
        //

        IoCopyCurrentIrpStackLocationToNext (Irp);
        (IoGetNextIrpStackLocation (Irp))->MajorFunction =
            IRP_MJ_INTERNAL_DEVICE_CONTROL;

        status = IoCallDriver (port->TopPort, Irp);
        break;

    case IOCTL_GET_SYS_BUTTON_CAPS:
    case IOCTL_GET_SYS_BUTTON_EVENT:
    case IOCTL_HID_GET_DRIVER_CONFIG:
    case IOCTL_HID_SET_DRIVER_CONFIG:
    case IOCTL_HID_GET_POLL_FREQUENCY_MSEC:
    case IOCTL_HID_SET_POLL_FREQUENCY_MSEC:
    case IOCTL_GET_NUM_DEVICE_INPUT_BUFFERS:
    case IOCTL_SET_NUM_DEVICE_INPUT_BUFFERS:
    case IOCTL_HID_GET_COLLECTION_INFORMATION:
    case IOCTL_HID_GET_COLLECTION_DESCRIPTOR:
    case IOCTL_HID_FLUSH_QUEUE:
    case IOCTL_HID_SET_FEATURE:
    case IOCTL_HID_GET_FEATURE:
    case IOCTL_GET_PHYSICAL_DESCRIPTOR:
    case IOCTL_HID_GET_HARDWARE_ID:
    case IOCTL_HID_GET_MANUFACTURER_STRING:
    case IOCTL_HID_GET_PRODUCT_STRING:
    case IOCTL_HID_GET_SERIALNUMBER_STRING:
    case IOCTL_HID_GET_INDEXED_STRING:
        if (deviceExtension->PnP && (deviceExtension != Globals.GrandMaster)) {
            IoSkipCurrentIrpStackLocation (Irp);
            status = IoCallDriver (deviceExtension->TopPort, Irp);
            break;
        }

    default:

        status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        break;
    }

MouseClassDeviceControlReject:

    IoReleaseRemoveLock (&deviceExtension->RemoveLock, Irp);

    MouPrint((2,"MOUCLASS-MouseClassDeviceControl: exit\n"));

    return(status);

}

NTSTATUS
MouseClassFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for flush requests.  The class
    input data queue is reinitialized.

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpSp;

    MouPrint((2,"MOUCLASS-MouseClassFlush: enter\n"));

    deviceExtension = DeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation(Irp);

    if (deviceExtension->Self != deviceExtension->TrueClassDevice) {
        status = STATUS_NOT_SUPPORTED;

    } else if (!IS_TRUSTED_FILE_FOR_READ (irpSp->FileObject)) {
        status = STATUS_PRIVILEGE_NOT_HELD;
    }

    if (NT_SUCCESS (status)) {
        //
        // Initialize mouse class input data queue.
        //
        MouInitializeDataQueue((PVOID)deviceExtension);
    }

    //
    // Complete the request and return status.
    //
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    MouPrint((2,"MOUCLASS-MouseClassFlush: exit\n"));

    return(status);

} // end MouseClassFlush

NTSTATUS
MouSyncComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:
    The pnp IRP is in the process of completing.
    signal

Arguments:
    Context set to the device object in question.

--*/
{
    PIO_STACK_LOCATION  stack;

    UNREFERENCED_PARAMETER (DeviceObject);

    stack = IoGetCurrentIrpStackLocation (Irp);

    //
    // Since this completion routines sole purpose in life is to synchronize
    // Irp, we know that unless something else happens that the IoCallDriver
    // will unwind AFTER the we have complete this Irp.  Therefore we should
    // NOT buble up the pending bit.
    //
    //    if (Irp->PendingReturned) {
    //        IoMarkIrpPending( Irp );
    //    }
    //

    KeSetEvent ((PKEVENT) Context, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
MouseSendIrpSynchronously (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN BOOLEAN          CopyToNext
    )
{
    KEVENT      event;
    NTSTATUS    status;

    PAGED_CODE ();

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    if (CopyToNext) {
        IoCopyCurrentIrpStackLocationToNext(Irp);
    }

    IoSetCompletionRoutine(Irp,
                           MouSyncComplete,
                           &event,
                           TRUE,                // on success
                           TRUE,                // on error
                           TRUE                 // on cancel
                           );

    IoCallDriver(DeviceObject, Irp);

    //
    // Wait for lower drivers to be done with the Irp
    //
    KeWaitForSingleObject(&event,
                         Executive,
                         KernelMode,
                         FALSE,
                         NULL
                         );
    status = Irp->IoStatus.Status;

    return status;
}

NTSTATUS
MouseClassCreate (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for create/open and close requests.
    Open/close requests are completed here.

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION   irpSp;
    PDEVICE_EXTENSION    deviceExtension;
    PPORT        port;
    KIRQL        oldIrql;
    NTSTATUS     status = STATUS_SUCCESS;
    ULONG        i;
    LUID         priv;
    KEVENT       event;
    BOOLEAN      someEnableDisableSucceeded = FALSE;
    BOOLEAN      enabled;

    MouPrint((2,"MOUCLASS-MouseClassCreate: enter\n"));

    //
    // Get a pointer to the device extension.
    //

    deviceExtension = DeviceObject->DeviceExtension;


    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    ASSERT (IRP_MJ_CREATE == irpSp->MajorFunction);

    //
    // We do not allow user mode opens for read.  This includes services (who
    // have the TCB privilege).
    //
    if (Irp->RequestorMode == UserMode &&
        (irpSp->Parameters.Create.SecurityContext->DesiredAccess & FILE_READ_DATA)) {
        status = STATUS_ACCESS_DENIED;
        goto MouseClassCreateEnd;
    }

    status = IoAcquireRemoveLock (&deviceExtension->RemoveLock, Irp);

    if (!NT_SUCCESS (status)) {
        goto MouseClassCreateEnd;
    }

    if ((deviceExtension->PnP) && (!deviceExtension->Started)) {
        MouPrint((
            1,
            "MOUCLASS-Create: failed create because PnP and Not started\n"
             ));

        status = STATUS_UNSUCCESSFUL;
        IoReleaseRemoveLock (&deviceExtension->RemoveLock, Irp);
        goto MouseClassCreateEnd;
    }

    //
    // For the create/open operation, send a MOUSE_ENABLE internal
    // device control request to the port driver to enable interrupts.
    //

    if (deviceExtension->Self == deviceExtension->TrueClassDevice) {
        //
        // First, if the requestor is the trusted subsystem (the single
        // reader), reset the the cleanup indicator and place a pointer to
        // the file object which this class driver uses
        // to determine if the requestor has sufficient
        // privilege to perform the read operation).
        //
        // Only allow one trusted subsystem to do READs.
        //

        priv = RtlConvertLongToLuid(SE_TCB_PRIVILEGE);

        if (SeSinglePrivilegeCheck(priv, Irp->RequestorMode)) {

            KeAcquireSpinLock(&deviceExtension->SpinLock, &oldIrql);

            ASSERT (!IS_TRUSTED_FILE_FOR_READ (irpSp->FileObject));
            SET_TRUSTED_FILE_FOR_READ (irpSp->FileObject);
            deviceExtension->TrustedSubsystemCount++;

            KeReleaseSpinLock(&deviceExtension->SpinLock, oldIrql);
        }
    }

    //
    // Pass on enables for opens to the true class device
    //
    ExAcquireFastMutex (&Globals.Mutex);
    if ((Globals.GrandMaster == deviceExtension) && (1 == ++Globals.Opens)) {

        for (i = 0; i < Globals.NumAssocClass; i++) {
            port = &Globals.AssocClassList[i];

            if (port->Free) {
                continue;
            }

            enabled = port->Enabled;
            port->Enabled = TRUE;
            ExReleaseFastMutex (&Globals.Mutex);

            if (!enabled) {
                status = MouEnableDisablePort(TRUE,
                                              Irp,
                                              port->Port,
                                              &port->File);
            }

            if (status != STATUS_SUCCESS) {

                MouPrint((0,
                          "MOUCLASS-MouseClassOpenClose: Could not enable/disable interrupts for port device object @ 0x%x\n",
                          deviceExtension->TopPort));

                MouseClassLogError (DeviceObject,
                                    MOUCLASS_PORT_INTERRUPTS_NOT_ENABLED,
                                    MOUSE_ERROR_VALUE_BASE + 120,
                                    status,
                                    0,
                                    NULL,
                                    irpSp->MajorFunction);

                port->Enabled = FALSE;
            }
            else {
                someEnableDisableSucceeded = TRUE;
            }
            ExAcquireFastMutex (&Globals.Mutex);
        }
        ExReleaseFastMutex (&Globals.Mutex);

    } else if (Globals.GrandMaster != deviceExtension) {
        ExReleaseFastMutex (&Globals.Mutex);

        if (deviceExtension->TrueClassDevice == DeviceObject) {
            //
            // An open to the true class Device => enable the one and only port
            //

            status = MouEnableDisablePort (TRUE,
                                           Irp,
                                           deviceExtension,
                                           &irpSp->FileObject);
        } else {
            IoSkipCurrentIrpStackLocation (Irp);
            status = IoCallDriver (deviceExtension->TopPort, Irp);
            IoReleaseRemoveLock (&deviceExtension->RemoveLock, Irp);
            return status;
        }

        if (status != STATUS_SUCCESS) {

            MouPrint((0,
                      "MOUCLASS-MouseClassOpenClose: Create failed (0x%x) port device object @ 0x%x\n",
                      status, deviceExtension->TopPort));

            //
            // Log an error.
            //
            // Do not log an error for a failed open on a PNP device, esp HID
            // devices which can be easily opened from user mode
            //
#if 0
            MouseClassLogError (DeviceObject,
                                MOUCLASS_PORT_INTERRUPTS_NOT_ENABLED,
                                MOUSE_ERROR_VALUE_BASE + 120,
                                status,
                                0,
                                NULL,
                                irpSp->MajorFunction);
#endif
        }
        else {
            someEnableDisableSucceeded = TRUE;
        }
    } else {
        ExReleaseFastMutex (&Globals.Mutex);
    }

    //
    // Complete the request and return status.
    //
    // NOTE: We complete the request successfully if any one of the
    //       connected port devices successfully handled the request.
    //       The RIT only knows about one pointing device.
    //

    if (someEnableDisableSucceeded) {
        status = STATUS_SUCCESS;
    }

    IoReleaseRemoveLock (&deviceExtension->RemoveLock, Irp);

MouseClassCreateEnd:
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    MouPrint((2,"MOUCLASS-MouseClassOpenClose: exit\n"));
    return(status);
}

NTSTATUS
MouseClassClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for create/open and close requests.
    Open/close requests are completed here.

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION   irpSp;
    PDEVICE_EXTENSION    deviceExtension;
    PPORT        port;
    KIRQL        oldIrql;
    NTSTATUS     status = STATUS_SUCCESS;
    ULONG        i;
    LUID         priv;
    KEVENT       event;
    PFILE_OBJECT file;
    BOOLEAN      someEnableDisableSucceeded = FALSE;
    BOOLEAN      enabled;
    PVOID        notifyHandle;

    MouPrint((2,"MOUCLASS-MouseClassOpenClose: enter\n"));

    //
    // Get a pointer to the device extension.
    //

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Let the close go through even if the device is removed
    // AKA do not call MouIncIoCount
    //

    //
    // For the create/open operation, send a MOUSE_ENABLE internal
    // device control request to the port driver to enable interrupts.
    //

    ASSERT (IRP_MJ_CLOSE == irpSp->MajorFunction);

    if (deviceExtension->Self == deviceExtension->TrueClassDevice) {
        KeAcquireSpinLock(&deviceExtension->SpinLock, &oldIrql);
        if (IS_TRUSTED_FILE_FOR_READ (irpSp->FileObject)) {
            ASSERT(0 < deviceExtension->TrustedSubsystemCount);
            deviceExtension->TrustedSubsystemCount--;
            CLEAR_TRUSTED_FILE_FOR_READ (irpSp->FileObject);
        }
        KeReleaseSpinLock(&deviceExtension->SpinLock, oldIrql);
    }

    //
    // Pass on enables for closes to the true class device
    //
    ExAcquireFastMutex (&Globals.Mutex);
    if ((Globals.GrandMaster == deviceExtension) && (0 == --Globals.Opens)) {

        for (i = 0; i < Globals.NumAssocClass; i++) {
            port = &Globals.AssocClassList[i];

            if (port->Free) {
                continue;
            }

            enabled = port->Enabled;
            port->Enabled = FALSE;
            ExReleaseFastMutex (&Globals.Mutex);

            if (enabled) {
                notifyHandle = InterlockedExchangePointer (
                                    &port->Port->TargetNotifyHandle,
                                    NULL);

                if (NULL != notifyHandle) {
                    IoUnregisterPlugPlayNotification (notifyHandle);
                }
                status = MouEnableDisablePort(FALSE,
                                              Irp,
                                              port->Port,
                                              &port->File);
            } else {
                ASSERT (NULL == port->Port->TargetNotifyHandle);
            }

            if (status != STATUS_SUCCESS) {

                MouPrint((0,
                          "MOUCLASS-MouseClassOpenClose: Could not enable/disable interrupts for port device object @ 0x%x\n",
                          port->Port->TopPort));

                //
                // Log an error.
                //
                MouseClassLogError (DeviceObject,
                                    MOUCLASS_PORT_INTERRUPTS_NOT_DISABLED,
                                    MOUSE_ERROR_VALUE_BASE + 120,
                                    status,
                                    0,
                                    NULL,
                                    irpSp->MajorFunction);

                ASSERTMSG ("Could not close open port!", FALSE);
            }
            else {
                someEnableDisableSucceeded = TRUE;
            }
            ExAcquireFastMutex (&Globals.Mutex);
        }
        ExReleaseFastMutex (&Globals.Mutex);

    } else if (Globals.GrandMaster != deviceExtension) {
        ExReleaseFastMutex (&Globals.Mutex);

        if (deviceExtension->TrueClassDevice == DeviceObject) {
            //
            // A close to the true class Device => disable the one and only port
            //

            status = MouEnableDisablePort (FALSE,
                                           Irp,
                                           deviceExtension,
                                           &irpSp->FileObject);
        } else {
            IoSkipCurrentIrpStackLocation (Irp);
            status = IoCallDriver (deviceExtension->TopPort, Irp);
            return status;
        }

        if (status != STATUS_SUCCESS) {

            MouPrint((0,
                      "MOUCLASS-MouseClassOpenClose: Could not enable/disable interrupts for port device object @ 0x%x\n",
                      deviceExtension->TopPort));

            //
            // Log an error.
            //
            MouseClassLogError (DeviceObject,
                                MOUCLASS_PORT_INTERRUPTS_NOT_DISABLED,
                                MOUSE_ERROR_VALUE_BASE + 120,
                                status,
                                0,
                                NULL,
                                irpSp->MajorFunction);
        }
        else {
            someEnableDisableSucceeded = TRUE;
        }
    } else {
        ExReleaseFastMutex (&Globals.Mutex);
    }

    //
    // Complete the request and return status.
    //
    // NOTE: We complete the request successfully if any one of the
    //       connected port devices successfully handled the request.
    //       The RIT only knows about one pointing device.
    //

    if (someEnableDisableSucceeded) {
        status = STATUS_SUCCESS;
    }

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    MouPrint((2,"MOUCLASS-MouseClassOpenClose: exit\n"));
    return(status);
}

NTSTATUS
MouseClassReadCopyData(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    )
/*++

Routine Description:
    Copies data as much from the internal queue to the irp as possible.

Assumptions:
    DeviceExtension->SpinLock is already held (so no further synch is required).

  --*/
{
    PIO_STACK_LOCATION irpSp;
    PCHAR destination;
    ULONG bytesInQueue;
    ULONG bytesToMove;
    ULONG moveSize;

    //
    // Bump the error log sequence number.
    //
    DeviceExtension->SequenceNumber += 1;

    //
    // Copy as much of the input data as possible from the class input
    // data queue to the SystemBuffer to satisfy the read.  It may be
    // necessary to copy the data in two chunks (i.e., if the circular
    // queue wraps).
    //
    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // bytesToMove <- MIN(Number of filled bytes in class input data queue,
    //                    Requested read length).
    //
    bytesInQueue = DeviceExtension->InputCount *
                       sizeof(MOUSE_INPUT_DATA);
    bytesToMove = irpSp->Parameters.Read.Length;

    MouPrint((
        3,
        "MOUCLASS-MouseClassCopyReadData: queue size 0x%lx, read length 0x%lx\n",
        bytesInQueue,
        bytesToMove
        ));

    bytesToMove = (bytesInQueue < bytesToMove) ?
                                  bytesInQueue:bytesToMove;

    //
    // moveSize <- MIN(Number of bytes to be moved from the class queue,
    //                 Number of bytes to end of class input data queue).
    //
    bytesInQueue = (ULONG)(((PCHAR) DeviceExtension->InputData +
                DeviceExtension->MouseAttributes.InputDataQueueLength) -
                (PCHAR) DeviceExtension->DataOut);
    moveSize = (bytesToMove < bytesInQueue) ?
                              bytesToMove:bytesInQueue;

    MouPrint((
        3,
        "MOUCLASS-MouseClassCopyReadData: bytes to end of queue 0x%lx\n",
        bytesInQueue
        ));

    //
    // Move bytes from the class input data queue to SystemBuffer, until
    // the request is satisfied or we wrap the class input data buffer.
    //
    destination = Irp->AssociatedIrp.SystemBuffer;

    MouPrint((
        3,
        "MOUCLASS-MouseClassCopyReadData: number of bytes in first move 0x%lx\n",
        moveSize
        ));
    MouPrint((
        3,
        "MOUCLASS-MouseClassCopyReadData: move bytes from 0x%lx to 0x%lx\n",
        (PCHAR) DeviceExtension->DataOut,
        destination
        ));

    RtlMoveMemory(
        destination,
        (PCHAR) DeviceExtension->DataOut,
        moveSize
        );
    destination += moveSize;

    //
    // If the data wraps in the class input data buffer, copy the rest
    // of the data from the start of the input data queue
    // buffer through the end of the queued data.
    //
    if ((bytesToMove - moveSize) > 0) {
        //
        // moveSize <- Remaining number bytes to move.
        //
        moveSize = bytesToMove - moveSize;

        //
        // Move the bytes from the class input data queue to SystemBuffer.
        //
        MouPrint((
            3,
            "MOUCLASS-MouseClassCopyReadData: number of bytes in second move 0x%lx\n",
            moveSize
            ));
        MouPrint((
            3,
            "MOUCLASS-MouseClassCopyReadData: move bytes from 0x%lx to 0x%lx\n",
            (PCHAR) DeviceExtension->InputData,
            destination
            ));

        RtlMoveMemory(
            destination,
            (PCHAR) DeviceExtension->InputData,
            moveSize
            );

        //
        // Update the class input data queue removal pointer.
        //
        DeviceExtension->DataOut = (PMOUSE_INPUT_DATA)
                         (((PCHAR) DeviceExtension->InputData) + moveSize);
    }
    else {
        //
        // Update the input data queue removal pointer.
        //
        DeviceExtension->DataOut = (PMOUSE_INPUT_DATA)
                         (((PCHAR) DeviceExtension->DataOut) + moveSize);
    }

    //
    // Update the class input data queue InputCount.
    //
    DeviceExtension->InputCount -=
        (bytesToMove / sizeof(MOUSE_INPUT_DATA));

    if (DeviceExtension->InputCount == 0) {
        //
        // Reset the flag that determines whether it is time to log
        // queue overflow errors.  We don't want to log errors too often.
        // Instead, log an error on the first overflow that occurs after
        // the ring buffer has been emptied, and then stop logging errors
        // until it gets cleared out and overflows again.
        //
        MouPrint((
            1,
            "MOUCLASS-MouseClassCopyReadData: Okay to log overflow\n"
            ));

        DeviceExtension->OkayToLogOverflow = TRUE;
    }

    MouPrint((
        3,
        "MOUCLASS-MouseClassCopyReadData: new DataIn 0x%lx, DataOut 0x%lx\n",
        DeviceExtension->DataIn,
        DeviceExtension->DataOut
        ));
    MouPrint((
        3,
        "MOUCLASS-MouseClassCopyReadData: new InputCount %ld\n",
        DeviceExtension->InputCount
        ));

    //
    // Record how many bytes we have satisfied
    //
    Irp->IoStatus.Information = bytesToMove;
    irpSp->Parameters.Read.Length = bytesToMove;

    return STATUS_SUCCESS;
}

NTSTATUS
MouseClassHandleRead(
    PDEVICE_EXTENSION DeviceExtension,
    PIRP Irp
    )
/*++

Routine Description:

    If there is queued data, the Irp will be completed immediately.  If there is
    no data to report, queue the irp.

  --*/
{
    PDRIVER_CANCEL oldCancelRoutine;
    NTSTATUS status = STATUS_PENDING;
    KIRQL irql;
    BOOLEAN completeIrp = FALSE;

    KeAcquireSpinLock(&DeviceExtension->SpinLock, &irql);

    if (DeviceExtension->InputCount == 0) {
        //
        // Easy case to handle, just enqueue the irp
        //
        InsertTailList (&DeviceExtension->ReadQueue, &Irp->Tail.Overlay.ListEntry);
        IoMarkIrpPending (Irp);

        //
        //  Must set a cancel routine before checking the Cancel flag.
        //
        oldCancelRoutine = IoSetCancelRoutine (Irp, MouseClassCancel);
        ASSERT (!oldCancelRoutine);

        if (Irp->Cancel) {
            //
            // The IRP was cancelled.  Check whether or not the cancel
            // routine was called.
            //
            oldCancelRoutine = IoSetCancelRoutine (Irp, NULL);
            if (oldCancelRoutine) {
                //
                // The cancel routine was NOT called so dequeue the IRP now and
                // complete it after releasing the spinlock.
                //
                RemoveEntryList (&Irp->Tail.Overlay.ListEntry);
                status = Irp->IoStatus.Status = STATUS_CANCELLED;
            }
            else {
                //
                //  The cancel routine WAS called.
                //
                //  As soon as we drop the spinlock it will dequeue and complete
                //  the IRP. So leave the IRP in the queue and otherwise don't
                //  touch it. Return pending since we're not completing the IRP
                //  here.
                //
                ;
            }
        }

        if (status != STATUS_PENDING){
            completeIrp = TRUE;
        }
    }
    else {
        //
        // If we have outstanding input to report, our queue better be empty!
        //
        ASSERT (IsListEmpty (&DeviceExtension->ReadQueue));

        status = MouseClassReadCopyData (DeviceExtension, Irp);
        Irp->IoStatus.Status = status;
        completeIrp = TRUE;
    }

    KeReleaseSpinLock(&DeviceExtension->SpinLock, irql);

    if (completeIrp) {
        IoReleaseRemoveLock (&DeviceExtension->RemoveLock, Irp);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return status;
}


NTSTATUS
MouseClassRead(
    IN PDEVICE_OBJECT Device,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for read requests.  Valid read
    requests are either marked pending if no data has been queued or completed
    immediatedly with available data.

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_EXTENSION  deviceExtension;

    MouPrint((2,"MOUCLASS-MouseClassRead: enter\n"));

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Validate the read request parameters.  The read length should be an
    // integral number of MOUSE_INPUT_DATA structures.
    //

    deviceExtension = (PDEVICE_EXTENSION) Device->DeviceExtension;
    if (irpSp->Parameters.Read.Length == 0) {
        status = STATUS_SUCCESS;
    } else if (irpSp->Parameters.Read.Length % sizeof(MOUSE_INPUT_DATA)) {
        status = STATUS_BUFFER_TOO_SMALL;
    } else if (deviceExtension->SurpriseRemoved) {
        status = STATUS_DEVICE_NOT_CONNECTED;
    } else if (IS_TRUSTED_FILE_FOR_READ (irpSp->FileObject)) {
        //
        // If the file object's FsContext is non-null, then we've already
        // done the Read privilege check once before for this thread.  Skip
        // the privilege check.
        //

        deviceExtension = (PDEVICE_EXTENSION) Device->DeviceExtension;
        status = IoAcquireRemoveLock (&deviceExtension->RemoveLock, Irp);

        if (NT_SUCCESS (status)) {
            status = STATUS_PENDING;
        }
    } else {
        //
        // We only allow a trusted subsystem with the appropriate privilege
        // level to execute a Read call.
        //
        status = STATUS_PRIVILEGE_NOT_HELD;
    }

    //
    // If status is pending, mark the packet pending and start the packet
    // in a cancellable state.  Otherwise, complete the request.
    //

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    if (status == STATUS_PENDING) {
        return MouseClassHandleRead(deviceExtension, Irp);
    }
    else {
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    MouPrint((2,"MOUCLASS-MouseClassRead: exit\n"));

    return status;
}

PIRP
MouseClassDequeueRead(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:
    Dequeues the next available read irp regardless of FileObject

Assumptions:
    DeviceExtension->SpinLock is already held (so no further sync is required).

  --*/
{
    PIRP nextIrp = NULL;
    KIRQL oldIrql;

    while (!nextIrp && !IsListEmpty (&DeviceExtension->ReadQueue)){
        PDRIVER_CANCEL oldCancelRoutine;
        PLIST_ENTRY listEntry = RemoveHeadList (&DeviceExtension->ReadQueue);

        //
        // Get the next IRP off the queue and clear the cancel routine
        //
        nextIrp = CONTAINING_RECORD (listEntry, IRP, Tail.Overlay.ListEntry);
        oldCancelRoutine = IoSetCancelRoutine (nextIrp, NULL);

        //
        // IoCancelIrp() could have just been called on this IRP.
        // What we're interested in is not whether IoCancelIrp() was called
        // (ie, nextIrp->Cancel is set), but whether IoCancelIrp() called (or
        // is about to call) our cancel routine. To check that, check the result
        // of the test-and-set macro IoSetCancelRoutine.
        //
        if (oldCancelRoutine) {
            //
            //  Cancel routine not called for this IRP.  Return this IRP.
            //
            ASSERT (oldCancelRoutine == MouseClassCancel);
        }
        else {
            //
            // This IRP was just cancelled and the cancel routine was (or will
            // be) called. The cancel routine will complete this IRP as soon as
            // we drop the spinlock. So don't do anything with the IRP.
            //
            // Also, the cancel routine will try to dequeue the IRP, so make the
            // IRP's listEntry point to itself.
            //
            ASSERT (nextIrp->Cancel);
            InitializeListHead (&nextIrp->Tail.Overlay.ListEntry);
            nextIrp = NULL;
        }
    }

    return nextIrp;
}

PIRP
MouseClassDequeueReadByFileObject(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PFILE_OBJECT FileObject
    )
/*++

Routine Description:
    Dequeues the next available read with a matching FileObject

Assumptions:
    DeviceExtension->SpinLock is already held (so no further sync is required).

  --*/
{
    PIRP                irp = NULL;
    PLIST_ENTRY         entry;
    PIO_STACK_LOCATION  stack;
    PDRIVER_CANCEL      oldCancelRoutine;
    KIRQL oldIrql;

    if (FileObject == NULL) {
        return MouseClassDequeueRead (DeviceExtension);
    }

    for (entry = DeviceExtension->ReadQueue.Flink;
         entry != &DeviceExtension->ReadQueue;
         entry = entry->Flink) {

        irp = CONTAINING_RECORD (entry, IRP, Tail.Overlay.ListEntry);
        stack = IoGetCurrentIrpStackLocation (irp);
        if (stack->FileObject == FileObject) {
            RemoveEntryList (entry);

            oldCancelRoutine = IoSetCancelRoutine (irp, NULL);

            //
            // IoCancelIrp() could have just been called on this IRP.
            // What we're interested in is not whether IoCancelIrp() was called
            // (ie, nextIrp->Cancel is set), but whether IoCancelIrp() called (or
            // is about to call) our cancel routine. To check that, check the result
            // of the test-and-set macro IoSetCancelRoutine.
            //
            if (oldCancelRoutine) {
                //
                //  Cancel routine not called for this IRP.  Return this IRP.
                //
                return irp;
            }
            else {
                //
                // This IRP was just cancelled and the cancel routine was (or will
                // be) called. The cancel routine will complete this IRP as soon as
                // we drop the spinlock. So don't do anything with the IRP.
                //
                // Also, the cancel routine will try to dequeue the IRP, so make the
                // IRP's listEntry point to itself.
                //
                ASSERT (irp->Cancel);
                InitializeListHead (&irp->Tail.Overlay.ListEntry);
            }
        }
    }

    return NULL;
}


VOID
MouseClassServiceCallback(
    IN PDEVICE_OBJECT DeviceObject,
    IN PMOUSE_INPUT_DATA InputDataStart,
    IN PMOUSE_INPUT_DATA InputDataEnd,
    IN OUT PULONG InputDataConsumed
    )

/*++

Routine Description:

    This routine is the class service callback routine.  It is
    called from the port driver's interrupt service DPC.  If there is an
    outstanding read request, the request is satisfied from the port input
    data queue.  Unsolicited mouse input is moved from the port input
    data queue to the class input data queue.

    N.B.  This routine is entered at DISPATCH_LEVEL IRQL from the port
          driver's ISR DPC routine.

Arguments:

    DeviceObject - Pointer to class device object.

    InputDataStart - Pointer to the start of the data in the port input
        data queue.

    InputDataEnd - Points one input data structure past the end of the
        valid port input data.

    InputDataConsumed - Pointer to storage in which the number of input
        data structures consumed by this call is returned.

    NOTE:  Could pull the duplicate code out into a called procedure.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION deviceExtension;
    PIO_STACK_LOCATION irpSp;
    LIST_ENTRY listHead;
    PIRP  irp;
    ULONG bytesInQueue;
    ULONG bytesToMove;
    ULONG moveSize;
    ULONG dumpData[2];
    BOOLEAN logOverflow;

    MouPrint((2,"MOUCLASS-MouseClassServiceCallback: enter\n"));

    deviceExtension = DeviceObject->DeviceExtension;
    bytesInQueue = (ULONG)((PCHAR) InputDataEnd - (PCHAR) InputDataStart);
    moveSize = 0;
    *InputDataConsumed = 0;

    logOverflow = FALSE;

    if ((InputDataEnd == InputDataStart + 1) &&
        (InputDataStart->Flags & MOUSE_ATTRIBUTES_CHANGED)) {
        //
        // This is a notification packet that is not indicative of the user
        // being present.  It is instead just a blank packet for the Raw
        // Input User Thread.
        //
        // We will pass it on, but we will not treat this as human input.
        //

        ;
    } else {
        //
        // Notify system that human input has occured
        //

        PoSetSystemState (ES_USER_PRESENT);
    }

    //
    // N.B. We can use KeAcquireSpinLockAtDpcLevel, instead of
    //      KeAcquireSpinLock, because this routine is already running
    //      at DISPATCH_IRQL.
    //

    KeAcquireSpinLockAtDpcLevel (&deviceExtension->SpinLock);

    InitializeListHead (&listHead);
    irp = MouseClassDequeueRead (deviceExtension);
    if (irp) {
        //
        // An outstanding read request exists.
        //
        // Copy as much of the input data possible from the port input
        // data queue to the SystemBuffer to satisfy the read.
        //
        irpSp = IoGetCurrentIrpStackLocation (irp);
        bytesToMove = irpSp->Parameters.Read.Length;
        moveSize = (bytesInQueue < bytesToMove) ? bytesInQueue
                                                : bytesToMove;

        *InputDataConsumed += (moveSize / sizeof(MOUSE_INPUT_DATA));

        MouPrint((
            3,
            "MOUCLASS-MouseClassServiceCallback: port queue length 0x%lx, read length 0x%lx\n",
            bytesInQueue,
            bytesToMove
            ));
        MouPrint((
            3,
            "MOUCLASS-MouseClassServiceCallback: number of bytes to move from port to SystemBuffer 0x%lx\n",
            moveSize
            ));
        MouPrint((
            3,
            "MOUCLASS-MouseClassServiceCallback: move bytes from 0x%lx to 0x%lx\n",
            (PCHAR) InputDataStart,
            irp->AssociatedIrp.SystemBuffer
            ));

        RtlMoveMemory(
            irp->AssociatedIrp.SystemBuffer,
            (PCHAR) InputDataStart,
            moveSize
            );

        //
        // Set the flag so that we start the next packet and complete
        // this read request (with STATUS_SUCCESS) prior to return.
        //
        irp->IoStatus.Status = STATUS_SUCCESS;
        irp->IoStatus.Information = moveSize;
        irpSp->Parameters.Read.Length = moveSize;

        InsertTailList (&listHead, &irp->Tail.Overlay.ListEntry);
    }

    //
    // If there is still data in the port input data queue, move it to the class
    // input data queue.
    //
    InputDataStart = (PMOUSE_INPUT_DATA) ((PCHAR) InputDataStart + moveSize);
    moveSize = bytesInQueue - moveSize;
    MouPrint((
        3,
        "MOUCLASS-MouseClassServiceCallback: bytes remaining after move to SystemBuffer 0x%lx\n",
        moveSize
        ));

    if (moveSize > 0) {

        //
        // Move the remaining data from the port input data queue to
        // the class input data queue.  The move will happen in two
        // parts in the case where the class input data buffer wraps.
        //

        bytesInQueue =
            deviceExtension->MouseAttributes.InputDataQueueLength -
            (deviceExtension->InputCount * sizeof(MOUSE_INPUT_DATA));
        bytesToMove = moveSize;

        MouPrint((
            3,
            "MOUCLASS-MouseClassServiceCallback: unused bytes in class queue 0x%lx, remaining bytes in port queue 0x%lx\n",
            bytesInQueue,
            bytesToMove
            ));

#if ALLOW_OVERFLOW
#else
        if (bytesInQueue == 0) {

            //
            // Refuse to move any bytes that would cause a class input data
            // queue overflow.  Just drop the bytes on the floor, and
            // log an overrun error.
            //

            MouPrint((
                1,
                "MOUCLASS-MouseClassServiceCallback: Class input data queue OVERRUN\n"
                ));

            if (deviceExtension->OkayToLogOverflow) {
                //
                // Allocate and report the error log entry outside of any locks
                // we are currently holding
                //
                logOverflow = TRUE
                dumpData[0] = bytesToMove;
                dumpData[1] =
                    deviceExtension->MouseAttributes.InputDataQueueLength;


                deviceExtension->OkayToLogOverflow = FALSE;
            }

        } else {
#endif

            //
            // There is room in the class input data queue, so move
            // the remaining port input data to it.
            //
            // bytesToMove <- MIN(Number of unused bytes in class input data
            //                    queue, Number of bytes remaining in port
            //                    input queue).
            // This is the total number of bytes that actually will move from
            // the port input data queue to the class input data queue.
            //

#if ALLOW_OVERFLOW
            bytesInQueue = deviceExtension->MouseAttributes.InputDataQueueLength;
#endif
            bytesToMove = (bytesInQueue < bytesToMove) ?
                                          bytesInQueue:bytesToMove;


            //
            // bytesInQueue <- Number of unused bytes from insertion pointer to
            // the end of the class input data queue (i.e., until the buffer
            // wraps).
            //

            bytesInQueue = (ULONG)(((PCHAR) deviceExtension->InputData +
                        deviceExtension->MouseAttributes.InputDataQueueLength) -
                        (PCHAR) deviceExtension->DataIn);

            MouPrint((
                3,
                "MOUCLASS-MouseClassServiceCallback: total number of bytes to move to class queue 0x%lx\n",
                bytesToMove
                ));

            MouPrint((
                3,
                "MOUCLASS-MouseClassServiceCallback: number of bytes to end of class buffer 0x%lx\n",
                bytesInQueue
                ));

            //
            // moveSize <- Number of bytes to handle in the first move.
            //

            moveSize = (bytesToMove < bytesInQueue) ?
                                      bytesToMove:bytesInQueue;

            MouPrint((
                3,
                "MOUCLASS-MouseClassServiceCallback: number of bytes in first move to class 0x%lx\n",
                moveSize
                ));

            //
            // Do the move from the port data queue to the class data queue.
            //

            MouPrint((
                3,
                "MOUCLASS-MouseClassServiceCallback: move bytes from 0x%lx to 0x%lx\n",
                (PCHAR) InputDataStart,
                (PCHAR) deviceExtension->DataIn
                ));

            RtlMoveMemory(
                (PCHAR) deviceExtension->DataIn,
                (PCHAR) InputDataStart,
                moveSize
                );

            //
            // Increment the port data queue pointer and the class input
            // data queue insertion pointer.  Wrap the insertion pointer,
            // if necessary.
            //

            InputDataStart = (PMOUSE_INPUT_DATA)
                             (((PCHAR) InputDataStart) + moveSize);
            deviceExtension->DataIn = (PMOUSE_INPUT_DATA)
                                 (((PCHAR) deviceExtension->DataIn) + moveSize);

            if ((PCHAR) deviceExtension->DataIn >=
                ((PCHAR) deviceExtension->InputData +
                 deviceExtension->MouseAttributes.InputDataQueueLength)) {
                deviceExtension->DataIn = deviceExtension->InputData;
            }

            if ((bytesToMove - moveSize) > 0) {

                //
                // Special case.  The data must wrap in the class input data buffer.
                // Copy the rest of the port input data into the beginning of the
                // class input data queue.
                //

                //
                // moveSize <- Number of bytes to handle in the second move.
                //

                moveSize = bytesToMove - moveSize;

                //
                // Do the move from the port data queue to the class data queue.
                //

                MouPrint((
                    3,
                    "MOUCLASS-MouseClassServiceCallback: number of bytes in second move to class 0x%lx\n",
                    moveSize
                    ));
                MouPrint((
                    3,
                    "MOUCLASS-MouseClassServiceCallback: move bytes from 0x%lx to 0x%lx\n",
                    (PCHAR) InputDataStart,
                    (PCHAR) deviceExtension->DataIn
                    ));

                RtlMoveMemory(
                    (PCHAR) deviceExtension->DataIn,
                    (PCHAR) InputDataStart,
                    moveSize
                    );

                //
                // Update the class input data queue insertion pointer.
                //

                deviceExtension->DataIn = (PMOUSE_INPUT_DATA)
                                 (((PCHAR) deviceExtension->DataIn) + moveSize);
            }

            //
            // Update the input data queue counter.
            //

            deviceExtension->InputCount +=
                    (bytesToMove / sizeof(MOUSE_INPUT_DATA));
            *InputDataConsumed += (bytesToMove / sizeof(MOUSE_INPUT_DATA));

            MouPrint((
                3,
                "MOUCLASS-MouseClassServiceCallback: changed InputCount to %ld entries in the class queue\n",
                deviceExtension->InputCount
                ));
            MouPrint((
                3,
                "MOUCLASS-MouseClassServiceCallback: DataIn 0x%lx, DataOut 0x%lx\n",
                deviceExtension->DataIn,
                deviceExtension->DataOut
                ));
            MouPrint((
                3,
                "MOUCLASS-MouseClassServiceCallback: Input data items consumed = %d\n",
                *InputDataConsumed
                ));
#if ALLOW_OVERFLOW
#else
        }
#endif

    }

    //
    // If we still have data in our internal queue, fulfill any outstanding
    // reads now until either we run out of data or outstanding reads
    //
    while (deviceExtension->InputCount > 0 &&
           (irp = MouseClassDequeueRead (deviceExtension)) != NULL) {
        irp->IoStatus.Status = MouseClassReadCopyData (deviceExtension, irp);
        InsertTailList (&listHead, &irp->Tail.Overlay.ListEntry);
    }

    //
    // Release the class input data queue spinlock.
    //
    KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);

    if (logOverflow) {
        MouseClassLogError (DeviceObject,
                            MOUCLASS_MOU_BUFFER_OVERFLOW,
                            MOUSE_ERROR_VALUE_BASE + 210,
                            0,
                            2,
                            dumpData,
                            0);
    }

    //
    // Complete all the read requests we have fulfilled outside of the spin lock
    //
    while (! IsListEmpty (&listHead)) {
        PLIST_ENTRY entry = RemoveHeadList (&listHead);

        irp = CONTAINING_RECORD (entry, IRP, Tail.Overlay.ListEntry);
        ASSERT (NT_SUCCESS (irp->IoStatus.Status) &&
                irp->IoStatus.Status != STATUS_PENDING);
        IoCompleteRequest (irp, IO_KEYBOARD_INCREMENT);

        IoReleaseRemoveLock (&deviceExtension->RemoveLock, irp);
    }

    MouPrint((2,"MOUCLASS-MouseClassServiceCallback: exit\n"));
}

VOID
MouseClassUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine is the class driver unload routine.

    NOTE:  Not currently implemented.

Arguments:

    DeviceObject - Pointer to class device object.

Return Value:

    None.

--*/

{
    PLIST_ENTRY entry;
    PDEVICE_EXTENSION data;
    PPORT port;
    PIRP irp;

    UNREFERENCED_PARAMETER(DriverObject);

    PAGED_CODE ();

    MouPrint((2,"MOUCLASS-MouseClassUnload: enter\n"));

    //
    // Delete all of our legacy devices
    //
    for (entry = Globals.LegacyDeviceList.Flink;
         entry != &Globals.LegacyDeviceList;
         /* advance to next before deleting the devobj */) {

        BOOLEAN enabled = FALSE;
        PFILE_OBJECT file = NULL;

        data = CONTAINING_RECORD (entry, DEVICE_EXTENSION, Link);
        ASSERT (data->PnP == FALSE);

        if (Globals.GrandMaster) {
            port = &Globals.AssocClassList[data->UnitId];
            ASSERT (port->Port == data);

            enabled = port->Enabled;
            file = port->File;

            port->Enabled = FALSE;
            port->File = NULL;
            port->Free = TRUE;
        }
        else {
            enabled = data->Enabled;
            file = data->File;
            ASSERT (data->File);
            data->Enabled = FALSE;
        }

        if (enabled) {
            irp = IoAllocateIrp(data->TopPort->StackSize+1, FALSE);
            if (irp) {
                MouEnableDisablePort (FALSE, irp, data, &file);
                IoFreeIrp (irp);
            }
        }

        //
        // This file object represents the open we performed on the legacy
        // port device object.  It does NOT represent the open that the RIT
        // performed on our DO.
        //
        if (file) {
            ObDereferenceObject(file);
        }


        //
        // Clean out the queue only if there is no GM
        //
        if (Globals.GrandMaster == NULL) {
            MouseClassCleanupQueue (data->Self, data, NULL);
        }

        RemoveEntryList (&data->Link);
        entry = entry->Flink;

        MouseClassDeleteLegacyDevice (data);
    }

    //
    // Delete the grandmaster if it exists
    //
    if (Globals.GrandMaster) {
        data = Globals.GrandMaster;
        Globals.GrandMaster = NULL;

        MouseClassCleanupQueue (data->Self, data, NULL);
        MouseClassDeleteLegacyDevice (data);
    }

    ExFreePool(Globals.RegistryPath.Buffer);
    if (Globals.AssocClassList) {
#if DBG
        ULONG i;

        for (i = 0; i < Globals.NumAssocClass; i++) {
            ASSERT (Globals.AssocClassList[i].Free == TRUE);
            ASSERT (Globals.AssocClassList[i].Enabled == FALSE);
            ASSERT (Globals.AssocClassList[i].File == NULL);
        }
#endif

        ExFreePool(Globals.AssocClassList);
    }

    MouPrint((2,"MOUCLASS-MouseClassUnload: exit\n"));
}

VOID
MouConfiguration()

/*++

Routine Description:

    This routine stores the configuration information for this device.

Return Value:

    None.  As a side-effect, sets fields in DeviceExtension->MouseAttributes.


--*/

{
    PRTL_QUERY_REGISTRY_TABLE parameters = NULL;
    ULONG defaultDataQueueSize = DATA_QUEUE_SIZE;
    ULONG defaultMaximumPortsServiced = 1;
    ULONG defaultConnectMultiplePorts = 0;

    NTSTATUS status = STATUS_SUCCESS;
    UNICODE_STRING parametersPath;
    UNICODE_STRING defaultUnicodeName;
    PWSTR path = NULL;
    USHORT queriesPlusOne = 5;

    PAGED_CODE ();

    parametersPath.Buffer = NULL;

    //
    // Registry path is already null-terminated, so just use it.
    //

    path = Globals.RegistryPath.Buffer;

    //
    // Allocate the Rtl query table.
    //

    parameters = ExAllocatePool(
                     PagedPool,
                     sizeof(RTL_QUERY_REGISTRY_TABLE) * queriesPlusOne
                     );

    if (!parameters) {

        MouPrint((
            1,
            "MOUCLASS-MouConfiguration: Couldn't allocate table for Rtl query to parameters for %ws\n",
             path
             ));

        status = STATUS_UNSUCCESSFUL;

    } else {

        RtlZeroMemory(
            parameters,
            sizeof(RTL_QUERY_REGISTRY_TABLE) * queriesPlusOne
            );

        //
        // Form a path to this driver's Parameters subkey.
        //

        RtlInitUnicodeString(
            &parametersPath,
            NULL
            );

        parametersPath.MaximumLength = Globals.RegistryPath.Length +
                                       sizeof(L"\\Parameters");

        parametersPath.Buffer = ExAllocatePool(
                                    PagedPool,
                                    parametersPath.MaximumLength
                                    );

        if (!parametersPath.Buffer) {

            MouPrint((
                1,
                "MOUCLASS-MouConfiguration: Couldn't allocate string for path to parameters for %ws\n",
                 path
                ));

            status = STATUS_UNSUCCESSFUL;

        }
    }

    if (NT_SUCCESS(status)) {

        //
        // Form the parameters path.
        //

        RtlZeroMemory(parametersPath.Buffer, parametersPath.MaximumLength);
        RtlAppendUnicodeToString(&parametersPath, path);
        RtlAppendUnicodeToString(&parametersPath, L"\\Parameters");

        MouPrint((
            1,
            "MOUCLASS-MouConfiguration: parameters path is %ws\n",
             parametersPath.Buffer
            ));

        //
        // Form the default pointer class device name, in case it is not
        // specified in the registry.
        //

        RtlInitUnicodeString(
            &defaultUnicodeName,
            DD_POINTER_CLASS_BASE_NAME_U
            );

        //
        // Gather all of the "user specified" information from
        // the registry.
        //

        parameters[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[0].Name = L"MouseDataQueueSize";
        parameters[0].EntryContext =
            &Globals.InitExtension.MouseAttributes.InputDataQueueLength;
        parameters[0].DefaultType = REG_DWORD;
        parameters[0].DefaultData = &defaultDataQueueSize;
        parameters[0].DefaultLength = sizeof(ULONG);

        parameters[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[1].Name = L"MaximumPortsServiced";
        parameters[1].EntryContext = &Globals.PortsServiced;
        parameters[1].DefaultType = REG_DWORD;
        parameters[1].DefaultData = &defaultMaximumPortsServiced;
        parameters[1].DefaultLength = sizeof(ULONG);

        parameters[2].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[2].Name = L"PointerDeviceBaseName";
        parameters[2].EntryContext = &Globals.BaseClassName;
        parameters[2].DefaultType = REG_SZ;
        parameters[2].DefaultData = defaultUnicodeName.Buffer;
        parameters[2].DefaultLength = 0;

        parameters[3].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[3].Name = L"ConnectMultiplePorts";
        parameters[3].EntryContext = &Globals.ConnectOneClassToOnePort;
        parameters[3].DefaultType = REG_DWORD;
        parameters[3].DefaultData = &defaultConnectMultiplePorts;
        parameters[3].DefaultLength = sizeof(ULONG);

        status = RtlQueryRegistryValues(
                     RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                     parametersPath.Buffer,
                     parameters,
                     NULL,
                     NULL
                     );

        if (!NT_SUCCESS(status)) {
            MouPrint((
                1,
                "MOUCLASS-MouConfiguration: RtlQueryRegistryValues failed with 0x%x\n",
                status
                ));
        }
    }

    if (!NT_SUCCESS(status)) {

        //
        // Go ahead and assign driver defaults.
        //

        Globals.InitExtension.MouseAttributes.InputDataQueueLength =
            defaultDataQueueSize;
        Globals.PortsServiced = defaultMaximumPortsServiced;
        Globals.ConnectOneClassToOnePort = defaultConnectMultiplePorts;
        RtlCopyUnicodeString(&Globals.BaseClassName, &defaultUnicodeName);
    }

    MouPrint((
        1,
        "MOUCLASS-MouConfiguration: Mouse class base name = %ws\n",
        Globals.BaseClassName.Buffer
        ));

    if (Globals.InitExtension.MouseAttributes.InputDataQueueLength == 0) {

        MouPrint((
            1,
            "MOUCLASS-MouConfiguration: overriding MouseInputDataQueueLength = 0x%x\n",
            Globals.InitExtension.MouseAttributes.InputDataQueueLength
            ));

        Globals.InitExtension.MouseAttributes.InputDataQueueLength =
            defaultDataQueueSize;
    }

    Globals.InitExtension.MouseAttributes.InputDataQueueLength *=
        sizeof(MOUSE_INPUT_DATA);

    MouPrint((
        1,
        "MOUCLASS-MouConfiguration: MouseInputDataQueueLength = 0x%x\n",
        Globals.InitExtension.MouseAttributes.InputDataQueueLength
        ));

    MouPrint((
        1,
        "MOUCLASS-MouConfiguration: MaximumPortsServiced = %d\n",
        Globals.PortsServiced
        ));

    //
    // Invert the flag that specifies the type of class/port connections.
    // We used it in the RtlQuery call in an inverted fashion.
    //

    Globals.ConnectOneClassToOnePort = !Globals.ConnectOneClassToOnePort;

    MouPrint((
        1,
        "MOUCLASS-MouConfiguration: Connection Type = %d\n",
        Globals.ConnectOneClassToOnePort
        ));

    //
    // Free the allocated memory before returning.
    //

    if (parametersPath.Buffer)
        ExFreePool(parametersPath.Buffer);
    if (parameters)
        ExFreePool(parameters);

}

NTSTATUS
MouCreateClassObject(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDEVICE_EXTENSION   TmpDeviceExtension,
    OUT PDEVICE_OBJECT    * ClassDeviceObject,
    OUT PWCHAR            * FullDeviceName,
    IN  BOOLEAN             Legacy
    )

/*++

Routine Description:

    This routine creates the mouse class device object.


Arguments:

    DriverObject - Pointer to driver object created by system.

    TmpDeviceExtension - Pointer to the template device extension.

    FullDeviceName - Pointer to the Unicode string that is the full path name
        for the class device object.

    ClassDeviceObject - Pointer to a pointer to the class device object.

Return Value:

    The function value is the final status from the operation.

--*/

{
    NTSTATUS            status;
    ULONG               uniqueErrorValue;
    PDEVICE_EXTENSION   deviceExtension = NULL;
    NTSTATUS            errorCode = STATUS_SUCCESS;
    UNICODE_STRING      fullClassName = {0,0,0};
    ULONG               dumpCount = 0;
    ULONG               dumpData[DUMP_COUNT];
    ULONG               i;
    WCHAR               nameIndex;

    PAGED_CODE ();

    MouPrint((1,"\n\nMOUCLASS-MouCreateClassObject: enter\n"));

    //
    // Create a non-exclusive device object for the mouse class device.
    //

    ExAcquireFastMutex (&Globals.Mutex);

    //
    // Make sure ClassDeviceObject isn't pointing to a random pointer value
    //
    *ClassDeviceObject = NULL;

    if (NULL == Globals.GrandMaster) {
        //
        // Create a legacy name for this DO.
        //
        ExReleaseFastMutex (&Globals.Mutex);

        //
        // Set up space for the class's full device object name.
        //
        fullClassName.MaximumLength = sizeof(L"\\Device\\") +
                                    + Globals.BaseClassName.Length
                                    + sizeof(L"0");

        if (Globals.ConnectOneClassToOnePort && Legacy) {
            fullClassName.MaximumLength += sizeof(L"Legacy");
        }

        fullClassName.Buffer = ExAllocatePool(PagedPool,
                                              fullClassName.MaximumLength);

        if (!fullClassName.Buffer) {

            MouPrint((
                1,
                "MOUCLASS-MouseClassInitialize: Couldn't allocate string for device object name\n"
                ));

            status = STATUS_UNSUCCESSFUL;
            errorCode = MOUCLASS_INSUFFICIENT_RESOURCES;
            uniqueErrorValue = MOUSE_ERROR_VALUE_BASE + 6;
            dumpData[0] = (ULONG) fullClassName.MaximumLength;
            dumpCount = 1;
            goto MouCreateClassObjectExit;
        }

        RtlZeroMemory(fullClassName.Buffer, fullClassName.MaximumLength);
        RtlAppendUnicodeToString(&fullClassName, L"\\Device\\");
        RtlAppendUnicodeToString(&fullClassName, Globals.BaseClassName.Buffer);

        if (Globals.ConnectOneClassToOnePort && Legacy) {
            RtlAppendUnicodeToString(&fullClassName, L"Legacy");
        }

        RtlAppendUnicodeToString(&fullClassName, L"0");

        //
        // Using the base name start trying to create device names until
        // one succeeds.  Everytime start over at 0 to eliminate gaps.
        //
        nameIndex = 0;

        do {
            fullClassName.Buffer [ (fullClassName.Length / sizeof (WCHAR)) - 1]
                = L'0' + nameIndex++;

            MouPrint((
                1,
                "MOUCLASS-MouCreateClassObject: Creating device object named %ws\n",
                fullClassName.Buffer
                ));

            status = IoCreateDevice(DriverObject,
                                    sizeof (DEVICE_EXTENSION),
                                    &fullClassName,
                                    FILE_DEVICE_MOUSE,
                                    0,
                                    FALSE,
                                    ClassDeviceObject);

        } while (STATUS_OBJECT_NAME_COLLISION == status);

        *FullDeviceName = fullClassName.Buffer;

    } else {
        ExReleaseFastMutex (&Globals.Mutex);
        status = IoCreateDevice(DriverObject,
                                sizeof(DEVICE_EXTENSION),
                                NULL, // no name for this FDO
                                FILE_DEVICE_MOUSE,
                                0,
                                FALSE,
                                ClassDeviceObject);
        *FullDeviceName = NULL;
    }

    if (!NT_SUCCESS(status)) {
        MouPrint((
            1,
            "MOUCLASS-MouCreateClassObject: Could not create class device object = %ws\n",
            fullClassName.Buffer
            ));

        errorCode = MOUCLASS_COULD_NOT_CREATE_DEVICE;
        uniqueErrorValue = MOUSE_ERROR_VALUE_BASE + 6;
        dumpData[0] = (ULONG) fullClassName.MaximumLength;
        dumpCount = 1;
        goto MouCreateClassObjectExit;
    }

    //
    // Do buffered I/O.  I.e., the I/O system will copy to/from user data
    // from/to a system buffer.
    //

    (*ClassDeviceObject)->Flags |= DO_BUFFERED_IO;
    deviceExtension =
        (PDEVICE_EXTENSION)(*ClassDeviceObject)->DeviceExtension;
    *deviceExtension = *TmpDeviceExtension;

    deviceExtension->Self = *ClassDeviceObject;
    IoInitializeRemoveLock (&deviceExtension->RemoveLock, MOUSE_POOL_TAG, 0, 10);

    //
    // Initialize spin lock for critical sections.
    //

    KeInitializeSpinLock(&deviceExtension->SpinLock);

    //
    // Initialize mouse class flags to indicate there is no outstanding
    // read request pending and cleanup has not been initiated.
    //
    InitializeListHead (&deviceExtension->ReadQueue);

    //
    // No trusted subsystem has sent us an open yet.
    //

    deviceExtension->TrustedSubsystemCount = 0;

    //
    // Allocate the ring buffer for the mouse class input data.
    //

    deviceExtension->InputData =
        ExAllocatePool(
            NonPagedPool,
            deviceExtension->MouseAttributes.InputDataQueueLength
            );

    if (!deviceExtension->InputData) {

        //
        // Could not allocate memory for the mouse class data queue.
        //

        MouPrint((
            1,
            "MOUCLASS-MouCreateClassObject: Could not allocate input data queue for %ws\n",
            fullClassName.Buffer
            ));

        status = STATUS_INSUFFICIENT_RESOURCES;

        //
        // Log an error.
        //

        errorCode = MOUCLASS_NO_BUFFER_ALLOCATED;
        uniqueErrorValue = MOUSE_ERROR_VALUE_BASE + 20;
        goto MouCreateClassObjectExit;
    }

    //
    // Initialize mouse class input data queue.
    //

    MouInitializeDataQueue((PVOID)deviceExtension);

MouCreateClassObjectExit:

    if (status != STATUS_SUCCESS) {

        //
        // Some part of the initialization failed.  Log an error, and
        // clean up the resources for the failed part of the initialization.
        //
        RtlFreeUnicodeString (&fullClassName);
        *FullDeviceName = NULL;

        if (errorCode != STATUS_SUCCESS) {
            MouseClassLogError (
                (*ClassDeviceObject == NULL) ?
                    (PVOID) DriverObject : (PVOID) *ClassDeviceObject,
                errorCode,
                uniqueErrorValue,
                status,
                dumpCount,
                dumpData,
                0);
        }

        if ((deviceExtension) && (deviceExtension->InputData)) {
            ExFreePool(deviceExtension->InputData);
            deviceExtension->InputData = NULL;
        }
        if (*ClassDeviceObject) {
            IoDeleteDevice(*ClassDeviceObject);
            *ClassDeviceObject = NULL;
        }
    }

    MouPrint((1,"MOUCLASS-MouCreateClassObject: exit\n"));

    return(status);
}

#if DBG
VOID
MouDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print routine.

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None.

--*/

{
    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= Globals.Debug) {

        char buffer[256];

        (VOID) vsprintf(buffer, DebugMessage, ap);

        DbgPrint(buffer);
    }

    va_end(ap);

}
#endif

NTSTATUS
MouDeterminePortsServiced(
    IN PUNICODE_STRING BasePortName,
    IN OUT PULONG NumberPortsServiced
    )

/*++

Routine Description:

    This routine reads the DEVICEMAP portion of the registry to determine
    how many ports the class driver is to service.  Depending on the
    value of DeviceExtension->ConnectOneClassToOnePort, the class driver
    will eventually create one device object per port device serviced, or
    one class device object that connects to multiple port device objects.

    Assumptions:

        1.  If the base device name for the class driver is "PointerClass",
                                                                    ^^^^^
            then the port drivers it can service are found under the
            "PointerPort" subkey in the DEVICEMAP portion of the registry.
                    ^^^^

        2.  The port device objects are created with suffixes in strictly
            ascending order, starting with suffix 0.  E.g.,
            \Device\PointerPort0 indicates the first pointer port device,
            \Device\PointerPort1 the second, and so on.  There are no gaps
            in the list.

        3.  If ConnectOneClassToOnePort is non-zero, there is a 1:1
            correspondence between class device objects and port device
            objects.  I.e., \Device\PointerClass0 will connect to
            \Device\PointerPort0, \Device\PointerClass1 to
            \Device\PointerPort1, and so on.

        4.  If ConnectOneClassToOnePort is zero, there is a 1:many
            correspondence between class device objects and port device
            objects.  I.e., \Device\PointerClass0 will connect to
            \Device\PointerPort0, and \Device\PointerPort1, and so on.


    Note that for Product 1, the Raw Input Thread (Windows USER) will
    only deign to open and read from one pointing device.  Hence, it is
    safe to make simplifying assumptions because the driver is basically
    providing  much more functionality than the RIT will use.

Arguments:

    BasePortName - Pointer to the Unicode string that is the base path name
        for the port device.

    NumberPortsServiced - Pointer to storage that will receive the
        number of ports this class driver should service.

Return Value:

    The function value is the final status from the operation.

--*/

{

    NTSTATUS status;
    PRTL_QUERY_REGISTRY_TABLE registryTable = NULL;
    USHORT queriesPlusOne = 2;

    PAGED_CODE ();

    //
    // Initialize the result.
    //

    *NumberPortsServiced = 0;

    //
    // Allocate the Rtl query table.
    //

    registryTable = ExAllocatePool(
                        PagedPool,
                        sizeof(RTL_QUERY_REGISTRY_TABLE) * queriesPlusOne
                     );

    if (!registryTable) {

        MouPrint((
            1,
            "MOUCLASS-MouDeterminePortsServiced: Couldn't allocate table for Rtl query\n"
            ));

        status = STATUS_UNSUCCESSFUL;

    } else {

        RtlZeroMemory(
            registryTable,
            sizeof(RTL_QUERY_REGISTRY_TABLE) * queriesPlusOne
            );

        //
        // Set things up so that MouDeviceMapQueryCallback will be
        // called once for every value in the pointer port section
        // of the registry's hardware devicemap.
        //

        registryTable[0].QueryRoutine = MouDeviceMapQueryCallback;
        registryTable[0].Name = NULL;

        status = RtlQueryRegistryValues(
                     RTL_REGISTRY_DEVICEMAP | RTL_REGISTRY_OPTIONAL,
                     BasePortName->Buffer,
                     registryTable,
                     NumberPortsServiced,
                     NULL
                     );

        if (!NT_SUCCESS(status)) {
            MouPrint((
                1,
                "MOUCLASS-MouDeterminePortsServiced: RtlQueryRegistryValues failed with 0x%x\n",
                status
                ));
        }

        ExFreePool(registryTable);
    }

    return(status);
}

NTSTATUS
MouDeviceMapQueryCallback(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )

/*++

Routine Description:

    This is the callout routine specified in a call to
    RtlQueryRegistryValues.  It increments the value pointed
    to by the Context parameter.

Arguments:

    ValueName - Unused.

    ValueType - Unused.

    ValueData - Unused.

    ValueLength - Unused.

    Context - Pointer to a count of the number of times this
        routine has been called.  This is the number of ports
        the class driver needs to service.

    EntryContext - Unused.

Return Value:

    The function value is the final status from the operation.

--*/

{
    PAGED_CODE ();

    *(PULONG)Context += 1;

    return(STATUS_SUCCESS);
}

NTSTATUS
MouEnableDisablePort(
    IN BOOLEAN  EnableFlag,
    IN PIRP     Irp,
    IN PDEVICE_EXTENSION  Port,
    IN OUT PFILE_OBJECT * File
    )

/*++

Routine Description:

    This routine sends an enable or a disable request to the port driver.
    The legacy port drivers require an enable or disable ioctl, while the
    plug and play drivers require merely a create.

Arguments:

    DeviceObject - Pointer to class device object.

    EnableFlag - If TRUE, send an ENABLE request; otherwise, send DISABLE.

    PortIndex - Index into the PortDeviceObjectList[] for the current
        enable/disable request.

Return Value:

    Status is returned.

--*/

{
    IO_STATUS_BLOCK ioStatus;
    UNICODE_STRING  name = {0,0,0};
    PDEVICE_OBJECT  device = NULL;
    NTSTATUS    status = STATUS_SUCCESS;
    PWCHAR      buffer = NULL;
    ULONG       bufferLength = 0;
    PIO_STACK_LOCATION stack;

    PAGED_CODE ();

    MouPrint((2,"MOUCLASS-MouEnableDisablePort: enter\n"));

    //
    // Create notification event object to be used to signal the
    // request completion.
    //

    if ((Port->TrueClassDevice == Port->Self) && (Port->PnP)) {

        IoCopyCurrentIrpStackLocationToNext (Irp);
        stack = IoGetNextIrpStackLocation (Irp);

        if (EnableFlag) {
            //
            // Since there is no grand master there could not have been a
            // create file against the FDO before it was started.  Therefore
            // the only time we would enable is during a create and not a
            // start as we might with another FDO attached to an already open
            // grand master.
            //
            ASSERT (IRP_MJ_CREATE == stack->MajorFunction);

        } else {
            if (IRP_MJ_CLOSE != stack->MajorFunction) {
                //
                // We are disabling.  This could be because the device was
                // closed, or because the device was removed out from
                // underneath us.
                //
                ASSERT (IRP_MJ_PNP == stack->MajorFunction);
                ASSERT ((IRP_MN_REMOVE_DEVICE == stack->MinorFunction) ||
                        (IRP_MN_STOP_DEVICE == stack->MinorFunction));
                stack->MajorFunction = IRP_MJ_CLOSE;
            }
        }

        //
        // Either way we need only pass the Irp down without mucking with the
        // file object.
        //
        status = MouseSendIrpSynchronously (Port->TopPort, Irp, FALSE);

    } else if (!Port->PnP) {
        Port->Enabled = EnableFlag;

        //
        // We have here an old style Port Object.  Therefore we send it the
        // old style internal IOCTLs of ENABLE and DISABLE, and not the new
        // style of passing on a create and close.
        //
        IoCopyCurrentIrpStackLocationToNext (Irp);
        stack = IoGetNextIrpStackLocation (Irp);

        stack->Parameters.DeviceIoControl.OutputBufferLength = 0;
        stack->Parameters.DeviceIoControl.InputBufferLength = 0;
        stack->Parameters.DeviceIoControl.IoControlCode
            = EnableFlag ? IOCTL_INTERNAL_MOUSE_ENABLE
                         : IOCTL_INTERNAL_MOUSE_DISABLE;
        stack->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
        stack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

        status = MouseSendIrpSynchronously (Port->TopPort, Irp, FALSE);

    } else {
        //
        // We are dealing with a plug and play port and we have a Grand
        // Master.
        //
        ASSERT (Port->TrueClassDevice == Globals.GrandMaster->Self);

        //
        // Therefore we need to substitute the given file object for a new
        // one for use with each individual ports.
        // For enable, we need to create this file object against the given
        // port and then hand it back in the File parameter, or for disable,
        // deref the File parameter and free that file object.
        //
        // Of course, there must be storage for a file pointer pointed to by
        // the File parameter.
        //
        ASSERT (NULL != File);

        if (EnableFlag) {

            ASSERT (NULL == *File);

            //
            // The following long list of rigamaroll translates into
            // sending the lower driver a create file IRP and creating a
            // NEW file object disjoint from the one given us in our create
            // file routine.
            //
            // Normally we would just pass down the Create IRP we were
            // given, but we do not have a one to one correspondance of
            // top device objects and port device objects.
            // This means we need more file objects: one for each of the
            // miriad of lower DOs.
            //

            bufferLength = 0;
            status = IoGetDeviceProperty (
                             Port->PDO,
                             DevicePropertyPhysicalDeviceObjectName,
                             bufferLength,
                             buffer,
                             &bufferLength);
            ASSERT (STATUS_BUFFER_TOO_SMALL == status);

            buffer = ExAllocatePool (PagedPool, bufferLength);

            if (NULL == buffer) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            status =  IoGetDeviceProperty (
                          Port->PDO,
                          DevicePropertyPhysicalDeviceObjectName,
                          bufferLength,
                          buffer,
                          &bufferLength);

            name.MaximumLength = (USHORT) bufferLength;
            name.Length = (USHORT) bufferLength - sizeof (UNICODE_NULL);
            name.Buffer = buffer;

            status = IoGetDeviceObjectPointer (&name,
                                               FILE_ALL_ACCESS,
                                               File,
                                               &device);
            ExFreePool (buffer);
            //
            // Note, that this create will first go to ourselves since we
            // are attached to this PDO stack.  Therefore two things are
            // noteworthy.  This driver will receive another Create IRP
            // (with a different file object) (not to the grand master but
            // to one of the subordenant FDO's).  The device object returned
            // will be the subordenant FDO, which in this case is the "self"
            // device object of this Port.
            //
            if (NT_SUCCESS (status)) {
                ASSERT (device == Port->Self);

                //
                // Register for Target device removal events
                //
                ASSERT (NULL == Port->TargetNotifyHandle);
                status = IoRegisterPlugPlayNotification (
                             EventCategoryTargetDeviceChange,
                             0, // No flags
                             *File,
                             Port->Self->DriverObject,
                             MouseClassPlugPlayNotification,
                             Port,
                             &Port->TargetNotifyHandle);
            }

        } else {
            //
            // Getting rid of the handle is easy.  Just deref the file.
            //
            ObDereferenceObject (*File);
            *File = NULL;
        }

    }
    MouPrint((2,"MOUCLASS-MouEnableDisablePort: exit\n"));

    return (status);
}

VOID
MouInitializeDataQueue (
    IN PVOID Context
    )

/*++

Routine Description:

    This routine initializes the input data queue.  IRQL is raised to
    DISPATCH_LEVEL to synchronize with StartIo, and the device object
    spinlock is acquired.

Arguments:

    Context - Supplies a pointer to the device extension.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;
    PDEVICE_EXTENSION deviceExtension;

    MouPrint((3,"MOUCLASS-MouInitializeDataQueue: enter\n"));

    //
    // Get address of device extension.
    //

    deviceExtension = (PDEVICE_EXTENSION)Context;

    //
    // Acquire the spinlock to protect the input data
    // queue and associated pointers.
    //

    KeAcquireSpinLock(&deviceExtension->SpinLock, &oldIrql);

    //
    // Initialize the input data queue.
    //

    deviceExtension->InputCount = 0;
    deviceExtension->DataIn = deviceExtension->InputData;
    deviceExtension->DataOut = deviceExtension->InputData;

    deviceExtension->OkayToLogOverflow = TRUE;

    //
    // Release the spinlock and return to the old IRQL.
    //

    KeReleaseSpinLock(&deviceExtension->SpinLock, oldIrql);

    MouPrint((3,"MOUCLASS-MouInitializeDataQueue: exit\n"));

} // end MouInitializeDataQueue

NTSTATUS
MouSendConnectRequest(
    IN PDEVICE_EXTENSION ClassData,
    IN PVOID ServiceCallback
    )

/*++

Routine Description:

    This routine sends a connect request to the port driver.

Arguments:

    DeviceObject - Pointer to class device object.

    ServiceCallback - Pointer to the class service callback routine.

    PortIndex - The index into the PortDeviceObjectList[] for the current
        connect request.

Return Value:

    Status is returned.

--*/

{
    PIRP irp;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS status;
    KEVENT event;
    CONNECT_DATA connectData;

    PAGED_CODE ();

    MouPrint((2,"MOUCLASS-MouSendConnectRequest: enter\n"));

    //
    // Create notification event object to be used to signal the
    // request completion.
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // Build the synchronous request to be sent to the port driver
    // to perform the request.  Allocate an IRP to issue the port internal
    // device control connect call.  The connect parameters are passed in
    // the input buffer.
    //
    //

    connectData.ClassDeviceObject = ClassData->TrueClassDevice;
    connectData.ClassService = ServiceCallback;

    irp = IoBuildDeviceIoControlRequest(
            IOCTL_INTERNAL_MOUSE_CONNECT,
            ClassData->TopPort,
            &connectData,
            sizeof(CONNECT_DATA),
            NULL,
            0,
            TRUE,
            &event,
            &ioStatus
            );

    //
    // Call the port driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //

    status = IoCallDriver(ClassData->TopPort, irp);

    if (status == STATUS_PENDING) {
        (VOID) KeWaitForSingleObject(
                   &event,
                   Executive,
                   KernelMode,
                   FALSE,
                   NULL
                   );

        status = irp->IoStatus.Status;
    } else {

        //
        // Ensure that the proper status value gets picked up.
        //

        ioStatus.Status = status;
    }

    MouPrint((2,"MOUCLASS-MouSendConnectRequest: exit\n"));

    return(ioStatus.Status);

} // end MouSendConnectRequest()

void
MouseClassRemoveDevice(
    IN PDEVICE_EXTENSION Data,
    BOOLEAN SurpriseRemove
    )
{
    PFILE_OBJECT *  file;
    PPORT           port;
    PIRP            waitWakeIrp;
    PVOID           notifyHandle;
    BOOLEAN         enabled;

    //
    // Mark that we were surprise removed so that we do not clean up twice
    //
    if (SurpriseRemove) {
        Data->SurpriseRemoved = TRUE;
    }

    //
    // If this is a surprise remove or we got a remove w/out a surprise remove,
    // then we need to clean up
    //
    if (SurpriseRemove || !Data->SurpriseRemoved) {
        waitWakeIrp = (PIRP)
            InterlockedExchangePointer(&Data->WaitWakeIrp, NULL);

        if (waitWakeIrp) {
            IoCancelIrp(waitWakeIrp);
        }

        IoWMIRegistrationControl (Data->Self, WMIREG_ACTION_DEREGISTER);

        if (Data->Started) {
            //
            // Stop the device without touching the hardware.
            // MouStopDevice(Data, FALSE);
            //
            // NB sending down the enable disable does NOT touch the hardware
            // it instead sends down a close file.
            //
            ExAcquireFastMutex (&Globals.Mutex);
            if (Globals.GrandMaster) {
                if (0 < Globals.Opens) {
                    port = &Globals.AssocClassList[Data->UnitId];
                    ASSERT (port->Port == Data);
                    file = &(port->File);
                    enabled = port->Enabled;
                    port->Enabled = FALSE;
                    ExReleaseFastMutex (&Globals.Mutex);

                    //
                    // ASSERT (NULL == Data->notifyHandle);
                    //
                    // If we have a grand master, that means we did the
                    // creation locally and registered for notification.
                    // we should have closed the file during
                    // TARGET_DEVICE_QUERY_REMOVE, but we will have not
                    // gotten rid of the notify handle.
                    //
                    // Of course if we receive a surprise removal then
                    // we should not have received the query cancel.
                    // In which case we should have received a
                    // TARGET_DEVICE_REMOVE_COMPLETE where we would have
                    // both closed the file and removed cleared the
                    // notify handle
                    //
                    // Either way the file should be closed by now.
                    //
                    ASSERT (!enabled);
                    // if (enabled) {
                    //     status = MouEnableDisablePort (FALSE, Irp, Data, file);
                    //     ASSERTMSG ("Could not close open port", NT_SUCCESS(status));
                    // }

                    notifyHandle = InterlockedExchangePointer (
                                       &Data->TargetNotifyHandle,
                                       NULL);

                    if (NULL != notifyHandle) {
                        IoUnregisterPlugPlayNotification (notifyHandle);
                    }
                }
                else {
                    ASSERT (!Globals.AssocClassList[Data->UnitId].Enabled);
                    ExReleaseFastMutex (&Globals.Mutex);
                }
            }
            else {
                ExReleaseFastMutex (&Globals.Mutex);
                ASSERT (Data->TrueClassDevice == Data->Self);
                ASSERT (Globals.ConnectOneClassToOnePort);

                //
                // If add device fails, then the buffer will be NULL
                //
                if (Data->SymbolicLinkName.Buffer != NULL) {
                    IoSetDeviceInterfaceState (&Data->SymbolicLinkName, FALSE);
                }

            }
        }
    }

    //
    // Always drain the queue, no matter if we have received both a surprise
    // remove and a remove
    //
    if (Data->PnP) {
        //
        // Empty the device I/O Queue
        //
        MouseClassCleanupQueue (Data->Self, Data, NULL);
    }
}

NTSTATUS
MousePnP (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    The plug and play dispatch routines.

    Most of these this filter driver will completely ignore.
    In all cases it must pass on the IRP to the lower driver.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PDEVICE_EXTENSION   data;
    PDEVICE_EXTENSION   trueClassData;
    PIO_STACK_LOCATION  stack;
    NTSTATUS            status, startStatus;
    ULONG               i;
    PFILE_OBJECT      * file;
    UINT_PTR            startInformation;
    DEVICE_CAPABILITIES devCaps;
    BOOLEAN             enabled;
    PPORT               port;
    PVOID               notifyHandle;

    data = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation (Irp);

    if(!data->PnP) {
        //
        // This irp was sent to the control device object, which knows not
        // how to deal with this IRP.  It is therefore an error.
        //
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return STATUS_NOT_SUPPORTED;

    }

    status = IoAcquireRemoveLock (&data->RemoveLock, Irp);
    if (!NT_SUCCESS (status)) {
        //
        // Someone gave us a pnp irp after a remove.  Unthinkable!
        //
        ASSERT (FALSE);
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    trueClassData = (PDEVICE_EXTENSION) data->TrueClassDevice->DeviceExtension;
    switch (stack->MinorFunction) {
    case IRP_MN_START_DEVICE:

        //
        // The device is starting.
        //
        // We cannot touch the device (send it any non pnp irps) until a
        // start device has been passed down to the lower drivers.
        //
        status = MouseSendIrpSynchronously (data->TopPort, Irp, TRUE);

        if (NT_SUCCESS (status) && NT_SUCCESS (Irp->IoStatus.Status)) {
            //
            // As we are successfully now back from our start device
            // we can do work.
            //
            // Get the caps of the device.  Save off pertinent information
            // before mucking about w/the irp
            //
            startStatus = Irp->IoStatus.Status;
            startInformation = Irp->IoStatus.Information;

            Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
            Irp->IoStatus.Information = 0;

            RtlZeroMemory(&devCaps, sizeof (DEVICE_CAPABILITIES));
            devCaps.Size = sizeof (DEVICE_CAPABILITIES);
            devCaps.Version = 1;
            devCaps.Address = devCaps.UINumber = (ULONG)-1;

            stack = IoGetNextIrpStackLocation (Irp);
            stack->MinorFunction = IRP_MN_QUERY_CAPABILITIES;
            stack->Parameters.DeviceCapabilities.Capabilities = &devCaps;

            status = MouseSendIrpSynchronously (data->TopPort, Irp, FALSE);

            if (NT_SUCCESS (status) && NT_SUCCESS (Irp->IoStatus.Status)) {
                data->MinDeviceWakeState = devCaps.DeviceWake;
                data->MinSystemWakeState = devCaps.SystemWake;

                RtlCopyMemory (data->SystemToDeviceState,
                               devCaps.DeviceState,
                               sizeof(DEVICE_POWER_STATE) * PowerSystemHibernate);
            } else {
                ASSERTMSG ("Get Device caps Failed!\n", status);
            }

            //
            // Set everything back to the way it was and continue with the start
            //
            status = STATUS_SUCCESS;
            Irp->IoStatus.Status = startStatus;
            Irp->IoStatus.Information = startInformation;

            data->Started = TRUE;

            if (WAITWAKE_SUPPORTED (data)) {
                //
                // register for the wait wake guid as well
                //
                data->WmiLibInfo.GuidCount = sizeof (MouseClassWmiGuidList) /
                                             sizeof (WMIGUIDREGINFO);

                //
                // See if the user has enabled wait wake for the device
                //
                MouseClassGetWaitWakeEnableState (data);
            }
            else {
                data->WmiLibInfo.GuidCount = sizeof (MouseClassWmiGuidList) /
                                             sizeof (WMIGUIDREGINFO) - 1;
            }

            data->WmiLibInfo.GuidList = MouseClassWmiGuidList;
            data->WmiLibInfo.QueryWmiRegInfo = MouseClassQueryWmiRegInfo;
            data->WmiLibInfo.QueryWmiDataBlock = MouseClassQueryWmiDataBlock;
            data->WmiLibInfo.SetWmiDataBlock = MouseClassSetWmiDataBlock;
            data->WmiLibInfo.SetWmiDataItem = MouseClassSetWmiDataItem;
            data->WmiLibInfo.ExecuteWmiMethod = NULL;
            data->WmiLibInfo.WmiFunctionControl = NULL;

            IoWMIRegistrationControl(data->Self,
                                     WMIREG_ACTION_REGISTER
                                     );

            ExAcquireFastMutex (&Globals.Mutex);
            if (Globals.GrandMaster) {
                if (0 < Globals.Opens) {
                    port = &Globals.AssocClassList[data->UnitId];
                    ASSERT (port->Port == data);
                    file = &(port->File);
                    enabled = port->Enabled;
                    port->Enabled = TRUE;
                    ExReleaseFastMutex (&Globals.Mutex);

                    if (!enabled) {
                        status = MouEnableDisablePort (TRUE, NULL, data, file);

                        if (!NT_SUCCESS (status)) {
                            port->Enabled = FALSE;
                            // ASSERT (Globals.AssocClassList[data->UnitId].Enabled);
                        } else {
                            ;
                        }
                    }
                } else {
                    ASSERT (!Globals.AssocClassList[data->UnitId].Enabled);
                    ExReleaseFastMutex (&Globals.Mutex);
                }
            } else {
                ExReleaseFastMutex (&Globals.Mutex);
                ASSERT (data->Self == data->TrueClassDevice);
                status=IoSetDeviceInterfaceState(&data->SymbolicLinkName, TRUE);
            }

            //
            // Start up the Wait Wake Engine if required.
            //
            if (SHOULD_SEND_WAITWAKE (data)) {
                MouseClassCreateWaitWakeIrp (data);
            }
        }

        //
        // We must now complete the IRP, since we stopped it in the
        // completetion routine with MORE_PROCESSING_REQUIRED.
        //
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        break;

    case IRP_MN_STOP_DEVICE:
        //
        // After the start IRP has been sent to the lower driver object, the
        // bus may NOT send any more IRPS down ``touch'' until another START
        // has occured.
        // What ever access is required must be done before the Irp is passed
        // on.
        //

        //
        // Do what ever
        //

        //
        // Stop Device touching the hardware MouStopDevice(data, TRUE);
        //
        if (data->Started) {
            ExAcquireFastMutex (&Globals.Mutex);
            if (Globals.GrandMaster) {
                if (0 < Globals.Opens) {
                    port = &Globals.AssocClassList[data->UnitId];
                    ASSERT (port->Port == data);
                    file = &(port->File);
                    enabled = port->Enabled;
                    port->Enabled = FALSE;
                    ExReleaseFastMutex (&Globals.Mutex);

                    if (enabled) {
                        notifyHandle = InterlockedExchangePointer (
                                           &data->TargetNotifyHandle,
                                           NULL);

                        if (NULL != notifyHandle) {
                            IoUnregisterPlugPlayNotification (notifyHandle);
                        }

                        status = MouEnableDisablePort (FALSE, NULL, data, file);
                        ASSERTMSG ("Could not close open port", NT_SUCCESS(status));
                    } else {
                        ASSERT (NULL == data->TargetNotifyHandle);
                    }
                } else {
                    ASSERT (!Globals.AssocClassList[data->UnitId].Enabled);
                    ExReleaseFastMutex (&Globals.Mutex);
                }
            } else {
                ExReleaseFastMutex (&Globals.Mutex);
            }
        }

        data->Started = FALSE;

        //
        // We don't need a completion routine so fire and forget.
        //
        // Set the current stack location to the next stack location and
        // call the next device object.
        //
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (data->TopPort, Irp);
        break;

    case IRP_MN_SURPRISE_REMOVAL:
        //
        // The PlugPlay system has dictacted the removal of this device.
        //
        MouseClassRemoveDevice (data, TRUE);

        //
        // We don't need a completion routine so fire and forget.
        //
        // Set the current stack location to the next stack location and
        // call the next device object.
        //
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (data->TopPort, Irp);
        break;

    case IRP_MN_REMOVE_DEVICE:
        //
        // The PlugPlay system has dictacted the removal of this device.  We
        // have no choise but to detach and delete the device objecct.
        // (If we wanted to express and interest in preventing this removal,
        // we should have filtered the query remove and query stop routines.)
        //
        MouseClassRemoveDevice (data, FALSE);


        //
        // Here if we had any outstanding requests in a personal queue we should
        // complete them all now.
        //
        // Note, the device is guarenteed stopped, so we cannot send it any non-
        // PNP IRPS.
        //

        //
        // Send on the remove IRP
        //
        IoCopyCurrentIrpStackLocationToNext (Irp);
        status = IoCallDriver (data->TopPort, Irp);

        ExAcquireFastMutex (&Globals.Mutex);
        if (Globals.GrandMaster) {
            ASSERT (Globals.GrandMaster->Self == data->TrueClassDevice);
            //
            // We must remove ourself from the Assoc List
            //

            if (1 < Globals.NumAssocClass) {
                ASSERT (Globals.AssocClassList[data->UnitId].Port == data);

                Globals.AssocClassList[data->UnitId].Free = TRUE;
                Globals.AssocClassList[data->UnitId].File = NULL;
                Globals.AssocClassList[data->UnitId].Port = NULL;

            } else {
                ASSERT (1 == Globals.NumAssocClass);
                Globals.NumAssocClass = 0;
                ExFreePool (Globals.AssocClassList);
                Globals.AssocClassList = NULL;
            }
            ExReleaseFastMutex (&Globals.Mutex);

        } else {
            //
            // We are removing the one and only port associated with this class
            // device object.
            //
            ExReleaseFastMutex (&Globals.Mutex);
            ASSERT (data->TrueClassDevice == data->Self);
            ASSERT (Globals.ConnectOneClassToOnePort);
        }

        IoReleaseRemoveLockAndWait (&data->RemoveLock, Irp);

        IoDetachDevice (data->TopPort);

        //
        // Clean up memory
        //

        RtlFreeUnicodeString (&data->SymbolicLinkName);
        ExFreePool (data->InputData);
        IoDeleteDevice (data->Self);

        return status;

    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_CANCEL_REMOVE_DEVICE:
    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_CANCEL_STOP_DEVICE:
    case IRP_MN_QUERY_DEVICE_RELATIONS:
    case IRP_MN_QUERY_INTERFACE:
    case IRP_MN_QUERY_CAPABILITIES:
    case IRP_MN_QUERY_RESOURCES:
    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
    case IRP_MN_READ_CONFIG:
    case IRP_MN_WRITE_CONFIG:
    case IRP_MN_EJECT:
    case IRP_MN_SET_LOCK:
    case IRP_MN_QUERY_ID:
    case IRP_MN_QUERY_PNP_DEVICE_STATE:
    default:
        //
        // Here the filter driver might modify the behavior of these IRPS
        // Please see PlugPlay documentation for use of these IRPs.
        //

        IoCopyCurrentIrpStackLocationToNext (Irp);
        status = IoCallDriver (data->TopPort, Irp);
        break;
    }

    IoReleaseRemoveLock (&data->RemoveLock, Irp);

    return status;
}

void
MouseClassLogError(
    PVOID Object,
    ULONG ErrorCode,
    ULONG UniqueErrorValue,
    NTSTATUS FinalStatus,
    ULONG DumpCount,
    ULONG *DumpData,
    UCHAR MajorFunction
    )
{
    PIO_ERROR_LOG_PACKET errorLogEntry;
    ULONG i;

    errorLogEntry = (PIO_ERROR_LOG_PACKET)
        IoAllocateErrorLogEntry(
            Object,
            (UCHAR) (sizeof(IO_ERROR_LOG_PACKET) + (DumpCount * sizeof(ULONG)))
            );

    if (errorLogEntry != NULL) {

        errorLogEntry->ErrorCode = ErrorCode;
        errorLogEntry->DumpDataSize = (USHORT) (DumpCount * sizeof(ULONG));
        errorLogEntry->SequenceNumber = 0;
        errorLogEntry->MajorFunctionCode = MajorFunction;
        errorLogEntry->IoControlCode = 0;
        errorLogEntry->RetryCount = 0;
        errorLogEntry->UniqueErrorValue = UniqueErrorValue;
        errorLogEntry->FinalStatus = FinalStatus;
        for (i = 0; i < DumpCount; i++)
            errorLogEntry->DumpData[i] = DumpData[i];

        IoWriteErrorLogEntry(errorLogEntry);
    }

}

VOID
MouseClassFindMorePorts (
    PDRIVER_OBJECT  DriverObject,
    PVOID           Context,
    ULONG           Count
    )
/*++

Routine Description:

    This routine is called from
    serviced by the boot device drivers and then called again by the
    IO system to find disk devices serviced by nonboot device drivers.

Arguments:

    DriverObject
    Context -
    Count - Used to determine if this is the first or second time called.

Return Value:

    None

--*/

{
    NTSTATUS                status;
    PDEVICE_EXTENSION       deviceExtension = NULL;
    PDEVICE_OBJECT          classDeviceObject = NULL;
    ULONG                   dumpData[DUMP_COUNT];
    ULONG                   i;
    ULONG                   numPorts;
    ULONG                   successfulCreates;
    UNICODE_STRING          basePortName;
    UNICODE_STRING          fullPortName;
    WCHAR                   basePortBuffer[NAME_MAX];
    PWCHAR                  fullClassName = NULL;
    PFILE_OBJECT            file;

    PAGED_CODE ();

    fullPortName.MaximumLength = 0;

    RtlZeroMemory(basePortBuffer, NAME_MAX * sizeof(WCHAR));
    basePortName.Buffer = basePortBuffer;
    basePortName.Length = 0;
    basePortName.MaximumLength = NAME_MAX * sizeof(WCHAR);

    //
    // Set up the base device name for the associated port device.
    // It is the same as the base class name, with "Class" replaced
    // by "Port".
    //
    RtlCopyUnicodeString(&basePortName, &Globals.BaseClassName);
    basePortName.Length -= (sizeof(L"Class") - sizeof(UNICODE_NULL));
    RtlAppendUnicodeToString(&basePortName, L"Port");

    //
    // Set up space for the full device object name for the ports.
    //
    RtlInitUnicodeString(&fullPortName, NULL);

    fullPortName.MaximumLength = sizeof(L"\\Device\\")
                               + basePortName.Length
                               + sizeof (UNICODE_NULL);

    fullPortName.Buffer = ExAllocatePool(PagedPool,
                                         fullPortName.MaximumLength);

    if (!fullPortName.Buffer) {

        MouPrint((
            1,
            "MOUCLASS-MouseClassInitialize: Couldn't allocate string for port device object name\n"
            ));

        dumpData[0] = (ULONG) fullPortName.MaximumLength;
        MouseClassLogError (DriverObject,
                            MOUCLASS_INSUFFICIENT_RESOURCES,
                            MOUSE_ERROR_VALUE_BASE + 8,
                            STATUS_UNSUCCESSFUL,
                            1,
                            dumpData,
                            0);

        goto MouseFindMorePortsExit;
    }

    RtlZeroMemory(fullPortName.Buffer, fullPortName.MaximumLength);
    RtlAppendUnicodeToString(&fullPortName, L"\\Device\\");
    RtlAppendUnicodeToString(&fullPortName, basePortName.Buffer);
    RtlAppendUnicodeToString(&fullPortName, L"0");

    MouDeterminePortsServiced(&basePortName, &numPorts);

    //
    // Set up the class device object(s) to handle the associated
    // port devices.
    //

    for (i = Globals.NumberLegacyPorts, successfulCreates = 0;
         ((i < Globals.PortsServiced) && (i < numPorts));
         i++) {

        //
        // Append the suffix to the device object name string.  E.g., turn
        // \Device\PointerClass into \Device\PointerClass0.  Then attempt
        // to create the device object.  If the device object already
        // exists increment the suffix and try again.
        //

        fullPortName.Buffer[(fullPortName.Length / sizeof(WCHAR)) - 1]
            = L'0' + (WCHAR) i;

        if (fullClassName) {
            ExFreePool(fullClassName);
            fullClassName = NULL;
        }

        //
        // Create the class device object.
        //
        status = MouCreateClassObject(DriverObject,
                                      &Globals.InitExtension,
                                      &classDeviceObject,
                                      &fullClassName,
                                      TRUE);

        if (!NT_SUCCESS(status)) {
            MouseClassLogError (DriverObject,
                                MOUCLASS_INSUFFICIENT_RESOURCES,
                                MOUSE_ERROR_VALUE_BASE + 8,
                                status,
                                0,
                                NULL,
                                0);
            continue;
        }

        deviceExtension = (PDEVICE_EXTENSION)classDeviceObject->DeviceExtension;
        deviceExtension->PnP = FALSE;

        //
        // Connect to the port device.
        //
        status = IoGetDeviceObjectPointer (&fullPortName,
                                           FILE_READ_ATTRIBUTES,
                                           &file,
                                           &deviceExtension->TopPort);

        if (status != STATUS_SUCCESS) {
            // ISSUE:  log error
            MouseClassDeleteLegacyDevice (deviceExtension);
            continue;
        }

        classDeviceObject->StackSize = 1 + deviceExtension->TopPort->StackSize;
        status = MouseAddDeviceEx (deviceExtension, fullClassName, file);
        classDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

        if (fullClassName) {
            ExFreePool (fullClassName);
            fullClassName = NULL;
        }

        if (!NT_SUCCESS (status)) {
            if (Globals.GrandMaster == NULL) {
                if (deviceExtension->File) {
                    file = deviceExtension->File;
                    deviceExtension->File = NULL;
                }
            }
            else {
                PPORT port;

                ExAcquireFastMutex (&Globals.Mutex);

                file = Globals.AssocClassList[deviceExtension->UnitId].File;
                Globals.AssocClassList[deviceExtension->UnitId].File = NULL;
                Globals.AssocClassList[deviceExtension->UnitId].Free = TRUE;
                Globals.AssocClassList[deviceExtension->UnitId].Port = NULL;

                ExReleaseFastMutex (&Globals.Mutex);
            }

            if (file) {
                ObDereferenceObject (file);
            }

            MouseClassDeleteLegacyDevice (deviceExtension);
            continue;
        }

        //
        // We want to only add it to our list if everything went alright
        //
        InsertTailList (&Globals.LegacyDeviceList, &deviceExtension->Link);
        successfulCreates++;
    } // for

    Globals.NumberLegacyPorts += successfulCreates;

MouseFindMorePortsExit:
    //
    // Free the unicode strings.
    //
    if (fullPortName.MaximumLength != 0) {
        ExFreePool(fullPortName.Buffer);
    }

    if (fullClassName) {
        ExFreePool(fullClassName);
    }
}

NTSTATUS
MouseClassEnableGlobalPort(
    IN PDEVICE_EXTENSION Port,
    IN BOOLEAN Enabled
    )
{
    NTSTATUS    status = STATUS_SUCCESS;
    PPORT       globalPort = NULL;
    BOOLEAN     enabled;
    ULONG       i;

    PAGED_CODE ();

    ExAcquireFastMutex (&Globals.Mutex);
    if (0 < Globals.Opens) {
        for (i = 0; i < Globals.NumAssocClass; i++) {
            if (! Globals.AssocClassList [i].Free) {
                if (Globals.AssocClassList[i].Port == Port) {
                    globalPort = &Globals.AssocClassList [i];
                    break;
                }
            }
        }
        ASSERTMSG ("What shall I do now?\n", (NULL != globalPort));

        //
        // This should never happen, globalPort should be in our list
        //
        if (globalPort == NULL) {
            ExReleaseFastMutex (&Globals.Mutex);
            return STATUS_NO_SUCH_DEVICE;
        }

        enabled = globalPort->Enabled;
        globalPort->Enabled = Enabled;

        ExReleaseFastMutex (&Globals.Mutex);

        //
        // Check to see if the port should change state. If so, send the new state
        // down the stack
        //
        if (Enabled != enabled  ) {
            status = MouEnableDisablePort (Enabled,
                                           NULL,
                                           Port,
                                           &globalPort->File);
        }
    } else {
        ExReleaseFastMutex (&Globals.Mutex);
    }

    return status;
}

NTSTATUS
MouseClassPlugPlayNotification(
    IN PTARGET_DEVICE_REMOVAL_NOTIFICATION NotificationStructure,
    IN PDEVICE_EXTENSION Port
    )
/*++

Routine Description:

    This routine is called as the result of recieving PlugPlay Notifications
    as registered by the previous call to IoRegisterPlugPlayNotification.

    Currently this should only occur for Target Device Notifications

Arguments:

    NotificationStructure - what happened.
    Port - The Fdo to which things happened.

Return Value:



--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    PVOID       notify = NULL;

    PAGED_CODE ();

    ASSERT (Globals.GrandMaster->Self == Port->TrueClassDevice);

    if (IsEqualGUID ((LPGUID) &(NotificationStructure->Event),
                     (LPGUID) &GUID_TARGET_DEVICE_QUERY_REMOVE)) {

        //
        // Our port device object will soon be receiving a query remove.
        // Before that query remove will actually be sent to the device object
        // stack itself the plug and play subsystem will send those registered
        // for target device notification the message first.
        //

        //
        // What we should do is now close the handle.
        // Because if we do not the query remove will fail before it ever
        // gets to the IRP_MJ_PNP IRP_MN_QUERY_REMOVE stage, as the PlugPlay
        // system fails before it is sent based on there being an open handle
        // to the device.
        //
        // DbgPrint ("Mouse QUERY Remove\n");
        // DbgBreakPoint();

        status = MouseClassEnableGlobalPort (Port, FALSE);

    } else if(IsEqualGUID ((LPGUID)&(NotificationStructure->Event),
                           (LPGUID)&GUID_TARGET_DEVICE_REMOVE_COMPLETE)) {

        //
        // Here the device has disappeared.
        //
        // DbgPrint ("Mouse Remove Complete\n");
        // DbgBreakPoint();

        notify = InterlockedExchangePointer (&Port->TargetNotifyHandle,
                                             NULL);

        if (NULL != notify) {
            //
            // Deregister
            //
            IoUnregisterPlugPlayNotification (notify);

            status = MouseClassEnableGlobalPort (Port, FALSE);
        }

    } else if(IsEqualGUID ((LPGUID)&(NotificationStructure->Event),
                           (LPGUID)&GUID_TARGET_DEVICE_REMOVE_CANCELLED)) {

        //
        // The query remove has been revoked.
        // Reopen the device.
        //
        // DbgPrint ("Mouse Remove Complete\n");
        // DbgBreakPoint();

        notify = InterlockedExchangePointer (&Port->TargetNotifyHandle,
                                             NULL);

        if (NULL != notify) {
            //
            // Deregister
            //
            IoUnregisterPlugPlayNotification (notify);

            status = MouseClassEnableGlobalPort (Port, TRUE);
        }
    }

    return status;
}

VOID
MouseClassPoRequestComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
MouseClassPowerComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
MouseClassWWPowerUpComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:
    Catch the Wait wake Irp on its way back.

Return Value:

--*/
{
    PDEVICE_EXTENSION       data = Context;
    POWER_STATE             powerState;
    NTSTATUS                status;
    PMOUSE_WORK_ITEM_DATA   itemData;

    ASSERT (MinorFunction == IRP_MN_SET_POWER);

    if (data->WaitWakeEnabled) {
        //
        // We cannot call CreateWaitWake from this completion routine,
        // as it is a paged function.
        //
        itemData = (PMOUSE_WORK_ITEM_DATA)
                ExAllocatePool (NonPagedPool, sizeof (MOUSE_WORK_ITEM_DATA));

        if (NULL != itemData) {
            itemData->Item = IoAllocateWorkItem (data->Self);
            if (itemData->Item == NULL) {
                ExFreePool (itemData);
                goto CreateWaitWakeWorkerError;
            }

            itemData->Data = data;
            itemData->Irp = NULL;
            status = IoAcquireRemoveLock (&data->RemoveLock, itemData);
            if (NT_SUCCESS(status)) {
                IoQueueWorkItem (itemData->Item,
                                 MouseClassCreateWaitWakeIrpWorker,
                                 DelayedWorkQueue,
                                 itemData);
            }
            else {
                //
                // The device has been removed
                //
                IoFreeWorkItem (itemData->Item);
                ExFreePool (itemData);
            }
        } else {
CreateWaitWakeWorkerError:
            //
            // Well, we dropped the WaitWake.
            //
            // Print a warning to the debugger, and log an error.
            //
            DbgPrint ("MouClass: WARNING: Failed alloc pool -> no WW Irp\n");

            MouseClassLogError (data->Self,
                                MOUCLASS_NO_RESOURCES_FOR_WAITWAKE,
                                1,
                                STATUS_INSUFFICIENT_RESOURCES,
                                0,
                                NULL,
                                0);
        }
    }
}

VOID
MouseClassWaitWakeComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:
    Catch the Wait wake Irp on its way back.

Return Value:

--*/
{
    PDEVICE_EXTENSION   data = Context;
    POWER_STATE         powerState;
    NTSTATUS            status;
    PMOUSE_WORK_ITEM_DATA   itemData;

    ASSERT (MinorFunction == IRP_MN_WAIT_WAKE);
    //
    // PowerState.SystemState is undefined when the WW irp has been completed
    //
    // ASSERT (PowerState.SystemState == PowerSystemWorking);

    if (InterlockedExchangePointer(&data->ExtraWaitWakeIrp, NULL)) {
        ASSERT(IoStatus->Status == STATUS_INVALID_DEVICE_STATE);
    } else {
        InterlockedExchangePointer(&data->WaitWakeIrp, NULL);
    }

    switch (IoStatus->Status) {

    case STATUS_SUCCESS:
        MouPrint((1, "MouClass: Wake irp was completed successfully.\n"));

        //
        //      We need to request a set power to power up the device.
        //
        powerState.DeviceState = PowerDeviceD0;
        status = PoRequestPowerIrp(
                    data->PDO,
                    IRP_MN_SET_POWER,
                    powerState,
                    MouseClassWWPowerUpComplete,
                    Context,
                    NULL);

        //
        // We do not notify the system that a user is present because:
        // 1  Win9x doesn't do this and we must maintain compatibility with it
        // 2  The USB PIX4 motherboards sends a wait wake event every time the
        //    machine wakes up, no matter if this device woke the machine or not
        //
        // If we incorrectly notify the system a user is present, the following
        // will occur:
        // 1  The monitor will be turned on
        // 2  We will prevent the machine from transitioning from standby
        //    (to PowerSystemWorking) to hibernate
        //
        // If a user is truly present, we will receive input in the service
        // callback and we will notify the system at that time.
        //
        // PoSetSystemState (ES_USER_PRESENT);

        // fall through to the break

    //
    // We get a remove.  We will not (obviously) send another wait wake
    //
    case STATUS_CANCELLED:

    //
    // This status code will be returned if the device is put into a power state
    // in which we cannot wake the machine (hibernate is a good example).  When
    // the device power state is returned to D0, we will attempt to rearm wait wake
    //
    case STATUS_POWER_STATE_INVALID:
    case STATUS_ACPI_POWER_REQUEST_FAILED:

    //
    // We failed the Irp because we already had one queued, or a lower driver in
    // the stack failed it.  Either way, don't do anything.
    //
    case STATUS_INVALID_DEVICE_STATE:

    //
    // Somehow someway we got two WWs down to the lower stack.
    // Let's just don't worry about it.
    //
    case STATUS_DEVICE_BUSY:
        break;

    default:
        //
        // Something went wrong, disable the wait wake.
        //
        KdPrint(("MOUCLASS:  wait wake irp failed with %x\n", IoStatus->Status));
        MouseToggleWaitWake (data, FALSE);
    }
}

BOOLEAN
MouseClassCheckWaitWakeEnabled(
    IN PDEVICE_EXTENSION Data
    )
{
    KIRQL irql;
    BOOLEAN enabled;

    KeAcquireSpinLock (&Data->WaitWakeSpinLock, &irql);
    enabled = Data->WaitWakeEnabled;
    KeReleaseSpinLock (&Data->WaitWakeSpinLock, irql);

    return enabled;
}

void
MouseClassCreateWaitWakeIrpWorker (
    IN PDEVICE_OBJECT DeviceObject,
    IN PMOUSE_WORK_ITEM_DATA  ItemData
    )
{
    PAGED_CODE ();

    MouseClassCreateWaitWakeIrp (ItemData->Data);
    IoReleaseRemoveLock (&ItemData->Data->RemoveLock, ItemData);
    IoFreeWorkItem (ItemData->Item);
    ExFreePool (ItemData);
}

BOOLEAN
MouseClassCreateWaitWakeIrp (
    IN PDEVICE_EXTENSION Data
    )
/*++

Routine Description:
    Catch the Wait wake Irp on its way back.

Return Value:

--*/
{
    POWER_STATE powerState;
    BOOLEAN     success = TRUE;
    NTSTATUS    status;
    PIRP        waitWakeIrp = NULL;

    PAGED_CODE ();

    powerState.SystemState = Data->MinSystemWakeState;
    status = PoRequestPowerIrp (Data->PDO,
                                IRP_MN_WAIT_WAKE,
                                powerState,
                                MouseClassWaitWakeComplete,
                                Data,
                                NULL);

    if (status != STATUS_PENDING) {
        success = FALSE;
    }

    return success;
}

VOID
MouseToggleWaitWakeWorker(
    IN PDEVICE_OBJECT DeviceObject,
    IN PMOUSE_WORK_ITEM_DATA ItemData
    )
/*++

Routine Description:

--*/
{
    PDEVICE_EXTENSION   data;
    PIRP                waitWakeIrp = NULL;
    KIRQL               irql;
    BOOLEAN             wwState = ItemData->WaitWakeState ? TRUE : FALSE;
    BOOLEAN             toggled = FALSE;

    //
    // Can't be paged b/c we are using spin locks
    //
    // PAGED_CODE ();

    data = ItemData->Data;

    KeAcquireSpinLock (&data->WaitWakeSpinLock, &irql);

    if (wwState != data->WaitWakeEnabled) {
        toggled = TRUE;
        if (data->WaitWakeEnabled) {
            waitWakeIrp = (PIRP)
                InterlockedExchangePointer (&data->WaitWakeIrp, NULL);
        }

        data->WaitWakeEnabled = wwState;
    }

    KeReleaseSpinLock (&data->WaitWakeSpinLock, irql);

    if (toggled) {
        UNICODE_STRING strEnable;
        HANDLE         devInstRegKey;
        ULONG          tmp = wwState;

        //
        // write the value out to the registry
        //
        if ((NT_SUCCESS(IoOpenDeviceRegistryKey (data->PDO,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     STANDARD_RIGHTS_ALL,
                                     &devInstRegKey)))) {
            RtlInitUnicodeString (&strEnable, MOUSE_WAIT_WAKE_ENABLE);

            ZwSetValueKey (devInstRegKey,
                           &strEnable,
                           0,
                           REG_DWORD,
                           &tmp,
                           sizeof(tmp));

            ZwClose (devInstRegKey);
        }
    }

    if (toggled && wwState) {
        //
        // wwState is our new state, so WW was just turned on
        //
        MouseClassCreateWaitWakeIrp (data);
    }

    //
    // If we have an IRP, then WW has been toggled off, otherwise, if toggled is
    // TRUE, we need to save this in the reg and, perhaps, send down a new WW irp
    //
    if (waitWakeIrp) {
        IoCancelIrp (waitWakeIrp);
    }

    IoReleaseRemoveLock (&data->RemoveLock, MouseToggleWaitWakeWorker);
    IoFreeWorkItem (ItemData->Item);
    ExFreePool (ItemData);
}

NTSTATUS
MouseToggleWaitWake(
    PDEVICE_EXTENSION Data,
    BOOLEAN           WaitWakeState
    )
{
    NTSTATUS       status;
    PMOUSE_WORK_ITEM_DATA itemData;

    status = IoAcquireRemoveLock (&Data->RemoveLock, MouseToggleWaitWakeWorker);
    if (!NT_SUCCESS (status)) {
        //
        // Device has gone away, just silently exit
        //
        return status;
    }

    itemData = (PMOUSE_WORK_ITEM_DATA)
        ExAllocatePool(NonPagedPool, sizeof(MOUSE_WORK_ITEM_DATA));

    if (itemData) {
        itemData->Item = IoAllocateWorkItem (Data->Self);
        if (itemData->Item == NULL) {
            IoReleaseRemoveLock (&Data->RemoveLock, MouseToggleWaitWakeWorker);
        }
        else {
            itemData->Data = Data;
            itemData->WaitWakeState = WaitWakeState;

            if (KeGetCurrentIrql() == PASSIVE_LEVEL) {
                //
                // We are safely at PASSIVE_LEVEL, call callback directly to perform
                // this operation immediately.
                //
                MouseToggleWaitWakeWorker (Data->Self, itemData);

            } else {
                //
                // We are not at PASSIVE_LEVEL, so queue a workitem to handle this
                // at a later time.
                //
                IoQueueWorkItem (itemData->Item,
                                 MouseToggleWaitWakeWorker,
                                 DelayedWorkQueue,
                                 itemData);
            }
        }
    }
    else {
        IoReleaseRemoveLock (&Data->RemoveLock, MouseToggleWaitWakeWorker);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
MouseClassPower (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    The power dispatch routine.

    In all cases it must call PoStartNextPowerIrp
    In all cases (except failure) it must pass on the IRP to the lower driver.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    POWER_STATE_TYPE        powerType;
    PIO_STACK_LOCATION      stack;
    PDEVICE_EXTENSION       data;


    NTSTATUS        status;
    POWER_STATE     powerState;
    BOOLEAN         hookit = FALSE;
    BOOLEAN         pendit = FALSE;

    PAGED_CODE ();

    data = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation (Irp);
    powerType = stack->Parameters.Power.Type;
    powerState = stack->Parameters.Power.State;

    if (data == Globals.GrandMaster) {
        //
        // We should never get a power irp to the grand master.
        //
        ASSERT (data != Globals.GrandMaster);
        PoStartNextPowerIrp (Irp);
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return STATUS_NOT_SUPPORTED;

    } else if (!data->PnP) {
        //
        // We should never get a power irp to a non PnP device object.
        //
        ASSERT (data->PnP);
        PoStartNextPowerIrp (Irp);
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return STATUS_NOT_SUPPORTED;
    }

    status = IoAcquireRemoveLock (&data->RemoveLock, Irp);

    if (!NT_SUCCESS (status)) {
        PoStartNextPowerIrp (Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }

    switch (stack->MinorFunction) {
    case IRP_MN_SET_POWER:
        MouPrint((2,"MouCLASS-PnP Setting %s state to %d\n",
                  ((powerType == SystemPowerState) ?  "System" : "Device"),
                  powerState.SystemState));

        switch (powerType) {
        case DevicePowerState:
            status = Irp->IoStatus.Status = STATUS_SUCCESS;
            if (data->DeviceState < powerState.DeviceState) {
                //
                // Powering down
                //

                PoSetPowerState (data->Self, powerType, powerState);
                data->DeviceState = powerState.DeviceState;

            } else if (powerState.DeviceState < data->DeviceState) {
                //
                // Powering Up
                //
                hookit = TRUE;
            } // else  { no change }.

            break;

        case SystemPowerState:

            if (data->SystemState < powerState.SystemState) {
                //
                // Powering down
                //
                status = IoAcquireRemoveLock (&data->RemoveLock, Irp);
                if (!NT_SUCCESS(status)) {
                    //
                    // This should never happen b/c we successfully acquired
                    // the lock already, but we must handle this case
                    //
                    // The S irp will completed with the value in status
                    //
                    break;
                }

                if (WAITWAKE_ON (data) &&
                    powerState.SystemState < PowerSystemHibernate) {
                    ASSERT(powerState.SystemState >= PowerSystemWorking &&
                           powerState.SystemState < PowerSystemHibernate);

                    powerState.DeviceState =
                        data->SystemToDeviceState[powerState.SystemState];
                }
                else {
                    powerState.DeviceState = PowerDeviceD3;
                }

                IoMarkIrpPending(Irp);
                status = PoRequestPowerIrp (data->Self,
                                            IRP_MN_SET_POWER,
                                            powerState,
                                            MouseClassPoRequestComplete,
                                            Irp,
                                            NULL);

                if (!NT_SUCCESS(status)) {
                    //
                    // Failure...release the inner reference we just took
                    //
                    IoReleaseRemoveLock (&data->RemoveLock, Irp);

                    //
                    // Propagate the failure back to the S irp
                    //
                    PoStartNextPowerIrp (Irp);
                    Irp->IoStatus.Status = status;
                    IoCompleteRequest(Irp, IO_NO_INCREMENT);

                    //
                    // Release the outer reference (top of the function)
                    //
                    IoReleaseRemoveLock (&data->RemoveLock, Irp);

                    //
                    // Must return status pending b/c we marked the irp pending
                    // so we special case the return here and avoid overly
                    // complex processing at the end of the function.
                    //
                    return STATUS_PENDING;
                }
                else {
                    pendit = TRUE;
                }
            }
            else if (powerState.SystemState < data->SystemState) {
                //
                // Powering Up
                //
                hookit = TRUE;
                status = Irp->IoStatus.Status = STATUS_SUCCESS;
            } else {
                //
                // No change, but we want to make sure a wait wake irp is sent.
                //
                if (powerState.SystemState == PowerSystemWorking &&
                    SHOULD_SEND_WAITWAKE (data)) {
                    MouseClassCreateWaitWakeIrp (data);
                }
                status = Irp->IoStatus.Status = STATUS_SUCCESS;
            }
            break;
        }

        break;

    case IRP_MN_QUERY_POWER:
        ASSERT (SystemPowerState == powerType);

        //
        // Fail the query if we can't wake the machine.  We do, however, want to
        // let hibernate succeed no matter what (besides, it is doubtful that a
        // mouse can wait wake the machine out of S4).
        //
        if (powerState.SystemState < PowerSystemHibernate       &&
            powerState.SystemState > data->MinSystemWakeState   &&
            WAITWAKE_ON(data)) {
            status = STATUS_POWER_STATE_INVALID;
        }
        else {
            status = STATUS_SUCCESS;
        }

        Irp->IoStatus.Status = status;
        break;

    case IRP_MN_WAIT_WAKE:
        if (InterlockedCompareExchangePointer(&data->WaitWakeIrp,
                                              Irp,
                                              NULL) != NULL) {
            /*  When powering up with WW being completed at same time, there
                is a race condition between PoReq completion for S Irp and
                completion of WW irp. Steps to repro this:

                S irp completes and does PoReq of D irp with completion
                routine MouseClassPoRequestComplete
                WW Irp completion fires and the following happens:
                    set data->WaitWakeIrp to NULL
                    PoReq D irp with completion routine MouseClassWWPowerUpComplete

                MouseClassPoRequestComplete fires first and sees no WW queued,
                so it queues one.
                MouseClassWWPowerUpComplete fires second and tries to queue
                WW. When the WW arrives in mouclass, it sees there's one
                queued already, so it fails it with invalid device state.
                The completion routine, MouseClassWaitWakeComplete, fires
                and it deletes the irp from the device extension.

                This results in the appearance of wake being disabled,
                even though the first irp is still queued.
            */

            InterlockedExchangePointer(&data->ExtraWaitWakeIrp, Irp);
            status = STATUS_INVALID_DEVICE_STATE;
        }
        else {
            status = STATUS_SUCCESS;
        }
        break;

    default:
        break;
    }

    if (!NT_SUCCESS (status)) {
        Irp->IoStatus.Status = status;
        PoStartNextPowerIrp (Irp);
        IoCompleteRequest (Irp, IO_NO_INCREMENT);

    } else if (hookit) {
        status = IoAcquireRemoveLock (&data->RemoveLock, Irp);
        ASSERT (STATUS_SUCCESS == status);
        IoCopyCurrentIrpStackLocationToNext (Irp);

        IoSetCompletionRoutine (Irp,
                                MouseClassPowerComplete,
                                NULL,
                                TRUE,
                                TRUE,
                                TRUE);
        IoMarkIrpPending(Irp);
        PoCallDriver (data->TopPort, Irp);

        //
        // We are returning pending instead of the result from PoCallDriver becuase:
        // 1  we are changing the status in the completion routine
        // 2  we will not be completing this irp in the completion routine
        //
        status = STATUS_PENDING;

    } else if (pendit) {
        status = STATUS_PENDING;

    } else {
        PoStartNextPowerIrp (Irp);
        IoSkipCurrentIrpStackLocation (Irp);
        status = PoCallDriver (data->TopPort, Irp);
    }

    IoReleaseRemoveLock (&data->RemoveLock, Irp);
    return status;
}

VOID
MouseClassPoRequestComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE D_PowerState,
    IN PIRP S_Irp, // The S irp that caused us to request the power.
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PDEVICE_EXTENSION   data;
    PMOUSE_WORK_ITEM_DATA   itemData;

    data = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // If the S_Irp is present, we are powering down.  We do not pass the S_Irp
    // as a parameter to PoRequestPowerIrp when we are powering up
    //
    if (ARGUMENT_PRESENT(S_Irp)) {
        //
        // Powering Down
        //
        POWER_STATE powerState;

        //
        // Powering Down
        //
        powerState = IoGetCurrentIrpStackLocation(S_Irp)->Parameters.Power.State;
        PoSetPowerState (data->Self, SystemPowerState, powerState);
        data->SystemState = powerState.SystemState;

        PoStartNextPowerIrp (S_Irp);
        IoSkipCurrentIrpStackLocation (S_Irp);
        PoCallDriver (data->TopPort, S_Irp);

        //
        // Finally, release the lock we acquired based on this irp
        //
        IoReleaseRemoveLock (&data->RemoveLock, S_Irp);
    }
    else {
    // } else if (S_powerState.SystemState < data->SystemState) {
        //
        // Powering Up
        //

        //
        // We have come back to the PowerSystemWorking state and the device is
        // fully powered.  If we can (and should), send a wait wake irp down
        // the stack.  This is necessary because we might have gone into a power
        // state where the wait wake irp was invalid.
        //
        ASSERT(data->SystemState == PowerSystemWorking);

        if (SHOULD_SEND_WAITWAKE (data)) {
            //
            // We cannot call CreateWaitWake from this completion routine,
            // as it is a paged function.
            //
            itemData = (PMOUSE_WORK_ITEM_DATA)
                    ExAllocatePool (NonPagedPool, sizeof (MOUSE_WORK_ITEM_DATA));

            if (NULL != itemData) {
                NTSTATUS status;

                itemData->Item = IoAllocateWorkItem (data->Self);
                if (itemData->Item == NULL) {
                    ExFreePool (itemData);
                    goto CreateWaitWakeWorkerError;
                }

                itemData->Data = data;
                itemData->Irp = NULL;

                status = IoAcquireRemoveLock (&data->RemoveLock, itemData);
                if (NT_SUCCESS (status)) {
                    IoQueueWorkItem (itemData->Item,
                                     MouseClassCreateWaitWakeIrpWorker,
                                     DelayedWorkQueue,
                                     itemData);
                }
                else {
                    IoFreeWorkItem (itemData->Item);
                    ExFreePool (itemData);
                    goto CreateWaitWakeWorkerError;
                }
            } else {
CreateWaitWakeWorkerError:
                //
                // Well, we dropped the WaitWake.
                //
                // Print a warning to the debugger, and log an error.
                //
                DbgPrint ("MouClass: WARNING: Failed alloc pool -> no WW Irp\n");

                MouseClassLogError (data->Self,
                                    MOUCLASS_NO_RESOURCES_FOR_WAITWAKE,
                                    2,
                                    STATUS_INSUFFICIENT_RESOURCES,
                                    0,
                                    NULL,
                                    0);
            }
        }
    }
}

NTSTATUS
MouseClassPowerComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    NTSTATUS            status;
    POWER_STATE         powerState;
    POWER_STATE_TYPE    powerType;
    PIO_STACK_LOCATION  stack;
    PDEVICE_EXTENSION   data;

    data = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation (Irp);
    powerType = stack->Parameters.Power.Type;
    powerState = stack->Parameters.Power.State;

    ASSERT (data != Globals.GrandMaster);
    ASSERT (data->PnP);

    switch (stack->MinorFunction) {
    case IRP_MN_SET_POWER:
        switch (powerType) {
        case DevicePowerState:
            ASSERT (powerState.DeviceState < data->DeviceState);
            data->DeviceState = powerState.DeviceState;

            PoSetPowerState (data->Self, powerType, powerState);
            break;

        case SystemPowerState:
            ASSERT (powerState.SystemState < data->SystemState);
            //
            // Powering up
            //
            // Save the system state before we overwrite it
            //
            PoSetPowerState (data->Self, powerType, powerState);
            data->SystemState = powerState.SystemState;
            powerState.DeviceState = PowerDeviceD0;

            status = PoRequestPowerIrp (data->Self,
                                        IRP_MN_SET_POWER,
                                        powerState,
                                        MouseClassPoRequestComplete,
                                        NULL,
                                        NULL);

            //
            // Propagate the error if one occurred
            //
            if (!NT_SUCCESS(status)) {
                Irp->IoStatus.Status = status;
            }

            break;
        }
        break;

    default:
        ASSERT (0xBADBAD == stack->MinorFunction);
        break;
    }

    PoStartNextPowerIrp (Irp);
    IoReleaseRemoveLock (&data->RemoveLock, Irp);

    return STATUS_SUCCESS;
}

//
// WMI System Call back functions
//
NTSTATUS
MouseClassSystemControl (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++
Routine Description

    We have just received a System Control IRP.

    Assume that this is a WMI IRP and
    call into the WMI system library and let it handle this IRP for us.

--*/
{
    PDEVICE_EXTENSION       deviceExtension;
    SYSCTL_IRP_DISPOSITION disposition;
    NTSTATUS status;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    status = IoAcquireRemoveLock (&deviceExtension->RemoveLock, Irp);
    if (!NT_SUCCESS (status)) {
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    status = WmiSystemControl(&deviceExtension->WmiLibInfo,
                                 DeviceObject,
                                 Irp,
                                 &disposition);
    switch(disposition) {
    case IrpProcessed:
        //
        // This irp has been processed and may be completed or pending.
        //
        break;

    case IrpNotCompleted:
        //
        // This irp has not been completed, but has been fully processed.
        // we will complete it now
        //
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        break;

    case IrpForward:
    case IrpNotWmi:
        //
        // This irp is either not a WMI irp or is a WMI irp targetted
        // at a device lower in the stack.
        //
        status = MouseClassPassThrough(DeviceObject, Irp);
        break;

    default:
        //
        // We really should never get here, but if we do just forward....
        //
        ASSERT(FALSE);
        status = MouseClassPassThrough(DeviceObject, Irp);
        break;
    }

    IoReleaseRemoveLock (&deviceExtension->RemoveLock, Irp);
    return status;
}

NTSTATUS
MouseClassSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION   data;
    NTSTATUS            status;
    ULONG               size = 0;

    PAGED_CODE ();

    data = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    switch(GuidIndex) {
    case WMI_CLASS_DRIVER_INFORMATION:
        status = STATUS_WMI_READ_ONLY;
        break;

    case WMI_WAIT_WAKE:

        size = sizeof(BOOLEAN);

        if (BufferSize < size) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        } else if ((1 != DataItemId) || (0 != InstanceIndex)) {
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        status = MouseToggleWaitWake(data, *(PBOOLEAN) Buffer);
        break;

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest (DeviceObject,
                                 Irp,
                                 status,
                                 0,
                                 IO_NO_INCREMENT);

    return status;
}

NTSTATUS
MouseClassSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION   data;
    NTSTATUS            status;
    ULONG               size = 0;

    PAGED_CODE ();

    data = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    switch(GuidIndex) {
    case WMI_CLASS_DRIVER_INFORMATION:
        status = STATUS_WMI_READ_ONLY;
        break;

    case WMI_WAIT_WAKE: {
        size = sizeof(BOOLEAN);
        if (BufferSize < size) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        } else if (0 != InstanceIndex) {
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        status = MouseToggleWaitWake (data, * (PBOOLEAN) Buffer);
        break;
    }

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest (DeviceObject,
                                 Irp,
                                 status,
                                 size,
                                 IO_NO_INCREMENT);

    return status;
}

NTSTATUS
MouseClassQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG OutBufferSize,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    InstanceCount is the number of instnaces expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION   data;
    NTSTATUS    status;
    ULONG       size = 0;
    PMSMouse_ClassInformation classInformation;

    PAGED_CODE ()

    data = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    switch (GuidIndex) {
    case WMI_CLASS_DRIVER_INFORMATION:
        //
        // Only registers 1 instance for this guid
        //
        if ((0 != InstanceIndex) || (1 != InstanceCount)) {
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }
        size = sizeof (MSMouse_ClassInformation);

        if (OutBufferSize < size) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        classInformation = (PMSMouse_ClassInformation)Buffer;
        classInformation->DeviceId = (ULONGLONG) DeviceObject;
        *InstanceLengthArray = size;
        status = STATUS_SUCCESS;

        break;

    case WMI_WAIT_WAKE:
        //
        // Only registers 1 instance for this guid
        //
        if ((0 != InstanceIndex) || (1 != InstanceCount)) {
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }
        size = sizeof(BOOLEAN);

        if (OutBufferSize < size) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        *(PBOOLEAN) Buffer = (WAITWAKE_ON (data) ? TRUE : FALSE);
        *InstanceLengthArray = size;
        status = STATUS_SUCCESS;
        break;

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest (DeviceObject,
                                 Irp,
                                 status,
                                 size,
                                 IO_NO_INCREMENT);

    return status;
}

NTSTATUS
MouseClassQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered.

    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe all of the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device. These flags are ORed into the flags specified
        by the GUIDREGINFO for each guid.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. This is
        required

    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in
        *RegFlags.

Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = DeviceObject->DeviceExtension;

    *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
    *RegistryPath = &Globals.RegistryPath;
    *Pdo = deviceExtension->PDO;
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\mouser\cseries.h ===
/*++

Copyright (c) 1993  Microsoft Corporation
Copyright (c) 1993  Logitech Inc.

Module Name:

    cseries.h

Abstract:

    Support for the Logitech CSeries type mice.

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/

#ifndef CSERIES_H
#define CSERIES_H


//
// Includes.
//
#include "mouser.h"

#define CSER_PROTOCOL_MM        0
#define CSER_PROTOCOL_MAX       1

//
// Not implemented in this release.
//
//#define CSER_PROTOCOL_3B      1
//#define CSER_PROTOCOL_5B      2
//#define CSER_PROTOCOL_M       3
//#define CSER_PROTOCOL_RBPO    4
//#define CSER_PROTOCOL_ABPO    5
//#define CSER_PROTOCOL_MAX     6

//
// Time needed for a CSeries mouse to power up.
//
#define CSER_POWER_UP (500 * MS_TO_100_NS)

//
// The minimum inactive time needed for the mouse to power down correctly.
//
#define CSER_POWER_DOWN (500 * MS_TO_100_NS)

//
// Function prototypes.
//

NTSTATUS
CSerPowerUp(
    PDEVICE_EXTENSION   DeviceExtension 
    );

VOID
CSerSetReportRate(
    PDEVICE_EXTENSION   DeviceExtension,
    UCHAR               ReportRate
    );

VOID
CSerSetBaudRate(
    PDEVICE_EXTENSION   DeviceExtension,
    ULONG BaudRate
    // ULONG BaudClock
    );

PPROTOCOL_HANDLER
CSerSetProtocol(
    PDEVICE_EXTENSION   DeviceExtension,
    UCHAR               NewProtocol
    );

BOOLEAN
CSerDetect(
    PDEVICE_EXTENSION   DeviceExtension,
    PULONG              HardwareButtons
    );

BOOLEAN
CSerHandlerMM(
    IN PDEVICE_EXTENSION    DeviceExtension,
    IN PMOUSE_INPUT_DATA    CurrentInput,
    IN PHANDLER_DATA        HandlerData,
    IN UCHAR                Value,
    IN UCHAR                LineState
    );

#endif // CSERIES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\moufiltr\moufiltr.c ===
/*--         
Copyright (c) 1998, 1999  Microsoft Corporation

Module Name:

    moufiltr.c

Abstract:

Environment:

    Kernel mode only.

Notes:


--*/

#include "moufiltr.h"

NTSTATUS DriverEntry (PDRIVER_OBJECT, PUNICODE_STRING);

#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, DriverEntry)
#pragma alloc_text (PAGE, MouFilter_AddDevice)
#pragma alloc_text (PAGE, MouFilter_CreateClose)
#pragma alloc_text (PAGE, MouFilter_IoCtl)
#pragma alloc_text (PAGE, MouFilter_InternIoCtl)
#pragma alloc_text (PAGE, MouFilter_PnP)
#pragma alloc_text (PAGE, MouFilter_Power)
#pragma alloc_text (PAGE, MouFilter_Unload)
#endif

NTSTATUS
DriverEntry (
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    )
/*++
Routine Description:

    Initialize the entry points of the driver.

--*/
{
    ULONG i;

    UNREFERENCED_PARAMETER (RegistryPath);

    // 
    // Fill in all the dispatch entry points with the pass through function
    // and the explicitly fill in the functions we are going to intercept
    // 
    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = MouFilter_DispatchPassThrough;
    }

    DriverObject->MajorFunction [IRP_MJ_CREATE] =
    DriverObject->MajorFunction [IRP_MJ_CLOSE] =        MouFilter_CreateClose;
    DriverObject->MajorFunction [IRP_MJ_PNP] =          MouFilter_PnP;
    DriverObject->MajorFunction [IRP_MJ_POWER] =        MouFilter_Power;
    DriverObject->MajorFunction [IRP_MJ_INTERNAL_DEVICE_CONTROL] =
                                                        MouFilter_InternIoCtl;
    //
    // If you are planning on using this function, you must create another
    // device object to send the requests to.  Please see the considerations 
    // comments for MouFilter_DispatchPassThrough for implementation details.
    //
    // DriverObject->MajorFunction [IRP_MJ_DEVICE_CONTROL] = MouFilter_IoCtl;

    DriverObject->DriverUnload = MouFilter_Unload;
    DriverObject->DriverExtension->AddDevice = MouFilter_AddDevice;

    return STATUS_SUCCESS;
}

NTSTATUS
MouFilter_AddDevice(
    IN PDRIVER_OBJECT   Driver,
    IN PDEVICE_OBJECT   PDO
    )
{
    PDEVICE_EXTENSION        devExt;
    IO_ERROR_LOG_PACKET      errorLogEntry;
    PDEVICE_OBJECT           device;
    NTSTATUS                 status = STATUS_SUCCESS;

    PAGED_CODE();

    status = IoCreateDevice(Driver,                   
                            sizeof(DEVICE_EXTENSION), 
                            NULL,                    
                            FILE_DEVICE_MOUSE,    
                            0,                   
                            FALSE,              
                            &device            
                            );

    if (!NT_SUCCESS(status)) {
        return (status);
    }

    RtlZeroMemory(device->DeviceExtension, sizeof(DEVICE_EXTENSION));

    devExt = (PDEVICE_EXTENSION) device->DeviceExtension;
    devExt->TopOfStack = IoAttachDeviceToDeviceStack(device, PDO);
    if (devExt->TopOfStack == NULL) {
        IoDeleteDevice(device);
        return STATUS_DEVICE_NOT_CONNECTED; 
    }

    ASSERT(devExt->TopOfStack);

    devExt->Self =          device;
    devExt->PDO =           PDO;
    devExt->DeviceState =   PowerDeviceD0;

    devExt->SurpriseRemoved = FALSE;
    devExt->Removed =         FALSE;
    devExt->Started =         FALSE;

    device->Flags |= (DO_BUFFERED_IO | DO_POWER_PAGABLE);
    device->Flags &= ~DO_DEVICE_INITIALIZING;

    return status;
}

NTSTATUS
MouFilter_Complete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
/*++
Routine Description:

    Generic completion routine that allows the driver to send the irp down the 
    stack, catch it on the way up, and do more processing at the original IRQL.
    
--*/
{
    PKEVENT             event;

    event = (PKEVENT) Context;

    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(Irp);

    //
    // We could switch on the major and minor functions of the IRP to perform
    // different functions, but we know that Context is an event that needs
    // to be set.
    //
    KeSetEvent(event, 0, FALSE);

    //
    // Allows the caller to use the IRP after it is completed
    //
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
MouFilter_CreateClose (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++
Routine Description:

    Maintain a simple count of the creates and closes sent against this device
    
--*/
{
    PIO_STACK_LOCATION  irpStack;
    NTSTATUS            status;
    PDEVICE_EXTENSION   devExt;

    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    devExt = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    status = Irp->IoStatus.Status;

    switch (irpStack->MajorFunction) {
    case IRP_MJ_CREATE:
    
        if (NULL == devExt->UpperConnectData.ClassService) {
            //
            // No Connection yet.  How can we be enabled?
            //
            status = STATUS_INVALID_DEVICE_STATE;
        }
        else if ( 1 >= InterlockedIncrement(&devExt->EnableCount)) {
            //
            // First time enable here
            //
        }
        else {
            //
            // More than one create was sent down
            //
        }
    
        break;

    case IRP_MJ_CLOSE:

        ASSERT(0 < devExt->EnableCount);
    
        if (0 >= InterlockedDecrement(&devExt->EnableCount)) {
            //
            // successfully closed the device, do any appropriate work here
            //
        }

        break;
    }

    Irp->IoStatus.Status = status;

    //
    // Pass on the create and the close
    //
    return MouFilter_DispatchPassThrough(DeviceObject, Irp);
}

NTSTATUS
MouFilter_DispatchPassThrough(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        )
/*++
Routine Description:

    Passes a request on to the lower driver.
     
Considerations:
     
    If you are creating another device object (to communicate with user mode
    via IOCTLs), then this function must act differently based on the intended 
    device object.  If the IRP is being sent to the solitary device object, then
    this function should just complete the IRP (becuase there is no more stack
    locations below it).  If the IRP is being sent to the PnP built stack, then
    the IRP should be passed down the stack. 
    
    These changes must also be propagated to all the other IRP_MJ dispatch
    functions (such as create, close, cleanup, etc.) as well!

--*/
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Pass the IRP to the target
    //
    IoSkipCurrentIrpStackLocation(Irp);
        
    return IoCallDriver(((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->TopOfStack, Irp);
}           

NTSTATUS
MouFilter_InternIoCtl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is the dispatch routine for internal device control requests.
    There are two specific control codes that are of interest:
    
    IOCTL_INTERNAL_MOUSE_CONNECT:
        Store the old context and function pointer and replace it with our own.
        This makes life much simpler than intercepting IRPs sent by the RIT and
        modifying them on the way back up.
                                      
    IOCTL_INTERNAL_I8042_HOOK_MOUSE:
        Add in the necessary function pointers and context values so that we can
        alter how the ps/2 mouse is initialized.
                                            
    NOTE:  Handling IOCTL_INTERNAL_I8042_HOOK_MOUSE is *NOT* necessary if 
           all you want to do is filter MOUSE_INPUT_DATAs.  You can remove
           the handling code and all related device extension fields and 
           functions to conserve space.
                                         
Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    PIO_STACK_LOCATION          irpStack;
    PDEVICE_EXTENSION           devExt;
    KEVENT                      event;
    PCONNECT_DATA               connectData;
    PINTERNAL_I8042_HOOK_MOUSE  hookMouse;
    NTSTATUS                    status = STATUS_SUCCESS;

    devExt = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    Irp->IoStatus.Information = 0;
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {

    //
    // Connect a mouse class device driver to the port driver.
    //
    case IOCTL_INTERNAL_MOUSE_CONNECT:
        //
        // Only allow one connection.
        //
        if (devExt->UpperConnectData.ClassService != NULL) {
            status = STATUS_SHARING_VIOLATION;
            break;
        }
        else if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CONNECT_DATA)) {
            //
            // invalid buffer
            //
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // Copy the connection parameters to the device extension.
        //
        connectData = ((PCONNECT_DATA)
            (irpStack->Parameters.DeviceIoControl.Type3InputBuffer));

        devExt->UpperConnectData = *connectData;

        //
        // Hook into the report chain.  Everytime a mouse packet is reported to
        // the system, MouFilter_ServiceCallback will be called
        //
        connectData->ClassDeviceObject = devExt->Self;
        connectData->ClassService = MouFilter_ServiceCallback;

        break;

    //
    // Disconnect a mouse class device driver from the port driver.
    //
    case IOCTL_INTERNAL_MOUSE_DISCONNECT:

        //
        // Clear the connection parameters in the device extension.
        //
        // devExt->UpperConnectData.ClassDeviceObject = NULL;
        // devExt->UpperConnectData.ClassService = NULL;

        status = STATUS_NOT_IMPLEMENTED;
        break;

    //
    // Attach this driver to the initialization and byte processing of the 
    // i8042 (ie PS/2) mouse.  This is only necessary if you want to do PS/2
    // specific functions, otherwise hooking the CONNECT_DATA is sufficient
    //
    case IOCTL_INTERNAL_I8042_HOOK_MOUSE:   

        if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                 sizeof(INTERNAL_I8042_HOOK_MOUSE)) {
            //
            // invalid buffer
            //
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // Copy the connection parameters to the device extension.
        //
        hookMouse = (PINTERNAL_I8042_HOOK_MOUSE)
            (irpStack->Parameters.DeviceIoControl.Type3InputBuffer);

        //
        // Set isr routine and context and record any values from above this driver
        //
        devExt->UpperContext = hookMouse->Context;
        hookMouse->Context = (PVOID) DeviceObject;

        if (hookMouse->IsrRoutine) {
            devExt->UpperIsrHook = hookMouse->IsrRoutine;
        }
        hookMouse->IsrRoutine = (PI8042_MOUSE_ISR) MouFilter_IsrHook;

        //
        // Store all of the other functions we might need in the future
        //
        devExt->IsrWritePort = hookMouse->IsrWritePort;
        devExt->CallContext = hookMouse->CallContext;
        devExt->QueueMousePacket = hookMouse->QueueMousePacket;

        break;

    //
    // These internal ioctls are not supported by the new PnP model.
    //
#if 0       // obsolete
    case IOCTL_INTERNAL_MOUSE_ENABLE:
    case IOCTL_INTERNAL_MOUSE_DISABLE:
        status = STATUS_NOT_SUPPORTED;
        break;
#endif  // obsolete

    //
    // Might want to capture this in the future.  For now, then pass it down
    // the stack.  These queries must be successful for the RIT to communicate
    // with the mouse.
    //
    case IOCTL_MOUSE_QUERY_ATTRIBUTES:
    default:
        break;
    }

    if (!NT_SUCCESS(status)) {
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return status;
    }

    return MouFilter_DispatchPassThrough(DeviceObject, Irp);
}

NTSTATUS
MouFilter_PnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is the dispatch routine for plug and play irps 

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    PDEVICE_EXTENSION           devExt; 
    PIO_STACK_LOCATION          irpStack;
    NTSTATUS                    status = STATUS_SUCCESS;
    KIRQL                       oldIrql;
    KEVENT                      event;        

    PAGED_CODE();

    devExt = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    switch (irpStack->MinorFunction) {
    case IRP_MN_START_DEVICE: {

        //
        // The device is starting.
        //
        // We cannot touch the device (send it any non pnp irps) until a
        // start device has been passed down to the lower drivers.
        //
        IoCopyCurrentIrpStackLocationToNext(Irp);
        KeInitializeEvent(&event,
                          NotificationEvent,
                          FALSE
                          );

        IoSetCompletionRoutine(Irp,
                               (PIO_COMPLETION_ROUTINE) MouFilter_Complete, 
                               &event,
                               TRUE,
                               TRUE,
                               TRUE); // No need for Cancel

        status = IoCallDriver(devExt->TopOfStack, Irp);

        if (STATUS_PENDING == status) {
            KeWaitForSingleObject(
               &event,
               Executive, // Waiting for reason of a driver
               KernelMode, // Waiting in kernel mode
               FALSE, // No allert
               NULL); // No timeout
        }

        if (NT_SUCCESS(status) && NT_SUCCESS(Irp->IoStatus.Status)) {
            //
            // As we are successfully now back from our start device
            // we can do work.
            //
            devExt->Started = TRUE;
            devExt->Removed = FALSE;
            devExt->SurpriseRemoved = FALSE;
        }

        //
        // We must now complete the IRP, since we stopped it in the
        // completetion routine with MORE_PROCESSING_REQUIRED.
        //
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        break;
    }

    case IRP_MN_SURPRISE_REMOVAL:
        //
        // Same as a remove device, but don't call IoDetach or IoDeleteDevice
        //
        devExt->SurpriseRemoved = TRUE;

        // Remove code here

        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(devExt->TopOfStack, Irp);
        break;

    case IRP_MN_REMOVE_DEVICE:
        
        devExt->Removed = TRUE;

        // remove code here
        Irp->IoStatus.Status = STATUS_SUCCESS;

        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(devExt->TopOfStack, Irp);

        IoDetachDevice(devExt->TopOfStack); 
        IoDeleteDevice(DeviceObject);

        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_CANCEL_REMOVE_DEVICE:
    case IRP_MN_CANCEL_STOP_DEVICE:
    case IRP_MN_FILTER_RESOURCE_REQUIREMENTS: 
    case IRP_MN_STOP_DEVICE:
    case IRP_MN_QUERY_DEVICE_RELATIONS:
    case IRP_MN_QUERY_INTERFACE:
    case IRP_MN_QUERY_CAPABILITIES:
    case IRP_MN_QUERY_DEVICE_TEXT:
    case IRP_MN_QUERY_RESOURCES:
    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
    case IRP_MN_READ_CONFIG:
    case IRP_MN_WRITE_CONFIG:
    case IRP_MN_EJECT:
    case IRP_MN_SET_LOCK:
    case IRP_MN_QUERY_ID:
    case IRP_MN_QUERY_PNP_DEVICE_STATE:
    default:
        //
        // Here the filter driver might modify the behavior of these IRPS
        // Please see PlugPlay documentation for use of these IRPs.
        //
        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(devExt->TopOfStack, Irp);
        break;
    }

    return status;
}

NTSTATUS
MouFilter_Power(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    )
/*++

Routine Description:

    This routine is the dispatch routine for power irps   Does nothing except
    record the state of the device.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    PIO_STACK_LOCATION  irpStack;
    PDEVICE_EXTENSION   devExt;
    POWER_STATE         powerState;
    POWER_STATE_TYPE    powerType;

    PAGED_CODE();

    devExt = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    powerType = irpStack->Parameters.Power.Type;
    powerState = irpStack->Parameters.Power.State;

    switch (irpStack->MinorFunction) {
    case IRP_MN_SET_POWER:
        if (powerType  == DevicePowerState) {
            devExt->DeviceState = powerState.DeviceState;
        }

    case IRP_MN_QUERY_POWER:
    case IRP_MN_WAIT_WAKE:
    case IRP_MN_POWER_SEQUENCE:
    default:
        break;
    }

    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);
    return PoCallDriver(devExt->TopOfStack, Irp);
}

BOOLEAN
MouFilter_IsrHook (
    PDEVICE_OBJECT          DeviceObject, 
    PMOUSE_INPUT_DATA       CurrentInput, 
    POUTPUT_PACKET          CurrentOutput,
    UCHAR                   StatusByte,
    PUCHAR                  DataByte,
    PBOOLEAN                ContinueProcessing,
    PMOUSE_STATE            MouseState,
    PMOUSE_RESET_SUBSTATE   ResetSubState
)
/*++

Remarks:
    i8042prt specific code, if you are writing a packet only filter driver, you
    can remove this function

Arguments:

    DeviceObject - Our context passed during IOCTL_INTERNAL_I8042_HOOK_MOUSE
    
    CurrentInput - Current input packet being formulated by processing all the
                    interrupts

    CurrentOutput - Current list of bytes being written to the mouse or the
                    i8042 port.
                    
    StatusByte    - Byte read from I/O port 60 when the interrupt occurred                                            
    
    DataByte      - Byte read from I/O port 64 when the interrupt occurred. 
                    This value can be modified and i8042prt will use this value
                    if ContinueProcessing is TRUE

    ContinueProcessing - If TRUE, i8042prt will proceed with normal processing of
                         the interrupt.  If FALSE, i8042prt will return from the
                         interrupt after this function returns.  Also, if FALSE,
                         it is this functions responsibilityt to report the input
                         packet via the function provided in the hook IOCTL or via
                         queueing a DPC within this driver and calling the
                         service callback function acquired from the connect IOCTL
                                             
Return Value:

    Status is returned.

  --+*/
{
    PDEVICE_EXTENSION   devExt;
    BOOLEAN             retVal = TRUE;

    devExt = DeviceObject->DeviceExtension;

    if (devExt->UpperIsrHook) {
        retVal = (*devExt->UpperIsrHook) (
            devExt->UpperContext,
            CurrentInput,
            CurrentOutput,
            StatusByte,
            DataByte,
            ContinueProcessing,
            MouseState,
            ResetSubState
            );

        if (!retVal || !(*ContinueProcessing)) {
            return retVal;
        }
    }

    *ContinueProcessing = TRUE;
    return retVal;
}

VOID
MouFilter_ServiceCallback(
    IN PDEVICE_OBJECT DeviceObject,
    IN PMOUSE_INPUT_DATA InputDataStart,
    IN PMOUSE_INPUT_DATA InputDataEnd,
    IN OUT PULONG InputDataConsumed
    )
/*++

Routine Description:

    Called when there are mouse packets to report to the RIT.  You can do 
    anything you like to the packets.  For instance:
    
    o Drop a packet altogether
    o Mutate the contents of a packet 
    o Insert packets into the stream 
                    
Arguments:

    DeviceObject - Context passed during the connect IOCTL
    
    InputDataStart - First packet to be reported
    
    InputDataEnd - One past the last packet to be reported.  Total number of
                   packets is equal to InputDataEnd - InputDataStart
    
    InputDataConsumed - Set to the total number of packets consumed by the RIT
                        (via the function pointer we replaced in the connect
                        IOCTL)

Return Value:

    Status is returned.

--*/
{
    PDEVICE_EXTENSION   devExt;

    devExt = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // UpperConnectData must be called at DISPATCH
    //
    (*(PSERVICE_CALLBACK_ROUTINE) devExt->UpperConnectData.ClassService)(
        devExt->UpperConnectData.ClassDeviceObject,
        InputDataStart,
        InputDataEnd,
        InputDataConsumed
        );
}

VOID
MouFilter_Unload(
   IN PDRIVER_OBJECT Driver
   )
/*++

Routine Description:

   Free all the allocated resources associated with this driver.

Arguments:

   DriverObject - Pointer to the driver object.

Return Value:

   None.

--*/

{
    PAGED_CODE();

    UNREFERENCED_PARAMETER(Driver);

    ASSERT(NULL == Driver->DeviceObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\moufiltr\moufiltr.h ===
/*++
Copyright (c) 1997  Microsoft Corporation

Module Name:

    moufiltr.h

Abstract:

    This module contains the common private declarations for the mouse
    packet filter

Environment:

    kernel mode only

Notes:


Revision History:


--*/

#ifndef MOUFILTER_H
#define MOUFILTER_H

#include "ntddk.h"
#include "kbdmou.h"
#include <ntddmou.h>
#include <ntdd8042.h>

#define MOUFILTER_POOL_TAG (ULONG) 'tlFM'
#undef ExAllocatePool
#define ExAllocatePool(type, size) \
            ExAllocatePoolWithTag (type, size, MOUFILTER_POOL_TAG)

#if DBG

#define TRAP()                      DbgBreakPoint()
#define DbgRaiseIrql(_x_,_y_)       KeRaiseIrql(_x_,_y_)
#define DbgLowerIrql(_x_)           KeLowerIrql(_x_)

#else   // DBG

#define TRAP()
#define DbgRaiseIrql(_x_,_y_)
#define DbgLowerIrql(_x_)

#endif

typedef struct _DEVICE_EXTENSION
{
    //
    // A backpointer to the device object for which this is the extension
    //
    PDEVICE_OBJECT  Self;

    //
    // "THE PDO"  (ejected by the bus)
    //
    PDEVICE_OBJECT  PDO;

    //
    // The top of the stack before this filter was added.  AKA the location
    // to which all IRPS should be directed.
    //
    PDEVICE_OBJECT  TopOfStack;

    //
    // Number of creates sent down
    //
    LONG EnableCount;

    //
    // Previous hook routine and context
    //                               
    PVOID UpperContext;
    PI8042_MOUSE_ISR UpperIsrHook;

    //
    // Write to the mouse in the context of MouFilter_IsrHook
    //
    IN PI8042_ISR_WRITE_PORT IsrWritePort;

    //
    // Context for IsrWritePort, QueueMousePacket
    //
    IN PVOID CallContext;

    //
    // Queue the current packet (ie the one passed into MouFilter_IsrHook)
    // to be reported to the class driver
    //
    IN PI8042_QUEUE_PACKET QueueMousePacket;

    //
    // The real connect data that this driver reports to
    //
    CONNECT_DATA UpperConnectData;

    //
    // current power state of the device
    //
    DEVICE_POWER_STATE  DeviceState;

    //
    // State of the stack and this device object
    //
    BOOLEAN Started;
    BOOLEAN SurpriseRemoved;
    BOOLEAN Removed;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

//
// Prototypes
//

NTSTATUS
MouFilter_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT BusDeviceObject
    );

NTSTATUS
MouFilter_CreateClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MouFilter_DispatchPassThrough(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        );
   
NTSTATUS
MouFilter_InternIoCtl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MouFilter_IoCtl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MouFilter_PnP (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MouFilter_Power (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
MouFilter_IsrHook (
    PDEVICE_OBJECT          DeviceObject, 
    PMOUSE_INPUT_DATA       CurrentInput, 
    POUTPUT_PACKET          CurrentOutput,
    UCHAR                   StatusByte,
    PUCHAR                  DataByte,
    PBOOLEAN                ContinueProcessing,
    PMOUSE_STATE            MouseState,
    PMOUSE_RESET_SUBSTATE   ResetSubState
);

VOID
MouFilter_ServiceCallback(
    IN PDEVICE_OBJECT DeviceObject,
    IN PMOUSE_INPUT_DATA InputDataStart,
    IN PMOUSE_INPUT_DATA InputDataEnd,
    IN OUT PULONG InputDataConsumed
    );

VOID
MouFilter_Unload (
    IN PDRIVER_OBJECT DriverObject
    );

#endif  // MOUFILTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\mouser\cseries.c ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved
Copyright (c) 1993  Logitech Inc.

Module Name:

    cseries.c

Abstract:

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/

//
// Includes.
//

#include "ntddk.h"
#include "mouser.h"
#include "cseries.h"
#include "debug.h"

//
// Use the alloc_text pragma to specify the driver initialization routines
// (they can be paged out).
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CSerPowerUp)
#pragma alloc_text(PAGE,CSerSetReportRate)
#pragma alloc_text(PAGE,CSerSetBaudRate)
#pragma alloc_text(PAGE,CSerSetProtocol)
#pragma alloc_text(PAGE,CSerDetect)
#endif // ALLOC_PRAGMA

//
// Constants.
//

//
// The status command sent to the mouse.
//

#define CSER_STATUS_COMMAND 's'

//
// The query number of mouse buttons command sent to the mouse.
//

#define CSER_QUERY_BUTTONS_COMMAND 'k'

//
// Status report from a CSeries mouse.
//

#define CSER_STATUS 0x4F

//
// Timeout value for the status returned by a CSeries mouse.
//
// #define CSER_STATUS_DELAY (50 * MS_TO_100_NS)
#define CSER_STATUS_DELAY 50

//
// Time (in microconds) needed by the mouse to adapt to a new baud rate.
//

#define CSER_BAUDRATE_DELAY (2 * MS_TO_100_NS)

//
// Default baud rate and report rate.
//

#define CSER_DEFAULT_BAUDRATE   1200
#define CSER_DEFAULT_REPORTRATE 150

//
// Button/status definitions.
//

#define CSER_SYNCH_BIT     0x80

#define CSER_BUTTON_LEFT   0x04
#define CSER_BUTTON_RIGHT  0x01
#define CSER_BUTTON_MIDDLE 0x02

#define CSER_BUTTON_LEFT_SR   2
#define CSER_BUTTON_RIGHT_SL  1
#define CSER_BUTTON_MIDDLE_SL 1

#define SIGN_X 0x10
#define SIGN_Y 0x08

//
// Macros.
//

#define sizeofel(x) (sizeof(x)/sizeof(*x))

//
// Type definitions.
//

typedef struct _REPORT_RATE {
    CHAR Command;
    UCHAR ReportRate;
} REPORT_RATE;

typedef struct _PROTOCOL {
    CHAR Command;
    SERIAL_LINE_CONTROL LineCtrl;
    PPROTOCOL_HANDLER Handler;
} PROTOCOL;

typedef struct _CSER_BAUDRATE {
    CHAR *Command;
    ULONG BaudRate;
} CSER_BAUDRATE;

//
// Globals.
//

//
//  The baud rate at which we try to detect a mouse.
//

static ULONG BaudRateDetect[] = { 1200, 2400, 4800, 9600 };

//
// This list is indexed by protocol values PROTOCOL_*.
//

PROTOCOL Protocol[] = {
    {'S',
    // ACE_8BW | ACE_PEN | ACE_1SB,
    { STOP_BIT_1, 0, 8 },
    CSerHandlerMM
    },
    {'T',
    // ACE_8BW | ACE_1SB,
    { STOP_BIT_1, NO_PARITY, 8 },
    NULL
    },
    {'U',
    // ACE_8BW | ACE_1SB,
    { STOP_BIT_1, NO_PARITY, 8 },
    NULL
    },
    {'V',
    // ACE_7BW | ACE_1SB,
    { STOP_BIT_1, NO_PARITY, 7 },
    NULL
    },
    {'B',
    // ACE_7BW | ACE_PEN | ACE_EPS | ACE_1SB,
    { STOP_BIT_1, EVEN_PARITY, 7 },
    NULL
    },
    {'A',
    // ACE_7BW | ACE_PEN | ACE_EPS | ACE_1SB,
    { STOP_BIT_1, EVEN_PARITY, 7 },
    NULL
    }
};

static REPORT_RATE ReportRateTable[] = {
        {'D', 0 },
        {'J', 10},
        {'K', 20},
        {'L', 35},
        {'R', 50},
        {'M', 70},
        {'Q', 100},
        {'N', 150},
        {'O', 151}      // Continuous
};
static CSER_BAUDRATE CserBaudRateTable[] = {
    { "*n", 1200 },
    { "*o", 2400 },
    { "*p", 4800 },
    { "*q", 9600 }
};

NTSTATUS
CSerPowerUp(
    PDEVICE_EXTENSION   DeviceExtension 
    )
/*++

Routine Description:

    Powers up the mouse by making the RTS and DTR active.

Arguments:

    Port - Pointer to the serial port.

Return Value:

    TRUE.

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    IO_STATUS_BLOCK     iosb;
    KEVENT              event;
    ULONG               bits;
    ULONG               rtsDtr = SERIAL_RTS_STATE | SERIAL_DTR_STATE;
    
    PAGED_CODE();

    Print(DeviceExtension, DBG_SS_TRACE, ("(c) PowerUp called\n"));

    KeInitializeEvent(&event,
                      NotificationEvent,
                      FALSE
                      );
    //
	// set DTR
	//
	Print(DeviceExtension, DBG_SS_NOISE, ("(c) Setting DTR...\n"));
	status = SerialMouseIoSyncIoctl(IOCTL_SERIAL_SET_DTR,
								    DeviceExtension->TopOfStack, 
								    &event,
								    &iosb
                                    );

	// 
	// set RTS	
	//
	Print(DeviceExtension, DBG_SS_NOISE, ("(c) Setting RTS...\n"));
    status = SerialMouseIoSyncIoctl(IOCTL_SERIAL_SET_RTS,
								    DeviceExtension->TopOfStack, 
								    &event,
								    &iosb
                                    );

    //
    // If the lines are high, the power is on for at least 500 ms due to the
    // MSeries detection.
    //
	status = SerialMouseIoSyncIoctlEx(IOCTL_SERIAL_GET_MODEMSTATUS,
		                              DeviceExtension->TopOfStack, 
		                              &event,
		                              &iosb,
		                              NULL,
		                              0,
		                              &bits,
		                              sizeof(ULONG)
                                      );

	if (NT_SUCCESS(status) && ((rtsDtr & bits) == rtsDtr)) {
        //
        // Wait CSER_POWER_UP milliseconds for the mouse to power up 
        // correctly.
        //
        Print(DeviceExtension, DBG_SS_INFO,
              ("(c) Waiting awhile for the mouse to power up\n"));
        SerialMouseWait(DeviceExtension,
                        -CSER_POWER_UP
                        );
    }

    return status;
}


VOID
CSerSetReportRate(
    PDEVICE_EXTENSION   DeviceExtension,
    UCHAR               ReportRate
    )
/*++

Routine Description:

    Set the mouse report rate. This can range from 0 (prompt mode) to 
    continuous report rate.

Arguments:

    Port - Pointer to serial port.

    ReportRate - The desired report rate.

Return Value:

    None.

--*/
{
    LONG count;

    PAGED_CODE();

    Print(DeviceExtension, DBG_SS_TRACE, ("CSerSetReportRate called\n"));

    for (count = sizeofel(ReportRateTable) - 1; count >= 0; count--) {

        //
        // Get the character to send from the table.
        //

        if (ReportRate >= ReportRateTable[count].ReportRate) {

            //
            // Set the baud rate.
            //

            Print(DeviceExtension, DBG_SS_INFO,
                  ("New ReportRate: %u\n",
                  ReportRateTable[count].ReportRate
                  ));

            SerialMouseWriteChar(DeviceExtension, ReportRateTable[count].Command);
            break;
        }
    }

    return;
}

VOID
CSerSetBaudRate(
    PDEVICE_EXTENSION   DeviceExtension,
    ULONG               BaudRate
    )
/*++

Routine Description:

    Set the new mouse baud rate. This will change the serial port baud rate.

Arguments:

    Port - Pointer to the serial port.

    BaudRate - Desired baud rate.

    BaudClock - The external frequency driving the serial chip.

Return Value:

    None.

--*/
{
    LONG count;

    PAGED_CODE();

    Print(DeviceExtension, DBG_SS_TRACE, ("CSerSetBaudRate called\n"));

    //
    // Before we mess with the baud rate, put the mouse in prompt mode.
    //
    CSerSetReportRate(DeviceExtension, 0);

    for (count = sizeofel(CserBaudRateTable) - 1; count >= 0; count--) {
        if (BaudRate >= CserBaudRateTable[count].BaudRate) {

            //
            // Set the baud rate.
            //

            SerialMouseWriteString(DeviceExtension, CserBaudRateTable[count].Command);
            SerialMouseSetBaudRate(DeviceExtension, CserBaudRateTable[count].BaudRate);

            //
            // Delay to allow the UART and the mouse to synchronize 
            // correctly.  
            //
            SerialMouseWait(DeviceExtension,
                            -CSER_BAUDRATE_DELAY
                            );
            break;
        }
    }

    return;
}


PPROTOCOL_HANDLER
CSerSetProtocol(
    PDEVICE_EXTENSION   DeviceExtension,
    UCHAR               NewProtocol
    )
/*++

Routine Description:

    Change the mouse protocol.

    Note: Not all the protocols are implemented in this driver.

Arguments:

    Port - Pointer to the serial port.


Return Value:

    Address of the protocol handler function. See the interrupt service 
    routine.

--*/
{
    PAGED_CODE();

    Print(DeviceExtension, DBG_SS_TRACE, ("CSerSetProtocol called\n"));

    ASSERT(NewProtocol < CSER_PROTOCOL_MAX);

    //
    // Set the protocol.
    //
    SerialMouseWriteChar(DeviceExtension, Protocol[NewProtocol].Command);
    SerialMouseSetLineCtrl(DeviceExtension, &Protocol[NewProtocol].LineCtrl);

    Print(DeviceExtension, DBG_SS_INFO, ("NewProtocol: %u\n", NewProtocol & 0xFF));

    return Protocol[NewProtocol].Handler;
}

BOOLEAN
CSerDetect(
    PDEVICE_EXTENSION   DeviceExtension,
    PULONG              HardwareButtons
    )
/*++

Routine Description:

    Detection of a CSeries type mouse. The main steps are:

    - Power up the mouse.
    - Cycle through the available baud rates and try to get an answer 
      from the mouse.

    At the end of the routine, a default baud rate and report rate are set.

Arguments:

    Port - Pointer to the serial port.

    HardwareButtons - Returns the number of hardware buttons detected.

Return Value:

    TRUE if a CSeries type mouse is detected, otherwise FALSE.

--*/
{
    UCHAR status, numButtons;
    ULONG count;
    BOOLEAN detected = FALSE;

    Print(DeviceExtension, DBG_SS_TRACE, ("CSerDetect called\n"));

    //
    // Power up the mouse if necessary.
    //

    CSerPowerUp(DeviceExtension);

    //
    // Set the line control register to a format that the mouse can
    // understand (see below: the line is set after the report rate).
    //

    SerialMouseSetLineCtrl(DeviceExtension, &Protocol[CSER_PROTOCOL_MM].LineCtrl);

    //
    // Cycle through the different baud rates to detect the mouse.
    //

    for (count = 0; count < sizeofel(BaudRateDetect); count++) {

        SerialMouseSetBaudRate(DeviceExtension, BaudRateDetect[count]);

        //
        // Put the mouse in prompt mode.
        //

        CSerSetReportRate(DeviceExtension, 0);

        //
        // Set the MM protocol. This way we get the mouse to talk to us in a
        // specific format. This avoids receiving errors from the line 
        // register.
        //

        CSerSetProtocol(DeviceExtension, CSER_PROTOCOL_MM);

        //
        // Try to get the status byte.
        //

        SerialMouseWriteChar(DeviceExtension, CSER_STATUS_COMMAND);

        //
        // In case something is already there...
        //

        SerialMouseFlushReadBuffer(DeviceExtension);

        SerialMouseSetReadTimeouts(DeviceExtension, 50);
        //
        // Read back the status character.
        //
        if (NT_SUCCESS(SerialMouseReadChar(DeviceExtension, &status)) &&
            (status == CSER_STATUS)) {
            detected = TRUE;
            Print(DeviceExtension, DBG_SS_INFO,
                  ("Detected mouse at %u baud\n",
                  BaudRateDetect[count]
                  ));
            break;
        }
    }

    if (detected) {

        //
        // Get the number of buttons back from the mouse.
        //
        SerialMouseWriteChar(DeviceExtension, CSER_QUERY_BUTTONS_COMMAND);

        //
        // In case something is already there...
        //

        SerialMouseFlushReadBuffer(DeviceExtension);

        //
        // Read back the number of buttons.
        //
        SerialMouseSetReadTimeouts(DeviceExtension, CSER_STATUS_DELAY);
        if (NT_SUCCESS(SerialMouseReadChar(DeviceExtension, &numButtons))) {

            numButtons &= 0x0F;
            Print(DeviceExtension, DBG_SS_NOISE, 
                  ("Successfully read number of buttons (%1u)\n", numButtons));

            if (numButtons == 2 || numButtons == 3) {
                *HardwareButtons = numButtons;
            } else {
                *HardwareButtons = MOUSE_NUMBER_OF_BUTTONS;
            }
        } else {
            *HardwareButtons = MOUSE_NUMBER_OF_BUTTONS;
        }

        //
        // Make sure that all subsequent reads are blocking and do not timeout
        //
        SerialMouseSetReadTimeouts(DeviceExtension, 0);
    }

    //
    // Put the mouse back in a default mode. The protocol is already set.
    //
    CSerSetBaudRate(DeviceExtension, CSER_DEFAULT_BAUDRATE);
    CSerSetReportRate(DeviceExtension, CSER_DEFAULT_REPORTRATE);

    Print(DeviceExtension, DBG_SS_INFO,
          ("Detected: %s\n", detected ? "true" : "false"));
    Print(DeviceExtension, DBG_SS_INFO, ("Status byte: %#x\n", status));

    return detected;
}

BOOLEAN
CSerHandlerMM(
    IN PDEVICE_EXTENSION    DeviceExtension,
    IN PMOUSE_INPUT_DATA    CurrentInput,
    IN PHANDLER_DATA        HandlerData,
    IN UCHAR                Value,
    IN UCHAR                LineState)

/*++

Routine Description:

    This is the protocol handler routine for the MM protocol.

Arguments:

    CurrentInput - Pointer to the report packet.

    Value - The input buffer value.

    LineState - The serial port line state.

Return Value:

    Returns TRUE if the handler has a completed report.

--*/

{
    BOOLEAN retval = FALSE;

    Print(DeviceExtension, DBG_HANDLER_TRACE, ("MMHandler, enter\n"));

    if ((Value & CSER_SYNCH_BIT) && (HandlerData->State != STATE0)) {
        HandlerData->Error++;
        Print(DeviceExtension, DBG_HANDLER_ERROR, 
              ("Synch error. State: %u\n",
              HandlerData->State
              ));
        HandlerData->State = STATE0;
    }
    else if (!(Value & CSER_SYNCH_BIT) && (HandlerData->State == STATE0)) {
        HandlerData->Error++;
        Print(DeviceExtension, DBG_HANDLER_ERROR, 
              ("Synch error. State: %u\n",
              HandlerData->State
              ));
        goto LExit;
    }

    //
    // Check for a line state error.
    //
    Print(DeviceExtension, DBG_HANDLER_INFO,
          ("State%u\n", HandlerData->State));
    HandlerData->Raw[HandlerData->State] = Value;

    switch (HandlerData->State) {
    case STATE0:
    case STATE1:
        HandlerData->State++;
        break;

    case STATE2:
        HandlerData->State = STATE0;

        //
        // Buttons formatting.
        //
        CurrentInput->RawButtons =
            (HandlerData->Raw[STATE0] & CSER_BUTTON_LEFT) >> CSER_BUTTON_LEFT_SR;
        CurrentInput->RawButtons |=
            (HandlerData->Raw[STATE0] & CSER_BUTTON_RIGHT) << CSER_BUTTON_RIGHT_SL;
        CurrentInput->RawButtons |=
            (HandlerData->Raw[STATE0] & CSER_BUTTON_MIDDLE) << CSER_BUTTON_MIDDLE_SL;

        //
        // Displacement formatting.
        //

        CurrentInput->LastX = (HandlerData->Raw[STATE0] & SIGN_X) ?
            HandlerData->Raw[STATE1] :
            -(LONG)HandlerData->Raw[STATE1];

        //
        // Note: The Y displacement is positive to the south.
        //

        CurrentInput->LastY = (HandlerData->Raw[STATE0] & SIGN_Y) ?
            -(LONG)HandlerData->Raw[STATE2] :
            HandlerData->Raw[STATE2];

        Print(DeviceExtension, DBG_HANDLER_NOISE,
              ("Displacement X: %ld\n",
              CurrentInput->LastX
              ));
        Print(DeviceExtension, DBG_HANDLER_NOISE,
              ("Displacement Y: %ld\n",
              CurrentInput->LastY
              ));
        Print(DeviceExtension, DBG_HANDLER_NOISE,
              ("Raw Buttons: %0lx\n",
              CurrentInput->RawButtons
              ));

        //
        // The report is complete. Tell the interrupt handler to send it.
        //

        retval = TRUE;

        break;

    default:
        Print(DeviceExtension, DBG_HANDLER_ERROR,
              ("MM Handler failure: incorrect state value.\n"));
        ASSERT(FALSE);
    }

LExit:
    Print(DeviceExtension, DBG_HANDLER_TRACE, ("MMHandler, exit\n"));

    return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\mouser\debug.h ===
/*++

Copyright (c) 1997-1998 Microsoft Corporation, All Rights Reserved
Copyright (c) 1993  Logitech Inc.

Module Name:

    debug.h

Abstract:

    Debugging support.

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/

#ifndef DEBUG_H
#define DEBUG_H

#if DBG

#define DEFAULT_DEBUG_FLAGS 0x88880808 

#define DBG_ALWAYS                 0x00000000

#define DBG_STARTUP_SHUTDOWN_MASK  0x0000000F
#define DBG_SS_NOISE               0x00000001
#define DBG_SS_TRACE               0x00000002
#define DBG_SS_INFO                0x00000004
#define DBG_SS_ERROR               0x00000008

#define DBG_HANDLER_MASK           0x000000F0
#define DBG_HANDLER_NOISE          0x00000010
#define DBG_HANDLER_TRACE          0x00000020
#define DBG_HANDLER_INFO           0x00000040
#define DBG_HANDLER_ERROR          0x00000080

#define DBG_IOCTL_MASK             0x00000F00
#define DBG_IOCTL_NOISE            0x00000100
#define DBG_IOCTL_TRACE            0x00000200
#define DBG_IOCTL_INFO             0x00000400
#define DBG_IOCTL_ERROR            0x00000800

#define DBG_UART_MASK              0x0000F000
#define DBG_UART_NOISE             0x00001000
#define DBG_UART_TRACE             0x00002000
#define DBG_UART_INFO              0x00004000
#define DBG_UART_ERROR             0x00008000

#define DBG_CC_MASK                0x000F0000
#define DBG_CC_NOISE               0x00010000
#define DBG_CC_TRACE               0x00020000
#define DBG_CC_INFO                0x00040000
#define DBG_CC_ERROR               0x00080000

#define DBG_POWER_MASK             0x00F00000
#define DBG_POWER_NOISE            0x00100000
#define DBG_POWER_TRACE            0x00200000
#define DBG_POWER_INFO             0x00400000
#define DBG_POWER_ERROR            0x00800000

#define DBG_PNP_MASK               0x0F000000
#define DBG_PNP_NOISE              0x01000000
#define DBG_PNP_TRACE              0x02000000
#define DBG_PNP_INFO               0x04000000
#define DBG_PNP_ERROR              0x08000000

#define DBG_READ_MASK              0xF0000000
#define DBG_READ_NOISE             0x10000000
#define DBG_READ_TRACE             0x20000000
#define DBG_READ_INFO              0x40000000
#define DBG_READ_ERROR             0x80000000

#define Print(_ext_, _flags_, _x_) \
            if ((_ext_)->DebugFlags & (_flags_) || !(_flags_)) { \
               DbgPrint ("sermouse: "); \
               DbgPrint _x_; \
            }
#define TRAP() DbgBreakPoint()


#else  // MOUSER_VERBOSE

#define DEFAULT_DEBUG_FLAGS 0x0

#define Print(_e_,_l_,_x_)
#define TRAP()

#endif  // DBG


#endif // DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\mouser\detect.c ===
/*++

Copyright (c) 1997-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    detect.c

Abstract:

   Detection of surprise removal of the mouse.
   
Environment:

   Kernel mode only.

Notes:

Revision History:

--*/

#include "stdarg.h"
#include "stdio.h"
#include "string.h"
#include "ntddk.h"
#include "mouser.h"
#include "sermlog.h"
#include "debug.h"

VOID
SerialMouseSerialMaskEventWorker(
    PDEVICE_OBJECT DeviceObject,
    PIO_WORKITEM   Item
    );

NTSTATUS
SerialMouseSerialMaskEventComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    );

NTSTATUS
SerialMouseSendWaitMaskIrp(
    IN PDEVICE_EXTENSION DeviceExtension
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SerialMouseSerialMaskEventWorker)
#pragma alloc_text(PAGE, SerialMouseStartDetection)
#pragma alloc_text(PAGE, SerialMouseStopDetection)
#pragma alloc_text(PAGE, SerialMouseSendWaitMaskIrp)
#endif

NTSTATUS
SerialMouseSendWaitMaskIrp(
    IN PDEVICE_EXTENSION DeviceExtension
    )
{
    PIRP                irp;
    PIO_STACK_LOCATION  next;
    NTSTATUS            status;

    PAGED_CODE();

    irp = DeviceExtension->DetectionIrp;

    DeviceExtension->SerialEventBits = 0x0;

    //
    // Will be released in the completion routine
    //
    status = IoAcquireRemoveLock (&DeviceExtension->RemoveLock, irp);
    if (!NT_SUCCESS(status)) {
        return status;
    }
    
    IoReuseIrp(irp, STATUS_SUCCESS);

    next = IoGetNextIrpStackLocation(irp);
    next->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    next->Parameters.DeviceIoControl.IoControlCode = IOCTL_SERIAL_WAIT_ON_MASK;
    next->Parameters.DeviceIoControl.OutputBufferLength = sizeof(ULONG);
    irp->AssociatedIrp.SystemBuffer = &DeviceExtension->SerialEventBits;
    
    //
    // Hook a completion routine for when the device completes.
    //
    IoSetCompletionRoutine(irp,
                           SerialMouseSerialMaskEventComplete,
                           DeviceExtension,
                           TRUE,
                           TRUE,
                           TRUE);

    return IoCallDriver(DeviceExtension->TopOfStack, irp);
}

VOID
SerialMouseStartDetection(
    PDEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description

This will cancel any previous set on the timer and queue the timer for
DetectionTimeout # of seconds and repeatedly trigger the timer every
DetectionTimeout # of seconds.

Arguments:

    DeviceExtension - pointer to the device extension


Return Value:

    None
    
  --*/        
{
    IO_STATUS_BLOCK     iosb;
    KEVENT              event;
    ULONG               waitMask, bits = 0x0;
    NTSTATUS            status;
    PDEVICE_OBJECT      self;
    ULONG               statusBits[] = {
                            SERIAL_DSR_STATE,
                            SERIAL_CTS_STATE,
                            0x0
                        };
    ULONG               eventBits[] = {
                            SERIAL_EV_DSR,
                            SERIAL_EV_CTS,
                        };
    int                 i;

    PAGED_CODE();

    //
    // Check to see if removal detection was turned off in the registry
    //
    if (DeviceExtension->WaitEventMask == 0xffffffff) {
        DeviceExtension->DetectionSupported = FALSE;
        return;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    if (!DeviceExtension->WaitEventMask) {
        status = SerialMouseIoSyncIoctlEx(IOCTL_SERIAL_GET_MODEMSTATUS,
                                          DeviceExtension->TopOfStack, 
                                          &event,
                                          &iosb,
                                          NULL,
                                          0,
                                          &bits,
                                          sizeof(ULONG)
                                          );
    
        Print(DeviceExtension, DBG_SS_NOISE, 
              ("get modem status, NTSTATUS = 0x%x, bits = 0x%x\n",
              status, bits));

        if (!NT_SUCCESS(status) || !bits) {
            Print(DeviceExtension, DBG_SS_ERROR, 
                  ("modem status failed, status = 0x%x, bits are 0x%x\n",
                  status, bits));

            DeviceExtension->ModemStatusBits = 0x0;
            DeviceExtension->DetectionSupported = FALSE;

            return;
        }

        DeviceExtension->ModemStatusBits = bits;

        for (i = 0, waitMask = 0x0; statusBits[i] != 0x0; i++) {
            if (bits & statusBits[i]) {
                waitMask |= eventBits[i];
            }
        }

        Print(DeviceExtension, DBG_SS_NOISE, 
              ("event wait bits are 0x%x\n", waitMask));

    }
    else {
        waitMask = DeviceExtension->WaitEventMask;
    }

    status = SerialMouseIoSyncIoctlEx(IOCTL_SERIAL_SET_WAIT_MASK,
                                      DeviceExtension->TopOfStack,
                                      &event,
                                      &iosb,
                                      &waitMask,
                                      sizeof(ULONG),
                                      NULL,
                                      0);

    if (!NT_SUCCESS(status)) {
        Print(DeviceExtension, DBG_SS_ERROR, 
              ("set mask failed, status = 0x%x\n", status));

        DeviceExtension->DetectionSupported = FALSE;
        return;
    }

    self = DeviceExtension->Self;

    if (!DeviceExtension->DetectionIrp) {
        if (!(DeviceExtension->DetectionIrp =
                IoAllocateIrp(self->StackSize, FALSE))) {
            DeviceExtension->DetectionSupported = FALSE;
            return;
        }
    }

    status = SerialMouseSendWaitMaskIrp(DeviceExtension);

    Print(DeviceExtension, DBG_SS_NOISE, ("set wait event status = 0x%x\n", status));

    if (NT_SUCCESS(status)) {
        DeviceExtension->DetectionSupported = TRUE;
    }
    else {
        IoCancelIrp(DeviceExtension->DetectionIrp);
        DeviceExtension->DetectionSupported = FALSE;
    }
}

VOID
SerialMouseStopDetection(
    PDEVICE_EXTENSION DeviceExtension
    )
{
    PAGED_CODE();

    if (!DeviceExtension->DetectionSupported) {
        return;
    }

    if (!DeviceExtension->RemovalDetected) {
        IoCancelIrp(DeviceExtension->DetectionIrp);
    }
}

NTSTATUS
SerialMouseSerialMaskEventComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
{
    PDEVICE_EXTENSION       deviceExtension = (PDEVICE_EXTENSION) Context;
    PIO_WORKITEM            item;
    NTSTATUS                status;
    BOOLEAN                 killMouse = FALSE;

    //
    // DeviceObject is NULL b/c this driver was the one that allocated and sent
    // the irp, we must use deviceExtension->Self instead.
    //
    UNREFERENCED_PARAMETER(DeviceObject);

    if (!deviceExtension->Removed && !deviceExtension->SurpriseRemoved) {
        item = IoAllocateWorkItem(deviceExtension->Self);
        if (!item) {
            //
            // Well, we can't allocate the work item, so lets invalidate our device
            // state and hope everything gets torn down.
            //
            killMouse = TRUE;
        }
        else {
            status = IoAcquireRemoveLock(&deviceExtension->RemoveLock, item);

            if (NT_SUCCESS(status)) {
                IoQueueWorkItem (item,
                                 SerialMouseSerialMaskEventWorker,
                                 DelayedWorkQueue,
                                 item);
            }
            else {
                killMouse = TRUE;
            }
        }
    }

    if (killMouse) {
        deviceExtension->RemovalDetected = TRUE;
        IoInvalidateDeviceState(deviceExtension->PDO);
    }

    IoReleaseRemoveLock (&deviceExtension->RemoveLock,
                         deviceExtension->DetectionIrp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
SerialMouseSerialMaskEventWorker(
    PDEVICE_OBJECT DeviceObject,
    PIO_WORKITEM   Item
    )
{
    IO_STATUS_BLOCK     iosb;
    PIRP                irp;
    KEVENT              event;
    NTSTATUS            status;
    ULONG               bits;
    BOOLEAN             removeSelf = FALSE;
    PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;

    PAGED_CODE();

    irp = deviceExtension->DetectionIrp;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    switch (irp->IoStatus.Status) {
    case STATUS_SUCCESS:

        Print(deviceExtension, DBG_SS_NOISE, 
              ("SerialEventBits are 0x%x\n", deviceExtension->SerialEventBits));

        bits = 0x0;

        status = SerialMouseIoSyncIoctlEx(IOCTL_SERIAL_GET_MODEMSTATUS,
                                          deviceExtension->TopOfStack, 
                                          &event,
                                          &iosb,
                                          NULL,
                                          0,
                                          &bits,
                                          sizeof(ULONG)
                                          );
    
        Print(deviceExtension, DBG_SS_NOISE, 
              ("get modem status, NTSTATUS = 0x%x, bits = 0x%x, MSB = 0x%x\n",
              status, bits, deviceExtension->ModemStatusBits));

        //
        // Make sure that the lines truly changed
        //
        if (deviceExtension->ModemStatusBits == bits) {
            //
            // Resend the detection irp
            //
            SerialMouseSendWaitMaskIrp(deviceExtension);
        }
        else {
            //
            // The lines have changed, it is a hot removal
            //
            Print(deviceExtension, DBG_SS_NOISE, ("device hot removed!\n"));
    
            SerialMouseIoSyncInternalIoctl(IOCTL_INTERNAL_SERENUM_REMOVE_SELF,
                                           deviceExtension->TopOfStack, 
                                           &event,
                                           &iosb);
        
            deviceExtension->RemovalDetected = TRUE;
        }

        break;

    case STATUS_CANCELLED:
        //
        // We get here if the user manually removes the device (ie through the 
        // device manager) and we send the clean up irp down the stack
        //
        Print(deviceExtension, DBG_SS_NOISE, ("wait cancelled!\n"));
        if (deviceExtension->PowerState != PowerDeviceD0 &&
            !deviceExtension->PoweringDown) {
            deviceExtension->RemovalDetected = TRUE;
        }

        break;

    default:
        Print(deviceExtension, DBG_SS_ERROR, 
              ("unknown status in mask event (0x%x)\n",
               irp->IoStatus.Status));
        TRAP();
    }

    IoReleaseRemoveLock(&deviceExtension->RemoveLock, Item);
    IoFreeWorkItem(Item);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\mouser\io.c ===
/*++

Copyright (c) 1997-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    io.c

Abstract:

    Contains functions that communicate to the serial driver below sermouse in
    the stack.  This includes the read/complete loop mechanism to acquire bytes
    and IOCTL calls.

Environment:

    Kernel & user mode.

Revision History:

--*/


#include "mouser.h"
#include "debug.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, SerialMousepIoSyncIoctl)
#pragma alloc_text (PAGE, SerialMousepIoSyncIoctlEx)
#endif

//
// Private definitions.
//

NTSTATUS
SerialMouseReadComplete (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PDEVICE_EXTENSION    DeviceExtension  // (PVOID Context)
    )
/*++

Routine Description:

    This routine is the read IRP completion routine.  It is called when the
    serial driver satisfies (or rejects) the IRP request we sent it.  The
    read report is analysed, and a MOUSE_INPUT_DATA structure is built
    and sent to the mouse class driver via a callback routine.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

    Context - Pointer to the device context structure


Return Value:

    NTSTATUS result code.

--*/
{
    LARGE_INTEGER       li;
    ULONG               inputDataConsumed,
                        buttonsDelta,
                        i;
    NTSTATUS            status;
    PMOUSE_INPUT_DATA   currentInput;
    KIRQL               oldIrql;
    BOOLEAN             startRead = TRUE;

    Print(DeviceExtension, DBG_READ_TRACE, ("ReadComplete enter\n"));

    //
    // Obtain the current status of the IRP.
    //
    status = Irp->IoStatus.Status;

    Print(DeviceExtension, DBG_SS_NOISE,
          ("Comp Routine:  interlock was %d\n", DeviceExtension->ReadInterlock));

    //
    // If ReadInterlock is == START_READ, this func has been completed
    // synchronously.  Place IMMEDIATE_READ into the interlock to signify this
    // situation; this will notify StartRead to loop when IoCallDriver returns.
    // Otherwise, we have been completed async and it is safe to call StartRead()
    //
    startRead =
       (SERIAL_MOUSE_START_READ !=
        InterlockedCompareExchange(&DeviceExtension->ReadInterlock,
                                   SERIAL_MOUSE_IMMEDIATE_READ,
                                   SERIAL_MOUSE_START_READ));

    //
    // Determine if the IRP request was successful.
    //
    switch (status) {
    case STATUS_SUCCESS:
        //
        // The buffer of the context now contains a single byte from the device.
        //
        Print(DeviceExtension, DBG_READ_NOISE,
              ("read, Information = %d\n",
              Irp->IoStatus.Information
              ));

        //
        // Nothing read, just start another read and return
        //
        if (Irp->IoStatus.Information == 0) {
            break;
        }

        ASSERT(Irp->IoStatus.Information == 1);

        currentInput = &DeviceExtension->InputData;

        Print(DeviceExtension, DBG_READ_NOISE,
              ("byte is 0x%x\n",
              (ULONG) DeviceExtension->ReadBuffer[0]
              ));

        if ((*DeviceExtension->ProtocolHandler)(
                DeviceExtension,
                currentInput,
                &DeviceExtension->HandlerData,
                DeviceExtension->ReadBuffer[0],
                0
                )) {

            //
            // The report is complete, compute the button deltas and send it off
            //
            // Do we have a button state change?
            //
            if (DeviceExtension->HandlerData.PreviousButtons ^ currentInput->RawButtons) {
                //
                // The state of the buttons changed. Make some calculations...
                //
                buttonsDelta = DeviceExtension->HandlerData.PreviousButtons ^
                                    currentInput->RawButtons;

                //
                // Button 1.
                //
                if (buttonsDelta & MOUSE_BUTTON_1) {
                    if (currentInput->RawButtons & MOUSE_BUTTON_1) {
                        currentInput->ButtonFlags |= MOUSE_BUTTON_1_DOWN;
                    }
                    else {
                        currentInput->ButtonFlags |= MOUSE_BUTTON_1_UP;
                    }
                }

                //
                // Button 2.
                //
                if (buttonsDelta & MOUSE_BUTTON_2) {
                    if (currentInput->RawButtons & MOUSE_BUTTON_2) {
                        currentInput->ButtonFlags |= MOUSE_BUTTON_2_DOWN;
                    }
                    else {
                        currentInput->ButtonFlags |= MOUSE_BUTTON_2_UP;
                    }
                }

                //
                // Button 3.
                //
                if (buttonsDelta & MOUSE_BUTTON_3) {
                    if (currentInput->RawButtons & MOUSE_BUTTON_3) {
                        currentInput->ButtonFlags |= MOUSE_BUTTON_3_DOWN;
                    }
                    else {
                        currentInput->ButtonFlags |= MOUSE_BUTTON_3_UP;
                    }
                }

                DeviceExtension->HandlerData.PreviousButtons =
                    currentInput->RawButtons;
            }

            Print(DeviceExtension, DBG_READ_NOISE,
                  ("Buttons: %0lx\n",
                  currentInput->Buttons
                  ));

            if (DeviceExtension->EnableCount) {
                //
                // Synchronization issue -  it's not a big deal if .Enabled is set
                // FALSE after the condition above, but before the callback below,
                // so long as the .MouClassCallback field is not nulled.   This is
                // guaranteed since the disconnect IOCTL is not implemented yet.
                //
                // Mouse class callback assumes we are running at DISPATCH level,
                // however this IoCompletion routine can be running <= DISPATCH.
                // Raise the IRQL before calling the callback.
                //

                KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);

                //
                // Call the callback.
                //
                (*(PSERVICE_CALLBACK_ROUTINE)
                 DeviceExtension->ConnectData.ClassService) (
                     DeviceExtension->ConnectData.ClassDeviceObject,
                     currentInput,
                     currentInput+1,
                     &inputDataConsumed);

                //
                // Restore the previous IRQL right away.
                //
                KeLowerIrql(oldIrql);

                if (1 != inputDataConsumed) {
                    //
                    // oh well, the packet was not consumed, just drop it
                    //
                    Print(DeviceExtension, DBG_READ_ERROR,
                          ("packet not consumed!!!\n"));
                }
            }

            //
            // Clear the button flags for the next packet
            //
            currentInput->Buttons = 0;
        }

        break;

    case STATUS_TIMEOUT:
        // The IO timed out, this shouldn't happen because we set the timeouts
        // to never when the device was initialized
        break;

    case STATUS_CANCELLED:
        // The read IRP was cancelled.  Do not send any more read IRPs.
        //
        // Set the event so that the stop code can continue processing
        //
        KeSetEvent(&DeviceExtension->StopEvent, 0, FALSE);

    case STATUS_DELETE_PENDING:
    case STATUS_DEVICE_NOT_CONNECTED:
        //
        // The serial mouse object is being deleted.  We will soon
        // receive Plug 'n Play notification of this device's removal,
        // if we have not received it already.
        //
        Print(DeviceExtension, DBG_READ_INFO,
              ("removing lock on cancel, count is 0x%x\n",
              DeviceExtension->EnableCount));
        IoReleaseRemoveLock(&DeviceExtension->RemoveLock, DeviceExtension->ReadIrp);
        startRead = FALSE;

        break;

    default:
        //
        // Unknown device state
        //
        Print(DeviceExtension, DBG_READ_ERROR, ("read error\n"));
        TRAP();

    }

    if (startRead) {
        Print(DeviceExtension, DBG_READ_NOISE, ("calling StartRead directly\n"));
        SerialMouseStartRead(DeviceExtension);
    }
#if DBG
    else {
        Print(DeviceExtension, DBG_READ_NOISE, ("StartRead will loop\n"));
    }
#endif

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SerialMouseStartRead (
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    Initiates a read to the serial port driver.

    Note that the routine does not verify that the device context is in the
    OperationPending state, but simply assumes it.

    Note the IoCount must be incremented before entering into this read loop.

Arguments:

    DeviceExtension - Device context structure

Return Value:

    NTSTATUS result code from IoCallDriver().

--*/
{
    PIRP                irp;
    NTSTATUS            status = STATUS_SUCCESS;
    PIO_STACK_LOCATION  stack;
    PDEVICE_OBJECT      self;
    LONG                oldInterlock;
    KIRQL               irql;

    Print(DeviceExtension, DBG_READ_TRACE, ("Start Read: Enter\n"));

    irp = DeviceExtension->ReadIrp;

    while (1) {
        if ((DeviceExtension->Removed)  ||
            (!DeviceExtension->Started) ||
            (DeviceExtension->EnableCount == 0)) {

            Print(DeviceExtension, DBG_READ_INFO | DBG_READ_ERROR,
                  ("removing lock on start read\n"));

            //
            // Set the event so that the stop code can continue processing
            //
            KeSetEvent(&DeviceExtension->StopEvent, 0, FALSE);

            IoReleaseRemoveLock(&DeviceExtension->RemoveLock,
                                DeviceExtension->ReadIrp);

            return STATUS_UNSUCCESSFUL;
        }

        //
        // Make sure we have not been stopped
        //
        KeAcquireSpinLock(&DeviceExtension->PnpStateLock, &irql);
        if (DeviceExtension->Stopped) {
            KeReleaseSpinLock(&DeviceExtension->PnpStateLock, irql);

            //
            // Set the event so that the stop code can continue processing
            //
            KeSetEvent(&DeviceExtension->StopEvent, 0, FALSE);

            //
            // Release the remove lock that we acquired when we started the read
            // spinner irp
            //
            IoReleaseRemoveLock(&DeviceExtension->RemoveLock,
                                DeviceExtension->ReadIrp);

            return STATUS_SUCCESS;
        }

        //
        // It is important to only reuse the irp when we are holding onto the
        // spinlock, otherwise we can race
        //
        IoReuseIrp(irp, STATUS_SUCCESS);

        KeReleaseSpinLock(&DeviceExtension->PnpStateLock, irql);

        //
        // This is where things get interesting.  We don't want to call
        // SerialMouseStartRead if this read was completed synchronously by the
        // serial provider because we can potentially run out of stack space.
        //
        // Here is how we solve this:
        // At the beginning of StartRead(), the interlock is set to START_READ

        // IoCallDriver is called...
        //  o  If the read will be completed asynchronously, then StartRead()
        //     will continue executing and set the interlock to END_READ.
        //  o  If the request will be completed synchronously, then the
        //     completion routine will run before StartRead() has the chance of
        //     setting the interlock to END_READ.  We note this situation by
        //     setting the interlock to IMMEDIATE_READ in the completion function.
        //     Furthermore, StartRead() will not be called from the completion
        //     routine as it would be in the async case
        //  o  Upon setting the interlock to END_READ in StartReaD(), the
        //     previous value is examined.  If it is IMMEDIATE_READ, then
        //     StartRead() loops and calls IoCallDriver from the same location
        //     within the (call) stack frame.  If the previous value was *not*
        //     IMMEDIATE_READ, then StartRead() exits and the completion routine
        //     will be called in another context (and, thus, another stack) and
        //     make the next call to StartRead()
        //
#if DBG
        oldInterlock =
#endif
        InterlockedExchange(&DeviceExtension->ReadInterlock,
                            SERIAL_MOUSE_START_READ);

        //
        // END_READ should be the only value here!!!  If not, the state machine
        // of the interlock has been broken
        //
        ASSERT(oldInterlock == SERIAL_MOUSE_END_READ);

        //
        // start this read.
        //
        self = DeviceExtension->Self;

        //
        // Set the stack location for the serenum stack
        //
        // Remember to get the file pointer correct.
        // NOTE: we do not have any of the cool thread stuff set.
        //       therefore we need to make sure that we cut this IRP off
        //       at the knees when it returns. (STATUS_MORE_PROCESSING_REQUIRED)
        //
        // Note also that serial does buffered i/o
        //

        irp->AssociatedIrp.SystemBuffer = (PVOID) DeviceExtension->ReadBuffer;

        stack = IoGetNextIrpStackLocation(irp);
        stack->Parameters.Read.Length = 1;
        stack->Parameters.Read.ByteOffset.QuadPart = (LONGLONG) 0;
        stack->MajorFunction = IRP_MJ_READ;

        //
        // Hook a completion routine for when the device completes.
        //
        IoSetCompletionRoutine(irp,
                               SerialMouseReadComplete,
                               DeviceExtension,
                               TRUE,
                               TRUE,
                               TRUE);

        status = IoCallDriver(DeviceExtension->TopOfStack, irp);

        if (InterlockedExchange(&DeviceExtension->ReadInterlock,
                                SERIAL_MOUSE_END_READ) !=
            SERIAL_MOUSE_IMMEDIATE_READ) {
            //
            // The read is asynch, will call SerialMouseStartRead from the
            // completion routine
            //
            Print(DeviceExtension, DBG_READ_NOISE, ("read is pending\n"));
            break;
        }
#if DBG
        else {
            //
            // The read was synchronous (probably bytes in the buffer).  The
            // completion routine will not call SerialMouseStartRead, so we
            // just loop here.  This is to prevent us from running out of stack
            // space if always call StartRead from the completion routine
            //
            Print(DeviceExtension, DBG_READ_NOISE, ("read is looping\n"));
        }
#endif
    }

    return status;
}

//
// Stripped down version of SerialMouseIoSyncIoctlEx that
// doesn't use input or output buffers
//
NTSTATUS
SerialMousepIoSyncIoctl(
    BOOLEAN          Internal,
    ULONG            Ioctl,
    PDEVICE_OBJECT   DeviceObject,
    PKEVENT          Event,
    PIO_STATUS_BLOCK Iosb)
{
    return SerialMousepIoSyncIoctlEx(Internal,
                                     Ioctl,
                                     DeviceObject,
                                     Event,
                                     Iosb,
                                     NULL,
                                     0,
                                     NULL,
                                     0);
}

NTSTATUS
SerialMousepIoSyncIoctlEx(
    BOOLEAN          Internal,
    ULONG            Ioctl,                     // io control code
    PDEVICE_OBJECT   DeviceObject,              // object to call
    PKEVENT          Event,                     // event to wait on
    PIO_STATUS_BLOCK Iosb,                      // used inside IRP
    PVOID            InBuffer,      OPTIONAL    // input buffer
    ULONG            InBufferLen,   OPTIONAL    // input buffer length
    PVOID            OutBuffer,     OPTIONAL    // output buffer
    ULONG            OutBufferLen)  OPTIONAL    // output buffer length
/*++

Routine Description:
    Performs a synchronous IO control request by waiting on the event object
    passed to it.  The IRP is deallocated by the IO system when finished.

Return value:
    NTSTATUS

--*/
{
    PIRP                irp;
    NTSTATUS            status;

    KeClearEvent(Event);

    //
    // Allocate an IRP - No need to release
    // When the next-lower driver completes this IRP, the I/O Manager releases it.
    //
    if (NULL == (irp = IoBuildDeviceIoControlRequest(Ioctl,
                                                     DeviceObject,
                                                     InBuffer,
                                                     InBufferLen,
                                                     OutBuffer,
                                                     OutBufferLen,
                                                     Internal,
                                                     Event,
                                                     Iosb))) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

     status = IoCallDriver(DeviceObject, irp);

     if (STATUS_PENDING == status) {
         //
         // wait for it...
         //
         status = KeWaitForSingleObject(Event,
                                        Executive,
                                        KernelMode,
                                        FALSE, // Not alertable
                                        NULL); // No timeout structure
     }

     if (NT_SUCCESS(status)) {
         status = Iosb->Status;
     }

     return status;
}

NTSTATUS
SerialMouseSetReadTimeouts(
    PDEVICE_EXTENSION DeviceExtension,
    ULONG               Timeout
    )
{
    NTSTATUS        status;
    SERIAL_TIMEOUTS serialTimeouts;
    KEVENT          event;
    IO_STATUS_BLOCK iosb;

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    RtlZeroMemory(&serialTimeouts, sizeof(SERIAL_TIMEOUTS));

    if (Timeout != 0) {
        serialTimeouts.ReadIntervalTimeout = MAXULONG;
        serialTimeouts.ReadTotalTimeoutMultiplier = MAXULONG;
        serialTimeouts.ReadTotalTimeoutConstant = Timeout;
    }

    status =  SerialMouseIoSyncIoctlEx(IOCTL_SERIAL_SET_TIMEOUTS,
                                       DeviceExtension->TopOfStack,
                                       &event,
                                       &iosb,
                                       &serialTimeouts,
                                       sizeof(SERIAL_TIMEOUTS),
                                       NULL,
                                       0);

    return status;
}

NTSTATUS
SerialMouseReadSerialPortComplete(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PKEVENT              Event
    )
{
    UNREFERENCED_PARAMETER(DeviceObject);

    KeSetEvent(Event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SerialMouseReadSerialPort (
    PDEVICE_EXTENSION   DeviceExtension,
    PCHAR               ReadBuffer,
    USHORT              Buflen,
    PUSHORT             ActualBytesRead
    )
/*++

Routine Description:
    Performs a synchronous read on the serial port.  Used during setup so that
    the type of device can be determined.

Return value:
    NTSTATUS - STATUS_SUCCESS if the read was successful, error code otherwise

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PIRP                irp;
    KEVENT              event;
    IO_STATUS_BLOCK     iosb;
    PDEVICE_OBJECT      self;
    PIO_STACK_LOCATION  stack;
    SERIAL_TIMEOUTS     serialTimeouts;
    int                 i, numReads;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    self = DeviceExtension->Self;
    irp = DeviceExtension->ReadIrp;

    Print(DeviceExtension, DBG_SS_TRACE, ("Read pending...\n"));

    *ActualBytesRead = 0;
    while (*ActualBytesRead < Buflen) {

        KeClearEvent(&event);
        IoReuseIrp(irp, STATUS_SUCCESS);

        irp->AssociatedIrp.SystemBuffer = ReadBuffer;

        stack = IoGetNextIrpStackLocation(irp);
        stack->Parameters.Read.Length = 1;
        stack->Parameters.Read.ByteOffset.QuadPart = (LONGLONG) 0;
        stack->MajorFunction = IRP_MJ_READ;

        //
        // Hook a completion routine for when the device completes.
        //
        IoSetCompletionRoutine(irp,
                               SerialMouseReadSerialPortComplete,
                               &event,
                               TRUE,
                               TRUE,
                               TRUE);


        status = IoCallDriver(DeviceExtension->TopOfStack, irp);

        if (status == STATUS_PENDING) {
            //
            // Wait for the IRP
            //
            status = KeWaitForSingleObject(&event,
                                           Executive,
                                           KernelMode,
                                           FALSE,
                                           NULL);

            if (status == STATUS_SUCCESS) {
                status = irp->IoStatus.Status;
            }
        }

        if (!NT_SUCCESS(status) || status == STATUS_TIMEOUT) {
            Print(DeviceExtension, DBG_SS_NOISE,
                  ("IO Call failed with status %x\n", status));
            return status;
        }

        *ActualBytesRead += (USHORT) irp->IoStatus.Information;
        ReadBuffer += (USHORT) irp->IoStatus.Information;
    }

    return status;
}

NTSTATUS
SerialMouseWriteSerialPort (
    PDEVICE_EXTENSION   DeviceExtension,
    PCHAR               WriteBuffer,
    ULONG               NumBytes,
    PIO_STATUS_BLOCK    IoStatusBlock
    )
/*++

Routine Description:
    Performs a synchronous write on the serial port.  Used during setup so that
    the device can be configured.

Return value:
    NTSTATUS - STATUS_SUCCESS if the read was successful, error code otherwise

--*/
{
    NTSTATUS        status;
    PIRP            irp;
    LARGE_INTEGER   startingOffset;
    KEVENT          event;

    int             i, numReads;

    startingOffset.QuadPart = (LONGLONG) 0;

    KeInitializeEvent(&event,
                      NotificationEvent,
                      FALSE);

    Print(DeviceExtension, DBG_SS_TRACE, ("Write pending...\n"));

    //
    // Create a new IRP because there's a chance that it might get cancelled.
    // Can't cancel irps that I received.
    // IRP_MJ_READ with completion routine
    //
    if (NULL == (irp = IoBuildSynchronousFsdRequest(
                IRP_MJ_WRITE,
                DeviceExtension->TopOfStack,
                WriteBuffer,
                NumBytes,
                &startingOffset,
                &event,
                IoStatusBlock
                ))) {
        Print(DeviceExtension, DBG_SS_ERROR, ("Failed to allocate IRP\n"));

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(DeviceExtension->TopOfStack, irp);

    if (status == STATUS_PENDING) {

        // I don't know at this time if I can wait with the default time of
        // 200 ms as I'm doing.  In the help file for IoBuildSynchronousFsdRequest
        // I think that it says I can't, but I'm not quite sure.
        // Presently I will.  I'll cancel the Irp if it isn't done.
        status = KeWaitForSingleObject(
                            &event,
                            Executive,
                            KernelMode,
                            FALSE, // Not alertable
                            NULL);
    }

    status = IoStatusBlock->Status;

    if (!NT_SUCCESS(status)) {
        Print(DeviceExtension, DBG_SS_ERROR,
              ("IO Call failed with status %x\n",
              status
              ));
        return status;
    }

    if (!NT_SUCCESS(status)) {
        Print(DeviceExtension, DBG_SS_ERROR,
              ("IO Call failed with status %x\n",
              status
              ));
    }

    return status;
}

NTSTATUS
SerialMouseWait (
    IN PDEVICE_EXTENSION    DeviceExtension,
    IN LONG                 Timeout
    )
/*++

Routine Description:
    Performs a wait for the specified time.
    NB: Negative time is relative to the current time.  Positive time
    represents an absolute time to wait until.

Return value:
    NTSTATUS

--*/
{
    LARGE_INTEGER time;

    time.QuadPart = (LONGLONG) Timeout;

    Print(DeviceExtension, DBG_READ_NOISE,
          ("waiting for %d micro secs\n", Timeout));

    if (KeSetTimer(&DeviceExtension->DelayTimer,
                   time,
                   NULL)) {
        Print(DeviceExtension, DBG_SS_INFO, ("Timer already set\n"));
    }

    return KeWaitForSingleObject(&DeviceExtension->DelayTimer,
                                 Executive,
                                 KernelMode,
                                 FALSE,             // Not allertable
                                 NULL);             // No timeout structure
}

NTSTATUS
SerialMouseInitializePort(
    PDEVICE_EXTENSION DeviceExtension
    )
{
    NTSTATUS        status;
    KEVENT          event;
    IO_STATUS_BLOCK iosb;
    SERIAL_TIMEOUTS serialTimeouts;
    SERIAL_HANDFLOW serialHandFlow;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    status =
        SerialMouseIoSyncInternalIoctlEx(IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS,
                                         DeviceExtension->TopOfStack,
                                         &event,
                                         &iosb,
                                         NULL,
                                         0,
                                         &DeviceExtension->SerialBasicSettings,
                                         sizeof(SERIAL_BASIC_SETTINGS));

    //
    // In case we are running on a port that does not support basic settings
    //
    if (!NT_SUCCESS(status)) {
        SerialMouseIoSyncIoctlEx(IOCTL_SERIAL_GET_TIMEOUTS,
                                 DeviceExtension->TopOfStack,
                                 &event,
                                 &iosb,
                                 NULL,
                                 0,
                                 &DeviceExtension->SerialBasicSettings.Timeouts,
                                 sizeof(SERIAL_TIMEOUTS));

        RtlZeroMemory(&serialTimeouts, sizeof(SERIAL_TIMEOUTS));

        SerialMouseIoSyncIoctlEx(IOCTL_SERIAL_SET_TIMEOUTS,
                                 DeviceExtension->TopOfStack,
                                 &event,
                                 &iosb,
                                 &serialTimeouts,
                                 sizeof(SERIAL_TIMEOUTS),
                                 NULL,
                                 0);

        SerialMouseIoSyncIoctlEx(IOCTL_SERIAL_GET_HANDFLOW,
                                 DeviceExtension->TopOfStack,
                                 &event,
                                 &iosb,
                                 NULL,
                                 0,
                                 &DeviceExtension->SerialBasicSettings.HandFlow,
                                 sizeof(SERIAL_HANDFLOW));

        serialHandFlow.ControlHandShake = SERIAL_DTR_CONTROL;
        serialHandFlow.FlowReplace = SERIAL_RTS_CONTROL;
        serialHandFlow.XonLimit = 0;
        serialHandFlow.XoffLimit = 0;

        status = SerialMouseIoSyncIoctlEx(IOCTL_SERIAL_SET_HANDFLOW,
                                          DeviceExtension->TopOfStack,
                                          &event,
                                          &iosb,
                                          &serialHandFlow,
                                          sizeof(SERIAL_HANDFLOW),
                                          NULL,
                                          0);
    }

    return status;
}

VOID
SerialMouseRestorePort(
    PDEVICE_EXTENSION DeviceExtension
    )
{
    KEVENT          event;
    IO_STATUS_BLOCK iosb;
    NTSTATUS        status;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    status =
        SerialMouseIoSyncInternalIoctlEx(IOCTL_SERIAL_INTERNAL_RESTORE_SETTINGS,
                                         DeviceExtension->TopOfStack,
                                         &event,
                                         &iosb,
                                         &DeviceExtension->SerialBasicSettings,
                                         sizeof(SERIAL_BASIC_SETTINGS),
                                         NULL,
                                         0);
    //
    // 4-24 Once serial.sys supports this new IOCTL, this code can be removed
    //
    if (!NT_SUCCESS(status)) {
        SerialMouseIoSyncIoctlEx(IOCTL_SERIAL_SET_TIMEOUTS,
                                 DeviceExtension->TopOfStack,
                                 &event,
                                 &iosb,
                                 &DeviceExtension->SerialBasicSettings.Timeouts,
                                 sizeof(SERIAL_TIMEOUTS),
                                 NULL,
                                 0);

        SerialMouseIoSyncIoctlEx(IOCTL_SERIAL_SET_HANDFLOW,
                                 DeviceExtension->TopOfStack,
                                 &event,
                                 &iosb,
                                 &DeviceExtension->SerialBasicSettings.HandFlow,
                                 sizeof(SERIAL_HANDFLOW),
                                 NULL,
                                 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\mouser\mouser.h ===
/*++

Copyright (c) 1989-1998 Microsoft Corporation, All Rights Reserved
Copyright (c) 1993  Logitech Inc.

Module Name:

    mouser.h

Abstract:

    These are the structures and defines that are used in the
    serial mouse filter driver.

Revision History:


--*/

#ifndef _MOUSER_
#define _MOUSER_

#include <ntddk.h>
#include <ntddmou.h>
#include <ntddser.h>
#include "kbdmou.h"

#include "wmilib.h"

#define SERMOU_POOL_TAG (ULONG) 'resM'
#undef ExAllocatePool
#define ExAllocatePool(type, size) \
            ExAllocatePoolWithTag (type, size, SERMOU_POOL_TAG);
//
// Default number of buttons and sample rate for the serial mouse.
//

#define MOUSE_NUMBER_OF_BUTTONS     2
#define MOUSE_SAMPLE_RATE           40    // 1200 baud
#define DETECTION_TIMEOUT_DEFAULT   50    // expressed in 10ths of a second
//
// Protocol handler state constants.
//

#define STATE0    0     // Sync bit, buttons and high x & y bits
#define STATE1    1     // lower x bits
#define STATE2    2     // lower y bits
#define STATE3    3     // Switch 2, extended packet bit & low z data
#define STATE4    4     // high z data
#define STATE_MAX 5

//
// Useful constants.
//

#define MOUSE_BUTTON_1  0x01
#define MOUSE_BUTTON_2  0x02
#define MOUSE_BUTTON_3  0x04

#define MOUSE_BUTTON_LEFT   0x01
#define MOUSE_BUTTON_RIGHT  0x02
#define MOUSE_BUTTON_MIDDLE 0x04

//
// Conversion factor for milliseconds to microseconds.
//

#define MS_TO_MICROSECONDS 1000

//
//  150/200 millisecond pause expressed in 100's of nanoseconds
//          200 ms * 1000  us/ms * 10 ns/100 us
//
#define PAUSE_200_MS            (200 * 1000 * 10)
#define PAUSE_150_MS            (150 * 1000 * 10)

//
// convert milliseconds to 100's of nanoseconds 
//      1000 us/ms * 10 ns/100 us
//
#define MS_TO_100_NS            10000
//
// Protocol handler static data.
//

typedef struct _HANDLER_DATA {
    ULONG       Error;              // Error count
    ULONG       State;              // Keep the current state
    ULONG       PreviousButtons;    // The previous button state
    UCHAR       Raw[STATE_MAX];     // Accumulate raw data
} HANDLER_DATA, *PHANDLER_DATA;


//
// Define the protocol handler type.
//

typedef BOOLEAN
(*PPROTOCOL_HANDLER)(
    IN PVOID                DevicExtension,
    IN PMOUSE_INPUT_DATA    CurrentInput,
    IN PHANDLER_DATA        HandlerData,
    IN UCHAR                Value,
    IN UCHAR                LineState);

//
// Defines for DeviceExtension->HardwarePresent.
// These should match the values in i8042prt
//

#define MOUSE_HARDWARE_PRESENT      0x02
#define BALLPOINT_HARDWARE_PRESENT  0x04
#define WHEELMOUSE_HARDWARE_PRESENT 0x08

#define SERIAL_MOUSE_START_READ     0x01
#define SERIAL_MOUSE_END_READ       0x02
#define SERIAL_MOUSE_IMMEDIATE_READ 0x03

//
// Port device extension.
//

typedef struct _DEVICE_EXTENSION {
    //
    // Debug flags
    //
    ULONG DebugFlags;

    //
    // Pointer back to the this extension's device object.
    //
    PDEVICE_OBJECT Self;

    //
    // An event to halt the deletion of a device until it is ready to go.
    //
    KEVENT StartEvent;

    //
    // The top of the stack before this filter was added.  AKA the location
    // to which all IRPS should be directed.
    //
    PDEVICE_OBJECT TopOfStack;

    //
    // "THE PDO"  (ejected by serenum)
    //
    PDEVICE_OBJECT PDO;

    //
    // Remove Lock object to protect IRP_MN_REMOVE_DEVICE
    //
    IO_REMOVE_LOCK RemoveLock;

    ULONG ReadInterlock;

    //
    // Pointer to the mouse class device object and callback routine
    // above us, Used as the first parameter and the  MouseClassCallback().
    // routine itself.
    //
    CONNECT_DATA ConnectData;

    //
    // Reference count for number of mouse enables.
    //
    LONG EnableCount;

    //
    // Sermouse created irp used to bounce reads down to the serial driver
    //
    PIRP ReadIrp;

    //
    // Sermouse created irp used to detect when the mouse has been hot plugged
    //
    PIRP DetectionIrp;

    ULONG SerialEventBits;

    //
    // WMI Information
    //
    WMILIB_CONTEXT WmiLibInfo;

    //
    // Attributes of the mouse
    //
    MOUSE_ATTRIBUTES MouseAttributes;

    //
    // Current mouse input packet.
    //
    MOUSE_INPUT_DATA InputData;

    //
    // Timer used during startup to follow power cycle detection protocol
    //
    KTIMER DelayTimer;

    //
    // Bits to use when testing if the device has been removed
    //
    ULONG WaitEventMask;

    ULONG ModemStatusBits;

    //
    // Request sequence number (used for error logging).
    //
    ULONG SequenceNumber;

    //
    // Pointer to the interrupt protocol handler routine.
    //

    PPROTOCOL_HANDLER ProtocolHandler;

    //
    // Static state machine handler data.
    //
    HANDLER_DATA HandlerData;

    DEVICE_POWER_STATE PowerState;

    SERIAL_BASIC_SETTINGS SerialBasicSettings;

    KSPIN_LOCK PnpStateLock;

    KEVENT StopEvent;

    //
    // Has the device been taken out from under us?
    // Has it been started?
    //
    BOOLEAN Removed;
    BOOLEAN SurpriseRemoved;
    BOOLEAN Started;
    BOOLEAN Stopped;

    BOOLEAN RemovalDetected;

    //
    // Buffer used in the read irp
    //
    UCHAR ReadBuffer[1];

    //
    // Set to false if all the lines are low on the first attempt at detection
    // If false, all further attempts at detection are stopped
    //
    BOOLEAN DetectionSupported;

    BOOLEAN WaitWakePending;

    BOOLEAN PoweringDown;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

//
// Function prototypes.
//

/*
PUNICODE_STRING
SerialMouseGetRegistryPath(
    PDRIVER_OBJECT DriverObject
    );
*/
#define SerialMouseGetRegistryPath(DriverObject) \
   (PUNICODE_STRING)IoGetDriverObjectExtension(DriverObject, (PVOID) 1)
   
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
SerialMouseCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    );

VOID
SerialMouseClosePort(
    PDEVICE_EXTENSION DeviceExtension,
    PIRP              Irp
    );

NTSTATUS
SerialMouseSpinUpRead(
    PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
SerialMouseStartDevice(
    PDEVICE_EXTENSION DeviceExtension,
    PIRP              Irp,
    BOOLEAN           CloseOnFailure
    );

NTSTATUS
SerialMouseInitializeDevice (
    IN PDEVICE_EXTENSION    DeviceExtension
    );

VOID
SerialMouseStartDetection(
    PDEVICE_EXTENSION DeviceExtension
    );

VOID
SerialMouseStopDetection(
    PDEVICE_EXTENSION DeviceExtension
    );

VOID
SerialMouseDetectionDpc(
    IN PKDPC            Dpc,
    IN PDEVICE_OBJECT   DeviceObject,
    IN PVOID            SystemArg1, 
    IN PVOID            SystemArg2
    );

VOID
SerialMouseDetectionRoutine(
    PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
SerialMouseSendIrpSynchronously (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN BOOLEAN          CopyToNext
    );

NTSTATUS
SerialMouseFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialMouseInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialMouseAddDevice (
    IN PDRIVER_OBJECT   Driver,
    IN PDEVICE_OBJECT   PDO
    );

NTSTATUS
SerialMouseCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialMouseClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialMousePnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialMousePower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SerialMouseRemoveDevice(
    PDEVICE_EXTENSION DeviceExtension,
    PIRP Irp
    );

NTSTATUS
SerialMouseSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SerialMouseUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
SerialMouseInitializeHardware(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
SerialMouseGetDebugFlags(
    IN PUNICODE_STRING RegPath
    );

VOID
SerialMouseServiceParameters(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN HANDLE            Handle
    );

NTSTATUS
SerialMouseInitializePort(
    PDEVICE_EXTENSION DeviceExtension
    );

VOID
SerialMouseRestorePort(
    PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
SerialMouseSetReadTimeouts(
    PDEVICE_EXTENSION DeviceExtension,
    ULONG               Timeout
    );

NTSTATUS
SerialMousepIoSyncIoctl(
    BOOLEAN          Internal,
	ULONG            Ioctl,
	PDEVICE_OBJECT   DeviceObject, 
	PKEVENT          Event,
	PIO_STATUS_BLOCK Iosb
    );

/*--
NTSTATUS
SerialMouseIoSyncIoctl(
	ULONG            Ioctl,
	PDEVICE_OBJECT   DeviceObject, 
	PKEVENT          Event,
	PIO_STATUS_BLOCK Iosb
    );
  ++*/
#define SerialMouseIoSyncIoctl(Ioctl, DeviceObject, Event, Iosb)  \
        SerialMousepIoSyncIoctl(FALSE, Ioctl, DeviceObject, Event, Iosb)

/*--
NTSTATUS
SerialMouseIoSyncInteralIoctl(
	ULONG            Ioctl,
	PDEVICE_OBJECT   DeviceObject, 
	PKEVENT          Event,
	PIO_STATUS_BLOCK Iosb
    );
  ++*/
#define SerialMouseIoSyncInternalIoctl(Ioctl, DeviceObject, Event, Iosb) \
        SerialMousepIoSyncIoctl(TRUE, Ioctl, DeviceObject, Event, Iosb)                                   


NTSTATUS
SerialMousepIoSyncIoctlEx(
    BOOLEAN          Internal,
	ULONG            Ioctl,                     // io control code
    PDEVICE_OBJECT   DeviceObject,              // object to call
	PKEVENT          Event,                     // event to wait on
	PIO_STATUS_BLOCK Iosb,                      // used inside IRP
	PVOID            InBuffer,    OPTIONAL      // input buffer
	ULONG            InBufferLen, OPTIONAL      // input buffer length
	PVOID            OutBuffer,   OPTIONAL      // output buffer 
	ULONG            OutBufferLen OPTIONAL      // output buffer length 
    );

/*--
NTSTATUS
SerialMouseIoSyncIoctlEx(
	ULONG            Ioctl,                     // io control code
    PDEVICE_OBJECT   DeviceObject,              // object to call
	PKEVENT          Event,                     // event to wait on
	PIO_STATUS_BLOCK Iosb,                      // used inside IRP
	PVOID            InBuffer,    OPTIONAL      // input buffer
	ULONG            InBufferLen, OPTIONAL      // input buffer length
	PVOID            OutBuffer,   OPTIONAL      // output buffer 
	ULONG            OutBufferLen OPTIONAL      // output buffer length 
    );
  ++*/
#define SerialMouseIoSyncIoctlEx(Ioctl, DeviceObject, Event, Iosb,           \
                                 InBuffer, InBufferLen, OutBuffer,           \
                                 OutBufferLen)                               \
        SerialMousepIoSyncIoctlEx(FALSE, Ioctl, DeviceObject, Event, Iosb,   \
                                  InBuffer, InBufferLen, OutBuffer,          \
                                  OutBufferLen)                           

/*--
NTSTATUS
SerialMouseIoSyncInternalIoctlEx(
	ULONG            Ioctl,                     // io control code
    PDEVICE_OBJECT   DeviceObject,              // object to call
	PKEVENT          Event,                     // event to wait on
	PIO_STATUS_BLOCK Iosb,                      // used inside IRP
	PVOID            InBuffer,    OPTIONAL      // input buffer
	ULONG            InBufferLen, OPTIONAL      // input buffer length
	PVOID            OutBuffer,   OPTIONAL      // output buffer 
	ULONG            OutBufferLen OPTIONAL      // output buffer length 
    );
  ++*/
#define SerialMouseIoSyncInternalIoctlEx(Ioctl, DeviceObject, Event, Iosb,  \
                                         InBuffer, InBufferLen, OutBuffer,  \
                                         OutBufferLen)                      \
        SerialMousepIoSyncIoctlEx(TRUE, Ioctl, DeviceObject, Event, Iosb,   \
                                  InBuffer, InBufferLen, OutBuffer,         \
                                  OutBufferLen)                           

NTSTATUS
SerialMouseReadSerialPort (
    PDEVICE_EXTENSION	DeviceExtension,
	PCHAR 				ReadBuffer,
	USHORT 				Buflen,
	PUSHORT 			ActualBytesRead
	);

NTSTATUS
SerialMouseWriteSerialPort (
    PDEVICE_EXTENSION   DeviceExtension,
    PCHAR               WriteBuffer,
    ULONG               NumBytes,
    PIO_STATUS_BLOCK    IoStatusBlock
    );

NTSTATUS
SerialMouseWait (
    IN PDEVICE_EXTENSION    DeviceExtension,
    IN LONG                 Timeout
    );

NTSTATUS
SerialMouseReadComplete (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PDEVICE_EXTENSION    DeviceExtension  
    );

NTSTATUS
SerialMouseStartRead (
    IN PDEVICE_EXTENSION DeviceExtension
    );

//
// ioctl.c and SerialMouse definitions
//
    
//
// Function prototypes
//

NTSTATUS
SerialMouseSetFifo(
    PDEVICE_EXTENSION DeviceExtension,
    UCHAR             Value
    );

NTSTATUS
SerialMouseGetLineCtrl(
    PDEVICE_EXTENSION       DeviceExtension,
    PSERIAL_LINE_CONTROL    SerialLineControl
    );

NTSTATUS
SerialMouseSetLineCtrl(
    PDEVICE_EXTENSION       DeviceExtension,
    PSERIAL_LINE_CONTROL    SerialLineControl
    );

NTSTATUS
SerialMouseGetModemCtrl(
    PDEVICE_EXTENSION DeviceExtension,
    PULONG            ModemCtrl
    );

NTSTATUS
SerialMouseSetModemCtrl(
    PDEVICE_EXTENSION DeviceExtension,
    ULONG             Value,
    PULONG            OldValue          OPTIONAL
    );

NTSTATUS
SerialMouseGetBaudRate(
    PDEVICE_EXTENSION DeviceExtension,
    PULONG            BaudRate
    );

NTSTATUS
SerialMouseSetBaudRate(
    PDEVICE_EXTENSION DeviceExtension,
    ULONG             BaudRate
    );

NTSTATUS
SerialMouseReadChar(
    PDEVICE_EXTENSION   DeviceExtension,
    PUCHAR              Value
    );

NTSTATUS
SerialMouseFlushReadBuffer(
    PDEVICE_EXTENSION   DeviceExtension 
    );

NTSTATUS
SerialMouseWriteChar(
    PDEVICE_EXTENSION   DeviceExtension,
    UCHAR Value
    );

NTSTATUS
SerialMouseWriteString(
    PDEVICE_EXTENSION   DeviceExtension,
    PSZ Buffer
    );

NTSTATUS
SerialMouseSetWmiDataItem(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            DataItemId,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    );

NTSTATUS
SerialMouseSetWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    );

NTSTATUS
SerialMouseQueryWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            InstanceCount,
    IN OUT PULONG       InstanceLengthArray,
    IN ULONG            BufferAvail,
    OUT PUCHAR          Buffer
    );

NTSTATUS
SerialMouseQueryWmiRegInfo(
    IN PDEVICE_OBJECT   DeviceObject,
    OUT PULONG          RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *Pdo
    );


extern WMIGUIDREGINFO WmiGuidList[1];

#endif // _MOUSER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\mouser\mseries.h ===
/*++

Copyright (c) 1993  Microsoft Corporation
Copyright (c) 1993  Logitech Inc.

Module Name:

    mseries.h

Abstract:

    Support routines for the following devices:

    - Microsoft 2 button serial devices.
    - Logitech 3 button serial devices (Microsoft compatible).
    - Microsoft Ballpoint.

Environment:

    Kernel mode only.

Notes:


Revision History:

--*/

//
// Constants.
//

#define MSER_PROTOCOL_MP        0
#define MSER_PROTOCOL_BP        1
#define MSER_PROTOCOL_Z         2
#define MSER_PROTOCOL_MAX       3

//
// Type definitions.
//

typedef enum _MOUSETYPE {
        NO_MOUSE = 0,
        MOUSE_2B,
        MOUSE_3B,
        BALLPOINT,
        MOUSE_Z,
        MAX_MOUSETYPE
} MOUSETYPE;

//
// Prototypes.
//

MOUSETYPE
MSerDetect(
    PDEVICE_EXTENSION DeviceExtension
    );

BOOLEAN
MSerHandlerBP(
    IN PDEVICE_EXTENSION    DeviceExtension,
    IN PMOUSE_INPUT_DATA    CurrentInput,
    IN PHANDLER_DATA        HandlerData,
    IN UCHAR                Value,
    IN UCHAR                LineState
    );

BOOLEAN
MSerHandlerMP(
    IN PDEVICE_EXTENSION    DeviceExtension,
    IN PMOUSE_INPUT_DATA    CurrentInput,
    IN PHANDLER_DATA        HandlerData,
    IN UCHAR                Value,
    IN UCHAR                LineState
    );

BOOLEAN
MSerHandlerZ(
    IN PDEVICE_EXTENSION    DeviceExtension,
    IN PMOUSE_INPUT_DATA    CurrentInput,
    IN PHANDLER_DATA        HandlerData,
    IN UCHAR                Value,
    IN UCHAR                LineState
    );

NTSTATUS
MSerPowerDown(
    PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
MSerPowerUp(
    PDEVICE_EXTENSION DeviceExtension
    );

PPROTOCOL_HANDLER
MSerSetProtocol(
    PDEVICE_EXTENSION DeviceExtension, 
    UCHAR NewProtocol
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\mouser\mseries.c ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved
Copyright (c) 1993  Logitech Inc.

Module Name:

    mseries.c

Abstract:


Environment:

    Kernel mode only.

Notes:


Revision History:

--*/

//
// Includes.
//

#include "ntddk.h"
#include "mouser.h"
#include "debug.h"
#include "cseries.h"
#include "mseries.h"

//
// Use the alloc_text pragma to specify the driver initialization routines
// (they can be paged out).
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,MSerSetProtocol)
#pragma alloc_text(PAGE,MSerPowerUp)
#pragma alloc_text(PAGE,MSerPowerDown)
#pragma alloc_text(PAGE,MSerDetect)
#endif // ALLOC_PRAGMA

//
// Constants.
//

#define MSER_BAUDRATE 1200
#define MAX_RESET_BUFFER 8
#define MINIMUM_RESET_TIME (200 * MS_TO_100_NS)

//
// Microsoft Plus.
//

#define MP_SYNCH_BIT          0x40

#define MP_BUTTON_LEFT        0x20
#define MP_BUTTON_RIGHT       0x10
#define MP_BUTTON_MIDDLE      0x20

#define MP_BUTTON_LEFT_SR     5
#define MP_BUTTON_RIGHT_SR    3
#define MP_BUTTON_MIDDLE_SR   3

#define MP_BUTTON_MIDDLE_MASK 0x04

#define MP_UPPER_MASKX        0x03
#define MP_UPPER_MASKY        0x0C

#define MP_UPPER_MASKX_SL     6
#define MP_UPPER_MASKY_SL     4

//
// Microsoft BallPoint.
//

#define BP_SYNCH_BIT          0x40

#define BP_BUTTON_LEFT        0x20
#define BP_BUTTON_RIGHT       0x10
#define BP_BUTTON_3           0x04
#define BP_BUTTON_4           0x08

#define BP_BUTTON_LEFT_SR     5
#define BP_BUTTON_RIGHT_SR    3
#define BP_BUTTON_3_SL        0
#define BP_BUTTON_4_SL        0

#define BP_UPPER_MASKX        0x03
#define BP_UPPER_MASKY        0x0C

#define BP_UPPER_MASKX_SL     6
#define BP_UPPER_MASKY_SL     4

#define BP_SIGN_MASKX         0x01
#define BP_SIGN_MASKY         0x02

//
// Microsoft Magellan Mouse.
//

#define Z_SYNCH_BIT          0x40
#define Z_EXTRA_BIT          0x20

#define Z_BUTTON_LEFT        0x20
#define Z_BUTTON_RIGHT       0x10
#define Z_BUTTON_MIDDLE      0x10

#define Z_BUTTON_LEFT_SR     5
#define Z_BUTTON_RIGHT_SR    3
#define Z_BUTTON_MIDDLE_SR   3

#define Z_BUTTON_MIDDLE_MASK 0x04

#define Z_UPPER_MASKX        0x03
#define Z_UPPER_MASKY        0x0C
#define Z_UPPER_MASKZ        0x0F

#define Z_LOWER_MASKZ        0x0F

#define Z_UPPER_MASKX_SL     6
#define Z_UPPER_MASKY_SL     4
#define Z_UPPER_MASKZ_SL     4

//
// Type definitions.
//

typedef struct _PROTOCOL {
    PPROTOCOL_HANDLER Handler;
    // UCHAR LineCtrl;
    SERIAL_LINE_CONTROL LineCtrl;
} PROTOCOL;

//
// This list is indexed by protocol values MSER_PROTOCOL_*.
//

static PROTOCOL Protocol[] = {
    {
    MSerHandlerMP,  // Microsoft Plus
    // ACE_7BW | ACE_1SB
    { STOP_BIT_1, NO_PARITY, 7 }
    },
    {
    MSerHandlerBP,  // BALLPOINT
    // ACE_7BW | ACE_1SB
    { STOP_BIT_1, NO_PARITY, 7 }
    },
    {
    MSerHandlerZ,   // Magellan Mouse
    // ACE_7BW | ACE_1SB
    { STOP_BIT_1, NO_PARITY, 7 }
    }
};

PPROTOCOL_HANDLER
MSerSetProtocol(
    PDEVICE_EXTENSION DeviceExtension, 
    UCHAR             NewProtocol
    )
/*++

Routine Description:

    Set the mouse protocol. This function only sets the serial port 
    line control register.

Arguments:

    Port - Pointer to the serial port.

    NewProtocol - Index into the protocol table.

Return Value:

    Pointer to the protocol handler function.

--*/
{
    ASSERT(NewProtocol < MSER_PROTOCOL_MAX);
    PAGED_CODE();

    Print(DeviceExtension, DBG_SS_TRACE, ("MSerSetProtocol called\n"));

    //
    // Set the protocol
    //
    SerialMouseSetLineCtrl(DeviceExtension, &Protocol[NewProtocol].LineCtrl);

    return Protocol[NewProtocol].Handler;
}

NTSTATUS
MSerPowerUp(
    PDEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    Powers up the mouse. Just sets the RTS and DTR lines and returns.

Arguments:

    Port - Pointer to the serial port.

Return Value:

    TRUE.

--*/
{
    IO_STATUS_BLOCK     iosb;
    NTSTATUS            status;
    KEVENT              event;

    PAGED_CODE();

    Print(DeviceExtension, DBG_SS_TRACE, ("MSerPowerUp called\n"));

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // Clear DTR
    //
    Print(DeviceExtension, DBG_SS_NOISE, ("Clearing DTR...\n"));
    status = SerialMouseIoSyncIoctl(IOCTL_SERIAL_CLR_DTR,
                                    DeviceExtension->TopOfStack, 
                                    &event,
                                    &iosb
                                    );

    if (!NT_SUCCESS(status)) {
        return status;  
    }
                
    //
    // Clear RTS
    //
    Print(DeviceExtension, DBG_SS_NOISE, ("Clearing RTS...\n"));
    status = SerialMouseIoSyncIoctl(IOCTL_SERIAL_CLR_RTS,
                                    DeviceExtension->TopOfStack, 
                                    &event,
                                    &iosb
                                    );
    if (!NT_SUCCESS(status)) {
        return status;
    }
                
    //
    // Set a timer for 200 ms
    //
    status = SerialMouseWait(DeviceExtension, -PAUSE_200_MS);
    if (!NT_SUCCESS(status)) {
        Print(DeviceExtension, DBG_SS_ERROR,
              ("Timer failed with status %x\n", status ));
        return status;      
    }

    //
    // set DTR
    //
    Print(DeviceExtension, DBG_SS_NOISE, ("Setting DTR...\n"));
    status = SerialMouseIoSyncIoctl(IOCTL_SERIAL_SET_DTR,
                                    DeviceExtension->TopOfStack, 
                                    &event,
                                    &iosb
                                    );
    if (!NT_SUCCESS(status)) {
        return status;
    }
        
    status = SerialMouseWait(DeviceExtension, -PAUSE_200_MS);
    if (!NT_SUCCESS(status)) {
            Print(DeviceExtension, DBG_SS_ERROR,
              ("Timer failed with status %x\n", status ));
        return status;
    }                                 

    // 
    // set RTS      
    //
    Print(DeviceExtension, DBG_SS_NOISE, ("Setting RTS...\n"));
    status = SerialMouseIoSyncIoctl(IOCTL_SERIAL_SET_RTS,
                                    DeviceExtension->TopOfStack, 
                                    &event,
                                    &iosb
                                    );

    status = SerialMouseWait(DeviceExtension, -175 * MS_TO_100_NS);
    if (!NT_SUCCESS(status)) {
        Print(DeviceExtension, DBG_SS_ERROR,
        ("Timer failed with status %x\n", status ));
        return status;
    }                                 

    return status;
}

NTSTATUS
MSerPowerDown(
    PDEVICE_EXTENSION   DeviceExtension 
    )
/*++

Routine Description:

    Powers down the mouse. Sets the RTS line to an inactive state.

Arguments:

    Port - Pointer to the serial port.

Return Value:

    TRUE.

--*/
{
    IO_STATUS_BLOCK     iosb;
    SERIAL_HANDFLOW     shf;
    KEVENT              event;
    NTSTATUS            status;
    ULONG               bits;

    PAGED_CODE();

    Print(DeviceExtension, DBG_SS_TRACE, ("MSerPowerDown called\n"));

    KeInitializeEvent(&event,
                      NotificationEvent,
                      FALSE
                      );

#if 0
    //
    // Set the handflow to default values
    //
    Print(DeviceExtension, DBG_SS_NOISE,
          ("Setting handflow to default values...\n"));
    shf.ControlHandShake = SERIAL_DTR_CONTROL;
    shf.FlowReplace = SERIAL_RTS_CONTROL;
    shf.XonLimit = 0;
    shf.XoffLimit = 0;
    status = SerialMouseIoSyncIoctlEx(IOCTL_SERIAL_SET_HANDFLOW,
                                      DeviceExtension->TopOfStack, 
                                      &event,
                                      &iosb,
                                      &shf,
                                      sizeof(SERIAL_HANDFLOW),
                                      NULL,
                                      0);
    if (!NT_SUCCESS(status)) {
        return status;
    }
#endif

    //
    // Set DTR
    //
    Print(DeviceExtension, DBG_SS_NOISE, ("Setting DTR...\n"));
    status = SerialMouseIoSyncIoctl(IOCTL_SERIAL_SET_DTR,
                                    DeviceExtension->TopOfStack, 
                                    &event,
                                    &iosb);
    if (!NT_SUCCESS(status)) {
        return status; 
    }
        
    //
    // Clear RTS
    //
    Print(DeviceExtension, DBG_SS_NOISE, ("Clearing RTS...\n"));
    status = SerialMouseIoSyncIoctl(IOCTL_SERIAL_CLR_RTS,
                                    DeviceExtension->TopOfStack, 
                                    &event,
                                    &iosb);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Set a timer for 200 ms
    //
    status = SerialMouseWait(DeviceExtension, -PAUSE_200_MS);
    if (!NT_SUCCESS(status)) {
        Print(DeviceExtension, DBG_SS_ERROR,
              ("Timer failed with status %x\n", status));
       return status;
    }
    
    return status;
}

#define BUFFER_SIZE 256
    
MOUSETYPE
MSerDetect(
    PDEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    Detection code for pointing devices that identify themselves at 
    power on time.

Arguments:

    Port - Pointer to the serial port.

    BaudClock - The external frequency driving the serial chip.

Return Value:

    The type of mouse detected.

--*/
{
    ULONG           count = 0;
    MOUSETYPE       mouseType = NO_MOUSE;
    NTSTATUS        status;
    ULONG           i;
    CHAR            receiveBuffer[BUFFER_SIZE];

    PAGED_CODE();

    Print(DeviceExtension, DBG_SS_TRACE,
          ("MSerDetect enter\n"));

    status = SerialMouseInitializePort(DeviceExtension);
    if (!NT_SUCCESS(status)) {
        Print(DeviceExtension, DBG_SS_ERROR,
              ("Initializing the port failed (%x)\n", status));
        // return status;
    }

    status = MSerPowerDown(DeviceExtension);
    if (!NT_SUCCESS(status)) {
        Print(DeviceExtension, DBG_SS_ERROR,
              ("PowerDown failed (%x)\n", status));
        // return status;
    }

    //
    // Set the baud rate.
    //
    SerialMouseSetBaudRate(DeviceExtension, MSER_BAUDRATE);

    //
    // Set the data format so that the possible answer can be recognized.
    //
    SerialMouseSetLineCtrl(DeviceExtension,
                           &Protocol[MSER_PROTOCOL_MP].LineCtrl);

    //
    // Clean possible garbage in uart input buffer.
    //
    SerialMouseFlushReadBuffer(DeviceExtension);

    status = MSerPowerUp(DeviceExtension);
    if (!NT_SUCCESS(status)) {
        Print(DeviceExtension, DBG_SS_ERROR, ("Powerup failed (%x)\n", status));
    }
        
    //
    // Get the possible first reset character ('M' or 'B'), followed
    // by any other characters the hardware happens to send back.
    //
    // Note:  Typically, we expect to get just one character ('M' or
    //        'B'), perhaps followed by a '2' or '3' (to indicate the
    //        number of mouse buttons.  On some machines, we're
    //        getting extraneous characters before the 'M'.
    //        We get extraneous characters after the expected data if this a 
    //        true PnP comm device
    //

    ASSERT(CSER_POWER_UP >= MINIMUM_RESET_TIME);

    status = SerialMouseSetReadTimeouts(DeviceExtension, 200);

    if (NT_SUCCESS(SerialMouseReadChar(DeviceExtension,
                                       &receiveBuffer[count]))) {

        count++;
        SerialMouseSetReadTimeouts(DeviceExtension, 100);

        while (count < (BUFFER_SIZE - 1)) { 
            if (NT_SUCCESS(SerialMouseReadChar(DeviceExtension,
                                               &receiveBuffer[count]))) {
                count++;
            } else {
                break;
            }
        } 
    }

    *(receiveBuffer + count) = 0;

    Print(DeviceExtension, DBG_SS_NOISE, ("Receive buffer:\n"));
    for (i = 0; i < count; i++) {
        Print(DeviceExtension, DBG_SS_NOISE, ("\t0x%x\n", receiveBuffer[i]));
    }

    //
    //
    // Analyze the possible mouse answer.  Start at the beginning of the 
    // "good" data in the receive buffer, ignoring extraneous characters 
    // that may have come in before the 'M' or 'B'.
    //

    for (i = 0; i < count; i++) {
        if (receiveBuffer[i] == 'M') {
            if (receiveBuffer[i + 1] == '3') {
                Print(DeviceExtension, DBG_SS_INFO,
                      ("Detected MSeries 3 buttons\n"));
                mouseType = MOUSE_3B;
            }
            else if (receiveBuffer[i + 1] == 'Z') {
                Print(DeviceExtension, DBG_SS_INFO,
                      ("Detected Wheel Mouse\n"));
                mouseType = MOUSE_Z;
            }
            else {
                Print(DeviceExtension, DBG_SS_INFO,
                      ("Detected MSeries 2 buttons\n"));
                mouseType = MOUSE_2B;
            }
            break;
        } else if (receiveBuffer[i] == 'B') {
            Print(DeviceExtension, DBG_SS_INFO,
                  ("Detected Ballpoint\n"));
            mouseType = BALLPOINT;
            break;
        }
    }

    if (i >= count) {

        //
        // Special case: If another device is connected (CSeries, for 
        // example) and this device sends a character (movement), the 
        // minimum power up time might not be respected. Take
        // care of this unlikely case.
        //

        if (count != 0) {
            SerialMouseWait(DeviceExtension, -CSER_POWER_UP);
        }

        Print(DeviceExtension, DBG_SS_ERROR | DBG_SS_INFO,
              ("No MSeries detected\n"));
        mouseType = NO_MOUSE;
    }

    //
    // Make sure that all subsequent reads are blocking and do not timeout
    //
    if (mouseType != NO_MOUSE) {
        SerialMouseSetReadTimeouts(DeviceExtension, 0);
    }

    Print(DeviceExtension, DBG_SS_INFO,
          ("mouse type is %d\n", (ULONG) mouseType));

    return mouseType;
}


BOOLEAN
MSerHandlerMP(
    IN PDEVICE_EXTENSION    DeviceExtension,
    IN PMOUSE_INPUT_DATA    CurrentInput,
    IN PHANDLER_DATA        HandlerData,
    IN UCHAR                Value,
    IN UCHAR                LineState
    )

/*++

Routine Description:

    This is the protocol handler routine for the Microsoft Plus protocol.

Arguments:

    CurrentInput - Pointer to the report packet.

    HandlerData - Instance specific static data for the handler.

    Value - The input buffer value.

    LineState - The serial port line state.

Return Value:

    Returns TRUE if the handler has a complete report ready.

--*/

{
    BOOLEAN retval = FALSE;
    ULONG middleButton;

    Print(DeviceExtension, DBG_HANDLER_TRACE, ("MP protocol handler, enter\n"));

    if ((Value & MP_SYNCH_BIT) && (HandlerData->State != STATE0)) {
        if ((HandlerData->State != STATE3)) {

            //
            // We definitely have a synchronization problem (likely a data 
            // overrun).
            //
        
            HandlerData->Error++;
        }
        else if ((HandlerData->PreviousButtons & MOUSE_BUTTON_3) != 0) {

            //
            // We didn't receive the expected fourth byte. Missed it? 
            // Reset button 3 to zero.
            //

            HandlerData->PreviousButtons ^= MOUSE_BUTTON_3;
            HandlerData->Error++;
        }

        Print(DeviceExtension, DBG_HANDLER_ERROR,
              ("Synch error. State: %u\n",
              HandlerData->State
              ));

        HandlerData->State = STATE0;
    }
    else if (!(Value & MP_SYNCH_BIT) && (HandlerData->State == STATE0)) {
        HandlerData->Error++;
        Print(DeviceExtension, DBG_HANDLER_ERROR,
              ("Synch error. State: %u\n",
               HandlerData->State
              ));
        goto LExit;
    }

    //
    // Check for a line state error.
    //

    // if (LineState & ACE_LERR) {
    if (0) {

        //
        // Reset the handler state.
        //

        HandlerData->State = STATE0;
        HandlerData->Error++;
        Print(DeviceExtension, DBG_HANDLER_ERROR,
              ("Line status error: %#x\n", LineState));
    }
    else {

        //
        // Set the untranslated value.
        //

        HandlerData->Raw[HandlerData->State] = Value;
        Print(DeviceExtension, DBG_HANDLER_NOISE,
              ("State%u\n", HandlerData->State));

        switch (HandlerData->State) {
        case STATE0:
        case STATE1:
            HandlerData->State++;
            break;
        case STATE2:
            HandlerData->State++;

            //
            // Build the report.
            //

            CurrentInput->RawButtons  =
                (HandlerData->Raw[0] & MP_BUTTON_LEFT) >> MP_BUTTON_LEFT_SR;
            CurrentInput->RawButtons |=
                (HandlerData->Raw[0] & MP_BUTTON_RIGHT) >> MP_BUTTON_RIGHT_SR;
            CurrentInput->RawButtons |= 
                HandlerData->PreviousButtons & MOUSE_BUTTON_3;

            CurrentInput->LastX =
                (SCHAR)(HandlerData->Raw[1] |
                ((HandlerData->Raw[0] & MP_UPPER_MASKX) << MP_UPPER_MASKX_SL));
            CurrentInput->LastY =
                (SCHAR)(HandlerData->Raw[2] |
                ((HandlerData->Raw[0] & MP_UPPER_MASKY) << MP_UPPER_MASKY_SL));

            retval = TRUE;

            break;

        case STATE3:
            HandlerData->State = STATE0;
            middleButton = 
                (HandlerData->Raw[STATE3] & MP_BUTTON_MIDDLE) >> MP_BUTTON_MIDDLE_SR;

            //
            // Send a report only if the middle button state changed.
            //

            if (middleButton ^ (HandlerData->PreviousButtons & MOUSE_BUTTON_3)) {

                //
                // Toggle the state of the middle button.
                //

                CurrentInput->RawButtons ^= MP_BUTTON_MIDDLE_MASK;
                CurrentInput->LastX = 0;
                CurrentInput->LastY = 0;

                //
                // Send the report one more time.
                //

                retval = TRUE;
            }

            break;

        default:
            Print(DeviceExtension, DBG_HANDLER_ERROR,
                  ("MP Handler failure: incorrect state value.\n"
                  ));
            ASSERT(FALSE);
        }
    }

LExit:
    Print(DeviceExtension, DBG_HANDLER_TRACE, ("MP protocol handler: exit\n"));

    return retval;

}

BOOLEAN
MSerHandlerBP(
    IN PDEVICE_EXTENSION    DeviceExtension,
    IN PMOUSE_INPUT_DATA    CurrentInput,
    IN PHANDLER_DATA        HandlerData,
    IN UCHAR                Value,
    IN UCHAR                LineState
    )

/*++

Routine Description:

    This is the protocol handler routine for the Microsoft Ballpoint protocol.

Arguments:

    CurrentInput - Pointer to the report packet.

    HandlerData - Instance specific static data for the handler.

    Value - The input buffer value.

    LineState - The serial port line state.

Return Value:

    Returns TRUE if the handler has a complete report ready.

--*/

{
    BOOLEAN retval = FALSE;

    Print(DeviceExtension, DBG_HANDLER_TRACE, ("BP protocol handler, enter\n"));

    //
    // Check for synchronization errors.
    //

    if ((Value & BP_SYNCH_BIT) && (HandlerData->State != STATE0)) {
        HandlerData->Error++;
        Print(DeviceExtension, DBG_HANDLER_ERROR,
              ("Synch error. State: %u\n", HandlerData->State
              ));
        HandlerData->State = STATE0;
    }
    else if (!(Value & BP_SYNCH_BIT) && (HandlerData->State == STATE0)) {
        HandlerData->Error++;
        Print(DeviceExtension, DBG_HANDLER_ERROR,
              ("Synch error. State: %u\n", HandlerData->State
              ));
        goto LExit;
    }

    //
    // Check for a line state error.
    //
    //if (LineState & ACE_LERR) {
    if (0) {

        //
        // Reset the handler state.
        //

        HandlerData->State = STATE0;
        HandlerData->Error++;
        Print(DeviceExtension, DBG_HANDLER_NOISE,
              ("Line status error: %#x\n", LineState));
    }
    else {

        //
        // Set the untranslated value.
        //

        HandlerData->Raw[HandlerData->State] = Value;

        Print(DeviceExtension, DBG_HANDLER_NOISE,
              ("State%u\n", HandlerData->State));

        switch (HandlerData->State) {

        case STATE0:
        case STATE1:
        case STATE2:
            HandlerData->State++;
            break;

        case STATE3:
            HandlerData->State = STATE0;

            //
            // Build the report.
            //

            CurrentInput->RawButtons =
                (HandlerData->Raw[0] & BP_BUTTON_LEFT) >> BP_BUTTON_LEFT_SR;
            CurrentInput->RawButtons |=
                (HandlerData->Raw[0] & BP_BUTTON_RIGHT) >> BP_BUTTON_RIGHT_SR;

#if 0
            CurrentInput->ButtonFlags |=
                (HandlerData->Raw[3] & BP_BUTTON_3) << BP_BUTTON_3_SL;
            CurrentInput->ButtonFlags |=
                (HandlerData->Raw[3] & BP_BUTTON_4) << BP_BUTTON_4_SL;
#endif
            CurrentInput->LastX = HandlerData->Raw[3] & BP_SIGN_MASKX ?
                (LONG)(HandlerData->Raw[1] | (ULONG)(-1 & ~0xFF) |
                ((HandlerData->Raw[0] & BP_UPPER_MASKX) << BP_UPPER_MASKX_SL)):
                (LONG)(HandlerData->Raw[1] |
                ((HandlerData->Raw[0] & BP_UPPER_MASKX) << BP_UPPER_MASKX_SL));

            CurrentInput->LastY = HandlerData->Raw[3] & BP_SIGN_MASKY ?
                (LONG)(HandlerData->Raw[2] | (ULONG)(-1 & ~0xFF) |
                ((HandlerData->Raw[0] & BP_UPPER_MASKY) << BP_UPPER_MASKY_SL)):
                (LONG)(HandlerData->Raw[2] |
                ((HandlerData->Raw[0] & BP_UPPER_MASKY) << BP_UPPER_MASKY_SL));

            retval = TRUE;

            break;

        default:
            Print(DeviceExtension, DBG_HANDLER_ERROR,
                  ("BP Handler failure: incorrect state value.\n"
                  ));
            ASSERT(FALSE);
        }
    }

LExit:
    Print(DeviceExtension, DBG_HANDLER_TRACE, ("BP protocol handler: exit\n"));

    return retval;

}

BOOLEAN
MSerHandlerZ(
    IN PDEVICE_EXTENSION    DeviceExtension,
    IN PMOUSE_INPUT_DATA    CurrentInput,
    IN PHANDLER_DATA        HandlerData,
    IN UCHAR                Value,
    IN UCHAR                LineState
    )

/*++

Routine Description:

    This is the protocol handler routine for the Microsoft Magellan Mouse
    (wheel mouse)

Arguments:

    CurrentInput - Pointer to the report packet.

    HandlerData - Instance specific static data for the handler.

    Value - The input buffer value.

    LineState - The serial port line state.

Return Value:

    Returns TRUE if the handler has a complete report ready.

--*/

{
    BOOLEAN retval = FALSE;
    ULONG   middleButton;
    CHAR    zMotion = 0;

    Print(DeviceExtension, DBG_HANDLER_TRACE, ("Z protocol handler, enter\n"));

    if ((Value & Z_SYNCH_BIT) && (HandlerData->State != STATE0)) {
        if ((HandlerData->State != STATE3)) {

            //
            // We definitely have a synchronization problem (likely a data 
            // overrun).
            //

            HandlerData->Error++;
        }

        Print(DeviceExtension, DBG_HANDLER_ERROR,
              ("Z Synch error #1. State: %u\n", HandlerData->State
              ));

        HandlerData->State = STATE0;
    }
    else if (!(Value & Z_SYNCH_BIT) && (HandlerData->State == STATE0)) {
        HandlerData->Error++;
        Print(DeviceExtension, DBG_HANDLER_ERROR,
              ("Z Synch error #2. State: %u\n", HandlerData->State
              ));
        goto LExit;
    }

    //
    // Check for a line state error.
    //

    // if (LineState & ACE_LERR) {
    if (0) {

        //
        // Reset the handler state.
        //

        HandlerData->State = STATE0;
        HandlerData->Error++;
        Print(DeviceExtension, DBG_HANDLER_ERROR,
              ("Z Line status error: %#x\n", LineState));
    }
    else {

        //
        // Set the untranslated value.
        //

        HandlerData->Raw[HandlerData->State] = Value;
        Print(DeviceExtension, DBG_HANDLER_NOISE,
              ("Z State%u\n", HandlerData->State));

        switch (HandlerData->State) {
        case STATE0:
        case STATE1:
        case STATE2:
            HandlerData->State++;
            break;

        case STATE3:

            //
            // Check to see if the mouse is going to the high bits of
            // the wheel movement.  If not, this is the last bit - transition
            // back to state0
            //

            if((HandlerData->Raw[STATE3] & Z_EXTRA_BIT) == 0) {

                HandlerData->State = STATE0;
                HandlerData->Raw[STATE4] = 0;
                retval = TRUE;
            }
            else {
                HandlerData->State++;
            }

            break;

        case STATE4:

            Print(DeviceExtension, DBG_HANDLER_NOISE, 
                  ("Z Got that 5th byte\n"));
            HandlerData->State = STATE0;
            retval = TRUE;
            break;

        default:
            Print(DeviceExtension, DBG_HANDLER_ERROR,
                  ("Z Handler failure: incorrect state value.\n"
                  ));
            ASSERT(FALSE);
        }

        if (retval) {

            CurrentInput->RawButtons = 0;
            
            if(HandlerData->Raw[STATE0] & Z_BUTTON_LEFT) {
                CurrentInput->RawButtons |= MOUSE_BUTTON_LEFT;
            }

            if(HandlerData->Raw[STATE0] & Z_BUTTON_RIGHT) {
                CurrentInput->RawButtons |= MOUSE_BUTTON_RIGHT;
            }

            if(HandlerData->Raw[STATE3] & Z_BUTTON_MIDDLE) {
                CurrentInput->RawButtons |= MOUSE_BUTTON_MIDDLE;
            }

            CurrentInput->LastX =
                (SCHAR)(HandlerData->Raw[STATE1] |
                ((HandlerData->Raw[0] & Z_UPPER_MASKX) << Z_UPPER_MASKX_SL));
            CurrentInput->LastY =
                (SCHAR)(HandlerData->Raw[STATE2] |
                ((HandlerData->Raw[0] & Z_UPPER_MASKY) << Z_UPPER_MASKY_SL));

            //
            // If the extra bit isn't set then the 4th byte contains
            // a 4 bit signed quantity for the wheel movement.  if it
            // is set, then we need to combine the z info from the
            // two bytes
            //

            if((HandlerData->Raw[STATE3] & Z_EXTRA_BIT) == 0) {

                zMotion = HandlerData->Raw[STATE3] & Z_LOWER_MASKZ;

                //
                // Sign extend the 4 bit 
                //

                if(zMotion & 0x08)  {
                    zMotion |= 0xf0;
                }
            } else {
                zMotion = ((HandlerData->Raw[STATE3] & Z_LOWER_MASKZ) |
                           ((HandlerData->Raw[STATE4] & Z_UPPER_MASKZ)
                                << Z_UPPER_MASKZ_SL));
            }

            if(zMotion == 0) {
                CurrentInput->ButtonData = 0;
            } else {
                CurrentInput->ButtonData = 0x0078;
                if(zMotion & 0x80) {
                    CurrentInput->ButtonData = 0x0078;
                } else {
                    CurrentInput->ButtonData = 0xff88;
                }
                CurrentInput->ButtonFlags |= MOUSE_WHEEL;
            }

        }
    }

LExit:
    Print(DeviceExtension, DBG_HANDLER_TRACE, ("Z protocol handler: exit\n"));

    return retval;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\mouser\pnp.c ===
/*++

Copyright (c) 1997-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    pnp.c

Abstract:

    This module contains plug & play code for the serial Mouse Filter Driver,
    including code for the creation and removal of serial mouse device contexts.

Environment:

    Kernel & user mode.

Revision History:

--*/

#include "mouser.h"
#include "sermlog.h"
#include "debug.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SerialMouseAddDevice)
#pragma alloc_text(PAGE, SerialMousePnP)
#pragma alloc_text(PAGE, SerialMousePower)
#pragma alloc_text(PAGE, SerialMouseRemoveDevice)
#pragma alloc_text(PAGE, SerialMouseSendIrpSynchronously)
#endif

NTSTATUS
SerialMouseAddDevice (
    IN PDRIVER_OBJECT   Driver,
    IN PDEVICE_OBJECT   PDO
    )
/*++

Routine Description:


Arguments:


Return Value:

    NTSTATUS result code.

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension;
    PDEVICE_OBJECT      device;
    KIRQL               oldIrql;

    PAGED_CODE();

    status = IoCreateDevice(Driver,
                            sizeof(DEVICE_EXTENSION),
                            NULL, // no name for this Filter DO
                            FILE_DEVICE_SERIAL_MOUSE_PORT,
                            0,
                            FALSE,
                            &device);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    deviceExtension = (PDEVICE_EXTENSION) device->DeviceExtension;

    Print(deviceExtension, DBG_PNP_TRACE, ("enter Add Device\n"));

    //
    // Initialize the fields.
    //
    RtlZeroMemory(deviceExtension, sizeof(DEVICE_EXTENSION));

    deviceExtension->TopOfStack = IoAttachDeviceToDeviceStack(device, PDO);

    if (deviceExtension->TopOfStack == NULL) {
        PIO_ERROR_LOG_PACKET errorLogEntry;

        //
        // Not good; in only extreme cases will this fail
        //
        errorLogEntry = (PIO_ERROR_LOG_PACKET)
            IoAllocateErrorLogEntry(Driver,
                                    (UCHAR) sizeof(IO_ERROR_LOG_PACKET));

        if (errorLogEntry) {
            errorLogEntry->ErrorCode = SERMOUSE_ATTACH_DEVICE_FAILED;
            errorLogEntry->DumpDataSize = 0;
            errorLogEntry->SequenceNumber = 0;
            errorLogEntry->MajorFunctionCode = 0;
            errorLogEntry->IoControlCode = 0;
            errorLogEntry->RetryCount = 0;
            errorLogEntry->UniqueErrorValue = 0;
            errorLogEntry->FinalStatus =  STATUS_DEVICE_NOT_CONNECTED;

            IoWriteErrorLogEntry(errorLogEntry);
        }

        IoDeleteDevice(device);
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    ASSERT(deviceExtension->TopOfStack);

    deviceExtension->PDO = PDO;
    deviceExtension->Self = device;
    deviceExtension->Removed = FALSE;
    deviceExtension->Started = FALSE;
    deviceExtension->Stopped = FALSE;


    deviceExtension->PowerState = PowerDeviceD0;
    deviceExtension->WaitWakePending = FALSE;

    KeInitializeSpinLock(&deviceExtension->PnpStateLock);
    KeInitializeEvent(&deviceExtension->StopEvent, SynchronizationEvent, FALSE);
    IoInitializeRemoveLock(&deviceExtension->RemoveLock, SERMOU_POOL_TAG, 0, 10);

    deviceExtension->ReadIrp = IoAllocateIrp( device->StackSize, FALSE );
    if (!deviceExtension->ReadIrp) {
        //
        // The ReadIrp is critical to this driver, if we can't get one, no use
        // in going any further
        //
        IoDetachDevice(deviceExtension->TopOfStack);
        IoDeleteDevice(device);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    deviceExtension->WmiLibInfo.GuidCount = sizeof(WmiGuidList) /
                                            sizeof(WMIGUIDREGINFO);

    deviceExtension->WmiLibInfo.GuidList = WmiGuidList;
    deviceExtension->WmiLibInfo.QueryWmiRegInfo = SerialMouseQueryWmiRegInfo;
    deviceExtension->WmiLibInfo.QueryWmiDataBlock = SerialMouseQueryWmiDataBlock;
    deviceExtension->WmiLibInfo.SetWmiDataBlock = SerialMouseSetWmiDataBlock;
    deviceExtension->WmiLibInfo.SetWmiDataItem = SerialMouseSetWmiDataItem;
    deviceExtension->WmiLibInfo.ExecuteWmiMethod = NULL;
    deviceExtension->WmiLibInfo.WmiFunctionControl = NULL;

    IoWMIRegistrationControl(deviceExtension->Self, WMIREG_ACTION_REGISTER);

    KeInitializeTimer(&deviceExtension->DelayTimer);

    //
    // Set all the appropriate device object flags
    //
    device->Flags &= ~DO_DEVICE_INITIALIZING;
    device->Flags |= DO_BUFFERED_IO;
    device->Flags |= DO_POWER_PAGABLE;

    return status;
}

VOID
SerialMouseRemoveDevice(
    PDEVICE_EXTENSION DeviceExtension,
    PIRP Irp
    )
{
    BOOLEAN closePort = FALSE;

    PAGED_CODE();

    //
    // Run the (surprise remove code).  If we are surprise removed, then this
    // will be called twice.  We only run the removal code once.
    //
    if (!DeviceExtension->SurpriseRemoved) {
        DeviceExtension->SurpriseRemoved = TRUE;

        //
        // Here if we had any outstanding requests in a personal queue we should
        // complete them all now.
        //
        // Note, the device could be GONE so we cannot send it any non-
        // PNP IRPS.
        //
        IoWMIRegistrationControl(DeviceExtension->Self, WMIREG_ACTION_DEREGISTER);

        if (DeviceExtension->Started && DeviceExtension->EnableCount > 0) {
            Print(DeviceExtension, DBG_PNP_INFO,
                  ("Cancelling and stopping detection for remove\n"));
            IoCancelIrp(DeviceExtension->ReadIrp);

            //
            // Cancel the detection timer, SerialMouseRemoveLockAndWait will
            // guarantee that we don't yank the device from under the polling
            // routine
            //
            SerialMouseStopDetection(DeviceExtension);

        }
    }

    //
    // The stack is about to be torn down, make sure that the underlying serial
    // port is closed.  No other piece of code will be looking at EnableCount if
    // Remove is true, so there is no need for InterlockedXxx.
    //
    if (DeviceExtension->Removed && DeviceExtension->EnableCount > 0) {
        Print(DeviceExtension, DBG_PNP_INFO | DBG_PNP_ERROR,
              ("sending final close, enable count %d\n",
              DeviceExtension->EnableCount));

        DeviceExtension->EnableCount = 0;

        SerialMouseClosePort(DeviceExtension, Irp);
    }
}

NTSTATUS
SerialMouseCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PKEVENT        Event
    )
/*++

Routine Description:
    The pnp IRP is in the process of completing.
    signal

Arguments:
    Context set to the device object in question.

--*/
{
    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(Irp);

    KeSetEvent(Event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SerialMouseSendIrpSynchronously (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN BOOLEAN          CopyToNext
    )
{
    KEVENT      event;
    NTSTATUS    status;

    PAGED_CODE();

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    if (CopyToNext) {
        IoCopyCurrentIrpStackLocationToNext(Irp);
    }

    IoSetCompletionRoutine(Irp,
                           SerialMouseCompletionRoutine,
                           &event,
                           TRUE,                // on success
                           TRUE,                // on error
                           TRUE                 // on cancel
                           );

    status = IoCallDriver(DeviceObject, Irp);

    //
    // Wait for lower drivers to be done with the Irp
    //
    if (status == STATUS_PENDING) {
       KeWaitForSingleObject(&event,
                             Executive,
                             KernelMode,
                             FALSE,
                             NULL
                             );
       status = Irp->IoStatus.Status;
    }

    return status;
}

void
SerialMouseHandleStartStopStart(
    IN PDEVICE_EXTENSION DeviceExtension
    )
{
    KIRQL irql;

    KeAcquireSpinLock(&DeviceExtension->PnpStateLock, &irql);

    if (DeviceExtension->Stopped) {
        DeviceExtension->Stopped = FALSE;
        IoReuseIrp(DeviceExtension->ReadIrp, STATUS_SUCCESS);
    }

    KeReleaseSpinLock(&DeviceExtension->PnpStateLock, irql);
}

void
SerialMouseStopDevice (
    IN PDEVICE_EXTENSION DeviceExtension
    )
{
    KIRQL irql;

    KeAcquireSpinLock(&DeviceExtension->PnpStateLock, &irql);
    DeviceExtension->Stopped = TRUE;
    KeReleaseSpinLock(&DeviceExtension->PnpStateLock, irql);

    if (DeviceExtension->Started) {
        Print(DeviceExtension, DBG_PNP_INFO,
              ("Cancelling and stopping detection for stop\n"));

        DeviceExtension->Started = FALSE;

        //
        // Stop detection and cancel the read
        //
        SerialMouseStopDetection(DeviceExtension);

        //
        // BUGBUG:  should I only wait if IoCancelIrp fails?
        //
        if (!IoCancelIrp(DeviceExtension->ReadIrp)) {
            //
            // Wait for the read irp to complete
            //
            Print(DeviceExtension, DBG_PNP_INFO, ("Waiting for stop event\n"));

            KeWaitForSingleObject(&DeviceExtension->StopEvent,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL
                                  );

            Print(DeviceExtension, DBG_PNP_INFO, ("Done waiting for stop event\n"));
        }
    }
}

NTSTATUS
SerialMousePnP (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    The plug and play dispatch routines.

    Most of these this filter driver will completely ignore.
    In all cases it must pass on the IRP to the lower driver.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  stack;
    HANDLE              keyHandle;
    NTSTATUS            status;
    KIRQL               oldIrql;
    BOOLEAN             skipIt = FALSE;

    PAGED_CODE();

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation(Irp);

    status = IoAcquireRemoveLock(&deviceExtension->RemoveLock, Irp);
    if (!NT_SUCCESS(status)) {
        //
        // Someone gave us a pnp irp after a remove.  Unthinkable!
        //
        ASSERT(FALSE);
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    Print(deviceExtension, DBG_PNP_TRACE,
          ("PnP Enter (min func=0x%x)\n", stack->MinorFunction));

    switch (stack->MinorFunction) {
    case IRP_MN_START_DEVICE:

        //
        // Send the actual start down the stack
        //
        status = SerialMouseSendIrpSynchronously(deviceExtension->TopOfStack,
                                                 Irp,
                                                 TRUE);

        if (NT_SUCCESS(status) && NT_SUCCESS(Irp->IoStatus.Status)) {
            PIO_STACK_LOCATION  nextStack;

            //
            // If a create has not been sent down the stack yet, then send one
            // now.  The serial port driver reequires a create before
            // any reads or IOCTLS are to be sent.
            //
            if (InterlockedIncrement(&deviceExtension->EnableCount) == 1) {
                NTSTATUS    prevStatus;
                ULONG_PTR   prevInformation;

                //
                // No previous create has been sent, send one now
                //
                prevStatus = Irp->IoStatus.Status;
                prevInformation = Irp->IoStatus.Information;

                nextStack = IoGetNextIrpStackLocation (Irp);
                RtlZeroMemory(nextStack, sizeof(IO_STACK_LOCATION));
                nextStack->MajorFunction = IRP_MJ_CREATE;

                status =
                    SerialMouseSendIrpSynchronously(deviceExtension->TopOfStack,
                                                    Irp,
                                                    FALSE);

                Print(deviceExtension, DBG_PNP_NOISE,
                      ("Create for start 0x%x\n", status));

                if (NT_SUCCESS(status) && NT_SUCCESS(Irp->IoStatus.Status)) {
                    Irp->IoStatus.Status = prevStatus;
                    Irp->IoStatus.Information = prevInformation;
                }
                else {
                    Print(deviceExtension, DBG_CC_ERROR | DBG_PNP_ERROR,
                          ("Create for start failed, 0x%x!\n", status));

                    goto SerialMouseStartFinished;
                }
            }

            //
            // Open the device registry key and read the devnode stored values
            //
            status = IoOpenDeviceRegistryKey(deviceExtension->PDO,
                                             PLUGPLAY_REGKEY_DEVICE,
                                             STANDARD_RIGHTS_READ,
                                             &keyHandle);

            if (NT_SUCCESS(status)) {
                SerialMouseServiceParameters(deviceExtension, keyHandle);
                ZwClose(keyHandle);
            }

            //
            // Handle the transition from start to stop to start correctly
            //
            SerialMouseHandleStartStopStart(deviceExtension);

            //
            // Initialize the device to make sure we can start it and report
            // data from it
            //
            status = SerialMouseInitializeDevice(deviceExtension);

            Print(deviceExtension, DBG_PNP_INFO,
                  ("Start InitializeDevice 0x%x\n", status));

            if (InterlockedDecrement(&deviceExtension->EnableCount) == 0) {
                //
                // We will start the read loop when we receive a "real" create
                // from the raw input thread.   We do not keep our own create
                // around after the start device because it will mess up the
                // logic for handling QUERY_REMOVE (our "fake" create will still
                // be in effect and the QUERY_REMOVE will fail).
                //
                Print(deviceExtension, DBG_PNP_NOISE,
                      ("sending close for start\n"));

                SerialMouseClosePort(deviceExtension, Irp);
            }
            else {
                //
                // We already have an outstanding create, just spin up the read
                // loop again
                //
                ASSERT(deviceExtension->EnableCount >= 1);

                Print(deviceExtension, DBG_PNP_INFO,
                      ("spinning up read in start\n"));

                status = SerialMouseSpinUpRead(deviceExtension);
            }
        }

SerialMouseStartFinished:
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        break;

    case IRP_MN_STOP_DEVICE:
        //
        // After the start IRP has been sent to the lower driver object, the
        // bus may NOT send any more IRPS down ``touch'' until another START
        // has occured.
        // What ever access is required must be done before the Irp is passed
        // on.
        //

        SerialMouseStopDevice(deviceExtension);

        //
        // We don't need a completion routine so fire and forget.
        //
        skipIt = TRUE;
        Irp->IoStatus.Status = STATUS_SUCCESS;
        break;

    case IRP_MN_SURPRISE_REMOVAL:
        SerialMouseRemoveDevice(deviceExtension, Irp);
        skipIt = TRUE;
        Irp->IoStatus.Status = STATUS_SUCCESS;
        break;

    case IRP_MN_REMOVE_DEVICE:
        //
        // The PlugPlay system has dictacted the removal of this device.  We
        // have no choise but to detach and delete the device objecct.
        // (If we wanted to express and interest in preventing this removal,
        // we should have filtered the query remove and query stop routines.)
        //
        // Note! we might receive a remove WITHOUT first receiving a stop.
        //
        Print(deviceExtension, DBG_PNP_TRACE, ("enter RemoveDevice \n"));

        deviceExtension->Removed = TRUE;
        SerialMouseRemoveDevice(deviceExtension, Irp);

        //
        // Send on the remove IRP
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(deviceExtension->TopOfStack, Irp);

        //
        // Wait for the remove lock to free.
        //
        IoReleaseRemoveLockAndWait(&deviceExtension->RemoveLock, Irp);

        //
        // Free the associated memory.
        //
        IoFreeIrp(deviceExtension->ReadIrp);
        deviceExtension->ReadIrp = NULL;
        if (deviceExtension->DetectionIrp) {
            IoFreeIrp(deviceExtension->DetectionIrp);
            deviceExtension->DetectionIrp = NULL;
        }

        Print(deviceExtension, DBG_PNP_NOISE, ("remove and wait done\n"));

        IoDetachDevice(deviceExtension->TopOfStack);
        IoDeleteDevice(deviceExtension->Self);

        return status;

    case IRP_MN_QUERY_CAPABILITIES:

        status = SerialMouseSendIrpSynchronously(deviceExtension->TopOfStack,
                                                 Irp,
                                                 TRUE);

        if (NT_SUCCESS(status) && NT_SUCCESS(Irp->IoStatus.Status)) {
            PDEVICE_CAPABILITIES devCaps;

            devCaps = stack->Parameters.DeviceCapabilities.Capabilities;

            if (devCaps) {
                SYSTEM_POWER_STATE i;

                //
                // We do not want to show up in the hot plug removal applet
                //
                devCaps->SurpriseRemovalOK = TRUE;

                //
                // While the underlying serial bus might be able to wake the
                // machine from low power (via wake on ring), the mouse cannot.
                //
                devCaps->SystemWake = PowerSystemUnspecified;
                devCaps->DeviceWake = PowerDeviceUnspecified;
                devCaps->WakeFromD0 =
                    devCaps->WakeFromD1 =
                        devCaps->WakeFromD2 =
                            devCaps->WakeFromD3 = FALSE;

                devCaps->DeviceState[PowerSystemWorking] = PowerDeviceD0;
                for (i = PowerSystemSleeping1; i < PowerSystemMaximum; i++) {
                    devCaps->DeviceState[i] = PowerDeviceD3;
                }
            }
        }

        //
        // status, Irp->IoStatus.Status set above
        //
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        break;

    case IRP_MN_QUERY_PNP_DEVICE_STATE:
        status = SerialMouseSendIrpSynchronously(deviceExtension->TopOfStack,
                                                 Irp,
                                                 TRUE);
        //
        // If the lower filter does not support this Irp, this is
        // OK, we can ignore this error
        //
        if (status == STATUS_NOT_SUPPORTED ||
            status == STATUS_INVALID_DEVICE_REQUEST) {
            status = STATUS_SUCCESS;
        }

        if (NT_SUCCESS(status) && deviceExtension->RemovalDetected) {
            (PNP_DEVICE_STATE) Irp->IoStatus.Information |= PNP_DEVICE_REMOVED;
        }

        if (!NT_SUCCESS(status)) {
           Print(deviceExtension, DBG_PNP_ERROR,
                 ("error pending query pnp device state event (0x%x)\n",
                 status
                 ));
        }

        //
        // Irp->IoStatus.Information will contain the new i/o resource
        // requirements list so leave it alone
        //
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_CANCEL_REMOVE_DEVICE:
    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_CANCEL_STOP_DEVICE:
    case IRP_MN_QUERY_DEVICE_RELATIONS:
    case IRP_MN_QUERY_INTERFACE:
    case IRP_MN_QUERY_RESOURCES:
    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
    case IRP_MN_READ_CONFIG:
    case IRP_MN_WRITE_CONFIG:
    case IRP_MN_EJECT:
    case IRP_MN_SET_LOCK:
    case IRP_MN_QUERY_ID:
    default:
        skipIt = TRUE;
        break;
    }

    if (skipIt) {
        //
        // Don't touch the irp...
        //
        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(deviceExtension->TopOfStack, Irp);
    }

    IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

    Print(deviceExtension, DBG_PNP_TRACE, ("PnP exit (%x)\n", status));
    return status;
}

typedef struct _MOUSER_START_WORKITEM {
    PDEVICE_EXTENSION   DeviceExtension;
    PIO_WORKITEM        WorkItem;
} MOUSER_START_WORKITEM, *PMOUSER_START_WORKITEM;

VOID
StartDeviceWorker (
    IN PDEVICE_OBJECT DeviceObject,
    IN PMOUSER_START_WORKITEM WorkItemContext
    )
{
    PDEVICE_EXTENSION deviceExtension = WorkItemContext->DeviceExtension;
    NTSTATUS status;
    PIRP irp;

    if (deviceExtension->Started &&
        !deviceExtension->Removed &&
        deviceExtension->EnableCount > 0) {
        irp = IoAllocateIrp( deviceExtension->Self->StackSize, FALSE );
        if (irp) {
            status = SerialMouseStartDevice(deviceExtension,
                                            irp,
                                            FALSE);

            if (!NT_SUCCESS(status)) {
                KEVENT              event;
                IO_STATUS_BLOCK     iosb;

                Print(deviceExtension, DBG_POWER_INFO,
                      ("mouse not found on power up, 0x%x\n", status));

                //
                // The device has been removed or is not detectable
                // after powering back up ... have serenum do the
                // removal work
                //
                KeInitializeEvent(&event, SynchronizationEvent, FALSE);

                SerialMouseIoSyncInternalIoctl(
                    IOCTL_INTERNAL_SERENUM_REMOVE_SELF,
                    deviceExtension->TopOfStack,
                    &event,
                    &iosb
                    );
            }
            IoFreeIrp(irp);
        }
    }

    IoFreeWorkItem(WorkItemContext->WorkItem);
    ExFreePool(WorkItemContext);
    IoReleaseRemoveLock(&deviceExtension->RemoveLock, deviceExtension);
}

NTSTATUS
SerialMousePower (
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    )
/*++

Routine Description:

    The power dispatch routine.

    All we care about is the transition from a low D state to D0.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PIO_STACK_LOCATION  stack;
    NTSTATUS            status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;
    POWER_STATE         powerState;
    POWER_STATE_TYPE    powerType;
    KEVENT              event;
    IO_STATUS_BLOCK     iosb;
    LARGE_INTEGER       li;

    PAGED_CODE();

    Print(deviceExtension, DBG_POWER_TRACE, ("Power Enter.\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation(Irp);
    powerType = stack->Parameters.Power.Type;
    powerState = stack->Parameters.Power.State;

    status = IoAcquireRemoveLock(&deviceExtension->RemoveLock, Irp);

    if (!NT_SUCCESS(status)) {
        PoStartNextPowerIrp(Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    switch (stack->MinorFunction) {
    case IRP_MN_WAIT_WAKE:
        break;

    case IRP_MN_SET_POWER:
        //
        // Let system power irps fall through
        //
        if (powerType == DevicePowerState &&
            powerState.DeviceState != deviceExtension->PowerState) {
            switch (powerState.DeviceState) {
            case PowerDeviceD0:

                //
                // Transitioning from a low D state to D0
                //
                Print(deviceExtension, DBG_POWER_INFO,
                      ("Powering up to PowerDeviceD0\n"));

                KeInitializeEvent(&event, SynchronizationEvent, FALSE);

                deviceExtension->PoweringDown = FALSE;

                deviceExtension->PowerState =
                    stack->Parameters.Power.State.DeviceState;

                IoCopyCurrentIrpStackLocationToNext(Irp);
                IoSetCompletionRoutine(Irp,
                                       SerialMouseCompletionRoutine,
                                       &event,
                                       TRUE,                // on success
                                       TRUE,                // on error
                                       TRUE                 // on cancel
                                       );

                status = PoCallDriver(deviceExtension->TopOfStack, Irp);

                //
                // Wait for lower drivers to be done with the Irp
                //
                if (status == STATUS_PENDING) {
                   KeWaitForSingleObject(&event,
                                         Executive,
                                         KernelMode,
                                         FALSE,
                                         NULL
                                         );
                   status = Irp->IoStatus.Status;
                }

                if (NT_SUCCESS(status) && NT_SUCCESS(Irp->IoStatus.Status)) {

                    PoSetPowerState(DeviceObject, powerType, powerState);

                    if (NT_SUCCESS(IoAcquireRemoveLock(&deviceExtension->RemoveLock, deviceExtension))) {
                        PIO_WORKITEM workItem;
                        PMOUSER_START_WORKITEM workItemContext;

                        workItem = IoAllocateWorkItem(DeviceObject);

                        if (workItem) {
                            workItemContext = ExAllocatePool(NonPagedPool, sizeof(MOUSER_START_WORKITEM));
                            if (workItemContext) {
                                workItemContext->WorkItem = workItem;
                                workItemContext->DeviceExtension = deviceExtension;
                                IoQueueWorkItem(
                                    workItem,
                                    StartDeviceWorker,
                                    DelayedWorkQueue,
                                    workItemContext);
                            } else {
                                IoFreeWorkItem(workItem);
                                IoReleaseRemoveLock(&deviceExtension->RemoveLock, deviceExtension);
                            }
                        } else {
                            IoReleaseRemoveLock(&deviceExtension->RemoveLock, deviceExtension);
                        }
                    }
                }

                Irp->IoStatus.Status = status;
                IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
                PoStartNextPowerIrp(Irp);
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                return status;

            case PowerDeviceD1:
            case PowerDeviceD2:
            case PowerDeviceD3:

                deviceExtension->PoweringDown = TRUE;

                // If a wait wake is pending against the mouse, keep it powered
                //
                if (deviceExtension->WaitWakePending) {
                    Print(deviceExtension, DBG_POWER_INFO,
                          ("Ignoring power down for wait wake (-> D%d)\n",
                          powerState.DeviceState-1
                          ));
                    break;
                }

                Print(deviceExtension, DBG_POWER_INFO,
                      ("Powering down to PowerDeviceD%d\n",
                      powerState.DeviceState-1
                      ));

                //
                // Acquire another reference to the lock so that the decrement
                // in the cancel section of the completion routine will not fall
                // to zero (and have the remlock think we are removed)
                //
//                 status = IoAcquireRemoveLock(&deviceExtension->RemoveLock,
  //                                            deviceExtension->ReadIrp);
                ASSERT(NT_SUCCESS(status));

                deviceExtension->PowerState =
                    stack->Parameters.Power.State.DeviceState;

                //
                // Cancel the read irp so that it won't conflict with power up
                // initialization (which involves some reads against the port)
                //
                IoCancelIrp(deviceExtension->ReadIrp);

                //
                // We don't want the powering down of the port to be confused
                // with removal
                //
                SerialMouseStopDetection(deviceExtension);

                //
                // Power down the device by clearing RTS and waiting 150 ms
                //
                Print(deviceExtension, DBG_POWER_INFO, ("Clearing RTS...\n"));
                KeInitializeEvent(&event, NotificationEvent, FALSE);
                status = SerialMouseIoSyncIoctl(IOCTL_SERIAL_CLR_RTS,
                                                deviceExtension->TopOfStack,
                                                &event,
                                                &iosb
                                                );

                if (NT_SUCCESS(status)) {
                    Print(deviceExtension, DBG_POWER_INFO, ("150ms wait\n"));

                    li.QuadPart = (LONGLONG) -PAUSE_150_MS;
                    KeDelayExecutionThread(KernelMode, FALSE, &li);
                }

                PoSetPowerState(DeviceObject,
                                stack->Parameters.Power.Type,
                                stack->Parameters.Power.State);

                IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

                //
                // Fire and forget
                //
                Irp->IoStatus.Status = STATUS_SUCCESS;
                IoCopyCurrentIrpStackLocationToNext(Irp);

                PoStartNextPowerIrp(Irp);
                return  PoCallDriver(deviceExtension->TopOfStack, Irp);
            }
        }

        break;

    case IRP_MN_QUERY_POWER:
        break;

    default:
        Print(deviceExtension, DBG_POWER_ERROR,
              ("Power minor (0x%x) is not handled\n", stack->MinorFunction));
    }

    //
    // Must call the Po versions of these functions or bad things (tm) will happen!
    //
    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);
    status = PoCallDriver(deviceExtension->TopOfStack, Irp);

    IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\mouser\sermcmn.c ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved
Copyright (c) 1993  Logitech Inc.

Module Name:

    sermcmn.c

Abstract:

    The common portions of the Microsoft serial (i8250) mouse port driver.
    This file should not require modification to support new mice
    that are similar to the serial mouse.

Environment:

    Kernel mode only.

Notes:

    NOTES:  (Future/outstanding issues)

    - Powerfail not implemented.

    - IOCTL_INTERNAL_MOUSE_DISCONNECT has not been implemented.  It's not
      needed until the class unload routine is implemented. Right now,
      we don't want to allow the mouse class driver to unload.

    - Consolidate duplicate code, where possible and appropriate.

Revision History:


--*/

#include "stdarg.h"
#include "stdio.h"
#include "string.h"
#include "ntddk.h"
#include "mouser.h"
#include "sermlog.h"
#include "debug.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SerialMouseCreate)
#pragma alloc_text(PAGE, SerialMouseClose)
#endif

NTSTATUS
SerialMouseFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PDEVICE_EXTENSION  deviceExtension;
    NTSTATUS           status;

    //
    // Get a pointer to the device extension.
    //
    deviceExtension = DeviceObject->DeviceExtension;

    Print(deviceExtension, DBG_UART_INFO, ("Flush \n"));

    status = IoAcquireRemoveLock(&deviceExtension->RemoveLock, Irp);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Fire and forget
    //
    IoSkipCurrentIrpStackLocation(Irp);
    status = IoCallDriver(deviceExtension->TopOfStack, Irp);

    IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

    return status;
}

NTSTATUS
SerialMouseInternalDeviceControl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for internal device control requests.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION irpSp;
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS status;

    //
    // Get a pointer to the device extension.
    //
    deviceExtension = DeviceObject->DeviceExtension;

    Print(deviceExtension, DBG_IOCTL_TRACE, ("IOCTL, enter\n"));

    //
    // Initialize the returned Information field.
    //
    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //
    irpSp = IoGetCurrentIrpStackLocation(Irp);

    status = IoAcquireRemoveLock(&deviceExtension->RemoveLock, Irp);
    if (!NT_SUCCESS(status)) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    ASSERT (deviceExtension->Started ||
            (IOCTL_INTERNAL_MOUSE_CONNECT ==
             irpSp->Parameters.DeviceIoControl.IoControlCode));


    //
    // Case on the device control subfunction that is being performed by the
    // requestor.
    //
    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {

    //
    // Connect a mouse class device driver to the port driver.
    //

    case IOCTL_INTERNAL_MOUSE_CONNECT:

        Print(deviceExtension, DBG_IOCTL_INFO, ("connect\n"));

        //
        // Only allow one connection.
        //
        if (deviceExtension->ConnectData.ClassService != NULL) {

            Print(deviceExtension, DBG_IOCTL_ERROR, ("error - already connected\n"));

            status = STATUS_SHARING_VIOLATION;
            break;

        }
        else if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CONNECT_DATA)) {

            Print(deviceExtension, DBG_IOCTL_ERROR,
                  ("connect error - invalid buffer length\n"));

            status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // Copy the connection parameters to the device extension.
        //

        deviceExtension->ConnectData =
            *((PCONNECT_DATA) (irpSp->Parameters.DeviceIoControl.Type3InputBuffer));

        status = STATUS_SUCCESS;
        break;

    //
    // Disconnect a mouse class device driver from the port driver.
    //
    // NOTE: Not implemented.
    //

    case IOCTL_INTERNAL_MOUSE_DISCONNECT:

        Print(deviceExtension, DBG_IOCTL_INFO, ("disconnect\n"));
        TRAP();

        //
        // Not implemented.
        //
        // To implement, code the following:
        // ---------------------------------
        // o ENSURE that we are NOT enabled (extension->EnableCount);
        //   o If we are, then (a) return STATUS_UNSUCCESSFUL, or
        //                     (b) disable all devices immediately; see
        //                         DISABLE IOCTL call for necessary code.
        // o SYNCHRONIZE with the mouse read completion routine (must
        //   protect the callback pointer from being dereferenced when
        //   it becomes null).  Note that no mechanism currently exists
        //   for this.
        // o CLEAR the connection parameters in the device extension;
        //   ie. extension->ConnectData = { 0, 0 }
        // o RELEASE the synchronizing lock.
        // o RETURN STATUS_SUCCESS.
        //

        //
        // Clear the connection parameters in the device extension.
        // NOTE:  Must synchronize this with the mouse ISR.
        //
        //
        //deviceExtension->ConnectData.ClassDeviceObject =
        //    Null;
        //deviceExtension->ConnectData.ClassService =
        //    Null;

        //
        // Set the completion status.
        //

        status = STATUS_NOT_IMPLEMENTED;
        break;

    case IOCTL_INTERNAL_MOUSE_ENABLE:
        //
        // Enable interrupts
        //
        Print (deviceExtension, DBG_IOCTL_ERROR,
               ("ERROR: PnP => use create not enable! \n"));
        status = STATUS_NOT_SUPPORTED;

        break;

    case IOCTL_INTERNAL_MOUSE_DISABLE:
        //
        // Disable Mouse interrupts 
        //
        Print(deviceExtension, DBG_IOCTL_ERROR,
              ("ERROR: PnP => use close not Disable! \n"));
        status = STATUS_NOT_SUPPORTED;

        break;

    //
    // Query the mouse attributes.  First check for adequate buffer
    // length.  Then, copy the mouse attributes from the device
    // extension to the output buffer.
    //

    case IOCTL_MOUSE_QUERY_ATTRIBUTES:

        Print(deviceExtension, DBG_IOCTL_INFO, ("query attributes\n"));

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(MOUSE_ATTRIBUTES)) {
            Print(deviceExtension, DBG_IOCTL_ERROR, ("QA buffer too small\n"));
            status = STATUS_BUFFER_TOO_SMALL;
        }
        else {
            //
            // Copy the attributes from the DeviceExtension to the
            // buffer.
            //

            *(PMOUSE_ATTRIBUTES) Irp->AssociatedIrp.SystemBuffer =
                deviceExtension->MouseAttributes;

            Irp->IoStatus.Information = sizeof(MOUSE_ATTRIBUTES);
            status = STATUS_SUCCESS;
        }

        break;

    default:
        Print (deviceExtension, DBG_IOCTL_ERROR,
               ("ERROR: unknown IOCTL: 0x%x \n",
                irpSp->Parameters.DeviceIoControl.IoControlCode));
        TRAP();

        status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

    Print(deviceExtension, DBG_IOCTL_TRACE, ("IOCTL, exit (%x)\n", status));

    return status;
}

NTSTATUS
SerialMouseClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    NTSTATUS            status;

    PAGED_CODE();

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    Print(deviceExtension, DBG_CC_NOISE, 
          ("Close:   enable count is %d\n", deviceExtension->EnableCount));

    ASSERT(0 < deviceExtension->EnableCount);

    status = IoAcquireRemoveLock(&deviceExtension->RemoveLock, Irp);
    if (!NT_SUCCESS(status)) {
        goto SerialMouseCloseReject;
    }

    //
    // Serial can only handle one create/close, all others fail.  This is not
    // true for mice though.  Only send the last close on to serial.
    //
    if (0 == InterlockedDecrement(&deviceExtension->EnableCount)) {
        Print(deviceExtension, DBG_PNP_INFO | DBG_CC_INFO,
              ("Cancelling and stopping detection for close\n"));

        //
        // Cleanup:  cancel the read and stop detection
        //
        IoCancelIrp(deviceExtension->ReadIrp);
        SerialMouseStopDetection(deviceExtension);

        //
        // Restore the port to the state it was before we opened it
        //
        SerialMouseRestorePort(deviceExtension);

        IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

        IoSkipCurrentIrpStackLocation(Irp);
        return IoCallDriver(deviceExtension->TopOfStack, Irp);
    }
    else {
        Print(deviceExtension, DBG_CC_INFO,
              ("Close (%d)\n", deviceExtension->EnableCount));

        status = STATUS_SUCCESS;
    }

    IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

SerialMouseCloseReject:
    Irp->IoStatus.Status = status; 
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
SerialMouseCreate(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )

/*++

Routine Description:

    This is the dispatch routine for create/open requests.
    These requests complete successfully.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION  irpSp  = NULL;
    NTSTATUS            status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   deviceExtension = NULL;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    Print(deviceExtension, DBG_CC_TRACE, ("Create: Enter.\n"));

    Print(deviceExtension, DBG_CC_NOISE, 
          ("Create:   enable count is %d\n"));

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //
    irpSp = IoGetCurrentIrpStackLocation (Irp);

    //
    // Determine if request is trying to open a subdirectory of the
    // given device object.  This is not allowed.
    //
    if (0 != irpSp->FileObject->FileName.Length) {
        Print(deviceExtension, DBG_CC_ERROR,
              ("ERROR: Create Access Denied.\n"));

        status = STATUS_ACCESS_DENIED;
        goto SerialMouseCreateReject;
    }

    status = IoAcquireRemoveLock(&deviceExtension->RemoveLock, Irp);
    if (!NT_SUCCESS(status)) {
        goto SerialMouseCreateReject;
    }

    if (NULL == deviceExtension->ConnectData.ClassService) {
        //
        // No Connection yet.  How can we be enabled?
        //
        Print(deviceExtension, DBG_IOCTL_ERROR,
              ("ERROR: enable before connect!\n"));
        status = STATUS_UNSUCCESSFUL;
    }
    else if ( 1 == InterlockedIncrement(&deviceExtension->EnableCount)) {
        //
        // send it down the stack
        //
        status = SerialMouseSendIrpSynchronously(deviceExtension->TopOfStack,
                                                 Irp,
                                                 TRUE);

        if (NT_SUCCESS(status) && NT_SUCCESS(Irp->IoStatus.Status)) {
            //
            // Everything worked, start up the mouse. 
            //
            status = SerialMouseStartDevice(deviceExtension, Irp, TRUE);
        }
        else {
            //
            // Create failed, decrement the enable count back to zero
            //
            InterlockedDecrement(&deviceExtension->EnableCount);
        }
    }
    else {
        //
        // Serial only handles one create/close.  Don't send this one down the
        // stack, it will fail.  The call to  InterlockedIncrement above
        // correctly adjusts the count.
        //
        ASSERT (deviceExtension->EnableCount >= 1);

        status = STATUS_SUCCESS;
    }

    IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

SerialMouseCreateReject:

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    Print(deviceExtension, DBG_CC_TRACE,
          ("SerialMouseCreate, 0x%x\n", status));

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\mouser\sermdep.c ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved
Copyright (c) 1993  Logitech Inc.

Module Name:

    sermdep.c

Abstract:

    The initialization and hardware-dependent portions of
    the Microsoft serial (i8250) mouse port driver.  Modifications
    to support new mice similar to the serial mouse should be
    localized to this file.

Environment:

    Kernel mode only.

Notes:

    NOTES:  (Future/outstanding issues)

    - Powerfail not implemented.

    - Consolidate duplicate code, where possible and appropriate.

    - The serial ballpoint is supported.   However, Windows USER does not
      intend (right now) to use the ballpoint in anything except mouse
      emulation mode.  In ballpoint mode, there is extra functionality that
      would need to be supported.  E.g., the driver would need to pass
      back extra button information from the 4th byte of the ballpoint
      data packet.  Windows USER would need/want to allow the user to select
      which buttons are used, what the orientation of the ball is (esp.
      important for lefthanders), sensitivity, and acceleration profile.


Revision History:


--*/

#include "stdarg.h"
#include "stdio.h"
#include "string.h"
#include "ntddk.h"
#include "mouser.h"
#include "sermlog.h"
#include "cseries.h"
#include "mseries.h"
#include "debug.h"

//
// Use the alloc_text pragma to specify the driver initialization routines
// (they can be paged out).
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, SerialMouseServiceParameters)
#pragma alloc_text(PAGE, SerialMouseClosePort)
#pragma alloc_text(PAGE, SerialMouseInitializeHardware)
#pragma alloc_text(PAGE, SerialMouseInitializeDevice)
#pragma alloc_text(PAGE, SerialMouseSpinUpRead)
#pragma alloc_text(PAGE, SerialMouseStartDevice)
#pragma alloc_text(PAGE, SerialMouseUnload)

#if DBG
#pragma alloc_text(INIT,SerialMouseGetDebugFlags)
#endif

#endif

#if DBG
ULONG GlobalDebugFlags;
#endif

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine initializes the serial (i8250) mouse port driver.

Arguments:

    DriverObject - Pointer to driver object created by system.

    RegistryPath - Pointer to the Unicode name of the registry path
        for this driver.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    PUNICODE_STRING regPath;
    NTSTATUS status;

    status = IoAllocateDriverObjectExtension(DriverObject,
                                             (PVOID) 1,
                                             sizeof(UNICODE_STRING),
                                             (PVOID *) &regPath);

    ASSERT(NT_SUCCESS(status));

    if (regPath) {
        regPath->MaximumLength = RegistryPath->Length + sizeof(UNICODE_NULL);
        regPath->Length = RegistryPath->Length;
        regPath->Buffer = ExAllocatePool(NonPagedPool,
                                         regPath->MaximumLength);

        if (regPath->Buffer) {
            RtlZeroMemory(regPath->Buffer,
                          regPath->MaximumLength);

            RtlMoveMemory(regPath->Buffer,
                          RegistryPath->Buffer,
                          RegistryPath->Length);
        }
        else {
            regPath->MaximumLength = regPath->Length = 0;
        }
    }

#if DBG
    SerialMouseGetDebugFlags(regPath);
#endif

    //
    // Set up the device driver entry points and leave
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE] = SerialMouseCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]  = SerialMouseClose;
    DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS]  =
                                                 SerialMouseFlush;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] =
                                         SerialMouseInternalDeviceControl;

    DriverObject->MajorFunction[IRP_MJ_PNP]    = SerialMousePnP;
    DriverObject->MajorFunction[IRP_MJ_POWER]  = SerialMousePower;

    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] =
                                                 SerialMouseSystemControl;

    DriverObject->DriverUnload                 = SerialMouseUnload;
    DriverObject->DriverExtension->AddDevice   = SerialMouseAddDevice;

    return STATUS_SUCCESS;
}

VOID
SerialMouseClosePort(
    PDEVICE_EXTENSION DeviceExtension,
    PIRP              Irp
    )
{
    PIO_STACK_LOCATION next;

    SerialMouseRestorePort(DeviceExtension);

    next = IoGetNextIrpStackLocation (Irp);
    RtlZeroMemory(next, sizeof(IO_STACK_LOCATION));
    next->MajorFunction = IRP_MJ_CLEANUP;

    SerialMouseSendIrpSynchronously(DeviceExtension->TopOfStack,
                                    Irp,
                                    FALSE);

    next = IoGetNextIrpStackLocation (Irp);
    RtlZeroMemory(next, sizeof(IO_STACK_LOCATION));
    next->MajorFunction = IRP_MJ_CLOSE;

    SerialMouseSendIrpSynchronously(DeviceExtension->TopOfStack,
                                    Irp,
                                    FALSE);

}
NTSTATUS
SerialMouseSpinUpRead(
    PDEVICE_EXTENSION DeviceExtension
    )
{
    NTSTATUS status;

    PAGED_CODE();

    IoAcquireRemoveLock(&DeviceExtension->RemoveLock,
                        DeviceExtension->ReadIrp);

    ASSERT(DeviceExtension->Started);

    //
    // SerialMouseStartRead needs started to be set to true
    //
    DeviceExtension->ReadInterlock = SERIAL_MOUSE_END_READ;

    status = SerialMouseStartRead(DeviceExtension);

    if (status == STATUS_PENDING || status == STATUS_SUCCESS) {
        Print(DeviceExtension, DBG_PNP_INFO,
              ("Start read succeeded, 0x%x\n", status));

        status = STATUS_SUCCESS;
    }
    else {
        Print(DeviceExtension, DBG_PNP_ERROR,
              ("Start read failed, 0x%x\n", status));

        ASSERT(!NT_SUCCESS(status));

        //
        // No need to release the remove lock here.  If SerialMouseStartRead
        // fails, then it will release the lock on its own.
        //
        // IoReleaseRemoveLock(&DeviceExtension->RemoveLock,
        //                     DeviceExtension->ReadIrp);

        DeviceExtension->Started = FALSE;
    }

    return status;
}

NTSTATUS
SerialMouseStartDevice(
    PDEVICE_EXTENSION DeviceExtension,
    PIRP              Irp,
    BOOLEAN           CloseOnFailure
    )
{
    PIO_STACK_LOCATION  next;
    NTSTATUS            status;

    PAGED_CODE();

    status = SerialMouseInitializeDevice(DeviceExtension);

    Print(DeviceExtension, DBG_PNP_INFO, ("InitializeDevice 0x%x\n", status));

    if (NT_SUCCESS(status)) {
        status = SerialMouseSpinUpRead(DeviceExtension);
    }

    if (!NT_SUCCESS(status) && CloseOnFailure) {

        Print(DeviceExtension, DBG_PNP_ERROR,
              ("sending close due to failure, 0x%x\n", status));

        //
        // The start failed and we sent the create as part of the start
        // Send the matching cleanup/close so the port is accessible again.
        //
        SerialMouseClosePort(DeviceExtension, Irp);

        InterlockedDecrement(&DeviceExtension->EnableCount);
    }

    return status;
}

NTSTATUS
SerialMouseInitializeDevice (
    IN PDEVICE_EXTENSION    DeviceExtension
    )

/*++

Routine Description:

    This routine initializes the device for the given device
    extension.

Arguments:

    DriverObject        - Supplies the driver object.

    TmpDeviceExtension  - Supplies a temporary device extension for the
                            device to initialize.

    RegistryPath        - Supplies the registry path.

    BaseDeviceName      - Supplies the base device name to the device
                            to create.

Return Value:

    None.

--*/

{
#define DUMP_COUNT 4
    NTSTATUS                status = STATUS_SUCCESS;
    PIO_ERROR_LOG_PACKET    errorLogEntry;
    ULONG                   uniqueErrorValue,
                            dumpCount = 0,
                            i,
                            dumpData[DUMP_COUNT];
    UNICODE_STRING              keyName;
    KEVENT                  event;
    IO_STATUS_BLOCK         iosb;
    ULONG                   waitMask;

    for (i = 0; i < DUMP_COUNT; i++) {
        dumpData[i] = 0;
    }

    Print(DeviceExtension, DBG_SS_TRACE, ("StartDevice, enter\n"));

    PAGED_CODE();

    DeviceExtension->Started = TRUE;

    //
    // Set the wait mask to zero so that when we send the
    // wait request it won't get completed due to init flipping lines
    //
    // (the wait mask could have been set by a previous app or by this driver
    //  and we are coming out of a > D0 state)
    //
    waitMask = 0x0;
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    SerialMouseIoSyncIoctlEx(IOCTL_SERIAL_SET_WAIT_MASK,
                             DeviceExtension->TopOfStack,
                             &event,
                             &iosb,
                             &waitMask,
                             sizeof(ULONG),
                             NULL,
                             0);

    //
    // Initialize the h/w and figure out what type of mouse is on the port
    //
    status = SerialMouseInitializeHardware(DeviceExtension);

    if (!NT_SUCCESS(status)) {
        Print(DeviceExtension, DBG_SS_ERROR,
              ("Could not initialize hardware\n"));
        goto SerialMouseInitializeExit;
    }

    if (!DeviceExtension->MouseAttributes.MouseIdentifier) {
        DeviceExtension->MouseAttributes.MouseIdentifier =
            MOUSE_SERIAL_HARDWARE;
    }

    DeviceExtension->DetectionSupported = TRUE;
    SerialMouseStartDetection(DeviceExtension);

SerialMouseInitializeExit:

    //
    // Log an error, if necessary.
    //

    if (status != STATUS_SUCCESS) {
        DeviceExtension->Started = FALSE;

        errorLogEntry = (PIO_ERROR_LOG_PACKET)
            IoAllocateErrorLogEntry(
                DeviceExtension->Self,
                (UCHAR) (sizeof(IO_ERROR_LOG_PACKET)
                         + (dumpCount * sizeof(ULONG)))
                );

        if (errorLogEntry != NULL) {

            errorLogEntry->ErrorCode = status;
            errorLogEntry->DumpDataSize = (USHORT) dumpCount * sizeof(ULONG);
            errorLogEntry->SequenceNumber = 0;
            errorLogEntry->MajorFunctionCode = 0;
            errorLogEntry->IoControlCode = 0;
            errorLogEntry->RetryCount = 0;
            // errorLogEntry->UniqueErrorValue = uniqueErrorValue;
            errorLogEntry->FinalStatus = status;
            for (i = 0; i < dumpCount; i++)
                errorLogEntry->DumpData[i] = dumpData[i];

            IoWriteErrorLogEntry(errorLogEntry);
        }
    }

    Print(DeviceExtension, DBG_SS_TRACE, ("IntializeDevice 0x%x\n", status));

    return status;
}

VOID
SerialMouseUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{
    PUNICODE_STRING regPath;

    PAGED_CODE();

    ASSERT(NULL == DriverObject->DeviceObject);

    regPath = SerialMouseGetRegistryPath(DriverObject);
    if (regPath && regPath->Buffer) {
        ExFreePool(regPath->Buffer);
    }
}

NTSTATUS
SerialMouseInitializeHardware(
    IN PDEVICE_EXTENSION DeviceExtension
    )

/*++

Routine Description:

    This routine initializes the serial mouse/ballpoint.  Note that this
    routine is only called at initialization time, so synchronization is
    not required.

Arguments:

    DeviceObject - Pointer to the device object.

Return Value:

    STATUS_SUCCESS if a pointing device is detected, otherwise STATUS_UNSUCCESSFUL

--*/

{
    MOUSETYPE mouseType;
    ULONG hardwareButtons;
    NTSTATUS status = STATUS_UNSUCCESSFUL;

    Print(DeviceExtension, DBG_SS_TRACE, ("SerialMouseInitializeHardware: enter\n"));

    //
    // Zero out the handler data in case we have previous state from a
    // previous start
    //
    RtlZeroMemory(&DeviceExtension->HandlerData, sizeof(HANDLER_DATA));

    if ((mouseType = MSerDetect(DeviceExtension)) != NO_MOUSE) {
        status = STATUS_SUCCESS;
        switch (mouseType) {
        case MOUSE_2B:
            DeviceExtension->ProtocolHandler =
                MSerSetProtocol(DeviceExtension, MSER_PROTOCOL_MP);
            DeviceExtension->MouseAttributes.MouseIdentifier =
                MOUSE_SERIAL_HARDWARE;
            hardwareButtons = 2;
            break;
        case MOUSE_3B:
            DeviceExtension->ProtocolHandler =
                MSerSetProtocol(DeviceExtension, MSER_PROTOCOL_MP);
            DeviceExtension->MouseAttributes.MouseIdentifier =
                MOUSE_SERIAL_HARDWARE;
            hardwareButtons = 3;
            break;
        case BALLPOINT:
            DeviceExtension->ProtocolHandler =
                MSerSetProtocol(DeviceExtension, MSER_PROTOCOL_BP);
            DeviceExtension->MouseAttributes.MouseIdentifier =
                BALLPOINT_SERIAL_HARDWARE;
            hardwareButtons = 2;
            break;
        case MOUSE_Z:
            DeviceExtension->ProtocolHandler =
                MSerSetProtocol(DeviceExtension, MSER_PROTOCOL_Z);
            hardwareButtons = 3;
            DeviceExtension->MouseAttributes.MouseIdentifier =
                WHEELMOUSE_SERIAL_HARDWARE;
            break;
        }
    }
    else if (CSerDetect(DeviceExtension, &hardwareButtons)) {
        status = STATUS_SUCCESS;
        DeviceExtension->ProtocolHandler =
            CSerSetProtocol(DeviceExtension, CSER_PROTOCOL_MM);
#if DBG
        DeviceExtension->DebugFlags |= (DBG_HANDLER_INFO | DBG_HANDLER_ERROR);
#endif
    }
    else {
        DeviceExtension->ProtocolHandler = NULL;
        hardwareButtons = MOUSE_NUMBER_OF_BUTTONS;
    }


    //
    // If the hardware wasn't overridden, set the number of buttons
    // according to the protocol.
    //

    DeviceExtension->MouseAttributes.NumberOfButtons =
            (USHORT) hardwareButtons;

    if (NT_SUCCESS(status)) {

        //
        // Make sure the FIFO is turned off.
        //

        SerialMouseSetFifo(DeviceExtension, 0);

        //
        // Clean up anything left in the receive buffer.
        //
        SerialMouseFlushReadBuffer(DeviceExtension);

    }

    Print(DeviceExtension, DBG_SS_TRACE,
          ("SerialMouseInitializeHardware exit (0x%x)\n", status));

    return status;
}

#if DBG
VOID
SerialMouseGetDebugFlags(
    IN PUNICODE_STRING RegPath
    )
{
}
#endif

VOID
SerialMouseServiceParameters(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN HANDLE Handle
    )

/*++

Routine Description:

    This routine retrieves this driver's service parameters information
    from the registry.

Arguments:

    DeviceExtension - Pointer to the device extension.

    RegistryPath - Pointer to the null-terminated Unicode name of the
        registry path for this driver.

    DeviceName - Pointer to the Unicode string that will receive
        the port device name.

Return Value:

    None.  As a side-effect, sets fields in DeviceExtension->Configuration.

--*/

{
    PRTL_QUERY_REGISTRY_TABLE  parameters = NULL;
    NTSTATUS                   status = STATUS_SUCCESS;
    LONG                       defaultWaitEventMask = 0x0,
                               numberOfButtons        = MOUSE_NUMBER_OF_BUTTONS,
                               defaultNumberOfButtons = MOUSE_NUMBER_OF_BUTTONS,
                               sampleRate        = MOUSE_SAMPLE_RATE,
                               defaultSampleRate = MOUSE_SAMPLE_RATE,
                               i;
    USHORT                     queriesPlusOne = 4;

    WCHAR                      strParameters[] = L"Parameters";
    PUNICODE_STRING            regPath;
    UNICODE_STRING             parametersPath;

#if DBG
    ULONG                      defaultDebugFlags = DEFAULT_DEBUG_FLAGS;

    queriesPlusOne++;
#endif

    RtlInitUnicodeString(&parametersPath, NULL);

    //
    // Allocate the Rtl query table.
    //
    parameters = ExAllocatePool(
                     PagedPool,
                     sizeof(RTL_QUERY_REGISTRY_TABLE) * queriesPlusOne
                     );

    if (!parameters) {
        status = STATUS_UNSUCCESSFUL;
        goto SetParameters;
    }
    else {
        RtlZeroMemory(
            parameters,
            sizeof(RTL_QUERY_REGISTRY_TABLE) * queriesPlusOne
            );

        regPath = SerialMouseGetRegistryPath(DeviceExtension->Self->DriverObject);
        if (!regPath || !regPath->Buffer) {
            goto GetServiceParametersByHandle;
        }
        parametersPath.MaximumLength = regPath->Length +
            (wcslen(strParameters) * sizeof(WCHAR) ) + sizeof(UNICODE_NULL);

        parametersPath.Buffer = ExAllocatePool(PagedPool,
                                               parametersPath.MaximumLength);

        if (!parametersPath.Buffer) {
            status = STATUS_UNSUCCESSFUL;
            goto GetServiceParametersByHandle;
        }

    }

    RtlZeroMemory(parametersPath.Buffer,
                  parametersPath.MaximumLength);
    RtlAppendUnicodeToString(&parametersPath,
                             regPath->Buffer);
    RtlAppendUnicodeToString(&parametersPath,
                             strParameters);

    //
    // Gather all of the "user specified" information from
    // the registry.
    //

    i = 0;
    parameters[i].Flags = RTL_QUERY_REGISTRY_DIRECT;
    parameters[i].Name = L"NumberOfButtons";
    parameters[i].EntryContext = &numberOfButtons;
    parameters[i].DefaultType = REG_DWORD;
    parameters[i].DefaultData = &defaultNumberOfButtons;
    parameters[i].DefaultLength = sizeof(LONG);

    parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
    parameters[i].Name = L"SampleRate";
    parameters[i].EntryContext = &sampleRate;
    parameters[i].DefaultType = REG_DWORD;
    parameters[i].DefaultData = &defaultSampleRate;
    parameters[i].DefaultLength = sizeof(LONG);

#if DBG
    parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
    parameters[i].Name = L"DebugFlags";
    parameters[i].EntryContext = &DeviceExtension->DebugFlags;
    parameters[i].DefaultType = REG_DWORD;
    parameters[i].DefaultData = &defaultDebugFlags;
    parameters[i].DefaultLength = sizeof(ULONG);
#endif

    status = RtlQueryRegistryValues(
        RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
        parametersPath.Buffer,
        parameters,
        NULL,
        NULL
        );

    if (!NT_SUCCESS(status)) {
        Print(DeviceExtension, DBG_SS_ERROR,
              ("RtlQueryRegistryValues failed with 0x%x\n", status));

        DeviceExtension->DebugFlags = DEFAULT_DEBUG_FLAGS;
    }

GetServiceParametersByHandle:
    if (Handle) {
        LONG prevNumberOfButtons = numberOfButtons,
             prevSampleRate = sampleRate;

        i = 0;
        parameters[i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = L"NumberOfButtons";
        parameters[i].EntryContext = &numberOfButtons;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &prevNumberOfButtons;
        parameters[i].DefaultLength = sizeof(LONG);

        parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = L"SampleRate";
        parameters[i].EntryContext = &sampleRate;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &prevSampleRate;
        parameters[i].DefaultLength = sizeof(LONG);

        parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = L"WaitEventMask";
        parameters[i].EntryContext = &DeviceExtension->WaitEventMask;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &defaultWaitEventMask;
        parameters[i].DefaultLength = sizeof(LONG);

#if DBG
        parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = L"DebugFlags";
        parameters[i].EntryContext = &DeviceExtension->DebugFlags;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &defaultDebugFlags;
        parameters[i].DefaultLength = sizeof(ULONG);
#endif

        status = RtlQueryRegistryValues(
                     RTL_REGISTRY_HANDLE,
                     (PWSTR) Handle,
                     parameters,
                     NULL,
                     NULL
                     );
    }

SetParameters:
    if (!NT_SUCCESS(status)) {
        DeviceExtension->WaitEventMask = defaultWaitEventMask;
#if DBG
        DeviceExtension->DebugFlags = defaultDebugFlags;
#endif
    }

#if DBG
    if (defaultDebugFlags == DeviceExtension->DebugFlags &&
        GlobalDebugFlags != 0x0) {
        DeviceExtension->DebugFlags = GlobalDebugFlags;
    }
#endif

    DeviceExtension->MouseAttributes.NumberOfButtons = (USHORT) numberOfButtons;
    DeviceExtension->MouseAttributes.SampleRate = (USHORT) sampleRate;

    Print(DeviceExtension, DBG_SS_NOISE, ("NumberOfButtons = %d\n",
          DeviceExtension->MouseAttributes.NumberOfButtons));

    Print(DeviceExtension, DBG_SS_NOISE, ("SampleRate = %d\n",
          DeviceExtension->MouseAttributes.SampleRate));

    Print(DeviceExtension, DBG_SS_NOISE, ("WaitEventMask = 0x%x\n",
          DeviceExtension->WaitEventMask));

    Print(DeviceExtension, DBG_SS_NOISE, ("DebugFlags  0x%x\n",
          DeviceExtension->DebugFlags));

    if (parametersPath.Buffer)
        ExFreePool(parametersPath.Buffer);
    if (parameters)
        ExFreePool(parameters);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\mouser\wmi.c ===
/*++

Copyright (c) 1997-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    wmi.c

Abstract:

    This module contains the code that handles the wmi IRPs for the
    serial mouse driver.

Author:

Environment:

    Kernel mode

Revision History :
--*/

#include "mouser.h"
#include "debug.h"
#include <wmistr.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SerialMouseSystemControl)
#pragma alloc_text(PAGE, SerialMouseSetWmiDataItem)
#pragma alloc_text(PAGE, SerialMouseSetWmiDataBlock)
#pragma alloc_text(PAGE, SerialMouseQueryWmiDataBlock)
#pragma alloc_text(PAGE, SerialMouseQueryWmiRegInfo)
#endif

#define WMI_MOUSE_PORT_INFORMATION    0
GUID SerialMousePointerPortGuid = POINTER_PORT_WMI_STD_DATA_GUID;

WMIGUIDREGINFO WmiGuidList[1] =
{
    { &SerialMousePointerPortGuid, 1, 0 }   // Pointer Port driver information
};

NTSTATUS
SerialMouseSystemControl(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    )
/*++
Routine Description

    We have just received a System Control IRP.

    Assume that this is a WMI IRP and call into the WMI system library and let
    it handle this IRP for us.

--*/
{
    PDEVICE_EXTENSION       deviceExtension;
    SYSCTL_IRP_DISPOSITION disposition;
    NTSTATUS status;

    PAGED_CODE();
    
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    status = WmiSystemControl(&deviceExtension->WmiLibInfo, 
                                 DeviceObject, 
                                 Irp,
                                 &disposition);
    switch(disposition)
    {
        case IrpProcessed:
        {
            //
            // This irp has been processed and may be completed or pending.
            break;
        }
        
        case IrpNotCompleted:
        {
            //
            // This irp has not been completed, but has been fully processed.
            // we will complete it now
            IoCompleteRequest(Irp, IO_NO_INCREMENT);                
            break;
        }
        
        case IrpForward:
        case IrpNotWmi:
        {
            //
            // This irp is either not a WMI irp or is a WMI irp targetted
            // at a device lower in the stack.
            IoSkipCurrentIrpStackLocation (Irp);
            status = IoCallDriver (deviceExtension->TopOfStack, Irp);
            break;
        }
                                    
        default:
        {
            //
            // We really should never get here, but if we do just forward....
            ASSERT(FALSE);
            IoSkipCurrentIrpStackLocation (Irp);
            status = IoCallDriver (deviceExtension->TopOfStack, Irp);
            break;
        }        
    }
    
    return(status);
}

NTSTATUS
SerialMouseSetWmiDataItem(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            DataItemId,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION   deviceExtension;
    NTSTATUS            status;

    PAGED_CODE();

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    switch(GuidIndex) {

    case WMI_MOUSE_PORT_INFORMATION:
        status = STATUS_WMI_READ_ONLY;
        break;

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
        break;
    }

    status = WmiCompleteRequest(  DeviceObject,
                                  Irp,
                                  status,
                                  0,
                                  IO_NO_INCREMENT
                                  );

    return status;
}

NTSTATUS
SerialMouseSetWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION   deviceExtension;
    NTSTATUS            status;

    PAGED_CODE();

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    switch (GuidIndex) {

    case WMI_MOUSE_PORT_INFORMATION:
        status = STATUS_WMI_READ_ONLY;
        break;

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest(  DeviceObject,
                                  Irp,
                                  status,
                                  0,
                                  IO_NO_INCREMENT
                                  );

    return status;
}

NTSTATUS
SerialMouseQueryWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            InstanceCount,
    IN OUT PULONG       InstanceLengthArray,
    IN ULONG            OutBufferSize,
    OUT PUCHAR          Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    BufferAvail on has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION   deviceExtension;
    NTSTATUS            status;
    ULONG               size = 0;

    PAGED_CODE();

    ASSERT((InstanceIndex == 0) && (InstanceCount == 1));
    
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    switch (GuidIndex) {

    case WMI_MOUSE_PORT_INFORMATION: {

        POINTER_PORT_WMI_STD_DATA   mouData;

        size = sizeof(mouData);

        if (OutBufferSize < size) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        *InstanceLengthArray = size;
        mouData.ConnectorType = POINTER_PORT_WMI_STD_I8042;
        mouData.DataQueueSize =
            deviceExtension->MouseAttributes.InputDataQueueLength; 
        mouData.Buttons = deviceExtension->MouseAttributes.NumberOfButtons;
        mouData.ErrorCount = 0;

        *(PPOINTER_PORT_WMI_STD_DATA) Buffer = mouData;

        *InstanceLengthArray = size;

        status = STATUS_SUCCESS;

        break;
    }

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
        break;
    }

    status = WmiCompleteRequest(  DeviceObject,
                                  Irp,
                                  status,
                                  size,
                                  IO_NO_INCREMENT
                                  );

    return status;
}

NTSTATUS
SerialMouseQueryWmiRegInfo(
    IN PDEVICE_OBJECT   DeviceObject,
    OUT PULONG          RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered. 
            
    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe all of the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device. These flags are ORed into the flags specified
        by the GUIDREGINFO for each guid.               

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. This is 
        required
                
    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.
                
    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in 
        *RegFlags.

Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    PUNICODE_STRING regPath;    
        
    PAGED_CODE();
    
    deviceExtension = DeviceObject->DeviceExtension;
    
    *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
    if (regPath = SerialMouseGetRegistryPath(DeviceObject->DriverObject)) {
        *RegistryPath = regPath;
    }
    *Pdo = deviceExtension->PDO;
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\neckbadd\sources.inc ===
MAJORCOMP=ntos
MINORCOMP=dd

TARGETNAME=neckbadd

TARGETPATH=obj
TARGETTYPE=DRIVER

INCLUDES=..\..\inc;..\i386

SOURCES=..\neckbadd.c      \
        ..\neckbadd.rc

NTTEST=
OPTIONAL_NTTEST=
UMTEST=

C_DEFINES=-DPNP_IDENTIFY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\mouser\wrapper.c ===
/*++


Copyright (c) 1997-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    wrapper.c

Abstract:

    Wraps all IOCTL based requests into nice self contained functions

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/

#include "mouser.h"
#include "debug.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,SerialMouseSetFifo)
#pragma alloc_text(PAGE,SerialMouseGetLineCtrl)
#pragma alloc_text(PAGE,SerialMouseSetLineCtrl)
#pragma alloc_text(PAGE,SerialMouseGetModemCtrl)
#pragma alloc_text(PAGE,SerialMouseSetModemCtrl)
#pragma alloc_text(PAGE,SerialMouseGetBaudRate)
#pragma alloc_text(PAGE,SerialMouseSetBaudRate)
#pragma alloc_text(PAGE,SerialMouseReadChar)
#pragma alloc_text(PAGE,SerialMouseWriteChar)
#pragma alloc_text(PAGE,SerialMouseWriteString)
#endif // ALLOC_PRAGMA

//
// Constants
//

//
// unknown
//
NTSTATUS
SerialMouseSetFifo(
    PDEVICE_EXTENSION DeviceExtension,
    UCHAR             Value
    )
/*++

Routine Description:

    Set the FIFO register.

Arguments:

    Port - Pointer to the serial port.

    Value - The FIFO control mask.

Return Value:

    None.

--*/
{
    ULONG               fifo = Value; 
    IO_STATUS_BLOCK     iosb;
    KEVENT              event;
    NTSTATUS            status;

    Print(DeviceExtension, DBG_UART_TRACE, ("Fifo, enter\n"));

    KeInitializeEvent(&event,
                      NotificationEvent,
                      FALSE);

    status = SerialMouseIoSyncIoctlEx(
        IOCTL_SERIAL_SET_FIFO_CONTROL,
        DeviceExtension->TopOfStack, 
        &event,
        &iosb,
        &fifo,
        sizeof(ULONG),
        NULL,
        0);

    if (!NT_SUCCESS(iosb.Status)) {
        status = iosb.Status;
    }

    if (!NT_SUCCESS(status)) {
       Print(DeviceExtension, DBG_UART_ERROR, ("Fifo failed (%x)\n", status));
    }

    return status;
}

NTSTATUS
SerialMouseGetLineCtrl(
    PDEVICE_EXTENSION       DeviceExtension,
    PSERIAL_LINE_CONTROL    SerialLineControl
    )
/*++

Routine Description:

    Get the serial port line control register.

Arguments:

    Port - Pointer to the serial port.

Return Value:

    Serial port line control value.

--*/
{
    IO_STATUS_BLOCK     iosb;
    KEVENT              event;
    NTSTATUS            status;

    Print(DeviceExtension, DBG_UART_TRACE, ("GetLineCtrl enter\n"));

    KeInitializeEvent(&event,
                      NotificationEvent,
                      FALSE);

    status = SerialMouseIoSyncIoctlEx(
        IOCTL_SERIAL_GET_LINE_CONTROL,
        DeviceExtension->TopOfStack, 
        &event,
        &iosb,
        NULL,
        0,
        SerialLineControl,
        sizeof(SERIAL_LINE_CONTROL));

    if (!NT_SUCCESS(iosb.Status)) {
        status = iosb.Status;
    }

    if (!NT_SUCCESS(status)) {
        Print(DeviceExtension, DBG_UART_ERROR,
              ("GetLineCtrl failed! (%x)\n", status));
    }

    Print(DeviceExtension, DBG_UART_TRACE,
          ("GetLineCtrl exit (%x)\n", status));

    return status;
}

NTSTATUS
SerialMouseSetLineCtrl(
    PDEVICE_EXTENSION       DeviceExtension, 
    PSERIAL_LINE_CONTROL    SerialLineControl
    )
/*++

Routine Description:

    Set the serial port line control register.

Arguments:

    Port - Pointer to the serial port.

    Value - New line control value.

Return Value:

    Previous serial line control register value.

--*/
{
    IO_STATUS_BLOCK     iosb;
    KEVENT              event;
    NTSTATUS            status;

    KeInitializeEvent(&event,
                      NotificationEvent,
                      FALSE);

    status = SerialMouseIoSyncIoctlEx(
        IOCTL_SERIAL_SET_LINE_CONTROL,
        DeviceExtension->TopOfStack, 
        &event,
        &iosb,
        SerialLineControl,
        sizeof(SERIAL_LINE_CONTROL),
        NULL,
        0);

    if (!NT_SUCCESS(iosb.Status)) {
        status = iosb.Status;
    }

    if (!NT_SUCCESS(status)) {
        Print(DeviceExtension, DBG_UART_ERROR,
              ("SetLineCtrl failed (%x)\n", status));
    }

    Print(DeviceExtension, DBG_UART_TRACE,
          ("SetLineCtrl exit (%x)\n", status));

    return status;
}

NTSTATUS
SerialMouseGetModemCtrl(
    PDEVICE_EXTENSION   DeviceExtension,
    PULONG              ModemCtrl
    )
/*++

Routine Description:

    Get the serial port modem control register.

Arguments:

    Port - Pointer to the serial port.

Return Value:

    Serial port modem control register value.

--*/
{
    IO_STATUS_BLOCK     iosb;
    KEVENT              event;
    NTSTATUS            status;

    KeInitializeEvent(&event,
                      NotificationEvent,
                      FALSE);

    status = SerialMouseIoSyncIoctlEx(
        IOCTL_SERIAL_GET_MODEM_CONTROL,
        DeviceExtension->TopOfStack, 
        &event,
        &iosb,
        NULL,
        0,
        ModemCtrl,
        sizeof(ULONG));

    if (!NT_SUCCESS(iosb.Status)) {
        status = iosb.Status;
    }

    if (!NT_SUCCESS(status)) {
        Print(DeviceExtension, DBG_UART_ERROR,
              ("GetModemCtrl failed! (%x)\n", status));
    }

    Print(DeviceExtension, DBG_UART_TRACE,
          ("GetModemCtrl exit (%x)\n", status));

    return status; 
}

//
// unknown
//
NTSTATUS
SerialMouseSetModemCtrl(
    PDEVICE_EXTENSION DeviceExtension,
    ULONG             Value,
    PULONG            OldValue          OPTIONAL
    )
/*++

Routine Description:

    Set the serial port modem control register.

Arguments:

    Port - Pointer to the serial port.

Return Value:

    Previous modem control register value.

--*/
{
    IO_STATUS_BLOCK     iosb;
    KEVENT              event;
    NTSTATUS            status;

    Print(DeviceExtension, DBG_UART_TRACE, ("SetModemCtrl enter\n"));

    if (ARGUMENT_PRESENT(OldValue)) {
        SerialMouseGetModemCtrl(DeviceExtension, OldValue);
    }

    KeInitializeEvent(&event,
                      NotificationEvent,
                      FALSE);

    status = SerialMouseIoSyncIoctlEx(
        IOCTL_SERIAL_SET_MODEM_CONTROL,
        DeviceExtension->TopOfStack, 
        &event,
        &iosb,
        &Value,
        sizeof(ULONG),
        NULL,
        0);

    if (!NT_SUCCESS(iosb.Status)) {
        status = iosb.Status;
    }

    if (!NT_SUCCESS(status)) {
        Print(DeviceExtension, DBG_UART_ERROR,
              ("SetModemCtrl failed!  (%x)\n", status));
    }

    Print(DeviceExtension, DBG_UART_TRACE,
          ("SetModemCtrl exit (%x)\n", status));

    return status; 
}

NTSTATUS
SerialMouseGetBaudRate(
    PDEVICE_EXTENSION DeviceExtension,
    PULONG            BaudRate
    )
/*++

Routine Description:

    Get the serial port baud rate setting.

Arguments:

    Port - Pointer to the serial port.

    BaudClock - The external frequency driving the serial chip.

Return Value:

    Serial port baud rate.

--*/
{
    SERIAL_BAUD_RATE    sbr;
    IO_STATUS_BLOCK     iosb;
    KEVENT              event;
    NTSTATUS            status;

    Print(DeviceExtension, DBG_UART_TRACE, ("GetBaud enter\n"));
    
    KeInitializeEvent(&event,
                      NotificationEvent,
                      FALSE);

    status = SerialMouseIoSyncIoctlEx(
        IOCTL_SERIAL_GET_BAUD_RATE,
        DeviceExtension->TopOfStack, 
        &event,
        &iosb,
        NULL,
        0,
        &sbr,
        sizeof(SERIAL_BAUD_RATE));

    if (!NT_SUCCESS(iosb.Status)) {
        status = iosb.Status;
    }

    if (!NT_SUCCESS(status)) {
        Print(DeviceExtension, DBG_UART_ERROR,
              ("GetBaud failed (%x)\n", status));
    }
    else {
        *BaudRate = sbr.BaudRate;
    }

    Print(DeviceExtension, DBG_UART_TRACE,
          ("GetBaud exit (%x)\n", status));
    return status;
}

NTSTATUS
SerialMouseSetBaudRate(
    PDEVICE_EXTENSION   DeviceExtension,
    ULONG               BaudRate
    )
/*++

Routine Description:

    Set the serial port baud rate.

Arguments:

    Port - Pointer to the serial port.

    BaudRate - New serial port baud rate.

    BaudClock - The external frequency driving the serial chip.

Return Value:

    None.

--*/
{
    SERIAL_BAUD_RATE    sbr;
    IO_STATUS_BLOCK     iosb;
    KEVENT              event;
    NTSTATUS            status;

    KeInitializeEvent(&event,
                      NotificationEvent,
                      FALSE);

    sbr.BaudRate = BaudRate;
    status = SerialMouseIoSyncIoctlEx(
        IOCTL_SERIAL_SET_BAUD_RATE,
        DeviceExtension->TopOfStack, 
        &event,
        &iosb,
        &sbr,
        sizeof(SERIAL_BAUD_RATE),
        NULL,
        0);

    if (!NT_SUCCESS(iosb.Status)) {
        status = iosb.Status;
    }

    if (!NT_SUCCESS(status)) {
        Print(DeviceExtension, DBG_UART_ERROR,
              ("SetBaud failed! (%x)\n", status));
    }
    else {
        Print(DeviceExtension, DBG_UART_INFO, ("BaudRate: %d\n", BaudRate));
    }

    return status;
}

NTSTATUS
SerialMouseReadChar(
    PDEVICE_EXTENSION DeviceExtension, 
    PUCHAR            Value
    )
/*++

Routine Description:

    Read a character from the serial port.  Waits until a character has 
    been read or the timeout value is reached.

Arguments:

    Port - Pointer to the serial port.

    Value  - The character read from the serial port input buffer.

    Timeout - The timeout value in milliseconds for the read.

Return Value:

    TRUE if a character has been read, FALSE if a timeout occured.

--*/
{
    NTSTATUS            status;
    USHORT              actual;

    Print(DeviceExtension, DBG_UART_TRACE, ("ReadChar enter\n"));

    status =
        SerialMouseReadSerialPort(DeviceExtension, Value, 1, &actual);

    if (!NT_SUCCESS(status)) {
        Print(DeviceExtension, DBG_UART_ERROR,
              ("ReadChar failed! (%x)\n", status));
    }
    else if (actual != 1) {
        status  = STATUS_UNSUCCESSFUL;
    }
    else {
        Print(DeviceExtension, DBG_UART_NOISE,
              ("ReadChar read %x (actual = %d)\n", (ULONG) *Value, actual));
    }

    Print(DeviceExtension, DBG_UART_TRACE, ("ReadChar exit (%x)\n", status));

    return status;
}

NTSTATUS
SerialMouseFlushReadBuffer(
    PDEVICE_EXTENSION   DeviceExtension
    )
/*++

Routine Description:

    Flush the serial port input buffer.

Arguments:

    Port - Pointer to the serial port.

Return Value:

    TRUE.

--*/
{
    ULONG           bits = SERIAL_PURGE_RXCLEAR;
    NTSTATUS 		status;
	KEVENT			event;
    IO_STATUS_BLOCK iosb;

    Print(DeviceExtension, DBG_UART_TRACE, ("FlushReadBuffer enter\n"));

    KeInitializeEvent(&event,
                      NotificationEvent,
                      FALSE);

    status = SerialMouseIoSyncIoctlEx(
        IOCTL_SERIAL_PURGE, 
        DeviceExtension->TopOfStack, 
        &event,
        &iosb,
        &bits,
        sizeof(ULONG),
        NULL,
        0);

    if (!NT_SUCCESS(iosb.Status)) {
        status = iosb.Status;
    }

    if (!NT_SUCCESS(status)) {
       Print(DeviceExtension, DBG_UART_ERROR,
             ("FlushReadBuffer failed! (%x)\n", status));
    }

    Print(DeviceExtension, DBG_UART_TRACE,
          ("FlushReadBuffer exit (%x)\n", status));

    return status;
}

NTSTATUS
SerialMouseWriteChar(
    PDEVICE_EXTENSION   DeviceExtension,
    UCHAR               Value
    )
/*++

Routine Description:

     Write a character to a serial port. Make sure the transmit buffer 
     is empty before we write there.

Arguments:

    Port - Pointer to the serial port.

    Value - Value to write to the serial port.

Return Value:

    TRUE.

--*/
{
    IO_STATUS_BLOCK iosb;
    NTSTATUS        status;

    Print(DeviceExtension, DBG_UART_TRACE, ("WriteChar enter\n"));

    status = SerialMouseWriteSerialPort(
                DeviceExtension,
                &Value,
                1,
                &iosb);

    if (!NT_SUCCESS(iosb.Status)) {
        status = iosb.Status;
    }

    if (!NT_SUCCESS(status)) {
        Print(DeviceExtension, DBG_UART_ERROR,
              ("WriteChar failed! (%x)\n", status));
    }

    Print(DeviceExtension, DBG_UART_TRACE, ("WriteChar exit\n"));

    return status;
}

NTSTATUS
SerialMouseWriteString(
    PDEVICE_EXTENSION   DeviceExtension,
    PSZ                 Buffer
    )
/*++

Routine Description:

    Write a zero-terminated string to the serial port.

Arguments:

    Port - Pointer to the serial port.

    Buffer - Pointer to a zero terminated string to write to 
        the serial port.

Return Value:

    TRUE.

--*/
{
    IO_STATUS_BLOCK iosb;
    NTSTATUS        status;

    Print(DeviceExtension, DBG_UART_TRACE, ("WriteString enter\n"));

    status = SerialMouseWriteSerialPort(
                DeviceExtension,
                Buffer,
                strlen(Buffer),
                &iosb);
    if (!NT_SUCCESS(iosb.Status)) {
        status = iosb.Status;
    }

    if (!NT_SUCCESS(status)) {
        Print(DeviceExtension, DBG_UART_ERROR,
              ("WriteString failed! (%x)\n", status));
    }

    Print(DeviceExtension, DBG_UART_TRACE,
          ("WriteString exit (%x)\n", status));

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\neckbadd\neckbadd.h ===
/*++
Copyright (c) 1998  Microsoft Corporation

Module Name:

    nec98kbd.h

Abstract:

    This module contains the common private declarations for the NEC98 layout keyboard driver.

Author:

    Hideki Miura(NEC)

Environment:

    kernel mode only

Notes:


Revision History:


--*/

#ifndef NECKBADD_H
#define NECKBADD_H

#include "ntddk.h"
#include <ntddkbd.h>
#include "kbdmou.h"

#define NECKBADD_POOL_TAG (ULONG) 'dabK'
#undef ExAllocatePool
#define ExAllocatePool(type, size) \
            ExAllocatePoolWithTag (type, size, NECKBADD_POOL_TAG)

//#pragma warning(error:4100)   // Unreferenced formal parameter
//#pragma warning(error:4705)   // Statement has no effect

#define MIN(_A_,_B_) (((_A_) < (_B_)) ? (_A_) : (_B_))

#if DBG
BOOLEAN DebugFlags = 1;
#define Print(_X_) \
    if (DebugFlags) { \
        DbgPrint _X_; \
    }

#define CLASSSERVICE_CALLBACK(_X_, _Y_) \
    (*(PSERVICE_CALLBACK_ROUTINE) devExt->UpperConnectData.ClassService)( \
        devExt->UpperConnectData.ClassDeviceObject, \
        _X_, \
        _Y_, \
        InputDataConsumed);
//   Print(("NecKbdServiceCallback: flushing %8x - %8x\n", _X_, _Y_));

#else
#define Print(_X_)
#define CLASSSERVICE_CALLBACK(_X_, _Y_) \
    (*(PSERVICE_CALLBACK_ROUTINE) devExt->UpperConnectData.ClassService)( \
        devExt->UpperConnectData.ClassDeviceObject, \
        _X_, \
        _Y_, \
        InputDataConsumed);

#endif

typedef struct _DEVICE_EXTENSION
{
    //
    // A backpointer to the device object for which this is the extension
    //
    PDEVICE_OBJECT  Self;

    //
    // "THE PDO"  (ejected by the root bus or ACPI)
    //
    PDEVICE_OBJECT  PDO;

    //
    // The top of the stack before this filter was added.  AKA the location
    // to which all IRPS should be directed.
    //
    PDEVICE_OBJECT  TopOfStack;

    //
    // Number of creates sent down
    //
    LONG EnableCount;

    //
    // The real connect data that this driver reports to
    //
    CONNECT_DATA UpperConnectData;

    //
    // current power state of the device
    //
    DEVICE_POWER_STATE  DeviceState;

    BOOLEAN         Started;
    BOOLEAN         Removed;

    //
    //
    //
    ULONG KeyStatusFlags;

    //
    //
    //
    KEYBOARD_INPUT_DATA CachedInputData;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

//
// define the scancodes
//

#define CTRL_KEY                0x1d
#define HANKAKU_ZENKAKU_KEY     0x29
#define SHIFT_KEY               0x2a
#define CAPS_KEY                0x3a
#define COPY_KEY                0x37
#define PRINT_SCREEN_KEY        0x37
#define PAUSE_KEY               0x45
#define NUMLOCK_KEY             0x45  // +E0
#define STOP_KEY                0x46  // +E0
#define SCROLL_LOCK_KEY         0x46
#define VF3_KEY                 0x5D
#define VF4_KEY                 0x5E
#define VF5_KEY                 0x5F
#define KANA_KEY                0x70

//
//
//
#define CAPS_PRESSING    0x00000001
#define KANA_PRESSING    0x00000002
#define STOP_PREFIX      0x00000004
#define STOP_PRESSING    0x00000008
#define COPY_PREFIX      0x00000010
#define COPY_PRESSING    0x00000020

//
// Some strings by the driver
//
const PWSTR pwParameters     = L"\\Parameters";
const PWSTR pwVfKeyEmulation = L"VfKeyEmulation";

//
// Variables
//

//
// VfKey Emulation Flag
//   if FALSE(emulation off),  vf3 -> F13, vf4 -> F14, vf5 -> F15
//   if TRUE(emulation on),    vf3 -> NumLock, vf4 -> ScrollLock, vf5 -> Hankaku/Zenkaku
//
BOOLEAN VfKeyEmulation;

//
// Prototypes
//

NTSTATUS
DriverEntry (
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

NTSTATUS
NecKbdAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT BusDeviceObject
    );

NTSTATUS
NecKbdComplete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );

NTSTATUS
NecKbdCreateClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NecKbdDispatchPassThrough(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
   
NTSTATUS
NecKbdInternIoCtl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NecKbdPnP (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NecKbdPower (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
NecKbdServiceCallback(
    IN PDEVICE_OBJECT DeviceObject,
    IN PKEYBOARD_INPUT_DATA InputDataStart,
    IN PKEYBOARD_INPUT_DATA InputDataEnd,
    IN OUT PULONG InputDataConsumed
    );

VOID
NecKbdUnload (
    IN PDRIVER_OBJECT DriverObject
    );

VOID
NecKbdServiceParameters(
    IN PUNICODE_STRING   RegistryPath
    );

#endif  // NECKBADD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\neckbrep\neckbrep.c ===
/*--
Copyright (c) 1997  Microsoft Corporation

Module Name:

    neckbrep.c

Abstract:

Environment:

    Kernel mode only.

Notes:

Revision History:


--*/

#include "neckbrep.h"

NTSTATUS DriverEntry (PDRIVER_OBJECT, PUNICODE_STRING);

#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, DriverEntry)
#pragma alloc_text (PAGE, KbRepeatCreateClose)
#pragma alloc_text (PAGE, KbRepeatInternIoCtl)
#pragma alloc_text (PAGE, KbRepeatUnload)
#endif

NTSTATUS
DriverEntry (
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    )
/*++
Routine Description:

    Initialize the entry points of the driver.

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    ULONG       i;

    UNREFERENCED_PARAMETER (RegistryPath);

	// 
    // Fill in all the dispatch entry points with the pass through function
    // and the explicitly fill in the functions we are going to intercept
	// 
    for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++) {
       DriverObject->MajorFunction[i] = KbRepeatDispatchPassThrough;
    }

    DriverObject->MajorFunction [IRP_MJ_CREATE] =
    DriverObject->MajorFunction [IRP_MJ_CLOSE] =        KbRepeatCreateClose;
    DriverObject->MajorFunction [IRP_MJ_PNP] =          KbRepeatPnP;
    DriverObject->MajorFunction [IRP_MJ_POWER] =        KbRepeatPower;
    DriverObject->MajorFunction [IRP_MJ_INTERNAL_DEVICE_CONTROL] =
                                                        KbRepeatInternIoCtl;

    DriverObject->DriverUnload = KbRepeatUnload;
    DriverObject->DriverExtension->AddDevice = KbRepeatAddDevice;

	return STATUS_SUCCESS;
}

NTSTATUS
KbRepeatAddDevice(
    IN PDRIVER_OBJECT   Driver,
    IN PDEVICE_OBJECT   PDO
    )
{
    PDEVICE_EXTENSION        devExt;
    IO_ERROR_LOG_PACKET      errorLogEntry;
    PDEVICE_OBJECT           device;
    NTSTATUS                 status = STATUS_SUCCESS;

    PAGED_CODE();

    status = IoCreateDevice(Driver,                   // driver
                            sizeof(DEVICE_EXTENSION), // size of extension
                            NULL,                     // device name
                            FILE_DEVICE_8042_PORT,    // device type 
                            0,                        // device characteristics
                            FALSE,                    // exclusive
                            &device                   // new device
                            );

    if (!NT_SUCCESS(status)) {
        return (status);
    }

    RtlZeroMemory(device->DeviceExtension, sizeof(DEVICE_EXTENSION));

    devExt = (PDEVICE_EXTENSION) device->DeviceExtension;
    devExt->TopOfStack = IoAttachDeviceToDeviceStack(device, PDO);

    if (devExt->TopOfStack == NULL) {
        IoDeleteDevice(device);
        return STATUS_DEVICE_NOT_CONNECTED; 
    }

    ASSERT(devExt->TopOfStack);

    devExt->Self =          device;
    devExt->PDO =           PDO;
    devExt->DeviceState =   PowerDeviceD0;

    devExt->Removed = FALSE;
    devExt->Started = FALSE;

    device->Flags |= DO_BUFFERED_IO;
    device->Flags |= DO_POWER_PAGABLE;
    device->Flags &= ~DO_DEVICE_INITIALIZING;

    //
    // Initialize Timer DPC.
    //

    KeInitializeTimer (&(devExt->KbRepeatTimer));
    KeInitializeDpc (&(devExt->KbRepeatDPC),
                     KbRepeatDpc,
                     device);

    //
    // Initialize device extension.
    //

    RtlZeroMemory(&(devExt->KbRepeatInput), sizeof(KEYBOARD_INPUT_DATA));
    devExt->KbRepeatDelay.LowPart = -(KEYBOARD_TYPEMATIC_DELAY_DEFAULT * 10000);
    devExt->KbRepeatDelay.HighPart = -1;
    devExt->KbRepeatRate = 1000 / KEYBOARD_TYPEMATIC_RATE_DEFAULT;

    return status;
}

NTSTATUS
KbRepeatComplete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
{
    PKEVENT             event;
    PIO_STACK_LOCATION  irpStack;
    NTSTATUS            status = STATUS_SUCCESS;

    event = (PKEVENT) Context;

    UNREFERENCED_PARAMETER(DeviceObject);

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    //
    // We could switch on the major and minor functions of the IRP to perform
    // different functions, but we know that Context is an event that needs
    // to be set.
    //
    KeSetEvent(event, 0, FALSE);

    //
    // Allows the caller to use the IRP after it is completed
    //
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
KbRepeatCreateClose (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++
Routine Description:

    Maintain a simple count of the creates and closes sent against this device
    
--*/
{
    PIO_STACK_LOCATION  irpStack;
    NTSTATUS            status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   devExt;
    PKEYBOARD_INPUT_DATA CurrentRepeat;


    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    devExt = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    switch (irpStack->MajorFunction) {
    case IRP_MJ_CREATE:
    
        if (NULL == devExt->UpperConnectData.ClassService) {
            //
            // No Connection yet.  How can we be enabled?
            //
            status = STATUS_INVALID_DEVICE_STATE;
        }
        break;

    case IRP_MJ_CLOSE:

        CurrentRepeat = &(devExt->KbRepeatInput);
        if (CurrentRepeat->MakeCode != 0) {
            Print(("NecKbRep-KbRepeatCreateClose : Stopping repeat\n"));
            KeCancelTimer(&(devExt->KbRepeatTimer));
            RtlZeroMemory(CurrentRepeat, sizeof(KEYBOARD_INPUT_DATA));
        }
        break;
    }

    Irp->IoStatus.Status = status;

    //
    // Pass on the create and the close
    //
	return KbRepeatDispatchPassThrough(DeviceObject, Irp);
}

NTSTATUS
KbRepeatDispatchPassThrough(
	IN PDEVICE_OBJECT DeviceObject,
	IN PIRP Irp
	)
/*++
Routine Description:

	Passes a request on to the lower driver.

--*/
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

	//
	// Pass the IRP to the target
	//
    IoSkipCurrentIrpStackLocation(Irp);
	
	return IoCallDriver(
        ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->TopOfStack,
		Irp);
}           

NTSTATUS
KbRepeatInternIoCtl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for internal device control requests.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION  irpStack;
    PDEVICE_EXTENSION   devExt;
    KEVENT              event;
    PCONNECT_DATA       connectData;
    PKEYBOARD_TYPEMATIC_PARAMETERS TypematicParameters;
    NTSTATUS            status = STATUS_SUCCESS;

    //
    // Get a pointer to the device extension.
    //

    devExt = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // Initialize the returned Information field.
    //

    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Case on the device control subfunction that is being performed by the
    // requestor.
    //
    switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {

    //
    // Connect a keyboard class device driver to the port driver.
    //

    case IOCTL_INTERNAL_KEYBOARD_CONNECT:
        //
        // Only allow a connection if the keyboard hardware is present.
        // Also, only allow one connection.
        //
        if (devExt->UpperConnectData.ClassService != NULL) {
            status = STATUS_SHARING_VIOLATION;
            break;
        }
        else if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CONNECT_DATA)) {
            //
            // invalid buffer
            //
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // Copy the connection parameters to the device extension.
        //
        connectData = ((PCONNECT_DATA)
            (irpStack->Parameters.DeviceIoControl.Type3InputBuffer));

        devExt->UpperConnectData = *connectData;

        connectData->ClassDeviceObject = devExt->Self;
        connectData->ClassService = KbRepeatServiceCallback;

        break;

    //
    // Disconnect a keyboard class device driver from the port driver.
    //
    case IOCTL_INTERNAL_KEYBOARD_DISCONNECT:

        //
        // Clear the connection parameters in the device extension.
        //
        // devExt->UpperConnectData.ClassDeviceObject = NULL;
        // devExt->UpperConnectData.ClassService = NULL;

        status = STATUS_NOT_IMPLEMENTED;
        break;

    case IOCTL_KEYBOARD_SET_TYPEMATIC:

        TypematicParameters = (PKEYBOARD_TYPEMATIC_PARAMETERS)(Irp->AssociatedIrp.SystemBuffer);

        if (TypematicParameters->Rate != 0) {
            devExt->KbRepeatDelay.LowPart = -TypematicParameters->Delay * 10000;
            devExt->KbRepeatDelay.HighPart = -1;
            devExt->KbRepeatRate = 1000 / TypematicParameters->Rate;
            Print((
                "NecKbRep-KbRepeatInternIoCtl : New Delay = %d, New Rate = %d\n",
                TypematicParameters->Delay,
                TypematicParameters->Rate
                ));
        } else {
            Print((
                "NecKbRep-KbRepeatInternIoCtl : Invalid Parameters. New Delay = %d, New Rate = %d\n",
                TypematicParameters->Delay,
                TypematicParameters->Rate
                ));
        }

        break;

    //
    // Might want to capture these in the future
    //
    case IOCTL_KEYBOARD_QUERY_ATTRIBUTES:
    case IOCTL_KEYBOARD_QUERY_INDICATOR_TRANSLATION:
    case IOCTL_KEYBOARD_QUERY_INDICATORS:
    case IOCTL_KEYBOARD_SET_INDICATORS:
    case IOCTL_KEYBOARD_QUERY_TYPEMATIC:
        break;
    }

    if (!NT_SUCCESS(status)) {
        return status;
    }

    return KbRepeatDispatchPassThrough(DeviceObject, Irp);
}

NTSTATUS
KbRepeatPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is the dispatch routine for plug and play irps 

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    PDEVICE_EXTENSION           devExt; 
    PIO_STACK_LOCATION          irpStack;
    NTSTATUS                    status = STATUS_SUCCESS;
    KIRQL                       oldIrql;
    KEVENT                      event;        

    PAGED_CODE();

    devExt = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    switch (irpStack->MinorFunction) {
    case IRP_MN_START_DEVICE: {

        //
        // The device is starting.
        //
        // We cannot touch the device (send it any non pnp irps) until a
        // start device has been passed down to the lower drivers.
        //
        IoCopyCurrentIrpStackLocationToNext(Irp);
        KeInitializeEvent(&event,
                          NotificationEvent,
                          FALSE
                          );

        IoSetCompletionRoutine(Irp,
                               (PIO_COMPLETION_ROUTINE) KbRepeatComplete, 
                               &event,
                               TRUE,
                               TRUE,
                               TRUE); // No need for Cancel

        status = IoCallDriver(devExt->TopOfStack, Irp);

        if (STATUS_PENDING == status) {
            KeWaitForSingleObject(
               &event,
               Executive, // Waiting for reason of a driver
               KernelMode, // Waiting in kernel mode
               FALSE, // No allert
               NULL); // No timeout
        }

        if (NT_SUCCESS(status) && NT_SUCCESS(Irp->IoStatus.Status)) {
            //
            // As we are successfully now back from our start device
            // we can do work.
            //
            devExt->Started = TRUE;
            devExt->Removed = FALSE;
        }

        //
        // We must now complete the IRP, since we stopped it in the
        // completetion routine with MORE_PROCESSING_REQUIRED.
        //
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        break;
    }

    case IRP_MN_REMOVE_DEVICE:
        
        IoSkipCurrentIrpStackLocation(Irp);
        IoCallDriver(devExt->TopOfStack, Irp);

        devExt->Removed = TRUE;

        IoDetachDevice(devExt->TopOfStack); 
        IoDeleteDevice(DeviceObject);

        status = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_CANCEL_REMOVE_DEVICE:
    case IRP_MN_CANCEL_STOP_DEVICE:
    case IRP_MN_FILTER_RESOURCE_REQUIREMENTS: 
    case IRP_MN_STOP_DEVICE:
    case IRP_MN_QUERY_DEVICE_RELATIONS:
    case IRP_MN_QUERY_INTERFACE:
    case IRP_MN_QUERY_CAPABILITIES:
    case IRP_MN_QUERY_DEVICE_TEXT:
    case IRP_MN_QUERY_RESOURCES:
    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
    case IRP_MN_READ_CONFIG:
    case IRP_MN_WRITE_CONFIG:
    case IRP_MN_EJECT:
    case IRP_MN_SET_LOCK:
    case IRP_MN_QUERY_ID:
    case IRP_MN_QUERY_PNP_DEVICE_STATE:
    default:
        //
        // Here the filter driver might modify the behavior of these IRPS
        // Please see PlugPlay documentation for use of these IRPs.
        //
        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(devExt->TopOfStack, Irp);
        break;
    }

    return status;
}

NTSTATUS
KbRepeatPower(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    )
/*++

Routine Description:

    This routine is the dispatch routine for power irps   Does nothing except
    record the state of the device.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    PIO_STACK_LOCATION  irpStack;
    NTSTATUS            status;
    PDEVICE_EXTENSION   devExt;
    POWER_STATE         powerState;
    POWER_STATE_TYPE    powerType;

    devExt = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    powerType = irpStack->Parameters.Power.Type;
    powerState = irpStack->Parameters.Power.State;

    switch (irpStack->MinorFunction) {
    case IRP_MN_SET_POWER:
        Print(("NecKbRep-KbRepeatPower : Power Setting %s state to %d\n",
                              ((powerType == SystemPowerState) ? "System"
                                                               : "Device"),
                               powerState.SystemState - 1));
        if (powerType  == DevicePowerState) {
            devExt->DeviceState = powerState.DeviceState;
            switch (powerState.DeviceState) {
            case PowerDeviceD0:
                //
                // if powering up, clear last repeat
                //
                RtlZeroMemory(&(devExt->KbRepeatInput), sizeof(KEYBOARD_INPUT_DATA));
                break;
            case PowerDeviceD1:
            case PowerDeviceD2:
            case PowerDeviceD3:
                //
                // if powering down, stop current repeat
                //
                Print(("NecKbRep-KbRepeatPower : Stopping repeat\n"));
                KeCancelTimer(&(devExt->KbRepeatTimer));
                RtlZeroMemory(&(devExt->KbRepeatInput), sizeof(KEYBOARD_INPUT_DATA));
                break;
            default:
                Print(("NecKbRep-KbRepeatPower : DeviceState (%d) no known\n",
                               powerState.DeviceState - 1));
                break;
            }
        }

        break;

    case IRP_MN_QUERY_POWER:
        Print(("NecKbRep-KbRepeatPower : Power query %s status to %d\n",
                              ((powerType == SystemPowerState) ? "System"
                                                               : "Device"),
                                powerState.SystemState - 1));
        break;

    default:
        Print(("NecKbRep-KbRepeatPower : Power minor (0x%x) no known\n",
                               irpStack->MinorFunction));
        break;
    }

    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);
    PoCallDriver(devExt->TopOfStack, Irp);

    return STATUS_SUCCESS;
}

VOID
KbRepeatServiceCallback(
    IN PDEVICE_OBJECT DeviceObject,
    IN PKEYBOARD_INPUT_DATA InputDataStart,
    IN PKEYBOARD_INPUT_DATA InputDataEnd,
    IN OUT PULONG InputDataConsumed
    )
{
    PDEVICE_EXTENSION   devExt;
    PKEYBOARD_INPUT_DATA CurrentRepeat, NewInput;
    KEYBOARD_INPUT_DATA TempRepeat;

    devExt = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    CurrentRepeat = &(devExt->KbRepeatInput);

    RtlMoveMemory(
        (PCHAR)&TempRepeat,
        (PCHAR)CurrentRepeat,
        sizeof(KEYBOARD_INPUT_DATA)
        );

    for (NewInput = InputDataStart; NewInput < InputDataEnd; NewInput++) {

        if ((TempRepeat.MakeCode == NewInput->MakeCode) &&
            ((TempRepeat.Flags & (KEY_E0 | KEY_E1)) == (NewInput->Flags & (KEY_E0 | KEY_E1)))) {

            if (!(NewInput->Flags & KEY_BREAK)) {
                // Do nothing(Inserted by this driver)
                ;
            } else {
                // Stop current repeat
                RtlZeroMemory(&TempRepeat, sizeof(KEYBOARD_INPUT_DATA));
            }

        } else {
            if (!(NewInput->Flags & KEY_BREAK)) {
                // Start new repeat
                RtlMoveMemory(
                    (PCHAR)&TempRepeat,
                    (PCHAR)NewInput,
                    sizeof(KEYBOARD_INPUT_DATA)
                    );
            } else {
                // Do nothing(Break code is inserted, but it's not repeated)
                ;
            }
        }
    }

    (*(PSERVICE_CALLBACK_ROUTINE) devExt->UpperConnectData.ClassService)(
        devExt->UpperConnectData.ClassDeviceObject,
        InputDataStart,
        InputDataEnd,
        InputDataConsumed);

    if ((TempRepeat.MakeCode != CurrentRepeat->MakeCode)||
        ((TempRepeat.Flags & (KEY_E0 | KEY_E1)) != (CurrentRepeat->Flags & (KEY_E0 | KEY_E1)))) {
        if (CurrentRepeat->MakeCode != 0) {
            // Stop Current Repeat.
            KeCancelTimer(&(devExt->KbRepeatTimer));
        }

        RtlMoveMemory(
            (PCHAR)CurrentRepeat,
            (PCHAR)&TempRepeat,
            sizeof(KEYBOARD_INPUT_DATA)
            );

        if ((TempRepeat.MakeCode != 0)&&(TempRepeat.MakeCode != 0xff)) {
            // Start new repeat.
            KeSetTimerEx(&(devExt->KbRepeatTimer),
                         devExt->KbRepeatDelay,
                         devExt->KbRepeatRate,
                         &(devExt->KbRepeatDPC));
        }
    }
}

VOID
KbRepeatUnload(
   IN PDRIVER_OBJECT Driver
   )
/*++

Routine Description:

   Free all the allocated resources associated with this driver.

Arguments:

   DriverObject - Pointer to the driver object.

Return Value:

   None.

--*/

{
    PAGED_CODE();
    ASSERT(NULL == Driver->DeviceObject);
    return;
}

VOID
KbRepeatDpc(
    IN PKDPC DPC,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

{
    PDEVICE_EXTENSION   devExt;
    PKEYBOARD_INPUT_DATA InputDataStart;
    PKEYBOARD_INPUT_DATA InputDataEnd;
    LONG InputDataConsumed;

    devExt = ((PDEVICE_OBJECT)DeferredContext)->DeviceExtension;

    InputDataStart = &(devExt->KbRepeatInput);
    InputDataEnd = InputDataStart + 1;
    (*(PSERVICE_CALLBACK_ROUTINE) devExt->UpperConnectData.ClassService)(
        devExt->UpperConnectData.ClassDeviceObject,
        InputDataStart,
        InputDataEnd,
        &InputDataConsumed);

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\neckbrep\sources.inc ===
MAJORCOMP=ntos
MINORCOMP=dd

TARGETNAME=neckbrep
TARGETPATH=obj
TARGETTYPE=DRIVER

INCLUDES=..\..\inc;..\i386

SOURCES=..\neckbrep.c      \
        ..\neckbrep.rc

C_DEFINES=-DPNP_IDENTIFY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\neckbadd\neckbadd.c ===
/*--
Copyright (c) 1997  Microsoft Corporation

Module Name:

    neckbadd.c

Abstract:

Environment:

    Kernel mode only.

Notes:

Revision History:


--*/

#include "neckbadd.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, DriverEntry)
#pragma alloc_text (PAGE, NecKbdCreateClose)
#pragma alloc_text (PAGE, NecKbdInternIoCtl)
#pragma alloc_text (PAGE, NecKbdUnload)
#endif

NTSTATUS
DriverEntry (
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    )
/*++
Routine Description:

    Initialize the entry points of the driver.

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    ULONG       i;

    UNREFERENCED_PARAMETER (RegistryPath);

    //
    // Fill in all the dispatch entry points with the pass through function
    // and the explicitly fill in the functions we are going to intercept
    //
    for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++) {
       DriverObject->MajorFunction[i] = NecKbdDispatchPassThrough;
    }

    DriverObject->MajorFunction [IRP_MJ_CREATE] =
    DriverObject->MajorFunction [IRP_MJ_CLOSE] =        NecKbdCreateClose;
    DriverObject->MajorFunction [IRP_MJ_PNP] =          NecKbdPnP;
    DriverObject->MajorFunction [IRP_MJ_POWER] =        NecKbdPower;
    DriverObject->MajorFunction [IRP_MJ_INTERNAL_DEVICE_CONTROL] = NecKbdInternIoCtl;

    DriverObject->DriverUnload = NecKbdUnload;
    DriverObject->DriverExtension->AddDevice = NecKbdAddDevice;

    NecKbdServiceParameters(RegistryPath);

    return STATUS_SUCCESS;
}

NTSTATUS
NecKbdAddDevice(
    IN PDRIVER_OBJECT   Driver,
    IN PDEVICE_OBJECT   PDO
    )
{
    PDEVICE_EXTENSION        devExt;
    IO_ERROR_LOG_PACKET      errorLogEntry;
    PDEVICE_OBJECT           device;
    NTSTATUS                 status = STATUS_SUCCESS;

    PAGED_CODE();

    status = IoCreateDevice(Driver,                   // driver
                            sizeof(DEVICE_EXTENSION), // size of extension
                            NULL,                     // device name
                            FILE_DEVICE_8042_PORT,    // device type
                            0,                        // device characteristics
                            FALSE,                    // exclusive
                            &device                   // new device
                            );

    if (!NT_SUCCESS(status)) {
        return (status);
    }

    RtlZeroMemory(device->DeviceExtension, sizeof(DEVICE_EXTENSION));

    devExt = (PDEVICE_EXTENSION) device->DeviceExtension;
    devExt->TopOfStack = IoAttachDeviceToDeviceStack(device, PDO);

    if (devExt->TopOfStack == NULL) {
        IoDeleteDevice(device);
        return STATUS_DEVICE_NOT_CONNECTED; 
    }

    ASSERT(devExt->TopOfStack);

    devExt->Self =          device;
    devExt->PDO =           PDO;
    devExt->DeviceState =   PowerDeviceD0;

    devExt->Removed = FALSE;
    devExt->Started = FALSE;

    device->Flags |= DO_BUFFERED_IO;
    device->Flags |= DO_POWER_PAGABLE;
    device->Flags &= ~DO_DEVICE_INITIALIZING;

    return status;
}

NTSTATUS
NecKbdComplete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
{
    PKEVENT             event;
    PIO_STACK_LOCATION  irpStack;
    NTSTATUS            status = STATUS_SUCCESS;

    event = (PKEVENT) Context;

    UNREFERENCED_PARAMETER(DeviceObject);

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    //
    // We could switch on the major and minor functions of the IRP to perform
    // different functions, but we know that Context is an event that needs
    // to be set.
    //
    KeSetEvent(event, 0, FALSE);

    //
    // Allows the caller to use the IRP after it is completed
    //
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
NecKbdCreateClose (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++
Routine Description:

    Maintain a simple count of the creates and closes sent against this device

--*/
{
    PIO_STACK_LOCATION  irpStack;
    NTSTATUS            status = STATUS_SUCCESS;
    PDEVICE_EXTENSION   devExt;


    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    devExt = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    switch (irpStack->MajorFunction) {
    case IRP_MJ_CREATE:

        if (NULL == devExt->UpperConnectData.ClassService) {
            //
            // No Connection yet.  How can we be enabled?
            //
            status = STATUS_INVALID_DEVICE_STATE;
        }

        break;

    case IRP_MJ_CLOSE:

        break;
    }

    Irp->IoStatus.Status = status;

    //
    // Pass on the create and the close
    //
    return NecKbdDispatchPassThrough(DeviceObject, Irp);
}

NTSTATUS
NecKbdDispatchPassThrough(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
Routine Description:

    Passes a request on to the lower driver.

--*/
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Pass the IRP to the target
    //
    IoSkipCurrentIrpStackLocation(Irp);

    return IoCallDriver(
        ((PDEVICE_EXTENSION) DeviceObject->DeviceExtension)->TopOfStack,
        Irp);
}

NTSTATUS
NecKbdInternIoCtl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for internal device control requests.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION  irpStack;
    PDEVICE_EXTENSION   devExt;
    KEVENT              event;
    PCONNECT_DATA       connectData;
    PKEYBOARD_TYPEMATIC_PARAMETERS TypematicParameters;
    NTSTATUS            status = STATUS_SUCCESS;

    //
    // Get a pointer to the device extension.
    //

    devExt = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // Initialize the returned Information field.
    //

    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Case on the device control subfunction that is being performed by the
    // requestor.
    //
    switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {

    //
    // Connect a keyboard class device driver to the port driver.
    //

    case IOCTL_INTERNAL_KEYBOARD_CONNECT:
        //
        // Only allow a connection if the keyboard hardware is present.
        // Also, only allow one connection.
        //
        if (devExt->UpperConnectData.ClassService != NULL) {
            status = STATUS_SHARING_VIOLATION;
            break;
        }
        else if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CONNECT_DATA)) {
            //
            // invalid buffer
            //
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // Copy the connection parameters to the device extension.
        //
        connectData = ((PCONNECT_DATA)
            (irpStack->Parameters.DeviceIoControl.Type3InputBuffer));

        devExt->UpperConnectData = *connectData;

        connectData->ClassDeviceObject = devExt->Self;
        connectData->ClassService = NecKbdServiceCallback;

        break;

    //
    // Disconnect a keyboard class device driver from the port driver.
    //
    case IOCTL_INTERNAL_KEYBOARD_DISCONNECT:

        //
        // Clear the connection parameters in the device extension.
        //
        // devExt->UpperConnectData.ClassDeviceObject = NULL;
        // devExt->UpperConnectData.ClassService = NULL;

        status = STATUS_NOT_IMPLEMENTED;
        break;

    case IOCTL_KEYBOARD_SET_TYPEMATIC:
    //
    // Might want to capture these in the future
    //
    case IOCTL_KEYBOARD_QUERY_ATTRIBUTES:
    case IOCTL_KEYBOARD_QUERY_INDICATOR_TRANSLATION:
    case IOCTL_KEYBOARD_QUERY_INDICATORS:
    case IOCTL_KEYBOARD_SET_INDICATORS:
    case IOCTL_KEYBOARD_QUERY_TYPEMATIC:
    default:
        break;
    }

    if (!NT_SUCCESS(status)) {
        return status;
    }

    return NecKbdDispatchPassThrough(DeviceObject, Irp);
}

NTSTATUS
NecKbdPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is the dispatch routine for plug and play irps

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    PDEVICE_EXTENSION           devExt;
    PIO_STACK_LOCATION          irpStack;
    NTSTATUS                    status = STATUS_SUCCESS;
    KIRQL                       oldIrql;
    KEVENT                      event;

    PAGED_CODE();

    devExt = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    switch (irpStack->MinorFunction) {
    case IRP_MN_START_DEVICE: {

        //
        // The device is starting.
        //
        // We cannot touch the device (send it any non pnp irps) until a
        // start device has been passed down to the lower drivers.
        //
        IoCopyCurrentIrpStackLocationToNext(Irp);
        KeInitializeEvent(&event,
                          NotificationEvent,
                          FALSE
                          );

        IoSetCompletionRoutine(Irp,
                               (PIO_COMPLETION_ROUTINE) NecKbdComplete,
                               &event,
                               TRUE,
                               TRUE,
                               TRUE); // No need for Cancel

        status = IoCallDriver(devExt->TopOfStack, Irp);

        if (STATUS_PENDING == status) {
            KeWaitForSingleObject(
               &event,
               Executive, // Waiting for reason of a driver
               KernelMode, // Waiting in kernel mode
               FALSE, // No allert
               NULL); // No timeout
        }

        if (NT_SUCCESS(status) && NT_SUCCESS(Irp->IoStatus.Status)) {
            //
            // As we are successfully now back from our start device
            // we can do work.
            //
            devExt->Started = TRUE;
            devExt->Removed = FALSE;
        }

        //
        // We must now complete the IRP, since we stopped it in the
        // completetion routine with MORE_PROCESSING_REQUIRED.
        //
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        break;
    }

    case IRP_MN_REMOVE_DEVICE:

        IoSkipCurrentIrpStackLocation(Irp);
        IoCallDriver(devExt->TopOfStack, Irp);

        devExt->Removed = TRUE;

        IoDetachDevice(devExt->TopOfStack);
        IoDeleteDevice(DeviceObject);

        status = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_CANCEL_REMOVE_DEVICE:
    case IRP_MN_CANCEL_STOP_DEVICE:
    case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
    case IRP_MN_STOP_DEVICE:
    case IRP_MN_QUERY_DEVICE_RELATIONS:
    case IRP_MN_QUERY_INTERFACE:
    case IRP_MN_QUERY_CAPABILITIES:
    case IRP_MN_QUERY_DEVICE_TEXT:
    case IRP_MN_QUERY_RESOURCES:
    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
    case IRP_MN_READ_CONFIG:
    case IRP_MN_WRITE_CONFIG:
    case IRP_MN_EJECT:
    case IRP_MN_SET_LOCK:
    case IRP_MN_QUERY_ID:
    case IRP_MN_QUERY_PNP_DEVICE_STATE:
    default:
        //
        // Here the filter driver might modify the behavior of these IRPS
        // Please see PlugPlay documentation for use of these IRPs.
        //
        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(devExt->TopOfStack, Irp);
        break;
    }

    return status;
}

NTSTATUS
NecKbdPower(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    )
/*++

Routine Description:

    This routine is the dispatch routine for power irps   Does nothing except
    record the state of the device.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    PIO_STACK_LOCATION  irpStack;
    NTSTATUS            status;
    PDEVICE_EXTENSION   devExt;
    POWER_STATE         powerState;
    POWER_STATE_TYPE    powerType;

    devExt = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    powerType = irpStack->Parameters.Power.Type;
    powerState = irpStack->Parameters.Power.State;

    switch (irpStack->MinorFunction) {
    case IRP_MN_SET_POWER:
        Print(("NecKbdPower:Power Setting %s state to %d\n",
                            ((powerType == SystemPowerState) ? "System"
                                                             : "Device"),
                             powerState.SystemState));
        if (powerType  == DevicePowerState) {
            devExt->DeviceState = powerState.DeviceState;
        }

        break;

    case IRP_MN_QUERY_POWER:
        Print(("NecKbdPower:Power query %s status to %d\n",
                            ((powerType == SystemPowerState) ? "System"
                                                             : "Device"),
                              powerState.SystemState));
        break;

    default:
        Print(("NecKbdPower:Power minor (0x%x) no known\n",
                             irpStack->MinorFunction));
        break;
    }

    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);
    PoCallDriver(devExt->TopOfStack, Irp);

    return STATUS_SUCCESS;
}

VOID
NecKbdServiceCallback(
    IN PDEVICE_OBJECT DeviceObject,
    IN PKEYBOARD_INPUT_DATA InputDataStart,
    IN PKEYBOARD_INPUT_DATA InputDataEnd,
    IN OUT PULONG InputDataConsumed
    )
{

    PDEVICE_EXTENSION    devExt;
    PKEYBOARD_INPUT_DATA CurrentInputData,
                         CurrentInputDataStart;
    KEYBOARD_INPUT_DATA  TempInputData[2];

    devExt = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    RtlZeroMemory(TempInputData, sizeof(KEYBOARD_INPUT_DATA) * 2);

    CurrentInputData = CurrentInputDataStart = InputDataStart;

     while (CurrentInputData < InputDataEnd) {

//        Print(("NecKbdServiceCallBack: captured scancode: 0x%2x(%2x)\n",
//                  CurrentInputData->MakeCode,
//                  CurrentInputData->Flags
//                  ));

        if (devExt->KeyStatusFlags & STOP_PREFIX) {

            if (((CurrentInputData->MakeCode != NUMLOCK_KEY) ||
                 ((CurrentInputData->Flags & (KEY_E0|KEY_E1)) != 0) ||
                 ((CurrentInputData->Flags & KEY_BREAK) != (devExt->CachedInputData.Flags & KEY_BREAK)))) {

                Print(("NecKbdServiceCallBack: clearing prefix of STOP(%s)\n",
                          (CurrentInputData->Flags & KEY_BREAK) ? "Break" : "Make"
                          ));

                //
                // send cached input data
                //
                CLASSSERVICE_CALLBACK(
                    &(devExt->CachedInputData),
                    &(devExt->CachedInputData) + 1);

                devExt->KeyStatusFlags &= ~STOP_PREFIX;
            }
        }

        switch (CurrentInputData->MakeCode) {

        case CAPS_KEY:
        case KANA_KEY:

            if (CurrentInputData->Flags & (KEY_E0|KEY_E1)) {
                break;
            }

            if (!(CurrentInputData->Flags & KEY_BREAK)) {

                Print(("NecKbdServiceCallBack: Captured %s (Make)\n",
                          ((CurrentInputData->MakeCode == CAPS_KEY) ? "CAPS" : "KANA")
                          ));

                if (((CurrentInputData->MakeCode == CAPS_KEY)&&(devExt->KeyStatusFlags & CAPS_PRESSING))||
                    ((CurrentInputData->MakeCode == KANA_KEY)&&(devExt->KeyStatusFlags & KANA_PRESSING))) {

                    //
                    // ignore repeated make code
                    //
                    Print(("NecKbdServiceCallBack: ignoring repeated %s(Break)\n",
                              ((CurrentInputData->MakeCode == CAPS_KEY) ? "CAPS" : "KANA")
                              ));

                } else {

                    if (CurrentInputDataStart <= CurrentInputData) {

                        CLASSSERVICE_CALLBACK(
                            CurrentInputDataStart,
                            CurrentInputData + 1);
                    }

                    //
                    // Send break code
                    //
                    RtlCopyMemory(
                        (PCHAR)&(TempInputData[0]),
                        (PCHAR)CurrentInputData,
                        sizeof(KEYBOARD_INPUT_DATA)
                        );
                    TempInputData[0].Flags |= KEY_BREAK;

                    Print(("NecKbdServiceCallBack: Sending %s(Break)\n",
                              ((CurrentInputData->MakeCode == CAPS_KEY) ? "CAPS" : "KANA")
                              ));

                    CLASSSERVICE_CALLBACK(
                        &(TempInputData[0]),
                        &(TempInputData[1]));
                }

                if (CurrentInputData->MakeCode == CAPS_KEY) {
                    devExt->KeyStatusFlags |= CAPS_PRESSING;
                } else {
                    devExt->KeyStatusFlags |= KANA_PRESSING;
                }

            } else {

                //
                // Break generates no scancode.
                //
                Print(("NecKbdServiceCallBack: ignoring %s(Break)\n",
                          ((CurrentInputData->MakeCode == CAPS_KEY) ? "CAPS" : "KANA")
                          ));

                if (CurrentInputDataStart < CurrentInputData) {

                    CLASSSERVICE_CALLBACK(
                        CurrentInputDataStart,
                        CurrentInputData);
                }

                if (CurrentInputData->MakeCode == CAPS_KEY) {
                    devExt->KeyStatusFlags &= ~CAPS_PRESSING;
                } else {
                    devExt->KeyStatusFlags &= ~KANA_PRESSING;
                }

            }
            CurrentInputDataStart = CurrentInputData + 1;

            break;

        case CTRL_KEY:

            if ((CurrentInputData->Flags & (KEY_E0|KEY_E1)) == KEY_E1) {

                Print(("NecKbdServiceCallBack: prefix of STOP(%s)\n",
                          (CurrentInputData->Flags & KEY_BREAK) ? "Break" : "Make"
                          ));

                if (CurrentInputDataStart < CurrentInputData) {
                    CLASSSERVICE_CALLBACK(
                        CurrentInputDataStart,
                        CurrentInputData);
                }

                RtlCopyMemory(
                    (PCHAR)&(devExt->CachedInputData),
                    (PCHAR)CurrentInputData,
                    sizeof(KEYBOARD_INPUT_DATA)
                    );

                devExt->KeyStatusFlags |= STOP_PREFIX;
                CurrentInputDataStart = CurrentInputData + 1;
            }

            break;

        case NUMLOCK_KEY:

            if ((CurrentInputData->Flags & (KEY_E0|KEY_E1)) == 0) {

                if (devExt->KeyStatusFlags & STOP_PREFIX) {

                    if ((CurrentInputData->Flags & KEY_BREAK) == (devExt->CachedInputData.Flags & KEY_BREAK)) {

                        //
                        // it is STOP key
                        //
                        Print(("NecKbdServiceCallBack: Captured STOP(%s)\n",
                                  ((CurrentInputData->Flags & KEY_BREAK) ? "Break" : "Make")
                                  ));

                        devExt->KeyStatusFlags &= ~STOP_PREFIX;

                        //
                        // make packets for 0x1d
                        //
                        RtlCopyMemory(
                            (PCHAR)&(TempInputData[0]),
                            (PCHAR)CurrentInputData,
                            sizeof(KEYBOARD_INPUT_DATA)
                            );
                        TempInputData[0].MakeCode = CTRL_KEY;
                        TempInputData[0].Flags &= ~(KEY_E0|KEY_E1);

                        //
                        // make packet for 0x46+E0
                        //
                        RtlCopyMemory(
                            (PCHAR)&(TempInputData[1]),
                            (PCHAR)CurrentInputData,
                            sizeof(KEYBOARD_INPUT_DATA)
                            );
                        TempInputData[1].MakeCode = STOP_KEY;
                        TempInputData[1].Flags |= KEY_E0;
                        TempInputData[1].Flags &= ~KEY_E1;

                        //
                        // send packets 0x1d, 0x46+E0
                        //
                        CLASSSERVICE_CALLBACK(
                            &(TempInputData[0]),
                            &(TempInputData[2]));

                        CurrentInputDataStart = CurrentInputData + 1;

                    } else {

                        //
                        // invalid prefix. send it as is.
                        //
                        Print(("NecKbdServiceCallBack: invalid prefix for STOP(%s)\n",
                                  ((CurrentInputData->Flags & KEY_BREAK) ? "Break" : "Make")
                                  ));

                    }

                } else {

                    //
                    // it is vf3 key. it behaves as F13 or NumLock
                    //
                    Print(("NecKbdServiceCallBack: Captured vf3(VfKeyEmulation is %s)\n",
                              ((VfKeyEmulation) ? "On" : "Off")
                              ));

                    if (!(VfKeyEmulation)) {
                        CurrentInputData->MakeCode = VF3_KEY;
                        CurrentInputData->Flags &= ~(KEY_E0|KEY_E1);
                    }

                }
            }

            break;

        //
        // ScrollLock can emulate VF4
        //
        case SCROLL_LOCK_KEY:

            if ((CurrentInputData->Flags & (KEY_E0|KEY_E1)) == 0) {

                Print(("NecKbdServiceCallBack: Captured vf4(VfKeyEmulation is %s)\n",
                          ((VfKeyEmulation) ? "On" : "Off")
                          ));

                if (!(VfKeyEmulation)) {
                    CurrentInputData->MakeCode = VF4_KEY;
                    CurrentInputData->Flags &= ~(KEY_E0|KEY_E1);
                }
            }

            break;

        //
        // hankaku/zenkaku can emulate VF5
        //
        case HANKAKU_ZENKAKU_KEY:

            if ((CurrentInputData->Flags & (KEY_E0|KEY_E1)) == 0) {

                Print(("NecKbdServiceCallBack: Captured vf5(VfKeyEmulation is %s)\n",
                          ((VfKeyEmulation) ? "On" : "Off")
                          ));

                if (!(VfKeyEmulation)) {
                    CurrentInputData->MakeCode = VF5_KEY;
                    CurrentInputData->Flags &= ~(KEY_E0|KEY_E1);
                }
            }

            break;

        //
        // the others(sent as is)
        //

        default:
            break;
        }

        CurrentInputData++;

    }

    //
    // flush InputData
    //
    if (CurrentInputDataStart < InputDataEnd) {
        if (devExt->KeyStatusFlags & STOP_PREFIX) {
            CLASSSERVICE_CALLBACK(
                CurrentInputDataStart,
                InputDataEnd - 1);
        } else {
            CLASSSERVICE_CALLBACK(
                CurrentInputDataStart,
                InputDataEnd);
        }
    }

}

VOID
NecKbdUnload(
   IN PDRIVER_OBJECT Driver
   )
/*++

Routine Description:

   Free all the allocated resources associated with this driver.

Arguments:

   DriverObject - Pointer to the driver object.

Return Value:

   None.

--*/

{
    PAGED_CODE();
    ASSERT(NULL == Driver->DeviceObject);
    return;
}

VOID
NecKbdServiceParameters(
    IN PUNICODE_STRING   RegistryPath
    )

/*++

Routine Description:

    This routine retrieves this driver's service parameters information
    from the registry.

Arguments:

    RegistryPath - Pointer to the null-terminated Unicode name of the
        registry path for this driver.

Return Value:

    None.

--*/

{
    NTSTATUS                  Status = STATUS_SUCCESS;
    PRTL_QUERY_REGISTRY_TABLE Parameters = NULL;
    PWSTR                     Path = NULL;
    UNICODE_STRING            ParametersPath;
    ULONG                     QueriedVfKeyEmulation = 0;
    ULONG                     DefaultVfKeyEmulation = 0;
    USHORT                    queries = 1;

    PAGED_CODE();

    ParametersPath.Buffer = NULL;

    //
    // Registry path is already null-terminated, so just use it.
    //
    Path = RegistryPath->Buffer;

    if (NT_SUCCESS(Status)) {

        //
        // Allocate the Rtl query table.
        //
        Parameters = ExAllocatePool(
            PagedPool,
            sizeof(RTL_QUERY_REGISTRY_TABLE) * (queries + 1)
            );

        if (!Parameters) {

            Print(("NecKbdServiceParameters: couldn't allocate table for Rtl query to %ws for %ws\n",
                      pwParameters,
                      Path
                      ));
            Status = STATUS_UNSUCCESSFUL;

        } else {

            RtlZeroMemory(
                Parameters,
                sizeof(RTL_QUERY_REGISTRY_TABLE) * (queries + 1)
                );

            //
            // Form a path to this driver's Parameters subkey.
            //
            RtlInitUnicodeString( &ParametersPath, NULL );
            ParametersPath.MaximumLength = RegistryPath->Length +
                (wcslen(pwParameters) * sizeof(WCHAR) ) + sizeof(UNICODE_NULL);

            ParametersPath.Buffer = ExAllocatePool(
                PagedPool,
                ParametersPath.MaximumLength
                );

            if (!ParametersPath.Buffer) {

                Print(("NecKbdServiceParameters: Couldn't allocate string for path to %ws for %ws\n",
                          pwParameters,
                          Path
                          ));
                Status = STATUS_UNSUCCESSFUL;

            }
        }
    }

    if (NT_SUCCESS(Status)) {

        //
        // Form the parameters path.
        //

        RtlZeroMemory(
            ParametersPath.Buffer,
            ParametersPath.MaximumLength
            );
        RtlAppendUnicodeToString(
            &ParametersPath,
            Path
            );
        RtlAppendUnicodeToString(
            &ParametersPath,
            pwParameters
            );

        //
        // Gather all of the "user specified" information from
        // the registry.
        //
        Parameters[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
        Parameters[0].Name = pwVfKeyEmulation;
        Parameters[0].EntryContext = &QueriedVfKeyEmulation;
        Parameters[0].DefaultType = REG_DWORD;
        Parameters[0].DefaultData = &DefaultVfKeyEmulation;
        Parameters[0].DefaultLength = sizeof(ULONG);

        Status = RtlQueryRegistryValues(
            RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
            ParametersPath.Buffer,
            Parameters,
            NULL,
            NULL
            );

        if (!NT_SUCCESS(Status)) {
            Print(("NecKbdServiceParameters: RtlQueryRegistryValues failed (0x%x)\n", Status));
        }
    }

    if (!NT_SUCCESS(Status)) {

        //
        // assign driver defaults.
        //
        VfKeyEmulation = (DefaultVfKeyEmulation == 0) ? FALSE : TRUE;

    } else {

        VfKeyEmulation = (QueriedVfKeyEmulation == 0) ? FALSE : TRUE;

    }

    Print(("NecKbdServiceParameters: VfKeyEmulation is %s\n",
              VfKeyEmulation ? "Enable" : "Disable"));

    //
    // Free the allocated memory before returning.
    //
    if (ParametersPath.Buffer)
        ExFreePool(ParametersPath.Buffer);
    if (Parameters)
        ExFreePool(Parameters);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\pnpi8042\hook.c ===
/*++

Copyright (c) 1997-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    hook.c

Abstract:

    Implements hook functions used by upper filters to directly control a PS/2
    device.

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/

#include "i8042prt.h"

//
// Mouse hook functions
//
VOID
I8xMouseIsrWritePort(
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            Value
    )
/*++

Routine Description:

    This routine runs at HIGH IRQL to write values to the mouse device

Arguments:

    DeviceObject - The i8042prt FDO representing the mouse
    
    Value        - Value to write to the mouse
    
Return Value:

    None.

--*/
{
    #if DBG
    ASSERT(! ((PCOMMON_DATA) DeviceObject->DeviceExtension)->IsKeyboard);
    #else
    UNREFERENCED_PARAMETER(DeviceObject);
    #endif

    I8X_WRITE_CMD_TO_MOUSE();
    I8X_MOUSE_COMMAND( Value );
}

//
// Keyboard hook functions
//
NTSTATUS 
I8xKeyboardSynchReadPort (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PUCHAR           Value,
    IN BOOLEAN          Dummy
    )
/*++

Routine Description:

    This routine runs at PASSIVE IRQL to synchronousely read a value from the
    keyboard device during the initialization of the device

Arguments:

    DeviceObject - The i8042prt FDO representing the keyboard
    
    Value        - Pointer in which to place the results of the read 
    
Return Value:

    status of the operation, STATUS_SUCCESS if successful

--*/
{
    #if DBG
    ASSERT(((PCOMMON_DATA) DeviceObject->DeviceExtension)->IsKeyboard);
    #else
    UNREFERENCED_PARAMETER(DeviceObject);
    #endif
    UNREFERENCED_PARAMETER(Dummy);

    return I8xGetBytePolled((CCHAR) KeyboardDeviceType,
                            Value 
                            );
}

NTSTATUS 
I8xKeyboardSynchWritePort (
    IN PDEVICE_OBJECT   DeviceObject,                           
    IN UCHAR            Value,
    IN BOOLEAN          WaitForACK
    )
/*++

Routine Description:

    This routine runs at PASSIVE IRQL to synchronousely write values to the
    keyboard device during the initialization of the device

Arguments:

    DeviceObject - The i8042prt FDO representing the keyboard
    
    Value        - Value to write to the keyboard
    
    WaitForACK   - Whether we should wait the device to ACK the Value written
    
Return Value:

    status of the operation, STATUS_SUCCESS if successful

--*/
{
    #if DBG
    ASSERT(((PCOMMON_DATA) DeviceObject->DeviceExtension)->IsKeyboard);
    #else
    UNREFERENCED_PARAMETER(DeviceObject);
    #endif

    return I8xPutBytePolled(
               DataPort,
               WaitForACK,
               (CCHAR) KeyboardDeviceType,
               Value
               );
}

VOID
I8xKeyboardIsrWritePort(
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            Value
    )
/*++

Routine Description:

    This routine runs at HIGH IRQL to write values to the keyboard device

Arguments:

    DeviceObject - The i8042prt FDO representing the keyboard
    
    Value        - Value to write to the keyboard
    
Return Value:

    None.

--*/
{
    #if DBG
    ASSERT(((PCOMMON_DATA) DeviceObject->DeviceExtension)->IsKeyboard);
    #else
    UNREFERENCED_PARAMETER(DeviceObject);
    #endif

    I8xPutByteAsynchronous((CCHAR) DataPort,
                           Value
                           );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\pnpi8042\i8042cfg.h ===
/*++

Copyright (c) 1989, 1990, 1991, 1992, 1993  Microsoft Corporation

Module Name:

    i8042cfg.h

Abstract:

    These are the machine-dependent configuration constants that are used in
    the Intel 8042 port driver.

Revision History:

--*/

#ifndef _I8042CFG_
#define _I8042CFG_

//
// Define the interrupt-related configuration constants.
//

#define I8042_INTERFACE_TYPE      Isa
#define I8042_INTERRUPT_MODE      Latched
#define I8042_INTERRUPT_SHARE     FALSE
#define I8042_FLOATING_SAVE       FALSE

//
// Define the default allowable retry and polling iterations.
//

#define I8042_RESEND_DEFAULT      3
#define I8042_POLLING_DEFAULT 12000
#define I8042_POLLING_MAXIMUM 12000

//
// Define the keyboard-specific configuration parameters.
//

#define KEYBOARD_VECTOR  1
#define KEYBOARD_IRQL    KEYBOARD_VECTOR

//
// Define the mouse-specific configuration parameters.
//

#define MOUSE_VECTOR  12
#define MOUSE_IRQL    MOUSE_VECTOR

//
// Define the base port offsets for the i8042 controller command/status and
// data registers.
//
#define I8042_PHYSICAL_BASE           0x60
#define I8042_DATA_REGISTER_OFFSET    0
#define I8042_COMMAND_REGISTER_OFFSET 4
#define I8042_STATUS_REGISTER_OFFSET  4
#define I8042_REGISTER_LENGTH         1
#define I8042_REGISTER_SHARE          FALSE
#define I8042_PORT_TYPE               CM_RESOURCE_PORT_IO

#endif // _I8042CFG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\neckbrep\neckbrep.h ===
/*++
Copyright (c) 1997  Microsoft Corporation

Module Name:

    neckbrep.h

Abstract:

    This module contains the common private declarations for the auto-key-repeat
    driver.

Author:

    Hideki Miura

Environment:

    kernel mode only

Notes:


Revision History:


--*/

#ifndef NECKBREP_H
#define NECKBREP_H

#include "ntddk.h"
#include <ntddkbd.h>
#include "kbdmou.h"

#define KBSTUFF_POOL_TAG (ULONG) 'prKN'
#undef ExAllocatePool
#define ExAllocatePool(type, size) \
            ExAllocatePoolWithTag (type, size, KBSTUFF_POOL_TAG)

//#pragma warning(error:4100)   // Unreferenced formal parameter
//#pragma warning(error:4705)   // Statement has no effect

#if DBG

#define TRAP()                      DbgBreakPoint()
#define DbgRaiseIrql(_x_,_y_)       KeRaiseIrql(_x_,_y_)
#define DbgLowerIrql(_x_)           KeLowerIrql(_x_)
#define Print(_x_)                  DbgPrint _x_;

#else   // DBG

#define TRAP()
#define DbgRaiseIrql(_x_,_y_)
#define DbgLowerIrql(_x_)
#define Print(_x_)

#endif

#define MIN(_A_,_B_) (((_A_) < (_B_)) ? (_A_) : (_B_))

typedef struct _DEVICE_EXTENSION
{
    //
    // A backpointer to the device object for which this is the extension
    //
    PDEVICE_OBJECT  Self;

    //
    // "THE PDO"  (ejected by the root bus or ACPI)
    //
    PDEVICE_OBJECT  PDO;

    //
    // The top of the stack before this filter was added.  AKA the location
    // to which all IRPS should be directed.
    //
    PDEVICE_OBJECT  TopOfStack;

    //
    // Number of creates sent down
    //
    LONG EnableCount;

    //
    // The real connect data that this driver reports to
    //
    CONNECT_DATA UpperConnectData;

    //
    // current power state of the device
    //
    DEVICE_POWER_STATE  DeviceState;

    BOOLEAN         Started;
    BOOLEAN         Removed;

    //
    // A input data to do the autorepeat.
    //

    KEYBOARD_INPUT_DATA KbRepeatInput;

    //
    // A timer DPC to do the autorepeat.
    //

    KDPC          KbRepeatDPC;
    KTIMER        KbRepeatTimer;
    LARGE_INTEGER KbRepeatDelay;
    LONG          KbRepeatRate;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

//
// Default Typematic Parameters.
//

#define KEYBOARD_TYPEMATIC_RATE_DEFAULT    30
#define KEYBOARD_TYPEMATIC_DELAY_DEFAULT  250

//
// Prototypes
//

NTSTATUS
DriverEntry (
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

NTSTATUS
KbRepeatAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT BusDeviceObject
    );

NTSTATUS
KbRepeatComplete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );

NTSTATUS
KbRepeatCreateClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
KbRepeatDispatchPassThrough(
	IN PDEVICE_OBJECT DeviceObject,
	IN PIRP Irp
	);
   
NTSTATUS
KbRepeatInternIoCtl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
KbRepeatPnP (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
KbRepeatPower (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
KbRepeatServiceCallback(
    IN PDEVICE_OBJECT DeviceObject,
    IN PKEYBOARD_INPUT_DATA InputDataStart,
    IN PKEYBOARD_INPUT_DATA InputDataEnd,
    IN OUT PULONG InputDataConsumed
    );

VOID
KbRepeatUnload (
    IN PDRIVER_OBJECT DriverObject
    );

VOID
KbRepeatDpc(
    IN PKDPC DPC,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
KbdInitializeTypematic(
    IN PDEVICE_EXTENSION devExt
    );

#endif  // NECKBREP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\pnpi8042\i8042cmn.c ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    i8042cmn.c

Abstract:

    The common portions of the Intel i8042 port driver which
    apply to both the keyboard and the auxiliary (PS/2 mouse) device.

Environment:

    Kernel mode only.

Notes:

    NOTES:  (Future/outstanding issues)

    - Powerfail not implemented.

    - IOCTL_INTERNAL_KEYBOARD_DISCONNECT and IOCTL_INTERNAL_MOUSE_DISCONNECT
      have not been implemented.  They're not needed until the class
      unload routine is implemented.  Right now, we don't want to allow
      either the keyboard or the mouse class driver to unload.

    - Consolidate duplicate code, where possible and appropriate.

Revision History:

--*/

#include "stdarg.h"
#include "stdio.h"
#include "string.h"
#include "i8042prt.h"
#include "i8042log.h"

// sys button IOCTL definitions
#include "poclass.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, I8xClose)
#pragma alloc_text(PAGE, I8xCreate)
#pragma alloc_text(PAGE, I8xDeviceControl)
#pragma alloc_text(PAGE, I8xSanityCheckResources)
#endif // ALLOC_PRAGMA

NTSTATUS
I8xCreate (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP           Irp
   )
/*++

Routine Description:

    This is the dispatch routine for create/open requests.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    NT status code.

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PCOMMON_DATA        commonData = NULL;

    Print(DBG_CC_TRACE, ("Create enter\n"));

    PAGED_CODE();

    commonData = GET_COMMON_DATA(DeviceObject->DeviceExtension);

    if (NULL == commonData->ConnectData.ClassService) {
        //
        // No Connection yet.  How can we be enabled?
        //
        Print(DBG_IOCTL_ERROR | DBG_CC_ERROR,
              ("ERROR: enable before connect!\n"));
        status = STATUS_INVALID_DEVICE_STATE;
    }
    else if (MANUALLY_REMOVED(commonData)) {
        status = STATUS_NO_SUCH_DEVICE;
    }
    else 
#if defined(_M_IX86) && (_MSC_FULL_VER < 13009175)  // workaround for 13.00.9111 compiler (fixed in 9175 or better)
    {
        ULONG i = InterlockedIncrement(&commonData->EnableCount);
        if (1 >= i) {
            Print(DBG_CC_INFO,
                 ("Enabling %s (%d)\n",
                 commonData->IsKeyboard ? "Keyboard" : "Mouse",
                 commonData->EnableCount
                 ));
        }
    }
#else
    if (1 >= InterlockedIncrement(&commonData->EnableCount)) {
        Print(DBG_CC_INFO,
             ("Enabling %s (%d)\n",
             commonData->IsKeyboard ? "Keyboard" : "Mouse",
             commonData->EnableCount
             ));
    }
#endif

    //
    // No need to call the lower driver (the root bus) because it only handles
    // Power and PnP Irps
    //
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    Print(DBG_CC_TRACE, ("Create (%x)\n", status));

    return status;
}

NTSTATUS
I8xClose (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP           Irp
   )
/*++

Routine Description:

    This is the dispatch routine for close requests.  This request
    completes successfully.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    NT status code.

--*/
{
    PCOMMON_DATA        commonData;
    ULONG               count;

    PAGED_CODE();

    Print(DBG_CC_TRACE, ("Close\n"));

    commonData = GET_COMMON_DATA(DeviceObject->DeviceExtension);

    ASSERT(0 < commonData->EnableCount);

    count = InterlockedDecrement(&commonData->EnableCount);
    if (0 >= count) {
        Print(DBG_IOCTL_INFO,
              ("Disabling %s (%d)\n",
              commonData->IsKeyboard ? "Keyboard" : "Mouse",
              commonData->EnableCount
              ));
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}

VOID
I8042CompletionDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ISR_DPC_CAUSE IsrDpcCause
    )
/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL to complete requests.
    It is queued by the ISR routine.

Arguments:

    Dpc - Pointer to the DPC object.

    DeviceObject - Pointer to the device object.

    Irp - Irp about to be completed

    Context - Indicates type of error to log.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION       irpSp;
    PPORT_KEYBOARD_EXTENSION kbExtension = DeviceObject->DeviceExtension;
    PPORT_MOUSE_EXTENSION    mouseExtension = DeviceObject->DeviceExtension;
    PCOMMON_DATA             commonData = GET_COMMON_DATA(DeviceObject->DeviceExtension);

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(IsrDpcCause);

    Print(DBG_DPC_TRACE, ("I8042CompletionDpc: enter\n"));

    // Stop the command timer.
    KeCancelTimer(&Globals.ControllerData->CommandTimer);

    ASSERT(Irp == DeviceObject->CurrentIrp);
    ASSERT(Irp != NULL);

    if (Irp == NULL) {
#if DBG
        if (Globals.ControllerData->CurrentIoControlCode != 0x0) {
            Print(DBG_DPC_ERROR,
                  ("Current IOCTL code is 0x%x\n",
                   Globals.ControllerData->CurrentIoControlCode
                   ));
        }
#endif

        goto CompletionDpcFinished;
    }

    irpSp = IoGetCurrentIrpStackLocation(Irp);

#if DBG
    ASSERT(irpSp->Parameters.DeviceIoControl.IoControlCode ==
           Globals.ControllerData->CurrentIoControlCode);

    Globals.ControllerData->CurrentIoControlCode = 0x0;
#endif

    //
    // We know we're completing an internal device control request.  Switch
    // on IoControlCode.
    //
    switch(irpSp->Parameters.DeviceIoControl.IoControlCode) {

    //
    // Complete the keyboard set indicators request.
    //
    case IOCTL_KEYBOARD_SET_INDICATORS:

        Print(DBG_IOCTL_NOISE | DBG_DPC_NOISE,
              ("I8042CompletionDpc: keyboard set indicators updated\n"
              ));

        //
        // Update the current indicators flag in the device extension.
        //
        kbExtension->KeyboardIndicators =
            *(PKEYBOARD_INDICATOR_PARAMETERS) Irp->AssociatedIrp.SystemBuffer;

        Print(DBG_IOCTL_INFO | DBG_DPC_INFO,
              ("I8042CompletionDpc: new LED flags 0x%x\n",
              kbExtension->KeyboardIndicators.LedFlags
              ));

        break;

    //
    // Complete the keyboard set typematic request.
    //
    case IOCTL_KEYBOARD_SET_TYPEMATIC:

        Print(DBG_IOCTL_NOISE | DBG_DPC_NOISE,
              ("I8042CompletionDpc: keyboard set typematic updated\n"
              ));

        //
        // Update the current typematic rate/delay in the device extension.
        //
        kbExtension->KeyRepeatCurrent =
            *(PKEYBOARD_TYPEMATIC_PARAMETERS) Irp->AssociatedIrp.SystemBuffer;

        Print(DBG_IOCTL_INFO | DBG_DPC_INFO,
              ("I8042CompletionDpc: new rate/delay 0x%x/%x\n",
              kbExtension->KeyRepeatCurrent.Rate,
              kbExtension->KeyRepeatCurrent.Delay
              ));

        break;

    case IOCTL_INTERNAL_MOUSE_RESET:

        Print(DBG_IOCTL_NOISE | DBG_DPC_NOISE,
              ("I8042CompletionDpc: mouse reset complete\n"
              ));

        I8xFinishResetRequest(mouseExtension, 
                              FALSE,  // success
                              FALSE,  // at DISPATCH already
                              TRUE);  // cancel the timer
        return;

    default:

        Print(DBG_DPC_INFO,  ("I8042CompletionDpc: miscellaneous\n"));
        break;
    }

    //
    // Set the completion status, start the next packet, and complete the
    // request.
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest (Irp, IO_KEYBOARD_INCREMENT);

    KeAcquireSpinLockAtDpcLevel(&Globals.ControllerData->BytesSpinLock);
    if (commonData->CurrentOutput.Bytes &&
        commonData->CurrentOutput.Bytes != Globals.ControllerData->DefaultBuffer) {
        ExFreePool(commonData->CurrentOutput.Bytes);
    }
#if DBG
    else {
        RtlZeroMemory(Globals.ControllerData->DefaultBuffer,
                      sizeof(Globals.ControllerData->DefaultBuffer));
    }
#endif
    commonData->CurrentOutput.Bytes = NULL;
    KeReleaseSpinLockFromDpcLevel(&Globals.ControllerData->BytesSpinLock);

CompletionDpcFinished:
    IoFreeController(Globals.ControllerData->ControllerObject);
    IoStartNextPacket(DeviceObject, FALSE);

    if (Irp != NULL) {
        IoReleaseRemoveLock(&commonData->RemoveLock, Irp);
    }

    Print(DBG_DPC_TRACE, ("I8042CompletionDpc: exit\n"));
}

VOID
I8042ErrorLogDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL to log errors that are
    discovered at IRQL > DISPATCH_LEVEL (e.g., in the ISR routine or
    in a routine that is executed via KeSynchronizeExecution).  There
    is not necessarily a current request associated with this condition.

Arguments:

    Dpc - Pointer to the DPC object.

    DeviceObject - Pointer to the device object.

    Irp - Not used.

    Context - Indicates type of error to log.

Return Value:

    None.

--*/
{
    PIO_ERROR_LOG_PACKET errorLogEntry;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(Irp);

    Print(DBG_DPC_TRACE, ("I8042ErrorLogDpc: enter\n"));

    //
    // Log an error packet.
    //
    errorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
                                              DeviceObject,
                                              sizeof(IO_ERROR_LOG_PACKET)
                                              + (2 * sizeof(ULONG))
                                              );
    if (errorLogEntry != NULL) {

        errorLogEntry->DumpDataSize = 2 * sizeof(ULONG);
        if ((ULONG_PTR) Context == I8042_KBD_BUFFER_OVERFLOW) {
            errorLogEntry->UniqueErrorValue = I8042_ERROR_VALUE_BASE + 310;
            errorLogEntry->DumpData[0] = sizeof(KEYBOARD_INPUT_DATA);
            errorLogEntry->DumpData[1] = ((PPORT_KEYBOARD_EXTENSION)
               DeviceObject->DeviceExtension)->KeyboardAttributes.InputDataQueueLength;
        }
        else if ((ULONG_PTR) Context == I8042_MOU_BUFFER_OVERFLOW) {
            errorLogEntry->UniqueErrorValue = I8042_ERROR_VALUE_BASE + 320;
            errorLogEntry->DumpData[0] = sizeof(MOUSE_INPUT_DATA);
            errorLogEntry->DumpData[1] = ((PPORT_MOUSE_EXTENSION)
               DeviceObject->DeviceExtension)->MouseAttributes.InputDataQueueLength;
        }
        else {
            errorLogEntry->UniqueErrorValue = I8042_ERROR_VALUE_BASE + 330;
            errorLogEntry->DumpData[0] = 0;
            errorLogEntry->DumpData[1] = 0;
        }

        errorLogEntry->ErrorCode = (NTSTATUS)((ULONG_PTR)Context);
        errorLogEntry->SequenceNumber = 0;
        errorLogEntry->MajorFunctionCode = 0;
        errorLogEntry->IoControlCode = 0;
        errorLogEntry->RetryCount = 0;
        errorLogEntry->FinalStatus = 0;

        IoWriteErrorLogEntry(errorLogEntry);
    }

    Print(DBG_DPC_TRACE, ("I8042ErrorLogDpc: exit\n"));
}

NTSTATUS
I8xFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Unimplemented flush routine

Arguments:

    DeviceObject - An FDO

    Irp          - The flush request

Return Value:

    STATUS_NOT_IMPLEMENTED;

--*/
{
    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(Irp);

    Print(DBG_CALL_TRACE, ("I8042Flush: enter\n"));
    Print(DBG_CALL_TRACE, ("I8042Flush: exit\n"));

    return(STATUS_NOT_IMPLEMENTED);
}

NTSTATUS
I8xDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PPORT_KEYBOARD_EXTENSION    kbExtension;
    PIO_STACK_LOCATION          stack;
    NTSTATUS                    status = STATUS_INVALID_DEVICE_REQUEST;

    PAGED_CODE();

    //
    // Get a pointer to the device extension.
    //
    kbExtension = (PPORT_KEYBOARD_EXTENSION) DeviceObject->DeviceExtension;

    if (!kbExtension->IsKeyboard || !kbExtension->Started ||
        MANUALLY_REMOVED(kbExtension)) {
        status = STATUS_INVALID_DEVICE_REQUEST;
    }
    else {
        stack = IoGetCurrentIrpStackLocation(Irp);
        switch (stack->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_GET_SYS_BUTTON_CAPS:
            return I8xKeyboardGetSysButtonCaps(kbExtension, Irp);

        case IOCTL_GET_SYS_BUTTON_EVENT:
            return I8xKeyboardGetSysButtonEvent(kbExtension, Irp);

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
I8xSendIoctl(
    PDEVICE_OBJECT      Target,
    ULONG               Ioctl,
    PVOID               InputBuffer,
    ULONG               InputBufferLength
    )
/*++

Routine Description:

    Sends an internal IOCTL to the top of the stack.

Arguments:

    Target - The top of the stack

    Ioctl  - The IOCTL to send

    InputBuffer - The buffer to be filled if the IOCTL is handled on the way down

    InputBufferLength - size, in bytes, of InputBuffer

Return Value:

    STATUS_NOT_IMPLEMENTED;

--*/
{
    KEVENT          event;
    NTSTATUS        status = STATUS_SUCCESS;
    IO_STATUS_BLOCK iosb;
    PIRP            irp;

    KeInitializeEvent(&event,
                      NotificationEvent,
                      FALSE
                      );

    //
    // Allocate an IRP - No need to release
    // When the next-lower driver completes this IRP, the I/O Manager releases it.
    //
    if (NULL == (irp = IoBuildDeviceIoControlRequest(Ioctl,
                                                     Target,
                                                     InputBuffer,
                                                     InputBufferLength,
                                                     0,
                                                     0,
                                                     TRUE,
                                                     &event,
                                                     &iosb))) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(Target, irp);
    Print(DBG_IOCTL_INFO,
          ("result of sending 0x%x was 0x%x\n",
          Ioctl,
          status
          ));

    if (STATUS_PENDING == status) {
        //
        // wait for it...
        //
        status = KeWaitForSingleObject(&event,
                                       Executive,
                                       KernelMode,
                                       FALSE, // Not alertable
                                       NULL); // No timeout structure

        ASSERT(STATUS_SUCCESS == status);
        status = iosb.Status;
    }

    return status;
}

NTSTATUS
I8xInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is the dispatch routine for internal device control requests.
    This routine cannot be paged because the class drivers send down internal
    IOCTLs at DISPATCH_LEVEL.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    PIO_STACK_LOCATION                  irpSp;
    PPORT_MOUSE_EXTENSION               mouseExtension = DeviceObject->DeviceExtension;
    PPORT_KEYBOARD_EXTENSION            kbExtension = DeviceObject->DeviceExtension;

    NTSTATUS                            status;
    PVOID                               parameters;
    PKEYBOARD_ATTRIBUTES                keyboardAttributes;
    ULONG                               sizeOfTranslation;

    PDEVICE_OBJECT                      topOfStack;
    PINTERNAL_I8042_HOOK_KEYBOARD       hookKeyboard;
    PINTERNAL_I8042_HOOK_MOUSE          hookMouse;
    KEYBOARD_ID                         keyboardId;

    Print(DBG_IOCTL_TRACE, ("IOCTL: enter\n"));

    Irp->IoStatus.Information = 0;
    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Case on the device control subfunction that is being performed by the
    // requestor.
    //
    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {

    //
    // Connect a keyboard class device driver to the port driver.
    //

    case IOCTL_INTERNAL_KEYBOARD_CONNECT:
        //
        // This really isn't something to worry about overall, but it is worthy
        // enough to be noted and recorded.  The multiple starts will be handled in
        // I8xPnp and I8xKeyboardStartDevice routines
        //
        if (KEYBOARD_PRESENT()) {
            Print(DBG_ALWAYS, ("Received 1+ kb connects!\n"));
            SET_HW_FLAGS(DUP_KEYBOARD_HARDWARE_PRESENT);
        }

        InterlockedIncrement(&Globals.AddedKeyboards);

        kbExtension->IsKeyboard = TRUE;

        SET_HW_FLAGS(KEYBOARD_HARDWARE_PRESENT);

        Print(DBG_IOCTL_INFO, ("IOCTL: keyboard connect\n"));

        //
        // Only allow a connection if the keyboard hardware is present.
        // Also, only allow one connection.
        //
        if (kbExtension->ConnectData.ClassService != NULL) {

            Print(DBG_IOCTL_ERROR, ("IOCTL: error - already connected\n"));
            status = STATUS_SHARING_VIOLATION;
            break;
        }
        else if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CONNECT_DATA)) {

            Print(DBG_IOCTL_ERROR, ("IOCTL: error - invalid buffer length\n"));
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // Copy the connection parameters to the device extension.
        //

        kbExtension->ConnectData =
            *((PCONNECT_DATA) (irpSp->Parameters.DeviceIoControl.Type3InputBuffer));

        hookKeyboard = ExAllocatePool(PagedPool,
                                      sizeof(INTERNAL_I8042_HOOK_KEYBOARD)
                                      );
        if (hookKeyboard) {
            topOfStack = IoGetAttachedDeviceReference(kbExtension->Self);

            RtlZeroMemory(hookKeyboard,
                          sizeof(INTERNAL_I8042_HOOK_KEYBOARD)
                          );

            hookKeyboard->CallContext = (PVOID) DeviceObject;

            hookKeyboard->QueueKeyboardPacket = (PI8042_QUEUE_PACKET)
                I8xQueueCurrentKeyboardInput;

            hookKeyboard->IsrWritePort = (PI8042_ISR_WRITE_PORT)
                I8xKeyboardIsrWritePort;

            I8xSendIoctl(topOfStack,
                         IOCTL_INTERNAL_I8042_HOOK_KEYBOARD,
                         (PVOID) hookKeyboard,
                         sizeof(INTERNAL_I8042_HOOK_KEYBOARD)
                         );

            ObDereferenceObject(topOfStack);
            ExFreePool(hookKeyboard);
        }

        status = STATUS_SUCCESS;
        break;

    //
    // Disconnect a keyboard class device driver from the port driver.
    //
    // NOTE: Not implemented.
    //
    case IOCTL_INTERNAL_KEYBOARD_DISCONNECT:

        Print(DBG_IOCTL_INFO, ("IOCTL: keyboard disconnect\n"));

        //
        // Perform a keyboard interrupt disable call.
        //

        //
        // Clear the connection parameters in the device extension.
        // NOTE:  Must synchronize this with the keyboard ISR.
        //
        //
        //deviceExtension->KeyboardExtension.ConnectData.ClassDeviceObject =
        //    Null;
        //deviceExtension->KeyboardExtension.ConnectData.ClassService =
        //    Null;

        status = STATUS_NOT_IMPLEMENTED;
        break;

    case IOCTL_INTERNAL_I8042_HOOK_KEYBOARD:

        Print(DBG_IOCTL_INFO, ("hook keyboard received!\n"));

        if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(INTERNAL_I8042_HOOK_KEYBOARD)) {

            Print(DBG_IOCTL_ERROR,
                 ("InternalIoctl error - invalid buffer length\n"
                 ));
            status = STATUS_INVALID_PARAMETER;
        }
        else {
            //
            // Copy the values if they are filled in
            //
            hookKeyboard = (PINTERNAL_I8042_HOOK_KEYBOARD)
                irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

            kbExtension->HookContext = hookKeyboard->Context;
            if (hookKeyboard->InitializationRoutine) {
                Print(DBG_IOCTL_NOISE,
                      ("KB Init Routine 0x%x\n",
                       hookKeyboard->IsrRoutine
                       ));
                kbExtension->InitializationHookCallback =
                    hookKeyboard->InitializationRoutine;
            }

            if (hookKeyboard->IsrRoutine) {
                Print(DBG_IOCTL_NOISE,
                      ("KB Hook Routine 0x%x\n",
                       hookKeyboard->IsrRoutine
                       ));
                kbExtension->IsrHookCallback = hookKeyboard->IsrRoutine;
            }

            status = STATUS_SUCCESS;
        }
        break;

    //
    // Connect a mouse class device driver to the port driver.
    //
    case IOCTL_INTERNAL_MOUSE_CONNECT:

        //
        // This really isn't something to worry about overall, but it is worthy
        // enough to be noted and recorded.  The multiple starts will be handled in
        // I8xPnp and I8xMouseStartDevice routines
        //
        if (MOUSE_PRESENT()) {
            Print(DBG_ALWAYS, ("Received 1+ mouse connects!\n"));
            SET_HW_FLAGS(DUP_MOUSE_HARDWARE_PRESENT);
        }

        InterlockedIncrement(&Globals.AddedMice);

        mouseExtension->IsKeyboard = FALSE;

        SET_HW_FLAGS(MOUSE_HARDWARE_PRESENT);

        Print(DBG_IOCTL_INFO, ("IOCTL: mouse connect\n"));


        //
        // Only allow a connection if the mouse hardware is present.
        // Also, only allow one connection.
        //
        if (mouseExtension->ConnectData.ClassService != NULL) {

            Print(DBG_IOCTL_ERROR, ("IOCTL: error - already connected\n"));
            status = STATUS_SHARING_VIOLATION;
            break;
        }
        else if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CONNECT_DATA)) {

            Print(DBG_IOCTL_ERROR, ("IOCTL: error - invalid buffer length\n"));
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // Copy the connection parameters to the device extension.
        //
        mouseExtension->ConnectData =
            *((PCONNECT_DATA) (irpSp->Parameters.DeviceIoControl.Type3InputBuffer));

        hookMouse = ExAllocatePool(PagedPool,
                                   sizeof(INTERNAL_I8042_HOOK_MOUSE)
                                   );
        if (hookMouse) {
            topOfStack = IoGetAttachedDeviceReference(mouseExtension->Self);
            RtlZeroMemory(hookMouse,
                          sizeof(INTERNAL_I8042_HOOK_MOUSE)
                          );

            hookMouse->CallContext = (PVOID) DeviceObject;

            hookMouse->QueueMousePacket = (PI8042_QUEUE_PACKET)
               I8xQueueCurrentMouseInput;

            hookMouse->IsrWritePort = (PI8042_ISR_WRITE_PORT)
                I8xMouseIsrWritePort;

            I8xSendIoctl(topOfStack,
                         IOCTL_INTERNAL_I8042_HOOK_MOUSE,
                         (PVOID) hookMouse,
                         sizeof(INTERNAL_I8042_HOOK_MOUSE)
                         );

            ObDereferenceObject(topOfStack);
            ExFreePool(hookMouse);
        }

        status = STATUS_SUCCESS;
        break;

    //
    // Disconnect a mouse class device driver from the port driver.
    //
    // NOTE: Not implemented.
    //
    case IOCTL_INTERNAL_MOUSE_DISCONNECT:

        Print(DBG_IOCTL_INFO, ("IOCTL: mouse disconnect\n"));

        //
        // Perform a mouse interrupt disable call.
        //

        //
        // Clear the connection parameters in the device extension.
        // NOTE:  Must synchronize this with the mouse ISR.
        //
        //
        //deviceExtension->MouseExtension.ConnectData.ClassDeviceObject =
        //    Null;
        //deviceExtension->MouseExtension.ConnectData.ClassService =
        //    Null;
        status = STATUS_NOT_IMPLEMENTED;
        break;

    case IOCTL_INTERNAL_I8042_HOOK_MOUSE:

        Print(DBG_IOCTL_INFO, ("hook mouse received!\n"));

        if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(INTERNAL_I8042_HOOK_MOUSE)) {

            Print(DBG_IOCTL_ERROR,
                     ("InternalIoctl error - invalid buffer length\n"
                     ));
            status = STATUS_INVALID_PARAMETER;
        }
        else {
            //
            // Copy the values if they are filled in
            //
            hookMouse = (PINTERNAL_I8042_HOOK_MOUSE)
                irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

            mouseExtension->HookContext = hookMouse->Context;
            if (hookMouse->IsrRoutine) {
                Print(DBG_IOCTL_NOISE,
                      ("Mou Hook Routine 0x%x\n",
                       hookMouse->IsrRoutine
                       ));
                mouseExtension->IsrHookCallback = hookMouse->IsrRoutine;
            }

            status = STATUS_SUCCESS;
        }
        break;

    //
    // Query the keyboard attributes.  First check for adequate buffer
    // length.  Then, copy the keyboard attributes from the device
    // extension to the output buffer.
    //
    case IOCTL_KEYBOARD_QUERY_ATTRIBUTES:

        Print(DBG_IOCTL_NOISE, ("IOCTL: keyboard query attributes\n"));

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(KEYBOARD_ATTRIBUTES)) {
            status = STATUS_BUFFER_TOO_SMALL;
        }
        else {
            //
            // Copy the attributes from the DeviceExtension to the
            // buffer.
            //
            *(PKEYBOARD_ATTRIBUTES) Irp->AssociatedIrp.SystemBuffer =
                kbExtension->KeyboardAttributes;

            Irp->IoStatus.Information = sizeof(KEYBOARD_ATTRIBUTES);
            status = STATUS_SUCCESS;
        }

        break;

    //
    // Query the scan code to indicator-light mapping. Validate the
    // parameters, and copy the indicator mapping information from
    // the port device extension to the SystemBuffer.
    //
    case IOCTL_KEYBOARD_QUERY_INDICATOR_TRANSLATION: {

        PKEYBOARD_INDICATOR_TRANSLATION translation;

        ASSERT(kbExtension->IsKeyboard);

        Print(DBG_IOCTL_NOISE, ("IOCTL: keyboard query indicator translation\n"));

        sizeOfTranslation = sizeof(KEYBOARD_INDICATOR_TRANSLATION)
            + (sizeof(INDICATOR_LIST)
            * (kbExtension->KeyboardAttributes.NumberOfIndicators - 1));

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeOfTranslation) {
            status = STATUS_BUFFER_TOO_SMALL;
        }
        else {
            //
            // Copy the indicator mapping information to the system
            // buffer.
            //

            translation = (PKEYBOARD_INDICATOR_TRANSLATION)
                          Irp->AssociatedIrp.SystemBuffer;
            translation->NumberOfIndicatorKeys =
                kbExtension->KeyboardAttributes.NumberOfIndicators;

            RtlMoveMemory(
                translation->IndicatorList,
                (PCHAR) IndicatorList,
                sizeof(INDICATOR_LIST) * translation->NumberOfIndicatorKeys
                );

            Irp->IoStatus.Information = sizeOfTranslation;
            status = STATUS_SUCCESS;
        }

        break;
    }

    //
    // Query the keyboard indicators.  Validate the parameters, and
    // copy the indicator information from the port device extension to
    // the SystemBuffer.
    //
    case IOCTL_KEYBOARD_QUERY_INDICATORS:

        ASSERT(kbExtension->IsKeyboard);

        Print(DBG_IOCTL_NOISE, ("IOCTL: keyboard query indicators\n"));

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(KEYBOARD_INDICATOR_PARAMETERS)) {
            status = STATUS_BUFFER_TOO_SMALL;
        }
        else {
            //
            // Don't bother to synchronize access to the DeviceExtension
            // KeyboardIndicators field while copying it.  We don't
            // really care if another process is setting the LEDs via
            // StartIo running on another processor.
            //
            *(PKEYBOARD_INDICATOR_PARAMETERS) Irp->AssociatedIrp.SystemBuffer =
                kbExtension->KeyboardIndicators;
#if defined(FE_SB)
            keyboardId = kbExtension->KeyboardAttributes.KeyboardIdentifier;
            if (DEC_KANJI_KEYBOARD(keyboardId)) {
                //
                // DEC LK411 keyboard does not have LED for NumLock,
                // but the bit is used for KanaLock.
                //
                if (((PKEYBOARD_INDICATOR_PARAMETERS)
                    Irp->AssociatedIrp.SystemBuffer)->LedFlags & KEYBOARD_NUM_LOCK_ON) {
                    //
                    // KEYBOARD_KANA_LOCK_ON is mapped to KEYBOARD_NUM_LOCK_ON
                    //
                    ((PKEYBOARD_INDICATOR_PARAMETERS)
                    Irp->AssociatedIrp.SystemBuffer)->LedFlags |= KEYBOARD_KANA_LOCK_ON;
                    ((PKEYBOARD_INDICATOR_PARAMETERS)
                    Irp->AssociatedIrp.SystemBuffer)->LedFlags &= ~(KEYBOARD_NUM_LOCK_ON);
                }
            }
#endif
            Irp->IoStatus.Information = sizeof(KEYBOARD_INDICATOR_PARAMETERS);
            status = STATUS_SUCCESS;
        }

        break;

    //
    // Set the keyboard indicators (validate the parameters, mark the
    // request pending, and handle it in StartIo).
    //
    case IOCTL_KEYBOARD_SET_INDICATORS:

        if (!kbExtension->InterruptObject) {
            status = STATUS_DEVICE_NOT_READY;
            break;
        }

        if (kbExtension->PowerState != PowerDeviceD0) {
            status = STATUS_POWER_STATE_INVALID; 
            break;
        }

        Print(DBG_IOCTL_NOISE, ("IOCTL: keyboard set indicators\n"));

#ifdef FE_SB // I8042InternalDeviceControl()
        //
        // Katakana keyboard indicator support on AX Japanese keyboard
        //
        if ((irpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(KEYBOARD_INDICATOR_PARAMETERS)) ||
            ((((PKEYBOARD_INDICATOR_PARAMETERS)
                Irp->AssociatedIrp.SystemBuffer)->LedFlags
            & ~(KEYBOARD_SCROLL_LOCK_ON
            | KEYBOARD_NUM_LOCK_ON | KEYBOARD_CAPS_LOCK_ON
            | KEYBOARD_KANA_LOCK_ON)) != 0)) {
            status = STATUS_INVALID_PARAMETER;
        }
        else {
            keyboardId = kbExtension->KeyboardAttributes.KeyboardIdentifier;
            if (DEC_KANJI_KEYBOARD(keyboardId)) {
                //
                // DEC LK411 keyboard does not have LED for NumLock,
                // but the bit is used for KanaLock.
                //
                if (((PKEYBOARD_INDICATOR_PARAMETERS)
                    Irp->AssociatedIrp.SystemBuffer)->LedFlags & KEYBOARD_KANA_LOCK_ON) {
                    //
                    // KEYBOARD_KANA_LOCK_ON is mapped to KEYBOARD_NUM_LOCK_ON
                    //
                    ((PKEYBOARD_INDICATOR_PARAMETERS)
                    Irp->AssociatedIrp.SystemBuffer)->LedFlags |= KEYBOARD_NUM_LOCK_ON;
                    ((PKEYBOARD_INDICATOR_PARAMETERS)
                    Irp->AssociatedIrp.SystemBuffer)->LedFlags &= ~(KEYBOARD_KANA_LOCK_ON);
                }
                else {
                    //
                    // Ignore NumLock. (There is no LED for NumLock)
                    //
                    ((PKEYBOARD_INDICATOR_PARAMETERS)
                    Irp->AssociatedIrp.SystemBuffer)->LedFlags &= ~(KEYBOARD_NUM_LOCK_ON);
                }
            }
            else if (! AX_KEYBOARD(keyboardId) &&
                (((PKEYBOARD_INDICATOR_PARAMETERS)
                   Irp->AssociatedIrp.SystemBuffer)->LedFlags
                 & KEYBOARD_KANA_LOCK_ON)) {
                //
                // If this is not AX keyboard, the keyboard dose
                // have 'kana' LED, then just turn off the bit.
                //
                ((PKEYBOARD_INDICATOR_PARAMETERS)
                  Irp->AssociatedIrp.SystemBuffer)->LedFlags &=
                    ~(KEYBOARD_KANA_LOCK_ON);
            }
            status = STATUS_PENDING;
        }
#else
        if ((irpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(KEYBOARD_INDICATOR_PARAMETERS)) ||
            ((((PKEYBOARD_INDICATOR_PARAMETERS)
                Irp->AssociatedIrp.SystemBuffer)->LedFlags
            & ~(KEYBOARD_SCROLL_LOCK_ON
            | KEYBOARD_NUM_LOCK_ON | KEYBOARD_CAPS_LOCK_ON)) != 0)) {
            status = STATUS_INVALID_PARAMETER;
        }
        else {
            status = STATUS_PENDING;
        }
#endif // FE_SB

        break;

    //
    // Query the current keyboard typematic rate and delay.  Validate
    // the parameters, and copy the typematic information from the port
    // device extension to the SystemBuffer.
    //
    case IOCTL_KEYBOARD_QUERY_TYPEMATIC:

        Print(DBG_IOCTL_NOISE, ("IOCTL: keyboard query typematic\n"));

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(KEYBOARD_TYPEMATIC_PARAMETERS)) {
            status = STATUS_BUFFER_TOO_SMALL;
        }
        else {
            //
            // Don't bother to synchronize access to the DeviceExtension
            // KeyRepeatCurrent field while copying it.  We don't
            // really care if another process is setting the typematic
            // rate/delay via StartIo running on another processor.
            //

            *(PKEYBOARD_TYPEMATIC_PARAMETERS) Irp->AssociatedIrp.SystemBuffer =
                   kbExtension->KeyRepeatCurrent;
            Irp->IoStatus.Information = sizeof(KEYBOARD_TYPEMATIC_PARAMETERS);
            status = STATUS_SUCCESS;
        }

        break;

    //
    // Set the keyboard typematic rate and delay (validate the parameters,
    // mark the request pending, and handle it in StartIo).
    //
    case IOCTL_KEYBOARD_SET_TYPEMATIC:

        if (!kbExtension->InterruptObject) {
            status = STATUS_DEVICE_NOT_READY;
            break;
        }

        if (kbExtension->PowerState != PowerDeviceD0) {
            status = STATUS_POWER_STATE_INVALID; 
            break;
        }

        Print(DBG_IOCTL_NOISE, ("IOCTL: keyboard set typematic\n"));

        parameters = Irp->AssociatedIrp.SystemBuffer;
        keyboardAttributes = &kbExtension->KeyboardAttributes;

        if ((irpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(KEYBOARD_TYPEMATIC_PARAMETERS)) ||
            (((PKEYBOARD_TYPEMATIC_PARAMETERS) parameters)->Rate <
             keyboardAttributes->KeyRepeatMinimum.Rate) ||
            (((PKEYBOARD_TYPEMATIC_PARAMETERS) parameters)->Rate >
             keyboardAttributes->KeyRepeatMaximum.Rate) ||
            (((PKEYBOARD_TYPEMATIC_PARAMETERS) parameters)->Delay <
             keyboardAttributes->KeyRepeatMinimum.Delay) ||
            (((PKEYBOARD_TYPEMATIC_PARAMETERS) parameters)->Delay >
             keyboardAttributes->KeyRepeatMaximum.Delay)) {
            status = STATUS_INVALID_PARAMETER;
        }
        else {
            status = STATUS_PENDING;
        }

        break;

#if defined(_X86_)

    case IOCTL_KEYBOARD_SET_IME_STATUS:

        Print(DBG_IOCTL_NOISE, ("IOCTL: keyboard set ime status\n"));

        if (!kbExtension->InterruptObject) {
            status = STATUS_DEVICE_NOT_READY;
            break;
        }

        if (kbExtension->PowerState != PowerDeviceD0) {
            status = STATUS_POWER_STATE_INVALID; 
            break;
        }

        keyboardId = kbExtension->KeyboardAttributes.KeyboardIdentifier;
        if (!OYAYUBI_KEYBOARD(keyboardId)) {
            //
            // This ioctl supported on 'Fujitsu oyayubi' keyboard only...
            //
            status = STATUS_INVALID_DEVICE_REQUEST;
        }
        else {
            if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(KEYBOARD_IME_STATUS)) {

                status = STATUS_INVALID_PARAMETER;
            }
            else {
                ULONG InternalMode;

                parameters = Irp->AssociatedIrp.SystemBuffer;

                InternalMode = I8042QueryIMEStatusForOasys(
                                   (PKEYBOARD_IME_STATUS)parameters
                                   );

                if ((InternalMode <= 0) || (InternalMode > 8)) {
                    //
                    // IME mode could not translate to hardware mode.
                    //
                    status = STATUS_INVALID_PARAMETER;
                }
                else {
                    status = STATUS_PENDING;
                }
            }
        }

        break;

#endif
    //
    // Query the mouse attributes.  First check for adequate buffer
    // length.  Then, copy the mouse attributes from the device
    // extension to the output buffer.
    //
    case IOCTL_MOUSE_QUERY_ATTRIBUTES:

        Print(DBG_IOCTL_NOISE, ("IOCTL: mouse query attributes\n"));

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(MOUSE_ATTRIBUTES)) {
            status = STATUS_BUFFER_TOO_SMALL;
        }
        else {
            //
            // Copy the attributes from the DeviceExtension to the
            // buffer.
            //
            *(PMOUSE_ATTRIBUTES) Irp->AssociatedIrp.SystemBuffer =
                mouseExtension->MouseAttributes;

            Irp->IoStatus.Information = sizeof(MOUSE_ATTRIBUTES);
            status = STATUS_SUCCESS;
        }

        break;

    case IOCTL_INTERNAL_I8042_KEYBOARD_START_INFORMATION:
    case IOCTL_INTERNAL_I8042_MOUSE_START_INFORMATION:
        status = STATUS_SUCCESS;
        break;

    case IOCTL_INTERNAL_I8042_MOUSE_WRITE_BUFFER:
    case IOCTL_INTERNAL_I8042_KEYBOARD_WRITE_BUFFER:
        if (!mouseExtension->InterruptObject) {
            status = STATUS_DEVICE_NOT_READY;
            break;
        }

        if (mouseExtension->PowerState != PowerDeviceD0) {
            status = STATUS_POWER_STATE_INVALID; 
            break;
        }

        Print(DBG_IOCTL_NOISE, ("IOCTL: mouse send buffer\n"));

        if (irpSp->Parameters.DeviceIoControl.InputBufferLength < 1 ||
            !irpSp->Parameters.DeviceIoControl.Type3InputBuffer) {
            status = STATUS_INVALID_PARAMETER;
        }
        else {
            status = STATUS_PENDING;
        }
        break;

    case IOCTL_INTERNAL_I8042_CONTROLLER_WRITE_BUFFER:

        if (!kbExtension->IsKeyboard) {
            //
            // This should only be sent down the kb stack
            //
            Print(DBG_ALWAYS, ("Send this request down the kb stack!!!\n"));
            ASSERT(FALSE);
            status = STATUS_INVALID_DEVICE_REQUEST;
        }
        else {
            //
            // We currently do not support this IOCTL
            //
            status = STATUS_NOT_SUPPORTED;
        }
        break;

    default:

        Print(DBG_IOCTL_ERROR, ("IOCTL: INVALID REQUEST\n"));

        status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    Irp->IoStatus.Status = status;
    if (status == STATUS_PENDING) {
        Print(DBG_IOCTL_NOISE, ("Acquiring tag %p on remlock %p\n",
              Irp, 
              &GET_COMMON_DATA(DeviceObject->DeviceExtension)->RemoveLock));

        status = IoAcquireRemoveLock(
            &GET_COMMON_DATA(DeviceObject->DeviceExtension)->RemoveLock,
            Irp
            );

        if (!NT_SUCCESS(status)) {
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }
        else {
            status = STATUS_PENDING;
            IoMarkIrpPending(Irp);
            IoStartPacket(DeviceObject,
                          Irp,
                          (PULONG) NULL,
                          NULL
                          );
        }
    }
    else {
        IoCompleteRequest(Irp,
                          IO_NO_INCREMENT
                          );
    }

    Print(DBG_IOCTL_TRACE, ("IOCTL: exit (0x%x)\n", status));

    return status;
}

VOID
I8042RetriesExceededDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL to complete requests that
    have exceeded the maximum number of retries.  It is queued in the
    keyboard ISR.

Arguments:

    Dpc - Pointer to the DPC object.

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the Irp.

    Context - Not used.

Return Value:

    None.

--*/
{
    PCOMMON_DATA             commonData;
    PIO_ERROR_LOG_PACKET     errorLogEntry;
    PIO_STACK_LOCATION       irpSp;
    ULONG                    i;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(Context);

    Print(DBG_DPC_TRACE, ("I8042RetriesExceededDpc: enter\n"));

    commonData = GET_COMMON_DATA(DeviceObject->DeviceExtension);

    //
    // Set the completion status.
    //
    Irp->IoStatus.Status = STATUS_IO_TIMEOUT;

    if(Globals.ReportResetErrors == TRUE)
    {
        //
        // Log an error.
        //
        errorLogEntry = (PIO_ERROR_LOG_PACKET)
                IoAllocateErrorLogEntry(DeviceObject,
                                        (UCHAR) (sizeof(IO_ERROR_LOG_PACKET) +
                                        commonData->CurrentOutput.ByteCount *
                                        sizeof(ULONG))
                                        );

        KeAcquireSpinLockAtDpcLevel(&Globals.ControllerData->BytesSpinLock);

        if (errorLogEntry != NULL) {

            errorLogEntry->ErrorCode = commonData->IsKeyboard ?
                    I8042_RETRIES_EXCEEDED_KBD :
                    I8042_RETRIES_EXCEEDED_MOU;

            errorLogEntry->DumpDataSize = (USHORT)
                commonData->CurrentOutput.ByteCount * sizeof(ULONG);
            errorLogEntry->SequenceNumber = commonData->SequenceNumber;
            irpSp = IoGetCurrentIrpStackLocation(Irp);
            errorLogEntry->MajorFunctionCode = irpSp->MajorFunction;
            errorLogEntry->IoControlCode =
            irpSp->Parameters.DeviceIoControl.IoControlCode;
            errorLogEntry->RetryCount = (UCHAR) commonData->ResendCount;
            errorLogEntry->UniqueErrorValue = I8042_ERROR_VALUE_BASE + 210;
            errorLogEntry->FinalStatus = Irp->IoStatus.Status;

            if (commonData->CurrentOutput.Bytes) {
                for (i = 0; i < commonData->CurrentOutput.ByteCount; i++) {
                    errorLogEntry->DumpData[i] = commonData->CurrentOutput.Bytes[i];
                }
            }

            IoWriteErrorLogEntry(errorLogEntry);
        }
    }
    else{
        KeAcquireSpinLockAtDpcLevel(&Globals.ControllerData->BytesSpinLock);
    }

    if (commonData->CurrentOutput.Bytes &&
        commonData->CurrentOutput.Bytes != Globals.ControllerData->DefaultBuffer) {
        ExFreePool(commonData->CurrentOutput.Bytes);
    }
    commonData->CurrentOutput.Bytes = NULL;
    KeReleaseSpinLockFromDpcLevel(&Globals.ControllerData->BytesSpinLock);

    I8xCompletePendedRequest(DeviceObject, Irp, 0, STATUS_IO_TIMEOUT);

    Print(DBG_DPC_TRACE, ("I8042RetriesExceededDpc: exit\n"));
}

VOID
I8xStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine starts an I/O operation for the device which is further
    controlled by the controller object

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    None.

--*/
{
    KIRQL                     cancelIrql;
    PIO_STACK_LOCATION        irpSp;
    PCOMMON_DATA              common;

    Print(DBG_IOCTL_TRACE, ("I8042StartIo: enter\n"));

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    switch(irpSp->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_KEYBOARD_SET_INDICATORS:
    case IOCTL_KEYBOARD_SET_TYPEMATIC:
#if defined(_X86_)
    case IOCTL_KEYBOARD_SET_IME_STATUS:
#endif
    case IOCTL_INTERNAL_I8042_MOUSE_WRITE_BUFFER:
    case IOCTL_INTERNAL_I8042_KEYBOARD_WRITE_BUFFER:
    case IOCTL_INTERNAL_MOUSE_RESET:
        IoAllocateController(Globals.ControllerData->ControllerObject,
                             DeviceObject,
                             I8xControllerRoutine,
                             NULL
                             );
        break;

    default:

        Print(DBG_IOCTL_ERROR, ("I8042StartIo: INVALID REQUEST\n"));

        //
        // Log an internal error.  Note that we're calling the
        // error log DPC routine directly, rather than duplicating
        // code.
        //
        common = GET_COMMON_DATA(DeviceObject->DeviceExtension);
        I8042ErrorLogDpc((PKDPC) NULL,
                         DeviceObject,
                         Irp,
                         LongToPtr(common->IsKeyboard ?
                             I8042_INVALID_STARTIO_REQUEST_KBD :
                             I8042_INVALID_STARTIO_REQUEST_MOU)
                         );

        IoAcquireCancelSpinLock(&cancelIrql);
        IoSetCancelRoutine(Irp, NULL);
        IoReleaseCancelSpinLock(cancelIrql);

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        IoStartNextPacket(DeviceObject, FALSE);

        //
        // Release the lock we acquired when we started the packet
        //
        IoReleaseRemoveLock(&common->RemoveLock, Irp);
    }

    Print(DBG_IOCTL_TRACE, ("I8042StartIo: exit\n"));
}

IO_ALLOCATION_ACTION
I8xControllerRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          MapRegisterBase,
    IN PVOID          Context
    )
/*++

Routine Description:

    This routine synchronously writes the first byte to the intended device and
    fires off a timer to assure the write took place.

Arguments:

    DeviceObject - The device object for which the write is meant for

    Irp - Pointer to the request packet.

    MapRegisterBase - Unused

    Context - Unused

Return Value:

    None.

--*/
{
    PCOMMON_DATA              commonData = GET_COMMON_DATA(DeviceObject->DeviceExtension);
    PPORT_KEYBOARD_EXTENSION  kbExtension = DeviceObject->DeviceExtension;
    PPORT_MOUSE_EXTENSION     mouseExtension = DeviceObject->DeviceExtension;

    KIRQL                     cancelIrql;
    PIO_STACK_LOCATION        irpSp;
    INITIATE_OUTPUT_CONTEXT   ic;
    LARGE_INTEGER             deltaTime;
    LONG                      interlockedResult;
    ULONG                     bufferLen;
    NTSTATUS                  status = STATUS_SUCCESS;
    KEYBOARD_ID               keyboardId;

    commonData->SequenceNumber += 1;

    UNREFERENCED_PARAMETER(MapRegisterBase);
    UNREFERENCED_PARAMETER(Context);

    irpSp = IoGetCurrentIrpStackLocation(Irp);

#if DBG
    Globals.ControllerData->CurrentIoControlCode =
        irpSp->Parameters.DeviceIoControl.IoControlCode;
#endif

    switch(irpSp->Parameters.DeviceIoControl.IoControlCode) {

    //
    // Set the keyboard indicators to the desired state.
    //
    case IOCTL_KEYBOARD_SET_INDICATORS:

        Print(DBG_IOCTL_NOISE, ("I8xControllerRoutine: keyboard set indicators\n"));

        if (kbExtension->KeyboardIndicators.LedFlags ==
            ((PKEYBOARD_INDICATOR_PARAMETERS)
                Irp->AssociatedIrp.SystemBuffer)->LedFlags) {

            ASSERT(Irp->CancelRoutine == NULL);

            I8xCompletePendedRequest(DeviceObject,
                                     Irp,
                                     0,
                                     STATUS_SUCCESS
                                     );

            //
            // Tell the controller processing routine to stop processing packets
            // because we called IoFreeController ourselves.
            //
            return KeepObject;
        }

        ic.Bytes = Globals.ControllerData->DefaultBuffer;

        //
        // Set up the context structure for the InitiateIo wrapper.
        //
        ic.DeviceObject = DeviceObject;
        ic.ByteCount = 2;
        ic.Bytes[0] = SET_KEYBOARD_INDICATORS;
        ic.Bytes[1]  = (UCHAR) ((PKEYBOARD_INDICATOR_PARAMETERS)
            Irp->AssociatedIrp.SystemBuffer)->LedFlags;

        break;

    //
    // Set the keyboard typematic rate and delay.
    //
    case IOCTL_KEYBOARD_SET_TYPEMATIC:

        Print(DBG_IOCTL_NOISE, ("I8xControllerRoutine: keyboard set typematic\n"));

        ic.Bytes = Globals.ControllerData->DefaultBuffer;

        //
        // Set up the context structure for the InitiateIo wrapper.
        //
        ic.DeviceObject = DeviceObject;
        ic.ByteCount = 2;
        ic.Bytes[0] = SET_KEYBOARD_TYPEMATIC;
        ic.Bytes[1]  =
                 I8xConvertTypematicParameters(
                    ((PKEYBOARD_TYPEMATIC_PARAMETERS)
                        Irp->AssociatedIrp.SystemBuffer)->Rate,
                    ((PKEYBOARD_TYPEMATIC_PARAMETERS)
                        Irp->AssociatedIrp.SystemBuffer)->Delay
                    );
        break;

    case IOCTL_INTERNAL_I8042_MOUSE_WRITE_BUFFER:    // Write data to the mouse
    case IOCTL_INTERNAL_I8042_KEYBOARD_WRITE_BUFFER: // Write data to the kb

#if DBG
        if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
            IOCTL_INTERNAL_I8042_MOUSE_WRITE_BUFFER) {
            Print(DBG_IOCTL_NOISE, ("I8xControllerRoutine: mou write buffer\n"));
        }
        else {
            Print(DBG_IOCTL_NOISE, ("I8xControllerRoutine: kb write buffer\n"));
        }
#endif

        bufferLen = irpSp->Parameters.DeviceIoControl.InputBufferLength;
        if (bufferLen <= 4) {
            ic.Bytes = Globals.ControllerData->DefaultBuffer;
        }
        else {
            ic.Bytes = ExAllocatePool(NonPagedPool, bufferLen);
            if (!ic.Bytes) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto ControllerRequestError;
            }
        }

        ic.DeviceObject = DeviceObject;
        RtlCopyMemory(ic.Bytes,
                      irpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                      bufferLen);
        ic.ByteCount = bufferLen;

        break;

#if defined(_X86_)
    case IOCTL_KEYBOARD_SET_IME_STATUS:

        Print(DBG_IOCTL_NOISE, ("I8xControllerRoutine: keyboard set ime status\n"));

        keyboardId = kbExtension->KeyboardAttributes.KeyboardIdentifier;
        if (OYAYUBI_KEYBOARD(keyboardId)) {
            status = I8042SetIMEStatusForOasys(DeviceObject,
                                               Irp,
                                               &ic);
            if (!NT_SUCCESS(status)) {
                goto ControllerRequestError;
            }
        }
        else {
            status = STATUS_INVALID_DEVICE_REQUEST;
            goto ControllerRequestError;
        }
        break;
#endif

    case IOCTL_INTERNAL_MOUSE_RESET:
        Print(DBG_IOCTL_NOISE, ("I8xControllerRoutine: internal reset mouse\n"));
        I8xSendResetCommand(mouseExtension);
        return KeepObject;

    default:
        Print(DBG_IOCTL_ERROR, ("I8xContollerRoutine: INVALID REQUEST\n"));
        ASSERT(FALSE);

ControllerRequestError:
        IoAcquireCancelSpinLock(&cancelIrql);
        IoSetCancelRoutine(Irp, NULL);
        IoReleaseCancelSpinLock(cancelIrql);

        I8xCompletePendedRequest(DeviceObject, Irp, 0, status);
        
        //
        // Since we called IoFreeController already, tell the controller object
        // routine to stop processing packets 
        //
        return KeepObject;
    }

    KeSynchronizeExecution(
            commonData->InterruptObject,
            (PKSYNCHRONIZE_ROUTINE) I8xInitiateOutputWrapper,
            (PVOID) &ic
            );

    deltaTime.LowPart = (ULONG)(-10 * 1000 * 1000);
    deltaTime.HighPart = -1;

    KeSetTimer(&Globals.ControllerData->CommandTimer,
               deltaTime,
               &commonData->TimeOutDpc
               );

    return KeepObject;
}

VOID
I8xCompletePendedRequest(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    ULONG_PTR Information,
    NTSTATUS Status
    )
{
    PIO_STACK_LOCATION stack;
    PCOMMON_DATA common;

    stack = IoGetCurrentIrpStackLocation(Irp);
    common = GET_COMMON_DATA(DeviceObject->DeviceExtension);
        
    Irp->IoStatus.Information = Information;
    Irp->IoStatus.Status = Status;

    ASSERT(IOCTL_INTERNAL_MOUSE_RESET != 
                IoGetCurrentIrpStackLocation(Irp)->
                                    Parameters.DeviceIoControl.IoControlCode); 
    Print(DBG_IOCTL_INFO, 
          ("Completing IOCTL irp %p, code 0x%x, status 0x%x\n",
          Irp, stack->Parameters.DeviceIoControl.IoControlCode, Status)); 
    ASSERT(stack->Control & SL_PENDING_RETURNED);
    IoCompleteRequest(Irp, IO_KEYBOARD_INCREMENT);

    //
    // Start the next packet and complete the request.
    //
    // Order is important!  If IoStartNextPacket is called first, then
    // (potentially) the same device object will be enqueued twice on 
    // the controller object which will cause corruption in the 
    // controller object's list of allocated routines
    //
    IoFreeController(Globals.ControllerData->ControllerObject);
    IoStartNextPacket(DeviceObject, FALSE);

    //
    // Release the lock we acquired in start io.  Release this last so
    // that lifetime is guaranteed for IoFreeController and IoStart
    //
    IoReleaseRemoveLock(&common->RemoveLock, Irp);
}

VOID
I8042TimeOutDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )
/*++

Routine Description:

    This is the driver's command timeout routine.  It is called when the
    command timer fires.

Arguments:

    Dpc - Not Used.

    DeviceObject - Pointer to the device object.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.  As a side-effect, the timeout counter is updated and an error
    is logged.

--*/
{
    PCOMMON_DATA commonData;
    KIRQL cancelIrql;
    TIMER_CONTEXT timerContext;
    PIRP irp;
    PIO_ERROR_LOG_PACKET errorLogEntry;
    PIO_STACK_LOCATION irpSp;
    LARGE_INTEGER deltaTime;
    ULONG         i;

    Print(DBG_DPC_TRACE, ("I8042TimeOutDpc: enter\n"));

    //
    // Get the device extension.
    //
    commonData = GET_COMMON_DATA(DeviceObject->DeviceExtension);

    //
    // Acquire the cancel spinlock, verify that the CurrentIrp has not been
    // cancelled (i.e., CurrentIrp != NULL), set the cancel routine to NULL,
    // and release the cancel spinlock.
    //
    IoAcquireCancelSpinLock(&cancelIrql);
    irp = DeviceObject->CurrentIrp;
    if (irp == NULL) {
        IoReleaseCancelSpinLock(cancelIrql);
        Print(DBG_DPC_TRACE, ("I8042RetriesExceededDpc: exit (NULL irp)\n"));
        return;
    }
    IoSetCancelRoutine(irp, NULL);
    IoReleaseCancelSpinLock(cancelIrql);

    //
    // If the TimerCounter == 0 on entry to this routine, the last packet
    // timed out and was completed.  We just decrement TimerCounter
    // (synchronously) to indicate that we're no longer timing.
    //
    // If the TimerCounter indicates no timeout (I8042_ASYNC_NO_TIMEOUT)
    // on entry to this routine, there is no command being timed.
    //

    timerContext.DeviceObject = DeviceObject;
    timerContext.TimerCounter = &Globals.ControllerData->TimerCount;

    KeSynchronizeExecution(
        commonData->InterruptObject,
        (PKSYNCHRONIZE_ROUTINE) I8xDecrementTimer,
        &timerContext
        );

    if (timerContext.NewTimerCount == 0) {

        //
        // Set up the IO Status Block prior to completing the request.
        //
        irp->IoStatus.Information = 0;
        irp->IoStatus.Status = STATUS_IO_TIMEOUT;

        if(Globals.ReportResetErrors == TRUE)
        {
            //
            // Log a timeout error.
            //
            errorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
                                                  DeviceObject,
                                                  (UCHAR) (sizeof(IO_ERROR_LOG_PACKET) +
                                                  commonData->CurrentOutput.ByteCount * sizeof(ULONG))
                                                  );

            KeAcquireSpinLockAtDpcLevel(&Globals.ControllerData->BytesSpinLock);

            if (errorLogEntry != NULL) {

                errorLogEntry->ErrorCode = commonData->IsKeyboard ?
                    I8042_TIMEOUT_KBD :
                    I8042_TIMEOUT_MOU;
                errorLogEntry->DumpDataSize = (USHORT)
                    commonData->CurrentOutput.ByteCount * sizeof(ULONG);
                errorLogEntry->SequenceNumber = commonData->SequenceNumber;
                irpSp = IoGetCurrentIrpStackLocation(irp);
                errorLogEntry->MajorFunctionCode = irpSp->MajorFunction;
                errorLogEntry->IoControlCode =
                    irpSp->Parameters.DeviceIoControl.IoControlCode;
                errorLogEntry->RetryCount = (UCHAR) commonData->ResendCount;
                errorLogEntry->UniqueErrorValue = 90;
                errorLogEntry->FinalStatus = STATUS_IO_TIMEOUT;

                if (commonData->CurrentOutput.Bytes) {
                    for (i = 0; i < commonData->CurrentOutput.ByteCount; i++) {
                        errorLogEntry->DumpData[i] = commonData->CurrentOutput.Bytes[i];
                    }
                }

                IoWriteErrorLogEntry(errorLogEntry);
            }
        }
        else{
            KeAcquireSpinLockAtDpcLevel(&Globals.ControllerData->BytesSpinLock);
        }

        if (commonData->CurrentOutput.Bytes &&
            commonData->CurrentOutput.Bytes != Globals.ControllerData->DefaultBuffer) {
            ExFreePool(commonData->CurrentOutput.Bytes);
        }
        commonData->CurrentOutput.Bytes = NULL;
        KeReleaseSpinLockFromDpcLevel(&Globals.ControllerData->BytesSpinLock);

        I8xCompletePendedRequest(DeviceObject, irp, 0, irp->IoStatus.Status);
    }
    else {
        //
        // Restart the command timer.  Once started, the timer stops only
        // when the TimerCount goes to zero (indicating that the command
        // has timed out) or when explicitly cancelled in the completion
        // DPC (indicating that the command has successfully completed).
        //

        deltaTime.LowPart = (ULONG)(-10 * 1000 * 1000);
        deltaTime.HighPart = -1;

        (VOID) KeSetTimer(
                   &Globals.ControllerData->CommandTimer,
                   deltaTime,
                   &commonData->TimeOutDpc
                   );
    }

    Print(DBG_DPC_TRACE, ("I8042TimeOutDpc: exit\n" ));
}

VOID
I8xDecrementTimer(
    IN PTIMER_CONTEXT Context
    )
/*++

Routine Description:

    This routine decrements the timeout counter.  It is called from
    I8042TimeOutDpc.

Arguments:

    Context - Points to the context structure containing a pointer
        to the device object and a pointer to the timeout counter.

Return Value:

    None.  As a side-effect, the timeout counter is updated.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PCOMMON_DATA commonData;

    deviceObject = Context->DeviceObject;
    commonData = GET_COMMON_DATA(deviceObject->DeviceExtension);

    //
    // Decrement the timeout counter.
    //

    if (*(Context->TimerCounter) != I8042_ASYNC_NO_TIMEOUT)
        (*(Context->TimerCounter))--;

    //
    // Return the decremented timer count in NewTimerCount.  The
    // TimerCounter itself could change between the time this KeSynch'ed
    // routine returns to the TimeOutDpc, and the time the TimeOutDpc
    // looks at the value.  The TimeOutDpc will use NewTimerCount.
    //

    Context->NewTimerCount = *(Context->TimerCounter);

    //
    // Reset the state and the resend count, if the timeout counter goes to 0.
    //

    if (*(Context->TimerCounter) == 0) {
        commonData->CurrentOutput.State = Idle;
        commonData->ResendCount = 0;
    }
}

VOID
I8xDpcVariableOperation(
    IN  PVOID Context
    )
/*++

Routine Description:

    This routine is called synchronously by the ISR DPC to perform an
    operation on the InterlockedDpcVariable.  The operations that can be
    performed include increment, decrement, write, and read.  The ISR
    itself reads and writes the InterlockedDpcVariable without calling this
    routine.

Arguments:

    Context - Pointer to a structure containing the address of the variable
        to be operated on, the operation to perform, and the address at
        which to copy the resulting value of the variable (the latter is also
        used to pass in the value to write to the variable, on a write
        operation).

Return Value:

    None.

--*/
{
    PVARIABLE_OPERATION_CONTEXT operationContext = Context;

    Print(DBG_DPC_TRACE, ("I8xDpcVariableOperation: enter\n"));
    Print(DBG_DPC_INFO,
         ("\tPerforming %s at 0x%x (current value 0x%x)\n",
         (operationContext->Operation == IncrementOperation)? "increment":
         (operationContext->Operation == DecrementOperation)? "decrement":
         (operationContext->Operation == WriteOperation)?     "write":
         (operationContext->Operation == ReadOperation)?      "read":"",
         operationContext->VariableAddress,
         *(operationContext->VariableAddress)
         ));

    //
    // Perform the specified operation at the specified address.
    //

    switch(operationContext->Operation) {
        case IncrementOperation:
            *(operationContext->VariableAddress) += 1;
            break;
        case DecrementOperation:
            *(operationContext->VariableAddress) -= 1;
            break;
        case ReadOperation:
            break;
        case WriteOperation:
            Print(DBG_DPC_INFO,
                 ("\tWriting 0x%x\n",
                 *(operationContext->NewValue)
                 ));
            *(operationContext->VariableAddress) =
                *(operationContext->NewValue);
            break;
        default:
            ASSERT(FALSE);
            break;
    }

    *(operationContext->NewValue) = *(operationContext->VariableAddress);

    Print(DBG_DPC_TRACE,
         ("I8xDpcVariableOperation: exit with value 0x%x\n",
         *(operationContext->NewValue)
         ));
}

VOID
I8xGetDataQueuePointer(
    IN PGET_DATA_POINTER_CONTEXT Context
    )

/*++

Routine Description:

    This routine is called synchronously to get the current DataIn and DataOut
    pointers for the port InputData queue.

Arguments:

    Context - Pointer to a structure containing the device extension,
        device type, address at which to store the current DataIn pointer,
        and the address at which to store the current DataOut pointer.

Return Value:

    None.

--*/

{
    PPORT_MOUSE_EXTENSION mouseExtension;
    PPORT_KEYBOARD_EXTENSION kbExtension;
    CCHAR deviceType;

    Print(DBG_CALL_TRACE, ("I8xGetDataQueuePointer: enter\n"));

    //
    // Get address of device extension.
    //

    deviceType = (CCHAR) ((PGET_DATA_POINTER_CONTEXT) Context)->DeviceType;

    //
    // Get the DataIn and DataOut pointers for the indicated device.
    //

    if (deviceType == KeyboardDeviceType) {
        kbExtension = (PPORT_KEYBOARD_EXTENSION) Context->DeviceExtension;

        Print(DBG_CALL_INFO,
             ("I8xGetDataQueuePointer: keyboard\n"
             ));
        Print(DBG_CALL_INFO,
             ("I8xGetDataQueuePointer: DataIn 0x%x, DataOut 0x%x\n",
             kbExtension->DataIn,
             kbExtension->DataOut
             ));

        Context->DataIn = kbExtension->DataIn;
        Context->DataOut = kbExtension->DataOut;
        Context->InputCount = kbExtension->InputCount;
    } else if (deviceType == MouseDeviceType) {
        mouseExtension = (PPORT_MOUSE_EXTENSION) Context->DeviceExtension;

        Print(DBG_CALL_INFO,
             ("I8xGetDataQueuePointer: mouse\n"
             ));
        Print(DBG_CALL_INFO,
             ("I8xGetDataQueuePointer: DataIn 0x%x, DataOut 0x%x\n",
             mouseExtension->DataIn,
             mouseExtension->DataOut
             ));

        Context->DataIn = mouseExtension->DataIn;
        Context->DataOut = mouseExtension->DataOut;
        Context->InputCount = mouseExtension->InputCount;
    }
    else {
        ASSERT(FALSE);
    }

    Print(DBG_CALL_TRACE, ("I8xGetDataQueuePointer: exit\n"));
}

VOID
I8xInitializeDataQueue (
    IN PI8042_INITIALIZE_DATA_CONTEXT InitializeDataContext
    )

/*++

Routine Description:

    This routine initializes the input data queue for the indicated device.
    This routine is called via KeSynchronization, except when called from
    the initialization routine.

Arguments:

    Context - Pointer to a structure containing the device extension and
        the device type.

Return Value:

    None.

--*/

{
    PPORT_KEYBOARD_EXTENSION kbExtension;
    PPORT_MOUSE_EXTENSION mouseExtension;
    CCHAR deviceType;

    Print(DBG_CALL_TRACE, ("I8xInitializeDataQueue: enter\n"));

    //
    // Get address of device extension.
    //

    deviceType = InitializeDataContext->DeviceType;

    //
    // Initialize the input data queue for the indicated device.
    //
    if (deviceType == KeyboardDeviceType) {
        kbExtension = (PPORT_KEYBOARD_EXTENSION)
                      InitializeDataContext->DeviceExtension;
        kbExtension->InputCount = 0;
        kbExtension->DataIn = kbExtension->InputData;
        kbExtension->DataOut = kbExtension->InputData;
        kbExtension->OkayToLogOverflow = TRUE;

        Print(DBG_CALL_INFO, ("I8xInitializeDataQueue: keyboard\n"));
    }
    else if (deviceType == MouseDeviceType) {
        mouseExtension = (PPORT_MOUSE_EXTENSION)
                         InitializeDataContext->DeviceExtension;

        mouseExtension->InputCount = 0;
        mouseExtension->DataIn = mouseExtension->InputData;
        mouseExtension->DataOut = mouseExtension->InputData;
        mouseExtension->OkayToLogOverflow = TRUE;

        Print(DBG_CALL_INFO, ("I8xInitializeDataQueue: mouse\n"));
    }
    else {
        ASSERT(FALSE);
    }

    Print(DBG_CALL_TRACE, ("I8xInitializeDataQueue: exit\n"));

}

VOID
I8xLogError(
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS ErrorCode,
    IN ULONG UniqueErrorValue,
    IN NTSTATUS FinalStatus,
    IN PULONG DumpData,
    IN ULONG DumpCount
    )

/*++

Routine Description:

    This routine contains common code to write an error log entry.  It is
    called from other routines, especially I8xInitializeKeyboard, to avoid
    duplication of code.  Note that some routines continue to have their
    own error logging code (especially in the case where the error logging
    can be localized and/or the routine has more data because there is
    and IRP).

Arguments:

    DeviceObject - Pointer to the device object.

    ErrorCode - The error code for the error log packet.

    UniqueErrorValue - The unique error value for the error log packet.

    FinalStatus - The final status of the operation for the error log packet.

    DumpData - Pointer to an array of dump data for the error log packet.

    DumpCount - The number of entries in the dump data array.


Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;
    ULONG i;

    errorLogEntry = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry(
                                               DeviceObject,
                                               (UCHAR)
                                               (sizeof(IO_ERROR_LOG_PACKET)
                                               + (DumpCount * sizeof(ULONG)))
                                               );

    if (errorLogEntry != NULL) {

        errorLogEntry->ErrorCode = ErrorCode;
        errorLogEntry->DumpDataSize = (USHORT) (DumpCount * sizeof(ULONG));
        errorLogEntry->SequenceNumber = 0;
        errorLogEntry->MajorFunctionCode = 0;
        errorLogEntry->IoControlCode = 0;
        errorLogEntry->RetryCount = 0;
        errorLogEntry->UniqueErrorValue = UniqueErrorValue;
        errorLogEntry->FinalStatus = FinalStatus;
        for (i = 0; i < DumpCount; i++)
            errorLogEntry->DumpData[i] = DumpData[i];

        IoWriteErrorLogEntry(errorLogEntry);
    }
}

VOID
I8xSetDataQueuePointer(
    IN PSET_DATA_POINTER_CONTEXT SetDataPointerContext
    )

/*++

Routine Description:

    This routine is called synchronously to set the DataOut pointer
    and InputCount for the port InputData queue.

Arguments:

    Context - Pointer to a structure containing the device extension,
        device type, and the new DataOut value for the port InputData queue.

Return Value:

    None.

--*/

{
    PPORT_MOUSE_EXTENSION    mouseExtension;
    PPORT_KEYBOARD_EXTENSION kbExtension;
    CCHAR                    deviceType;

    Print(DBG_CALL_TRACE, ("I8xSetDataQueuePointer: enter\n"));

    //
    // Get address of device extension.
    //

    deviceType = (CCHAR) SetDataPointerContext->DeviceType;

    //
    // Set the DataOut pointer for the indicated device.
    //

    if (deviceType == KeyboardDeviceType) {
        kbExtension = (PPORT_KEYBOARD_EXTENSION)
                          SetDataPointerContext->DeviceExtension;

        Print(DBG_CALL_INFO,
             ("I8xSetDataQueuePointer: old keyboard DataOut 0x%x, InputCount %d\n",
             kbExtension->DataOut,
             kbExtension->InputCount
             ));
        kbExtension->DataOut = SetDataPointerContext->DataOut;
        kbExtension->InputCount -= SetDataPointerContext->InputCount;
        if (kbExtension->InputCount == 0) {

            //
            // Reset the flag that determines whether it is time to log
            // queue overflow errors.  We don't want to log errors too often.
            // Instead, log an error on the first overflow that occurs after
            // the ring buffer has been emptied, and then stop logging errors
            // until it gets cleared out and overflows again.
            //

            Print(DBG_CALL_INFO,
                 ("I8xSetDataQueuePointer: Okay to log keyboard overflow\n"
                 ));
            kbExtension->OkayToLogOverflow = TRUE;
        }
        Print(DBG_CALL_INFO,
             ("I8xSetDataQueuePointer: new keyboard DataOut 0x%x, InputCount %d\n",
             kbExtension->DataOut,
             kbExtension->InputCount
             ));
    } else if (deviceType == MouseDeviceType) {
        mouseExtension = (PPORT_MOUSE_EXTENSION)
                          SetDataPointerContext->DeviceExtension;

        Print(DBG_CALL_INFO,
             ("I8xSetDataQueuePointer: old mouse DataOut 0x%x, InputCount %d\n",
             mouseExtension->DataOut,
             mouseExtension->InputCount
             ));
        mouseExtension->DataOut = SetDataPointerContext->DataOut;
        mouseExtension->InputCount -= SetDataPointerContext->InputCount;
        if (mouseExtension->InputCount == 0) {

            //
            // Reset the flag that determines whether it is time to log
            // queue overflow errors.  We don't want to log errors too often.
            // Instead, log an error on the first overflow that occurs after
            // the ring buffer has been emptied, and then stop logging errors
            // until it gets cleared out and overflows again.
            //

            Print(DBG_CALL_INFO,
                 ("I8xSetDataQueuePointer: Okay to log mouse overflow\n"
                 ));
            mouseExtension->OkayToLogOverflow = TRUE;
        }
        Print(DBG_CALL_INFO,
             ("I8xSetDataQueuePointer: new mouse DataOut 0x%x, InputCount %d\n",
             mouseExtension->DataOut,
             mouseExtension->InputCount
             ));
    } else {
        ASSERT(FALSE);
    }

    Print(DBG_CALL_TRACE, ("I8xSetDataQueuePointer: exit\n"));
}

#if WRAP_IO_FUNCTIONS
UCHAR
NTAPI
I8xReadRegisterUchar(
    PUCHAR Register
    )
{
    return READ_REGISTER_UCHAR(Register);
}

void
NTAPI
I8xWriteRegisterUchar(
    PUCHAR Register,
    UCHAR Value
    )
{
    WRITE_REGISTER_UCHAR(Register, Value);
}

UCHAR
NTAPI
I8xReadPortUchar(
    PUCHAR Port
    )
{
    return READ_PORT_UCHAR(Port);
}

void
NTAPI
I8xWritePortUchar(
    PUCHAR Port,
    UCHAR Value
    )
{
    WRITE_PORT_UCHAR(Port, Value);
}
#endif // WRAP_IO_FUNCTIONS 

BOOLEAN
I8xSanityCheckResources(
    VOID
    )
/*++

Routine Description:

    Upon receiving the last Start Device IRP, all of the necessary i/o ports are checked
    to see if they exist.  If not, try to acquire them the old (non PnP) way.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG                               i;
    ULONG                               interruptVector;
    KIRQL                               interruptLevel;
    PI8042_CONFIGURATION_INFORMATION    configuration;
    CM_PARTIAL_RESOURCE_DESCRIPTOR      tmpResourceDescriptor;

    PCM_RESOURCE_LIST                   resources = NULL;
    ULONG                               resourceListSize = 0;
    UNICODE_STRING                      resourceDeviceClass;
    PDEVICE_OBJECT                      deviceObject = NULL;
    ULONG                               dumpData[4];
    BOOLEAN                             conflictDetected;

    BOOLEAN                             resourcesOK = TRUE;

    PAGED_CODE();

    //
    // If no port configuration information was found and we are at the last
    // added device (in the PnP view of things), use the i8042 defaults.
    //
    configuration = &Globals.ControllerData->Configuration;

    if (configuration->PortListCount == 0) {
        //
        // This state is now taken care of in IRP_MN_FILTER_RESOURCE_REQUIREMENTS,
        // it should never happen!
        //
        return FALSE;
    }
    else if (configuration->PortListCount == 1) {
        //
        // Kludge for Jazz machines.  Their ARC firmware neglects to
        // separate out the port addresses, so fix that up here.
        //
        configuration->PortList[DataPort].u.Port.Length = I8042_REGISTER_LENGTH;
        configuration->PortList[CommandPort] = configuration->PortList[DataPort];
        configuration->PortList[CommandPort].u.Port.Start.LowPart +=
            I8042_COMMAND_REGISTER_OFFSET;
        configuration->PortListCount += 1;
    }

    //
    // Put the lowest port address range in the DataPort element of
    // the port list.
    //
    if (configuration->PortList[CommandPort].u.Port.Start.LowPart
        < configuration->PortList[DataPort].u.Port.Start.LowPart) {

        tmpResourceDescriptor = configuration->PortList[DataPort];
        configuration->PortList[DataPort] =
            configuration->PortList[CommandPort];
        configuration->PortList[CommandPort] = tmpResourceDescriptor;
    }

    //
    // Set the DeviceRegister, mapping them if necessary
    //
    if (Globals.ControllerData->DeviceRegisters[0] == NULL) {
        if (Globals.RegistersMapped) {
            Print(DBG_SS_INFO, ("\tMapping registers !!!\n\n"));
            for (i=0; i < Globals.ControllerData->Configuration.PortListCount; i++) {
                Globals.ControllerData->DeviceRegisters[i] = (PUCHAR)
                    MmMapIoSpace(
                        Globals.ControllerData->Configuration.PortList[i].u.Memory.Start,
                        Globals.ControllerData->Configuration.PortList[i].u.Memory.Length,
                        MmNonCached
                        );
            }
#if WRAP_IO_FUNCTIONS
            Globals.I8xReadXxxUchar = I8xReadRegisterUchar;
            Globals.I8xWriteXxxUchar = I8xWriteRegisterUchar;
#else
            Globals.I8xReadXxxUchar = READ_REGISTER_UCHAR;
            Globals.I8xWriteXxxUchar = WRITE_REGISTER_UCHAR;
#endif
        }
        else {
            for (i=0; i < Globals.ControllerData->Configuration.PortListCount; i++) {
                Globals.ControllerData->DeviceRegisters[i] = (PUCHAR)
                    ULongToPtr(Globals.ControllerData->Configuration.PortList[i].u.Port.Start.LowPart);
            }

#if WRAP_IO_FUNCTIONS
            Globals.I8xReadXxxUchar = I8xReadPortUchar;
            Globals.I8xWriteXxxUchar = I8xWritePortUchar;
#else
            Globals.I8xReadXxxUchar = READ_PORT_UCHAR;
            Globals.I8xWriteXxxUchar = WRITE_PORT_UCHAR;
#endif
        }
    }

    for (i = 0; i < configuration->PortListCount; i++) {

        Print(DBG_SS_INFO,
              ("    %s, Ports (#%d) 0x%x - 0x%x\n",
              configuration->PortList[i].ShareDisposition
                  == CmResourceShareShared ?  "Sharable" : "NonSharable",
              i,
              configuration->PortList[i].u.Port.Start.LowPart,
              configuration->PortList[i].u.Port.Start.LowPart +
                 configuration->PortList[i].u.Port.Length - 1
              ));

    }

    return TRUE;
}

VOID
I8xInitiateIo(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is called synchronously from I8xKeyboardInitiateWrapper and
    the ISR to initiate an I/O operation for the keyboard device.

Arguments:

    Context - Pointer to the device object.

Return Value:

    None.

--*/

{
    PCOMMON_DATA commonData;
    PUCHAR       bytes;

    Print(DBG_CALL_TRACE, ("I8xInitiateIo: enter\n"));

    //
    // Get the device extension.
    //
    commonData = GET_COMMON_DATA(DeviceObject->DeviceExtension);

    //
    // Set the timeout value.
    //
    Globals.ControllerData->TimerCount = I8042_ASYNC_TIMEOUT;

    bytes = commonData->CurrentOutput.Bytes;

    //
    // Check to see if we have a valid buffer and we are actually transmitting.
    // We can get a bytes == 0 and State != SendingBytes by timing out a request
    // (a set lights for example) and then receiving the ACK for the request
    // after the cancellation.
    //
    // I don't think we should log an error here because the timeout will have
    // already done so and the relevant errror msg for this is too cryptic
    // for the user to understand.
    //
    if (!bytes || commonData->CurrentOutput.State != SendingBytes) {
        return;
    }

    if (commonData->CurrentOutput.CurrentByte <
        commonData->CurrentOutput.ByteCount) {

        Print(DBG_CALL_INFO,
              ("I8xInitiateIo: sending byte #%d (0x%x)\n",
              commonData->CurrentOutput.CurrentByte,
              bytes[commonData->CurrentOutput.CurrentByte]
              ));

        //
        // Send a byte of a command sequence to the keyboard/mouse
        // asynchronously.
        //
        if (!commonData->IsKeyboard) {
            I8X_WRITE_CMD_TO_MOUSE();
        }

        I8xPutByteAsynchronous(
             (CCHAR) DataPort,
             bytes[commonData->CurrentOutput.CurrentByte++]
             );
    }
    else {

        Print(DBG_CALL_ERROR | DBG_CALL_INFO,
              ("I8xInitiateIo: INVALID REQUEST\n"
              ));

        //
        // Queue a DPC to log an internal driver error.
        //
        KeInsertQueueDpc(
            &commonData->ErrorLogDpc,
            (PIRP) NULL,
            LongToPtr(commonData->IsKeyboard ?
                I8042_INVALID_INITIATE_STATE_KBD    :
                I8042_INVALID_INITIATE_STATE_MOU)
            );

        ASSERT(FALSE);
    }

    Print(DBG_CALL_TRACE, ("I8xInitiateIo: exit\n"));

    return;
}

VOID
I8xInitiateOutputWrapper(
    IN PINITIATE_OUTPUT_CONTEXT InitiateContext
    )
/*++

Routine Description:

    This routine is called from StartIo synchronously.  It sets up the
    CurrentOutput and ResendCount fields in the device extension, and
    then calls I8xKeyboardInitiateIo to do the real work.

Arguments:

    Context - Pointer to the context structure containing the first and
        last bytes of the send sequence.

Return Value:

    None.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PCOMMON_DATA   commonData;
    LARGE_INTEGER  li;

    //
    // Get a pointer to the device object from the context argument.
    //
    deviceObject = InitiateContext->DeviceObject;

    //
    // Set up CurrentOutput state for this operation.
    //

    commonData = GET_COMMON_DATA(deviceObject->DeviceExtension);

    commonData->CurrentOutput.Bytes = InitiateContext->Bytes;
    commonData->CurrentOutput.ByteCount = InitiateContext->ByteCount;
    commonData->CurrentOutput.CurrentByte = 0;
    commonData->CurrentOutput.State = SendingBytes;

    //
    // We're starting a new operation, so reset the resend count.
    //
    commonData->ResendCount = 0;

    //
    // Initiate the keyboard I/O operation.  Note that we were called
    // using KeSynchronizeExecution, so I8xKeyboardInitiateIo is also
    // synchronized with the keyboard ISR.
    //

    I8xInitiateIo(deviceObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\pnpi8042\i8042dep.c ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    i8042dep.c

Abstract:

    The initialization and hardware-dependent portions of
    the Intel i8042 port driver which are common to both
    the keyboard and the auxiliary (PS/2 mouse) device.

Environment:

    Kernel mode only.

Notes:

    NOTES:  (Future/outstanding issues)

    - Powerfail not implemented.

    - Consolidate duplicate code, where possible and appropriate.

    - There is code ifdef'ed out (#if 0).  This code was intended to
      disable the device by setting the correct disable bit in the CCB.
      It is supposedly correct to disable the device prior to sending a
      command that will cause output to end up in the 8042 output buffer
      (thereby possibly trashing something that was already in the output
      buffer).  Unfortunately, on rev K8 of the AMI 8042, disabling the
      device where we do caused some commands to timeout, because
      the keyboard was unable to return the expected bytes.  Interestingly,
      AMI claim that the device is only really disabled until the next ACK
      comes back.

Revision History:

--*/

#include "stdarg.h"
#include "stdio.h"
#include "string.h"
#include "i8042prt.h"
#include "i8042log.h"

//
// Use the alloc_text pragma to specify the driver initialization routines
// (they can be paged out).
//
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(INIT, I8xDetermineSharedInterrupts)
#pragma alloc_text(INIT, I8xServiceParameters)
#pragma alloc_text(PAGE, I8xInitializeHardwareAtBoot)
#pragma alloc_text(PAGE, I8xInitializeHardware)
#pragma alloc_text(PAGE, I8xReinitializeHardware)
#pragma alloc_text(PAGE, I8xUnload)
#pragma alloc_text(PAGE, I8xToggleInterrupts)
#endif

GLOBALS Globals;

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    NTSTATUS                    status = STATUS_SUCCESS; 
    UNICODE_STRING              parametersPath;
    PWSTR                       path;

    RtlZeroMemory(&Globals,
                  sizeof(GLOBALS)
                  );

    Globals.ControllerData = (PCONTROLLER_DATA) ExAllocatePool(
        NonPagedPool,
        sizeof(CONTROLLER_DATA)
        );

    if (!Globals.ControllerData) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto DriverEntryError;
    }

    RtlZeroMemory(Globals.ControllerData,
                  sizeof(CONTROLLER_DATA)
                  );

    Globals.ControllerData->ControllerObject = IoCreateController(0);

    if (!Globals.ControllerData->ControllerObject) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto DriverEntryError;
    }

    Globals.RegistryPath.MaximumLength = RegistryPath->Length +
                                          sizeof(UNICODE_NULL);
    Globals.RegistryPath.Length = RegistryPath->Length;
    Globals.RegistryPath.Buffer = ExAllocatePool(
                                       NonPagedPool,
                                       Globals.RegistryPath.MaximumLength
                                       );    

    if (!Globals.RegistryPath.Buffer) {

        Print (DBG_SS_ERROR,
               ("Initialize: Couldn't allocate pool for registry path."));

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto DriverEntryError;
    }

    RtlZeroMemory (Globals.RegistryPath.Buffer,
                   Globals.RegistryPath.MaximumLength);

    RtlMoveMemory (Globals.RegistryPath.Buffer,
                   RegistryPath->Buffer,
                   RegistryPath->Length);


    I8xServiceParameters(RegistryPath);

    ExInitializeFastMutex(&Globals.DispatchMutex);
    KeInitializeSpinLock(&Globals.ControllerData->BytesSpinLock);
    KeInitializeSpinLock(&Globals.ControllerData->PowerSpinLock);
    KeInitializeTimer(&Globals.ControllerData->CommandTimer);
    Globals.ControllerData->TimerCount = I8042_ASYNC_NO_TIMEOUT;

    DriverObject->DriverStartIo                             = I8xStartIo;
    DriverObject->DriverUnload                              = I8xUnload;
    DriverObject->DriverExtension->AddDevice                = I8xAddDevice;

    DriverObject->MajorFunction[IRP_MJ_CREATE]              = I8xCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]               = I8xClose;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] =
        I8xInternalDeviceControl;  
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]      = I8xDeviceControl;  
    DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS]       = I8xFlush;

    DriverObject->MajorFunction[IRP_MJ_PNP]                 = I8xPnP;
    DriverObject->MajorFunction[IRP_MJ_POWER]               = I8xPower;

    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]      = I8xSystemControl;

    //
    // Initialize the i8042 command timer.
    //

    Print(DBG_SS_TRACE, ("DriverEntry (0x%x) \n", status));

    return status;

DriverEntryError:

    //
    // Clean after something has gone wrong
    //
    if (Globals.ControllerData) {
        if (Globals.ControllerData->ControllerObject) {
            IoDeleteController(Globals.ControllerData->ControllerObject);
        }

        ExFreePool(Globals.ControllerData);
    }

    if (Globals.RegistryPath.Buffer) {
        ExFreePool(Globals.RegistryPath.Buffer);
    }

    return status;
}

VOID
I8xUnload(
   IN PDRIVER_OBJECT Driver
   )
/*++

Routine Description:

   Free all the allocated resources associated with this driver.

Arguments:

   DriverObject - Pointer to the driver object.

Return Value:

   None.

--*/

{
    ULONG i;

    PAGED_CODE();

    ASSERT(NULL == Driver->DeviceObject);

    Print(DBG_SS_TRACE, ("Unload \n"));

    if (Globals.RegistersMapped) {
        for (i = 0;
             i < Globals.ControllerData->Configuration.PortListCount;
             i++) {
            MmUnmapIoSpace(
                Globals.ControllerData->DeviceRegisters[i],
                Globals.ControllerData->Configuration.PortList[i].u.Memory.Length
                );
        }
    }

    //
    // Free resources in Globals
    //
    ExFreePool(Globals.RegistryPath.Buffer);
    if (Globals.ControllerData->ControllerObject) {
        IoDeleteController(Globals.ControllerData->ControllerObject);
    }
    ExFreePool(Globals.ControllerData);

    return;
}

VOID
I8xDrainOutputBuffer(
    IN PUCHAR DataAddress,
    IN PUCHAR CommandAddress
    )

/*++

Routine Description:

    This routine drains the i8042 controller's output buffer.  This gets
    rid of stale data that may have resulted from the user hitting a key
    or moving the mouse, prior to the execution of I8042Initialize.

Arguments:

    DataAddress - Pointer to the data address to read/write from/to.

    CommandAddress - Pointer to the command/status address to
        read/write from/to.


Return Value:

    None.

--*/

{
    UCHAR byte;
    ULONG i, limit;
    LARGE_INTEGER li;

    Print(DBG_BUFIO_TRACE, ("I8xDrainOutputBuffer: enter\n"));

    //
    // Wait till the input buffer is processed by keyboard
    // then go and read the data from keyboard.  Don't wait longer
    // than 1 second in case hardware is broken.  This fix is
    // necessary for some DEC hardware so that the keyboard doesn't
    // lock up.
    //
    limit = 1000;
    li.QuadPart = -10000;       

    for (i = 0; i < limit; i++) {
        if (!(I8X_GET_STATUS_BYTE(CommandAddress)&INPUT_BUFFER_FULL)) {
            break;
        }

        KeDelayExecutionThread(KernelMode,              // Mode
                               FALSE,                   // Alertable
                               &li);                    // Delay in (micro s)
    }

    while (I8X_GET_STATUS_BYTE(CommandAddress) & OUTPUT_BUFFER_FULL) {
        //
        // Eat the output buffer byte.
        //
        byte = I8X_GET_DATA_BYTE(DataAddress);
    }

    Print(DBG_BUFIO_TRACE, ("I8xDrainOutputBuffer: exit\n"));
}

VOID
I8xGetByteAsynchronous(
    IN CCHAR DeviceType,
    OUT PUCHAR Byte
    )

/*++

Routine Description:

    This routine reads a data byte from the controller or keyboard
    or mouse, asynchronously.

Arguments:

    DeviceType - Specifies which device (i8042 controller, keyboard, or
        mouse) to read the byte from.

    Byte - Pointer to the location to store the byte read from the hardware.

Return Value:

    None.

    As a side-effect, the byte value read is stored.  If the hardware was not
    ready for output or did not respond, the byte value is not stored.

--*/

{
    ULONG i;
    UCHAR response;
    UCHAR desiredMask;

    Print(DBG_BUFIO_TRACE,
         ("I8xGetByteAsynchronous: enter\n"
         ));

    Print(DBG_BUFIO_INFO,
         ("I8xGetByteAsynchronous: %s\n",
         DeviceType == KeyboardDeviceType ? "keyboard" :
            (DeviceType == MouseDeviceType ? "mouse" :
                                             "8042 controller")
         ));

    i = 0;
    desiredMask = (DeviceType == MouseDeviceType)?
                  (UCHAR) (OUTPUT_BUFFER_FULL | MOUSE_OUTPUT_BUFFER_FULL):
                  (UCHAR) OUTPUT_BUFFER_FULL;

    //
    // Poll until we get back a controller status value that indicates
    // the output buffer is full.  If we want to read a byte from the mouse,
    // further ensure that the auxiliary device output buffer full bit is
    // set.
    //

    while ((i < (ULONG)Globals.ControllerData->Configuration.PollingIterations) &&
           ((UCHAR)((response =
               I8X_GET_STATUS_BYTE(Globals.ControllerData->DeviceRegisters[CommandPort]))
               & desiredMask) != desiredMask)) {

        if (response & OUTPUT_BUFFER_FULL) {

            //
            // There is something in the i8042 output buffer, but it
            // isn't from the device we want to get a byte from.  Eat
            // the byte and try again.
            //

            *Byte = I8X_GET_DATA_BYTE(Globals.ControllerData->DeviceRegisters[DataPort]);
            Print(DBG_BUFIO_INFO, ("I8xGetByteAsynchronous: ate 0x%x\n",*Byte));
        } else {

            //
            // Try again.
            //

            i += 1;

            Print(DBG_BUFIO_NOISE,
                 ("I8xGetByteAsynchronous: wait for correct status\n"
                 ));
        }
    }
    if (i >= (ULONG)Globals.ControllerData->Configuration.PollingIterations) {
        Print(DBG_BUFIO_INFO | DBG_BUFIO_ERROR,
             ("I8xGetByteAsynchronous: timing out\n"
             ));
        return;
    }

    //
    // Grab the byte from the hardware.
    //

    *Byte = I8X_GET_DATA_BYTE(Globals.ControllerData->DeviceRegisters[DataPort]);

    Print(DBG_BUFIO_TRACE,
         ("I8xGetByteAsynchronous: exit with Byte 0x%x\n", *Byte
         ));

}

NTSTATUS
I8xGetBytePolled(
    IN CCHAR DeviceType,
    OUT PUCHAR Byte
    )

/*++

Routine Description:

    This routine reads a data byte from the controller or keyboard
    or mouse, in polling mode.

Arguments:

    DeviceType - Specifies which device (i8042 controller, keyboard, or
        mouse) to read the byte from.

    Byte - Pointer to the location to store the byte read from the hardware.

Return Value:

    STATUS_IO_TIMEOUT - The hardware was not ready for output or did not
    respond.

    STATUS_SUCCESS - The byte was successfully read from the hardware.

    As a side-effect, the byte value read is stored.

--*/

{
    ULONG i;
    UCHAR response;
    UCHAR desiredMask;
    PSTR  device;

    Print(DBG_BUFIO_TRACE,
         ("I8xGetBytePolled: enter\n"
         ));

    if (DeviceType == KeyboardDeviceType) {
        device = "keyboard";
    } else if (DeviceType == MouseDeviceType) {
        device = "mouse";
    } else {
        device = "8042 controller";
    }
    Print(DBG_BUFIO_INFO, ("I8xGetBytePolled: %s\n", device));

    i = 0;
    desiredMask = (DeviceType == MouseDeviceType)?
                  (UCHAR) (OUTPUT_BUFFER_FULL | MOUSE_OUTPUT_BUFFER_FULL):
                  (UCHAR) OUTPUT_BUFFER_FULL;


    //
    // Poll until we get back a controller status value that indicates
    // the output buffer is full.  If we want to read a byte from the mouse,
    // further ensure that the auxiliary device output buffer full bit is
    // set.
    //

    while ((i < (ULONG)Globals.ControllerData->Configuration.PollingIterations) &&
           ((UCHAR)((response =
               I8X_GET_STATUS_BYTE(Globals.ControllerData->DeviceRegisters[CommandPort]))
               & desiredMask) != desiredMask)) {
        if (response & OUTPUT_BUFFER_FULL) {

            //
            // There is something in the i8042 output buffer, but it
            // isn't from the device we want to get a byte from.  Eat
            // the byte and try again.
            //

            *Byte = I8X_GET_DATA_BYTE(Globals.ControllerData->DeviceRegisters[DataPort]);
            Print(DBG_BUFIO_INFO, ("I8xGetBytePolled: ate 0x%x\n", *Byte));
        } else {
            Print(DBG_BUFIO_NOISE, ("I8xGetBytePolled: stalling\n"));
            KeStallExecutionProcessor(
                 Globals.ControllerData->Configuration.StallMicroseconds
                 );
            i += 1;
        }
    }
    if (i >= (ULONG)Globals.ControllerData->Configuration.PollingIterations) {
        Print(DBG_BUFIO_INFO | DBG_BUFIO_NOISE, 
             ("I8xGetBytePolled: timing out\n"
             ));
        return(STATUS_IO_TIMEOUT);
    }

    //
    // Grab the byte from the hardware, and return success.
    //

    *Byte = I8X_GET_DATA_BYTE(Globals.ControllerData->DeviceRegisters[DataPort]);

    Print(DBG_BUFIO_TRACE, ("I8xGetBytePolled: exit with Byte 0x%x\n", *Byte));

    return(STATUS_SUCCESS);
}

NTSTATUS
I8xGetControllerCommand(
    IN ULONG HardwareDisableEnableMask,
    OUT PUCHAR Byte
    )

/*++

Routine Description:

    This routine reads the 8042 Controller Command Byte.

Arguments:

    HardwareDisableEnableMask - Specifies which hardware devices, if any,
        need to be disabled/enable around the operation.

    Byte - Pointer to the location into which the Controller Command Byte is
        read.

Return Value:

    Status is returned.

--*/

{
    NTSTATUS status;
    NTSTATUS secondStatus;
    ULONG retryCount;

    Print(DBG_BUFIO_TRACE, ("I8xGetControllerCommand: enter\n"));

    //
    // Disable the specified devices before sending the command to
    // read the Controller Command Byte (otherwise data in the output
    // buffer might get trashed).
    //

    if (HardwareDisableEnableMask & KEYBOARD_HARDWARE_PRESENT) {
        status = I8xPutBytePolled(
                     (CCHAR) CommandPort,
                     NO_WAIT_FOR_ACKNOWLEDGE,
                     (CCHAR) UndefinedDeviceType,
                     (UCHAR) I8042_DISABLE_KEYBOARD_DEVICE
                     );
        if (!NT_SUCCESS(status)) {
            return(status);
        }
    }

    if (HardwareDisableEnableMask & MOUSE_HARDWARE_PRESENT) {
        status = I8xPutBytePolled(
                     (CCHAR) CommandPort,
                     NO_WAIT_FOR_ACKNOWLEDGE,
                     (CCHAR) UndefinedDeviceType,
                     (UCHAR) I8042_DISABLE_MOUSE_DEVICE
                     );
        if (!NT_SUCCESS(status)) {

            //
            // Re-enable the keyboard device, if necessary, before returning.
            //

            if (HardwareDisableEnableMask & KEYBOARD_HARDWARE_PRESENT) {
                secondStatus = I8xPutBytePolled(
                                   (CCHAR) CommandPort,
                                   NO_WAIT_FOR_ACKNOWLEDGE,
                                   (CCHAR) UndefinedDeviceType,
                                   (UCHAR) I8042_ENABLE_KEYBOARD_DEVICE
                                   );
            }
            return(status);
        }
    }

    //
    // Send a command to the i8042 controller to read the Controller
    // Command Byte.
    //

    status = I8xPutBytePolled(
                 (CCHAR) CommandPort,
                 NO_WAIT_FOR_ACKNOWLEDGE,
                 (CCHAR) UndefinedDeviceType,
                 (UCHAR) I8042_READ_CONTROLLER_COMMAND_BYTE
                 );

    //
    // Read the byte from the i8042 data port.
    //

    if (NT_SUCCESS(status)) {
        for (retryCount = 0; retryCount < 5; retryCount++) {
            status = I8xGetBytePolled(
                         (CCHAR) ControllerDeviceType,
                         Byte
                         );
            if (NT_SUCCESS(status)) {
                break;
            }
            if (status == STATUS_IO_TIMEOUT) {
                KeStallExecutionProcessor(50);
            } else {
                break;
            }
        }
    }

    //
    // Re-enable the specified devices.  Clear the device disable
    // bits in the Controller Command Byte by hand (they got set when
    // we disabled the devices, so the CCB we read lacked the real
    // device disable bit information).
    //

    if (HardwareDisableEnableMask & KEYBOARD_HARDWARE_PRESENT) {
        secondStatus = I8xPutBytePolled(
                           (CCHAR) CommandPort,
                           NO_WAIT_FOR_ACKNOWLEDGE,
                           (CCHAR) UndefinedDeviceType,
                           (UCHAR) I8042_ENABLE_KEYBOARD_DEVICE
                           );
        if (!NT_SUCCESS(secondStatus)) {
            if (NT_SUCCESS(status))
                status = secondStatus;
        } else if (status == STATUS_SUCCESS) {
            *Byte &= (UCHAR) ~CCB_DISABLE_KEYBOARD_DEVICE;
        }

    }

    if (HardwareDisableEnableMask & MOUSE_HARDWARE_PRESENT) {
        secondStatus = I8xPutBytePolled(
                           (CCHAR) CommandPort,
                           NO_WAIT_FOR_ACKNOWLEDGE,
                           (CCHAR) UndefinedDeviceType,
                           (UCHAR) I8042_ENABLE_MOUSE_DEVICE
                           );
        if (!NT_SUCCESS(secondStatus)) {
            if (NT_SUCCESS(status))
                status = secondStatus;
        } else if (NT_SUCCESS(status)) {
            *Byte &= (UCHAR) ~CCB_DISABLE_MOUSE_DEVICE;
        }
    }

    Print(DBG_BUFIO_TRACE, ("I8xGetControllerCommand: exit\n"));

    return(status);

}

NTSTATUS
I8xToggleInterrupts(
    BOOLEAN State
    )
/*++

Routine Description:

    This routine is called by KeSynchronizeExecution to turn toggle the 
    interrupt(s).
     
Arguments:

    ToggleContext - indicates whether to turn the interrupts on or off plus it
                    stores the results of the operation
                    
Return Value:

    success of the toggle
    
--*/
{
    I8042_TRANSMIT_CCB_CONTEXT transmitCCBContext;

    PAGED_CODE();

    Print(DBG_SS_TRACE,
          ("I8xToggleInterrupts(%s), enter\n",
          State ? "TRUE" : "FALSE"
          ));

    if (State) {
        transmitCCBContext.HardwareDisableEnableMask =
            Globals.ControllerData->HardwarePresent;
        transmitCCBContext.AndOperation = OR_OPERATION;
        transmitCCBContext.ByteMask =
            (KEYBOARD_PRESENT()) ? CCB_ENABLE_KEYBOARD_INTERRUPT : 0;
        transmitCCBContext.ByteMask |= (UCHAR)
            (MOUSE_PRESENT()) ? CCB_ENABLE_MOUSE_INTERRUPT : 0;
    }
    else {
        transmitCCBContext.HardwareDisableEnableMask = 0;
        transmitCCBContext.AndOperation = AND_OPERATION;
        transmitCCBContext.ByteMask = (UCHAR)
             ~((UCHAR) CCB_ENABLE_KEYBOARD_INTERRUPT |
               (UCHAR) CCB_ENABLE_MOUSE_INTERRUPT);
    }

    I8xTransmitControllerCommand((PVOID) &transmitCCBContext);

    if (!NT_SUCCESS(transmitCCBContext.Status)) {
        Print(DBG_SS_INFO | DBG_SS_ERROR,
             ("I8xToggleInterrupts: failed to %sable the interrupts, status 0x%x\n",
             State ? "en" : "dis",
             transmitCCBContext.Status 
             ));

    }

    return transmitCCBContext.Status;
}

NTSTATUS
I8xInitializeHardwareAtBoot(
    NTSTATUS *KeyboardStatus,
    NTSTATUS *MouseStatus
    )
/*++

Routine Description:

    First initialization of the hardware
         
Arguments:

    KeyboardStatus - Stores result of keyboard init
    
    MouseStatus - Stores result of mouse init
    
Return Value:

    success if any of the devices are found and initialized
    
--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    //
    // It is OK to try to initialize the keyboard if the mouse has already started,
    // BUT we don't want to take the chance of disabling the keyboard if it has
    // already started and a start for the mouse arrives.
    //
    if (Globals.KeyboardExtension &&
        Globals.KeyboardExtension->InterruptObject) {
        return STATUS_INVALID_DEVICE_REQUEST; 
    }

    if (!I8xSanityCheckResources()) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // NEC machine can not toggle interrupts
    //
    status = I8xToggleInterrupts(FALSE);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    I8xInitializeHardware(KeyboardStatus, MouseStatus, INIT_FIRST_TIME);

    if ((NT_SUCCESS(*KeyboardStatus) ||
         (DEVICE_START_SUCCESS(*KeyboardStatus) && Globals.Headless) ||
         NT_SUCCESS(*MouseStatus)  ||
         (DEVICE_START_SUCCESS(*MouseStatus) && Globals.Headless)) &&
        (MOUSE_PRESENT() || KEYBOARD_PRESENT())) {
        status = I8xToggleInterrupts(TRUE);
    }

    return status;
}

VOID
I8xReinitializeHardware (
    PPOWER_UP_WORK_ITEM Item
    )
/*++

Routine Description:

    Initializes the hardware after returning from a low power state.  The
    routine is called from a worker item thread.
         
Arguments:

    Item - Work queue item
    
Return Value:

    success if any of the devices are found and initialized
    
--*/

{
    NTSTATUS            keyboardStatus = STATUS_UNSUCCESSFUL,
                        mouseStatus = STATUS_UNSUCCESSFUL;
    BOOLEAN             result;
    PIRP                mouOutstandingPowerIrp = NULL,
                        kbOutstandingPowerIrp = NULL;
    PIO_STACK_LOCATION  stack;
    NTSTATUS            status;
    ULONG               initFlags = 0;

    PPORT_MOUSE_EXTENSION mouseExtension = Globals.MouseExtension;
    PPORT_KEYBOARD_EXTENSION keyboardExtension = Globals.KeyboardExtension;

    PAGED_CODE();

    kbOutstandingPowerIrp = Item->KeyboardPowerIrp; 
    mouOutstandingPowerIrp = Item->MousePowerIrp; 

    //
    // Initialize the device if it is returning from a low power state (denoted
    // by an outstanding power irp) or if it is already in D0 (and the other 
    // device has been power cycled)
    //
    if (kbOutstandingPowerIrp                                        ||
        (KEYBOARD_PRESENT()                                     &&
         Globals.KeyboardExtension                              &&
         Globals.KeyboardExtension->PowerState == PowerDeviceD0    )    ) {
        initFlags |= INIT_KEYBOARD;
    }
    
    //
    // if the keyboard is in D0, then the other device has to have power cycled
    // for us to get into this code path
    //
    if (KEYBOARD_PRESENT()                                &&
         Globals.KeyboardExtension                        &&
         Globals.KeyboardExtension->PowerState == PowerDeviceD0) {
        ASSERT(mouOutstandingPowerIrp);
    }

    if (mouOutstandingPowerIrp                                    ||
        (MOUSE_PRESENT()                                     &&
         Globals.MouseExtension                              &&
         Globals.MouseExtension->PowerState == PowerDeviceD0    )    ) {
        initFlags |= INIT_MOUSE;
    }

    //
    // if the mouse is in D0, then the other device has to have power cycled
    // for us to get into this code path
    //
    if (MOUSE_PRESENT()                                &&
         Globals.MouseExtension                        &&
         Globals.MouseExtension->PowerState == PowerDeviceD0) {
        ASSERT(kbOutstandingPowerIrp);
    }

    ASSERT(initFlags != 0x0);

    //
    // Disable the interrupts on the i8042
    //
    I8xToggleInterrupts(FALSE);  

    Print(DBG_POWER_NOISE, ("item ... starting init\n"));
    I8xInitializeHardware(&keyboardStatus, &mouseStatus, initFlags);

    //
    // Reset PoweredDevices so that we can keep track of the powered device
    //  the next time the machine is power managed off.
    //

    if (!DEVICE_START_SUCCESS(keyboardStatus)) {
        Print(DBG_SS_ERROR,
              ("I8xReinitializeHardware for kb failed, 0x%x\n",
              keyboardStatus
              ));
    }

    if (!DEVICE_START_SUCCESS(mouseStatus)) {
        Print(DBG_SS_ERROR,
              ("I8xReinitializeHardware for mou failed, 0x%x\n",
              mouseStatus
              ));
    }

    if (DEVICE_START_SUCCESS(keyboardStatus) || DEVICE_START_SUCCESS(mouseStatus)) {
        //
        // Enable the interrupts on the i8042
        //
        I8xToggleInterrupts(TRUE);  
    }

    if (DEVICE_START_SUCCESS(mouseStatus) || mouseStatus == STATUS_IO_TIMEOUT) { 
        Print(DBG_SS_NOISE, ("reinit, mouse status == 0x%x\n", mouseStatus));

        if (mouOutstandingPowerIrp) {
            stack = IoGetCurrentIrpStackLocation(mouOutstandingPowerIrp);

            ASSERT(stack->Parameters.Power.State.DeviceState == PowerDeviceD0);
            mouseExtension->PowerState = stack->Parameters.Power.State.DeviceState; 
            mouseExtension->ShutdownType = PowerActionNone;

            PoSetPowerState(mouseExtension->Self,
                            stack->Parameters.Power.Type,
                            stack->Parameters.Power.State
                            );
        }

        if (IS_LEVEL_TRIGGERED(mouseExtension)) {
            Print(DBG_SS_NOISE,
                  ("mouse is level triggered, reconnecting INT\n"));

            ASSERT(mouseExtension->InterruptObject == NULL);
            I8xMouseConnectInterruptAndEnable(mouseExtension, FALSE);
            ASSERT(mouseExtension->InterruptObject != NULL);
        }

        if (mouseStatus != STATUS_IO_TIMEOUT &&
            mouseStatus != STATUS_DEVICE_NOT_CONNECTED) { 

            if (mouseExtension->InitializePolled) {
                I8xMouseEnableTransmission(mouseExtension);
            }
            else {
                I8X_MOUSE_INIT_COUNTERS(mouseExtension);
                I8xResetMouse(mouseExtension);
            }
        }
        else {
            //
            // Came back from low power and device didn't respond, pretend that
            // it is there, so that if the user plugs in a mouse later on, we
            // will be able to init it and make it usable
            //
            ;
        }

        mouseStatus = STATUS_SUCCESS;
    }

    //
    // Complete the irp no matter how the device came back
    //
    if (mouOutstandingPowerIrp) {
        mouOutstandingPowerIrp->IoStatus.Status = mouseStatus;
        mouOutstandingPowerIrp->IoStatus.Information = 0;

        PoStartNextPowerIrp(mouOutstandingPowerIrp);
        IoCompleteRequest(mouOutstandingPowerIrp, IO_NO_INCREMENT);
        IoReleaseRemoveLock(&mouseExtension->RemoveLock,
                            mouOutstandingPowerIrp);
    }

    if (DEVICE_START_SUCCESS(keyboardStatus)) {
        if (kbOutstandingPowerIrp) {
            stack = IoGetCurrentIrpStackLocation(kbOutstandingPowerIrp);

            ASSERT(stack->Parameters.Power.State.DeviceState == PowerDeviceD0);
            keyboardExtension->PowerState = stack->Parameters.Power.State.DeviceState;
            keyboardExtension->ShutdownType = PowerActionNone;

            PoSetPowerState(keyboardExtension->Self,
                            stack->Parameters.Power.Type,
                            stack->Parameters.Power.State
                            );
        }

        keyboardStatus = STATUS_SUCCESS;
    }

    //
    // Complete the irp no matter how the device came back
    //
    if (kbOutstandingPowerIrp) {
        kbOutstandingPowerIrp->IoStatus.Status = keyboardStatus;
        kbOutstandingPowerIrp->IoStatus.Information = 0;

        PoStartNextPowerIrp(kbOutstandingPowerIrp);
        IoCompleteRequest(kbOutstandingPowerIrp, IO_NO_INCREMENT);
        IoReleaseRemoveLock(&keyboardExtension->RemoveLock,
                            kbOutstandingPowerIrp);
    }

    I8xSetPowerFlag(WORK_ITEM_QUEUED, FALSE);
    ExFreePool(Item);
}

VOID
I8xInitializeHardware(
    NTSTATUS *KeyboardStatus,
    NTSTATUS *MouseStatus,
    ULONG    InitFlags
    )

/*++

Routine Description:

    This routine initializes the i8042 controller, keyboard, and mouse.
    Note that it is only called at initialization time.  This routine
    does not need to synchronize access to the hardware, or synchronize
    with the ISRs (they aren't connected yet).

Arguments:

    DeviceObject - Pointer to the device object.

Return Value:

    None.  As a side-effect, however, DeviceExtension->HardwarePresent is set.

--*/

{
    NTSTATUS    altStatus;
    PUCHAR      dataAddress, commandAddress;
    BOOLEAN     canTouchKeyboard, canTouchMouse, firstInit;

    PPORT_MOUSE_EXTENSION mouseExtension = Globals.MouseExtension;
    PPORT_KEYBOARD_EXTENSION keyboardExtension = Globals.KeyboardExtension;

    PAGED_CODE();

    Print(DBG_SS_TRACE, ("I8xInitializeHardware: enter\n"));

    //
    // Grab useful configuration parameters from global data 
    //
    dataAddress = Globals.ControllerData->DeviceRegisters[DataPort];
    commandAddress = Globals.ControllerData->DeviceRegisters[CommandPort];

    //
    // Drain the i8042 output buffer to get rid of stale data.
    //

    I8xDrainOutputBuffer(dataAddress, commandAddress);

    if (!MOUSE_PRESENT()) {
        Print(DBG_SS_INFO, ("I8xInitializeHardware: no mouse present\n"));
    }

    if (!KEYBOARD_PRESENT()) {
        Print(DBG_SS_INFO, ("I8xInitializeHardware: no keyboard present\n" ));
    }

    firstInit = (InitFlags & INIT_FIRST_TIME) ? TRUE : FALSE;

    if (firstInit) {
        canTouchKeyboard = canTouchMouse = TRUE;
    }
    else {
        canTouchKeyboard = (InitFlags & INIT_KEYBOARD) ? TRUE : FALSE;
        canTouchMouse = (InitFlags & INIT_MOUSE) ? TRUE : FALSE;
    }

    //
    // Disable the keyboard and mouse devices.
    //

#if 0
    //
    // NOTE:  This is supposedly the "correct" thing to do.  However,
    // disabling the keyboard device here causes the AMI rev K8 machines
    // (e.g., some Northgates) to fail some commands (e.g., the READID
    // command).
    //
   *KeyboardStatus =
            I8xPutBytePolled(
                 (CCHAR) CommandPort,
                 NO_WAIT_FOR_ACKNOWLEDGE,
                 (CCHAR) UndefinedDeviceType,
                 (UCHAR) I8042_DISABLE_KEYBOARD_DEVICE
                 
                 );
    if (!NT_SUCCESS(*KeyboardStatus)) {
        Print(DBG_SS_ERROR,
             ("I8xInitializeHardware: failed kbd disable, status 0x%x\n",
             *KeyboardStatus
             ));
        I8xManuallyRemoveDevice(GET_COMMON_DATA(keyboardExtension));
        }
#endif

    //
    // We will only run this piece of code when we are coming out of sleep.  We
    // do this b/c the user might moved the mouse or keyboard and that can lead
    // to errors during init.
    //
    if (KEYBOARD_PRESENT() && firstInit == FALSE && canTouchKeyboard &&
        keyboardExtension->ShutdownType  == PowerActionSleep) {
        I8xPutBytePolled((CCHAR) CommandPort,
                         NO_WAIT_FOR_ACKNOWLEDGE,
                         (CCHAR) UndefinedDeviceType,
                         (UCHAR) I8042_DISABLE_KEYBOARD_DEVICE
                         );
    }
        
#if 0
    //
    // NOTE:  This is supposedly the "correct thing to do.  However,
    // disabling the mouse on RadiSys EPC-24 which uses VLSI part number
    // VL82C144 (3751E) causes the part to shut down keyboard interrupts.
    //
    *MouseStatus =
            I8xPutBytePolled(
                 (CCHAR) CommandPort,
                 NO_WAIT_FOR_ACKNOWLEDGE,
                 (CCHAR) UndefinedDeviceType,
                 (UCHAR) I8042_DISABLE_MOUSE_DEVICE
                 );
    if (!NT_SUCCESS(*MouseStatus)) {
        Print(DBG_SS_ERROR,
             ("I8xInitializeHardware: failed mou disable, status 0x%x\n",
             *MouseStatus
             ));

        I8xManuallyRemoveDevice(GET_COMMON_DATA(mouseExtension));
    }
#endif

    //
    // We will only run this piece of code when we are coming out of sleep.  We
    // do this b/c the user might moved the mouse or keyboard and that can lead
    // to errors during init.
    //
    if (MOUSE_PRESENT() && firstInit == FALSE && canTouchMouse &&
        mouseExtension->ShutdownType  == PowerActionSleep) {
        I8xPutBytePolled((CCHAR) CommandPort,
                         NO_WAIT_FOR_ACKNOWLEDGE,
                         (CCHAR) UndefinedDeviceType,
                         (UCHAR) I8042_DISABLE_MOUSE_DEVICE
                         );
    }

    //
    // Drain the i8042 output buffer to get rid of stale data that could
    // come in sometime between the previous drain and the time the devices
    // are disabled.
    //

    I8xDrainOutputBuffer(dataAddress, commandAddress);

    //
    // Setup the keyboard hardware.
    //
    if (KEYBOARD_PRESENT() && canTouchKeyboard) { 
        ASSERT(keyboardExtension);

        *KeyboardStatus = I8xInitializeKeyboard(keyboardExtension);

        if (DEVICE_START_SUCCESS(*KeyboardStatus)) {
            //
            // If we are not headless and there is no device, we want to
            // successfully start the device, but then remove it in 
            // IRP_MN_QUERY_PNP_DEVICE_STATE.  If we fail the start now, we will
            // never get the query device state irp.
            //
            // If we are headless, then do not remove the device.   This has the
            // side effect of the keyboard being listed when the user enumerates
            // all of the keyboards on the machine.
            //
            if (*KeyboardStatus == STATUS_DEVICE_NOT_CONNECTED) {
                if (Globals.Headless == FALSE) {
                    Print(DBG_SS_INFO, ("kb not connected, removing\n"));
                    I8xManuallyRemoveDevice(GET_COMMON_DATA(keyboardExtension));
                }
                else if (firstInit) {
                    Print(DBG_SS_INFO, ("hiding the kb in the UI\n"));
                    keyboardExtension->PnpDeviceState |= PNP_DEVICE_DONT_DISPLAY_IN_UI;
                    IoInvalidateDeviceState(keyboardExtension->PDO);
                }

            }
        }
        else {
            Print(DBG_SS_ERROR,
                ("I8xInitializeHardware: failed kbd init, status 0x%x\n",
                *KeyboardStatus
                ));

            I8xManuallyRemoveDevice(GET_COMMON_DATA(keyboardExtension));
        }
    }
    else {
        *KeyboardStatus = STATUS_NO_SUCH_DEVICE;
    }

    //
    // Setup the mouse hardware. 
    //
    if (MOUSE_PRESENT() && canTouchMouse) {
        ASSERT(mouseExtension);

        *MouseStatus = I8xInitializeMouse(mouseExtension);

        if (DEVICE_START_SUCCESS(*MouseStatus)) {
            //
            // If we are not headless and there is no device, we want to
            // successfully start the device, but then remove it in 
            // IRP_MN_QUERY_PNP_DEVICE_STATE.  If we fail the start now, we will
            // never get the query device state irp.
            //
            // If we are headless, then do not remove the device.  This has the
            // side effect of keeping a mouse pointer on the screen even if 
            // there is no mouse plugged in and will be listed when a user 
            // enumerates all of the mice on the machine.
            //
            // If this is not the initial boot, then do not remove the device
            // if it is not responsive no matter what mode we are in.
            //
            if (*MouseStatus == STATUS_DEVICE_NOT_CONNECTED) { 
                if (firstInit) { 
                    if (Globals.Headless == FALSE) { 
                        Print(DBG_SS_INFO, ("mouse not connected, removing\n")); 
                        I8xManuallyRemoveDevice(GET_COMMON_DATA(mouseExtension)); 
                    } 
                    else { 
                        Print(DBG_SS_INFO, ("hiding mouse in  the UI\n")); 
                        mouseExtension->PnpDeviceState |= 
                            PNP_DEVICE_DONT_DISPLAY_IN_UI; 
                        IoInvalidateDeviceState(mouseExtension->PDO); 
                    } 
                } 
                else { 
                    // 
                    // Mouse was previously present, but is now unresponsive.  
                    // Hope that it comes back at a later point in time.  
                    // 
                    // FYI:  Mouse can be unresponsive because of the PC's BIOS
                    // password security. 
                    // 
                    /* do nothing */; 
                } 
            } 
        }
        else if (firstInit) {
            Print(DBG_SS_ERROR,
                ("I8xInitializeHardware: failed mou init, status 0x%x\n" ,
                *MouseStatus
                ));

            I8xManuallyRemoveDevice(GET_COMMON_DATA(mouseExtension));
        }
    }
    else {
        *MouseStatus = STATUS_NO_SUCH_DEVICE;
    }

    //
    // Enable the keyboard and mouse devices and their interrupts.  Note
    // that it is required that this operation happen during intialization
    // time, because the i8042 Output Buffer Full bit gets set in the
    // Controller Command Byte when the keyboard/mouse is used, even if
    // the device is disabled.  Hence, we cannot successfully perform
    // the enable operation later (e.g., when processing
    // IOCTL_INTERNAL_*_ENABLE), because we can't guarantee that
    // I8xPutBytePolled() won't time out waiting for the Output Buffer Full
    // bit to clear, even if we drain the output buffer (because the user
    // could be playing with the mouse/keyboard, and continuing to set the
    // OBF bit).  KeyboardEnableCount and MouseEnableCount remain zero until
    // their respective IOCTL_INTERNAL_*_ENABLE call succeeds, so the ISR
    // ignores the unexpected interrupts.
    //

    if (KEYBOARD_PRESENT() && NT_SUCCESS(*KeyboardStatus) && canTouchKeyboard) {
        NTSTATUS status;

        Print(DBG_SS_INFO, ("resetting the LEDs\n"));

        if ((status = I8xPutBytePolled(
                          (CCHAR) DataPort,
                          WAIT_FOR_ACKNOWLEDGE,
                          (CCHAR) KeyboardDeviceType,
                          (UCHAR) SET_KEYBOARD_INDICATORS
                          )) == STATUS_SUCCESS) {
    
            status = I8xPutBytePolled(
                                 (CCHAR) DataPort,
                                 WAIT_FOR_ACKNOWLEDGE,
                                 (CCHAR) KeyboardDeviceType,
                                 (UCHAR) keyboardExtension->KeyboardIndicators.LedFlags
                                 );
            if (status != STATUS_SUCCESS) {
                Print(DBG_SS_INFO, ("setting LEDs value at mou failure failed 0x%x\n", status));
            }
        }
        else {
            Print(DBG_SS_INFO, ("setting LEDs at mou failure failed 0x%x\n", status));
        }

    }

    //
    // Re-enable the keyboard device in the Controller Command Byte.
    // Note that some of the keyboards will send an ACK back, while
    // others don't.  Don't wait for an ACK, but do drain the output
    // buffer afterwards so that an unexpected ACK doesn't mess up
    // successive PutByte operations.

    if (KEYBOARD_PRESENT() && canTouchKeyboard) {
        altStatus = I8xPutBytePolled(
                     (CCHAR) CommandPort,
                     NO_WAIT_FOR_ACKNOWLEDGE,
                     (CCHAR) UndefinedDeviceType,
                     (UCHAR) I8042_ENABLE_KEYBOARD_DEVICE
                     );
        if (!NT_SUCCESS(altStatus) && firstInit) {
            *KeyboardStatus = altStatus;
            Print(DBG_SS_ERROR,
                 ("I8xInitializeHardware: failed kbd re-enable, status 0x%x\n",
                 *KeyboardStatus
                 ));
            I8xManuallyRemoveDevice(GET_COMMON_DATA(keyboardExtension));
        }

        I8xDrainOutputBuffer(dataAddress, commandAddress);
    }

    //
    // Re-enable the mouse device in the Controller Command Byte.
    //
    if (MOUSE_PRESENT() && canTouchMouse) {

        altStatus = I8xPutBytePolled(
                     (CCHAR) CommandPort,
                     NO_WAIT_FOR_ACKNOWLEDGE,
                     (CCHAR) UndefinedDeviceType,
                     (UCHAR) I8042_ENABLE_MOUSE_DEVICE
                     );

        //
        // If the mouse or the controller is still unresponsive when coming out
        // of low power, just leave it be and hope it comes out of its confused
        // state later.
        //
        if (!NT_SUCCESS(altStatus) && firstInit) {
            *MouseStatus = altStatus;
            Print(DBG_SS_ERROR,
                 ("I8xInitializeHardware: failed mou re-enable, status 0x%x\n",
                 altStatus 
                 ));
            I8xManuallyRemoveDevice(GET_COMMON_DATA(mouseExtension));
        }

        I8xDrainOutputBuffer(dataAddress, commandAddress);
    }

    Print(DBG_SS_TRACE,
          ("I8xInitializeHardware (k 0x%x, m 0x%x)\n", 
          *KeyboardStatus,
          *MouseStatus
          ));
}

VOID
I8xPutByteAsynchronous(
    IN CCHAR PortType,
    IN UCHAR Byte
    )

/*++

Routine Description:

    This routine sends a command or data byte to the controller or keyboard
    or mouse, asynchronously.  It does not wait for acknowledgment.
    If the hardware was not ready for input, the byte is not sent.

Arguments:

    PortType - If CommandPort, send the byte to the command register,
        otherwise send it to the data register.

    Byte - The byte to send to the hardware.

Return Value:

    None.

--*/

{
    ULONG i;

    Print(DBG_BUFIO_TRACE, ("I8xPutByteAsynchronous: enter\n" ));

    //
    // Make sure the Input Buffer Full controller status bit is clear.
    // Time out if necessary.
    //

    i = 0;
    while ((i++ < (ULONG)Globals.ControllerData->Configuration.PollingIterations) &&
           (I8X_GET_STATUS_BYTE(Globals.ControllerData->DeviceRegisters[CommandPort])
                & INPUT_BUFFER_FULL)) {

        //
        // Do nothing.
        //

        Print(DBG_BUFIO_NOISE,
             ("I8xPutByteAsynchronous: wait for IBF and OBF to clear\n"
             ));
    }

    if (i >= (ULONG)Globals.ControllerData->Configuration.PollingIterations) {
        Print(DBG_BUFIO_ERROR,
             ("I8xPutByteAsynchronous: exceeded number of retries\n"
             ));
        return;
    }

    //
    // Send the byte to the appropriate (command/data) hardware register.
    //

    if (PortType == CommandPort) {
        Print(DBG_BUFIO_INFO,
             ("I8xPutByteAsynchronous: sending 0x%x to command port\n",
             Byte
             ));
        I8X_PUT_COMMAND_BYTE(Globals.ControllerData->DeviceRegisters[CommandPort], Byte);
    } else {
        Print(DBG_BUFIO_INFO,
             ("I8xPutByteAsynchronous: sending 0x%x to data port\n",
             Byte
             ));
        I8X_PUT_DATA_BYTE(Globals.ControllerData->DeviceRegisters[DataPort], Byte);
    }

    Print(DBG_BUFIO_TRACE, ("I8xPutByteAsynchronous: exit\n"));
}

NTSTATUS
I8xPutBytePolled(
    IN CCHAR PortType,
    IN BOOLEAN WaitForAcknowledge,
    IN CCHAR AckDeviceType,
    IN UCHAR Byte
    )

/*++

Routine Description:

    This routine sends a command or data byte to the controller or keyboard
    or mouse, in polling mode.  It waits for acknowledgment and resends
    the command/data if necessary.

Arguments:

    PortType - If CommandPort, send the byte to the command register,
        otherwise send it to the data register.

    WaitForAcknowledge - If true, wait for an ACK back from the hardware.

    AckDeviceType - Indicates which device we expect to get the ACK back
        from.

    Byte - The byte to send to the hardware.

Return Value:

    STATUS_IO_TIMEOUT - The hardware was not ready for input or did not
    respond.

    STATUS_SUCCESS - The byte was successfully sent to the hardware.

--*/

{
    ULONG i,j;
    UCHAR response;
    NTSTATUS status;
    BOOLEAN keepTrying;
    PUCHAR dataAddress, commandAddress;

    Print(DBG_BUFIO_TRACE, ("I8xPutBytePolled: enter\n"));

    if (AckDeviceType == MouseDeviceType) {

        //
        // We need to precede a PutByte for the mouse device with
        // a PutByte that tells the controller that the next byte
        // sent to the controller should go to the auxiliary device
        // (by default it would go to the keyboard device).  We
        // do this by calling I8xPutBytePolled recursively to send
        // the "send next byte to auxiliary device" command
        // before sending the intended byte to the mouse.  Note that
        // there is only one level of recursion, since the AckDeviceType
        // for the recursive call is guaranteed to be UndefinedDeviceType,
        // and hence this IF statement will evaluate to FALSE.
        //

        I8xPutBytePolled(
            (CCHAR) CommandPort,
            NO_WAIT_FOR_ACKNOWLEDGE,
            (CCHAR) UndefinedDeviceType,
            (UCHAR) I8042_WRITE_TO_AUXILIARY_DEVICE
            );
    }

    dataAddress = Globals.ControllerData->DeviceRegisters[DataPort];
    commandAddress = Globals.ControllerData->DeviceRegisters[CommandPort];

    for (j=0;j < (ULONG)Globals.ControllerData->Configuration.ResendIterations;j++) {

        //
        // Make sure the Input Buffer Full controller status bit is clear.
        // Time out if necessary.
        //

        i = 0;
        while ((i++ < (ULONG)Globals.ControllerData->Configuration.PollingIterations)
               && (I8X_GET_STATUS_BYTE(commandAddress) & INPUT_BUFFER_FULL)) {
            Print(DBG_BUFIO_NOISE, ("I8xPutBytePolled: stalling\n"));
            KeStallExecutionProcessor(
                Globals.ControllerData->Configuration.StallMicroseconds
                );
        }
        if (i >= (ULONG)Globals.ControllerData->Configuration.PollingIterations) {
            Print((DBG_BUFIO_MASK & ~DBG_BUFIO_INFO),
                 ("I8xPutBytePolled: timing out\n"
                 ));
            status = STATUS_IO_TIMEOUT;
            break;
        }

        //
        // Drain the i8042 output buffer to get rid of stale data.
        //

        I8xDrainOutputBuffer(dataAddress, commandAddress);

        //
        // Send the byte to the appropriate (command/data) hardware register.
        //

        if (PortType == CommandPort) {
            Print(DBG_BUFIO_INFO,
                 ("I8xPutBytePolled: sending 0x%x to command port\n",
                 Byte
                 ));
            I8X_PUT_COMMAND_BYTE(commandAddress, Byte);
        } else {
            Print(DBG_BUFIO_INFO,
                 ("I8xPutBytePolled: sending 0x%x to data port\n",
                 Byte
                 ));
            I8X_PUT_DATA_BYTE(dataAddress, Byte);
        }

        //
        // If we don't need to wait for an ACK back from the controller,
        // set the status and break out of the for loop.
        //
        //

        if (WaitForAcknowledge == NO_WAIT_FOR_ACKNOWLEDGE) {
            status = STATUS_SUCCESS;
            break;
        }

        //
        // Wait for an ACK back from the controller.  If we get an ACK,
        // the operation was successful.  If we get a RESEND, break out to
        // the for loop and try the operation again.  Ignore anything other
        // than ACK or RESEND.
        //

        Print(DBG_BUFIO_NOISE,
             ("I8xPutBytePolled: waiting for ACK\n"
             ));
        keepTrying = FALSE;
        while ((status = I8xGetBytePolled(
                             AckDeviceType,
                             &response
                             )
               ) == STATUS_SUCCESS) {

            if (response == ACKNOWLEDGE) {
                Print(DBG_BUFIO_NOISE, ("I8xPutBytePolled: got ACK\n"));
                break;
            } else if (response == RESEND) {
                Print(DBG_BUFIO_NOISE, ("I8xPutBytePolled: got RESEND\n"));

                if (AckDeviceType == MouseDeviceType) {

                    //
                    // We need to precede the "resent" PutByte for the
                    // mouse device with a PutByte that tells the controller
                    // that the next byte sent to the controller should go
                    // to the auxiliary device (by default it would go to
                    // the keyboard device).  We do this by calling
                    // I8xPutBytePolled recursively to send the "send next
                    // byte to auxiliary device" command before resending
                    // the byte to the mouse.  Note that there is only one
                    // level of recursion, since the AckDeviceType for the
                    // recursive call is guaranteed to be UndefinedDeviceType.
                    //

                    I8xPutBytePolled(
                        (CCHAR) CommandPort,
                        NO_WAIT_FOR_ACKNOWLEDGE,
                        (CCHAR) UndefinedDeviceType,
                        (UCHAR) I8042_WRITE_TO_AUXILIARY_DEVICE
                        );
                }

                keepTrying = TRUE;
                break;
            }

           //
           // Ignore any other response, and keep trying.
           //

        }

        if (!keepTrying)
            break;
    }

    //
    // Check to see if the number of allowable retries was exceeded.
    //

    if (j >= (ULONG)Globals.ControllerData->Configuration.ResendIterations) {
        Print(DBG_BUFIO_ERROR,
             ("I8xPutBytePolled: exceeded number of retries\n"
             ));
        status = STATUS_IO_TIMEOUT;
    }

    Print(DBG_BUFIO_TRACE, ("I8xPutBytePolled: exit\n"));

    return(status);
}

NTSTATUS
I8xPutControllerCommand(
    IN UCHAR Byte
    )

/*++

Routine Description:

    This routine writes the 8042 Controller Command Byte.

Arguments:

    Byte - The byte to store in the Controller Command Byte.

Return Value:

    Status is returned.

--*/

{
    NTSTATUS status;

    Print(DBG_BUFIO_TRACE, ("I8xPutControllerCommand: enter\n"));

    //
    // Send a command to the i8042 controller to write the Controller
    // Command Byte.
    //

    status = I8xPutBytePolled(
                 (CCHAR) CommandPort,
                 NO_WAIT_FOR_ACKNOWLEDGE,
                 (CCHAR) UndefinedDeviceType,
                 (UCHAR) I8042_WRITE_CONTROLLER_COMMAND_BYTE
                 );

    if (!NT_SUCCESS(status)) {
        return(status);
    }

    //
    // Write the byte through the i8042 data port.
    //

    Print(DBG_BUFIO_TRACE, ("I8xPutControllerCommand: exit\n"));

    return(I8xPutBytePolled(
               (CCHAR) DataPort,
               NO_WAIT_FOR_ACKNOWLEDGE,
               (CCHAR) UndefinedDeviceType,
               (UCHAR) Byte
               )
    );
}

BOOLEAN
I8xDetermineSharedInterrupts(VOID)
{
//
// This was a specific fix for Jensen Alphas.  Since we do not support them
// anymore, ifdef this code away.
//
#ifdef JENSEN
    RTL_QUERY_REGISTRY_TABLE    jensenTable[2] = {0};
    UNICODE_STRING              jensenData;
    UNICODE_STRING              jensenValue;
    WCHAR                       jensenBuffer[256];

    BOOLEAN shareInterrupts = FALSE;
 
    //
    // Check to see if this is a Jensen alpha.  If it is, then
    // we'll have to change the way we enable and disable interrupts
    //
 
    jensenData.Length = 0;
    jensenData.MaximumLength = 512;
    jensenData.Buffer = (PWCHAR)&jensenBuffer[0];

    RtlInitUnicodeString(&jensenValue,
                         L"Jensen"
                         );

    RtlZeroMemory(jensenTable, sizeof(RTL_QUERY_REGISTRY_TABLE)*2);
    jensenTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT
                            | RTL_QUERY_REGISTRY_REQUIRED;
    jensenTable[0].Name = L"Identifier";
    jensenTable[0].EntryContext = &jensenData;
 
    if (NT_SUCCESS(RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE
                                            | RTL_REGISTRY_OPTIONAL,
                                           L"\\REGISTRY\\MACHINE\\HARDWARE"
                                           L"\\DESCRIPTION\\SYSTEM",
                                           &jensenTable[0],
                                           NULL,
                                           NULL))) {
 
        //
        // Skip past the DEC-XX Portion of the name string.
        // Be carful and make sure we have at least that much data.
        //
        if (jensenData.Length <= (sizeof(WCHAR)*6)) {
            return FALSE; 
        }
        else {
            jensenData.Length -= (sizeof(WCHAR)*6);
            jensenData.MaximumLength -= (sizeof(WCHAR)*6);
            jensenData.Buffer = (PWCHAR)&jensenBuffer[sizeof(WCHAR)*6];

            Print(DBG_SS_NOISE, ("Machine name is %ws\n", jensenData.Buffer));

            shareInterrupts = RtlEqualUnicodeString(&jensenData,
                                                    &jensenValue,
                                                    FALSE
                                                    );
       }
    }

    return shareInterrupts;
#else
    return FALSE;
#endif
}

VOID
I8xServiceParameters(
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine retrieves this driver's service parameters information
    from the registry.

Arguments:

    RegistryPath - Pointer to the null-terminated Unicode name of the
        registry path for this driver.

    KeyboardDeviceName - Pointer to the Unicode string that will receive
        the keyboard port device name.

    PointerDeviceName - Pointer to the Unicode string that will receive
        the pointer port device name.

Return Value:

    None.  As a side-effect, sets fields in DeviceExtension->Configuration.

--*/

{
    NTSTATUS                            status = STATUS_SUCCESS;
    PI8042_CONFIGURATION_INFORMATION    configuration;
    PRTL_QUERY_REGISTRY_TABLE           parameters = NULL;
    PWSTR                               path = NULL;
    ULONG                               defaultDataQueueSize = DATA_QUEUE_SIZE;
    ULONG                               defaultDebugFlags = DEFAULT_DEBUG_FLAGS;
    ULONG                               defaultIsrDebugFlags = 0L;
    ULONG                               defaultBreakOnSysRq = 1;
    ULONG                               defaultHeadless = 0;
    ULONG                               defaultReportResetErrors = 0;
    ULONG                               pollingIterations = 0;
    ULONG                               pollingIterationsMaximum = 0;
    ULONG                               resendIterations = 0;
    ULONG                               breakOnSysRq = 1;
    ULONG                               headless = 0;
    ULONG                               reportResetErrors = 0;
    ULONG                               i = 0;
    UNICODE_STRING                      parametersPath;
    USHORT                              defaultPollingIterations = I8042_POLLING_DEFAULT;
    USHORT                              defaultPollingIterationsMaximum = I8042_POLLING_MAXIMUM;
    USHORT                              defaultResendIterations = I8042_RESEND_DEFAULT;

    USHORT                              queries = 7; 

#if I8042_VERBOSE
    queries += 2;
#endif 
    
    configuration = &(Globals.ControllerData->Configuration);
    configuration->StallMicroseconds = I8042_STALL_DEFAULT;
    parametersPath.Buffer = NULL;

    configuration->SharedInterrupts = I8xDetermineSharedInterrupts();

    //
    // Registry path is already null-terminated, so just use it.
    //
    path = RegistryPath->Buffer;

    if (NT_SUCCESS(status)) {

        //
        // Allocate the Rtl query table.
        //
        parameters = ExAllocatePool(
            PagedPool,
            sizeof(RTL_QUERY_REGISTRY_TABLE) * (queries + 1)
            );

        if (!parameters) {

            Print(DBG_SS_ERROR,
                 ("%s: couldn't allocate table for Rtl query to %ws for %ws\n",
                 pFncServiceParameters,
                 pwParameters,
                 path
                 ));
            status = STATUS_UNSUCCESSFUL;

        } else {

            RtlZeroMemory(
                parameters,
                sizeof(RTL_QUERY_REGISTRY_TABLE) * (queries + 1)
                );

            //
            // Form a path to this driver's Parameters subkey.
            //
            RtlInitUnicodeString( &parametersPath, NULL );
            parametersPath.MaximumLength = RegistryPath->Length +
                (wcslen(pwParameters) * sizeof(WCHAR) ) + sizeof(UNICODE_NULL);

            parametersPath.Buffer = ExAllocatePool(
                PagedPool,
                parametersPath.MaximumLength
                );

            if (!parametersPath.Buffer) {

                Print(DBG_SS_ERROR,
                     ("%s: Couldn't allocate string for path to %ws for %ws\n",
                     pFncServiceParameters,
                     pwParameters,
                     path
                     ));
                status = STATUS_UNSUCCESSFUL;

            }
        }
    }

    if (NT_SUCCESS(status)) {

        //
        // Form the parameters path.
        //

        RtlZeroMemory(
            parametersPath.Buffer,
            parametersPath.MaximumLength
            );
        RtlAppendUnicodeToString(
            &parametersPath,
            path
            );
        RtlAppendUnicodeToString(                             
            &parametersPath,
            pwParameters
            );

        Print(DBG_SS_INFO,
             ("%s: %ws path is %ws\n",
             pFncServiceParameters,
             pwParameters,
             parametersPath.Buffer
             ));

        //
        // Gather all of the "user specified" information from
        // the registry.
        //
        parameters[i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = pwResendIterations;
        parameters[i].EntryContext = &resendIterations;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &defaultResendIterations;
        parameters[i].DefaultLength = sizeof(USHORT);

        parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = pwPollingIterations;
        parameters[i].EntryContext = &pollingIterations;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &defaultPollingIterations;
        parameters[i].DefaultLength = sizeof(USHORT);

        parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = pwPollingIterationsMaximum;
        parameters[i].EntryContext = &pollingIterationsMaximum;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &defaultPollingIterationsMaximum;
        parameters[i].DefaultLength = sizeof(USHORT);

        parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = L"BreakOnSysRq";
        parameters[i].EntryContext = &breakOnSysRq;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &defaultBreakOnSysRq;
        parameters[i].DefaultLength = sizeof(ULONG);

        parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = L"Headless";
        parameters[i].EntryContext = &headless;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &defaultHeadless;
        parameters[i].DefaultLength = sizeof(ULONG);

        parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = L"ReportResetErrors";
        parameters[i].EntryContext = &reportResetErrors;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &defaultReportResetErrors;
        parameters[i].DefaultLength = sizeof(ULONG);

#if I8042_VERBOSE
        parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = pwDebugFlags;
        parameters[i].EntryContext = &Globals.DebugFlags;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &defaultDebugFlags;
        parameters[i].DefaultLength = sizeof(ULONG);

        parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = pwIsrDebugFlags;
        parameters[i].EntryContext = &Globals.IsrDebugFlags;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &defaultIsrDebugFlags;
        parameters[i].DefaultLength = sizeof(ULONG);
        // 16
#endif // I8042_VERBOSE

        // ASSERT( ((LONG) i) == (queries-1) );

        status = RtlQueryRegistryValues(
            RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
            parametersPath.Buffer,
            parameters,
            NULL,
            NULL
            );

        if (!NT_SUCCESS(status)) {

            Print(DBG_SS_INFO,
                 ("%s: RtlQueryRegistryValues failed with 0x%x\n",
                 pFncServiceParameters,
                 status
                 ));
        }
    }

    if (!NT_SUCCESS(status)) {

        //
        // Go ahead and assign driver defaults.
        //
        configuration->ResendIterations = defaultResendIterations;
        configuration->PollingIterations = defaultPollingIterations;
        configuration->PollingIterationsMaximum =
            defaultPollingIterationsMaximum;

    }
    else {
        configuration->ResendIterations = (USHORT) resendIterations;
        configuration->PollingIterations = (USHORT) pollingIterations;
        configuration->PollingIterationsMaximum =
            (USHORT) pollingIterationsMaximum;

        if (breakOnSysRq) {
            Globals.BreakOnSysRq = TRUE;
            Print(DBG_SS_NOISE, ("breaking on SysRq\n"));
        }
        else {
            Print(DBG_SS_NOISE, ("NOT breaking on SysRq\n"));
        }

        if (headless) {
            Globals.Headless = TRUE;
            Print(DBG_SS_NOISE, ("headless\n"));
        }
        else {
            Globals.Headless = FALSE;
            Print(DBG_SS_NOISE, ("NOT headless\n"));
        }

        if (reportResetErrors) {
            Globals.ReportResetErrors = TRUE;
            Print(DBG_SS_NOISE,
                  ("reporting reset errors to system event log\n"));
        }
        else {
            Globals.ReportResetErrors = FALSE;
            Print(DBG_SS_NOISE,
                  ("NOT reporting reset errors to system event log\n"));
        }
    }

    Print(DBG_SS_NOISE, ("I8xServiceParameters results..\n"));

    Print(DBG_SS_NOISE,
          ("\tDebug flags are 0x%x, Isr Debug flags are 0x%x\n",
          Globals.DebugFlags,
          Globals.IsrDebugFlags
          ));

    Print(DBG_SS_NOISE,
         ("\tInterrupts are %s shared\n",
         configuration->SharedInterrupts ? "" : "not"
         ));
    Print(DBG_SS_NOISE,
         ("\tStallMicroseconds = %d\n",
         configuration->StallMicroseconds
         ));
    Print(DBG_SS_NOISE,
         (pDumpDecimal,
         pwResendIterations,
         configuration->ResendIterations
         ));
    Print(DBG_SS_NOISE,
         (pDumpDecimal,
         pwPollingIterations,
         configuration->PollingIterations
         ));
    Print(DBG_SS_NOISE,
         (pDumpDecimal,
         pwPollingIterationsMaximum,
         configuration->PollingIterationsMaximum
         ));

    //
    // Free the allocated memory before returning.
    //

    if (parametersPath.Buffer)
        ExFreePool(parametersPath.Buffer);
    if (parameters)
        ExFreePool(parameters);
}

VOID
I8xTransmitControllerCommand(
    IN PI8042_TRANSMIT_CCB_CONTEXT TransmitCCBContext
    )

/*++

Routine Description:

    This routine reads the 8042 Controller Command Byte, performs an AND
    or OR operation using the specified ByteMask, and writes the resulting
    ControllerCommandByte.

Arguments:

    Context - Pointer to a structure containing the HardwareDisableEnableMask,
        the AndOperation boolean, and the ByteMask to apply to the Controller
        Command Byte before it is rewritten.

Return Value:

    None.  Status is returned in the Context structure.

--*/

{
    UCHAR  controllerCommandByte;
    UCHAR  verifyCommandByte;
    PIO_ERROR_LOG_PACKET errorLogEntry;

    Print(DBG_BUFIO_TRACE, ("I8xTransmitControllerCommand: enter\n"));

    //
    // Get the current Controller Command Byte.
    //
    TransmitCCBContext->Status =
        I8xGetControllerCommand(
            TransmitCCBContext->HardwareDisableEnableMask,
            &controllerCommandByte
            );

    if (!NT_SUCCESS(TransmitCCBContext->Status)) {
        return;
    }

    Print(DBG_BUFIO_INFO,
         ("I8xTransmitControllerCommand: current CCB 0x%x\n",
         controllerCommandByte
         ));

    //
    // Diddle the desired bits in the Controller Command Byte.
    //

    if (TransmitCCBContext->AndOperation) {
        controllerCommandByte &= TransmitCCBContext->ByteMask;
    }
    else {
        controllerCommandByte |= TransmitCCBContext->ByteMask;
    }

    //
    // Write the new Controller Command Byte.
    //

PutControllerCommand:
    TransmitCCBContext->Status =
        I8xPutControllerCommand(controllerCommandByte);

    Print(DBG_BUFIO_INFO,
         ("I8xTransmitControllerCommand: new CCB 0x%x\n",
         controllerCommandByte
         ));

    //
    // Verify that the new Controller Command Byte really got written.
    //

    TransmitCCBContext->Status =
        I8xGetControllerCommand(
            TransmitCCBContext->HardwareDisableEnableMask,
            &verifyCommandByte
            );

    if (verifyCommandByte == 0xff) {
        KeStallExecutionProcessor(50);
        //
        // Stall for about a second
        //
        goto PutControllerCommand;
    }

    if (NT_SUCCESS(TransmitCCBContext->Status)
        && (verifyCommandByte != controllerCommandByte)
        && (verifyCommandByte != ACKNOWLEDGE) 
//        && (verifyCommandByte != KEYBOARD_RESET)
        ) {
        TransmitCCBContext->Status = STATUS_DEVICE_DATA_ERROR;

        Print(DBG_BUFIO_ERROR,
              ("I8xTransmitControllerCommand:  wrote 0x%x, failed verification (0x%x)\n",
              (int) controllerCommandByte,
              (int) verifyCommandByte
              ));

        if (KeGetCurrentIrql() <= DISPATCH_LEVEL) {
            //
            // Log an error only if we are running at dispatch or below
            //
            errorLogEntry = (PIO_ERROR_LOG_PACKET)
                IoAllocateErrorLogEntry((Globals.KeyboardExtension       ?
                                         Globals.KeyboardExtension->Self :
                                         Globals.MouseExtension->Self),
                                        sizeof(IO_ERROR_LOG_PACKET)
                                        + (4 * sizeof(ULONG))
                                        );
    
            if (errorLogEntry != NULL) {
    
                errorLogEntry->ErrorCode = I8042_CCB_WRITE_FAILED;
                errorLogEntry->DumpDataSize = 4 * sizeof(ULONG);
                errorLogEntry->SequenceNumber = 0;
                errorLogEntry->MajorFunctionCode = 0;
                errorLogEntry->IoControlCode = 0;
                errorLogEntry->RetryCount = 0;
                errorLogEntry->UniqueErrorValue = 80;
                errorLogEntry->FinalStatus = TransmitCCBContext->Status;
                errorLogEntry->DumpData[0] = KBDMOU_COULD_NOT_SEND_PARAM;
                errorLogEntry->DumpData[1] = DataPort;
                errorLogEntry->DumpData[2] = I8042_WRITE_CONTROLLER_COMMAND_BYTE;
                errorLogEntry->DumpData[3] = controllerCommandByte;
    
                IoWriteErrorLogEntry(errorLogEntry);
            }
        }
    }

    Print(DBG_BUFIO_TRACE, ("I8xTransmitControllerCommand: exit\n"));

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\pnpi8042\i8042prt.h ===
/*

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    i8042prt.h

Abstract:

    These are the structures and defines that are used in the
    Intel i8042 port driver.

Revision History:

--*/

#ifndef _I8042PRT_
#define _I8042PRT_

#include "ntddk.h"
#include <ntddkbd.h>
#include <ntddmou.h>
#include <ntdd8042.h>
#include "kbdmou.h"
#include "wmilib.h"
#include "i8042cfg.h"
#include "i8042str.h"

#define I8042_POOL_TAG (ULONG) '2408'
#undef ExAllocatePool
#define ExAllocatePool(type, size) \
            ExAllocatePoolWithTag (type, size, I8042_POOL_TAG)

#if DBG
#ifdef PAGED_CODE
#undef PAGED_CODE
#endif

#define PAGED_CODE() \
    if (KeGetCurrentIrql() > APC_LEVEL) { \
    KdPrint(( "8042: Pageable code called at IRQL %d\n", KeGetCurrentIrql() )); \
        DbgBreakPoint(); \
        }
#endif

#define MOUSE_RECORD_ISR     DBG
#define I8042_VERBOSE        DBG 
#define KEYBOARD_RECORD_INIT DBG

#define DELAY_SYSBUTTON_COMPLETION 1

//
// Define the timer values.
//


#define I8042_ASYNC_NO_TIMEOUT -1
#define I8042_ASYNC_TIMEOUT     3

//
// Define the default number of entries in the input data queue.
//

#define DATA_QUEUE_SIZE    100

//
// Define the default stall value.
//

#define I8042_STALL_DEFAULT      50

//
// Custom resource type used when pruning the fdo's resource lists
// 
#define I8X_REMOVE_RESOURCE 0xef

//
// Length (including NULL) of the PnP string identifying the mouse
//
// New style mice will respond with MSHxxxx
// Old style mice will respond with pnpxxxx
// 
#define MOUSE_PNPID_LENGTH 8

//
// Number of times to poll the hardware (determined empiracally)
//
#define I8X_POLL_ITERATIONS_MAX (11200)

//
// Define the default "sync time" used to determine when the start
// of a new mouse data packet is expected.  The value is in units
// of 100 nanoseconds.
//

#define MOUSE_SYNCH_PACKET_100NS 10000000UL // 1 second, in 100 ns units

//
// Time, in ms, for the mouse to respond to the query ID sequence
//
#define WHEEL_DETECTION_TIMEOUT 1500

//
// Default for how to initialize the mouse
//
#define I8X_INIT_POLLED_DEFAULT 0


#define IOCTL_INTERNAL_MOUSE_RESET  \
            CTL_CODE(FILE_DEVICE_MOUSE, 0x0FFF, METHOD_NEITHER, FILE_ANY_ACCESS)

#define FAILED_RESET_STOP           (0)
#define FAILED_RESET_PROCEED        (1)
#define FAILED_RESET_PROCEED_ALWAYS (2)

#define FAILED_RESET_DEFAULT        FAILED_RESET_PROCEED
#define STR_FAILED_RESET            L"KeyboardFailedReset"

//
// Define booleans.
//
#define WAIT_FOR_ACKNOWLEDGE    TRUE
#define NO_WAIT_FOR_ACKNOWLEDGE FALSE
#define AND_OPERATION           TRUE
#define OR_OPERATION            FALSE
#define ENABLE_OPERATION        TRUE
#define DISABLE_OPERATION       FALSE

//
// Default keyboard scan code mode.
//

#define KEYBOARD_SCAN_CODE_SET 0x01

//
// Default number of function keys, number of LED indicators, and total
// number of keys located on the known types of keyboard.
//

#define NUM_KNOWN_KEYBOARD_TYPES                   8
#define KEYBOARD_TYPE_DEFAULT                      4
#define KEYBOARD_INDICATORS_DEFAULT                0

typedef struct _KEYBOARD_TYPE_INFORMATION {
    USHORT NumberOfFunctionKeys;
    USHORT NumberOfIndicators;
    USHORT NumberOfKeysTotal;
} KEYBOARD_TYPE_INFORMATION, *PKEYBOARD_TYPE_INFORMATION;

static const
KEYBOARD_TYPE_INFORMATION KeyboardTypeInformation[NUM_KNOWN_KEYBOARD_TYPES] = {
    {10, 3, 84},     // PC/XT 83- 84-key keyboard (and compatibles)
    {12, 3, 102},    // Olivetti M24 102-key keyboard (and compatibles)
    {10, 3, 84},     // All AT type keyboards (84-86 keys)
    {12, 3, 101},    // Enhanced 101- or 102-key keyboards (and compatibles)
    {12, 3, 101},    // 5:
    {12, 3, 101},    // 6:
    { 0, 0, 0},      // 7: Japanese Keyboard
    { 0, 0, 0}       // 8: Korean keyboard
};

typedef struct _KEYBOARD_OEM_INFORMATION {
    KEYBOARD_ID               KeyboardId;
    KEYBOARD_TYPE_INFORMATION KeyboardTypeInformation;
} KEYBOARD_OEM_INFORMATION, *PKEYBOARD_OEM_INFORMATION;

//
// Keyboard hardware OEM id. by MSKK
//
#define MSFT    0x0 // Microsoft
#define AX      0x1 // AX consortium
#define TOSHIBA 0x2 // TOSHIBA
#define EPSON   0x4 // EPSON
#define FJ      0x5 // Fujitsu
#define IBMJ    0x7 // IBM Japan
#define DECJ    0x8 // DEC Japan
#define PANA    0xA // Panasonic
#define NEC     0xD // NEC

#define FE_SUBTYPE(SubType,OemId) ((SubType)|((OemId<<4)))

#define IBM02_KEYBOARD(Id)     (((Id).Type == 0x7) && ((Id).Subtype == FE_SUBTYPE(3,MSFT)))
#define AX_KEYBOARD(Id)        (((Id).Type == 0x7) && ((Id).Subtype == FE_SUBTYPE(1,MSFT)))
#define OYAYUBI_KEYBOARD(Id)   (((Id).Type == 0x7) && ((Id).Subtype == FE_SUBTYPE(2,FJ)))
#define DEC_KANJI_KEYBOARD(Id) (((Id).Type == 0x7) && (((Id).Subtype == FE_SUBTYPE(1,DECJ)) || \
                                                       ((Id).Subtype == FE_SUBTYPE(2,DECJ))))

static const
KEYBOARD_OEM_INFORMATION KeyboardFarEastOemInformation[] = {
    {{7, FE_SUBTYPE(1,MSFT)}, {12,3,101}}, // PC/AT 101 Enhanced Japanese Keyboard
    {{7, FE_SUBTYPE(1,MSFT)}, {12,4,105}}, // AX standard Japanese keyboard
    {{7, FE_SUBTYPE(2,MSFT)}, {12,3,106}}, // PC/AT 106 Japanese Keyboard
    {{7, FE_SUBTYPE(3,MSFT)}, {12,3,106}}, // IBM 5576-002 keyboard
    {{7, FE_SUBTYPE(1,MSFT)}, {12,4,105}}, // AX consortium compatible keyboard
    {{7, FE_SUBTYPE(2,FJ  )}, {12,3,108}}, // Fujitsu OYAYUBI shift keyboard
    {{7, FE_SUBTYPE(1,DECJ)}, {17,3,111}}, // DEC LK411 (Ansi layout) keyboard
    {{7, FE_SUBTYPE(2,DECJ)}, {17,3,112}}, // DEC LK411 (JIS layout) keyboard
    {{8, FE_SUBTYPE(3,MSFT)}, {12,3,101}}, // PC/AT 101 Enhanced Korean Keyboard (A)
    {{8, FE_SUBTYPE(4,MSFT)}, {12,3,101}}, // PC/AT 101 Enhanced Korean Keyboard (B)
    {{8, FE_SUBTYPE(5,MSFT)}, {12,3,101}}, // PC/AT 101 Enhanced Korean Keyboard (C)
    {{8, FE_SUBTYPE(6,MSFT)}, {12,3,103}}, // PC/AT 103 Enhanced Korean Keyboard
    {{0, FE_SUBTYPE(0,MSFT)}, { 0,0,  0}}  // Array terminator
};


//
// Minimum, maximum, and default values for keyboard typematic rate and delay.
//

#define KEYBOARD_TYPEMATIC_RATE_MINIMUM     2
#define KEYBOARD_TYPEMATIC_RATE_MAXIMUM    30
#define KEYBOARD_TYPEMATIC_RATE_DEFAULT    30
#define KEYBOARD_TYPEMATIC_DELAY_MINIMUM  250
#define KEYBOARD_TYPEMATIC_DELAY_MAXIMUM 1000
#define KEYBOARD_TYPEMATIC_DELAY_DEFAULT  250


//
// Define the 8042 mouse status bits.
//
#define LEFT_BUTTON        0x01
#define RIGHT_BUTTON       0x02
#define MIDDLE_BUTTON      0x04
#define BUTTON_4           0x10
#define BUTTON_5           0x20

#define X_DATA_SIGN        0x10
#define Y_DATA_SIGN        0x20
#define X_OVERFLOW         0x40
#define Y_OVERFLOW         0x80

#define MOUSE_SIGN_OVERFLOW_MASK (X_DATA_SIGN | Y_DATA_SIGN | X_OVERFLOW | Y_OVERFLOW)

//
// Define the maximum positive and negative values for mouse motion.
//

#define MOUSE_MAXIMUM_POSITIVE_DELTA 0x000000FF
#define MOUSE_MAXIMUM_NEGATIVE_DELTA 0xFFFFFF00

//
// Default number of buttons and sample rate for the i8042 mouse.
//

#define MOUSE_NUMBER_OF_BUTTONS     2
#define MOUSE_SAMPLE_RATE           60

//
// Define the mouse resolution specifier.  Note that (2**MOUSE_RESOLUTION)
// specifies counts-per-millimeter.  Counts-per-centimeter is
// (counts-per-millimeter * 10).
//

#define MOUSE_RESOLUTION            3

//
// Define the maximum number of resets we allow without success before we
// give up and consider the mouse dead
//
#define MOUSE_RESET_TIMEOUT         (1500 * 1000 * 10)

#define MOUSE_RESETS_MAX             3
#define MOUSE_RESENDS_MAX            4
#define MOUSE_RESET_RESENDS_MAX      10

//
// Defines and macros for Globals.ControllerData->HardwarePresent.
//
#define KEYBOARD_HARDWARE_PRESENT               0x001
#define MOUSE_HARDWARE_PRESENT                  0x002
#define BALLPOINT_HARDWARE_PRESENT              0x004
#define WHEELMOUSE_HARDWARE_PRESENT             0x008
#define DUP_KEYBOARD_HARDWARE_PRESENT           0x010
#define DUP_MOUSE_HARDWARE_PRESENT              0x020
#define KEYBOARD_HARDWARE_INITIALIZED           0x100
#define MOUSE_HARDWARE_INITIALIZED              0x200
#define FIVE_BUTTON_HARDWARE_PRESENT           0x1000
#define PHANTOM_KEYBOARD_HARDWARE_REPORTED     0x4000
#define PHANTOM_MOUSE_HARDWARE_REPORTED        0x8000

#define TEST_HARDWARE_PRESENT(bits)         \
 ((Globals.ControllerData->HardwarePresent & (bits)) == (bits))
#define CLEAR_HW_FLAGS(bits) (Globals.ControllerData->HardwarePresent &= ~(bits))
#define SET_HW_FLAGS(bits) (Globals.ControllerData->HardwarePresent |= (bits))
#define KEYBOARD_PRESENT()      TEST_HARDWARE_PRESENT(KEYBOARD_HARDWARE_PRESENT)
#define MOUSE_PRESENT()         TEST_HARDWARE_PRESENT(MOUSE_HARDWARE_PRESENT) 
#define WHEEL_PRESENT()         TEST_HARDWARE_PRESENT(WHEELMOUSE_HARDWARE_PRESENT)
#define FIVE_PRESENT()         TEST_HARDWARE_PRESENT(FIVE_BUTTON_HARDWARE_PRESENT)
#define KEYBOARD_INITIALIZED() \
                            TEST_HARDWARE_PRESENT(KEYBOARD_HARDWARE_INITIALIZED)
#define MOUSE_INITIALIZED()    \
                            TEST_HARDWARE_PRESENT(MOUSE_HARDWARE_INITIALIZED) 
#define KEYBOARD_STARTED() (Globals.KeyboardExtension          ?    \
                            Globals.KeyboardExtension->Started :    \
                            FALSE)                                  
#define MOUSE_STARTED() (Globals.MouseExtension          ?    \
                         Globals.MouseExtension->Started :    \
                         FALSE)                                  
#define CLEAR_MOUSE_PRESENT() CLEAR_HW_FLAGS(MOUSE_HARDWARE_INITIALIZED | MOUSE_HARDWARE_PRESENT | WHEELMOUSE_HARDWARE_PRESENT)
#define CLEAR_KEYBOARD_PRESENT() CLEAR_HW_FLAGS(KEYBOARD_HARDWARE_INITIALIZED | KEYBOARD_HARDWARE_PRESENT)

#define KBD_POWERED_UP_STARTED      0x00000001
#define KBD_POWERED_DOWN            0x00000002
#define MOU_POWERED_UP_STARTED      0x00000010
#define MOU_POWERED_DOWN            0x00000020
#define KBD_POWERED_UP_SUCCESS      0x00000100
#define KBD_POWERED_UP_FAILURE      0x00000200
#define MOU_POWERED_UP_SUCCESS      0x00001000
#define MOU_POWERED_UP_FAILURE      0x00002000

#define WORK_ITEM_QUEUED            0x10000000

#define MOU_POWER_FLAGS             (MOU_POWERED_DOWN       |   \
                                     MOU_POWERED_UP_STARTED |   \
                                     MOU_POWERED_UP_SUCCESS)

#define KBD_POWER_FLAGS             (KBD_POWERED_DOWN       |   \
                                     KBD_POWERED_UP_STARTED |   \
                                     KBD_POWERED_UP_SUCCESS)

#define SET_PWR_FLAGS(bits)     (Globals.PowerFlags |= (bits))
#define CMP_PWR_FLAGS(bits)     ((Globals.PowerFlags & (bits)) == (bits))
#define TEST_PWR_FLAGS(bits)    (Globals.PowerFlags & (bits))

#define KEYBOARD_POWERED_DOWN_SUCCESS() CMP_PWR_FLAGS(KBD_POWERED_DOWN)
#define MOUSE_POWERED_DOWN_SUCCESS()    CMP_PWR_FLAGS(MOU_POWERED_DOWN)

#define KEYBOARD_POWERED_UP_SUCCESSFULLY()  SET_PWR_FLAGS(KBD_POWERED_UP_SUCCESS)
#define MOUSE_POWERED_UP_SUCCESSFULLY()     SET_PWR_FLAGS(MOU_POWERED_UP_SUCCESS)

#define KEYBOARD_POWERED_UP_FAILURE()  SET_PWR_FLAGS(KBD_POWERED_UP_FAILURE)
#define MOUSE_POWERED_UP_FAILURE()     SET_PWR_FLAGS(MOU_POWERED_UP_FAILURE)

#define KEYBOARD_POWERED_UP_FAILED()  CMP_PWR_FLAGS(KBD_POWERED_UP_FAILURE)
#define MOUSE_POWERED_UP_FAILED()     CMP_PWR_FLAGS(MOU_POWERED_UP_FAILURE)

#define KEYBOARD_POWERED_UP_SUCCESS() CMP_PWR_FLAGS(KBD_POWERED_UP_SUCCESS)
#define MOUSE_POWERED_UP_SUCCESS()    CMP_PWR_FLAGS(MOU_POWERED_UP_SUCCESS)
#define A_POWERED_UP_SUCCEEDED() \
            TEST_PWR_FLAGS(KBD_POWERED_UP_SUCCESS | MOU_POWERED_UP_SUCCESS)
                    
#define IS_KEYBOARD(_devExt_) ((_devExt_)->IsKeyboard)
#define IS_MOUSE(_devExt_) ((_devExt_)->IsKeyboard == FALSE)

#define IS_LEVEL_TRIGGERED(_devExt_)   ((_devExt_)->InterruptDescriptor.Flags == CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE)
#define IS_EDGE_TRIGGERED(_devExt_)    ((_devExt_)->InterruptDescriptor.Flags == CM_RESOURCE_INTERRUPT_LATCHED)

#define DEVICE_START_SUCCESS(status)    (NT_SUCCESS((status)) || ((status) == STATUS_DEVICE_NOT_CONNECTED))

#define INIT_FIRST_TIME         0x00000001
#define INIT_KEYBOARD           0x00010000
#define INIT_MOUSE              0x00020000

#if _X86_
    #define WRAP_IO_FUNCTIONS 0
#else
    #define WRAP_IO_FUNCTIONS 1
#endif

typedef
UCHAR
(*PI8X_READ_UCHAR) (
    PUCHAR Address
    );

typedef
VOID
(*PI8X_WRITE_UCHAR) (
    PUCHAR Address,
    UCHAR Byte
    );

//
// Define macros for performing I/O on the 8042 command/status and data
// registers.
//
#define I8X_PUT_COMMAND_BYTE(Address, Byte)                                  \
    Globals.I8xWriteXxxUchar(Address, (UCHAR) Byte)
    
#define I8X_PUT_DATA_BYTE(Address, Byte)                                     \
    Globals.I8xWriteXxxUchar(Address, (UCHAR) Byte)
    
#define I8X_GET_STATUS_BYTE(Address)                                         \
    Globals.I8xReadXxxUchar(Address)
    
#define I8X_GET_DATA_BYTE(Address)                                           \
    Globals.I8xReadXxxUchar(Address)
    
#define I8X_WRITE_CMD_TO_MOUSE( )                                            \
    I8xPutByteAsynchronous(                                                  \
        (CCHAR) CommandPort,                                                 \
        (UCHAR) I8042_WRITE_TO_AUXILIARY_DEVICE                              \
        ) 

#define I8X_MOUSE_COMMAND( Byte )                                            \
    I8xPutByteAsynchronous(                                                  \
        (CCHAR) DataPort,                                                    \
        (UCHAR) Byte                                                         \
        )
        
//
// Define commands to the 8042 controller.
//
#define I8042_READ_CONTROLLER_COMMAND_BYTE      0x20
#define I8042_WRITE_CONTROLLER_COMMAND_BYTE     0x60
#define I8042_DISABLE_MOUSE_DEVICE              0xA7
#define I8042_ENABLE_MOUSE_DEVICE               0xA8
#define I8042_AUXILIARY_DEVICE_TEST             0xA9
#define I8042_KEYBOARD_DEVICE_TEST              0xAB
#define I8042_DISABLE_KEYBOARD_DEVICE           0xAD
#define I8042_ENABLE_KEYBOARD_DEVICE            0xAE
#define I8042_WRITE_TO_AUXILIARY_DEVICE         0xD4

//
// Define the 8042 Controller Command Byte.
//

#define CCB_ENABLE_KEYBOARD_INTERRUPT 0x01
#define CCB_ENABLE_MOUSE_INTERRUPT    0x02
#define CCB_DISABLE_KEYBOARD_DEVICE   0x10
#define CCB_DISABLE_MOUSE_DEVICE      0x20
#define CCB_KEYBOARD_TRANSLATE_MODE   0x40


//
// Define the 8042 Controller Status Register bits.
//

#define OUTPUT_BUFFER_FULL       0x01
#define INPUT_BUFFER_FULL        0x02
#define MOUSE_OUTPUT_BUFFER_FULL 0x20

//
// Define the 8042 responses.
//
#define ACKNOWLEDGE         0xFA
#define RESEND              0xFE
#define FAILURE             0xFC

//
// Define commands to the keyboard (through the 8042 data port).
//

#define SET_KEYBOARD_INDICATORS           0xED
#define SELECT_SCAN_CODE_SET              0xF0
#define READ_KEYBOARD_ID                  0xF2
#define SET_KEYBOARD_TYPEMATIC            0xF3
#define SET_ALL_TYPEMATIC_MAKE_BREAK      0xFA
#define KEYBOARD_RESET                    0xFF

//
// Define the keyboard responses.
//

#define KEYBOARD_COMPLETE_SUCCESS 0xAA
#define KEYBOARD_COMPLETE_FAILURE 0xFC
#define KEYBOARD_BREAK_CODE       0xF0
#define KEYBOARD_DEBUG_HOTKEY_ENH 0x37 // SysReq scan code for Enhanced Keyboard
#define KEYBOARD_DEBUG_HOTKEY_AT  0x54 // SysReq scan code for 84-key Keyboard

//
// Define keyboard power scan codes
//
#define KEYBOARD_POWER_CODE        0x5E
#define KEYBOARD_SLEEP_CODE        0x5F
#define KEYBOARD_WAKE_CODE         0x63

/*
Power event 
        Set1:   Make = E0, 5E   Break = E0, DE
        Set2:   Make = E0, 37   Break = E0, F0, 37
Sleep event 
        Set1:   Make = E0, 5F   Break = E0, DF
        Set2:   Make = E0, 3F   Break = E0, F0, 3F
Wake event 
        Set1:   Make = E0, 63   Break = E0, E3
        Set2:   Make = E0, 5E   Break = E0, F0, 5E
*/

//
// Define commands to the mouse (through the 8042 data port).
//

#define SET_MOUSE_RESOLUTION              0xE8
#define SET_MOUSE_SAMPLING_RATE           0xF3
#define MOUSE_RESET                       0xFF
#define ENABLE_MOUSE_TRANSMISSION         0xF4
#define SET_MOUSE_SCALING_1TO1            0xE6
#define READ_MOUSE_STATUS                 0xE9
#define GET_DEVICE_ID                     0xF2

//
// Define the mouse responses.
//

#define MOUSE_COMPLETE      0xAA
#define MOUSE_ID_BYTE       0x00
#define WHEELMOUSE_ID_BYTE  0x03
#define FIVEBUTTON_ID_BYTE  0x04

//
// Define the i8042 controller input/output ports.
//

typedef enum _I8042_IO_PORT_TYPE {
    DataPort = 0,
    CommandPort,
    MaximumPortCount

} I8042_IO_PORT_TYPE;

//
// Define the device types attached to the i8042 controller.
//

typedef enum _I8042_DEVICE_TYPE {
    ControllerDeviceType,
    KeyboardDeviceType,
    MouseDeviceType,
    UndefinedDeviceType
} I8042_DEVICE_TYPE;

//
// Intel i8042 configuration information.
//
#ifdef FE_SB
#define KBD_IDENTIFIER  0x10
#endif

typedef struct _I8042_CONFIGURATION_INFORMATION {

    //
    // Bus interface type.
    //
    INTERFACE_TYPE InterfaceType;

    //
    // Bus Number.
    //
    ULONG BusNumber;

    //
    // The port/register resources used by this device.
    //
    CM_PARTIAL_RESOURCE_DESCRIPTOR PortList[MaximumPortCount];
    ULONG PortListCount;

    //
    // The highest IRQL between the two potential interrupts
    //
    KIRQL InterruptSynchIrql;

    //
    // Number of retries allowed.
    //
    USHORT ResendIterations;

    //
    // Number of polling iterations allowed.
    //
    USHORT PollingIterations;

    //
    // Maximum number of polling iterations allowed.
    //
    USHORT PollingIterationsMaximum;

    //
    // Maximum number of times to check the Status register in
    // the ISR before deciding the interrupt is spurious.
    //
    USHORT PollStatusIterations;

    //
    // Microseconds to stall in KeStallExecutionProcessor calls.
    //
    USHORT StallMicroseconds;

    //
    // Tracking resolution on the mouse
    //
    // USHORT MouseResolution;

    //
    // Flag that indicates whether floating point context should be saved.
    //
    BOOLEAN FloatingSave;

    //
    // Flag indicating if the interrupts should be shared
    //
    BOOLEAN SharedInterrupts;

#ifdef FE_SB
    //
    // Detected Device Identifier
    //
    WCHAR OverrideKeyboardIdentifier[KBD_IDENTIFIER];
#endif

} I8042_CONFIGURATION_INFORMATION, *PI8042_CONFIGURATION_INFORMATION;

//
// Define the common portion of the keyboard/mouse device extension.
//
typedef struct COMMON_DATA {
    //
    // Pointer back to the this extension's device object.
    //
    PDEVICE_OBJECT      Self;
 
    PKINTERRUPT InterruptObject;

    //
    // The spin lock guarding the object's ISR
    //
    KSPIN_LOCK          InterruptSpinLock;         
 
    //
    // The top of the stack before this filter was added.  AKA the location
    // to which all IRPS should be directed.
    //
    PDEVICE_OBJECT      TopOfStack;
 
    //
    // "THE PDO"  (ejected by root)
    //
    PDEVICE_OBJECT      PDO;
 
    //
    // Remove tracking
    //
    IO_REMOVE_LOCK RemoveLock;

    //
    // The IRP sent to the device to power it to D0
    //
    PIRP OutstandingPowerIrp;

    //
    // Current power state that the device is in
    //
    DEVICE_POWER_STATE PowerState;

    //
    // Current power state that the system in in
    //
    SYSTEM_POWER_STATE SystemState;

    POWER_ACTION ShutdownType; 

    // 
    // Number of input data items currently in the InputData queue
    //
    ULONG InputCount;
      
    //
    // Reference count for number of keyboard enables.
    //
    LONG EnableCount;

    //
    // Timer used to retry the ISR DPC routine when the class
    // driver is unable to consume all the port driver's data.
    //
    KTIMER DataConsumptionTimer;
 
    //
    // DPC queue for completion of requests that fail by exceeding
    // the maximum number of retries.
    //
    KDPC RetriesExceededDpc;

    //
    // DPC queue for logging overrun and internal driver errors.
    //
    KDPC ErrorLogDpc;

    //
    // DPC queue for command timeouts.
    //
    KDPC TimeOutDpc;

    //
    // DPC queue for resetting the device 
    //
    KDPC ResetDpc;

    //
    // Request sequence number (used for error logging).
    //
    ULONG SequenceNumber;
  
    //
    // Class connection data.
    //
    CONNECT_DATA ConnectData;

    //
    // WMI Information
    //
    WMILIB_CONTEXT WmiLibInfo;

    //
    // Current output buffer being written to the device
    //
    OUTPUT_PACKET CurrentOutput;

    //
    // Translated resource descriptor for the interrupt
    //
    CM_PARTIAL_RESOURCE_DESCRIPTOR InterruptDescriptor;

    PNP_DEVICE_STATE PnpDeviceState;

    //
    // Current resend count.
    //
    SHORT ResendCount;

    //
    // Indicates whether it is okay to log overflow errors.
    //
    BOOLEAN OkayToLogOverflow;

    BOOLEAN Initialized;

    BOOLEAN IsIsrActivated;

    BOOLEAN IsKeyboard;

    //
    // Has it been started?
    // Has the device been manually removed?
    //
    BOOLEAN Started;

} *PCOMMON_DATA;

#define GET_COMMON_DATA(ext) ((PCOMMON_DATA) ext)
#define MANUALLY_REMOVED(ext) ((ext)->PnpDeviceState & PNP_DEVICE_REMOVED)

//
// Define the keyboard portion of the port device extension.
//
typedef struct _PORT_KEYBOARD_EXTENSION {

    // 
    // Data in common with the mouse extension;
    //
    struct COMMON_DATA;
     
    //
    // bitfield which represents the power capabilities of the kb
    //
    UCHAR PowerCaps;

    //
    // A newly found power event which we need to inform the PO system of
    //
    UCHAR PowerEvent;
    
    UCHAR CurrentScanCode, LastScanCode;

    //
    // Irp to be completed when one the power buttons is pressed
    //
    PIRP SysButtonEventIrp;

    //
    // DPC to handle power button events (updating our caps and completing
    // previous IOCTL requests)
    //
    KDPC SysButtonEventDpc; 

    //
    // Spin lock to guard the cancel routine and the IOCTL handler
    //
    KSPIN_LOCK SysButtonSpinLock;

    //
    // Symbolic name for the interface
    //
    UNICODE_STRING SysButtonInterfaceName; 

    //
    // Keyboard attributes.
    //
    KEYBOARD_ATTRIBUTES KeyboardAttributes;

    //
    // Extended keyboard ID
    //
    KEYBOARD_ID_EX KeyboardIdentifierEx;

    //
    // Initial values of keyboard typematic rate and delay.
    //
    KEYBOARD_TYPEMATIC_PARAMETERS KeyRepeatCurrent;

    //
    // Current indicator (LED) setting.
    //
    KEYBOARD_INDICATOR_PARAMETERS KeyboardIndicators;

    //
    // Keyboard ISR DPC queue.
    //
    KDPC KeyboardIsrDpc;

    //
    // Keyboard ISR DPC recall queue.
    //
    KDPC KeyboardIsrDpcRetry;

    //
    // Used by the ISR and the ISR DPC (in I8xDpcVariableOperation calls)
    // to control processing by the ISR DPC.
    //
    LONG DpcInterlockKeyboard;
 
    //
    // Start of the port keyboard input data queue (really a circular buffer).
    //
    PKEYBOARD_INPUT_DATA InputData;
 
    //
    // Insertion pointer for keyboard InputData.
    //
    PKEYBOARD_INPUT_DATA DataIn;
 
    //
    // Removal pointer for keyboard InputData.
    //
    PKEYBOARD_INPUT_DATA DataOut;
 
    //
    // Points one input packet past the end of the InputData buffer.
    //
    PKEYBOARD_INPUT_DATA DataEnd;
 
    //
    // Current keyboard input packet.
    //
    KEYBOARD_INPUT_DATA CurrentInput;
 
    //
    // Current keyboard scan input state.
    //
    KEYBOARD_SCAN_STATE CurrentScanState;
  
    //
    // Routine to call after the mouse is reset
    //
    PI8042_KEYBOARD_INITIALIZATION_ROUTINE InitializationHookCallback;
    
    //
    // Routine to call when a byte is received via the interrupt
    //
    PI8042_KEYBOARD_ISR IsrHookCallback;
     
    //
    // Context variable for InitializationRoutine
    //
    PVOID HookContext;

    //
    // Crash by key combination.
    //
    // CrashFlags used to be Dump1Keys
    //
    LONG CrashFlags;          // CrashDump call first press keys flag
                              //  7 6 5 4 3 2 1 0 bit
                              //    | | |   | | +--- Right Shift Key
                              //    | | |   | +----- Right Ctrl Key
                              //    | | |   +------- Right Alt Key
                              //    | | +----------- Left Shift Key
                              //    | +------------- Left Ctrl Key
                              //    +--------------- Left Alt Key
    //
    // CurrentCrashFlags used to be Dump2Key
    //
    LONG CurrentCrashFlags;           

    //
    // Key to be pressed 2 times to cause the crash dump
    //
    UCHAR CrashScanCode; 

    //
    // Alternate to CrashScanCode, used only for the print screen scan codes(s)
    //
    UCHAR CrashScanCode2;

    //
    // If FAILED_RESET_PROCEED, ignore the fact that the keyboard did not send
    // an ACK in response to the reset command and still look for the 
    // success/failure code in the i8042 controller.
    //
    UCHAR FailedReset;

} PORT_KEYBOARD_EXTENSION, *PPORT_KEYBOARD_EXTENSION;

//
// Define the structure used to enable the mouse
//
typedef struct _ENABLE_MOUSE { 
    KDPC Dpc;
    KTIMER Timer;

    USHORT    Count;
    BOOLEAN   FirstTime;
    BOOLEAN   Enabled;
} ENABLE_MOUSE;

typedef enum _INTERNAL_RESET_STATE {
    InternalContinueTimer = 0x0,
    InternalMouseReset,
    InternalPauseOneSec
} INTERNAL_RESET_STATE;

typedef enum _ISR_RESET_STATE {
    IsrResetNormal = 0x0,
    IsrResetStopResetting,

    IsrResetQueueReset,
    IsrResetPause 
} ISR_RESET_STATE;

typedef enum _ISR_DPC_CAUSE {
    IsrDpcCauseKeyboardWriteComplete = 1,
    IsrDpcCauseMouseWriteComplete,
    IsrDpcCauseMouseResetComplete
} ISR_DPC_CAUSE;

typedef struct _RESET_MOUSE {
    KDPC Dpc;
    KTIMER Timer;

    ISR_RESET_STATE IsrResetState;

} RESET_MOUSE;

#define I8X_MOUSE_INIT_COUNTERS(mouExt)                                     \
    {                                                                       \
        (mouExt)->ResetCount = (mouExt)->FailedCompleteResetCount = -1;     \
        (mouExt)->ResendCount = 0;                                          \
    }

//
// Define the mouse portion of the port device extension.
//
typedef struct _PORT_MOUSE_EXTENSION {

    struct COMMON_DATA;

    //
    // Mouse attributes.
    //
    MOUSE_ATTRIBUTES MouseAttributes;

    //
    // Reset IRP used in StartIO
    //
    PIRP ResetIrp;

    //
    // Mouse ISR DPC queue.
    //
    KDPC MouseIsrDpc;
 
    //
    // Mouse ISR DPC recall queue.
    //
    KDPC MouseIsrDpcRetry;

    //
    // Mouse ISR reset queue.
    //
    KDPC MouseIsrResetDpc;

    //
    // These two structs represent different methods of initialization.  
    //
    union {
        RESET_MOUSE  ResetMouse; 
        ENABLE_MOUSE EnableMouse;
    };

    //
    // Used by the ISR and the ISR DPC (in I8xDpcVariableOperation calls)
    // to control processing by the ISR DPC.
    //
    LONG DpcInterlockMouse;
 
    //
    // Start of the port mouse input data queue (really a circular buffer).
    //
    PMOUSE_INPUT_DATA InputData;
 
    //
    // Insertion pointer for mouse InputData.
    //
    PMOUSE_INPUT_DATA DataIn;
 
    //
    // Removal pointer for mouse InputData.
    //
    PMOUSE_INPUT_DATA DataOut;
 
    //
    // Points one input packet past the end of the InputData buffer.
    //
    PMOUSE_INPUT_DATA DataEnd;
 
    //
    // Current mouse input packet.                   (24 bytes)
    //
    MOUSE_INPUT_DATA CurrentInput;
 
    //
    // Current mouse input state.
    //
    MOUSE_STATE InputState;
    MOUSE_RESET_SUBSTATE InputResetSubState;
 
    MOUSE_RESET_SUBSTATE WorkerResetSubState;

    //
    // Count the number of times we have reset and failed
    //
    UCHAR ResetCount;

    //
    // Count the number of times we have reset and not gone through the entire
    // reset process
    //
    UCHAR FailedCompleteResetCount;

    //
    // Current mouse sign and overflow data.
    //
    UCHAR CurrentSignAndOverflow;
 
    //
    // Previous mouse sign and overflow data.
    //
    UCHAR PreviousSignAndOverflow;

    //
    // The tick count (since system boot) at which the mouse last interrupted.
    // Retrieved via KeQueryTickCount.  Used to determine whether a byte of
    // the mouse data packet has been lost.  Allows the driver to synch
    // up with the true mouse input state.
    //
    LARGE_INTEGER PreviousTick;
 
    //
    // Number of interval timer ticks to wait before deciding that the
    // next mouse interrupt is for the start of a new packet.  Used to
    // synch up again if a byte of the mouse packet gets lost.
    //
    ULONG SynchTickCount;

    //
    // The amount of time that is valid between sending a set sampling sequence
    //  (of 20, 40, and 60) and receiving the first pnp id packet from the mouse
    //
    // Expressed in terms of system ticks
    //
    ULONG WheelDetectionTimeout;

    //
    // Contains a multi sz list of pnp mouse IDs to check for a wheel mouse
    //
    UNICODE_STRING WheelDetectionIDs;

    //
    // Plug n Play ID received from the mouse during reset
    //
    WCHAR PnPID[MOUSE_PNPID_LENGTH];

    //
    // An upper filter callback hook to call when processing mouse bytes
    //
    PI8042_MOUSE_ISR IsrHookCallback;
     
    //
    // Context variable for IsrHookCallback
    //
    PVOID HookContext;

    PVOID NotificationEntry;

    //
    // List of sample rates to send to the mouse during a reset
    //
    PUCHAR SampleRates;

    ULONG MouseResetStallTime;

    //
    // Index into the SampleRates array
    //
    UCHAR SampleRatesIndex;

    //
    // Previous mouse button data.
    //
    UCHAR PreviousButtons;

    //
    // Statue to transition to after the last sample rate from SampleRates has
    // been sent to the mouse
    //
    USHORT PostSamplesState;

    //
    // Keep track of last byte of data received from mouse so we can detect
    // the two-byte string which indicates a potential reset
    //
    UCHAR LastByteReceived;

    //
    // Tracking resolution on the mouse
    //
    UCHAR Resolution;
 
    //
    // One of 3 states that determines whether we should try and detect the wheel
    // on the mouse or not
    //
    UCHAR EnableWheelDetection;
 
    //
    // Skip button detection if it overridden in the registry.  
    //
    UCHAR NumberOfButtonsOverride;

    //
    // If 0, then initalize the mouse via the interrupt, if non zero, initialize
    // the mouse via polling
    //
    UCHAR InitializePolled;

#if MOUSE_RECORD_ISR
    ULONG RecordHistoryFlags;
    ULONG RecordHistoryCount;
    ULONG RecordHistoryState;
#endif

} PORT_MOUSE_EXTENSION, *PPORT_MOUSE_EXTENSION;

//
// controller specific data used by both devices
//
typedef struct _CONTROLLER_DATA { 

    //
    // Indicate which hardware is actually present (keyboard and/or mouse).
    //
    ULONG HardwarePresent;
    
    //
    // IOCTL synchronization object
    //
    PCONTROLLER_OBJECT ControllerObject;

    //
    // Port configuration information.
    //
    I8042_CONFIGURATION_INFORMATION Configuration; 

    //
    // Timer used to timeout i8042 commands.
    //
    KTIMER CommandTimer;

    //
    // Spin lock to guard freeing of bytes written to device
    //
    KSPIN_LOCK BytesSpinLock;

    //
    // Spin lock to guard powering the devices back up
    //
    KSPIN_LOCK PowerSpinLock;

    //
    // Default buffer to use for a write to a device if the request <=4 bytes
    // (avoid lots of tiny sized allocs)
    //
    UCHAR DefaultBuffer[4];

    //
    // Timer count used by the command time out routine.
    //
    LONG TimerCount;

    //
    // Interrupt to synchronize against
    //
    // IN PKINTERRUPT HigherInterrupt;

    //
    // The mapped addresses for this device's registers.
    //
    PUCHAR DeviceRegisters[MaximumPortCount];

    //
    // List of ports in IRP_MN_FILTER_RESOURCE_REQUIREMENTS
    //
    PHYSICAL_ADDRESS KnownPorts[MaximumPortCount];

    ULONG KnownPortsCount;

#if DBG
    ULONG CurrentIoControlCode;
#endif

} CONTROLLER_DATA, *PCONTROLLER_DATA;

#define POST_BUTTONDETECT_COMMAND                 (SET_MOUSE_RESOLUTION)
#define POST_BUTTONDETECT_COMMAND_SUBSTATE        (ExpectingSetResolutionDefaultACK)

#define POST_WHEEL_DETECT_COMMAND                 (GET_DEVICE_ID)
#define POST_WHEEL_DETECT_COMMAND_SUBSTATE        (ExpectingGetDeviceId2ACK)

#define ExpectingPnpId                            (I8042ReservedMinimum+  2)
#define PostWheelDetectState                      (I8042ReservedMinimum+  3)
#define PostEnableWheelState                      (I8042ReservedMinimum+  4)

#define QueueingMouseReset                        (I8042ReservedMinimum+100)
#define MouseResetFailed                          (I8042ReservedMinimum+101)

#define ExpectingLegacyPnpIdByte2_Make            (I8042ReservedMinimum+200)
#define ExpectingLegacyPnpIdByte2_Break           (I8042ReservedMinimum+201)
#define ExpectingLegacyPnpIdByte3_Make            (I8042ReservedMinimum+202)
#define ExpectingLegacyPnpIdByte3_Break           (I8042ReservedMinimum+203)
#define ExpectingLegacyPnpIdByte4_Make            (I8042ReservedMinimum+204)
#define ExpectingLegacyPnpIdByte4_Break           (I8042ReservedMinimum+205)
#define ExpectingLegacyPnpIdByte5_Make            (I8042ReservedMinimum+206)
#define ExpectingLegacyPnpIdByte5_Break           (I8042ReservedMinimum+207)
#define ExpectingLegacyPnpIdByte6_Make            (I8042ReservedMinimum+208)
#define ExpectingLegacyPnpIdByte6_Break           (I8042ReservedMinimum+209)
#define ExpectingLegacyPnpIdByte7_Make            (I8042ReservedMinimum+210)
#define ExpectingLegacyPnpIdByte7_Break           (I8042ReservedMinimum+211)

#define QueueingMousePolledReset                  (I8042ReservedMinimum+300)

#define KeepOldSubState                           (I8042ReservedMinimum+400)

typedef struct _GLOBALS {
 
#if I8042_VERBOSE
    //
    // Flags:  Bit field for enabling debugging print statements
    // Level:  Legacy way of controllign debugging statements
    //
    ULONG DebugFlags;
    ULONG IsrDebugFlags;
#endif 

    //
    // Pointer to controller specific data that both extensions may access it
    //
    PCONTROLLER_DATA ControllerData;

    //
    // The two possible extensions that can be created
    //
    PPORT_MOUSE_EXTENSION MouseExtension;
    PPORT_KEYBOARD_EXTENSION KeyboardExtension;

    //
    // Generic read and write functions.  Since we can use both memory and port
    // type resources, we must use a function pointer to abstract access to them.
    //
    PI8X_READ_UCHAR I8xReadXxxUchar;

    PI8X_WRITE_UCHAR I8xWriteXxxUchar;

    // 
    // Path to the driver's entry in the registry
    //
    UNICODE_STRING RegistryPath;

    //
    // Keep track of the number of AddDevice and StartDevice calls.  Want to 
    // postpone h/w initialization until the last StartDevice is received
    // (due to some h/w which freezes if initialized more than once)
    //
    LONG AddedKeyboards;
    LONG AddedMice;
    LONG StartedDevices;
    ULONG PowerFlags;
    
    //
    // Provide mutual exclusion during dispatch functions
    //
    FAST_MUTEX DispatchMutex; 

    //
    // Set during the first H/W intialization to indicate that the register
    // addresses must be unmapped when the driver is unloaded.  It is also used 
    // when calling I8X_PUT_COMMAND_BYTE, I8X_PUT_DATA_BYTE, I8X_GET_STATUS_BYTE,
    // I8X_GET_DATA_BYTE.
    //
    BOOLEAN RegistersMapped;

    BOOLEAN BreakOnSysRq;

    BOOLEAN Headless;

    BOOLEAN ReportResetErrors;

} GLOBALS;

extern GLOBALS Globals;

#define RECORD_INIT               0x00000001
#define RECORD_RESUME_FROM_POWER  0x00000002
#define RECORD_DPC_RESET          0x00000004
#define RECORD_DPC_RESET_POLLED   0x00000008
#define RECORD_HW_PROFILE_CHANGE  0x00000010

#if MOUSE_RECORD_ISR
typedef struct _MOUSE_STATE_RECORD {
    USHORT InputResetSubState;
    USHORT InputState;
    UCHAR  LastByte;
    UCHAR  Reserved;
    UCHAR  Byte;
    UCHAR  Command;
    LARGE_INTEGER Time;
} MOUSE_STATE_RECORD, *PMOUSE_STATE_RECORD;

extern PMOUSE_STATE_RECORD IsrStateHistory;
extern PMOUSE_STATE_RECORD CurrentIsrState;
extern PMOUSE_STATE_RECORD IsrStateHistoryEnd;
extern ULONG               IsrStateCount;

#define RECORD_ISR_STATE(devExt, byte, lastbyte, time)                  \
    if ((devExt->RecordHistoryFlags & devExt->RecordHistoryState)) {    \
        if (CurrentIsrState >= IsrStateHistoryEnd) {                    \
            CurrentIsrState = IsrStateHistory;                          \
            RtlFillMemory(CurrentIsrState, sizeof(MOUSE_STATE_RECORD), 0x88);  \
            CurrentIsrState++;                                          \
        }                                                               \
        CurrentIsrState->InputState = (USHORT) devExt->InputState;      \
        CurrentIsrState->InputResetSubState = (USHORT) devExt->InputResetSubState;    \
        CurrentIsrState->Byte = byte;                                   \
        CurrentIsrState->LastByte = lastbyte;                           \
        CurrentIsrState->Time = time;                                   \
        CurrentIsrState++;                                              \
    }

#define RECORD_ISR_STATE_COMMAND(devExt, command)                     \
    if ((devExt->RecordHistoryFlags & devExt->RecordHistoryState))    \
            CurrentIsrState->Command = command;                       

#define RECORD_ISR_STATE_TRANSITION(devExt, state)                          \
    if ((devExt->RecordHistoryFlags & devExt->RecordHistoryState)) {        \
        if (CurrentIsrState >= IsrStateHistoryEnd) CurrentIsrState = IsrStateHistory; \
        RtlFillMemory(CurrentIsrState, sizeof(MOUSE_STATE_RECORD), 0xFF);   \
        CurrentIsrState->Time.LowPart  = state;                             \
        CurrentIsrState++;                                                  \
    }

#define SET_RECORD_STATE(devExt, state)                                 \
    {                                                                   \
        if (IsrStateHistory) devExt->RecordHistoryState |= (state);     \
        RECORD_ISR_STATE_TRANSITION(devExt, state);                     \
    }

#define CLEAR_RECORD_STATE(devExt) devExt->RecordHistoryState = 0x0;

#define SET_RECORD_FLAGS(devExt, flags) if (IsrStateHistory) devExt->RecordHistoryFlags |= (flags)
#define CLEAR_RECORD_FLAGS(devExt, flags) devExt->RecordHistoryFlags &= ~(flags)

#else

#define RECORD_ISR_STATE(devExt, byte, lastbyte, time) 
#define RECORD_ISR_STATE_COMMAND(devExt, command)
#define SET_RECORD_STATE(devExt, state)
#define CLEAR_RECORD_STATE(devExt)
#define SET_RECORD_FLAGS(devExt, flags) 
#define CLEAN_RECORD_FLAGS(devExt, flags) 

#endif // MOUSE_RECORD_ISR

typedef struct _I8X_KEYBOARD_WORK_ITEM {
    PIO_WORKITEM  Item;
    ULONG MakeCode;
    PIRP Irp;
} I8X_KEYBOARD_WORK_ITEM, *PI8X_KEYBOARD_WORK_ITEM;

typedef struct _I8X_MOUSE_RESET_INFO {
    PPORT_MOUSE_EXTENSION MouseExtension;
    INTERNAL_RESET_STATE  InternalResetState;
} I8X_MOUSE_RESET_INFO, * PI8X_MOUSE_RESET_INFO;

//
// Define the port TransmitControllerCommandByte context structure.
//
typedef struct _I8042_TRANSMIT_CCB_CONTEXT {
    IN ULONG HardwareDisableEnableMask;
    IN BOOLEAN AndOperation;
    IN UCHAR ByteMask;
    OUT NTSTATUS Status;
} I8042_TRANSMIT_CCB_CONTEXT, *PI8042_TRANSMIT_CCB_CONTEXT;

//
// Define the port InitializeDataQueue context structure.
//
typedef struct _I8042_INITIALIZE_DATA_CONTEXT {
    IN PVOID DeviceExtension;
    IN CCHAR DeviceType;
} I8042_INITIALIZE_DATA_CONTEXT, *PI8042_INITIALIZE_DATA_CONTEXT;

//
// Define the port Get/SetDataQueuePointer context structures.
//
typedef struct _GET_DATA_POINTER_CONTEXT {
    IN PVOID DeviceExtension;
    IN CCHAR DeviceType;
    OUT PVOID DataIn;
    OUT PVOID DataOut;
    OUT ULONG InputCount;
} GET_DATA_POINTER_CONTEXT, *PGET_DATA_POINTER_CONTEXT;

typedef struct _SET_DATA_POINTER_CONTEXT {
    IN PVOID DeviceExtension;
    IN CCHAR DeviceType;
    IN ULONG InputCount;
    IN PVOID DataOut;
} SET_DATA_POINTER_CONTEXT, *PSET_DATA_POINTER_CONTEXT;

typedef struct _POWER_UP_WORK_ITEM {
    WORK_QUEUE_ITEM Item;
    PIRP MousePowerIrp;
    PIRP KeyboardPowerIrp;
} POWER_UP_WORK_ITEM, *PPOWER_UP_WORK_ITEM;

//
// Define the port timer context structure.
//
typedef struct _TIMER_CONTEXT {
    IN PDEVICE_OBJECT DeviceObject;
    IN PLONG TimerCounter;
    OUT LONG NewTimerCount;
} TIMER_CONTEXT, *PTIMER_CONTEXT;

//
// Define the device InitiateOutput context structure.
//
typedef struct INITIATE_OUTPUT_CONTEXT {
    IN PDEVICE_OBJECT DeviceObject;
    IN PUCHAR Bytes;
    IN ULONG ByteCount;
} INITIATE_OUTPUT_CONTEXT, *PINITIATE_OUTPUT_CONTEXT;

//
// Statically allocate the (known) scancode-to-indicator-light mapping.
// This information is returned by the
// IOCTL_KEYBOARD_QUERY_INDICATOR_TRANSLATION device control request.
//

#define KEYBOARD_NUMBER_OF_INDICATORS              3

static const INDICATOR_LIST IndicatorList[KEYBOARD_NUMBER_OF_INDICATORS] = {
        {0x3A, KEYBOARD_CAPS_LOCK_ON},
        {0x45, KEYBOARD_NUM_LOCK_ON},
        {0x46, KEYBOARD_SCROLL_LOCK_ON}};

//
// Define the context structure and operations for I8xDpcVariableOperation.
//
typedef enum _OPERATION_TYPE {
        IncrementOperation,
        DecrementOperation,
        WriteOperation,
        ReadOperation
} OPERATION_TYPE;

typedef struct _VARIABLE_OPERATION_CONTEXT {
    IN PLONG VariableAddress;
    IN OPERATION_TYPE Operation;
    IN OUT PLONG NewValue;
} VARIABLE_OPERATION_CONTEXT, *PVARIABLE_OPERATION_CONTEXT;

//
// Define the actions to be taked on processing a system button
//
typedef enum _SYS_BUTTON_ACTION {
    NoAction =0,
    SendAction,
    UpdateAction
} SYS_BUTTON_ACTION;

//
// Function prototypes.
//

// begin_i8042dep
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

BOOLEAN
I8xDetermineSharedInterrupts(
    VOID
    );

VOID
I8xDrainOutputBuffer(
    IN PUCHAR DataAddress,
    IN PUCHAR CommandAddress
    );

VOID
I8xGetByteAsynchronous(
    IN CCHAR DeviceType,
    OUT PUCHAR Byte
    );

NTSTATUS
I8xGetBytePolled(
    IN CCHAR DeviceType,
    OUT PUCHAR Byte
    );

VOID
I8xGetDataQueuePointer(
    IN PGET_DATA_POINTER_CONTEXT Context
    );

VOID
I8xInitializeHardware(
    NTSTATUS *KeyboardStatus,
    NTSTATUS *MouseStatus,
    ULONG    InitFlags 
    );

NTSTATUS
I8xInitializeHardwareAtBoot(
    NTSTATUS *KeyboardStatus,
    NTSTATUS *MouseStatus
    );

VOID
I8xLogError(
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS ErrorCode,
    IN ULONG UniqueErrorValue,
    IN NTSTATUS FinalStatus,
    IN PULONG DumpData,
    IN ULONG DumpCount
    );

VOID
I8xPutByteAsynchronous(
    IN CCHAR PortType,
    IN UCHAR Byte
    );

NTSTATUS
I8xPutBytePolled(
    IN CCHAR PortType,
    IN BOOLEAN WaitForAcknowledge,
    IN CCHAR AckDeviceType,
    IN UCHAR Byte
    );

VOID
I8xReinitializeHardware (
    PPOWER_UP_WORK_ITEM Item
    );

VOID
I8xServiceParameters(
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
I8xGetControllerCommand(
    IN ULONG HardwareDisableEnableMask,
    OUT PUCHAR Byte
    );

NTSTATUS
I8xPutControllerCommand(
    IN UCHAR Byte
    );

NTSTATUS
I8xToggleInterrupts(
    BOOLEAN State
    );

NTSTATUS
I8xPutControllerCommand(
    IN UCHAR Byte
    );

VOID
I8xTransmitControllerCommand(
    IN PI8042_TRANSMIT_CCB_CONTEXT TransmitCCBContext
    );
// end_i8042dep

// begin_i8042cmn
NTSTATUS
I8xClose (
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    );

VOID
I8042CompletionDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ISR_DPC_CAUSE IsrDpcCause
    );

IO_ALLOCATION_ACTION
I8xControllerRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          MapRegisterBase,
    IN PVOID          Context
    );

NTSTATUS
I8xCreate (
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    );

VOID
I8xDecrementTimer(
    IN PTIMER_CONTEXT Context
    );

VOID
I8xDpcVariableOperation(
    IN  PVOID Context
    );

VOID
I8042ErrorLogDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
I8xFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
I8xInitializeDataQueue(
    IN PI8042_INITIALIZE_DATA_CONTEXT InitializeDataContext
    );

VOID
I8xInitiateOutputWrapper(
    IN PINITIATE_OUTPUT_CONTEXT InitiateContext 
    );

VOID
I8xInitiateIo(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
I8xDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
I8xInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
I8042RetriesExceededDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

BOOLEAN
I8xSanityCheckResources(
    VOID
    );

NTSTATUS
I8xSendIoctl(
    PDEVICE_OBJECT      Target,
    ULONG               Ioctl,
    PVOID               InputBuffer,
    ULONG               InputBufferLength
    );

VOID
I8xSetDataQueuePointer(
    IN PSET_DATA_POINTER_CONTEXT Context
    );

VOID
I8xStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
I8xCompletePendedRequest(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    ULONG_PTR Information,
    NTSTATUS Status
    );

VOID
I8xFinishResetRequest(
    PPORT_MOUSE_EXTENSION MouseExtension,
    BOOLEAN Failed,
    BOOLEAN RaiseIrql,
    BOOLEAN CancelTimer
    );

VOID
I8042TimeOutDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );
// end_i8042cmn

// begin_kbddep
UCHAR
I8xConvertTypematicParameters(
    IN USHORT Rate,
    IN USHORT Delay
    );

NTSTATUS
I8xInitializeKeyboard(
    IN PPORT_KEYBOARD_EXTENSION KeyboardExtension
    );

NTSTATUS
I8xKeyboardConfiguration(
    IN PPORT_KEYBOARD_EXTENSION KeyboardExtension,
    IN PCM_RESOURCE_LIST ResourceList
    );

BOOLEAN
I8042KeyboardInterruptService(
    IN PKINTERRUPT Interrupt,
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
I8xKeyboardServiceParameters(
    IN PUNICODE_STRING          RegistryPath,
    IN PPORT_KEYBOARD_EXTENSION KeyboardExtension
    );

VOID
I8xQueueCurrentKeyboardInput(
    IN PDEVICE_OBJECT DeviceObject
    );
// end_kbddep

// begin_kbdcmn
VOID
I8042KeyboardIsrDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

BOOLEAN
I8xWriteDataToKeyboardQueue(
    IN PPORT_KEYBOARD_EXTENSION KeyboardExtension,
    IN PKEYBOARD_INPUT_DATA InputData
    );
// end_kbdcmn

// begin_kbdpnp
NTSTATUS
I8xKeyboardConnectInterrupt(
    PPORT_KEYBOARD_EXTENSION KeyboardExtension
    );

NTSTATUS
I8xKeyboardInitializeHardware(
    PPORT_KEYBOARD_EXTENSION    KeyboardExtension,
    PPORT_MOUSE_EXTENSION       MouseExtension
    );

VOID
I8xKeyboardRemoveDevice(
    PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
I8xKeyboardStartDevice(
    IN OUT PPORT_KEYBOARD_EXTENSION KeyboardExtension,
    IN PCM_RESOURCE_LIST ResourceList
    );
// end_kbdpnp

// begin_moucmn
VOID
I8042MouseIsrDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

BOOLEAN
I8xWriteDataToMouseQueue(
    IN PPORT_MOUSE_EXTENSION MouseExtension,
    IN PMOUSE_INPUT_DATA InputData
    );
// end_moucmn

// begin_moudep
NTSTATUS
I8xMouseConfiguration(
    IN PPORT_MOUSE_EXTENSION MouseExtension,
    IN PCM_RESOURCE_LIST ResourceList
    );

VOID
MouseCopyWheelIDs(
    PUNICODE_STRING Destination,
    PUNICODE_STRING Source
    );

NTSTATUS
I8xMouseEnableTransmission(
    IN PPORT_MOUSE_EXTENSION MouseExtension
    );

NTSTATUS
I8xTransmitByteSequence(
    PUCHAR Bytes,
    ULONG* UniqueErrorValue,
    ULONG* ErrorCode,
    ULONG* DumpData,
    ULONG* DumpCount
    );

NTSTATUS
I8xGetBytePolledIterated(
    IN CCHAR DeviceType,
    OUT PUCHAR Byte,
    ULONG Attempts
    );

NTSTATUS
I8xFindWheelMouse(
    IN PPORT_MOUSE_EXTENSION MouseExtension
    );

NTSTATUS
I8xInitializeMouse(
    IN PPORT_MOUSE_EXTENSION MouseExension
    );

BOOLEAN
I8042MouseInterruptService(
    IN PKINTERRUPT Interrupt,
    IN PVOID Context
    );

NTSTATUS
I8xQueryNumberOfMouseButtons(
    OUT PUCHAR          NumberOfMouseButtons
    );

NTSTATUS
I8xResetMouse(
    PPORT_MOUSE_EXTENSION MouseExtension
    );

VOID
I8xResetMouseFailed(
    PPORT_MOUSE_EXTENSION MouseExtension
    );

VOID
I8xSendResetCommand (
    PPORT_MOUSE_EXTENSION MouseExtension
    );

VOID
I8xMouseServiceParameters(
    IN PUNICODE_STRING       RegistryPath,
    IN PPORT_MOUSE_EXTENSION MouseExtension
    );

VOID
I8xQueueCurrentMouseInput(
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
I8xVerifyMousePnPID(
    PPORT_MOUSE_EXTENSION   MouseExtension,
    PWSTR                   MouseID
    );
// end_moudep

// begin_moupnp
NTSTATUS
I8xMouseConnectInterruptAndEnable(
    PPORT_MOUSE_EXTENSION MouseExtension,
    BOOLEAN Reset
    );

NTSTATUS
I8xMouseInitializeHardware(
    PPORT_KEYBOARD_EXTENSION    KeyboardExtension,
    PPORT_MOUSE_EXTENSION       MouseExtension
    );

NTSTATUS
I8xProfileNotificationCallback(
    IN PHWPROFILE_CHANGE_NOTIFICATION NotificationStructure,
    PPORT_MOUSE_EXTENSION MouseExtension
    );

VOID
I8xMouseRemoveDevice(
    PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
I8xMouseStartDevice(
    PPORT_MOUSE_EXTENSION MouseExtension,
    IN PCM_RESOURCE_LIST ResourceList
    );

BOOLEAN
I8xMouseEnableSynchRoutine(
    IN PPORT_MOUSE_EXTENSION    MouseExtension
    );

VOID
I8xMouseEnableDpc(
    IN PKDPC                    Dpc,
    IN PPORT_MOUSE_EXTENSION    MouseExtension,
    IN PVOID                    SystemArg1, 
    IN PVOID                    SystemArg2
    );

VOID 
I8xIsrResetDpc(
    IN PKDPC                    Dpc,
    IN PPORT_MOUSE_EXTENSION    MouseExtension,
    IN ULONG                    ResetPolled,
    IN PVOID                    SystemArg2
    );

VOID
I8xMouseResetTimeoutProc(
    IN PKDPC                    Dpc,
    IN PPORT_MOUSE_EXTENSION    MouseExtension,
    IN PVOID                    SystemArg1, 
    IN PVOID                    SystemArg2
    );

BOOLEAN
I8xMouseResetSynchRoutine(
    PI8X_MOUSE_RESET_INFO ResetInfo 
    );

VOID
I8xMouseInitializeInterruptWorker(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_WORKITEM   Item 
    );

VOID
I8xMouseInitializePolledWorker(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_WORKITEM   Item 
    );
// end_moupnp

// begin_pnp
NTSTATUS
I8xAddDevice (
    IN PDRIVER_OBJECT   Driver,
    IN PDEVICE_OBJECT   PDO
    );

NTSTATUS
I8xFilterResourceRequirements(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
I8xFindPortCallout(
    IN PVOID                        Context,
    IN PUNICODE_STRING              PathName,
    IN INTERFACE_TYPE               BusType,
    IN ULONG                        BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE           ControllerType,
    IN ULONG                        ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE           PeripheralType,
    IN ULONG                        PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    );

LONG
I8xManuallyRemoveDevice(
    PCOMMON_DATA CommonData
    );

NTSTATUS
I8xPnP (
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    );

NTSTATUS
I8xPnPComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    );

NTSTATUS
I8xPower (
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    );

NTSTATUS
I8xPowerUpToD0Complete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

void
I8xSetPowerFlag(
    IN ULONG Flag,
    IN BOOLEAN Set
    );

NTSTATUS
I8xRegisterDeviceInterface(
    PDEVICE_OBJECT PDO,
    CONST GUID *Guid,
    PUNICODE_STRING SymbolicName
    );

BOOLEAN
I8xRemovePort(
    IN PIO_RESOURCE_DESCRIPTOR ResDesc
    );

NTSTATUS
I8xSendIrpSynchronously (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN BOOLEAN Strict
    );

VOID
I8xUnload(
    IN PDRIVER_OBJECT DriverObject
    );
// end_pnp

// begin_sysbtn
VOID
I8xCompleteSysButtonIrp(
    PIRP Irp,
    ULONG Event,
    NTSTATUS Status
    );

#if DELAY_SYSBUTTON_COMPLETION
VOID 
I8xCompleteSysButtonEventWorker(
    IN PDEVICE_OBJECT DeviceObject,
    IN PI8X_KEYBOARD_WORK_ITEM Item
    );
#endif

NTSTATUS
I8xKeyboardGetSysButtonCaps(
    PPORT_KEYBOARD_EXTENSION KeyboardExtension,
    PIRP Irp
    );

NTSTATUS 
I8xKeyboardGetSysButtonEvent(
    PPORT_KEYBOARD_EXTENSION KeyboardExtension,
    PIRP Irp
    );

VOID
I8xKeyboardSysButtonEventDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN SYS_BUTTON_ACTION Action, 
    IN ULONG ButtonEvent 
    );

VOID
I8xSysButtonCancelRoutine( 
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
// end_sysbtn

// begin_hook
VOID
I8xMouseIsrWritePort(
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            Value
    );

VOID
I8xKeyboardIsrWritePort(
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            Value
    );

NTSTATUS 
I8xKeyboardSynchReadPort (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PUCHAR           Value,
    IN BOOLEAN          Dummy
    );

NTSTATUS 
I8xKeyboardSynchWritePort (
    IN PDEVICE_OBJECT   DeviceObject,                           
    IN UCHAR            Value,
    IN BOOLEAN          WaitForACK
    );
// end_hook

// begin_wmi
NTSTATUS
I8xSystemControl (
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    );

NTSTATUS
I8xInitWmi(
    PCOMMON_DATA CommonData
    );

NTSTATUS
I8xSetWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    );

NTSTATUS
I8xSetWmiDataItem(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            DataItemId,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    );

NTSTATUS
I8xKeyboardQueryWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            InstanceCount,
    IN OUT PULONG       InstanceLengthArray,
    IN ULONG            BufferAvail,
    OUT PUCHAR          Buffer
    );

NTSTATUS
I8xMouseQueryWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            InstanceCount,
    IN OUT PULONG       InstanceLengthArray,
    IN ULONG            BufferAvail,
    OUT PUCHAR          Buffer
    );

NTSTATUS
I8xQueryWmiRegInfo(
    IN PDEVICE_OBJECT   DeviceObject,
    OUT PULONG          RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *Pdo
    );


// end_wmi

//
// Flags to represent modifier key states 
//
#define CRASH_R_SHIFT  0x01
#define CRASH_R_CTRL   0x02
#define CRASH_R_ALT    0x04

#define CRASH_L_SHIFT  0x10
#define CRASH_L_CTRL   0x20
#define CRASH_L_ALT    0x40

#define CRASH_FIRST_TIME   0x100
#define CRASH_SECOND_TIME  0x200
#define CRASH_BOTH_TIMES (CRASH_FIRST_TIME | CRASH_SECOND_TIME)

VOID
I8xProcessCrashDump(
    PPORT_KEYBOARD_EXTENSION DeviceExtension,
    UCHAR ScanCode,
    KEYBOARD_SCAN_STATE ScanState
    );

VOID
I8xServiceCrashDump(
    IN PPORT_KEYBOARD_EXTENSION DeviceExtension,
    IN PUNICODE_STRING          RegistryPath
    );

#if defined(_X86_)
#ifndef _FJKBD_H_
#define _FJKBD_H_

//
// oyayubi-shift keyboard internal input mode value.
//
#define THUMB_NOROMAN_ALPHA_CAPSON     0x01
#define THUMB_NOROMAN_ALPHA_CAPSOFF    0x02
#define THUMB_NOROMAN_HIRAGANA         0x03
#define THUMB_NOROMAN_KATAKANA         0x04
#define THUMB_ROMAN_ALPHA_CAPSON       0x05
#define THUMB_ROMAN_ALPHA_CAPSOFF      0x06
#define THUMB_ROMAN_HIRAGANA           0x07
#define THUMB_ROMAN_KATAKANA           0x08

//
// Following functions are oyayubi-shift keyboard use only.
//
NTSTATUS
I8042SetIMEStatusForOasys(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN OUT PINITIATE_OUTPUT_CONTEXT InitiateContext
    );

ULONG
I8042QueryIMEStatusForOasys(
    IN PKEYBOARD_IME_STATUS KeyboardIMEStatus
    );

VOID
I8xKeyboardInitiateIoForOasys(
    IN PDEVICE_OBJECT DeviceObject
    );
#endif // _FJKBD_H_
#endif // _X86_

#if DBG
#define DEFAULT_DEBUG_FLAGS 0x88888808 // 0x8cc8888f
#else 
#define DEFAULT_DEBUG_FLAGS 0x0 
#endif


#if I8042_VERBOSE
//
//Debug messaging and breakpoint macros
//
#define DBG_ALWAYS                 0x00000000

#define DBG_STARTUP_SHUTDOWN_MASK  0x0000000F
#define DBG_SS_NOISE               0x00000001
#define DBG_SS_TRACE               0x00000002
#define DBG_SS_INFO                0x00000004
#define DBG_SS_ERROR               0x00000008

#define DBG_CALL_MASK              0x000000F0
#define DBG_CALL_NOISE             0x00000010
#define DBG_CALL_TRACE             0x00000020
#define DBG_CALL_INFO              0x00000040
#define DBG_CALL_ERROR             0x00000080

#define DBG_IOCTL_MASK             0x00000F00
#define DBG_IOCTL_NOISE            0x00000100
#define DBG_IOCTL_TRACE            0x00000200
#define DBG_IOCTL_INFO             0x00000400
#define DBG_IOCTL_ERROR            0x00000800

#define DBG_DPC_MASK              0x0000F000
#define DBG_DPC_NOISE             0x00001000
#define DBG_DPC_TRACE             0x00002000
#define DBG_DPC_INFO              0x00004000
#define DBG_DPC_ERROR             0x00008000

#define DBG_CREATE_CLOSE_MASK      0x000F0000
#define DBG_CC_NOISE               0x00010000
#define DBG_CC_TRACE               0x00020000
#define DBG_CC_INFO                0x00040000
#define DBG_CC_ERROR               0x00080000

#define DBG_POWER_MASK             0x00F00000
#define DBG_POWER_NOISE            0x00100000
#define DBG_POWER_TRACE            0x00200000
#define DBG_POWER_INFO             0x00400000
#define DBG_POWER_ERROR            0x00800000

#define DBG_PNP_MASK               0x0F000000
#define DBG_PNP_NOISE              0x01000000
#define DBG_PNP_TRACE              0x02000000
#define DBG_PNP_INFO               0x04000000
#define DBG_PNP_ERROR              0x08000000

#define DBG_BUFIO_MASK            0xF0000000
#define DBG_BUFIO_NOISE           0x10000000
#define DBG_BUFIO_TRACE           0x20000000
#define DBG_BUFIO_INFO            0x40000000
#define DBG_BUFIO_ERROR           0x80000000

#define DBG_KBISR_NOISE           0x00000001
#define DBG_KBISR_TRACE           0x00000002
#define DBG_KBISR_INFO            0x00000004
#define DBG_KBISR_ERROR           0x00000008

#define DBG_KBISR_STATE           0x00000010
#define DBG_KBISR_SCODE           0x00000020
#define DBG_KBISR_BREAK           0x00000040
#define DBG_KBISR_EMUL            0x00000080

#define DBG_KBISR_POWER            0x00000100

#define DBG_MOUISR_MASK            0x000F0000
#define DBG_MOUISR_NOISE           0x00010000
#define DBG_MOUISR_TRACE           0x00020000
#define DBG_MOUISR_INFO            0x00040000
#define DBG_MOUISR_ERROR           0x00080000

#define DBG_MOUISR_STATE           0x00100000
#define DBG_MOUISR_BYTE            0x00200000
#define DBG_MOUISR_RESETTING       0x00400000
#define DBG_MOUISR_ACK             0x00800000

#define DBG_MOUISR_PNPID           0x01000000
#define DBG_MOUISR_BREAK           0x02000000
// #define DBG_MOUISR_BREAK           0x04000000

#define Print(_flags_, _x_) \
            if (Globals.DebugFlags & (_flags_) || !(_flags_)) { \
                DbgPrint (pDriverName); \
                DbgPrint _x_; \
            }
#define IsrPrint(_flags_, _x_) \
            if (Globals.IsrDebugFlags & (_flags_) || !(_flags_)) { \
                DbgPrint (((ULONG)(_flags_)) >= 0x0001000 ? pIsrMou : pIsrKb); \
                DbgPrint _x_; \
            }
#define TRAP() DbgBreakPoint()

#else

#define Print(_l_,_x_)
#define IsrPrint(_l_,_x_)
#define TRAP()

#endif  // I8042_VERBOSE

static UCHAR ScanCodeToUChar[] = {
    0x00,            // Nothing
    0x00,            // Esc
    '1',
    '2',
    '3',
    '4',
    '5',
    '6',
    '7',
    '8',
    '9',
    '0',
    '-',
    '=',
    0x00,           // Backspace
    0x00,           // Tab
    'Q',
    'W',
    'E',
    'R',
    'T',
    'Y',
    'U',
    'I',
    'O',
    'P',
    '[',
    ']',
    '\\',
    0x00,            // Caps lock
    'A',
    'S',
    'D',
    'F',
    'G',
    'H',
    'I',
    'J',
    'K',
    'L',
    ';',
    '\'',
    0x00,           // Return
    0x00,           // Shift left
    'Z',
    'X',
    'C',
    'V',
    'B',
    'N',
    'M',
    ',',
    '.',
    '/'
    };


static const int ScanCodeToUCharCount = sizeof(ScanCodeToUChar)/sizeof(UCHAR);
    /*
    0x00,           // Shift right
    0x00,           // Ctrl left
    0x00,           // Alt left
    ' ', 
    0x00,           // Alt right
    0x00,           // Ctrl right
    0x00,           // num lock
    */

#define CTRL_SCANCODE          0x1d
#define LEFT_SHIFT_SCANCODE    0x2A
#define RIGHT_SHIFT_SCANCODE   0x36
#define ALT_SCANCODE           0x38
#define SCROLL_LOCK_SCANCODE   0x46

#endif // _I8042PRT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\pnpi8042\i8042str.c ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    i8042str.c

Abstract:

    These are the string constants used in the i8042prt drivers.
    Using pointers to these string allows for better memory
    utilization and more readable code

Revision History:

    08/26/96 - Initial Revision

--*/

#ifndef _I8042STR_C_
#define _I8042STR_C_

//
// Include the definitions file
//
#include "i8042prt.h"

//
// Define some of the constant strings used for the debugger
//
const   PSTR    pBus                        = I8042_BUS_A;
const   PSTR    pController                 = I8042_CONTROLLER_A;
const   PSTR    pDriverName                 = I8042_DRIVER_NAME_A;
const   PSTR    pIsrKb                      = I8042_ISR_KB_A;
const   PSTR    pIsrMou                     = I8042_ISR_MOU_A;
const   PSTR    pEnter                      = I8042_ENTER_A;
const   PSTR    pExit                       = I8042_EXIT_A;
const   PSTR    pInfo                       = I8042_INFO_A;
const   PSTR    pNumber                     = I8042_NUMBER_A;
const   PSTR    pPeripheral                 = I8042_PERIPHERAL_A;
const   PSTR    pType                       = I8042_TYPE_A;
const   PSTR    pDumpHex                    = I8042_DUMP_HEX_A;
const   PSTR    pDumpDecimal                = I8042_DUMP_DECIMAL_A;
const   PSTR    pDumpWideString             = I8042_DUMP_WIDE_STRING_A;
const   PSTR    pDumpExpecting              = I8042_DUMP_EXPECTING_A;
const   PSTR    pDumpExpectingAck           = I8042_DUMP_EXPECTING_ACK_A;
const   PSTR    pDumpExpectingIdAck         = I8042_DUMP_EXPECTING_ID_ACK_A;
const   PSTR    pFncDriverEntry             = I8042_FNC_DRIVER_ENTRY_A;
const   PSTR    pFncFindWheelMouse          = I8042_FNC_FIND_WHEEL_MOUSE_A;
const   PSTR    pFncInitializeMouse         = I8042_FNC_INITIALIZE_MOUSE_A;
const   PSTR    pFncKeyboardConfiguration   = I8042_FNC_KEYBOARD_CONFIGURATION_A;
const   PSTR    pFncMouseEnable             = I8042_FNC_MOUSE_ENABLE_A;
const   PSTR    pFncMouseInterrupt          = I8042_FNC_MOUSE_INTERRUPT_A;
const   PSTR    pFncMousePeripheral         = I8042_FNC_MOUSE_PERIPHERAL_A;
const   PSTR    pFncServiceParameters       = I8042_FNC_SERVICE_PARAMETERS_A;

//
// Define some Constant strings that the drivers uses
//
const   PWSTR   pwDebugFlags                = I8042_DEBUGFLAGS_W;
const   PWSTR   pwIsrDebugFlags             = I8042_ISRDEBUGFLAGS_W;
const   PWSTR   pwDevice                    = I8042_DEVICE_W;
const   PWSTR   pwForwardSlash              = I8042_FORWARD_SLASH_W;
const   PWSTR   pwParameters                = I8042_PARAMETERS_W;
const   PWSTR   pwResendIterations          = I8042_RESEND_ITERATIONS_W;
const   PWSTR   pwPollingIterations         = I8042_POLLING_ITERATIONS_W;
const   PWSTR   pwPollingIterationsMaximum  = I8042_POLLING_ITERATIONS_MAXIMUM_W;
const   PWSTR   pwKeyboardDataQueueSize     = I8042_KEYBOARD_DATA_QUEUE_SIZE_W;
const   PWSTR   pwMouseDataQueueSize        = I8042_MOUSE_DATA_QUEUE_SIZE_W;
const   PWSTR   pwNumberOfButtons           = I8042_NUMBER_OF_BUTTONS_W;
const   PWSTR   pwSampleRate                = I8042_SAMPLE_RATE_W;
const   PWSTR   pwMouseResolution           = I8042_MOUSE_RESOLUTION_W;
const   PWSTR   pwOverrideKeyboardType      = I8042_OVERRIDE_KEYBOARD_TYPE_W;
const   PWSTR   pwOverrideKeyboardSubtype   = I8042_OVERRIDE_KEYBOARD_SUBTYPE_W;
const   PWSTR   pwKeyboardDeviceBaseName    = I8042_KEYBOARD_DEVICE_BASE_NAME_W;
const   PWSTR   pwPointerDeviceBaseName     = I8042_POINTER_DEVICE_BASE_NAME_W;
const   PWSTR   pwMouseSynchIn100ns         = I8042_MOUSE_SYNCH_IN_100NS_W;
const   PWSTR   pwPollStatusIterations      = I8042_POLL_STATUS_ITERATIONS_W;
const   PWSTR   pwEnableWheelDetection      = I8042_ENABLE_WHEEL_DETECTION_W;
const   PWSTR   pwPowerCaps                 = I8042_POWER_CAPABILITIES_W;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\pnpi8042\kbddep.c ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    kbddep.c

Abstract:

    The initialization and hardware-dependent portions of
    the Intel i8042 port driver which are specific to the
    keyboard.

Environment:

    Kernel mode only.

Notes:

    NOTES:  (Future/outstanding issues)

    - Powerfail not implemented.

    - Consolidate duplicate code, where possible and appropriate.

Revision History:

--*/

#include "stdarg.h"
#include "stdio.h"
#include "string.h"
#include <ntddk.h>
#include <windef.h>
#include <imm.h>
#include "i8042prt.h"
#include "i8042log.h"
//
// Use the alloc_text pragma to specify the driver initialization routines
// (they can be paged out).
//
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, I8xKeyboardConfiguration)
#pragma alloc_text(PAGE, I8xInitializeKeyboard)
#pragma alloc_text(PAGE, I8xKeyboardServiceParameters)
#pragma alloc_text(PAGE, I8xServiceCrashDump)

#endif

#define BUFFER_FULL   (OUTPUT_BUFFER_FULL|MOUSE_OUTPUT_BUFFER_FULL)

#define GET_MAKE_CODE(_sc_)  (_sc_ & 0x7F)

//
// Tests for the top bit
//
#define IS_BREAK_CODE(_sc_)  (_sc_ > (UCHAR) 0x7F)
#define IS_MAKE_CODE(_sc_)   (_sc_ <= (UCHAR) 0x7F)

BOOLEAN
I8042KeyboardInterruptService(
    IN PKINTERRUPT Interrupt,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine performs the actual work.  It either processes a keystroke or
    the results from a write to the device.

Arguments:

    CallIsrContext - Contains the interrupt object and device object.

Return Value:

    TRUE if the interrupt was truly ours

--*/
{
    UCHAR scanCode, statusByte;
    PPORT_KEYBOARD_EXTENSION deviceExtension;
    KEYBOARD_SCAN_STATE *scanState;
    PKEYBOARD_INPUT_DATA input;
    ULONG i;
#ifdef FE_SB
    PKEYBOARD_ID KeyboardId;
#endif

    IsrPrint(DBG_KBISR_TRACE, ("enter\n"));

    //
    // Get the device extension.
    //
    deviceExtension = (PPORT_KEYBOARD_EXTENSION) DeviceObject->DeviceExtension;

    //
    // The interrupt will fire when we try to toggle the interrupts on the
    // controller itself.  Don't touch any of the ports in this state and the
    // toggle will succeed.
    //
    if (deviceExtension->PowerState != PowerDeviceD0) {
        return FALSE;
    }

#ifdef FE_SB
    //
    // Get a pointer to keyboard id.
    //
    KeyboardId = &deviceExtension->KeyboardAttributes.KeyboardIdentifier;
#endif

    //
    // Verify that this device really interrupted.  Check the status
    // register.  The Output Buffer Full bit should be set, and the
    // Auxiliary Device Output Buffer Full bit should be clear.
    //
    statusByte =
      I8X_GET_STATUS_BYTE(Globals.ControllerData->DeviceRegisters[CommandPort]);
    if ((statusByte & BUFFER_FULL) != OUTPUT_BUFFER_FULL) {

        //
        // Stall and then try again.  The Olivetti MIPS machine
        // sometimes gets an interrupt before the status
        // register is set.  They do this for DOS compatibility (some
        // DOS apps do things in polled mode, until they see a character
        // in the keyboard buffer at which point they expect to get
        // an interrupt???).
        //

        for (i = 0; i < (ULONG)Globals.ControllerData->Configuration.PollStatusIterations; i++) {
            KeStallExecutionProcessor(1);
            statusByte = I8X_GET_STATUS_BYTE(Globals.ControllerData->DeviceRegisters[CommandPort]);
            if ((statusByte & BUFFER_FULL) == (OUTPUT_BUFFER_FULL)) {
                break;
            }
        }

        statusByte = I8X_GET_STATUS_BYTE(Globals.ControllerData->DeviceRegisters[CommandPort]);
        if ((statusByte & BUFFER_FULL) != (OUTPUT_BUFFER_FULL)) {

            //
            // Not our interrupt.
            //
            // NOTE:  If the keyboard has not yet been "enabled", go ahead
            //        and read a byte from the data port anyway.
            //        This fixes weirdness on some Gateway machines, where
            //        we get an interrupt sometime during driver initialization
            //        after the interrupt is connected, but the output buffer
            //        full bit never gets set.
            //

            IsrPrint(DBG_KBISR_ERROR|DBG_KBISR_INFO, ("not our interrupt!\n"));

            if (deviceExtension->EnableCount == 0) {
                scanCode =
                    I8X_GET_DATA_BYTE(Globals.ControllerData->DeviceRegisters[DataPort]);
            }

            return FALSE;
        }
    }

    //
    // The interrupt is valid.  Read the byte from the i8042 data port.
    //

    I8xGetByteAsynchronous(
        (CCHAR) KeyboardDeviceType,
        &scanCode
        );

    deviceExtension->LastScanCode = deviceExtension->CurrentScanCode;
    deviceExtension->CurrentScanCode = scanCode;

    IsrPrint(DBG_KBISR_SCODE, ("scanCode 0x%x\n", scanCode));

    if (deviceExtension->IsrHookCallback) {
        BOOLEAN cont = FALSE, ret;

        ret = (*deviceExtension->IsrHookCallback)(
                  deviceExtension->HookContext,
                  &deviceExtension->CurrentInput,
                  &deviceExtension->CurrentOutput,
                  statusByte,
                  &scanCode,
                  &cont,
                  &deviceExtension->CurrentScanState
                  );

        if (!cont) {
            return ret;
        }
    }

    //
    // Take the appropriate action, depending on whether the byte read
    // is a keyboard command response or a real scan code.
    //

    switch(scanCode) {

        //
        // The keyboard controller requests a resend.  If the resend count
        // has not been exceeded, re-initiate the I/O operation.
        //

        case RESEND:

            IsrPrint(DBG_KBISR_INFO,
                  (" RESEND, retries = %d\n",
                  deviceExtension->ResendCount + 1
                  ));

            //
            // If the timer count is zero, don't process the interrupt
            // further.  The timeout routine will complete this request.
            //

            if (Globals.ControllerData->TimerCount == 0) {
                break;
            }

            //
            // Reset the timeout value to indicate no timeout.
            //

            Globals.ControllerData->TimerCount = I8042_ASYNC_NO_TIMEOUT;

            //
            // If the maximum number of retries has not been exceeded,
            //

            if ((deviceExtension->CurrentOutput.State == Idle)
                || (DeviceObject->CurrentIrp == NULL)) {

                //
                // We weren't sending a command or parameter to the hardware.
                // This must be a scan code.  I hear the Brazilian keyboard
                // actually uses this.
                //

                goto ScanCodeCase;

            } else if (deviceExtension->ResendCount
                       < Globals.ControllerData->Configuration.ResendIterations) {

                //
                // retard the byte count to resend the last byte
                //
                deviceExtension->CurrentOutput.CurrentByte -= 1;
                deviceExtension->ResendCount += 1;
                I8xInitiateIo(DeviceObject);

            } else {

                deviceExtension->CurrentOutput.State = Idle;

                KeInsertQueueDpc(
                    &deviceExtension->RetriesExceededDpc,
                    DeviceObject->CurrentIrp,
                    NULL
                    );
            }

            break;

        //
        // The keyboard controller has acknowledged a previous send.
        // If there are more bytes to send for the current packet, initiate
        // the next send operation.  Otherwise, queue the completion DPC.
        //

        case ACKNOWLEDGE:

            IsrPrint(DBG_KBISR_STATE, (": ACK, "));

            //
            // If the timer count is zero, don't process the interrupt
            // further.  The timeout routine will complete this request.
            //

            if (Globals.ControllerData->TimerCount == 0) {
                break;
            }

            //
            // We cannot clear the E0 or E1 bits b/c then the subsequent scan
            // code will be misinterpreted.  ie, the OS should have seen 0x2d 
            // with an extended bit, but instead it saw a plain 0x2d
            //
            // If the keyboard is using 0xE0 0x7A / 0xE0 0xFA as a make / break
            // code, then tough luck...bad choice, we do not support it.
            //
#if 0
            //
            // If the E0 or E1 is set, that means that this keyboard's
            // manufacturer made a poor choice for a scan code, 0x7A, whose
            // break code is 0xFA.  Thankfully, they used the E0 or E1 prefix
            // so we can tell the difference.
            //
            if (deviceExtension->CurrentInput.Flags & (KEY_E0 | KEY_E1)) {

                //
                // The following sequence can occur which requires the driver to
                // ignore the spurious keystroke
                //
                // 1 write set typematic to the device (0xF3)
                // 2 device responds with an ACK, ISR sees 0xFA
                // 3 write typematic value to the device (0x??)
                // 4 user hits an extended key (left arrow for instance),  ISR sees 0xE0
                // 5 device response with an ACK to the typematic value, ISR sees 0xFA
                //   before the actual scancode for the left arrow is sent to the ISR
                //

                //
                // Make sure we are trully not writing out data to the device
                //
                if (Globals.ControllerData->TimerCount == I8042_ASYNC_NO_TIMEOUT &&
                    deviceExtension->CurrentOutput.State == Idle) {
                    IsrPrint(DBG_KBISR_INFO,
                             ("BAD KEYBOARD:  0xFA used as a real scancode!\n"));
                    goto ScanCodeCase;
                }
                else {
                    //
                    // Spurious keystroke case.
                    //
                    // Clear the E0 / E1 flag.  the 2nd byte of the scan code will
                    // never come through b/c it was preempted by the ACK for the
                    // write to the device
                    //
                    deviceExtension->CurrentInput.Flags &= ~(KEY_E0 | KEY_E1);
                }
            }
#endif

            //
            // Reset the timeout value to indicate no timeout.
            //
            Globals.ControllerData->TimerCount = I8042_ASYNC_NO_TIMEOUT;

            //
            // Reset resend count.
            //
            deviceExtension->ResendCount = 0;

            //
            // Make sure we are writing to the device if we are going to write
            // another byte or queue a DPC
            //
            if (deviceExtension->CurrentOutput.State == SendingBytes) {
                if (deviceExtension->CurrentOutput.CurrentByte <
                    deviceExtension->CurrentOutput.ByteCount) {

                    //
                    // We've successfully sent the first byte of a 2-byte (or more)
                    // command sequence.  Initiate a send of the second byte.
                    //
                    IsrPrint(DBG_KBISR_STATE,
                          ("now initiate send of byte #%d\n",
                           deviceExtension->CurrentOutput.CurrentByte
                          ));

                    I8xInitiateIo(DeviceObject);
                }
                else {
                    //
                    // We've successfully sent all bytes in the command sequence.
                    // Reset the current state and queue the completion DPC.
                    //
                    IsrPrint(DBG_KBISR_STATE,
                          ("all bytes have been sent\n"
                          ));

                    deviceExtension->CurrentOutput.State = Idle;

                    ASSERT(DeviceObject->CurrentIrp != NULL);

                    IoRequestDpc(
                        DeviceObject,
                        DeviceObject->CurrentIrp,
                        IntToPtr(IsrDpcCauseKeyboardWriteComplete)
                        );
                }
            }
            break;

        //
        // Assume we've got a real, live scan code (or perhaps a keyboard
        // overrun code, which we treat like a scan code).  I.e., a key
        // has been pressed or released.  Queue the ISR DPC to process
        // a complete scan code sequence.
        //

        ScanCodeCase:
        default:

            IsrPrint(DBG_KBISR_SCODE, ("real scan code\n"));

            //
            // Differentiate between an extended key sequence (first
            // byte is E0, followed by a normal make or break byte), or
            // a normal make code (one byte, the high bit is NOT set),
            // or a normal break code (one byte, same as the make code
            // but the high bit is set), or the key #126 byte sequence
            // (requires special handling -- sequence is E11D459DC5).
            //
            // If there is a key detection error/overrun, the keyboard
            // sends an overrun indicator (0xFF in scan code set 1).
            // Map it to the overrun indicator expected by the Windows
            // USER Raw Input Thread.
            //

            input = &deviceExtension->CurrentInput;
            scanState = &deviceExtension->CurrentScanState;

            if (scanCode == (UCHAR) 0xFF) {
                IsrPrint(DBG_KBISR_ERROR, ("OVERRUN\n"));
                input->MakeCode = KEYBOARD_OVERRUN_MAKE_CODE;
                input->Flags = 0;
                *scanState = Normal;
            } else {

                switch (*scanState) {
                  case Normal:
                    if (scanCode == (UCHAR) 0xE0) {
                        input->Flags |= KEY_E0;
                        *scanState = GotE0;
                        IsrPrint(DBG_KBISR_STATE, ("change state to GotE0\n"));
                        break;
                    } else if (scanCode == (UCHAR) 0xE1) {
                        input->Flags |= KEY_E1;
                        *scanState = GotE1;
                        IsrPrint(DBG_KBISR_STATE, ("change state to GotE1\n"));
                        break;
                    }

                    //
                    // Fall through to the GotE0/GotE1 case for the rest of the
                    // Normal case.
                    //

                  case GotE0:
                  case GotE1:

                    if (deviceExtension->CrashFlags != 0x0) {
                        I8xProcessCrashDump(deviceExtension,
                                            scanCode,
                                            *scanState);
                    }

                    if (IS_BREAK_CODE(scanCode)) {
                        SYS_BUTTON_ACTION action;

                        //
                        // Got a break code.  Strip the high bit off
                        // to get the associated make code and set flags
                        // to indicate a break code.
                        //

                        IsrPrint(DBG_KBISR_SCODE, ("BREAK code\n"));

                        input->MakeCode = GET_MAKE_CODE(scanCode);
                        input->Flags |= KEY_BREAK;

                        if (input->Flags & KEY_E0) {
                            switch (input->MakeCode) {
                            case KEYBOARD_POWER_CODE:
                                if (deviceExtension->PowerCaps &
                                        I8042_POWER_SYS_BUTTON) {
                                    IsrPrint(DBG_KBISR_POWER, ("Send Power Button\n"));
                                    action = SendAction;
                                }
                                else {
                                    IsrPrint(DBG_KBISR_POWER, ("Update Power Button\n"));
                                    action = UpdateAction;
                                }
                                break;

                            case KEYBOARD_SLEEP_CODE:
                                if (deviceExtension->PowerCaps &
                                        I8042_SLEEP_SYS_BUTTON) {
                                    IsrPrint(DBG_KBISR_POWER, ("Send Sleep Button\n"));
                                    action = SendAction;
                                }
                                else {
                                    IsrPrint(DBG_KBISR_POWER, ("Update Sleep Button\n"));
                                    action = UpdateAction;
                                }
                                break;

                            case KEYBOARD_WAKE_CODE:
                                if (deviceExtension->PowerCaps &
                                        I8042_WAKE_SYS_BUTTON) {
                                    IsrPrint(DBG_KBISR_POWER, ("Send Wake Button\n"));
                                    action = SendAction;
                                }
                                else {
                                    IsrPrint(DBG_KBISR_POWER, ("Update Wake Button\n"));
                                    action = UpdateAction;
                                }
                                break;

                            default:
                                action = NoAction;
                                break;
                            }

                            if (action != NoAction) {
                                //
                                // Queue a DPC so that we can do the appropriate
                                // action
                                //
                                KeInsertQueueDpc(
                                    &deviceExtension->SysButtonEventDpc,
                                    (PVOID) action,
                                    (PVOID) input->MakeCode
                                    );
                            }
                        }

                    } else {

                        //
                        // Got a make code.
                        //

                        IsrPrint(DBG_KBISR_SCODE, ("MAKE code\n"));

                        input->MakeCode = scanCode;

                        //
                        // If the input scan code is debug stop, then drop
                        // into the kernel debugger if it is active.
                        //

                        if ((KD_DEBUGGER_NOT_PRESENT == FALSE) && !(input->Flags & KEY_BREAK)) {
                            if (ENHANCED_KEYBOARD(
                                     deviceExtension->KeyboardAttributes.KeyboardIdentifier
                                     )) {
                                //
                                // Enhanced 101 keyboard, SysReq key is 0xE0 0x37.
                                //

                                if ((input->MakeCode == KEYBOARD_DEBUG_HOTKEY_ENH) &&
                                     (input->Flags & KEY_E0)) {
                                    try {
                                        if ((KD_DEBUGGER_ENABLED != FALSE) &&
                                            Globals.BreakOnSysRq) {
                                            DbgBreakPointWithStatus(DBG_STATUS_SYSRQ);
                                        }

                                    } except(EXCEPTION_EXECUTE_HANDLER) {
                                    }
                                }
                                //
                                // 84-key AT keyboard, SysReq key is 0xE0 0x54.
                                //

                            } else if ((input->MakeCode == KEYBOARD_DEBUG_HOTKEY_AT)) {
                                try {
                                    if ((KD_DEBUGGER_ENABLED != FALSE)
                                        && Globals.BreakOnSysRq) {
                                            DbgBreakPointWithStatus(DBG_STATUS_SYSRQ);
                                    }

                                } except(EXCEPTION_EXECUTE_HANDLER) {
                                }
                            }
                        }
                    }


                    //
                    // Reset the state to Normal.
                    //

                    *scanState = Normal;
                    break;

                  default:

                    //
                    // Queue a DPC to log an internal driver error.
                    //

                    KeInsertQueueDpc(
                        &deviceExtension->ErrorLogDpc,
                        (PIRP) NULL,
                        LongToPtr(I8042_INVALID_ISR_STATE_KBD)
                        );

                    ASSERT(FALSE);
                    break;
                }
            }

            //
            // In the Normal state, if the keyboard device is enabled,
            // add the data to the InputData queue and queue the ISR DPC.
            //
            if (*scanState == Normal) {
                I8xQueueCurrentKeyboardInput(DeviceObject);
            }

            break;

    }

    IsrPrint(DBG_KBISR_TRACE, ("exit\n"));

    return TRUE;
}


VOID
I8xProcessCrashDump(
    PPORT_KEYBOARD_EXTENSION DeviceExtension,
    UCHAR ScanCode,
    KEYBOARD_SCAN_STATE ScanState
    )
{
    LONG crashFlags;
    BOOLEAN processFlags;
    UCHAR crashScanCode, crashScanCode2;

    crashFlags = DeviceExtension->CrashFlags;
    crashScanCode = DeviceExtension->CrashScanCode;
    crashScanCode2 = DeviceExtension->CrashScanCode2;

    if (IS_MAKE_CODE(ScanCode)) {
        //
        // make code
        //
        // If it is one of the crash flag keys record it.
        // If it is a crash dump key record it
        // If it is neither, reset the current tracking state (CurrentCrashFlags)
        //
        switch (ScanCode) {
        case CTRL_SCANCODE:
            if (ScanState == Normal) {     // Left
                DeviceExtension->CurrentCrashFlags |= CRASH_L_CTRL;
            }
            else if (ScanState == GotE0) { // Right
                DeviceExtension->CurrentCrashFlags |= CRASH_R_CTRL;
            }
            break;

        case ALT_SCANCODE:
            if (ScanState == Normal) {     // Left
                DeviceExtension->CurrentCrashFlags |= CRASH_L_ALT;
            }
            else if (ScanState == GotE0) { // Right
                DeviceExtension->CurrentCrashFlags |= CRASH_R_ALT;
            }
            break;

        case LEFT_SHIFT_SCANCODE:
            if (ScanState == Normal) {
                DeviceExtension->CurrentCrashFlags |= CRASH_L_SHIFT;
            }
            break;

        case RIGHT_SHIFT_SCANCODE:
            if (ScanState == Normal) {
                DeviceExtension->CurrentCrashFlags |= CRASH_R_SHIFT;
            }
            break;

        default:
            if (IS_MAKE_CODE(crashScanCode)) {
                if (ScanState == Normal && crashScanCode == ScanCode) {
                    break;
                }
            }
            else {
                if (ScanState == GotE0 && GET_MAKE_CODE(crashScanCode) == ScanCode) {
                    break;
                }
            }

            if (IS_MAKE_CODE(crashScanCode2)) {
                if (ScanState == Normal &&
                    crashScanCode2 == ScanCode) {
                    break;
                }
            }
            else {
                if (ScanState == GotE0 &&
                    GET_MAKE_CODE(crashScanCode2) == ScanCode) {
                    break;
                }
            }

            //
            // Not a key we are interested in, reset our current state
            //
            DeviceExtension->CurrentCrashFlags = 0x0;
            break;
        }
    }
    else {
        //
        // break code
        //
        // If one of the modifer keys is released, our state is reset and all
        //  keys have to be pressed again.
        // If it is a non modifier key, proceed with the processing if it is the
        //  crash dump key, otherwise reset our tracking state
        //
        switch (GET_MAKE_CODE(ScanCode)) {
        case CTRL_SCANCODE:
            if (ScanState == Normal) {     // Left
                DeviceExtension->CurrentCrashFlags &=
                    ~(CRASH_BOTH_TIMES | CRASH_L_CTRL);
            }
            else if (ScanState == GotE0) {  // Right
                DeviceExtension->CurrentCrashFlags &=
                    ~(CRASH_BOTH_TIMES | CRASH_R_CTRL);
            }
            break;

        case ALT_SCANCODE:
            if (ScanState == Normal) {     // Left
                DeviceExtension->CurrentCrashFlags &=
                    ~(CRASH_BOTH_TIMES | CRASH_L_ALT);
            }
            else if (ScanState == GotE0) { // Right
                DeviceExtension->CurrentCrashFlags &=
                    ~(CRASH_BOTH_TIMES | CRASH_R_ALT);
            }
            break;

        case RIGHT_SHIFT_SCANCODE:
            if (ScanState == Normal) {
                DeviceExtension->CurrentCrashFlags &=
                    ~(CRASH_BOTH_TIMES | CRASH_R_SHIFT);
            }
            break;

        case LEFT_SHIFT_SCANCODE:
            if (ScanState == Normal) {
                DeviceExtension->CurrentCrashFlags &=
                    ~(CRASH_BOTH_TIMES | CRASH_L_SHIFT);
            }
            break;

        default:
            processFlags = FALSE;

            if (IS_MAKE_CODE(crashScanCode)) {
                if (ScanState == Normal && crashScanCode == GET_MAKE_CODE(ScanCode))
                    processFlags = TRUE;
            }
            else {
                if (ScanState == GotE0 && crashScanCode == ScanCode) {
                    processFlags = TRUE;
                }
            }

            if (IS_MAKE_CODE(crashScanCode2)) {
                if (ScanState == Normal && crashScanCode2 == GET_MAKE_CODE(ScanCode)) {
                    processFlags = TRUE;
                }
            }
            else {
                if (ScanState == GotE0 && crashScanCode2 == ScanCode)
                    processFlags = TRUE;
            }

            //
            // If this is the key we are interested in, continue, otherwise
            // our tracking state is reset
            //
            if (processFlags) {
                //
                // test to see if all the needed modifier
                // keys are down
                //
                if (crashFlags != (DeviceExtension->CurrentCrashFlags & crashFlags)) {
                    break;
                }

                //
                // record how many times we have seen
                // this key
                //
                if (DeviceExtension->CurrentCrashFlags & CRASH_FIRST_TIME) {
                    DeviceExtension->CurrentCrashFlags |= CRASH_SECOND_TIME;
                }
                else {
                    DeviceExtension->CurrentCrashFlags |= CRASH_FIRST_TIME;
                }
                break;
            }

            DeviceExtension->CurrentCrashFlags = 0x0;
            break;
        }
    }

    crashFlags |= CRASH_BOTH_TIMES;

    if (DeviceExtension->CurrentCrashFlags == crashFlags) {
        DeviceExtension->CurrentCrashFlags = 0x0;

        //
        // Bring down the system in a somewhat controlled manner
        //
        KeBugCheckEx(MANUALLY_INITIATED_CRASH, 0, 0, 0, 0);
    }
}

//
//  The following table is used to convert typematic rate (keys per
//  second) into the value expected by the keyboard.  The index into the
//  array is the number of keys per second.  The resulting value is
//  the bit equate to send to the keyboard.
//

UCHAR
I8xConvertTypematicParameters(
    IN USHORT Rate,
    IN USHORT Delay
    )

/*++

Routine Description:

    This routine converts the typematic rate and delay to the form the
    keyboard expects.

    The byte passed to the keyboard looks like this:

        - bit 7 is zero
        - bits 5 and 6 indicate the delay
        - bits 0-4 indicate the rate

    The delay is equal to 1 plus the binary value of bits 6 and 5,
    multiplied by 250 milliseconds.

    The period (interval from one typematic output to the next) is
    determined by the following equation:

        Period = (8 + A) x (2^B) x 0.00417 seconds
        where
            A = binary value of bits 0-2
            B = binary value of bits 3 and 4


Arguments:

    Rate - Number of keys per second.

    Delay - Number of milliseconds to delay before the key repeat starts.

Return Value:

    The byte to pass to the keyboard.

--*/

{
    UCHAR value;
    UCHAR   TypematicPeriod[] = {
        31,    // 0 keys per second
        31,    // 1 keys per second
        28,    // 2 keys per second, This is really 2.5, needed for NEXUS.
        26,    // 3 keys per second
        23,    // 4 keys per second
        20,    // 5 keys per second
        18,    // 6 keys per second
        17,    // 7 keys per second
        15,    // 8 keys per second
        13,    // 9 keys per second
        12,    // 10 keys per second
        11,    // 11 keys per second
        10,    // 12 keys per second
         9,    // 13 keys per second
         9,    // 14 keys per second
         8,    // 15 keys per second
         7,    // 16 keys per second
         6,    // 17 keys per second
         5,    // 18 keys per second
         4,    // 19 keys per second
         4,    // 20 keys per second
         3,    // 21 keys per second
         3,    // 22 keys per second
         2,    // 23 keys per second
         2,    // 24 keys per second
         1,    // 25 keys per second
         1,    // 26 keys per second
         1     // 27 keys per second
               // > 27 keys per second, use 0
    };

    Print(DBG_CALL_TRACE, ("I8xConvertTypematicParameters: enter\n"));

    //
    // Calculate the delay bits.
    //

    value = (UCHAR) ((Delay / 250) - 1);

    //
    // Put delay bits in the right place.
    //

    value <<= 5;

    //
    // Get the typematic period from the table.  If keys per second
    // is > 27, the typematic period value is zero.
    //

    if (Rate <= 27) {
        value |= TypematicPeriod[Rate];
    }

    Print(DBG_CALL_TRACE, ("I8xConvertTypematicParameters: exit\n"));

    return(value);
}

#define KB_INIT_FAILED_RESET                0x00000001
#define KB_INIT_FAILED_XLATE_OFF            0x00000010
#define KB_INIT_FAILED_XLATE_ON             0x00000020
#define KB_INIT_FAILED_SET_TYPEMATIC        0x00000100
#define KB_INIT_FAILED_SET_TYPEMATIC_PARAM  0x00000200
#define KB_INIT_FAILED_SET_LEDS             0x00001000
#define KB_INIT_FAILED_SET_LEDS_PARAM       0x00002000
#define KB_INIT_FAILED_SELECT_SS            0x00010000
#define KB_INIT_FAILED_SELECT_SS_PARAM      0x00020000

#if KEYBOARD_RECORD_INIT

ULONG KeyboardInitStatus;
#define SET_KB_INIT_FAILURE(flag) KeyboardInitStatus |= flag
#define KB_INIT_START() KeyboardInitStatus = 0x0;

#else

#define SET_KB_INIT_FAILURE(flag)
#define KB_INIT_START()

#endif // KEYBOARD_RECORD_INIT

NTSTATUS
I8xInitializeKeyboard(
    IN PPORT_KEYBOARD_EXTENSION KeyboardExtension
    )
/*++

Routine Description:

    This routine initializes the i8042 keyboard hardware.  It is called
    only at initialization, and does not synchronize access to the hardware.

Arguments:

    DeviceObject - Pointer to the device object.

Return Value:

    Returns status.

--*/

{
    NTSTATUS                            status;
    PKEYBOARD_ID                        id;
    PPORT_KEYBOARD_EXTENSION            deviceExtension;
    PDEVICE_OBJECT                      deviceObject;
    UCHAR                               byte,
                                        failedResetResponseByte,
                                        failedResetResponseByte2;
    I8042_TRANSMIT_CCB_CONTEXT          transmitCCBContext;
    ULONG                               i;
    ULONG                               limit;
    NTSTATUS                            failedLedsStatus,
                                        failedTypematicStatus,
                                        failedResetStatus,
                                        failedResetResponseStatus,
                                        failedResetResponseStatus2;
    PI8042_CONFIGURATION_INFORMATION    configuration;
    PKEYBOARD_ID                        keyboardId;
    LARGE_INTEGER                       startOfSpin,
                                        nextQuery,
                                        difference,
                                        resetRespTimeout,
                                        li;
    BOOLEAN                             waitForAckOnReset = WAIT_FOR_ACKNOWLEDGE,
                                        translationOn = TRUE,
                                        failedReset = FALSE,
                                        failedResetResponse = FALSE,
                                        failedResetResponse2 = FALSE,
                                        failedTypematic = FALSE,
                                        failedLeds = FALSE;

#define DUMP_COUNT 4
    ULONG                               dumpData[DUMP_COUNT];

    PAGED_CODE();

    KB_INIT_START();

    Print(DBG_SS_TRACE, ("I8xInitializeKeyboard, enter\n"));

    for (i = 0; i < DUMP_COUNT; i++)
        dumpData[i] = 0;

    //
    // Get the device extension.
    //
    deviceExtension = KeyboardExtension; 
    deviceObject = deviceExtension->Self;

    //
    // Reset the keyboard.
    //
StartOfReset:
    status = I8xPutBytePolled(
                 (CCHAR) DataPort,
                 waitForAckOnReset,
                 (CCHAR) KeyboardDeviceType,
                 (UCHAR) KEYBOARD_RESET
                 );
    if (!NT_SUCCESS(status)) {
        SET_KB_INIT_FAILURE(KB_INIT_FAILED_RESET);
        failedReset = TRUE;
        failedResetStatus = status;

        if (KeyboardExtension->FailedReset == FAILED_RESET_STOP) {
            //
            // If the device was reported, but not responding, it is phantom
            //
            status = STATUS_DEVICE_NOT_CONNECTED; 
            SET_HW_FLAGS(PHANTOM_KEYBOARD_HARDWARE_REPORTED);
            Print(DBG_SS_INFO, 
                  ("kb failed reset Reset failed, stopping immediately\n"));
            goto I8xInitializeKeyboardExit;
        }
        else {
            //
            // NOTE:  The Gateway 4DX2/66V has a problem when an old Compaq 286
            //        keyboard is attached.  In this case, the keyboard reset
            //        is not acknowledged (at least, the system never
            //        receives the ack).  Instead, the KEYBOARD_COMPLETE_SUCCESS
            //        byte is sitting in the i8042 output buffer.  The fix
            //        is to ignore the keyboard reset failure and continue.
            //
            /* do nothing */;
            Print(DBG_SS_INFO, ("kb failed reset, proceeding\n"));
        }
    }

    //
    // Get the keyboard reset self-test response.  A response byte of
    // KEYBOARD_COMPLETE_SUCCESS indicates success; KEYBOARD_COMPLETE_FAILURE
    // indicates failure.
    //
    // Note that it is usually necessary to stall a long time to get the
    // keyboard reset/self-test to work.
    //
    li.QuadPart = -100;

    resetRespTimeout.QuadPart = 50*10*1000*1000;
    KeQueryTickCount(&startOfSpin);

    while (TRUE) {
        status = I8xGetBytePolled(
                     (CCHAR) KeyboardDeviceType,
                     &byte
                     );

        if (NT_SUCCESS(status)) {
            if (byte == (UCHAR) KEYBOARD_COMPLETE_SUCCESS) {
                //
                // The reset completed successfully.
                //
                break;
            }
            else {
                //
                // There was some sort of failure during the reset
                // self-test.  Continue anyway.
                //
                failedResetResponse = TRUE;
                failedResetResponseStatus = status;
                failedResetResponseByte = byte;

                break;
            }
        }
        else {
            if (status == STATUS_IO_TIMEOUT) {
                //
                // Stall, and then try again to get a response from
                // the reset.
                //
                KeDelayExecutionThread(KernelMode,
                                       FALSE,
                                       &li);

                KeQueryTickCount(&nextQuery);

                difference.QuadPart = nextQuery.QuadPart - startOfSpin.QuadPart;

                ASSERT(KeQueryTimeIncrement() <= MAXLONG);
                if (difference.QuadPart*KeQueryTimeIncrement() >=
                    resetRespTimeout.QuadPart) {
                    Print(DBG_SS_ERROR, ("no reset response, quitting\n"));
                    break;
                }
            }
            else {
                break;
            }
        }
    }

    if (!NT_SUCCESS(status)) {
        if (waitForAckOnReset == WAIT_FOR_ACKNOWLEDGE) {
            waitForAckOnReset = NO_WAIT_FOR_ACKNOWLEDGE;
            goto StartOfReset;
        }

        failedResetResponse2 = TRUE;
        failedResetResponseStatus2 = status;
        failedResetResponseByte2 = byte;

        goto I8xInitializeKeyboardExit;
    }

    //
    // Turn off Keyboard Translate Mode.  Call I8xTransmitControllerCommand
    // to read the Controller Command Byte, modify the appropriate bits, and
    // rewrite the Controller Command Byte.
    //
    transmitCCBContext.HardwareDisableEnableMask = 0;
    transmitCCBContext.AndOperation = AND_OPERATION;
    transmitCCBContext.ByteMask = (UCHAR) ~((UCHAR)CCB_KEYBOARD_TRANSLATE_MODE);

    I8xTransmitControllerCommand(
        (PVOID) &transmitCCBContext
        );

    if (!NT_SUCCESS(transmitCCBContext.Status)) {
        //
        // If failure then retry once.  This is for Toshiba T3400CT.
        //
        I8xTransmitControllerCommand(
            (PVOID) &transmitCCBContext
            );
    }

    if (!NT_SUCCESS(transmitCCBContext.Status)) {
        Print(DBG_SS_ERROR,
              ("I8xInitializeKeyboard: could not turn off translate\n"
              ));
        status = transmitCCBContext.Status;
        SET_KB_INIT_FAILURE(KB_INIT_FAILED_XLATE_OFF);
        goto I8xInitializeKeyboardExit;
    }

    //
    // Get a pointer to the keyboard identifier field.
    //

    id = &deviceExtension->KeyboardAttributes.KeyboardIdentifier;

    //
    // Set the typematic rate and delay.  Send the Set Typematic Rate command
    // to the keyboard, followed by the typematic rate/delay parameter byte.
    // Note that it is often necessary to stall a long time to get this
    // to work.  The stall value was determined by experimentation.  Some
    // broken hardware does not accept this command, so ignore errors in the
    // hope that the keyboard will work okay anyway.
    //
    //

    if ((status = I8xPutBytePolled(
                      (CCHAR) DataPort,
                      WAIT_FOR_ACKNOWLEDGE,
                      (CCHAR) KeyboardDeviceType,
                      (UCHAR) SET_KEYBOARD_TYPEMATIC
                      )) != STATUS_SUCCESS) {

        Print(DBG_SS_INFO, ("kb set typematic failed\n"));

        SET_KB_INIT_FAILURE(KB_INIT_FAILED_SET_TYPEMATIC);
        failedTypematic = TRUE;
        failedTypematicStatus = status;

    } else if ((status = I8xPutBytePolled(
                          (CCHAR) DataPort,
                          WAIT_FOR_ACKNOWLEDGE,
                          (CCHAR) KeyboardDeviceType,
                          I8xConvertTypematicParameters(
                          deviceExtension->KeyRepeatCurrent.Rate,
                          deviceExtension->KeyRepeatCurrent.Delay
                          ))) != STATUS_SUCCESS) {

        SET_KB_INIT_FAILURE(KB_INIT_FAILED_SET_TYPEMATIC_PARAM);
        Print(DBG_SS_ERROR,
              ("I8xInitializeKeyboard: could not send typematic param\n"
              ));

        //
        // Log an error.
        //

        dumpData[0] = KBDMOU_COULD_NOT_SEND_PARAM;
        dumpData[1] = DataPort;
        dumpData[2] = SET_KEYBOARD_TYPEMATIC;
        dumpData[3] =
            I8xConvertTypematicParameters(
                deviceExtension->KeyRepeatCurrent.Rate,
                deviceExtension->KeyRepeatCurrent.Delay
                );

        I8xLogError(
            deviceObject,
            I8042_SET_TYPEMATIC_FAILED,
            I8042_ERROR_VALUE_BASE + 540,
            status,
            dumpData,
            4
            );

    }

    status = STATUS_SUCCESS;

    //
    // Set the keyboard indicator lights.  Ignore errors.
    //

    if ((status = I8xPutBytePolled(
                      (CCHAR) DataPort,
                      WAIT_FOR_ACKNOWLEDGE,
                      (CCHAR) KeyboardDeviceType,
                      (UCHAR) SET_KEYBOARD_INDICATORS
                      )) != STATUS_SUCCESS) {

        Print(DBG_SS_INFO, ("kb set LEDs failed\n"));

        SET_KB_INIT_FAILURE(KB_INIT_FAILED_SET_LEDS);
        failedLeds = TRUE;
        failedLedsStatus = status;

    } else if ((status = I8xPutBytePolled(
                             (CCHAR) DataPort,
                             WAIT_FOR_ACKNOWLEDGE,
                             (CCHAR) KeyboardDeviceType,
                             (UCHAR) deviceExtension->KeyboardIndicators.LedFlags
                             )) != STATUS_SUCCESS) {

        SET_KB_INIT_FAILURE(KB_INIT_FAILED_SET_LEDS_PARAM);

        Print(DBG_SS_ERROR,
              ("I8xInitializeKeyboard: could not send SET LEDS param\n"
              ));

        //
        // Log an error.
        //

        dumpData[0] = KBDMOU_COULD_NOT_SEND_PARAM;
        dumpData[1] = DataPort;
        dumpData[2] = SET_KEYBOARD_INDICATORS;
        dumpData[3] =
            deviceExtension->KeyboardIndicators.LedFlags;

        I8xLogError(
            deviceObject,
            I8042_SET_LED_FAILED,
            I8042_ERROR_VALUE_BASE + 550,
            status,
            dumpData,
            4
            );

    }

    status = STATUS_SUCCESS;

#if !(defined(_X86_) || defined(_IA64_) || defined(_PPC_))  // IBMCPK: MIPS specific initialization

    //
    // NOTE:    This code is necessary until the MIPS firmware stops
    //          selecting scan code set 3.  Select scan code set 2 here.
    //          Since the translate bit is set, the net effect is that
    //          we will receive scan code set 1 bytes.
    //

    if (ENHANCED_KEYBOARD(*id))  {
        status = I8xPutBytePolled(
                     (CCHAR) DataPort,
                     WAIT_FOR_ACKNOWLEDGE,
                     (CCHAR) KeyboardDeviceType,
                     (UCHAR) SELECT_SCAN_CODE_SET
                     );

        if (NT_SUCCESS(status)) {

            //
            // Send the associated parameter byte.
            //

            status = I8xPutBytePolled(
                         (CCHAR) DataPort,
                         WAIT_FOR_ACKNOWLEDGE,
                         (CCHAR) KeyboardDeviceType,
                         (UCHAR) 2
                         );
        }

        if (!NT_SUCCESS(status)) {
            Print(DBG_SS_ERROR,
                  ("I8xInitializeKeyboard: could not send Select Scan command\n"
                  ));

            //
            // This failed so probably what we have here isn't an enhanced
            // keyboard at all.  Make this an old style keyboard.
            //

            configuration = &Globals.ControllerData->Configuration;
            keyboardId = &deviceExtension->KeyboardAttributes.KeyboardIdentifier;

            keyboardId->Type = 3;

            deviceExtension->KeyboardAttributes.NumberOfFunctionKeys =
                KeyboardTypeInformation[keyboardId->Type - 1].NumberOfFunctionKeys;
            deviceExtension->KeyboardAttributes.NumberOfIndicators =
                KeyboardTypeInformation[keyboardId->Type - 1].NumberOfIndicators;
            deviceExtension->KeyboardAttributes.NumberOfKeysTotal =
                KeyboardTypeInformation[keyboardId->Type - 1].NumberOfKeysTotal;

            status = STATUS_SUCCESS;
        }
    }
#endif

#if defined(FE_SB)

    if (IBM02_KEYBOARD(*id)) {

        //
        // IBM-J 5576-002 Keyboard should set local scan code set for
        // supplied NLS key.
        //

        status = I8xPutBytePolled(
                     (CCHAR) DataPort,
                     WAIT_FOR_ACKNOWLEDGE,
                     (CCHAR) KeyboardDeviceType,
                     (UCHAR) SELECT_SCAN_CODE_SET
                     );
        if (status != STATUS_SUCCESS) {
            Print(DBG_SS_ERROR,
                  ("I8xInitializeKeyboard: could not send Select Scan command\n"
                  ));
            Print(DBG_SS_ERROR,
                  ("I8xInitializeKeyboard: WARNING - using scan set 82h\n"
                  ));
            deviceExtension->KeyboardAttributes.KeyboardMode = 3;
        } else {

            //
            // Send the associated parameter byte.
            //

            status = I8xPutBytePolled(
                         (CCHAR) DataPort,
                         WAIT_FOR_ACKNOWLEDGE,
                         (CCHAR) KeyboardDeviceType,
                         (UCHAR) 0x82
                         );
            if (status != STATUS_SUCCESS) {
                Print(DBG_SS_ERROR,
                      ("I8xInitializeKeyboard: could not send Select Scan param\n"
                      ));
                Print(DBG_SS_ERROR,
                      ("I8xInitializeKeyboard: WARNING - using scan set 82h\n"
                      ));
                deviceExtension->KeyboardAttributes.KeyboardMode = 3;
            }
        }
    }
#endif // FE_SB

    if (deviceExtension->InitializationHookCallback) {
        (*deviceExtension->InitializationHookCallback) (
            deviceExtension->HookContext,
            (PVOID) deviceObject,
            (PI8042_SYNCH_READ_PORT) I8xKeyboardSynchReadPort,
            (PI8042_SYNCH_WRITE_PORT) I8xKeyboardSynchWritePort,
            &translationOn
            );
    }

    if (deviceExtension->KeyboardAttributes.KeyboardMode == 1 &&
        translationOn) {

        //
        // Turn translate back on.  The keyboard should, by default, send
        // scan code set 2.  When the translate bit in the 8042 command byte
        // is on, the 8042 translates the scan code set 2 bytes to scan code
        // set 1 before sending them to the CPU.  Scan code set 1 is
        // the industry standard scan code set.
        //
        // N.B.  It does not appear to be possible to change the translate
        //       bit on some models of PS/2.
        //

        transmitCCBContext.HardwareDisableEnableMask = 0;
        transmitCCBContext.AndOperation = OR_OPERATION;
        transmitCCBContext.ByteMask = (UCHAR) CCB_KEYBOARD_TRANSLATE_MODE;

        I8xTransmitControllerCommand(
            (PVOID) &transmitCCBContext
            );

        if (!NT_SUCCESS(transmitCCBContext.Status)) {
            SET_KB_INIT_FAILURE(KB_INIT_FAILED_XLATE_ON);
            Print(DBG_SS_ERROR,
                  ("I8xInitializeKeyboard: couldn't turn on translate\n"
                  ));

            if (transmitCCBContext.Status == STATUS_DEVICE_DATA_ERROR) {

                //
                // Could not turn translate back on.  This happens on some
                // PS/2 machines.  In this case, select scan code set 1
                // for the keyboard, since the 8042 will not do the
                // translation from the scan code set 2, which is what the
                // KEYBOARD_RESET caused the keyboard to default to.
                //

                if (ENHANCED_KEYBOARD(*id))  {
                    status = I8xPutBytePolled(
                                 (CCHAR) DataPort,
                                 WAIT_FOR_ACKNOWLEDGE,
                                 (CCHAR) KeyboardDeviceType,
                                 (UCHAR) SELECT_SCAN_CODE_SET
                                 );
                    if (!NT_SUCCESS(status)) {
                        SET_KB_INIT_FAILURE(KB_INIT_FAILED_SELECT_SS);
                        Print(DBG_SS_ERROR,
                              ("I8xInitializeKeyboard: could not send Select Scan command\n"
                              ));
                        Print(DBG_SS_ERROR,
                              ("I8xInitializeKeyboard: WARNING - using scan set 2\n"
                              ));
                        deviceExtension->KeyboardAttributes.KeyboardMode = 2;
                        //
                        // Log an error.
                        //

                        dumpData[0] = KBDMOU_COULD_NOT_SEND_COMMAND;
                        dumpData[1] = DataPort;
                        dumpData[2] = SELECT_SCAN_CODE_SET;

                        I8xLogError(
                            deviceObject,
                            I8042_SELECT_SCANSET_FAILED,
                            I8042_ERROR_VALUE_BASE + 555,
                            status,
                            dumpData,
                            3
                            );

                    } else {

                        //
                        // Send the associated parameter byte.
                        //

                        status = I8xPutBytePolled(
                                     (CCHAR) DataPort,
                                     WAIT_FOR_ACKNOWLEDGE,
                                     (CCHAR) KeyboardDeviceType,
#ifdef FE_SB // I8xInitializeKeyboard()
                                     (UCHAR) (IBM02_KEYBOARD(*id) ? 0x81 : 1 )
#else
                                     (UCHAR) 1
#endif // FE_SB
                                     );
                        if (!NT_SUCCESS(status)) {
                            SET_KB_INIT_FAILURE(KB_INIT_FAILED_SELECT_SS_PARAM);
                            Print(DBG_SS_ERROR,
                                  ("I8xInitializeKeyboard: could not send Select Scan param\n"
                                  ));
                            Print(DBG_SS_ERROR,
                                  ("I8xInitializeKeyboard: WARNING - using scan set 2\n"
                                  ));
                            deviceExtension->KeyboardAttributes.KeyboardMode = 2;
                            //
                            // Log an error.
                            //

                            dumpData[0] = KBDMOU_COULD_NOT_SEND_PARAM;
                            dumpData[1] = DataPort;
                            dumpData[2] = SELECT_SCAN_CODE_SET;
                            dumpData[3] = 1;

                            I8xLogError(
                                deviceObject,
                                I8042_SELECT_SCANSET_FAILED,
                                I8042_ERROR_VALUE_BASE + 560,
                                status,
                                dumpData,
                                4
                                );

                        }
                    }
                }

            } else {
                status = transmitCCBContext.Status;
                goto I8xInitializeKeyboardExit;
            }
        }
    }

I8xInitializeKeyboardExit:

    //
    // If all 3 of these have failed, then we have a device that was reported 
    // present but is not plugged in.  This usually happens on either an ACPI 
    // enabled machine (where it always reports the PS/2 kbd and mouse present)
    // or on a machine which has legacy HID support (where the reported PS/2
    // device(s) are really USB HID).
    //
    // If this is the case, then we will succeed the start and hide the device 
    // in the UI
    //
    if (failedReset && failedTypematic && failedLeds) {
        if (KeyboardExtension->FailedReset == FAILED_RESET_PROCEED) {
            OBJECT_ATTRIBUTES oa;
            UNICODE_STRING string;
            HANDLE hService, hParameters;

            InitializeObjectAttributes(&oa,
                                       &Globals.RegistryPath,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       (PSECURITY_DESCRIPTOR) NULL);

            if (NT_SUCCESS(ZwOpenKey(&hService, KEY_ALL_ACCESS, &oa))) {
                RtlInitUnicodeString(&string, L"Parameters");

                InitializeObjectAttributes(&oa,
                                           &string,
                                           OBJ_CASE_INSENSITIVE,
                                           hService,
                                           (PSECURITY_DESCRIPTOR) NULL);

                if (NT_SUCCESS(ZwOpenKey(&hParameters, KEY_ALL_ACCESS, &oa))) {
                    ULONG tmp;

                    RtlInitUnicodeString (&string, STR_FAILED_RESET);
                    tmp = FAILED_RESET_STOP; 

                    Print(DBG_SS_INFO | DBG_SS_ERROR, 
                          ("Future failed kbd resets will stop init\n"));

                    ZwSetValueKey(hParameters,
                                  &string,
                                  0,
                                  REG_DWORD,
                                  &tmp,
                                  sizeof(tmp));

                    ZwClose(hParameters);
                }

                ZwClose(hService);
            }
        }

        Print(DBG_SS_INFO, 
              ("kb, all 3 sets failed, assuming a phantom keyboard\n"));

        status = STATUS_DEVICE_NOT_CONNECTED; 
        // errorCode = I8042_NO_KBD_DEVICE;

        SET_HW_FLAGS(PHANTOM_KEYBOARD_HARDWARE_REPORTED);

        if (Globals.ReportResetErrors) {
            I8xLogError(deviceObject,
                        I8042_NO_KBD_DEVICE,
                        0,
                        status,
                        NULL,
                        0
                        );
        }
    }
    else {
        if (failedReset) {
            Print(DBG_SS_ERROR,
                  ("I8xInitializeKeyboard: failed keyboard reset, status 0x%x\n",
                  status
                  ));

            if (Globals.ReportResetErrors) {
                dumpData[0] = KBDMOU_COULD_NOT_SEND_COMMAND;
                dumpData[1] = DataPort;
                dumpData[2] = KEYBOARD_RESET;

                I8xLogError(deviceObject,
                            I8042_KBD_RESET_COMMAND_FAILED,
                            I8042_ERROR_VALUE_BASE + 510,
                            failedResetStatus,
                            dumpData,
                            3
                            );
            }
        }

        if (failedResetResponse2) {
            Print(DBG_SS_ERROR,
                  ("I8xInitializeKeyboard, failed reset response, status 0x%x, byte 0x%x\n",
                  status,
                  byte
                  ));

            //
            // Log a warning.
            //
            dumpData[0] = KBDMOU_INCORRECT_RESPONSE;
            dumpData[1] = KeyboardDeviceType;
            dumpData[2] = KEYBOARD_COMPLETE_SUCCESS;
            dumpData[3] = failedResetResponse2;

            I8xLogError(
                deviceObject,
                I8042_KBD_RESET_RESPONSE_FAILED,
                I8042_ERROR_VALUE_BASE + 520,
                failedResetResponseStatus2,
                dumpData,
                4
                );
        }
        else if (failedResetResponse) {
            Print(DBG_SS_ERROR,
                  ("kb failed reset response\n")
                  );

            //
            // Log a warning.
            //
            dumpData[0] = KBDMOU_INCORRECT_RESPONSE;
            dumpData[1] = KeyboardDeviceType;
            dumpData[2] = KEYBOARD_COMPLETE_SUCCESS;
            dumpData[3] = failedResetResponseByte;

            I8xLogError(
                deviceObject,
                I8042_KBD_RESET_RESPONSE_FAILED,
                I8042_ERROR_VALUE_BASE + 515,
                failedResetResponseStatus,
                dumpData,
                4
                );
        }

        if (failedTypematic) {
            Print(DBG_SS_ERROR,
                  ("I8xInitializeKeyboard: could not send SET TYPEMATIC cmd\n"
                  ));

            //
            // Log an error.
            //
            dumpData[0] = KBDMOU_COULD_NOT_SEND_COMMAND;
            dumpData[1] = DataPort;
            dumpData[2] = SET_KEYBOARD_TYPEMATIC;

            I8xLogError(
                deviceObject,
                I8042_SET_TYPEMATIC_FAILED,
                I8042_ERROR_VALUE_BASE + 535,
                failedTypematicStatus,
                dumpData,
                3
                );
        }

        if (failedLeds) {
            Print(DBG_SS_ERROR,
                  ("I8xInitializeKeyboard: could not send SET LEDS cmd\n"
                  ));

            //
            // Log an error.
            //

            dumpData[0] = KBDMOU_COULD_NOT_SEND_COMMAND;
            dumpData[1] = DataPort;
            dumpData[2] = SET_KEYBOARD_INDICATORS;

            I8xLogError(
                deviceObject,
                I8042_SET_LED_FAILED,
                I8042_ERROR_VALUE_BASE + 545,
                failedLedsStatus,
                dumpData,
                3
                );
        }
    }

    if (DEVICE_START_SUCCESS(status)) {
        SET_HW_FLAGS(KEYBOARD_HARDWARE_PRESENT |
                     KEYBOARD_HARDWARE_INITIALIZED);
    }
    else {
        CLEAR_KEYBOARD_PRESENT();
    }

    //
    // Initialize current keyboard set packet state.
    //
    deviceExtension->CurrentOutput.State = Idle;
    deviceExtension->CurrentOutput.Bytes = NULL;
    deviceExtension->CurrentOutput.ByteCount = 0;

    Print(DBG_SS_TRACE, ("I8xInitializeKeyboard (0x%x)\n", status));

    return status;
}

NTSTATUS
I8xKeyboardConfiguration(
    IN PPORT_KEYBOARD_EXTENSION KeyboardExtension,
    IN PCM_RESOURCE_LIST ResourceList
    )
/*++

Routine Description:

    This routine retrieves the configuration information for the keyboard.

Arguments:

    KeyboardExtension - Keyboard extension

    ResourceList - Translated resource list give to us via the start IRP

Return Value:

    STATUS_SUCCESS if all the resources required are presented

--*/
{
    NTSTATUS                            status = STATUS_SUCCESS;

    PCM_PARTIAL_RESOURCE_LIST           partialResList = NULL;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR     firstResDesc = NULL,
                                        currentResDesc = NULL;
    PCM_FULL_RESOURCE_DESCRIPTOR        fullResDesc = NULL;
    PI8042_CONFIGURATION_INFORMATION    configuration;

    PKEYBOARD_ID                        keyboardId;

    ULONG                               count,
                                        i;

    KINTERRUPT_MODE                     defaultInterruptMode;
    BOOLEAN                             defaultInterruptShare;

    PAGED_CODE();

    if (!ResourceList) {
        Print(DBG_SS_INFO | DBG_SS_ERROR, ("keyboard with null resources\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    fullResDesc = ResourceList->List;
    if (!fullResDesc) {
        //
        // this should never happen
        //
        ASSERT(fullResDesc != NULL);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    configuration = &Globals.ControllerData->Configuration;

    partialResList = &fullResDesc->PartialResourceList;
    currentResDesc = firstResDesc = partialResList->PartialDescriptors;
    count = partialResList->Count;

    configuration->FloatingSave   = I8042_FLOATING_SAVE;
    configuration->BusNumber      = fullResDesc->BusNumber;
    configuration->InterfaceType  = fullResDesc->InterfaceType;

    if (configuration->InterfaceType == MicroChannel) {
        defaultInterruptShare = TRUE;
        defaultInterruptMode = LevelSensitive;
    }
    else {
        defaultInterruptShare = I8042_INTERRUPT_SHARE;
        defaultInterruptMode = I8042_INTERRUPT_MODE;
    }

    for (i = 0;     i < count;     i++, currentResDesc++) {
        switch (currentResDesc->Type) {
        case CmResourceTypeMemory:
            Globals.RegistersMapped = TRUE;

        case CmResourceTypePort:
            //
            // Copy the port information.  We will sort the port list
            // into ascending order based on the starting port address
            // later (note that we *know* there are a max of two port
            // ranges for the i8042).
            //
#if 0
            if (currentResDesc->Flags == CM_RESOURCE_PORT_MEMORY) {
                Globals.RegistersMapped = TRUE;
            }
#endif

            Print(DBG_SS_NOISE,
                  ("port is %s.\n",
                  Globals.RegistersMapped ? "memory" : "io"));

            if (configuration->PortListCount < MaximumPortCount) {
                configuration->PortList[configuration->PortListCount] =
                    *currentResDesc;
                configuration->PortList[configuration->PortListCount].ShareDisposition =
                    I8042_REGISTER_SHARE ? CmResourceShareShared:
                                           CmResourceShareDriverExclusive;
                configuration->PortListCount += 1;
            }
            else {
                Print(DBG_SS_INFO | DBG_SS_ERROR,
                      ("KB::PortListCount already at max (%d)\n",
                       configuration->PortListCount
                      )
                     );
            }
            break;

        case CmResourceTypeInterrupt:

            //
            // Copy the interrupt information.
            //
            KeyboardExtension->InterruptDescriptor = *currentResDesc;
            KeyboardExtension->InterruptDescriptor.ShareDisposition =
                defaultInterruptShare ? CmResourceShareShared :
                                        CmResourceShareDeviceExclusive;

            break;

        default:
            Print(DBG_ALWAYS,
                  ("resource type 0x%x unhandled...\n",
                  (LONG) currentResDesc->Type
                  ));
            break;
        }
    }

    if (KeyboardExtension->InterruptDescriptor.Type & CmResourceTypeInterrupt) {
        Print(DBG_SS_INFO,
              ("Keyboard interrupt config --\n"
              "    %s, %s, Irq = 0x%x\n",
              KeyboardExtension->InterruptDescriptor.ShareDisposition ==
                  CmResourceShareShared ? "Sharable" : "NonSharable",
              KeyboardExtension->InterruptDescriptor.Flags ==
                  CM_RESOURCE_INTERRUPT_LATCHED ? "Latched" : "Level Sensitive",
              KeyboardExtension->InterruptDescriptor.u.Interrupt.Vector
              ));
    }
    //
    // If no keyboard-specific information (i.e., keyboard type, subtype,
    // and initial LED settings) was found, use the keyboard driver
    // defaults.
    //
    if (KeyboardExtension->KeyboardAttributes.KeyboardIdentifier.Type == 0) {

        Print(DBG_SS_INFO, ("Using default keyboard type\n"));

        KeyboardExtension->KeyboardAttributes.KeyboardIdentifier.Type =
            KEYBOARD_TYPE_DEFAULT;
        KeyboardExtension->KeyboardIndicators.LedFlags =
            KEYBOARD_INDICATORS_DEFAULT;

        KeyboardExtension->KeyboardIdentifierEx.Type = KEYBOARD_TYPE_DEFAULT;
    }

    Print(DBG_SS_INFO,
          ("Keyboard device specific data --\n"
          "    Type = %d, Subtype = %d, Initial LEDs = 0x%x\n",
          KeyboardExtension->KeyboardAttributes.KeyboardIdentifier.Type,
          KeyboardExtension->KeyboardAttributes.KeyboardIdentifier.Subtype,
          KeyboardExtension->KeyboardIndicators.LedFlags
          ));

    keyboardId = &KeyboardExtension->KeyboardAttributes.KeyboardIdentifier;
    if (!ENHANCED_KEYBOARD(*keyboardId)) {
        Print(DBG_SS_INFO, ("Old AT-style keyboard\n"));
        configuration->PollingIterations =
            configuration->PollingIterationsMaximum;
    }

    //
    // Initialize keyboard-specific configuration parameters.
    //

    if (FAREAST_KEYBOARD(*keyboardId)) {
        ULONG                      iIndex = 0;
        PKEYBOARD_TYPE_INFORMATION pKeyboardTypeInformation = NULL;

        while (KeyboardFarEastOemInformation[iIndex].KeyboardId.Type) {
            if ((KeyboardFarEastOemInformation[iIndex].KeyboardId.Type
                         == keyboardId->Type) &&
                (KeyboardFarEastOemInformation[iIndex].KeyboardId.Subtype
                         == keyboardId->Subtype)) {

                pKeyboardTypeInformation = (PKEYBOARD_TYPE_INFORMATION)
                    &(KeyboardFarEastOemInformation[iIndex].KeyboardTypeInformation);
                break;
            }

            iIndex++;
        }

        if (pKeyboardTypeInformation == NULL) {

            //
            // Set default...
            //

            pKeyboardTypeInformation = (PKEYBOARD_TYPE_INFORMATION)
                &(KeyboardTypeInformation[KEYBOARD_TYPE_DEFAULT-1]);
        }

        KeyboardExtension->KeyboardAttributes.NumberOfFunctionKeys =
            pKeyboardTypeInformation->NumberOfFunctionKeys;
        KeyboardExtension->KeyboardAttributes.NumberOfIndicators =
            pKeyboardTypeInformation->NumberOfIndicators;
        KeyboardExtension->KeyboardAttributes.NumberOfKeysTotal =
            pKeyboardTypeInformation->NumberOfKeysTotal;
    }
    else {
        KeyboardExtension->KeyboardAttributes.NumberOfFunctionKeys =
            KeyboardTypeInformation[keyboardId->Type - 1].NumberOfFunctionKeys;
        KeyboardExtension->KeyboardAttributes.NumberOfIndicators =
            KeyboardTypeInformation[keyboardId->Type - 1].NumberOfIndicators;
        KeyboardExtension->KeyboardAttributes.NumberOfKeysTotal =
            KeyboardTypeInformation[keyboardId->Type - 1].NumberOfKeysTotal;
    }

    KeyboardExtension->KeyboardAttributes.KeyboardMode =
        KEYBOARD_SCAN_CODE_SET;

    KeyboardExtension->KeyboardAttributes.KeyRepeatMinimum.Rate =
        KEYBOARD_TYPEMATIC_RATE_MINIMUM;
    KeyboardExtension->KeyboardAttributes.KeyRepeatMinimum.Delay =
        KEYBOARD_TYPEMATIC_DELAY_MINIMUM;
    KeyboardExtension->KeyboardAttributes.KeyRepeatMaximum.Rate =
        KEYBOARD_TYPEMATIC_RATE_MAXIMUM;
    KeyboardExtension->KeyboardAttributes.KeyRepeatMaximum.Delay =
        KEYBOARD_TYPEMATIC_DELAY_MAXIMUM;
    KeyboardExtension->KeyRepeatCurrent.Rate =
        KEYBOARD_TYPEMATIC_RATE_DEFAULT;
    KeyboardExtension->KeyRepeatCurrent.Delay =
        KEYBOARD_TYPEMATIC_DELAY_DEFAULT;

    return status;
}

#if defined(_X86_)
ULONG
I8042ConversionStatusForOasys(
    IN ULONG fOpen,
    IN ULONG ConvStatus)

/*++

Routine Description:

    This routine convert ime open/close status and ime converion mode to
    FMV oyayubi-shift keyboard device internal input mode.

Arguments:


Return Value:

    FMV oyayubi-shift keyboard's internal input mode.

--*/
{
    ULONG ImeMode = 0;

    if (fOpen) {
        if (ConvStatus & IME_CMODE_ROMAN) {
            if (ConvStatus & IME_CMODE_ALPHANUMERIC) {
                //
                // Alphanumeric, roman mode.
                //
                ImeMode = THUMB_ROMAN_ALPHA_CAPSON;
            } else if (ConvStatus & IME_CMODE_KATAKANA) {
                //
                // Katakana, roman mode.
                //
                ImeMode = THUMB_ROMAN_KATAKANA;
            } else if (ConvStatus & IME_CMODE_NATIVE) {
                //
                // Hiragana, roman mode.
                //
                ImeMode = THUMB_ROMAN_HIRAGANA;
            } else {
                ImeMode = THUMB_ROMAN_ALPHA_CAPSON;
            }
        } else {
            if (ConvStatus & IME_CMODE_ALPHANUMERIC) {
                //
                // Alphanumeric, no-roman mode.
                //
                ImeMode = THUMB_NOROMAN_ALPHA_CAPSON;
            } else if (ConvStatus & IME_CMODE_KATAKANA) {
                //
                // Katakana, no-roman mode.
                //
                ImeMode = THUMB_NOROMAN_KATAKANA;
            } else if (ConvStatus & IME_CMODE_NATIVE) {
                //
                // Hiragana, no-roman mode.
                //
                ImeMode = THUMB_NOROMAN_HIRAGANA;
            } else {
                ImeMode = THUMB_NOROMAN_ALPHA_CAPSON;
            }
        }
    } else {
        //
        // Ime close. In this case, internal mode is always this value.
        // (the both LED off roman and kana)
        //
        ImeMode = THUMB_NOROMAN_ALPHA_CAPSON;
    }

    return ImeMode;
}

ULONG
I8042QueryIMEStatusForOasys(
    IN PKEYBOARD_IME_STATUS KeyboardIMEStatus
    )
{
    ULONG InternalMode;

    //
    // Map to IME mode to hardware mode.
    //
    InternalMode = I8042ConversionStatusForOasys(
                KeyboardIMEStatus->ImeOpen,
                KeyboardIMEStatus->ImeConvMode
                );

    return InternalMode;
}

NTSTATUS
I8042SetIMEStatusForOasys(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN OUT PINITIATE_OUTPUT_CONTEXT InitiateContext
    )
{
    PKEYBOARD_IME_STATUS KeyboardIMEStatus;
    PPORT_KEYBOARD_EXTENSION  kbExtension;
    ULONG InternalMode;
    LARGE_INTEGER deltaTime;

    kbExtension = DeviceObject->DeviceExtension;

    //
    // Get pointer to KEYBOARD_IME_STATUS buffer.
    //
    KeyboardIMEStatus = (PKEYBOARD_IME_STATUS)(Irp->AssociatedIrp.SystemBuffer);

    //
    // Map IME mode to keyboard hardware mode.
    //
    InternalMode = I8042QueryIMEStatusForOasys(KeyboardIMEStatus);

    //
    // Set up the context structure for the InitiateIo wrapper.
    //
    InitiateContext->Bytes = Globals.ControllerData->DefaultBuffer;
    InitiateContext->DeviceObject = DeviceObject;
    InitiateContext->ByteCount = 3;
    InitiateContext->Bytes[0] = 0xF0;
    InitiateContext->Bytes[1] = 0x8C;
    InitiateContext->Bytes[2]  = (UCHAR)InternalMode;

    return (STATUS_SUCCESS);
}
#endif // defined(_X86_)

VOID
I8xQueueCurrentKeyboardInput(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine queues the current input data to be processed by a
    DPC outside the ISR

Arguments:

    DeviceObject - Pointer to the device object

Return Value:

    None

--*/
{
    PPORT_KEYBOARD_EXTENSION deviceExtension;

    deviceExtension = DeviceObject->DeviceExtension;

    if (deviceExtension->EnableCount) {

        if (!I8xWriteDataToKeyboardQueue(
                 deviceExtension,
                 &deviceExtension->CurrentInput
                 )) {

            //
            // The InputData queue overflowed.  There is
            // not much that can be done about it, so just
            // continue (but don't queue the ISR DPC, since
            // no new packets were added to the queue).
            //
            // Queue a DPC to log an overrun error.
            //

            IsrPrint(DBG_KBISR_ERROR, ("queue overflow\n"));

            if (deviceExtension->OkayToLogOverflow) {
                KeInsertQueueDpc(
                    &deviceExtension->ErrorLogDpc,
                    (PIRP) NULL,
                    LongToPtr(I8042_KBD_BUFFER_OVERFLOW)
                    );
                deviceExtension->OkayToLogOverflow = FALSE;
            }

        } else if (deviceExtension->DpcInterlockKeyboard >= 0) {

           //
           // The ISR DPC is already executing.  Tell the ISR DPC
           // it has more work to do by incrementing
           // DpcInterlockKeyboard.
           //

           deviceExtension->DpcInterlockKeyboard += 1;

        } else {

            //
            // Queue the ISR DPC.
            //

            KeInsertQueueDpc(
                &deviceExtension->KeyboardIsrDpc,
                DeviceObject->CurrentIrp,
                NULL
                );
        }
    }

    //
    // Reset the input state.
    //
    deviceExtension->CurrentInput.Flags = 0;
}

VOID
I8xServiceCrashDump(
    IN PPORT_KEYBOARD_EXTENSION DeviceExtension,
    IN PUNICODE_STRING          RegistryPath
    )

/*++

Routine Description:

    This routine retrieves this driver's service parameters information
    from the registry.

Arguments:

    DeviceExtension - Pointer to the device extension.

    RegistryPath - Pointer to the null-terminated Unicode name of the
        registry path for this driver.

Return Value:

    None.  As a side-effect, sets fields in DeviceExtension->Dump1Keys
    & DeviceExtension->Dump2Key.

--*/

{
    PRTL_QUERY_REGISTRY_TABLE parameters = NULL;
    UNICODE_STRING parametersPath;
    LONG defaultCrashFlags = 0;
    LONG crashFlags;
    LONG defaultKeyNumber = 0;
    LONG keyNumber;
    NTSTATUS status = STATUS_SUCCESS;
    PWSTR path = NULL;
    USHORT queriesPlusOne = 3;

    const UCHAR keyToScanTbl[134] = {
        0x00,0x29,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,
        0x0A,0x0B,0x0C,0x0D,0x7D,0x0E,0x0F,0x10,0x11,0x12,
        0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x00,
        0x3A,0x1E,0x1F,0x20,0x21,0x22,0x23,0x24,0x25,0x26,
        0x27,0x28,0x2B,0x1C,0x2A,0x00,0x2C,0x2D,0x2E,0x2F,
        0x30,0x31,0x32,0x33,0x34,0x35,0x73,0x36,0x1D,0x00,
        0x38,0x39,0xB8,0x00,0x9D,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0xD2,0xD3,0x00,0x00,0xCB,
        0xC7,0xCF,0x00,0xC8,0xD0,0xC9,0xD1,0x00,0x00,0xCD,
        0x45,0x47,0x4B,0x4F,0x00,0xB5,0x48,0x4C,0x50,0x52,
        0x37,0x49,0x4D,0x51,0x53,0x4A,0x4E,0x00,0x9C,0x00,
        0x01,0x00,0x3B,0x3C,0x3D,0x3E,0x3F,0x40,0x41,0x42,
        0x43,0x44,0x57,0x58,0x00,0x46,0x00,0x00,0x00,0x00,
        0x00,0x7B,0x79,0x70 };

    PAGED_CODE();

    parametersPath.Buffer = NULL;

    //
    // Registry path is already null-terminated, so just use it.
    //

    path = RegistryPath->Buffer;

    if (NT_SUCCESS(status)) {

        //
        // Allocate the Rtl query table.
        //

        parameters = ExAllocatePool(
                         PagedPool,
                         sizeof(RTL_QUERY_REGISTRY_TABLE) * queriesPlusOne
                         );

        if (!parameters) {

            Print(DBG_SS_ERROR,
                 ("I8xServiceCrashDump: Couldn't allocate table for Rtl query to parameters for %ws\n",
                 path
                 ));

            status = STATUS_UNSUCCESSFUL;

        } else {

            RtlZeroMemory(
                parameters,
                sizeof(RTL_QUERY_REGISTRY_TABLE) * queriesPlusOne
                );

            //
            // Form a path to this driver's Parameters subkey.
            //

            RtlInitUnicodeString(
                &parametersPath,
                NULL
                );

            parametersPath.MaximumLength = RegistryPath->Length +
                                           sizeof(L"\\Crashdump");

            parametersPath.Buffer = ExAllocatePool(
                                        PagedPool,
                                        parametersPath.MaximumLength
                                        );

            if (!parametersPath.Buffer) {

                Print(DBG_SS_ERROR,
                     ("I8xServiceCrashDump: Couldn't allocate string for path to parameters for %ws\n",
                     path
                     ));

                status = STATUS_UNSUCCESSFUL;

            }
        }
    }

    if (NT_SUCCESS(status)) {

        //
        // Form the parameters path.
        //

        RtlZeroMemory(
            parametersPath.Buffer,
            parametersPath.MaximumLength
            );
        RtlAppendUnicodeToString(
            &parametersPath,
            path
            );
        RtlAppendUnicodeToString(
            &parametersPath,
            L"\\Crashdump"
            );

        Print(DBG_SS_INFO,
             ("I8xServiceCrashDump: crashdump path is %ws\n",
             parametersPath.Buffer
             ));

        //
        // Gather all of the "user specified" information from
        // the registry.
        //

        parameters[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[0].Name = L"Dump1Keys";
        parameters[0].EntryContext = &crashFlags;
        parameters[0].DefaultType = REG_DWORD;
        parameters[0].DefaultData = &defaultCrashFlags;
        parameters[0].DefaultLength = sizeof(LONG);

        parameters[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[1].Name = L"Dump2Key";
        parameters[1].EntryContext = &keyNumber;
        parameters[1].DefaultType = REG_DWORD;
        parameters[1].DefaultData = &defaultKeyNumber;
        parameters[1].DefaultLength = sizeof(LONG);

        status = RtlQueryRegistryValues(
                     RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                     parametersPath.Buffer,
                     parameters,
                     NULL,
                     NULL
                     );
    }

    if (!NT_SUCCESS(status)) {
        //
        // Go ahead and assign driver defaults.
        //
        DeviceExtension->CrashFlags = defaultCrashFlags;
    }
    else {
        DeviceExtension->CrashFlags = crashFlags;
    }

    if (DeviceExtension->CrashFlags) {
        if (keyNumber == 124) {
            DeviceExtension->CrashScanCode = KEYBOARD_DEBUG_HOTKEY_ENH | 0x80;
            DeviceExtension->CrashScanCode2 = KEYBOARD_DEBUG_HOTKEY_AT;
        }
        else {
            if(keyNumber <= 133) {
                DeviceExtension->CrashScanCode = keyToScanTbl[keyNumber];
            }
            else {
                DeviceExtension->CrashScanCode = 0;
            }

            DeviceExtension->CrashScanCode2 = 0;
        }
    }

    Print(DBG_SS_NOISE,
         ("I8xServiceCrashDump: CrashFlags = 0x%x\n",
         DeviceExtension->CrashFlags
         ));
    Print(DBG_SS_NOISE,
         ("I8xServiceCrashDump: CrashScanCode = 0x%x, CrashScanCode2 = 0x%x\n",
         (ULONG) DeviceExtension->CrashScanCode,
         (ULONG) DeviceExtension->CrashScanCode2
         ));

    //
    // Free the allocated memory before returning.
    //
    if (parametersPath.Buffer)
        ExFreePool(parametersPath.Buffer);
    if (parameters)
        ExFreePool(parameters);
}

VOID
I8xKeyboardServiceParameters(
    IN PUNICODE_STRING          RegistryPath,
    IN PPORT_KEYBOARD_EXTENSION KeyboardExtension
    )
/*++

Routine Description:

    This routine retrieves this driver's service parameters information
    from the registry.  Overrides these values if they are present in the
    devnode.

Arguments:

    RegistryPath - Pointer to the null-terminated Unicode name of the
        registry path for this driver.

    KeyboardExtension - Keyboard extension

Return Value:

    None.

--*/
{
    NTSTATUS                            status = STATUS_SUCCESS;
    PI8042_CONFIGURATION_INFORMATION    configuration;
    PRTL_QUERY_REGISTRY_TABLE           parameters = NULL;
    PWSTR                               path = NULL;
    ULONG                               defaultDataQueueSize = DATA_QUEUE_SIZE;
    ULONG                               invalidKeyboardSubtype = (ULONG) -1;
    ULONG                               invalidKeyboardType = 0;
    ULONG                               overrideKeyboardSubtype = (ULONG) -1;
    ULONG                               overrideKeyboardType = 0;
    ULONG                               pollStatusIterations = 0;
    ULONG                               defaultPowerCaps = 0x0, powerCaps = 0x0;
    ULONG                               failedReset = FAILED_RESET_DEFAULT,
                                        defaultFailedReset = FAILED_RESET_DEFAULT;
    ULONG                               i = 0;
    UNICODE_STRING                      parametersPath;
    HANDLE                              keyHandle;
    ULONG                               defaultPollStatusIterations = I8042_POLLING_DEFAULT;

    ULONG                               crashOnCtrlScroll = 0,
                                        defaultCrashOnCtrlScroll = 0;

    USHORT                              queries = 8;

    PAGED_CODE();

#if I8042_VERBOSE
    queries += 2;
#endif

    configuration = &(Globals.ControllerData->Configuration);
    parametersPath.Buffer = NULL;

    //
    // Registry path is already null-terminated, so just use it.
    //
    path = RegistryPath->Buffer;

    if (NT_SUCCESS(status)) {

        //
        // Allocate the Rtl query table.
        //
        parameters = ExAllocatePool(
            PagedPool,
            sizeof(RTL_QUERY_REGISTRY_TABLE) * (queries + 1)
            );

        if (!parameters) {

            Print(DBG_SS_ERROR,
                 ("%s: couldn't allocate table for Rtl query to %ws for %ws\n",
                 pFncServiceParameters,
                 pwParameters,
                 path
                 ));
            status = STATUS_UNSUCCESSFUL;

        } else {

            RtlZeroMemory(
                parameters,
                sizeof(RTL_QUERY_REGISTRY_TABLE) * (queries + 1)
                );

            //
            // Form a path to this driver's Parameters subkey.
            //
            RtlInitUnicodeString( &parametersPath, NULL );
            parametersPath.MaximumLength = RegistryPath->Length +
                (wcslen(pwParameters) * sizeof(WCHAR) ) + sizeof(UNICODE_NULL);

            parametersPath.Buffer = ExAllocatePool(
                PagedPool,
                parametersPath.MaximumLength
                );

            if (!parametersPath.Buffer) {

                Print(DBG_SS_ERROR,
                     ("%s: Couldn't allocate string for path to %ws for %ws\n",
                     pFncServiceParameters,
                     pwParameters,
                     path
                     ));
                status = STATUS_UNSUCCESSFUL;

            }
        }
    }

    if (NT_SUCCESS(status)) {

        //
        // Form the parameters path.
        //

        RtlZeroMemory(
            parametersPath.Buffer,
            parametersPath.MaximumLength
            );
        RtlAppendUnicodeToString(
            &parametersPath,
            path
            );
        RtlAppendUnicodeToString(
            &parametersPath,
            pwParameters
            );

        //
        // Gather all of the "user specified" information from
        // the registry.
        //
        parameters[i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = pwKeyboardDataQueueSize;
        parameters[i].EntryContext =
            &KeyboardExtension->KeyboardAttributes.InputDataQueueLength;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &defaultDataQueueSize;
        parameters[i].DefaultLength = sizeof(ULONG);

        parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = pwOverrideKeyboardType;
        parameters[i].EntryContext = &overrideKeyboardType;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &invalidKeyboardType;
        parameters[i].DefaultLength = sizeof(ULONG);

        parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = pwOverrideKeyboardSubtype;
        parameters[i].EntryContext = &overrideKeyboardSubtype;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &invalidKeyboardSubtype;
        parameters[i].DefaultLength = sizeof(ULONG);

        parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = pwPollStatusIterations;
        parameters[i].EntryContext = &pollStatusIterations;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &defaultPollStatusIterations;
        parameters[i].DefaultLength = sizeof(ULONG);

        parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = pwPowerCaps;
        parameters[i].EntryContext = &powerCaps;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &defaultPowerCaps;
        parameters[i].DefaultLength = sizeof(ULONG);

        parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = L"CrashOnCtrlScroll";
        parameters[i].EntryContext = &crashOnCtrlScroll;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &defaultCrashOnCtrlScroll;
        parameters[i].DefaultLength = sizeof(ULONG);

        parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = STR_FAILED_RESET;
        parameters[i].EntryContext = &failedReset;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &defaultFailedReset;
        parameters[i].DefaultLength = sizeof(ULONG);

        status = RtlQueryRegistryValues(
            RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
            parametersPath.Buffer,
            parameters,
            NULL,
            NULL
            );

        if (!NT_SUCCESS(status)) {
            Print(DBG_SS_INFO,
                 ("kb RtlQueryRegistryValues failed (0x%x)\n",
                 status
                 ));
        }
    }

    if (!NT_SUCCESS(status)) {

        //
        // Go ahead and assign driver defaults.
        //
        configuration->PollStatusIterations = (USHORT)
            defaultPollStatusIterations;
        KeyboardExtension->KeyboardAttributes.InputDataQueueLength =
            defaultDataQueueSize;
    }
    else {
        configuration->PollStatusIterations = (USHORT) pollStatusIterations;
    }

    switch (failedReset) {
    case FAILED_RESET_STOP:
    case FAILED_RESET_PROCEED:
    case FAILED_RESET_PROCEED_ALWAYS:
        KeyboardExtension->FailedReset = (UCHAR) failedReset;
        break;

    default:
        KeyboardExtension->FailedReset = FAILED_RESET_DEFAULT;
        break;
    }

    Print(DBG_SS_NOISE, ("Failed reset is set to %d\n", 
          KeyboardExtension->FailedReset));

    status = IoOpenDeviceRegistryKey(KeyboardExtension->PDO,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     STANDARD_RIGHTS_READ,
                                     &keyHandle
                                     );

    if (NT_SUCCESS(status)) {
        //
        // If the value is not present in devnode, then the default is the value
        // read in from the Services\i8042prt\Parameters key
        //
        ULONG prevInputDataQueueLength,
              prevPowerCaps,
              prevOverrideKeyboardType,
              prevOverrideKeyboardSubtype,
              prevPollStatusIterations;

        prevInputDataQueueLength =
            KeyboardExtension->KeyboardAttributes.InputDataQueueLength;
        prevPowerCaps = powerCaps;
        prevOverrideKeyboardType = overrideKeyboardType;
        prevOverrideKeyboardSubtype = overrideKeyboardSubtype;
        prevPollStatusIterations = pollStatusIterations;

        RtlZeroMemory(
            parameters,
            sizeof(RTL_QUERY_REGISTRY_TABLE) * (queries + 1)
            );

        i = 0;

        //
        // Gather all of the "user specified" information from
        // the registry (this time from the devnode)
        //
        parameters[i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = pwKeyboardDataQueueSize;
        parameters[i].EntryContext =
            &KeyboardExtension->KeyboardAttributes.InputDataQueueLength;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &prevInputDataQueueLength;
        parameters[i].DefaultLength = sizeof(ULONG);

        parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = pwOverrideKeyboardType;
        parameters[i].EntryContext = &overrideKeyboardType;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &prevOverrideKeyboardType;
        parameters[i].DefaultLength = sizeof(ULONG);

        parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = pwOverrideKeyboardSubtype;
        parameters[i].EntryContext = &overrideKeyboardSubtype;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &prevOverrideKeyboardSubtype;
        parameters[i].DefaultLength = sizeof(ULONG);

        parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = pwPollStatusIterations;
        parameters[i].EntryContext = &pollStatusIterations;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &prevPollStatusIterations;
        parameters[i].DefaultLength = sizeof(ULONG);

        parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = pwPowerCaps,
        parameters[i].EntryContext = &powerCaps;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &prevPowerCaps;
        parameters[i].DefaultLength = sizeof(ULONG);

        status = RtlQueryRegistryValues(
                    RTL_REGISTRY_HANDLE,
                    (PWSTR) keyHandle,
                    parameters,
                    NULL,
                    NULL
                    );

        if (!NT_SUCCESS(status)) {
            Print(DBG_SS_INFO,
                  ("kb RtlQueryRegistryValues (via handle) failed (0x%x)\n",
                  status
                  ));
        }

        ZwClose(keyHandle);
    }
    else {
        Print(DBG_SS_INFO | DBG_SS_ERROR,
             ("kb, opening devnode handle failed (0x%x)\n",
             status
             ));
    }

    Print(DBG_SS_NOISE, ("I8xKeyboardServiceParameters results..\n"));

    Print(DBG_SS_NOISE,
          (pDumpDecimal,
          pwPollStatusIterations,
          configuration->PollStatusIterations
          ));

    if (KeyboardExtension->KeyboardAttributes.InputDataQueueLength == 0) {

        Print(DBG_SS_INFO | DBG_SS_ERROR,
             ("\toverriding %ws = 0x%x\n",
             pwKeyboardDataQueueSize,
             KeyboardExtension->KeyboardAttributes.InputDataQueueLength
             ));

        KeyboardExtension->KeyboardAttributes.InputDataQueueLength =
            defaultDataQueueSize;

    }
    KeyboardExtension->KeyboardAttributes.InputDataQueueLength *=
        sizeof(KEYBOARD_INPUT_DATA);

    KeyboardExtension->PowerCaps = (UCHAR) (powerCaps & I8042_SYS_BUTTONS);
    Print(DBG_SS_NOISE, (pDumpHex, pwPowerCaps, KeyboardExtension->PowerCaps));

    if (overrideKeyboardType != invalidKeyboardType) {

        if (overrideKeyboardType <= NUM_KNOWN_KEYBOARD_TYPES) {

            Print(DBG_SS_NOISE,
                 (pDumpDecimal,
                 pwOverrideKeyboardType,
                 overrideKeyboardType
                 ));

            KeyboardExtension->KeyboardAttributes.KeyboardIdentifier.Type =
                (UCHAR) overrideKeyboardType;

        } else {

            Print(DBG_SS_NOISE,
                 (pDumpDecimal,
                 pwOverrideKeyboardType,
                 overrideKeyboardType
                 ));

        }

        KeyboardExtension->KeyboardIdentifierEx.Type = overrideKeyboardType;
    }

    if (overrideKeyboardSubtype != invalidKeyboardSubtype) {

        Print(DBG_SS_NOISE,
             (pDumpDecimal,
             pwOverrideKeyboardSubtype,
             overrideKeyboardSubtype
             ));

        KeyboardExtension->KeyboardAttributes.KeyboardIdentifier.Subtype =
            (UCHAR) overrideKeyboardSubtype;

        KeyboardExtension->KeyboardIdentifierEx.Subtype  =
            overrideKeyboardSubtype;
    }

    if (crashOnCtrlScroll) {
        Print(DBG_SS_INFO, ("Crashing on Ctrl + Scroll Lock\n"));

        KeyboardExtension->CrashFlags = CRASH_R_CTRL;
        KeyboardExtension->CrashScanCode = SCROLL_LOCK_SCANCODE;
        KeyboardExtension->CrashScanCode2 = 0x0;
    }

    //
    // Free the allocated memory before returning.
    //
    if (parametersPath.Buffer)
        ExFreePool(parametersPath.Buffer);
    if (parameters)
        ExFreePool(parameters);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\pnpi8042\moucmn.c ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    moucmn.c

Abstract:

    The common portions of the Intel i8042 port driver which
    apply to the auxiliary (PS/2 mouse) device.

Environment:

    Kernel mode only.

Notes:

    NOTES:  (Future/outstanding issues)

    - Powerfail not implemented.

    - Consolidate duplicate code, where possible and appropriate.

Revision History:

--*/

#include "stdarg.h"
#include "stdio.h"
#include "string.h"
#include "i8042prt.h"

#ifdef ALLOC_PRAGMA

#if 1
#pragma alloc_text(PAGEMOUC, I8042MouseIsrDpc)
#pragma alloc_text(PAGEMOUC, I8xWriteDataToMouseQueue)
#endif

#endif

VOID
I8042MouseIsrDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL to finish processing
    mouse interrupts.  It is queued in the mouse ISR.  The real
    work is done via a callback to the connected mouse class driver.

Arguments:

    Dpc - Pointer to the DPC object.

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the Irp.

    Context - Not used.

Return Value:

    None.

--*/

{
    PPORT_MOUSE_EXTENSION deviceExtension;
    GET_DATA_POINTER_CONTEXT getPointerContext;
    SET_DATA_POINTER_CONTEXT setPointerContext;
    VARIABLE_OPERATION_CONTEXT operationContext;
    PVOID classService;
    PVOID classDeviceObject;
    LONG interlockedResult;
    BOOLEAN moreDpcProcessing;
    ULONG dataNotConsumed = 0;
    ULONG inputDataConsumed = 0;
    LARGE_INTEGER deltaTime;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(Irp);
    UNREFERENCED_PARAMETER(Context);

    Print(DBG_DPC_TRACE, ("I8042MouseIsrDpc: enter\n"));

    deviceExtension = (PPORT_MOUSE_EXTENSION) DeviceObject->DeviceExtension;
    //
    // Use DpcInterlockMouse to determine whether the DPC is running
    // concurrently on another processor.  We only want one instantiation
    // of the DPC to actually do any work.  DpcInterlockMouse is -1
    // when no DPC is executing.  We increment it, and if the result is
    // zero then the current instantiation is the only one executing, and it
    // is okay to proceed.  Otherwise, we just return.
    //
    //

    operationContext.VariableAddress =
        &deviceExtension->DpcInterlockMouse;
    operationContext.Operation = IncrementOperation;
    operationContext.NewValue = &interlockedResult;

    KeSynchronizeExecution(
            deviceExtension->InterruptObject,
            (PKSYNCHRONIZE_ROUTINE) I8xDpcVariableOperation,
            (PVOID) &operationContext
            );

    moreDpcProcessing = (interlockedResult == 0)? TRUE:FALSE;

    while (moreDpcProcessing) {

        dataNotConsumed = 0;
        inputDataConsumed = 0;

        //
        // Get the port InputData queue pointers synchronously.
        //

        getPointerContext.DeviceExtension = deviceExtension;
        setPointerContext.DeviceExtension = deviceExtension;
        getPointerContext.DeviceType = (CCHAR) MouseDeviceType;
        setPointerContext.DeviceType = (CCHAR) MouseDeviceType;
        setPointerContext.InputCount = 0;

        KeSynchronizeExecution(
            deviceExtension->InterruptObject,
            (PKSYNCHRONIZE_ROUTINE) I8xGetDataQueuePointer,
            (PVOID) &getPointerContext
            );

        if (getPointerContext.InputCount != 0) {

            //
            // Call the connected class driver's callback ISR with the
            // port InputData queue pointers.  If we have to wrap the queue,
            // break the operation into two pieces, and call the class callback
            // ISR once for each piece.
            //

            classDeviceObject =
                deviceExtension->ConnectData.ClassDeviceObject;
            classService =
                deviceExtension->ConnectData.ClassService;
            ASSERT(classService != NULL);

            if (getPointerContext.DataOut >= getPointerContext.DataIn) {

                //
                // We'll have to wrap the InputData circular buffer.  Call
                // the class callback ISR with the chunk of data starting at
                // DataOut and ending at the end of the queue.
                //

                Print(DBG_DPC_NOISE,
                      ("I8042MouseIsrDpc: calling class callback\n"
                      ));
                Print(DBG_DPC_INFO,
                      ("I8042MouseIsrDpc: with Start 0x%x and End 0x%x\n",
                      getPointerContext.DataOut,
                      deviceExtension->DataEnd
                      ));

                (*(PSERVICE_CALLBACK_ROUTINE) classService)(
                      classDeviceObject,
                      getPointerContext.DataOut,
                      deviceExtension->DataEnd,
                      &inputDataConsumed
                      );

                dataNotConsumed = ((ULONG)((PUCHAR)
                    deviceExtension->DataEnd -
                    (PUCHAR) getPointerContext.DataOut)
                    / sizeof(MOUSE_INPUT_DATA)) - inputDataConsumed;

                Print(DBG_DPC_INFO,
                      ("I8042MouseIsrDpc: (Wrap) Call callback consumed %d items, left %d\n",
                      inputDataConsumed,
                      dataNotConsumed
                      ));

                setPointerContext.InputCount += inputDataConsumed;

                if (dataNotConsumed) {
                    setPointerContext.DataOut =
                        ((PUCHAR)getPointerContext.DataOut) +
                        (inputDataConsumed * sizeof(MOUSE_INPUT_DATA));
                } else {
                    setPointerContext.DataOut =
                        deviceExtension->InputData;
                    getPointerContext.DataOut = setPointerContext.DataOut;
                }
            }

            //
            // Call the class callback ISR with data remaining in the queue.
            //

            if ((dataNotConsumed == 0) &&
                (inputDataConsumed < getPointerContext.InputCount)){
                Print(DBG_DPC_NOISE,
                      ("I8042MouseIsrDpc: calling class callback\n"
                      ));
                Print(DBG_DPC_INFO,
                     ("I8042MouseIsrDpc: with Start 0x%x and End 0x%x\n",
                      getPointerContext.DataOut,
                      getPointerContext.DataIn
                      ));

                (*(PSERVICE_CALLBACK_ROUTINE) classService)(
                      classDeviceObject,
                      getPointerContext.DataOut,
                      getPointerContext.DataIn,
                      &inputDataConsumed
                      );

                dataNotConsumed = ((ULONG)((PUCHAR) getPointerContext.DataIn -
                      (PUCHAR) getPointerContext.DataOut)
                      / sizeof(MOUSE_INPUT_DATA)) - inputDataConsumed;

                Print(DBG_DPC_INFO,
                      ("I8042MouseIsrDpc: Call callback consumed %d items, left %d\n",
                      inputDataConsumed,
                      dataNotConsumed
                      ));

                setPointerContext.DataOut =
                    ((PUCHAR)getPointerContext.DataOut) +
                    (inputDataConsumed * sizeof(MOUSE_INPUT_DATA));
                setPointerContext.InputCount += inputDataConsumed;

            }

            //
            // Update the port InputData queue DataOut pointer and InputCount
            // synchronously.
            //

            KeSynchronizeExecution(
                deviceExtension->InterruptObject,
                (PKSYNCHRONIZE_ROUTINE) I8xSetDataQueuePointer,
                (PVOID) &setPointerContext
                );

        }

        if (dataNotConsumed) {

            //
            // The class driver was unable to consume all the data.
            // Reset the interlocked variable to -1.  We do not want
            // to attempt to move more data to the class driver at this
            // point, because it is already overloaded.  Need to wait a
            // while to give the Raw Input Thread a chance to read some
            // of the data out of the class driver's queue.  We accomplish
            // this "wait" via a timer.
            //

            Print(DBG_DPC_INFO,
                  ("I8042MouseIsrDpc: set timer in DPC\n"
                  ));

            operationContext.Operation = WriteOperation;
            interlockedResult = -1;
            operationContext.NewValue = &interlockedResult;

            KeSynchronizeExecution(
                    deviceExtension->InterruptObject,
                    (PKSYNCHRONIZE_ROUTINE) I8xDpcVariableOperation,
                    (PVOID) &operationContext
                    );

            deltaTime.LowPart = (ULONG)(-10 * 1000 * 1000);
            deltaTime.HighPart = -1;

            (VOID) KeSetTimer(
                       &deviceExtension->DataConsumptionTimer,
                       deltaTime,
                       &deviceExtension->MouseIsrDpcRetry
                       );

            moreDpcProcessing = FALSE;

        } else {

            //
            // Decrement DpcInterlockMouse.  If the result goes negative,
            // then we're all finished processing the DPC.  Otherwise, either
            // the ISR incremented DpcInterlockMouse because it has more
            // work for the ISR DPC to do, or a concurrent DPC executed on
            // some processor while the current DPC was running (the
            // concurrent DPC wouldn't have done any work).  Make sure that
            // the current DPC handles any extra work that is ready to be
            // done.
            //

            operationContext.Operation = DecrementOperation;
            operationContext.NewValue = &interlockedResult;

            KeSynchronizeExecution(
                    deviceExtension->InterruptObject,
                    (PKSYNCHRONIZE_ROUTINE) I8xDpcVariableOperation,
                    (PVOID) &operationContext
                    );

            if (interlockedResult != -1) {

                //
                // The interlocked variable is still greater than or equal to
                // zero. Reset it to zero, so that we execute the loop one
                // more time (assuming no more DPCs execute and bump the
                // variable up again).
                //

                operationContext.Operation = WriteOperation;
                interlockedResult = 0;
                operationContext.NewValue = &interlockedResult;

                KeSynchronizeExecution(
                    deviceExtension->InterruptObject,
                    (PKSYNCHRONIZE_ROUTINE) I8xDpcVariableOperation,
                    (PVOID) &operationContext
                    );

                Print(DBG_DPC_INFO, ("I8042MouseIsrDpc: loop in DPC\n"));
            }
            else {
                moreDpcProcessing = FALSE;
            }
        }
    }

    Print(DBG_DPC_TRACE, ("I8042MouseIsrDpc: exit\n"));

}

BOOLEAN
I8xWriteDataToMouseQueue(
    PPORT_MOUSE_EXTENSION MouseExtension,
    IN PMOUSE_INPUT_DATA InputData
    )

/*++

Routine Description:

    This routine adds input data from the mouse to the InputData queue.

Arguments:

    MouseExtension - Pointer to the mouse portion of the device extension.

    InputData - Pointer to the data to add to the InputData queue.

Return Value:

    Returns TRUE if the data was added, otherwise FALSE.

--*/

{

    Print(DBG_CALL_TRACE, ("I8xWriteDataToMouseQueue: enter\n"));
    Print(DBG_CALL_NOISE,
          ("I8xWriteDataToMouseQueue: DataIn 0x%x, DataOut 0x%x\n",
          MouseExtension->DataIn,
          MouseExtension->DataOut
          ));
    Print(DBG_CALL_NOISE,
          ("I8xWriteDataToMouseQueue: InputCount %d\n",
          MouseExtension->InputCount
          ));

    //
    // Check for full input data queue.
    //

    if ((MouseExtension->DataIn == MouseExtension->DataOut) &&
        (MouseExtension->InputCount != 0)) {

        //
        // The input data queue is full.  Intentionally ignore
        // the new data.
        //

        Print(DBG_CALL_ERROR, ("I8xWriteDataToMouseQueue: OVERFLOW\n"));
        return(FALSE);

    } else {
        *(MouseExtension->DataIn) = *InputData;
        MouseExtension->InputCount += 1;
        MouseExtension->DataIn++;
        Print(DBG_DPC_INFO,
              ("I8xWriteDataToMouseQueue: new InputCount %d\n",
              MouseExtension->InputCount
              ));
        if (MouseExtension->DataIn == MouseExtension->DataEnd) {
            Print(DBG_DPC_NOISE, ("I8xWriteDataToMouseQueue: wrap buffer\n"));
            MouseExtension->DataIn = MouseExtension->InputData;
        }
    }

    Print(DBG_DPC_TRACE, ("I8xWriteDataToMouseQueue: exit\n"));

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\pnpi8042\moudep.c ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    moudep.c

Abstract:

    The initialization and hardware-dependent portions of
    the Intel i8042 port driver which are specific to
    the auxiliary (PS/2 mouse) device.

Environment:

    Kernel mode only.

Notes:

    NOTES:  (Future/outstanding issues)

    - Powerfail not implemented.

    - Consolidate duplicate code, where possible and appropriate.

Revision History:

--*/

#include "stdarg.h"
#include "stdio.h"
#include "string.h"
#include "i8042prt.h"
#include "i8042log.h"

//
// Use the alloc_text pragma to specify the driver initialization routines
// (they can be paged out).
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, I8xMouseConfiguration)
#pragma alloc_text(PAGE, I8xMouseServiceParameters)
#pragma alloc_text(PAGE, I8xInitializeMouse)
#pragma alloc_text(PAGE, I8xGetBytePolledIterated)
#pragma alloc_text(PAGE, I8xTransmitByteSequence)
#pragma alloc_text(PAGE, I8xFindWheelMouse)
#pragma alloc_text(PAGE, I8xQueryNumberOfMouseButtons)
#pragma alloc_text(PAGE, MouseCopyWheelIDs)

//
// These will be locked down right before the mouse interrupt is enabled if a 
// mouse is present
//
#pragma alloc_text(PAGEMOUC, I8042MouseInterruptService)
#pragma alloc_text(PAGEMOUC, I8xQueueCurrentMouseInput)
#pragma alloc_text(PAGEMOUC, I8xVerifyMousePnPID)
#endif

#define ONE_PAST_FINAL_SAMPLE ((UCHAR) 0x00)

static const
UCHAR PnpDetectCommands[] = { 20,
                              40,
                              60,
                              ONE_PAST_FINAL_SAMPLE
                              };

static const
UCHAR WheelEnableCommands[] = { 200,
                                100,
                                80,
                                ONE_PAST_FINAL_SAMPLE
                                };

static const
UCHAR FiveButtonEnableCommands[] = { 200,
                                     200,
                                     80,
                                     ONE_PAST_FINAL_SAMPLE
                                     };

#if MOUSE_RECORD_ISR

PMOUSE_STATE_RECORD IsrStateHistory     = NULL;
PMOUSE_STATE_RECORD CurrentIsrState     = NULL;
PMOUSE_STATE_RECORD IsrStateHistoryEnd  = NULL;

#endif // MOUSE_RECORD_ISR

#define BUFFER_FULL   (OUTPUT_BUFFER_FULL | MOUSE_OUTPUT_BUFFER_FULL)

#define RML_BUTTONS    (RIGHT_BUTTON | MIDDLE_BUTTON | LEFT_BUTTON)
#define BUTTONS_4_5    (BUTTON_4 | BUTTON_5)

#define _TRANSITION_DOWN(previous, current, button) \
           ((!(previous & button)) && (current & button))

#define _TRANSITION_UP(previous, current, button) \
           ((previous & button) && (!(current & button)))

BOOLEAN
I8042MouseInterruptService(
    IN PKINTERRUPT Interrupt,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine performs the actual work.  It either processes a mouse packet
    or the results from a write to the device.

Arguments:

    CallIsrContext - Contains the interrupt object and device object.  
    
Return Value:

    TRUE if the interrupt was truly ours
    
--*/
{
    PPORT_MOUSE_EXTENSION deviceExtension;
    LARGE_INTEGER tickDelta, newTick;
    UCHAR previousButtons;
    UCHAR previousSignAndOverflow;
    UCHAR byte, statusByte, lastByte;
    UCHAR resendCommand, nextCommand, altCommand;
    BOOLEAN bSendCommand, ret = TRUE;
    static PWCHAR currentIdChar;

#define TRANSITION_UP(button)     _TRANSITION_UP(previousButtons, byte, button)
#define TRANSITION_DOWN(button) _TRANSITION_DOWN(previousButtons, byte, button)

    IsrPrint(DBG_MOUISR_TRACE, ("%s\n", pEnter));

    deviceExtension = (PPORT_MOUSE_EXTENSION) DeviceObject->DeviceExtension;

    if (deviceExtension->PowerState != PowerDeviceD0) {
        return FALSE;
    }

    //
    // Verify that this device really interrupted.  Check the status
    // register.  The Output Buffer Full bit should be set, and the
    // Auxiliary Device Output Buffer Full bit should be set.
    //
    statusByte =
      I8X_GET_STATUS_BYTE(Globals.ControllerData->DeviceRegisters[CommandPort]);
    if ((statusByte & BUFFER_FULL) != BUFFER_FULL) {
        //
        // Stall and then try again.  The Olivetti MIPS machine
        // sometimes gets a mouse interrupt before the status
        // register is set.
        //
        KeStallExecutionProcessor(10);
        statusByte = I8X_GET_STATUS_BYTE(Globals.ControllerData->DeviceRegisters[CommandPort]);
        if ((statusByte & BUFFER_FULL) != BUFFER_FULL) {

            //
            // Not our interrupt.
            //
            IsrPrint(DBG_MOUISR_ERROR | DBG_MOUISR_INFO,
                     ("not our interrupt!\n"
                     ));

            return FALSE;
        }
    }

    //
    // Read the byte from the i8042 data port.
    //
    I8xGetByteAsynchronous(
        (CCHAR) MouseDeviceType,
        &byte
        );

    IsrPrint(DBG_MOUISR_BYTE, ("byte 0x%x\n", byte));

    KeQueryTickCount(&newTick);

    if (deviceExtension->InputResetSubState == QueueingMouseReset) {

        RECORD_ISR_STATE(deviceExtension,
                         byte,
                         deviceExtension->LastByteReceived,
                         newTick);

        return TRUE;
    }

    if (deviceExtension->InputState == MouseResetting && byte == FAILURE) {
        RECORD_ISR_STATE(deviceExtension,
                         byte,
                         deviceExtension->LastByteReceived,
                         newTick);
        deviceExtension->LastByteReceived = byte;
        ret = TRUE;
        goto IsrResetMouse;
    }

    if (deviceExtension->IsrHookCallback) {
        BOOLEAN cont= FALSE;

        ret = (*deviceExtension->IsrHookCallback)(
                  deviceExtension->HookContext,
                  &deviceExtension->CurrentInput,
                  &deviceExtension->CurrentOutput,
                  statusByte,
                  &byte,
                  &cont,
                  &deviceExtension->InputState,
                  &deviceExtension->InputResetSubState
                  );

        if (!cont) {
            return ret;
        }
    }       


    //
    // Watch the data stream for a reset completion (0xaa) followed by the
    // device id
    //
    // this pattern can appear as part of a normal data packet as well. This
    // code assumes that sending an enable to an already enabled mouse will:
    //  * not hang the mouse
    //  * abort the current packet and return an ACK.
    //

    if (deviceExtension->LastByteReceived == MOUSE_COMPLETE &&
        (byte == 0x00 || byte == 0x03)) {

        IsrPrint(DBG_MOUISR_RESETTING, ("received id %2d\n", byte));

        RECORD_ISR_STATE(deviceExtension,
                         byte,
                         deviceExtension->LastByteReceived, 
                         newTick);

        if (InterlockedCompareExchangePointer(&deviceExtension->ResetIrp,
                                              NULL,
                                              NULL) == NULL) {
            // 
            // user unplugged and plugged in the mouse...queue a reset packet
            // so the programming of the mouse in the ISR does not conflict with
            // any other writes to the i8042prt controller
            //
            IsrPrint(DBG_MOUISR_RESETTING, ("user initiated reset...queueing\n"));
            goto IsrResetMouseOnly;
        }

        //
        // Tell the 8042 port to fetch the device ID of the aux device
        // We do this async so that we don't spin at IRQ1!!!
        //
        I8X_WRITE_CMD_TO_MOUSE();
        I8X_MOUSE_COMMAND( GET_DEVICE_ID );
        RECORD_ISR_STATE_COMMAND(deviceExtension, GET_DEVICE_ID); 

        //
        // This is part of the substate system for handling a (possible)
        // mouse reset.
        //
        deviceExtension->InputState = MouseResetting;
        deviceExtension->InputResetSubState =
            ExpectingGetDeviceIdACK;

        //
        // We don't want to execute any more of the ISR code, so lets just
        // do a few things and then return now
        //
        deviceExtension->LastByteReceived = byte;
        deviceExtension->ResendCount = 0;

        //
        // Done
        //
        return TRUE;
    }

    if (deviceExtension->InputState == MouseIdle &&
        deviceExtension->CurrentOutput.State != Idle &&
        DeviceObject->CurrentIrp != NULL) {
        if (byte == RESEND) {

            //
            // If the timer count is zero, don't process the interrupt
            // further.  The timeout routine will complete this request.
            //
            if (Globals.ControllerData->TimerCount == 0) {
                return FALSE;
            }
    
            //
            // Reset the timeout value to indicate no timeout.
            //
            Globals.ControllerData->TimerCount = I8042_ASYNC_NO_TIMEOUT;
    
            if (deviceExtension->ResendCount <
                Globals.ControllerData->Configuration.ResendIterations) {
    
                //
                // retard the byte count to resend the last byte
                //
                deviceExtension->CurrentOutput.CurrentByte -= 1;
                deviceExtension->ResendCount += 1;
                I8xInitiateIo(DeviceObject);
    
            } else {
    
                deviceExtension->CurrentOutput.State = Idle;
    
                KeInsertQueueDpc(&deviceExtension->RetriesExceededDpc,
                                 DeviceObject,
                                 NULL
                                 );

                return TRUE;
            }
        }
        else if (byte == ACKNOWLEDGE) {
            //
            // The keyboard controller has acknowledged a previous send.
            // If there are more bytes to send for the current packet, initiate
            // the next send operation.  Otherwise, queue the completion DPC.
            //
            // If the timer count is zero, don't process the interrupt
            // further.  The timeout routine will complete this request.
            //
            if (Globals.ControllerData->TimerCount == 0) {
                return FALSE;
            }
    
            //
            // Reset the timeout value to indicate no timeout.
            //
            Globals.ControllerData->TimerCount = I8042_ASYNC_NO_TIMEOUT;
    
            //
            // Reset resend count.
            //
            deviceExtension->ResendCount = 0;
            if (deviceExtension->CurrentOutput.CurrentByte <
                deviceExtension->CurrentOutput.ByteCount) {
                //
                // We've successfully sent the first byte of a 2-byte
                // command sequence.  Initiate a send of the second byte.
                //
                IsrPrint(DBG_MOUISR_STATE,
                      ("now initiate send of byte #%d\n",
                       deviceExtension->CurrentOutput.CurrentByte
                      ));
    
                I8xInitiateIo(DeviceObject);
            }
            else {
                //
                // We've successfully sent all bytes in the command sequence.
                // Reset the current state and queue the completion DPC.
                //
    
                IsrPrint(DBG_MOUISR_STATE,
                      ("all bytes have been sent\n"
                      ));
    
                deviceExtension->CurrentOutput.State = Idle;
    
                ASSERT(DeviceObject->CurrentIrp != NULL);

                IoRequestDpc(
                    DeviceObject,
                    DeviceObject->CurrentIrp,
                    IntToPtr(IsrDpcCauseMouseWriteComplete)
                    );
            }

            //
            // No matter what, we are done processing for now
            //
            return TRUE;
        }
        else {
            //
            // do what here, eh?
            //
        }
    }

    //
    // Remember what the last byte we got was
    //
    lastByte = deviceExtension->LastByteReceived;
    deviceExtension->LastByteReceived = byte;

    //
    // Take the appropriate action, depending on the current state.
    // When the state is Idle, we expect to receive mouse button
    // data.  When the state is XMovement, we expect to receive mouse
    // motion in the X direction data.  When the state is YMovement,
    // we expect to receive mouse motion in the Y direction data.  Once
    // the Y motion data has been received, the data is queued to the
    // mouse InputData queue, the mouse ISR DPC is requested, and the
    // state returns to Idle.
    //
    tickDelta.QuadPart =
            newTick.QuadPart -
            deviceExtension->PreviousTick.QuadPart;

    if ((deviceExtension->InputState != MouseIdle)
           && (deviceExtension->InputState != MouseExpectingACK)
           && (deviceExtension->InputState != MouseResetting)
           && ((tickDelta.LowPart >= deviceExtension->SynchTickCount)
               || (tickDelta.HighPart != 0))) {

        //
        // It has been a long time since we got a byte of
        // the data packet.  Assume that we are now receiving
        // the first byte of a new packet, and discard any
        // partially received packet.
        //
        // N.B.  We assume that SynchTickCount is ULONG, and avoid
        //       a LARGE_INTEGER compare with tickDelta...
        //

        IsrPrint(DBG_MOUISR_STATE,
                 ("State was %d, synching\n",
                 deviceExtension->InputState
                 ));

        //
        // The device misbehaved. Lets play it safe and reset the device.
        //
        // Note: this code is meant to handle cases where some intermediate
        // (switch) box resets the mouse and doesn't tell us about it.
        // This avoid problems with trying to detect this code since there
        // isn't a fool proof way to do it
        //
        goto IsrResetMouse;
    }

    deviceExtension->PreviousTick = newTick;

    switch(deviceExtension->InputState) {

        //
        // The mouse interrupted with a status byte.  The status byte
        // contains information on the mouse button state along with
        // the sign and overflow bits for the (yet-to-be-received)
        // X and Y motion bytes.
        //

        case MouseIdle: {

            IsrPrint(DBG_MOUISR_STATE, ("mouse status byte\n"));

            //
            // This is a sanity check test. It is required because some people
            // in industry persist in their notion that you can reset a mouse
            // device any time you want and not let the OS know anything about
            // it. This results in our nice little wheel mouse (which is a
            // 4 byte packet engine) suddenly only dumping 3 byte packets.
            //
            if (WHEEL_PRESENT() && (byte & 0xC8) != 8 ) { // Guaranteed True for Megallan

                //
                // We are getting a bad packet for the idle state. The best bet
                // is to issue a mouse reset request and hope we can recover.
                //
                goto IsrResetMouse;
            }

            //
            // Update CurrentInput with button transition data.
            // I.e., set a button up/down bit in the Buttons field if
            // the state of a given button has changed since we
            // received the last packet.
            //

            previousButtons = deviceExtension->PreviousButtons;

            // This clears both ButtonFlags and ButtonData
            deviceExtension->CurrentInput.Buttons = 0;
            deviceExtension->CurrentInput.Flags = 0x0;

            if (TRANSITION_DOWN(LEFT_BUTTON)) {
                deviceExtension->CurrentInput.ButtonFlags |=
                    MOUSE_LEFT_BUTTON_DOWN;
            } else
            if (TRANSITION_UP(LEFT_BUTTON)) {
                deviceExtension->CurrentInput.ButtonFlags |=
                    MOUSE_LEFT_BUTTON_UP;
            }
            if (TRANSITION_DOWN(RIGHT_BUTTON)) {
                deviceExtension->CurrentInput.ButtonFlags |=
                    MOUSE_RIGHT_BUTTON_DOWN;
            } else
            if (TRANSITION_UP(RIGHT_BUTTON)) {
                deviceExtension->CurrentInput.ButtonFlags |=
                    MOUSE_RIGHT_BUTTON_UP;
            }
            if (TRANSITION_DOWN(MIDDLE_BUTTON)) {
                deviceExtension->CurrentInput.ButtonFlags |=
                    MOUSE_MIDDLE_BUTTON_DOWN;
            } else
            if (TRANSITION_UP(MIDDLE_BUTTON)) {
                deviceExtension->CurrentInput.ButtonFlags |=
                    MOUSE_MIDDLE_BUTTON_UP;
            }

            //
            // Save the button state for comparison the next time around.
            // (previousButtons will never have 4/5 set if a 5 button mouse is
            //  not present, but checking to see if a 5 button mouse is present
            //  is just as expensive as the additional & and | so just do it with
            //  out regard to the 5 button mouse's presence
            //
            deviceExtension->PreviousButtons =
                (byte & RML_BUTTONS) | (previousButtons & BUTTONS_4_5);

            //
            // Save the sign and overflow information from the current byte.
            //
            deviceExtension->CurrentSignAndOverflow =
                (UCHAR) (byte & MOUSE_SIGN_OVERFLOW_MASK);

            //
            // Update to the next state.
            //
            deviceExtension->InputState = XMovement;

            break;
        }

        //
        // The mouse interrupted with the X motion byte.  Apply
        // the sign and overflow bits from the mouse status byte received
        // previously.  Attempt to correct for bogus changes in sign
        // that occur with large, rapid mouse movements.
        //

        case XMovement: {

            IsrPrint(DBG_MOUISR_STATE, ("mouse LastX byte\n"));

            //
            // Update CurrentInput with the X motion data.
            //

            if (deviceExtension->CurrentSignAndOverflow
                & X_OVERFLOW) {

                //
                // Handle overflow in the X direction.  If the previous
                // mouse movement overflowed too, ensure that the current
                // overflow is in the same direction (i.e., that the sign
                // is the same as it was for the previous event).  We do this
                // to correct for hardware problems -- it should not be possible
                // to overflow in one direction and then immediately overflow
                // in the opposite direction.
                //

                previousSignAndOverflow =
                    deviceExtension->PreviousSignAndOverflow;
                if (previousSignAndOverflow & X_OVERFLOW) {
                    if ((previousSignAndOverflow & X_DATA_SIGN) !=
                        (deviceExtension->CurrentSignAndOverflow
                         & X_DATA_SIGN)) {
                        deviceExtension->CurrentSignAndOverflow
                            ^= X_DATA_SIGN;
                    }
                }

                if (deviceExtension->CurrentSignAndOverflow &
                    X_DATA_SIGN)
                    deviceExtension->CurrentInput.LastX =
                        (LONG) MOUSE_MAXIMUM_NEGATIVE_DELTA;
                else
                    deviceExtension->CurrentInput.LastX =
                        (LONG) MOUSE_MAXIMUM_POSITIVE_DELTA;

            } else {

                //
                // No overflow.  Just store the data, correcting for the
                // sign if necessary.
                //

                deviceExtension->CurrentInput.LastX = (ULONG) byte;
                if (deviceExtension->CurrentSignAndOverflow &
                    X_DATA_SIGN)
                    deviceExtension->CurrentInput.LastX |=
                        MOUSE_MAXIMUM_NEGATIVE_DELTA;
            }

            //
            // Update to the next state.
            //

            deviceExtension->InputState = YMovement;

            break;
        }

        //
        // The mouse interrupted with the Y motion byte.  Apply
        // the sign and overflow bits from the mouse status byte received
        // previously.  [Attempt to correct for bogus changes in sign
        // that occur with large, rapid mouse movements.]  Write the
        // data to the mouse InputData queue, and queue the mouse ISR DPC
        // to complete the interrupt processing.
        //

        case YMovement: {

            IsrPrint(DBG_MOUISR_STATE, ("mouse LastY byte\n"));

            //
            // Update CurrentInput with the Y motion data.
            //

            if (deviceExtension->CurrentSignAndOverflow
                & Y_OVERFLOW) {

                //
                // Handle overflow in the Y direction.  If the previous
                // mouse movement overflowed too, ensure that the current
                // overflow is in the same direction (i.e., that the sign
                // is the same as it was for the previous event).  We do this
                // to correct for hardware problems -- it should not be possible
                // to overflow in one direction and then immediately overflow
                // in the opposite direction.
                //

                previousSignAndOverflow =
                    deviceExtension->PreviousSignAndOverflow;
                if (previousSignAndOverflow & Y_OVERFLOW) {
                    if ((previousSignAndOverflow & Y_DATA_SIGN) !=
                        (deviceExtension->CurrentSignAndOverflow
                         & Y_DATA_SIGN)) {
                        deviceExtension->CurrentSignAndOverflow
                            ^= Y_DATA_SIGN;
                    }
                }

                if (deviceExtension->CurrentSignAndOverflow &
                    Y_DATA_SIGN)
                    deviceExtension->CurrentInput.LastY =
                        (LONG) MOUSE_MAXIMUM_POSITIVE_DELTA;
                else
                    deviceExtension->CurrentInput.LastY =
                        (LONG) MOUSE_MAXIMUM_NEGATIVE_DELTA;

            } else {

                //
                // No overflow.  Just store the data, correcting for the
                // sign if necessary.
                //

                deviceExtension->CurrentInput.LastY = (ULONG) byte;
                if (deviceExtension->CurrentSignAndOverflow &
                    Y_DATA_SIGN)
                    deviceExtension->CurrentInput.LastY |=
                        MOUSE_MAXIMUM_NEGATIVE_DELTA;

                 //
                 // Negate the LastY value (the hardware reports positive
                 // motion in the direction that we consider negative).
                 //

                 deviceExtension->CurrentInput.LastY =
                     -deviceExtension->CurrentInput.LastY;

            }

            //
            // Update our notion of the previous sign and overflow bits for
            // the start of the next mouse input sequence.
            //

            deviceExtension->PreviousSignAndOverflow =
                deviceExtension->CurrentSignAndOverflow;

            //
            // Choose the next state.  The WheelMouse has an extra byte of data
            // for us
            //

            if (WHEEL_PRESENT()) {
                deviceExtension->InputState = ZMovement;
            }
            else {
                I8xQueueCurrentMouseInput(DeviceObject);
                deviceExtension->InputState = MouseIdle;
            }
            break;
        }

        case ZMovement: {

            IsrPrint(DBG_MOUISR_STATE, ("mouse LastZ byte\n"));

            //
            // This code is here to handle the cases were mouse resets were
            // not notified to the OS. Uncomment this if you *really* want it,
            // but remember that it could possibly reset the mouse when it
            // shouldn't have...
            //
#if 0
            if ( (byte & 0xf8) != 0 && (byte & 0xf8) != 0xf8 ) {

                //
                // for some reason, the byte was not sign extanded,
                // or has a value > 7, which we assume cannot be
                // possible giving our equipment. So the packet
                // *must* be bogus...
                //
                // No longer the case with 5 button mice
                //
                goto IsrResetMouse;
            }
#endif
            //
            // Check to see if we got any z data
            // If there were any changes in the button state, ignore the
            // z data
            //
            if (FIVE_PRESENT()) {
                //
                // Wheel info first, value returned should be
                // -120 * the value reported
                //
                if (byte & 0x0F) {

                    // sign extend to the upper 4 bits if necessary
                    if (byte & 0x08) {
                        deviceExtension->CurrentInput.ButtonData =
                            (-120) * ((CHAR)((byte & 0xF) | 0xF0));
                    }
                    else {
                        deviceExtension->CurrentInput.ButtonData =
                            (-120) * ((CHAR) byte & 0xF);
                    }

                    deviceExtension->CurrentInput.ButtonFlags |= MOUSE_WHEEL;
                }

                previousButtons = deviceExtension->PreviousButtons;

                // extra buttons
                if (TRANSITION_DOWN(BUTTON_4)) { 
                    deviceExtension->CurrentInput.ButtonFlags |=
                        MOUSE_BUTTON_4_DOWN;
                } else
                if (TRANSITION_UP(BUTTON_4)) {
                    deviceExtension->CurrentInput.ButtonFlags |=
                        MOUSE_BUTTON_4_UP;
                }
                if (TRANSITION_DOWN(BUTTON_5)) {
                    deviceExtension->CurrentInput.ButtonFlags |=
                        MOUSE_BUTTON_5_DOWN;
                } else
                if (TRANSITION_UP(BUTTON_5)) {
                    deviceExtension->CurrentInput.ButtonFlags |=
                        MOUSE_BUTTON_5_UP;
                }

                // record btns 4 & 5 w/out losing btns 1-3
                deviceExtension->PreviousButtons =
                    (byte & BUTTONS_4_5) | (previousButtons & RML_BUTTONS);
            }
            else if (byte) {
                deviceExtension->CurrentInput.ButtonData =
                    (-120) * ((CHAR) byte);

                deviceExtension->CurrentInput.ButtonFlags |= MOUSE_WHEEL;
            }
        
            //
            // Pack the data on to the class driver
            //

            I8xQueueCurrentMouseInput(DeviceObject);

            //
            // Reset the state
            //

            deviceExtension->InputState = MouseIdle;

            break;
        }

        case MouseExpectingACK: {

            RECORD_ISR_STATE(deviceExtension, byte, lastByte, newTick);

            //
            // This is a special case.  We hit this on one of the very
            // first mouse interrupts following the IoConnectInterrupt.
            // The interrupt is caused when we enable mouse transmissions
            // via I8xMouseEnableTransmission() -- the hardware returns
            // an ACK.  Just toss this byte away, and set the input state
            // to coincide with the start of a new mouse data packet.
            //

            IsrPrint(DBG_MOUISR_BYTE,
                     ("...should be from I8xMouseEnableTransmission\n"));
            IsrPrint(DBG_MOUISR_BYTE,
                  (pDumpExpectingAck,
                  (ULONG) ACKNOWLEDGE,
                  (ULONG) byte
                  ));

            if (byte == (UCHAR) ACKNOWLEDGE) {

                deviceExtension->InputState = MouseIdle;
                deviceExtension->EnableMouse.Enabled = FALSE;

            } else if (byte == (UCHAR) RESEND) {

                //
                // Resend the "Enable Mouse Transmission" sequence.
                //
                // NOTE: This is a workaround for the Olivetti MIPS machine,
                // which sends a resend response if a key is held down
                // while we're attempting the I8xMouseEnableTransmission.
                //
                resendCommand = ENABLE_MOUSE_TRANSMISSION;
            }

            break;
        }

        case MouseResetting: {

            IsrPrint(DBG_MOUISR_RESETTING,
                  ("state (%d) substate (%2d)\n",
                  deviceExtension->InputState,
                  deviceExtension->InputResetSubState
                  ));
            
            //
            // We enter the reset substate machine
            //
SwitchOnInputResetSubState:
            bSendCommand = TRUE;
            altCommand = (UCHAR) 0x00;
            RECORD_ISR_STATE(deviceExtension, byte, lastByte, newTick);
            switch (deviceExtension->InputResetSubState) {

            case StartPnPIdDetection:
                ASSERT(byte == (UCHAR) ACKNOWLEDGE);
                nextCommand = SET_MOUSE_SAMPLING_RATE;

                deviceExtension->InputResetSubState =
                    ExpectingLoopSetSamplingRateACK;
                deviceExtension->SampleRatesIndex = 0;
                deviceExtension->SampleRates = (PUCHAR) PnpDetectCommands;
                deviceExtension->PostSamplesState = ExpectingPnpId;
                break;

            case EnableWheel:
                bSendCommand = FALSE;
                altCommand = SET_MOUSE_SAMPLING_RATE;

                deviceExtension->InputResetSubState =
                    ExpectingLoopSetSamplingRateACK;
                deviceExtension->SampleRatesIndex = 0;
                deviceExtension->SampleRates = (PUCHAR) WheelEnableCommands;

                //
                // After enabling the wheel, we shall get the device ID because
                // some kinds of wheel mice require the get id right after the
                // wheel enabling sequence
                //
                deviceExtension->PostSamplesState = PostEnableWheelState;
                break;

            case PostEnableWheelState:
                //
                // Some wheel mice require a get device ID after turning on the 
                // wheel for the wheel to be truly turned on
                //
                bSendCommand = FALSE;
                altCommand = GET_DEVICE_ID; 

                deviceExtension->InputResetSubState = 
                    ExpectingGetDeviceIdDetectACK;
                break;

            case ExpectingGetDeviceIdDetectACK:
                IsrPrint(DBG_MOUISR_ACK,
                         (pDumpExpectingAck,
                         (ULONG) ACKNOWLEDGE,
                         (ULONG) byte
                         ));

                if (byte == (UCHAR) ACKNOWLEDGE) {
                    bSendCommand = FALSE;
                    deviceExtension->InputResetSubState =
                        ExpectingGetDeviceIdDetectValue;
                }
                else if (byte == (UCHAR) RESEND) {
                    //
                    // NOTE: This is a workaround for the Olivetti MIPS machine,
                    // which sends a resend response if a key is held down
                    // while we're attempting the I8xMouseEnableTransmission.
                    //
                    resendCommand = GET_DEVICE_ID;
                }
                else {
                    //
                    // Log the error
                    //
                    KeInsertQueueDpc(&deviceExtension->ErrorLogDpc,
                                     (PIRP) NULL,
                                     LongToPtr(I8042_GET_DEVICE_ID_FAILED)
                                     );

                    //
                    // We didn't get an ACK on this? Boggle. Okay, let's
                    // reset the mouse (probably AGAIN) and try to figure
                    // things out one more time
                    //
                    goto IsrResetMouse;
                }
                break;

            case ExpectingGetDeviceIdDetectValue:
                //
                // In theory, we can check the mouse ID here and only send the
                // 5 button enable sequence if the mouse ID is the wheel mouse
                // ID....BUT there are filter drivers which trap the ISR and
                // depend on the mouse ID always showing up in the
                // ExpectingGetDeviceId2Value state
                //
                deviceExtension->InputResetSubState = Enable5Buttons;
                goto SwitchOnInputResetSubState;
                // break;

            case Enable5Buttons:
                bSendCommand = FALSE;
                altCommand = SET_MOUSE_SAMPLING_RATE;

                deviceExtension->InputResetSubState =
                    ExpectingLoopSetSamplingRateACK;
                deviceExtension->SampleRatesIndex = 0;
                deviceExtension->SampleRates = (PUCHAR) FiveButtonEnableCommands;
                deviceExtension->PostSamplesState = PostWheelDetectState;
                break;

            //
            // This state (ExpectingReset) and the next one (Expecting
            // ResetId) are only called if we have to issue a reset
            // from within the substate machine.
            //
            case ExpectingReset: 
                // 
                // This case handles 3 cases
                //
                // 1)  The ack resulting from writing a MOUSE_RESET (0xFF)
                // 2)  A resend resulting from writing the reset
                // 3)  The reset character following the the ack
                //
                // If the byte is neither of these 3, then just let it go
                //
                if (byte == ACKNOWLEDGE) {
                    //
                    // The ack for the reset, the 0xAA will come immediately
                    // after this.  We can handle it in the same state
                    //
                    bSendCommand = FALSE;
                    break;
                    
                }
                else if (byte == RESEND) {

                    bSendCommand = FALSE;
                    if (deviceExtension->ResendCount++ < MOUSE_RESET_RESENDS_MAX &&

                        deviceExtension->ResetMouse.IsrResetState
                        == IsrResetNormal) {

                        IsrPrint(DBG_MOUISR_RESETTING, ("resending from isr\n"));

                        //
                        // Fix for old Digital machines (both x86 and alpha) 
                        // that can't handle resets to close together
                        //
                        KeStallExecutionProcessor(
                            deviceExtension->MouseResetStallTime
                            );
            
                        //
                        // We send an alt command instead of the normal
                        // resetCommand so that we can maintain our own count
                        // here (we want the reset resend max to be larger than
                        // the std resend max)
                        //
                        altCommand = MOUSE_RESET;
                    }

                    break;
                }
                else if (byte != MOUSE_COMPLETE) {
                    //
                    // Check to see if we got a reset character (0xAA). If
                    // not, then we will *ignore* it. Note that this means
                    // that if we dropped this char, then we could infinite
                    // loop in this routine.
                    //
                    break;
                }

                //
                // Now check to see how many times we have gone
                // through this routine without exiting the
                // MouseResetting SubState
                //
                if (deviceExtension->ResetCount >= MOUSE_RESETS_MAX) {
                    //
                    // This will queue a reset DPC which will see that too many 
                    // resets have been sent and will clean up the counters and
                    // and start the next Irp in the StartIO queue
                    //
                    goto IsrResetMouse;
                }

                //
                // Because of the test for mouse resets at the start of
                // the ISR, the following code should really have no
                // effect
                //
                deviceExtension->InputResetSubState =
                    ExpectingResetId;

                break;

            //
            // This state is special in that its just here as a place
            // holder because we have a detection routine at the start
            // of the ISR that automically puts us into
            // ExpectingGetDeviceIdACK.
            //
            // OLD WAY:
            // For completeness though, we
            // issue a bugcheck here since we can't normally get into
            // this state
            //
            // NEW WAY:
            // We ignore this state entirely.  As far as I can tell, we get 
            // into this state when the controller requests a resend (which
            // is honored) and then sends the 0xFA, 0xAA in reverse order,
            // which the state machine handles, but hits this assert
            //
            case ExpectingResetId: 
                //
                // Next state
                //
                deviceExtension->InputResetSubState =
                    ExpectingGetDeviceIdACK;

                if (byte == WHEELMOUSE_ID_BYTE) {

                    //
                    // Start a enable command to the device. We *really* don't
                    // expect to be here.
                    //
                    bSendCommand = FALSE;
                    altCommand = GET_DEVICE_ID;

                }
                else {
#if 0
                    //
                    // Log that we are in a bad state
                    //
                    KeInsertQueueDpc(&deviceExtension->ErrorLogDpc,
                                     (PIRP) NULL,
                                     (PVOID) (ULONG) I8042_INVALID_ISR_STATE_MOU
                                     );

                    ASSERT( byte == WHEELMOUSE_ID_BYTE);
#endif
                    //
                    // For sake of completeness
                    //
                    deviceExtension->InputResetSubState =
                        ExpectingReset;

                }
                break;

            case ExpectingGetDeviceIdACK: 

                IsrPrint(DBG_MOUISR_ACK,
                         (pDumpExpectingIdAck,
                         (ULONG) ACKNOWLEDGE,
                         (ULONG) byte
                         ));

                if (byte == (UCHAR) ACKNOWLEDGE) {

                    deviceExtension->InputResetSubState =
                        ExpectingGetDeviceIdValue;

                    bSendCommand = FALSE;

                } else if (byte == (UCHAR) RESEND) {

                    //
                    // Resend the "Get Mouse ID Transmission" sequence.
                    //
                    // NOTE: This is a workaround for the Olivetti MIPS machine,
                    // which sends a resend response if a key is held down
                    // while we're attempting the I8xMouseEnableTransmission.
                    //
                    resendCommand = GET_DEVICE_ID;
                } else {

                    //
                    // If we got here, then we don't know what's going
                    // on with the device... The best bet is to send down
                    // a mouse reset command...
                    //
                    goto IsrResetMouse;
                }

                break;

            case ExpectingGetDeviceIdValue: 

                IsrPrint(DBG_MOUISR_RESETTING,
                         ("id from get device id is %2d\n" ,
                         (ULONG) byte
                         ));

                //
                // Got the device ID from the mouse and compare it with what we
                // expect to see.  If the ID byte is still wheel or five button
                // then we STILL cannot consider this to be data from the mouse
                // that has mirrored a reset.   There are two reasons why we can't
                // consider this real data:
                //
                // 1) Switch boxes cache the device ID and returned the cached 
                //    ID upon a reset
                // 2) Some mice, once put in the 4 byte packet mode, will return
                //    the wheel or 5 button ID byte even if they have been reset
                //
                // Furthermore, we cannot check to see if extension->ResetIrp
                // exists because this does not cover the case where the mouse
                // was unplugged / replugged in.
                //
                // @@BEGIN_DDKSPLIT
                // This is a pit of despair.  No matter how crafty we try to be,
                // we will never get this right!  Perhaps we can turn on this
                // check via a reg flag.  The MS hardware folks have
                // respectfully requested this many, many times and we have
                // tried to accomodate them, but we always get bitten by the fix
                // in the end.
                // @@END_DDKSPLIT

                // (byte != WHEELMOUSE_ID_BYTE) && byte != (FIVEBUTTON_ID_BYTE)) {
                if  (1) {
                
                    //
                    // Log an error/warning message so that we can track these
                    // problems down in the field
                    //

#if 0
                    KeInsertQueueDpc(&deviceExtension->ErrorLogDpc,
                                     (PIRP) NULL,
                                     (PVOID)(ULONG) (WHEEL_PRESENT() ?
                                         I8042_UNEXPECTED_WHEEL_MOUSE_RESET :
                                         I8042_UNEXPECTED_MOUSE_RESET)
                                     );
#endif 
                    bSendCommand = FALSE;
                    if (deviceExtension->NumberOfButtonsOverride != 0) {
                        //
                        // skip button detection and set the res
                        //
                        altCommand = POST_BUTTONDETECT_COMMAND; 
        
                        deviceExtension->InputResetSubState =
                             POST_BUTTONDETECT_COMMAND_SUBSTATE;
                    }
                    else {
                        altCommand = SET_MOUSE_RESOLUTION;
    
                        deviceExtension->InputResetSubState =
                            ExpectingSetResolutionACK;
                    }
                }
                else {

                    //
                    // We have a wheel mouse present here... Log something so that
                    // we know that we got here.
                    //
                    KeInsertQueueDpc(&deviceExtension->ErrorLogDpc,
                                     (PIRP) NULL,
                                     LongToPtr(I8042_BOGUS_MOUSE_RESET)
                                     );


                    //
                    // Lets go back to the idle state
                    //
                    deviceExtension->InputState = MouseIdle;

                    //
                    // Reset the number of possible mouse resets
                    //
                    deviceExtension->ResetCount = 0;

                }
                break;

            case ExpectingSetResolutionACK:
                IsrPrint(DBG_MOUISR_ACK,
                         (pDumpExpectingIdAck,
                         (ULONG) ACKNOWLEDGE,
                         (ULONG) byte
                         ));

                if (byte == (UCHAR) ACKNOWLEDGE) {

                    //
                    // Set the resolution to 0x00 
                    //
                    nextCommand = 0x00;

                    deviceExtension->InputResetSubState =
                        ExpectingSetResolutionValueACK;

                } else if (byte == (UCHAR) RESEND) {

                    //
                    // NOTE: This is a workaround for the Olivetti MIPS machine,
                    // which sends a resend response if a key is held down
                    // while we're attempting the I8xMouseEnableTransmission.
                    //
                    resendCommand = SET_MOUSE_RESOLUTION;

                } else {

                    //
                    // Log the error
                    //
                    KeInsertQueueDpc(&deviceExtension->ErrorLogDpc,
                                     (PIRP) NULL,
                                     LongToPtr(I8042_SET_RESOLUTION_FAILED)
                                     );

                    bSendCommand = FALSE;
                    altCommand = GET_DEVICE_ID;

                    //
                    // Best possible next state
                    //
                    deviceExtension->InputResetSubState =
                        ExpectingGetDeviceId2ACK;

                }
                break;

            case ExpectingSetResolutionValueACK:
                IsrPrint(DBG_MOUISR_ACK,
                         (pDumpExpectingIdAck,
                         (ULONG) ACKNOWLEDGE,
                         (ULONG) byte
                         ));

                if (byte == (UCHAR) ACKNOWLEDGE) {

                    nextCommand = SET_MOUSE_SCALING_1TO1;

                    deviceExtension->InputResetSubState =
                        ExpectingSetScaling1to1ACK;
                }
                else if (byte == (UCHAR) RESEND) {

                    //
                    // NOTE: This is a workaround for the Olivetti MIPS machine,
                    // which sends a resend response if a key is held down
                    // while we're attempting the I8xMouseEnableTransmission.
                    //
                    resendCommand = 0x00;
                }
                else {

                    //
                    // Log the error
                    //
                    KeInsertQueueDpc(&deviceExtension->ErrorLogDpc,
                                     (PIRP) NULL,
                                     LongToPtr(I8042_SET_SAMPLE_RATE_FAILED)
                                     );

                    //
                    // Probably not a wheel mouse .. jump to the GetDeviceID2
                    // code
                    //
                    bSendCommand = FALSE;
                    altCommand = GET_DEVICE_ID;

                    //
                    // Best possible next state
                    //
                    deviceExtension->InputResetSubState =
                        ExpectingGetDeviceId2ACK;

                }
                break;

            case ExpectingSetScaling1to1ACK:
            case ExpectingSetScaling1to1ACK2:
            case ExpectingSetScaling1to1ACK3:
                IsrPrint(DBG_MOUISR_ACK,
                         (pDumpExpectingIdAck,
                         (ULONG) ACKNOWLEDGE,
                         (ULONG) byte
                         ));

                if (byte == (UCHAR) ACKNOWLEDGE) {

                    if (deviceExtension->InputResetSubState == 
                        ExpectingSetScaling1to1ACK3) {

                        //
                        // Read the status of the mouse (a 3 byte stream)
                        //
                        nextCommand = READ_MOUSE_STATUS;

                        deviceExtension->InputResetSubState =
                            ExpectingReadMouseStatusACK;
                    }
                    else {
                        deviceExtension->InputResetSubState++;
                        nextCommand = SET_MOUSE_SCALING_1TO1;
                    }

                } else if (byte == (UCHAR) RESEND) {

                    //
                    // NOTE: This is a workaround for the Olivetti MIPS machine,
                    // which sends a resend response if a key is held down
                    // while we're attempting the I8xMouseEnableTransmission.
                    //
                    resendCommand = SET_MOUSE_SCALING_1TO1;

                } else {

                    //
                    // Log the error
                    //
                    KeInsertQueueDpc(&deviceExtension->ErrorLogDpc,
                                     (PIRP) NULL,
                                     LongToPtr(I8042_ERROR_DURING_BUTTONS_DETECT)
                                     );

                    bSendCommand = FALSE; 
                    altCommand = GET_DEVICE_ID;

                    //
                    // Best possible next state
                    //
                    deviceExtension->InputResetSubState =
                        ExpectingGetDeviceId2ACK;

                }
                break;

            case ExpectingReadMouseStatusACK:
                IsrPrint(DBG_MOUISR_ACK,
                         (pDumpExpectingIdAck,
                         (ULONG) ACKNOWLEDGE,
                         (ULONG) byte
                         ));

                if (byte == (UCHAR) ACKNOWLEDGE) {

                    //
                    // Get ready for the 3 bytes
                    //
                    deviceExtension->InputResetSubState =
                        ExpectingReadMouseStatusByte1;

                    bSendCommand = FALSE;

                } else if (byte == (UCHAR) RESEND) {

                    //
                    // NOTE: This is a workaround for the Olivetti MIPS machine,
                    // which sends a resend response if a key is held down
                    // while we're attempting the I8xMouseEnableTransmission.
                    //
                    resendCommand = READ_MOUSE_STATUS;

                } else {

                    //
                    // Log the error
                    //
                    KeInsertQueueDpc(&deviceExtension->ErrorLogDpc,
                                     (PIRP) NULL,
                                     LongToPtr(I8042_ERROR_DURING_BUTTONS_DETECT)
                                     );

                    //
                    // Probably not a wheel mouse .. jump to the GetDeviceID2
                    // code
                    //
                    bSendCommand = FALSE;
                    altCommand = GET_DEVICE_ID;

                    //
                    // Best possible next state
                    //
                    deviceExtension->InputResetSubState =
                        ExpectingGetDeviceId2ACK;

                }
                break;

            case ExpectingReadMouseStatusByte1:
                IsrPrint(DBG_MOUISR_PNPID,
                         (pDumpExpecting,
                         (ULONG) 0x00,
                         (ULONG) byte
                         ));

                bSendCommand = FALSE;
                deviceExtension->InputResetSubState =
                    ExpectingReadMouseStatusByte2;
                break;

            case ExpectingReadMouseStatusByte2:
                IsrPrint(DBG_MOUISR_PNPID,
                         (pDumpExpecting,
                         (ULONG) 0x00,
                         (ULONG) byte
                         ));

                bSendCommand = FALSE;
                deviceExtension->InputResetSubState =
                    ExpectingReadMouseStatusByte3;

                //
                // This will be the number of buttons
                //
                if (byte == 2 || byte == 3) {
                    deviceExtension->MouseAttributes.NumberOfButtons = byte;
                }
                else  {
                    deviceExtension->MouseAttributes.NumberOfButtons = 
                        MOUSE_NUMBER_OF_BUTTONS;
                }
                break;

            case ExpectingReadMouseStatusByte3:
                IsrPrint(DBG_MOUISR_PNPID,
                         (pDumpExpecting,
                         (ULONG) 0x00,
                         (ULONG) byte
                         ));

                bSendCommand = FALSE;
                altCommand = POST_BUTTONDETECT_COMMAND; 

                deviceExtension->InputResetSubState =
                    POST_BUTTONDETECT_COMMAND_SUBSTATE;

                break;

            case ExpectingSetResolutionDefaultACK: 

                IsrPrint(DBG_MOUISR_ACK,
                         (pDumpExpectingAck,
                         (ULONG) ACKNOWLEDGE,
                         (ULONG) byte
                         ));

                if (byte == (UCHAR) ACKNOWLEDGE) {
                    //
                    // Set the mouse refresh to the default
                    //
                    nextCommand = deviceExtension->Resolution;

                    deviceExtension->InputResetSubState =
                        ExpectingSetResolutionDefaultValueACK;

                }
                else if (byte == (UCHAR) RESEND) {
                    //
                    // NOTE: This is a workaround for the Olivetti MIPS machine,
                    // which sends a resend response if a key is held down
                    // while we're attempting the I8xMouseEnableTransmission.
                    //
                    resendCommand = SET_MOUSE_RESOLUTION;

                }
                else {
                    //
                    // Log the error
                    //
                    KeInsertQueueDpc(&deviceExtension->ErrorLogDpc,
                                     (PIRP) NULL,
                                     LongToPtr(I8042_SET_RESOLUTION_FAILED)
                                     );

                    //
                    // We didn't get an ACK on this? Boggle. Okay, let's
                    // reset the mouse (probably AGAIN) and try to figure
                    // things out one more time
                    //
                    goto IsrResetMouse;
                }

                break;
            
            case ExpectingSetResolutionDefaultValueACK: 

                IsrPrint(DBG_MOUISR_ACK,
                         (pDumpExpectingAck,
                         (ULONG) ACKNOWLEDGE,
                         (ULONG) byte
                         ));

                if (byte == (UCHAR) ACKNOWLEDGE) {
                    //
                    // Are we allowed to detect wether or not a wheel mouse
                    // is present?
                    //
                    if (deviceExtension->EnableWheelDetection == 2) { 
                        //
                        // Begin the sequence to activate the mouse wheel
                        //
                        deviceExtension->InputResetSubState = EnableWheel;
                        goto SwitchOnInputResetSubState;

                    }
                    else if (deviceExtension->EnableWheelDetection == 1) {
                        //
                        // Begin the PNP id detection sequence
                        //
                        deviceExtension->InputResetSubState =
                            StartPnPIdDetection;
                        goto SwitchOnInputResetSubState;
                    }
                    else {
                        //
                        // Begin the sequence to set the default refresh
                        // rate
                        //
                        nextCommand = POST_WHEEL_DETECT_COMMAND;

                        deviceExtension->InputResetSubState =
                            POST_WHEEL_DETECT_COMMAND_SUBSTATE;
                    }
                }
                else if (byte == (UCHAR) RESEND) {
                    //
                    // NOTE: This is a workaround for the Olivetti MIPS machine,
                    // which sends a resend response if a key is held down
                    // while we're attempting the I8xMouseEnableTransmission.
                    //
                    deviceExtension->InputResetSubState =
                        ExpectingSetResolutionDefaultACK;

                    resendCommand = SET_MOUSE_RESOLUTION;


                }
                else {
                    //
                    // Log the error
                    //
                    KeInsertQueueDpc(&deviceExtension->ErrorLogDpc,
                                     (PIRP) NULL,
                                     LongToPtr(I8042_SET_RESOLUTION_FAILED)
                                     );

                    //
                    // We didn't get an ACK on this? Boggle. Okay, let's
                    // reset the mouse (probably AGAIN) and try to figure
                    // things out one more time
                    //
                    goto IsrResetMouse;
                }
                break;

            case ExpectingLoopSetSamplingRateACK: 

                IsrPrint(DBG_MOUISR_ACK,
                         (pDumpExpectingAck,
                         (ULONG) ACKNOWLEDGE,
                         (ULONG) byte
                         ));

                if (byte == (UCHAR) ACKNOWLEDGE) {
                    //
                    // Set the new sampling rate value
                    //
                    nextCommand = deviceExtension->SampleRates[
                                       deviceExtension->SampleRatesIndex];

                    deviceExtension->InputResetSubState =
                        ExpectingLoopSetSamplingRateValueACK;

                }
                else if (byte == (UCHAR) RESEND) {
                    //
                    // The state stays the same, just resend the command
                    //
                    resendCommand = SET_MOUSE_SAMPLING_RATE;
                }
                else {

                    //
                    // Log the error
                    //
                    KeInsertQueueDpc(&deviceExtension->ErrorLogDpc,
                                     (PIRP) NULL,
                                     LongToPtr(I8042_SET_SAMPLE_RATE_FAILED)
                                     );

                    //
                    // Probably not a wheel mouse .. jump to the GetDeviceID2
                    // code
                    //
                    bSendCommand = FALSE;
                    altCommand = GET_DEVICE_ID;

                    //
                    // Best possible next state
                    //
                    deviceExtension->InputResetSubState =
                        ExpectingGetDeviceId2ACK;

                }

                break;

            case ExpectingLoopSetSamplingRateValueACK: 
                IsrPrint(DBG_MOUISR_ACK,
                         (pDumpExpectingAck,
                         (ULONG) ACKNOWLEDGE,
                         (ULONG) byte
                         ));
                IsrPrint(DBG_MOUISR_ACK,
                         ("(%2d)\n",
                         deviceExtension->SampleRates[
                          deviceExtension->SampleRatesIndex]
                         ));


                if (byte == (UCHAR) ACKNOWLEDGE) {
                    if (deviceExtension->SampleRates[
                        ++deviceExtension->SampleRatesIndex] == 
                        ONE_PAST_FINAL_SAMPLE) {
    
                        deviceExtension->InputResetSubState =
                            deviceExtension->PostSamplesState;

                        goto SwitchOnInputResetSubState;
                    }
                    else {
                        nextCommand = SET_MOUSE_SAMPLING_RATE;

                        deviceExtension->InputResetSubState =
                            ExpectingLoopSetSamplingRateACK;
                    }

                }
                else if (byte == (UCHAR) RESEND) {
                    //
                    // The state stays the same, just resend the command
                    //
                    resendCommand = deviceExtension->SampleRates[
                                       deviceExtension->SampleRatesIndex];
                }
                else {

                    //
                    // Log the error
                    //
                    KeInsertQueueDpc(&deviceExtension->ErrorLogDpc,
                                     (PIRP) NULL,
                                     LongToPtr(I8042_SET_SAMPLE_RATE_FAILED)
                                     );

                    //
                    // Probably not a wheel mouse .. jump to the GetDeviceID2
                    // code
                    //
                    bSendCommand = FALSE;
                    altCommand = GET_DEVICE_ID;

                    //
                    // Best possible next state
                    //
                    deviceExtension->InputResetSubState =
                        ExpectingGetDeviceId2ACK;

                }
                break;

            case ExpectingPnpId:
                //
                // Don't do anything but advance the state, the PnP ID will
                // be "pushed" to the ISR
                //
                deviceExtension->InputResetSubState = ExpectingPnpIdByte1;
                currentIdChar = deviceExtension->PnPID;
                RtlZeroMemory(deviceExtension->PnPID,
                              MOUSE_PNPID_LENGTH * sizeof(WCHAR)
                              );
                bSendCommand = FALSE;

                break;

            case ExpectingPnpIdByte2:
                //
                // Check to see if this an older MS mouse that gives back its ID
                // in make AND BREAK codes (ugh!).  If so, then just eat the
                // remaining 6 (+6) bytes
                //
                if (deviceExtension->PnPID[0] == L'P' && byte == 0x99) {
                    deviceExtension->InputResetSubState =
                        ExpectingLegacyPnpIdByte2_Make;
                    bSendCommand = FALSE;
                    break;
                }

            case ExpectingPnpIdByte1: 
            case ExpectingPnpIdByte3:
            case ExpectingPnpIdByte4:
            case ExpectingPnpIdByte5:
            case ExpectingPnpIdByte6:
            case ExpectingPnpIdByte7:

                IsrPrint(DBG_MOUISR_PNPID,
                         ("ExpectingPnpIdByte%1d (0x%2x)\n",
                         (ULONG) deviceExtension->InputResetSubState -
                            ExpectingPnpIdByte1 + 1,
                         (ULONG) byte
                         ));

                if (byte < ScanCodeToUCharCount) {
                    *currentIdChar = (WCHAR) ScanCodeToUChar[byte];
                }
                else {
                    *currentIdChar = L'?';
                }
                currentIdChar++;

                bSendCommand = FALSE;
                if (deviceExtension->InputResetSubState ==
                    ExpectingPnpIdByte7) {
                    if (I8xVerifyMousePnPID(deviceExtension,
                                            deviceExtension->PnPID)) {
                        //
                        // We are know know for sure that we have a wheel
                        // mouse on this system. However, we will update
                        // our date structures after the enable has gone
                        // through since that simplifies things a great deal
                        //
                        deviceExtension->InputResetSubState = EnableWheel;
                        goto SwitchOnInputResetSubState;
                    }
                    else {
                        //
                        // Oops, not our device, so lets stop the sequence
                        // now by sending it a GET_DEVICE_ID
                        //
                        altCommand = GET_DEVICE_ID;

                        //
                        // Best possible next state
                        //
                        deviceExtension->InputResetSubState =
                            ExpectingGetDeviceId2ACK;

                    }
                }
                else {
                    ASSERT(deviceExtension->InputResetSubState >= 
                           ExpectingPnpIdByte1);
                    ASSERT(deviceExtension->InputResetSubState <
                           ExpectingPnpIdByte7);

                    deviceExtension->InputResetSubState++;
                }
                break;

            case ExpectingLegacyPnpIdByte2_Make:
            case ExpectingLegacyPnpIdByte2_Break:
            case ExpectingLegacyPnpIdByte3_Make:
            case ExpectingLegacyPnpIdByte3_Break:
            case ExpectingLegacyPnpIdByte4_Make:
            case ExpectingLegacyPnpIdByte4_Break:
            case ExpectingLegacyPnpIdByte5_Make:
            case ExpectingLegacyPnpIdByte5_Break:
            case ExpectingLegacyPnpIdByte6_Make:
            case ExpectingLegacyPnpIdByte6_Break:
            case ExpectingLegacyPnpIdByte7_Make:
                //
                // Just eat the byte
                //
                deviceExtension->InputResetSubState++;
                bSendCommand = FALSE;
                break;

            case ExpectingLegacyPnpIdByte7_Break:

                //
                // Best possible next state
                //
                bSendCommand = FALSE;

                altCommand = GET_DEVICE_ID;
                deviceExtension->InputResetSubState = ExpectingGetDeviceId2ACK;
                break;
                
            case PostWheelDetectState:
                bSendCommand = FALSE;
                altCommand = POST_WHEEL_DETECT_COMMAND;

                //
                // Best possible next state
                //
                deviceExtension->InputResetSubState = 
                    POST_WHEEL_DETECT_COMMAND_SUBSTATE;
                break;

            case ExpectingGetDeviceId2ACK: 

                IsrPrint(DBG_MOUISR_ACK,
                         (pDumpExpectingAck,
                         (ULONG) ACKNOWLEDGE,
                         (ULONG) byte
                         ));

                if (byte == (UCHAR) ACKNOWLEDGE) {

                    deviceExtension->InputResetSubState =
                        ExpectingGetDeviceId2Value;

                    bSendCommand = FALSE;

                } else if (byte == (UCHAR) RESEND) {

                    //
                    // NOTE: This is a workaround for the Olivetti MIPS machine,
                    // which sends a resend response if a key is held down
                    // while we're attempting the I8xMouseEnableTransmission.
                    //
                    resendCommand = GET_DEVICE_ID;

                } else {

                    //
                    // Log the error
                    //
                    KeInsertQueueDpc(&deviceExtension->ErrorLogDpc,
                                     (PIRP) NULL,
                                     LongToPtr(I8042_GET_DEVICE_ID_FAILED)
                                     );

                    //
                    // We didn't get an ACK on this? Boggle. Okay, let's
                    // reset the mouse (probably AGAIN) and try to figure
                    // things out one more time
                    //
                    goto IsrResetMouse;
                }
                break;

            case ExpectingGetDeviceId2Value:
                IsrPrint(DBG_MOUISR_PNPID,
                         ("got a device ID of %2d\n",
                         (ULONG) byte
                         ));

                CLEAR_HW_FLAGS(WHEELMOUSE_HARDWARE_PRESENT | FIVE_BUTTON_HARDWARE_PRESENT);
                SET_HW_FLAGS(MOUSE_HARDWARE_PRESENT);
                switch (byte) {
                case MOUSE_ID_BYTE:
                    //
                    // Mouse Present, but no wheel
                    //
                    deviceExtension->MouseAttributes.MouseIdentifier =
                        MOUSE_I8042_HARDWARE;

                    if (deviceExtension->NumberOfButtonsOverride != 0) {
                        deviceExtension->MouseAttributes.NumberOfButtons = 
                            deviceExtension->NumberOfButtonsOverride;
                    }
                    else {
                        //
                        // Number of buttons is determined in the 
                        // ExpectingReadMouseStatusByte2 case
                        //
                        // Number of buttons determined in
                        ;
                    }

                    break;

                case WHEELMOUSE_ID_BYTE:
                    //
                    // Update the HardwarePresent to show a Z mouse is
                    // operational and set the appropraite mouse type flags
                    //
                    SET_HW_FLAGS(WHEELMOUSE_HARDWARE_PRESENT);

                    deviceExtension->MouseAttributes.MouseIdentifier =
                        WHEELMOUSE_I8042_HARDWARE;

                    deviceExtension->MouseAttributes.NumberOfButtons = 3;
                    break;

                case FIVEBUTTON_ID_BYTE:
                    //
                    // Update the HardwarePresent to show a 5 button wheel mouse
                    // is operational and set the appropraite mouse type flags
                    //
                    SET_HW_FLAGS(FIVE_BUTTON_HARDWARE_PRESENT | WHEELMOUSE_HARDWARE_PRESENT);
                    deviceExtension->MouseAttributes.MouseIdentifier =
                        WHEELMOUSE_I8042_HARDWARE;

                    deviceExtension->MouseAttributes.NumberOfButtons = 5;
                    break;

                default:
                    //
                    // Make sure to log the problem
                    //
                    KeInsertQueueDpc(&deviceExtension->ErrorLogDpc,
                                     (PIRP) NULL,
                                     LongToPtr(I8042_MOU_RESET_RESPONSE_FAILED)
                                     );

                    Print(DBG_MOUISR_RESETTING, ("clearing mouse (no response)\n"));
                    CLEAR_MOUSE_PRESENT();

                    deviceExtension->MouseAttributes.NumberOfButtons = 0;
                    deviceExtension->MouseAttributes.MouseIdentifier = 0;

                    //
                    // Set up the state machine as best we can
                    //
                    goto IsrResetMouse;
                }


                //
                // Send down the command to set a new sampling rate
                //
                bSendCommand = FALSE;
                altCommand = SET_MOUSE_SAMPLING_RATE;

                //
                // This is our next state
                //
                deviceExtension->InputResetSubState =
                    ExpectingSetSamplingRateACK;

                break;

            case ExpectingSetSamplingRateACK: 

                IsrPrint(DBG_MOUISR_ACK,
                         (pDumpExpectingAck,
                         (ULONG) ACKNOWLEDGE,
                         (ULONG) byte
                         ));

                if (byte == (UCHAR) ACKNOWLEDGE) {
                    //
                    // Set the mouse refresh rate to its final value
                    //
                    nextCommand = 
                        (UCHAR) deviceExtension->MouseAttributes.SampleRate;

                    deviceExtension->InputResetSubState =
                        ExpectingSetSamplingRateValueACK;

                }
                else if (byte == (UCHAR) RESEND) {
                    //
                    // NOTE: This is a workaround for the Olivetti MIPS machine,
                    // which sends a resend response if a key is held down
                    // while we're attempting the I8xMouseEnableTransmission.
                    //
                    resendCommand = SET_MOUSE_SAMPLING_RATE;
                }
                else {
                    //
                    // Log the error
                    //
                    KeInsertQueueDpc(&deviceExtension->ErrorLogDpc,
                                     (PIRP) NULL,
                                     LongToPtr(I8042_SET_SAMPLE_RATE_FAILED)
                                     );

                    //
                    // We didn't get an ACK on this? Boggle. Okay, let's
                    // reset the mouse (probably AGAIN) and try to figure
                    // things out one more time
                    //
                    goto IsrResetMouse;
                }
                break;

            case ExpectingSetSamplingRateValueACK: 

                IsrPrint(DBG_MOUISR_ACK,
                         (pDumpExpectingAck,
                         (ULONG) ACKNOWLEDGE,
                         (ULONG) byte
                         ));

                if (byte == (UCHAR) ACKNOWLEDGE) {
                    //
                    // Let's set the resolution once more to be sure.
                    //
                    nextCommand = SET_MOUSE_RESOLUTION;

                    //
                    // We go back to expecting an ACK
                    //
                    deviceExtension->InputResetSubState =
                        ExpectingFinalResolutionACK;
                }
                else if (byte == (UCHAR) RESEND) {
                    //
                    // NOTE: This is a workaround for the Olivetti MIPS machine,
                    // which sends a resend response if a key is held down
                    // while we're attempting the I8xMouseEnableTransmission.
                    //
                    resendCommand = SET_MOUSE_SAMPLING_RATE;

                    deviceExtension->InputResetSubState =
                        ExpectingSetSamplingRateACK;
                }
                else {
                    //
                    // Log the error
                    //
                    KeInsertQueueDpc(&deviceExtension->ErrorLogDpc,
                                     (PIRP) NULL,
                                     LongToPtr(I8042_SET_SAMPLE_RATE_FAILED)
                                     );

                    //
                    // We didn't get an ACK on this? Boggle. Okay, let's
                    // reset the mouse (probably AGAIN) and try to figure
                    // things out one more time
                    //
                    goto IsrResetMouse;
                }
                break;

            case ExpectingFinalResolutionACK: 

                IsrPrint(DBG_MOUISR_ACK,
                         (pDumpExpectingAck,
                         (ULONG) ACKNOWLEDGE,
                         (ULONG) byte
                         ));

                if (byte == (UCHAR) ACKNOWLEDGE) {
                    //
                    // Set the mouse refresh rate to its final value
                    //
                    nextCommand = 
                        (UCHAR) deviceExtension->Resolution;

                    deviceExtension->InputResetSubState =
                        ExpectingFinalResolutionValueACK;

                }
                else if (byte == (UCHAR) RESEND) {
                    //
                    // NOTE: This is a workaround for the Olivetti MIPS machine,
                    // which sends a resend response if a key is held down
                    // while we're attempting the I8xMouseEnableTransmission.
                    //
                    resendCommand = SET_MOUSE_RESOLUTION;
                }
                else {
                    //
                    // Log the error
                    //
                    KeInsertQueueDpc(&deviceExtension->ErrorLogDpc,
                                     (PIRP) NULL,
                                     LongToPtr(I8042_SET_RESOLUTION_FAILED)
                                     );

                    //
                    // We didn't get an ACK on this? Boggle. Okay, let's
                    // reset the mouse (probably AGAIN) and try to figure
                    // things out one more time
                    //
                    goto IsrResetMouse;
                }
                break;

            case ExpectingFinalResolutionValueACK: 

                IsrPrint(DBG_MOUISR_ACK,
                         (pDumpExpectingAck,
                         (ULONG) ACKNOWLEDGE,
                         (ULONG) byte
                         ));

                if (byte == (UCHAR) ACKNOWLEDGE) {
                    //
                    // Finally!  Enable the mouse and we are done
                    //
                    nextCommand = ENABLE_MOUSE_TRANSMISSION;

                    //
                    // We go back to expecting an ACK
                    //
                    deviceExtension->InputResetSubState =
                        ExpectingEnableACK;
                }
                else if (byte == (UCHAR) RESEND) {
                    //
                    // NOTE: This is a workaround for the Olivetti MIPS machine,
                    // which sends a resend response if a key is held down
                    // while we're attempting the I8xMouseEnableTransmission.
                    //
                    resendCommand = SET_MOUSE_RESOLUTION;

                    deviceExtension->InputResetSubState =
                        ExpectingFinalResolutionACK;
                }
                else {
                    //
                    // Log the error
                    //
                    KeInsertQueueDpc(&deviceExtension->ErrorLogDpc,
                                     (PIRP) NULL,
                                     LongToPtr(I8042_SET_RESOLUTION_FAILED)
                                     );

                    //
                    // We didn't get an ACK on this? Boggle. Okay, let's
                    // reset the mouse (probably AGAIN) and try to figure
                    // things out one more time
                    //
                    goto IsrResetMouse;
                }
                break;
  
            case ExpectingEnableACK: 

                IsrPrint(DBG_MOUISR_ACK,
                         (pDumpExpectingAck,
                         (ULONG) ACKNOWLEDGE,
                         (ULONG) byte
                         ));

                if (byte == (UCHAR) ACKNOWLEDGE) {
                    //
                    // Done and reset the number of possible mouse resets
                    //
                    deviceExtension->InputState = MouseIdle;
                    I8X_MOUSE_INIT_COUNTERS(deviceExtension);

                    deviceExtension->CurrentInput.Flags |=
                        MOUSE_ATTRIBUTES_CHANGED;
                    I8xQueueCurrentMouseInput(DeviceObject);

                    ASSERT(DeviceObject->CurrentIrp ==
                           deviceExtension->ResetIrp);

                    ASSERT(deviceExtension->ResetIrp != NULL);
                    ASSERT(DeviceObject->CurrentIrp != NULL);

                    //
                    // CurrentIrp is == deviceExtension->ResetIrp
                    //
                    IoRequestDpc(DeviceObject,
                                 // DeviceObject->CurrentIrp,
                                 deviceExtension->ResetIrp,
                                 IntToPtr(IsrDpcCauseMouseResetComplete)
                                 );
                }
                else if (byte == (UCHAR) RESEND) {

                    //
                    // Resend the "Enable Mouse Transmission" sequence.
                    //
                    // NOTE: This is a workaround for the Olivetti MIPS machine,
                    // which sends a resend response if a key is held down
                    // while we're attempting the I8xMouseEnableTransmission.
                    //
                    resendCommand = ENABLE_MOUSE_TRANSMISSION;
                }
                else {

                    //
                    // We could not understand if we were able to reenable the
                    // mouse... Best bet here is to also reset the mouse.
                    //
                    // Log the error
                    //
                    KeInsertQueueDpc(&deviceExtension->ErrorLogDpc,
                                     (PIRP) NULL,
                                     LongToPtr(I8042_ENABLE_FAILED)
                                     );

                    goto IsrResetMouse;
                }
                break;

            case MouseResetFailed:
                //
                // We have failed to reset the mouse, just ignore all further
                // data.  The ResetSubState will be reset if / when the user
                // tries to reset the mouse via a plug in
                //
                return TRUE;

            default: 

                //
                // This is our bad state
                //
                IsrPrint(DBG_MOUISR_ERROR | DBG_MOUISR_STATE,
                      (" INVALID RESET SUBSTATE %d\n",
                      deviceExtension->InputResetSubState
                      ));

                //
                // Queue a DPC to log an internal driver error.
                //

                KeInsertQueueDpc(
                    &deviceExtension->ErrorLogDpc,
                    (PIRP) NULL,
                    LongToPtr(I8042_INVALID_ISR_STATE_MOU)
                    );

                ASSERT(FALSE);

            } // switch (deviceExtension->MouseExtension.InputResetSubState)

            break;
        }

        default: {

            //
            // This is our bad state
            //
            IsrPrint(DBG_MOUISR_ERROR | DBG_MOUISR_STATE,
                  (" INVALID STATE %d\n",
                  deviceExtension->InputState
                  ));

            //
            // Queue a DPC to log an internal driver error.
            //

            KeInsertQueueDpc(
                &deviceExtension->ErrorLogDpc,
                (PIRP) NULL,
                LongToPtr(I8042_INVALID_ISR_STATE_MOU)
                );

            ASSERT(FALSE);
            break;
        }

    }

    if (deviceExtension->InputState == MouseResetting) {
        if (bSendCommand) {
            if (byte == (UCHAR) ACKNOWLEDGE) {
                I8X_WRITE_CMD_TO_MOUSE();
                I8X_MOUSE_COMMAND( nextCommand );
                RECORD_ISR_STATE_COMMAND(deviceExtension, nextCommand); 
            }
            else if (byte == (UCHAR) RESEND) {
                if (deviceExtension->ResendCount++ < MOUSE_RESENDS_MAX) {
                    I8X_WRITE_CMD_TO_MOUSE();
                    I8X_MOUSE_COMMAND( resendCommand );
                    RECORD_ISR_STATE_COMMAND(deviceExtension, resendCommand); 
                }
                else {
                    //
                    // Got too many resends, try a (possible) reset
                    //
                    deviceExtension->ResendCount = 0;
                    goto IsrResetMouse;
                }
            }
        }
        else if (altCommand) {
            I8X_WRITE_CMD_TO_MOUSE();
            I8X_MOUSE_COMMAND( altCommand );
            RECORD_ISR_STATE_COMMAND(deviceExtension, altCommand); 
        }

        if (byte != (UCHAR) RESEND) {
            deviceExtension->ResendCount = 0;
        }
    }


    IsrPrint(DBG_MOUISR_TRACE, ("exit\n"));

    return TRUE;

IsrResetMouse:
    //
    // About 1/2 of the errors in the resetting state machine are caused by 
    // trying to see if the wheel on the mouse exists...just try to enable it 
    // from now on....
    //
    if (deviceExtension->EnableWheelDetection == 1) {
        deviceExtension->EnableWheelDetection = 2;
    }

IsrResetMouseOnly:
    deviceExtension->InputResetSubState = QueueingMouseReset;
    KeInsertQueueDpc(&deviceExtension->MouseIsrResetDpc,
                     0,
                     NULL
                     );

    return ret;
#undef TRANSITION_UP
#undef TRANSITION_DOWN
}

NTSTATUS
I8xInitializeMouse(
    IN PPORT_MOUSE_EXTENSION MouseExtension
    )
/*++

Routine Description:

    This routine initializes the i8042 mouse hardware.  It is called
    only at initialization, and does not synchronize access to the hardware.

Arguments:

    DeviceObject - Pointer to the device object.

Return Value:

    Returns status.

--*/    

{
#define DUMP_COUNT 4

    NTSTATUS                errorCode = STATUS_SUCCESS;
    NTSTATUS                status;
    PPORT_MOUSE_EXTENSION   deviceExtension;
    PDEVICE_OBJECT          deviceObject;
    PIO_ERROR_LOG_PACKET    errorLogEntry;
    UCHAR                   byte;
    UCHAR                   numButtons;
    ULONG                   dumpData[DUMP_COUNT];
    ULONG                   dumpCount = 0;
    ULONG                   i;
    ULONG                   uniqueErrorValue;
    LARGE_INTEGER           li,
                            startOfSpin,
                            nextQuery,
                            difference,
                            tenSeconds;
    BOOLEAN                 okToLogError;

    PAGED_CODE();

    Print(DBG_SS_TRACE, ("I8xInitializeMouse enter\n"));

    //
    // Initialize this array
    //
    for (i = 0; i < DUMP_COUNT; i++) {
        dumpData[i] = 0;
    }

    //
    // Get the device extension.
    //
    deviceExtension = MouseExtension; 
    deviceObject = deviceExtension->Self;
    okToLogError = TRUE;

    //
    // Reset the mouse.  Send a Write To Auxiliary Device command to the
    // 8042 controller.  Then send the Reset Mouse command to the mouse
    // through the 8042 data register.  Expect to get back an ACK, followed
    // by a completion code and the ID code (0x00).
    //
    status = I8xPutBytePolled(
        (CCHAR) DataPort,
        WAIT_FOR_ACKNOWLEDGE,
        (CCHAR) MouseDeviceType,
        (UCHAR) MOUSE_RESET
        );

    if (!NT_SUCCESS(status)) {
        Print(DBG_SS_ERROR,
             ("%s failed mouse reset, status 0x%x\n",
             pFncInitializeMouse,
             status
             ));

        //
        // Only log this error if the user wants to see it
        //
        okToLogError = Globals.ReportResetErrors;

        //
        // Set up error log info.
        //
        // Use NO_MOU_DEVICE instead of I8042_MOU_RESET_COMMAND_FAILED because 
        // it is a clearer message.
        //
        errorCode = I8042_NO_MOU_DEVICE;
        uniqueErrorValue = I8042_ERROR_VALUE_BASE + 415;
        dumpData[0] = KBDMOU_COULD_NOT_SEND_PARAM;
        dumpData[1] = DataPort;
        dumpData[2] = I8042_WRITE_TO_AUXILIARY_DEVICE;
        dumpData[3] = MOUSE_RESET;
        dumpCount = 4;

        status = STATUS_DEVICE_NOT_CONNECTED;
        SET_HW_FLAGS(PHANTOM_MOUSE_HARDWARE_REPORTED);
       
        goto I8xInitializeMouseExit;
    }

    deviceExtension->ResendCount = 0;
    I8X_MOUSE_INIT_COUNTERS(deviceExtension);

    //
    // Get the mouse reset responses.  The first response should be a
    // MOUSE_COMPLETE.  The second response should be the mouse ID.
    // Note that it is usually necessary to stall a long time to get the
    // mouse reset/self-test to work.
    //
    li.QuadPart = -100;

    tenSeconds.QuadPart = 10*10*1000*1000;
    KeQueryTickCount(&startOfSpin);

    while (1) {
        status = I8xGetBytePolled(
            (CCHAR) ControllerDeviceType,
            &byte
            );

        if (NT_SUCCESS(status) && (byte == (UCHAR) MOUSE_COMPLETE)) {
            //
            // The reset completed successfully.
            //
            break;
        }
        else {
            //
            // Stall, and then try again to get a response from
            // the reset.
            //
            if (status == STATUS_IO_TIMEOUT) {
                //
                // Stall, and then try again to get a response from
                // the reset.
                //
                KeDelayExecutionThread(KernelMode,
                                       FALSE,
                                       &li);

                KeQueryTickCount(&nextQuery);

                difference.QuadPart = nextQuery.QuadPart - startOfSpin.QuadPart;

                ASSERT(KeQueryTimeIncrement() <= MAXLONG);
                if (difference.QuadPart*KeQueryTimeIncrement() >=
                    tenSeconds.QuadPart) {

                    break;
                }
            }
            else {
                break;
            }
        }
    }

    if (!NT_SUCCESS(status)) {
        Print(DBG_SS_ERROR,
             ("%s failed reset response 1, status 0x%x, byte 0x%x\n",
             pFncInitializeMouse,
             status,
             byte
             ));

        //
        // Set up error log info.
        //
        errorCode = I8042_MOU_RESET_RESPONSE_FAILED;
        uniqueErrorValue = I8042_ERROR_VALUE_BASE + 420;
        dumpData[0] = KBDMOU_INCORRECT_RESPONSE;
        dumpData[1] = ControllerDeviceType;
        dumpData[2] = MOUSE_COMPLETE;
        dumpData[3] = byte;
        dumpCount = 4;

        goto I8xInitializeMouseExit;
    }

    status = I8xGetBytePolled(
        (CCHAR) ControllerDeviceType,
        &byte
        );

    if ((!NT_SUCCESS(status)) || (byte != MOUSE_ID_BYTE)) {

        Print(DBG_SS_ERROR,
             ("%s failed reset response 2, status 0x%x, byte 0x%x\n",
             pFncInitializeMouse,
             status,
             byte
             ));

        //
        // Set up error log info.
        //
        errorCode = I8042_MOU_RESET_RESPONSE_FAILED;
        uniqueErrorValue = I8042_ERROR_VALUE_BASE + 425;
        dumpData[0] = KBDMOU_INCORRECT_RESPONSE;
        dumpData[1] = ControllerDeviceType;
        dumpData[2] = MOUSE_ID_BYTE;
        dumpData[3] = byte;
        dumpCount = 4;

        goto I8xInitializeMouseExit;
    }

    //
    // If we are going to initialize the mouse via the interrupt (the default),
    //  then quit here 
    //
    if (!deviceExtension->InitializePolled) {
        Print(DBG_SS_NOISE, ("Initializing via the interrupt\n"));
        return STATUS_SUCCESS;
    }

    Print(DBG_SS_NOISE, ("Initializing polled\n"));

    deviceExtension->EnableMouse.FirstTime = TRUE;
    deviceExtension->EnableMouse.Enabled = TRUE;
    deviceExtension->EnableMouse.Count = 0;

    //
    // Check to see if this is a wheel mouse
    //
    I8xFindWheelMouse(deviceExtension);

    //
    // Try to detect the number of mouse buttons.
    //
    status = I8xQueryNumberOfMouseButtons(&numButtons);

    Print(DBG_SS_INFO,
          ("num buttons returned (%d), num butons in attrib (%d)\n"
           "\t(if 0, then no logitech detection support)\n",
          numButtons,
          deviceExtension->MouseAttributes.NumberOfButtons
          ));

    if (!NT_SUCCESS(status)) {
        Print(DBG_SS_ERROR,
              ("%s: failed to get buttons, status 0x%x\n",
              pFncInitializeMouse,
              status
              ));

        //
        // Set up error log info.
        //
        errorCode = I8042_ERROR_DURING_BUTTONS_DETECT;
        uniqueErrorValue = I8042_ERROR_VALUE_BASE + 426;
        dumpData[0] = KBDMOU_COULD_NOT_SEND_PARAM;
        dumpData[1] = DataPort;
        dumpData[2] = I8042_WRITE_TO_AUXILIARY_DEVICE;
        dumpCount = 3;

        goto I8xInitializeMouseExit;

    } else if (numButtons) {

        deviceExtension->MouseAttributes.NumberOfButtons =
            numButtons;

    }

    //
    // If there is a 5 button mouse, report it.
    // If there is a wheel, hardcode the number of buttons to three
    //
    if (FIVE_PRESENT()) {
        deviceExtension->MouseAttributes.NumberOfButtons = 5;
    }
    else if (WHEEL_PRESENT()) {
        deviceExtension->MouseAttributes.NumberOfButtons = 3;
    }


    //
    // Set mouse sampling rate.  Send a Write To Auxiliary Device command
    // to the 8042 controller.  Then send the Set Mouse Sampling Rate
    // command to the mouse through the 8042 data register,
    // followed by its parameter.
    //
    status = I8xPutBytePolled(
        (CCHAR) DataPort,
        WAIT_FOR_ACKNOWLEDGE,
        (CCHAR) MouseDeviceType,
        (UCHAR) SET_MOUSE_SAMPLING_RATE
        );

    if (!NT_SUCCESS(status)) {

        Print(DBG_SS_ERROR,
              ("%s: failed write set sample rate, status 0x%x\n",
              pFncInitializeMouse,
              status
              ));

        //
        // Set up error log info.
        //
        errorCode = I8042_SET_SAMPLE_RATE_FAILED;
        uniqueErrorValue = I8042_ERROR_VALUE_BASE + 435;
        dumpData[0] = KBDMOU_COULD_NOT_SEND_PARAM;
        dumpData[1] = DataPort;
        dumpData[2] = I8042_WRITE_TO_AUXILIARY_DEVICE;
        dumpData[3] = SET_MOUSE_SAMPLING_RATE;
        dumpCount = 4;

        goto I8xInitializeMouseExit;

    }

    status = I8xPutBytePolled(
        (CCHAR) DataPort,
        WAIT_FOR_ACKNOWLEDGE,
        (CCHAR) MouseDeviceType,
        (UCHAR) deviceExtension->MouseAttributes.SampleRate
        );

    if (!NT_SUCCESS(status)) {

        Print(DBG_SS_ERROR,
              ("%s: failed write sample rate, status 0x%x\n",
              pFncInitializeMouse,
              status
              ));

        //
        // Set up error log info.
        //
        errorCode = I8042_SET_SAMPLE_RATE_FAILED;
        uniqueErrorValue = I8042_ERROR_VALUE_BASE + 445;
        dumpData[0] = KBDMOU_COULD_NOT_SEND_PARAM;
        dumpData[1] = DataPort;
        dumpData[2] = I8042_WRITE_TO_AUXILIARY_DEVICE;
        dumpData[3] = deviceExtension->MouseAttributes.SampleRate;
        dumpCount = 4;

        goto I8xInitializeMouseExit;

    }

    //
    // Set the mouse resolution.  Send a Write To Auxiliary Device command
    // to the 8042 controller.  Then send the Set Mouse Resolution
    // command to the mouse through the 8042 data register,
    // followed by its parameter.
    //
    status = I8xPutBytePolled(
        (CCHAR) DataPort,
        WAIT_FOR_ACKNOWLEDGE,
        (CCHAR) MouseDeviceType,
        (UCHAR) SET_MOUSE_RESOLUTION
        );

    if (!NT_SUCCESS(status)) {

        Print(DBG_SS_ERROR,
              ("%s: failed write set resolution, status 0x%x\n",
              pFncInitializeMouse,
              status
              ));

        //
        // Set up error log info.
        //
        errorCode = I8042_SET_RESOLUTION_FAILED;
        uniqueErrorValue = I8042_ERROR_VALUE_BASE + 455;
        dumpData[0] = KBDMOU_COULD_NOT_SEND_PARAM;
        dumpData[1] = DataPort;
        dumpData[2] = I8042_WRITE_TO_AUXILIARY_DEVICE;
        dumpData[3] = SET_MOUSE_RESOLUTION;
        dumpCount = 4;

        goto I8xInitializeMouseExit;

    }

    status = I8xPutBytePolled(
        (CCHAR) DataPort,
        WAIT_FOR_ACKNOWLEDGE,
        (CCHAR) MouseDeviceType,
        (UCHAR) deviceExtension->Resolution
        );

    if (!NT_SUCCESS(status)) {

        Print(DBG_SS_ERROR,
              ("%s: failed set mouse resolution, status 0x%x\n",
              pFncInitializeMouse,
              status
              ));

        //
        // Set up error log info.
        //
        errorCode = I8042_SET_RESOLUTION_FAILED;
        uniqueErrorValue = I8042_ERROR_VALUE_BASE + 465;
        dumpData[0] = KBDMOU_COULD_NOT_SEND_PARAM;
        dumpData[1] = DataPort;
        dumpData[2] = I8042_WRITE_TO_AUXILIARY_DEVICE;
        dumpData[3] = deviceExtension->Resolution;
        dumpCount = 4;

        goto I8xInitializeMouseExit;

    }

I8xInitializeMouseExit:

    if (!NT_SUCCESS(status)) {
        //
        // The mouse initialization failed.  Log an error.
        //
        if (errorCode != STATUS_SUCCESS && okToLogError) {
            I8xLogError(deviceObject,
                        errorCode,
                        uniqueErrorValue,
                        status,
                        dumpData,
                        dumpCount
                        );
        }
    }

    //
    // Initialize current mouse input packet state.
    //
    deviceExtension->PreviousSignAndOverflow = 0;
    deviceExtension->InputState = MouseExpectingACK;
    deviceExtension->InputResetSubState = 0;
    deviceExtension->LastByteReceived = 0;

    Print(DBG_SS_TRACE,
          ("%s, %s\n",
          pFncInitializeMouse,
          pExit
          ));

    return status;
}

NTSTATUS
I8xMouseConfiguration(
    IN PPORT_MOUSE_EXTENSION MouseExtension,
    IN PCM_RESOURCE_LIST ResourceList
    )
/*++

Routine Description:

    This routine retrieves the configuration information for the mouse.

Arguments:

    MouseExtension - Mouse extension
    
    ResourceList - Translated resource list give to us via the start IRP
    
Return Value:

    STATUS_SUCCESS if all the resources required are presented
    
--*/
{
    NTSTATUS                            status = STATUS_SUCCESS;

    PCM_PARTIAL_RESOURCE_LIST           partialResList = NULL;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR     firstResDesc = NULL,
                                        currentResDesc = NULL;
    PCM_FULL_RESOURCE_DESCRIPTOR        fullResDesc = NULL;
    PI8042_CONFIGURATION_INFORMATION    configuration;

    ULONG                               count,
                                        i;

    KINTERRUPT_MODE                     defaultInterruptMode;
    BOOLEAN                             defaultInterruptShare;

    PAGED_CODE();

    if (!ResourceList) {
        Print(DBG_SS_INFO | DBG_SS_ERROR, ("mouse with no resources\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    fullResDesc = ResourceList->List;
    if (!fullResDesc) {
        //
        // this should never happen
        //
        ASSERT(fullResDesc != NULL);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    SET_HW_FLAGS(MOUSE_HARDWARE_PRESENT);
    configuration = &Globals.ControllerData->Configuration;

    partialResList = &fullResDesc->PartialResourceList;
    currentResDesc = firstResDesc = partialResList->PartialDescriptors;
    count = partialResList->Count;
  
    configuration->FloatingSave   = I8042_FLOATING_SAVE;
    configuration->BusNumber      = fullResDesc->BusNumber;
    configuration->InterfaceType  = fullResDesc->InterfaceType;

    if (configuration->InterfaceType == MicroChannel) {
        defaultInterruptShare = TRUE;
        defaultInterruptMode = LevelSensitive;
    }
    else {
        defaultInterruptShare = I8042_INTERRUPT_SHARE;
        defaultInterruptMode = I8042_INTERRUPT_MODE;
    }
    
    //
    // NOTE:  not all of the resources associated with the i8042 may be given at 
    //        this time.  From empirical tests, the mouse is only associated with its
    //        interrupt, while the keyboard will receive the ports along with its
    //        interrupt
    //
    for (i = 0; i < count; i++, currentResDesc++) {
        switch (currentResDesc->Type) {
        case CmResourceTypeMemory:
            Globals.RegistersMapped = TRUE;

        case CmResourceTypePort:
            //
            // Copy the port information.  We will sort the port list
            // into ascending order based on the starting port address
            // later (note that we *know* there are a max of two port
            // ranges for the i8042).
            //
#if 0
            if (currentResDesc->Flags == CM_RESOURCE_PORT_MEMORY) {
                Globals.RegistersMapped = TRUE;
            }
#endif

            Print(DBG_SS_NOISE, ("io flags are 0x%x\n", currentResDesc->Flags));

            if (configuration->PortListCount < MaximumPortCount) {
                configuration->PortList[configuration->PortListCount] =
                    *currentResDesc;
                configuration->PortList[configuration->PortListCount].ShareDisposition =
                    I8042_REGISTER_SHARE ? CmResourceShareShared:
                                           CmResourceShareDriverExclusive;
                configuration->PortListCount += 1;
            }
            else {
                Print(DBG_SS_INFO | DBG_SS_ERROR,
                      ("Mouse::PortListCount already at max (%d)",
                      configuration->PortListCount
                      ));
            }

            break;

        case CmResourceTypeInterrupt:
            //
            // Copy the interrupt information.
            //
            MouseExtension->InterruptDescriptor = *currentResDesc;
            MouseExtension->InterruptDescriptor.ShareDisposition =
            defaultInterruptShare ? CmResourceShareShared :
                                    CmResourceShareDeviceExclusive;

            break;

        default:
            Print(DBG_ALWAYS,
                  ("resource type 0x%x unhandled...\n",
                  (LONG) currentResDesc->Type
                  ));
            break;

        }
    }

    MouseExtension->MouseAttributes.MouseIdentifier = MOUSE_I8042_HARDWARE;

    //
    // If no interrupt configuration information was found, use the
    // mouse driver defaults.
    //
    if (!(MouseExtension->InterruptDescriptor.Type & CmResourceTypeInterrupt)) {

        Print(DBG_SS_INFO | DBG_SS_ERROR,
              ("Using default mouse interrupt config\n"
              ));

        MouseExtension->InterruptDescriptor.Type = CmResourceTypeInterrupt;
        MouseExtension->InterruptDescriptor.ShareDisposition =
            defaultInterruptShare ? CmResourceShareShared :
                                    CmResourceShareDeviceExclusive;
        MouseExtension->InterruptDescriptor.Flags =
            (defaultInterruptMode == Latched) ? CM_RESOURCE_INTERRUPT_LATCHED :
                CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
        MouseExtension->InterruptDescriptor.u.Interrupt.Level = MOUSE_IRQL;
        MouseExtension->InterruptDescriptor.u.Interrupt.Vector = MOUSE_VECTOR;

        // MouseExtension->ReportInterrupt = TRUE;
    }

    Print(DBG_SS_INFO,
          ("Mouse interrupt config --\n"
          "%s, %s, Irq = 0x%x\n",
          MouseExtension->InterruptDescriptor.ShareDisposition == CmResourceShareShared?
              "Sharable" : "NonSharable",
          MouseExtension->InterruptDescriptor.Flags == CM_RESOURCE_INTERRUPT_LATCHED?
              "Latched" : "Level Sensitive",
          MouseExtension->InterruptDescriptor.u.Interrupt.Vector
          ));

    if (NT_SUCCESS(status)) {
        SET_HW_FLAGS(MOUSE_HARDWARE_INITIALIZED); 
    }
    return status;
}

NTSTATUS
I8xQueryNumberOfMouseButtons(
    OUT PUCHAR          NumberOfMouseButtons
    )

/*++

Routine Description:

    This implements logitech's method for detecting the number of
    mouse buttons.  If anything doesn't go as expected then 0
    is returned.

    Calling this routine will set the mouse resolution to something
    really low.  The mouse resolution should be reset after this
    call.

Arguments:

    DeviceObject    - Supplies the device object.

    NumberOfMouseButtons    - Returns the number of mouse buttons or 0 if
                                the device did not support this type of
                                mouse button detection.

Return Value:

    An NTSTATUS code indicating success or failure.

--*/

{
    NTSTATUS            status;
    UCHAR               byte;
    UCHAR               buttons;
    ULONG               i;

    PAGED_CODE();

    //
    // First we need to send down a set resolution command
    //
    status = I8xPutBytePolled(
        (CCHAR) DataPort,
        WAIT_FOR_ACKNOWLEDGE,
        (CCHAR) MouseDeviceType, 
        (UCHAR) SET_MOUSE_RESOLUTION
        );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    //
    // This is another part of the data packet to get the info we want
    //
    status = I8xPutBytePolled(
        (CCHAR) DataPort,
        WAIT_FOR_ACKNOWLEDGE,
        (CCHAR) MouseDeviceType,
        (UCHAR) 0x00
        );

    if (!NT_SUCCESS(status)) {

        return status;

    }

    for (i = 0; i < 3; i++) {

        status = I8xPutBytePolled(
            (CCHAR) DataPort,
            WAIT_FOR_ACKNOWLEDGE,
            (CCHAR) MouseDeviceType,
            (UCHAR) SET_MOUSE_SCALING_1TO1
            );
        if (!NT_SUCCESS(status)) {

            return status;

        }

    }

    status = I8xPutBytePolled(
        (CCHAR) DataPort,
        WAIT_FOR_ACKNOWLEDGE,
        (CCHAR) MouseDeviceType,
        (UCHAR) READ_MOUSE_STATUS
        );
    if (!NT_SUCCESS(status)) {

        return status;

    }

    status = I8xGetBytePolled((CCHAR) ControllerDeviceType, &byte);
    if (!NT_SUCCESS(status)) {
        return status;
    }
    Print(DBG_SS_NOISE, ("Query Buttons, 1st byte:  0x%2x\n", byte));

    status = I8xGetBytePolled((CCHAR) ControllerDeviceType, &buttons);
    if (!NT_SUCCESS(status)) {
        return status;
    }
    Print(DBG_SS_NOISE, ("Query Buttons, 2nd byte:  0x%2x\n", buttons));

    status = I8xGetBytePolled((CCHAR) ControllerDeviceType, &byte);
    if (!NT_SUCCESS(status)) {
        return status;
    }
    Print(DBG_SS_NOISE, ("Query Buttons, 3rd byte:  0x%2x\n", byte));

    if (buttons == 2 || buttons == 3) {
        *NumberOfMouseButtons = buttons;
        Print(DBG_SS_NOISE, ("Query Buttons found %2x", *NumberOfMouseButtons));
    }
    else {
        *NumberOfMouseButtons = 0;
        Print(DBG_SS_NOISE, ("Query Buttons -- not supported\n"));
    }

    return status;
}

NTSTATUS
I8xMouseEnableTransmission(
    IN PPORT_MOUSE_EXTENSION MouseExtension
    )

/*++

Routine Description:

    This routine sends an Enable command to the mouse hardware, causing
    the mouse to begin transmissions.  It is called at initialization
    time, but only after the interrupt has been connected.  This is
    necessary so the driver can keep its notion of the mouse input data
    state in sync with the hardware (i.e., for this type of mouse there is no
    way to differentiate the first byte of a packet; if the user is randomly
    moving the mouse during boot/initialization, the first mouse interrupt we
    receive following IoConnectInterrupt could be for a byte that is not the
    start of a packet, and we have no way to know that).

Arguments:

    DeviceObject - Pointer to the device object.

Return Value:

    Returns status.

--*/

{
#define DUMP_COUNT 4
    NTSTATUS                errorCode = STATUS_SUCCESS;
    NTSTATUS                status;
    PIO_ERROR_LOG_PACKET    errorLogEntry;
    ULONG                   dumpCount = 0;
    ULONG                   dumpData[DUMP_COUNT];
    ULONG                   i;
    ULONG                   uniqueErrorValue;
    LARGE_INTEGER           li;
    PPORT_MOUSE_EXTENSION  mouseExtension;

    Print(DBG_SS_TRACE,
          ("%s: %s\n",
          pFncMouseEnable,
          pEnter
          ));

    //
    // Initialize the dump structure
    //
    for (i = 0; i < DUMP_COUNT; i++) {

        dumpData[i] = 0;

    }

    if (MouseExtension->EnableMouse.FirstTime) {
        // 5 seconds
        li.QuadPart = -5    * 10       // from 100 ns to us
                            * 1000     //      us to ms
                            * 1000;    //      ms to s
        MouseExtension->EnableMouse.FirstTime = FALSE;

        KeSetTimerEx(
            &MouseExtension->EnableMouse.Timer,
            li,
            5 * 1000,  // ms to s
            &MouseExtension->EnableMouse.Dpc
            );
    }
                 
    //
    // Re-enable the mouse at the mouse hardware, so that it can transmit
    // data packets in continuous mode.  Note that this is not the same
    // as enabling the mouse device at the 8042 controller.  The mouse
    // hardware is sent an Enable command here, because it was
    // Disabled as a result of the mouse reset command performed
    // in I8xInitializeMouse().
    //
    // Note that we don't wait for an ACKNOWLEDGE back.  The
    // ACKNOWLEDGE back will actually cause a mouse interrupt, which
    // then gets handled in the mouse ISR.
    //
    status = I8xPutBytePolled(
        (CCHAR) DataPort,
        NO_WAIT_FOR_ACKNOWLEDGE,
        (CCHAR) MouseDeviceType,
        (UCHAR) ENABLE_MOUSE_TRANSMISSION
        );

    if (!NT_SUCCESS(status)) {

        Print(DBG_SS_ERROR,
             ("%s: "
             "failed write enable transmission, status 0x%x\n",
             pFncMouseEnable,
             status
             ));

        //
        // Set up error log info.
        //
        errorCode = I8042_MOU_ENABLE_XMIT;
        uniqueErrorValue = I8042_ERROR_VALUE_BASE + 475;
        dumpData[0] = KBDMOU_COULD_NOT_SEND_PARAM;
        dumpData[1] = DataPort;
        dumpData[2] = I8042_WRITE_TO_AUXILIARY_DEVICE;
        dumpData[3] = ENABLE_MOUSE_TRANSMISSION;
        dumpCount = 4;

        goto I8xEnableMouseTransmissionExit;
    }

I8xEnableMouseTransmissionExit:

    if (!NT_SUCCESS(status)) {

        //
        // The mouse initialization failed.  Log an error.
        //
        if (errorCode != STATUS_SUCCESS) {

            errorLogEntry = (PIO_ERROR_LOG_PACKET)
                IoAllocateErrorLogEntry(
                    MouseExtension->Self, (UCHAR)
                    (sizeof(IO_ERROR_LOG_PACKET) + (dumpCount * sizeof(ULONG)))
                    );

            if (errorLogEntry != NULL) {

                errorLogEntry->ErrorCode = errorCode;
                errorLogEntry->DumpDataSize = (USHORT) dumpCount * sizeof(ULONG);
                errorLogEntry->SequenceNumber = 0;
                errorLogEntry->MajorFunctionCode = 0;
                errorLogEntry->IoControlCode = 0;
                errorLogEntry->RetryCount = 0;
                errorLogEntry->UniqueErrorValue = uniqueErrorValue;
                errorLogEntry->FinalStatus = status;
                for (i = 0; i < dumpCount; i++) {

                    errorLogEntry->DumpData[i] = dumpData[i];

                }
                IoWriteErrorLogEntry(errorLogEntry);

            }

        }

    }

    //
    // Initialize current mouse input packet state
    //
    MouseExtension->PreviousSignAndOverflow = 0;
    MouseExtension->InputState = MouseExpectingACK;

    Print(DBG_SS_TRACE, ("I8xMouseEnableTransmission (0x%x)\n", status));

    return status;
}

NTSTATUS
I8xTransmitByteSequence(
    PUCHAR Bytes,
    ULONG* UniqueErrorValue,
    ULONG* ErrorCode,
    ULONG* DumpData,
    ULONG* DumpCount
    )
{
    NTSTATUS status;
    ULONG byteCount;

    PAGED_CODE();

    status = STATUS_SUCCESS;
    byteCount = 0;

    //
    // Begin sending commands to the mouse
    //
    while (Bytes[byteCount] != 0) {
        status = I8xPutBytePolled(
            (CCHAR) DataPort,
            WAIT_FOR_ACKNOWLEDGE,
            (CCHAR) MouseDeviceType,
            Bytes[byteCount]
            );

        if (!NT_SUCCESS(status)) {
            Print(DBG_SS_ERROR,
                  ("%s, failed write set sample rate #%d, status 0x%x\n",
                  pFncFindWheelMouse,
                  byteCount,
                  status
                  ));

            //
            // Set up error log info
            //
            *ErrorCode = I8042_SET_SAMPLE_RATE_FAILED;
            *DumpCount = 4;
            DumpData[0] = KBDMOU_COULD_NOT_SEND_PARAM;
            DumpData[1] = DataPort;
            DumpData[2] = I8042_WRITE_TO_AUXILIARY_DEVICE;
            DumpData[3] = Bytes[byteCount];
            break;
        }

        //
        // Next command
        //
        byteCount++;
        (*UniqueErrorValue) += 5;
        KeStallExecutionProcessor(50);
    } // while

    return status;
}

NTSTATUS
I8xGetBytePolledIterated(
    IN CCHAR DeviceType,
    OUT PUCHAR Byte,
    ULONG Attempts
    )
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    ULONG i;

    PAGED_CODE();

    //
    // Try to get a single character
    //
    for(i = 0; i < Attempts; i++) {
        status = I8xGetBytePolled(
            (CCHAR) ControllerDeviceType,
            Byte
            );

        if (NT_SUCCESS(status)) {
            //
            // Read was successfull. We got a byte.
            //
            break;
        }

        //
        // If the read timed out, stall and retry.
        // If some other error occured handle it outside the loop
        //
        if (status == STATUS_IO_TIMEOUT) {
            KeStallExecutionProcessor(50);
        }
        else {
            break;
        }
    }

    return status;
}

NTSTATUS
I8xFindWheelMouse(
    IN PPORT_MOUSE_EXTENSION MouseExtension
    )

/*++

Routine Description:

    There are two methods of finding a wheel mouse on a system. The first
    method, is to send down the request to get the PNP id of the device
    and compare it with the known id for a wheel mouse. The method is
    useful since some machines hang on the second detection mechanism,
    even if no mouse is present on the system.

    The second method, which also enables a wheel mouse is set the sampling
    rate to 200hz, then 100hz, then 80hz, and then read the device id. An
    ID of 3 indicates a zoom mouse.

    If the registry entry "EnableWheelDetection" is 0 then this
    routine will just return STATUS_NO_SUCH_DEVICE. If the registry entry
    is 1 (the default), then the first and second detection mechanisms will
    be used. If the registry entry is 2, then only the second detection
    mechanism will be used.

Arguments:

    DeviceObject - Pointer to the device object

Return Value:

    Returns status

Remarks:

    As a side effect the sample rate is left at 80Hz and if a wheelmouse is
    attached it is in the wheel mode where packets are different.

--*/

{
#define DUMP_COUNT 4
    NTSTATUS                errorCode = STATUS_SUCCESS;
    NTSTATUS                status;
    PIO_ERROR_LOG_PACKET    errorLogEntry;
    UCHAR                   byte;
    UCHAR                   enableCommands[] = {
                                SET_MOUSE_SAMPLING_RATE, 200,
                                SET_MOUSE_SAMPLING_RATE, 100,
                                SET_MOUSE_SAMPLING_RATE, 80,
                                GET_DEVICE_ID, 0  // NULL terminate
                                };
    UCHAR                   enable5Commands[] = {
                                SET_MOUSE_SAMPLING_RATE, 200,
                                SET_MOUSE_SAMPLING_RATE, 200,
                                SET_MOUSE_SAMPLING_RATE, 80,
                                GET_DEVICE_ID, 0  // NULL terminate
                                };
    UCHAR                   pnpCommands[] = {
                                SET_MOUSE_SAMPLING_RATE, 20,
                                SET_MOUSE_SAMPLING_RATE, 40,
                                SET_MOUSE_SAMPLING_RATE, 60,
                                0  // NULL terminates
                                };
    ULONG                   dumpCount = 0;
    ULONG                   dumpData[DUMP_COUNT];
    ULONG                   i;
    ULONG                   idCount;
    ULONG                   uniqueErrorValue = I8042_ERROR_VALUE_BASE + 480;
    WCHAR                   mouseID[MOUSE_PNPID_LENGTH];
    PWCHAR                  currentChar;

    PAGED_CODE();

    //
    // Let the world know that we have entered this routine
    //
    Print(DBG_SS_TRACE,
          ("%s, %s\n",
          pFncFindWheelMouse,
          pEnter
          ));

    if (MouseExtension->EnableWheelDetection == 0) {

        Print(DBG_SS_INFO | DBG_SS_NOISE,
              ("%s: Detection disabled in registry\n",
              pFncFindWheelMouse
              ));
        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // Initialize some variables
    //
    for(i = 0; i < DUMP_COUNT; i++) {
        dumpData[i] = 0;
    }

    //
    // If the MouseInterruptObject exists, then we have gone through initialization
    // at least once and know about the mouse attached
    //
    if (MouseExtension->InterruptObject) {     
        if (WHEEL_PRESENT()) {
            //
            // Skip detection and go straight to turning on the wheel
            //
            goto InitializeWheel;
        }
        else {
            //
            // No wheel mouse present, no need to detect it a second time
            //
            return STATUS_NO_SUCH_DEVICE;
        }
    }

    //
    // What is the point of this here???
    //
    KeStallExecutionProcessor(50);

    //
    // First check to see if we will try the 'better' method of detection
    //
    if (MouseExtension->EnableWheelDetection == 1) {

        status = I8xTransmitByteSequence(
            pnpCommands,
            &uniqueErrorValue,
            &errorCode,
            dumpData,
            &dumpCount
            );

        if (!NT_SUCCESS(status)) {
            goto I8xFindWheelMouseExit;
        }

        //
        // Zero out the string that will ID the mouse
        //
        RtlZeroMemory(mouseID,
                      MOUSE_PNPID_LENGTH * sizeof(WCHAR)
                      );

        currentChar = mouseID;

        //
        // We should start to see the PNP string come back our way
        // (MOUSE_PNPID_LENGTH includes the NULL in its length)
        //
        for (idCount = 0; idCount < MOUSE_PNPID_LENGTH-1; idCount++) {
            status = I8xGetBytePolledIterated(
                (CCHAR) ControllerDeviceType,
                &byte,
                5
                );


            //
            // if the operation wasn't successful or the characters don't
            // match, than try to flush the buffers
            //
            if (byte < ScanCodeToUCharCount) {
                *currentChar = ScanCodeToUChar[byte];
                if (*currentChar) {
                    currentChar++;
                }
            }

            if (!NT_SUCCESS(status)) {  //  || byte != pnpID[idCount]) {
                //
                // Couldn't get a byte
                //
                do {
                    //
                    // Wait a little bit
                    //
                    KeStallExecutionProcessor( 50 );

                    //
                    // Get a byte if there is one
                    //
                    status = I8xGetBytePolled(
                        (CCHAR) ControllerDeviceType,
                        &byte
                        );
                } while (status != STATUS_IO_TIMEOUT);

                //
                // We are done here
                //
                return STATUS_NO_SUCH_DEVICE;
            } // if
        } // for

        Print(DBG_SS_INFO, ("found a pnp id of %ws\n", mouseID));
        if (!I8xVerifyMousePnPID(MouseExtension, mouseID)) {
            return STATUS_NO_SUCH_DEVICE;
        }
    }
    else if (MouseExtension->EnableWheelDetection != 2) {
        //
        // We got a bogus id. Let's just assume that they meant to disable
        // the little detection routine
        //
        Print(DBG_SS_INFO | DBG_SS_NOISE,
              ("%s: Detection disabled in registry\n",
              pFncFindWheelMouse
              ));

        //
        // Done
        //
        return STATUS_NO_SUCH_DEVICE;

    } // if

    //
    // Start the second detection routine, which will also enable the
    // device if present
    //
InitializeWheel:
    status = I8xTransmitByteSequence(
        enableCommands,
        &uniqueErrorValue,
        &errorCode,
        dumpData,
        &dumpCount
        );

    if (!NT_SUCCESS(status)) {
        goto I8xFindWheelMouseExit;
    }

    //
    // Get the mouse ID
    //

    status = I8xGetBytePolledIterated(
        (CCHAR) ControllerDeviceType,
        &byte,
        5
        );

    //
    // Check to see what we got
    //
    if ((!NT_SUCCESS(status)) ||
       ((byte != MOUSE_ID_BYTE) && (byte != WHEELMOUSE_ID_BYTE))) {
        Print(DBG_SS_ERROR,
              ("%s, failed ID, status 0x%x, byte 0x%x\n",
              pFncFindWheelMouse,
              status,
              byte
              ));

        //
        // Set up error log info
        //
        errorCode = I8042_MOU_RESET_RESPONSE_FAILED;
        dumpData[0] = KBDMOU_INCORRECT_RESPONSE;
        dumpData[1] = ControllerDeviceType;
        dumpData[2] = MOUSE_ID_BYTE;
        dumpData[3] = byte;
        dumpCount = 4;
        goto I8xFindWheelMouseExit;
    }
    else if (byte == WHEELMOUSE_ID_BYTE) {
        //
        // Update the HardwarePresent to show a Z mouse is operational,
        // and set the appropriate mouse type flags
        //
        SET_HW_FLAGS(WHEELMOUSE_HARDWARE_PRESENT);

        MouseExtension->MouseAttributes.MouseIdentifier =
            WHEELMOUSE_I8042_HARDWARE;

        status = I8xTransmitByteSequence(
            enable5Commands,
            &uniqueErrorValue,
            &errorCode,
            dumpData,
            &dumpCount
            );

        if (NT_SUCCESS(status)) {
            status = I8xGetBytePolledIterated(
                (CCHAR) ControllerDeviceType,
                &byte,
                5
                );

            if (NT_SUCCESS(status) && byte == FIVEBUTTON_ID_BYTE) {
                //
                // Update the HardwarePresent to show a Z mouse with 2 extra buttons is operational,
                // and set the appropriate mouse type flags
                //
                SET_HW_FLAGS(FIVE_BUTTON_HARDWARE_PRESENT | WHEELMOUSE_HARDWARE_PRESENT);

                MouseExtension->MouseAttributes.MouseIdentifier =
                    WHEELMOUSE_I8042_HARDWARE;
            }
        }
    }
    else {
        SET_HW_FLAGS(MOUSE_HARDWARE_PRESENT);

        Print(DBG_SS_INFO,
              ("%s, Mouse attached - running in mouse mode.\n",
              pFncFindWheelMouse
              ));
    }

I8xFindWheelMouseExit:

    if (!NT_SUCCESS(status)) {

        //
        // The mouse initialization failed. Log an error.
        //
        if(errorCode != STATUS_SUCCESS) {

            errorLogEntry = (PIO_ERROR_LOG_PACKET)
                IoAllocateErrorLogEntry(
                    MouseExtension->Self,
                    (UCHAR) (sizeof(IO_ERROR_LOG_PACKET) +
                            (dumpCount * sizeof(ULONG)))
                    );

            if(errorLogEntry != NULL) {

                errorLogEntry->ErrorCode = errorCode;
                errorLogEntry->DumpDataSize = (USHORT) dumpCount * sizeof(ULONG);
                errorLogEntry->SequenceNumber = 0;
                errorLogEntry->MajorFunctionCode = 0;
                errorLogEntry->IoControlCode = 0;
                errorLogEntry->RetryCount = 0;
                errorLogEntry->UniqueErrorValue = uniqueErrorValue;
                errorLogEntry->FinalStatus = status;
                for(i = 0; i < dumpCount; i++) {

                    errorLogEntry->DumpData[i] = dumpData[i];

                }
                IoWriteErrorLogEntry(errorLogEntry);

            }

        }

    }

    Print(DBG_SS_TRACE, ("FindWheel mouse (0x%x)\n", status));

    return status;
}

VOID
I8xFinishResetRequest(
    PPORT_MOUSE_EXTENSION MouseExtension,
    BOOLEAN Failed,
    BOOLEAN RaiseIrql,
    BOOLEAN CancelTimer
    )
{
    PIRP irp;
    KIRQL oldIrql;

    irp = (PIRP) InterlockedExchangePointer(&MouseExtension->ResetIrp,
                                            NULL
                                            );

    if (CancelTimer) {
        //
        // We must cancel our watchdog timer so that it doesn't try to reset the
        // mouse at a later time
        //
        KeCancelTimer(&MouseExtension->ResetMouse.Timer);
    }

    Print(DBG_IOCTL_INFO |  DBG_SS_INFO,
          ("Finished with mouse reset irp %p\n", irp));

    //
    // Raise to dispatch because KeInsertQueueDpc, IoFreeController, and
    // IoStartNextPacket all require to be at this irql. 
    //
    if (RaiseIrql) {
        KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);
    }

    //
    // Let people know that the reset failed
    //
    if (Failed && Globals.ReportResetErrors) {
        KeInsertQueueDpc(&MouseExtension->ErrorLogDpc,
                         (PIRP) NULL,
                         LongToPtr(I8042_MOU_RESET_RESPONSE_FAILED)
                         );
    }

    CLEAR_RECORD_STATE(MouseExtension);

    //
    // NOTE: To prevent the reset detection code from
    // restarting us all over again (which don't want
    // otherwise we would not be here, we need to fool
    // the detection into thinking that the last character
    // wasn't MOUSE_COMPLETE
    //
    MouseExtension->LastByteReceived = 0;

    //
    // Oops. Oh well, the mouse hasn't been able to reset
    // in all these tries, so lets consider it dead.
    //
    // However, just in case the user yanks it out and
    // plugs in a new one, we should reset our count
    // back down to zero so that we will actually try to
    // activate the thing when he plugs it back in there....but we don't do
    // this here.  If we see the reset sequence in the ISR, we will reset
    // the counts there.
    //
    //MouseExtension->ResendCount = 0;

    // I8X_MOUSE_INIT_COUNTERS(MouseExtension);

    //
    // Make sure the next packet is started, regardless if the reset IRP
    // was present or not
    //
    IoFreeController(Globals.ControllerData->ControllerObject);
    IoStartNextPacket(MouseExtension->Self, FALSE);

    if (RaiseIrql) {
        KeLowerIrql(oldIrql);
    }

    if (irp != NULL) {
        IoFreeIrp(irp);
        IoReleaseRemoveLock(&MouseExtension->RemoveLock, irp);
    }
}


VOID
I8xResetMouseFailed(
    PPORT_MOUSE_EXTENSION MouseExtension
    )
/*++

Routine Description:

    The resetting of the mouse failed after repeated tries to get it working.
    Free the irp and start the next packet in our start io reoutine.
    
Arguments:

    MouseExtension - Mouse extension
    
Return Value:

    None. 
--*/
{
    PIRP irp;
    KIRQL oldIrql;

    Print(DBG_SS_ERROR | DBG_SS_INFO, ("mouse reset failed\n"));

    //
    // Mark the failed reset in the device extension
    //
    MouseExtension->ResetMouse.IsrResetState = MouseResetFailed;

    I8xFinishResetRequest(MouseExtension, TRUE, TRUE, TRUE);
}

NTSTATUS
I8xResetMouse(
    PPORT_MOUSE_EXTENSION MouseExtension
    )
/*++

Routine Description:

    Sends the reset command to the mouse (through the start i/o routine if it
    doesn't exist yet) if we haven't reached our reset limit.  Otherwise, gives
    up and calls I8xResetMouseFailed.
    
Arguments:

    MouseExtension - Mouse extension
    
Return Value:

    STATUS_SUCCESS if successful
    
--*/
{
    PDEVICE_OBJECT self;
    PIO_STACK_LOCATION stack;
    PIRP pResetIrp, pIrp;
    NTSTATUS status;

    Print(DBG_SS_NOISE, ("reset count = %d\n", (LONG) MouseExtension->ResetCount));

    self = MouseExtension->Self;
    status = STATUS_SUCCESS;

    MouseExtension->ResetCount++;
    MouseExtension->FailedCompleteResetCount++;

    if (MouseExtension->ResetCount >= MOUSE_RESETS_MAX ||
        MouseExtension->FailedCompleteResetCount >= MOUSE_RESETS_MAX) {
        Print(DBG_SS_ERROR, ("Resetting mouse failed!\n"));
        I8xResetMouseFailed(MouseExtension);
        return STATUS_DEVICE_NOT_CONNECTED;
    }

#if 0
    if (MouseExtension->LastByteReceived == 0xFC &&
        MouseExtension->InputState == MouseResetting) {
        I8xDrainOutputBuffer(
            Globals.ControllerData->DeviceRegisters[DataPort],
            Globals.ControllerData->DeviceRegisters[CommandPort]
            );
    }
#endif

    //
    // Insert a "fake" request into the StartIO queue for the reset.  This way,
    // the reset of the mouse can be serialized with all of the other kb IOCTLS
    // that come down during start or return from a low power state
    //
    pResetIrp = IoAllocateIrp(self->StackSize, FALSE);
    if (pResetIrp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    pIrp = (PIRP) InterlockedCompareExchangePointer(&MouseExtension->ResetIrp,
                                                    pResetIrp,
                                                    NULL);

    //
    // Check to see if we had a pending reset request.  If there was, 
    // pIrp != NULL and we should just write the reset to the device now.
    //
    if (pIrp == NULL) {
        stack = IoGetNextIrpStackLocation(pResetIrp);
        stack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        stack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_MOUSE_RESET; 
        IoSetNextIrpStackLocation(pResetIrp);

        status = IoAcquireRemoveLock(&MouseExtension->RemoveLock, pResetIrp);

        if (NT_SUCCESS(status)) {
            Print(DBG_SS_INFO, ("IoStarting reset irp %p\n",  pResetIrp));
            IoStartPacket(self, pResetIrp, (PULONG) NULL, NULL);
        }
        else {
            pIrp = (PIRP) InterlockedExchangePointer(&MouseExtension->ResetIrp,
                                                     NULL);

            Print(DBG_SS_INFO, ("Failed acquire on reset irp %p\n",  pIrp));

            if (pIrp != NULL) {
                ASSERT(pIrp == pResetIrp);
                IoFreeIrp(pIrp);
                pIrp = NULL;
            }
        }
    }
    else {
        //
        // Free the irp we just allocated
        //
        IoFreeIrp(pResetIrp);
        pResetIrp = NULL;

        //
        // The Reset Irp exists, just send another reset
        //
        I8xSendResetCommand(MouseExtension);
    }

    return status;
}

VOID
I8xSendResetCommand (
    PPORT_MOUSE_EXTENSION MouseExtension
    )
/*++

Routine Description:

    Writes the actual reset to the mouse and kicks off the watch dog timer.
    
Arguments:

    MouseExtension  - Mouse extension
    
Return Value:

    None. 
--*/
{
    LARGE_INTEGER li = RtlConvertLongToLargeInteger(-MOUSE_RESET_TIMEOUT);

    MouseExtension->ResetMouse.IsrResetState = IsrResetNormal;

    //
    // Delay for 1 second
    //
    KeSetTimer(&MouseExtension->ResetMouse.Timer,
               li,
               &MouseExtension->ResetMouse.Dpc
               );

    MouseExtension->PreviousSignAndOverflow = 0;
    MouseExtension->InputState = MouseResetting;
    MouseExtension->InputResetSubState = ExpectingReset;
    MouseExtension->LastByteReceived = 0;

    //
    // The watch dog timer bases its time computations on this value, set it to
    // now so that all the times computed are relative to the last time we sent
    // a reset and not x seconds ago when we last received an interrupt from the
    // mouse
    //
    KeQueryTickCount(&MouseExtension->PreviousTick);

    I8xPutBytePolled((CCHAR) DataPort,
                     NO_WAIT_FOR_ACKNOWLEDGE,
                     (CCHAR) MouseDeviceType,
                     (UCHAR) MOUSE_RESET
                     );
}

VOID
I8xQueueCurrentMouseInput(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine queues the current input data to be processed by a
    DPC outside the ISR

Arguments:

    DeviceObject - Pointer to the device object

Return Value:

    None

--*/
{
    PPORT_MOUSE_EXTENSION   deviceExtension;
    UCHAR                   buttonsDelta;
    UCHAR                   previousButtons;

    deviceExtension = (PPORT_MOUSE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // If the mouse is enabled, add the data to the InputData queue
    // and queue the ISR DPC.  One might wonder why we bother to
    // do all this processing of the mouse packet, only to toss it
    // away (i.e., not queue it) at this point.  The answer is that
    // this mouse provides no data to allow the driver to determine
    // when the first byte of a packet is received -- if the driver
    // doesn't process all interrupts from the start, there is no
    // way to keep MouseExtension.InputState in synch with hardware
    // reality.
    //
    if (deviceExtension->EnableCount) {

        if (!I8xWriteDataToMouseQueue(
                 deviceExtension,
                 &deviceExtension->CurrentInput
                 )) {

            //
            // InputData queue overflowed.
            //
            // Queue a DPC to log an overrun error.
            //
            IsrPrint(DBG_MOUISR_ERROR,
                     ("I8042MouseInterruptService: queue overflow\n"
                     ));

            if (deviceExtension->OkayToLogOverflow) {

                KeInsertQueueDpc(
                    &deviceExtension->ErrorLogDpc,
                    (PIRP) NULL,
                    LongToPtr(I8042_MOU_BUFFER_OVERFLOW)
                    );
                deviceExtension->OkayToLogOverflow =
                    FALSE;

            }

        } else if (deviceExtension->DpcInterlockMouse >= 0) {

           //
           // The ISR DPC is already executing.  Tell the ISR DPC it has
           // more work to do by incrementing DpcInterlockMouse.
           //
           deviceExtension->DpcInterlockMouse += 1;

        } else {

           //
           // Queue the ISR DPC.
           //
           KeInsertQueueDpc(
               &deviceExtension->MouseIsrDpc,
               (PIRP) NULL, // DeviceObject->CurrentIrp,
               NULL
               );
       }

    }

    return;
}

VOID
MouseCopyWheelIDs(
    OUT PUNICODE_STRING Destination,
    IN  PUNICODE_STRING Source
    )
/*++

Routine Description:

    Copies the multisz specified in Source into Destinatio along with the default
    IDs already known.  Destination is in non paged pool while Source is paged.
    
Argument:

    Destination - Will receive new copied string
    
    Source - String read from the registry
    
Return Value:

    None.  

--*/
{
    PWSTR       str = NULL;
    ULONG       length;

    PAGED_CODE();

    ASSERT(Destination->Buffer == NULL);

    RtlZeroMemory(Destination, sizeof(*Destination));

    //
    // Check to see the Source string is not just an empty multi SZ
    //
    if (Source->MaximumLength > (sizeof(L'\0') * 2)) {
        Destination->Buffer = (WCHAR*)
            ExAllocatePool(NonPagedPool, Source->MaximumLength * sizeof(WCHAR));

        if (Destination->Buffer != NULL) {
            RtlCopyMemory(Destination->Buffer,
                          Source->Buffer, 
                          Source->MaximumLength * sizeof(WCHAR));

            Destination->Length = Destination->MaximumLength =
                Source->MaximumLength;

            //
            // Make sure each string is in upper case
            //
            str = Destination->Buffer;
            while (*str != L'\0') {
                Print(DBG_SS_NOISE, ("wheel id:  %ws\n", str));
                _wcsupr(str);
                str += wcslen(str) + 1;
            }
        }
    }
}

VOID
I8xMouseServiceParameters(
    IN PUNICODE_STRING          RegistryPath,
    IN PPORT_MOUSE_EXTENSION    MouseExtension
    )
/*++

Routine Description:

    This routine retrieves this driver's service parameters information
    from the registry.  Overrides these values if they are present in the
    devnode.

Arguments:

    RegistryPath - Pointer to the null-terminated Unicode name of the
        registry path for this driver.

    MouseExtension - Mouse extension
    
Return Value:

    None.  

--*/
{
    NTSTATUS                            status = STATUS_SUCCESS;
    PRTL_QUERY_REGISTRY_TABLE           parameters = NULL;
    HANDLE                              keyHandle;
    UNICODE_STRING                      parametersPath;
    PWSTR                               path = NULL;
    ULONG                               defaultDataQueueSize = DATA_QUEUE_SIZE,
                                        defaultSynchPacket100ns = MOUSE_SYNCH_PACKET_100NS,
                                        defaultEnableWheelDetection = 1,
                                        defaultMouseResolution = MOUSE_RESOLUTION,
                                        defaultNumberOfButtons = 0,
                                        defaultSampleRate = MOUSE_SAMPLE_RATE,
                                        defaultWheelDetectionTimeout = WHEEL_DETECTION_TIMEOUT,
                                        defaultInitializePolled = I8X_INIT_POLLED_DEFAULT,
                                        enableWheelDetection = 1,
                                        mouseResolution = MOUSE_RESOLUTION,
                                        numberOfButtons = MOUSE_NUMBER_OF_BUTTONS,
                                        sampleRate = MOUSE_SAMPLE_RATE,
                                        initializePolled = I8X_INIT_POLLED_DEFAULT,
                                        i = 0;
    ULONG                               defaultStallTime = 1000;
    LARGE_INTEGER                       largeDetectionTimeout;
    USHORT                              queries = 10;

    WCHAR           szDefaultIDs[] = { L"\0" };
    UNICODE_STRING  IDs;

#if MOUSE_RECORD_ISR
    ULONG                               defaultHistoryLength = 100,
                                        defaultRecordHistoryFlags = 0x0;

    queries += 2;
#endif

    PAGED_CODE();

    parametersPath.Buffer = NULL;

    //
    // Registry path is already null-terminated, so just use it.
    //
    path = RegistryPath->Buffer;

    if (NT_SUCCESS(status)) {

        //
        // Allocate the Rtl query table.
        //
        parameters = ExAllocatePool(
            PagedPool,
            sizeof(RTL_QUERY_REGISTRY_TABLE) * (queries + 1)
            );

        if (!parameters) {

            Print(DBG_SS_ERROR,
                 ("%s: couldn't allocate table for Rtl query to %ws for %ws\n",
                 pFncServiceParameters,
                 pwParameters,
                 path
                 ));
            status = STATUS_UNSUCCESSFUL;

        } else {

            RtlZeroMemory(
                parameters,
                sizeof(RTL_QUERY_REGISTRY_TABLE) * (queries + 1)
                );

            //
            // Form a path to this driver's Parameters subkey.
            //
            RtlInitUnicodeString( &parametersPath, NULL );
            parametersPath.MaximumLength = RegistryPath->Length +
                (wcslen(pwParameters) * sizeof(WCHAR) ) + sizeof(UNICODE_NULL);

            parametersPath.Buffer = ExAllocatePool(
                PagedPool,
                parametersPath.MaximumLength
                );

            if (!parametersPath.Buffer) {

                Print(DBG_SS_ERROR,
                     ("%s: Couldn't allocate string for path to %ws for %ws\n",
                     pFncServiceParameters,
                     pwParameters,
                     path
                     ));
                status = STATUS_UNSUCCESSFUL;

            }
        }
    }

    if (NT_SUCCESS(status)) {

        //
        // Form the parameters path.
        //

        RtlZeroMemory(
            parametersPath.Buffer,
            parametersPath.MaximumLength
            );
        RtlAppendUnicodeToString(
            &parametersPath,
            path
            );
        RtlAppendUnicodeToString(                             
            &parametersPath,
            pwParameters
            );

        //
        // Gather all of the "user specified" information from
        // the registry.
        //
        parameters[i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = pwMouseDataQueueSize;
        parameters[i].EntryContext =
            &MouseExtension->MouseAttributes.InputDataQueueLength;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &defaultDataQueueSize;
        parameters[i].DefaultLength = sizeof(ULONG);

        parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = pwNumberOfButtons;
        parameters[i].EntryContext = &numberOfButtons;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &defaultNumberOfButtons;
        parameters[i].DefaultLength = sizeof(ULONG);

        parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = pwSampleRate;
        parameters[i].EntryContext = &sampleRate;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &defaultSampleRate;    
        parameters[i].DefaultLength = sizeof(ULONG);

        parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = pwMouseResolution;
        parameters[i].EntryContext = &mouseResolution;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &defaultMouseResolution;
        parameters[i].DefaultLength = sizeof(ULONG);

        parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = pwMouseSynchIn100ns;
        parameters[i].EntryContext = &MouseExtension->SynchTickCount;
        parameters[i].DefaultType = REG_DWORD;

        parameters[i].DefaultData = &defaultSynchPacket100ns;
        parameters[i].DefaultLength = sizeof(ULONG);

        parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = pwEnableWheelDetection;
        parameters[i].EntryContext = &enableWheelDetection;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &defaultEnableWheelDetection;
        parameters[i].DefaultLength = sizeof(ULONG);

        parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = L"MouseInitializePolled";
        parameters[i].EntryContext = &initializePolled;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &defaultInitializePolled;
        parameters[i].DefaultLength = sizeof(ULONG);

        parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = L"MouseResendStallTime";
        parameters[i].EntryContext = &MouseExtension->MouseResetStallTime;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &defaultStallTime;
        parameters[i].DefaultLength = sizeof(ULONG);

#if MOUSE_RECORD_ISR
        parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = L"RecordMouseIsrFlags";
        parameters[i].EntryContext = &MouseExtension->RecordHistoryFlags;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &defaultRecordHistoryFlags;
        parameters[i].DefaultLength = sizeof(ULONG);

        parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = L"RecordMouseIsrLength";
        parameters[i].EntryContext = &MouseExtension->RecordHistoryCount;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &defaultHistoryLength;
        parameters[i].DefaultLength = sizeof(ULONG);
#endif

        status = RtlQueryRegistryValues(
            RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
            parametersPath.Buffer,
            parameters,
            NULL,
            NULL
            );

        if (!NT_SUCCESS(status)) {
            Print(DBG_SS_INFO,
                 ("mou RtlQueryRegistryValues failed (0x%x)\n",
                 status
                 ));
        }
    }

    if (!NT_SUCCESS(status)) {

        //
        // Go ahead and assign driver defaults.
        //
        MouseExtension->MouseAttributes.InputDataQueueLength =
            defaultDataQueueSize;
        MouseExtension->EnableWheelDetection = (UCHAR)
            defaultEnableWheelDetection;
        MouseExtension->SynchTickCount = defaultSynchPacket100ns;
    }

    Print(DBG_SS_NOISE,
          ("results from services key:\n"
           "\tmouse queue length = %d\n"
           "\tnumber of buttons  = %d\n"
           "\tsample rate        = %d\n"  
           "\tresolution         = %d\n"
           "\tsynch tick count   = %d\n"
           "\twheel detection    = %d\n"
           "\tdetection timeout  = %d\n"
           "\tintiailize polled  = %d\n"
           "\treset stall time   = %d\n",
          MouseExtension->MouseAttributes.InputDataQueueLength,
          numberOfButtons,
          sampleRate,
          mouseResolution,
          MouseExtension->SynchTickCount,
          enableWheelDetection,
          MouseExtension->WheelDetectionTimeout,
          initializePolled,
          MouseExtension->MouseResetStallTime
          ));

    status = IoOpenDeviceRegistryKey(MouseExtension->PDO,
                                     PLUGPLAY_REGKEY_DEVICE, 
                                     STANDARD_RIGHTS_READ,
                                     &keyHandle
                                     );

    if (NT_SUCCESS(status)) {
        ULONG           prevInputDataQueueLength,
                        prevNumberOfButtons,
                        prevSampleRate,
                        prevMouseResolution,
                        prevSynchPacket100ns,
                        prevEnableWheelDetection,
                        prevWheelDetectionTimeout,
                        prevInitializePolled;

        RtlInitUnicodeString(&IDs,
                             NULL);

        //
        // If the value is not present in devnode, then the default is the value
        // read in from the Services\i8042prt\Parameters key
        //
        prevInputDataQueueLength =
            MouseExtension->MouseAttributes.InputDataQueueLength;
        prevNumberOfButtons = numberOfButtons;
        prevSampleRate = sampleRate;
        prevMouseResolution = mouseResolution;
        prevSynchPacket100ns = MouseExtension->SynchTickCount;
        prevEnableWheelDetection = enableWheelDetection;
        prevWheelDetectionTimeout = MouseExtension->WheelDetectionTimeout;
        prevInitializePolled = initializePolled;

        i = 0; 

        //
        // Gather all of the "user specified" information from
        // the registry (this time from the devnode)
        //
        parameters[i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = pwMouseDataQueueSize;
        parameters[i].EntryContext =
            &MouseExtension->MouseAttributes.InputDataQueueLength;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &prevInputDataQueueLength;
        parameters[i].DefaultLength = sizeof(ULONG);

        parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = pwNumberOfButtons;
        parameters[i].EntryContext = &numberOfButtons;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &prevNumberOfButtons;
        parameters[i].DefaultLength = sizeof(ULONG);

        parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = pwSampleRate;
        parameters[i].EntryContext = &sampleRate;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &prevSampleRate;
        parameters[i].DefaultLength = sizeof(ULONG);

        parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = pwMouseResolution;
        parameters[i].EntryContext = &mouseResolution;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &prevMouseResolution;
        parameters[i].DefaultLength = sizeof(ULONG);

        parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = pwMouseSynchIn100ns;
        parameters[i].EntryContext = &MouseExtension->SynchTickCount;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &prevSynchPacket100ns;
        parameters[i].DefaultLength = sizeof(ULONG);

        parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = pwEnableWheelDetection;
        parameters[i].EntryContext = &enableWheelDetection;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &prevEnableWheelDetection;
        parameters[i].DefaultLength = sizeof(ULONG);

        parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = L"MouseInitializePolled";
        parameters[i].EntryContext = &initializePolled;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &prevInitializePolled;
        parameters[i].DefaultLength = sizeof(ULONG);

        parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_NOEXPAND;
        parameters[i].Name = L"WheelDetectIDs";
        parameters[i].EntryContext = &IDs;
        parameters[i].DefaultType = REG_MULTI_SZ;
        parameters[i].DefaultData = szDefaultIDs;
        parameters[i].DefaultLength = sizeof(szDefaultIDs);

        parameters[++i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = L"WheelDetectionTimeout";
        parameters[i].EntryContext = &MouseExtension->WheelDetectionTimeout;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &defaultWheelDetectionTimeout;
        parameters[i].DefaultLength = sizeof(ULONG);

        status = RtlQueryRegistryValues(
            RTL_REGISTRY_HANDLE,
            (PWSTR) keyHandle,
            parameters,
            NULL,
            NULL
            );

        if (NT_SUCCESS(status)) {

            Print(DBG_SS_NOISE,
                  ("results from devnode key:\n"
                   "\tmouse queue length = %d\n"
                   "\tnumber of buttons  = %d\n"
                   "\tsample rate        = %d\n"  
                   "\tresolution         = %d\n"
                   "\tsynch tick count   = %d\n"
                   "\twheel detection    = %d\n"
                   "\tinitialize polled  = %d\n"
                   "\tdetection timeout  = %d\n",
                  MouseExtension->MouseAttributes.InputDataQueueLength,
                  numberOfButtons,
                  sampleRate,
                  mouseResolution,
                  MouseExtension->SynchTickCount,
                  enableWheelDetection,
                  initializePolled,
                  MouseExtension->WheelDetectionTimeout
                  ));
        }
        else {
            Print(DBG_SS_INFO | DBG_SS_ERROR,
                 ("mou RtlQueryRegistryValues (via handle) failed with (0x%x)\n",
                 status
                 ));
        }

        ZwClose(keyHandle);
    }
    else {
        Print(DBG_SS_INFO | DBG_SS_ERROR,
             ("mou, opening devnode handle failed (0x%x)\n",
             status
             ));
    }

    //
    // Needs to be in NonPagedPool so it can be access during the ISR
    //
    MouseCopyWheelIDs(&MouseExtension->WheelDetectionIDs,
                      &IDs);
    RtlFreeUnicodeString(&IDs);

    Print(DBG_SS_NOISE, ("I8xMouseServiceParameters results..\n"));

    if (MouseExtension->MouseAttributes.InputDataQueueLength == 0) {

        Print(DBG_SS_INFO | DBG_SS_ERROR,
             ("\toverriding %ws = 0x%x\n",
             pwMouseDataQueueSize,
             MouseExtension->MouseAttributes.InputDataQueueLength
             ));

        MouseExtension->MouseAttributes.InputDataQueueLength =
            defaultDataQueueSize;
    }
    MouseExtension->MouseAttributes.InputDataQueueLength *=
        sizeof(MOUSE_INPUT_DATA);

    MouseExtension->InitializePolled = (UCHAR) initializePolled;

    switch (enableWheelDetection) {
        case 2:
        case 1:
            MouseExtension->EnableWheelDetection = (UCHAR) enableWheelDetection;
            break;
        default:
            MouseExtension->EnableWheelDetection = 0;
    }
    Print(DBG_SS_NOISE,
         (pDumpHex,
         pwEnableWheelDetection,
         MouseExtension->EnableWheelDetection
         ));


    Print(DBG_SS_NOISE,
          (pDumpHex,
          pwMouseDataQueueSize,
          MouseExtension->MouseAttributes.InputDataQueueLength
          ));

    if (numberOfButtons == 0) {
        MouseExtension->NumberOfButtonsOverride = 0;
        MouseExtension->MouseAttributes.NumberOfButtons = MOUSE_NUMBER_OF_BUTTONS;
    }
    else {
        MouseExtension->NumberOfButtonsOverride = (UCHAR) numberOfButtons;
        MouseExtension->MouseAttributes.NumberOfButtons = (USHORT) numberOfButtons;
    }

    Print(DBG_SS_NOISE,
          (pDumpDecimal,
          pwNumberOfButtons,
          MouseExtension->MouseAttributes.NumberOfButtons
          ));

    MouseExtension->MouseAttributes.SampleRate = (USHORT) sampleRate;
    Print(DBG_SS_NOISE,
          (pDumpDecimal,
          pwSampleRate,
          MouseExtension->MouseAttributes.SampleRate
          ));

    MouseExtension->Resolution = (UCHAR) mouseResolution;
    Print(DBG_SS_NOISE,
         (pDumpDecimal,
         pwMouseResolution,
         mouseResolution
         ));

    Print(DBG_SS_NOISE,
         (pDumpDecimal,
         L"MouseResetStallTime",
         MouseExtension->MouseResetStallTime
         ));

    if (MouseExtension->WheelDetectionTimeout > 4000) {
        MouseExtension->WheelDetectionTimeout = WHEEL_DETECTION_TIMEOUT;
    }
    //
    // Convert ms to 100 ns units 
    //   1000 => ms to us
    //   10   => us to 100 ns
    //
    largeDetectionTimeout.QuadPart = MouseExtension->WheelDetectionTimeout *
                                     1000 * 10;
    largeDetectionTimeout.QuadPart /= KeQueryTimeIncrement();
    MouseExtension->WheelDetectionTimeout = largeDetectionTimeout.LowPart;
                            
    Print(DBG_SS_NOISE,
         (pDumpDecimal,
         L"WheelDetectionTimeout",
         MouseExtension->WheelDetectionTimeout
         ));


    if (MouseExtension->SynchTickCount == 0) {

        Print(DBG_SS_ERROR | DBG_SS_INFO,
             ("\toverriding %ws\n",
             pwMouseSynchIn100ns
             ));

        MouseExtension->SynchTickCount = defaultSynchPacket100ns;

    }

    //
    // Convert SynchTickCount to be the number of interval timer
    // interrupts that occur during the time specified by MouseSynchIn100ns.
    // Note that KeQueryTimeIncrement returns the number of 100ns units that
    // are added to the system time each time the interval clock interrupts.
    //
    MouseExtension->SynchTickCount /= KeQueryTimeIncrement();

    Print(DBG_SS_NOISE,
         (pDumpHex,
         pwMouseSynchIn100ns,
         MouseExtension->SynchTickCount
         ));

    //
    // Free the allocated memory before returning.
    //
    if (parametersPath.Buffer)
        ExFreePool(parametersPath.Buffer);

    if (parameters)
        ExFreePool(parameters);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\pnpi8042\i8042str.h ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    i8042str.h

Abstract:

    These are the string constants used in the i8042prt drivers.
    Using pointers to these string allows for better memory
    utilization and more readable code

Revision History:

    08/26/96 - Initial Revision

--*/

#ifndef _I8042STR_H_
#define _I8042STR_H_

//
// The name of the Driver. Used in debug print statements
//
#define I8042_DRIVER_NAME_A                         "8042: "
#define I8042_DRIVER_NAME_W                         L"8042: "

//
// The Name of the various functions which send debug print statements
//
#define I8042_FNC_DRIVER_ENTRY_A                    "DriverEntry"
#define I8042_FNC_DRIVER_ENTRY_W                    L"DriverEntry"
#define I8042_FNC_FIND_WHEEL_MOUSE_A                "I8xFindWheelMouse"
#define I8042_FNC_FIND_WHEEL_MOUSE_W                L"I8xFindWheelMouse"
#define I8042_FNC_INITIALIZE_MOUSE_A                "I8xInitializeMouse"
#define I8042_FNC_INITIALIZE_MOUSE_W                L"I8xInitializeMouse"
#define I8042_FNC_KEYBOARD_CONFIGURATION_A          "I8xKeyboardConfiguration"
#define I8042_FNC_KEYBOARD_CONFIGURATION_W          L"I8xKeyboardConfiguration"
#define I8042_FNC_MOUSE_ENABLE_A                    "I8xMouseEnableTransmission"
#define I8042_FNC_MOUSE_ENABLE_W                    L"I8xMouseEnableTransmission"
#define I8042_FNC_MOUSE_INTERRUPT_A                 "I8042MouseInterruptService"
#define I8042_FNC_MOUSE_INTERRUPT_W                 L"I8042MouseInterruptService"
#define I8042_FNC_MOUSE_PERIPHERAL_A                "I8xMousePeripheralCallout"
#define I8042_FNC_MOUSE_PERIPHERAL_W                L"I8xMousePeripheralCallout"
#define I8042_FNC_SERVICE_PARAMETERS_A              "I8xServiceParameters"
#define I8042_FNC_SERVICE_PARAMETERS_W              L"I8xServiceParameters"
#define I8042_ISR_KB_A                              "i8042 isr (kb): "
#define I8042_ISR_MOU_A                             "i8042 isr (mou): "
#define I8042_BUS_A                                 "Bus"
#define I8042_BUS_W                                 L"Bus"
#define I8042_CONTROLLER_A                          "Controller"
#define I8042_CONTROLLER_W                          L"Controller"
#define I8042_ENTER_A                               "enter"
#define I8042_ENTER_W                               L"enter"
#define I8042_EXIT_A                                "exit"
#define I8042_EXIT_W                                L"exit"
#define I8042_INFO_A                                "Info"
#define I8042_INFO_W                                L"Info"
#define I8042_NUMBER_A                              "Number"
#define I8042_NUMBER_W                              L"Number"
#define I8042_PERIPHERAL_A                          "Peripheral"
#define I8042_PERIPHERAL_W                          L"Peripheral"
#define I8042_TYPE_A                                "Type"
#define I8042_TYPE_W                                L"Type"

//
// Some strings used frequently by the driver
//
#define I8042_DEBUGFLAGS_A                          "DebugFlags"
#define I8042_DEBUGFLAGS_W                          L"DebugFlags"
#define I8042_ISRDEBUGFLAGS_A                       "IsrDebugFlags"
#define I8042_ISRDEBUGFLAGS_W                       L"IsrDebugFlags"
#define I8042_DEVICE_A                              "\\Device\\"
#define I8042_DEVICE_W                              L"\\Device\\"
#define I8042_PARAMETERS_A                          "\\Parameters"
#define I8042_PARAMETERS_W                          L"\\Parameters"
#define I8042_FORWARD_SLASH_A                       "/"
#define I8042_FORWARD_SLASH_W                       L"/"
#define I8042_RESEND_ITERATIONS_A                   "ResendIterations"
#define I8042_RESEND_ITERATIONS_W                   L"ResendIterations"
#define I8042_POLLING_ITERATIONS_A                  "PollingIterations"
#define I8042_POLLING_ITERATIONS_W                  L"PollingIterations"
#define I8042_POLLING_ITERATIONS_MAXIMUM_A          "PollingTerationsMaximum"
#define I8042_POLLING_ITERATIONS_MAXIMUM_W          L"PollingTerationsMaximum"
#define I8042_KEYBOARD_DATA_QUEUE_SIZE_A            "KeyboardDataQueueSize"
#define I8042_KEYBOARD_DATA_QUEUE_SIZE_W            L"KeyboardDataQueueSize"
#define I8042_MOUSE_DATA_QUEUE_SIZE_A               "MouseDataQueueSize"
#define I8042_MOUSE_DATA_QUEUE_SIZE_W               L"MouseDataQueueSize"
#define I8042_NUMBER_OF_BUTTONS_A                   "NumberOfButtons"
#define I8042_NUMBER_OF_BUTTONS_W                   L"NumberOfButtons"
#define I8042_SAMPLE_RATE_A                         "SampleRate"
#define I8042_SAMPLE_RATE_W                         L"SampleRate"
#define I8042_MOUSE_RESOLUTION_A                    "MouseResolution"
#define I8042_MOUSE_RESOLUTION_W                    L"MouseResolution"
#define I8042_OVERRIDE_KEYBOARD_TYPE_A              "OverrideKeyboardType"
#define I8042_OVERRIDE_KEYBOARD_TYPE_W              L"OverrideKeyboardType"
#define I8042_OVERRIDE_KEYBOARD_SUBTYPE_A           "OverrideKeyboardSubType"
#define I8042_OVERRIDE_KEYBOARD_SUBTYPE_W           L"OverrideKeyboardSubType"
#define I8042_KEYBOARD_DEVICE_BASE_NAME_A           "KeyboardDeviceBaseName"
#define I8042_KEYBOARD_DEVICE_BASE_NAME_W           L"KeyboardDeviceBaseName"
#define I8042_POINTER_DEVICE_BASE_NAME_A            "PointerDeviceBaseName"
#define I8042_POINTER_DEVICE_BASE_NAME_W            L"PointerDeviceBaseName"
#define I8042_MOUSE_SYNCH_IN_100NS_A                "MouseSynchIn100ns"
#define I8042_MOUSE_SYNCH_IN_100NS_W                L"MouseSynchIn100ns"
#define I8042_POLL_STATUS_ITERATIONS_A              "PollStatusIterations"
#define I8042_POLL_STATUS_ITERATIONS_W              L"PollStatusIterations"
#define I8042_ENABLE_WHEEL_DETECTION_A              "EnableWheelDetection"
#define I8042_ENABLE_WHEEL_DETECTION_W              L"EnableWheelDetection"
#define I8042_POWER_CAPABILITIES_A                  "PowerCapabilities"
#define I8042_POWER_CAPABILITIES_W                  L"PowerCapabilities"
#define I8042_DUMP_HEX_A                            "\t%ws = 0x%x\n"
#define I8042_DUMP_HEX_W                            L"\t%ws = 0x%x\n"
#define I8042_DUMP_DECIMAL_A                        "\t%ws = %d\n"
#define I8042_DUMP_DECIMAL_W                        L"\t%ws = %d\n"
#define I8042_DUMP_WIDE_STRING_A                    "%s-%s: %ws = %ws\n"
#define I8042_DUMP_WIDE_STRING_W                    L"%s-%s: %ws = %ws\n"
#define I8042_DUMP_EXPECTING_A                      " expecting (0x%x), got 0x%x\n"
#define I8042_DUMP_EXPECTING_W                      L" expecting (0x%x), got 0x%x\n"
#define I8042_DUMP_EXPECTING_ACK_A                  " expecting ACK (0x%x), got 0x%x\n"
#define I8042_DUMP_EXPECTING_ACK_W                  L" expecting ACK (0x%x), got 0x%x\n"
#define I8042_DUMP_EXPECTING_ID_ACK_A               "expecting ID ACK (0x%x), got 0x%x\n"
#define I8042_DUMP_EXPECTING_ID_ACK_W               L"expecting ID ACK (0x%x), got 0x%x\n"

//
// Make sure that the proper definition is always visible
//
#ifdef UNICODE
#define I8042_DRIVER_NAME                           I8042_DRIVER_NAME_W
#define I8042_BUS                                   I8042_BUS_W
#define I8042_CONTROLLER                            I8042_CONTROLLER_W
#define I8042_ENTER                                 I8042_ENTER_W
#define I8042_EXIT                                  I8042_EXIT_W
#define I8042_INFO                                  I8042_INFO_W
#define I8042_NUMBER                                I8042_NUMBER_W
#define I8042_PERIPHERAL                            I8042_PERIPHERAL_W
#define I8042_TYPE                                  I8042_TYPE_W
#define I8042_FNC_DRIVER_ENTRY                      I8042_FNC_DRIVER_ENTRY_W
#define I8042_FNC_FIND_WHEEL_MOUSE                  I8042_FNC_FIND_WHEEL_MOUSE_W
#define I8042_INITIALIZE_MOUSE                      I8042_INITIALIZE_MOUSE_W
#define I8042_FNC_KEYBOARD_CONFIGURATION            I8042_FNC_KEYBOARD_CONFIGURATION_W
#define I8042_FNC_MOUSE_ENABLE                      I8042_FNC_MOUSE_ENABLE_W
#define I8042_FNC_MOUSE_INTERRUPT                   I8042_FNC_MOUSE_INTERRUPT_W
#define I8042_FNC_MOUSE_PERIPHERAL                  I8042_FNC_MOUSE_PERIPHERAL_W
#define I8042_FNC_SERVICE_PARAMETERS                I8042_FNC_SERVICE_PARAMETERS_W
#define I8042_DEBUGFLAGS                            I8042_DEBUGFLAGS_W
#define I8042_ISRDEBUGFLAGS                         I8042_ISRDEBUGFLAGS_W
#define I8042_DEVICE                                I8042_DEVICE_W
#define I8042_PARAMETERS                            I8042_PARAMETERS_W
#define I8042_FORWARD_SLASH                         I8042_FORWARD_SLASH_W
#define I8042_RESEND_ITERATIONS                     I8042_RESEND_ITERATIONS_W
#define I8042_POLLING_ITERATIONS                    I8042_POLLING_ITERATIONS_W
#define I8042_POLLING_ITERATIONS_MAXIMUM            I8042_POLLING_ITERATIONS_MAXIMUM_W
#define I8042_KEYBOARD_DATA_QUEUE_SIZE              I8042_KEYBOARD_DATA_QUEUE_SIZE_W
#define I8042_MOUSE_DATA_QUEUE_SIZE                 I8042_MOUSE_DATA_QUEUE_SIZE_W
#define I8042_NUMBER_OF_BUTTONS                     I8042_NUMBER_OF_BUTTONS_W
#define I8042_SAMPLE_RATE                           I8042_SAMPLE_RATE_W
#define I8042_MOUSE_RESOLUTION                      I8042_MOUSE_RESOLUTION_W
#define I8042_OVERRIDE_KEYBOARD_TYPE                I8042_OVERRIDE_KEYBOARD_TYPE_W
#define I8042_OVERRIDE_KEYBOARD_SUBTYPE             I8042_OVERRIDE_KEYBOARD_SUBTYE_W
#define I8042_KEYBOARD_DEVICE_BASE_NAME             I8042_KEYBOARD_DEVICE_BASE_NAME_W
#define I8042_POINTER_DEVICE_BASE_NAME              I8042_POINTER_DEVICE_BASE_NAME_W
#define I8042_MOUSE_SYNCH_IN_100NS                  I8042_MOUSE_SYNCH_IN_100NS_W
#define I8042_POLL_STATUS_ITERATIONS                I8042_POLL_STATUS_ITERATIONS_W
#define I8042_ENABLE_WHEEL_DETECTION                I8042_ENABLE_WHEEL_DETECTION_W
#define I8042_DUMP_HEX                              I8042_DUMP_HEX_W
#define I8042_DUMP_DECIMAL                          I8042_DUMP_DECIMAL_W
#define I8042_DUMP_WIDE_STRING                      I8042_DUMP_WIDE_STRING_W
#define I8042_DUMP_EXPECTING                        I8042_DUMP_EXPECTING_W
#define I8042_DUMP_EXPECTING_ACK                    I8042_DUMP_EXPECTING_ACK_W
#define I8042_DUMP_EXPECTING_ID_ACK                 I8042_DUMP_EXPECTING_ID_ACK_W
#else
#define I8042_DRIVER_NAME                           I8042_DRIVER_NAME_A
#define I8042_BUS                                   I8042_BUS_A
#define I8042_CONTROLLER                            I8042_CONTROLLER_A
#define I8042_ENTER                                 I8042_ENTER_A
#define I8042_EXIT                                  I8042_EXIT_A
#define I8042_INFO                                  I8042_INFO_A
#define I8042_NUMBER                                I8042_NUMBER_A
#define I8042_PERIPHERAL                            I8042_PERIPHERAL_A
#define I8042_TYPE                                  I8042_TYPE_A
#define I8042_FNC_DRIVER_ENTRY                      I8042_FNC_DRIVER_NAME_A
#define I8042_FNC_FIND_WHEEL_MOUSE                  I8042_FNC_FIND_WHEEL_MOUSE_A
#define I8042_INITIALIZE_MOUSE                      I8042_INITIALIZE_MOUSE_A
#define I8042_FNC_KEYBOARD_CONFIGURATION            I8042_FNC_KEYBOARD_CONFIGURATION_A
#define I8042_FNC_MOUSE_ENABLE                      I8042_FNC_MOUSE_ENABLE_A
#define I8042_FNC_MOUSE_INTERRUPT                   I8042_FNC_MOUSE_INTERRUPT_A
#define I8042_FNC_MOUSE_PERIPHERAL                  I8042_FNC_MOUSE_PERIPHERAL_A
#define I8042_FNC_SERVICE_PARAMETERS                I8042_FNC_SERVICE_PARAMETERS_A
#define I8042_DEBUGFLAGS                            I8042_DEBUGFLAGS_A
#define I8042_ISRDEBUGFLAGS                            I8042_ISRDEBUGFLAGS_A
#define I8042_DEVICE                                I8042_DEVICE_A
#define I8042_PARAMETERS                            I8042_PARAMETERS_A
#define I8042_FORWARD_SLASH                         I8042_FORWARD_SLASH_A
#define I8042_RESEND_ITERATIONS                     I8042_RESEND_ITERATIONS_A
#define I8042_POLLING_ITERATIONS                    I8042_POLLING_ITERATIONS_A
#define I8042_POLLING_ITERATIONS_MAXIMUM            I8042_POLLING_ITERATIONS_MAXIMUM_A
#define I8042_KEYBOARD_DATA_QUEUE_SIZE              I8042_KEYBOARD_DATA_QUEUE_SIZE_A
#define I8042_MOUSE_DATA_QUEUE_SIZE                 I8042_MOUSE_DATA_QUEUE_SIZE_A
#define I8042_NUMBER_OF_BUTTONS                     I8042_NUMBER_OF_BUTTONS_A
#define I8042_SAMPLE_RATE                           I8042_SAMPLE_RATE_A
#define I8042_MOUSE_RESOLUTION                      I8042_MOUSE_RESOLUTION_A
#define I8042_OVERRIDE_KEYBOARD_TYPE                I8042_OVERRIDE_KEYBOARD_TYPE_A
#define I8042_OVERRIDE_KEYBOARD_SUBTYPE             I8042_OVERRIDE_KEYBOARD_SUBTYE_A
#define I8042_KEYBOARD_DEVICE_BASE_NAME             I8042_KEYBOARD_DEVICE_BASE_NAME_A
#define I8042_POINTER_DEVICE_BASE_NAME              I8042_POINTER_DEVICE_BASE_NAME_A
#define I8042_MOUSE_SYNCH_IN_100NS                  I8042_MOUSE_SYNCH_IN_100NS_A
#define I8042_POLL_STATUS_ITERATIONS                I8042_POLL_STATUS_ITERATIONS_A
#define I8042_ENABLE_WHEEL_DETECTION                I8042_ENABLE_WHEEL_DETECTION_A
#define I8042_DUMP_HEX                              I8042_DUMP_HEX_A
#define I8042_DUMP_DECIMAL                          I8042_DUMP_DECIMAL_A
#define I8042_DUMP_WIDE_STRING                      I8042_DUMP_WIDE_STRING_A
#define I8042_DUMP_EXPECTING                        I8042_DUMP_EXPECTING_A
#define I8042_DUMP_EXPECTING_ACK                    I8042_DUMP_EXPECTING_ACK_A
#define I8042_DUMP_EXPECTING_ID_ACK                 I8042_DUMP_EXPECTING_ID_ACK_A
#endif // UNICODE

//
// Make these variables globally visible
//
extern  const   PSTR    pBus;
extern  const   PSTR    pController;
extern  const   PSTR    pDriverName;
extern  const   PSTR    pIsrKb;
extern  const   PSTR    pIsrMou;
extern  const   PSTR    pEnter;
extern  const   PSTR    pExit;
extern  const   PSTR    pInfo;
extern  const   PSTR    pNumber;
extern  const   PSTR    pPeripheral;
extern  const   PSTR    pType;
extern  const   PSTR    pDumpHex;
extern  const   PSTR    pDumpDecimal;
extern  const   PSTR    pDumpWideString;
extern  const   PSTR    pDumpExpecting;
extern  const   PSTR    pDumpExpectingAck;
extern  const   PSTR    pDumpExpectingIdAck;
extern  const   PSTR    pFncDriverEntry;
extern  const   PSTR    pFncFindWheelMouse;
extern  const   PSTR    pFncInitializeMouse;
extern  const   PSTR    pFncKeyboardConfiguration;
extern  const   PSTR    pFncMouseEnable;
extern  const   PSTR    pFncMouseInterrupt;
extern  const   PSTR    pFncMousePeripheral;
extern  const   PSTR    pFncServiceParameters;
extern  const   PWSTR   pwDebugFlags;
extern  const   PWSTR   pwIsrDebugFlags;
extern  const   PWSTR   pwDevice;
extern  const   PWSTR   pwParameters;
extern  const   PWSTR   pwForwardSlash;
extern  const   PWSTR   pwResendIterations;
extern  const   PWSTR   pwPollingIterations;
extern  const   PWSTR   pwPollingIterationsMaximum;
extern  const   PWSTR   pwKeyboardDataQueueSize;
extern  const   PWSTR   pwMouseDataQueueSize;
extern  const   PWSTR   pwNumberOfButtons;
extern  const   PWSTR   pwSampleRate;
extern  const   PWSTR   pwMouseResolution;
extern  const   PWSTR   pwOverrideKeyboardType;
extern  const   PWSTR   pwOverrideKeyboardSubtype;
extern  const   PWSTR   pwKeyboardDeviceBaseName;
extern  const   PWSTR   pwPointerDeviceBaseName;
extern  const   PWSTR   pwMouseSynchIn100ns;
extern  const   PWSTR   pwPollStatusIterations;
extern  const   PWSTR   pwEnableWheelDetection;
extern  const   PWSTR   pwPowerCaps;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\pnpi8042\kbdcmn.c ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    kbdcmn.c

Abstract:

    The common portions of the Intel i8042 port driver which
    apply to the keyboard device.

Environment:

    Kernel mode only.

Notes:

    NOTES:  (Future/outstanding issues)

    - Powerfail not implemented.

    - Consolidate duplicate code, where possible and appropriate.

Revision History:

--*/

#include "stdarg.h"
#include "stdio.h"
#include "string.h"
#include "i8042prt.h"


VOID
I8042KeyboardIsrDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL to finish processing
    keyboard interrupts.  It is queued in the keyboard ISR.  The real
    work is done via a callback to the connected keyboard class driver.

Arguments:

    Dpc - Pointer to the DPC object.

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the Irp.

    Context - Not used.

Return Value:

    None.

--*/

{
    PPORT_KEYBOARD_EXTENSION deviceExtension;
    GET_DATA_POINTER_CONTEXT getPointerContext;
    SET_DATA_POINTER_CONTEXT setPointerContext;
    VARIABLE_OPERATION_CONTEXT operationContext;
    PVOID classService;
    PVOID classDeviceObject;
    LONG interlockedResult;
    BOOLEAN moreDpcProcessing;
    ULONG dataNotConsumed = 0;
    ULONG inputDataConsumed = 0;
    LARGE_INTEGER deltaTime;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(Irp);
    UNREFERENCED_PARAMETER(Context);

    Print(DBG_DPC_TRACE, ("I8042KeyboardIsrDpc: enter\n"));

    deviceExtension = (PPORT_KEYBOARD_EXTENSION) DeviceObject->DeviceExtension;

    //
    // Use DpcInterlockKeyboard to determine whether the DPC is running
    // concurrently on another processor.  We only want one instantiation
    // of the DPC to actually do any work.  DpcInterlockKeyboard is -1
    // when no DPC is executing.  We increment it, and if the result is
    // zero then the current instantiation is the only one executing, and it
    // is okay to proceed.  Otherwise, we just return.
    //
    //

    operationContext.VariableAddress =
        &deviceExtension->DpcInterlockKeyboard;
    operationContext.Operation = IncrementOperation;
    operationContext.NewValue = &interlockedResult;

    KeSynchronizeExecution(
            deviceExtension->InterruptObject,
            (PKSYNCHRONIZE_ROUTINE) I8xDpcVariableOperation,
            (PVOID) &operationContext
            );

    moreDpcProcessing = (interlockedResult == 0)? TRUE:FALSE;

    while (moreDpcProcessing) {

        dataNotConsumed = 0;
        inputDataConsumed = 0;

        //
        // Get the port InputData queue pointers synchronously.
        //

        getPointerContext.DeviceExtension = deviceExtension;
        setPointerContext.DeviceExtension = deviceExtension;
        getPointerContext.DeviceType = (CCHAR) KeyboardDeviceType;
        setPointerContext.DeviceType = (CCHAR) KeyboardDeviceType;
        setPointerContext.InputCount = 0;

        KeSynchronizeExecution(
            deviceExtension->InterruptObject,
            (PKSYNCHRONIZE_ROUTINE) I8xGetDataQueuePointer,
            (PVOID) &getPointerContext
            );

        if (getPointerContext.InputCount != 0) {

            //
            // Call the connected class driver's callback ISR with the
            // port InputData queue pointers.  If we have to wrap the queue,
            // break the operation into two pieces, and call the class
            // callback ISR once for each piece.
            //

            classDeviceObject =
                deviceExtension->ConnectData.ClassDeviceObject;
            classService =
                deviceExtension->ConnectData.ClassService;
            ASSERT(classService != NULL);

            if (getPointerContext.DataOut >= getPointerContext.DataIn) {

                //
                // We'll have to wrap the InputData circular buffer.  Call
                // the class callback ISR with the chunk of data starting at
                // DataOut and ending at the end of the queue.
                //

                Print(DBG_DPC_NOISE,
                      ("I8042KeyboardIsrDpc: calling class callback\n"
                      ));
                Print(DBG_DPC_INFO,
                      ("I8042KeyboardIsrDpc: with Start 0x%x and End 0x%x\n",
                      getPointerContext.DataOut,
                      deviceExtension->DataEnd
                      ));

                (*(PSERVICE_CALLBACK_ROUTINE) classService)(
                      classDeviceObject,
                      getPointerContext.DataOut,
                      deviceExtension->DataEnd,
                      &inputDataConsumed
                      );

                dataNotConsumed = ((ULONG)((PUCHAR)
                    deviceExtension->DataEnd -
                    (PUCHAR) getPointerContext.DataOut)
                    / sizeof(KEYBOARD_INPUT_DATA)) - inputDataConsumed;

                Print(DBG_DPC_INFO,
                      ("I8042KeyboardIsrDpc: (Wrap) Call callback consumed %d items, left %d\n",
                      inputDataConsumed,
                      dataNotConsumed
                      ));

                setPointerContext.InputCount += inputDataConsumed;

                if (dataNotConsumed) {
                    setPointerContext.DataOut =
                        ((PUCHAR)getPointerContext.DataOut) +
                        (inputDataConsumed * sizeof(KEYBOARD_INPUT_DATA));
                } else {
                    setPointerContext.DataOut =
                        deviceExtension->InputData;
                    getPointerContext.DataOut = setPointerContext.DataOut;
                }
            }

            //
            // Call the class callback ISR with data remaining in the queue.
            //

            if ((dataNotConsumed == 0) &&
                (inputDataConsumed < getPointerContext.InputCount)){
                Print(DBG_DPC_NOISE,
                      ("I8042KeyboardIsrDpc: calling class callback\n"
                      ));
                Print(DBG_DPC_INFO,
                      ("I8042KeyboardIsrDpc: with Start 0x%x and End 0x%x\n",
                      getPointerContext.DataOut,
                      getPointerContext.DataIn
                      ));

                (*(PSERVICE_CALLBACK_ROUTINE) classService)(
                      classDeviceObject,
                      getPointerContext.DataOut,
                      getPointerContext.DataIn,
                      &inputDataConsumed
                      );

                dataNotConsumed = ((ULONG)((PUCHAR) getPointerContext.DataIn -
                      (PUCHAR) getPointerContext.DataOut)
                      / sizeof(KEYBOARD_INPUT_DATA)) - inputDataConsumed;

                Print(DBG_DPC_INFO,
                      ("I8042KeyboardIsrDpc: Call callback consumed %d items, left %d\n",
                      inputDataConsumed,
                      dataNotConsumed
                      ));

                setPointerContext.DataOut =
                    ((PUCHAR)getPointerContext.DataOut) +
                    (inputDataConsumed * sizeof(KEYBOARD_INPUT_DATA));
                setPointerContext.InputCount += inputDataConsumed;

            }

            //
            // Update the port InputData queue DataOut pointer and InputCount
            // synchronously.
            //

            KeSynchronizeExecution(
                deviceExtension->InterruptObject,
                (PKSYNCHRONIZE_ROUTINE) I8xSetDataQueuePointer,
                (PVOID) &setPointerContext
                );

        }

        if (dataNotConsumed) {

            //
            // The class driver was unable to consume all the data.
            // Reset the interlocked variable to -1.  We do not want
            // to attempt to move more data to the class driver at this
            // point, because it is already overloaded.  Need to wait a
            // while to give the Raw Input Thread a chance to read some
            // of the data out of the class driver's queue.  We accomplish
            // this "wait" via a timer.
            //

            Print(DBG_DPC_INFO,
                  ("I8042KeyboardIsrDpc: set timer in DPC\n"
                  ));

            operationContext.Operation = WriteOperation;
            interlockedResult = -1;
            operationContext.NewValue = &interlockedResult;

            KeSynchronizeExecution(
                    deviceExtension->InterruptObject,
                    (PKSYNCHRONIZE_ROUTINE) I8xDpcVariableOperation,
                    (PVOID) &operationContext
                    );

            deltaTime.LowPart = (ULONG)(-10 * 1000 * 1000);
            deltaTime.HighPart = -1;

            (VOID) KeSetTimer(
                       &deviceExtension->DataConsumptionTimer,
                       deltaTime,
                       &deviceExtension->KeyboardIsrDpcRetry
                       );

            moreDpcProcessing = FALSE;

        } else {

            //
            // Decrement DpcInterlockKeyboard.  If the result goes negative,
            // then we're all finished processing the DPC.  Otherwise, either
            // the ISR incremented DpcInterlockKeyboard because it has more
            // work for the ISR DPC to do, or a concurrent DPC executed on
            // some processor while the current DPC was running (the
            // concurrent DPC wouldn't have done any work).  Make sure that
            // the current DPC handles any extra work that is ready to be
            // done.
            //

            operationContext.Operation = DecrementOperation;
            operationContext.NewValue = &interlockedResult;

            KeSynchronizeExecution(
                    deviceExtension->InterruptObject,
                    (PKSYNCHRONIZE_ROUTINE) I8xDpcVariableOperation,
                    (PVOID) &operationContext
                    );

            if (interlockedResult != -1) {

                //
                // The interlocked variable is still greater than or equal to
                // zero. Reset it to zero, so that we execute the loop one
                // more time (assuming no more DPCs execute and bump the
                // variable up again).
                //

                operationContext.Operation = WriteOperation;
                interlockedResult = 0;
                operationContext.NewValue = &interlockedResult;

                KeSynchronizeExecution(
                    deviceExtension->InterruptObject,
                    (PKSYNCHRONIZE_ROUTINE) I8xDpcVariableOperation,
                    (PVOID) &operationContext
                    );

                Print(DBG_DPC_INFO,
                      ("I8042KeyboardIsrDpc: loop in DPC\n"
                      ));
            }
            else {
                moreDpcProcessing = FALSE;
            }
        }

    }

    Print(DBG_DPC_TRACE, ("I8042KeyboardIsrDpc: exit\n"));
}

BOOLEAN
I8xWriteDataToKeyboardQueue(
    PPORT_KEYBOARD_EXTENSION KeyboardExtension,
    IN PKEYBOARD_INPUT_DATA InputData
    )

/*++

Routine Description:

    This routine adds input data from the keyboard to the InputData queue.

Arguments:

    KeyboardExtension - Pointer to the keyboard portion of the device extension.

    InputData - Pointer to the data to add to the InputData queue.

Return Value:

    Returns TRUE if the data was added, otherwise FALSE.

--*/

{

    PKEYBOARD_INPUT_DATA previousDataIn;

    Print(DBG_CALL_TRACE, ("I8xWriteDataToKeyboardQueue: enter\n"));
    Print(DBG_CALL_NOISE,
          ("I8xWriteDataToKeyboardQueue: DataIn 0x%x, DataOut 0x%x\n",
          KeyboardExtension->DataIn,
          KeyboardExtension->DataOut
          ));
    Print(DBG_CALL_NOISE,
          ("I8xWriteDataToKeyboardQueue: InputCount %d\n",
          KeyboardExtension->InputCount
          ));

    //
    // Check for full input data queue.
    //

    if ((KeyboardExtension->DataIn == KeyboardExtension->DataOut) &&
        (KeyboardExtension->InputCount != 0)) {

        //
        // Queue overflow.  Replace the previous input data packet
        // with a keyboard overrun data packet, thus losing both the
        // previous and the current input data packet.
        //

        Print(DBG_CALL_ERROR, ("I8xWriteDataToKeyboardQueue: OVERFLOW\n"));

        if (KeyboardExtension->DataIn == KeyboardExtension->InputData) {
            Print(DBG_CALL_NOISE,
                  ("I8xWriteDataToKeyboardQueue: wrap buffer\n"
                  ));
            previousDataIn = KeyboardExtension->DataEnd;
        } else {
            previousDataIn = KeyboardExtension->DataIn - 1;
        }

        previousDataIn->MakeCode = KEYBOARD_OVERRUN_MAKE_CODE;
        previousDataIn->Flags = 0;

        Print(DBG_CALL_TRACE, ("I8xWriteDataToKeyboardQueue: exit\n"));
        return(FALSE);

    } else {
        *(KeyboardExtension->DataIn) = *InputData;
        KeyboardExtension->InputCount += 1;
        KeyboardExtension->DataIn++;
        Print(DBG_CALL_INFO,
              ("I8xWriteDataToKeyboardQueue: new InputCount %d\n",
              KeyboardExtension->InputCount
              ));
        if (KeyboardExtension->DataIn ==
            KeyboardExtension->DataEnd) {
            Print(DBG_CALL_NOISE,
                  ("I8xWriteDataToKeyboardQueue: wrap buffer\n"
                  ));
            KeyboardExtension->DataIn = KeyboardExtension->InputData;
        }
    }

    Print(DBG_CALL_TRACE, ("I8xWriteDataToKeyboardQueue: exit\n"));

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\pnpi8042\kbdpnp.c ===
/*++

Copyright (c) 1997-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    kbdpnp.c

Abstract:

    This module contains plug & play code for the I8042 Keyboard Filter Driver.

Environment:

    Kernel mode.

Revision History:

--*/

#include "i8042prt.h"
#include "i8042log.h"
#include <poclass.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, I8xKeyboardConnectInterrupt)
#pragma alloc_text(PAGE, I8xKeyboardInitializeHardware)
#pragma alloc_text(PAGE, I8xKeyboardStartDevice)
#pragma alloc_text(PAGE, I8xKeyboardRemoveDevice)
#endif

NTSTATUS
I8xKeyboardConnectInterrupt(
    PPORT_KEYBOARD_EXTENSION KeyboardExtension
    )
/*++

Routine Description:

    Calls IoConnectInterupt to connect the keyboard interrupt
    
Arguments:

    KeyboardExtension - Keyboard Extension
   
    SyncConnectContext -  Structure to be filled in if synchronization needs to 
                          take place between this interrupt and the mouse
                          interrupt. 

Return Value:

    STATUS_SUCCESSFUL if successful,

--*/
{
    NTSTATUS                            status = STATUS_SUCCESS;
    ULONG                               dumpData[1];
    PI8042_CONFIGURATION_INFORMATION    configuration;
    PDEVICE_OBJECT                      self;

    PAGED_CODE();

    //
    // If the devices were started in totally disparate manner, make sure we 
    // retry to connect the interrupt (and fail and NULL out InterruptObject)
    //
    if (KeyboardExtension->InterruptObject) {
        return STATUS_SUCCESS;
    }

    configuration = &Globals.ControllerData->Configuration;
    self = KeyboardExtension->Self;

    Print(DBG_SS_NOISE,
          ("I8xKeyboardConnectInterrupt:\n"
          "\tFDO = 0x%x\n"
          "\tVector = 0x%x\n"
          "\tIrql = 0x%x\n"
          "\tSynchIrql = 0x%x\n"
          "\tIntterupt Mode = %s\n"
          "\tShared int:  %s\n"
          "\tAffinity = 0x%x\n"
          "\tFloating Save = %s\n",
          self,
          (ULONG) KeyboardExtension->InterruptDescriptor.u.Interrupt.Vector,       
          (ULONG) KeyboardExtension->InterruptDescriptor.u.Interrupt.Level,
          (ULONG) configuration->InterruptSynchIrql, 
          KeyboardExtension->InterruptDescriptor.Flags
            == CM_RESOURCE_INTERRUPT_LATCHED ? "Latched" : "LevelSensitive",
          (ULONG) KeyboardExtension->InterruptDescriptor.ShareDisposition
            == CmResourceShareShared ? "true" : "false",
          (ULONG) KeyboardExtension->InterruptDescriptor.u.Interrupt.Affinity,       
          configuration->FloatingSave ? "yes" : "no"
          ));

    KeyboardExtension->IsIsrActivated = TRUE;

    //
    // Connect the interrupt and set everything in motion
    //
    status = IoConnectInterrupt(
        &(KeyboardExtension->InterruptObject),
        (PKSERVICE_ROUTINE) I8042KeyboardInterruptService,
        self,
        &KeyboardExtension->InterruptSpinLock,
        KeyboardExtension->InterruptDescriptor.u.Interrupt.Vector,       
        (KIRQL) KeyboardExtension->InterruptDescriptor.u.Interrupt.Level,
        configuration->InterruptSynchIrql, 
        KeyboardExtension->InterruptDescriptor.Flags
          == CM_RESOURCE_INTERRUPT_LATCHED ? Latched : LevelSensitive,
        (BOOLEAN) (KeyboardExtension->InterruptDescriptor.ShareDisposition
            == CmResourceShareShared),
        KeyboardExtension->InterruptDescriptor.u.Interrupt.Affinity,    
        configuration->FloatingSave
        );

    if (NT_SUCCESS(status)) {
        INTERNAL_I8042_START_INFORMATION startInfo;
        PDEVICE_OBJECT topOfStack = IoGetAttachedDeviceReference(self);

        ASSERT(KeyboardExtension->InterruptObject != NULL);
        ASSERT(topOfStack);

        RtlZeroMemory(&startInfo, sizeof(INTERNAL_I8042_START_INFORMATION));
        startInfo.Size = sizeof(INTERNAL_I8042_START_INFORMATION);
        startInfo.InterruptObject = KeyboardExtension->InterruptObject; 

        I8xSendIoctl(topOfStack,
                     IOCTL_INTERNAL_I8042_KEYBOARD_START_INFORMATION,
                     &startInfo, 
                     sizeof(INTERNAL_I8042_START_INFORMATION)
                     );

        ObDereferenceObject(topOfStack);
    }
    else {
        //
        // Failed to install.  Free up resources before exiting.
        //
        Print(DBG_SS_ERROR, ("Could not connect keyboard isr!!!\n")); 

        dumpData[0] = KeyboardExtension->InterruptDescriptor.u.Interrupt.Level;
        //
        // Log the error
        //
        I8xLogError(self,
                    I8042_NO_INTERRUPT_CONNECTED_KBD,
                    I8042_ERROR_VALUE_BASE + 80,
                    STATUS_INSUFFICIENT_RESOURCES, 
                    dumpData,
                    1
                    );

        I8xManuallyRemoveDevice(GET_COMMON_DATA(KeyboardExtension));
    }

    return status;
}

NTSTATUS
I8xKeyboardInitializeHardware(
    PPORT_KEYBOARD_EXTENSION    KeyboardExtension,
    PPORT_MOUSE_EXTENSION       MouseExtension
    )
/*++

Routine Description:

    Called if the keyboard is the last device to initialized with respect to the
    mouse (if it is present at all).  It calls the initialization function and
    then connects the (possibly) two interrupts, synchronizing the lower IRQL'ed
    interrupt to the higher one.
     
Arguments:

    KeyboardExtension - Keyboard Extension
   
    SyncConnectContext -  Structure to be filled in if synchronization needs to 
                          take place between this interrupt and the mouse
                          interrupt. 

Return Value:

    STATUS_SUCCESSFUL if successful,

--*/
{
    NTSTATUS                keyboardStatus = STATUS_UNSUCCESSFUL,
                            mouseStatus = STATUS_UNSUCCESSFUL,
                            status;
    BOOLEAN                 mouThoughtPresent;

    PAGED_CODE();


    //
    // Initialize the i8042 for all devices present on it.
    // If either device is unresponsive, then XXX_PRESENT() will be false
    //
    mouThoughtPresent = MOUSE_PRESENT();
    status = I8xInitializeHardwareAtBoot(&keyboardStatus, &mouseStatus);

    //
    // failure here means that we couldn't toggle the interrupts on the i8042
    //
    if (!NT_SUCCESS(status)) {
        return status;
    }

    if (DEVICE_START_SUCCESS(mouseStatus)) {
        //
        // Any errors will be logged by I8xMouseConnectInterruptAndEnable
        //
        status = I8xMouseConnectInterruptAndEnable(
            MouseExtension, 
            mouseStatus == STATUS_DEVICE_NOT_CONNECTED ? FALSE : TRUE
            );

        //
        // mou couldn't connect, make sure our count of started devices reflects 
        // this
        //
        if (!NT_SUCCESS(status)) {
            Print(DBG_SS_ERROR, ("thought mou was present, is not (2)!\n"));
        }
    }
    else {
        //
        // We thought the mouse was present, but it is not, make sure that started
        // devices reflects this
        //
        // if (mouThoughtPresent) {
        //     InterlockedDecrement(&Globals.StartedDevices);
        // }
    }

    //
    // The keyboard could be present but not have been initialized
    //  in I8xInitializeHardware
    //
    if (DEVICE_START_SUCCESS(keyboardStatus)) {
        // 
        // I8xKeyboardConnectInterrupt will log any errors if unsuccessful
        //
        keyboardStatus = I8xKeyboardConnectInterrupt(KeyboardExtension);
    }

    return keyboardStatus;
}

NTSTATUS
I8xKeyboardStartDevice(
    IN OUT PPORT_KEYBOARD_EXTENSION KeyboardExtension,
    IN PCM_RESOURCE_LIST ResourceList
    )
/*++

Routine Description:

    Configures the keyboard's device extension (ie allocation of pool,
    initialization of DPCs, etc).  If the keyboard is the last device to start,
    it will also initialize the hardware and connect all the interrupts.

Arguments:

    KeyboardExtension - Keyboard extesnion
    
    ResourceList - Translated resource list for this device
    
Return Value:

    STATUS_SUCCESSFUL if successful,

--*/
{
    ULONG                               dumpData[1];
    NTSTATUS                            status = STATUS_SUCCESS;
    PDEVICE_OBJECT                      self;
    I8042_INITIALIZE_DATA_CONTEXT       initializeDataContext;
    BOOLEAN                             tryMouseInit = FALSE;

    PAGED_CODE();

    Print(DBG_SS_TRACE, ("I8xKeyboardStartDevice, enter\n"));

    //
    // Check to see if kb has been started.  If so, fail this start
    //
    if (KEYBOARD_INITIALIZED()) {
        Print(DBG_SS_ERROR, ("too many kbs!\n"));

        //
        // This is not really necessary because the value won't ever be checked
        // in the context of seeing if all the keyboards were bogus, but it is
        // done so that Globals.AddedKeyboards == # of actual started keyboards
        //
        InterlockedDecrement(&Globals.AddedKeyboards);

        status = STATUS_NO_SUCH_DEVICE;
        goto I8xKeyboardStartDeviceExit; 
    }
    else if (KeyboardExtension->ConnectData.ClassService == NULL) {
        //
        // We are never really going to get here because if we don't have the
        // class driver on top of us, extension->IsKeyboard will be false and 
        // we will think that the device is a mouse, but for completeness

        //
        // No class driver on top of us == BAD BAD BAD
        //
        // Fail the start of this device in the hope that there is another stack
        // that is correctly formed.  Another side affect of having no class 
        // driver is that the AddedKeyboards count is not incremented for this
        // device
        //

        Print(DBG_SS_ERROR, ("Keyboard started with out a service cb!\n"));
        return STATUS_INVALID_DEVICE_STATE;
    }


    status = I8xKeyboardConfiguration(KeyboardExtension,
                                      ResourceList
                                      );

    if (!NT_SUCCESS(status)) {
        if (I8xManuallyRemoveDevice(GET_COMMON_DATA(KeyboardExtension)) < 1) {
            tryMouseInit = TRUE;
        }
        goto I8xKeyboardStartDeviceExit;
    }

    ASSERT( KEYBOARD_PRESENT() );

    Globals.KeyboardExtension = KeyboardExtension;
    self = KeyboardExtension->Self;

    if ((KIRQL) KeyboardExtension->InterruptDescriptor.u.Interrupt.Level >
        Globals.ControllerData->Configuration.InterruptSynchIrql) {
        Globals.ControllerData->Configuration.InterruptSynchIrql = 
            (KIRQL) KeyboardExtension->InterruptDescriptor.u.Interrupt.Level;
    }

    //
    // Initialize crash dump configuration
    //
    KeyboardExtension->CrashFlags = 0;
    KeyboardExtension->CurrentCrashFlags = 0;
    KeyboardExtension->CrashScanCode = (UCHAR) 0;
    KeyboardExtension->CrashScanCode2 = (UCHAR) 0;

    I8xKeyboardServiceParameters(
        &Globals.RegistryPath,
        KeyboardExtension
        );

    //
    // These may have been set by a value in the Parameters key.  It overrides
    // the "Crash Dump" key
    //
    if (KeyboardExtension->CrashFlags == 0) {
        //
        // Get the crashdump information.
        //
        I8xServiceCrashDump(KeyboardExtension,
                            &Globals.RegistryPath
                            );
    }

    //
    // Allocate memory for the keyboard data queue.
    //
    KeyboardExtension->InputData = ExAllocatePool(
        NonPagedPool,
        KeyboardExtension->KeyboardAttributes.InputDataQueueLength
        );

    if (!KeyboardExtension->InputData) {

        //
        // Could not allocate memory for the keyboard data queue.
        //
        Print(DBG_SS_ERROR,
              ("I8xStartDevice: Could not allocate keyboard input data queue\n"
              ));

        dumpData[0] = KeyboardExtension->KeyboardAttributes.InputDataQueueLength;

        //
        // Log the error
        //
        I8xLogError(self,
                    I8042_NO_BUFFER_ALLOCATED_KBD, 
                    I8042_ERROR_VALUE_BASE + 50,
                    STATUS_INSUFFICIENT_RESOURCES, 
                    dumpData,
                    1
                    );

        status =  STATUS_INSUFFICIENT_RESOURCES;
        tryMouseInit = TRUE;

        goto I8xKeyboardStartDeviceExit;
    }
    else {
        KeyboardExtension->DataEnd =
            (PKEYBOARD_INPUT_DATA)
            ((PCHAR) (KeyboardExtension->InputData) +
            KeyboardExtension->KeyboardAttributes.InputDataQueueLength);

        //
        // Zero the keyboard input data ring buffer.
        //
        RtlZeroMemory(
            KeyboardExtension->InputData,
            KeyboardExtension->KeyboardAttributes.InputDataQueueLength
            );

        initializeDataContext.DeviceExtension = KeyboardExtension;
        initializeDataContext.DeviceType = KeyboardDeviceType;
        I8xInitializeDataQueue(&initializeDataContext);
    }

    KeyboardExtension->DpcInterlockKeyboard = -1;

    //
    // Initialize the ISR DPC .  The ISR DPC
    // is responsible for calling the connected class driver's callback
    // routine to process the input data queue.
    //
    KeInitializeDpc(
        &KeyboardExtension->KeyboardIsrDpc,
        (PKDEFERRED_ROUTINE) I8042KeyboardIsrDpc,
        self
        );

    KeInitializeDpc(
        &KeyboardExtension->KeyboardIsrDpcRetry,
        (PKDEFERRED_ROUTINE) I8042KeyboardIsrDpc,
        self
        );

    KeInitializeDpc(
        &KeyboardExtension->SysButtonEventDpc,
        (PKDEFERRED_ROUTINE) I8xKeyboardSysButtonEventDpc,
        self
        );

    KeInitializeSpinLock(&KeyboardExtension->SysButtonSpinLock);
    if (KeyboardExtension->PowerCaps) {
        I8xRegisterDeviceInterface(KeyboardExtension->PDO,
                                   &GUID_DEVICE_SYS_BUTTON,
                                   &KeyboardExtension->SysButtonInterfaceName
                                   );
    }

    I8xInitWmi(GET_COMMON_DATA(KeyboardExtension));

    KeyboardExtension->Initialized = TRUE;

    //
    // This is not the last device to started on the i8042, defer h/w init
    // until the last device is started
    //
    if (MOUSE_PRESENT() && !MOUSE_STARTED()) {
        //
        // A mouse is present, but it has not been started yet
        //
        Print(DBG_SS_INFO, ("skipping init until mouse\n"));
    }
    else {
        status = I8xKeyboardInitializeHardware(KeyboardExtension,
                                               Globals.MouseExtension);
    }

I8xKeyboardStartDeviceExit:
    if (tryMouseInit && MOUSE_STARTED() && !MOUSE_INITIALIZED()) {
        Print(DBG_SS_INFO, ("keyboard may have failed, trying to init mouse\n"));
        I8xMouseInitializeHardware(KeyboardExtension,
                                   Globals.MouseExtension 
                                   ); 
    }

    Print(DBG_SS_INFO, 
          ("I8xKeyboardStartDevice %s\n",
          NT_SUCCESS(status) ? "successful" : "unsuccessful"
          ));

    Print(DBG_SS_TRACE, ("I8xKeyboardStartDevice exit (0x%x)\n", status));

    return status;
}

VOID
I8xKeyboardRemoveDeviceInitialized(
    PPORT_KEYBOARD_EXTENSION KeyboardExtension
    )
{
    PIRP    irp = NULL;
    KIRQL   irql;

    KeAcquireSpinLock(&KeyboardExtension->SysButtonSpinLock, &irql);

    KeRemoveQueueDpc(&KeyboardExtension->SysButtonEventDpc);
    irp = KeyboardExtension->SysButtonEventIrp;
    KeyboardExtension->SysButtonEventIrp = NULL;

    if (irp && (irp->Cancel || IoSetCancelRoutine(irp, NULL) == NULL)) {
        irp = NULL;
    }

    KeReleaseSpinLock(&KeyboardExtension->SysButtonSpinLock, irql);

    if (irp) {
        I8xCompleteSysButtonIrp(irp, 0x0, STATUS_DELETE_PENDING);
    }
}

VOID
I8xKeyboardRemoveDevice(
    PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Removes the device.  This will only occur if the device removed itself.  
    Disconnects the interrupt, removes the synchronization flag for the mouse if 
    present, and frees any memory associated with the device.
    
Arguments:

    DeviceObject - The device object for the keyboard 

Return Value:

    STATUS_SUCCESSFUL if successful,

--*/
{
    PPORT_KEYBOARD_EXTENSION keyboardExtension = DeviceObject->DeviceExtension;
    PIRP irp;

    Print(DBG_PNP_INFO, ("I8xKeyboardRemoveDevice enter\n"));

    PAGED_CODE();

    if (Globals.KeyboardExtension == keyboardExtension && keyboardExtension) {
        CLEAR_KEYBOARD_PRESENT();
        Globals.KeyboardExtension = NULL;
    }

    if (keyboardExtension->InterruptObject) {
        IoDisconnectInterrupt(keyboardExtension->InterruptObject);
        keyboardExtension->InterruptObject = NULL;
    }

    if (keyboardExtension->InputData) {
        ExFreePool(keyboardExtension->InputData);
        keyboardExtension->InputData = 0;
    }

    //
    // See if we have gotten a sys button key press in the midst of a removal.
    // If so, then the request will be in PendingCompletion...Irp, otherwise we
    // might have the irp in Pending...Irp
    //
    if (keyboardExtension->Initialized) {
        I8xKeyboardRemoveDeviceInitialized(keyboardExtension);
    }

    if (keyboardExtension->SysButtonInterfaceName.Buffer) {
        IoSetDeviceInterfaceState(&keyboardExtension->SysButtonInterfaceName,
                                  FALSE
                                  );
        RtlFreeUnicodeString(&keyboardExtension->SysButtonInterfaceName);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\pnpi8042\moupnp.c ===
/*+

Copyright (c) 1997-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    moupnp.c

Abstract:

    This module contains plug & play code for the aux device (mouse) of the 
    i8042prt device driver

Environment:

    Kernel mode.

Revision History:

--*/

#include "i8042prt.h"
#include "i8042log.h"

#include <initguid.h>
#include <wdmguid.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, I8xMouseConnectInterruptAndEnable)
#pragma alloc_text(PAGE, I8xMouseStartDevice)
#pragma alloc_text(PAGE, I8xMouseInitializeHardware)
#pragma alloc_text(PAGE, I8xMouseRemoveDevice)
#pragma alloc_text(PAGE, I8xProfileNotificationCallback)
#pragma alloc_text(PAGE, I8xMouseInitializeInterruptWorker)

//
// These will be locked down right before the mouse interrupt is enabled if a 
// mouse is present
//
#pragma alloc_text(PAGEMOUC, I8xMouseInitializePolledWorker)
#pragma alloc_text(PAGEMOUC, I8xMouseEnableSynchRoutine)
#pragma alloc_text(PAGEMOUC, I8xMouseEnableDpc)
#pragma alloc_text(PAGEMOUC, I8xIsrResetDpc) 
#pragma alloc_text(PAGEMOUC, I8xMouseResetTimeoutProc) 
#pragma alloc_text(PAGEMOUC, I8xMouseResetSynchRoutine)

#endif

#define MOUSE_INIT_POLLED(MouseExtension)                           \
        {                                                           \
            KeInitializeDpc(&MouseExtension->EnableMouse.Dpc,       \
                            (PKDEFERRED_ROUTINE) I8xMouseEnableDpc, \
                            MouseExtension);                        \
            KeInitializeTimerEx(&MouseExtension->EnableMouse.Timer, \
                                SynchronizationTimer);              \
            MouseExtension->InitializePolled = TRUE;                \
        }

#define MOUSE_INIT_INTERRUPT(MouseExtension)                        \
        {                                                           \
            KeInitializeDpc(&MouseExtension->ResetMouse.Dpc,        \
                            (PKDEFERRED_ROUTINE) I8xMouseResetTimeoutProc,  \
                            MouseExtension);                        \
            KeInitializeTimer(&MouseExtension->ResetMouse.Timer);   \
                MouseExtension->InitializePolled = FALSE;           \
        }

NTSTATUS
I8xMouseConnectInterruptAndEnable(
    PPORT_MOUSE_EXTENSION MouseExtension,
    BOOLEAN Reset
    )
/*++

Routine Description:

    Calls IoConnectInterupt to connect the mouse interrupt
    
Arguments:

    MouseExtension - Mouse Extension

    Reset - flag to indicate if the mouse should be reset from within this function   
    
Return Value:

    STATUS_SUCCESSFUL if successful,

--*/
{
    NTSTATUS                            status = STATUS_SUCCESS;
    ULONG                               dumpData[1];
    PI8042_CONFIGURATION_INFORMATION    configuration;
    PDEVICE_OBJECT                      self;

    PAGED_CODE();

    Print(DBG_SS_NOISE, ("Connect INT,  reset = %d\n", (ULONG) Reset));

    //
    // If the devices were started in totally disparate manner, make sure we 
    // retry to connect the interrupt (and fail and NULL out
    // MouseInterruptObject)
    //
    if (MouseExtension->InterruptObject) {
        return STATUS_SUCCESS;
    }

    configuration = &Globals.ControllerData->Configuration;
    self = MouseExtension->Self;

    //
    // Lock down all of the mouse related ISR/DPC functions
    //
    MmLockPagableCodeSection(I8042MouseInterruptService);

    //
    // Connect the interrupt and set everything in motion
    //
    Print(DBG_SS_NOISE,
          ("I8xMouseConnectInterruptAndEnable:\n"
          "\tFDO = 0x%x\n"
          "\tVector = 0x%x\n"
          "\tIrql = 0x%x\n"
          "\tSynchIrql = 0x%x\n"
          "\tIntterupt Mode = %s\n"
          "\tShared int: %s\n"
          "\tAffinity = 0x%x\n"
          "\tFloating Save = %s\n",
          self,
          (ULONG) MouseExtension->InterruptDescriptor.u.Interrupt.Vector,       
          (ULONG) MouseExtension->InterruptDescriptor.u.Interrupt.Level,
          (ULONG) configuration->InterruptSynchIrql,
          MouseExtension->InterruptDescriptor.Flags
            == CM_RESOURCE_INTERRUPT_LATCHED ? "Latched" : "LevelSensitive",
          (ULONG) MouseExtension->InterruptDescriptor.ShareDisposition
           == CmResourceShareShared ? "true" : "false",
          (ULONG) MouseExtension->InterruptDescriptor.u.Interrupt.Affinity,       
          configuration->FloatingSave ? "yes" : "no"
          ));

    MouseExtension->IsIsrActivated = TRUE;

    status = IoConnectInterrupt(
        &(MouseExtension->InterruptObject),
        (PKSERVICE_ROUTINE) I8042MouseInterruptService,
        self,
        &MouseExtension->InterruptSpinLock,
        MouseExtension->InterruptDescriptor.u.Interrupt.Vector,       
        (KIRQL) MouseExtension->InterruptDescriptor.u.Interrupt.Level,
        configuration->InterruptSynchIrql, 
        MouseExtension->InterruptDescriptor.Flags
          == CM_RESOURCE_INTERRUPT_LATCHED ?
          Latched : LevelSensitive,
        (BOOLEAN) (MouseExtension->InterruptDescriptor.ShareDisposition
            == CmResourceShareShared),
        MouseExtension->InterruptDescriptor.u.Interrupt.Affinity,       
        configuration->FloatingSave
        );

    if (NT_SUCCESS(status)) {
        INTERNAL_I8042_START_INFORMATION startInfo;
        PDEVICE_OBJECT topOfStack = IoGetAttachedDeviceReference(self);

        ASSERT(MouseExtension->InterruptObject != NULL);
        ASSERT(topOfStack);

        RtlZeroMemory(&startInfo, sizeof(INTERNAL_I8042_START_INFORMATION));
        startInfo.Size = sizeof(INTERNAL_I8042_START_INFORMATION);
        startInfo.InterruptObject = MouseExtension->InterruptObject; 

        I8xSendIoctl(topOfStack,
                     IOCTL_INTERNAL_I8042_MOUSE_START_INFORMATION,
                     &startInfo, 
                     sizeof(INTERNAL_I8042_START_INFORMATION)
                     );

        ObDereferenceObject(topOfStack);
    }
    else {
        Print(DBG_SS_ERROR, ("Could not connect mouse isr!!!\n"));

        dumpData[0] = MouseExtension->InterruptDescriptor.u.Interrupt.Level;

        I8xLogError(self,
                    I8042_NO_INTERRUPT_CONNECTED_MOU,
                    I8042_ERROR_VALUE_BASE + 90,
                    STATUS_INSUFFICIENT_RESOURCES, 
                    dumpData,
                    1
                    );

        I8xManuallyRemoveDevice(GET_COMMON_DATA(MouseExtension));

        return status;
    }

    if (Reset) {
        if (MouseExtension->InitializePolled) {
            //
            // Enable mouse transmissions, now that the interrupts are enabled.
            // We've held off transmissions until now, in an attempt to
            // keep the driver's notion of mouse input data state in sync
            // with the mouse hardware.
            //
            status = I8xMouseEnableTransmission(MouseExtension);
            if (!NT_SUCCESS(status)) {
        
                //
                // Couldn't enable mouse transmissions.  Continue on, anyway.
                //
                Print(DBG_SS_ERROR,
                      ("I8xMouseConnectInterruptAndEnable: "
                       "Could not enable mouse transmission (0x%x)\n", status));
        
                status = STATUS_SUCCESS;
            }
        }
        else {
    
            I8X_MOUSE_INIT_COUNTERS(MouseExtension);
    
            // 
            // Reset the mouse and start the init state machine in the ISR
            //
            status = I8xResetMouse(MouseExtension);
        
            if (!NT_SUCCESS(status)) {
                Print(DBG_SS_ERROR,
                      ("I8xMouseConnectInterruptAndEnable:  "
                       "failed to reset mouse (0x%x), reset count = %d, failed resets = %d, resend count = %d\n",
                       status, MouseExtension->ResetCount,
                       MouseExtension->FailedCompleteResetCount,
                       MouseExtension->ResendCount));
            }
        }
    }
    else {
        Print(DBG_SS_NOISE, ("NOT resetting mouse on INT connect\n"));
    }

    return status;
}


NTSTATUS
I8xMouseInitializeHardware(
    PPORT_KEYBOARD_EXTENSION    KeyboardExtension,
    PPORT_MOUSE_EXTENSION       MouseExtension
    )
/*++

Routine Description:

    Called if the mouse is the last device to initialized with respect to the
    keyboard (if it is present at all).  It calls the initialization function and
    then connects the (possibly) two interrupts, synchronizing the lower IRQL'ed
    interrupt to the higher one.
     
Arguments:

    MouseExtension - Mouse Extension
   
    SyncConnectContext -  Structure to be filled in if synchronization needs to 
                          take place between this interrupt and the mouse
                          interrupt. 

Return Value:

    STATUS_SUCCESSFUL if successful,

--*/
{
    NTSTATUS    keyboardStatus = STATUS_UNSUCCESSFUL,
                mouseStatus = STATUS_UNSUCCESSFUL,
                status = STATUS_SUCCESS;
    BOOLEAN     kbThoughtPresent;

    PAGED_CODE();

    //
    // Initialize the hardware for all types of devices present on the i8042
    //
    kbThoughtPresent = KEYBOARD_PRESENT();
    status = I8xInitializeHardwareAtBoot(&keyboardStatus, &mouseStatus);            

    //
    // The kb has alread been started (from the controller's perspective,  the 
    // of the mouse is denied in fear of disabling the kb
    //
    if (status == STATUS_INVALID_DEVICE_REQUEST) {
        I8xManuallyRemoveDevice(GET_COMMON_DATA(MouseExtension));
    }

    if (!NT_SUCCESS(status)) {
        return status;
    }

    if (DEVICE_START_SUCCESS(keyboardStatus)) { 

        //
        // Any errors will be logged by I8xKeyboardConnectInterrupt
        //
        status = I8xKeyboardConnectInterrupt(KeyboardExtension);

        //
        // kb couldn't start, make sure our count of started devices reflects 
        // this
        //
        // if (!NT_SUCCESS(status)) {
        //     InterlockedDecrement(&Globals.StartedDevices);
        // }
    }
    else {
        //
        // We thought the kb was present, but it is not, make sure that started
        // devices reflects this
        //
        if (kbThoughtPresent) {
            Print(DBG_SS_ERROR, ("thought kb was present, is not!\n"));
        }
    }

    //
    // The mouse could be present but not have been initialized
    // in I8xInitializeHardware
    //
    if (DEVICE_START_SUCCESS(mouseStatus)) {
        // 
        // I8xMouseConnectInterruptAndEnable will log any errors if unsuccessful
        //
        mouseStatus = I8xMouseConnectInterruptAndEnable(
            MouseExtension,
            mouseStatus == STATUS_DEVICE_NOT_CONNECTED ? FALSE : TRUE
            );
    }

    return mouseStatus;
}

NTSTATUS
I8xMouseStartDevice(
    PPORT_MOUSE_EXTENSION MouseExtension,
    IN PCM_RESOURCE_LIST ResourceList
    )
/*++

Routine Description:

    Configures the mouse's device extension (ie allocation of pool,
    initialization of DPCs, etc).  If the mouse is the last device to start,
    it will also initialize the hardware and connect all the interrupts.

Arguments:

    MouseExtension - Mouse extesnion
    
    ResourceList - Translated resource list for this device

Return Value:

    STATUS_SUCCESSFUL if successful,

--*/
{
    ULONG                               dumpData[1];
    NTSTATUS                            status = STATUS_SUCCESS;
    PDEVICE_OBJECT                      self;
    I8042_INITIALIZE_DATA_CONTEXT       initializeDataContext;
    BOOLEAN                             tryKbInit = FALSE;

    PAGED_CODE();

    Print(DBG_SS_TRACE, ("I8xMouseStartDevice, enter\n"));

    //
    // Check to see if a mouse has been started. If so, fail this start.
    //
    if (MOUSE_INITIALIZED()) {
        Print(DBG_SS_ERROR, ("too many mice!\n"));

        //
        // This is not really necessary because the value won't ever be checked
        // in the context of seeing if all the mice were bogus, but it is
        // done so that Globals.AddedMice == # of actual started mice
        //
        InterlockedDecrement(&Globals.AddedMice);

        status =  STATUS_NO_SUCH_DEVICE;
        goto I8xMouseStartDeviceExit;
    }
    else if (MouseExtension->ConnectData.ClassService == NULL) {
        //
        // No class driver on top of us == BAD BAD BAD
        //
        // Fail the start of this device in the hope that there is another stack
        // that is correctly formed.  Another side affect of having no class 
        // driver is that the AddedMice count is not incremented for this
        // device
        //
        Print(DBG_SS_ERROR, ("Mouse started with out a service cb!\n"));
        status = STATUS_INVALID_DEVICE_STATE;
        goto I8xMouseStartDeviceExit;
    }

    //
    // Parse and store all of the resources associated with the mouse
    //
    status = I8xMouseConfiguration(MouseExtension,
                                   ResourceList
                                   );
    if (!NT_SUCCESS(status)) {
        if (I8xManuallyRemoveDevice(GET_COMMON_DATA(MouseExtension)) < 1) {
            tryKbInit = TRUE;
        }

        goto I8xMouseStartDeviceExit;
    }

    ASSERT( MOUSE_PRESENT() ); 

    Globals.MouseExtension = MouseExtension;
    self = MouseExtension->Self;

    if ((KIRQL) MouseExtension->InterruptDescriptor.u.Interrupt.Level >
        Globals.ControllerData->Configuration.InterruptSynchIrql) {
        Globals.ControllerData->Configuration.InterruptSynchIrql = 
            (KIRQL) MouseExtension->InterruptDescriptor.u.Interrupt.Level;
    }

    I8xMouseServiceParameters(&Globals.RegistryPath,
                              MouseExtension
                              );

    //
    // Allocate memory for the mouse data queue.
    //
    MouseExtension->InputData =
        ExAllocatePool(NonPagedPool,
                       MouseExtension->MouseAttributes.InputDataQueueLength
                       );

    if (!MouseExtension->InputData) {

        //
        // Could not allocate memory for the mouse data queue.
        //
        Print(DBG_SS_ERROR,
              ("I8xMouseStartDevice: Could not allocate mouse input data queue\n"
              ));

        dumpData[0] = MouseExtension->MouseAttributes.InputDataQueueLength;

        //
        // Log the error
        //
        I8xLogError(self,
                    I8042_NO_BUFFER_ALLOCATED_MOU, 
                    I8042_ERROR_VALUE_BASE + 50,
                    STATUS_INSUFFICIENT_RESOURCES, 
                    dumpData,
                    1
                    );

        status =  STATUS_INSUFFICIENT_RESOURCES;

        //
        // Mouse failed initialization, but we can try to get the keyboard
        // working if it has been initialized
        //
        tryKbInit = TRUE;

        goto I8xMouseStartDeviceExit;
    }
    else {
        MouseExtension->DataEnd =
            (PMOUSE_INPUT_DATA)
            ((PCHAR) (MouseExtension->InputData) +
            MouseExtension->MouseAttributes.InputDataQueueLength);

        //
        // Zero the mouse input data ring buffer.
        //
        RtlZeroMemory(
            MouseExtension->InputData,
            MouseExtension->MouseAttributes.InputDataQueueLength
            );

        initializeDataContext.DeviceExtension = MouseExtension;
        initializeDataContext.DeviceType = MouseDeviceType;
        I8xInitializeDataQueue(&initializeDataContext);
    }

#if MOUSE_RECORD_ISR
    if (MouseExtension->RecordHistoryFlags && MouseExtension->RecordHistoryCount) {
        IsrStateHistory = (PMOUSE_STATE_RECORD)
          ExAllocatePool(
            NonPagedPool,
            MouseExtension->RecordHistoryCount * sizeof(MOUSE_STATE_RECORD)
            );

        if (IsrStateHistory) {
            RtlZeroMemory(
               IsrStateHistory,
               MouseExtension->RecordHistoryCount * sizeof(MOUSE_STATE_RECORD)
               );

            CurrentIsrState = IsrStateHistory;
            IsrStateHistoryEnd =
                IsrStateHistory + MouseExtension->RecordHistoryCount;
        }
        else {
            MouseExtension->RecordHistoryFlags = 0x0;
            MouseExtension->RecordHistoryCount = 0;
        }
    }
#endif // MOUSE_RECORD_ISR

    SET_RECORD_STATE(MouseExtension, RECORD_INIT);

    MouseExtension->DpcInterlockMouse = -1;

    //
    // Initialize the port DPC queue to log overrun and internal
    // driver errors.
    //
    KeInitializeDpc(
        &MouseExtension->ErrorLogDpc,
        (PKDEFERRED_ROUTINE) I8042ErrorLogDpc,
        self
        );

    //
    // Initialize the ISR DPC.  The ISR DPC
    // is responsible for calling the connected class driver's callback
    // routine to process the input data queue.
    //
    KeInitializeDpc(
        &MouseExtension->MouseIsrDpc,
        (PKDEFERRED_ROUTINE) I8042MouseIsrDpc,
        self
        );
    KeInitializeDpc(
        &MouseExtension->MouseIsrDpcRetry,
        (PKDEFERRED_ROUTINE) I8042MouseIsrDpc,
        self
        );

    KeInitializeDpc(
        &MouseExtension->MouseIsrResetDpc,
        (PKDEFERRED_ROUTINE) I8xIsrResetDpc,
        MouseExtension
        );

    if (MouseExtension->InitializePolled) {
        MOUSE_INIT_POLLED(MouseExtension);        
    }
    else {
        MOUSE_INIT_INTERRUPT(MouseExtension);
    }

    I8xInitWmi(GET_COMMON_DATA(MouseExtension));

    MouseExtension->Initialized = TRUE;

    IoRegisterPlugPlayNotification(
        EventCategoryHardwareProfileChange,
        0x0,
        NULL,
        self->DriverObject,
        I8xProfileNotificationCallback,
        (PVOID) MouseExtension,
        &MouseExtension->NotificationEntry
        );
                                   
    //
    // This is not the last device to started on the i8042, defer h/w init
    // until the last device is started
    //
    if (KEYBOARD_PRESENT() && !KEYBOARD_STARTED()) {
        //
        // Delay the initialization until both have been started
        //
        Print(DBG_SS_INFO, ("skipping init until kb\n"));
    }
    else {
        status = I8xMouseInitializeHardware(Globals.KeyboardExtension,
                                            MouseExtension);
    }

I8xMouseStartDeviceExit:
    if (tryKbInit && KEYBOARD_STARTED() && !KEYBOARD_INITIALIZED()) {
        Print(DBG_SS_INFO, ("moused may failed, trying to init kb\n"));
        I8xKeyboardInitializeHardware(Globals.KeyboardExtension,
                                      MouseExtension
                                      ); 
    }

    Print(DBG_SS_INFO, 
          ("I8xMouseStartDevice %s\n",
          NT_SUCCESS(status) ? "successful" : "unsuccessful"
          ));

    Print(DBG_SS_TRACE, ("I8xMouseStartDevice exit (0x%x)\n", status));

    return status;
}


VOID
I8xMouseRemoveDevice(
    PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Removes the device.  This will only occur if the device removed itself.  
    Disconnects the interrupt, removes the synchronization flag for the keyboard
    if present, and frees any memory associated with the device.
    
Arguments:

    DeviceObject - The device object for the mouse 

Return Value:

    STATUS_SUCCESSFUL if successful,

--*/
{
    PPORT_MOUSE_EXTENSION mouseExtension = DeviceObject->DeviceExtension;

    PAGED_CODE();

    Print(DBG_PNP_INFO, ("I8xMouseRemoveDevice enter\n"));

    if (mouseExtension->Initialized) {
        if (mouseExtension->NotificationEntry) {
            IoUnregisterPlugPlayNotification(mouseExtension->NotificationEntry);
            mouseExtension->NotificationEntry = NULL;
        }
    }

    //
    // By this point, it is guaranteed that the other ISR will not be synching
    // against this one.  We can safely disconnect and free all acquire resources
    //
    if (mouseExtension->InterruptObject) {
        IoDisconnectInterrupt(mouseExtension->InterruptObject);
        mouseExtension->InterruptObject = NULL;
    }

    if (mouseExtension->InputData) {
        ExFreePool(mouseExtension->InputData);
        mouseExtension->InputData = 0;
    }

    RtlFreeUnicodeString(&mouseExtension->WheelDetectionIDs); 

    if (Globals.MouseExtension == mouseExtension) {
        CLEAR_MOUSE_PRESENT();
        Globals.MouseExtension = NULL;
    }
}

NTSTATUS
I8xProfileNotificationCallback(
    IN PHWPROFILE_CHANGE_NOTIFICATION NotificationStructure,
    PPORT_MOUSE_EXTENSION MouseExtension
    )
{
    PAGED_CODE();

    if (IsEqualGUID ((LPGUID) &(NotificationStructure->Event),
                     (LPGUID) &GUID_HWPROFILE_CHANGE_COMPLETE)) {
        Print(DBG_PNP_INFO | DBG_SS_INFO,
              ("received hw profile change complete notification\n"));

        I8X_MOUSE_INIT_COUNTERS(MouseExtension);
        SET_RECORD_STATE(Globals.MouseExtension, RECORD_HW_PROFILE_CHANGE);

        I8xResetMouse(MouseExtension);
    }
    else {
        Print(DBG_PNP_NOISE, ("received other hw profile notification\n"));
    }

    return STATUS_SUCCESS;
}

//
// Begin infrastructure for initializing the mouse via polling
//
BOOLEAN
I8xMouseEnableSynchRoutine(
    IN PPORT_MOUSE_EXTENSION    MouseExtension
    )
/*++

Routine Description:

    Writes the reset byte (if necessary to the mouse) in synch with the
    interrupt
        
Arguments:

    MouseExtension - Mouse Extension
   
Return Value:

    TRUE if the byte was written successfully

--*/
{
    NTSTATUS        status;

    if (++MouseExtension->EnableMouse.Count > 15) {
        //
        // log an error b/c we tried this many times
        //
        Print(DBG_SS_ERROR, ("called enable 16 times!\n"));
        return FALSE;
    }

    Print(DBG_STARTUP_SHUTDOWN_MASK, ("resending enable mouse!\n"));
    status = I8xMouseEnableTransmission(MouseExtension);
    return NT_SUCCESS(status);
}

VOID
I8xMouseEnableDpc(
    IN PKDPC                    Dpc,
    IN PPORT_MOUSE_EXTENSION    MouseExtension,
    IN PVOID                    SystemArg1, 
    IN PVOID                    SystemArg2
    )
/*++

Routine Description:

    DPC for making sure that the sending of the mouse enable command was
    successful.  If it has failed, try to enable the mouse again synched up to 
    the interrupt.
    
Arguments:

    Dpc - The dpc request
    
    MouseExtension - Mouse extension
    
    SystemArg1 - Unused
    
    SystemArg2 - Unused
    
Return Value:

    None. 
--*/
{
    BOOLEAN result;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemArg1);
    UNREFERENCED_PARAMETER(SystemArg2);

    ASSERT(!MouseExtension->IsKeyboard);

    if (!MouseExtension->EnableMouse.Enabled) {
        //
        // Must be called at IRQL <= DISPATCH
        //
        Print(DBG_SS_NOISE, ("cancelling due to isr receiving ACK!\n"));
        KeCancelTimer(&MouseExtension->EnableMouse.Timer);
        return;
    }

    result = KeSynchronizeExecution(
        MouseExtension->InterruptObject,
        (PKSYNCHRONIZE_ROUTINE) I8xMouseEnableSynchRoutine,
        MouseExtension
        );

    if (!result) {
        Print(DBG_SS_NOISE, ("cancelling due to enable FALSE!\n"));
        KeCancelTimer(&MouseExtension->EnableMouse.Timer);
    }
}
//
// End infrastructure for initializing the mouse via polling
//

//
// Begin infrastructure for initializing the mouse via the interrupt
//
BOOLEAN
I8xResetMouseFromDpc(
    PPORT_MOUSE_EXTENSION MouseExtension,
    MOUSE_RESET_SUBSTATE NewResetSubState
    )
{
    PIO_WORKITEM item;

    item = IoAllocateWorkItem(MouseExtension->Self);

    if (item) {
        MouseExtension->WorkerResetSubState = NewResetSubState;

        IoQueueWorkItem(item,
                        I8xMouseInitializeInterruptWorker,
                        DelayedWorkQueue,
                        item);
    }
    else {
        I8xResetMouseFailed(MouseExtension);
    }

    return (BOOLEAN) (item != NULL);
}


VOID 
I8xIsrResetDpc(
    IN PKDPC                    Dpc,
    IN PPORT_MOUSE_EXTENSION    MouseExtension,
    IN ULONG                    ResetPolled,
    IN PVOID                    SystemArg2
    )
/*++

Routine Description:

    The ISR needs to reset the mouse so it queued this DPC.  ResetPolled
    detemines if the reset and initialization are sychronous (ie polled) or
    asynchronous (using the interrupt).
    
Arguments:

    Dpc - The request
    
    MouseExtension - Mouse Extension

    ResetPolled - If non zero, should reset and initialize the mouse in a polled
                    manner   
                    
    SystemArg2 - Unused
                        
Return Value:

    None. 
--*/
{
    PIO_WORKITEM item;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemArg2);

    if (ResetPolled) {
        item = IoAllocateWorkItem(MouseExtension->Self);
    
        if (!item) {
            I8xResetMouseFailed(MouseExtension);
        }

        if (!MouseExtension->InitializePolled) {
            MOUSE_INIT_POLLED(MouseExtension);
        }

        SET_RECORD_STATE(MouseExtension, RECORD_DPC_RESET_POLLED);

        IoQueueWorkItem(item,
                        I8xMouseInitializePolledWorker,
                        DelayedWorkQueue,
                        item);
    }
    else {
        //
        // If we initialized the mouse polled, then we need to setup the data
        // structures so that we can mimic init via the interrupt
        //
        if (MouseExtension->InitializePolled) {
            MOUSE_INIT_INTERRUPT(MouseExtension);
            MouseExtension->InitializePolled = FALSE;
        }
    
        SET_RECORD_STATE(MouseExtension, RECORD_DPC_RESET);
        I8xResetMouseFromDpc(MouseExtension, IsrResetNormal);
    }
}

VOID
I8xMouseResetTimeoutProc(
    IN PKDPC                    Dpc,
    IN PPORT_MOUSE_EXTENSION    MouseExtension,
    IN PVOID                    SystemArg1, 
    IN PVOID                    SystemArg2
    )
/*++

Routine Description:

    DPC for the watch dog timer that runs when the mouse is being initialized
    via the interrupt.  The function checks upon the state of the mouse.  If
    a certain action has timed out, then next state is initiated via a write to
    the device
        
Arguments:

    Dpc - The dpc request
    
    MouseExtension - Mouse extension
    
    SystemArg1 - Unused
    
    SystemArg2 - Unused
    
Return Value:

    None. 
--*/
{
    LARGE_INTEGER           li;
    I8X_MOUSE_RESET_INFO    resetInfo;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemArg1);
    UNREFERENCED_PARAMETER(SystemArg2);

    if (MouseExtension->ResetMouse.IsrResetState == IsrResetStopResetting) {
        //
        // We have waited one second, send the reset and continue the state 
        // machine.  I8xResetMouse will set the state correctly and set all the
        // vars to the appropriate states.
        //
        Print(DBG_SS_ERROR | DBG_SS_INFO, ("Paused one second for reset\n"));
        I8xResetMouseFromDpc(MouseExtension, KeepOldSubState);
        return;
    }
    else if (MouseExtension->ResetMouse.IsrResetState == MouseResetFailed) {
        //
        // We have tried to repeatedly reset the mouse, but have failed.  We
        // have already taken care of this in I8xResetMouseFailed.
        //
        return;
    }

    resetInfo.MouseExtension = MouseExtension;
    resetInfo.InternalResetState = InternalContinueTimer;

    if (KeSynchronizeExecution(MouseExtension->InterruptObject,
                               (PKSYNCHRONIZE_ROUTINE) I8xMouseResetSynchRoutine,
                               &resetInfo)) {

        switch (resetInfo.InternalResetState) {
        case InternalContinueTimer:

            //
            // Delay for 1.5 second
            //
            li = RtlConvertLongToLargeInteger(-MOUSE_RESET_TIMEOUT);
    
            KeSetTimer(&MouseExtension->ResetMouse.Timer,
                       li,
                       &MouseExtension->ResetMouse.Dpc
                       );

            Print(DBG_SS_NOISE, ("Requeueing timer\n"));
            break;

        case InternalMouseReset:
            //
            // If we have had too many resets, I8xResetMouse will take of the 
            // cleanup
            //
            I8xResetMouseFromDpc(MouseExtension, KeepOldSubState);
            break;

        case InternalPauseOneSec: 
            //
            // Delay for 1 second, we will handle this case up above
            //
            li = RtlConvertLongToLargeInteger(-1 * 1000 * 1000 * 10);

            KeSetTimer(&MouseExtension->ResetMouse.Timer,
                       li,
                       &MouseExtension->ResetMouse.Dpc
                       );
        
            break;
        }
    }
}

BOOLEAN
I8xMouseResetSynchRoutine(
    PI8X_MOUSE_RESET_INFO ResetInfo 
    )
/*++

Routine Description:

    Synchronized routine with the mouse interrupt to check upon the state of
    the mouse while it is being reset.  Certain situations arise on a
    variety of platforms (lost bytes, numerous resend requests).  These are
    taken care of here.
    
Arguments:

    ResetInfo - struct to be filled in about the current state of the mouse
    
Return Value:

    TRUE if the watchdog timer should keep on checking the state of the device
    FALSE if the watchdog timer should cease because the device has been 
        initialized correctly.
--*/
{
    LARGE_INTEGER           tickNow, tickDelta, oneSecond, threeSeconds;
    PPORT_MOUSE_EXTENSION   mouseExtension; 

    mouseExtension = ResetInfo->MouseExtension;

    Print(DBG_SS_NOISE, ("synch routine enter\n"));

    if (mouseExtension->InputState != MouseResetting) {
        return FALSE;
    }
    
    //
    // PreviousTick is set whenever the last byte was received
    //
    KeQueryTickCount(&tickNow);
    tickDelta.QuadPart =
            tickNow.QuadPart - mouseExtension->PreviousTick.QuadPart;

    //
    // convert one second into ticks
    //
    oneSecond = RtlConvertLongToLargeInteger(1000 * 1000 * 10);
    oneSecond.QuadPart /= KeQueryTimeIncrement();

    switch (mouseExtension->InputResetSubState) {
    case ExpectingReset: 
        switch (mouseExtension->LastByteReceived) {
        case 0x00:
            if (tickDelta.QuadPart > oneSecond.QuadPart) {
                //
                // Didn't get any reset response, try another reset
                //
                ResetInfo->InternalResetState = InternalMouseReset; 
                Print(DBG_SS_ERROR | DBG_SS_INFO,
                      ("RESET command never responded, retrying\n"));
            }
            break;

        case ACKNOWLEDGE:
            if (tickDelta.QuadPart > oneSecond.QuadPart) {
                //
                // Assume that the 0xAA was eaten, just setup the state
                // machine to go to the next state after reset
                //
                I8X_WRITE_CMD_TO_MOUSE();
                I8X_MOUSE_COMMAND( GET_DEVICE_ID );
        
                mouseExtension->InputResetSubState = ExpectingGetDeviceIdACK;
                mouseExtension->LastByteReceived = 0x00;

                Print(DBG_SS_ERROR | DBG_SS_INFO,
                      ("jump starting state machine\n"));
            }
            break;

        case RESEND:

            if (mouseExtension->ResendCount >= MOUSE_RESET_RESENDS_MAX) {
                //
                // Stop the ISR state machine from running and make sure
                // the timer is requeued
                //
                ResetInfo->InternalResetState = InternalPauseOneSec;
                mouseExtension->ResetMouse.IsrResetState =
                    IsrResetStopResetting;
            }
            else if (tickDelta.QuadPart > oneSecond.QuadPart) {
                //
                // Some machines request a resend (which is honored), 
                // but then don't respond again.  Since we can't wait 
                // +0.5 secs in the ISR, we take care of this case here
                //
                ResetInfo->InternalResetState = InternalMouseReset; 
                Print(DBG_SS_ERROR | DBG_SS_INFO,
                      ("resending RESET command\n"));
            }

        default:
            Print(DBG_SS_ERROR, ("unclassified response in ExpectingReset\n"));
            goto CheckForThreeSecondSilence;
        }
        break;

    //
    // These states is the state machine waiting for a sequence of bytes.  In
    //  each case, if we don't get what we want in the time allotted, goto the 
    //  next state
    //
    case ExpectingReadMouseStatusByte1:
    case ExpectingReadMouseStatusByte2:
    case ExpectingReadMouseStatusByte3:
        if (tickDelta.QuadPart > oneSecond.QuadPart) {
            I8X_WRITE_CMD_TO_MOUSE();
            I8X_MOUSE_COMMAND( POST_BUTTONDETECT_COMMAND );

            mouseExtension->InputResetSubState =
                POST_BUTTONDETECT_COMMAND_SUBSTATE; 
        }
        break;

    case ExpectingPnpIdByte1:
    case ExpectingPnpIdByte2:
    case ExpectingPnpIdByte3:
    case ExpectingPnpIdByte4:
    case ExpectingPnpIdByte5:
    case ExpectingPnpIdByte6:
    case ExpectingPnpIdByte7:

    case ExpectingLegacyPnpIdByte2_Make:
    case ExpectingLegacyPnpIdByte2_Break:
    case ExpectingLegacyPnpIdByte3_Make:
    case ExpectingLegacyPnpIdByte3_Break:
    case ExpectingLegacyPnpIdByte4_Make:
    case ExpectingLegacyPnpIdByte4_Break:
    case ExpectingLegacyPnpIdByte5_Make:
    case ExpectingLegacyPnpIdByte5_Break:
    case ExpectingLegacyPnpIdByte6_Make:
    case ExpectingLegacyPnpIdByte6_Break:
    case ExpectingLegacyPnpIdByte7_Make:
    case ExpectingLegacyPnpIdByte7_Break:

        if (tickDelta.LowPart >= mouseExtension->WheelDetectionTimeout ||
            tickDelta.HighPart != 0) {

            //
            // Trying to acquire the mouse wheel ID failed, just skip it!
            //
            mouseExtension->EnableWheelDetection = 0;
            I8X_WRITE_CMD_TO_MOUSE();
            I8X_MOUSE_COMMAND( POST_WHEEL_DETECT_COMMAND );
    
            //
            // Best possible next state
            //
            mouseExtension->InputResetSubState = 
                POST_WHEEL_DETECT_COMMAND_SUBSTATE;
        }
        break;
    
    case QueueingMouseReset:
    case QueueingMousePolledReset:
        //
        // A (polled) reset is somewhere in the works, don't collide with it
        //
        return FALSE;

    default:
CheckForThreeSecondSilence:
        threeSeconds = RtlConvertLongToLargeInteger(1000 * 1000 * 30);
        threeSeconds.QuadPart /= KeQueryTimeIncrement();

        if (tickDelta.QuadPart > threeSeconds.QuadPart) {
            Print(DBG_SS_ERROR, ("No response from mouse in ~3 seconds\n"));
            ResetInfo->InternalResetState = InternalMouseReset; 
        }
        break; 
    }

    return TRUE;
}

VOID
I8xMouseInitializeInterruptWorker(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_WORKITEM   Item 
    )
{
    PPORT_MOUSE_EXTENSION extension;

    PAGED_CODE();

    extension = (PPORT_MOUSE_EXTENSION) DeviceObject->DeviceExtension;

    if (extension->WorkerResetSubState != KeepOldSubState) {
        extension->ResetMouse.IsrResetState = extension->WorkerResetSubState;
    }

    I8xResetMouse(extension);
    IoFreeWorkItem(Item);
}

VOID
I8xMouseInitializePolledWorker(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_WORKITEM   Item 
    )
/*++

Routine Description:

    Queued work item to reset the mouse is a polled manner.  Turns off the
    interrupts and attempts to synchronously reset and initialize the mouse then
    turn the interrupts back on.
    
Arguments:

    Item - work item containing the mouse extension 
    
Return Value:

    None. 
--*/
{
    NTSTATUS                status;
    PIRP                    irp;
    PPORT_MOUSE_EXTENSION   mouseExtension;
    DEVICE_POWER_STATE      keyboardDeviceState;
    KIRQL                   oldIrql;

    Print(DBG_SS_ERROR | DBG_SS_INFO, ("forcing polled init!!!\n"));

    //
    // Force the keyboard to ignore interrupts
    //
    if (KEYBOARD_PRESENT() && Globals.KeyboardExtension) {
        keyboardDeviceState = Globals.KeyboardExtension->PowerState;
        Globals.KeyboardExtension->PowerState = PowerDeviceD3;
    }

    I8xToggleInterrupts(FALSE);

    mouseExtension = (PPORT_MOUSE_EXTENSION) DeviceObject->DeviceExtension;
    status = I8xInitializeMouse(mouseExtension);

    // 
    // Turn the interrupts on no matter what the results, hopefully the kb is still
    // there and functional if the mouse is dead
    // 
    I8xToggleInterrupts(TRUE);

    //
    // Undo the force from above
    //
    if (KEYBOARD_PRESENT() && Globals.KeyboardExtension) {
        Globals.KeyboardExtension->PowerState = keyboardDeviceState;
    }

    if (NT_SUCCESS(status) && MOUSE_PRESENT()) {
        status = I8xMouseEnableTransmission(mouseExtension);
        if (!NT_SUCCESS(status)) {
            goto init_failure;
        }

        Print(DBG_SS_ERROR | DBG_SS_INFO, ("polled init succeeded\n"));

        I8xFinishResetRequest(mouseExtension,
                              FALSE,            // success
                              TRUE,             // raise to DISPATCH 
                              FALSE);           // no timer to cancel
    }
    else {
init_failure:
        Print(DBG_SS_ERROR | DBG_SS_INFO,
              ("polled init failed (0x%x)\n", status));
        I8xResetMouseFailed(mouseExtension);
    }

    IoFreeWorkItem(Item);
}

//
// End infrastructure for initializing the mouse via the interrupt
//

BOOLEAN
I8xVerifyMousePnPID(
    PPORT_MOUSE_EXTENSION   MouseExtension,
    PWSTR                   MouseID
    )
/*++

Routine Description:

    Verifies that the MouseID reported by the mouse is valid
    
Arguments:

    MouseExtension  - Mouse extension
    
    MouseID - ID reported by the mouse 
    
Return Value:

    None. 
--*/
{
    PWSTR       currentString = NULL;
    ULONG       length;
    WCHAR       szDefaultIDs[] = {
        L"MSH0002\0"   // original wheel
        L"MSH0005\0"   // trackball
        L"MSH001F\0"   // shiny gray optioal 5 btn mouse
        L"MSH0020\0"   // intellimouse with intellieye
        L"MSH002A\0"   // 2 tone optical 5 btn mouse (intellimouse web)
        L"MSH0030\0"   // trackball optical 
        L"MSH0031\0"   // trackball explorer
        L"MSH003A\0"   // intellimouse optical
        L"MSH0041\0"   // wheel mouse optical
        L"MSH0043\0"   // 3 button wheel 
        L"MSH0044\0"   // intellimouse optical 3.0
        L"\0" };

    currentString = MouseExtension->WheelDetectionIDs.Buffer;

    //
    // If the mouse got far enough to report an ID and we don't have one in
    // memory, assume it is a wheel mouse id 
    //
    if (currentString != NULL) {
        while (*currentString != L'\0') {
            if (wcscmp(currentString, MouseID) == 0) {
                return TRUE;
            }

            //
            // Increment to the next string (length of current string plus NULL)
            //
            currentString += wcslen(currentString) + 1;
        }
    }

    currentString = szDefaultIDs; 

    if (currentString != NULL) {
        while (*currentString != L'\0') {
            if (wcscmp(currentString, MouseID) == 0) {
                return TRUE;
            }

            //
            // Increment to the next string (length of current string plus NULL)
            //
            currentString += wcslen(currentString) + 1;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\pnpi8042\sysbtn.c ===
/*++

Copyright (c) 1997-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    power.c

Abstract:

    This module contains plug & play code for the I8042 Keyboard Filter Driver.

Environment:

    Kernel mode.

Revision History:

--*/

#include "i8042prt.h"
#include "i8042log.h"
#include <initguid.h>
#include <poclass.h>

VOID
I8xUpdateSysButtonCaps(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PI8X_KEYBOARD_WORK_ITEM Item
    );

VOID 
I8xCompleteSysButtonEventWorker(
    IN PDEVICE_OBJECT DeviceObject,
    IN PI8X_KEYBOARD_WORK_ITEM Item
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, I8xKeyboardGetSysButtonCaps)
#pragma alloc_text(PAGE, I8xUpdateSysButtonCaps)

#if DELAY_SYSBUTTON_COMPLETION
#pragma alloc_text(PAGE, I8xCompleteSysButtonEventWorker)
#endif

#endif

VOID
I8xCompleteSysButtonIrp(
    PIRP Irp,
    ULONG Event,
    NTSTATUS Status
    )
{
    Print(DBG_POWER_NOISE,
          ("completing sys button irp 0x%x, event %d, status 0x%x\n",
          Irp, Event, Status));

    ASSERT(IoSetCancelRoutine(Irp, NULL) == NULL);

    *(PULONG) Irp->AssociatedIrp.SystemBuffer = Event;
    Irp->IoStatus.Information = sizeof(Event); 
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
}

NTSTATUS
I8xKeyboardGetSysButtonCaps(
    PPORT_KEYBOARD_EXTENSION KeyboardExtension,
    PIRP Irp
    )
{
    PIO_STACK_LOCATION  stack;
    NTSTATUS            status;
    ULONG               caps, size;

    PAGED_CODE();

    stack = IoGetCurrentIrpStackLocation(Irp);
    size = 0x0; 

    if (stack->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG)) {
        Print(DBG_POWER_ERROR, ("get caps, buffer too small\n"));
        status = STATUS_INVALID_BUFFER_SIZE; 
    }
    else {

        caps = 0x0;
        size = sizeof(caps);

        if (KeyboardExtension->PowerCaps & I8042_POWER_SYS_BUTTON) {
            Print(DBG_POWER_NOISE | DBG_IOCTL_NOISE,
                  ("get cap:  reporting power button\n"));
            caps |= SYS_BUTTON_POWER;
        }
        if (KeyboardExtension->PowerCaps & I8042_SLEEP_SYS_BUTTON) {
            Print(DBG_POWER_NOISE | DBG_IOCTL_NOISE,
                  ("get cap:  reporting sleep button\n"));
            caps |= SYS_BUTTON_SLEEP;
        }
        if (KeyboardExtension->PowerCaps & I8042_WAKE_SYS_BUTTON) {
            Print(DBG_POWER_NOISE | DBG_IOCTL_NOISE,
                  ("get cap:  reporting wake button\n"));
            caps |= SYS_BUTTON_WAKE;
        }

        // can't do this b/c SYS_BUTTON_WAKE is == 0x0
        // ASSERT(caps != 0x0);
        *(PULONG) Irp->AssociatedIrp.SystemBuffer = caps;
        status = STATUS_SUCCESS;
    }

    Irp->IoStatus.Information = size;
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

#if DELAY_SYSBUTTON_COMPLETION
VOID 
I8xCompleteSysButtonEventWorker(
    IN PDEVICE_OBJECT DeviceObject,
    IN PI8X_KEYBOARD_WORK_ITEM Item
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    //
    // Check to see if, in the short time that we queued the work item and it 
    // firing, that the irp has been cancelled
    //
    if (Item->Irp->Cancel) {
        status = STATUS_CANCELLED;
        Item->MakeCode = 0x0;
    }

    I8xCompleteSysButtonIrp(Item->Irp, Item->MakeCode, status);
    IoFreeWorkItem(Item->Item);
    ExFreePool(Item);
}
#endif

NTSTATUS 
I8xKeyboardGetSysButtonEvent(
    PPORT_KEYBOARD_EXTENSION KeyboardExtension,
    PIRP Irp
    )
{
    PIO_STACK_LOCATION  stack;
    PIRP                oldIrp, pendingIrp;
    NTSTATUS            status;
    ULONG               event = 0x0;
    KIRQL               irql;

    stack = IoGetCurrentIrpStackLocation(Irp);

    if (stack->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG)) {
        Print(DBG_POWER_ERROR, ("get event, buffer too small\n"));
        status = STATUS_INVALID_BUFFER_SIZE;

        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0x0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return status;
    }
    else if (KeyboardExtension->PowerEvent) {
#if DELAY_SYSBUTTON_COMPLETION
        PI8X_KEYBOARD_WORK_ITEM item;

        status = STATUS_INSUFFICIENT_RESOURCES;

        item = (PI8X_KEYBOARD_WORK_ITEM)
            ExAllocatePool(NonPagedPool, sizeof(I8X_KEYBOARD_WORK_ITEM));

        if (item) {
            item->Item = IoAllocateWorkItem(KeyboardExtension->Self);
            if (item->Item) {
                Print(DBG_POWER_NOISE, ("Queueing work item to complete event\n"));

                item->MakeCode = KeyboardExtension->PowerEvent;
                item->Irp = Irp;

                //
                // No need to set a cancel routine b/c we will always be
                // completing the irp in very short period of time
                //
                IoMarkIrpPending(Irp);

                IoQueueWorkItem(item->Item,
                                I8xCompleteSysButtonEventWorker,
                                DelayedWorkQueue,
                                item);

                status = STATUS_PENDING;
            }
            else {
                ExFreePool(item);
            }
        }

#else  // DELAY_SYSBUTTON_COMPLETION

        Print(DBG_POWER_INFO, ("completing event immediately\n"));
        event = KeyboardExtension->PowerEvent;
        status = STATUS_SUCCESS;

#endif // DELAY_SYSBUTTON_COMPLETION

        KeyboardExtension->PowerEvent = 0x0;
    }
    else {
        //
        // See if the pending sys button is NULL.  If it is, then Irp will 
        // put into the slot
        //
        KeAcquireSpinLock(&KeyboardExtension->SysButtonSpinLock, &irql);

        if (KeyboardExtension->SysButtonEventIrp == NULL) {
            Print(DBG_POWER_INFO, ("pending sys button event\n"));

            KeyboardExtension->SysButtonEventIrp = Irp;
            IoMarkIrpPending(Irp);
            IoSetCancelRoutine(Irp, I8xSysButtonCancelRoutine);

            status = STATUS_PENDING;

            // 
            // We don't care if Irp->Cancel is TRUE.  If it is, then the cancel
            // routine will complete the irp an everything will be all set.
            // Since status == STATUS_PENDING, nobody in this code path is going
            // to touch the irp
            //
        }
        else {
            Print(DBG_POWER_ERROR | DBG_POWER_INFO,
                  ("got 1+ get sys button event requests!\n"));
            status = STATUS_UNSUCCESSFUL;
        }

        KeReleaseSpinLock(&KeyboardExtension->SysButtonSpinLock, irql);
    }

    if (status != STATUS_PENDING) {
        Print(DBG_POWER_NOISE, 
              ("completing get sys power event with 0x%x\n", status));
        I8xCompleteSysButtonIrp(Irp, event, status);
    }

    return status;
}

VOID
I8xKeyboardSysButtonEventDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN SYS_BUTTON_ACTION Action, 
    IN ULONG MakeCode 
    )
{
    PPORT_KEYBOARD_EXTENSION kbExtension = DeviceObject->DeviceExtension;
    PI8X_KEYBOARD_WORK_ITEM item;
    KIRQL irql;
    ULONG event;
    PIRP irp;

    UNREFERENCED_PARAMETER(Dpc);

    ASSERT(Action != NoAction);

    //
    // Check to see if we need to complete the IRP or actually register for a 
    // notification
    //
    switch (MakeCode) {
    case KEYBOARD_POWER_CODE: event = SYS_BUTTON_POWER; break; 
    case KEYBOARD_SLEEP_CODE: event = SYS_BUTTON_SLEEP; break;
    case KEYBOARD_WAKE_CODE:  event = SYS_BUTTON_WAKE;  break;
    default:                  event = 0x0;              TRAP();
    }

    if (Action == SendAction) {
    
        Print(DBG_POWER_INFO, ("button event complete (0x%x)\n", event));

        KeAcquireSpinLock(&kbExtension->SysButtonSpinLock, &irql);

        irp = kbExtension->SysButtonEventIrp;
        kbExtension->SysButtonEventIrp = NULL;

        if (irp && (irp->Cancel || IoSetCancelRoutine(irp, NULL) == NULL)) {
            irp = NULL;
        }

        KeReleaseSpinLock(&kbExtension->SysButtonSpinLock, irql);

        if (irp) {
            I8xCompleteSysButtonIrp(irp, event, STATUS_SUCCESS);
        }
    }
    else {
        ASSERT(Action == UpdateAction);

        //
        // Queue the work item.  We need to write the value to the registry and
        // set the device interface
        //
        item = (PI8X_KEYBOARD_WORK_ITEM)
            ExAllocatePool(NonPagedPool, sizeof(I8X_KEYBOARD_WORK_ITEM));

        if (item) {
            item->Item = IoAllocateWorkItem(DeviceObject);
            if (item->Item) {
                Print(DBG_POWER_NOISE, ("Queueing work item to update caps\n"));

                //
                // Save this off so when we get the IOCTL, we can complete it immediately
                //
                kbExtension->PowerEvent |= (UCHAR) event;
                item->MakeCode = MakeCode;

                IoQueueWorkItem(item->Item,
                                I8xUpdateSysButtonCaps,
                                DelayedWorkQueue,
                                item);
            }
            else {
                ExFreePool(item);
            }
        }
    }
}

VOID
I8xSysButtonCancelRoutine( 
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PPORT_KEYBOARD_EXTENSION kbExtension = DeviceObject->DeviceExtension;
    PIRP irp;
    KIRQL irql;

    Print(DBG_POWER_TRACE, ("SysButtonCancelRoutine\n"));

    KeAcquireSpinLock(&kbExtension->SysButtonSpinLock, &irql);

    irp = kbExtension->SysButtonEventIrp;
    kbExtension->SysButtonEventIrp = NULL;
    Print(DBG_POWER_INFO, ("pending event irp = 0x%x\n", irp));

    KeReleaseSpinLock(&kbExtension->SysButtonSpinLock, irql);

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    Irp->IoStatus.Information = 0x0;
    Irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
}

PIRP                  
I8xUpdateSysButtonCapsGetPendedIrp(
    PPORT_KEYBOARD_EXTENSION KeyboardExtension
    )
{
    KIRQL irql;
    PIRP irp;

    KeAcquireSpinLock(&KeyboardExtension->SysButtonSpinLock, &irql);
                      
    irp = KeyboardExtension->SysButtonEventIrp;
    KeyboardExtension->SysButtonEventIrp = NULL;

    if (irp && IoSetCancelRoutine(irp, NULL) == NULL) {
        //
        // Cancel routine take care of the irp
        //
        irp = NULL;
    }

    KeReleaseSpinLock(&KeyboardExtension->SysButtonSpinLock, irql);

    return irp;
}

VOID
I8xUpdateSysButtonCaps(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PI8X_KEYBOARD_WORK_ITEM Item
    )
{
    UNICODE_STRING strPowerCaps;
    PPORT_KEYBOARD_EXTENSION kbExtension;
    HANDLE devInstRegKey;
    ULONG newPowerCaps;
    NTSTATUS status = STATUS_SUCCESS;
    PIRP irp;

    PAGED_CODE();

    kbExtension = (PPORT_KEYBOARD_EXTENSION) DeviceObject->DeviceExtension;

    if (Item->MakeCode != 0x0) {
        if ((NT_SUCCESS(IoOpenDeviceRegistryKey(kbExtension->PDO,
                                                PLUGPLAY_REGKEY_DEVICE,
                                                STANDARD_RIGHTS_ALL,
                                                &devInstRegKey)))) {
            //
            // Update the power caps 
            //
            switch (Item->MakeCode) {
            case KEYBOARD_POWER_CODE:
                Print(DBG_POWER_NOISE, ("Adding Power Sys Button cap\n"));
                kbExtension->PowerCaps |= I8042_POWER_SYS_BUTTON;
                break;
    
            case KEYBOARD_SLEEP_CODE:
                Print(DBG_POWER_NOISE, ("Adding Power Sleep Button cap\n"));
                kbExtension->PowerCaps |= I8042_SLEEP_SYS_BUTTON;
                break;
    
            case KEYBOARD_WAKE_CODE:
                Print(DBG_POWER_NOISE, ("Adding Power Wake Button cap\n"));
                kbExtension->PowerCaps |= I8042_WAKE_SYS_BUTTON;
                break;
    
            default:
                Print(DBG_POWER_ERROR,
                      ("Adding power cap, unknown makecode 0x%x\n",
                      (ULONG) Item->MakeCode
                      ));
                TRAP(); 
            }
    
            RtlInitUnicodeString(&strPowerCaps,
                                 pwPowerCaps
                                 );
    
            newPowerCaps = kbExtension->PowerCaps;
    
            ZwSetValueKey(devInstRegKey,
                          &strPowerCaps,
                          0,
                          REG_DWORD,
                          &newPowerCaps,
                          sizeof(newPowerCaps)
                          );
    
            ZwClose(devInstRegKey);
    
            if (!kbExtension->SysButtonInterfaceName.Buffer) {
                //
                // No prev caps so we must register and turn on the interface now
                //
                ASSERT(kbExtension->SysButtonEventIrp == NULL);
    
                status = I8xRegisterDeviceInterface(kbExtension->PDO,
                                                    &GUID_DEVICE_SYS_BUTTON,
                                                    &kbExtension->SysButtonInterfaceName
                                                    );
    
                Print(DBG_POWER_NOISE,
                      ("Registering Interface for 1st time (0x%x)\n", status));
            }
            else {
                //
                // We better have a pending event irp already then!
                //
                Print(DBG_POWER_INFO, ("failing old sys button event irp\n"));
                
                if ((irp = I8xUpdateSysButtonCapsGetPendedIrp(kbExtension))) {
                    //
                    // Complete the old irp, the PO subsystem will then 
                    // remove this system button. 
                    //
                    I8xCompleteSysButtonIrp(irp, 0x0, STATUS_DEVICE_NOT_CONNECTED);
                }

                //
                // We need to reregister with the PO subsystem so that it will 
                // requery this interface
                //
                IoSetDeviceInterfaceState(&kbExtension->SysButtonInterfaceName,
                                          FALSE);

                IoSetDeviceInterfaceState(&kbExtension->SysButtonInterfaceName,
                                          TRUE);
            }
        }
        else {
            Print(DBG_POWER_ERROR, ("could not open devnode key!\n"));
        }
    }
    else {
        //
        // Must report the device interface
        //
    }

    IoFreeWorkItem(Item->Item);
    ExFreePool(Item);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\pnpi8042\sources.inc ===
TARGETNAME=i8042prt
TARGETPATH=obj
TARGETTYPE=DRIVER

INCLUDES=..\inc;..\..\inc;..\i386

W32_SB=1

SOURCES=..\i8042log.mc \
        ..\i8042prt.rc \
        ..\i8042cmn.c  \
        ..\i8042dep.c  \
        ..\i8042str.c  \
        ..\kbdcmn.c    \
        ..\kbddep.c    \
        ..\kbdpnp.c    \
        ..\moucmn.c    \
        ..\moudep.c    \
        ..\moupnp.c    \
        ..\pnp.c       \
        ..\sysbtn.c    \
        ..\wmi.c       \
        ..\hook.c

MSC_WARNING_LEVEL=/W3 /WX

# for .mc files
MC_SOURCEDIR=$(O)

# for generated headers
PASS0_HEADERDIR=$(O)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\sermouse\cseries.c ===
/*++

Copyright (c) 1993  Microsoft Corporation
Copyright (c) 1993  Logitech Inc.

Module Name:

    cseries.c

Abstract:

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/

//
// Includes.
//

#include "ntddk.h"
#include "sermouse.h"
#include "cseries.h"
#include "debug.h"

//
// Use the alloc_text pragma to specify the driver initialization routines
// (they can be paged out).
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,CSerPowerUp)
#pragma alloc_text(INIT,CSerSetReportRate)
#pragma alloc_text(INIT,CSerSetBaudRate)
#pragma alloc_text(INIT,CSerSetProtocol)
#pragma alloc_text(INIT,CSerDetect)
#endif // ALLOC_PRAGMA

//
// Constants.
//

//
// The status command sent to the mouse.
//

#define CSER_STATUS_COMMAND 's'

//
// The query number of mouse buttons command sent to the mouse.
//

#define CSER_QUERY_BUTTONS_COMMAND 'k'

//
// Status report from a CSeries mouse.
//

#define CSER_STATUS 0x4F

//
// Timeout value for the status returned by a CSeries mouse.
//

#define CSER_STATUS_DELAY 50

//
// Time (in milliseconds) needed by the mouse to adapt to a new baud rate.
//

#define CSER_BAUDRATE_DELAY 2

//
// Default baud rate and report rate.
//

#define CSER_DEFAULT_BAUDRATE   1200
#define CSER_DEFAULT_REPORTRATE 150

//
// Button/status definitions.
//

#define CSER_SYNCH_BIT     0x80

#define CSER_BUTTON_LEFT   0x04
#define CSER_BUTTON_RIGHT  0x01
#define CSER_BUTTON_MIDDLE 0x02

#define CSER_BUTTON_LEFT_SR   2
#define CSER_BUTTON_RIGHT_SL  1
#define CSER_BUTTON_MIDDLE_SL 1

#define SIGN_X 0x10
#define SIGN_Y 0x08

//
// Macros.
//

#define sizeofel(x) (sizeof(x)/sizeof(*x))

//
// Type definitions.
//

typedef struct _REPORT_RATE {
    CHAR Command;
    UCHAR ReportRate;
} REPORT_RATE;

typedef struct _PROTOCOL {
    CHAR Command;
    UCHAR LineCtrl;
    PPROTOCOL_HANDLER Handler;
} PROTOCOL;

typedef struct _CSER_BAUDRATE {
    CHAR *Command;
    ULONG BaudRate;
} CSER_BAUDRATE;

//
// Globals.
//

//
//  The baud rate at which we try to detect a mouse.
//

static ULONG BaudRateDetect[] = { 1200, 2400, 4800, 9600 };

//
// This list is indexed by protocol values PROTOCOL_*.
//

PROTOCOL Protocol[] = {
    {'S',
    ACE_8BW | ACE_PEN | ACE_1SB,
    CSerHandlerMM
    },
    {'T',
    ACE_8BW | ACE_1SB,
    NULL
    },
    {'U',
    ACE_8BW | ACE_1SB,
    NULL
    },
    {'V',
    ACE_7BW | ACE_1SB,
    NULL
    },
    {'B',
    ACE_7BW | ACE_PEN | ACE_EPS | ACE_1SB,
    NULL
    },
    {'A',
    ACE_7BW | ACE_PEN | ACE_EPS | ACE_1SB,
    NULL
    }
};

static REPORT_RATE ReportRateTable[] = {
        {'D', 0 },
        {'J', 10},
        {'K', 20},
        {'L', 35},
        {'R', 50},
        {'M', 70},
        {'Q', 100},
        {'N', 150},
        {'O', 151}      // Continuous
};
static CSER_BAUDRATE CserBaudRateTable[] = {
    { "*n", 1200 },
    { "*o", 2400 },
    { "*p", 4800 },
    { "*q", 9600 }
};


BOOLEAN
CSerPowerUp(
    PUCHAR Port
    )
/*++

Routine Description:

    Powers up the mouse by making the RTS and DTR active.

Arguments:

    Port - Pointer to the serial port.

Return Value:

    TRUE.

--*/
{
    UCHAR lineCtrl;
    SerMouPrint((2, "SERMOUSE-PowerUp: Enter\n"));

    //
    // Set both RTS and DTR lines to an active state.
    //

    lineCtrl = UARTSetModemCtrl(Port, ACE_DTR | ACE_RTS);
    SerMouPrint((1, "SERMOUSE-Initial line control: %#x\n", lineCtrl));

    //
    // If the lines are high, the power is on for at least 500 ms due to the
    // MSeries detection.
    //

    if ((lineCtrl & (ACE_DTR | ACE_RTS)) != (ACE_DTR | ACE_RTS)) {
        SerMouPrint((1, "SERMOUSE-Powering up\n"));

        //
        // Wait CSER_POWER_UP milliseconds for the mouse to power up 
        // correctly.
        //

        KeStallExecutionProcessor(CSER_POWER_UP * MS_TO_MICROSECONDS);
    }

    SerMouPrint((2, "SERMOUSE-PowerUp: Exit\n"));

    return TRUE;
}


VOID
CSerSetReportRate(
    PUCHAR Port,
    UCHAR ReportRate
    )
/*++

Routine Description:

    Set the mouse report rate. This can range from 0 (prompt mode) to 
    continuous report rate.

Arguments:

    Port - Pointer to serial port.

    ReportRate - The desired report rate.

Return Value:

    None.

--*/
{
    LONG count;

    SerMouPrint((2, "SERMOUSE-CSerSetReportRate: Enter\n"));

    for (count = sizeofel(ReportRateTable) - 1; count >= 0; count--) {

        //
        // Get the character to send from the table.
        //

        if (ReportRate >= ReportRateTable[count].ReportRate) {

            //
            // Set the baud rate.
            //

            SerMouPrint((
                3, 
                "SERMOUSE-New ReportRate: %u\n", ReportRateTable[count].ReportRate
                ));

            UARTWriteChar(Port, ReportRateTable[count].Command);
            break;
        }
    }
    SerMouPrint((2, "SERMOUSE-CSerSetReportRate: Exit\n"));

    return;
}


VOID
CSerSetBaudRate(
    PUCHAR Port,
    ULONG BaudRate,
    ULONG BaudClock
    )
/*++

Routine Description:

    Set the new mouse baud rate. This will change the serial port baud rate.

Arguments:

    Port - Pointer to the serial port.

    BaudRate - Desired baud rate.

    BaudClock - The external frequency driving the serial chip.

Return Value:

    None.

--*/
{
    LONG count;

    SerMouPrint((2, "SERMOUSE-CSerSetBaudRate: Enter\n"));

    //
    // Before we mess with the baud rate, put the mouse in prompt mode.
    //

    CSerSetReportRate(Port, 0);

    for (count = sizeofel(CserBaudRateTable) - 1; count >= 0; count--) {
        if (BaudRate >= CserBaudRateTable[count].BaudRate) {

            //
            // Set the baud rate.
            //

            UARTWriteString(Port, CserBaudRateTable[count].Command);
            while(!UARTIsTransmitEmpty(Port)) /* Do nothing */;
            UARTSetBaudRate(Port, CserBaudRateTable[count].BaudRate, BaudClock);

            //
            // Delay to allow the UART and the mouse to synchronize 
            // correctly.  
            //

            KeStallExecutionProcessor(CSER_BAUDRATE_DELAY * MS_TO_MICROSECONDS);
            break;
        }
    }

    SerMouPrint((2, "SERMOUSE-CSerSetBaudRate: Exit\n"));

    return;
}


PPROTOCOL_HANDLER
CSerSetProtocol(
    PUCHAR Port,
    UCHAR NewProtocol
    )
/*++

Routine Description:

    Change the mouse protocol.

    Note: Not all the protocols are implemented in this driver.

Arguments:

    Port - Pointer to the serial port.


Return Value:

    Address of the protocol handler function. See the interrupt service 
    routine.

--*/
{
    SerMouPrint((2, "SERMOUSE-CSerSetProtocol: Enter\n"));

    ASSERT(NewProtocol < CSER_PROTOCOL_MAX);

    //
    // Set the protocol.
    //

    UARTWriteChar(Port, Protocol[NewProtocol].Command);
    UARTSetLineCtrl(Port, Protocol[NewProtocol].LineCtrl);
    SerMouPrint((2, "SERMOUSE-NewProtocol: %u\n", NewProtocol & 0xFF));


    SerMouPrint((2, "SERMOUSE-CSerSetProtocol: Exit\n"));

    return Protocol[NewProtocol].Handler;
}


BOOLEAN
CSerDetect(
    PUCHAR Port,
    ULONG BaudClock,
    PULONG HardwareButtons
    )
/*++

Routine Description:

    Detection of a CSeries type mouse. The main steps are:

    - Power up the mouse.
    - Cycle through the available baud rates and try to get an answer 
      from the mouse.

    At the end of the routine, a default baud rate and report rate are set.

Arguments:

    Port - Pointer to the serial port.

    BaudClock - The external frequency driving the serial chip.

    HardwareButtons - Returns the number of hardware buttons detected.

Return Value:

    TRUE if a CSeries type mouse is detected, otherwise FALSE.

--*/
{
    UCHAR status, numButtons;
    ULONG count;
    BOOLEAN detected = FALSE;

    SerMouSetDebugOutput(DBG_COLOR);
    SerMouPrint((2, "SERMOUSE-CSerDetect: Start\n"));

    //
    // Power up the mouse if necessary.
    //

    CSerPowerUp(Port);

    //
    // Set the line control register to a format that the mouse can
    // understand (see below: the line is set after the report rate).
    //

    UARTSetLineCtrl(Port, Protocol[CSER_PROTOCOL_MM].LineCtrl);

    //
    // Cycle through the different baud rates to detect the mouse.
    //

    for (count = 0; count < sizeofel(BaudRateDetect); count++) {

        UARTSetBaudRate(Port, BaudRateDetect[count], BaudClock);

        //
        // Put the mouse in prompt mode.
        //

        CSerSetReportRate(Port, 0);

        //
        // Set the MM protocol. This way we get the mouse to talk to us in a
        // specific format. This avoids receiving errors from the line 
        // register.
        //

        CSerSetProtocol(Port, CSER_PROTOCOL_MM);

        //
        // Try to get the status byte.
        //

        UARTWriteChar(Port, CSER_STATUS_COMMAND);

        while (!UARTIsTransmitEmpty(Port)) {
            // Nothing
        }

        //
        // In case something is already there...
        //

        UARTFlushReadBuffer(Port);

        //
        // Read back the status character.
        //
        if (UARTReadChar(Port, &status, CSER_STATUS_DELAY) &&
                (status ==  CSER_STATUS)) {
            detected = TRUE;
            SerMouPrint((
                1,
                "SERMOUSE-Detected mouse at %u bauds\n",
                BaudRateDetect[count]
                ));
            break;
        }
    }

    if (detected) {

        //
        // Get the number of buttons back from the mouse.
        //

        UARTWriteChar(Port, CSER_QUERY_BUTTONS_COMMAND);

        while (!UARTIsTransmitEmpty(Port)) {
            // Nothing
        }

        //
        // In case something is already there...
        //

        UARTFlushReadBuffer(Port);

        //
        // Read back the number of buttons.
        //
        if (UARTReadChar(Port, &numButtons, CSER_STATUS_DELAY)) {

            numButtons &= 0x0F;

            if (numButtons == 2 || numButtons == 3) {
                *HardwareButtons = numButtons;
            } else {
                *HardwareButtons = MOUSE_NUMBER_OF_BUTTONS;
            }
        } else {
            *HardwareButtons = MOUSE_NUMBER_OF_BUTTONS;
        }
    }

    //
    // Put the mouse back in a default mode. The protocol is already set.
    //

    CSerSetBaudRate(Port, CSER_DEFAULT_BAUDRATE, BaudClock);
    CSerSetReportRate(Port, CSER_DEFAULT_REPORTRATE);

    SerMouPrint((3, "SERMOUSE-Detected: %s\n", detected ? "TRUE" : "FALSE"));
    SerMouPrint((3, "SERMOUSE-Status byte: %#x\n", status));
    SerMouPrint((2, "SERMOUSE-CSerDetect: End\n"));

    SerMouSetDebugOutput(DBG_SERIAL);

    return detected;
}


BOOLEAN
CSerHandlerMM(
    IN PMOUSE_INPUT_DATA CurrentInput,
    IN PHANDLER_DATA HandlerData,
    IN UCHAR Value,
    IN UCHAR LineState)

/*++

Routine Description:

    This is the protocol handler routine for the MM protocol.

Arguments:

    CurrentInput - Pointer to the report packet.

    Value - The input buffer value.

    LineState - The serial port line state.

Return Value:

    Returns TRUE if the handler has a completed report.

--*/

{

    BOOLEAN retval = FALSE;

    SerMouPrint((2, "SERMOUSE-MMHandler: enter\n"));

    if ((Value & CSER_SYNCH_BIT) && (HandlerData->State != STATE0)) {
        HandlerData->Error++;
        SerMouPrint((
            1,
            "SERMOUSE-Synch error. State: %u\n", HandlerData->State
            ));
        HandlerData->State = STATE0;
    }
    else if (!(Value & CSER_SYNCH_BIT) && (HandlerData->State == STATE0)) {
        HandlerData->Error++;
        SerMouPrint((
            1,
            "SERMOUSE-Synch error. State: %u\n", HandlerData->State
            ));
        goto LExit;
    }

    //
    // Check for a line state error.
    //

    if (LineState & ACE_LERR) {

        //
        // Reset the handler state.
        //

        HandlerData->State = STATE0;
        HandlerData->Error++;
        SerMouPrint((1, "SERMOUSE-Line status error: %#x\n", LineState));
    }
    else {
        SerMouPrint((2, "SERMOUSE-State%u\n", HandlerData->State));
        HandlerData->Raw[HandlerData->State] = Value;

        switch (HandlerData->State) {
        case STATE0:
        case STATE1:
            HandlerData->State++;
            break;
        case STATE2:
            HandlerData->State = STATE0;

            //
            // Buttons formatting.
            //

            CurrentInput->RawButtons =
                (HandlerData->Raw[STATE0] & CSER_BUTTON_LEFT) >> CSER_BUTTON_LEFT_SR;
            CurrentInput->RawButtons |=
                (HandlerData->Raw[STATE0] & CSER_BUTTON_RIGHT) << CSER_BUTTON_RIGHT_SL;
            CurrentInput->RawButtons |=
                (HandlerData->Raw[STATE0] & CSER_BUTTON_MIDDLE) << CSER_BUTTON_MIDDLE_SL;

            //
            // Displacement formatting.
            //

            CurrentInput->LastX = (HandlerData->Raw[STATE0] & SIGN_X) ?
                HandlerData->Raw[STATE1] :
                -(LONG)HandlerData->Raw[STATE1];

            //
            // Note: The Y displacement is positive to the south.
            //

            CurrentInput->LastY = (HandlerData->Raw[STATE0] & SIGN_Y) ?
                -(LONG)HandlerData->Raw[STATE2] :
                HandlerData->Raw[STATE2];

            SerMouPrint((1, "SERMOUSE-Displacement X: %ld\n", CurrentInput->LastX));
            SerMouPrint((1, "SERMOUSE-Displacement Y: %ld\n", CurrentInput->LastY));
            SerMouPrint((1, "SERMOUSE-Raw Buttons: %0lx\n", CurrentInput->RawButtons));

            //
            // The report is complete. Tell the interrupt handler to send it.
            //

            retval = TRUE;

            break;

        default:
            SerMouPrint((
                0,
                "SERMOUSE-MM Handler failure: incorrect state value.\n"
                ));
            ASSERT(FALSE);
        }

    }

LExit:
    SerMouPrint((2, "SERMOUSE-MMHandler: exit\n"));

    return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\pnpi8042\wmi.c ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    wmi.c

Abstract:

    This module contains the code that handles the wmi IRPs for the
    i8042prt driver.

Environment:

    Kernel mode

Revision History :

--*/

#include <initguid.h>
#include "i8042prt.h"
#include <wmistr.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, I8xInitWmi)
#pragma alloc_text(PAGE, I8xSystemControl)
#pragma alloc_text(PAGE, I8xSetWmiDataItem)
#pragma alloc_text(PAGE, I8xSetWmiDataBlock)
#pragma alloc_text(PAGE, I8xKeyboardQueryWmiDataBlock)
#pragma alloc_text(PAGE, I8xMouseQueryWmiDataBlock)
#pragma alloc_text(PAGE, I8xQueryWmiRegInfo)
#endif

#define WMI_KEYBOARD_PORT_INFORMATION 0
#define WMI_KEYBOARD_PORT_EXTENDED_ID 1

#define WMI_MOUSE_PORT_INFORMATION    0

GUID KbKeyboardPortGuid = KEYBOARD_PORT_WMI_STD_DATA_GUID;

WMIGUIDREGINFO KbWmiGuidList[] =
{
    { &MSKeyboard_PortInformation_GUID, 1, 0 },  // Keyboard Port driver information
    { &MSKeyboard_ExtendedID_GUID, 1, 0 },
};

GUID MouPointerPortGuid = POINTER_PORT_WMI_STD_DATA_GUID;

WMIGUIDREGINFO MouWmiGuidList[] =
{
    { &MouPointerPortGuid,  1, 0 }  // Pointer Port driver information
};

NTSTATUS
I8xInitWmi(
    PCOMMON_DATA CommonData
    )
/*++

Routine Description:

    Initializes the WmiLibInfo data structure for the device represented by
    CommonData
    
Arguments:

    CommonData - the device

Return Value:

    status from IoWMIRegistrationControl
    
--*/
{
    PAGED_CODE();

    if (CommonData->IsKeyboard) {
        CommonData->WmiLibInfo.GuidCount = sizeof(KbWmiGuidList) /
                                           sizeof(WMIGUIDREGINFO);
        CommonData->WmiLibInfo.GuidList = KbWmiGuidList;
        CommonData->WmiLibInfo.QueryWmiDataBlock = I8xKeyboardQueryWmiDataBlock;
    }
    else {
        CommonData->WmiLibInfo.GuidCount = sizeof(MouWmiGuidList) /
                                           sizeof(WMIGUIDREGINFO);
        CommonData->WmiLibInfo.GuidList = MouWmiGuidList;
        CommonData->WmiLibInfo.QueryWmiDataBlock = I8xMouseQueryWmiDataBlock;
    }

    CommonData->WmiLibInfo.QueryWmiRegInfo = I8xQueryWmiRegInfo;
    CommonData->WmiLibInfo.SetWmiDataBlock = I8xSetWmiDataBlock;
    CommonData->WmiLibInfo.SetWmiDataItem = I8xSetWmiDataItem;
    CommonData->WmiLibInfo.ExecuteWmiMethod = NULL;
    CommonData->WmiLibInfo.WmiFunctionControl = NULL;

    return IoWMIRegistrationControl(CommonData->Self,
                                    WMIREG_ACTION_REGISTER
                                    );
}

NTSTATUS
I8xSystemControl(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    )
/*++
Routine Description

    We have just received a System Control IRP.

    Assume that this is a WMI IRP and call into the WMI system library and let
    it handle this IRP for us.

--*/
{
    PCOMMON_DATA           commonData;
    SYSCTL_IRP_DISPOSITION disposition;
    NTSTATUS               status;

    PAGED_CODE();

    commonData = (PCOMMON_DATA) DeviceObject->DeviceExtension;

    status = WmiSystemControl(&commonData->WmiLibInfo, 
                              DeviceObject, 
                              Irp,
                              &disposition
                              );
    switch(disposition) {
    case IrpProcessed:
        //
        // This irp has been processed and may be completed or pending.
        //
        break;
        
    case IrpNotCompleted:
        //
        // This irp has not been completed, but has been fully processed.
        // we will complete it now
        //
        IoCompleteRequest(Irp, IO_NO_INCREMENT);                
        break;
        
    case IrpForward:
    case IrpNotWmi:
        //
        // This irp is either not a WMI irp or is a WMI irp targetted
        // at a device lower in the stack.
        //
        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(commonData->TopOfStack, Irp);
        break;
                                    
    default:
        //
        // We really should never get here, but if we do just forward....
        //
        ASSERT(FALSE);
        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(commonData->TopOfStack, Irp);
        break;
    }
    
    return status;
}

//
// WMI System Call back functions
//
NTSTATUS
I8xSetWmiDataItem(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            DataItemId,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/
{
    PCOMMON_DATA    commonData;
    NTSTATUS        status;

    PAGED_CODE();

    commonData = (PCOMMON_DATA) DeviceObject->DeviceExtension;

    switch(GuidIndex) {

    case WMI_KEYBOARD_PORT_INFORMATION:
    case WMI_KEYBOARD_PORT_EXTENDED_ID:
    // case WMI_MOUSE_PORT_INFORMATION:  // they are the same index
        status = STATUS_WMI_READ_ONLY;
        break;

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
        break;
    }

    return WmiCompleteRequest(DeviceObject,
                              Irp,
                              status,
                              0,
                              IO_NO_INCREMENT
                              );
}

NTSTATUS
I8xSetWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
{
    PCOMMON_DATA    commonData;
    NTSTATUS        status;

    PAGED_CODE();

    commonData = (PCOMMON_DATA) DeviceObject->DeviceExtension;

    switch (GuidIndex) {

    case WMI_KEYBOARD_PORT_INFORMATION:
    case WMI_KEYBOARD_PORT_EXTENDED_ID:
    // case WMI_MOUSE_PORT_INFORMATION:     // they are the same index
        status = STATUS_WMI_READ_ONLY;
        break;

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    return WmiCompleteRequest(DeviceObject,
                              Irp,
                              status,
                              0,
                              IO_NO_INCREMENT
                              );
}

NTSTATUS
I8xKeyboardQueryWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            InstanceCount,
    IN OUT PULONG       InstanceLengthArray,
    IN ULONG            OutBufferSize,
    OUT PUCHAR          Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    InstanceCount is the number of instnaces expected to be returned for
        the data block.
            
    InstanceLengthArray is a pointer to an array of ULONG that returns the 
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.        
            
    BufferAvail on has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    NTSTATUS                    status;
    ULONG                       size;
    KEYBOARD_PORT_WMI_STD_DATA  kbData;
    PPORT_KEYBOARD_EXTENSION    kbExtension;
    PKEYBOARD_ATTRIBUTES        attributes;

    PAGED_CODE();

    ASSERT(InstanceIndex == 0 && InstanceCount == 1);

    kbExtension = (PPORT_KEYBOARD_EXTENSION) DeviceObject->DeviceExtension; 
    size = 0;

    switch (GuidIndex) {
    case WMI_KEYBOARD_PORT_INFORMATION: 

        size = sizeof(KEYBOARD_PORT_WMI_STD_DATA);
        attributes = &kbExtension->KeyboardAttributes;

        if (OutBufferSize < size) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        RtlZeroMemory(&kbData,
                      size
                      );

        kbData.ConnectorType = KEYBOARD_PORT_WMI_STD_I8042;
        kbData.DataQueueSize = attributes->InputDataQueueLength /
            sizeof(KEYBOARD_INPUT_DATA);
        kbData.ErrorCount = 0; 
        kbData.FunctionKeys = attributes->NumberOfFunctionKeys;
        kbData.Indicators = attributes->NumberOfIndicators;

        *(PKEYBOARD_PORT_WMI_STD_DATA) Buffer = kbData;
        
        *InstanceLengthArray = size;

        status = STATUS_SUCCESS;

        break;

    case WMI_KEYBOARD_PORT_EXTENDED_ID:
        size = sizeof(KEYBOARD_ID_EX);
        if (OutBufferSize < size) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        *(PKEYBOARD_ID_EX) Buffer = kbExtension->KeyboardIdentifierEx;
        *InstanceLengthArray = sizeof(KEYBOARD_ID_EX);

        status = STATUS_SUCCESS;

        break;

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
        break;
    }

    return WmiCompleteRequest(DeviceObject,
                              Irp,
                              status,
                              size,
                              IO_NO_INCREMENT
                              );
}

NTSTATUS
I8xMouseQueryWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            InstanceCount,
    IN OUT PULONG       InstanceLengthArray,
    IN ULONG            OutBufferSize,
    OUT PUCHAR          Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    InstanceCount is the number of instnaces expected to be returned for
        the data block.
            
    InstanceLengthArray is a pointer to an array of ULONG that returns the 
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.        
            
    BufferAvail on has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    NTSTATUS                    status;
    ULONG                       size = sizeof(POINTER_PORT_WMI_STD_DATA);
    POINTER_PORT_WMI_STD_DATA   mouData;
    PPORT_MOUSE_EXTENSION       mouseExtension;
    PMOUSE_ATTRIBUTES           attributes;

    PAGED_CODE();

    //
    // Only ever registers 1 instance per guid
    //
    ASSERT(InstanceIndex == 0 && InstanceCount == 1);
    
    mouseExtension = (PPORT_MOUSE_EXTENSION) DeviceObject->DeviceExtension; 

    switch (GuidIndex) {
    case WMI_MOUSE_PORT_INFORMATION:

        attributes = &mouseExtension->MouseAttributes;

        if (OutBufferSize < size) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        RtlZeroMemory(&mouData,
                      size
                      );

        mouData.ConnectorType = POINTER_PORT_WMI_STD_I8042;
        mouData.DataQueueSize = attributes->InputDataQueueLength /
                                sizeof(MOUSE_INPUT_DATA);
        mouData.Buttons = attributes->NumberOfButtons;
        mouData.ErrorCount = 0;
        mouData.HardwareType = POINTER_PORT_WMI_STD_MOUSE;

        *(PPOINTER_PORT_WMI_STD_DATA) Buffer = mouData;
                
        *InstanceLengthArray = size;
                
        status = STATUS_SUCCESS;

        break;

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
        break;
    }

    return WmiCompleteRequest(DeviceObject,
                              Irp,
                              status,
                              size,
                              IO_NO_INCREMENT
                              );
}

NTSTATUS
I8xQueryWmiRegInfo(
    IN PDEVICE_OBJECT   DeviceObject,
    OUT PULONG          RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered. 
            
    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe all of the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device. These flags are ORed into the flags specified
        by the GUIDREGINFO for each guid.               

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. This is 
        required
                
    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.
                
    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in 
        *RegFlags.

Return Value:

    status

--*/
{
    PCOMMON_DATA commonData;
    
    PAGED_CODE();
    
    commonData = (PCOMMON_DATA) DeviceObject->DeviceExtension;

    *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
    *RegistryPath = &Globals.RegistryPath;
    *Pdo = commonData->PDO;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\sermouse\cseries.h ===
/*++

Copyright (c) 1993  Microsoft Corporation
Copyright (c) 1993  Logitech Inc.

Module Name:

    cseries.h

Abstract:

    Support for the Logitech CSeries type mice.

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/

#ifndef CSERIES_H
#define CSERIES_H


//
// Includes.
//

#include "uart.h"

#define CSER_PROTOCOL_MM        0
#define CSER_PROTOCOL_MAX       1

//
// Not implemented in this release.
//
//#define CSER_PROTOCOL_3B      1
//#define CSER_PROTOCOL_5B      2
//#define CSER_PROTOCOL_M       3
//#define CSER_PROTOCOL_RBPO    4
//#define CSER_PROTOCOL_ABPO    5
//#define CSER_PROTOCOL_MAX     6

//
// Time needed for a CSeries mouse to power up.
//
#define CSER_POWER_UP 500

//
// The minimum inactive time needed for the mouse to power down correctly.
//
#define CSER_POWER_DOWN 500

//
// Function prototypes.
//

BOOLEAN
CSerPowerUp(
    PUCHAR Port
    );

VOID
CSerSetReportRate(
    PUCHAR Port,
    UCHAR ReportRate
    );

VOID
CSerSetBaudRate(
    PUCHAR Port,
    ULONG BaudRate,
    ULONG BaudClock
    );

PPROTOCOL_HANDLER
CSerSetProtocol(
    PUCHAR Port,
    UCHAR NewProtocol
    );

BOOLEAN
CSerDetect(
    PUCHAR Port,
    ULONG BaudClock,
    PULONG HardwareButtons
    );

BOOLEAN
CSerHandlerMM(
    IN PMOUSE_INPUT_DATA CurrentInput,
    IN PHANDLER_DATA HandlerData,
    IN UCHAR Value,
    IN UCHAR LineState
    );

#endif // CSERIES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\sermouse\debug.c ===
/*++

Copyright (c) 1993  Microsoft Corporation
Copyright (c) 1993  Logitech Inc.

Module Name:

    debug.c

Abstract:

    Debugging support routines.

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/

#include "stdarg.h"
#include "stdio.h"
#include "string.h"
#include "ntddk.h"
#include "debug.h"


#if DBG
//
// Declare the global debug flag for this driver.
//

ULONG SerialMouseDebug = 0;

//
// Undocumented call (prototype).
// Use it to avoid timing problems and conflicts with the serial device. 
// This call is valid only during initialization and before the display 
// driver takes ownership of the display.
//

VOID HalDisplayString(PSZ Buffer);

static ULONG DebugOutput = DBG_SERIAL;

VOID
_SerMouSetDebugOutput(
    IN ULONG Destination
    )
/*++

Routine Description:

   Set the destination of the debugging string. The options are:
       DBG_COLOR:    Main computer screen.
       DBG_SERIAL:   Serial debugger port

   Note: The output to the DBG_COLOR screen can be used only during 
   initilialization before we switch to graphical mode.

Arguments:

    Destination - The debugging string destination.

Return Value:

    None.

--*/
{
    DebugOutput = Destination;
    return;
}

int
_SerMouGetDebugOutput(
    VOID
    )
/*++

Routine Description:

    Get the current debugger string output destination.

Arguments:

    None.

Return Value:

    Current debugging output destination.

--*/
{
    return DebugOutput;
}

VOID
SerMouDebugPrint(
    ULONG DebugPrintLevel,
    PCSZ DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print routine.

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None.

--*/

{
    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= SerialMouseDebug) {

        CHAR buffer[128];

        (VOID) vsprintf(buffer, DebugMessage, ap);

        if (DebugOutput & DBG_SERIAL) {
            DbgPrint(buffer);
        }

        if (DebugOutput & DBG_COLOR) {
            HalDisplayString(buffer);
        }
    }

    va_end(ap);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\pnpi8042\pnp.c ===
/*++

Copyright (c) 1997-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    pnp.c

Abstract:

    This module contains general PnP and Power code for the i8042prt Driver.

Environment:

    Kernel mode.

Revision History:

--*/
#include "i8042prt.h"
#include "i8042log.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, I8xAddDevice)
#pragma alloc_text(PAGE, I8xFilterResourceRequirements)
#pragma alloc_text(PAGE, I8xFindPortCallout)
#pragma alloc_text(PAGE, I8xManuallyRemoveDevice)
#pragma alloc_text(PAGE, I8xPnP)
#pragma alloc_text(PAGE, I8xPower)
#pragma alloc_text(PAGE, I8xRegisterDeviceInterface)
#pragma alloc_text(PAGE, I8xRemovePort)
#pragma alloc_text(PAGE, I8xSendIrpSynchronously) 
#endif

NTSTATUS
I8xAddDevice (
    IN PDRIVER_OBJECT   Driver,
    IN PDEVICE_OBJECT   PDO
    )
/*++

Routine Description:

    Adds a device to the stack and sets up the appropriate flags and 
    device extension for the newly created device.
    
Arguments:

    Driver - The driver object
    PDO    - the device that we are attaching ourselves on top of
    
Return Value:

    NTSTATUS result code.

--*/
{
    PCOMMON_DATA             commonData;
    PIO_ERROR_LOG_PACKET     errorLogEntry;
    PDEVICE_OBJECT           device;
    NTSTATUS                 status = STATUS_SUCCESS;
    ULONG                    maxSize;

    PAGED_CODE();

    Print(DBG_PNP_TRACE, ("enter Add Device \n"));

    maxSize = sizeof(PORT_KEYBOARD_EXTENSION) > sizeof(PORT_MOUSE_EXTENSION) ?
              sizeof(PORT_KEYBOARD_EXTENSION) :
              sizeof(PORT_MOUSE_EXTENSION);

    status = IoCreateDevice(Driver,                 // driver
                            maxSize,                // size of extension
                            NULL,                   // device name
                            FILE_DEVICE_8042_PORT,  // device type  ?? unknown at this time!!!
                            0,                      // device characteristics
                            FALSE,                  // exclusive
                            &device                 // new device
                            );

    if (!NT_SUCCESS(status)) {
        return (status);
    }

    RtlZeroMemory(device->DeviceExtension, maxSize);

    commonData = GET_COMMON_DATA(device->DeviceExtension);
    commonData->TopOfStack = IoAttachDeviceToDeviceStack(device, PDO);

    if (commonData->TopOfStack == NULL) {
        //
        // Not good; in only extreme cases will this fail
        //
        errorLogEntry = (PIO_ERROR_LOG_PACKET)
            IoAllocateErrorLogEntry(Driver, (UCHAR)sizeof(IO_ERROR_LOG_PACKET));
        if (errorLogEntry) {
            errorLogEntry->ErrorCode = I8042_ATTACH_DEVICE_FAILED;
            errorLogEntry->DumpDataSize = 0;
            errorLogEntry->SequenceNumber = 0;
            errorLogEntry->MajorFunctionCode = 0;
            errorLogEntry->IoControlCode = 0;
            errorLogEntry->RetryCount = 0;
            errorLogEntry->UniqueErrorValue = 0;
            errorLogEntry->FinalStatus =  STATUS_DEVICE_NOT_CONNECTED;

            IoWriteErrorLogEntry (errorLogEntry);
        }

        IoDeleteDevice (device);
        return STATUS_DEVICE_NOT_CONNECTED; 
    }

    ASSERT(commonData->TopOfStack);

    commonData->Self =          device;
    commonData->PDO =           PDO;
    commonData->PowerState =    PowerDeviceD0;

    KeInitializeSpinLock(&commonData->InterruptSpinLock);

    //
    // Initialize the data consumption timer
    //
    KeInitializeTimer(&commonData->DataConsumptionTimer);

    //
    // Initialize the port DPC queue to log overrun and internal
    // device errors.
    //
    KeInitializeDpc(
        &commonData->ErrorLogDpc,
        (PKDEFERRED_ROUTINE) I8042ErrorLogDpc,
        device
        );

    //
    // Initialize the device completion DPC for requests that exceed the
    // maximum number of retries.
    //
    KeInitializeDpc(
        &commonData->RetriesExceededDpc,
        (PKDEFERRED_ROUTINE) I8042RetriesExceededDpc,
        device
        );

    //
    // Initialize the device completion DPC for requests that have timed out
    //
    KeInitializeDpc(
        &commonData->TimeOutDpc,
        (PKDEFERRED_ROUTINE) I8042TimeOutDpc,
        device
        );

    //
    // Initialize the port completion DPC object in the device extension.
    // This DPC routine handles the completion of successful set requests.
    //
    IoInitializeDpcRequest(device, I8042CompletionDpc);

    IoInitializeRemoveLock(&commonData->RemoveLock,
                           I8042_POOL_TAG,
                           0,
                           0);

    device->Flags |= DO_BUFFERED_IO;
    device->Flags |= DO_POWER_PAGABLE;
    device->Flags &= ~DO_DEVICE_INITIALIZING;

    Print(DBG_PNP_TRACE, ("Add Device (0x%x)\n", status));

    return status;
}

NTSTATUS
I8xSendIrpSynchronously (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN BOOLEAN Strict
    )
/*++

Routine Description:

    Generic routine to send an irp DeviceObject and wait for its return up the
    device stack.
    
Arguments:

    DeviceObject - The device object to which we want to send the Irp
    
    Irp - The Irp we want to send
    
Return Value:

    return code from the Irp
--*/
{
    KEVENT   event;
    NTSTATUS status;

    PAGED_CODE();

    KeInitializeEvent(&event,
                      SynchronizationEvent,
                      FALSE
                      );

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(Irp,
                           I8xPnPComplete,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE
                           );

    status = IoCallDriver(DeviceObject, Irp);

    //
    // Wait for lower drivers to be done with the Irp
    //
    if (status == STATUS_PENDING) {
       KeWaitForSingleObject(&event,
                             Executive,
                             KernelMode,
                             FALSE,
                             NULL
                             );
       status = Irp->IoStatus.Status;
    }

    if (!Strict && 
        (status == STATUS_NOT_SUPPORTED ||
         status == STATUS_INVALID_DEVICE_REQUEST)) {
        status = STATUS_SUCCESS;
    }

    return status;
}

NTSTATUS
I8xPnPComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )
/*++

Routine Description:

    Completion routine for all PnP IRPs
    
Arguments:

    DeviceObject - Pointer to the DeviceObject

    Irp - Pointer to the request packet
    
    Event - The event to set once processing is complete 

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/
{
    UNREFERENCED_PARAMETER (DeviceObject);
    UNREFERENCED_PARAMETER (Irp);

    //
    // Since this completion routines sole purpose in life is to synchronize
    // Irp, we know that unless something else happens that the IoCallDriver
    // will unwind AFTER the we have complete this Irp.  Therefore we should
    // NOT bubble up the pending bit.
    //
    // if (Irp->PendingReturned) {
    //     IoMarkIrpPending(Irp);
    // }
    //

    KeSetEvent(Event, 0, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
I8xPnP (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the dispatch routine for PnP requests
Arguments:

    DeviceObject - Pointer to the device object

    Irp - Pointer to the request packet


Return Value:

    STATUS_SUCCESSFUL if successful,
    an valid NTSTATUS error code otherwise

--*/
{
    PPORT_KEYBOARD_EXTENSION   kbExtension;
    PPORT_MOUSE_EXTENSION      mouseExtension;
    PCOMMON_DATA               commonData;
    PIO_STACK_LOCATION         stack;
    NTSTATUS                   status = STATUS_SUCCESS;
    KIRQL                      oldIrql;

    PAGED_CODE();

    commonData = GET_COMMON_DATA(DeviceObject->DeviceExtension);
    stack = IoGetCurrentIrpStackLocation(Irp);

    status = IoAcquireRemoveLock(&commonData->RemoveLock, Irp);
    if (!NT_SUCCESS(status)) {
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return status;
    }

    Print(DBG_PNP_TRACE,
          ("I8xPnP (%s),  enter (min func=0x%x)\n",
          commonData->IsKeyboard ? "kb" : "mou",
          (ULONG) stack->MinorFunction
          ));

    switch (stack->MinorFunction) {
    case IRP_MN_START_DEVICE:

        //
        // The device is starting.
        //
        // We cannot touch the device (send it any non pnp irps) until a
        // start device has been passed down to the lower drivers.
        //
        status = I8xSendIrpSynchronously(commonData->TopOfStack, Irp, TRUE);

        if (NT_SUCCESS(status) && NT_SUCCESS(Irp->IoStatus.Status)) {
            //
            // As we are successfully now back from our start device
            // we can do work.

            ExAcquireFastMutexUnsafe(&Globals.DispatchMutex);

            if (commonData->Started) {
                Print(DBG_PNP_ERROR,
                      ("received 1+ starts on %s\n",
                      commonData->IsKeyboard ? "kb" : "mouse"
                      ));
            }
            else {
                //
                // commonData->IsKeyboard is set during
                //  IOCTL_INTERNAL_KEYBOARD_CONNECT to TRUE and 
                //  IOCTL_INTERNAL_MOUSE_CONNECT to FALSE
                //
                if (IS_KEYBOARD(commonData)) {
                    status = I8xKeyboardStartDevice(
                      (PPORT_KEYBOARD_EXTENSION) DeviceObject->DeviceExtension,
                      stack->Parameters.StartDevice.AllocatedResourcesTranslated
                      );
                }
                else {
                    status = I8xMouseStartDevice(
                      (PPORT_MOUSE_EXTENSION) DeviceObject->DeviceExtension,
                      stack->Parameters.StartDevice.AllocatedResourcesTranslated
                      );
                }
    
                if (NT_SUCCESS(status)) {
                    InterlockedIncrement(&Globals.StartedDevices);
                    commonData->Started = TRUE;
                }
            }

            ExReleaseFastMutexUnsafe(&Globals.DispatchMutex);
        }

        //
        // We must now complete the IRP, since we stopped it in the
        // completetion routine with MORE_PROCESSING_REQUIRED.
        //
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        break;

    case IRP_MN_FILTER_RESOURCE_REQUIREMENTS: 
        //
        // The general rule of thumb for handling this minor code is this:  
        //    add resources when the irp is going down the stack and
        //    remove resources when the irp is coming back up the stack
        //
        // The irp has the original resources on the way down.
        //
        status = I8xSendIrpSynchronously(commonData->TopOfStack, Irp, FALSE);

        if (NT_SUCCESS(status)) {
            status = I8xFilterResourceRequirements(DeviceObject,
                                                   Irp
                                                   );
        }
        else {
           Print(DBG_PNP_ERROR,
                 ("error pending filter res req event (0x%x)\n",
                 status
                 ));
        }
   
        //
        // Irp->IoStatus.Information will contain the new i/o resource 
        // requirements list so leave it alone
        //
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        break;
    
    case IRP_MN_QUERY_PNP_DEVICE_STATE: 

        status = I8xSendIrpSynchronously(commonData->TopOfStack, Irp, FALSE);
        if (NT_SUCCESS(status)) {
            (PNP_DEVICE_STATE) Irp->IoStatus.Information |=
                commonData->PnpDeviceState;
        }
        else {
            Print(DBG_PNP_ERROR,
                  ("error pending query pnp device state event (0x%x)\n",
                  status
                  ));

        }
   
        //
        // Irp->IoStatus.Information will contain the new i/o resource 
        // requirements list so leave it alone
        //
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        break;

    //
    // Don't let either of the requests succeed, otherwise the kb/mouse
    // might be rendered useless.
    //
    //  NOTE: this behavior is particular to i8042prt.  Any other driver,
    //        especially any other keyboard or port driver, should 
    //        succeed the query remove or stop.  i8042prt has this different 
    //        behavior because of the shared I/O ports but independent interrupts.
    //
    //        FURTHERMORE, if you allow the query to succeed, it should be sent
    //        down the stack (see sermouse.sys for an example of how to do this)
    //
    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_QUERY_STOP_DEVICE:
        status = (MANUALLY_REMOVED(commonData) ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);

        //
        // If we succeed the irp, we must send it down the stack
        //
        if (NT_SUCCESS(status)) {
            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver(commonData->TopOfStack, Irp);
        }
        else {
            Irp->IoStatus.Status = status; 
            Irp->IoStatus.Information = 0;    
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }
        break;

    //
    // PnP rules dictate we send the IRP down to the PDO first
    //
    case IRP_MN_CANCEL_REMOVE_DEVICE:
    case IRP_MN_CANCEL_STOP_DEVICE:
        status = I8xSendIrpSynchronously(commonData->TopOfStack, Irp, FALSE);

        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;    
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        break;

    // case IRP_MN_SURPRISE_REMOVAL:
    case IRP_MN_REMOVE_DEVICE:
        Print(DBG_PNP_INFO,
              ("(surprise) remove device (0x%x function 0x%x)\n",
              commonData->Self,
              (ULONG) stack->MinorFunction));

        if (commonData->Initialized) {
            IoWMIRegistrationControl(commonData->Self,
                                     WMIREG_ACTION_DEREGISTER
                                     );
        }

        if (commonData->Started) {
             InterlockedDecrement(&Globals.StartedDevices);
        }

        //
        // Wait for any pending I/O to drain
        //
        IoReleaseRemoveLockAndWait(&commonData->RemoveLock, Irp);

        ExAcquireFastMutexUnsafe(&Globals.DispatchMutex);
        if (IS_KEYBOARD(commonData)) {
            I8xKeyboardRemoveDevice(DeviceObject);
        }
        else {
            I8xMouseRemoveDevice(DeviceObject);
        }
        ExReleaseFastMutexUnsafe(&Globals.DispatchMutex);

        //
        // Set these flags so that when a surprise remove is sent, it will be
        // handled just like a remove, and when the remove comes, no other 
        // removal type actions will occur.
        //
        commonData->Started = FALSE;
        commonData->Initialized = FALSE;

        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(commonData->TopOfStack, Irp);

        IoDetachDevice(commonData->TopOfStack); 
        IoDeleteDevice(DeviceObject);
        
        return status;

    case IRP_MN_QUERY_CAPABILITIES:

        //
        // Change the device caps to not allow wait wake requests on level
        // triggered interrupts for mice because when an errant mouse movement
        // occurs while we are going to sleep, the interrupt will remain
        // triggered indefinitely.
        //
        // If the mouse does not have a level triggered interrupt, just let the
        // irp go by...
        //
        if (commonData->Started &&
            IS_MOUSE(commonData) && IS_LEVEL_TRIGGERED(commonData)) {

            Print(DBG_PNP_NOISE, ("query caps, mouse is level triggered\n"));

            status = I8xSendIrpSynchronously(commonData->TopOfStack, Irp, TRUE);
            if (NT_SUCCESS(status) && NT_SUCCESS(Irp->IoStatus.Status)) {
                PDEVICE_CAPABILITIES devCaps;

                Print(DBG_PNP_INFO, ("query caps, removing wake caps\n"));

                stack = IoGetCurrentIrpStackLocation(Irp);
                devCaps = stack->Parameters.DeviceCapabilities.Capabilities;

                ASSERT(devCaps);

                if (devCaps) {
                    Print(DBG_PNP_NOISE,
                          ("old DeviceWake was D%d and SystemWake was S%d.\n",
                          devCaps->DeviceWake-1, devCaps->SystemWake-1
                          )) ;

                    devCaps->DeviceWake = PowerDeviceUnspecified;
                    devCaps->SystemWake = PowerSystemUnspecified;
                }
            }

            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            break;
        }

    case IRP_MN_STOP_DEVICE:
    case IRP_MN_QUERY_DEVICE_RELATIONS:
    case IRP_MN_QUERY_INTERFACE:
    case IRP_MN_QUERY_DEVICE_TEXT:
    case IRP_MN_QUERY_RESOURCES:
    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
    case IRP_MN_READ_CONFIG:
    case IRP_MN_WRITE_CONFIG:
    case IRP_MN_EJECT:
    case IRP_MN_SET_LOCK:
    case IRP_MN_QUERY_ID:
    default:
        //
        // Here the driver below i8042prt might modify the behavior of these IRPS
        // Please see PlugPlay documentation for use of these IRPs.
        //
        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(commonData->TopOfStack, Irp);
        break;
    }

    Print(DBG_PNP_TRACE,
          ("I8xPnP (%s) exit (status=0x%x)\n",
          commonData->IsKeyboard ? "kb" : "mou",
          status
          ));

    IoReleaseRemoveLock(&commonData->RemoveLock, Irp);

    return status;
}

LONG
I8xManuallyRemoveDevice(
    PCOMMON_DATA CommonData
    )
/*++

Routine Description:

    Invalidates CommonData->PDO's device state and sets the manually removed 
    flag
    
Arguments:

    CommonData - represent either the keyboard or mouse
    
Return Value:

    new device count for that particular type of device
    
--*/
{
    LONG deviceCount;

    PAGED_CODE();

    if (IS_KEYBOARD(CommonData)) {

        deviceCount = InterlockedDecrement(&Globals.AddedKeyboards);
        if (deviceCount < 1) {
            Print(DBG_PNP_INFO, ("clear kb (manually remove)\n"));
            CLEAR_KEYBOARD_PRESENT();
        }

    } else {

        deviceCount = InterlockedDecrement(&Globals.AddedMice);
        if (deviceCount < 1) {
            Print(DBG_PNP_INFO, ("clear mou (manually remove)\n"));
            CLEAR_MOUSE_PRESENT();
        }
        
    }

    CommonData->PnpDeviceState |= PNP_DEVICE_REMOVED | PNP_DEVICE_DONT_DISPLAY_IN_UI;
    IoInvalidateDeviceState(CommonData->PDO);

    return deviceCount;
}

#define PhysAddrCmp(a,b) ( (a).LowPart == (b).LowPart && (a).HighPart == (b).HighPart )

BOOLEAN
I8xRemovePort(
    IN PIO_RESOURCE_DESCRIPTOR ResDesc
    )
/*++

Routine Description:

    If the physical address contained in the ResDesc is not in the list of 
    previously seen physicall addresses, it is placed within the list.
    
Arguments:

    ResDesc - contains the physical address

Return Value:

    TRUE  - if the physical address was found in the list
    FALSE - if the physical address was not found in the list (and thus inserted
            into it)
--*/
{
    ULONG               i;
    PHYSICAL_ADDRESS   address;

    PAGED_CODE();

    if (Globals.ControllerData->KnownPortsCount == -1) {
        return FALSE;
    }

    address =  ResDesc->u.Port.MinimumAddress;
    for (i = 0; i < Globals.ControllerData->KnownPortsCount; i++) {
        if (PhysAddrCmp(address, Globals.ControllerData->KnownPorts[i])) {
            return TRUE;
        }
    }

    if (Globals.ControllerData->KnownPortsCount < MaximumPortCount) {
        Globals.ControllerData->KnownPorts[
            Globals.ControllerData->KnownPortsCount++] = address;
    }

    Print(DBG_PNP_INFO,
          ("Saw port [0x%08x %08x] - [0x%08x %08x]\n",
          address.HighPart,
          address.LowPart,
          ResDesc->u.Port.MaximumAddress.HighPart,
          ResDesc->u.Port.MaximumAddress.LowPart
          ));

    return FALSE;
}

NTSTATUS
I8xFindPortCallout(
    IN PVOID                        Context,
    IN PUNICODE_STRING              PathName,
    IN INTERFACE_TYPE               BusType,
    IN ULONG                        BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE           ControllerType,
    IN ULONG                        ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE           PeripheralType,
    IN ULONG                        PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    )
/*++

Routine Description:

    This is the callout routine sent as a parameter to
    IoQueryDeviceDescription.  It grabs the keyboard controller and
    peripheral configuration information.

Arguments:

    Context - Context parameter that was passed in by the routine
        that called IoQueryDeviceDescription.

    PathName - The full pathname for the registry key.

    BusType - Bus interface type (Isa, Eisa, Mca, etc.).

    BusNumber - The bus sub-key (0, 1, etc.).

    BusInformation - Pointer to the array of pointers to the full value
        information for the bus.

    ControllerType - The controller type (should be KeyboardController).

    ControllerNumber - The controller sub-key (0, 1, etc.).

    ControllerInformation - Pointer to the array of pointers to the full
        value information for the controller key.

    PeripheralType - The peripheral type (should be KeyboardPeripheral).

    PeripheralNumber - The peripheral sub-key.

    PeripheralInformation - Pointer to the array of pointers to the full
        value information for the peripheral key.


Return Value:

    None.  If successful, will have the following side-effects:

        - Sets DeviceObject->DeviceExtension->HardwarePresent.
        - Sets configuration fields in
          DeviceObject->DeviceExtension->Configuration.

--*/
{
    PUCHAR                          controllerData;
    NTSTATUS                        status = STATUS_UNSUCCESSFUL;
    ULONG                           i,
                                    listCount,
                                    portCount = 0;
    PIO_RESOURCE_LIST               pResList = (PIO_RESOURCE_LIST) Context;
    PIO_RESOURCE_DESCRIPTOR         pResDesc;
    PKEY_VALUE_FULL_INFORMATION     controllerInfo = NULL;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR resourceDescriptor;

    PAGED_CODE();

    UNREFERENCED_PARAMETER(PathName);
    UNREFERENCED_PARAMETER(BusType);
    UNREFERENCED_PARAMETER(BusNumber);
    UNREFERENCED_PARAMETER(BusInformation);
    UNREFERENCED_PARAMETER(ControllerType);
    UNREFERENCED_PARAMETER(ControllerNumber);
    UNREFERENCED_PARAMETER(PeripheralType);
    UNREFERENCED_PARAMETER(PeripheralNumber);
    UNREFERENCED_PARAMETER(PeripheralInformation);

    pResDesc = pResList->Descriptors + pResList->Count;
    controllerInfo = ControllerInformation[IoQueryDeviceConfigurationData];

    Print(DBG_PNP_TRACE, ("I8xFindPortCallout enter\n"));

    if (controllerInfo->DataLength != 0) {
        controllerData = ((PUCHAR) controllerInfo) + controllerInfo->DataOffset;
        controllerData += FIELD_OFFSET(CM_FULL_RESOURCE_DESCRIPTOR,
                                       PartialResourceList);

        listCount = ((PCM_PARTIAL_RESOURCE_LIST) controllerData)->Count;

        resourceDescriptor =
            ((PCM_PARTIAL_RESOURCE_LIST) controllerData)->PartialDescriptors;

        for (i = 0; i < listCount; i++, resourceDescriptor++) {
            switch(resourceDescriptor->Type) {
            case CmResourceTypePort:
                
                if (portCount < 2) {

                    Print(DBG_PNP_INFO, 
                          ("found port [0x%x 0x%x] with length %d\n",
                          resourceDescriptor->u.Port.Start.HighPart,
                          resourceDescriptor->u.Port.Start.LowPart,
                          resourceDescriptor->u.Port.Length
                          ));

                    pResDesc->Type = resourceDescriptor->Type;
                    pResDesc->Flags = resourceDescriptor->Flags;
                    pResDesc->ShareDisposition = CmResourceShareDeviceExclusive;

                    pResDesc->u.Port.Alignment = 1;
                    pResDesc->u.Port.Length =
                        resourceDescriptor->u.Port.Length;
                    pResDesc->u.Port.MinimumAddress.QuadPart =
                        resourceDescriptor->u.Port.Start.QuadPart;
                    pResDesc->u.Port.MaximumAddress.QuadPart = 
                        pResDesc->u.Port.MinimumAddress.QuadPart +
                        pResDesc->u.Port.Length - 1;

                    pResList->Count++;

                    //
                    // We want to record the ports we stole from the kb as seen
                    // so that if the keyboard is started later, we can trim
                    // its resources and not have a resource conflict...
                    //
                    // ...we are getting too smart for ourselves here :]
                    //
                    I8xRemovePort(pResDesc);
                    pResDesc++;
                }

                status = STATUS_SUCCESS;

                break;

            default:
                Print(DBG_PNP_NOISE, ("type 0x%x found\n",
                                      (LONG) resourceDescriptor->Type));
                break;
            }
        }

    }

    Print(DBG_PNP_TRACE, ("I8xFindPortCallout exit (0x%x)\n", status));
    return status;
}

NTSTATUS
I8xFilterResourceRequirements(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Iterates through the resource requirements list contained in the IRP and removes
    any duplicate requests for I/O ports.  (This is a common problem on the Alphas.)
    
    No removal is performed if more than one resource requirements list is present.
    
Arguments:

    DeviceObject - A pointer to the device object

    Irp - A pointer to the request packet which contains the resource req. list.


Return Value:

    None.
    
--*/
{
    PIO_RESOURCE_REQUIREMENTS_LIST  pReqList = NULL,
                                    pNewReqList = NULL;
    PIO_RESOURCE_LIST               pResList = NULL,
                                    pNewResList = NULL;
    PIO_RESOURCE_DESCRIPTOR         pResDesc = NULL,
                                    pNewResDesc = NULL;
    ULONG                           i = 0, j = 0,
                                    removeCount,
                                    reqCount,
                                    size;
    BOOLEAN                         foundInt = FALSE,
                                    foundPorts = FALSE;

    PIO_STACK_LOCATION  stack;

    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(DeviceObject->DeviceExtension);

    Print(DBG_PNP_NOISE,
          ("Received IRP_MN_FILTER_RESOURCE_REQUIREMENTS for %s\n",
          (GET_COMMON_DATA(DeviceObject->DeviceExtension))->IsKeyboard ? "kb" : "mouse"
          ));

    stack = IoGetCurrentIrpStackLocation(Irp);

    //
    // The list can be in either the information field, or in the current
    //  stack location.  The Information field has a higher precedence over
    //  the stack location.
    //
    if (Irp->IoStatus.Information == 0) {
        pReqList =
            stack->Parameters.FilterResourceRequirements.IoResourceRequirementList;
        Irp->IoStatus.Information = (ULONG_PTR) pReqList;
    }
    else {
        pReqList = (PIO_RESOURCE_REQUIREMENTS_LIST) Irp->IoStatus.Information;
    }

    if (!pReqList) {
        // 
        // Not much can be done here except return
        //
        Print(DBG_PNP_MASK & ~ DBG_PNP_TRACE, 
              ("(%s) NULL resource list in I8xFilterResourceRequirements\n",
              (GET_COMMON_DATA(DeviceObject->DeviceExtension))->IsKeyboard ?
                  "kb" : "mou"
              ));

        return STATUS_SUCCESS;
    }

    ASSERT(Irp->IoStatus.Information != 0);
    ASSERT(pReqList != 0);

    reqCount = pReqList->AlternativeLists;

    //
    // Only one AlternativeList is supported.  If there is more than one list,
    // then there is now way of knowing which list will be chosen.  Also, if
    // there are multiple lists, then chances are that a list with no i/o port
    // conflicts will be chosen.
    //
    if (reqCount > 1) {
        return STATUS_SUCCESS;
    }

    pResList = pReqList->List;
    removeCount = 0;

    for (j = 0; j < pResList->Count; j++) {
        pResDesc = &pResList->Descriptors[j];
        switch (pResDesc->Type) {
        case CmResourceTypePort:
            Print(DBG_PNP_INFO, 
                  ("option = 0x%x, flags = 0x%x\n",
                  (LONG) pResDesc->Option,
                  (LONG) pResDesc->Flags
                  ));

            if (I8xRemovePort(pResDesc)) {
                //
                // Increment the remove count and tag this resource as
                // one that we don't want to copy to the new list
                //
                removeCount++;
                pResDesc->Type = I8X_REMOVE_RESOURCE;
            }

            foundPorts = TRUE;
            break;

        case CmResourceTypeInterrupt:
            if (Globals.ControllerData->Configuration.SharedInterrupts) {
                if (pResDesc->ShareDisposition != CmResourceShareShared) {
                    Print(DBG_PNP_INFO, ("forcing non shared int to shared\n"));
                }
                pResDesc->ShareDisposition = CmResourceShareShared;
            }

            foundInt = TRUE;
            break;

        default:
            break;
        }
    }

    if (removeCount) {
        size = pReqList->ListSize;

        // 
        // One element of the array is already allocated (via the struct 
        //  definition) so make sure that we are allocating at least that 
        //  much memory.
        //

        ASSERT(pResList->Count >= removeCount);
        if (pResList->Count > 1) {
            size -= removeCount * sizeof(IO_RESOURCE_DESCRIPTOR);
        }

        pNewReqList =
            (PIO_RESOURCE_REQUIREMENTS_LIST) ExAllocatePool(PagedPool, size);

        if (!pNewReqList) {
            //
            // This is not good, but the system doesn't really need to know about
            //  this, so just fix up our munging and return the original list
            //
            pReqList = stack->Parameters.FilterResourceRequirements.IoResourceRequirementList;
            reqCount = pReqList->AlternativeLists;
            removeCount = 0;
       
            for (i = 0; i < reqCount; i++) {
                pResList = &pReqList->List[i];
       
                for (j = 0; j < pResList->Count; j++) {
                    pResDesc = &pResList->Descriptors[j];
                    if (pResDesc->Type == I8X_REMOVE_RESOURCE) {
                        pResDesc->Type = CmResourceTypePort;
                    }
                }
            
            }

            return STATUS_SUCCESS;
        }

        //
        // Clear out the newly allocated list
        //
        RtlZeroMemory(pNewReqList,
                      size
                      );

        //
        // Copy the list header information except for the IO resource list
        // itself
        //
        RtlCopyMemory(pNewReqList,
                      pReqList,
                      sizeof(IO_RESOURCE_REQUIREMENTS_LIST) - 
                        sizeof(IO_RESOURCE_LIST)
                      );
        pNewReqList->ListSize = size;

        pResList = pReqList->List;
        pNewResList = pNewReqList->List;

        //
        // Copy the list header information except for the IO resource
        // descriptor list itself
        //
        RtlCopyMemory(pNewResList,
                      pResList,
                      sizeof(IO_RESOURCE_LIST) -
                        sizeof(IO_RESOURCE_DESCRIPTOR)
                      );

        pNewResList->Count = 0;
        pNewResDesc = pNewResList->Descriptors;

        for (j = 0; j < pResList->Count; j++) {
            pResDesc = &pResList->Descriptors[j];
            if (pResDesc->Type != I8X_REMOVE_RESOURCE) {
                //
                // Keep this resource, so copy it into the new list and
                // incement the count and the location for the next
                // IO resource descriptor
                //
                *pNewResDesc = *pResDesc;
                pNewResDesc++;
                pNewResList->Count++;

                Print(DBG_PNP_INFO,
                     ("List #%d, Descriptor #%d ... keeping res type %d\n",
                     i, j,
                     (ULONG) pResDesc->Type
                     ));
            }
            else {
                //
                // Decrement the remove count so we can assert it is
                //  zero once we are done
                //
                Print(DBG_PNP_INFO,
                      ("Removing port [0x%08x %08x] - [0x%#08x %08x]\n",
                      pResDesc->u.Port.MinimumAddress.HighPart,
                      pResDesc->u.Port.MinimumAddress.LowPart,
                      pResDesc->u.Port.MaximumAddress.HighPart,
                      pResDesc->u.Port.MaximumAddress.LowPart
                      ));
                removeCount--;
              }
        }

        ASSERT(removeCount == 0);

        //
        // There have been bugs where the old list was being used.  Zero it out to
        //  make sure that no conflicts arise.  (Not to mention the fact that some
        //  other code is accessing freed memory
        //
        RtlZeroMemory(pReqList,
                      pReqList->ListSize
                      );

        //
        // Free the old list and place the new one in its place
        //
        ExFreePool(pReqList);
        stack->Parameters.FilterResourceRequirements.IoResourceRequirementList =
            pNewReqList;
        Irp->IoStatus.Information = (ULONG_PTR) pNewReqList;
    }
    else if (!KEYBOARD_PRESENT() && !foundPorts && foundInt) {
        INTERFACE_TYPE                      interfaceType;
        NTSTATUS                            status;
        ULONG                               prevCount;
        CONFIGURATION_TYPE                  controllerType = KeyboardController;
        CONFIGURATION_TYPE                  peripheralType = KeyboardPeripheral;

        ASSERT( MOUSE_PRESENT() );

        Print(DBG_PNP_INFO, ("Adding ports to res list!\n"));

        //
        // We will now yank the resources from the keyboard to start the mouse
        // solo
        //
        size = pReqList->ListSize + 2 * sizeof(IO_RESOURCE_DESCRIPTOR);
        pNewReqList = (PIO_RESOURCE_REQUIREMENTS_LIST)
                        ExAllocatePool(
                            PagedPool,
                            size
                            );

        if (!pNewReqList) {
            return STATUS_SUCCESS;
        }

        //
        // Clear out the newly allocated list
        //
        RtlZeroMemory(pNewReqList,
                      size
                      );

        //
        // Copy the entire old list
        //
        RtlCopyMemory(pNewReqList,
                      pReqList,
                      pReqList->ListSize
                      );

        pResList = pReqList->List;
        pNewResList = pNewReqList->List;

        prevCount = pNewResList->Count;
        for (i = 0; i < MaximumInterfaceType; i++) {

            //
            // Get the registry information for this device.
            //
            interfaceType = i;
            status = IoQueryDeviceDescription(
                &interfaceType,
                NULL,
                &controllerType,
                NULL,
                &peripheralType,
                NULL,
                I8xFindPortCallout,
                (PVOID) pNewResList
                );

            if (NT_SUCCESS(status) || prevCount != pNewResList->Count) {
                break;
            }
        }

        if (NT_SUCCESS(status) || prevCount != pNewResList->Count) {
            pNewReqList->ListSize = size - (2 - (pNewResList->Count - prevCount));
    
            //
            // Free the old list and place the new one in its place
            //
            ExFreePool(pReqList);
            stack->Parameters.FilterResourceRequirements.IoResourceRequirementList =
                pNewReqList;
            Irp->IoStatus.Information = (ULONG_PTR) pNewReqList;
        }
        else {
            ExFreePool(pNewReqList);
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
I8xRegisterDeviceInterface(
    PDEVICE_OBJECT PDO,
    CONST GUID * Guid,
    PUNICODE_STRING SymbolicName
    )
{
    NTSTATUS status;

    PAGED_CODE();

    status = IoRegisterDeviceInterface(
                PDO,
                Guid,
                NULL,
                SymbolicName 
                );

    if (NT_SUCCESS(status)) {
        status = IoSetDeviceInterfaceState(SymbolicName,
                                           TRUE
                                           );
    }

    return status;
}

void
I8xSetPowerFlag(
    IN ULONG Flag,
    IN BOOLEAN Set
    )
{
    KIRQL irql;

    KeAcquireSpinLock(&Globals.ControllerData->PowerSpinLock, &irql);
    if (Set) {
        Globals.PowerFlags |= Flag;
    }
    else {
        Globals.PowerFlags &= ~Flag;
    }
    KeReleaseSpinLock(&Globals.ControllerData->PowerSpinLock, irql);
}

BOOLEAN
I8xCheckPowerFlag(
    ULONG Flag
    )
{
    KIRQL irql;
    BOOLEAN rVal = FALSE;

    KeAcquireSpinLock(&Globals.ControllerData->PowerSpinLock, &irql);
    if (Globals.PowerFlags & Flag) {
        rVal = TRUE;
    }
    KeReleaseSpinLock(&Globals.ControllerData->PowerSpinLock, irql);
    
    return rVal;
}

NTSTATUS
I8xPower (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the dispatch routine for power requests.  

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    STATUS_SUCCESSFUL if successful,
    an valid NTSTATUS error code otherwise

--*/
{
    PCOMMON_DATA        commonData;
    PIO_STACK_LOCATION  stack;
    NTSTATUS            status = STATUS_SUCCESS;

    PAGED_CODE();

    commonData = GET_COMMON_DATA(DeviceObject->DeviceExtension);

    stack = IoGetCurrentIrpStackLocation(Irp);

    Print(DBG_POWER_TRACE,
          ("Power (%s), enter\n",
          commonData->IsKeyboard ? "keyboard" :
                                   "mouse"
          ));

    //
    // A power irp can be sent to the device before we have been started or
    // initialized.  Since the code below relies on StartDevice() to have
    // executed, just fire and forget the irp
    //
    if (!commonData->Started || !commonData->Initialized) {
        PoStartNextPowerIrp(Irp);
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation(Irp);
        return PoCallDriver(commonData->TopOfStack, Irp);
    }

    switch(stack->MinorFunction) {
    case IRP_MN_WAIT_WAKE:
        Print(DBG_POWER_NOISE, ("Got IRP_MN_WAIT_WAKE\n" ));

        //
        // Fail all wait wake requests on level triggered interrupts for mice
        // because when an errant mouse movement occurs while we are going to
        // sleep, it will keep the interrupt triggered indefinitely.
        //
        // We should not even get into this situation because the caps of the 
        // mouse should have been altered to not report wait wake 
        //
        if (IS_MOUSE(commonData) && IS_LEVEL_TRIGGERED(commonData)) {

            PoStartNextPowerIrp(Irp);
            status = Irp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);

            Print(DBG_POWER_INFO | DBG_POWER_ERROR,
                  ("failing a wait wake request on a level triggered mouse\n"));

            return status;
        }

        break;

    case IRP_MN_POWER_SEQUENCE:
        Print(DBG_POWER_NOISE, ("Got IRP_MN_POWER_SEQUENCE\n" ));
        break;

    case IRP_MN_SET_POWER:
        Print(DBG_POWER_NOISE, ("Got IRP_MN_SET_POWER\n" ));

        //
        // Don't handle anything but DevicePowerState changes
        //
        if (stack->Parameters.Power.Type != DevicePowerState) {
            commonData->SystemState = stack->Parameters.Power.State.SystemState;

            Print(DBG_POWER_INFO, ("system power irp, S%d\n", commonData->SystemState-1));
            break;
        }

        //
        // Check for no change in state, and if none, do nothing.  This state
        // can occur when the device is armed for wake.  We will get a D0 in 
        // response to the WW irp completing and then another D0 corresponding
        // to the S0 irp sent to the stack.
        //
        if (stack->Parameters.Power.State.DeviceState ==
            commonData->PowerState) {
            Print(DBG_POWER_INFO,
                  ("no change in state (PowerDeviceD%d)\n",
                  commonData->PowerState-1
                  ));
            break;
        }

        switch (stack->Parameters.Power.State.DeviceState) {
        case PowerDeviceD0:
            Print(DBG_POWER_INFO, ("Powering up to PowerDeviceD0\n"));

            IoAcquireRemoveLock(&commonData->RemoveLock, Irp);

            if (IS_KEYBOARD(commonData)) {
                I8xSetPowerFlag(KBD_POWERED_UP_STARTED, TRUE);
            }
            else {
                I8xSetPowerFlag(MOU_POWERED_UP_STARTED, TRUE);
            }
                                
            //
            // PoSetPowerState will be called in I8xReinitalizeHardware for each
            // device once all the devices have powered back up
            //
            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine(Irp,
                                   I8xPowerUpToD0Complete,
                                   NULL,
                                   TRUE,                // on success
                                   TRUE,                // on error
                                   TRUE                 // on cancel
                                   );

            //
            // PoStartNextPowerIrp() gets called when the irp gets completed 
            // in either the completion routine or the resulting work item
            //
            // It is OK to call PoCallDriver and return pending b/c we are 
            // pending the irp in the completion routine and we may change
            // the completion status if we can't alloc pool.  If we return the
            // value from PoCallDriver, we are tied to that status value on the
            // way back up.
            //                
            IoMarkIrpPending(Irp);
            PoCallDriver(commonData->TopOfStack, Irp);
            return STATUS_PENDING;

        case PowerDeviceD1:
        case PowerDeviceD2:
        case PowerDeviceD3:
            Print(DBG_POWER_INFO,
                  ("Powering down to PowerDeviceD%d\n",
                  stack->Parameters.Power.State.DeviceState-1
                  ));

            //
            // If WORK_ITEM_QUEUED is set, that means that a work item is
            // either queued to be run, or running now so we don't want to yank
            // any devices underneath from the work item
            //
            if (I8xCheckPowerFlag(WORK_ITEM_QUEUED)) {
                Print(DBG_POWER_INFO | DBG_POWER_ERROR,
                      ("denying power down request because work item is running\n"
                      ));

                PoStartNextPowerIrp(Irp);
                status = Irp->IoStatus.Status = STATUS_POWER_STATE_INVALID;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);

                return status;
            }

            if (IS_KEYBOARD(commonData)) {
                I8xSetPowerFlag(KBD_POWERED_DOWN, TRUE);
            }
            else {
                I8xSetPowerFlag(MOU_POWERED_DOWN, TRUE);
            }

            PoSetPowerState(DeviceObject,
                            stack->Parameters.Power.Type,
                            stack->Parameters.Power.State
                            );

            //
            // Disconnect level triggered interupts on mice when we go into 
            // low power so errant mouse movement doesn't leave the interrupt
            // signalled for long periods of time
            //
            if (IS_MOUSE(commonData) && IS_LEVEL_TRIGGERED(commonData)) {
                PKINTERRUPT interrupt = commonData->InterruptObject;

                Print(DBG_POWER_NOISE,
                      ("disconnecting interrupt on level triggered mouse\n")
                      );

                commonData->InterruptObject = NULL;
                if (interrupt) {
                    IoDisconnectInterrupt(interrupt);
                }
            }

            commonData->PowerState = stack->Parameters.Power.State.DeviceState;
            commonData->ShutdownType = stack->Parameters.Power.ShutdownType;

            //
            // For what we are doing, we don't need a completion routine
            // since we don't race on the power requests.
            //
            Irp->IoStatus.Status = STATUS_SUCCESS;
            PoStartNextPowerIrp(Irp);
            IoSkipCurrentIrpStackLocation(Irp);
            return  PoCallDriver(commonData->TopOfStack, Irp);

        default:
            Print(DBG_POWER_INFO, ("unknown state\n"));
            break;
        }
        break;

    case IRP_MN_QUERY_POWER:
        Print(DBG_POWER_NOISE, ("Got IRP_MN_QUERY_POWER\n" ));
        break;

    default:
        Print(DBG_POWER_NOISE,
              ("Got unhandled minor function (%d)\n",
              stack->MinorFunction
              ));
        break;
    }

    Print(DBG_POWER_TRACE, ("Power, exit\n"));

    PoStartNextPowerIrp(Irp);

    IoSkipCurrentIrpStackLocation(Irp);
    return PoCallDriver(commonData->TopOfStack, Irp);
}

NTSTATUS
I8xPowerUpToD0Complete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    Reinitializes the i8042 haardware after any type of hibernation/sleep.
    
Arguments:

    DeviceObject - Pointer to the device object

    Irp - Pointer to the request
    
    Context - Context passed in from the funciton that set the completion
              routine. UNUSED.


Return Value:

    STATUS_SUCCESSFUL if successful,
    an valid NTSTATUS error code otherwise

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PCOMMON_DATA        commonData;
    PPOWER_UP_WORK_ITEM item;
    KIRQL               irql;
    UCHAR               poweredDownDevices = 0,
                        poweredUpDevices = 0,
                        failedDevices = 0;
    BOOLEAN             queueItem = FALSE,
                        clearFlags = FALSE,
                        failMouIrp = FALSE; 
    PIRP                mouIrp = NULL,
                        kbdIrp = NULL;

    UNREFERENCED_PARAMETER(Context);

    commonData = GET_COMMON_DATA(DeviceObject->DeviceExtension);

    Print(DBG_POWER_TRACE,
          ("PowerUpToD0Complete (%s), Enter\n",
          commonData->IsKeyboard ? "kb" : "mouse"
          ));


    //
    // We can use a regular work item because we have a non completed power irp
    // which has an outstanding reference to this stack.
    //
    item = (PPOWER_UP_WORK_ITEM) ExAllocatePool(NonPagedPool,
                                                sizeof(POWER_UP_WORK_ITEM));

    KeAcquireSpinLock(&Globals.ControllerData->PowerSpinLock, &irql);

    Print(DBG_POWER_TRACE,
          ("Power up to D0 completion enter, power flags 0x%x\n",
          Globals.PowerFlags));

    if (NT_SUCCESS(Irp->IoStatus.Status)) {
        commonData->OutstandingPowerIrp = Irp;
        status = STATUS_MORE_PROCESSING_REQUIRED;

        if (IS_KEYBOARD(commonData)) {
            KEYBOARD_POWERED_UP_SUCCESSFULLY(); 
        }
        else {
            MOUSE_POWERED_UP_SUCCESSFULLY();
        }
    }
    else {
        if (IS_KEYBOARD(commonData)) {
            KEYBOARD_POWERED_UP_FAILURE();
        }
        else {
            MOUSE_POWERED_UP_FAILURE();
        }
    }

    if (KEYBOARD_POWERED_DOWN_SUCCESS()) {
        Print(DBG_POWER_NOISE, ("--kbd powered down successfully\n"));
        poweredDownDevices++;
    }
    if (MOUSE_POWERED_DOWN_SUCCESS()) {
        Print(DBG_POWER_NOISE, ("--mou powered down successfully\n"));
        poweredDownDevices++;
    }

    if (KEYBOARD_POWERED_UP_SUCCESS()) {
        Print(DBG_POWER_NOISE, ("++kbd powered up successfully\n"));
        poweredUpDevices++;
    }
    if (MOUSE_POWERED_UP_SUCCESS()) {
        Print(DBG_POWER_NOISE, ("++mou powered up successfully\n"));
        poweredUpDevices++;
    }

    if (KEYBOARD_POWERED_UP_FAILED()) {
        Print(DBG_POWER_NOISE|DBG_POWER_ERROR, (">>kbd powered down failed\n"));
        failedDevices++;
    }
    if (MOUSE_POWERED_UP_FAILED()) {
        Print(DBG_POWER_NOISE|DBG_POWER_ERROR, (">>mou powered down failed\n"));
        failedDevices++;
    }

    Print(DBG_POWER_INFO,
          ("up %d, down %d, failed %d, flags 0x%x\n",
          (ULONG) poweredUpDevices, 
          (ULONG) poweredDownDevices, 
          (ULONG) failedDevices, 
          Globals.PowerFlags));

    if ((poweredUpDevices + failedDevices) == poweredDownDevices) {
        if (poweredUpDevices > 0) {
            //
            // The ports are associated with the keyboard.  If it has failed to
            // power up while the mouse succeeded, we still need to fail the
            // mouse b/c there is no hardware to talk to
            //
            if (failedDevices > 0 && KEYBOARD_POWERED_UP_FAILED()) {
                ASSERT(MOUSE_POWERED_UP_SUCCESS());
                ASSERT(Globals.KeyboardExtension->OutstandingPowerIrp == NULL);

                mouIrp = Globals.MouseExtension->OutstandingPowerIrp;
                Globals.MouseExtension->OutstandingPowerIrp = NULL;
                Globals.PowerFlags &= ~MOU_POWER_FLAGS;
                clearFlags =  TRUE;

                if (mouIrp != Irp) {
                    //
                    // we have queued the irp, complete it later in this
                    // function under a special case
                    //
                    failMouIrp = TRUE;
                }
                else {
                    //
                    // The mouse irp is the current irp.  We have already
                    // completed the kbd irp in our previous processing.  Set
                    // the irp status to some unsuccessful value so that we will
                    // call PoStartNextPowerIrp later in this function.  Also
                    // set status to != STATUS_MORE_PROCESSING_REQUIRED so the 
                    // irp will be completed when the function exits.
                    //
                    status = mouIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;
                }

            }
            else {
                Print(DBG_POWER_INFO, ("at least one device powered up!\n"));
                queueItem = TRUE;
            }
        }
        else {
            Print(DBG_POWER_INFO,
                  ("all devices failed power up, 0x%x\n",
                   Globals.PowerFlags));

            clearFlags = TRUE;
        }
    }
    else {
        //
        // the other device is still powered down, wait for it to power back
        // up before processing power states 
        //
        Print(DBG_POWER_INFO,
              ("queueing, waiting for 2nd dev obj to power cycle\n"));
    }

    if (queueItem || clearFlags) {
        //
        // Extract the irp from each successfully started device and clear the
        // associated power flags for the device
        //
        if (MOUSE_POWERED_UP_SUCCESS()) {
            mouIrp = Globals.MouseExtension->OutstandingPowerIrp;
            Globals.MouseExtension->OutstandingPowerIrp = NULL;

            ASSERT(!TEST_PWR_FLAGS(MOU_POWERED_UP_FAILURE));
            Globals.PowerFlags &= ~MOU_POWER_FLAGS;
        }
        else {
            Globals.PowerFlags &= ~(MOU_POWERED_UP_FAILURE);
        }

        if (KEYBOARD_POWERED_UP_SUCCESS()) {
            kbdIrp = Globals.KeyboardExtension->OutstandingPowerIrp;
            Globals.KeyboardExtension->OutstandingPowerIrp = NULL;

            ASSERT(!TEST_PWR_FLAGS(KBD_POWERED_UP_FAILURE));
            Globals.PowerFlags &= ~(KBD_POWER_FLAGS);
        }
        else {
             Globals.PowerFlags &= ~(KBD_POWERED_UP_FAILURE);
        }

        //
        // Mark that the work item is queued.  This is used to make sure that 2
        // work items are not queued concucrrently
        //
        if (item && queueItem) {
            Print(DBG_POWER_INFO, ("setting work item queued flag\n"));

            Globals.PowerFlags |= WORK_ITEM_QUEUED;
        }
    }

    KeReleaseSpinLock(&Globals.ControllerData->PowerSpinLock, irql);

    if (queueItem) {
        if (item == NULL) {
            //
            // complete any queued power irps
            //
            Print(DBG_POWER_INFO | DBG_POWER_ERROR,
                  ("failed to alloc work item\n"));

            //
            // what about PoSetPowerState?
            //
            if (mouIrp != NULL) {
                Print(DBG_POWER_ERROR | DBG_POWER_INFO,
                      ("completing mouse power irp 0x%x", mouIrp));

                mouIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                mouIrp->IoStatus.Information = 0x0;

                PoStartNextPowerIrp(mouIrp);
                IoCompleteRequest(mouIrp, IO_NO_INCREMENT);
                IoReleaseRemoveLock(&Globals.MouseExtension->RemoveLock, 
                                    mouIrp);
                mouIrp = NULL;
            }

            if (kbdIrp != NULL) {
                Print(DBG_POWER_ERROR | DBG_POWER_INFO,
                      ("completing kbd power irp 0x%x", kbdIrp));

                kbdIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                kbdIrp->IoStatus.Information = 0x0;

                PoStartNextPowerIrp(kbdIrp);
                IoCompleteRequest(kbdIrp, IO_NO_INCREMENT);
                IoReleaseRemoveLock(&Globals.KeyboardExtension->RemoveLock, 
                                    kbdIrp);
                kbdIrp = NULL;
            }

            //
            // The passed in Irp has just been completed; by returning more
            // processing required, it will not be double completed
            //
            return STATUS_MORE_PROCESSING_REQUIRED;
        }
        else {
            RtlZeroMemory(item, sizeof(*item));

            if (MOUSE_STARTED()) {
                SET_RECORD_STATE(Globals.MouseExtension,
                                 RECORD_RESUME_FROM_POWER);
            }
    
            Print(DBG_POWER_INFO, ("queueing work item for init\n"));
    
            item->KeyboardPowerIrp = kbdIrp;
            item->MousePowerIrp = mouIrp;

            ExInitializeWorkItem(&item->Item, I8xReinitializeHardware, item);
            ExQueueWorkItem(&item->Item, DelayedWorkQueue);
        }
    }
    else if (item != NULL) {
        Print(DBG_POWER_NOISE,("freeing unused item %p\n", item));
        ExFreePool(item);
        item = NULL;
    }

    if (failMouIrp) {
        Print(DBG_POWER_INFO | DBG_POWER_ERROR,
              ("failing successful mouse irp %p because kbd failed power up\n",
               mouIrp));

        PoStartNextPowerIrp(mouIrp);
        IoCompleteRequest(mouIrp, IO_NO_INCREMENT);
        IoReleaseRemoveLock(&Globals.MouseExtension->RemoveLock, mouIrp);
        mouIrp = NULL;
    }

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        Print(DBG_POWER_INFO | DBG_POWER_ERROR,
              ("irp %p failed, starting next\n", Irp));

        PoStartNextPowerIrp(Irp);
        Irp = NULL;
        ASSERT(status != STATUS_MORE_PROCESSING_REQUIRED);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\sermouse\devdesc.h ===
#include "..\devdesc\devdesc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\sermouse\devdesc.c ===
#include "..\devdesc\devdesc.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\sermouse\debug.h ===
/*++

Copyright (c) 1993  Microsoft Corporation
Copyright (c) 1993  Logitech Inc.

Module Name:

    debug.h

Abstract:

    Debugging support.

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/

#ifndef DEBUG_H
#define DEBUG_H

#if DBG

#define DBG_SERIAL      0x0001
#define DBG_COLOR       0x0002

VOID
_SerMouSetDebugOutput(
    IN ULONG Destination
    );

#define SerMouSetDebugOutput(x) _SerMouSetDebugOutput(x)

int
_SerMouGetDebugOutput(
    VOID
    );

#define SerMouGetDebugOutput(x) _SerMouGetDebugOutput()

VOID
SerMouDebugPrint(
    ULONG DebugPrintLevel,
    PCSZ DebugMessage,
    ...
    );

extern ULONG SerialMouseDebug;
#define SerMouPrint(x) SerMouDebugPrint x
#define D(x) x
#else
#define SerMouSetDebugOutput(x)
#define SerMouGetDebugOutput(x)
#define SerMouPrint(x)
#define D(x)
#endif


#endif // DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\sermouse\mseries.h ===
/*++

Copyright (c) 1993  Microsoft Corporation
Copyright (c) 1993  Logitech Inc.

Module Name:

    mseries.h

Abstract:

    Support routines for the following devices:

    - Microsoft 2 button serial devices.
    - Logitech 3 button serial devices (Microsoft compatible).
    - Microsoft Ballpoint.

Environment:

    Kernel mode only.

Notes:


Revision History:

--*/

//
// Constants.
//

#define MSER_PROTOCOL_MP        0
#define MSER_PROTOCOL_BP        1
#define MSER_PROTOCOL_Z         2
#define MSER_PROTOCOL_MAX       3

//
// Type definitions.
//

typedef enum _MOUSETYPE {
        NO_MOUSE = 0,
        MOUSE_2B,
        MOUSE_3B,
        BALLPOINT,
        MOUSE_Z,
        MAX_MOUSETYPE
} MOUSETYPE;

//
// Prototypes.
//

MOUSETYPE
MSerDetect(
    PUCHAR Port,
    ULONG BaudClock
    );

BOOLEAN
MSerHandlerBP(
    IN PMOUSE_INPUT_DATA CurrentInput,
    IN PHANDLER_DATA HandlerData,
    IN UCHAR Value,
    IN UCHAR LineState
    );

BOOLEAN
MSerHandlerMP(
    IN PMOUSE_INPUT_DATA CurrentInput,
    IN PHANDLER_DATA HandlerData,
    IN UCHAR Value,
    IN UCHAR LineState
    );

BOOLEAN
MSerHandlerZ(
    IN PMOUSE_INPUT_DATA CurrentInput,
    IN PHANDLER_DATA HandlerData,
    IN UCHAR Value,
    IN UCHAR LineState
    );

BOOLEAN
MSerPowerDown(
    PUCHAR Port
    );

BOOLEAN
MSerPowerUp(
    PUCHAR Port
    );

BOOLEAN
MSerReset(
    PUCHAR Port
    );

PPROTOCOL_HANDLER
MSerSetProtocol(
    PUCHAR Port,
    UCHAR NewProtocol
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\sermouse\sermcmn.c ===
/*++

Copyright (c) 1990, 1991, 1992, 1993  Microsoft Corporation
Copyright (c) 1993  Logitech Inc.

Module Name:

    sermcmn.c

Abstract:

    The common portions of the Microsoft serial (i8250) mouse port driver.
    This file should not require modification to support new mice
    that are similar to the serial mouse.

Environment:

    Kernel mode only.

Notes:

    NOTES:  (Future/outstanding issues)

    - Powerfail not implemented.

    - IOCTL_INTERNAL_MOUSE_DISCONNECT has not been implemented.  It's not
      needed until the class unload routine is implemented. Right now,
      we don't want to allow the mouse class driver to unload.

    - Consolidate duplicate code, where possible and appropriate.

Revision History:


--*/

#include "stdarg.h"
#include "stdio.h"
#include "string.h"
#include "ntddk.h"
#include "sermouse.h"
#include "sermlog.h"
#include "debug.h"


VOID
SerialMouseErrorLogDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL to log errors that are
    discovered at IRQL > DISPATCH_LEVEL (e.g., in the ISR routine or
    in a routine that is executed via KeSynchronizeExecution).  There
    is not necessarily a current request associated with this condition.

Arguments:

    Dpc - Pointer to the DPC object.

    DeviceObject - Pointer to the device object.

    Irp - Not used.

    Context - Indicates type of error to log.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION deviceExtension;
    PIO_ERROR_LOG_PACKET errorLogEntry;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(Irp);

    SerMouPrint((2, "SERMOUSE-SerialMouseErrorLogDpc: enter\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Log an error packet.
    //

    errorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
                                              DeviceObject,
                                              sizeof(IO_ERROR_LOG_PACKET)
                                              + (2 * sizeof(ULONG))
                                              );
    if (errorLogEntry != NULL) {

        errorLogEntry->DumpDataSize = 2 * sizeof(ULONG);

        if ((ULONG) Context == SERMOUSE_MOU_BUFFER_OVERFLOW) {
            errorLogEntry->UniqueErrorValue = SERIAL_MOUSE_ERROR_VALUE_BASE + 210;
            errorLogEntry->DumpData[0] = sizeof(MOUSE_INPUT_DATA);
            errorLogEntry->DumpData[1] =
                deviceExtension->Configuration.MouseAttributes.InputDataQueueLength;
        } else {
            errorLogEntry->UniqueErrorValue = SERIAL_MOUSE_ERROR_VALUE_BASE + 220;
            errorLogEntry->DumpData[0] = 0;
            errorLogEntry->DumpData[1] = 0;
        }

        errorLogEntry->ErrorCode = (ULONG) Context;
        errorLogEntry->SequenceNumber = 0;
        errorLogEntry->MajorFunctionCode = 0;
        errorLogEntry->IoControlCode = 0;
        errorLogEntry->RetryCount = 0;
        errorLogEntry->FinalStatus = 0;

        IoWriteErrorLogEntry(errorLogEntry);
    }

    SerMouPrint((2, "SERMOUSE-SerialMouseErrorLogDpc: exit\n"));

}

NTSTATUS
SerialMouseFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(Irp);

    SerMouPrint((2,"SERMOUSE-SerialMouseFlush: enter\n"));
    SerMouPrint((2,"SERMOUSE-SerialMouseFlush: exit\n"));

    return(STATUS_NOT_IMPLEMENTED);
}

NTSTATUS
SerialMouseInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for internal device control requests.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{

    PIO_STACK_LOCATION irpSp;
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS status;

    SerMouPrint((2,"SERMOUSE-SerialMouseInternalDeviceControl: enter\n"));

    //
    // Get a pointer to the device extension.
    //

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Initialize the returned Information field.
    //

    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Case on the device control subfunction that is being performed by the
    // requestor.
    //

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {

        //
        // Connect a mouse class device driver to the port driver.
        //

        case IOCTL_INTERNAL_MOUSE_CONNECT:

            SerMouPrint((
                2,
                "SERMOUSE-SerialMouseInternalDeviceControl: mouse connect\n"
                ));

            //
            // Only allow one connection.
            //
            // FUTURE:  Consider allowing multiple connections, just for
            // the sake of generality?
            //

            if (deviceExtension->ConnectData.ClassService
                != NULL) {

                SerMouPrint((
                    2,
                    "SERMOUSE-SerialMouseInternalDeviceControl: error - already connected\n"
                    ));

                status = STATUS_SHARING_VIOLATION;
                break;

            } else
            if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
                    sizeof(CONNECT_DATA)) {

                SerMouPrint((
                    2,
                    "SERMOUSE-SerialMouseInternalDeviceControl: error - invalid buffer length\n"
                    ));

                status = STATUS_INVALID_PARAMETER;
                break;
            }

            //
            // Copy the connection parameters to the device extension.
            //

            deviceExtension->ConnectData =
                *((PCONNECT_DATA) (irpSp->Parameters.DeviceIoControl.Type3InputBuffer));

            //
            // Reinitialize the port input data queue synchronously.
            //

            KeSynchronizeExecution(
                deviceExtension->InterruptObject,
                (PKSYNCHRONIZE_ROUTINE) SerMouInitializeDataQueue,
                (PVOID) deviceExtension
                );

            //
            // Set the completion status.
            //

            status = STATUS_SUCCESS;
            break;

        //
        // Disconnect a mouse class device driver from the port driver.
        //
        // NOTE: Not implemented.
        //

        case IOCTL_INTERNAL_MOUSE_DISCONNECT:

            SerMouPrint((
                2,
                "SERMOUSE-SerialMouseInternalDeviceControl: mouse disconnect\n"
                ));

            //
            // Perform a mouse interrupt disable call.
            //

            //
            // Clear the connection parameters in the device extension.
            // NOTE:  Must synchronize this with the mouse ISR.
            //
            //
            //deviceExtension->ConnectData.ClassDeviceObject =
            //    Null;
            //deviceExtension->ConnectData.ClassService =
            //    Null;

            //
            // Set the completion status.
            //

            status = STATUS_NOT_IMPLEMENTED;
            break;

        //
        // Enable mouse interrupts (mark the request pending and handle
        // it in StartIo).
        //

        case IOCTL_INTERNAL_MOUSE_ENABLE:

            SerMouPrint((
                2,
                "SERMOUSE-SerialMouseInternalDeviceControl: mouse enable\n"
                ));

            status = STATUS_PENDING;
            break;

        //
        // Disable mouse interrupts (mark the request pending and handle
        // it in StartIo).
        //

        case IOCTL_INTERNAL_MOUSE_DISABLE:

            SerMouPrint((
                2,
                "SERMOUSE-SerialMouseInternalDeviceControl: mouse disable\n"
                ));

            status = STATUS_PENDING;
            break;

        //
        // Query the mouse attributes.  First check for adequate buffer
        // length.  Then, copy the mouse attributes from the device
        // extension to the output buffer.
        //

        case IOCTL_MOUSE_QUERY_ATTRIBUTES:

            SerMouPrint((
                2,
                "SERMOUSE-SerialMouseInternalDeviceControl: mouse query attributes\n"
                ));

            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(MOUSE_ATTRIBUTES)) {
                status = STATUS_BUFFER_TOO_SMALL;
            } else {

                //
                // Copy the attributes from the DeviceExtension to the
                // buffer.
                //

                *(PMOUSE_ATTRIBUTES) Irp->AssociatedIrp.SystemBuffer =
                    deviceExtension->Configuration.MouseAttributes;

                Irp->IoStatus.Information = sizeof(MOUSE_ATTRIBUTES);
                status = STATUS_SUCCESS;
            }

            break;

        default:

            SerMouPrint((
                2,
                "SERMOUSE-SerialMouseInternalDeviceControl: INVALID REQUEST\n"
                ));

            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    Irp->IoStatus.Status = status;
    if (status == STATUS_PENDING) {
        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject, Irp, (PULONG)NULL, NULL);
    } else {
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    SerMouPrint((2,"SERMOUSE-SerialMouseInternalDeviceControl: exit\n"));

    return(status);

}

BOOLEAN
SerialMouseInterruptService(
    IN PKINTERRUPT Interrupt,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the interrupt service routine for the mouse device.

Arguments:

    Interrupt - A pointer to the interrupt object for this interrupt.

    Context - A pointer to the device object.

Return Value:

    Returns TRUE if the interrupt was expected (and therefore processed);
    otherwise, FALSE is returned.

--*/

{
    PDEVICE_EXTENSION deviceExtension;
    PDEVICE_OBJECT deviceObject;
    PMOUSE_INPUT_DATA currentInput;
    PUCHAR port;
    UCHAR value;
    UCHAR lineState;
    ULONG buttonsDelta;

    UNREFERENCED_PARAMETER(Interrupt);

    SerMouPrint((2, "SERMOUSE-SerialMouseInterruptService: enter\n"));

    //
    // Get the device extension.
    //

    deviceObject = (PDEVICE_OBJECT) Context;
    deviceExtension = (PDEVICE_EXTENSION) deviceObject->DeviceExtension;

    //
    // Get the serial mouse port address.
    //

    port = deviceExtension->Configuration.DeviceRegisters[0];

    //
    // Verify that the interrupt really belongs to this driver.
    //

    if ((READ_PORT_UCHAR((PUCHAR) (port + ACE_IIDR)) & ACE_IIP) == ACE_IIP) {

        //
        // Not our interrupt.
        //

        SerMouPrint((
            2,
            "SERMOUSE-SerialMouseInterruptService: not our interrupt\n"
            ));
        return(FALSE);
    }

    //
    // Get the line state byte. This value can be checked by the
    // protocol handler for errors.
    //

    lineState = READ_PORT_UCHAR((PUCHAR) (port + ACE_LSR));
    SerMouPrint((
        2,
        "SERMOUSE-Line status: 0x%x\n", lineState
        ));

    //
    // Read the byte from the serial mouse port.  If the mouse has not
    // been enabled, don't process the byte further.
    //

    value = READ_PORT_UCHAR((PUCHAR) port + ACE_RBR);

    SerMouPrint((
        2,
        "SERMOUSE-SerialMouseInterruptService: byte 0x%x\n", value
        ));

    if (deviceExtension->MouseEnableCount == 0) {
        SerMouPrint((
            2,
            "SERMOUSE-SerialMouseInterruptService: not enabled\n"
            ));
        return(TRUE);
    }

    //
    // At this point, the protocol handler should already be set because
    // the hardware is enabled.
    //

    ASSERT(deviceExtension->ProtocolHandler);

    currentInput = &deviceExtension->CurrentInput;

    //
    // Call the current protocol handler for this device
    //

    if ((*deviceExtension->ProtocolHandler)(
              currentInput,
              &deviceExtension->HandlerData,
              value,
              lineState
              )){

        //
        // The report is complete, compute the button deltas and queue it.
        //

        currentInput->UnitId = deviceExtension->UnitId;

        //
        // Do we have a button state change?
        //

        if (deviceExtension->HandlerData.PreviousButtons ^ currentInput->RawButtons) {


            //
            // The state of the buttons changed. Make some calculations...
            //

            buttonsDelta = deviceExtension->HandlerData.PreviousButtons ^
                                currentInput->RawButtons;

            //
            // Button 1.
            //

            if (buttonsDelta & MOUSE_BUTTON_1) {
                if (currentInput->RawButtons & MOUSE_BUTTON_1) {
                    currentInput->ButtonFlags |= MOUSE_BUTTON_1_DOWN;
                }
                else {
                    currentInput->ButtonFlags |= MOUSE_BUTTON_1_UP;
                }
            }

            //
            // Button 2.
            //

            if (buttonsDelta & MOUSE_BUTTON_2) {
                if (currentInput->RawButtons & MOUSE_BUTTON_2) {
                    currentInput->ButtonFlags |= MOUSE_BUTTON_2_DOWN;
                }
                else {
                    currentInput->ButtonFlags |= MOUSE_BUTTON_2_UP;
                }
            }

            //
            // Button 3.
            //

            if (buttonsDelta & MOUSE_BUTTON_3) {
                if (currentInput->RawButtons & MOUSE_BUTTON_3) {
                    currentInput->ButtonFlags |= MOUSE_BUTTON_3_DOWN;
                }
                else {
                    currentInput->ButtonFlags |= MOUSE_BUTTON_3_UP;
                }
            }

            deviceExtension->HandlerData.PreviousButtons =
                currentInput->RawButtons;

        }

        SerMouPrint((1, "SERMOUSE-Buttons: %0lx\n", currentInput->Buttons));

        SerMouSendReport(deviceObject);

        //
        // Clear the button flags for the next packet
        //

        currentInput->Buttons = 0;
    }

    SerMouPrint((2, "SERMOUSE-SerialMouseInterruptService: exit\n"));

    return TRUE;
}

VOID
SerialMouseIsrDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL to finish processing
    mouse interrupts.  It is queued in the mouse ISR.  The real
    work is done via a callback to the connected mouse class driver.

Arguments:

    Dpc - Pointer to the DPC object.

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the Irp.

    Context - Not used.

Return Value:

    None.

--*/

{

    PDEVICE_EXTENSION deviceExtension;
    GET_DATA_POINTER_CONTEXT getPointerContext;
    SET_DATA_POINTER_CONTEXT setPointerContext;
    VARIABLE_OPERATION_CONTEXT operationContext;
    PVOID classService;
    PVOID classDeviceObject;
    LONG interlockedResult;
    BOOLEAN moreDpcProcessing;
    ULONG dataNotConsumed = 0;
    ULONG inputDataConsumed = 0;
    LARGE_INTEGER deltaTime;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(Irp);
    UNREFERENCED_PARAMETER(Context);

    SerMouPrint((2, "SERMOUSE-SerialMouseIsrDpc: enter\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // Use DpcInterlockVariable to determine whether the DPC is running
    // concurrently on another processor.  We only want one instantiation
    // of the DPC to actually do any work.  DpcInterlockVariable is -1
    // when no DPC is executing.  We increment it, and if the result is
    // zero then the current instantiation is the only one executing, and it
    // is okay to proceed.  Otherwise, we just return.
    //
    //

    operationContext.VariableAddress =
        &deviceExtension->DpcInterlockVariable;
    operationContext.Operation = IncrementOperation;
    operationContext.NewValue = &interlockedResult;

    KeSynchronizeExecution(
            deviceExtension->InterruptObject,
            (PKSYNCHRONIZE_ROUTINE) SerMouDpcVariableOperation,
            (PVOID) &operationContext
            );

    moreDpcProcessing = (interlockedResult == 0)? TRUE:FALSE;

    while (moreDpcProcessing) {

        dataNotConsumed = 0;
        inputDataConsumed = 0;

        //
        // Get the port InputData queue pointers synchronously.
        //

        getPointerContext.DeviceExtension = deviceExtension;
        setPointerContext.DeviceExtension = deviceExtension;
        setPointerContext.InputCount = 0;

        KeSynchronizeExecution(
            deviceExtension->InterruptObject,
            (PKSYNCHRONIZE_ROUTINE) SerMouGetDataQueuePointer,
            (PVOID) &getPointerContext
            );

        if (getPointerContext.InputCount != 0) {

            //
            // Call the connected class driver's callback ISR with the
            // port InputData queue pointers.  If we have to wrap the queue,
            // break the operation into two pieces, and call the class callback
            // ISR once for each piece.
            //

            classDeviceObject =
                deviceExtension->ConnectData.ClassDeviceObject;
            classService =
                deviceExtension->ConnectData.ClassService;
            ASSERT(classService != NULL);

            if (getPointerContext.DataOut >= getPointerContext.DataIn) {

                //
                // We'll have to wrap the InputData circular buffer.  Call
                // the class callback ISR with the chunk of data starting at
                // DataOut and ending at the end of the queue.
                //

                SerMouPrint((
                    2,
                    "SERMOUSE-SerialMouseIsrDpc: calling class callback\n"
                    ));
                SerMouPrint((
                    2,
                    "SERMOUSE-SerialMouseIsrDpc: with Start 0x%x and End 0x%x\n",
                    getPointerContext.DataOut,
                    deviceExtension->DataEnd
                    ));

                (*(PSERVICE_CALLBACK_ROUTINE) classService)(
                      classDeviceObject,
                      getPointerContext.DataOut,
                      deviceExtension->DataEnd,
                      &inputDataConsumed
                      );

                dataNotConsumed = ((ULONG)((PUCHAR)
                    deviceExtension->DataEnd -
                    (PUCHAR) getPointerContext.DataOut)
                    / sizeof(MOUSE_INPUT_DATA)) - inputDataConsumed;

                SerMouPrint((
                    2,
                    "SERMOUSE-SerialMouseIsrDpc: (Wrap) Call callback consumed %d items, left %d\n",
                    inputDataConsumed,
                    dataNotConsumed
                    ));

                setPointerContext.InputCount += inputDataConsumed;

                if (dataNotConsumed) {
                    setPointerContext.DataOut =
                        ((PUCHAR)getPointerContext.DataOut) +
                        (inputDataConsumed * sizeof(MOUSE_INPUT_DATA));
                } else {
                    setPointerContext.DataOut =
                        deviceExtension->InputData;
                    getPointerContext.DataOut = setPointerContext.DataOut;
                }
            }

            //
            // Call the class callback ISR with data remaining in the queue.
            //

            if ((dataNotConsumed == 0) &&
                (inputDataConsumed < getPointerContext.InputCount)){
                SerMouPrint((
                    2,
                    "SERMOUSE-SerialMouseIsrDpc: calling class callback\n"
                    ));
                SerMouPrint((
                    2,
                    "SERMOUSE-SerialMouseIsrDpc: with Start 0x%x and End 0x%x\n",
                    getPointerContext.DataOut,
                    getPointerContext.DataIn
                    ));

                (*(PSERVICE_CALLBACK_ROUTINE) classService)(
                      classDeviceObject,
                      getPointerContext.DataOut,
                      getPointerContext.DataIn,
                      &inputDataConsumed
                      );

                dataNotConsumed = ((ULONG)((PUCHAR) getPointerContext.DataIn -
                      (PUCHAR) getPointerContext.DataOut)
                      / sizeof(MOUSE_INPUT_DATA)) - inputDataConsumed;

                SerMouPrint((
                    2,
                    "SERMOUSE-SerialMouseIsrDpc: Call callback consumed %d items, left %d\n",
                    inputDataConsumed,
                    dataNotConsumed
                    ));

                setPointerContext.DataOut =
                    ((PUCHAR)getPointerContext.DataOut) +
                    (inputDataConsumed * sizeof(MOUSE_INPUT_DATA));
                setPointerContext.InputCount += inputDataConsumed;

            }

            //
            // Update the port InputData queue DataOut pointer and InputCount
            // synchronously.
            //

            KeSynchronizeExecution(
                deviceExtension->InterruptObject,
                (PKSYNCHRONIZE_ROUTINE) SerMouSetDataQueuePointer,
                (PVOID) &setPointerContext
                );

        }

        if (dataNotConsumed) {

            //
            // The class driver was unable to consume all the data.
            // Reset the interlocked variable to -1.  We do not want
            // to attempt to move more data to the class driver at this
            // point, because it is already overloaded.  Need to wait a
            // while to give the Raw Input Thread a chance to read some
            // of the data out of the class driver's queue.  We accomplish
            // this "wait" via a timer.
            //

            SerMouPrint((2, "SERMOUSE-SerialMouseIsrDpc: set timer in DPC\n"));

            operationContext.Operation = WriteOperation;
            interlockedResult = -1;
            operationContext.NewValue = &interlockedResult;

            KeSynchronizeExecution(
                    deviceExtension->InterruptObject,
                    (PKSYNCHRONIZE_ROUTINE) SerMouDpcVariableOperation,
                    (PVOID) &operationContext
                    );

            deltaTime.LowPart = (ULONG)(-10 * 1000 * 1000);
            deltaTime.HighPart = -1;

            (VOID) KeSetTimer(
                       &deviceExtension->DataConsumptionTimer,
                       deltaTime,
                       &deviceExtension->IsrDpcRetry
                       );

            moreDpcProcessing = FALSE;

        } else {

            //
            // Decrement DpcInterlockVariable.  If the result goes negative,
            // then we're all finished processing the DPC.  Otherwise, either
            // the ISR incremented DpcInterlockVariable because it has more
            // work for the ISR DPC to do, or a concurrent DPC executed on
            // some processor while the current DPC was running (the
            // concurrent DPC wouldn't have done any work).  Make sure that
            // the current DPC handles any extra work that is ready to be
            // done.
            //

            operationContext.Operation = DecrementOperation;
            operationContext.NewValue = &interlockedResult;

            KeSynchronizeExecution(
                    deviceExtension->InterruptObject,
                    (PKSYNCHRONIZE_ROUTINE) SerMouDpcVariableOperation,
                    (PVOID) &operationContext
                    );

            if (interlockedResult != -1) {

                //
                // The interlocked variable is still greater than or equal to
                // zero. Reset it to zero, so that we execute the loop one
                // more time (assuming no more DPCs execute and bump the
                // variable up again).
                //

                operationContext.Operation = WriteOperation;
                interlockedResult = 0;
                operationContext.NewValue = &interlockedResult;

                KeSynchronizeExecution(
                    deviceExtension->InterruptObject,
                    (PKSYNCHRONIZE_ROUTINE) SerMouDpcVariableOperation,
                    (PVOID) &operationContext
                    );

                SerMouPrint((2, "SERMOUSE-SerialMouseIsrDpc: loop in DPC\n"));
            } else {
                moreDpcProcessing = FALSE;
            }
        }
    }

    SerMouPrint((2, "SERMOUSE-SerialMouseIsrDpc: exit\n"));

}

NTSTATUS
SerialMouseOpenClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for create/open and close requests.
    These requests complete successfully.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{

    UNREFERENCED_PARAMETER(DeviceObject);

    SerMouPrint((3,"SERMOUSE-SerialMouseOpenClose: enter\n"));

    //
    // Complete the request with successful status.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    SerMouPrint((3,"SERMOUSE-SerialMouseOpenClose: exit\n"));

    return(STATUS_SUCCESS);

} // end SerialMouseOpenClose

VOID
SerialMouseStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine starts an I/O operation for the device.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION deviceExtension;
    PIO_STACK_LOCATION irpSp;

    SerMouPrint((2, "SERMOUSE-SerialMouseStartIo: enter\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Bump the error log sequence number.
    //

    deviceExtension->SequenceNumber += 1;

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // We know we got here with an internal device control request.  Switch
    // on IoControlCode.
    //

    switch(irpSp->Parameters.DeviceIoControl.IoControlCode) {

        //
        // Enable mouse interrupts, by calling SerMouEnableInterrupts
        // synchronously.
        //

        case IOCTL_INTERNAL_MOUSE_ENABLE:

            KeSynchronizeExecution(
                deviceExtension->InterruptObject,
                (PKSYNCHRONIZE_ROUTINE) SerMouEnableInterrupts,
                (PVOID) deviceExtension
                );

            SerMouPrint((
                2,
                "SERMOUSE-SerialMouseStartIo: mouse enable (count %d)\n",
                deviceExtension->MouseEnableCount
                ));

            Irp->IoStatus.Status = STATUS_SUCCESS;

            //
            // Complete the request.
            //

            IoStartNextPacket(DeviceObject, FALSE);
            IoCompleteRequest(Irp, IO_MOUSE_INCREMENT);

            break;

        //
        // Disable mouse interrupts, by calling SerMouDisableInterrupts
        // synchronously.
        //

        case IOCTL_INTERNAL_MOUSE_DISABLE:

            SerMouPrint((2, "SERMOUSE-SerialMouseStartIo: mouse disable"));

            if (deviceExtension->MouseEnableCount == 0) {

                //
                // Mouse already disabled.
                //

                SerMouPrint((2, " - error\n"));

                Irp->IoStatus.Status = STATUS_DEVICE_DATA_ERROR;

            } else {

                //
                // Disable mouse by calling SerMouDisableInterrupts.
                //

                KeSynchronizeExecution(
                    deviceExtension->InterruptObject,
                    (PKSYNCHRONIZE_ROUTINE) SerMouDisableInterrupts,
                    (PVOID) deviceExtension
                    );

                SerMouPrint((
                    2,
                    " (count %d)\n",
                    deviceExtension->MouseEnableCount
                    ));

                Irp->IoStatus.Status = STATUS_SUCCESS;
            }

            //
            // Complete the request.
            //

            IoStartNextPacket(DeviceObject, FALSE);
            IoCompleteRequest(Irp, IO_MOUSE_INCREMENT);

            break;

        default:

            SerMouPrint((2, "SERMOUSE-SerialMouseStartIo: INVALID REQUEST\n"));

            //
            // Log an internal error.  Note that we're calling the
            // error log DPC routine directly, rather than duplicating
            // code.
            //

            SerialMouseErrorLogDpc(
                (PKDPC) NULL,
                DeviceObject,
                Irp,
                (PVOID) (ULONG) SERMOUSE_INVALID_STARTIO_REQUEST
                );


            ASSERT(FALSE);
            break;
    }

    SerMouPrint((2, "SERMOUSE-SerialMouseStartIo: exit\n"));

    return;
}

VOID
SerMouDpcVariableOperation(
    IN  PVOID Context
    )

/*++

Routine Description:

    This routine is called synchronously by the ISR DPC to perform an
    operation on the InterlockedDpcVariable.  The operations that can be
    performed include increment, decrement, write, and read.  The ISR
    itself reads and writes the InterlockedDpcVariable without calling this
    routine.

Arguments:

    Context - Pointer to a structure containing the address of the variable
        to be operated on, the operation to perform, and the address at
        which to copy the resulting value of the variable (the latter is also
        used to pass in the value to write to the variable, on a write
        operation).

Return Value:

    None.

--*/

{
    PVARIABLE_OPERATION_CONTEXT operationContext = Context;

    SerMouPrint((3,"SERMOUSE-SerMouDpcVariableOperation: enter\n"));
    SerMouPrint((
        3,
        "\tPerforming %s at 0x%x (current value 0x%x)\n",
        (operationContext->Operation == IncrementOperation)? "increment":
        (operationContext->Operation == DecrementOperation)? "decrement":
        (operationContext->Operation == WriteOperation)?     "write":
        (operationContext->Operation == ReadOperation)?      "read":"",
        operationContext->VariableAddress,
        *(operationContext->VariableAddress)
        ));

    //
    // Perform the specified operation at the specified address.
    //

    switch(operationContext->Operation) {
        case IncrementOperation:
            *(operationContext->VariableAddress) += 1;
            break;
        case DecrementOperation:
            *(operationContext->VariableAddress) -= 1;
            break;
        case ReadOperation:
            break;
        case WriteOperation:
            SerMouPrint((
                3,
                "\tWriting 0x%x\n",
                *(operationContext->NewValue)
                ));
            *(operationContext->VariableAddress) =
                *(operationContext->NewValue);
            break;
        default:
            ASSERT(FALSE);
            break;
    }

    *(operationContext->NewValue) = *(operationContext->VariableAddress);

    SerMouPrint((
        3,
        "SERMOUSE-SerMouDpcVariableOperation: exit with value 0x%x\n",
        *(operationContext->NewValue)
        ));
}

VOID
SerMouGetDataQueuePointer(
    IN  PVOID Context
    )

/*++

Routine Description:

    This routine is called synchronously to get the current DataIn and DataOut
    pointers for the port InputData queue.

Arguments:

    Context - Pointer to a structure containing the device extension,
        address at which to store the current DataIn pointer, and the
        address at which to store the current DataOut pointer.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION deviceExtension;

    SerMouPrint((3,"SERMOUSE-SerMouGetDataQueuePointer: enter\n"));

    //
    // Get address of device extension.
    //

    deviceExtension = (PDEVICE_EXTENSION)
                      ((PGET_DATA_POINTER_CONTEXT) Context)->DeviceExtension;

    //
    // Get the DataIn and DataOut pointers.
    //

    SerMouPrint((
        3,
        "SERMOUSE-SerMouGetDataQueuePointer: DataIn 0x%x, DataOut 0x%x\n",
        deviceExtension->DataIn,
        deviceExtension->DataOut
        ));
    ((PGET_DATA_POINTER_CONTEXT) Context)->DataIn = deviceExtension->DataIn;
    ((PGET_DATA_POINTER_CONTEXT) Context)->DataOut = deviceExtension->DataOut;
    ((PGET_DATA_POINTER_CONTEXT) Context)->InputCount =
        deviceExtension->InputCount;

    SerMouPrint((3,"SERMOUSE-SerMouGetDataQueuePointer: exit\n"));
}

VOID
SerMouInitializeDataQueue (
    IN PVOID Context
    )

/*++

Routine Description:

    This routine initializes the input data queue.  It is called
    via KeSynchronization, except when called from the initialization routine.

Arguments:

    Context - Pointer to the device extension.

Return Value:

    None.

--*/

{

    PDEVICE_EXTENSION deviceExtension;

    SerMouPrint((3,"SERMOUSE-SerMouInitializeDataQueue: enter\n"));

    //
    // Get address of device extension.
    //

    deviceExtension = (PDEVICE_EXTENSION) Context;

    //
    // Initialize the input data queue.
    //

    deviceExtension->InputCount = 0;
    deviceExtension->DataIn = deviceExtension->InputData;
    deviceExtension->DataOut = deviceExtension->InputData;

    deviceExtension->OkayToLogOverflow = TRUE;

    SerMouPrint((3,"SERMOUSE-SerMouInitializeDataQueue: exit\n"));

} // end SerMouInitializeDataQueue

VOID
SerMouSendReport(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Place a completed report in the queue for subsequent processing by a DPC.

Arguments:

    Device Object - Pointer to the device object.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    if (!SerMouWriteDataToQueue(
                deviceExtension,
                &deviceExtension->CurrentInput
                )) {

        //
        // The mouse input data queue is full.  Just drop the
        // latest input on the floor.
        //
        // Queue a DPC to log an overrun error.
        //

        SerMouPrint((
            1,
            "SERMOUSE-SerMouSendReport: queue overflow\n"
            ));

        if (deviceExtension->OkayToLogOverflow) {
            KeInsertQueueDpc(
                &deviceExtension->ErrorLogDpc,
                (PIRP) NULL,
                (PVOID) (ULONG) SERMOUSE_MOU_BUFFER_OVERFLOW
                );
            deviceExtension->OkayToLogOverflow = FALSE;
        }

    } else if (deviceExtension->DpcInterlockVariable >= 0) {

        //
        // The ISR DPC is already executing.  Tell the ISR DPC it has
        // more work to do by incrementing the DpcInterlockVariable.
        //

        deviceExtension->DpcInterlockVariable += 1;

    } else {

        //
        // Queue the ISR DPC.
        //

        KeInsertQueueDpc(
            &deviceExtension->IsrDpc,
            DeviceObject->CurrentIrp,
            NULL
            );

    }

    return;
}

VOID
SerMouSetDataQueuePointer(
    IN  PVOID Context
    )

/*++

Routine Description:

    This routine is called synchronously to set the DataOut pointer
    and InputCount for the port InputData queue.

Arguments:

    Context - Pointer to a structure containing the device extension
        and the new DataOut value for the port InputData queue.

Return Value:

    None.

--*/

{
    PDEVICE_EXTENSION deviceExtension;

    SerMouPrint((3,"SERMOUSE-SerMouSetDataQueuePointer: enter\n"));

    //
    // Get address of device extension.
    //

    deviceExtension = (PDEVICE_EXTENSION)
                      ((PSET_DATA_POINTER_CONTEXT) Context)->DeviceExtension;

    //
    // Set the DataOut pointer.
    //

    SerMouPrint((
        3,
        "SERMOUSE-SerMouSetDataQueuePointer: old mouse DataOut 0x%x, InputCount %d\n",
        deviceExtension->DataOut,
        deviceExtension->InputCount
        ));
    deviceExtension->DataOut = ((PSET_DATA_POINTER_CONTEXT) Context)->DataOut;
    deviceExtension->InputCount -=
        ((PSET_DATA_POINTER_CONTEXT) Context)->InputCount;

    if (deviceExtension->InputCount == 0) {

        //
        // Reset the flag that determines whether it is time to log
        // queue overflow errors.  We don't want to log errors too often.
        // Instead, log an error on the first overflow that occurs after
        // the ring buffer has been emptied, and then stop logging errors
        // until it gets cleared out and overflows again.
        //

        SerMouPrint((
            1,
            "SERMOUSE-SerMouSetDataQueuePointer: Okay to log overflow\n"
            ));
        deviceExtension->OkayToLogOverflow = TRUE;
    }

    SerMouPrint((
        3,
        "SERMOUSE-SerMouSetDataQueuePointer: new mouse DataOut 0x%x, InputCount %d\n",
        deviceExtension->DataOut,
        deviceExtension->InputCount
        ));

    SerMouPrint((3,"SERMOUSE-SerMouSetDataQueuePointer: exit\n"));
}

BOOLEAN
SerMouWriteDataToQueue(
    PDEVICE_EXTENSION DeviceExtension,
    IN PMOUSE_INPUT_DATA InputData
    )

/*++

Routine Description:

    This routine adds input data from the mouse to the InputData queue.

Arguments:

    DeviceExtension - Pointer to the device extension.

    InputData - Pointer to the data to add to the InputData queue.

Return Value:

    Returns TRUE if the data was added, otherwise FALSE.

--*/

{

    SerMouPrint((2,"SERMOUSE-SerMouWriteDataToQueue: enter\n"));
    SerMouPrint((
        3,
        "SERMOUSE-SerMouWriteDataToQueue: DataIn 0x%x, DataOut 0x%x\n",
        DeviceExtension->DataIn,
        DeviceExtension->DataOut
        ));
    SerMouPrint((
        3,
        "SERMOUSE-SerMouWriteDataToQueue: InputCount %d\n",
        DeviceExtension->InputCount
        ));

    //
    // Check for full input data queue.
    //

    if ((DeviceExtension->DataIn == DeviceExtension->DataOut) &&
        (DeviceExtension->InputCount != 0)) {

        //
        // The input data queue is full.  Intentionally ignore
        // the new data.
        //

        SerMouPrint((1,"SERMOUSE-SerMouWriteDataToQueue: OVERFLOW\n"));
        return(FALSE);

    } else {
        *(DeviceExtension->DataIn) = *InputData;
        DeviceExtension->InputCount += 1;
        DeviceExtension->DataIn++;
        SerMouPrint((
            2,
            "SERMOUSE-SerMouWriteDataToQueue: new InputCount %d\n",
            DeviceExtension->InputCount
            ));
        if (DeviceExtension->DataIn ==
            DeviceExtension->DataEnd) {
            SerMouPrint((2,"SERMOUSE-SerMouWriteDataToQueue: wrap buffer\n"));
            DeviceExtension->DataIn = DeviceExtension->InputData;
        }
    }

    SerMouPrint((2,"SERMOUSE-SerMouWriteDataToQueue: exit\n"));

    return(TRUE);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\sermouse\sermdep.c ===
/*++

Copyright (c) 1990, 1991, 1992, 1993  Microsoft Corporation
Copyright (c) 1993  Logitech Inc.

Module Name:

    sermdep.c

Abstract:

    The initialization and hardware-dependent portions of
    the Microsoft serial (i8250) mouse port driver.  Modifications
    to support new mice similar to the serial mouse should be
    localized to this file.

Environment:

    Kernel mode only.

Notes:

    NOTES:  (Future/outstanding issues)

    - Powerfail not implemented.

    - Consolidate duplicate code, where possible and appropriate.

    - The serial ballpoint is supported.   However, Windows USER does not
      intend (right now) to use the ballpoint in anything except mouse
      emulation mode.  In ballpoint mode, there is extra functionality that
      would need to be supported.  E.g., the driver would need to pass
      back extra button information from the 4th byte of the ballpoint
      data packet.  Windows USER would need/want to allow the user to select
      which buttons are used, what the orientation of the ball is (esp.
      important for lefthanders), sensitivity, and acceleration profile.


Revision History:


--*/

#include "stdarg.h"
#include "stdio.h"
#include "string.h"
#include "ntddk.h"
#include "sermouse.h"
#include "sermlog.h"
#include "cseries.h"
#include "mseries.h"
#include "debug.h"

#ifdef PNP_IDENTIFY
#include "devdesc.h"
#endif

//
// Use the alloc_text pragma to specify the driver initialization routines
// (they can be paged out).
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(INIT,SerMouConfiguration)
#pragma alloc_text(INIT,SerMouInitializeDevice)
#pragma alloc_text(INIT,SerMouPeripheralCallout)
#pragma alloc_text(INIT,SerMouPeripheralListCallout)
#pragma alloc_text(INIT,SerMouServiceParameters)
#pragma alloc_text(INIT,SerMouInitializeHardware)
#pragma alloc_text(INIT,SerMouBuildResourceList)
#endif

typedef struct _DEVICE_EXTENSION_LIST_ENTRY {
    LIST_ENTRY          ListEntry;
    DEVICE_EXTENSION    DeviceExtension;

#ifdef PNP_IDENTIFY
    HWDESC_INFO         HardwareInfo;
#endif

} DEVICE_EXTENSION_LIST_ENTRY, *PDEVICE_EXTENSION_LIST_ENTRY;


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine initializes the serial (i8250) mouse port driver.

Arguments:

    DriverObject - Pointer to driver object created by system.

    RegistryPath - Pointer to the Unicode name of the registry path
        for this driver.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
#define NAME_MAX 256

    PDEVICE_EXTENSION_LIST_ENTRY tmpDeviceExtension;
    LIST_ENTRY tmpDeviceExtensionList;
    UNICODE_STRING baseDeviceName;
    UNICODE_STRING registryPath;
    WCHAR nameBuffer[NAME_MAX];
    PLIST_ENTRY head;

    SerMouPrint((1,"\n\nSERMOUSE-SerialMouseInitialize: enter\n"));

    RtlZeroMemory(nameBuffer, NAME_MAX * sizeof(WCHAR));
    baseDeviceName.Buffer = nameBuffer;
    baseDeviceName.Length = 0;
    baseDeviceName.MaximumLength = NAME_MAX * sizeof(WCHAR);

    //
    // Need to ensure that the registry path is null-terminated.
    // Allocate pool to hold a null-terminated copy of the path.
    //

    registryPath.Buffer = ExAllocatePool(
                              PagedPool,
                              RegistryPath->Length + sizeof(UNICODE_NULL)
                              );

    if (!registryPath.Buffer) {

        SerMouPrint((
            1,
            "SERMOUSE-SerialMouseInitialize: Couldn't allocate pool for registry path\n"
            ));

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    registryPath.Length = RegistryPath->Length + sizeof(UNICODE_NULL);
    registryPath.MaximumLength = registryPath.Length;

    RtlZeroMemory(
        registryPath.Buffer,
        registryPath.Length
        );

    RtlMoveMemory(
        registryPath.Buffer,
        RegistryPath->Buffer,
        RegistryPath->Length
        );


    //
    // Get the configuration information for this driver.
    //

    InitializeListHead(&tmpDeviceExtensionList);
    SerMouConfiguration(&tmpDeviceExtensionList, &registryPath, &baseDeviceName);

    while (!IsListEmpty(&tmpDeviceExtensionList)) {

        head = RemoveHeadList(&tmpDeviceExtensionList);
        tmpDeviceExtension = CONTAINING_RECORD(head,
                                               DEVICE_EXTENSION_LIST_ENTRY,
                                               ListEntry);

        SerMouInitializeDevice(DriverObject,
                               &(tmpDeviceExtension->DeviceExtension),
                               &registryPath, &baseDeviceName);

        ExFreePool(tmpDeviceExtension);
    }

    ExFreePool(registryPath.Buffer);

    if (!DriverObject->DeviceObject) {
        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // Set up the device driver entry points.
    //

    DriverObject->DriverStartIo = SerialMouseStartIo;
    DriverObject->MajorFunction[IRP_MJ_CREATE] = SerialMouseOpenClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]  = SerialMouseOpenClose;
    DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS]  =
                                             SerialMouseFlush;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] =
                                         SerialMouseInternalDeviceControl;

    return STATUS_SUCCESS;
}

VOID
SerMouInitializeDevice(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDEVICE_EXTENSION   TmpDeviceExtension,
    IN  PUNICODE_STRING     RegistryPath,
    IN  PUNICODE_STRING     BaseDeviceName
    )

/*++

Routine Description:

    This routine initializes the device for the given device
    extension.

Arguments:

    DriverObject        - Supplies the driver object.

    TmpDeviceExtension  - Supplies a temporary device extension for the
                            device to initialize.

    RegistryPath        - Supplies the registry path.

    BaseDeviceName      - Supplies the base device name to the device
                            to create.

Return Value:

    None.

--*/

{
    PDEVICE_OBJECT portDeviceObject;
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS status = STATUS_SUCCESS;
    KIRQL coordinatorIrql = 0;
    ULONG interruptVector;
    KIRQL interruptLevel;
    KAFFINITY affinity;
    PIO_ERROR_LOG_PACKET errorLogEntry;
    ULONG uniqueErrorValue;
    NTSTATUS errorCode = STATUS_SUCCESS;
    ULONG dumpCount = 0;
    PCM_RESOURCE_LIST resources = NULL;
    ULONG resourceListSize = 0;
    BOOLEAN conflictDetected;
    ULONG addressSpace;
    PHYSICAL_ADDRESS cardAddress;
    ULONG i;
    UNICODE_STRING fullDeviceName;
    UNICODE_STRING deviceNameSuffix;
    UNICODE_STRING servicesPath;

#ifdef PNP_IDENTIFY
    PHWDESC_INFO hardwareInfo = (PHWDESC_INFO) (TmpDeviceExtension + 1);
#endif

#define DUMP_COUNT 4
    ULONG dumpData[DUMP_COUNT];

    for (i = 0; i < DUMP_COUNT; i++) {
        dumpData[i] = 0;
    }

    //
    // Set up space for the port's device object suffix.  Note that
    // we overallocate space for the suffix string because it is much
    // easier than figuring out exactly how much space is required.
    // The storage gets freed at the end of driver initialization, so
    // who cares...
    //

    RtlInitUnicodeString(
        &deviceNameSuffix,
        NULL
        );

    deviceNameSuffix.MaximumLength = POINTER_PORTS_MAXIMUM * sizeof(WCHAR);
    deviceNameSuffix.MaximumLength += sizeof(UNICODE_NULL);

    deviceNameSuffix.Buffer = ExAllocatePool(
                                  PagedPool,
                                  deviceNameSuffix.MaximumLength
                                  );

    if (!deviceNameSuffix.Buffer) {

        SerMouPrint((
            1,
            "SERMOUSE-SerialMouseInitialize: Couldn't allocate string for device object suffix\n"
            ));

        status = STATUS_UNSUCCESSFUL;
        errorCode = SERMOUSE_INSUFFICIENT_RESOURCES;
        uniqueErrorValue = SERIAL_MOUSE_ERROR_VALUE_BASE + 6;
        dumpData[0] = (ULONG) deviceNameSuffix.MaximumLength;
        dumpCount = 1;
        goto SerialMouseInitializeExit;

    }

    RtlZeroMemory(
        deviceNameSuffix.Buffer,
        deviceNameSuffix.MaximumLength
        );

    //
    // Set up space for the port's full device object name.
    //

    RtlInitUnicodeString(
        &fullDeviceName,
        NULL
        );

    fullDeviceName.MaximumLength = sizeof(L"\\Device\\") +
                                      BaseDeviceName->Length +
                                      deviceNameSuffix.MaximumLength;


    fullDeviceName.Buffer = ExAllocatePool(
                                   PagedPool,
                                   fullDeviceName.MaximumLength
                                   );

    if (!fullDeviceName.Buffer) {

        SerMouPrint((
            1,
            "SERMOUSE-SerialMouseInitialize: Couldn't allocate string for device object name\n"
            ));

        status = STATUS_UNSUCCESSFUL;
        errorCode = SERMOUSE_INSUFFICIENT_RESOURCES;
        uniqueErrorValue = SERIAL_MOUSE_ERROR_VALUE_BASE + 8;
        dumpData[0] = (ULONG) fullDeviceName.MaximumLength;
        dumpCount = 1;
        goto SerialMouseInitializeExit;

    }

    RtlZeroMemory(
        fullDeviceName.Buffer,
        fullDeviceName.MaximumLength
        );
    RtlAppendUnicodeToString(
        &fullDeviceName,
        L"\\Device\\"
        );
    RtlAppendUnicodeToString(
        &fullDeviceName,
        BaseDeviceName->Buffer
        );

    for (i = 0; i < POINTER_PORTS_MAXIMUM; i++) {

        //
        // Append the suffix to the device object name string.  E.g., turn
        // \Device\PointerPort into \Device\PointerPort0.  Then we attempt
        // to create the device object.  If the device object already
        // exists (because it was already created by another port driver),
        // increment the suffix and try again.
        //

        status = RtlIntegerToUnicodeString(
                     i,
                     10,
                     &deviceNameSuffix
                     );

        if (!NT_SUCCESS(status)) {
            break;
        }

        RtlAppendUnicodeStringToString(
            &fullDeviceName,
            &deviceNameSuffix
        );

        SerMouPrint((
            1,
            "SERMOUSE-SerialMouseInitialize: Creating device object named %ws\n",
            fullDeviceName.Buffer
            ));

        //
        // Create a non-exclusive device object for the serial mouse
        // port device.
        //

        status = IoCreateDevice(
                    DriverObject,
                    sizeof(DEVICE_EXTENSION),
                    &fullDeviceName,
                    FILE_DEVICE_SERIAL_MOUSE_PORT,
                    0,
                    FALSE,
                    &portDeviceObject
                    );

        if (NT_SUCCESS(status)) {

            //
            // We've successfully created a device object.
            //

            TmpDeviceExtension->UnitId = (USHORT) i;
            break;
        } else {

           //
           // We'll increment the suffix and try again.  Note that we reset
           // the length of the string here to get back to the beginning
           // of the suffix portion of the name.  Do not bother to
           // zero the suffix, though, because the string for the
           // incremented suffix will be at least as long as the previous
           // one.
           //

           fullDeviceName.Length -= deviceNameSuffix.Length;
        }
    }

    if (!NT_SUCCESS(status)) {
        SerMouPrint((
            1,
            "SERMOUSE-SerialMouseInitialize: Could not create port device object = %ws\n",
            fullDeviceName.Buffer
            ));
        errorCode = SERMOUSE_INSUFFICIENT_RESOURCES;
        uniqueErrorValue = SERIAL_MOUSE_ERROR_VALUE_BASE + 10;
        dumpData[0] = (ULONG) i;
        dumpCount = 1;
        goto SerialMouseInitializeExit;
    }

    //
    // Do buffered I/O.  I.e., the I/O system will copy to/from user data
    // from/to a system buffer.
    //

    portDeviceObject->Flags |= DO_BUFFERED_IO;

    //
    // Set up the device extension.
    //

    deviceExtension =
        (PDEVICE_EXTENSION) portDeviceObject->DeviceExtension;
    *deviceExtension = *TmpDeviceExtension;
    deviceExtension->DeviceObject = portDeviceObject;

    //
    // Set up the device resource list prior to reporting resource usage.
    //

    SerMouBuildResourceList(deviceExtension, &resources, &resourceListSize);

    //
    // Report resource usage for the registry.
    //

    IoReportResourceUsage(
        BaseDeviceName,
        DriverObject,
        NULL,
        0,
        portDeviceObject,
        resources,
        resourceListSize,
        FALSE,
        &conflictDetected
        );

    if (conflictDetected) {

        //
        // Some other device already owns the ports or interrupts.
        // Fatal error.
        //

        SerMouPrint((
            1,
            "SERMOUSE-SerialMouseInitialize: Resource usage conflict\n"
            ));

        //
        // Log an error.
        //

        errorCode = SERMOUSE_RESOURCE_CONFLICT;
        uniqueErrorValue = SERIAL_MOUSE_ERROR_VALUE_BASE + 15;
        dumpData[0] =  (ULONG)
            resources->List[0].PartialResourceList.PartialDescriptors[0].u.Interrupt.Level;
        dumpData[1] = (ULONG)
            resources->List[0].PartialResourceList.PartialDescriptors[0].u.Interrupt.Vector;
        dumpData[2] = (ULONG)
            resources->List[0].PartialResourceList.PartialDescriptors[1].u.Interrupt.Level;
        dumpData[3] = (ULONG)
            resources->List[0].PartialResourceList.PartialDescriptors[1].u.Interrupt.Vector;
        dumpCount = 4;

        goto SerialMouseInitializeExit;

    }

    //
    // Map the serial mouse controller registers.
    //

    addressSpace = (deviceExtension->Configuration.PortList[0].Flags
                       & CM_RESOURCE_PORT_IO) == CM_RESOURCE_PORT_IO? 1:0;

    if (!HalTranslateBusAddress(
        deviceExtension->Configuration.InterfaceType,
        deviceExtension->Configuration.BusNumber,
        deviceExtension->Configuration.PortList[0].u.Port.Start,
        &addressSpace,
        &cardAddress
        )) {

        addressSpace = 1;
        cardAddress.QuadPart = 0;
    }

    if (!addressSpace) {

        deviceExtension->Configuration.UnmapRegistersRequired = TRUE;
        deviceExtension->Configuration.DeviceRegisters[0] =
            MmMapIoSpace(
                cardAddress,
                deviceExtension->Configuration.PortList[0].u.Port.Length,
                FALSE
                );

    } else {

        deviceExtension->Configuration.UnmapRegistersRequired = FALSE;
        deviceExtension->Configuration.DeviceRegisters[0] =
            (PVOID)cardAddress.LowPart;

    }

    if (!deviceExtension->Configuration.DeviceRegisters[0]) {

        SerMouPrint((
            1,
            "SERMOUSE-SerialMouseInitialize: Couldn't map the device registers.\n"
            ));
        deviceExtension->Configuration.UnmapRegistersRequired = FALSE;
        status = STATUS_NONE_MAPPED;

        //
        // Log an error.
        //

        errorCode = SERMOUSE_REGISTERS_NOT_MAPPED;
        uniqueErrorValue = SERIAL_MOUSE_ERROR_VALUE_BASE + 20;
        dumpData[0] = cardAddress.LowPart;
        dumpCount = 1;

        goto SerialMouseInitializeExit;

    } else {
        SerMouPrint((
            1,
            "SERMOUSE-SerialMouseInitialize: Mapped device registers to 0x%x.\n",
            deviceExtension->Configuration.DeviceRegisters[0]
            ));
    }

    //
    // Initialize the serial mouse hardware to default values for the mouse.
    // Note that interrupts remain disabled until the class driver
    // requests a MOUSE_CONNECT internal device control.
    //

    status = SerMouInitializeHardware(portDeviceObject);

    if (!NT_SUCCESS(status)) {
        SerMouPrint((
            1,
            "SERMOUSE-SerialMouseInitialize: Could not initialize hardware\n"
            ));
        goto SerialMouseInitializeExit;
    }

    //
    // Allocate the ring buffer for the mouse input data.
    //

    deviceExtension->InputData =
        ExAllocatePool(
            NonPagedPool,
            deviceExtension->Configuration.MouseAttributes.InputDataQueueLength
            );

    if (!deviceExtension->InputData) {

        //
        // Could not allocate memory for the mouse data queue.
        //

        SerMouPrint((
            1,
            "SERMOUSE-SerialMouseInitialize: Could not allocate mouse input data queue\n"
            ));

        status = STATUS_INSUFFICIENT_RESOURCES;

        //
        // Log an error.
        //

        errorCode = SERMOUSE_NO_BUFFER_ALLOCATED;
        uniqueErrorValue = SERIAL_MOUSE_ERROR_VALUE_BASE + 30;
        dumpData[0] =
            deviceExtension->Configuration.MouseAttributes.InputDataQueueLength;
        dumpCount = 1;

        goto SerialMouseInitializeExit;
    }

    deviceExtension->DataEnd =
        (PMOUSE_INPUT_DATA)  ((PCHAR) (deviceExtension->InputData)
        + deviceExtension->Configuration.MouseAttributes.InputDataQueueLength);

    //
    // Zero the mouse input data ring buffer.
    //

    RtlZeroMemory(
        deviceExtension->InputData,
        deviceExtension->Configuration.MouseAttributes.InputDataQueueLength
        );

    //
    // Initialize the connection data.
    //

    deviceExtension->ConnectData.ClassDeviceObject = NULL;
    deviceExtension->ConnectData.ClassService = NULL;

    //
    // Initialize the input data queue.
    //

    SerMouInitializeDataQueue((PVOID) deviceExtension);

    //
    // Initialize the port ISR DPC.  The ISR DPC is responsible for
    // calling the connected class driver's callback routine to process
    // the input data queue.
    //

    deviceExtension->DpcInterlockVariable = -1;

    KeInitializeSpinLock(&deviceExtension->SpinLock);

    KeInitializeDpc(
        &deviceExtension->IsrDpc,
        (PKDEFERRED_ROUTINE) SerialMouseIsrDpc,
        portDeviceObject
        );

    KeInitializeDpc(
        &deviceExtension->IsrDpcRetry,
        (PKDEFERRED_ROUTINE) SerialMouseIsrDpc,
        portDeviceObject
        );

    //
    // Initialize the mouse data consumption timer.
    //

    KeInitializeTimer(&deviceExtension->DataConsumptionTimer);

    //
    // Initialize the port DPC queue to log overrun and internal
    // driver errors.
    //

    KeInitializeDpc(
        &deviceExtension->ErrorLogDpc,
        (PKDEFERRED_ROUTINE) SerialMouseErrorLogDpc,
        portDeviceObject
        );

    //
    // From the Hal, get the interrupt vector and level.
    //

    interruptVector = HalGetInterruptVector(
                          deviceExtension->Configuration.InterfaceType,
                          deviceExtension->Configuration.BusNumber,
                          deviceExtension->Configuration.MouseInterrupt.u.Interrupt.Level,
                          deviceExtension->Configuration.MouseInterrupt.u.Interrupt.Vector,
                          &interruptLevel,
                          &affinity
                          );

    //
    // Initialize and connect the interrupt object for the mouse.
    //

    status = IoConnectInterrupt(
                 &(deviceExtension->InterruptObject),
                 (PKSERVICE_ROUTINE) SerialMouseInterruptService,
                 (PVOID) portDeviceObject,
                 (PKSPIN_LOCK)NULL,
                 interruptVector,
                 interruptLevel,
                 interruptLevel,
                 deviceExtension->Configuration.MouseInterrupt.Flags
                     == CM_RESOURCE_INTERRUPT_LATCHED ? Latched:LevelSensitive,
                 deviceExtension->Configuration.MouseInterrupt.ShareDisposition,
                 affinity,
                 deviceExtension->Configuration.FloatingSave
                 );

    if (!NT_SUCCESS(status)) {

        //
        // Failed to install.  Free up resources before exiting.
        //

        SerMouPrint((
            1,
            "SERMOUSE-SerialMouseInitialize: Could not connect mouse interrupt\n"
            ));

        //
        // Log an error.
        //

        errorCode = SERMOUSE_NO_INTERRUPT_CONNECTED;
        uniqueErrorValue = SERIAL_MOUSE_ERROR_VALUE_BASE + 40;
        dumpData[0] = interruptLevel;
        dumpCount = 1;

        goto SerialMouseInitializeExit;

    }

    //
    // Once initialization is finished, load the device map information
    // into the registry so that setup can determine which pointer port
    // is active.
    //

    status = RtlWriteRegistryValue(
                 RTL_REGISTRY_DEVICEMAP,
                 BaseDeviceName->Buffer,
                 fullDeviceName.Buffer,
                 REG_SZ,
                 RegistryPath->Buffer,
                 RegistryPath->Length
                 );

    if (!NT_SUCCESS(status)) {

        SerMouPrint((
            1,
            "SERMOUSE-SerialMouseInitialize: Could not store name in DeviceMap\n"
            ));

        errorCode = SERMOUSE_NO_DEVICEMAP_CREATED;
        uniqueErrorValue = SERIAL_MOUSE_ERROR_VALUE_BASE + 50;
        dumpCount = 0;

        goto SerialMouseInitializeExit;

    } else {

        SerMouPrint((
            1,
            "SERMOUSE-SerialMouseInitialize: Stored name in DeviceMap\n"
            ));
    }

    ASSERT(status == STATUS_SUCCESS);

#ifdef PNP_IDENTIFY

    //
    // Pull off the UNICODE_NULL we appended to the string earlier for this
    // routine
    //

    servicesPath = *RegistryPath;
    servicesPath.Length -= sizeof(UNICODE_NULL);

    status = LinkDeviceToDescription(
                &servicesPath,
                &fullDeviceName,
                hardwareInfo->InterfaceType,
                hardwareInfo->InterfaceNumber,
                hardwareInfo->ControllerType,
                hardwareInfo->ControllerNumber,
                hardwareInfo->PeripheralType,
                hardwareInfo->PeripheralNumber
                );

#endif

    if(!NT_SUCCESS(status)) {

        SerMouPrint((
            1,
            "SERMOUSE-SerialMouseInitialize: LinkDeviceToDescription returned "
            "status %#08lx\n",
            status
            ));

        status = STATUS_SUCCESS;
    }
                            

SerialMouseInitializeExit:

    //
    // Log an error, if necessary.
    //

    if (errorCode != STATUS_SUCCESS) {
        errorLogEntry = (PIO_ERROR_LOG_PACKET)
            IoAllocateErrorLogEntry(
                (portDeviceObject == NULL) ? 
                    (PVOID) DriverObject : (PVOID) portDeviceObject,
                (UCHAR) (sizeof(IO_ERROR_LOG_PACKET)
                         + (dumpCount * sizeof(ULONG)))
                );

        if (errorLogEntry != NULL) {

            errorLogEntry->ErrorCode = errorCode;
            errorLogEntry->DumpDataSize = (USHORT) dumpCount * sizeof(ULONG);
            errorLogEntry->SequenceNumber = 0;
            errorLogEntry->MajorFunctionCode = 0;
            errorLogEntry->IoControlCode = 0;
            errorLogEntry->RetryCount = 0;
            errorLogEntry->UniqueErrorValue = uniqueErrorValue;
            errorLogEntry->FinalStatus = status;
            for (i = 0; i < dumpCount; i++)
                errorLogEntry->DumpData[i] = dumpData[i];

            IoWriteErrorLogEntry(errorLogEntry);
        }
    }

    if (!NT_SUCCESS(status)) {

        //
        // The initialization failed.  Cleanup resources before exiting.
        //
        //
        // Note:  No need/way to undo the KeInitializeDpc or
        //        KeInitializeTimer calls.
        //

        if (resources) {

            //
            // Call IoReportResourceUsage to remove the resources from
            // the map.
            //

            resources->Count = 0;

            IoReportResourceUsage(
                BaseDeviceName,
                DriverObject,
                NULL,
                0,
                portDeviceObject,
                resources,
                resourceListSize,
                FALSE,
                &conflictDetected
                );

        }

        if (deviceExtension) {
            if (deviceExtension->InterruptObject != NULL)
                IoDisconnectInterrupt(deviceExtension->InterruptObject);
            if (deviceExtension->Configuration.UnmapRegistersRequired) {

                MmUnmapIoSpace(
                    deviceExtension->Configuration.DeviceRegisters[0],
                    deviceExtension->Configuration.PortList[0].u.Port.Length
                    );
            }
            if (deviceExtension->InputData)
                ExFreePool(deviceExtension->InputData);
        }
        if (portDeviceObject)
            IoDeleteDevice(portDeviceObject);
    }

    //
    // Free the resource list.
    //
    // N.B.  If we ever decide to hang on to the resource list instead,
    //       we need to allocate it from non-paged pool (it is now paged pool).
    //

    if (resources)
        ExFreePool(resources);

    //
    // Free the unicode strings.
    //

    if (deviceNameSuffix.MaximumLength != 0)
        ExFreePool(deviceNameSuffix.Buffer);
    if (fullDeviceName.MaximumLength != 0)
        ExFreePool(fullDeviceName.Buffer);


    SerMouPrint((1,"SERMOUSE-SerialMouseInitialize: exit\n"));

}

VOID
SerialMouseUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{
    UNREFERENCED_PARAMETER(DriverObject);

    SerMouPrint((2, "SERMOUSE-SerialMouseUnload: enter\n"));
    SerMouPrint((2, "SERMOUSE-SerialMouseUnload: exit\n"));
}

VOID
SerMouBuildResourceList(
    IN PDEVICE_EXTENSION DeviceExtension,
    OUT PCM_RESOURCE_LIST *ResourceList,
    OUT PULONG ResourceListSize
    )

/*++

Routine Description:

    Creates a resource list that is used to query or report resource usage.

Arguments:

    DeviceExtension - Pointer to the port's device extension.

    ResourceList - Pointer to a pointer to the resource list to be allocated
        and filled.

    ResourceListSize - Pointer to the returned size of the resource
        list (in bytes).

Return Value:

    None.  If the call succeeded, *ResourceList points to the built
    resource list and *ResourceListSize is set to the size (in bytes)
    of the resource list; otherwise, *ResourceList is NULL.

Note:

    Memory is allocated here for *ResourceList. It must be
    freed up by the caller, by calling ExFreePool();

--*/

{
    ULONG count = 0;
    PIO_ERROR_LOG_PACKET errorLogEntry;
    ULONG i = 0;
    ULONG j = 0;

    count += DeviceExtension->Configuration.PortListCount;
    if (DeviceExtension->Configuration.MouseInterrupt.Type
        == CmResourceTypeInterrupt)
        count += 1;

    *ResourceListSize = sizeof(CM_RESOURCE_LIST) +
                       ((count - 1) * sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));

    *ResourceList = (PCM_RESOURCE_LIST) ExAllocatePool(
                                            PagedPool,
                                            *ResourceListSize
                                            );

    //
    // Return NULL if the structure could not be allocated.
    // Otherwise, fill in the resource list.
    //

    if (!*ResourceList) {

        //
        // Could not allocate memory for the resource list.
        //

        SerMouPrint((
            1,
            "SERMOUSE-SerMouBuildResourceList: Could not allocate resource list\n"
            ));

        //
        // Log an error.
        //

        errorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
                                              DeviceExtension->DeviceObject,
                                              sizeof(IO_ERROR_LOG_PACKET)
                                              + sizeof(ULONG)
                                              );

        if (errorLogEntry != NULL) {

            errorLogEntry->ErrorCode = SERMOUSE_INSUFFICIENT_RESOURCES;
            errorLogEntry->DumpDataSize = sizeof(ULONG);
            errorLogEntry->SequenceNumber = 0;
            errorLogEntry->MajorFunctionCode = 0;
            errorLogEntry->IoControlCode = 0;
            errorLogEntry->RetryCount = 0;
            errorLogEntry->UniqueErrorValue =
                SERIAL_MOUSE_ERROR_VALUE_BASE + 110;
            errorLogEntry->FinalStatus = STATUS_INSUFFICIENT_RESOURCES;
            errorLogEntry->DumpData[0] = *ResourceListSize;
            *ResourceListSize = 0;

            IoWriteErrorLogEntry(errorLogEntry);
        }

        return;

    }

    RtlZeroMemory(
        *ResourceList,
        *ResourceListSize
        );

    //
    // Concoct one full resource descriptor.
    //

    (*ResourceList)->Count = 1;

    (*ResourceList)->List[0].InterfaceType =
        DeviceExtension->Configuration.InterfaceType;
    (*ResourceList)->List[0].BusNumber =
        DeviceExtension->Configuration.BusNumber;

    //
    // Build the partial resource descriptors for interrupt and port
    // resources from the saved values.
    //

    (*ResourceList)->List[0].PartialResourceList.Count = count;
    if (DeviceExtension->Configuration.MouseInterrupt.Type
        == CmResourceTypeInterrupt)
        (*ResourceList)->List[0].PartialResourceList.PartialDescriptors[i++] =
            DeviceExtension->Configuration.MouseInterrupt;

    for (j = 0; j < DeviceExtension->Configuration.PortListCount; j++) {
        (*ResourceList)->List[0].PartialResourceList.PartialDescriptors[i++] =
            DeviceExtension->Configuration.PortList[j];
    }

}

VOID
SerMouConfiguration(
    IN OUT  PLIST_ENTRY     DeviceExtensionList,
    IN      PUNICODE_STRING RegistryPath,
    IN      PUNICODE_STRING DeviceName
    )

/*++

Routine Description:

    This routine retrieves the configuration information for the mouse.

Arguments:

    DeviceExtensionList - Pointer to an empty list of device extensions.

    RegistryPath - Pointer to the null-terminated Unicode name of the
        registry path for this driver.

    DeviceName - Pointer to the Unicode string that will receive
        the port device name.

Return Value:

    None.  As a side-effect, may set DeviceExtension->HardwarePresent.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    INTERFACE_TYPE interfaceType;
    CONFIGURATION_TYPE controllerType = SerialController;
    CONFIGURATION_TYPE peripheralType = PointerPeripheral;
    ULONG i;
    PDEVICE_EXTENSION_LIST_ENTRY deviceExtensionListEntry;
    PDEVICE_EXTENSION deviceExtension;
    PLIST_ENTRY current;

    for (i=0;
         i < MaximumInterfaceType;
         i++) {

        //
        // Get the hardware registry information for this device.
        //

        interfaceType = i;

        status = IoQueryDeviceDescription(&interfaceType,
                                          NULL,
                                          &controllerType,
                                          NULL,
                                          &peripheralType,
                                          NULL,
                                          SerMouPeripheralListCallout,
                                          (PVOID) DeviceExtensionList);
    }

    //
    // Get the driver's service parameters from the registry (e.g., 
    // user-configurable data input queue size, etc.).  Note that the 
    // service parameters can override information from the hardware
    // registry (e.g., the service parameters can specify that
    // the hardware is on the system, regardless of what the
    // detection logic recognized).
    //

    for (current = DeviceExtensionList->Flink;
         current != DeviceExtensionList;
         current = current->Flink) {

        deviceExtensionListEntry = CONTAINING_RECORD(current,
                                                     DEVICE_EXTENSION_LIST_ENTRY,
                                                     ListEntry);
        deviceExtension = &(deviceExtensionListEntry->DeviceExtension);
        SerMouServiceParameters(deviceExtension, RegistryPath, DeviceName);
    }

    if (IsListEmpty(DeviceExtensionList)) {

        //
        // Get the driver's service parameters from the registry (e.g.,
        // user-configurable data input queue size, etc.).  Note that the
        // service parameters can override information from the hardware
        // registry (e.g., the service parameters can specify that
        // the hardware is on the system, regardless of what the
        // detection logic recognized).
        //

        deviceExtensionListEntry = ExAllocatePool(PagedPool,
                                   sizeof(DEVICE_EXTENSION_LIST_ENTRY));
        if (!deviceExtensionListEntry) {
            return;
        }
        deviceExtension = &(deviceExtensionListEntry->DeviceExtension);
        RtlZeroMemory(deviceExtension, sizeof(DEVICE_EXTENSION));

        SerMouServiceParameters(
            deviceExtension,
            RegistryPath,
            DeviceName
            );

        if (deviceExtension->Configuration.OverrideHardwarePresent !=
            DEFAULT_OVERRIDE_HARDWARE) {

            //
            // There was no information about a pointer peripheral on a
            // serial controller in the hardware registry, but the driver's
            // service parameters specify that we should assume there is
            // a serial mouse on the system anyway.  Attempt to find the
            // hardware registry information for the serial port specified
            // in the override portion of the driver service parameters.
            //

            for (i=0;
                 i < MaximumInterfaceType && !deviceExtension->HardwarePresent;
                 i++) {

                ULONG peripheralNumber =
                    deviceExtension->Configuration.OverrideHardwarePresent - 1;

                //
                // Get the hardware registry information for the serial
                // peripheral specified as the "override".
                //

                interfaceType = i;

                status = IoQueryDeviceDescription(
                             &interfaceType,
                             NULL,
                             &controllerType,
                             NULL,
                             NULL,
                             &peripheralNumber,
                             SerMouPeripheralCallout,
                             (PVOID) deviceExtension
                             );

                if (!deviceExtension->HardwarePresent) {
                    SerMouPrint((
                        1,
                        "SERMOUSE-SerMouConfiguration: IoQueryDeviceDescription for SerialPeripheral on bus type %d failed\n",
                        interfaceType
                        ));
                }
            }

            deviceExtension->HardwarePresent = MOUSE_HARDWARE_PRESENT;

            InsertTailList(DeviceExtensionList,
                           &(deviceExtensionListEntry->ListEntry));

        } else {
            ExFreePool(deviceExtensionListEntry);
        }
    }

    //
    // Initialize mouse-specific configuration parameters.
    //

    for (current = DeviceExtensionList->Flink;
         current != DeviceExtensionList;
         current = current->Flink) {

        deviceExtensionListEntry = CONTAINING_RECORD(current,
                                                     DEVICE_EXTENSION_LIST_ENTRY,
                                                     ListEntry);
        deviceExtension = &(deviceExtensionListEntry->DeviceExtension);
        deviceExtension->Configuration.MouseAttributes.MouseIdentifier =
            MOUSE_SERIAL_HARDWARE;
    }
}

VOID
SerMouDisableInterrupts(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is called from StartIo synchronously.  It touches the
    hardware to disable interrupts.

Arguments:

    Context - Pointer to the device extension.

Return Value:

    None.

--*/

{
    PUCHAR port;
    PLONG  enableCount;
    UCHAR  mask;

    //
    // Decrement the reference count for device enables.
    //

    enableCount = &((PDEVICE_EXTENSION) Context)->MouseEnableCount;
    *enableCount = *enableCount - 1;

    if (*enableCount == 0) {

        //
        // Get the port register address.
        //

        port = ((PDEVICE_EXTENSION) Context)->Configuration.DeviceRegisters[0];

        //
        // Disable hardware interrupts.
        //

        WRITE_PORT_UCHAR((PUCHAR) (port + ACE_IER), 0);

        //
        // Turn off modem control output line 2.
        //

        mask = READ_PORT_UCHAR((PUCHAR) (port + ACE_MCR));
        WRITE_PORT_UCHAR((PUCHAR) (port + ACE_MCR), (UCHAR)(mask & ~ACE_OUT2));
    }
}

VOID
SerMouEnableInterrupts(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is called from StartIo synchronously.  It touches the
    hardware to enable interrupts.

Arguments:

    Context - Pointer to the device extension.

Return Value:

    None.

--*/

{
    PUCHAR port;
    PLONG  enableCount;
    UCHAR  mask;


    enableCount = &((PDEVICE_EXTENSION) Context)->MouseEnableCount;

    if (*enableCount == 0) {

        //
        // Get the port register address.
        //

        port = ((PDEVICE_EXTENSION) Context)->Configuration.DeviceRegisters[0];

        //
        // Enable the serial mouse's interrupt at the i8250.
        //

        WRITE_PORT_UCHAR((PUCHAR) (port + ACE_IER), ACE_ERBFI);

        //
        // Turn on modem control output line 2.
        //

        mask = READ_PORT_UCHAR((PUCHAR) (port + ACE_MCR));
        WRITE_PORT_UCHAR((PUCHAR) (port + ACE_MCR), (UCHAR)(mask | ACE_OUT2));

        //
        // Clean possible garbage in uart input buffer.
        //

        UARTFlushReadBuffer(port);
    }

    //
    // Increment the reference count for device enables.
    //

    *enableCount = *enableCount + 1;
}

NTSTATUS
SerMouInitializeHardware(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine initializes the serial mouse/ballpoint.  Note that this
    routine is only called at initialization time, so synchronization is
    not required.

Arguments:

    DeviceObject - Pointer to the device object.

Return Value:

    STATUS_SUCCESS if a pointing device is detected, otherwise STATUS_UNSUCCESSFUL

--*/

{
    PDEVICE_EXTENSION deviceExtension;
    PUCHAR port;
    MOUSETYPE mouseType;
    ULONG hardwareButtons;
    NTSTATUS status = STATUS_UNSUCCESSFUL;

    SerMouPrint((2, "SERMOUSE-SerMouInitializeHardware: enter\n"));

    //
    // Grab useful configuration parameters from the device extension.
    //

    deviceExtension = DeviceObject->DeviceExtension;
    port = deviceExtension->Configuration.DeviceRegisters[0];

    //
    // Save the UART initial state.
    //

    SerMouPrint
        ((
        2,
        "SERMOUSE-SerMouInitializeHardware: Saving UART state\n"
        ));

    UARTGetState(
        port, 
        &deviceExtension->Configuration.UartSaved, 
        deviceExtension->Configuration.BaudClock
        );

    //
    // Disable interrupts at the i8250.
    //

    SerMouPrint
        ((
        2,
        "SERMOUSE-SerMouInitializeHardware: Disabling UART interrupts\n"
        ));

    UARTSetInterruptCtrl(port, 0);


    SerMouPrint
        ((
        2,
        "SERMOUSE-SerMouInitializeHardware: Setting UART line control\n"
        ));

    if ((mouseType = MSerDetect(port, deviceExtension->Configuration.BaudClock))
            != NO_MOUSE) {
        status = STATUS_SUCCESS;
        switch (mouseType) {
        case MOUSE_2B:
            deviceExtension->ProtocolHandler =
                MSerSetProtocol(port, MSER_PROTOCOL_MP);
            hardwareButtons = 2;
            deviceExtension->HardwarePresent = MOUSE_HARDWARE_PRESENT;
            break;
        case MOUSE_3B:
            deviceExtension->ProtocolHandler =
                MSerSetProtocol(port, MSER_PROTOCOL_MP);
            hardwareButtons = 3;
            deviceExtension->HardwarePresent = MOUSE_HARDWARE_PRESENT;
            break;
        case BALLPOINT:
            deviceExtension->ProtocolHandler =
                MSerSetProtocol(port, MSER_PROTOCOL_BP);
            deviceExtension->HardwarePresent |= BALLPOINT_HARDWARE_PRESENT;
            deviceExtension->Configuration.MouseAttributes.MouseIdentifier =
                BALLPOINT_SERIAL_HARDWARE;
            hardwareButtons = 2;
            break;
        case MOUSE_Z:
            deviceExtension->ProtocolHandler =
                MSerSetProtocol(port, MSER_PROTOCOL_Z);
            hardwareButtons = 3;
            deviceExtension->HardwarePresent |= WHEELMOUSE_HARDWARE_PRESENT;
            deviceExtension->Configuration.MouseAttributes.MouseIdentifier =
                WHEELMOUSE_SERIAL_HARDWARE;
            break;
        }
    }
    else if (CSerDetect(port, deviceExtension->Configuration.BaudClock,
                        &hardwareButtons)) {
        status = STATUS_SUCCESS;
        deviceExtension->ProtocolHandler =
            CSerSetProtocol(port, CSER_PROTOCOL_MM);
    }
    else {
        deviceExtension->ProtocolHandler = NULL;
        hardwareButtons = MOUSE_NUMBER_OF_BUTTONS;
    }


    //
    // If the hardware wasn't overridden, set the number of buttons 
    // according to the protocol.
    //

    if (deviceExtension->Configuration.OverrideHardwarePresent == DEFAULT_OVERRIDE_HARDWARE) {

        deviceExtension->Configuration.MouseAttributes.NumberOfButtons = 
            (USHORT) hardwareButtons;

    }

    if (NT_SUCCESS(status)) {

        //
        // Make sure the FIFO is turned off.
        //

        UARTSetFifo(port, 0);

        //
        // Clean up anything left in the receive buffer.
        //

        UARTFlushReadBuffer(port);

    }
    else {

        //
        // Restore the hardware to its previous state.
        //

        UARTSetState(
            port, 
            &deviceExtension->Configuration.UartSaved,
            deviceExtension->Configuration.BaudClock
            );
    }

    SerMouPrint((2, "SERMOUSE-SerMouInitializeHardware: exit\n"));

    return status;

}

NTSTATUS
SerMouPeripheralCallout(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    )

/*++

Routine Description:

    This is the callout routine sent as a parameter to
    IoQueryDeviceDescription.  It grabs the pointer controller and
    peripheral configuration information.

Arguments:

    Context - Context parameter that was passed in by the routine
        that called IoQueryDeviceDescription.

    PathName - The full pathname for the registry key.

    BusType - Bus interface type (Isa, Eisa, Mca, etc.).

    BusNumber - The bus sub-key (0, 1, etc.).

    BusInformation - Pointer to the array of pointers to the full value
        information for the bus.

    ControllerType - The controller type (should be SerialController).

    ControllerNumber - The controller sub-key (0, 1, etc.).

    ControllerInformation - Pointer to the array of pointers to the full
        value information for the controller key.

    PeripheralType - The peripheral type (should be PointerPeripheral).

    PeripheralNumber - The peripheral sub-key.

    PeripheralInformation - Pointer to the array of pointers to the full
        value information for the peripheral key.


Return Value:

    None.  If successful, will have the following side-effects:

        - Sets DeviceObject->DeviceExtension->HardwarePresent.
        - Sets configuration fields in
          DeviceObject->DeviceExtension->Configuration.

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    PSERIAL_MOUSE_CONFIGURATION_INFORMATION configuration;
    UNICODE_STRING unicodeIdentifier;
    PUCHAR controllerData;
    NTSTATUS status = STATUS_SUCCESS;
    ULONG i;
    ULONG listCount;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR resourceDescriptor;
    PCM_SERIAL_DEVICE_DATA serialSpecificData;
    ANSI_STRING ansiString;
    BOOLEAN defaultInterruptShare;
    KINTERRUPT_MODE defaultInterruptMode;

#ifdef PNP_IDENTIFY
    PHWDESC_INFO hardwareInfo;
#endif

    SerMouPrint((
        1,
        "SERMOUSE-SerMouPeripheralCallout: Path @ 0x%x, Bus Type 0x%x, Bus Number 0x%x\n",
        PathName, BusType, BusNumber
        ));
    SerMouPrint((
        1,
        "    Controller Type 0x%x, Controller Number 0x%x, Controller info @ 0x%x\n",
        ControllerType, ControllerNumber, ControllerInformation
        ));
    SerMouPrint((
        1,
        "    Peripheral Type 0x%x, Peripheral Number 0x%x, Peripheral info @ 0x%x\n",
        PeripheralType, PeripheralNumber, PeripheralInformation
        ));

    //
    // If we already have the configuration information for the
    // mouse peripheral, just return.
    //

    deviceExtension = (PDEVICE_EXTENSION) Context;

#ifdef PNP_IDENTIFY

    //
    // Kludge to identify ourselves so that PnP can determine which driver owns
    // which arc device
    //

    hardwareInfo = (PHWDESC_INFO) ((PDEVICE_EXTENSION) deviceExtension + 1);
    hardwareInfo->InterfaceType = BusType;
    hardwareInfo->InterfaceNumber = BusNumber;
    hardwareInfo->ControllerType = ControllerType;
    hardwareInfo->ControllerNumber = ControllerNumber;
    hardwareInfo->PeripheralType = PeripheralType;
    hardwareInfo->PeripheralNumber = PeripheralNumber;

#endif

    if (deviceExtension->HardwarePresent) {

        //
        // Future: Change driver to handle multiple port devices
        //         (create multiple port device objects).
        //

        return ( status );
    }

    configuration = &deviceExtension->Configuration;

    //
    // If OverrideHardwarePresent is zero, this routine was called
    // as a result of the IoQueryDeviceDescription for serial 
    // PointerPeripheral information.  Otherwise, it was called as
    // a result of the IoQueryDeviceDescription for generic
    // serial controller information.  In the latter case, the 
    // mouse-specific code is skipped.
    //

    if (configuration->OverrideHardwarePresent == 0) {

        //
        // Get the identifier information for the peripheral.  If
        // the peripheral identifier is missing, just return. 
        //
    
        unicodeIdentifier.Length = (USHORT)
            (*(PeripheralInformation + IoQueryDeviceIdentifier))->DataLength;
        if (unicodeIdentifier.Length == 0) {
            return(status);
        }

        unicodeIdentifier.MaximumLength = unicodeIdentifier.Length;
        unicodeIdentifier.Buffer = (PWSTR) (((PUCHAR)(*(PeripheralInformation +
                                   IoQueryDeviceIdentifier))) +
                                   (*(PeripheralInformation +
                                   IoQueryDeviceIdentifier))->DataOffset);
        SerMouPrint((
            1,
            "SERMOUSE-SerMouPeripheralCallout: Mouse type %ws\n",
            unicodeIdentifier.Buffer
            ));
    
        //
        // Verify that this is a serial mouse or ballpoint.
        //
    
        status = RtlUnicodeStringToAnsiString(
                     &ansiString,
                     &unicodeIdentifier,
                     TRUE
                     );
    
        if (!NT_SUCCESS(status)) {
            SerMouPrint((
                1,
                "SERMOUSE-SerMouPeripheralCallout: Could not convert identifier to Ansi\n"
                ));
            return(status);
        }
    
        if (strstr(ansiString.Buffer, "SERIAL MOUSE")) {
    
            //
            // There is a serial mouse/ballpoint.
            //
    
            deviceExtension->HardwarePresent = MOUSE_HARDWARE_PRESENT;
    
        }

        RtlFreeAnsiString(&ansiString);
    } else {
 
        //
        // Go ahead and assume, because of the service parameter override,
        // that there is serial mouse on this serial controller.
        //

        if ((ULONG)(configuration->OverrideHardwarePresent - 1) == ControllerNumber) {
        deviceExtension->HardwarePresent = MOUSE_HARDWARE_PRESENT;
        }
    }

    if (!deviceExtension->HardwarePresent)
        return(status);

    //
    // Get the bus information.
    //

    configuration->InterfaceType = BusType;
    configuration->BusNumber = BusNumber;
    configuration->FloatingSave = SERIAL_MOUSE_FLOATING_SAVE;

    if (BusType == MicroChannel) {
        defaultInterruptShare = TRUE;
        defaultInterruptMode = LevelSensitive;
    } else {
        defaultInterruptShare = SERIAL_MOUSE_INTERRUPT_SHARE;
        defaultInterruptMode = SERIAL_MOUSE_INTERRUPT_MODE;
    }

    //
    // Look through the resource list for interrupt and port
    // configuration information.
    //

    if ((*(ControllerInformation + IoQueryDeviceConfigurationData))->DataLength != 0){
        controllerData = ((PUCHAR) (*(ControllerInformation +
                                   IoQueryDeviceConfigurationData))) +
                                   (*(ControllerInformation +
                                   IoQueryDeviceConfigurationData))->DataOffset;
    
        controllerData += FIELD_OFFSET(CM_FULL_RESOURCE_DESCRIPTOR,
                                       PartialResourceList);
    
        listCount = ((PCM_PARTIAL_RESOURCE_LIST) controllerData)->Count;
    
        resourceDescriptor =
            ((PCM_PARTIAL_RESOURCE_LIST) controllerData)->PartialDescriptors;
    
        for (i = 0; i < listCount; i++, resourceDescriptor++) {
            switch(resourceDescriptor->Type) {
                case CmResourceTypePort:
    
                    //
                    // Copy the port information.  Note that we only expect to
                    // find one port range for the serial mouse/ballpoint.
                    //
    
                    configuration->PortListCount = 0;
                    configuration->PortList[configuration->PortListCount] =
                        *resourceDescriptor;
                    configuration->PortList[configuration->PortListCount].ShareDisposition =
                        SERIAL_MOUSE_REGISTER_SHARE? CmResourceShareShared:
                                                     CmResourceShareDeviceExclusive;
                    configuration->PortListCount += 1;
    
                    break;
    
                case CmResourceTypeInterrupt:
    
                    //
                    // Copy the interrupt information.
                    //
    
                    configuration->MouseInterrupt = *resourceDescriptor;
                    configuration->MouseInterrupt.ShareDisposition =
                        defaultInterruptShare? CmResourceShareShared :
                                               CmResourceShareDeviceExclusive;
    
                    break;
    
                case CmResourceTypeDeviceSpecific:
    
                    //
                    // Get the clock rate.  This is used to determine the
                    // divisor for setting the serial baud rate.
                    //
                   
                    serialSpecificData = 
                        (PCM_SERIAL_DEVICE_DATA) (((PUCHAR) resourceDescriptor) 
                            + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));
                    configuration->BaudClock = 
                            serialSpecificData->BaudClock;
                    break;
    
                default:
                    break;
            }
        }
    }

    //
    // If no interrupt configuration information was found, use the
    // driver defaults.
    //

    if (!(configuration->MouseInterrupt.Type & CmResourceTypeInterrupt)) {

        SerMouPrint((
            1,
            "SERMOUSE-SerMouPeripheralCallout: Using default mouse interrupt config\n"
            ));

        configuration->MouseInterrupt.Type = CmResourceTypeInterrupt;
        configuration->MouseInterrupt.ShareDisposition =
            defaultInterruptShare? CmResourceShareShared :
                                   CmResourceShareDeviceExclusive;
        configuration->MouseInterrupt.Flags =
            (defaultInterruptMode == Latched)?
                CM_RESOURCE_INTERRUPT_LATCHED :
                CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
        configuration->MouseInterrupt.u.Interrupt.Level = MOUSE_IRQL;
        configuration->MouseInterrupt.u.Interrupt.Vector = MOUSE_VECTOR;
    }

    SerMouPrint((
        1,
        "SERMOUSE-SerMouPeripheralCallout: Mouse config --\n"
        ));
    SerMouPrint((
        1,
        "\t%s, %s, Irq = %d\n",
        configuration->MouseInterrupt.ShareDisposition == CmResourceShareShared?
            "Sharable" : "NonSharable",
        configuration->MouseInterrupt.Flags == CM_RESOURCE_INTERRUPT_LATCHED?
            "Latched" : "Level Sensitive",
        configuration->MouseInterrupt.u.Interrupt.Vector
        ));

    //
    // If no port configuration information was found, use the
    // driver defaults.
    //

    if (configuration->PortListCount == 0) {

        //
        // No port configuration information was found, so use
        // the driver defaults.
        //

        SerMouPrint((
            1,
            "SERMOUSE-SerMouPeripheralCallout: Using default port config\n"
            ));

        configuration->PortList[0].Type = CmResourceTypePort;
        configuration->PortList[0].Flags = SERIAL_MOUSE_PORT_TYPE;
        configuration->PortList[0].ShareDisposition =
            SERIAL_MOUSE_REGISTER_SHARE? CmResourceShareShared:
                                         CmResourceShareDeviceExclusive;
        configuration->PortList[0].u.Port.Start.LowPart =
            SERIAL_MOUSE_PHYSICAL_BASE;
        configuration->PortList[0].u.Port.Start.HighPart = 0;
        configuration->PortList[0].u.Port.Length =
            SERIAL_MOUSE_REGISTER_LENGTH;

        configuration->PortListCount = 1;
    }

    for (i = 0; i < configuration->PortListCount; i++) {

        SerMouPrint((
            1,
            "\t%s, Ports 0x%x - 0x%x\n",
            configuration->PortList[i].ShareDisposition
                == CmResourceShareShared?  "Sharable" : "NonSharable",
            configuration->PortList[i].u.Port.Start.LowPart,
            configuration->PortList[i].u.Port.Start.LowPart +
                configuration->PortList[i].u.Port.Length - 1
            ));
    }

    //
    // If no baud clock information was found, use the driver defaults.
    //

    if (configuration->BaudClock == 0) {
        configuration->BaudClock = MOUSE_BAUD_CLOCK;
    }

    SerMouPrint((
        1,
        "\tBaud clock %ld Hz\n",
        configuration->BaudClock
        ));

    return( status );
}

NTSTATUS
SerMouPeripheralListCallout(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    )

/*++

Routine Description:

    This is the callout routine sent as a parameter to
    IoQueryDeviceDescription.  It grabs the pointer controller and
    peripheral configuration information.

Arguments:

    Context - Context parameter that was passed in by the routine
        that called IoQueryDeviceDescription.

    PathName - The full pathname for the registry key.

    BusType - Bus interface type (Isa, Eisa, Mca, etc.).

    BusNumber - The bus sub-key (0, 1, etc.).

    BusInformation - Pointer to the array of pointers to the full value
        information for the bus.

    ControllerType - The controller type (should be SerialController).

    ControllerNumber - The controller sub-key (0, 1, etc.).

    ControllerInformation - Pointer to the array of pointers to the full
        value information for the controller key.

    PeripheralType - The peripheral type (should be PointerPeripheral).

    PeripheralNumber - The peripheral sub-key.

    PeripheralInformation - Pointer to the array of pointers to the full
        value information for the peripheral key.


Return Value:

    None.  If successful, will have the following side-effects:

        - Sets DeviceObject->DeviceExtension->HardwarePresent.
        - Sets configuration fields in
          DeviceObject->DeviceExtension->Configuration.

--*/
{
    PLIST_ENTRY                     deviceExtensionList = Context;
    PDEVICE_EXTENSION_LIST_ENTRY    deviceExtensionListEntry;
    PDEVICE_EXTENSION               deviceExtension;
    NTSTATUS                        status;

    deviceExtensionListEntry = ExAllocatePool(PagedPool,
                               sizeof(DEVICE_EXTENSION_LIST_ENTRY));
    if (!deviceExtensionListEntry) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    deviceExtension = &(deviceExtensionListEntry->DeviceExtension);
    RtlZeroMemory(deviceExtension, sizeof(DEVICE_EXTENSION));

    status = SerMouPeripheralCallout(deviceExtension, PathName, BusType,
                                     BusNumber, BusInformation, ControllerType,
                                     ControllerNumber, ControllerInformation,
                                     PeripheralType, PeripheralNumber,
                                     PeripheralInformation);

    if (deviceExtension->HardwarePresent) {

        InsertTailList(deviceExtensionList,
                       &(deviceExtensionListEntry->ListEntry));

    } else {
        ExFreePool(deviceExtensionListEntry);
    }

    return status;
}

VOID
SerMouServiceParameters(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PUNICODE_STRING RegistryPath,
    IN PUNICODE_STRING DeviceName
    )

/*++

Routine Description:

    This routine retrieves this driver's service parameters information
    from the registry.

Arguments:

    DeviceExtension - Pointer to the device extension.

    RegistryPath - Pointer to the null-terminated Unicode name of the
        registry path for this driver.

    DeviceName - Pointer to the Unicode string that will receive
        the port device name.

Return Value:

    None.  As a side-effect, sets fields in DeviceExtension->Configuration.

--*/

{
    PSERIAL_MOUSE_CONFIGURATION_INFORMATION configuration;
    PRTL_QUERY_REGISTRY_TABLE parameters = NULL;
    UNICODE_STRING parametersPath;
    ULONG defaultDataQueueSize = DATA_QUEUE_SIZE;
    ULONG numberOfButtons = MOUSE_NUMBER_OF_BUTTONS;
    USHORT defaultNumberOfButtons = MOUSE_NUMBER_OF_BUTTONS;
    ULONG sampleRate = MOUSE_SAMPLE_RATE;
    USHORT defaultSampleRate = MOUSE_SAMPLE_RATE;
    UNICODE_STRING defaultUnicodeName;
    LONG defaultHardwarePresent = DEFAULT_OVERRIDE_HARDWARE;
    NTSTATUS status = STATUS_SUCCESS;
    PWSTR path = NULL;
    ULONG overrideBits, comPort, i;
    USHORT queriesPlusOne = 6;
    BOOLEAN defaultInterruptShare;
    KINTERRUPT_MODE defaultInterruptMode;

    configuration = &DeviceExtension->Configuration;
    parametersPath.Buffer = NULL;

    //
    // Registry path is already null-terminated, so just use it.
    //

    path = RegistryPath->Buffer;

    if (NT_SUCCESS(status)) {

        //
        // Allocate the Rtl query table.
        //

        parameters = ExAllocatePool(
                         PagedPool,
                         sizeof(RTL_QUERY_REGISTRY_TABLE) * queriesPlusOne
                         );

        if (!parameters) {

            SerMouPrint((
                1,
                "SERMOUSE-SerMouServiceParameters: Couldn't allocate table for Rtl query to parameters for %ws\n",
                 path
                 ));

            status = STATUS_UNSUCCESSFUL;

        } else {

            RtlZeroMemory(
                parameters,
                sizeof(RTL_QUERY_REGISTRY_TABLE) * queriesPlusOne
                );

            //
            // Form a path to this driver's Parameters subkey.
            //

            RtlInitUnicodeString(
                &parametersPath,
                NULL
                );

            parametersPath.MaximumLength = RegistryPath->Length +
                                           sizeof(L"\\Parameters");

            parametersPath.Buffer = ExAllocatePool(
                                        PagedPool,
                                        parametersPath.MaximumLength
                                        );

            if (!parametersPath.Buffer) {

                SerMouPrint((
                    1,
                    "SERMOUSE-SerMouServiceParameters: Couldn't allocate string for path to parameters for %ws\n",
                     path
                    ));

                status = STATUS_UNSUCCESSFUL;

            }
        }
    }

    if (NT_SUCCESS(status)) {

        //
        // Form the parameters path.
        //

        RtlZeroMemory(
            parametersPath.Buffer,
            parametersPath.MaximumLength
            );
        RtlAppendUnicodeToString(
            &parametersPath,
            path
            );
        RtlAppendUnicodeToString(
            &parametersPath,
            L"\\Parameters"
            );

        SerMouPrint((
            1,
            "SERMOUSE-SerMouServiceParameters: parameters path is %ws\n",
             parametersPath.Buffer
            ));

        //
        // Form the default pointer port device name, in case it is not
        // specified in the registry.
        //

        RtlInitUnicodeString(
            &defaultUnicodeName,
            DD_POINTER_PORT_BASE_NAME_U
            );

        //
        // Gather all of the "user specified" information from
        // the registry.
        //

        parameters[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[0].Name = L"MouseDataQueueSize";
        parameters[0].EntryContext =
            &configuration->MouseAttributes.InputDataQueueLength;
        parameters[0].DefaultType = REG_DWORD;
        parameters[0].DefaultData = &defaultDataQueueSize;
        parameters[0].DefaultLength = sizeof(ULONG);

        parameters[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[1].Name = L"NumberOfButtons";
        parameters[1].EntryContext = &numberOfButtons;
        parameters[1].DefaultType = REG_DWORD;
        parameters[1].DefaultData = &defaultNumberOfButtons;
        parameters[1].DefaultLength = sizeof(USHORT);

        parameters[2].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[2].Name = L"SampleRate";
        parameters[2].EntryContext = &sampleRate;
        parameters[2].DefaultType = REG_DWORD;
        parameters[2].DefaultData = &defaultSampleRate;
        parameters[2].DefaultLength = sizeof(USHORT);

        parameters[3].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[3].Name = L"PointerDeviceBaseName";
        parameters[3].EntryContext = DeviceName;
        parameters[3].DefaultType = REG_SZ;
        parameters[3].DefaultData = defaultUnicodeName.Buffer;
        parameters[3].DefaultLength = 0;

        parameters[4].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[4].Name = L"OverrideHardwareBitstring";
        parameters[4].EntryContext = &configuration->OverrideHardwarePresent;
        parameters[4].DefaultType = REG_DWORD;
        parameters[4].DefaultData = &defaultHardwarePresent;
        parameters[4].DefaultLength = sizeof(LONG);

        status = RtlQueryRegistryValues(
                     RTL_REGISTRY_ABSOLUTE,
                     parametersPath.Buffer,
                     parameters,
                     NULL,
                     NULL
                     );

    }

    if (!NT_SUCCESS(status)) {

        SerMouPrint((
            1,
            "SERMOUSE-SerMouServiceParameters: RtlQueryRegistryValues failed with 0x%x\n",
            status
            ));

        //
        // Go ahead and assign driver defaults.
        //

        configuration->MouseAttributes.InputDataQueueLength =
            defaultDataQueueSize;
        configuration->OverrideHardwarePresent = DEFAULT_OVERRIDE_HARDWARE;
        RtlCopyUnicodeString(DeviceName, &defaultUnicodeName);
    }

    //
    // Check for overrides from the Service Parameters.  Allow the
    // information from the Hardware Registry to be overridden.  For
    // example, the Service Parameters can specify that the hardware
    // is present on a given COM port, even though the Hardware Registry 
    // indicated otherwise.
    //

    if (configuration->OverrideHardwarePresent != defaultHardwarePresent) {
        if ((!DeviceExtension->HardwarePresent) && (configuration->OverrideHardwarePresent)) {

            //
            // Behave as if the hardware is on the system, even though
            // this conflicts with the Hardware Registry information.  Set
            // the hardware information fields in the device extension to
            // system defaults depending on which COM port was specified
            // by the OverrideHardwareBitstring in the registry.  Any field 
            // overrides from the Service Parameters will be applied later.
            //

            for (overrideBits=configuration->OverrideHardwarePresent,comPort=0;
                 overrideBits != 0;
                 overrideBits >>= 1) {

                //
                // Get the desired COM port from the override bitstring.
                // A 0x1 implies com1, 0x2 implies com2, 0x4 implies com3,
                // 0x8 implies com4, and so on.
                //
                // NOTE: We really only support com1 and com2 today. 
                //

                comPort += 1;
                if (overrideBits & 1) {
                    break;
                }
            }

            //
            // Set the common configuration fields.
            //

            configuration->InterfaceType = SERIAL_MOUSE_INTERFACE_TYPE;
            configuration->BusNumber = SERIAL_MOUSE_BUS_NUMBER;
            configuration->FloatingSave = SERIAL_MOUSE_FLOATING_SAVE;
            configuration->MouseInterrupt.Type = CmResourceTypeInterrupt;

            if (configuration->InterfaceType == MicroChannel) {
                defaultInterruptShare = TRUE;
                defaultInterruptMode = LevelSensitive;
            } else {
                defaultInterruptShare = SERIAL_MOUSE_INTERRUPT_SHARE;
                defaultInterruptMode = SERIAL_MOUSE_INTERRUPT_MODE;
            }

            configuration->MouseInterrupt.ShareDisposition =
                defaultInterruptShare? CmResourceShareShared :
                                       CmResourceShareDeviceExclusive;
            configuration->MouseInterrupt.Flags =
                (defaultInterruptMode == Latched)?
                    CM_RESOURCE_INTERRUPT_LATCHED :
                    CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;

            configuration->PortList[0].Type = CmResourceTypePort;
            configuration->PortList[0].Flags = SERIAL_MOUSE_PORT_TYPE;
            configuration->PortList[0].ShareDisposition =
                SERIAL_MOUSE_REGISTER_SHARE? CmResourceShareShared:
                                             CmResourceShareDeviceExclusive;
            configuration->PortList[0].u.Port.Start.HighPart = 0;
            configuration->PortList[0].u.Port.Length =
                SERIAL_MOUSE_REGISTER_LENGTH;

            configuration->PortListCount = 1;
    
            switch (comPort) {
                case 2:
    
                    //
                    // Use com2 for the mouse.
                    //

                    configuration->MouseInterrupt.u.Interrupt.Level = 
                        MOUSE_COM2_IRQL;
                    configuration->MouseInterrupt.u.Interrupt.Vector = 
                        MOUSE_COM2_VECTOR;
                    configuration->PortList[0].u.Port.Start.LowPart =
                        SERIAL_MOUSE_COM2_PHYSICAL_BASE;
                    break;

                case 1:
                default:
    
                    //
                    // Assume com1 for the mouse, unless com2 was specified.
                    //
    
                    comPort = 1;
                    configuration->MouseInterrupt.u.Interrupt.Level = 
                        MOUSE_COM1_IRQL;
                    configuration->MouseInterrupt.u.Interrupt.Vector = 
                        MOUSE_COM1_VECTOR;
                    configuration->PortList[0].u.Port.Start.LowPart =
                        SERIAL_MOUSE_COM1_PHYSICAL_BASE;
                    break;
            }
    
            configuration->OverrideHardwarePresent = comPort;
        
            SerMouPrint((
                1,
                "SERMOUSE-SerMouServiceParameters: Overriding hardware registry --\n"
                ));
            SerMouPrint((
                1,
                "SERMOUSE-SerMouServiceParameters: Mouse config --\n"
                ));
            SerMouPrint((
                1,
                "\t%s, %s, Irq = %d\n",
                configuration->MouseInterrupt.ShareDisposition == CmResourceShareShared?
                    "Sharable" : "NonSharable",
                configuration->MouseInterrupt.Flags == CM_RESOURCE_INTERRUPT_LATCHED?
                    "Latched" : "Level Sensitive",
                configuration->MouseInterrupt.u.Interrupt.Vector
                ));

            for (i = 0; i < configuration->PortListCount; i++) {
        
                SerMouPrint((
                    1,
                    "\t%s, Ports 0x%x - 0x%x\n",
                    configuration->PortList[i].ShareDisposition
                        == CmResourceShareShared?  "Sharable" : "NonSharable",
                    configuration->PortList[i].u.Port.Start.LowPart,
                    configuration->PortList[i].u.Port.Start.LowPart +
                        configuration->PortList[i].u.Port.Length - 1
                    ));
            }

        }

    }

    if ((DeviceExtension->HardwarePresent) ||
        (configuration->OverrideHardwarePresent != defaultHardwarePresent)) {

        SerMouPrint((
            1,
            "SERMOUSE-SerMouServiceParameters: Pointer port base name = %ws\n",
            DeviceName->Buffer
            ));

        if (configuration->MouseAttributes.InputDataQueueLength == 0) {

            SerMouPrint((
                1,
                "SERMOUSE-SerMouServiceParameters: overriding MouseInputDataQueueLength = 0x%x\n",
                configuration->MouseAttributes.InputDataQueueLength
                ));

            configuration->MouseAttributes.InputDataQueueLength =
                defaultDataQueueSize;
        }

        configuration->MouseAttributes.InputDataQueueLength *=
            sizeof(MOUSE_INPUT_DATA);

        SerMouPrint((
            1,
            "SERMOUSE-SerMouServiceParameters: MouseInputDataQueueLength = 0x%x\n",
            configuration->MouseAttributes.InputDataQueueLength
            ));

        configuration->MouseAttributes.NumberOfButtons = (USHORT) numberOfButtons;
        SerMouPrint((
            1,
            "SERMOUSE-SerMouServiceParameters: NumberOfButtons = %d\n",
            configuration->MouseAttributes.NumberOfButtons
            ));

        configuration->MouseAttributes.SampleRate = (USHORT) sampleRate;
        SerMouPrint((
            1,
            "SERMOUSE-SerMouServiceParameters: SampleRate = %d\n",
            configuration->MouseAttributes.SampleRate
            ));
    }

    //
    // Free the allocated memory before returning.
    //

    if (parametersPath.Buffer)
        ExFreePool(parametersPath.Buffer);
    if (parameters)
        ExFreePool(parameters);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\sermouse\uart.c ===
/*++

Copyright (c) 1993  Microsoft Corporation
Copyright (c) 1993  Logitech Inc.

Module Name:

    uart.c

Abstract:

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/

#include "ntddk.h"
#include "uart.h"
#include "sermouse.h"
#include "debug.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,UARTSetFifo)
#pragma alloc_text(INIT,UARTGetInterruptCtrl)
#pragma alloc_text(INIT,UARTSetInterruptCtrl)
#pragma alloc_text(INIT,UARTGetLineCtrl)
#pragma alloc_text(INIT,UARTSetLineCtrl)
#pragma alloc_text(INIT,UARTGetModemCtrl)
#pragma alloc_text(INIT,UARTSetModemCtrl)
#pragma alloc_text(INIT,UARTSetDlab)
#pragma alloc_text(INIT,UARTGetBaudRate)
#pragma alloc_text(INIT,UARTSetBaudRate)
#pragma alloc_text(INIT,UARTGetState)
#pragma alloc_text(INIT,UARTSetState)
#pragma alloc_text(INIT,UARTReadChar)
#pragma alloc_text(INIT,UARTIsTransmitEmpty)
#pragma alloc_text(INIT,UARTWriteChar)
#pragma alloc_text(INIT,UARTWriteString)
#endif // ALLOC_PRAGMA

//
// Constants
//


VOID
UARTSetFifo(
    PUCHAR Port,
    UCHAR Value
    )
/*++

Routine Description:

    Set the FIFO register.

Arguments:

    Port - Pointer to the serial port.

    Value - The FIFO control mask.

Return Value:

    None.

--*/
{
    WRITE_PORT_UCHAR(Port + ACE_IIDR, Value);
}
UCHAR
UARTGetInterruptCtrl(
    PUCHAR Port
    )
/*++

Routine Description:

    Get the serial port interrupt control register.

Arguments:

    Port - Pointer to the serial port.

Return Value:

    Serial port interrupt control register value.

--*/
{
    return READ_PORT_UCHAR(Port + ACE_IER);
}

UCHAR
UARTSetInterruptCtrl(
    PUCHAR Port,
    UCHAR Value
    )
/*++

Routine Description:

    Set the interrupt control register.

Arguments:

    Port - Pointer to the serial port.

    Value - The interrupt control mask.

Return Value:

    Previous interrupt control value.

--*/
{
    UCHAR oldValue = UARTGetInterruptCtrl(Port);
    WRITE_PORT_UCHAR(Port + ACE_IER, Value);

    return oldValue;
}


UCHAR
UARTGetLineCtrl(
    PUCHAR Port
    )
/*++

Routine Description:

    Get the serial port line control register.

Arguments:

    Port - Pointer to the serial port.

Return Value:

    Serial port line control value.

--*/
{
    return READ_PORT_UCHAR(Port + ACE_LCR);
}

UCHAR
UARTSetLineCtrl(
    PUCHAR Port,
    UCHAR Value
    )
/*++

Routine Description:

    Set the serial port line control register.

Arguments:

    Port - Pointer to the serial port.

    Value - New line control value.

Return Value:

    Previous serial line control register value.

--*/
{
    UCHAR oldValue = UARTGetLineCtrl(Port);
    WRITE_PORT_UCHAR(Port + ACE_LCR, Value);

    return oldValue;
}


UCHAR
UARTGetModemCtrl(
    PUCHAR Port
    )
/*++

Routine Description:

    Get the serial port modem control register.

Arguments:

    Port - Pointer to the serial port.

Return Value:

    Serial port modem control register value.

--*/
{
    return READ_PORT_UCHAR(Port + ACE_MCR);
}

UCHAR
UARTSetModemCtrl(
    PUCHAR Port,
    UCHAR Value
    )
/*++

Routine Description:

    Set the serial port modem control register.

Arguments:

    Port - Pointer to the serial port.

Return Value:

    Previous modem control register value.

--*/
{

    UCHAR oldValue = UARTGetModemCtrl(Port);
    WRITE_PORT_UCHAR(Port + ACE_MCR, Value);

    return oldValue;
}


BOOLEAN
UARTSetDlab(
    PUCHAR Port,
    BOOLEAN Set
    )
/*++

Routine Description:

    Set/reset the baud rate access bit.

Arguments:

    Port - Pointer to the serial port.

    Set - Set or Reset (TRUE/FALSE) the baud rate access bit.

Return Value:

    The previous baud rate access bit setting.

--*/
{
    UCHAR lineControl = UARTGetLineCtrl(Port);
    UCHAR newLineControl = Set ? lineControl | ACE_DLAB :
                                 lineControl & ~ACE_DLAB;

    WRITE_PORT_UCHAR(Port + ACE_LCR, newLineControl);

    return lineControl & ACE_DLAB;
}

ULONG
UARTGetBaudRate(
    PUCHAR Port,
    ULONG BaudClock
    )
/*++

Routine Description:

    Get the serial port baud rate setting.

Arguments:

    Port - Pointer to the serial port.

    BaudClock - The external frequency driving the serial chip.

Return Value:

    Serial port baud rate.

--*/
{
    USHORT baudRateDivisor;
    ULONG  baudRateFactor = BaudClock/BAUD_GENERATOR_DIVISOR;

    //
    // Set the baud rate access bit.
    //

    UARTSetDlab(Port, TRUE);

    //
    // Read the baud rate factor.
    //

    baudRateDivisor = READ_PORT_UCHAR(Port + ACE_DLL);
    baudRateDivisor |= READ_PORT_UCHAR(Port + ACE_DLM) << 8;

    //
    // Reset the baud rate bit for normal data access.
    //

    UARTSetDlab(Port, FALSE);

    //
    // Make sure the divisor is not zero.
    //

    if (baudRateDivisor == 0) {
        baudRateDivisor = 1;
    }

    return baudRateFactor / baudRateDivisor;
}

VOID
UARTSetBaudRate(
    PUCHAR Port,
    ULONG BaudRate,
    ULONG BaudClock
    )
/*++

Routine Description:

    Set the serial port baud rate.

Arguments:

    Port - Pointer to the serial port.

    BaudRate - New serial port baud rate.

    BaudClock - The external frequency driving the serial chip.

Return Value:

    None.

--*/
{
   
    ULONG  baudRateFactor = BaudClock/BAUD_GENERATOR_DIVISOR;
    USHORT baudRateDivisor;

    SerMouPrint((2, "SERMOUSE-SetBaudRate: Enter\n"));

    baudRateDivisor = (USHORT) (baudRateFactor / BaudRate);
    UARTSetDlab(Port, TRUE);
    WRITE_PORT_UCHAR(Port + ACE_DLL, (UCHAR)baudRateDivisor);
    WRITE_PORT_UCHAR(Port + ACE_DLM, (UCHAR)(baudRateDivisor >> 8));
    UARTSetDlab(Port, FALSE);
    SerMouPrint((2, "SERMOUSE-New BaudRate: %u\n", BaudRate));

    SerMouPrint((2, "SERMOUSE-SetBaudRate: Exit\n"));

    return;
}


VOID
UARTGetState(
    PUCHAR Port,
    PUART Uart,
    ULONG BaudClock
    )
/*++

Routine Description:

    Get the complete state of the serial port. May be used for save/restore.

Arguments:

    Port - Pointer to the serial port.

    Uart - Pointer to a serial port structure.

    BaudClock - The external frequency driving the serial chip.

Return Value:

    None.

--*/
{
    Uart->LineCtrl = UARTGetLineCtrl(Port);
    Uart->ModemCtrl = UARTGetModemCtrl(Port);
    Uart->InterruptCtrl = UARTGetInterruptCtrl(Port);
    Uart->BaudRate = UARTGetBaudRate(Port, BaudClock);

    return;
}

VOID
UARTSetState(
    PUCHAR Port,
    PUART Uart,
    ULONG BaudClock
    )
/*++

Routine Description:

    Set the complete state of a serial port.

Arguments:

    Port - Pointer to the serial port.

    Uart - Pointer to a serial port structure.

    BaudClock - The external frequency driving the serial chip.

Return Value:

    None.

--*/
{
    UARTSetLineCtrl(Port, Uart->LineCtrl);
    UARTSetModemCtrl(Port, Uart->ModemCtrl);
    UARTSetInterruptCtrl(Port, Uart->InterruptCtrl);
    UARTSetBaudRate(Port, Uart->BaudRate, BaudClock);

    return;
}


BOOLEAN
UARTIsReceiveBufferFull(
    PUCHAR Port
    )
/*++

Routine Description:

    Check whether the serial port input buffer is full.

Arguments:

    Port - Pointer to the serial port.

Return Value:

    TRUE if a character is present in the input buffer, otherwise FALSE.

--*/
{
    return READ_PORT_UCHAR(Port + ACE_LSR) & ACE_DR;
}


BOOLEAN
UARTReadCharNoWait(
    PUCHAR Port,
    PUCHAR Value
    )
/*++

Routine Description:

    Read a character from the serial port and return immediately.

Arguments:

    Port - Pointer to the serial port.

    Value - The character read from the serial port input buffer.

Return Value:

    TRUE if character has been read, FALSE otherwise.

--*/
{
    BOOLEAN charReady = FALSE;

    if ( UARTIsReceiveBufferFull(Port) ) {
        *Value = READ_PORT_UCHAR(Port + ACE_RBR);
        charReady = TRUE;
    }

    return charReady;
}

BOOLEAN
UARTReadChar(
    PUCHAR Port,
    PUCHAR Value,
    ULONG Timeout
    )
/*++

Routine Description:

    Read a character from the serial port.  Waits until a character has 
    been read or the timeout value is reached.

Arguments:

    Port - Pointer to the serial port.

    Value  - The character read from the serial port input buffer.

    Timeout - The timeout value in milliseconds for the read.

Return Value:

    TRUE if a character has been read, FALSE if a timeout occured.

--*/
{

    ULONG i, j;
    BOOLEAN returnValue = FALSE;


    //
    // Exit when a character is found or the timeout value is reached.
    //

    for (i = 0; i < Timeout; i++) {
        for (j = 0; j < MS_TO_MICROSECONDS; j++) {
            if ((returnValue = UARTReadCharNoWait(Port, Value)) == TRUE) {
    
                //
                // Got a character.
                //
    
                break;
            } else {
    
                //
                // Stall 1 microsecond and then try to read again.
                //
    
                KeStallExecutionProcessor(1);
            }
        }
        if (returnValue) {
            break;
        }
    }

    return(returnValue);
}

BOOLEAN
UARTFlushReadBuffer(
    PUCHAR Port
    )
/*++

Routine Description:

    Flush the serial port input buffer.

Arguments:

    Port - Pointer to the serial port.

Return Value:

    TRUE.

--*/
{
    UCHAR value;

    SerMouPrint((4, "SERMOUSE-UARTFlushReadBuffer: Enter\n"));
    while (UARTReadCharNoWait(Port, &value)) {
        /* Nothing */
    }
    SerMouPrint((4, "SERMOUSE-UARTFlushReadBuffer: Exit\n"));

    return TRUE;
}


BOOLEAN
UARTIsTransmitEmpty(
    PUCHAR Port
    )
/*++

Routine Description:

     Check whether the serial port transmit buffer is empty.

     Note: We also check whether the shift register is empty. This is 
     not critical in our case, but allows some more delay between characters
     sent to a device. (Safe, safe...)

Arguments:

    Port - Pointer to the serial port.

Return Value:

    TRUE if the serial port transmit buffer is empty.

--*/
{
    return ((READ_PORT_UCHAR((PUCHAR) (Port + ACE_LSR)) &
                (ACE_TSRE | ACE_THRE)) == (ACE_THRE | ACE_TSRE));
}


BOOLEAN
UARTWriteChar(
    PUCHAR Port,
    UCHAR Value
    )
/*++

Routine Description:

     Write a character to a serial port. Make sure the transmit buffer 
     is empty before we write there.

Arguments:

    Port - Pointer to the serial port.

    Value - Value to write to the serial port.

Return Value:

    TRUE.

--*/
{
    while (!UARTIsTransmitEmpty(Port)) {
        /* Nothing */
    }
    WRITE_PORT_UCHAR(Port + ACE_THR, Value);

    return TRUE;
}

BOOLEAN
UARTWriteString(
    PUCHAR Port,
    PSZ Buffer
    )
/*++

Routine Description:

    Write a zero-terminated string to the serial port.

Arguments:

    Port - Pointer to the serial port.

    Buffer - Pointer to a zero terminated string to write to 
        the serial port.

Return Value:

    TRUE.

--*/
{
    PSZ current = Buffer;

    while (*current) {
        UARTWriteChar(Port, *current++);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\sermouse\sermouse.h ===
/*++

Copyright (c) 1989, 1990, 1991, 1992, 1993  Microsoft Corporation
Copyright (c) 1993  Logitech Inc.

Module Name:

    sermouse.h

Abstract:

    These are the structures and defines that are used in the
    i8250 serial mouse port driver.

Revision History:


--*/

#ifndef _SERMOUSE_
#define _SERMOUSE_

#include <ntddmou.h>
#include "kbdmou.h"
#include "sermcfg.h"
#include "uart.h"

//
// Default number of buttons and sample rate for the serial mouse.
//

#define MOUSE_NUMBER_OF_BUTTONS     2
#define MOUSE_SAMPLE_RATE           40    // 1200 baud


//
// Protocol handler state constants.
//

#define STATE0    0     // Sync bit, buttons and high x & y bits
#define STATE1    1     // lower x bits
#define STATE2    2     // lower y bits
#define STATE3    3     // Switch 2, extended packet bit & low z data
#define STATE4    4     // high z data
#define STATE_MAX 5

//
// Useful constants.
//

#define MOUSE_BUTTON_1  0x01
#define MOUSE_BUTTON_2  0x02
#define MOUSE_BUTTON_3  0x04

#define MOUSE_BUTTON_LEFT   0x01
#define MOUSE_BUTTON_RIGHT  0x02
#define MOUSE_BUTTON_MIDDLE 0x04

//
// Conversion factor for milliseconds to microseconds.
//

#define MS_TO_MICROSECONDS 1000

//
// Protocol handler static data.
//

typedef struct _HANDLER_DATA {
    ULONG Error;              // Error count
    ULONG State;              // Keep the current state
    ULONG PreviousButtons;    // The previous button state
    UCHAR Raw[STATE_MAX];     // Accumulate raw data
} HANDLER_DATA, *PHANDLER_DATA;


//
// Define the protocol handler type.
//

typedef BOOLEAN
(*PPROTOCOL_HANDLER)(
    IN PMOUSE_INPUT_DATA CurrentInput,
    IN PHANDLER_DATA HandlerData,
    IN UCHAR Value,
    IN UCHAR LineState);

//
// Defines for DeviceExtension->HardwarePresent.
// These should match the values in i8042prt
//

#define MOUSE_HARDWARE_PRESENT      0x02
#define BALLPOINT_HARDWARE_PRESENT  0x04
#define WHEELMOUSE_HARDWARE_PRESENT 0x08

//
// Serial mouse configuration information.
//

typedef struct _SERIAL_MOUSE_CONFIGURATION_INFORMATION {

    //
    // Bus interface type.
    //

    INTERFACE_TYPE InterfaceType;

    //
    // Bus Number.
    //

    ULONG BusNumber;

    //
    // The port/register resources used by this device.
    //

    CM_PARTIAL_RESOURCE_DESCRIPTOR PortList[1];
    ULONG PortListCount;

    //
    // Interrupt resources.
    //

    CM_PARTIAL_RESOURCE_DESCRIPTOR MouseInterrupt;

    //
    // The mapped address for the set of this device's registers.
    //

    PUCHAR DeviceRegisters[1];

    //
    // The external frequency at which the UART is being driven.
    //

    ULONG BaudClock;

    //
    // The saved initial UART state.
    //

    UART UartSaved;

    //
    // Set at intialization to indicate that the base register
    // address must be unmapped when the driver is unloaded.
    //

    BOOLEAN UnmapRegistersRequired;

    //
    // Flag set through the registry to force the type of hardware 
    // (bypassing NtDetect).
    //

    LONG OverrideHardwarePresent;

    //
    // Flag that indicates whether floating point context should be saved.
    //

    BOOLEAN FloatingSave;

    //
    // Mouse attributes.
    //

    MOUSE_ATTRIBUTES MouseAttributes;

} SERIAL_MOUSE_CONFIGURATION_INFORMATION,
  *PSERIAL_MOUSE_CONFIGURATION_INFORMATION;

//
// Port device extension.
//

typedef struct _DEVICE_EXTENSION {

    //
    // If HardwarePresent is non-zero, there is some sort of serial
    // pointing device present in the system, either a serial mouse
    // (MOUSE_HARDWARE_PRESENT) or a serial ballpoint
    // (BALLPOINT_HARDWARE_PRESENT).
    //

    ULONG HardwarePresent;

    //
    // Port configuration information.
    //

    SERIAL_MOUSE_CONFIGURATION_INFORMATION Configuration;

    //
    // Reference count for number of mouse enables.
    //

    LONG MouseEnableCount;

    //
    // Pointer to the device object.
    //

    PDEVICE_OBJECT DeviceObject;

    //
    // Mouse class connection data.
    //

    CONNECT_DATA ConnectData;

    //
    // Number of input data items currently in the mouse InputData queue.
    //

    ULONG InputCount;

    //
    // Start of the port mouse input data queue (really a circular buffer).
    //

    PMOUSE_INPUT_DATA InputData;

    //
    // Insertion pointer for mouse InputData.
    //

    PMOUSE_INPUT_DATA DataIn;

    //
    // Removal pointer for mouse InputData.
    //

    PMOUSE_INPUT_DATA DataOut;

    //
    // Points one input packet past the end of the InputData buffer.
    //

    PMOUSE_INPUT_DATA DataEnd;

    //
    // Current mouse input packet.
    //

    MOUSE_INPUT_DATA CurrentInput;

    //
    // Pointer to interrupt object.
    //

    PKINTERRUPT InterruptObject;

    //
    // Mouse ISR DPC queue.
    //

    KDPC IsrDpc;

    //
    // Mouse ISR DPC recall queue.
    //

    KDPC IsrDpcRetry;

    //
    // Used by the ISR and the ISR DPC (in SerMouDpcVariableOperation calls)
    // to control processing by the ISR DPC.
    //

    LONG DpcInterlockVariable;

    //
    // Spinlock used to protect the DPC interlock variable.
    //

    KSPIN_LOCK SpinLock;

    //
    // Timer used to retry the ISR DPC routine when the class
    // driver is unable to consume all the port driver's data.
    //

    KTIMER DataConsumptionTimer;

    //
    // DPC queue for logging overrun and internal driver errors.
    //

    KDPC ErrorLogDpc;

    //
    // Request sequence number (used for error logging).
    //

    ULONG SequenceNumber;

    //
    // Pointer to the interrupt protocol handler routine.
    //

    PPROTOCOL_HANDLER ProtocolHandler;

    //
    // Static state machine handler data.
    //

    HANDLER_DATA HandlerData;

    //
    // Indicates which pointer port device this driver created (UnitId
    // is the suffix appended to the pointer port basename for the
    // call to IoCreateDevice).
    //

    USHORT UnitId;

    //
    // Indicates whether it is okay to log overflow errors.
    //

    BOOLEAN OkayToLogOverflow;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

//
// Define the port Get/SetDataQueuePointer context structures.
//

typedef struct _GET_DATA_POINTER_CONTEXT {
    IN PDEVICE_EXTENSION DeviceExtension;
    OUT PVOID DataIn;
    OUT PVOID DataOut;
    OUT ULONG InputCount;
} GET_DATA_POINTER_CONTEXT, *PGET_DATA_POINTER_CONTEXT;

typedef struct _SET_DATA_POINTER_CONTEXT {
    IN PDEVICE_EXTENSION DeviceExtension;
    IN ULONG InputCount;
    IN PVOID DataOut;
} SET_DATA_POINTER_CONTEXT, *PSET_DATA_POINTER_CONTEXT;

//
// Define the context structure and operations for SerMouDpcVariableOperation.
//

typedef enum _OPERATION_TYPE {
        IncrementOperation,
        DecrementOperation,
        WriteOperation,
        ReadOperation
} OPERATION_TYPE;

typedef struct _VARIABLE_OPERATION_CONTEXT {
    IN PLONG VariableAddress;
    IN OPERATION_TYPE Operation;
    IN OUT PLONG NewValue;
} VARIABLE_OPERATION_CONTEXT, *PVARIABLE_OPERATION_CONTEXT;

//
// Function prototypes.
//


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
SerMouInitializeDevice(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDEVICE_EXTENSION   TmpDeviceExtension,
    IN  PUNICODE_STRING     RegistryPath,
    IN  PUNICODE_STRING     BaseDeviceName
    );

VOID
SerialMouseErrorLogDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
SerialMouseFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
NTSTATUS
SerialMouseInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
SerialMouseInterruptService(
    IN PKINTERRUPT Interrupt,
    IN PVOID Context
    );

VOID
SerialMouseIsrDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
SerialMouseOpenClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SerialMouseStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SerialMouseUnload(
    IN PDRIVER_OBJECT DriverObject
    );

VOID
SerMouBuildResourceList(
    IN PDEVICE_EXTENSION DeviceExtension,
    OUT PCM_RESOURCE_LIST *ResourceList,
    OUT PULONG ResourceListSize
    );

VOID
SerMouConfiguration(
    IN OUT  PLIST_ENTRY     DeviceExtensionList,
    IN      PUNICODE_STRING RegistryPath,
    IN      PUNICODE_STRING DeviceName
    );

VOID
SerMouDisableInterrupts(
    IN PVOID Context
    );

VOID
SerMouDpcVariableOperation(
    IN  PVOID Context
    );

VOID
SerMouEnableInterrupts(
    IN PVOID Context
    );

VOID
SerMouGetDataQueuePointer(
    IN PVOID Context
    );

VOID
SerMouInitializeDataQueue(
    IN PVOID Context
    );

NTSTATUS
SerMouInitializeHardware(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
SerMouPeripheralCallout(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    );

NTSTATUS
SerMouPeripheralListCallout(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    );

VOID
SerMouSendReport(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
SerMouServiceParameters(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PUNICODE_STRING RegistryPath,
    IN PUNICODE_STRING DeviceName
    );

VOID
SerMouSetDataQueuePointer(
    IN PVOID Context
    );

BOOLEAN
SerMouWriteDataToQueue(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PMOUSE_INPUT_DATA InputData
    );

#endif // _SERMOUSE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\sermouse\mseries.c ===
/*++

Copyright (c) 1993  Microsoft Corporation
Copyright (c) 1993  Logitech Inc.

Module Name:

    mseries.c

Abstract:


Environment:

    Kernel mode only.

Notes:


Revision History:

--*/

//
// Includes.
//

#include "ntddk.h"
#include "uart.h"
#include "sermouse.h"
#include "debug.h"
#include "cseries.h"
#include "mseries.h"

//
// Use the alloc_text pragma to specify the driver initialization routines
// (they can be paged out).
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,MSerSetProtocol)
#pragma alloc_text(INIT,MSerPowerUp)
#pragma alloc_text(INIT,MSerPowerDown)
#pragma alloc_text(INIT,MSerReset)
#pragma alloc_text(INIT,MSerDetect)
#endif // ALLOC_PRAGMA

//
// Constants.
//

#define MSER_BAUDRATE 1200
#define MAX_RESET_BUFFER 8
#define MINIMUM_RESET_TIME 200

//
// Microsoft Plus.
//

#define MP_SYNCH_BIT          0x40

#define MP_BUTTON_LEFT        0x20
#define MP_BUTTON_RIGHT       0x10
#define MP_BUTTON_MIDDLE      0x20

#define MP_BUTTON_LEFT_SR     5
#define MP_BUTTON_RIGHT_SR    3
#define MP_BUTTON_MIDDLE_SR   3

#define MP_BUTTON_MIDDLE_MASK 0x04

#define MP_UPPER_MASKX        0x03
#define MP_UPPER_MASKY        0x0C

#define MP_UPPER_MASKX_SL     6
#define MP_UPPER_MASKY_SL     4

//
// Microsoft BallPoint.
//

#define BP_SYNCH_BIT          0x40

#define BP_BUTTON_LEFT        0x20
#define BP_BUTTON_RIGHT       0x10
#define BP_BUTTON_3           0x04
#define BP_BUTTON_4           0x08

#define BP_BUTTON_LEFT_SR     5
#define BP_BUTTON_RIGHT_SR    3
#define BP_BUTTON_3_SL        0
#define BP_BUTTON_4_SL        0

#define BP_UPPER_MASKX        0x03
#define BP_UPPER_MASKY        0x0C

#define BP_UPPER_MASKX_SL     6
#define BP_UPPER_MASKY_SL     4

#define BP_SIGN_MASKX         0x01
#define BP_SIGN_MASKY         0x02

//
// Microsoft Magellan Mouse.
//

#define Z_SYNCH_BIT          0x40
#define Z_EXTRA_BIT          0x20

#define Z_BUTTON_LEFT        0x20
#define Z_BUTTON_RIGHT       0x10
#define Z_BUTTON_MIDDLE      0x10

#define Z_BUTTON_LEFT_SR     5
#define Z_BUTTON_RIGHT_SR    3
#define Z_BUTTON_MIDDLE_SR   3

#define Z_BUTTON_MIDDLE_MASK 0x04

#define Z_UPPER_MASKX        0x03
#define Z_UPPER_MASKY        0x0C
#define Z_UPPER_MASKZ        0x0F

#define Z_LOWER_MASKZ        0x0F

#define Z_UPPER_MASKX_SL     6
#define Z_UPPER_MASKY_SL     4
#define Z_UPPER_MASKZ_SL     4

//
// Type definitions.
//

typedef struct _PROTOCOL {
    PPROTOCOL_HANDLER Handler;
    UCHAR LineCtrl;
} PROTOCOL;

//
// This list is indexed by protocol values MSER_PROTOCOL_*.
//

static PROTOCOL Protocol[] = {
    {
    MSerHandlerMP,  // Microsoft Plus
    ACE_7BW | ACE_1SB
    },
    {
    MSerHandlerBP,  // BALLPOINT
    ACE_7BW | ACE_1SB
    },
    {
    MSerHandlerZ,   // Magellan Mouse
    ACE_7BW | ACE_1SB
    }
};

PPROTOCOL_HANDLER
MSerSetProtocol(
    PUCHAR Port,
    UCHAR NewProtocol
    )
/*++

Routine Description:

    Set the mouse protocol. This function only sets the serial port 
    line control register.

Arguments:

    Port - Pointer to the serial port.

    NewProtocol - Index into the protocol table.

Return Value:

    Pointer to the protocol handler function.

--*/
{
    ASSERT(NewProtocol < MSER_PROTOCOL_MAX);

    //
    // Set the protocol
    //

    UARTSetLineCtrl(Port, Protocol[NewProtocol].LineCtrl);

    return Protocol[NewProtocol].Handler;
}

BOOLEAN
MSerPowerUp(
    PUCHAR Port
    )
/*++

Routine Description:

    Powers up the mouse. Just sets the RTS and DTR lines and returns.

Arguments:

    Port - Pointer to the serial port.

Return Value:

    TRUE.

--*/
{

    //
    // Turn RTS on to power the mouse up (DTR should already be on,
    // but make extra sure).
    //

    UARTSetModemCtrl(Port, ACE_DTR | ACE_RTS);

    //
    // Wait 10 ms.  The power-up response byte(s) should take at least
    // this long to get transmitted.
    //

    KeStallExecutionProcessor(10 * MS_TO_MICROSECONDS);

    return TRUE;
}

BOOLEAN
MSerPowerDown(
    PUCHAR Port
    )
/*++

Routine Description:

    Powers down the mouse. Sets the RTS line to an inactive state.

Arguments:

    Port - Pointer to the serial port.

Return Value:

    TRUE.

--*/
{
    UCHAR lineCtrl = UARTGetModemCtrl(Port);

    SerMouPrint((
        2,
        "SERMOUSE-MSerPowerDown: The intial line control is: %#X\n",
        lineCtrl & 0xFF
        ));

    UARTSetModemCtrl(Port, (UCHAR) ((lineCtrl & ~ACE_RTS) | ACE_DTR));

    //
    // Keep RTS low for at least 150 ms, in order to correctly power
    // down older Microsoft serial mice.  Wait even longer to avoid
    // sending some Logitech CSeries mice into the floating point world...
    //

    ASSERT(CSER_POWER_DOWN >= 150);

    KeStallExecutionProcessor(CSER_POWER_DOWN * MS_TO_MICROSECONDS);

    return TRUE;
}

BOOLEAN
MSerReset(
    PUCHAR Port
    )
/*++

Routine Description:

    Reset the serial mouse.

Arguments:

    Port - Pointer to the serial port.

Return Value:

    TRUE.

--*/
{

    //
    // Remove mouse power if necessary.
    //

    MSerPowerDown(Port);

    //
    // Clean possible garbage in uart input buffer.
    //

    UARTFlushReadBuffer(Port);

    //
    // Power up the mouse (reset).
    //

    MSerPowerUp(Port);

    return TRUE;
}

MOUSETYPE
MSerDetect(
    PUCHAR Port,
    ULONG BaudClock
    )
/*++

Routine Description:

    Detection code for pointing devices that identify themselves at 
    power on time.

Arguments:

    Port - Pointer to the serial port.

    BaudClock - The external frequency driving the serial chip.

Return Value:

    The type of mouse detected.

--*/
{
    ULONG count = 0;
    MOUSETYPE mouseType;
    CHAR receiveBuffer[MAX_RESET_BUFFER];
    ULONG i;

    //
    // Set the debug output to the main display to avoid timing problems.
    //

    SerMouSetDebugOutput(DBG_COLOR);

    //
    // Set the baud rate.
    //

    UARTSetBaudRate(Port, MSER_BAUDRATE, BaudClock);

    //
    // Set the data format so that the possible answer can be recognized.
    //

    UARTSetLineCtrl(Port, Protocol[MSER_PROTOCOL_MP].LineCtrl);

    //
    // Apply the reset to the mouse.
    //

    MSerReset(Port);

    //
    // Get the possible first reset character ('M' or 'B'), followed
    // by any other characters the hardware happens to send back.
    //
    // Note:  Typically, we expect to get just one character ('M' or
    //        'B'), perhaps followed by a '2' or '3' (to indicate the
    //        number of mouse buttons.  On some machines, we're
    //        getting extraneous characters before the 'M'. Sometimes
    //        we get extraneous characters after the expected data, as
    //        well.  They either get read in here, or get flushed 
    //        when SerMouEnableInterrupts executes.
    //

    ASSERT(CSER_POWER_UP >= MINIMUM_RESET_TIME);

    if (UARTReadChar(Port, &receiveBuffer[count], CSER_POWER_UP)) {
        count++;
        while (count < (MAX_RESET_BUFFER - 1)) { 
            if (UARTReadChar(Port, &receiveBuffer[count], 100)) {
                count++;
            } else {
                break;
            }
        } 
    }

    *(receiveBuffer + count) = 0;

    SerMouPrint((2, "SERMOUSE-Receive buffer:\n"));
    for (i = 0; i < count; i++) {
        SerMouPrint((2, "\t0x%x\n", receiveBuffer[i]));
    }
    SerMouPrint((2, "\n"));

    //
    // Redirect the output to the serial port.
    //

    SerMouSetDebugOutput(DBG_SERIAL);
    
    //
    //
    // Analyze the possible mouse answer.  Start at the beginning of the 
    // "good" data in the receive buffer, ignoring extraneous characters 
    // that may have come in before the 'M' or 'B'.
    //

    for (i = 0; i < count; i++) {
        if (receiveBuffer[i] == 'M') {
            if (receiveBuffer[i + 1] == '3') {
                SerMouPrint((2, "SERMOUSE-Detected MSeries 3 buttons\n"));
                mouseType = MOUSE_3B;
            }
            else if (receiveBuffer[i + 1] == 'Z') {
                SerMouPrint((2, "SERMOUSE-Detected Wheel Mouse\n"));
                mouseType = MOUSE_Z;
            }
            else {
                SerMouPrint((2, "SERMOUSE-Detected MSeries 2 buttons\n"));
                mouseType = MOUSE_2B;
            }
            break;
        } else if (receiveBuffer[i] == 'B') {
            SerMouPrint((2, "SERMOUSE-Detected Ballpoint\n"));
            mouseType = BALLPOINT;
            break;
        }
    }

    if (i >= count) {

        //
        // Special case: If another device is connected (CSeries, for 
        // example) and this device sends a character (movement), the 
        // minimum power up time might not be respected. Take
        // care of this unlikely case.
        //

        if (count != 0) {
            KeStallExecutionProcessor(CSER_POWER_UP * MS_TO_MICROSECONDS);
        }

        SerMouPrint((1, "SERMOUSE-No MSeries detected\n"));
        mouseType = NO_MOUSE;
    }

    return mouseType;
}


BOOLEAN
MSerHandlerMP(
    IN PMOUSE_INPUT_DATA CurrentInput,
    IN PHANDLER_DATA HandlerData,
    IN UCHAR Value,
    IN UCHAR LineState
    )

/*++

Routine Description:

    This is the protocol handler routine for the Microsoft Plus protocol.

Arguments:

    CurrentInput - Pointer to the report packet.

    HandlerData - Instance specific static data for the handler.

    Value - The input buffer value.

    LineState - The serial port line state.

Return Value:

    Returns TRUE if the handler has a complete report ready.

--*/

{
    BOOLEAN retval = FALSE;
    ULONG middleButton;

    SerMouPrint((2, "SERMOUSE-MP protocol handler: enter\n"));


    if ((Value & MP_SYNCH_BIT) && (HandlerData->State != STATE0)) {
        if ((HandlerData->State != STATE3)) {

            //
            // We definitely have a synchronization problem (likely a data 
            // overrun).
            //

            HandlerData->Error++;
        }
        else if ((HandlerData->PreviousButtons & MOUSE_BUTTON_3) != 0) {

            //
            // We didn't receive the expected fourth byte. Missed it? 
            // Reset button 3 to zero.
            //

            HandlerData->PreviousButtons ^= MOUSE_BUTTON_3;
            HandlerData->Error++;
        }

        SerMouPrint((
            1,
            "SERMOUSE-Synch error. State: %u\n", HandlerData->State
            ));

        HandlerData->State = STATE0;
    }
    else if (!(Value & MP_SYNCH_BIT) && (HandlerData->State == STATE0)) {
        HandlerData->Error++;
        SerMouPrint((
            1,
            "SERMOUSE-Synch error. State: %u\n", HandlerData->State
            ));
        goto LExit;
    }

    //
    // Check for a line state error.
    //

    if (LineState & ACE_LERR) {

        //
        // Reset the handler state.
        //

        HandlerData->State = STATE0;
        HandlerData->Error++;
        SerMouPrint((1, "SERMOUSE-Line status error: %#x\n", LineState));
    }
    else {

        //
        // Set the untranslated value.
        //

        HandlerData->Raw[HandlerData->State] = Value;
        SerMouPrint((3, "SERMOUSE-State%u\n", HandlerData->State));

        switch (HandlerData->State) {
        case STATE0:
        case STATE1:
            HandlerData->State++;
            break;
        case STATE2:
            HandlerData->State++;

            //
            // Build the report.
            //

            CurrentInput->RawButtons  =
                (HandlerData->Raw[0] & MP_BUTTON_LEFT) >> MP_BUTTON_LEFT_SR;
            CurrentInput->RawButtons |=
                (HandlerData->Raw[0] & MP_BUTTON_RIGHT) >> MP_BUTTON_RIGHT_SR;
            CurrentInput->RawButtons |= 
                HandlerData->PreviousButtons & MOUSE_BUTTON_3;

            CurrentInput->LastX =
                (SCHAR)(HandlerData->Raw[1] |
                ((HandlerData->Raw[0] & MP_UPPER_MASKX) << MP_UPPER_MASKX_SL));
            CurrentInput->LastY =
                (SCHAR)(HandlerData->Raw[2] |
                ((HandlerData->Raw[0] & MP_UPPER_MASKY) << MP_UPPER_MASKY_SL));

            retval = TRUE;

            break;

        case STATE3:
            HandlerData->State = STATE0;
            middleButton = 
                (HandlerData->Raw[STATE3] & MP_BUTTON_MIDDLE) >> MP_BUTTON_MIDDLE_SR;

            //
            // Send a report only if the middle button state changed.
            //

            if (middleButton ^ (HandlerData->PreviousButtons & MOUSE_BUTTON_3)) {

                //
                // Toggle the state of the middle button.
                //

                CurrentInput->RawButtons ^= MP_BUTTON_MIDDLE_MASK;
                CurrentInput->LastX = 0;
                CurrentInput->LastY = 0;

                //
                // Send the report one more time.
                //

                retval = TRUE;
            }

            break;

        default:
            SerMouPrint((
                0, 
                "SERMOUSE-MP Handler failure: incorrect state value.\n"
                ));
            ASSERT(FALSE);
        }
    }

LExit:
    SerMouPrint((2, "SERMOUSE-MP protocol handler: exit\n"));

    return retval;

}

BOOLEAN
MSerHandlerBP(
    IN PMOUSE_INPUT_DATA CurrentInput,
    IN PHANDLER_DATA HandlerData,
    IN UCHAR Value,
    IN UCHAR LineState
    )

/*++

Routine Description:

    This is the protocol handler routine for the Microsoft Ballpoint protocol.

Arguments:

    CurrentInput - Pointer to the report packet.

    HandlerData - Instance specific static data for the handler.

    Value - The input buffer value.

    LineState - The serial port line state.

Return Value:

    Returns TRUE if the handler has a complete report ready.

--*/

{
    BOOLEAN retval = FALSE;

    SerMouPrint((2, "SERMOUSE-BP protocol handler: enter\n"));

    //
    // Check for synchronization errors.
    //

    if ((Value & BP_SYNCH_BIT) && (HandlerData->State != STATE0)) {
        HandlerData->Error++;
        SerMouPrint((
            1,
            "SERMOUSE-Synch error. State: %u\n", HandlerData->State
            ));
        HandlerData->State = STATE0;
    }
    else if (!(Value & BP_SYNCH_BIT) && (HandlerData->State == STATE0)) {
        HandlerData->Error++;
        SerMouPrint((
            1,
            "SERMOUSE-Synch error. State: %u\n", HandlerData->State
            ));
        goto LExit;
    }

    //
    // Check for a line state error.
    //

    if (LineState & ACE_LERR) {

        //
        // Reset the handler state.
        //

        HandlerData->State = STATE0;
        HandlerData->Error++;
        SerMouPrint((1, "SERMOUSE-Line status error: %#x\n", LineState));
    }
    else {

        //
        // Set the untranslated value.
        //

        HandlerData->Raw[HandlerData->State] = Value;

        SerMouPrint((3, "SERMOUSE-State%u\n", HandlerData->State));

        switch (HandlerData->State) {

        case STATE0:
        case STATE1:
        case STATE2:
            HandlerData->State++;
            break;

        case STATE3:
            HandlerData->State = STATE0;

            //
            // Build the report.
            //

            CurrentInput->RawButtons =
                (HandlerData->Raw[0] & BP_BUTTON_LEFT) >> BP_BUTTON_LEFT_SR;
            CurrentInput->RawButtons |=
                (HandlerData->Raw[0] & BP_BUTTON_RIGHT) >> BP_BUTTON_RIGHT_SR;

#if 0
            CurrentInput->ButtonFlags |=
                (HandlerData->Raw[3] & BP_BUTTON_3) << BP_BUTTON_3_SL;
            CurrentInput->ButtonFlags |=
                (HandlerData->Raw[3] & BP_BUTTON_4) << BP_BUTTON_4_SL;
#endif
            CurrentInput->LastX = HandlerData->Raw[3] & BP_SIGN_MASKX ?
                (LONG)(HandlerData->Raw[1] | (ULONG)(-1 & ~0xFF) |
                ((HandlerData->Raw[0] & BP_UPPER_MASKX) << BP_UPPER_MASKX_SL)):
                (LONG)(HandlerData->Raw[1] |
                ((HandlerData->Raw[0] & BP_UPPER_MASKX) << BP_UPPER_MASKX_SL));

            CurrentInput->LastY = HandlerData->Raw[3] & BP_SIGN_MASKY ?
                (LONG)(HandlerData->Raw[2] | (ULONG)(-1 & ~0xFF) |
                ((HandlerData->Raw[0] & BP_UPPER_MASKY) << BP_UPPER_MASKY_SL)):
                (LONG)(HandlerData->Raw[2] |
                ((HandlerData->Raw[0] & BP_UPPER_MASKY) << BP_UPPER_MASKY_SL));

            retval = TRUE;

            break;

        default:
            SerMouPrint((
                0,
                "SERMOUSE-BP Handler failure: incorrect state value.\n"
                ));
            ASSERT(FALSE);
        }
    }

LExit:
    SerMouPrint((2, "SERMOUSE-BP protocol handler: exit\n"));

    return retval;

}

BOOLEAN
MSerHandlerZ(
    IN PMOUSE_INPUT_DATA CurrentInput,
    IN PHANDLER_DATA HandlerData,
    IN UCHAR Value,
    IN UCHAR LineState
    )

/*++

Routine Description:

    This is the protocol handler routine for the Microsoft Magellan Mouse
    (wheel mouse)

Arguments:

    CurrentInput - Pointer to the report packet.

    HandlerData - Instance specific static data for the handler.

    Value - The input buffer value.

    LineState - The serial port line state.

Return Value:

    Returns TRUE if the handler has a complete report ready.

--*/

{
    BOOLEAN retval = FALSE;
    ULONG   middleButton;
    CHAR    zMotion = 0;

    SerMouPrint((2, "SERMOUSE-Z protocol handler: enter\n"));


    if ((Value & Z_SYNCH_BIT) && (HandlerData->State != STATE0)) {
        if ((HandlerData->State != STATE3)) {

            //
            // We definitely have a synchronization problem (likely a data 
            // overrun).
            //

            HandlerData->Error++;
        }

        SerMouPrint((
            1,
            "SERMOUSE-Z Synch error. State: %u\n", HandlerData->State
            ));

        HandlerData->State = STATE0;
    }
    else if (!(Value & Z_SYNCH_BIT) && (HandlerData->State == STATE0)) {
        HandlerData->Error++;
        SerMouPrint((
            1,
            "SERMOUSE-Z Synch error. State: %u\n", HandlerData->State
            ));
        goto LExit;
    }

    //
    // Check for a line state error.
    //

    if (LineState & ACE_LERR) {

        //
        // Reset the handler state.
        //

        HandlerData->State = STATE0;
        HandlerData->Error++;
        SerMouPrint((1, "SERMOUSE-Z Line status error: %#x\n", LineState));
    }
    else {

        //
        // Set the untranslated value.
        //

        HandlerData->Raw[HandlerData->State] = Value;
        SerMouPrint((3, "SERMOUSE-Z State%u\n", HandlerData->State));

        switch (HandlerData->State) {
        case STATE0:
        case STATE1:
        case STATE2:
            HandlerData->State++;
            break;

        case STATE3:

            //
            // Check to see if the mouse is going to the high bits of
            // the wheel movement.  If not, this is the last bit - transition
            // back to state0
            //

            if((HandlerData->Raw[STATE3] & Z_EXTRA_BIT) == 0) {

                HandlerData->State = STATE0;
                HandlerData->Raw[STATE4] = 0;
                retval = TRUE;
            }

            break;

        case STATE4:

            DbgPrint("SERMOUSE-Z Got that 5th byte\n");
            HandlerData->State = STATE0;
            retval = TRUE;
            break;

        default:
            SerMouPrint((
                0, 
                "SERMOUSE-Z Handler failure: incorrect state value.\n"
                ));
            ASSERT(FALSE);
        }

        if(retval) {

            CurrentInput->RawButtons = 0;
            
            if(HandlerData->Raw[STATE0] & Z_BUTTON_LEFT) {
                CurrentInput->RawButtons |= MOUSE_BUTTON_LEFT;
            }

            if(HandlerData->Raw[STATE0] & Z_BUTTON_RIGHT) {
                CurrentInput->RawButtons |= MOUSE_BUTTON_RIGHT;
            }

            if(HandlerData->Raw[STATE3] & Z_BUTTON_MIDDLE) {
                CurrentInput->RawButtons |= MOUSE_BUTTON_MIDDLE;
            }

            CurrentInput->LastX =
                (SCHAR)(HandlerData->Raw[STATE1] |
                ((HandlerData->Raw[0] & Z_UPPER_MASKX) << Z_UPPER_MASKX_SL));
            CurrentInput->LastY =
                (SCHAR)(HandlerData->Raw[STATE2] |
                ((HandlerData->Raw[0] & Z_UPPER_MASKY) << Z_UPPER_MASKY_SL));

            //
            // If the extra bit isn't set then the 4th byte contains
            // a 4 bit signed quantity for the wheel movement.  if it
            // is set, then we need to combine the z info from the
            // two bytes
            //

            if((HandlerData->Raw[STATE3] & Z_EXTRA_BIT) == 0) {

                zMotion = HandlerData->Raw[STATE3] & Z_LOWER_MASKZ;

                //
                // Sign extend the 4 bit 
                //

                if(zMotion & 0x08)  {
                    zMotion |= 0xf0;
                }
            } else {
                zMotion = ((HandlerData->Raw[STATE3] & Z_LOWER_MASKZ) |
                           ((HandlerData->Raw[STATE4] & Z_UPPER_MASKZ)
                                << Z_UPPER_MASKZ_SL));
            }

            if(zMotion == 0) {
                CurrentInput->ButtonData = 0;
            } else {
                CurrentInput->ButtonData = 0x0078;
                if(zMotion & 0x80) {
                    CurrentInput->ButtonData = 0x0078;
                } else {
                    CurrentInput->ButtonData = 0xff88;
                }
                CurrentInput->ButtonFlags |= MOUSE_WHEEL;
            }

        }

    }

LExit:
    SerMouPrint((2, "SERMOUSE-Z protocol handler: exit\n"));

    return retval;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\sermouse\uart.h ===
/*++

Copyright (c) 1993  Microsoft Corporation
Copyright (c) 1993  Logitech Inc.

Module Name:

    uart.h

Abstract:

    Hardware dependent support for the serial port.

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/

#ifndef UART_H
#define UART_H

//
// Constants
//

//
// Define the INS8250 ACE Register Offsets And Bit Definitions
//

#define ACE_RBR     0       // Receiver Buffer
#define ACE_THR     0       // Transmit Holding Register

#define ACE_IER     1       // Interrupt Enable
#define   ACE_ERBFI 0x01    //   Received Data Available             00000001b
#define   ACE_ETBEI 0x02    //   Transmitter Holding Register Empty  00000010b
#define   ACE_ELSI  0x04    //   Receiver Line Status                00000100b
#define   ACE_EDSSI 0x08    //   Modem Status                        00001000b

#define ACE_IIDR    2       // Interrupt Identification
#define   ACE_IIP   0x01    //   Inverted Interrupt Pending (0=int)  00000001b
#define   ACE_IID   0x06    //   Interrupt ID                        00000110b
#define   ACE_MSI   0x00    //   Modem Status                        00000000b
#define   ACE_THREI 0x02    //   Transmitter Holding Register Empty  00000010b
#define   ACE_RDAI  0x04    //   Received Data Available             00000100b
#define   ACE_RLSI  0x06    //   Receiver Line Status                00000110b

#define ACE_LCR     3       // Line Control
#define   ACE_WLS   0x03    //   Word Length Select Bits             00000011b
#define   ACE_WLS0  0x01    //   Word Length Select Bit 0            00000001b
#define   ACE_WLS1  0x02    //   Word Length Select Bit 1            00000010b
#define   ACE_5BW   0x00    //   5 Bit Words                         00000000b
#define   ACE_6BW   0x01    //   6 Bit Words                         00000001b
#define   ACE_7BW   0x02    //   7 Bit Words                         00000010b
#define   ACE_8BW   0x03    //   8 Bit Words                         00000011b
#define   ACE_STB   0x04    //   Stop Bits                           00000100b
#define   ACE_1SB   0x00    //   1 Stop Bits (1.5 for 5 bit words)   00000000b
#define   ACE_2SB   0x04    //   2 Stop Bits                         00000100b
#define   ACE_PEN   0x08    //   Parity Enable                       00001000b
#define   ACE_PSB   0x30    //   Parity Select bits                  00110000b
#define   ACE_EPS   0x10    //   Even Parity Select                  00010000b
#define   ACE_SP    0x20    //   Stick Parity                        00100000b
#define   ACE_SB    0x40    //   Set Break                           01000000b
#define   ACE_DLAB  0x80    //   Divisor Latch Access Bit            10000000b

#define ACE_MCR     4       // Modem Control
#define   ACE_DTR   0x01    //   Data Terminal ready                 00000001b
#define   ACE_RTS   0x02    //   Request To Send                     00000010b
#define   ACE_OUT1  0x04    //   Output Line 1                       00000100b
#define   ACE_OUT2  0x08    //   Output Line 2                       00001000b
#define   ACE_LOOP  0x10    //   Loopback                            00010000b

#define ACE_LSR     5       // Line Status
#define   ACE_DR    0x01    //   Data Ready                          00000001b
#define   ACE_OR    0x02    //   Overrun Error                       00000010b
#define   ACE_PE    0x04    //   Parity Error                        00000100b
#define   ACE_FE    0x08    //   Framing Error                       00001000b
#define   ACE_BI    0x10    //   Break Interrupt                     00010000b
#define   ACE_THRE  0x20    //   Transmitter Holding Register Empty  00100000b
#define   ACE_TSRE  0x40    //   Transmitter Shift Register Empty    01000000b
#define   ACE_LERR  (ACE_OR | ACE_PE | ACE_FE | ACE_BI)

#define ACE_MSR     6       // Modem Status
#define   ACE_DCTS  0x01    //   Delta Clear to Send                 00000001b
#define   ACE_DDSR  0x02    //   Delta Data Set Ready                00000010b
#define   ACE_TERI  0x04    //   Trailing Edge Ring Indicator        00000100b
#define   ACE_DRLSD 0x08    //   Delta Receive Line Signal Detect    00001000b
#define   ACE_CTS   0x10    //   Clear To Send                       00010000b
#define   ACE_DSR   0x20    //   Data Set ready                      00100000b
#define   ACE_RI    0x40    //   Ring Indicator                      01000000b
#define   ACE_RLSD  0x80    //   Receive Line Signal Detect          10000000b

#define ACE_DLL     0       // LSB Baud Rate Divisor

#define ACE_DLM     1       // MSB Baud Rate Divisor

//
// Define the Baud Generator Divisor.  BaudClock (a value known via the 
// hardware registry) is actually BAUD_GENERATOR_DIVISOR times the baud rate.
// For example, if the output frequency of the Baud Generator is 16 times 
// the baud rate, then BAUD_GENERATOR_DIVISOR is 16.  
//
// The Baud Rate Factor is BaudClock/BAUD_GENERATOR_DIVISOR.  
//
// The Baud Rate Divisor for the DLAB is Baud Rate Factor divided by the
// desired baud rate, where the desired baud rate is 1200, 2400, and so on.
//

#define BAUD_GENERATOR_DIVISOR 16

//
// Type definitions.
//

//
// UART configuration
//
typedef struct _UART {
    ULONG BaudRate;
    UCHAR LineCtrl;
    UCHAR ModemCtrl;
    UCHAR InterruptCtrl;
} UART, *PUART;


//
// Function prototypes
//

VOID
UARTSetFifo(
    PUCHAR Port,
    UCHAR Value
    );

UCHAR
UARTGetInterruptCtrl(
    PUCHAR Port
    );

UCHAR
UARTSetInterruptCtrl(
    PUCHAR Port,
    UCHAR Value
    );

UCHAR
UARTGetLineCtrl(
    PUCHAR Port
    );

UCHAR
UARTSetLineCtrl(
    PUCHAR Port,
    UCHAR Value
    );

UCHAR
UARTGetModemCtrl(
    PUCHAR Port
    );

UCHAR
UARTSetModemCtrl(
    PUCHAR Port,
    UCHAR Value
    );

BOOLEAN
UARTSetDlab(
    PUCHAR Port,
    BOOLEAN Set
    );

ULONG
UARTGetBaudRate(
    PUCHAR Port,
    ULONG BaudClock
    );

VOID
UARTSetBaudRate(
    PUCHAR Port,
    ULONG BaudRate,
    ULONG BaudClock
    );

VOID
UARTGetState(
    PUCHAR Port,
    PUART Uart,
    ULONG BaudClock
    );

VOID
UARTSetState(
    PUCHAR Port,
    PUART Uart,
    ULONG BaudClock
    );

BOOLEAN
UARTIsReceiveBufferFull(
    PUCHAR Port
    );

BOOLEAN
UARTReadCharNoWait(
    PUCHAR Port,
    PUCHAR Value
    );

BOOLEAN
UARTReadChar(
    PUCHAR Port,
    PUCHAR Value,
    ULONG Timeout
    );

BOOLEAN
UARTFlushReadBuffer(
    PUCHAR Port
    );

BOOLEAN
UARTIsTransmitEmpty(
    PUCHAR Port
    );

BOOLEAN
UARTWriteChar(
    PUCHAR Port,
    UCHAR Value
    );

BOOLEAN
UARTWriteString(
    PUCHAR Port,
    PSZ Buffer
    );

#endif // UART_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\sermouse\i386\sermcfg.h ===
/*++

Copyright (c) 1989, 1990, 1991, 1992, 1993  Microsoft Corporation

Module Name:

    sermcfg.h

Abstract:

    These are the machine-dependent configuration constants that are used in
    the i8250 serial mouse port driver.

Revision History:

--*/

#ifndef _SERMCFG_
#define _SERMCFG_

//
// Define the interrupt-related configuration constants.
//

#ifdef i386
#define SERIAL_MOUSE_INTERFACE_TYPE        Isa
#define SERIAL_MOUSE_INTERRUPT_MODE        Latched
#define SERIAL_MOUSE_INTERRUPT_SHARE       FALSE
#else
#define SERIAL_MOUSE_INTERFACE_TYPE        Isa
#define SERIAL_MOUSE_INTERRUPT_MODE        LevelSensitive
#define SERIAL_MOUSE_INTERRUPT_SHARE       TRUE
#endif

#define SERIAL_MOUSE_BUS_NUMBER            0

#ifdef i386
#define SERIAL_MOUSE_FLOATING_SAVE         FALSE
#else
#define SERIAL_MOUSE_FLOATING_SAVE         TRUE
#endif

#define MOUSE_COM1_VECTOR                  4
#define MOUSE_COM1_IRQL                    MOUSE_COM1_VECTOR
#define SERIAL_MOUSE_COM1_PHYSICAL_BASE    0x3F8

#define MOUSE_COM2_VECTOR                  3
#define MOUSE_COM2_IRQL                    MOUSE_COM2_VECTOR
#define SERIAL_MOUSE_COM2_PHYSICAL_BASE    0x2F8

#define MOUSE_VECTOR                       MOUSE_COM1_VECTOR
#define MOUSE_IRQL                         MOUSE_COM1_IRQL
#define SERIAL_MOUSE_PHYSICAL_BASE         SERIAL_MOUSE_COM1_PHYSICAL_BASE
#define SERIAL_MOUSE_REGISTER_LENGTH       8
#define SERIAL_MOUSE_REGISTER_SHARE        FALSE
#define SERIAL_MOUSE_PORT_TYPE             CM_RESOURCE_PORT_IO

//
// Define the default clock rate to be 1.8432 MHz.
//

#define MOUSE_BAUD_CLOCK                   1843200UL

//
// Define the default number of entries in the input data queue.
//

#define DATA_QUEUE_SIZE    100

//
// The default overrideHardware flag (disabled)
//

#define DEFAULT_OVERRIDE_HARDWARE -1

#endif // _SERMCFG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\sermouse\ia64\sermcfg.h ===
/*++

Copyright (c) 1989, 1990, 1991, 1992, 1993  Microsoft Corporation

Module Name:

    sermcfg.h

Abstract:

    These are the machine-dependent configuration constants that are used in
    the i8250 serial mouse port driver.

Revision History:

--*/

#ifndef _SERMCFG_
#define _SERMCFG_

//
// Define the interrupt-related configuration constants.
//

#ifdef i386
#define SERIAL_MOUSE_INTERFACE_TYPE        Isa
#define SERIAL_MOUSE_INTERRUPT_MODE        Latched
#define SERIAL_MOUSE_INTERRUPT_SHARE       FALSE
#else
#define SERIAL_MOUSE_INTERFACE_TYPE        Isa
#define SERIAL_MOUSE_INTERRUPT_MODE        LevelSensitive
#define SERIAL_MOUSE_INTERRUPT_SHARE       TRUE
#endif

#define SERIAL_MOUSE_BUS_NUMBER            0

#ifdef i386
#define SERIAL_MOUSE_FLOATING_SAVE         FALSE
#else
#define SERIAL_MOUSE_FLOATING_SAVE         TRUE
#endif

#define MOUSE_COM1_VECTOR                  4
#define MOUSE_COM1_IRQL                    MOUSE_COM1_VECTOR
#define SERIAL_MOUSE_COM1_PHYSICAL_BASE    0x3F8

#define MOUSE_COM2_VECTOR                  3
#define MOUSE_COM2_IRQL                    MOUSE_COM2_VECTOR
#define SERIAL_MOUSE_COM2_PHYSICAL_BASE    0x2F8

#define MOUSE_VECTOR                       MOUSE_COM1_VECTOR
#define MOUSE_IRQL                         MOUSE_COM1_IRQL
#define SERIAL_MOUSE_PHYSICAL_BASE         SERIAL_MOUSE_COM1_PHYSICAL_BASE
#define SERIAL_MOUSE_REGISTER_LENGTH       8
#define SERIAL_MOUSE_REGISTER_SHARE        FALSE
#define SERIAL_MOUSE_PORT_TYPE             CM_RESOURCE_PORT_IO

//
// Define the default clock rate to be 1.8432 MHz.
//

#define MOUSE_BAUD_CLOCK                   1843200UL

//
// Define the default number of entries in the input data queue.
//

#define DATA_QUEUE_SIZE    100

//
// The default overrideHardware flag (disabled)
//

#define DEFAULT_OVERRIDE_HARDWARE -1

#endif // _SERMCFG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\sidewndr\swndr3p.c ===
//TODO check return and irp->status returns for all routines.  Trace 'em as far as necessary.

/*++ BUILD Version: 0001    // Increment this if a change has global effects


Copyright (c) 1995, 1996  Microsoft Corporation

Module Name:

    swndr3p.c

Abstract:

    Kernel mode device driver for Microsoft SideWinder 3p joystick device


Author:

    edbriggs 30-Nov-95


Revision History:

    stevez May 96
    removed unused code, including analog and 1-bit digital modes.
    See analog3p.c, .h for original version
    May need 1-bit digital mode for Aztec game cards, may want analog
    for future release.
    NB there is still a lot of unnecessary code left in this driver

    RtlLargeIntegerX calls are historical and can be replaced by __int64
    compiler supported arithmetic.

    6/10/96 registry variables now being used for port address
    6/10/96 resets enhanced digital mode if joystick goes to analog mode during
        use (for example if user toggles "emulation" switch)
    6/13/96 limits polling to 100/s by setting min time between polls to 10ms
    6/13/96 code structure revised in SidewndrPoll and subroutines


--*/



#include <ntddk.h>
#include <windef.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <ntddsjoy.h>
//#include "joylog.h"



//
// Device extension data
//

typedef struct {

    //
    // JOYSTICKID0 or JOYDSTICKID1
    //

    DWORD DeviceNumber;

    //
    // Number of axes supported and configured for this device. The
    // Sidewinder 3P supports a maximum of 4 axes
    //

    DWORD NumberOfAxes;

    //
    // Current operating mode of the device:
    // { Invalid | Analog | Digital | Enhanced | Maximum }
    //

    DWORD CurrentDeviceMode;

    //
    // The I/O address of the device. Note, this may be a memory mapped
    // address
    //

    PUCHAR DeviceAddress;

    //
    // Boolean denoting whether this address is mapped (TRUE) or not)
    //

    BOOL DeviceIsMapped;

    //
    // A fast mutext is used to synchronize access to this device.
    //

    FAST_MUTEX Lock;

}  JOY_EXTENSION, *PJOY_EXTENSION;




//
//  Debugging macros
//

#ifdef DEBUG
#define ENABLE_DEBUG_TRACE
#endif

#ifdef ENABLE_DEBUG_TRACE
#define DebugTrace(_x_)         \
    DbgPrint("SideWndr : ");    \
    KdPrint(_x_);               \
    DbgPrint("\n");
#else
#define DebugTrace(_x_)
#endif

//
// Condition Compilation Directives
//




//
// Global values used to speed up calculations in sampling loops
// Also calibration constants set in DriverEntry
// -------------------------------------------------------------
//

JOY_STATISTICS JoyStatistics;   // These are used for debugging and performance testing

//
// The high resolution system clock (from KeQueryPerformanceCounter)
// is updated at this frequency
//

DWORD Frequency;

//
// The latency in a call to KeQueryPerformanceCounter in microseconds
//

DWORD dwQPCLatency;

//
// After a write to the joystick port, we spin in a read-port loop, waiting
// for a bit to go high.
// This is the number of iterations to spin before timing out.  Set
// to timeout after about 2 milliseconds

LONG nReadLoopMax;

//
// Values for KeDelayExecutionThread
//

LARGE_INTEGER LI10ms;

//
// number of KeQueryPerformanceCounter ticks in 1 millisecond
// (used to prevent too-frequent polling of joystick)
//

DWORD nMinTicksBetweenPolls;

//
//  Assembly area for digital packets
//

#define MAX_PACKET_SIZE 23
BYTE  NormalPacket[8];
BYTE  EnhancedPacket[MAX_PACKET_SIZE];

//
//  Last good packet
//

BOOL bLastGoodPacket;
JOY_DD_INPUT_DATA jjLastGoodPacket;

//
// time at which the joystick was last polled
//

LARGE_INTEGER liLastPoll;   // set whenever the joystick's polled
DWORD PollLength;
DWORD PollLengthMax;

#define MAX_POLL_LENGTH 0 // 310
#define USE_CLI 1


//
// End of Global Values
// ---------------------
//



//
// Routine Prototypes
//


NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  pDriverObject,
    IN  PUNICODE_STRING RegistryPathName
);


NTSTATUS
SidewndrCreateDevice(
    PDRIVER_OBJECT pDriverObject,
    PWSTR DeviceNameBase,
    DWORD DeviceNumber,
    DWORD ExtensionSize,
    BOOLEAN  Exclusive,
    DWORD DeviceType,
    PDEVICE_OBJECT *DeviceObject
);


NTSTATUS
SidewndrDispatch(
    IN  PDEVICE_OBJECT pDO,
    IN  PIRP pIrp
);


NTSTATUS
SidewndrReportNullResourceUsage(
    PDEVICE_OBJECT DeviceObject
);


NTSTATUS
SidewndrReadRegistryParameterDWORD(
    PUNICODE_STRING RegistryPathName,
    PWSTR  ParameterName,
    PDWORD ParameterValue
);


NTSTATUS
SidewndrMapDevice(
    DWORD PortBase,
    DWORD NumberOfPorts,
    PJOY_EXTENSION pJoyExtension
);


VOID
SidewndrUnload(
    PDRIVER_OBJECT pDriverObject
);


NTSTATUS
SidewndrPoll(
    IN  PDEVICE_OBJECT pDO,
    IN  PIRP pIrp
);


NTSTATUS
SidewndrEnhancedDigitalPoll(
    IN  PDEVICE_OBJECT pDO,
    IN  PIRP pIrp
);


BOOL
SidewndrQuiesce(
    PUCHAR JoyPort,
    UCHAR  Mask
);


DWORD
TimeInMicroSeconds(
    DWORD dwTime
);


DWORD
TimeInTicks(
    DWORD dwTimeInMicroSeconds
);


NTSTATUS
SidewndrWaitForClockEdge(
    DWORD  edge,
    BYTE   *pByte,
    PUCHAR JoyPort
);


NTSTATUS
SidewndrReset(
    PUCHAR JoyPort
);


NTSTATUS
SidewndrStartAnalogMode(
    PUCHAR JoyPort
);


NTSTATUS
SidewndrStartDigitalMode(
    PUCHAR JoyPort
);


NTSTATUS
SidewndrStartEnhancedMode(
    PUCHAR JoyPort
);


NTSTATUS
SidewndrGetEnhancedPacket(
    PUCHAR joyPort
);


NTSTATUS
SidewndrInterpretEnhancedPacket(
    PJOY_DD_INPUT_DATA pInput
);


int
lstrnicmpW(
    LPWSTR pszA,
    LPWSTR pszB,
    size_t cch
);


VOID
SidewndrWait (
    DWORD TotalWait // in uS
);


BOOL
SidewndrReadWait (
    PUCHAR JoyPort,
    UCHAR Mask
);


void
SidewndrGetConfig(
    LPJOYREGHWCONFIG pConfig,
    PJOY_EXTENSION pJoyExtension
);


NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  pDriverObject,
    IN  PUNICODE_STRING RegistryPathName
)
/*++

Routine Description:

    This routine is called at system initialization time to initialize
    this driver.

Arguments:

    DriverObject    - Supplies the driver object.

    RegistryPath    - Supplies the registry path for this driver.

Return Value:

    STATUS_SUCCESS
    STATUS_DEVICE_CONFIGURATION_ERROR - Wrong number of axi in the registry

    or error status from NT itself

--*/
{
    NTSTATUS Status;
    PDEVICE_OBJECT JoyDevice0;
    PDEVICE_OBJECT JoyDevice1;
    DWORD NumberOfAxes;
    DWORD DeviceAddress;
    DWORD DeviceType;


    //
    // See how many axes we have from the registry parameters. These parameters
    // are set up by the driver installation program, and can be modified by
    // control panel
    //

    //DbgBreakPoint();
    JoyStatistics.nVersion = 16;    // global, initialize it first thing so we for sure what we're running
    DebugTrace(("Sidewndr %d", JoyStatistics.nVersion));

    Status = SidewndrReadRegistryParameterDWORD(
                RegistryPathName,
                JOY_DD_NAXES_U,
                &NumberOfAxes
                );

    DebugTrace(("Number of axes returned from registry: %d", NumberOfAxes));


    if (!NT_SUCCESS(Status))
    {
        SidewndrUnload(pDriverObject);
        return Status;
    }


    if (( NumberOfAxes < 2) || (NumberOfAxes > 4))
    {
        SidewndrUnload(pDriverObject);
        Status = STATUS_DEVICE_CONFIGURATION_ERROR;
        return Status;
    }


    //
    // See if the registry contains a device address other than the
    // default of 0x201
    //

    Status = SidewndrReadRegistryParameterDWORD(
                RegistryPathName,
                JOY_DD_DEVICE_ADDRESS_U,
                &DeviceAddress
                );

    if (NT_SUCCESS(Status))
    {
        DebugTrace(("Registry specified device address of 0x%x", DeviceAddress));
    }
    else
    {
        DebugTrace(("Using default device address of 0x%x", JOY_IO_PORT_ADDRESS));
        DeviceAddress = JOY_IO_PORT_ADDRESS;
    }


    //
    // See if there is a device type specified in the registry
    //

    Status = SidewndrReadRegistryParameterDWORD(
                RegistryPathName,
                JOY_DD_DEVICE_TYPE_U,
                &DeviceType
                );

    if (!NT_SUCCESS(Status))
    {
        DebugTrace(("No device type entry for joystick"));
        SidewndrUnload(pDriverObject);
        Status = STATUS_DEVICE_CONFIGURATION_ERROR;
        return Status;
    }

    DebugTrace(("Joystick device type %d", DeviceType));

    // set global large_integers for KeDelayExecutionThread (negative numbers for relative time)
    // NB KeDelayExecutionThread calls typically take at least 10 milliseconds on the pentium75 I used for testing,
    // no matter how little time is requested
    LI10ms = RtlConvertLongToLargeInteger(-100000);

    //
    // Calculate time thresholds for analog device
    //

    {
        DWORD Remainder;
        LARGE_INTEGER LargeFrequency;
        DWORD ulStart, ulTemp, ulEnd;
        DWORD dwTicks, dwTimems;
        int i;
        BYTE byteJoy, byteTmp;

        //
        // Get the system timer resolution expressed in Hertz.
        //

        KeQueryPerformanceCounter(&LargeFrequency);

        Frequency = LargeFrequency.LowPart;

        DebugTrace(("Frequency: %u", Frequency));

        // need latency for KeQueryPerformanceCounter.  While we're at it, let's
        // get min time for delay and stall execution


        ulStart = KeQueryPerformanceCounter(NULL).LowPart;
        for (i = 0; i < 1000; i++) {
            ulTemp = KeQueryPerformanceCounter(NULL).LowPart;
        }
        dwTicks = ulTemp - ulStart;
        dwTimems = TimeInMicroSeconds (dwTicks);
        dwQPCLatency = (dwTimems / 1000) + 1;   // round up

        /* following code used only for testing timing of kernel timing routines
        ulStart = KeQueryPerformanceCounter(NULL).LowPart;
        KeDelayExecutionThread( KernelMode, FALSE, &LI2ms);
        ulEnd = KeQueryPerformanceCounter(NULL).LowPart;
        DebugTrace(("QPC latency in uS: %u, DET(2ms) in ticks: %u ticks",
            dwQPCLatency,
            ulEnd - ulStart));

        ulStart = KeQueryPerformanceCounter(NULL).LowPart;
        for (i = 0; i < 1000; i++) {
            KeStallExecutionProcessor(1);   // 1 microsecond (Hah!)
        }
        ulEnd = KeQueryPerformanceCounter(NULL).LowPart;
        DebugTrace(("KeStallExecutionProcessor(1) called 1000 times, in ticks: %u",
            ulEnd - ulStart));
        */

    }


    //
    // Attempt to create the device
    //

    Status = SidewndrCreateDevice(
                pDriverObject,
                JOY_DD_DEVICE_NAME_U,    // device driver
                0,
                sizeof(JOY_EXTENSION),
                FALSE,                   // exclusive access
                FILE_DEVICE_UNKNOWN,
                &JoyDevice0);

    if (!NT_SUCCESS(Status))
    {
        DebugTrace(("SwndrCreateDevice returned %x", Status));
        SidewndrUnload(pDriverObject);
        return Status;
    }

    ((PJOY_EXTENSION)JoyDevice0->DeviceExtension)->DeviceNumber = JOYSTICKID1;
    ((PJOY_EXTENSION)JoyDevice0->DeviceExtension)->NumberOfAxes = NumberOfAxes;
    ((PJOY_EXTENSION)JoyDevice0->DeviceExtension)->CurrentDeviceMode =
            SIDEWINDER3P_ANALOG_MODE;

    ((PJOY_EXTENSION)JoyDevice0->DeviceExtension)->DeviceIsMapped = FALSE;
    ((PJOY_EXTENSION)JoyDevice0->DeviceExtension)->DeviceAddress  = (PUCHAR) 0;

    //
    // Initialize the fast mutext used to synchronize access to this device
    //

    ExInitializeFastMutex(&((PJOY_EXTENSION)JoyDevice0->DeviceExtension)->Lock);

    //
    // Get the device address into the device extension
    //

    Status = SidewndrMapDevice(
                DeviceAddress,
                1,
                (PJOY_EXTENSION)JoyDevice0->DeviceExtension);


    // Calibrate nReadLoopMax for spinning in read_port loops to timeout after 2ms
    {
        int i;
        PBYTE JoyPort;
        DWORD ulStart, ulEnd;
        BYTE byteJoy;
        int LoopTimeInMicroSeconds;

        i = 1000;
        JoyPort = ((PJOY_EXTENSION)JoyDevice0->DeviceExtension)->DeviceAddress;

        ulStart = KeQueryPerformanceCounter(NULL).LowPart;
        while (i--){
            byteJoy = READ_PORT_UCHAR(JoyPort);
            if ((byteJoy & X_AXIS_BITMASK)) {
                ;
            }
        }
        ulEnd = KeQueryPerformanceCounter(NULL).LowPart;
        LoopTimeInMicroSeconds = TimeInMicroSeconds (ulEnd - ulStart);
        nReadLoopMax = (1000 * 2000) / LoopTimeInMicroSeconds; // want 2 mS for nReadLoopMax iterations
        DebugTrace(("READ_PORT_UCHAR loop, 1000 interations: %u ticks", ulEnd - ulStart));
        DebugTrace(("nReadLoopMax: %u", nReadLoopMax));
   }
    //
    // if only 2 axes were requested, we can support a second device
    //

    // Number of axed should be 4 here, since we're only supporting sidewinder
    // in enhanced digital mode.  Leave this code in just for safety.

    if (2 == NumberOfAxes)
    {
        Status = SidewndrCreateDevice(
                    pDriverObject,
                    JOY_DD_DEVICE_NAME_U,
                    1,                      // device number
                    sizeof (JOY_EXTENSION),
                    FALSE,                  // exclusive access
                    FILE_DEVICE_UNKNOWN,
                    &JoyDevice1);

        if (!NT_SUCCESS(Status))
        {
            DebugTrace(("Create device for second device returned %x", Status));
            SidewndrUnload(pDriverObject);
            return Status;
        }

        //
        // In the analog world (which we are in if there are 2 devices, both
        // devices share the same I/O address so just copy it from JoyDevice0
        //

        ((PJOY_EXTENSION)JoyDevice1->DeviceExtension)->DeviceIsMapped =
            ((PJOY_EXTENSION)JoyDevice0->DeviceExtension)->DeviceIsMapped;

        ((PJOY_EXTENSION)JoyDevice1->DeviceExtension)->DeviceAddress =
            ((PJOY_EXTENSION)JoyDevice0->DeviceExtension)->DeviceAddress;

    }

    //
    // Place the enty points in our driver object
    //

    pDriverObject->DriverUnload                         = SidewndrUnload;
    pDriverObject->MajorFunction[IRP_MJ_CREATE]         = SidewndrDispatch;
    pDriverObject->MajorFunction[IRP_MJ_CLOSE]          = SidewndrDispatch;
    pDriverObject->MajorFunction[IRP_MJ_READ]           = SidewndrDispatch;
    pDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = SidewndrDispatch;

    //
    // Zero statistics, set misc globals
    //

    JoyStatistics.EnhancedPolls        = 0;
    JoyStatistics.EnhancedPollTimeouts = 0;
    JoyStatistics.EnhancedPollErrors   = 0;
    JoyStatistics.nPolledTooSoon       = 0;
    JoyStatistics.nReset               = 0;
    {
        int i;
        for (i = 0; i < MAX_ENHANCEDMODE_ATTEMPTS; i++) {
            JoyStatistics.Retries[i] = 0;
        }
    }

    bLastGoodPacket = FALSE;
    liLastPoll = KeQueryPerformanceCounter (NULL);
    // allow max of 100 polls/s (min time  between polls 10ms), which reduces time spinning in the NT kernel
    nMinTicksBetweenPolls = TimeInTicks (10000);
    PollLengthMax = TimeInTicks (MAX_POLL_LENGTH);

    return STATUS_SUCCESS;

}


NTSTATUS
SidewndrCreateDevice(
    PDRIVER_OBJECT pDriverObject,
    PWSTR DeviceNameBase,
    DWORD DeviceNumber,
    DWORD ExtensionSize,
    BOOLEAN  Exclusive,
    DWORD DeviceType,
    PDEVICE_OBJECT *DeviceObject
)
/*++

Routine Description:

    This routine is called at driver initialization time to create
    the device. The device is created to use Buffered IO.

Arguments:

    pDriverObject   - Supplies the driver object.

    DeviceNameBase  - The base name of the device to which a number is appended

    DeviceNumber    - A number which will be appended to the device name

    ExtensionSize   - Size of the device extension area

    Exclusive       - True if exclusive access should be enforced

    DeviceType      - NT Device type this device is modeled after

    DeviceObject    - pointer to the device object


Return Value:

    STATUS_SUCCESS
    or error status from NT itself

--*/
{

    WCHAR DeviceName[100];
    WCHAR UnicodeDosDeviceName[200];

    UNICODE_STRING UnicodeDeviceName;
    NTSTATUS Status;
    int Length;

    (void) wcscpy(DeviceName, DeviceNameBase);
    Length = wcslen(DeviceName);
    DeviceName[Length + 1] = L'\0';
    DeviceName[Length] = (USHORT) (L'0' + DeviceNumber);

    (void) RtlInitUnicodeString(&UnicodeDeviceName, DeviceName);

    Status = IoCreateDevice(
                pDriverObject,
                ExtensionSize,
                &UnicodeDeviceName,
                DeviceType,
                0,
                (BOOLEAN) Exclusive,
                DeviceObject
                );

    if (!NT_SUCCESS(Status))
    {
        return Status;
    }



    RtlInitUnicodeString((PUNICODE_STRING) &UnicodeDosDeviceName, L"\\DosDevices\\Joy1");

    Status = IoCreateSymbolicLink(
                (PUNICODE_STRING) &UnicodeDosDeviceName,
                (PUNICODE_STRING) &UnicodeDeviceName
                );

    if (!NT_SUCCESS(Status))
    {
        return Status;
    }




    // Set the flag signifying that we will do buffered I/O. This causes NT
    // to allocate a buffer on a ReadFile operation which will then be copied
    // back to the calling application by the I/O subsystem


    (*DeviceObject)->Flags |= DO_BUFFERED_IO;


    return Status;

}



NTSTATUS
SidewndrReadRegistryParameterDWORD(
    PUNICODE_STRING RegistryPathName,
    PWSTR  ParameterName,
    PDWORD ParameterValue
)
/*++

Routine Description:

    This routine reads registry values for the driver configuration

Arguments:

    RegistryPathName    -  Registry path containing the desired parameters

    ParameterName       -  The name of the parameter

    ParameterValue      -  Variable to receive the parameter value

Return Value:

    STATUS_SUCCESS                      --
    STATUS_NO_MORE_ENTRIES              --  Couldn't find any entries
    STATUS_INSUFFICIENT_RESOURCES       --  Couldn't allocate paged pool
    STATUS_DEVICE_CONFIGURATION_ERROR   --  Returned value wasn't a DWORD

    or error status from NT itself

--*/
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS Status;

    HANDLE ServiceKey;
    HANDLE DeviceKey;           // Key handle of service node
    UNICODE_STRING DeviceName;  // Key to parameter node
    DWORD KeyIndex;
    DWORD KeyValueLength;
    PBYTE KeyData;
    BOOL  ValueWasFound;
    PKEY_VALUE_FULL_INFORMATION KeyInfo;

    InitializeObjectAttributes( &ObjectAttributes,
                                RegistryPathName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                (PSECURITY_DESCRIPTOR) NULL);

    //
    // Open a key for our services node entry
    //

    Status = ZwOpenKey( &ServiceKey,
                        KEY_READ | KEY_WRITE,
                        &ObjectAttributes);

    if (!NT_SUCCESS(Status))
    {
        return Status;
    }


    //
    // Open the key to our device subkey
    //

    RtlInitUnicodeString(&DeviceName, L"Parameters");

    InitializeObjectAttributes( &ObjectAttributes,
                                &DeviceName,
                                OBJ_CASE_INSENSITIVE,
                                ServiceKey,
                                (PSECURITY_DESCRIPTOR) NULL);

    Status = ZwOpenKey (&DeviceKey,
                        KEY_READ | KEY_WRITE,
                        &ObjectAttributes);


    ZwClose(ServiceKey);


    if (!NT_SUCCESS(Status))
    {
        return Status;
    }

    //
    // Loop reading our key values
    //

    // TODO exit loop when value is found?
    ValueWasFound = FALSE;

    for (KeyIndex = 0; ; KeyIndex++)
    {
        KeyValueLength = 0;

        //
        // find out how much data we will get
        //

        Status = ZwEnumerateValueKey(
                    DeviceKey,
                    KeyIndex,
                    KeyValueFullInformation,
                    NULL,
                    0,
                    &KeyValueLength);

        if (STATUS_NO_MORE_ENTRIES == Status)
        {
            break;
        }

        if (0 == KeyValueLength)
        {
            return Status;
        }

        //
        // Read the data
        //

        KeyData = ExAllocatePool (PagedPool, KeyValueLength);

        if (NULL == KeyData)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }


        Status = ZwEnumerateValueKey(
                    DeviceKey,
                    KeyIndex,
                    KeyValueFullInformation,
                    KeyData,
                    KeyValueLength,
                    &KeyValueLength);

        if (!NT_SUCCESS(Status))
        {
            ExFreePool(KeyData);
            return Status;
        }

        KeyInfo = (PKEY_VALUE_FULL_INFORMATION) KeyData;

        if (0 == lstrnicmpW(KeyInfo->Name,
                            ParameterName,
                            KeyInfo->NameLength / sizeof(WCHAR)))
        {
            // check its a DWORD

            if (REG_DWORD != KeyInfo->Type)
            {
                ExFreePool(KeyData);
                return STATUS_DEVICE_CONFIGURATION_ERROR;
            }

            ValueWasFound = TRUE;

            *ParameterValue = *(PDWORD) (KeyData + KeyInfo->DataOffset);
        }

        ExFreePool(KeyData);

    }

    return (ValueWasFound) ? STATUS_SUCCESS : STATUS_DEVICE_CONFIGURATION_ERROR;

}


NTSTATUS
SidewndrDispatch(
    IN  PDEVICE_OBJECT pDO,
    IN  PIRP pIrp
)
/*++

Routine Description:

    Driver dispatch routine. Processes IRPs based on IRP MajorFunction

Arguments:

    pDO     -- pointer to the device object

    pIrp    -- pointer to the IRP to process


Return Value:

    Returns the value of the IRP IoStatus.Status

--*/
{
    PIO_STACK_LOCATION pIrpStack;
    NTSTATUS  Status;
    DWORD     dwRetries = 0;

    //DbgBreakPoint();

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

    Status = STATUS_SUCCESS;
    pIrp->IoStatus.Status = Status;
    pIrp->IoStatus.Information = 0;

    switch (pIrpStack->MajorFunction)
    {
        case IRP_MJ_CREATE:

            //
            // perform synchronous I/O
            //

            //pIrpStack->FileObject->Flags |= FO_SYNCHRONOUS_IO;
            //NB This is bad code -- we are simply one thread wandering off through the computer -- we should be queuing up a DPC,
            //returning status_pending to the calling program, then finishing the job when the dpc goes.  This is possible given
            //the analog game port technology.

            Status = SidewndrReset (((PJOY_EXTENSION)pDO->DeviceExtension)->DeviceAddress);

            ((PJOY_EXTENSION)pDO->DeviceExtension)->CurrentDeviceMode =
                             SIDEWINDER3P_ENHANCED_DIGITAL_MODE;

            //KeDelayExecutionThread( KernelMode, FALSE, &LI10ms); //unnecessary since SidewndrReset has a delay in it?

            pIrp->IoStatus.Status = Status;
            break;

        case IRP_MJ_CLOSE:

            break;

        case IRP_MJ_READ:

            //
            // Find out which device we are and read, but first make sure
            // there is enough room
            //

            DebugTrace(("IRP_MJ_READ"));
            //DbgBreakPoint();


            if (pIrpStack->Parameters.Read.Length < sizeof(JOY_DD_INPUT_DATA))
            {
                Status = STATUS_BUFFER_TOO_SMALL;
                pIrp->IoStatus.Status = Status;
                break;
            }

            //
            // Serialize and get the current device values
            //

            ExAcquireFastMutex(&((PJOY_EXTENSION)pDO->DeviceExtension)->Lock);


            Status = SidewndrPoll(pDO, pIrp);

            //
            // release the lock
            //

            ExReleaseFastMutex(&((PJOY_EXTENSION)pDO->DeviceExtension)->Lock);

            pIrp->IoStatus.Status = Status;
            pIrp->IoStatus.Information  = sizeof (JOY_DD_INPUT_DATA);
            break;


        case IRP_MJ_DEVICE_CONTROL:

            switch (pIrpStack->Parameters.DeviceIoControl.IoControlCode)
            {
                case IOCTL_JOY_GET_STATISTICS:

                    // report statistics
                    ((PJOY_STATISTICS)pIrp->AssociatedIrp.SystemBuffer)->nVersion             = JoyStatistics.nVersion;
                    ((PJOY_STATISTICS)pIrp->AssociatedIrp.SystemBuffer)->EnhancedPolls        = JoyStatistics.EnhancedPolls;
                    ((PJOY_STATISTICS)pIrp->AssociatedIrp.SystemBuffer)->EnhancedPollTimeouts = JoyStatistics.EnhancedPollTimeouts;
                    ((PJOY_STATISTICS)pIrp->AssociatedIrp.SystemBuffer)->EnhancedPollErrors   = JoyStatistics.EnhancedPollErrors;
                    ((PJOY_STATISTICS)pIrp->AssociatedIrp.SystemBuffer)->nPolledTooSoon       = JoyStatistics.nPolledTooSoon;
                    ((PJOY_STATISTICS)pIrp->AssociatedIrp.SystemBuffer)->nReset               = JoyStatistics.nReset;
                    {
                        int i;
                        for (i = 0; i < MAX_ENHANCEDMODE_ATTEMPTS; i++) {
                            ((PJOY_STATISTICS)pIrp->AssociatedIrp.SystemBuffer)->Retries[i] = JoyStatistics.Retries[i];
                        }
                    }

                    ((PJOY_STATISTICS)pIrp->AssociatedIrp.SystemBuffer)->dwQPCLatency         = dwQPCLatency;
                    ((PJOY_STATISTICS)pIrp->AssociatedIrp.SystemBuffer)->nReadLoopMax         = nReadLoopMax;
                    ((PJOY_STATISTICS)pIrp->AssociatedIrp.SystemBuffer)->Frequency            = Frequency;

                    Status = STATUS_SUCCESS;
                    pIrp->IoStatus.Status = Status;
                    pIrp->IoStatus.Information = sizeof(JOY_STATISTICS);

                    // reset statistics
                    JoyStatistics.EnhancedPolls        = 0;
                    JoyStatistics.EnhancedPollTimeouts = 0;
                    JoyStatistics.EnhancedPollErrors   = 0;
                    JoyStatistics.nPolledTooSoon       = 0;
                    JoyStatistics.nReset               = 0;
                    {
                        int i;
                        for (i = 0; i < MAX_ENHANCEDMODE_ATTEMPTS; i++) {
                            JoyStatistics.Retries[i] = 0;
                        }
                    }

                    break;

                case IOCTL_JOY_GET_JOYREGHWCONFIG:

                    SidewndrGetConfig (
                           (LPJOYREGHWCONFIG)(pIrp->AssociatedIrp.SystemBuffer),
                           ((PJOY_EXTENSION)pDO->DeviceExtension)
                                      );

                    pIrp->IoStatus.Information = sizeof(JOYREGHWCONFIG);

                    break;

                default:
                        DebugTrace(("Unknown IoControlCode"));

                    break;

            } // end switch on IOCTL code
            break;



        default:

            DebugTrace(("Unknown IRP Major Function %d", pIrpStack->MajorFunction));


    } // end switch on IRP_MAJOR_XXXX

    // pIrp->IoStatus.Status must be set to Status by this point.
    // pIrp->IoStatus.Information must be set to the correct size by this point.
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    return Status;
}


VOID
SidewndrUnload(
    PDRIVER_OBJECT pDriverObject
)

/*++

Routine Description:

    Driver unload routine. Deletes the device objects

Arguments:

    pDriverObject     -- pointer to the driver object whose devices we
                         are about to delete.


Return Value:

    Returns     Nothing

--*/
{
    DWORD DeviceNumber;
    WCHAR UnicodeDosDeviceName[200];


    //
    // Delete all of our devices
    //

    while (pDriverObject->DeviceObject)
    {
        DeviceNumber =
            ((PJOY_EXTENSION)pDriverObject->DeviceObject->DeviceExtension)->
                  DeviceNumber;

        //
        // withdraw claims on hardware by reporting no resource utilization
        //

        if (pDriverObject->DeviceObject)
        {
            if (DeviceNumber == 0)
            {
                SidewndrReportNullResourceUsage(pDriverObject->DeviceObject);
            }
        }



        RtlInitUnicodeString(
                    (PUNICODE_STRING) &UnicodeDosDeviceName,
                    L"\\DosDevices\\Joy1");

        IoDeleteSymbolicLink(
                    (PUNICODE_STRING) &UnicodeDosDeviceName);



        DebugTrace(("Freeing device %d", DeviceNumber));

        IoDeleteDevice(pDriverObject->DeviceObject);
    }
}


NTSTATUS
SidewndrPoll(
    IN  PDEVICE_OBJECT pDO,
    IN  PIRP pIrp
)
/*++

Routine Description:

    Polls the device for position and button information. The polling method
    (analog, digital, enhanced) is selected by the CurrentDeviceMode variable
    in the device extension.

    Only enhanced digital allowed.  If other modes are necessary, cut and paste
    (and test!) the code from file analog3p.c

Arguments:

    pDO     -- pointer to the device object

    pIrp    -- pointer to the IRP to process
               if successful, data is put into the pIrp


Return Value:

    STATUS_SUCCESS   -- if the poll succeeded,
    STATUS_TIMEOUT   -- if the poll failed

--*/
{
    NTSTATUS Status;
    PJOY_DD_INPUT_DATA pInput;

    pInput  = (PJOY_DD_INPUT_DATA)pIrp->AssociatedIrp.SystemBuffer;

    Status = STATUS_TIMEOUT;
    pIrp->IoStatus.Status = Status;


    if (pInput != NULL)
    {
        pInput->Unplugged = TRUE; // until proven otherwise
    }

    switch (((PJOY_EXTENSION)pDO->DeviceExtension)->CurrentDeviceMode)
    {
        case SIDEWINDER3P_INVALID_MODE:
            break;

        case SIDEWINDER3P_ANALOG_MODE:
            break;

        case SIDEWINDER3P_DIGITAL_MODE:
            break;

        case SIDEWINDER3P_ENHANCED_DIGITAL_MODE:

            // Don't poll too frequently, instead return last good packet
            if (KeQueryPerformanceCounter(NULL).QuadPart < liLastPoll.QuadPart + nMinTicksBetweenPolls) {
                JoyStatistics.nPolledTooSoon++;
                if (bLastGoodPacket) {
                    RtlCopyMemory (pInput, &jjLastGoodPacket, sizeof (JOY_DD_INPUT_DATA));
                    Status = STATUS_SUCCESS;
                }
                else {
                    // no last packet, too soon to poll, nothing we can do
                    Status = STATUS_TIMEOUT;
                }
                break;
            }
            // Poll the joystick
            Status = SidewndrEnhancedDigitalPoll(pDO, pIrp);
            if (Status == STATUS_SUCCESS) {
                // Everything's fine
                break;
            }
            else {
                // timed out, maybe user switched to analog mode?
                Status = SidewndrReset ( (PUCHAR) ((PJOY_EXTENSION)pDO->DeviceExtension)->DeviceAddress);
                JoyStatistics.nReset++;
                if (Status != STATUS_SUCCESS) {
                    // won't go digital, maybe unplugged, nothing we can do
                    break;
                }
            }
            // Now in enhanced digital mode, try polling it again (if user switches joystick between prev lines and
            // this line, we'll time out, next query to the joystick will find and solve the problem)
            Status = SidewndrEnhancedDigitalPoll(pDO, pIrp);
            break;

        case SIDEWINDER3P_MAXIMUM_MODE:
            break;

        default:
            break;

    }
    pIrp->IoStatus.Status = Status;
    return Status;
}


NTSTATUS
SidewndrEnhancedDigitalPoll(
    IN  PDEVICE_OBJECT pDO,
    IN PIRP pIrp
)
{
    PUCHAR   joyPort;
    NTSTATUS PollStatus;
    NTSTATUS DecodeStatus;
    DWORD    MaxRetries;

    joyPort = ((PJOY_EXTENSION)pDO->DeviceExtension)->DeviceAddress;

    // Try to get a good enhanced mode packet up to MAX_ENHANCEDMODE_ATTEMPTS
    // If there is a timeout, or if the data are invalid (bad checksum or sync
    // bits) wait 1ms for the joystick to reset itself, and try again.
    //
    // Note that although this should eventually get a good packet, packets
    // discarded in the interim (because of errors) will cause button presses
    // to be lost.
    //
    // Although this loses data, it keeps bad data from reaching the caller,
    // which seem to be about the best we can do at this stage.
    //
    // We keep a count of all the errors so that we keep track of just
    // how bad the situation really is.
    //

    for( MaxRetries = 0; MaxRetries < MAX_ENHANCEDMODE_ATTEMPTS; MaxRetries++)
    {
        // try to read (poll) the device

        liLastPoll = KeQueryPerformanceCounter (NULL);
        PollStatus = SidewndrGetEnhancedPacket(joyPort);
        ++JoyStatistics.EnhancedPolls;

        if (PollStatus != STATUS_SUCCESS)
        {
            // There was a timeout of some sort on the device read.
            ++JoyStatistics.EnhancedPollTimeouts;
        }
        else
        {
            // The device read completed. Process the data and verify the checksum
            // and sync bits. The processed data will be in AssociatedIrp.SystemBuffer
            DecodeStatus = SidewndrInterpretEnhancedPacket(
                (PJOY_DD_INPUT_DATA)pIrp->AssociatedIrp.SystemBuffer);
            if (DecodeStatus != STATUS_SUCCESS)
            {
                // The data was bad, most likely because we missed some of the nibbles.
                ++JoyStatistics.EnhancedPollErrors;
            }
            else
            {
                // Everything worked as we had hoped. The data has already been
                // deposited in the AssociatedIrp.SystemBuffer.
                JoyStatistics.Retries[MaxRetries]++;
                return STATUS_SUCCESS;
            }
        }

        // We did not succeed in reading the packet.  Wait 1 ms for the device to
        // stabilize before re-trying the read
        //KeDelayExecutionThread( KernelMode, FALSE, &LI1ms);  // cannot use KeDelayExecutionThread here
        //                                                      because we're at dispatch level, thanks
        //                                                      to the spin lock we hold
        // Mail from manolito says (64-48)*10us = 160us should be enough.  But I seem to recall reading 21 packets out of 66 sent.
        // Pending answer from manolito, set to 450us.
        SidewndrWait (600); // this is bad because it monopolizes the cpu, but since we're spinlocked anyway, what the heck, do it.

    }

    // We exceeded MAX_ENHANCEDMODE_ATTEMPTS. Something is pretty badly wrong;
    // in any case, a higher level caller will have to decide what to do
    return STATUS_TIMEOUT;

}


NTSTATUS
SidewndrReportNullResourceUsage(
    PDEVICE_OBJECT DeviceObject
)
{
    BOOLEAN ResourceConflict;
    CM_RESOURCE_LIST ResourceList;
    NTSTATUS Status;

    ResourceList.Count = 0;

    //
    // Report our usage and detect conflicts
    //

    Status = IoReportResourceUsage( NULL,
                                    DeviceObject->DriverObject,
                                    &ResourceList,
                                    sizeof(DWORD),
                                    DeviceObject,
                                    NULL,
                                    0,
                                    FALSE,
                                    &ResourceConflict);
    if (NT_SUCCESS(Status))
    {
        if (ResourceConflict)
        {
            return STATUS_DEVICE_CONFIGURATION_ERROR;
        }
        else
        {
            return STATUS_SUCCESS;
        }
    }
    else
    {
        return Status;
    }

}



BOOL
SidewndrQuiesce(
    PUCHAR JoyPort,
    UCHAR Mask
)
/*++

Routine Description:

    This routine attempts to insure that the joystick is not still active as a
    result of an earlier operation. This is accomplished by repeatedly reading
    the device and checking that no bits are set in the supplied mask. The idea
    is to check that none of the analog bits (resistive bits) are in use.

Arguments:

    JoyPort         - the address of the port (as returned from hal)

    Mask            - the mask specifying which analog bits should be checked.

Return Value:

    TRUE            Quiesce operation succeeded

    FALSE           No quiesce within a reasonable period. This generally means
                    that the device is unplugged.

    NB This is not a reliable test for "joystick unplugged"
    This routine can return TRUE under some circumstances
    even when there is no joystick

--*/
{
    int i;
    UCHAR PortVal;

    //
    // Wait for the stuff to quiesce
    //

    for (i = 0; i < ANALOG_POLL_TIMEOUT; i++) {

        PortVal = READ_PORT_UCHAR(JoyPort);
        if ((PortVal & Mask) == 0){
            return TRUE;
        } else {
            KeStallExecutionProcessor(1);
        }
    }

    //
    // If poll timed out we have an uplugged joystick
    //

    DebugTrace(("SidewndrQuiesce failed!"));

    return FALSE;
}


NTSTATUS
SidewndrMapDevice(
    DWORD PortBase,
    DWORD NumberOfPorts,
    PJOY_EXTENSION pJoyExtension
)
{
    DWORD MemType;
    PHYSICAL_ADDRESS PortAddress;
    PHYSICAL_ADDRESS MappedAddress;


    MemType = 1;                 // IO space
    PortAddress.LowPart = PortBase;
    PortAddress.HighPart = 0;


    HalTranslateBusAddress(
                Isa,
                0,
                PortAddress,
                &MemType,
                &MappedAddress);

    if (MemType == 0) {
        //
        // Map memory type IO space into our address space
        //
        pJoyExtension->DeviceAddress = (PUCHAR) MmMapIoSpace(MappedAddress,
                                                             NumberOfPorts,
                                                             FALSE);
        pJoyExtension->DeviceIsMapped = TRUE;
    }
    else
    {
        pJoyExtension->DeviceAddress  = (PUCHAR) MappedAddress.LowPart;
        pJoyExtension->DeviceIsMapped = FALSE;
    }

    return STATUS_SUCCESS;

}


DWORD
TimeInMicroSeconds(
    DWORD dwTime
)
{
    DWORD Remainder;

    return RtlExtendedLargeIntegerDivide(
                RtlEnlargedUnsignedMultiply( dwTime, 1000000L),
                Frequency,
                &Remainder
           ).LowPart;
}

DWORD
TimeInTicks(
    DWORD dwTimeInMicroSeconds
)
{
    return (DWORD) (((__int64)dwTimeInMicroSeconds * (__int64)Frequency) / (__int64) 1000000L);
}


NTSTATUS
SidewndrWaitForClockEdge(
    DWORD   edge,
    BYTE    *pByte,
    PUCHAR  JoyPort
)
/*++

Routine Description:

    Waits for the clock line to go high, or low depending on a the supplied
    parameter (edge).  If edge is CLOCK_RISING_EDGE, waits for rising edge,
    else if edge is CLOCK_FALLING_EDGE

    An upper bound for the wait duration is set at 1000 iterations.

    Arguments:

    edge    -- CLOCK_RISING_EDGE or CLOCK_FALLING Edge to specify what to await

    pByte   -- The contents of the device register are returned for other use


Return Value:

    STATUS_SUCCESS  --  the specified edge was detected before timeout

    STATUS_TIMEOUT  --  timeout before detecting specified edge.

--*/

{
    DWORD  maxTimeout;
    BYTE   joyByte;

    maxTimeout = nReadLoopMax;

    if (CLOCK_RISING_EDGE == edge)
    {
        while (maxTimeout--)
        {
            joyByte = READ_PORT_UCHAR(JoyPort);
            if (joyByte & CLOCK_BITMASK)
            {
                *pByte = joyByte;
                return STATUS_SUCCESS;
            }
        }
        *pByte = joyByte;
        return STATUS_TIMEOUT;
    }
    else
    {
        while (maxTimeout--)
        {
            joyByte = READ_PORT_UCHAR(JoyPort);
            if (!(joyByte & CLOCK_BITMASK))
            {
                *pByte = joyByte;
                return STATUS_SUCCESS;
            }
        }
        *pByte = joyByte;
        return STATUS_TIMEOUT;
    }
}


NTSTATUS
SidewndrReset(
    PUCHAR JoyPort
)
// This resets the joystick to enhanced digital mode.
{
    DWORD dwRetries;
    NTSTATUS Status;

    dwRetries = 0;

    do {
        ++dwRetries;

        Status = SidewndrStartAnalogMode(JoyPort);
        if (Status == STATUS_TIMEOUT) continue;
        //KeDelayExecutionThread( KernelMode, FALSE, &LI10ms);  //MarkSV thinks this is unnecessary

        Status = SidewndrStartDigitalMode(JoyPort);
        if (Status == STATUS_TIMEOUT) continue;
        //KeDelayExecutionThread( KernelMode, FALSE, &LI10ms);  //MarkSV thinks this is unnecessary

        Status = SidewndrStartEnhancedMode(JoyPort);

    } while ((Status == STATUS_TIMEOUT) && (dwRetries < 10) );

    // give the joystick time to stabilize  MarkSV thinks this is unnecessary
    //KeDelayExecutionThread( KernelMode, FALSE, &LI10ms);


    return Status;
}



NTSTATUS
SidewndrStartAnalogMode(
    PUCHAR JoyPort
)
{
    KIRQL   OldIrql;

    if(! SidewndrQuiesce(JoyPort, 0x01))
    {
        return STATUS_TIMEOUT;
    }

    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

    WRITE_PORT_UCHAR(JoyPort, JOY_START_TIMERS);
    if (!SidewndrReadWait(JoyPort, X_AXIS_BITMASK)) goto timeout;

    WRITE_PORT_UCHAR(JoyPort, JOY_START_TIMERS);
    if (!SidewndrReadWait(JoyPort, X_AXIS_BITMASK)) goto timeout;

    WRITE_PORT_UCHAR(JoyPort, JOY_START_TIMERS);

    KeLowerIrql(OldIrql);

    //
    // Wait 1ms to let port settle out
    //

    KeDelayExecutionThread( KernelMode, FALSE, &LI10ms); // MarkSV says 1 ms is enough, original code had 8 ms

    return STATUS_SUCCESS;

timeout:
    KeLowerIrql(OldIrql);
    return STATUS_TIMEOUT;

}


NTSTATUS
SidewndrStartDigitalMode(
    PUCHAR JoyPort
)
{
    KIRQL   OldIrql;
    DWORD dwStart, dwX0, dwX1, dwX2, dwX3;


    DebugTrace(("Sidewndr: Digital Mode Requested"));

    SidewndrQuiesce(JoyPort, 0x01);


    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);


    WRITE_PORT_UCHAR(JoyPort, JOY_START_TIMERS);
    if (!SidewndrReadWait(JoyPort, X_AXIS_BITMASK)) goto timeout;
    SidewndrWait (75);

    WRITE_PORT_UCHAR(JoyPort, JOY_START_TIMERS);
    if (!SidewndrReadWait(JoyPort, X_AXIS_BITMASK)) goto timeout;
    SidewndrWait (75 + 726);

    WRITE_PORT_UCHAR(JoyPort, JOY_START_TIMERS);
    if (!SidewndrReadWait(JoyPort, X_AXIS_BITMASK)) goto timeout;
    SidewndrWait (75 + 300);

    WRITE_PORT_UCHAR(JoyPort, JOY_START_TIMERS);
    if (!SidewndrReadWait(JoyPort, X_AXIS_BITMASK)) goto timeout;

    KeLowerIrql(OldIrql);

    SidewndrQuiesce(JoyPort, 0x01);

    return STATUS_SUCCESS;

timeout:
    KeLowerIrql(OldIrql);
    return STATUS_TIMEOUT;
}



NTSTATUS
SidewndrStartEnhancedMode(
    PUCHAR JoyPort
)
{
    DWORD     byteIndex;
    DWORD     bitIndex;
    BYTE     JoyByte;
    NTSTATUS Status;
    KIRQL    OldIrql;



    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

    WRITE_PORT_UCHAR(JoyPort, JOY_START_TIMERS);

    // Wait for serial clock to go high, probably already there.
    Status = SidewndrWaitForClockEdge(CLOCK_RISING_EDGE, &JoyByte, JoyPort);

    if (Status != STATUS_SUCCESS)
    {
        KeLowerIrql(OldIrql);
        DebugTrace(("SidewndrStartEnhancedMode: timeout in first spin"));
        return(STATUS_TIMEOUT);
    }

    for (byteIndex = 0; byteIndex < 6; byteIndex++)
    {
        for (bitIndex = 0; bitIndex < 8; bitIndex++)
        {
            // look for falling edge of serial clock.

            Status = SidewndrWaitForClockEdge(CLOCK_FALLING_EDGE, &JoyByte, JoyPort);
            if (Status != STATUS_SUCCESS)
            {
                KeLowerIrql(OldIrql);
                DebugTrace(("SidewndrStartEnhancedMode: timeout in second spin byteIndex %d bitIndex %d", byteIndex, bitIndex));
                return(STATUS_TIMEOUT);
            }

            // Wait for serial clock to go high.
            Status = SidewndrWaitForClockEdge(CLOCK_RISING_EDGE, &JoyByte, JoyPort);
            if (Status != STATUS_SUCCESS)
            {
                KeLowerIrql(OldIrql);
                DebugTrace(("SidewndrStartEnhancedMode: timeout in third spin"));
                return(STATUS_TIMEOUT);
            }

        }
    }

    // Interrupt the processor again, telling it to send an ID packet.
    // After getting the ID packet it knows to go into enhanced mode.
    // This does not affect the packet currently going.

    WRITE_PORT_UCHAR(JoyPort, JOY_START_TIMERS);


    // Wait out the rest of the packet so we can figure out how long this takes.
    for (byteIndex = 6; byteIndex < 8; byteIndex++)
    {
        for (bitIndex = 0; bitIndex < 8; bitIndex++)
        {
            // look for falling edge of serial clock.
            Status = SidewndrWaitForClockEdge(CLOCK_FALLING_EDGE, &JoyByte, JoyPort);

            if (Status != STATUS_SUCCESS)
            {
                KeLowerIrql(OldIrql);
                DebugTrace(("SidewndrStartEnhancedMode Timeout in 4th spin"));
                return(STATUS_TIMEOUT);
            }

            // Wait for serial clock to go high.

            Status = SidewndrWaitForClockEdge(CLOCK_RISING_EDGE, &JoyByte, JoyPort);
            if (Status != STATUS_SUCCESS)
            {
                KeLowerIrql(OldIrql);
                DebugTrace(("SidewndrStartEnhancedMode Timeout in 5th spin"));
                return(STATUS_TIMEOUT);
            }

        }
    }

    KeLowerIrql(OldIrql);

    //m_tmPacketTime = SystemTime() - tmStartTime;

    // The joystick ID comes across on 20 bytes and we just did 8 bytes,
    // so wait (with interrupts enabled) long enough for the ID packet to
    // complete.  After that we should be in enhanced mode.  Each nibble takes
    // about 10us, so 1ms should be plenty of time for everything.
    KeDelayExecutionThread( KernelMode, FALSE, &LI10ms);

    return(STATUS_SUCCESS);

}



/*++
*******************************************************************************
Routine:

    CSidewinder::GetEnhancedPacket

Description:

    If the joystick is in digital enhanced mode, you can call this to
    get a digital packet and store the data into the class' m_enhancedPacket
    member variable.  Call InterpretEnhancedPacket to turn the raw data into
    joystick info.

    Note that while you can get an enhanced packet in 1/3 the time of a normal
    packet (and can thus turn back on interrputs much sooner), you can not get
    enhanced packets any faster than you can get normal packets.  This function
    will check to make sure sufficient time has passed since the last time it
    was called and if it hasn't it will wait (with interrupts ENABLED) until
    that is true before asking for another packet.

    This assumes the joystick is in digital enhanced mode and there is no way
    to tell if this is not the case.  If the joystick is just in digital
    (non-enhanced) mode then this will return successfully.  However, the
    checksum and/or sync bits will not be correct.

Arguments:

    None.

Return Value:

    successful if it worked.
    not_digital_mode if the joystick is not in digital mode.

*******************************************************************************
--*/
NTSTATUS
SidewndrGetEnhancedPacket(
    PUCHAR JoyPort
)
{
    KIRQL    OldIrql;
    DWORD    byteIndex;
    DWORD    maxTimeout;
    BYTE     joyByte;
    NTSTATUS Status;

    // While enhanced packets come across faster than normal packets,
    // they can not be called any more frequently.  This makes sure
    // we've let enough time since the last packet go by before calling
    // for another.


#if USE_CLI && defined(_X86_)
    __asm {
        cli
    }

#else
    KeRaiseIrql(HIGH_LEVEL, &OldIrql);
#endif

    // Start the retrieval operation

    WRITE_PORT_UCHAR(JoyPort, 0);

    // Wait for serial clock to go high, probably already there.

    maxTimeout = nReadLoopMax;
    while (maxTimeout--)
    {
        joyByte = READ_PORT_UCHAR(JoyPort);
        if (joyByte & CLOCK_BITMASK)
        {
            break;
        }
    }

    if (maxTimeout == 0)
    {
        goto Done;
    }

    for (byteIndex = 0; byteIndex < MAX_PACKET_SIZE; byteIndex++)
    {
        // look for falling edge of serial clock.

        maxTimeout = nReadLoopMax;
        while (maxTimeout--)
        {
            joyByte = READ_PORT_UCHAR(JoyPort);
            if (!(joyByte & CLOCK_BITMASK))
            {
                break;
            }
        }

        if (maxTimeout == 0)
        {
            goto Done;
        }


        // Wait for serial clock to go high.

        maxTimeout = nReadLoopMax;
        while (maxTimeout--)
        {
            joyByte = READ_PORT_UCHAR(JoyPort);
            if (joyByte & CLOCK_BITMASK)
            {
                break;
            }
        }

        if (maxTimeout == 0)
        {
            goto Done;
        }

        EnhancedPacket[byteIndex] = (joyByte & ALLDATA_BITMASK) >> 5;
    }

Done:

#if USE_CLI && defined(_X86_)
    __asm {
        sti
    }
#else
    KeLowerIrql(OldIrql);
#endif

    if (maxTimeout == 0)
    {
        return(STATUS_TIMEOUT);
    }

#if MAX_POLL_LENGTH

    PollLength =  KeQueryPerformanceCounter(NULL).QuadPart - liLastPoll.QuadPart;

    if (PollLength > PollLengthMax) {
        // DbgPrint( "Swndr: Poll Length exceed %d.\n", TimeInMicroSeconds(PollLength) );
        return(STATUS_TIMEOUT);
    }
#endif

    return(STATUS_SUCCESS);
}





/*++
*******************************************************************************
Routine:

    CSidewinder::InterpretEnhancedPacket

Description:

    Call this after getting an enhanced packet.  It converts the raw data into
    normal joystick data, filling out the class' m_data structure.

    The encoding of the raw Data bits (D1-D3) is given below.

Data packet format for Enhanced Mode transmission (4 line)
 Byte   D3      D2      D1        D0
    0   Y9      Y8      Y7         SCLK
    1   X9      X8      X7         SCLK
    2   B0      1       H3         SCLK
    3   B3      B2      B1         SCLK
    4   B6      B5      B4         SCLK
    5   X1      X0      0         SCLK
    6   X4      X3      X2         SCLK
    7   0       X6      X5         SCLK
    8   Y2      Y1      Y0         SCLK
    9   Y5      Y4      Y3         SCLK
    10  T7      0       Y6         SCLK
    11  R7      T9      T8         SCLK
    12  B7      CH/TM   R8         SCLK
    13  R1      R0      0          SCLK
    14  R4      R3      R2         SCLK
    15  0       R6      R5         SCLK
    16  T2      T1      T0         SCLK
    17  T5      T4      T3         SCLK
    18  CHKSUM0 0       T6         SCLK
    19  CHKSUM3 CHKSUM2 CHKSUM1    SCLK
    20  H2      H1      H0         SCLK
    21  0       0       0          SCLK
    22  Y9      Y8      Y7         SCLK


Arguments:

    None.

Return Value:

    successful if the data was valid.
    bad_packet if either the checksum or sync bits were incorrect.


*******************************************************************************
--*/
NTSTATUS
SidewndrInterpretEnhancedPacket(
    PJOY_DD_INPUT_DATA pInput
)
{
    WORD    temp16;
    BYTE    temp8;
    BYTE    checksum;

    pInput->Unplugged = FALSE;
    pInput->Mode      = SIDEWINDER3P_ENHANCED_DIGITAL_MODE;

    //Get xOffset.
    temp16 = 0x0000;
    temp16 |= (EnhancedPacket[1]  & 0x07) << 7;
    temp16 |= (EnhancedPacket[7]  & 0x03) << 5;
    temp16 |= (EnhancedPacket[6]  & 0x07) << 2;
    temp16 |= (EnhancedPacket[5]  & 0x06) >> 1;
    pInput->u.DigitalData.XOffset = temp16;


    //Get yOffset.
    temp16 = 0x0000;
    temp16 |= (EnhancedPacket[0]  & 0x07) << 7;
    temp16 |= (EnhancedPacket[10] & 0x01) << 6;
    temp16 |= (EnhancedPacket[9]  & 0x07) << 3;
    temp16 |= (EnhancedPacket[5]  & 0x07);
    pInput->u.DigitalData.YOffset = temp16;


    //Get rzOffset: Only 9 bits (others are 10)
    temp16 = 0x0000;
    temp16 |= (EnhancedPacket[12] & 0x01) << 8;
    temp16 |= (EnhancedPacket[11] & 0x04) << 5;
    temp16 |= (EnhancedPacket[15] & 0x03) << 5;
    temp16 |= (EnhancedPacket[14] & 0x07) << 2;
    temp16 |= (EnhancedPacket[13] & 0x06) >> 1;
    pInput->u.DigitalData.RzOffset = temp16;

    //Get tOffset.
    temp16 = 0x0000;
    temp16 |= (EnhancedPacket[11] & 0x03) << 8;
    temp16 |= (EnhancedPacket[10] & 0x04) << 5;
    temp16 |= (EnhancedPacket[18] & 0x01) << 6;
    temp16 |= (EnhancedPacket[17] & 0x07) << 3;
    temp16 |= (EnhancedPacket[16] & 0x07);
    pInput->u.DigitalData.TOffset = temp16;


    //Get Hat
    temp8 = 0x00;
    temp8 |= (EnhancedPacket[2]  & 0x01) << 3;
    temp8 |= (EnhancedPacket[20] & 0x07);
    pInput->u.DigitalData.Hat = temp8;

    //Get Buttons
    temp8 = 0x00;
    temp8 |= (EnhancedPacket[2]  & 0x04) >> 2;
    temp8 |= (EnhancedPacket[3]  & 0x07) << 1;
    temp8 |= (EnhancedPacket[4]  & 0x07) << 4;
    temp8 |= (EnhancedPacket[12] & 0x04) << 5;
    temp8 = ~temp8;  // Buttons are 1 = off, 0 = on.  Want the opposite.
    pInput->u.DigitalData.Buttons = temp8;


    // Get CH/TM switch.
    pInput->u.DigitalData.Switch_CH_TM =
        ((EnhancedPacket[12] & 0x02) == 0) ? 1 : 2;


    // Get Checksum
    temp8 = 0x00;
    temp8 |= (EnhancedPacket[18] & 0x04) >> 2;
    temp8 |= (EnhancedPacket[19] & 0x07) << 1;
    pInput->u.DigitalData.Checksum = temp8;


    //
    // Check the checksum. Because the enhance mode retrieves the data packet
    // 3 bits at a time, the data is not in the same order that it arrives in
    // in the normal mode. Thus, calculating the checksum requires additional
    // manipulation.
    //

    checksum = pInput->u.DigitalData.Checksum;
    checksum += 0x08 | ((EnhancedPacket[2] & 0x01) << 2) |
        ((EnhancedPacket[1] & 0x06) >> 1);
    checksum += ((EnhancedPacket[1] & 0x01) << 3) |
        (EnhancedPacket[0] & 0x07);
    checksum += (EnhancedPacket[4] & 0x07);
    checksum += ((EnhancedPacket[3] & 0x07) << 1) |
        ((EnhancedPacket[2] & 0x04) >> 2);
    checksum += ((EnhancedPacket[7] & 0x03) << 1) |
        ((EnhancedPacket[6] & 0x04) >> 2);
    checksum += ((EnhancedPacket[6] & 0x03) << 2) |
        ((EnhancedPacket[5] & 0x06) >> 1);
    checksum += ((EnhancedPacket[10] & 0x01) << 2) |
        ((EnhancedPacket[9] & 0x06) >> 1);
    checksum += ((EnhancedPacket[9] & 0x01) << 3) |
        (EnhancedPacket[8] & 0x07);
    checksum += (EnhancedPacket[12] & 0x07);
    checksum += ((EnhancedPacket[11] & 0x07) << 1) |
        ((EnhancedPacket[10] & 0x04) >> 2);
    checksum += ((EnhancedPacket[15] & 0x03) << 1) |
        ((EnhancedPacket[14] & 0x04) >> 2);
    checksum += ((EnhancedPacket[14] & 0x03) << 2) |
        ((EnhancedPacket[13] & 0x06) >> 1);
    checksum += ((EnhancedPacket[18] & 0x01) << 2) |
        ((EnhancedPacket[17] & 0x06) >> 1);
    checksum += ((EnhancedPacket[17] & 0x01) << 3) |
        (EnhancedPacket[16] & 0x07);
    checksum += (EnhancedPacket[20] & 0x07);

    checksum &= 0x0F;
    if (checksum == 0)
    {
        pInput->u.DigitalData.fChecksumCorrect = TRUE;
    }
    else
    {
        pInput->u.DigitalData.fChecksumCorrect = FALSE;
        DebugTrace(("Enhanced packet checksum failed.\n"));
    }


    //
    // Check SyncBits
    // The routine gathers 2 extra bytes from the joystick. These
    // should be zero and equal to the first byte.
    //

    if ((EnhancedPacket[2] & 0x02) != 0 &&
        EnhancedPacket[0] == EnhancedPacket[22])
    {
        checksum =
            (EnhancedPacket[5]  & 0x01) + (EnhancedPacket[7]  & 0x04) +
            (EnhancedPacket[10] & 0x02) + (EnhancedPacket[13] & 0x01) +
            (EnhancedPacket[15] & 0x04) + (EnhancedPacket[18] & 0x02) +
            EnhancedPacket[21];

        if (checksum == 0)
        {
            pInput->u.DigitalData.fSyncBitsCorrect = TRUE;
        }
        else
        {
            pInput->u.DigitalData.fSyncBitsCorrect = FALSE;
            DebugTrace(("Enhanced packet sync bits incorrect.\n"));
        }
    }
    else
    {
        pInput->u.DigitalData.fSyncBitsCorrect = FALSE;
    }

    if (pInput->u.DigitalData.fChecksumCorrect == TRUE &&
        pInput->u.DigitalData.fSyncBitsCorrect == TRUE )
    {
        // everything worked, save this info as last good packet
        RtlCopyMemory (&jjLastGoodPacket, pInput, sizeof (JOY_DD_INPUT_DATA));
        bLastGoodPacket = TRUE;
        return(STATUS_SUCCESS);
    }
    else
    {
        return(STATUS_TIMEOUT);
    }
}



int lstrnicmpW (LPWSTR pszA, LPWSTR pszB, size_t cch)
{
    if (!pszA || !pszB)
    {
        return (!pszB) - (!pszA);   // A,!B:1, !A,B:-1, !A,!B:0
    }

//  while (cch--)
    for ( ; cch > 0; cch--, pszA++, pszB++) // previous version did not increment string pointers [SteveZ]
    {
        if (!*pszA || !*pszB)
        {
            return (!*pszB) - (!*pszA);    // A,!B:1, !A,B:-1, !A,!B:0
        }

        if (*pszA != *pszB)
        {
            return (int)(*pszA) - (int)(*pszB);   // -1:A<B, 0:A==B, 1:A>B
        }
    }

    return 0;  // no differences before told to stop comparing, so A==B
}


VOID
SidewndrWait (
    DWORD TotalWait // in uS
)
/*++

Routine Description:

    This routine waits for the specified number of microseconds.  Tolerances for
    the joystick are smaller than NT typically provide, so all timing is isolated
    into this routine, where we can do crude things and play nasty hacks as
    necessary.  This routine locks up the cpu, so only use it for putting the joystick
    into digital mode.

Arguments:

    TotalWait - time to wait in microseconds

--*/
{
    DWORD ulStartTime, ulEndTime;
    int nTicks;

    // dwQPCLatency is the calibrated-for-this-machine latency for a call to KeQueryPerfomanceCounter (in uS).

    nTicks = TimeInTicks (TotalWait - dwQPCLatency);
    if (nTicks <= 0) return;

    ulStartTime = KeQueryPerformanceCounter(NULL).LowPart;
    ulEndTime = ulStartTime + nTicks;


    while (KeQueryPerformanceCounter(NULL).LowPart < ulEndTime) {
        ;
    }
}


BOOL
SidewndrReadWait (
    PUCHAR JoyPort,
    UCHAR Mask
)
{
/*++
read a port and wait until it gives correct answer based on mask.
timeout after nReadLoopMax iterations (about 2 mS).
--*/

    int i;
    for (i = 0; i < nReadLoopMax; i++) {
        if ( ! (READ_PORT_UCHAR(JoyPort) & Mask) )
            return TRUE; // port went high
    }
    return FALSE; // timed out
}


void
SidewndrGetConfig (
    LPJOYREGHWCONFIG pConfig,
    PJOY_EXTENSION pJoyExtension
)
/*++

Routine Description:

    This routine is called in response to the IOCTL_JOY_GET_JOYREGHWCONFIG
    query.  It fills out a JOYREGHWCONFIG structure with relevant information
    about the given joystick.

Arguments:

    pConfig - Specifies a JOYREGHWCONFIG structure, to be filled in

    pJoyExtension - Specifies the joystick to query

Return Value:

    void

--*/
{
    pConfig->hws.dwNumButtons = 4;

    switch (pJoyExtension->CurrentDeviceMode)
    {
        case SIDEWINDER3P_ANALOG_MODE:
        {
            pConfig->hws.dwFlags = JOY_HWS_HASPOV |
                                   JOY_HWS_POVISBUTTONCOMBOS |
                                   JOY_HWS_HASR |
                                   JOY_HWS_HASZ;

            pConfig->dwUsageSettings = JOY_US_HASRUDDER |
                                       JOY_US_PRESENT |
                                       JOY_US_ISOEM;

            pConfig->hwv.jrvHardware.jpMin.dwX = 20;
            pConfig->hwv.jrvHardware.jpMin.dwY = 20;
            pConfig->hwv.jrvHardware.jpMin.dwZ = 20;
            pConfig->hwv.jrvHardware.jpMin.dwR = 20;
            pConfig->hwv.jrvHardware.jpMin.dwU = 0;
            pConfig->hwv.jrvHardware.jpMin.dwV = 0;

            pConfig->hwv.jrvHardware.jpMax.dwX = 1600;
            pConfig->hwv.jrvHardware.jpMax.dwY = 1600;
            pConfig->hwv.jrvHardware.jpMax.dwZ = 1600;
            pConfig->hwv.jrvHardware.jpMax.dwR = 1600;
            pConfig->hwv.jrvHardware.jpMax.dwU = 0;
            pConfig->hwv.jrvHardware.jpMax.dwV = 0;

            pConfig->hwv.jrvHardware.jpCenter.dwX = 790;
            pConfig->hwv.jrvHardware.jpCenter.dwY = 790;
            pConfig->hwv.jrvHardware.jpCenter.dwZ = 790;
            pConfig->hwv.jrvHardware.jpCenter.dwR = 790;
            pConfig->hwv.jrvHardware.jpCenter.dwU = 0;
            pConfig->hwv.jrvHardware.jpCenter.dwV = 0;

            break;
        }

        default:
        case SIDEWINDER3P_DIGITAL_MODE:
        case SIDEWINDER3P_ENHANCED_DIGITAL_MODE:
        {
            pConfig->hws.dwFlags = JOY_HWS_HASPOV |
                                   JOY_HWS_POVISBUTTONCOMBOS |
                                   JOY_HWS_HASR |
                                   JOY_HWS_HASZ;

            pConfig->dwUsageSettings = JOY_US_HASRUDDER |
                                       JOY_US_PRESENT |
                                       JOY_US_ISOEM;

            pConfig->hwv.jrvHardware.jpMin.dwX = 0;
            pConfig->hwv.jrvHardware.jpMin.dwY = 0;
            pConfig->hwv.jrvHardware.jpMin.dwZ = 0;
            pConfig->hwv.jrvHardware.jpMin.dwR = 0;
            pConfig->hwv.jrvHardware.jpMin.dwU = 0;
            pConfig->hwv.jrvHardware.jpMin.dwV = 0;

            pConfig->hwv.jrvHardware.jpMax.dwX = 1024;
            pConfig->hwv.jrvHardware.jpMax.dwY = 1024;
            pConfig->hwv.jrvHardware.jpMax.dwZ = 1024;
            pConfig->hwv.jrvHardware.jpMax.dwR = 512;
            pConfig->hwv.jrvHardware.jpMax.dwU = 0;
            pConfig->hwv.jrvHardware.jpMax.dwV = 0;

            pConfig->hwv.jrvHardware.jpCenter.dwX = 512;
            pConfig->hwv.jrvHardware.jpCenter.dwY = 512;
            pConfig->hwv.jrvHardware.jpCenter.dwZ = 512;
            pConfig->hwv.jrvHardware.jpCenter.dwR = 256;
            pConfig->hwv.jrvHardware.jpCenter.dwU = 0;
            pConfig->hwv.jrvHardware.jpCenter.dwV = 0;

            break;
        }
    }

    pConfig->hwv.dwCalFlags = JOY_ISCAL_POV;

    pConfig->dwType = JOY_HW_CUSTOM;

    pConfig->dwReserved = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\winkey\inc\winkeycmn.h ===
#ifndef __WINKEYCMN_H__
#define __WINKEYCMN_H__

/* 017a328b-938d-4576-970f-9e08a7f24948 */
DEFINE_GUID(GUID_WMI_WINKEY_RAW_DATA, 0x017a328b, 0x938d, 0x4576, 0x97, 0x0f, 0x9e, 0x08, 0xa7, 0xf2, 0x49, 0x48);

#endif // __WINKEYCMN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\upgrade\upgrade.c ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <tchar.h>
#include <regstr.h>

// this will change when the .h is moved to a public location
#include "comp.h"

HINSTANCE hInstance;

PCOMPAIBILITYCALLBACK CompatCallback;
LPVOID                CompatContext;

#define szServicesPath REGSTR_PATH_SERVICES TEXT("\\")
#define szDeviceMap    TEXT("HARDWARE\\DEVICEMAP")

typedef struct _INPUT_DRIVER_DATA {
    LPTSTR Service;

    BOOL DisableReplacements;

    LPTSTR DeviceMapSubKey;

} INPUT_DRIVER_DATA;

INPUT_DRIVER_DATA DriverData[] = {
    { TEXT("sermouse"), FALSE, NULL },
    { TEXT("i8042prt"), TRUE, TEXT("KeyboardPort") },
    { TEXT("mouclass"), TRUE, TEXT("PointerClass") },
    { TEXT("kbdclass"), TRUE, TEXT("KeyboardClass") },
};

#define NUM_DRIVER_DATA (sizeof(DriverData) / sizeof(INPUT_DRIVER_DATA))

LPENUM_SERVICE_STATUS
AllocEnumServiceStatus(SC_HANDLE hSCManager, LPDWORD Count)
{
    LPENUM_SERVICE_STATUS ess;
    DWORD size;
    DWORD resume;

    EnumServicesStatus(hSCManager,
                       SERVICE_DRIVER,
                       SERVICE_ACTIVE,
                       NULL,
                       0,
                       &size,
                       Count,
                       &resume);

    if (size == 0) {
        return NULL;
    }

    ess = (LPENUM_SERVICE_STATUS) LocalAlloc(LPTR, size);
    if (!ess) {
        return NULL;
    }

    EnumServicesStatus(hSCManager,
                       SERVICE_DRIVER,
                       SERVICE_ACTIVE,
                       ess,
                       size,
                       &size,
                       Count,
                       &resume);

    return ess;
}

LPQUERY_SERVICE_CONFIG 
GetServiceConfig(SC_HANDLE hService)
{
    LPQUERY_SERVICE_CONFIG pConfig;
    DWORD configSize;

    QueryServiceConfig(hService, NULL, 0, &configSize);

    pConfig = (LPQUERY_SERVICE_CONFIG) LocalAlloc(LPTR, configSize);
    if (pConfig == NULL) {
        return NULL;
    }

    if (!QueryServiceConfig(hService, pConfig, configSize, &configSize)) {
        LocalFree(pConfig);
        pConfig = NULL;
    }

    return pConfig;
}

BOOL
ValidImagePath(LPTSTR Service, LPTSTR ImagePath, LPTSTR *ImageName)
{
    LPTSTR pszDriver, pszDriverEnd, pszDriverBegin;

    if (!ImagePath) {
        return FALSE;
    }

    if (lstrlen(ImagePath) == 0) {
        return TRUE;
    }

    if (_tcschr(ImagePath, TEXT('\\')) == 0) {
        return FALSE;
    }

    pszDriver = ImagePath;
    pszDriverEnd = pszDriver + lstrlen(pszDriver);

    while(pszDriverEnd != pszDriver &&
          *pszDriverEnd != TEXT('.')) {
        pszDriverEnd--;
    }

    // pszDriverEnd points to either the beginning of the string or '.'
    pszDriverBegin = pszDriverEnd;

    while(pszDriverBegin != pszDriver &&
          *pszDriverBegin != TEXT('\\')) {
        pszDriverBegin--;
    }

    pszDriverBegin++;

    //
    // If pszDriver and pszDriverEnd are different, we now
    // have the driver name.
    //
    if (pszDriverBegin > pszDriver && 
        pszDriverEnd > pszDriverBegin) {

        LONG len, res;
        LPTSTR image;

        len = ((LONG) (pszDriverEnd - pszDriverBegin)) + 1;

        image = (LPTSTR) LocalAlloc(LPTR, len * sizeof(TCHAR));
        if (!image) {
            return FALSE;
        }
        
        // want to copy up to, but not including, the ','
        lstrcpyn(image, pszDriverBegin, len);
        res = lstrcmpi(image, Service); 

        if (ImageName != NULL) {
            *ImageName = image;
        } 
        else {
            LocalFree(image);
        }

        return res == 0;
    }
    else {
        return FALSE;
    }

}

VOID
SetServiceStartValue(LPTSTR Service, DWORD StartValue)
{
    COMPATIBILITY_ENTRY ce;
    TCHAR szStart[] = TEXT("Start");
    LPTSTR regPath;
    DWORD len;

    len = lstrlen(Service) + lstrlen(szServicesPath) + 1;
    len *= sizeof(TCHAR);

    regPath = (LPTSTR) LocalAlloc(LPTR, len);
    if (!regPath) {
        return;
    }

    lstrcpy(regPath, szServicesPath);
    lstrcat(regPath, Service);

    ZeroMemory(&ce, sizeof(COMPATIBILITY_ENTRY));
    // Description and TextName are need even though this is hidden
    ce.Description = Service; 
    ce.TextName = Service;
    ce.RegKeyName = regPath;
    ce.RegValName = szStart;
    ce.RegValDataSize = sizeof(DWORD);
    ce.RegValData = (LPVOID) &StartValue;
    ce.Flags |= COMPFLAG_HIDE;

    CompatCallback(&ce, CompatContext);

    LocalFree(regPath);
}

VOID
SetServiceImagePath(LPTSTR Service)
{
    COMPATIBILITY_ENTRY ce;
    TCHAR szImagePath[] = TEXT("ImagePath");
    TCHAR szPath[] = TEXT("System32\\Drivers\\");
    LPTSTR imagePath, regPath;
    DWORD len;

    len = lstrlen(Service) + lstrlen(szServicesPath) + 1;
    len *= sizeof(TCHAR);

    regPath = (LPTSTR) LocalAlloc(LPTR, len);
    if (!regPath) {
        return;
    }

    len = lstrlen(szPath) + lstrlen(Service) + lstrlen(TEXT(".sys")) + 1;
    len *= sizeof(TCHAR);

    imagePath = (LPTSTR) LocalAlloc(LPTR, len);
    if (!imagePath) {
        LocalFree(regPath);
        return;
    }

    lstrcpy(regPath, szServicesPath);
    lstrcat(regPath, Service);

    lstrcpy(imagePath, szPath);
    lstrcat(imagePath, Service);
    lstrcat(imagePath, TEXT(".sys"));

    ZeroMemory(&ce, sizeof(COMPATIBILITY_ENTRY));
    // Description and TextName are need even though this is hidden
    ce.Description = Service;
    ce.TextName = Service;
    ce.RegKeyName = regPath;
    ce.RegValName = szImagePath;
    ce.RegValDataSize = len; 
    ce.RegValData = (LPVOID) imagePath;
    ce.Flags |= COMPFLAG_HIDE;

    CompatCallback(&ce, CompatContext);

    LocalFree(regPath);
    LocalFree(imagePath);
}

SC_HANDLE
CheckService(SC_HANDLE hSCManager, LPTSTR Service, BOOL *Disabled)
{
    SC_HANDLE hService;
    LPQUERY_SERVICE_CONFIG pConfig;

    hService = OpenService(hSCManager, Service, SERVICE_QUERY_CONFIG);
    if (hService) {
        pConfig = GetServiceConfig(hService);
        if (pConfig) {

            if (pConfig->dwStartType == SERVICE_DISABLED && 
                pConfig->lpBinaryPathName &&
                lstrlen(pConfig->lpBinaryPathName) == 0) {
                //
                // The service has been preinstalled in the registry, but never
                // installed on the machine (indicated byno image path,
                // disabled).  Setting its start value to demand start will not
                // cause any conflicts at all in the PNP world of input drivers.
                //
                SetServiceStartValue(Service, SERVICE_DEMAND_START);
            }
            else {
                if (pConfig->dwStartType != SERVICE_SYSTEM_START &&
                    pConfig->dwStartType != SERVICE_DEMAND_START) {
                    if (Disabled) {
                        *Disabled = TRUE;
                    }
                    SetServiceStartValue(Service, SERVICE_DEMAND_START);
                }
    
                if (!ValidImagePath(Service, pConfig->lpBinaryPathName, NULL)) {
                    SetServiceImagePath(Service);
                }
    
            
            }

            LocalFree(pConfig);
            pConfig = NULL;
        }
    }

    return hService;                                   
}

BOOL
KnownInputDriver(LPTSTR Service)
{
    int i = 0;

    for ( ; i < NUM_DRIVER_DATA; i++) {
        if (lstrcmpi(Service, DriverData[i].Service) == 0) {
            return TRUE;
        }
    }

    return FALSE;
}

VOID
EnumAndDisableFromDeviceMap(SC_HANDLE hSCManager, LPTSTR Key)
{
    HKEY hMap, hSubKey;                                                     
    DWORD dwIndex = 0, dwType, err, dwValueNameSize, dwDataSize;
    TCHAR szValueName[255], szData[255];

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     szDeviceMap,
                     0,
                     KEY_READ,
                     &hMap) != ERROR_SUCCESS) {
        return;
    }
    
    if (RegOpenKeyEx(hMap, Key, 0, KEY_READ, &hSubKey) != ERROR_SUCCESS) {
        RegCloseKey(hMap);
        return;
    }

    RegCloseKey(hMap);

    do {
        dwValueNameSize = sizeof(szValueName) / sizeof(TCHAR);
        dwDataSize = sizeof(szData);

        err = RegEnumValue(hSubKey,
                           dwIndex++,
                           szValueName,
                           &dwValueNameSize,
                           0,
                           &dwType,
                           (LPBYTE) szData,
                           &dwDataSize);

        if (err == ERROR_SUCCESS) {
            LPTSTR service = _tcsrchr(szData, TEXT('\\'));

            if (service) {
                service++;
                if (!KnownInputDriver(service)) {
                    SetServiceStartValue(service, SERVICE_DISABLED);
                }
            }
        }
    } while (err == ERROR_SUCCESS);

    RegCloseKey(hSubKey);
}

BOOL
InputUpgradeCheck(PCOMPAIBILITYCALLBACK CompatibilityCallback, LPVOID Context)
{
    SC_HANDLE hSCManager, hService;
    BOOL disabled;
    int i;

    LPENUM_SERVICE_STATUS ess = NULL;
    DWORD count, resume;

    CompatCallback = CompatibilityCallback;
    CompatContext = Context;

    hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (hSCManager == NULL) {
        return TRUE;
    }

    for (i = 0; i < NUM_DRIVER_DATA; i++) {
        disabled = FALSE;
        hService = CheckService(hSCManager, DriverData[i].Service, &disabled);
        if (hService) {
            if (disabled && DriverData[i].DisableReplacements) {
                // search and destroy
                EnumAndDisableFromDeviceMap(hSCManager,
                                            DriverData[i].DeviceMapSubKey); 
            }
            CloseServiceHandle(hService); 
        }
    }

    CloseServiceHandle(hSCManager);
    return TRUE;
}

BOOL APIENTRY 
DllMain(HINSTANCE hDll,
        DWORD dwReason, 
        LPVOID lpReserved)
{
    switch (dwReason) {
    case DLL_PROCESS_ATTACH:
        hInstance = hDll;
        break;

    case DLL_PROCESS_DETACH:
        break;

    case DLL_THREAD_DETACH:
        break;

    case DLL_THREAD_ATTACH:
        break;

    default:
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\input\winkey\exe\main.c ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif //  WIN32_LEAN_AND_MEAN

#define INITGUID
#include <stdio.h>
#include <windows.h>
#include <wmium.h>
#include <wmistr.h>
#include <setupapi.h>
#include <regstr.h>
#include <devguid.h>
#include <ntddkbd.h>
#include "winkeycmn.h"

void WinKeyWmiRawDataCallback(PWNODE_HEADER WnodeHeader, ULONG_PTR Context)
{
    PWNODE_SINGLE_INSTANCE wNode;
    LPGUID eventGuid;

    wNode = (PWNODE_SINGLE_INSTANCE)WnodeHeader;
    eventGuid = &WnodeHeader->Guid;	

    if (IsEqualGUID(eventGuid, &GUID_WMI_WINKEY_RAW_DATA)) {
        PKEYBOARD_INPUT_DATA pPackets;
        ULONG numPackets, i;
         
        numPackets = wNode->SizeDataBlock / sizeof(KEYBOARD_INPUT_DATA);
        pPackets = (PKEYBOARD_INPUT_DATA) (((PBYTE) wNode) + wNode->DataBlockOffset);

        for (i = 0; i < numPackets; i++) {
            printf("code %04x, flags %04x (",
                   (ULONG) pPackets[i].MakeCode, (ULONG) pPackets[i].Flags);

            if (pPackets[i].Flags & KEY_BREAK) {
                printf("break");
            }
            else {
                printf("make");
            }

            if (pPackets[i].Flags & KEY_E0) {
                printf(", E0");
            }
            else if (pPackets[i].Flags & KEY_E1) {
                printf(", E1");
            }

            printf(")\n");
        }
    }
}

BOOL g_quit = FALSE;

BOOL WINAPI CtrlHandler(DWORD dwCtrlType) 
{
    switch (dwCtrlType) {
    case CTRL_C_EVENT:
    case CTRL_BREAK_EVENT:
    case CTRL_CLOSE_EVENT:
        printf("received ctrl event %d\n", dwCtrlType);
        g_quit = TRUE;
        return TRUE;
    default:
        return FALSE;
    }
}

#define STR_WINKEYD TEXT("winkeyd")

BOOL AddFilter(HKEY ClassKey)
{
    DWORD   dwType, dwSize;
    ULONG   res,
            filterLength,
            length;
    BOOLEAN added = FALSE,
            addFilter;
    TCHAR   szFilter[] = STR_WINKEYD TEXT("\0");
    PTCHAR  szCurrentFilter, szOffset, szUpperFilters;

    filterLength = lstrlen(szFilter);

    dwSize = 0;
    res = RegQueryValueEx(ClassKey,
                          REGSTR_VAL_UPPERFILTERS,
                          NULL,
                          &dwType,
                          NULL,
                          &dwSize);

    if (res == ERROR_FILE_NOT_FOUND || dwType != REG_MULTI_SZ) {
        //
        // Value isn't there,
        //
        RegSetValueEx(ClassKey,
                      REGSTR_VAL_UPPERFILTERS,
                      0,
                      REG_MULTI_SZ,
                      (PBYTE) szFilter,
                      (filterLength + 2) * sizeof(TCHAR) );

        added = TRUE;
    }
    else if (res == ERROR_SUCCESS) {

        szUpperFilters = (PTCHAR)
            LocalAlloc(LPTR, dwSize + (filterLength + 1) * sizeof(TCHAR));
